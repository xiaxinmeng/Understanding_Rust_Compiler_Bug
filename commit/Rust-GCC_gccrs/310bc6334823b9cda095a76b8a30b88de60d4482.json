{"sha": "310bc6334823b9cda095a76b8a30b88de60d4482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwYmM2MzM0ODIzYjljZGEwOTVhNzZiOGEzMGI4OGRlNjBkNDQ4Mg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-07-18T22:03:39Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-07-18T22:03:39Z"}, "message": "ipa-prop.h: Include alloc-pool.h, all sorts of updates to general comments.\n\n2011-07-18  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h: Include alloc-pool.h, all sorts of updates to general\n\tcomments.\n\t(ipcp_values_pool): Declare.\n\t(ipcp_sources_pool): Likewise.\n\t(ipcp_lattice): Changed to forward declaration.\n\t(ipa_param_descriptor): Removed fields ipcp_lattice, types and\n\tcannot_devirtualize.\n\t(ipa_node_params): New fields descriptors, lattices, known_vals,\n\tclone_for_all_contexts and node dead, removed fields params and\n\tcount_scale.\n\t(ipa_set_param_count): Removed.\n\t(ipa_get_param_count): Made to work with descriptors vector.\n\t(ipa_get_param): Updated.\n\t(ipa_param_cannot_devirtualize_p): Removed.\n\t(ipa_param_types_vec_empty): Likewise.\n\t(ipa_set_param_used): New function.\n\t(ipa_get_param_used): Updated to use descriptors vector.\n\t(ipa_func_list): Removed.\n\t(ipa_init_func_list): Removed declaration.\n\t(ipa_push_func_to_list_1): Likewise.\n\t(ipa_pop_func_from_list): Likewise.\n\t(ipa_push_func_to_list): Removed.\n\t(ipa_lattice_from_jfunc): Remove declaration.\n\t(ipa_get_jf_pass_through_result): Declare.\n\t(ipa_get_jf_ancestor_result): Likewise.\n\t(ipa_value_from_jfunc): Likewise.\n\t(ipa_get_lattice): Update.\n\t(ipa_lat_is_single_const): New function.\n\t* ipa-prop.c (ipa_push_func_to_list_1): Removed.\n\t(ipa_init_func_list): Likewise.\n\t(ipa_pop_func_from_list): Likewise.\n\t(ipa_get_param_decl_index): Fix coding style.\n\t(count_formal_params): Removed.\n\t(count_formal_params_1): Renamed to count_formal_params.\n\t(ipa_populate_param_decls): Update to use descriptors vector.\n\t(ipa_initialize_node_params): Likewise.\n\t(visit_ref_for_mod_analysis): Use ipa_set_param_used.\n\t(ipa_analyze_params_uses): Likewise.\n\t(ipa_free_node_params_substructures): Likewise and free also lattices\n\tand known values.\n\t(duplicate_array): Removed.\n\t(ipa_edge_duplication_hook): Add the new edge to the list of edge\n\tclones.\n\t(ipa_node_duplication_hook): Update to use new lattices.\n\t(ipa_free_all_structures_after_ipa_cp): Free alloc pools.\n\t(ipa_free_all_structures_after_iinln): Likewise.\n\t(ipa_write_node_info): Update to use new lattices.\n\t(ipa_read_node_info): Likewise.\n\t(ipa_get_jf_pass_through_result): New function.\n\t(ipa_get_jf_ancestor_result): Likewise.\n\t(ipa_value_from_jfunc): Likewise.\n\t(ipa_cst_from_jfunc): Reimplemented using ipa_value_from_jfunc.\n\t* ipa-cp.c: Reimplemented.\n\t* params.def (PARAM_DEVIRT_TYPE_LIST_SIZE): Removed.\n\t(PARAM_IPA_CP_VALUE_LIST_SIZE): New parameter.\n\t(PARAM_IPA_CP_EVAL_THRESHOLD): Likewise.\n\t* Makefile.in (IPA_PROP_H): Added alloc-pool.h to dependencies.\n\n\t* doc/invoke.texi (devirt-type-list-size): Removed description.\n\t(ipa-cp-value-list-size): Added description.\n\n\t* testsuite/gcc.dg/ipa/ipa-1.c: Updated testcase dump scan.\n\t* testsuite/gcc.dg/ipa/ipa-2.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipa-3.c: Likewise and made functions static.\n\t* testsuite/gcc.dg/ipa/ipa-4.c: Updated testcase dump scan.\n\t* testsuite/gcc.dg/ipa/ipa-5.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipa-7.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipa-8.c: Updated testcase dump scan.\n\t* testsuite/gcc.dg/ipa/ipacost-1.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipacost-2.c: Likewise and increased sizes\n\tof some functions.\n\t* testsuite/gcc.dg/ipa/ipcp-1.c: New test.\n\t* testsuite/gcc.dg/ipa/ipcp-2.c: Likewise.\n\t* testsuite/gcc.dg/tree-ssa/ipa-cp-1.c: Updated testcase.\n\nFrom-SVN: r176424", "tree": {"sha": "59b4fc7375a8af4c9814ac80383950deb2ac1542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59b4fc7375a8af4c9814ac80383950deb2ac1542"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/310bc6334823b9cda095a76b8a30b88de60d4482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310bc6334823b9cda095a76b8a30b88de60d4482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310bc6334823b9cda095a76b8a30b88de60d4482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310bc6334823b9cda095a76b8a30b88de60d4482/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca176e1c3639905d47f812f9c5a9a8ec57d8e6d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca176e1c3639905d47f812f9c5a9a8ec57d8e6d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca176e1c3639905d47f812f9c5a9a8ec57d8e6d6"}], "stats": {"total": 3816, "additions": 2386, "deletions": 1430}, "files": [{"sha": "f114c254423851b5949dbf86a2ea0e9f2a3e0b58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -1,3 +1,65 @@\n+2011-07-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h: Include alloc-pool.h, all sorts of updates to general\n+\tcomments.\n+\t(ipcp_values_pool): Declare.\n+\t(ipcp_sources_pool): Likewise.\n+\t(ipcp_lattice): Changed to forward declaration.\n+\t(ipa_param_descriptor): Removed fields ipcp_lattice, types and\n+\tcannot_devirtualize.\n+\t(ipa_node_params): New fields descriptors, lattices, known_vals,\n+\tclone_for_all_contexts and node dead, removed fields params and\n+\tcount_scale.\n+\t(ipa_set_param_count): Removed.\n+\t(ipa_get_param_count): Made to work with descriptors vector.\n+\t(ipa_get_param): Updated.\n+\t(ipa_param_cannot_devirtualize_p): Removed.\n+\t(ipa_param_types_vec_empty): Likewise.\n+\t(ipa_set_param_used): New function.\n+\t(ipa_get_param_used): Updated to use descriptors vector.\n+\t(ipa_func_list): Removed.\n+\t(ipa_init_func_list): Removed declaration.\n+\t(ipa_push_func_to_list_1): Likewise.\n+\t(ipa_pop_func_from_list): Likewise.\n+\t(ipa_push_func_to_list): Removed.\n+\t(ipa_lattice_from_jfunc): Remove declaration.\n+\t(ipa_get_jf_pass_through_result): Declare.\n+\t(ipa_get_jf_ancestor_result): Likewise.\n+\t(ipa_value_from_jfunc): Likewise.\n+\t(ipa_get_lattice): Update.\n+\t(ipa_lat_is_single_const): New function.\n+\t* ipa-prop.c (ipa_push_func_to_list_1): Removed.\n+\t(ipa_init_func_list): Likewise.\n+\t(ipa_pop_func_from_list): Likewise.\n+\t(ipa_get_param_decl_index): Fix coding style.\n+\t(count_formal_params): Removed.\n+\t(count_formal_params_1): Renamed to count_formal_params.\n+\t(ipa_populate_param_decls): Update to use descriptors vector.\n+\t(ipa_initialize_node_params): Likewise.\n+\t(visit_ref_for_mod_analysis): Use ipa_set_param_used.\n+\t(ipa_analyze_params_uses): Likewise.\n+\t(ipa_free_node_params_substructures): Likewise and free also lattices\n+\tand known values.\n+\t(duplicate_array): Removed.\n+\t(ipa_edge_duplication_hook): Add the new edge to the list of edge\n+\tclones.\n+\t(ipa_node_duplication_hook): Update to use new lattices.\n+\t(ipa_free_all_structures_after_ipa_cp): Free alloc pools.\n+\t(ipa_free_all_structures_after_iinln): Likewise.\n+\t(ipa_write_node_info): Update to use new lattices.\n+\t(ipa_read_node_info): Likewise.\n+\t(ipa_get_jf_pass_through_result): New function.\n+\t(ipa_get_jf_ancestor_result): Likewise.\n+\t(ipa_value_from_jfunc): Likewise.\n+\t(ipa_cst_from_jfunc): Reimplemented using ipa_value_from_jfunc.\n+\t* ipa-cp.c: Reimplemented.\n+\t* params.def (PARAM_DEVIRT_TYPE_LIST_SIZE): Removed.\n+\t(PARAM_IPA_CP_VALUE_LIST_SIZE): New parameter.\n+\t(PARAM_IPA_CP_EVAL_THRESHOLD): Likewise.\n+\t* Makefile.in (IPA_PROP_H): Added alloc-pool.h to dependencies.\n+\t* doc/invoke.texi (devirt-type-list-size): Removed description.\n+\t(ipa-cp-value-list-size): Added description.\n+\n 2011-07-18  Richard Henderson  <rth@redhat.com>\n \n \t* bb-reorder.c (fix_crossing_conditional_branches): Emit all insns"}, {"sha": "cbebc239114318a588808b7b055ddf288ad18fcf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -1006,7 +1006,7 @@ LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n \t\t$(CGRAPH_H) $(VEC_H) vecprim.h $(TREE_H) $(GIMPLE_H) \\\n \t\t$(GCOV_IO_H)\n TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n-IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H)\n+IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H) alloc-pool.h\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "ddad55b303f6ae3214a5418c8a03d3010c794a27", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -9006,11 +9006,11 @@ loop in the loop nest by a given number of iterations.  The strip\n length can be changed using the @option{loop-block-tile-size}\n parameter.  The default value is 51 iterations.\n \n-@item devirt-type-list-size\n-IPA-CP attempts to track all possible types passed to a function's\n-parameter in order to perform devirtualization.\n-@option{devirt-type-list-size} is the maximum number of types it\n-stores per a single formal parameter of a function.\n+@item ipa-cp-value-list-size\n+IPA-CP attempts to track all possible values and types passed to a function's\n+parameter in order to propagate them and perform devirtualization.\n+@option{ipa-cp-value-list-size} is the maximum number of values and types it\n+stores per one formal parameter of a function.\n \n @item lto-partitions\n Specify desired number of partitions produced during WHOPR compilation."}, {"sha": "dc8cf095f6ef3a32d276d70aaaa17734ae555cfe", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2014, "deletions": 1078, "changes": 3092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482"}, {"sha": "def34c3e6a18cc19b507efa44b6d2b4dc680ac4f", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 33, "deletions": 192, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -65,65 +65,6 @@ static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n \n-/* Add cgraph NODE described by INFO to the worklist WL regardless of whether\n-   it is in one or not.  It should almost never be used directly, as opposed to\n-   ipa_push_func_to_list.  */\n-\n-void\n-ipa_push_func_to_list_1 (struct ipa_func_list **wl,\n-\t\t\t struct cgraph_node *node,\n-\t\t\t struct ipa_node_params *info)\n-{\n-  struct ipa_func_list *temp;\n-\n-  info->node_enqueued = 1;\n-  temp = XCNEW (struct ipa_func_list);\n-  temp->node = node;\n-  temp->next = *wl;\n-  *wl = temp;\n-}\n-\n-/* Initialize worklist to contain all functions.  */\n-\n-struct ipa_func_list *\n-ipa_init_func_list (void)\n-{\n-  struct cgraph_node *node;\n-  struct ipa_func_list * wl;\n-\n-  wl = NULL;\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && !node->alias)\n-      {\n-\tstruct ipa_node_params *info = IPA_NODE_REF (node);\n-\t/* Unreachable nodes should have been eliminated before ipcp and\n-\t   inlining.  */\n-\tgcc_assert (node->needed || node->reachable);\n-\tipa_push_func_to_list_1 (&wl, node, info);\n-      }\n-\n-  return wl;\n-}\n-\n-/* Remove a function from the worklist WL and return it.  */\n-\n-struct cgraph_node *\n-ipa_pop_func_from_list (struct ipa_func_list **wl)\n-{\n-  struct ipa_node_params *info;\n-  struct ipa_func_list *first;\n-  struct cgraph_node *node;\n-\n-  first = *wl;\n-  *wl = (*wl)->next;\n-  node = first->node;\n-  free (first);\n-\n-  info = IPA_NODE_REF (node);\n-  info->node_enqueued = 0;\n-  return node;\n-}\n-\n /* Return index of the formal whose tree is PTREE in function which corresponds\n    to INFO.  */\n \n@@ -134,7 +75,7 @@ ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n \n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n-    if (ipa_get_param(info, i) == ptree)\n+    if (ipa_get_param (info, i) == ptree)\n       return i;\n \n   return -1;\n@@ -157,15 +98,16 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   param_num = 0;\n   for (parm = fnargs; parm; parm = DECL_CHAIN (parm))\n     {\n-      info->params[param_num].decl = parm;\n+      VEC_index (ipa_param_descriptor_t,\n+\t\t info->descriptors, param_num)->decl = parm;\n       param_num++;\n     }\n }\n \n /* Return how many formal parameters FNDECL has.  */\n \n static inline int\n-count_formal_params_1 (tree fndecl)\n+count_formal_params (tree fndecl)\n {\n   tree parm;\n   int count = 0;\n@@ -176,19 +118,6 @@ count_formal_params_1 (tree fndecl)\n   return count;\n }\n \n-/* Count number of formal parameters in NOTE. Store the result to the\n-   appropriate field of INFO.  */\n-\n-static void\n-ipa_count_formal_params (struct cgraph_node *node,\n-\t\t\t struct ipa_node_params *info)\n-{\n-  int param_num;\n-\n-  param_num = count_formal_params_1 (node->decl);\n-  ipa_set_param_count (info, param_num);\n-}\n-\n /* Initialize the ipa_node_params structure associated with NODE by counting\n    the function parameters, creating the descriptors and populating their\n    param_decls.  */\n@@ -198,12 +127,17 @@ ipa_initialize_node_params (struct cgraph_node *node)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-  if (!info->params)\n+  if (!info->descriptors)\n     {\n-      ipa_count_formal_params (node, info);\n-      info->params = XCNEWVEC (struct ipa_param_descriptor,\n-\t\t\t\t    ipa_get_param_count (info));\n-      ipa_populate_param_decls (node, info);\n+      int param_count;\n+\n+      param_count = count_formal_params (node->decl);\n+      if (param_count)\n+\t{\n+\t  VEC_safe_grow_cleared (ipa_param_descriptor_t, heap,\n+\t\t\t\t info->descriptors, param_count);\n+\t  ipa_populate_param_decls (node, info);\n+\t}\n     }\n }\n \n@@ -1497,7 +1431,7 @@ visit_ref_for_mod_analysis (gimple stmt ATTRIBUTE_UNUSED,\n     {\n       int index = ipa_get_param_decl_index (info, op);\n       gcc_assert (index >= 0);\n-      info->params[index].used = true;\n+      ipa_set_param_used (info, index, true);\n     }\n \n   return false;\n@@ -1529,7 +1463,7 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n \t the flag during modification analysis.  */\n       if (is_gimple_reg (parm)\n \t  && gimple_default_def (DECL_STRUCT_FUNCTION (node->decl), parm))\n-\tinfo->params[i].used = true;\n+\tipa_set_param_used (info, i, true);\n     }\n \n   func = DECL_STRUCT_FUNCTION (decl);\n@@ -1936,8 +1870,11 @@ ipa_free_all_edge_args (void)\n void\n ipa_free_node_params_substructures (struct ipa_node_params *info)\n {\n-  free (info->params);\n-\n+  VEC_free (ipa_param_descriptor_t, heap, info->descriptors);\n+  free (info->lattices);\n+  /* Lattice values and their sources are deallocated with their alocation\n+     pool.  */\n+  VEC_free (tree, heap, info->known_vals);\n   memset (info, 0, sizeof (*info));\n }\n \n@@ -1980,22 +1917,6 @@ ipa_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   ipa_free_node_params_substructures (IPA_NODE_REF (node));\n }\n \n-/* Helper function to duplicate an array of size N that is at SRC and store a\n-   pointer to it to DST.  Nothing is done if SRC is NULL.  */\n-\n-static void *\n-duplicate_array (void *src, size_t n)\n-{\n-  void *p;\n-\n-  if (!src)\n-    return NULL;\n-\n-  p = xmalloc (n);\n-  memcpy (p, src, n);\n-  return p;\n-}\n-\n static struct ipa_jump_func *\n duplicate_ipa_jump_func_array (const struct ipa_jump_func * src, size_t n)\n {\n@@ -2040,22 +1961,15 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t   ATTRIBUTE_UNUSED void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n-  int param_count, i;\n \n   ipa_check_create_node_params ();\n   old_info = IPA_NODE_REF (src);\n   new_info = IPA_NODE_REF (dst);\n-  param_count = ipa_get_param_count (old_info);\n \n-  ipa_set_param_count (new_info, param_count);\n-  new_info->params = (struct ipa_param_descriptor *)\n-    duplicate_array (old_info->params,\n-\t\t     sizeof (struct ipa_param_descriptor) * param_count);\n-  for (i = 0; i < param_count; i++)\n-    new_info->params[i].types = VEC_copy (tree, heap,\n- \t\t\t\t\t  old_info->params[i].types);\n+  new_info->descriptors = VEC_copy (ipa_param_descriptor_t, heap,\n+\t\t\t\t    old_info->descriptors);\n+  new_info->lattices = NULL;\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n-  new_info->count_scale = old_info->count_scale;\n \n   new_info->called_with_var_arguments = old_info->called_with_var_arguments;\n   new_info->uses_analysis_done = old_info->uses_analysis_done;\n@@ -2127,6 +2041,8 @@ ipa_free_all_structures_after_ipa_cp (void)\n     {\n       ipa_free_all_edge_args ();\n       ipa_free_all_node_params ();\n+      free_alloc_pool (ipcp_sources_pool);\n+      free_alloc_pool (ipcp_values_pool);\n       ipa_unregister_cgraph_hooks ();\n     }\n }\n@@ -2142,6 +2058,10 @@ ipa_free_all_structures_after_iinln (void)\n   ipa_free_all_edge_args ();\n   ipa_free_all_node_params ();\n   ipa_unregister_cgraph_hooks ();\n+  if (ipcp_sources_pool)\n+    free_alloc_pool (ipcp_sources_pool);\n+  if (ipcp_values_pool)\n+    free_alloc_pool (ipcp_values_pool);\n }\n \n /* Print ipa_tree_map data structures of all functions in the\n@@ -2196,7 +2116,7 @@ ipa_get_vector_of_formal_parms (tree fndecl)\n   int count;\n   tree parm;\n \n-  count = count_formal_params_1 (fndecl);\n+  count = count_formal_params (fndecl);\n   args = VEC_alloc (tree, heap, count);\n   for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n     VEC_quick_push (tree, args, parm);\n@@ -2859,7 +2779,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   gcc_assert (!info->node_enqueued);\n   gcc_assert (!info->ipcp_orig_node);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n-    bp_pack_value (&bp, info->params[j].used, 1);\n+    bp_pack_value (&bp, ipa_is_param_used (info, j), 1);\n   lto_output_bitpack (&bp);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -2900,7 +2820,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n     info->uses_analysis_done = true;\n   info->node_enqueued = false;\n   for (k = 0; k < ipa_get_param_count (info); k++)\n-    info->params[k].used = bp_unpack_value (&bp, 1);\n+    ipa_set_param_used (info, k, bp_unpack_value (&bp, 1));\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -3064,82 +2984,3 @@ ipa_update_after_lto_read (void)\n \t}\n }\n \n-/* Given the jump function JFUNC, compute the lattice LAT that describes the\n-   value coming down the callsite. INFO describes the caller node so that\n-   pass-through jump functions can be evaluated.  */\n-\n-void\n-ipa_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n-\t\t\t struct ipa_jump_func *jfunc)\n-{\n-  if (jfunc->type == IPA_JF_CONST)\n-    {\n-      lat->type = IPA_CONST_VALUE;\n-      lat->constant = jfunc->value.constant;\n-    }\n-  else if (jfunc->type == IPA_JF_PASS_THROUGH)\n-    {\n-      struct ipcp_lattice *caller_lat;\n-      tree cst;\n-\n-      caller_lat = ipa_get_lattice (info, jfunc->value.pass_through.formal_id);\n-      lat->type = caller_lat->type;\n-      if (caller_lat->type != IPA_CONST_VALUE)\n-\treturn;\n-      cst = caller_lat->constant;\n-\n-      if (jfunc->value.pass_through.operation != NOP_EXPR)\n-\t{\n-\t  tree restype;\n-\t  if (TREE_CODE_CLASS (jfunc->value.pass_through.operation)\n-\t      == tcc_comparison)\n-\t    restype = boolean_type_node;\n-\t  else\n-\t    restype = TREE_TYPE (cst);\n-\t  cst = fold_binary (jfunc->value.pass_through.operation,\n-\t\t\t     restype, cst, jfunc->value.pass_through.operand);\n-\t}\n-      if (!cst || !is_gimple_ip_invariant (cst))\n-\tlat->type = IPA_BOTTOM;\n-      lat->constant = cst;\n-    }\n-  else if (jfunc->type == IPA_JF_ANCESTOR)\n-    {\n-      struct ipcp_lattice *caller_lat;\n-      tree t;\n-\n-      caller_lat = ipa_get_lattice (info, jfunc->value.ancestor.formal_id);\n-      lat->type = caller_lat->type;\n-      if (caller_lat->type != IPA_CONST_VALUE)\n-\treturn;\n-      if (TREE_CODE (caller_lat->constant) != ADDR_EXPR)\n-\t{\n-\t  /* This can happen when the constant is a NULL pointer.  */\n-\t  lat->type = IPA_BOTTOM;\n-\t  return;\n-\t}\n-      t = TREE_OPERAND (caller_lat->constant, 0);\n-      t = build_ref_for_offset (EXPR_LOCATION (t), t,\n-\t\t\t\tjfunc->value.ancestor.offset,\n-\t\t\t\tjfunc->value.ancestor.type, NULL, false);\n-      lat->constant = build_fold_addr_expr (t);\n-    }\n-  else\n-    lat->type = IPA_BOTTOM;\n-}\n-\n-/* Determine whether JFUNC evaluates to a constant and if so, return it.\n-   Otherwise return NULL. INFO describes the caller node so that pass-through\n-   jump functions can be evaluated.  */\n-\n-tree\n-ipa_cst_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n-{\n-  struct ipcp_lattice lat;\n-\n-  ipa_lattice_from_jfunc (info, &lat, jfunc);\n-  if (lat.type == IPA_CONST_VALUE)\n-    return lat.constant;\n-  else\n-    return NULL_TREE;\n-}"}, {"sha": "994e4ac146d660f1fe646dcb484aef29cd27b79b", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 52, "deletions": 126, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -25,14 +25,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"cgraph.h\"\n #include \"gimple.h\"\n+#include \"alloc-pool.h\"\n \n /* The following definitions and interfaces are used by\n    interprocedural analyses or parameters.  */\n \n /* ipa-prop.c stuff (ipa-cp, indirect inlining):  */\n \n /* A jump function for a callsite represents the values passed as actual\n-   arguments of the callsite. There are three main types of values :\n+   arguments of the callsite.  They were originally proposed in a paper called\n+   \"Interprocedural Constant Propagation\", by David Callahan, Keith D Cooper,\n+   Ken Kennedy, Linda Torczon in Comp86, pg 152-161.  There are three main\n+   types of values :\n \n    Pass-through - the caller's formal parameter is passed as an actual\n                   argument, possibly one simple operation performed on it.\n@@ -41,7 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n    Unknown      - neither of the above.\n \n    IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers, it is a special\n-   constant in this regard.  Other constants are represented with IPA_JF_CONST.\n+   constant in this regard because it is in fact a structure consisting of two\n+   values.  Other constants are represented with IPA_JF_CONST.\n \n    IPA_JF_ANCESTOR is a special pass-through jump function, which means that\n    the result is an address of a part of the object pointed to by the formal\n@@ -130,95 +135,65 @@ struct GTY (()) ipa_jump_func\n   } GTY ((desc (\"%1.type\"))) value;\n };\n \n-/* All formal parameters in the program have a lattice associated with it\n-   computed by the interprocedural stage of IPCP.\n-   There are three main values of the lattice:\n-   IPA_TOP - unknown,\n-   IPA_BOTTOM - variable,\n-   IPA_CONST_VALUE - simple scalar constant,\n-\n-   We also use this type to propagate types accross the call graph for the\n-   purpose of devirtualization.  In that case, IPA_CONST_VALUE denotes a known\n-   type, rather than a constant.  */\n-enum ipa_lattice_type\n-{\n-  IPA_BOTTOM,\n-  IPA_CONST_VALUE,\n-  IPA_TOP\n-};\n+/* Summary describing a single formal parameter.  */\n \n-/* All formal parameters in the program have a cval computed by\n-   the interprocedural stage of IPCP. See enum ipa_lattice_type for\n-   the various types of lattices supported */\n-struct ipcp_lattice\n-{\n-  enum ipa_lattice_type type;\n-  tree constant;\n-};\n-\n-/* Structure describing a single formal parameter.  */\n struct ipa_param_descriptor\n {\n-  /* IPA-CP lattice.  */\n-  struct ipcp_lattice ipcp_lattice;\n   /* PARAM_DECL of this parameter.  */\n   tree decl;\n-  /* Vector of BINFOs of types that this argument might encounter.  NULL\n-     basically means a top value, bottom is marked by the cannot_devirtualize\n-     flag below.*/\n-  VEC (tree, heap) *types;\n   /* The parameter is used.  */\n   unsigned used : 1;\n-  /* Set when parameter type cannot be used for devirtualization.  */\n-  unsigned cannot_devirtualize : 1;\n };\n \n+typedef struct ipa_param_descriptor ipa_param_descriptor_t;\n+DEF_VEC_O (ipa_param_descriptor_t);\n+DEF_VEC_ALLOC_O (ipa_param_descriptor_t, heap);\n+struct ipcp_lattice;\n+\n /* ipa_node_params stores information related to formal parameters of functions\n    and some other information for interprocedural passes that operate on\n    parameters (such as ipa-cp).  */\n+\n struct ipa_node_params\n {\n-  /* Number of formal parameters of this function.  When set to 0, this\n-     function's parameters would not be analyzed by IPA CP.  */\n-  int param_count;\n+  /* Information about individual formal parameters that are gathered when\n+     summaries are generated. */\n+  VEC (ipa_param_descriptor_t, heap) *descriptors;\n+  /* Pointer to an array of structures describing individual formal\n+     parameters.  */\n+  struct ipcp_lattice *lattices;\n+  /* Only for versioned nodes this field would not be NULL,\n+     it points to the node that IPA cp cloned from.  */\n+  struct cgraph_node *ipcp_orig_node;\n+  /* If this node is an ipa-cp clone, these are the known values that describe\n+     what it has been specialized for.  */\n+  VEC (tree, heap) *known_vals;\n   /* Whether this function is called with variable number of actual\n      arguments.  */\n   unsigned called_with_var_arguments : 1;\n+  /* Set when it is possible to create specialized versions of this node.  */\n+  unsigned node_versionable : 1;\n   /* Whether the param uses analysis has already been performed.  */\n   unsigned uses_analysis_done : 1;\n-  /* Whether the function is enqueued in an ipa_func_list.  */\n+  /* Whether the function is enqueued in ipa-cp propagation stack.  */\n   unsigned node_enqueued : 1;\n-  /* Pointer to an array of structures describing individual formal\n-     parameters.  */\n-  struct ipa_param_descriptor *params;\n-  /* Only for versioned nodes this field would not be NULL,\n-     it points to the node that IPA cp cloned from.  */\n-  struct cgraph_node *ipcp_orig_node;\n-  /* Meaningful only for original functions.  Expresses the\n-     ratio between the direct calls and sum of all invocations of\n-     this function (given by profiling info).  It is used to calculate\n-     the profiling information of the original function and the versioned\n-     one.  */\n-  gcov_type count_scale;\n+  /* Whether we should create a specialized version based on values that are\n+     known to be constant in all contexts.  */\n+  unsigned clone_for_all_contexts : 1;\n+  /* Node has been completely replaced by clones and will be removed after\n+     ipa-cp is finished.  */\n+  unsigned node_dead : 1;\n };\n \n /* ipa_node_params access functions.  Please use these to access fields that\n    are or will be shared among various passes.  */\n \n-/* Set the number of formal parameters. */\n-\n-static inline void\n-ipa_set_param_count (struct ipa_node_params *info, int count)\n-{\n-  info->param_count = count;\n-}\n-\n /* Return the number of formal parameters. */\n \n static inline int\n ipa_get_param_count (struct ipa_node_params *info)\n {\n-  return info->param_count;\n+  return VEC_length (ipa_param_descriptor_t, info->descriptors);\n }\n \n /* Return the declaration of Ith formal parameter of the function corresponding\n@@ -228,39 +203,25 @@ ipa_get_param_count (struct ipa_node_params *info)\n static inline tree\n ipa_get_param (struct ipa_node_params *info, int i)\n {\n-  gcc_assert (i >= 0 && i <= info->param_count);\n-  return info->params[i].decl;\n-}\n-\n-/* Return the used flag corresponding to the Ith formal parameter of\n-   the function associated with INFO.  */\n-\n-static inline bool\n-ipa_is_param_used (struct ipa_node_params *info, int i)\n-{\n-  gcc_assert (i >= 0 && i <= info->param_count);\n-  return info->params[i].used;\n+  return VEC_index (ipa_param_descriptor_t, info->descriptors, i)->decl;\n }\n \n-/* Return the cannot_devirtualize flag corresponding to the Ith formal\n-   parameter of the function associated with INFO.  The corresponding function\n-   to set the flag is ipa_set_param_cannot_devirtualize.  */\n+/* Set the used flag corresponding to the Ith formal parameter of the function\n+   associated with INFO to VAL.  */\n \n-static inline bool\n-ipa_param_cannot_devirtualize_p (struct ipa_node_params *info, int i)\n+static inline void\n+ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n {\n-  gcc_assert (i >= 0 && i <= info->param_count);\n-  return info->params[i].cannot_devirtualize;\n+  VEC_index (ipa_param_descriptor_t, info->descriptors, i)->used = val;\n }\n \n-/* Return true iff the vector of possible types of the Ith formal parameter of\n-   the function associated with INFO is empty.  */\n+/* Return the used flag corresponding to the Ith formal parameter of the\n+   function associated with INFO.  */\n \n static inline bool\n-ipa_param_types_vec_empty (struct ipa_node_params *info, int i)\n+ipa_is_param_used (struct ipa_node_params *info, int i)\n {\n-  gcc_assert (i >= 0 && i <= info->param_count);\n-  return info->params[i].types == NULL;\n+  return VEC_index (ipa_param_descriptor_t, info->descriptors, i)->used;\n }\n \n /* Flag this node as having callers with variable number of arguments.  */\n@@ -279,8 +240,6 @@ ipa_is_called_with_var_arguments (struct ipa_node_params *info)\n   return info->called_with_var_arguments;\n }\n \n-\n-\n /* ipa_edge_args stores information related to a callsite and particularly its\n    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */\n typedef struct GTY(()) ipa_edge_args\n@@ -402,33 +361,6 @@ ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)\n \t\t\t\t\t     ipa_edge_args_vector));\n }\n \n-/* A function list element.  It is used to create a temporary worklist used in\n-   the propagation stage of IPCP. (can be used for more IPA optimizations)  */\n-struct ipa_func_list\n-{\n-  struct cgraph_node *node;\n-  struct ipa_func_list *next;\n-};\n-\n-/* ipa_func_list interface.  */\n-struct ipa_func_list *ipa_init_func_list (void);\n-void ipa_push_func_to_list_1 (struct ipa_func_list **, struct cgraph_node *,\n-\t\t\t      struct ipa_node_params *);\n-struct cgraph_node *ipa_pop_func_from_list (struct ipa_func_list **);\n-\n-/* Add cgraph NODE to the worklist WL if it is not already in one.  */\n-\n-static inline void\n-ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *node)\n-{\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n-\n-  if (!info->node_enqueued)\n-    ipa_push_func_to_list_1 (wl, node, info);\n-}\n-\n-void ipa_analyze_node (struct cgraph_node *);\n-\n /* Function formal parameters related computations.  */\n void ipa_initialize_node_params (struct cgraph_node *node);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n@@ -438,12 +370,18 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n \t\t\t\t\t\t    tree);\n \n+/* Functions related to both.  */\n+void ipa_analyze_node (struct cgraph_node *);\n \n /* Debugging interface.  */\n void ipa_print_node_params (FILE *, struct cgraph_node *node);\n void ipa_print_all_params (FILE *);\n void ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node);\n void ipa_print_all_jump_functions (FILE * f);\n+void ipcp_verify_propagated_values (void);\n+\n+extern alloc_pool ipcp_values_pool;\n+extern alloc_pool ipcp_sources_pool;\n \n /* Structure to describe transformations of formal parameters and actual\n    arguments.  Each instance describes one new parameter and they are meant to\n@@ -521,9 +459,6 @@ void ipa_prop_write_jump_functions (cgraph_node_set set);\n void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n-void ipa_lattice_from_jfunc (struct ipa_node_params *info,\n-\t\t\t     struct ipcp_lattice *lat,\n-\t\t\t     struct ipa_jump_func *jfunc);\n tree ipa_cst_from_jfunc (struct ipa_node_params *info,\n \t\t\t struct ipa_jump_func *jfunc);\n \n@@ -532,13 +467,4 @@ tree ipa_cst_from_jfunc (struct ipa_node_params *info,\n tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, tree,\n \t\t\t   gimple_stmt_iterator *, bool);\n \n-/* Return the lattice corresponding to the Ith formal parameter of the function\n-   described by INFO.  */\n-static inline struct ipcp_lattice *\n-ipa_get_lattice (struct ipa_node_params *info, int i)\n-{\n-  gcc_assert (i >= 0 && i <= info->param_count);\n-  return &(info->params[i].ipcp_lattice);\n-}\n-\n #endif /* IPA_PROP_H */"}, {"sha": "60397c15fb13bc6ced1a6e0401cda3e631d9b390", "filename": "gcc/params.def", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -860,12 +860,18 @@ DEFPARAM (PARAM_IPA_SRA_PTR_GROWTH_FACTOR,\n \t  \"a pointer to an aggregate with\",\n \t  2, 0, 0)\n \n-DEFPARAM (PARAM_DEVIRT_TYPE_LIST_SIZE,\n-\t  \"devirt-type-list-size\",\n-\t  \"Maximum size of a type list associated with each parameter for \"\n-\t  \"devirtualization\",\n+DEFPARAM (PARAM_IPA_CP_VALUE_LIST_SIZE,\n+\t  \"ipa-cp-value-list-size\",\n+\t  \"Maximum size of a list of values associated with each parameter for \"\n+\t  \"interprocedural constant propagation\",\n \t  8, 0, 0)\n \n+DEFPARAM (PARAM_IPA_CP_EVAL_THRESHOLD,\n+\t  \"ipa-cp-eval-threshold\",\n+\t  \"Threshold ipa-cp opportunity evaluation that is still considered \"\n+\t  \"beneficial to clone.\",\n+\t  500, 0, 0)\n+\n /* WHOPR partitioning configuration.  */\n \n DEFPARAM (PARAM_LTO_PARTITIONS,"}, {"sha": "7ccdad4a835518fb65796391ede09e95f14129a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -1,3 +1,19 @@\n+2011-07-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/ipa-1.c: Updated testcase dump scan.\n+\t* gcc.dg/ipa/ipa-2.c: Likewise.\n+\t* gcc.dg/ipa/ipa-3.c: Likewise and made functions static.\n+\t* gcc.dg/ipa/ipa-4.c: Updated testcase dump scan.\n+\t* gcc.dg/ipa/ipa-5.c: Likewise.\n+\t* gcc.dg/ipa/ipa-7.c: Likewise.\n+\t* gcc.dg/ipa/ipa-8.c: Updated testcase dump scan.\n+\t* gcc.dg/ipa/ipacost-1.c: Likewise.\n+\t* gcc.dg/ipa/ipacost-2.c: Likewise and increased sizes of some\n+\tfunctions.\n+\t* gcc.dg/ipa/ipcp-1.c: New test.\n+\t* gcc.dg/ipa/ipcp-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/ipa-cp-1.c: Updated testcase.\n+\n 2011-07-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/49675"}, {"sha": "3517b035f1c19c5bfdaf4423104c9df1fbc6c569", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-1.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -24,9 +24,8 @@ int main ()\n }\n \n \n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump \"replacing param b with const 7\" \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */\n \n "}, {"sha": "122a4a0181a3ed2d1e8c67e43b2154c92b9089e3", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-2.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -22,7 +22,6 @@ int main ()\n }\n \n \n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump \"replacing param c with const 3\" \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "e15f084b40074e242cf3d54702d8fe0fe1b6c301", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-3.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-3.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -7,12 +7,12 @@\n \n #include <stdio.h>\n void t(void);\n-int g (double b, double c)\n+static int g (double b, double c)\n {\n   t();\n   return (int)(b+c);\n }\n-int f (double a)\n+static int f (double a)\n {\n   if (a > 0)\n     g (a, 3.1);\n@@ -28,8 +28,9 @@ int main ()\n }\n \n \n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of g\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param b with const 7\" \"cp\"  } } */\n /* { dg-final { scan-ipa-dump \"replacing param c with const 3\" \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "88716dd8f4ccbce07b7f9f3a0a757166523fda46", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-4.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -25,6 +25,6 @@ int main ()\n }\n \n \n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\"  } } */\n /* { dg-final { scan-ipa-dump-times \"replacing param a with const 7\" 1 \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "22d1be89c0e1db1093da08bf760ca0aa27bc35e6", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-5.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -26,8 +26,7 @@ int main ()\n   return 0;\n }\n \n-\n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node\" 2 \"cp\"  } } */\n /* { dg-final { scan-ipa-dump \"replacing param c with const 3\" \"cp\"  } } */\n /* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "c8b510046a1d5b6469e760ddfc5aec86ef4d3340", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-7.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -26,8 +26,8 @@ int main ()\n }\n \n \n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"replacing param a with const 7\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"replacing param . with const 7\" 1 \"cp\" } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */\n \n "}, {"sha": "dcbed13a0ed125fa6dcdc58e9e6cec19dddfee27", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-8.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-8.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -22,8 +22,9 @@ int main ()\n }\n \n \n-/* { dg-final { scan-ipa-dump-times \"versioned function\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of g\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param b with const 7\" \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */\n "}, {"sha": "4fce41e82359f8e4e8f30a69e19044309b0878c4", "filename": "gcc/testsuite/gcc.dg/ipa/ipacost-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-1.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -51,10 +51,10 @@ main()\n   i_can_not_be_propagated_fully2 (array);\n }\n \n-/* { dg-final { scan-ipa-dump-times \"versioned function i_can_be_propagated_fully2\" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"versioned function i_can_be_propagated_fully \" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-not \"versioned function i_can_not_be_propagated_fully2\" \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-not \"versioned function i_can_not_be_propagated_fully \" \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully2\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully/\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"Creating a specialized node of i_can_not_be_propagated_fully2\" \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"Creating a specialized node of i_can_not_be_propagated_fully/\" \"cp\"  } } */\n /* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully \" \"optimized\"  } } */\n /* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully2 \" \"optimized\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "ceb524e00ae8decbf215458c8c86c0e4c2fe300b", "filename": "gcc/testsuite/gcc.dg/ipa/ipacost-2.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -40,8 +40,23 @@ i_can_not_be_propagated_fully (int *a)\n int\n i_can_not_be_propagated_fully2 (int *a)\n {\n+  int i;\n   i_can_not_be_propagated_fully (a);\n+  for (i=0;i<50;i++)\n+  {\n+    t(a[i] + 1);\n+    t(a[i+1] + 1);\n+    t(a[i+2] + 1);\n+    t(a[i+3] + 1);\n+  }\n   i_can_not_be_propagated_fully (a);\n+  for (i=0;i<50;i++)\n+  {\n+    t(a[i] + 2);\n+    t(a[i+1] + 2);\n+    t(a[i+2] + 2);\n+    t(a[i+3] + 2);\n+  }\n   i_can_not_be_propagated_fully (a);\n }\n main()\n@@ -50,15 +65,15 @@ main()\n   i_can_be_propagated_fully2 (array);\n   i_can_be_propagated_fully2 (array);\n \n-  for (i = 0; i < 100; i++)\n+  for (i = 0; i < 7; i++)\n     i_can_not_be_propagated_fully2 (array);\n   i_can_not_be_propagated_fully2 (array);\n }\n \n-/* { dg-final { scan-ipa-dump-times \"versioned function i_can_be_propagated_fully2\" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"versioned function i_can_be_propagated_fully \" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"versioned function i_can_not_be_propagated_fully2\" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"versioned function i_can_not_be_propagated_fully \" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully2\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully/\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"Creating a specialized node of i_can_not_be_propagated_fully2\" \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"Creating a specialized node of i_can_not_be_propagated_fully/\" \"cp\"  } } */\n /* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully \\\\(\" \"optimized\"  } } */\n /* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully2 \\\\(\" \"optimized\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "0f50ff9276adc88d0f4fb7230af51d9ecf384540", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-1.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -0,0 +1,52 @@\n+/* Test that IPA-CP is able to figure out that poth parameters a are constant 7\n+   even though f and h recursively call each other and specialize them\n+   accordinly.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+extern void use_stuff (int);\n+\n+static\n+int g (int b, int c)\n+{\n+  int i;\n+\n+  for (i = 0; i < b; i++)\n+    use_stuff (c);\n+}\n+\n+static void f (int a, int x, int z);\n+\n+static void h (int z, int a)\n+{\n+  use_stuff (z);\n+  f (a, 9, 10);\n+\n+}\n+\n+static void\n+f (int a, int x, int z)\n+{\n+  if (z > 1)\n+    g (a, x);\n+  else\n+    h (5, a);\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    f (7, 8, argc);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+\n+"}, {"sha": "c6dcdf0af522aebb08f0d6f9e85dc9a4499faca8", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-2.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-2.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+extern int get_stuff (int);\n+extern void do_stuff (int);\n+extern void do_stuff2 (int);\n+extern void do_other_stuff (void);\n+extern int get_element (int, int, int);\n+extern int adjust (int, int, int, int);\n+\n+extern int count;\n+\n+int\n+foo (int s, int p)\n+{\n+  int c, r = 0;\n+\n+  for (c = 0 ; c < count; c++)\n+    {\n+      r += get_stuff (s);\n+      /* The following is just something big that can go away.  */\n+      if (p != 0)\n+\t{\n+\t  int a[64][64];\n+\t  int i, j, k;\n+\n+\t  for (i = 0; i < 64; i++)\n+\t    for (j = 0; j < 64; j++)\n+\t      a[i][j] = get_element (p + c, i, j);\n+\n+\t  for (k = 0; k < 4; k++)\n+\t    {\n+\t      r = r / 2;\n+\n+\t      for (i = 1; i < 63; i++)\n+\t\tfor (j = 62; j > 0; j--)\n+\t\t  a[i][j] += adjust (a[i-1][j], a[i][j-1],\n+\t\t\t\t     a[i+1][j], a[i][j+1]);\n+\n+\t      for (i = 4; i < 64; i += 4)\n+\t\tfor (j = 4; j < 64; j += 4)\n+\t\t  r += a[i][j] / 4;\n+\t    }\n+\t}\n+    }\n+  return r;\n+}\n+\n+int\n+bar (int p, int q)\n+{\n+  if (q > 0)\n+    do_stuff (q);\n+  else\n+    do_stuff (-q);\n+\n+  if (q % 2)\n+    do_stuff2 (2 * q);\n+  else\n+    do_stuff2 (2 * (q + 1));\n+\n+  return foo (4, p);\n+}\n+\n+int\n+bah (int p, int q)\n+{\n+  int i, j;\n+\n+  while (q < -20)\n+    q += get_stuff (-q);\n+\n+  for (i = 0; i < 36; i++)\n+    for (j = 0; j < 36; j++)\n+      do_stuff (get_stuff (q * i + 2));\n+\n+  bar (p, q);\n+}\n+\n+int\n+top1 (int q)\n+{\n+  do_other_stuff ();\n+  return bah (0, q);\n+}\n+\n+int\n+top2 (int q)\n+{\n+  do_stuff (200);\n+  do_other_stuff ();\n+  return bah (16, q);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of foo\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"replacing param p with const 0\" 3 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"replacing param s with const 4\" \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "26b433823aceba8706b2e4a2f96b1ab9a04ba2f7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-cp-1.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310bc6334823b9cda095a76b8a30b88de60d4482/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c?ref=310bc6334823b9cda095a76b8a30b88de60d4482", "patch": "@@ -5,9 +5,13 @@\n int\n very_long_function(int a)\n {\n-  return very_long_function (a)/4;\n+  if (a > 0)\n+    return 2 * a + very_long_function (a)/4;\n+  else\n+    return 2 * -a + very_long_function (a)/4;\n }\n-main()\n+\n+blah ()\n {\n   very_long_function (1);\n }"}]}