{"sha": "8926095fe7324b246adcf31dc78297d8963ed38a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkyNjA5NWZlNzMyNGIyNDZhZGNmMzFkYzc4Mjk3ZDg5NjNlZDM4YQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-08T06:08:43Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-08T06:08:43Z"}, "message": "31th Cygnus<->FSF merge.\n\nFrom-SVN: r6996", "tree": {"sha": "1fb3f41281c4d10d1e934c50f6a7221f801fb9a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb3f41281c4d10d1e934c50f6a7221f801fb9a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8926095fe7324b246adcf31dc78297d8963ed38a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926095fe7324b246adcf31dc78297d8963ed38a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8926095fe7324b246adcf31dc78297d8963ed38a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926095fe7324b246adcf31dc78297d8963ed38a/comments", "author": null, "committer": null, "parents": [{"sha": "779c643ac3d2dede46b80d0461019828321fb590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779c643ac3d2dede46b80d0461019828321fb590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779c643ac3d2dede46b80d0461019828321fb590"}], "stats": {"total": 1958, "additions": 1117, "deletions": 841}, "files": [{"sha": "5a1e161c00856ee9f82f07cd9aa9e8cd0419568c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -2658,7 +2658,7 @@ build_scoped_method_call (exp, scopes, name, parms)\n       return error_mark_node;\n     }\n \n-  if (binfo = binfo_or_else (basetype, type))\n+  if ((binfo = binfo_or_else (basetype, type)))\n     {\n       if (binfo == error_mark_node)\n \treturn error_mark_node;\n@@ -2965,13 +2965,14 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n       if (TREE_CODE (basetype) == REFERENCE_TYPE)\n \t{\n-\t  basetype = TYPE_MAIN_VARIANT (TREE_TYPE (basetype));\n+\t  basetype = TREE_TYPE (basetype);\n \t  if (! IS_AGGR_TYPE (basetype))\n \t    goto non_aggr_error;\n \t  /* Call to convert not needed because we are remaining\n \t     within the same type.  */\n-\t  instance_ptr = build1 (NOP_EXPR, TYPE_POINTER_TO (basetype), instance);\n-\t  inst_ptr_basetype = basetype;\n+\t  instance_ptr = build1 (NOP_EXPR, build_pointer_type (basetype),\n+\t\t\t\t instance);\n+\t  inst_ptr_basetype = TYPE_MAIN_VARIANT (basetype);\n \t}\n       else\n \t{\n@@ -3077,7 +3078,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       return error_mark_node;\n     }\n \n-  save_basetype = basetype;\n+  save_basetype = TYPE_MAIN_VARIANT (basetype);\n \n #if 0\n   if (all_virtual == 1\n@@ -3118,8 +3119,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   if (instance)\n     {\n-      constp = TREE_READONLY (instance);\n-      volatilep = TREE_THIS_VOLATILE (instance);\n+      /* TREE_READONLY (instance) fails for references.  */\n+      constp = TYPE_READONLY (TREE_TYPE (TREE_TYPE (instance_ptr)));\n+      volatilep = TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (instance_ptr)));\n       parms = tree_cons (NULL_TREE, instance_ptr, parms);\n     }\n   else\n@@ -3161,9 +3163,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    parms = tree_cons (NULL_TREE, instance_ptr, parms);\n \t}\n     }\n-  parmtypes = tree_cons (NULL_TREE,\n-\t\t\t build_pointer_type (build_type_variant (basetype, constp, volatilep)),\n-\t\t\t parmtypes);\n+\n+  parmtypes = tree_cons (NULL_TREE, TREE_TYPE (instance_ptr), parmtypes);\n+\n   if (last == NULL_TREE)\n     last = parmtypes;\n \n@@ -3253,19 +3255,22 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  if (flags & LOOKUP_GLOBAL)\n \t    {\n \t      tree friend_parms;\n-\t      tree parm = TREE_VALUE (parms);\n+\t      tree parm = instance_ptr;\n \n \t      if (TREE_CODE (TREE_TYPE (parm)) == REFERENCE_TYPE)\n-\t\tfriend_parms = parms;\n+\t\t{\n+\t\t  /* TREE_VALUE (parms) may have been modified by now;\n+                     restore it to its original value. */\n+\t\t  TREE_VALUE (parms) = parm;\n+\t\t  friend_parms = parms;\n+\t\t}\n \t      else if (TREE_CODE (TREE_TYPE (parm)) == POINTER_TYPE)\n \t\t{\n \t\t  tree new_type;\n \t\t  parm = build_indirect_ref (parm, \"friendifying parms (compiler error)\");\n \t\t  new_type = build_reference_type (TREE_TYPE (parm));\n \t\t  /* It is possible that this should go down a layer. */\n-\t\t  new_type = build_type_variant (new_type,\n-\t\t\t\t\t\t TREE_READONLY (parm),\n-\t\t\t\t\t\t TREE_THIS_VOLATILE (parm));\n+\t\t  new_type = build_type_variant (new_type, constp, volatilep);\n \t\t  parm = convert (new_type, parm);\n \t\t  friend_parms = tree_cons (NULL_TREE, parm, TREE_CHAIN (parms));\n \t\t}\n@@ -3330,9 +3335,20 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    basetype_path = TREE_VALUE (basetype_path);\n \t  basetype = BINFO_TYPE (basetype_path);\n \n-\t  /* Cast the instance variable to the appropriate type.  */\n-\t  TREE_VALUE (parms) = convert_force (TYPE_POINTER_TO (basetype),\n-\t\t\t\t\t      instance_ptr);\n+\t  /* Cast the instance variable if necessary.  */\n+\t  if (basetype != TYPE_MAIN_VARIANT\n+\t      (TREE_TYPE (TREE_TYPE (TREE_VALUE (parms)))))\n+\t    {\n+\t      if (basetype == save_basetype)\n+\t\tTREE_VALUE (parms) = instance_ptr;\n+\t      else\n+\t\t{\n+\t\t  tree type = build_pointer_type\n+\t\t    (build_type_variant (basetype, constp, volatilep));\n+\t\t  TREE_VALUE (parms) = convert_force (type, instance_ptr);\n+\t\t}\n+\t    }\n+\n \t  /* FIXME: this is the wrong place to get an error.  Hopefully\n \t     the access-control rewrite will make this change more cleanly.  */\n \t  if (TREE_VALUE (parms) == error_mark_node)\n@@ -3468,12 +3484,18 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t     then all we ever saw were private members.  */\n \t  if (cp - candidates > 1)\n \t    {\n+\t      int n_candidates = cp - candidates;\n+\t      TREE_VALUE (parms) = instance_ptr;\n \t      cp = ideal_candidate (save_basetype, candidates,\n-\t\t\t\t    cp - candidates, parms, len);\n+\t\t\t\t    n_candidates, parms, len);\n \t      if (cp == (struct candidate *)0)\n \t\t{\n-\t\t  cp_error (\"ambiguous type conversion requested for %s `%D'\",\n-\t\t\t    name_kind, name);\n+\t\t  if (flags & LOOKUP_COMPLAIN)\n+\t\t    {\n+\t\t      cp_error (\"call of overloaded %s `%D' is ambiguous\",\n+\t\t\t\tname_kind, name);\n+\t\t      print_n_candidates (candidates, n_candidates);\n+\t\t    }\n \t\t  return error_mark_node;\n \t\t}\n \t      if ((flag_ansi_overloading && (cp->h.code & EVIL_CODE))\n@@ -3483,8 +3505,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  else if ((flag_ansi_overloading && (cp[-1].h.code & EVIL_CODE))\n \t\t   || (!flag_ansi_overloading && cp[-1].evil == 2))\n \t    {\n-\t      cp_error (\"ambiguous type conversion requested for %s `%D'\",\n-\t\t\tname_kind, name);\n+\t      if (flags & LOOKUP_COMPLAIN)\n+\t\tcp_error (\"ambiguous type conversion requested for %s `%D'\",\n+\t\t\t  name_kind, name);\n \t      return error_mark_node;\n \t    }\n \t  else\n@@ -3549,10 +3572,12 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       continue;\n \n     found_and_maybe_warn:\n-      if ((flag_ansi_overloading\n-\t   && (cp->v.ansi_harshness[0].code & CONST_CODE))\n-\t  || (!flag_ansi_overloading\n-\t      && CONST_HARSHNESS (cp->v.old_harshness[0])))\n+      if (((flag_ansi_overloading\n+\t    && (cp->v.ansi_harshness[0].code & CONST_CODE))\n+\t   || (!flag_ansi_overloading\n+\t       && CONST_HARSHNESS (cp->v.old_harshness[0])))\n+\t  /* 12.1p2: Constructors can be called for const objects.  */\n+\t  && ! DECL_CONSTRUCTOR_P (cp->function))\n \t{\n \t  if (flags & LOOKUP_COMPLAIN)\n \t    {"}, {"sha": "20116fe25ade522258c15e0af38cd9b67d6d225c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 92, "deletions": 53, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -371,35 +371,67 @@ tree\n build_vtable_entry (delta, pfn)\n      tree delta, pfn;\n {\n-  extern int flag_huge_objects;\n-  tree elems = tree_cons (NULL_TREE, delta,\n-\t\t\t  tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t     build_tree_list (NULL_TREE, pfn)));\n-  tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n-\n-  /* DELTA is constructed by `size_int', which means it may be an\n-     unsigned quantity on some platforms.  Therefore, we cannot use\n-     `int_fits_type_p', because when DELTA is really negative,\n-     `force_fit_type' will make it look like a very large number.  */\n-\n-  if ((TREE_INT_CST_LOW (TYPE_MAX_VALUE (delta_type_node))\n-       < TREE_INT_CST_LOW (delta))\n-      || (TREE_INT_CST_LOW (delta)\n-\t  < TREE_INT_CST_LOW (TYPE_MIN_VALUE (delta_type_node))))\n-    if (flag_huge_objects)\n-      sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n-    else\n-      sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n+  extern tree abort_fndecl;\n+  if (TREE_CODE (pfn) == ADDR_EXPR)\n+    {\n+      tree fndecl = TREE_OPERAND (pfn, 0);\n+      if (TREE_CODE(fndecl) == FUNCTION_DECL\n+\t  && DECL_ABSTRACT_VIRTUAL_P(fndecl))\n+\t{\n+\t  tree d = copy_node (fndecl);\n+\t  DECL_RTL (d) = DECL_RTL (abort_fndecl);\n+\t  TREE_OPERAND (pfn, 0) = d;\n+\t}\n+    }\n+\n+  if (flag_vtable_thunks)\n+    {\n+      HOST_WIDE_INT idelta = TREE_INT_CST_LOW (delta);\n+      extern tree make_thunk ();\n+      if (idelta)\n+\t{\n+\t  pfn = build1 (ADDR_EXPR, ptr_type_node,\n+\t\t\tmake_thunk (pfn, idelta));\n+\t  TREE_READONLY (pfn) = 1;\n+\t  TREE_CONSTANT (pfn) = 1;\n+\t}\n+#ifdef GATHER_STATISTICS\n+      n_vtable_entries += 1;\n+#endif\n+      return pfn;\n+    }\n+  else\n+    {\n+      extern int flag_huge_objects;\n+      tree elems = tree_cons (NULL_TREE, delta,\n+\t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t build_tree_list (NULL_TREE, pfn)));\n+      tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n+\n+      /* DELTA is constructed by `size_int', which means it may be an\n+\t unsigned quantity on some platforms.  Therefore, we cannot use\n+\t `int_fits_type_p', because when DELTA is really negative,\n+\t `force_fit_type' will make it look like a very large number.  */\n+\n+      if ((TREE_INT_CST_LOW (TYPE_MAX_VALUE (delta_type_node))\n+\t   < TREE_INT_CST_LOW (delta))\n+\t  || (TREE_INT_CST_LOW (delta)\n+\t      < TREE_INT_CST_LOW (TYPE_MIN_VALUE (delta_type_node))))\n+\tif (flag_huge_objects)\n+\t  sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n+\telse\n+\t  sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n \n-  TREE_CONSTANT (entry) = 1;\n-  TREE_STATIC (entry) = 1;\n-  TREE_READONLY (entry) = 1;\n+      TREE_CONSTANT (entry) = 1;\n+      TREE_STATIC (entry) = 1;\n+      TREE_READONLY (entry) = 1;\n \n #ifdef GATHER_STATISTICS\n-  n_vtable_entries += 1;\n+      n_vtable_entries += 1;\n #endif\n \n-  return entry;\n+      return entry;\n+    }\n }\n \n /* Given an object INSTANCE, return an expression which yields the\n@@ -471,7 +503,7 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n \tvtbl = build_indirect_ref (build_vfield_ref (instance, basetype),\n \t\t\t\t   NULL_PTR);\n     }\n-  if (!flag_vtable_hack)\n+  if (!flag_vtable_thunks)\n     assemble_external (vtbl);\n   aref = build_array_ref (vtbl, idx);\n \n@@ -480,12 +512,17 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n   if (!building_cleanup && TREE_CODE (aref) == INDIRECT_REF)\n     TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n \n-  *ptr_to_instptr\n-    = build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n-\t     *ptr_to_instptr,\n-\t     convert (ptrdiff_type_node,\n-\t\t      build_component_ref (aref, delta_identifier, 0, 0)));\n-  return build_component_ref (aref, pfn_identifier, 0, 0);\n+  if (flag_vtable_thunks)\n+    return aref;\n+  else\n+    {\n+      *ptr_to_instptr\n+\t= build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n+\t\t *ptr_to_instptr,\n+\t\t convert (ptrdiff_type_node,\n+\t\t\t  build_component_ref (aref, delta_identifier, 0, 0)));\n+      return build_component_ref (aref, pfn_identifier, 0, 0);\n+    }\n }\n \n /* Set TREE_PUBLIC and/or TREE_EXTERN on the vtable DECL,\n@@ -828,18 +865,14 @@ modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n     DECL_VINDEX (fndecl) = vindex;\n   else\n     {\n-      if (! tree_int_cst_equal (DECL_VINDEX (fndecl), vindex))\n+      if (! tree_int_cst_equal (DECL_VINDEX (fndecl), vindex)\n+\t  && ! doing_hard_virtuals)\n \t{\n-\t  tree elts = CONSTRUCTOR_ELTS (new_entry);\n-\n-\t  if (! doing_hard_virtuals)\n-\t    {\n-\t      pending_hard_virtuals\n-\t\t= tree_cons (fndecl, FNADDR_FROM_VTABLE_ENTRY (new_entry),\n-\t\t\t     pending_hard_virtuals);\n-\t      TREE_TYPE (pending_hard_virtuals) = TREE_OPERAND (base_pfn, 0);\n-\t      return;\n-\t    }\n+\t  pending_hard_virtuals\n+\t    = tree_cons (fndecl, FNADDR_FROM_VTABLE_ENTRY (new_entry),\n+\t\t\t pending_hard_virtuals);\n+\t  TREE_TYPE (pending_hard_virtuals) = TREE_OPERAND (base_pfn, 0);\n+\t  return;\n \t}\n     }\n }\n@@ -972,7 +1005,6 @@ static int\n is_normal (binfo, t)\n      tree t, binfo;\n {\n-  tree binfo2;\n   int i = CLASSTYPE_VFIELD_PARENT (t);\n   if (i != -1)\n     {\n@@ -992,10 +1024,13 @@ modify_other_vtable_entries (t, binfo, fndecl, base_fndecl, pfn)\n      tree t, binfo;\n      tree fndecl, base_fndecl, pfn;\n {\n-  tree vfields, virtuals;\n+  tree virtuals;\n   tree binfos;\n   int i, n_baselinks;\n   unsigned HOST_WIDE_INT n;\n+#if 0\n+  tree vfields;\n+#endif\n   \n   virtuals = BINFO_VIRTUALS (binfo);\n   n = 0;\n@@ -1173,7 +1208,10 @@ modify_vtable_entries (t, fndecl, base_fndecl, pfn)\n \t\t  DECL_ASSEMBLER_NAME(fndecl));\n     }\n #endif\n+#if 0\n+  /* this is wrong, see p4736a.C testcase */\n   DECL_CONTEXT (fndecl) = DECL_CONTEXT (base_fndecl);\n+#endif\n \n   offset = integer_zero_node;\n   if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n@@ -1377,7 +1415,7 @@ add_virtual_function (pending_virtuals, has_virtual, x, t)\n   TREE_CONSTANT (vfn) = 1;\n \n   /* current_class_type may be NULL_TREE in case of error.  */\n-  if (current_class_type)\n+  if (current_class_type && !flag_vtable_thunks)\n     TREE_ADDRESSABLE (x) = CLASSTYPE_VTABLE_NEEDS_WRITING (current_class_type);\n \n   /* If the virtual function is a redefinition of a prior one,\n@@ -1386,7 +1424,7 @@ add_virtual_function (pending_virtuals, has_virtual, x, t)\n      to hold that entry.  */\n   if (DECL_VINDEX (x) == error_mark_node)\n     {\n-      tree entry = build_vtable_entry (integer_zero_node, vfn);\n+      tree entry;\n \n       if (flag_dossier && *has_virtual == 0)\n \t{\n@@ -1416,6 +1454,7 @@ add_virtual_function (pending_virtuals, has_virtual, x, t)\n \tDECL_VINDEX (x) = index;\n       }\n #endif\n+      entry = build_vtable_entry (integer_zero_node, vfn);\n       pending_virtuals = tree_cons (DECL_VINDEX (x), entry, pending_virtuals);\n     }\n   /* Happens if declared twice in class or we're not in a class definition.\n@@ -2041,7 +2080,7 @@ finish_base_struct (t, b, t_binfo)\n \t      if (! TREE_VIA_VIRTUAL (base_base_binfo))\n \t\tTREE_VEC_ELT (base_binfos, j)\n \t\t  = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t\tBINFO_TYPE (base_base_binfo),\n+\t\t\t\tbase_base_binfo,\n \t\t\t\tBINFO_VTABLE (base_base_binfo),\n \t\t\t\tBINFO_VIRTUALS (base_base_binfo),\n \t\t\t\tchain);\n@@ -2773,7 +2812,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   int any_default_members = 0;\n   int const_sans_init = 0;\n   int ref_sans_init = 0;\n-  int do_mem_init = 0;\n   int nonprivate_method = 0;\n   tree t_binfo = TYPE_BINFO (t);\n   tree access_decls = 0;\n@@ -3005,10 +3043,10 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      if (DECL_VINDEX (x)\n \t\t  || (all_virtual == 1 && ! DECL_CONSTRUCTOR_P (x)))\n \t\t{\n-\t\t  pending_virtuals = add_virtual_function (pending_virtuals,\n-\t\t\t\t\t\t\t   &has_virtual, x, t);\n-\t\t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n-\t\t    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n+                  pending_virtuals = add_virtual_function (pending_virtuals,\n+                                                           &has_virtual, x, t);\n+                  if (DECL_ABSTRACT_VIRTUAL_P (x))\n+                    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n \t\t}\n \t      continue;\n \t    }\n@@ -3772,8 +3810,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      if (! SAME_FN (decl, base_fndecl))\n \t\t{\n \t\t  tree base_context = DECL_CLASS_CONTEXT (base_fndecl);\n-\t\t  tree binfo = NULL_TREE, these_virtuals;\n+\t\t  tree binfo = NULL_TREE;\n #if 0\n+\t\t  tree these_virtuals;\n \t\t  unsigned HOST_WIDE_INT i\n \t\t    = (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))\n \t\t       & (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1));"}, {"sha": "3ddb359fcf740734af933adce94d3517902f847c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -90,3 +90,13 @@ DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 2)\n                 TREE_CHAIN      null\n    Other useful fields to be defined later.  */\n DEFTREECODE (UNINSTANTIATED_P_TYPE, \"uninstantiated_p_type\", \"t\", 0)\n+\n+/* A thunk is a stub function.\n+\n+   Thunks are used to implement multiple inheritance:\n+   At run-time, such a thunk subtracts THUNK_DELTA (an int, not a tree)\n+   from the this pointer, and then jumps to DECL_INITIAL\n+   (which is an ADDR_EXPR whose operand is a FUNCTION_DECL).\n+\n+   Other kinds of thunks may be defined later. */\n+DEFTREECODE (THUNK_DECL, \"thunk_decl\", \"d\", 0)"}, {"sha": "e5a10db5b0f521785142fb47a536d96fdac3a7a3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -259,10 +259,10 @@ extern int flag_signed_bitfields;\n \n extern int write_virtuals;\n \n-/* True if we want output of vtables to be controlled by whether\n-   we seen the class's first non-inline virtual function.\n+/* True for more efficient but incompatible (not not fully tested)\n+   vtable implementation (using thunks).\n    0 is old behavior; 1 is new behavior. */\n-extern flag_vtable_hack;\n+extern int flag_vtable_thunks;\n \n /* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n    section of the compiler.  INTERFACE_UNKNOWN nonzero means\n@@ -339,10 +339,12 @@ enum languages { lang_c, lang_cplusplus };\n /* Virtual function addresses can be gotten from a virtual function\n    table entry using this macro.  */\n #define FNADDR_FROM_VTABLE_ENTRY(ENTRY) \\\n-  TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (ENTRY))))\n+  (!flag_vtable_thunks ? \\\n+     TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (ENTRY)))) \\\n+   : TREE_CODE (TREE_OPERAND ((ENTRY), 0)) != THUNK_DECL ? (ENTRY) \\\n+   : DECL_INITIAL (TREE_OPERAND ((ENTRY), 0)))\n #define SET_FNADDR_FROM_VTABLE_ENTRY(ENTRY,VALUE) \\\n   (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (ENTRY)))) = (VALUE))\n-\n #define FUNCTION_ARG_CHAIN(NODE) (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n #define PROMOTES_TO_AGGR_TYPE(NODE,CODE)\t\\\n   (((CODE) == TREE_CODE (NODE)\t\t\t\\\n@@ -924,7 +926,8 @@ struct lang_decl_flags\n   unsigned mutable_flag : 1;\n   unsigned is_default_implementation : 1;\n   unsigned synthesized : 1;\n-  unsigned dummy : 10;\n+  unsigned saved_inline : 1;\n+  unsigned dummy : 9;\n \n   tree access;\n   tree context;\n@@ -986,6 +989,11 @@ struct lang_decl\n    member function.  */\n #define DECL_STATIC_FUNCTION_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.static_function)\n \n+/* Nonzero for FUNCTION_DECL means that this decl is a member function\n+   (static or non-static).  */\n+#define DECL_FUNCTION_MEMBER_P(NODE) \\\n+ (TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE || DECL_STATIC_FUNCTION_P (NODE))\n+\n /* Nonzero for FUNCTION_DECL means that this member function\n    has `this' as const X *const.  */\n #define DECL_CONST_MEMFUNC_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.const_memfunc)\n@@ -1005,8 +1013,9 @@ struct lang_decl\n /* Nonzero if allocated on permanent_obstack.  */\n #define LANG_DECL_PERMANENT(LANGDECL) ((LANGDECL)->decl_flags.permanent_attr)\n \n-/* The _TYPE context in which this _DECL appears.  This field is used\n-   only to compute access information.  */\n+/* The _TYPE context in which this _DECL appears.  This field holds the\n+   class where a virtual function instance is actually defined, and the\n+   lexical scope of a friend function defined in a class body.  */\n #define DECL_CLASS_CONTEXT(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.context)\n \n /* For a FUNCTION_DECL: the chain through which the next method\n@@ -1029,6 +1038,10 @@ struct lang_decl\n    squirreled away.  */\n #define DECL_PENDING_INLINE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->pending_inline_info)\n \n+/* True if on the saved_inlines (see decl2.c) list. */\n+#define DECL_SAVED_INLINE(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->decl_flags.saved_inline)\n+\n /* For a FUNCTION_DECL: if this function was declared inside a signature\n    declaration, this is the corresponding member function pointer that was\n    created for it.  */\n@@ -1057,7 +1070,9 @@ struct lang_decl\n /* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n    should be looked up in a non-standard way.  */\n #define TREE_OVERLOADED(NODE) (TREE_LANG_FLAG_0 (NODE))\n+#if 0\t\t\t\t/* UNUSED */\n #define DECL_OVERLOADED(NODE) (DECL_LANG_FLAG_4 (NODE))\n+#endif\n \n /* Nonzero if this (non-TYPE)_DECL has its virtual attribute set.\n    For a FUNCTION_DECL, this is when the function is a virtual function.\n@@ -1165,8 +1180,8 @@ struct lang_decl\n #define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), delta2_identifier, 0, 0))\n #define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), pfn_identifier, 0, 0))\n \n-/* Nonzero for VAR_DECL node means that `external' was specified in\n-   its declaration.  */\n+/* Nonzero for VAR_DECL and FUNCTION_DECL node means that `external' was\n+   specified in its declaration.  */\n #define DECL_THIS_EXTERN(NODE) (DECL_LANG_FLAG_2(NODE))\n \n /* Nonzero for SAVE_EXPR if used to initialize a PARM_DECL.  */\n@@ -1232,6 +1247,8 @@ struct lang_decl\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n \n+#define THUNK_DELTA(DECL) ((DECL)->decl.frame_size)\n+\n /* ...and for unexpanded-parameterized-type nodes.  */\n #define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))\n #define UPT_PARMS(NODE)         TREE_VALUE(TYPE_VALUES(NODE))\n@@ -1293,6 +1310,7 @@ extern tree void_list_node;\n extern tree void_zero_node;\n extern tree default_function_type;\n extern tree vtable_entry_type;\n+extern tree memptr_type;\n extern tree sigtable_entry_type;\n extern tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n extern tree Type_info_type_node;\n@@ -1790,6 +1808,7 @@ extern void print_binding_stack\t\t\tPROTO((void));\n extern void push_to_top_level\t\t\tPROTO((void));\n extern void pop_from_top_level\t\t\tPROTO((void));\n extern void set_identifier_type_value\t\tPROTO((tree, tree));\n+extern void pop_everything\t\t\tPROTO((void));\n extern tree make_type_decl\t\t\tPROTO((tree, tree));\n extern void pushtag\t\t\t\tPROTO((tree, tree, int));\n extern tree make_anon_name\t\t\tPROTO((void));\n@@ -1823,6 +1842,7 @@ extern void expand_static_init\t\t\tPROTO((tree, tree));\n extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n extern tree grokdeclarator\t\t\t(); /* PROTO((tree, tree, enum decl_context, int, tree)); */\n+extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n extern tree xref_defn_tag\t\t\tPROTO((tree, tree, tree));\n extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree start_enum\t\t\t\tPROTO((tree));\n@@ -1928,7 +1948,6 @@ extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n /* in init.c */\n extern void emit_base_init\t\t\tPROTO((tree, int));\n extern void check_base_init\t\t\tPROTO((tree));\n-extern tree build_virtual_init\t\t\tPROTO((tree, tree, tree));\n extern void init_vtbl_ptrs\t\t\tPROTO((tree, int, int));\n extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n@@ -2000,6 +2019,16 @@ extern void dump_time_statistics\t\tPROTO((void));\n extern void compiler_error_with_decl\t\tPROTO((tree, char *));\n extern void yyerror\t\t\t\tPROTO((char *));\n \n+/* in errfn.c */\n+extern void cp_error\t\t\t\t();\n+extern void cp_error_at\t\t\t\t();\n+extern void cp_warning\t\t\t\t();\n+extern void cp_warning_at\t\t\t();\n+extern void cp_pedwarn\t\t\t\t();\n+extern void cp_pedwarn_at\t\t\t();\n+extern void cp_compiler_error\t\t\t();\n+extern void cp_sprintf\t\t\t\t();\n+\n /* in error.c */\n extern void init_error\t\t\t\tPROTO((void));\n extern char *fndecl_as_string\t\t\tPROTO((tree, tree, int));\n@@ -2059,7 +2088,7 @@ extern void push_memoized_context\t\tPROTO((tree, int));\n extern void pop_memoized_context\t\tPROTO((int));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n-extern enum access_type check_access\tPROTO((tree, tree));\n+extern enum access_type compute_access\t\tPROTO((tree, tree));\n extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n@@ -2071,7 +2100,7 @@ extern tree get_abstract_virtuals\t\tPROTO((tree));\n extern tree get_baselinks\t\t\tPROTO((tree, tree, tree));\n extern tree next_baselink\t\t\tPROTO((tree));\n extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n-extern tree build_vbase_vtables_init\t\tPROTO((tree, tree, tree, tree, int));\n+extern void expand_vbase_vtables_init\t\tPROTO((tree, tree, tree, tree, int));\n extern void clear_search_slots\t\t\tPROTO((tree));\n extern tree get_vbase_types\t\t\tPROTO((tree));\n extern void build_mi_matrix\t\t\tPROTO((tree));\n@@ -2132,6 +2161,7 @@ extern tree virtual_member\t\t\tPROTO((tree, tree));\n extern tree virtual_offset\t\t\tPROTO((tree, tree, tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern int decl_list_length\t\t\tPROTO((tree));\n+extern int count_functions\t\t\tPROTO((tree));\n extern tree decl_value_member\t\t\tPROTO((tree, tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n extern tree get_first_fn\t\t\tPROTO((tree));"}, {"sha": "fbe0d61a8650986962f3912ad5691830a7a45cfd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -285,22 +285,21 @@ build_up_reference (type, arg, flags, checkconst)\n {\n   tree rval, targ;\n   int literal_flag = 0;\n-  tree argtype = TREE_TYPE (arg), basetype = argtype;\n+  tree argtype = TREE_TYPE (arg);\n   tree target_type = TREE_TYPE (type);\n   tree binfo = NULL_TREE;\n \n   my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 187);\n-  if (flags != 0\n+  if ((flags & LOOKUP_PROTECT)\n       && TYPE_MAIN_VARIANT (argtype) != TYPE_MAIN_VARIANT (target_type)\n       && IS_AGGR_TYPE (argtype)\n       && IS_AGGR_TYPE (target_type))\n     {\n       binfo = get_binfo (target_type, argtype, 1);\n-      if ((flags & LOOKUP_PROTECT) && binfo == error_mark_node)\n+      if (binfo == error_mark_node)\n \treturn error_mark_node;\n       if (binfo == NULL_TREE)\n \treturn error_not_base_type (target_type, argtype);\n-      basetype = BINFO_TYPE (binfo);\n     }\n \n   /* Pass along const and volatile down into the type. */\n@@ -619,8 +618,8 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n   register enum tree_code form = TREE_CODE (intype);\n   tree rval = NULL_TREE;\n \n-  if (TREE_CODE(type) == ARRAY_TYPE)\n-    type = build_pointer_type (TREE_TYPE(type));\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    type = build_pointer_type (TREE_TYPE (type));\n   if (form == REFERENCE_TYPE)\n     intype = TREE_TYPE (intype);\n   intype = TYPE_MAIN_VARIANT (intype);\n@@ -639,10 +638,11 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n       /* Section 13.  */\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n-\t  /* Since convert_for_initialization didn't call convert_for_assignment,\n-\t     we have to do this checking here.  FIXME: We should have a common\n-\t     routine between here and convert_for_assignment.  */\n-\t  if (TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE)\n+\t  /* Since convert_for_initialization didn't call\n+\t     convert_for_assignment, we have to do this checking here.\n+\t     FIXME: We should have a common routine between here and\n+\t     convert_for_assignment.  */\n+\t  if (form == REFERENCE_TYPE)\n \t    {\n \t      register tree ttl = TREE_TYPE (reftype);\n \t      register tree ttr = TREE_TYPE (TREE_TYPE (expr));\n@@ -683,37 +683,52 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t then we don't need to convert it to reference type if\n \t it is only being used to initialize DECL which is also\n \t of the same aggregate type.  */\n-      if (form == REFERENCE_TYPE\n-\t  || (decl != NULL_TREE && decl != error_mark_node\n-\t      && IS_AGGR_TYPE (type)\n-\t      && TREE_CODE (expr) == CALL_EXPR\n-\t      && TYPE_MAIN_VARIANT (type) == intype))\n+      if (decl != NULL_TREE && decl != error_mark_node\n+\t  && IS_AGGR_TYPE (type)\n+\t  && TREE_CODE (expr) == CALL_EXPR\n+\t  && TYPE_MAIN_VARIANT (type) == intype)\n \t{\n-\t  if (decl && decl != error_mark_node)\n-\t    {\n-\t      tree e1 = build (INIT_EXPR, void_type_node, decl, expr);\n-\t      tree e2;\n+\t  tree e1 = build (INIT_EXPR, void_type_node, decl, expr);\n+\t  tree e2;\n \n-\t      TREE_SIDE_EFFECTS (e1) = 1;\n-\t      if (form == REFERENCE_TYPE)\n-\t\te2 = build1 (NOP_EXPR, reftype, decl);\n-\t      else\n-\t\t{\n-\t\t  e2 = build_unary_op (ADDR_EXPR, decl, 0);\n-\t\t  TREE_TYPE (e2) = reftype;\n-\t\t  TREE_REFERENCE_EXPR (e2) = 1;\n-\t\t}\n-\t      return build_compound_expr (tree_cons (NULL_TREE, e1,\n-\t\t\t\t\t\t     build_tree_list (NULL_TREE, e2)));\n+\t  TREE_SIDE_EFFECTS (e1) = 1;\n+\t  if (form == REFERENCE_TYPE)\n+\t    e2 = build1 (NOP_EXPR, reftype, decl);\n+\t  else\n+\t    {\n+\t      e2 = build_unary_op (ADDR_EXPR, decl, 0);\n+\t      TREE_TYPE (e2) = reftype;\n+\t      TREE_REFERENCE_EXPR (e2) = 1;\n \t    }\n-\t  expr = copy_node (expr);\n-\t  TREE_TYPE (expr) = reftype;\n-\t  return expr;\n+\t  return build_compound_expr\n+\t    (tree_cons (NULL_TREE, e1, build_tree_list (NULL_TREE, e2)));\n+\t}\n+\n+      else if (form == REFERENCE_TYPE)\n+\t{\n+\t  rval = copy_node (expr);\n+\t  TREE_TYPE (rval) = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n+\t  rval = convert (build_pointer_type (TREE_TYPE (reftype)), rval);\n+\t  TREE_TYPE (rval) = reftype;\n+\t  return rval;\n \t}\n+\n       return build_up_reference (reftype, expr, flags, decl!=NULL_TREE);\n     }\n \n-  if (decl == error_mark_node)\n+  if (decl == NULL_TREE && lvalue_p (expr))\n+    {\n+      /* When casting an lvalue to a reference type, just convert into\n+\t a pointer to the new type and deference it.  This is allowed\n+\t by San Diego WP section 5.2.8 paragraph 9, though perhaps it\n+\t should be done directly (jason).  (int &)ri ---> *(int*)&ri */\n+      rval = build_unary_op (ADDR_EXPR, expr, 0);\n+      if (rval != error_mark_node)\n+\trval = convert_force (build_pointer_type (TREE_TYPE (reftype)), rval);\n+      if (rval != error_mark_node)\n+\tTREE_TYPE (rval) = reftype;\n+    }\n+  else if (decl == error_mark_node || decl == NULL_TREE)\n     {\n       tree rval_as_conversion = NULL_TREE;\n       tree rval_as_ctor = NULL_TREE;\n@@ -798,12 +813,12 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \n   my_friendly_assert (form != OFFSET_TYPE, 189);\n \n-  if ((flags & (LOOKUP_COMPLAIN|LOOKUP_SPECULATIVELY)) == LOOKUP_COMPLAIN)\n-    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n-\n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n \n+  else if (flags & LOOKUP_COMPLAIN)\n+    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n+\n   return error_mark_node;\n }\n \n@@ -1025,14 +1040,13 @@ convert_to_aggr (type, expr, msgp, protect)\n \t    *msgp = \"only private conversions apply\";\n \telse if (saw_protected)\n \t  *msgp = \"only protected conversions apply\";\n+\telse\n+\t  *msgp = \"no appropriate conversion to type `%s'\";\n       }\n     return error_mark_node;\n   }\n   /* NOTREACHED */\n \n- not_found:\n-  if (msgp) *msgp = \"no appropriate conversion to type `%s'\";\n-  return error_mark_node;\n  found:\n   if (access == access_private)\n     if (! can_be_private)\n@@ -1436,7 +1450,7 @@ convert_force (type, expr)\n \n   if (code == REFERENCE_TYPE)\n     return fold (convert_to_reference (0, type, e, NULL_TREE, -1,\n-\t\t\t\t       NULL, -1, 0));\n+\t\t\t\t       NULL, -1, LOOKUP_COMPLAIN));\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n "}, {"sha": "67812169a2e2d68c3515ef68187fe7f49ec222d1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 212, "deletions": 336, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -224,7 +224,7 @@ tree sizet_ftype_string;\n tree int_ftype_cptr_cptr_sizet;\n \n /* C++ extensions */\n-tree vtable_entry_type;\n+tree memptr_type, vtable_entry_type;\n tree delta_type_node;\n tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n tree __t_desc_array_type, __i_desc_array_type, __m_desc_array_type;\n@@ -310,11 +310,6 @@ static tree named_label_uses;\n    in the TREE_PURPOSE slot.  */\n tree static_aggregates;\n \n-/* A list of functions which were declared inline, but later had their\n-   address taken.  Used only for non-virtual member functions, since we can\n-   find other functions easily enough.  */\n-tree pending_addressable_inlines;\n-\n /* A list of overloaded functions which we should forget ever\n    existed, such as functions declared in a function's scope,\n    once we leave that function's scope.  */\n@@ -1682,6 +1677,26 @@ set_nested_typename (decl, classname, name, type)\n     DECL_NESTED_TYPENAME (decl) = name;\n }\n \n+/* Pop off extraneous binding levels left over due to syntax errors.  */\n+void\n+pop_everything ()\n+{\n+#ifdef DEBUG_CP_BINDING_LEVELS\n+  fprintf (stderr, \"XXX entering pop_everything ()\\n\");\n+#endif\n+  while (current_binding_level != global_binding_level\n+\t && ! current_binding_level->pseudo_global)\n+    {\n+      if (class_binding_level)\n+\tpop_nested_class (1);\n+      else\n+\tpoplevel (0, 0, 0);\n+    }\n+#ifdef DEBUG_CP_BINDING_LEVELS\n+  fprintf (stderr, \"XXX leaving pop_everything ()\\n\");\n+#endif\n+}\n+\n #if 0 /* not yet, should get fixed properly later */\n /* Create a TYPE_DECL node with the correct DECL_ASSEMBLER_NAME.\n    Other routines shouldn't use build_decl directly; they'll produce\n@@ -1981,7 +1996,14 @@ decls_match (newdecl, olddecl)\n \n       if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (f1)),\n \t\t     TYPE_MAIN_VARIANT (TREE_TYPE (f2)), 2))\n-\ttypes_match = compparms (p1, p2, 2);\n+\t{\n+\t  if (DECL_LANGUAGE (olddecl) == lang_c\n+\t      && ! strict_prototypes_lang_c\n+\t      && p2 == NULL_TREE)\n+\t    types_match = self_promoting_args_p (p1);\n+\t  else\n+\t    types_match = compparms (p1, p2, 1);\n+\t}\n       else\n \ttypes_match = 0;\n     }\n@@ -2096,42 +2118,7 @@ duplicate_decls (newdecl, olddecl)\n   int new_defines_function;\n   tree previous_c_decl = NULL_TREE;\n \n-  if (TREE_CODE (newdecl) == FUNCTION_DECL && is_overloaded_fn (olddecl))\n-    {\n-      olddecl = get_first_fn (olddecl);\n-\n-      while (olddecl)\n-\t{\n-\t  if (DECL_LANGUAGE (olddecl) == lang_c)\n-\t    previous_c_decl = olddecl;\n-\n-\t  /* Redeclaration.  */\n-\t  if (decls_match (newdecl, olddecl))\n-\t    {\n-\t      types_match = 1;\n-\t      break;\n-\t    }\n-\t  /* Ambiguous overload.  */\n-\t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n-\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 2))\n-\t    break;\n-\n-\t  /* Attempt to define multiple C-binding fns.  */\n-\t  if (previous_c_decl)\n-\t    break;\n-\t  \n-\t  olddecl = DECL_CHAIN (olddecl);\n-\t}\n-      if (!olddecl)\n-\t{\n-\t  /* If we found no match, make this join the other\n-\t     overloaded decls.  */\n-\t  DECL_OVERLOADED (newdecl) = 1;\n-\t  return 1;\n-\t}\n-    }\n-  else\n-    types_match = decls_match (newdecl, olddecl);\n+  types_match = decls_match (newdecl, olddecl);\n \n   if (TREE_CODE (olddecl) != TREE_LIST)\n     olddecl_friend = DECL_LANG_SPECIFIC (olddecl) && DECL_FRIEND_P (olddecl);\n@@ -2149,6 +2136,14 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n     {\n+      if ((TREE_CODE (newdecl) == FUNCTION_DECL\n+\t   && TREE_CODE (olddecl) == TEMPLATE_DECL\n+\t   && ! DECL_TEMPLATE_IS_CLASS (olddecl))\n+\t  || (TREE_CODE (olddecl) == FUNCTION_DECL\n+\t      && TREE_CODE (newdecl) == TEMPLATE_DECL\n+\t      && ! DECL_TEMPLATE_IS_CLASS (newdecl)))\n+\treturn 0;\n+      \n       cp_error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n       if (TREE_CODE (olddecl) == TREE_LIST)\n \tolddecl = TREE_VALUE (olddecl);\n@@ -2167,7 +2162,8 @@ duplicate_decls (newdecl, olddecl)\n     ;\n   else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t   && (DECL_BUILT_IN (olddecl)\n-\t       || DECL_BUILT_IN_NONANSI (olddecl)))\n+\t       || DECL_BUILT_IN_NONANSI (olddecl))\n+\t   && DECL_ASSEMBLER_NAME (newdecl) == DECL_ASSEMBLER_NAME (olddecl))\n     {\n       /* If you declare a built-in or predefined function name as static,\n \t the old definition is overridden,\n@@ -2195,101 +2191,34 @@ duplicate_decls (newdecl, olddecl)\n \t  return 0;\n \t}\n     }\n-  else if (!types_match && previous_c_decl\n-\t   && DECL_LANGUAGE (newdecl) == lang_c)\n-    {\n-      cp_error (\"declaration of C function `%#D' conflicts with\", newdecl);\n-      cp_error_at (\"previous declaration `%#D' here\", previous_c_decl);\n-    }\n-  else if (!types_match && TREE_CODE (newdecl) == TEMPLATE_DECL)\n-    return 0;\n   else if (!types_match)\n     {\n-      tree oldtype = TREE_TYPE (olddecl);\n-      tree newtype = TREE_TYPE (newdecl);\n-      int give_error = 0;\n+      if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n+\treturn 0;\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t{\n+\t  if (DECL_LANGUAGE (newdecl) == lang_c\n+\t      && DECL_LANGUAGE (olddecl) == lang_c)\n+\t    {\n+\t      cp_error (\"declaration of C function `%#D' conflicts with\",\n+\t\t\tnewdecl);\n+\t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n+\t    }\n+\t  \n+\t  return 0;\n+\t}\n \n       /* Already complained about this, so don't do so again.  */\n       if (current_class_type == NULL_TREE\n \t  || IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (newdecl)) != current_class_type)\n \t{\n-\t  give_error = 1;\n-\n \t  /* Since we're doing this before finish_struct can set the\n \t     line number on NEWDECL, we just do a regular error here.  */\n \t  if (DECL_SOURCE_LINE (newdecl) == 0)\n \t    cp_error (\"conflicting types for `%#D'\", newdecl);\n \t  else\n \t    cp_error_at (\"conflicting types for `%#D'\", newdecl);\n-\t}\n-\n-      /* Check for function type mismatch\n-\t involving an empty arglist vs a nonempty one.  */\n-      if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  && comptypes (TREE_TYPE (oldtype),\n-\t\t\tTREE_TYPE (newtype), 1)\n-\t  && ((TYPE_ARG_TYPES (oldtype) == NULL_TREE\n-\t       && DECL_INITIAL (olddecl) == NULL_TREE)\n-\t      || (TYPE_ARG_TYPES (newtype) == NULL_TREE\n-\t\t  && DECL_INITIAL (newdecl) == NULL_TREE)))\n-\t{\n-\t  /* Classify the problem further.  */\n-\t  register tree t = TYPE_ARG_TYPES (oldtype);\n-\n-\t  if (t == NULL_TREE)\n-\t    t = TYPE_ARG_TYPES (newtype);\n-\t  for (; t; t = TREE_CHAIN (t))\n-\t    {\n-\t      register tree type = TREE_VALUE (t);\n-\n-\t      if (TREE_CHAIN (t) == NULL_TREE && type != void_type_node)\n-\t\t{\n-\t\t  give_error = 1;\n-\t\t  error (\"A parameter list with an ellipsis can't match\");\n-\t\t  error (\"an empty parameter name list declaration.\");\n-\t\t  break;\n-\t\t}\n-\n-\t      if (TYPE_MAIN_VARIANT (type) == float_type_node\n-\t\t  || C_PROMOTING_INTEGER_TYPE_P (type))\n-\t\t{\n-\t\t  give_error = 1;\n-\t\t  error (\"An argument type that has a default promotion\");\n-\t\t  error (\"can't match an empty parameter name list declaration.\");\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      if (give_error)\n-\tcp_error_at (\"previous declaration as `%#D'\", olddecl);\n-\n-      /* There is one thing GNU C++ cannot tolerate: a constructor\n-\t which takes the type of object being constructed.\n-\t Farm that case out here.  */\n-      if (TREE_CODE (newdecl) == FUNCTION_DECL\n-\t  && DECL_CONSTRUCTOR_P (newdecl))\n-\t{\n-\t  tree tmp = TREE_CHAIN (TYPE_ARG_TYPES (newtype));\n-\n-\t  if (tmp != NULL_TREE\n-\t      && (TYPE_MAIN_VARIANT (TREE_VALUE (tmp))\n-\t\t  == TYPE_METHOD_BASETYPE (newtype)))\n-\t    {\n-\t      tree parm = TREE_CHAIN (DECL_ARGUMENTS (newdecl));\n-\t      tree argtypes\n-\t\t= hash_tree_chain (build_reference_type (TREE_VALUE (tmp)),\n-\t\t\t\t   TREE_CHAIN (tmp));\n-\n-\t      DECL_ARG_TYPE (parm)\n-\t\t= TREE_TYPE (parm)\n-\t\t  = TYPE_REFERENCE_TO (TREE_VALUE (tmp));\n-\n-\t      TREE_TYPE (newdecl) = newtype\n-\t\t= build_cplus_method_type (TYPE_METHOD_BASETYPE (newtype),\n-\t\t\t\t\t   TREE_TYPE (newtype), argtypes);\n-\t      error (\"constructor cannot take as argument the type being constructed\");\n-\t      SET_IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (newdecl), current_class_type);\n-\t    }\n+\t  cp_error_at (\"previous declaration as `%#D'\", olddecl);\n \t}\n     }\n   else\n@@ -2315,18 +2244,25 @@ duplicate_decls (newdecl, olddecl)\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t       && DECL_LANGUAGE (newdecl) != DECL_LANGUAGE (olddecl))\n-\t/* extern \"C\" int foo ();\n-\t   int foo () { bar (); }\n-\t   is OK.  */\n-\tif (current_lang_stack == current_lang_base)\n-\t  DECL_LANGUAGE (newdecl) = DECL_LANGUAGE (olddecl);\n-\telse\n-\t  {\n-\t    cp_error_at (\"previous declaration of `%#D' with %L linkage\",\n-\t\t\t olddecl, DECL_LANGUAGE (olddecl));\n-\t    cp_error (\"conflicts with new declaration with %L linkage\",\n-\t\t      DECL_LANGUAGE (newdecl));\n-\t  }\n+\t{\n+\t  /* extern \"C\" int foo ();\n+\t     int foo () { bar (); }\n+\t     is OK.  */\n+\t  if (current_lang_stack == current_lang_base)\n+\t    {\n+\t      DECL_LANGUAGE (newdecl) = DECL_LANGUAGE (olddecl);\n+\t      if (TYPE_ARG_TYPES (TREE_TYPE (olddecl)) == NULL_TREE\n+\t\t  && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) == void_list_node)\n+\t\tTREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n+\t    }\n+\t  else\n+\t    {\n+\t      cp_error_at (\"previous declaration of `%#D' with %L linkage\",\n+\t\t\t   olddecl, DECL_LANGUAGE (olddecl));\n+\t      cp_error (\"conflicts with new declaration with %L linkage\",\n+\t\t\tDECL_LANGUAGE (newdecl));\n+\t    }\n+\t}\n \n       /* These bits are logically part of the type.  */\n       if (pedantic\n@@ -2386,10 +2322,6 @@ duplicate_decls (newdecl, olddecl)\n #endif\n     }\n \n-  if (TREE_CODE (olddecl) == TEMPLATE_DECL\n-      && DECL_TEMPLATE_INFO (olddecl)->length)\n-    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n-  \n   /* Special handling ensues if new decl is a function definition.  */\n   new_defines_function = (TREE_CODE (newdecl) == FUNCTION_DECL\n \t\t\t  && DECL_INITIAL (newdecl) != NULL_TREE);\n@@ -2463,8 +2395,13 @@ duplicate_decls (newdecl, olddecl)\n \tTREE_THIS_VOLATILE (olddecl) = 1;\n \n       /* Merge the initialization information.  */\n-      if (DECL_INITIAL (newdecl) == NULL_TREE)\n-\tDECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+      if (DECL_INITIAL (newdecl) == NULL_TREE\n+\t  && DECL_INITIAL (olddecl) != NULL_TREE)\n+\t{\n+\t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+\t  DECL_SOURCE_FILE (newdecl) = DECL_SOURCE_FILE (olddecl);\n+\t  DECL_SOURCE_LINE (newdecl) = DECL_SOURCE_LINE (olddecl);\n+\t}\n       /* Keep the old rtl since we can safely use it, unless it's the\n \t call to abort() used for abstract virtuals.  */\n       if ((DECL_LANG_SPECIFIC (olddecl)\n@@ -2547,7 +2484,7 @@ duplicate_decls (newdecl, olddecl)\n \t    DECL_FRAME_SIZE (newdecl) = DECL_FRAME_SIZE (olddecl);\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n-\t  if (DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl))\n+\t  if ((DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl)))\n \t    /* Previously saved insns go together with\n \t       the function's previous definition.  */\n \t    DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n@@ -2557,6 +2494,15 @@ duplicate_decls (newdecl, olddecl)\n \t}\n     }\n \n+  if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n+    {\n+      if (DECL_TEMPLATE_INFO (olddecl)->length)\n+\tDECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n+      DECL_TEMPLATE_MEMBERS (newdecl) = DECL_TEMPLATE_MEMBERS (olddecl);\n+      DECL_TEMPLATE_INSTANTIATIONS (newdecl)\n+\t= DECL_TEMPLATE_INSTANTIATIONS (olddecl);\n+    }\n+  \n   /* Now preserve various other info from the definition.  */\n   TREE_ADDRESSABLE (newdecl) = TREE_ADDRESSABLE (olddecl);\n   TREE_ASM_WRITTEN (newdecl) = TREE_ASM_WRITTEN (olddecl);\n@@ -2706,7 +2652,10 @@ pushdecl (x)\n \t  file = DECL_SOURCE_FILE (t);\n \t  line = DECL_SOURCE_LINE (t);\n \n-\t  if (TREE_CODE (t) != TREE_CODE (x))\n+\t  if (TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c\n+\t      && is_overloaded_fn (t))\n+\t    /* don't do anything just yet */;\n+\t  else if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n \t      if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (x) == TYPE_DECL)\n \t\t{\n@@ -2723,39 +2672,47 @@ pushdecl (x)\n \t  else if (duplicate_decls (x, t))\n \t    {\n #if 0\n-\t  /* This is turned off until I have time to do it right (bpk).  */\n-\n-\t  /* Also warn if they did a prototype with `static' on it, but\n-\t     then later left the `static' off.  */\n-\t  else if (! TREE_PUBLIC (name) && TREE_PUBLIC (x))\n-\t    {\n-\t      if (DECL_LANG_SPECIFIC (t) && DECL_FRIEND_P (t))\n-\t\treturn t;\n+\t      /* This is turned off until I have time to do it right (bpk).  */\n \n-\t      if (extra_warnings)\n+\t      /* Also warn if they did a prototype with `static' on it, but\n+\t\t then later left the `static' off.  */\n+\t      if (! TREE_PUBLIC (name) && TREE_PUBLIC (x))\n \t\t{\n-\t\t  cp_warning (\"`static' missing from declaration of `%D'\", t);\n-\t\t  warning_with_file_and_line (file, line,\n-\t\t\t\t\t      \"previous declaration of `%s'\",\n-\t\t\t\t\t      decl_as_string (t, 0));\n-\t\t}\n+\t\t  if (DECL_LANG_SPECIFIC (t) && DECL_FRIEND_P (t))\n+\t\t    return t;\n \n-\t      /* Now fix things so it'll do what they expect.  */\n-\t      if (current_function_decl)\n-\t\tTREE_PUBLIC (current_function_decl) = 0;\n-\t    }\n-#endif\n+\t\t  if (extra_warnings)\n+\t\t    {\n+\t\t      cp_warning (\"`static' missing from declaration of `%D'\", t);\n+\t\t      warning_with_file_and_line (file, line,\n+\t\t\t\t\t\t  \"previous declaration of `%s'\",\n+\t\t\t\t\t\t  decl_as_string (t, 0));\n+\t\t    }\n \n+\t\t  /* Now fix things so it'll do what they expect.  */\n+\t\t  if (current_function_decl)\n+\t\t    TREE_PUBLIC (current_function_decl) = 0;\n+\t\t}\n \t      /* Due to interference in memory reclamation (X may be\n \t\t obstack-deallocated at this point), we must guard against\n-\t\t one really special case.  */\n+\t\t one really special case.  [jason: This should be handled\n+\t\t by start_function]  */\n \t      if (current_function_decl == x)\n \t\tcurrent_function_decl = t;\n+#endif\n \t      \n \t      return t;\n \t    }\n \t}\n-      \n+\n+      if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_FUNCTION_MEMBER_P (x))\n+\t{\n+\t  t = push_overloaded_decl (x, 1);\n+\t  if (t != x || DECL_LANGUAGE (x) == lang_c)\n+\t    return t;\n+\t}\n+      else if (TREE_CODE (x) == TEMPLATE_DECL && ! DECL_TEMPLATE_IS_CLASS (x))\n+\treturn push_overloaded_decl (x, 0);\n \n       /* If declaring a type as a typedef, and the type has no known\n \t typedef name, install this TYPE_DECL as its typedef name.  */\n@@ -2819,7 +2776,7 @@ pushdecl (x)\n \t      && !DECL_BUILT_IN (decl))\n \t    {\n \t      cp_pedwarn (\"type mismatch with previous external decl\", x);\n-\t      cp_pedwarn_at (\"previous external decl of `%D'\", decl);\n+\t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n \t    }\n \t}\n \n@@ -3176,8 +3133,6 @@ push_overloaded_decl (decl, forgettable)\n   tree orig_name = DECL_NAME (decl);\n   tree glob = IDENTIFIER_GLOBAL_VALUE (orig_name);\n \n-  DECL_OVERLOADED (decl) = 1;\n-\n   if (forgettable\n       && ! flag_traditional\n       && (glob == NULL_TREE || TREE_PERMANENT (glob) == 1)\n@@ -3187,18 +3142,6 @@ push_overloaded_decl (decl, forgettable)\n \n   if (glob)\n     {\n-      if (DECL_LANGUAGE (decl) == lang_c)\n-\t{\n-\t  tree decls = get_first_fn (glob);\n-\t  while (decls && DECL_LANGUAGE (decls) == lang_cplusplus)\n-\t    decls = DECL_CHAIN (decls);\n-\t  if (decls)\n-\t    {\n-\t      cp_error_at (\"C-language function `%#D'\", decls);\n-\t      cp_error (\"overloaded as `%#D'\", decl);\n-\t    }\n-\t}\n-\n       /* We cache the value of builtin functions as ADDR_EXPRs\n \t in the name space.  Convert it to some kind of _DECL after\n \t remembering what to forget.  */\n@@ -3210,7 +3153,7 @@ push_overloaded_decl (decl, forgettable)\n \t  tree tmp;\n \n \t  for (tmp = get_first_fn (glob); tmp; tmp = DECL_CHAIN (tmp))\n-\t    if (decl == tmp)\n+\t    if (decl == tmp || duplicate_decls (decl, tmp))\n \t      return decl;\n \t}\n       else if (TREE_CODE (glob) == VAR_DECL)\n@@ -3219,40 +3162,26 @@ push_overloaded_decl (decl, forgettable)\n \t  cp_error (\"conflicts with function declaration `%#D'\", decl);\n \t  return error_mark_node;\n \t}\n+      else if (TREE_CODE (glob) == TYPE_DECL)\n+\t{\n+\t  tree t = TREE_TYPE (glob);\n+\t  if (IS_AGGR_TYPE (t) && warn_shadow)\n+\t    cp_warning (\"`%#D' hides constructor for `%#T'\", decl, t);\n+\t}\n       else if (is_overloaded_fn (glob))\n         {\n-          tree name = DECL_ASSEMBLER_NAME (decl);\n           tree tmp;\n \t  \n \t  for (tmp = get_first_fn (glob); tmp; tmp = DECL_CHAIN (tmp))\n \t    {\n-\t      if (TREE_CODE (tmp) == FUNCTION_DECL\n-\t\t  && comptypes (TREE_TYPE (tmp), TREE_TYPE (decl), 2))\n+\t      if (decl == tmp || duplicate_decls (decl, tmp))\n+\t\treturn tmp;\n+\t      if (compparms (TYPE_ARG_TYPES (TREE_TYPE (decl)),\n+\t\t\t     TYPE_ARG_TYPES (TREE_TYPE (tmp)), 2))\n \t\t{\n-\t\t  if (DECL_LANGUAGE (tmp) != DECL_LANGUAGE (decl))\n-\t\t    {\n-\t\t      if (current_lang_stack == current_lang_base)\n-\t\t\t{\n-\t\t\t  DECL_LANGUAGE (decl) = DECL_LANGUAGE (tmp);\n-\t\t\t  return tmp;\n-\t\t\t}\n-\t\t      cp_error_at (\"previous declaration of `%#D' with %L linkage\",\n-\t\t\t\t   tmp, DECL_LANGUAGE (tmp));\n-\t\t      cp_error (\"conflicts with new %L-language declaration\",\n-\t\t\t\t   DECL_LANGUAGE (decl));\n-\t\t    }\n-\t\t  else if (TREE_CODE (tmp) != TEMPLATE_DECL\n-\t\t\t   && DECL_ASSEMBLER_NAME (tmp) != name)\n-\t\t    {\n-\t\t      cp_error (\"new declaration `%#D'\", decl);\n-\t\t      cp_error_at (\"ambiguates old declaration `%#D'\", tmp);\n-\t\t    }\n+\t\t  cp_error (\"new declaration `%#D'\", decl);\n+\t\t  cp_error_at (\"ambiguates old declaration `%#D'\", tmp);\n \t\t}\n-\t      /* If we really have seen this before, then if it ambiguates\n-\t\t something, we've already given an error before.  */\n-\t      if (TREE_CODE (tmp) != TEMPLATE_DECL\n-\t\t  && DECL_ASSEMBLER_NAME (tmp) == name)\n-\t\treturn decl;\n \t    }\n \t}\n     }\n@@ -3335,7 +3264,7 @@ redeclaration_error_message (newdecl, olddecl)\n       /* Because C++ can put things into name space for free,\n \t constructs like \"typedef struct foo { ... } foo\"\n \t would look like an erroneous redeclaration.  */\n-      if (comptypes (newdecl, olddecl, 0))\n+      if (comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 0))\n \treturn 0;\n       else\n \treturn \"redefinition of `%#D'\";\n@@ -3378,15 +3307,12 @@ redeclaration_error_message (newdecl, olddecl)\n       /* If at least one is a reference, it's ok.  */\n       if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n \treturn 0;\n-      /* Reject two definitions.  */\n-      if (DECL_INITIAL (olddecl) != NULL_TREE\n-\t  && DECL_INITIAL (newdecl) != NULL_TREE)\n-\treturn \"redefinition of `%#D'\";\n       /* Now we have two tentative defs, or one tentative and one real def.  */\n       /* Insist that the linkage match.  */\n       if (TREE_PUBLIC (olddecl) != TREE_PUBLIC (newdecl))\n \treturn \"conflicting declarations of `%#D'\";\n-      return 0;\n+      /* Reject two definitions.  */\n+      return \"redefinition of `%#D'\";\n     }\n   else\n     {\n@@ -4114,6 +4040,9 @@ init_decl_processing ()\n   lang_name_cplusplus = get_identifier (\"C++\");\n   lang_name_c = get_identifier (\"C\");\n \n+  if (flag_ansi || pedantic)\n+    strict_prototypes_lang_c = strict_prototypes_lang_cplusplus;\n+\n   /* Initially, C.  */\n   current_lang_name = lang_name_c;\n \n@@ -4418,6 +4347,21 @@ init_decl_processing ()\n   builtin_function (\"__builtin_constant_p\", int_ftype_int,\n \t\t    BUILT_IN_CONSTANT_P, NULL_PTR);\n \n+  builtin_function (\"__builtin_return_address\",\n+\t\t    build_function_type (ptr_type_node, \n+\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t    unsigned_type_node,\n+\t\t\t\t\t\t    endlink)),\n+\t\t    BUILT_IN_RETURN_ADDRESS, NULL_PTR);\n+\n+  builtin_function (\"__builtin_frame_address\",\n+\t\t    build_function_type (ptr_type_node, \n+\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t    unsigned_type_node,\n+\t\t\t\t\t\t    endlink)),\n+\t\t    BUILT_IN_FRAME_ADDRESS, NULL_PTR);\n+\n+\n   builtin_function (\"__builtin_alloca\",\n \t\t    build_function_type (ptr_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n@@ -4596,14 +4540,14 @@ init_decl_processing ()\n       pushdecl (lookup_name (get_identifier (\"__gc_main\"), 0));\n     }\n \n-  /* Simplify life by making a \"vtable_entry_type\".  Give its\n+  /* Simplify life by making a \"memptr_type\".  Give its\n      fields names so that the debugger can use them.  */\n \n-  vtable_entry_type = make_lang_type (RECORD_TYPE);\n+  memptr_type = make_lang_type (RECORD_TYPE);\n   fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier, delta_type_node);\n   fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier, delta_type_node);\n   fields[2] = build_lang_field_decl (FIELD_DECL, pfn_identifier, ptr_type_node);\n-  finish_builtin_type (vtable_entry_type, VTBL_PTR_TYPE, fields, 2,\n+  finish_builtin_type (memptr_type, VTBL_PTR_TYPE, fields, 2,\n \t\t       double_type_node);\n \n   /* Make this part of an invisible union.  */\n@@ -4614,8 +4558,13 @@ init_decl_processing ()\n   DECL_SIZE (fields[3]) = TYPE_SIZE (delta_type_node);\n   TREE_UNSIGNED (fields[3]) = 0;\n   TREE_CHAIN (fields[2]) = fields[3];\n-  vtable_entry_type = build_type_variant (vtable_entry_type, 1, 0);\n-  record_builtin_type (RID_MAX, VTBL_PTR_TYPE, vtable_entry_type);\n+  memptr_type = build_type_variant (memptr_type, 1, 0);\n+  record_builtin_type (RID_MAX, VTBL_PTR_TYPE, memptr_type);\n+\n+  if (flag_vtable_thunks)\n+    vtable_entry_type = ptr_type_node;\n+  else\n+    vtable_entry_type = memptr_type;\n \n #ifdef VTABLE_USES_MASK\n   /* This is primarily for virtual function definition.  We\n@@ -5115,7 +5064,6 @@ start_decl (declarator, declspecs, initialized, raises)\n       DECL_EXTERNAL (d) = (DECL_EXTERNAL (decl)\n \t\t\t   && !(context && !DECL_THIS_EXTERN (decl)));\n       DECL_TEMPLATE_RESULT (d) = decl;\n-      DECL_OVERLOADED (d) = 1;\n       decl = d;\n     }\n \n@@ -5227,25 +5175,7 @@ start_decl (declarator, declspecs, initialized, raises)\n       || TREE_CODE (type) == LANG_TYPE)\n     tem = decl;\n   else\n-    {\n-      tem = pushdecl (decl);\n-      if (is_overloaded_fn (tem))\n-\t{\n-\t  tree tem2;\n-\t  tem = get_first_fn (tem);\n-\t  tem2 = decl_value_member (decl, tem);\n-\t  \n-\t  if (tem2 != NULL_TREE)\n-\t    tem = tem2;\n-\t  else\n-\t    {\n-\t      while (tem && ! decls_match (decl, tem))\n-\t\ttem = DECL_CHAIN (tem);\n-\t      if (tem == NULL_TREE)\n-\t\ttem = decl;\n-\t    }\n-\t}\n-    }\n+    tem = pushdecl (decl);\n \t     \n   /* Tell the back-end to use or not use .common as appropriate.  */\n   DECL_COMMON (tem) = flag_conserve_space;\n@@ -5267,10 +5197,7 @@ start_decl (declarator, declspecs, initialized, raises)\n     }\n #endif\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_OVERLOADED (decl))\n-    /* @@ Also done in start_function.  */\n-    tem = push_overloaded_decl (tem, 1);\n-  else if (TREE_CODE (decl) == TEMPLATE_DECL)\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n       tree result = DECL_TEMPLATE_RESULT (decl);\n       if (DECL_CONTEXT (result) != NULL_TREE)\n@@ -5339,6 +5266,7 @@ start_decl (declarator, declspecs, initialized, raises)\n   return tem;\n }\n \n+#if 0\t\t\t\t/* unused */\n static void\n make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n      tree decl, ctor_call, init;\n@@ -5397,6 +5325,7 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n   if (TREE_STATIC (tmp))\n     preserve_initializer ();\n }\n+#endif\n \n /* Handle initialization of references.\n    These three arguments from from `finish_decl', and have the\n@@ -5559,7 +5488,6 @@ grok_reference_init (decl, type, init, cleanupp)\n   else\n     my_friendly_abort (1);\n \n- done:\n   /* ?? Can this be optimized in some cases to\n      hand back the DECL_INITIAL slot??  */\n   if (TYPE_SIZE (TREE_TYPE (type)))\n@@ -6140,6 +6068,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n+#if 0\n \t  /* C++: Handle overloaded functions with default parameters.  */\n \t  if (DECL_OVERLOADED (decl))\n \t    {\n@@ -6184,6 +6113,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\t}\n \t      DECL_LANG_SPECIFIC (decl) = tmp_lang_decl;\n \t    }\n+#endif\n \t}\n       else if (DECL_EXTERNAL (decl))\n \t;\n@@ -6926,7 +6856,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n   {\n-    tree type, last = NULL_TREE;\n+    tree last = NULL_TREE;\n     register tree decl = declarator;\n     name = NULL;\n \n@@ -8722,10 +8652,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t   && ! funcdef_flag\n \t\t\t   && RIDBIT_NOTSETP (RID_STATIC, specbits)\n \t\t\t   && RIDBIT_NOTSETP (RID_INLINE, specbits)));\n-\t    if (TREE_CODE (type) == METHOD_TYPE)\n-\t      publicp \n-\t\t|= (ctype && CLASSTYPE_INTERFACE_KNOWN (ctype))\n-\t\t  || (!funcdef_flag && RIDBIT_NOTSETP (RID_INLINE, specbits));\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n \t\t\t       raises, friendp ? -1 : 0, publicp);\n@@ -8852,25 +8778,32 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       }\n     else if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n       {\n-\tint was_overloaded = 0;\n \ttree original_name = declarator;\n \tint publicp = 0;\n \n \tif (! declarator)\n \t  return NULL_TREE;\n \n-\tif (RIDBIT_SETP (RID_AUTO, specbits)\n-\t    || RIDBIT_SETP (RID_REGISTER, specbits))\n-\t  error (\"invalid storage class for function `%s'\", name);\n+\tif (RIDBIT_SETP (RID_AUTO, specbits))\n+\t  error (\"storage class `auto' invalid for function `%s'\", name);\n+\telse if (RIDBIT_SETP (RID_REGISTER, specbits))\n+\t  error (\"storage class `register' invalid for function `%s'\", name);\n \n \t/* Function declaration not at top level.\n \t   Storage classes other than `extern' are not allowed\n \t   and `extern' makes no difference.  */\n \tif (current_binding_level != global_binding_level\n-\t    && (RIDBIT_SETP (RID_STATIC, specbits) || RIDBIT_SETP (RID_INLINE, specbits))\n+\t    && ! processing_template_decl\n+\t    && (RIDBIT_SETP (RID_STATIC, specbits)\n+\t\t|| RIDBIT_SETP (RID_INLINE, specbits))\n \t    && pedantic)\n-\t  pedwarn (\"invalid storage class for function `%s'\", name);\n-\n+\t  {\n+\t    if (RIDBIT_SETP (RID_STATIC, specbits))\n+\t      pedwarn (\"storage class `static' invalid for function `%s' declared out of global scope\", name);\n+\t    else\n+\t      pedwarn (\"storage class `inline' invalid for function `%s' declared out of global scope\", name);\n+\t  }\n+\t\n \tif (ctype == NULL_TREE)\n \t  {\n \t    if (virtualp)\n@@ -8887,11 +8820,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t      && IDENTIFIER_POINTER (original_name)[0] == '_'\n \t\t      && IDENTIFIER_POINTER (original_name)[1] == '_'\n \t\t      && strncmp (IDENTIFIER_POINTER (original_name)+2, \"builtin_\", 8) == 0))\n-\t      {\n-\t\t/* Plain overloading: will not be grok'd by grokclassfn.  */\n-\t\tdeclarator = build_decl_overload (dname, TYPE_ARG_TYPES (type), 0);\n-\t\twas_overloaded = 1;\n-\t      }\n+\t      /* Plain overloading: will not be grok'd by grokclassfn.  */\n+\t      declarator = build_decl_overload (dname, TYPE_ARG_TYPES (type), 0);\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE && staticp < 2)\n \t  type = build_cplus_method_type (build_type_variant (ctype, constp, volatilep),\n@@ -8926,8 +8856,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\tcp_error_at (\"cannot declare member function `%D' to have static linkage\", decl);\n \t\tillegal_static = 1;\n \t      }\n-\t    else if (! was_overloaded\n-\t\t     && ! ctype\n+\t    else if (! ctype\n \t\t     && IDENTIFIER_LENGTH (original_name) == 4\n \t\t     && IDENTIFIER_POINTER (original_name)[0] == 'm'\n \t\t     && ! strcmp (IDENTIFIER_POINTER (original_name), \"main\"))\n@@ -8954,8 +8883,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  {\n \t    tree last = tree_last (TYPE_ARG_TYPES (type));\n \n-\t    if (! was_overloaded\n-\t\t&& ! ctype\n+\t    if (! ctype\n \t\t&& ! strcmp (IDENTIFIER_POINTER (original_name), \"main\"))\n \t      error (\"cannot inline function `main'\");\n \t    else if (last && last != void_list_node)\n@@ -8971,8 +8899,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  pedwarn (\"ANSI C++ does not permit `extern inline'\");\n \t      }\n \t  }\n-\tif (was_overloaded)\n-\t  DECL_OVERLOADED (decl) = 1;\n       }\n     else\n       {\n@@ -9012,6 +8938,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     if (RIDBIT_SETP (RID_REGISTER, specbits))\n       DECL_REGISTER (decl) = 1;\n \n+    if (RIDBIT_SETP (RID_EXTERN, specbits))\n+      DECL_THIS_EXTERN (decl) = 1;\n+\n     /* Record constancy and volatility.  */\n \n     if (constp)\n@@ -9753,7 +9682,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n \n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n-  if (t = IDENTIFIER_TYPE_VALUE(name))\n+  if ((t = IDENTIFIER_TYPE_VALUE(name)))\n     {\n        if (TREE_CODE(t) != code) t = NULL_TREE;\n     }\n@@ -10000,7 +9929,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n   \n \t      base_binfo = make_binfo (integer_zero_node, basetype,\n \t\t\t\t  TYPE_BINFO_VTABLE (basetype),\n- \t\t\t\t  TYPE_BINFO_VIRTUALS (basetype), 0);\n+ \t\t\t\t  TYPE_BINFO_VIRTUALS (basetype), NULL_TREE);\n  \n \t      TREE_VEC_ELT (binfos, i) = base_binfo;\n \t      TREE_VIA_PUBLIC (base_binfo) = via_public;\n@@ -10468,7 +10397,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n       if ( !(DECL_VINDEX (decl1)\n \t     && write_virtuals >= 2\n \t     && CLASSTYPE_VTABLE_NEEDS_WRITING (ctype)))\n-\tcurrent_extern_inline = TREE_PUBLIC (decl1) && DECL_INLINE (decl1);\n+\tcurrent_extern_inline = DECL_THIS_EXTERN (decl1) && DECL_INLINE (decl1);\n \n       raises = TYPE_RAISES_EXCEPTIONS (fntype);\n \n@@ -10585,73 +10514,19 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n        defining how to inline.  So set DECL_EXTERNAL in that case.  */\n     DECL_EXTERNAL (decl1) = current_extern_inline;\n \n-  /* Now see if this is the implementation of a declared function.  */\n-  if (ctype == NULL_TREE && current_lang_name == lang_name_cplusplus\n-      && !DECL_CONTEXT (decl1))\n-    {\n-      olddecl = lookup_name_current_level (DECL_NAME (decl1));\n-      if (olddecl && TREE_CODE (olddecl) != FUNCTION_DECL)\n-\tolddecl = NULL_TREE;\n-      if (olddecl && DECL_NAME (decl1) != DECL_NAME (olddecl))\n-\t{\n-\t  /* Collision between user and internal naming scheme.  */\n-\t  olddecl = lookup_name_current_level (DECL_ASSEMBLER_NAME (decl1));\n-\t  if (olddecl == NULL_TREE)\n-\t    olddecl = decl1;\n-\t}\n-      if (olddecl && olddecl != decl1\n-\t  && DECL_NAME (decl1) == DECL_NAME (olddecl))\n-\t{\n-\t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && decls_match (decl1, olddecl))\n-\t    {\n-\t      olddecl = DECL_MAIN_VARIANT (olddecl);\n-\t      /* The following copy is needed to handle forcing a function's\n-\t\t linkage to obey the linkage of the original decl.  */\n-\t      DECL_ASSEMBLER_NAME (decl1) = DECL_ASSEMBLER_NAME (olddecl);\n-\t      DECL_OVERLOADED (decl1) = DECL_OVERLOADED (olddecl);\n-\t      if (! DECL_BUILT_IN (olddecl) && DECL_INITIAL (olddecl))\n-\t\tredeclaration_error_message (decl1, olddecl);\n-\t      if (duplicate_decls (decl1, olddecl))\n-\t\tdecl1 = olddecl;\n-\t      else\n-\t\tolddecl = NULL_TREE;\n-\t    }\n-\t  else\n-\t    olddecl = NULL_TREE;\n-\t}\n-    }\n-\n   /* Record the decl so that the function name is defined.\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n      use the old decl.  */\n \n-  if (olddecl)\n-    current_function_decl = olddecl;\n-  else if (pre_parsed_p == 0)\n+  if (pre_parsed_p == 0)\n     {\n-      current_function_decl = pushdecl (decl1);\n-      if (TREE_CODE (current_function_decl) == TREE_LIST\n-\t  || (DECL_ASSEMBLER_NAME (current_function_decl)\n-\t      != DECL_ASSEMBLER_NAME (decl1)))\n-\t{\n-\t  /* @@ revert to modified original declaration.  */\n-\t  decl1 = DECL_MAIN_VARIANT (decl1);\n-\t  current_function_decl = decl1;\n-\t}\n-      else\n-\t{\n-\t  decl1 = current_function_decl;\n-\t  DECL_MAIN_VARIANT (decl1) = decl1;\n-\t}\n+      current_function_decl = decl1 = pushdecl (decl1);\n+      DECL_MAIN_VARIANT (decl1) = decl1;\n       fntype = TREE_TYPE (decl1);\n     }\n   else\n     current_function_decl = decl1;\n \n-  if (DECL_OVERLOADED (decl1))\n-    decl1 = push_overloaded_decl (decl1, 1);\n-\n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n     {\n       if (TREE_CODE (fntype) == METHOD_TYPE)\n@@ -10956,7 +10831,7 @@ store_return_init (return_id, init)\n     /* Give this error as many times as there are occurrences,\n        so that users can use Emacs compilation buffers to find\n        and fix all such places.  */\n-    error (\"ANSI C++ does not permit named return values\");\n+    pedwarn (\"ANSI C++ does not permit named return values\");\n \n   if (return_id != NULL_TREE)\n     {\n@@ -11266,8 +11141,7 @@ finish_function (lineno, call_poplevel)\n \t tables.  */\n       init_vtbl_ptrs (binfo, 1, 0);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\texpand_expr_stmt (build_vbase_vtables_init (binfo, binfo,\n-\t\t\t\t\t\t    C_C_D, current_class_decl, 0));\n+\texpand_vbase_vtables_init (binfo, binfo, C_C_D, current_class_decl, 0);\n       if (! ok_to_optimize_dtor)\n \t{\n \t  cond = build_binary_op (NE_EXPR,\n@@ -11604,6 +11478,12 @@ finish_function (lineno, call_poplevel)\n       rest_of_compilation (fndecl);\n     }\n \n+  if (DECL_INLINE (fndecl)\n+      && !TREE_ASM_WRITTEN (fndecl) && DECL_FUNCTION_MEMBER_P (fndecl))\n+    {\n+      mark_inline_for_output (fndecl);\n+    }\n+\n   if (ctype && TREE_ASM_WRITTEN (fndecl))\n     note_debug_info_needed (ctype);\n \n@@ -11715,10 +11595,7 @@ start_method (declspecs, declarator, raises)\n       return void_type_node;\n     }\n \n-  /* If we're expanding a template, a function must be explicitly declared\n-     inline if we're to compile it now.  If it isn't, we have to wait to see\n-     whether it's needed, and whether an override exists.  */\n-  if (flag_default_inline && !processing_template_defn)\n+  if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n \n   /* We read in the parameters on the maybepermanent_obstack,\n@@ -11777,7 +11654,6 @@ finish_method (decl)\n {\n   register tree fndecl = decl;\n   tree old_initial;\n-  tree context = DECL_CONTEXT (fndecl);\n \n   register tree link;\n "}, {"sha": "b088179ec7b64f982bde2d445810d7d2d5c29700", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -48,11 +48,6 @@ extern tree pending_statics;\n    in the TREE_PURPOSE slot.  */\n extern tree static_aggregates;\n \n-/* A list of functions which were declared inline, but later had their\n-   address taken.  Used only for non-virtual member functions, since we can\n-   find other functions easily enough.  */\n-extern tree pending_addressable_inlines;\n-\n #ifdef DEBUG_CP_BINDING_LEVELS\n /* Purely for debugging purposes.  */\n extern int debug_bindings_indentation;"}, {"sha": "2177713958c4f6dadd391bfeb03bc3a3eb3a5459", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 98, "deletions": 72, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -47,7 +47,9 @@ tree pending_vtables;\n    an initializer, and then initialized, staticly, outside the class.  */\n tree pending_statics;\n \n-extern tree pending_addressable_inlines;\n+/* A list of functions which were declared inline, but which we\n+   may need to emit outline anyway. */\n+static tree saved_inlines;\n \n /* Used to help generate temporary names which are unique within\n    a function.  Reset to 0 by start_function.  */\n@@ -129,9 +131,12 @@ int warn_implicit = 1;\n \n int warn_ctor_dtor_privacy = 1;\n \n-/* True if we want output of vtables to be controlled by whether\n+/* True if we want to implement vtbvales using \"thunks\".\n+   The default is off now, but will be on later.\n+\n+   Also causes output of vtables to be controlled by whether\n    we seen the class's first non-inline virtual function. */\n-int flag_vtable_hack = 0;\n+int flag_vtable_thunks = 0;\n \n /* Nonzero means give string constants the type `const char *'\n    to get extra warnings from them.  These warnings will be too numerous\n@@ -364,7 +369,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"ansi-overloading\", &flag_ansi_overloading, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n-  {\"vtable-hack\", &flag_vtable_hack, 1},\n+  {\"vtable-thunks\", &flag_vtable_thunks, 1},\n };\n \n /* Decode the string P as a language-specific option.\n@@ -609,6 +614,7 @@ grok_method_quals (ctype, function, quals)\n   return ctype;\n }\n \n+#if 0\t\t\t\t/* Not used. */\n /* This routine replaces cryptic DECL_NAMEs with readable DECL_NAMEs.\n    It leaves DECL_ASSEMBLER_NAMEs with the correct value.  */\n /* This does not yet work with user defined conversion operators\n@@ -625,6 +631,7 @@ substitute_nice_name (decl)\n       DECL_NAME (decl) = get_identifier (n);\n     }\n }\n+#endif\n \n /* Warn when -fexternal-templates is used and #pragma\n    interface/implementation is not used all the times it should be,\n@@ -1071,7 +1078,10 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n   if (doing_vec\n       && TREE_CODE (type) == POINTER_TYPE\n       && !TYPE_HAS_DESTRUCTOR (TREE_TYPE (type)))\n-    doing_vec = 0;\n+    {\n+      doing_vec = 0;\n+      use_global_delete = 1;\n+    }\n \n   if (doing_vec)\n     return build_vec_delete (t, maxindex, elt_size, NULL_TREE,\n@@ -1093,7 +1103,6 @@ check_classfn (ctype, cname, function)\n {\n   tree fn_name = DECL_NAME (function);\n   tree fndecl;\n-  int need_quotes = 0;\n   tree method_vec = CLASSTYPE_METHOD_VEC (ctype);\n   tree *methods = 0;\n   tree *end = 0;\n@@ -1241,12 +1250,14 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n \t}\n       else if (pedantic)\n \t{\n+#if 0\n+\t  /* Already warned in grokdeclarator.  */\n \t  if (DECL_NAME (value))\n \t    pedwarn (\"ANSI C++ forbids initialization of member `%s'\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (value)));\n \t  else\n \t    pedwarn (\"ANSI C++ forbids initialization of fields\");\n-\n+#endif\n \t  init = NULL_TREE;\n \t}\n       else\n@@ -1675,22 +1686,26 @@ grok_function_init (decl, init)\n   /* An initializer for a function tells how this function should\n      be inherited.  */\n   tree type = TREE_TYPE (decl);\n-  extern tree abort_fndecl;\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     cp_error (\"initializer specified for non-member function `%D'\", decl);\n   else if (DECL_VINDEX (decl) == NULL_TREE)\n     cp_error (\"initializer specified for non-virtual method `%D'\", decl);\n   else if (integer_zerop (init))\n     {\n+#if 0\n       /* Mark this function as being \"defined\".  */\n       DECL_INITIAL (decl) = error_mark_node;\n       /* pure virtual destructors must be defined. */\n+      /* pure virtual needs to be defined (as abort) only when put in \n+\t vtbl. For wellformed call, it should be itself. pr4737 */\n       if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)))\n \t{\n+\t  extern tree abort_fndecl;\n \t  /* Give this node rtl from `abort'.  */\n \t  DECL_RTL (decl) = DECL_RTL (abort_fndecl);\n \t}\n+#endif\n       DECL_ABSTRACT_VIRTUAL_P (decl) = 1;\n     }\n   else if (TREE_CODE (init) == OFFSET_REF\n@@ -1791,7 +1806,6 @@ tree\n constructor_name_full (thing)\n      tree thing;\n {\n-  tree t;\n   if (TREE_CODE (thing) == UNINSTANTIATED_P_TYPE)\n     return DECL_NAME (UPT_TEMPLATE (thing));\n   if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n@@ -1898,6 +1912,9 @@ void\n mark_inline_for_output (decl)\n      tree decl;\n {\n+  if (DECL_SAVED_INLINE (decl))\n+    return;\n+  DECL_SAVED_INLINE (decl) = 1;\n   if (DECL_PENDING_INLINE_INFO (decl) != 0\n       && ! DECL_PENDING_INLINE_INFO (decl)->deja_vu)\n     {\n@@ -1917,8 +1934,7 @@ mark_inline_for_output (decl)\n \t}\n       DECL_PENDING_INLINE_INFO (decl) = 0;\n     }\n-  pending_addressable_inlines = perm_tree_cons (NULL_TREE, decl,\n-\t\t\t\t\t\tpending_addressable_inlines);\n+  saved_inlines = perm_tree_cons (NULL_TREE, decl, saved_inlines);\n }\n \n void\n@@ -2275,7 +2291,7 @@ coerce_delete_type (type)\n }\n \f\n static void\n-write_vtable_entries (decl)\n+mark_vtable_entries (decl)\n      tree decl;\n {\n   tree entries = TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)));\n@@ -2287,58 +2303,25 @@ write_vtable_entries (decl)\n     {\n       tree fnaddr = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries));\n       tree fn = TREE_OPERAND (fnaddr, 0);\n-      if (! DECL_EXTERNAL (fn) && ! TREE_ASM_WRITTEN (fn)\n-\t  && DECL_SAVED_INSNS (fn))\n-\t{\n-\t  if (TREE_PUBLIC (DECL_CLASS_CONTEXT (fn)))\n-\t    TREE_PUBLIC (fn) = 1;\n-\t  TREE_ADDRESSABLE (fn) = 1;\n-\t  temporary_allocation ();\n-\t  output_inline_function (fn);\n-\t  permanent_allocation (1);\n-\t}\n-      else\n-\tassemble_external (fn);\n+      TREE_ADDRESSABLE (fn) = 1;\n     }\n }\n \n-/* Note even though prev is never used in here, walk_vtables\n-   expects this to have two arguments, so concede.  */\n-static void\n-finish_vtable_typedecl (prev, vars)\n-     tree prev, vars;\n-{\n-  tree decl = TYPE_BINFO_VTABLE (TREE_TYPE (vars));\n-\n-  /* If we are controlled by `+e2', obey.  */\n-  if (write_virtuals == 2)\n-    {\n-      tree binfo = value_member (DECL_NAME (vars), pending_vtables);\n-      if (binfo)\n-\tTREE_PURPOSE (binfo) = void_type_node;\n-      else\n-\tdecl = NULL_TREE;\n-    }\n-  /* If this type has inline virtual functions, then\n-     write those functions out now.  */\n-  if (decl && write_virtuals >= 0\n-      && ! DECL_EXTERNAL (decl) && (TREE_PUBLIC (decl) || TREE_USED (decl)))\n-    write_vtable_entries (decl);\n-}\n-\n static void\n finish_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n   tree ctype = DECL_CONTEXT (vars);\n-  if (flag_vtable_hack && !CLASSTYPE_INTERFACE_KNOWN (ctype))\n+  if (flag_vtable_thunks && !CLASSTYPE_INTERFACE_KNOWN (ctype))\n     {\n       tree method;\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n \t   method = DECL_NEXT_METHOD (method))\n \t{\n \t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method))\n \t    {\n+\t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n+\t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n \t      TREE_PUBLIC (vars) = 1;\n \t      DECL_EXTERNAL (vars) = DECL_EXTERNAL (method);\n \t      break;\n@@ -2354,15 +2337,32 @@ finish_vtable_vardecl (prev, vars)\n       /* Stuff this virtual function table's size into\n \t `pfn' slot of `the_null_vtable_entry'.  */\n       tree nelts = array_type_nelts (TREE_TYPE (vars));\n-      SET_FNADDR_FROM_VTABLE_ENTRY (the_null_vtable_entry, nelts);\n+      if (flag_vtable_thunks)\n+\tTREE_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (vars))) = nelts;\n+      else\n+\tSET_FNADDR_FROM_VTABLE_ENTRY (the_null_vtable_entry, nelts);\n       /* Kick out the dossier before writing out the vtable.  */\n       if (flag_dossier)\n \trest_of_decl_compilation (TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (vars))))), 0), 0, 1, 1);\n \n       /* Write it out.  */\n-      write_vtable_entries (vars);\n+      mark_vtable_entries (vars);\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n-\tstore_init_value (vars, DECL_INITIAL (vars));\n+\t  store_init_value (vars, DECL_INITIAL (vars));\n+      if (flag_vtable_thunks)\n+\t{\n+\t  tree list = CONSTRUCTOR_ELTS (DECL_INITIAL (vars));\n+\t  for (; list; list = TREE_CHAIN (list))\n+\t    {\n+\t      tree vfunc = TREE_VALUE (list);\n+\t      if (TREE_CODE (vfunc) == ADDR_EXPR)\n+\t\t{\n+\t\t  vfunc = TREE_OPERAND (vfunc, 0);\n+\t\t  if (TREE_CODE (vfunc) == THUNK_DECL)\n+\t\t    emit_thunk (vfunc);\n+\t\t}\n+\t    }\n+\t}\n \n #ifdef DWARF_DEBUGGING_INFO\n       if (write_symbols == DWARF_DEBUG)\n@@ -2394,7 +2394,7 @@ finish_vtable_vardecl (prev, vars)\n \n       rest_of_decl_compilation (vars, 0, 1, 1);\n     }\n-  else if (TREE_USED (vars) && flag_vtable_hack)\n+  else if (TREE_USED (vars) && flag_vtable_thunks)\n     assemble_external (vars);\n   /* We know that PREV must be non-zero here.  */\n   TREE_CHAIN (prev) = TREE_CHAIN (vars);\n@@ -2679,23 +2679,6 @@ finish_file ()\n   parse_time -= this_time - start_time;\n   varconst_time += this_time - start_time;\n \n-  /* Now write out inline functions which had their addresses taken\n-     and which were not declared virtual and which were not declared\n-     `extern inline'.  */\n-  while (pending_addressable_inlines)\n-    {\n-      tree decl = TREE_VALUE (pending_addressable_inlines);\n-      if (! TREE_ASM_WRITTEN (decl)\n-\t  && ! DECL_EXTERNAL (decl)\n-\t  && DECL_SAVED_INSNS (decl))\n-\t{\n-\t  temporary_allocation ();\n-\t  output_inline_function (decl);\n-\t  permanent_allocation (1);\n-\t}\n-      pending_addressable_inlines = TREE_CHAIN (pending_addressable_inlines);\n-    }\n-\n   start_time = get_run_time ();\n \n   /* Now delete from the chain of variables all virtual function tables.\n@@ -2726,7 +2709,38 @@ finish_file ()\n   pushdecl (vars);\n #endif\n \n-  walk_vtables (finish_vtable_typedecl, finish_vtable_vardecl);\n+  walk_vtables ((void (*)())0, finish_vtable_vardecl);\n+\n+  /* Now write out inline functions which had their addresses taken\n+     and which were not declared virtual and which were not declared\n+     `extern inline'.  */\n+  while (saved_inlines)\n+    {\n+      tree decl = TREE_VALUE (saved_inlines);\n+      saved_inlines = TREE_CHAIN (saved_inlines);\n+      if (TREE_ASM_WRITTEN (decl))\n+\tcontinue;\n+      if (DECL_FUNCTION_MEMBER_P (decl) && !TREE_PUBLIC (decl))\n+\t{\n+\t  tree ctype = DECL_CLASS_CONTEXT (decl);\n+\t  if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_EXTERNAL (decl) = CLASSTYPE_INTERFACE_ONLY (ctype);\n+\t    }\n+\t}\n+      if (TREE_PUBLIC (decl) || TREE_ADDRESSABLE (decl))\n+\t{\n+\t  if (DECL_EXTERNAL (decl))\n+\t    assemble_external (decl);\n+\t  else\n+\t    {\t\n+\t      temporary_allocation ();\n+\t      output_inline_function (decl);\n+\t      permanent_allocation (1);\n+\t    }\n+\t}\n+    }\n \n   if (write_virtuals == 2)\n     {\n@@ -2839,8 +2853,11 @@ reparse_decl_as_expr1 (decl)\n     case BIT_NOT_EXPR:\n       return build_x_unary_op (BIT_NOT_EXPR,\n \t\t\t       reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)));\n+\n+    default:\n+      my_friendly_abort (5);\n+      return NULL_TREE;\n     }\n-  my_friendly_abort (5);\n }\n \n /* This is something of the form `int (*a)++' that has turned out to be an\n@@ -2865,6 +2882,8 @@ tree\n finish_decl_parsing (decl)\n      tree decl;\n {\n+  extern int current_class_depth;\n+  \n   switch (TREE_CODE (decl))\n     {\n     case IDENTIFIER_NODE:\n@@ -2878,5 +2897,12 @@ finish_decl_parsing (decl)\n     case BIT_NOT_EXPR:\n       TREE_OPERAND (decl, 0) = finish_decl_parsing (TREE_OPERAND (decl, 0));\n       return decl;\n+    case SCOPE_REF:\n+      push_nested_class (TREE_OPERAND (decl, 0), 3);\n+      TREE_COMPLEXITY (decl) = current_class_depth;\n+      return decl;\n+    default:\n+      my_friendly_abort (5);\n+      return NULL_TREE;\n     }\n }"}, {"sha": "2cf2b87ff2329922b38ecd6fe85c75c303b7f8b6", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -112,7 +112,7 @@ cp_thing (errfn, atarg1, format, arglist)\n       if (*f == 'l')\n \t++f;\n \n-      function = cp_printers[*f];\n+      function = cp_printers[(int)*f];\n \n       if (function)\n \t{"}, {"sha": "781453af0ee05e60d8be929148e4216e3337044e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -92,9 +92,6 @@ init_error ()\n   scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n }\n \n-/* Counter to help build parameter names in case they were omitted.  */\n-static int dummy_name;\n-\n enum pad { none, before, after };\n \n static void\n@@ -505,8 +502,9 @@ ident_fndecl (t)\n   else if (TREE_CODE (n) == TREE_LIST\n \t   && TREE_CODE (TREE_VALUE (n)) == FUNCTION_DECL)\n     return TREE_VALUE (n);\n-  else\n-    my_friendly_abort (66);\n+\n+  my_friendly_abort (66);\n+  return NULL_TREE;\n }\n \n #ifndef NO_DOLLAR_IN_LABEL\n@@ -715,7 +713,6 @@ dump_function_decl (t, v)\n   tree fntype = TREE_TYPE (t);\n   tree parmtypes = TYPE_ARG_TYPES (fntype);\n   tree cname = NULL_TREE;\n-  int spaces = 0;\n \n   /* Friends have DECL_CLASS_CONTEXT set, but not DECL_CONTEXT.  */\n   if (DECL_CONTEXT (t))\n@@ -1335,6 +1332,7 @@ code_as_string (c, v)\n char *\n language_as_string (c, v)\n      enum languages c;\n+     int v;\n {\n   switch (c)\n     {\n@@ -1346,13 +1344,14 @@ language_as_string (c, v)\n \n     default:\n       my_friendly_abort (355);\n+      return 0;\n     }\n }\n \n /* Return the proper printed version of a parameter to a C++ function.  */\n char *\n parm_as_string (p, v)\n-     int p;\n+     int p, v;\n {\n   if (p < 0)\n     return \"`this'\";\n@@ -1364,6 +1363,7 @@ parm_as_string (p, v)\n char *\n op_as_string (p, v)\n      enum tree_code p;\n+     int v;\n {\n   static char buf[] = \"operator                \";\n "}, {"sha": "b59fefe954e008e056fb06b8a19ec0a873fcd102", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -211,6 +211,9 @@ cplus_expand_expr (exp, target, tmode, modifier)\n #endif\n       }\n \n+    case THUNK_DECL:\n+      return DECL_RTL (exp);\n+\n     default:\n       break;\n     }"}, {"sha": "90ff11cc529969ba56a177237267ee8c52e35905", "filename": "gcc/cp/init.c", "status": "modified", "additions": 79, "deletions": 98, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -50,6 +50,7 @@ void expand_aggr_init ();\n static void expand_aggr_init_1 ();\n static void expand_recursive_init_1 ();\n static void expand_recursive_init ();\n+static void expand_virtual_init PROTO((tree, tree, tree));\n tree expand_vec_init ();\n tree build_vec_delete ();\n \n@@ -60,7 +61,9 @@ static tree BIN, BID;\n \n /* Cache the identifier nodes for the two magic field of a new cookie.  */\n static tree nc_nelts_field_id;\n+#if 0\n static tree nc_ptr_2comp_field_id;\n+#endif\n \n static tree minus_one;\n \n@@ -122,7 +125,7 @@ init_vtbl_ptrs (binfo, init_self, can_elide)\n   if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n       tree base_ptr = convert_pointer_to_real (binfo, current_class_decl);\n-      expand_expr_stmt (build_virtual_init (binfo, binfo, base_ptr));\n+      expand_virtual_init (binfo, binfo, base_ptr);\n     }\n }\n \f\n@@ -345,13 +348,12 @@ emit_base_init (t, immediately)\n {\n   extern tree in_charge_identifier;\n \n-  tree member, decl, vbases;\n-  tree init_list, member_init;\n+  tree member, vbases;\n+  tree init_list;\n   int pass, start;\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree fields_to_unmark = NULL_TREE;\n   int have_init_list = 0, from_init_list;\n \n   if (! immediately)\n@@ -600,8 +602,8 @@ emit_base_init (t, immediately)\n   /* Initialize all the virtual function table fields that\n      do come from virtual base classes. */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    expand_expr_stmt (build_vbase_vtables_init (t_binfo, t_binfo,\n-\t\t\t\t\t\tC_C_D, current_class_decl, 0));\n+    expand_vbase_vtables_init (t_binfo, t_binfo,\n+\t\t\t\tC_C_D, current_class_decl, 0);\n   for (vbases = CLASSTYPE_VBASECLASSES (t); vbases; vbases = TREE_CHAIN (vbases))\n     CLEAR_BINFO_BASEINIT_MARKED (vbases);\n \n@@ -610,8 +612,7 @@ emit_base_init (t, immediately)\n   init_vtbl_ptrs (t_binfo, 0, 1);\n \n   if (CLASSTYPE_NEEDS_VIRTUAL_REINIT (t))\n-    expand_expr_stmt (build_virtual_init (TYPE_BINFO (t), t,\n-\t\t\t\t\t  current_class_decl));\n+    expand_virtual_init (TYPE_BINFO (t), t, current_class_decl);\n \n   if (current_member_init_list)\n     {\n@@ -704,8 +705,8 @@ check_base_init (t)\n \n    BINFO is the exact type that DECL is supposed to be.  In\n    multiple inheritance, this might mean \"C's A\" if C : A, B.  */\n-tree\n-build_virtual_init (main_binfo, binfo, decl)\n+static void\n+expand_virtual_init (main_binfo, binfo, decl)\n      tree main_binfo, binfo;\n      tree decl;\n {\n@@ -733,7 +734,6 @@ build_virtual_init (main_binfo, binfo, decl)\n     {\n       tree binfos = TYPE_BINFO_BASETYPES (TREE_TYPE (TREE_TYPE (decl)));\n       int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-      tree result = NULL_TREE;\n \n       for (i = n_baselinks-1; i >= 0; i--)\n \t{\n@@ -751,9 +751,9 @@ build_virtual_init (main_binfo, binfo, decl)\n \t  else\n \t    this_decl = build (PLUS_EXPR, TYPE_POINTER_TO (BINFO_TYPE (base_binfo)),\n \t\t\t       decl, BINFO_OFFSET (base_binfo));\n-\t  result = tree_cons (NULL_TREE, build_virtual_init (main_binfo, base_binfo, this_decl), result);\n+\t  expand_virtual_init (main_binfo, base_binfo, this_decl);\n \t}\n-      return build_compound_expr (result);\n+      return;\n     }\n #endif\n \n@@ -779,11 +779,11 @@ build_virtual_init (main_binfo, binfo, decl)\n   decl = convert_pointer_to_real (vtype_binfo, decl);\n   vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL_PTR), vtype);\n   if (vtbl_ptr == error_mark_node)\n-    return error_mark_node;\n+    return;\n \n   /* Have to convert VTBL since array sizes may be different.  */\n-  return build_modify_expr (vtbl_ptr, NOP_EXPR,\n-\t\t\t    convert (TREE_TYPE (vtbl_ptr), vtbl));\n+  expand_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR,\n+\t\t\t\t       convert (TREE_TYPE (vtbl_ptr), vtbl)));\n }\n \n /* Subroutine of `expand_aggr_vbase_init'.\n@@ -1304,8 +1304,7 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n \t      tree addr = build_unary_op (ADDR_EXPR, exp, 0);\n \t      expand_aggr_vbase_init (binfo, exp, addr, NULL_TREE);\n \n-\t      expand_expr_stmt (build_vbase_vtables_init (binfo, binfo,\n-\t\t\t\t\t\t\t  exp, addr, 1));\n+\t      expand_vbase_vtables_init (binfo, binfo, exp, addr, 1);\n \t    }\n \t  expand_expr_stmt (build_modify_expr (exp, INIT_EXPR, init));\n \t  return;\n@@ -1427,7 +1426,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n {\n   tree type = TREE_TYPE (exp);\n   tree init_type = NULL_TREE;\n-  tree rval;\n \n   my_friendly_assert (init != error_mark_node && type != error_mark_node, 211);\n \n@@ -1716,13 +1714,13 @@ expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this)\n \t      if (TREE_VALUE (init_list))\n \t\t{\n \t\t  /* We have to ensure that the second argment to\n-\t\t     build_virtual_init is in binfo's hierarchy.  */\n-\t\t  expand_expr_stmt (build_virtual_init (binfo,\n-\t\t\t\t\t\t\tget_binfo (TREE_VALUE (init_list), binfo, 0),\n-\t\t\t\t\t\t\taddr));\n+\t\t     expand_virtual_init is in binfo's hierarchy.  */\n+\t\t  expand_virtual_init (binfo,\n+\t\t\t\t      get_binfo (TREE_VALUE (init_list), binfo, 0),\n+\t\t\t\t      addr);\n \t\t  if (TREE_VALUE (init_list) == binfo\n \t\t      && TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n-\t\t    expand_expr_stmt (build_vbase_vtables_init (binfo, binfo, true_exp, addr, 1));\n+\t\t    expand_vbase_vtables_init (binfo,binfo, true_exp, addr, 1);\n \t\t}\n \t    }\n \t  else\n@@ -1771,7 +1769,7 @@ expand_recursive_init (binfo, true_exp, exp, init, init_list, alias_this)\n   if (true_exp == exp && TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n     {\n       expand_aggr_vbase_init (binfo, exp, addr, init_list);\n-      expand_expr_stmt (build_vbase_vtables_init (binfo, binfo, true_exp, addr, 1));\n+      expand_vbase_vtables_init (binfo, binfo, true_exp, addr, 1);\n     }\n   expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this);\n \n@@ -1858,8 +1856,6 @@ tree\n get_type_value (name)\n      tree name;\n {\n-  tree type;\n-\n   if (name == error_mark_node)\n     return NULL_TREE;\n \n@@ -1952,7 +1948,7 @@ build_member_call (cname, name, parmlist)\n     return build_method_call (decl, method_name, parmlist, basetype_path,\n \t\t\t      LOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n   if (TREE_CODE (name) == IDENTIFIER_NODE\n-      && (t = lookup_field (TYPE_BINFO (type), name, 1, 0)))\n+      && ((t = lookup_field (TYPE_BINFO (type), name, 1, 0))))\n     {\n       if (t == error_mark_node)\n \treturn error_mark_node;\n@@ -2525,8 +2521,10 @@ add_friend (type, decl)\n \t    {\n \t      if (decl == TREE_VALUE (friends))\n \t\t{\n-\t\t  cp_pedwarn_at (\"`%D' is already a friend of class `%T'\",\n-\t\t\t\t decl, type);\n+\t\t  cp_pedwarn (\"`%D' is already a friend of class `%T'\",\n+\t\t\t      decl, type);\n+\t\t  cp_pedwarn_at (\"previous friend declaration of `%D'\",\n+\t\t\t\t TREE_VALUE (friends));\n \t\t  return;\n \t\t}\n \t    }\n@@ -2606,9 +2604,9 @@ static void\n xref_friend (type, decl, ctype)\n      tree type, decl, ctype;\n {\n-  tree typedecl = TYPE_NAME (type);\n   tree friend_decl = TYPE_NAME (ctype);\n #if 0\n+  tree typedecl = TYPE_NAME (type);\n   tree t = tree_cons (NULL_TREE, ctype, DECL_UNDEFINED_FRIENDS (typedecl));\n \n   DECL_UNDEFINED_FRIENDS (typedecl) = t;\n@@ -2841,18 +2839,8 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n       make_decl_rtl (decl, NULL_PTR, 1);\n       add_friend (current_class_type, decl);\n \n-      if (! TREE_OVERLOADED (declarator)\n-\t  && IDENTIFIER_GLOBAL_VALUE (declarator)\n-\t  && TREE_CODE (IDENTIFIER_GLOBAL_VALUE (declarator)) == FUNCTION_DECL)\n-\t{\n-\t  error (\"friend `%s' implicitly overloaded\",\n-\t\t IDENTIFIER_POINTER (declarator));\n-\t  cp_error_at (\"after declaration of non-overloaded `%D'\", IDENTIFIER_GLOBAL_VALUE (declarator));\n-\t}\n       DECL_FRIEND_P (decl) = 1;\n-      DECL_OVERLOADED (decl) = 1;\n       TREE_OVERLOADED (declarator) = 1;\n-      decl = push_overloaded_decl (decl, 1);\n     }\n   else\n     {\n@@ -2973,7 +2961,7 @@ build_builtin_call (type, node, arglist)\n \n    Unless I am mistaken, a call to new () will return initialized\n    data regardless of whether the constructor itself is private or\n-   not.\n+   not.  NOPE; new fails if the constructor is private (jcm).\n \n    Note that build_new does nothing to assure that any special\n    alignment requirements of the type are met.  Rather, it leaves\n@@ -2990,8 +2978,8 @@ build_new (placement, decl, init, use_global_new)\n      int use_global_new;\n {\n   tree type, true_type, size, rval;\n-  tree init1 = NULL_TREE, nelts;\n-  int has_call = 0, has_array = 0;\n+  tree nelts;\n+  int has_array = 0;\n \n   tree pending_sizes = NULL_TREE;\n \n@@ -3014,13 +3002,7 @@ build_new (placement, decl, init, use_global_new)\n       nelts = integer_one_node;\n \n       if (absdcl && TREE_CODE (absdcl) == CALL_EXPR)\n-\t{\n-\t  /* probably meant to be a call */\n-\t  has_call = 1;\n-\t  init1 = TREE_OPERAND (absdcl, 1);\n-\t  absdcl = TREE_OPERAND (absdcl, 0);\n-\t  TREE_VALUE (decl) = absdcl;\n-\t}\n+\tmy_friendly_abort (215);\n       while (absdcl && TREE_CODE (absdcl) == INDIRECT_REF)\n \t{\n \t  last_absdcl = absdcl;\n@@ -3047,7 +3029,7 @@ build_new (placement, decl, init, use_global_new)\n \t\terror (\"new of array type fails to specify size\");\n \t      else\n \t\t{\n-\t\t  this_nelts = save_expr (this_nelts);\n+\t\t  this_nelts = save_expr (convert (sizetype, this_nelts));\n \t\t  absdcl = TREE_OPERAND (absdcl, 0);\n \t          if (this_nelts == integer_zero_node)\n \t\t    {\n@@ -3068,25 +3050,12 @@ build_new (placement, decl, init, use_global_new)\n \tTREE_VALUE (decl) = absdcl;\n \n       type = true_type = groktypename (decl);\n-      if (! type || type == error_mark_node\n-\t  || true_type == error_mark_node)\n+      if (! type || type == error_mark_node)\n \t{\n \t  immediate_size_expand = old_immediate_size_expand;\n \t  return error_mark_node;\n \t}\n \n-      /* ``A reference cannot be created by the new operator.  A reference\n-\t is not an object (8.2.2, 8.4.3), so a pointer to it could not be\n-\t returned by new.'' ARM 5.3.3 */\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\terror (\"new cannot be applied to a reference type\");\n-\n-      type = TYPE_MAIN_VARIANT (type);\n-      if (type == void_type_node)\n-\t{\n-\t  error (\"invalid type: `void []'\");\n-\t  return error_mark_node;\n-\t}\n       if (current_function_decl\n \t  && DECL_CONSTRUCTOR_P (current_function_decl))\n \t{\n@@ -3123,42 +3092,37 @@ build_new (placement, decl, init, use_global_new)\n       decl = TYPE_NAME (type);\n     }\n \n-  if (TYPE_SIZE (type) == 0)\n+  /* ``A reference cannot be created by the new operator.  A reference\n+     is not an object (8.2.2, 8.4.3), so a pointer to it could not be\n+     returned by new.'' ARM 5.3.3 */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      if (type == void_type_node)\n-\terror (\"invalid type for new: `void'\");\n-      else\n-\tincomplete_type_error (0, type);\n-      return error_mark_node;\n+      error (\"new cannot be applied to a reference type\");\n+      type = true_type = TREE_TYPE (type);\n     }\n \n-  if (TYPE_LANG_SPECIFIC (type) && CLASSTYPE_ABSTRACT_VIRTUALS (type))\n+  /* When the object being created is an array, the new-expression yields a\n+     pointer to the initial element (if any) of the array.  For example,\n+     both new int and new int[10] return an int*.  5.3.4.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE && has_array == 0)\n     {\n-      abstract_virtuals_error (NULL_TREE, type);\n-      return error_mark_node;\n+      nelts = array_type_nelts_top (type);\n+      has_array = 1;\n+      type = true_type = TREE_TYPE (type);\n     }\n \n-  if (TYPE_LANG_SPECIFIC (type) && IS_SIGNATURE (type))\n+  if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n     {\n-      signature_error (NULL_TREE, type);\n-      return error_mark_node;\n+      pedwarn (\"const and volatile types cannot be created with operator new\");\n+      type = true_type = TYPE_MAIN_VARIANT (type);\n     }\n-\n+  \n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n   while (TREE_CODE (true_type) == ARRAY_TYPE)\n     {\n       tree this_nelts = array_type_nelts_top (true_type);\n-      if (nelts == integer_one_node)\n-\t{\n-\t  has_array = 1;\n-\t  nelts = this_nelts;\n-\t}\n-      else\n-\t{\n-\t  my_friendly_assert (has_array != 0, 216);\n-\t  nelts = build_binary_op (MULT_EXPR, nelts, this_nelts, 1);\n-\t}\n+      nelts = build_binary_op (MULT_EXPR, nelts, this_nelts, 1);\n       true_type = TREE_TYPE (true_type);\n     }\n   if (has_array)\n@@ -3167,8 +3131,27 @@ build_new (placement, decl, init, use_global_new)\n   else\n     size = size_in_bytes (type);\n \n-  if (has_call)\n-    init = init1;\n+  if (TYPE_SIZE (true_type) == 0)\n+    {\n+      if (true_type == void_type_node)\n+\terror (\"invalid type for new: `void'\");\n+      else\n+\tincomplete_type_error (0, true_type);\n+      return error_mark_node;\n+    }\n+\n+  if (TYPE_LANG_SPECIFIC (true_type)\n+      && CLASSTYPE_ABSTRACT_VIRTUALS (true_type))\n+    {\n+      abstract_virtuals_error (NULL_TREE, true_type);\n+      return error_mark_node;\n+    }\n+\n+  if (TYPE_LANG_SPECIFIC (true_type) && IS_SIGNATURE (true_type))\n+    {\n+      signature_error (NULL_TREE, true_type);\n+      return error_mark_node;\n+    }\n \n   /* Get a little extra space to store a couple of things before the new'ed\n      array. */\n@@ -3182,7 +3165,8 @@ build_new (placement, decl, init, use_global_new)\n   /* Allocate the object. */\n   if (TYPE_LANG_SPECIFIC (true_type)\n       && (TREE_GETS_NEW (true_type) || TREE_GETS_PLACED_NEW (true_type))\n-      && !use_global_new)\n+      && !use_global_new\n+      && !has_array)\n     rval = build_opfncall (NEW_EXPR, LOOKUP_NORMAL,\n \t\t\t   TYPE_POINTER_TO (true_type), size, placement);\n   else if (placement)\n@@ -3302,8 +3286,7 @@ build_new (placement, decl, init, use_global_new)\n   if (init == void_type_node)\n     goto done;\n \n-  if (TYPE_NEEDS_CONSTRUCTING (type)\n-      || (has_call || init))\n+  if (TYPE_NEEDS_CONSTRUCTING (type) || init)\n     {\n       if (! TYPE_NEEDS_CONSTRUCTING (type) && ! IS_AGGR_TYPE (type))\n \t{\n@@ -3719,8 +3702,6 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n   if (! TYPE_NEEDS_DESTRUCTOR (type))\n     {\n-      tree virtual_size;\n-\n       if (auto_delete == integer_zero_node)\n \treturn void_zero_node;\n \n@@ -4100,7 +4081,7 @@ build_vec_delete (base, maxindex, elt_size, dtor_dummy, auto_delete_vec, auto_de\n       /* This is the real size */\n       virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n       body = build_tree_list (NULL_TREE,\n-\t\t\t      build_x_delete (ptr_type_node, base_tbd, 0,\n+\t\t\t      build_x_delete (ptr_type_node, base_tbd, 1,\n \t\t\t\t\t      virtual_size));\n       body = build (COND_EXPR, void_type_node,\n \t\t    build (BIT_AND_EXPR, integer_type_node,\n@@ -4112,7 +4093,7 @@ build_vec_delete (base, maxindex, elt_size, dtor_dummy, auto_delete_vec, auto_de\n \n   body = tree_cons (NULL_TREE,\n \t\t    build_delete (ptype, tbase, auto_delete,\n-\t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0),\n+\t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n \t\t    body);\n \n   body = tree_cons (NULL_TREE,"}, {"sha": "26155a7b707d4e5cfc57da62de9e685cbcc2a2a9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -21,10 +21,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* This file is the lexical analyzer for GNU C++.  */\n \n-#if defined(GATHER_STATISTICS) || defined(SPEW_DEBUG)\n-#undef YYDEBUG\n+/* Cause the `yydebug' variable to be defined.  */\n #define YYDEBUG 1\n-#endif\n \n #include <sys/types.h>\n #include <stdio.h>\n@@ -898,7 +896,6 @@ yyhook (yyn)\n {\n   reduce_count[yyn] += 1;\n }\n-#endif\n \n static int\n reduce_cmp (p, q)\n@@ -913,6 +910,7 @@ token_cmp (p, q)\n {\n   return token_count[*q] - token_count[*p];\n }\n+#endif\n \n void\n print_parse_statistics ()\n@@ -1829,7 +1827,7 @@ cons_up_default_function (type, name, fields, kind)\n \t\t IDENTIFIER_POINTER (t), func_buf);\n       }\n   }\n-#endif /* DEBUG_DEFAULT_FUNCTIONS\n+#endif /* DEBUG_DEFAULT_FUNCTIONS */\n \n   DECL_CLASS_CONTEXT (fn) = type;\n \n@@ -1858,6 +1856,7 @@ largest_union_member (type)\n \n   /* We should always find one.  */\n   my_friendly_abort (323);\n+  return NULL_TREE;\n }\n \n /* Construct the body of a default assignment operator.\n@@ -1946,7 +1945,7 @@ default_assign_ref_body (bufp, lenp, type, fields)\n \t{\n \t  tree binfo = TREE_VEC_ELT (bases, i);\n \t  tree btype, name;\n-\t  char *s, *p;\n+\t  char *s;\n \n \t  btype = BINFO_TYPE (binfo);\n \t  name = TYPE_NESTED_NAME (btype);\n@@ -1976,7 +1975,7 @@ default_assign_ref_body (bufp, lenp, type, fields)\n \t{\n \t  if (TREE_CODE (f) == FIELD_DECL && ! DECL_VIRTUAL_P (f))\n \t    {\n-\t      char *s, *p;\n+\t      char *s;\n \t      tree x;\n \t      tree t = TREE_TYPE (f);\n \n@@ -2098,7 +2097,7 @@ default_copy_constructor_body (bufp, lenp, type, fields)\n       for (;;)\n \t{\n \t  tree binfo, btype, name;\n-\t  char *s, *p;\n+\t  char *s;\n \n \t  if (v)\n \t    {\n@@ -2143,7 +2142,7 @@ default_copy_constructor_body (bufp, lenp, type, fields)\n \t{\n \t  if (TREE_CODE (f) == FIELD_DECL && ! DECL_VIRTUAL_P (f))\n \t    {\n-\t      char *s, *p;\n+\t      char *s;\n \t      tree x;\n \t      tree t = TREE_TYPE (f);\n \n@@ -2469,9 +2468,6 @@ check_newline ()\n \n \t\t      if (impl_file_chain == 0)\n \t\t\t{\n-\t\t\t  char *filename;\n-\t\t\t  tree fi;\n-\n \t\t\t  /* If this is zero at this point, then we are\n \t\t\t     auto-implementing.  */\n \t\t\t  if (main_input_filename == 0)\n@@ -2577,10 +2573,16 @@ check_newline ()\n \t\t      else\n \t\t\terror (\"`#pragma implementation' can only appear at top-level\");\n \t\t      interface_only = 0;\n+#if 0\n \t\t      /* We make this non-zero so that we infer decl linkage\n \t\t\t in the impl file only for variables first declared\n \t\t\t in the interface file.  */\n \t\t      interface_unknown = 1;\n+#else\n+\t\t      /* We make this zero so that templates in the impl\n+                         file will be emitted properly. */\n+\t\t      interface_unknown = 0;\n+#endif\n \t\t      TREE_INT_CST_LOW (fileinfo) = interface_only;\n \t\t      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n \t\t    }\n@@ -4679,7 +4681,8 @@ make_lang_type (code)\n   SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n   CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n   CLASSTYPE_VBASE_SIZE (t) = integer_zero_node;\n-  TYPE_BINFO (t) = make_binfo (integer_zero_node, t, 0, 0, 0);\n+  TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE,\n+\t\t\t       NULL_TREE);\n   CLASSTYPE_BINFO_AS_LIST (t) = build_tree_list (NULL_TREE, TYPE_BINFO (t));\n \n   /* Make sure this is laid out, for ease of use later."}, {"sha": "cdf3d196c7612adcc9a52809803a2bb379e56e00", "filename": "gcc/cp/method.c", "status": "modified", "additions": 257, "deletions": 1, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -32,6 +32,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"class.h\"\n #include \"obstack.h\"\n #include <ctype.h>\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"output.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n \n /* TREE_LIST of the current inline functions that need to be\n    processed.  */\n@@ -495,7 +500,7 @@ build_overload_name (parmtypes, begin, end)\n \n   if (begin) OB_INIT ();\n \n-  if (just_one = (TREE_CODE (parmtypes) != TREE_LIST))\n+  if ((just_one = (TREE_CODE (parmtypes) != TREE_LIST)))\n     {\n       parmtype = parmtypes;\n       goto only_one;\n@@ -1651,3 +1656,254 @@ build_component_type_expr (of, component, basetype_path, protect)\n \t    TREE_TYPE (name));\n   return error_mark_node;\n }\n+\f\n+static char *\n+thunk_printable_name (decl)\n+     tree decl;\n+{\n+  return \"<thunk function>\";\n+}\n+\n+tree\n+make_thunk (function, delta)\n+     tree function;\n+     int delta;\n+{\n+  char buffer[250];\n+  tree thunk_fndecl;\n+  tree thunk;\n+  static int thunk_number = 0;\n+  tree func_decl;\n+  if (TREE_CODE (function) != ADDR_EXPR)\n+    abort ();\n+  func_decl = TREE_OPERAND (function, 0);\n+  if (TREE_CODE (func_decl) != FUNCTION_DECL)\n+    abort ();\n+  sprintf (buffer, \"__thunk_%d_%d\", -delta, thunk_number++);\n+  thunk = build_decl (THUNK_DECL, get_identifier (buffer),\n+\t\t      TREE_TYPE (func_decl));\n+  DECL_RESULT (thunk)\n+    = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  make_function_rtl (thunk);\n+  DECL_INITIAL (thunk) = function;\n+  THUNK_DELTA (thunk) = delta;\n+  return thunk;\n+}\n+\n+void\n+emit_thunk (thunk_fndecl)\n+  tree thunk_fndecl;\n+{\n+  rtx insns;\n+  char *fnname;\n+  char buffer[250];\n+  tree argp;\n+  struct args_size stack_args_size;\n+  tree function = TREE_OPERAND (DECL_INITIAL (thunk_fndecl), 0);\n+  int delta = THUNK_DELTA (thunk_fndecl);\n+  int tem;\n+  int failure = 0;\n+\n+  /* Used to remember which regs we need to emit a USE rtx for. */\n+  rtx need_use[FIRST_PSEUDO_REGISTER];\n+  int need_use_count = 0;\n+\n+  /* rtx for the 'this' parameter. */\n+  rtx this_rtx = 0, this_reg_rtx = 0, fixed_this_rtx;\n+\n+  char *(*save_decl_printable_name) () = decl_printable_name;\n+  /* Data on reg parms scanned so far.  */\n+  CUMULATIVE_ARGS args_so_far;\n+\n+  if (TREE_ASM_WRITTEN (thunk_fndecl))\n+    return;\n+\n+  decl_printable_name = thunk_printable_name;\n+  if (current_function_decl)\n+    abort ();\n+  current_function_decl = thunk_fndecl;\n+  init_function_start (thunk_fndecl, input_filename, lineno);\n+  pushlevel (0);\n+  expand_start_bindings (1);\n+\n+  /* Start updating where the next arg would go.  */\n+  INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (function), NULL_RTX);\n+  stack_args_size.constant = 0;\n+  stack_args_size.var = 0;\n+  /* SETUP for possible structure return address FIXME */\n+\n+  /* Now look through all the parameters, make sure that we\n+     don't clobber any registers used for parameters.\n+     Also, pick up an rtx for the first \"this\" parameter. */\n+  for (argp = TYPE_ARG_TYPES (TREE_TYPE (function));\n+       argp != NULL_TREE;\n+       argp = TREE_CHAIN (argp))\n+\n+    {\n+      tree passed_type = TREE_VALUE (argp);\n+      register rtx entry_parm;\n+      int named = 1; /* FIXME */\n+      struct args_size stack_offset;\n+      struct args_size arg_size;\n+\n+      if (passed_type == void_type_node)\n+\tbreak;\n+\n+      if ((TREE_CODE (TYPE_SIZE (passed_type)) != INTEGER_CST\n+\t   && contains_placeholder_p (TYPE_SIZE (passed_type)))\n+#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n+\t  || FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far,\n+\t\t\t\t\t     TYPE_MODE (passed_type),\n+\t\t\t\t\t     passed_type, named)\n+#endif\n+\t  )\n+\tpassed_type = build_pointer_type (passed_type);\n+\n+      entry_parm = FUNCTION_ARG (args_so_far,\n+\t\t\t\t TYPE_MODE (passed_type),\n+\t\t\t\t passed_type,\n+\t\t\t\t named);\n+      if (entry_parm != 0)\n+\tneed_use[need_use_count++] = entry_parm;\n+\n+      locate_and_pad_parm (TYPE_MODE (passed_type), passed_type,\n+#ifdef STACK_PARMS_IN_REG_PARM_AREA\n+\t\t\t   1,\n+#else\n+\t\t\t   entry_parm != 0,\n+#endif\n+\t\t\t   thunk_fndecl,\n+\t\t\t   &stack_args_size, &stack_offset, &arg_size);\n+\n+/*    REGNO (entry_parm);*/\n+      if (this_rtx == 0)\n+\t{\n+\t  this_reg_rtx = entry_parm;\n+\t  if (!entry_parm)\n+\t    {\n+\t      rtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n+\n+\t      rtx internal_arg_pointer, stack_parm;\n+\n+\t      if ((ARG_POINTER_REGNUM == STACK_POINTER_REGNUM\n+\t\t   || ! (fixed_regs[ARG_POINTER_REGNUM]\n+\t\t\t || ARG_POINTER_REGNUM == FRAME_POINTER_REGNUM)))\n+\t\tinternal_arg_pointer = copy_to_reg (virtual_incoming_args_rtx);\n+\t      else\n+\t\tinternal_arg_pointer = virtual_incoming_args_rtx;\n+\n+\t      if (offset_rtx == const0_rtx)\n+\t\tentry_parm = gen_rtx (MEM, TYPE_MODE (passed_type),\n+\t\t\t\t      internal_arg_pointer);\n+\t      else\n+\t\tentry_parm = gen_rtx (MEM, TYPE_MODE (passed_type),\n+\t\t\t\t      gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t       internal_arg_pointer, \n+\t\t\t\t\t       offset_rtx));\n+\t    }\n+\t  \n+\t  this_rtx = entry_parm;\n+\t}\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far,\n+\t\t\t    TYPE_MODE (passed_type),\n+\t\t\t    passed_type,\n+\t\t\t    named);\n+    }\n+\n+  fixed_this_rtx = plus_constant (this_rtx, delta);\n+  if (this_rtx != fixed_this_rtx)\n+    emit_move_insn (this_rtx, fixed_this_rtx);\n+\n+  if (this_reg_rtx)\n+    emit_insn (gen_rtx (USE, VOIDmode, this_reg_rtx));\n+\n+  emit_indirect_jump (XEXP (DECL_RTL (function), 0));\n+\n+  while (need_use_count > 0)\n+    emit_insn (gen_rtx (USE, VOIDmode, need_use[--need_use_count]));\n+\n+  expand_end_bindings (NULL, 1, 0);\n+  poplevel (0, 0, 1);\n+\n+  TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+\n+  /* From now on, allocate rtl in current_obstack, not in saveable_obstack.\n+     Note that that may have been done above, in save_for_inline_copying.\n+     The call to resume_temporary_allocation near the end of this function\n+     goes back to the usual state of affairs.  */\n+\n+  rtl_in_current_obstack ();\n+\n+  insns = get_insns ();\n+\n+  /* Copy any shared structure that should not be shared.  */\n+\n+  unshare_all_rtl (insns);\n+\n+  /* Instantiate all virtual registers.  */\n+\n+  instantiate_virtual_regs (current_function_decl, get_insns ());\n+\n+  /* We are no longer anticipating cse in this function, at least.  */\n+\n+  cse_not_expected = 1;\n+\n+  /* Now we choose between stupid (pcc-like) register allocation\n+     (if we got the -noreg switch and not -opt)\n+     and smart register allocation.  */\n+\n+  if (optimize > 0)\t\t\t/* Stupid allocation probably won't work */\n+    obey_regdecls = 0;\t\t/* if optimizations being done.  */\n+\n+  regclass_init ();\n+\n+  regclass (insns, max_reg_num ());\n+  if (obey_regdecls)\n+    {\n+      stupid_life_analysis (insns, max_reg_num (), NULL);\n+      failure = reload (insns, 0, NULL);\n+    }\n+  else\n+    {\n+      /* Do control and data flow analysis,\n+\t and write some of the results to dump file.  */\n+\n+      flow_analysis (insns, max_reg_num (), NULL);\n+      local_alloc ();\n+      failure = global_alloc (NULL);\n+    }\n+\n+  reload_completed = 1;\n+\n+#ifdef LEAF_REGISTERS\n+  leaf_function = 0;\n+  if (optimize > 0 && only_leaf_regs_used () && leaf_function_p ())\n+    leaf_function = 1;\n+#endif\n+\n+  /* If a machine dependent reorganization is needed, call it.  */\n+#ifdef MACHINE_DEPENDENT_REORG\n+   MACHINE_DEPENDENT_REORG (insns);\n+#endif\n+\n+  /* Now turn the rtl into assembler code.  */\n+\n+    {\n+      char *fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n+      assemble_start_function (thunk_fndecl, fnname);\n+      final (insns, asm_out_file, optimize, 0);\n+      assemble_end_function (thunk_fndecl, fnname);\n+    };\n+\n+ exit_rest_of_compilation:\n+\n+  reload_completed = 0;\n+\n+  /* Cancel the effect of rtl_in_current_obstack.  */\n+\n+  resume_temporary_allocation ();\n+\n+  decl_printable_name = save_decl_printable_name;\n+  current_function_decl = 0;\n+}"}, {"sha": "9730a62ad7e5983e70348532256b54a928de5a6f", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -40,10 +40,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n   */\n \n %{\n-#if defined(GATHER_STATISTICS) || defined(SPEW_DEBUG)\n-#undef YYDEBUG\n+/* Cause the `yydebug' variable to be defined.  */\n #define YYDEBUG 1\n-#endif\n \n #include \"config.h\"\n \n@@ -74,8 +72,6 @@ void yyerror ();\n /* Like YYERROR but do call yyerror.  */\n #define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n \n-static void position_after_white_space ();\n-\n /* Contains the statement keyword (if/while/do) to include in an\n    error message if the user supplies an empty conditional expression.  */\n static char *cond_stmt_keyword;\n@@ -338,6 +334,8 @@ asm_keyword:\n lang_extdef:\n \t  { if (pending_lang_change) do_pending_lang_change(); }\n \t  extdef\n+\t  { if (! global_bindings_p () && ! pseudo_global_level_p())\n+\t      pop_everything (); }\n \t;\n \n extdef:\n@@ -1226,9 +1224,11 @@ unary_expr:\n \t\t  $$ = build_new ($2, typename, NULL_TREE, $$ != NULL_TREE);\n \t\t}\n \t| .scope new '(' type_id ')'\n-\t\t{ $$ = build_new ($2, $4, NULL_TREE, $$ != NULL_TREE); }\n+\t\t{ $$ = build_new ($2, groktypename ($4), NULL_TREE,\n+\t\t\t\t  $$ != NULL_TREE); }\n \t| .scope new '(' nonnull_exprlist ')' '(' type_id ')'\n-\t\t{ $$ = build_new ($4, $7, NULL_TREE, $$ != NULL_TREE); }\n+\t\t{ $$ = build_new ($4, groktypename ($7), NULL_TREE,\n+\t\t\t\t  $$ != NULL_TREE); }\n \t/* Unswallow a ':' which is probably meant for ?: expression.  */\n \t| .scope new TYPENAME_COLON\n \t\t{ yyungetc (':', 1); $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n@@ -1347,8 +1347,8 @@ expr_no_commas:\n \t\t{ $$ = build_modify_expr ($$, NOP_EXPR, $3); }\n \t| expr_no_commas ASSIGN expr_no_commas\n \t\t{ register tree rval;\n-\t\t  if (rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, $$, $3,\n-\t\t\t\t\t     make_node ($2)))\n+\t\t  if ((rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, $$, $3,\n+\t\t\t\t\t     make_node ($2))))\n \t\t    $$ = rval;\n \t\t  else\n \t\t    $$ = build_modify_expr ($$, $2, $3); }\n@@ -1473,8 +1473,7 @@ primary:\n \t\t    $$ = require_complete_type ($$);\n                 }\n \t| primary '[' expr ']'\n-\t\t{ do_array:\n-\t\t    $$ = grok_array_decl ($$, $3); }\n+\t\t{ $$ = grok_array_decl ($$, $3); }\n \t| object identifier_or_opname  %prec UNARY\n \t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object id_scope identifier_or_opname %prec UNARY\n@@ -1570,10 +1569,6 @@ primary:\n \t| TYPEID '(' type_id ')'\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = get_typeid (type); }\n-\t| SCOPE typespec '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_functional_cast ($2, $4); }\n-\t| SCOPE typespec LEFT_RIGHT\n-\t\t{ $$ = build_functional_cast ($2, NULL_TREE); }\n \t| SCOPE IDENTIFIER\n \t\t{\n \t\tdo_scoped_id:\n@@ -1617,7 +1612,6 @@ primary:\n \t\t{\n \t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    goto do_scoped_id;\n-\t\tdo_scoped_operator:\n \t\t  $$ = $2;\n \t\t}\n \t| id_scope identifier_or_opname  %prec HYPERUNARY\n@@ -2040,6 +2034,13 @@ initdcl0:\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n+\t\t  if (have_extern_spec && !used_extern_spec)\n+\t\t    {\n+\t\t      current_declspecs = decl_tree_cons\n+\t\t\t(NULL_TREE, get_identifier (\"extern\"), \n+\t\t\t current_declspecs);\n+\t\t      used_extern_spec = 1;\n+\t\t    }\n \t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n@@ -2052,6 +2053,13 @@ initdcl0:\n \t\t  current_declspecs = $<ttype>0;\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n+\t\t  if (have_extern_spec && !used_extern_spec)\n+\t\t    {\n+\t\t      current_declspecs = decl_tree_cons\n+\t\t\t(NULL_TREE, get_identifier (\"extern\"), \n+\t\t\t current_declspecs);\n+\t\t      used_extern_spec = 1;\n+\t\t    }\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4);"}, {"sha": "e9810e1177162d52cc9a5577e298bbfce9fb3848", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -87,7 +87,6 @@ process_template_parm (list, next)\n   if (!is_type)\n     {\n       tree tinfo = 0;\n-      int  idx = 0;\n       parm = TREE_PURPOSE (parm);\n       my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 260);\n       parm = TREE_VALUE (parm);\n@@ -281,19 +280,7 @@ end_template_decl (d1, d2, is_class, defn)\n     {\n       poplevel (0, 0, 0);\n       poplevel (0, 0, 0);\n-      if (TREE_TYPE (decl))\n-\t{\n-\t  /* Function template */\n-\t  tree t = IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl));\n-\t  if (t && is_overloaded_fn (t))\n-\t    for (t = get_first_fn (t); t; t = DECL_CHAIN (t))\n-\t      if (TREE_CODE (t) == TEMPLATE_DECL\n-\t\t  && duplicate_decls (decl, t))\n-\t\tdecl = t;\n-\t  push_overloaded_decl (decl, 0);\n-\t}\n-      else\n-\tpushdecl (decl);\n+      pushdecl (decl);\n     }\n  lose:\n #if 0 /* It happens sometimes, with syntactic or semantic errors.\n@@ -470,7 +457,6 @@ mangle_class_name_for_template (name, parms, arglist)\n   static struct obstack scratch_obstack;\n   static char *scratch_firstobj;\n   int i, nparms;\n-  char ibuf[100];\n \n   if (!scratch_firstobj)\n     {\n@@ -492,8 +478,6 @@ mangle_class_name_for_template (name, parms, arglist)\n #define advance\n #define cat(s)\tobstack_grow (&scratch_obstack, (s), strlen (s))\n #endif\n-#define icat(n)\tsprintf(ibuf,\"%d\",(n)); cat(ibuf)\n-#define xcat(n)\tsprintf(ibuf,\"%ux\",n); cat(ibuf)\n \n   cat (name);\n   ccat ('<');\n@@ -540,7 +524,9 @@ mangle_class_name_for_template (name, parms, arglist)\n   ccat ('\\0');\n   return (char *) obstack_base (&scratch_obstack);\n \n+#if 0\n  too_long:\n+#endif\n   fatal (\"out of (preallocated) string space creating template instantiation name\");\n   /* NOTREACHED */\n   return NULL;\n@@ -619,7 +605,11 @@ push_template_decls (parmlist, arglist, class_level)\n \n   /* Don't want to push values into global context.  */\n   if (!class_level)\n-    pushlevel (0);\n+    {\n+      pushlevel (1);\n+      declare_pseudo_global_level ();\n+    }\n+\n   nparms = TREE_VEC_LENGTH (parmlist);\n \n   for (i = 0; i < nparms; i++)\n@@ -669,8 +659,6 @@ push_template_decls (parmlist, arglist, class_level)\n \t    pushdecl (decl);\n \t}\n     }\n-  if (!class_level)\n-    set_current_level_tags_transparency (1);\n }\n \n void\n@@ -1235,7 +1223,7 @@ tsubst (t, args, nargs, in_decl)\n \t\t  {\n \t\t    my_friendly_assert (TREE_CODE (method) == FUNCTION_DECL,\n \t\t\t\t\t282);\n-\t\t    if (TREE_TYPE (method) != type)\n+\t\t    if (! comptypes (type, TREE_TYPE (method), 1))\n \t\t      {\n \t\t\ttree mtype = TREE_TYPE (method);\n \t\t\ttree t1, t2;\n@@ -1348,7 +1336,6 @@ tsubst (t, args, nargs, in_decl)\n \t\t    {\n \t\t      got_it = 1;\n \t\t      r = val;\n-\t\t      break;\n \t\t    }\n \t\t}\n \n@@ -2186,7 +2173,7 @@ do_pending_expansions ()\n       tree t = i->fndecl;\n \n       int decision = 0;\n-#define DECIDE(N) if(1){decision=(N); goto decided;}else\n+#define DECIDE(N) do {decision=(N); goto decided;} while(0)\n \n       my_friendly_assert (TREE_CODE (t) == FUNCTION_DECL\n \t\t\t  || TREE_CODE (t) == VAR_DECL, 294);"}, {"sha": "984ee439964a678d92c5f0a18f31b74bd3011676", "filename": "gcc/cp/search.c", "status": "modified", "additions": 49, "deletions": 62, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -377,6 +377,7 @@ pop_memoized_context (use_old)\n     type_stack = (struct type_level *)type_stack->base.prev;\n }\n \f\n+#if 0\t\t\t\t/* unused */\n /* This is the newer recursive depth first search routine. */\n /* Return non-zero if PARENT is directly derived from TYPE.  By directly\n    we mean it's only one step up the inheritance lattice.  We check this\n@@ -402,6 +403,7 @@ immediately_derived (parent, type)\n     }\n   return 0;\n }\n+#endif\n \n /* Check whether the type given in BINFO is derived from PARENT.  If\n    it isn't, return 0.  If it is, but the derivation is MI-ambiguous\n@@ -459,7 +461,7 @@ get_binfo (parent, binfo, protect)\n }\n \n /* This is the newer depth first get_base_distance routine.  */\n-static\n+static int\n get_base_distance_recursive (binfo, depth, is_private, basetype_path, rval,\n \t\t\t     rval_private_ptr, new_binfo_ptr, parent, path_ptr,\n \t\t\t     protect, via_virtual_ptr, via_virtual)\n@@ -583,10 +585,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n      int protect;\n      tree *path_ptr;\n {\n-  int head, tail;\n-  int is_private = 0;\n   int rval;\n-  int depth = 0;\n   int rval_private = 0;\n   tree type;\n   tree new_binfo = NULL_TREE;\n@@ -1966,54 +1965,31 @@ get_first_matching_virtual (binfo, fndecl, dtorp)\n     }\n }\n \n-/* Return the list of virtual functions which are abstract in type TYPE.\n-   This information is cached, and so must be built on a\n-   non-temporary obstack.  */\n-tree\n-get_abstract_virtuals (type)\n-     tree type;\n+/* Return the list of virtual functions which are abstract in type TYPE\n+   that come from non virtual base classes.  See init_vtbl_ptrs for\n+   the style of search we do.  */\n+static tree\n+get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n+     tree binfo, abstract_virtuals;\n+     int do_self;\n {\n-  /* For each layer of base class (i.e., the first base class, and each\n-     virtual base class from that one), modify the virtual function table\n-     of the derived class to contain the new virtual function.\n-     A class has as many vfields as it has virtual base classes (total).  */\n-  tree vfields, vbases, base, tmp;\n-  tree vfield = CLASSTYPE_VFIELD (type);\n-  tree fcontext = vfield ? DECL_FCONTEXT (vfield) : NULL_TREE;\n-  tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (type);\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n-  for (vfields = CLASSTYPE_VFIELDS (type); vfields; vfields = TREE_CHAIN (vfields))\n+  for (i = 0; i < n_baselinks; i++)\n     {\n-      int normal;\n-\n-      /* This code is most likely wrong, and probably only works for single\n-\t inheritance or by accident. */\n-\n-      /* Find the right base class for this derived class, call it BASE.  */\n-      base = VF_BASETYPE_VALUE (vfields);\n-      if (base == type)\n-\tcontinue;\n-\n-      /* We call this case NORMAL iff this virtual function table\n-\t pointer field has its storage reserved in this class.\n-\t This is normally the case without virtual baseclasses\n-\t or off-center multiple baseclasses.  */\n-      normal = (base == fcontext\n-\t\t&& (VF_BINFO_VALUE (vfields) == NULL_TREE\n-\t\t    || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields))));\n-\n-      if (normal)\n-\ttmp = TREE_CHAIN (TYPE_BINFO_VIRTUALS (type));\n-      else\n-\t{\n-\t  /* n.b.: VF_BASETYPE_VALUE (vfields) is the first basetype\n-\t     that provides the virtual function table, whereas\n-\t     VF_DERIVED_VALUE (vfields) is an immediate base type of TYPE\n-\t     that dominates VF_BASETYPE_VALUE (vfields).  The list of\n-\t     vfields we want lies between these two values.  */\n-\t  tree binfo = get_binfo (VF_NORMAL_VALUE (vfields), type, 0);\n-\t  tmp = TREE_CHAIN (BINFO_VIRTUALS (binfo));\n-\t}\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      if (! TREE_VIA_VIRTUAL (base_binfo))\n+\tabstract_virtuals\n+\t  = get_abstract_virtuals_1 (base_binfo, is_not_base_vtable,\n+\t\t\t\t     abstract_virtuals);\n+    }\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      tree tmp = TREE_CHAIN (BINFO_VIRTUALS (binfo));\n \n       /* Get around dossier entry if there is one.  */\n       if (flag_dossier)\n@@ -2028,6 +2004,23 @@ get_abstract_virtuals (type)\n \t  tmp = TREE_CHAIN (tmp);\n \t}\n     }\n+  return abstract_virtuals;\n+}\n+\n+/* Return the list of virtual functions which are abstract in type TYPE.\n+   This information is cached, and so must be built on a\n+   non-temporary obstack.  */\n+tree\n+get_abstract_virtuals (type)\n+     tree type;\n+{\n+  tree vbases, tmp;\n+  tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (type);\n+\n+  /* First get all from non-virtual bases. */\n+  abstract_virtuals\n+    = get_abstract_virtuals_1 (TYPE_BINFO (type), 1, abstract_virtuals);\n+\t\t\t\t\t       \n   for (vbases = CLASSTYPE_VBASECLASSES (type); vbases; vbases = TREE_CHAIN (vbases))\n     {\n       if (! BINFO_VIRTUALS (vbases))\n@@ -2414,8 +2407,7 @@ dfs_init_vbase_pointers (binfo)\n {\n   tree type = BINFO_TYPE (binfo);\n   tree fields = TYPE_FIELDS (type);\n-  tree path, this_vbase_ptr;\n-  int distance;\n+  tree this_vbase_ptr;\n \n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n \n@@ -2500,9 +2492,9 @@ init_vbase_pointers (type, decl_ptr)\n    offsets are valid to store vtables.  When zero, we must store new\n    vtables through virtual baseclass pointers.  */\n \n-tree\n-build_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n-\t\t\t  use_computed_offsets)\n+void\n+expand_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n+\t\t\t   use_computed_offsets)\n      tree main_binfo, binfo;\n      tree true_exp, decl_ptr;\n      int use_computed_offsets;\n@@ -2512,7 +2504,6 @@ build_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       int old_flag = flag_this_is_variable;\n-      tree vtable_init_result = NULL_TREE;\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n \n       vbase_types = CLASSTYPE_VBASECLASSES (for_type);\n@@ -2538,7 +2529,7 @@ build_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n \t      tree addr;\n \t      tree vtbl = BINFO_VTABLE (vbases);\n \t      tree init = build_unary_op (ADDR_EXPR, vtbl, 0);\n-\t      if (!flag_vtable_hack)\n+\t      if (!flag_vtable_thunks)\n \t\tassemble_external (vtbl);\n \t      TREE_USED (vtbl) = 1;\n \n@@ -2552,8 +2543,7 @@ build_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n \t\t  tree ref = build_vfield_ref (build_indirect_ref (addr, NULL_PTR),\n \t\t\t\t\t       BINFO_TYPE (vbases));\n \t\t  init = convert_force (TREE_TYPE (ref), init);\n-\t\t  vtable_init_result = tree_cons (NULL_TREE, build_modify_expr (ref, NOP_EXPR, init),\n-\t\t\t\t\t\t  vtable_init_result);\n+\t\t  expand_expr_stmt (build_modify_expr (ref, NOP_EXPR, init));\n \t\t}\n \t    }\n \t  vbases = TREE_CHAIN (vbases);\n@@ -2562,10 +2552,7 @@ build_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n       dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep);\n \n       flag_this_is_variable = old_flag;\n-      if (vtable_init_result)\n-\treturn build_compound_expr (vtable_init_result);\n     }\n-  return error_mark_node;\n }\n \n void\n@@ -2586,7 +2573,7 @@ dfs_get_vbase_types (binfo)\n {\n   if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n     {\n-      vbase_types = make_binfo (integer_zero_node, BINFO_TYPE (binfo),\n+      vbase_types = make_binfo (integer_zero_node, binfo,\n \t\t\t\tBINFO_VTABLE (binfo),\n \t\t\t\tBINFO_VIRTUALS (binfo), vbase_types);\n       TREE_VIA_VIRTUAL (vbase_types) = 1;"}, {"sha": "da707eb0848a90910d2125f5f3c14725a8f4f0f8", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -46,9 +46,11 @@ struct token  {\n \n static int do_aggr ();\n static struct token frob_identifier ();\n+static tree hack_more_ids ();\n+#if 0\n static struct token hack_scope ();\n static tree hack_ptype ();\n-static tree hack_more_ids ();\n+#endif\n \n /* From lex.c: */\n /* the declaration found for the last IDENTIFIER token read in.\n@@ -70,8 +72,10 @@ static unsigned int yylex_ctr = 0;\n static int debug_yychar ();\n #endif\n \n+#if 0\t\t\t\t/* Used by arbitrate_lookup */\n static char follows_typename[END_OF_SAVED_INPUT+1];\n static char follows_identifier[END_OF_SAVED_INPUT+1];\n+#endif\n \n /* This is a hack!!! TEMPLATE_TYPE_SEEN_BEFORE_SCOPE consists of the name\n  * of the last template_type parsed in parse.y if it is followed by a\n@@ -84,6 +88,7 @@ tree template_type_seen_before_scope;\n void\n init_spew ()\n {\n+#if 0\t\t\t\t/* Used by arbitrate_lookup */\n   static char *chars_following_identifier = \".+-|/%^!?:\";\n   short *ps;\n   static short toks_follow_ids[] =\n@@ -102,8 +107,6 @@ init_spew ()\n       TYPENAME_COLON, PAREN_STAR_PAREN, TYPENAME_ELLIPSIS, PTYPENAME,\n       PRE_PARSED_FUNCTION_DECL, PRE_PARSED_CLASS_DECL, -1 };\n \n-  gcc_obstack_init(&token_obstack);\n-\n   /* Initialize the arrays saying what tokens are definitely\n      (or possibly) valid following typenames and identifiers.  */\n   while (*chars_following_identifier)\n@@ -112,6 +115,9 @@ init_spew ()\n     follows_identifier[*ps] = 1;\n   for (ps = toks_follow_types; *ps != -1; ps++)\n     follows_typename[*ps] = 1;\n+#endif\n+\n+  gcc_obstack_init(&token_obstack);\n }\n \n #ifdef SPEW_DEBUG"}, {"sha": "a63ccac567b7bbf97008d228e4b968ec40138c85", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 67, "deletions": 44, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -448,7 +448,7 @@ propagate_binfo_offsets (binfo, offset)\n \t\t  if (! TREE_VIA_VIRTUAL (base_base_binfo))\n \t\t    TREE_VEC_ELT (base_binfos, k)\n \t\t      = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t\t    BINFO_TYPE (base_base_binfo),\n+\t\t\t\t    base_base_binfo,\n \t\t\t\t    BINFO_VTABLE (base_base_binfo),\n \t\t\t\t    BINFO_VIRTUALS (base_base_binfo),\n \t\t\t\t    chain);\n@@ -563,7 +563,7 @@ layout_vbasetypes (rec, max)\n \t      if (! TREE_VIA_VIRTUAL (base_base_binfo))\n \t\tTREE_VEC_ELT (base_binfos, j)\n \t\t  = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t\tBINFO_TYPE (base_base_binfo),\n+\t\t\t\tbase_base_binfo,\n \t\t\t\tBINFO_VTABLE (base_base_binfo),\n \t\t\t\tBINFO_VIRTUALS (base_base_binfo),\n \t\t\t\tchain);\n@@ -600,13 +600,15 @@ layout_basetypes (rec, binfos)\n   unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n #endif\n \n-  /* Record size so far is CONST_SIZE + VAR_SIZE bits,\n-     where CONST_SIZE is an integer\n-     and VAR_SIZE is a tree expression.\n-     If VAR_SIZE is null, the size is just CONST_SIZE.\n-     Naturally we try to avoid using VAR_SIZE.  */\n-  register unsigned const_size = 0;\n+  /* Record size so far is CONST_SIZE + VAR_SIZE bits, where CONST_SIZE is\n+     an integer and VAR_SIZE is a tree expression.  If VAR_SIZE is null,\n+     the size is just CONST_SIZE.  Naturally we try to avoid using\n+     VAR_SIZE.  And so far, we've been sucessful. */\n+#if 0\n   register tree var_size = 0;\n+#endif\n+\n+  register unsigned const_size = 0;\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n   /* Handle basetypes almost like fields, but record their\n@@ -945,7 +947,9 @@ get_identifier_list (value)\n \t  || TREE_VALUE (list) != value))\n     list = NULL_TREE;\n   else if (IDENTIFIER_HAS_TYPE_VALUE (value)\n-\t   && TREE_CODE (IDENTIFIER_TYPE_VALUE (value)) == RECORD_TYPE)\n+\t   && TREE_CODE (IDENTIFIER_TYPE_VALUE (value)) == RECORD_TYPE\n+\t   && IDENTIFIER_TYPE_VALUE (value)\n+\t      == TYPE_MAIN_VARIANT (IDENTIFIER_TYPE_VALUE (value)))\n     {\n       tree type = IDENTIFIER_TYPE_VALUE (value);\n \n@@ -1052,6 +1056,11 @@ list_hash_lookup_or_cons (value)\n    OFFSET is the offset added to `this' to convert it to a pointer\n    of type `TYPE *'\n \n+   BINFO is the base binfo to use, if we are deriving from one.  This\n+   is necessary, as we want specialized parent binfos from base\n+   classes, so that the VTABLE_NAMEs of bases are for the most derived\n+   type, instead of of the simple type.\n+\n    VTABLE is the virtual function table with which to initialize\n    sub-objects of type TYPE.\n \n@@ -1060,47 +1069,35 @@ list_hash_lookup_or_cons (value)\n    CHAIN are more associations we must retain.  */\n \n tree\n-make_binfo (offset, type, vtable, virtuals, chain)\n-     tree offset, type;\n+make_binfo (offset, binfo, vtable, virtuals, chain)\n+     tree offset, binfo;\n      tree vtable, virtuals;\n      tree chain;\n {\n-  tree binfo = make_tree_vec (6);\n-  tree old_binfo = TYPE_BINFO (type);\n-  tree last;\n+  tree new_binfo = make_tree_vec (6);\n+  tree type;\n \n-  TREE_CHAIN (binfo) = chain;\n-  if (chain)\n-    TREE_USED (binfo) = TREE_USED (chain);\n+  if (TREE_CODE (binfo) == TREE_VEC)\n+    type = BINFO_TYPE (binfo);\n+  else\n+    {\n+      type = binfo;\n+      binfo = TYPE_BINFO (binfo);\n+    }\n \n-  TREE_TYPE (binfo) = TYPE_MAIN_VARIANT (type);\n-  BINFO_OFFSET (binfo) = offset;\n-  BINFO_VTABLE (binfo) = vtable;\n-  BINFO_VIRTUALS (binfo) = virtuals;\n-  BINFO_VPTR_FIELD (binfo) = NULL_TREE;\n+  TREE_CHAIN (new_binfo) = chain;\n+  if (chain)\n+    TREE_USED (new_binfo) = TREE_USED (chain);\n \n-  last = binfo;\n-  if (old_binfo != NULL_TREE\n-      && BINFO_BASETYPES (old_binfo) != NULL_TREE)\n-    {\n-      int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (type);\n-      tree binfos = TYPE_BINFO_BASETYPES (type);\n+  TREE_TYPE (new_binfo) = TYPE_MAIN_VARIANT (type);\n+  BINFO_OFFSET (new_binfo) = offset;\n+  BINFO_VTABLE (new_binfo) = vtable;\n+  BINFO_VIRTUALS (new_binfo) = virtuals;\n+  BINFO_VPTR_FIELD (new_binfo) = NULL_TREE;\n \n-      BINFO_BASETYPES (binfo) = make_tree_vec (n_baseclasses);\n-      for (i = 0; i < n_baseclasses; i++)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  tree old_base_binfo = old_binfo ? BINFO_BASETYPE (old_binfo, i) : 0;\n-\t  BINFO_BASETYPE (binfo, i) = base_binfo;\n-\t  if (old_binfo)\n-\t    {\n-\t      TREE_VIA_PUBLIC (base_binfo) = TREE_VIA_PUBLIC (old_base_binfo);\n-\t      TREE_VIA_PROTECTED (base_binfo) = TREE_VIA_PROTECTED (old_base_binfo);\n-\t      TREE_VIA_VIRTUAL (base_binfo) = TREE_VIA_VIRTUAL (old_base_binfo);\n-\t    }\n-\t}\n-    }\n-  return binfo;\n+  if (binfo && BINFO_BASETYPES (binfo) != NULL_TREE)\n+    BINFO_BASETYPES (new_binfo) = copy_node (BINFO_BASETYPES (binfo));      \n+  return new_binfo;\n }\n \n tree\n@@ -1320,6 +1317,18 @@ is_overloaded_fn (x)\n   return 0;\n }\n \n+int\n+really_overloaded_fn (x)\n+     tree x;\n+{     \n+  if (TREE_CODE (x) == TREE_LIST\n+      && (TREE_CODE (TREE_VALUE (x)) == FUNCTION_DECL\n+\t  || TREE_CODE (TREE_VALUE (x)) == TEMPLATE_DECL))\n+    return 1;\n+\n+  return 0;\n+}\n+\n tree\n get_first_fn (from)\n      tree from;\n@@ -1336,13 +1345,27 @@ tree\n fnaddr_from_vtable_entry (entry)\n      tree entry;\n {\n-  return TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (entry))));\n+  if (flag_vtable_thunks)\n+    {\n+      tree func = entry;\n+      if (TREE_CODE (func) == ADDR_EXPR)\n+\tfunc = TREE_OPERAND (func, 0);\n+      if (TREE_CODE (func) == THUNK_DECL)\n+\treturn DECL_INITIAL (func);\n+      else\n+\treturn entry;\n+    }\n+  else\n+    return TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (entry))));\n }\n \n void\n set_fnaddr_from_vtable_entry (entry, value)\n      tree entry, value;\n {\n+  if (flag_vtable_thunks)\n+    abort ();\n+  else\n   TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (entry)))) = value;\n }\n "}, {"sha": "1271272015506c91acff1ca344e36cfb8921838b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -41,9 +41,6 @@ extern void warning ();\n int mark_addressable ();\n static tree convert_for_assignment ();\n /* static */ tree convert_for_initialization ();\n-int compparms ();\n-static int self_promoting_args_p ();\n-int comp_target_types ();\n extern tree shorten_compare ();\n extern void binary_op_error ();\n static tree pointer_int_sum ();\n@@ -386,7 +383,7 @@ common_type (t1, t2)\n \tif (p1 == NULL_TREE || TREE_VALUE (p1) == void_type_node)\n \t  {\n \t    rval = build_function_type (valtype, p2);\n-\t    if (raises = TYPE_RAISES_EXCEPTIONS (t2))\n+\t    if ((raises = TYPE_RAISES_EXCEPTIONS (t2)))\n \t      rval = build_exception_variant (NULL_TREE, rval, raises);\n \t    return rval;\n \t  }\n@@ -606,7 +603,7 @@ comptypes (type1, type2, strict)\n \t\t\t TYPE_POINTER_TO (TYPE_METHOD_BASETYPE (t1)), strict)\n \t      && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict)\n \t      && compparms (TREE_CHAIN (TYPE_ARG_TYPES (t1)),\n-\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES(t2)), strict));\n+\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t2)), strict));\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       t1 = TREE_TYPE (t1);\n@@ -678,7 +675,7 @@ comp_target_types (ttl, ttr, nptrs)\n     return comp_array_types (comp_target_types, ttl, ttr, 0);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs))\n-      switch (comp_target_parms (TYPE_ARG_TYPES (ttl), TYPE_ARG_TYPES (ttr), 0))\n+      switch (comp_target_parms (TYPE_ARG_TYPES (ttl), TYPE_ARG_TYPES (ttr), 1))\n \t{\n \tcase 0:\n \t  return 0;\n@@ -797,10 +794,10 @@ compparms (parms1, parms2, strict)\n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n-  if (t1 == 0)\n-    return self_promoting_args_p (t2);\n-  if (t2 == 0)\n-    return self_promoting_args_p (t1);\n+  if (strict <= 0 && t1 == 0)\n+\treturn self_promoting_args_p (t2);\n+  if (strict < 0 && t2 == 0)\n+\treturn self_promoting_args_p (t1);\n \n   while (1)\n     {\n@@ -956,7 +953,7 @@ comp_target_parms (parms1, parms2, strict)\n /* Return 1 if PARMS specifies a fixed number of parameters\n    and none of their types is affected by default promotions.  */\n \n-static int\n+int\n self_promoting_args_p (parms)\n      tree parms;\n {\n@@ -2111,7 +2108,6 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n       tree e2;\n       tree e3;\n       tree aref, vtbl;\n-      tree aux_delta;\n \n       /* convert down to the right base, before using the instance. */\n       instance = convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n@@ -2121,7 +2117,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n       vtbl = build (PLUS_EXPR,\n-\t\t    build_pointer_type (build_pointer_type (vtable_entry_type)),\n+\t\t    build_pointer_type (build_pointer_type (memptr_type)),\n \t\t    vtbl, convert (sizetype, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL_PTR);\n       aref = build_array_ref (vtbl, size_binop (MINUS_EXPR,\n@@ -3602,7 +3598,7 @@ build_component_addr (arg, argtype, msg)\n \t baseclasses.  */\n       rval = build1 (NOP_EXPR, argtype,\n \t\t     convert_pointer_to (basetype, rval));\n-      TREE_CONSTANT (rval) == TREE_CONSTANT (TREE_OPERAND (rval, 0));\n+      TREE_CONSTANT (rval) = TREE_CONSTANT (TREE_OPERAND (rval, 0));\n     }\n   else\n     /* This conversion is harmless.  */\n@@ -4935,6 +4931,7 @@ build_c_cast (type, expr)\n   return value;\n }\n \f\n+#if 0\n /* Build an assignment expression of lvalue LHS from value RHS.\n \n    In C++, if the left hand side of the assignment is a REFERENCE_TYPE,\n@@ -4969,7 +4966,6 @@ get_base_ref (type, base_index, expr)\n   return ref;\n }\n \n-#if 0\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n    to combine the old value of LHS with RHS to get the new value.\n@@ -5833,13 +5829,19 @@ language_lvalue_valid (exp)\n static tree\n get_delta_difference (from, to, force)\n      tree from, to;\n+     int force;\n {\n   tree delta = integer_zero_node;\n   tree binfo;\n   \n   if (to == from)\n     return delta;\n \n+  /* Should get_base_distance here, so we can check if any thing along the\n+     path is virtual, and we need to make sure we stay\n+     inside the real binfos when going through virtual bases.\n+     Maybe we should replace virtual bases with\n+     binfo_member (...CLASSTYPE_VBASECLASSES...)...  (mrs) */\n   binfo = get_binfo (from, to, 1);\n   if (binfo == error_mark_node)\n     {\n@@ -5867,7 +5869,7 @@ get_delta_difference (from, to, force)\n \t}\n       if (TREE_VIA_VIRTUAL (binfo))\n \t{\n-\t  warning (\"pointer to member conversion from virtual base class will only work if your very careful\");\n+\t  warning (\"pointer to member conversion to virtual base class will only work if your very careful\");\n \t}\n       return fold (size_binop (MINUS_EXPR,\n \t\t\t       integer_zero_node,\n@@ -6815,10 +6817,8 @@ c_expand_return (retval)\n     {\n       tree whats_returned = TREE_OPERAND (retval, 0);\n \n-      if (TREE_CODE (whats_returned) == TREE_LIST)\n-\twhats_returned = TREE_VALUE (whats_returned);\n-\n-      if (DECL_NAME (whats_returned)\n+      if (TREE_CODE (whats_returned) == VAR_DECL\n+\t  && DECL_NAME (whats_returned)\n \t  && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n \t  && !TREE_STATIC (whats_returned))\n \tcp_warning_at (\"address of local variable `%D' returned\", whats_returned);"}, {"sha": "19c8b735974348c95929a456dbbcad06b7961da8", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8926095fe7324b246adcf31dc78297d8963ed38a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8926095fe7324b246adcf31dc78297d8963ed38a", "patch": "@@ -60,7 +60,7 @@ binfo_or_else (parent_or_type, type)\n   tree binfo;\n   if (TYPE_MAIN_VARIANT (parent_or_type) == TYPE_MAIN_VARIANT (type))\n     return parent_or_type;\n-  if (binfo = get_binfo (parent_or_type, TYPE_MAIN_VARIANT (type), 0))\n+  if ((binfo = get_binfo (parent_or_type, TYPE_MAIN_VARIANT (type), 0)))\n     {\n       if (binfo == error_mark_node)\n \treturn NULL_TREE;\n@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 355.  */\n+/* First used: 0 (reserved), Last used: 355.  Free: 180.  */\n \n static int abortcount = 0;\n \n@@ -434,9 +434,10 @@ initializer_constant_valid_p (value)\n \t  return 2;\n \treturn 0;\n       }\n-    }\n \n-  return 0;\n+    default:\n+      return 0;\n+    }\n }\n \f\n /* Perform appropriate conversions on the initial value of a variable,\n@@ -583,14 +584,20 @@ store_init_value (decl, init)\n   else if (TREE_STATIC (decl)\n \t   && (! TREE_CONSTANT (value)\n \t       || ! initializer_constant_valid_p (value)\n+#if 0\n+\t       /* A STATIC PUBLIC int variable doesn't have to be\n+\t\t  run time inited when doing pic.  (mrs) */\n \t       /* Since ctors and dtors are the only things that can\n \t\t  reference vtables, and they are always written down\n \t\t  the the vtable definition, we can leave the\n \t\t  vtables in initialized data space.\n \t\t  However, other initialized data cannot be initialized\n \t\t  this way.  Instead a global file-level initializer\n \t\t  must do the job.  */\n-\t       || (flag_pic && !DECL_VIRTUAL_P (decl) && TREE_PUBLIC (decl))))\n+\t       || (flag_pic && !DECL_VIRTUAL_P (decl) && TREE_PUBLIC (decl))\n+#endif\n+\t       ))\n+\n     return value;\n   else\n     {\n@@ -1283,7 +1290,7 @@ build_x_arrow (datum)\n \n   if (IS_AGGR_TYPE (type) && TYPE_OVERLOADS_ARROW (type))\n     {\n-      while (rval = build_opfncall (COMPONENT_REF, LOOKUP_NORMAL, rval, NULL_TREE, NULL_TREE))\n+      while ((rval = build_opfncall (COMPONENT_REF, LOOKUP_NORMAL, rval, NULL_TREE, NULL_TREE)))\n \t{\n \t  if (rval == error_mark_node)\n \t    return error_mark_node;"}]}