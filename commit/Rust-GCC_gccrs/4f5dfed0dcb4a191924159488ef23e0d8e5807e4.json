{"sha": "4f5dfed0dcb4a191924159488ef23e0d8e5807e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY1ZGZlZDBkY2I0YTE5MTkyNDE1OTQ4OGVmMjNlMGQ4ZTU4MDdlNA==", "commit": {"author": {"name": "Josh Conner", "email": "jconner@apple.com", "date": "2005-05-13T21:13:17Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-05-13T21:13:17Z"}, "message": "arm.c (arm_size_return_regs): New.\n\n2005-05-13  Josh Conner  <jconner@apple.com>\n\n\t* config/arm/arm.c (arm_size_return_regs): New.\n\t(thumb_unexpanded_epilogue): replace in-line calculation\n\tof return registers with call to arm_size_return_regs.\n\t(use_return_insn): Include test of which registers are\n\tbeing used to hold return values, to accommodate\n\tvector return values.\n\nFrom-SVN: r99679", "tree": {"sha": "55c81a3f435b26340d07ba599f4997e712d1c6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55c81a3f435b26340d07ba599f4997e712d1c6fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f5dfed0dcb4a191924159488ef23e0d8e5807e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f5dfed0dcb4a191924159488ef23e0d8e5807e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f5dfed0dcb4a191924159488ef23e0d8e5807e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f5dfed0dcb4a191924159488ef23e0d8e5807e4/comments", "author": null, "committer": null, "parents": [{"sha": "9c309ac9a4e9d7f134c9d1714a355a20baa5dbdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c309ac9a4e9d7f134c9d1714a355a20baa5dbdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c309ac9a4e9d7f134c9d1714a355a20baa5dbdb"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "24513c8eb8c8a636ff55ebea3ddf2700bcb0cbce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5dfed0dcb4a191924159488ef23e0d8e5807e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5dfed0dcb4a191924159488ef23e0d8e5807e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f5dfed0dcb4a191924159488ef23e0d8e5807e4", "patch": "@@ -1,3 +1,12 @@\n+2005-05-13  Josh Conner  <jconner@apple.com>\n+\n+\t* config/arm/arm.c (arm_size_return_regs): New.\n+\t(thumb_unexpanded_epilogue): replace in-line calculation\n+\tof return registers with call to arm_size_return_regs.\n+\t(use_return_insn): Include test of which registers are\n+\tbeing used to hold return values, to accommodate\n+\tvector return values.\n+\n 2005-05-11  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/sysv4.opt (mlittle): Handle."}, {"sha": "1c0f60fa9ccdd60034c94fb75cebe7cbc9460e05", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5dfed0dcb4a191924159488ef23e0d8e5807e4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5dfed0dcb4a191924159488ef23e0d8e5807e4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4f5dfed0dcb4a191924159488ef23e0d8e5807e4", "patch": "@@ -73,6 +73,7 @@ static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n static rtx emit_sfm (int, int);\n+static int arm_size_return_regs (void);\n #ifndef AOF_ASSEMBLER\n static bool arm_assemble_integer (rtx, unsigned int, int);\n #endif\n@@ -1465,9 +1466,11 @@ use_return_insn (int iscond, rtx sibling)\n       if (!call_used_regs[3])\n \treturn 0;\n \n-      /* ... that it isn't being used for a return value (always true\n-\t until we implement return-in-regs), or for a tail-call\n-\t argument ...  */\n+      /* ... that it isn't being used for a return value ... */\n+      if (arm_size_return_regs () >= (4 * UNITS_PER_WORD))\n+\treturn 0;\n+\n+      /* ... or for a tail-call argument ...  */\n       if (sibling)\n \t{\n \t  gcc_assert (GET_CODE (sibling) == CALL_INSN);\n@@ -9851,6 +9854,20 @@ emit_multi_reg_push (unsigned long mask)\n   return par;\n }\n \n+/* Calculate the size of the return value that is passed in registers.  */\n+static int\n+arm_size_return_regs (void)\n+{\n+  enum machine_mode mode;\n+\n+  if (current_function_return_rtx != 0)\n+    mode = GET_MODE (current_function_return_rtx);\n+  else\n+    mode = DECL_MODE (DECL_RESULT (current_function_decl));\n+\n+  return GET_MODE_SIZE (mode);\n+}\n+\n static rtx\n emit_sfm (int base_reg, int count)\n {\n@@ -12920,13 +12937,7 @@ thumb_unexpanded_epilogue (void)\n      This is more reliable that examining regs_ever_live[] because that\n      will be set if the register is ever used in the function, not just if\n      the register is used to hold a return value.  */\n-\n-  if (current_function_return_rtx != 0)\n-    mode = GET_MODE (current_function_return_rtx);\n-  else\n-    mode = DECL_MODE (DECL_RESULT (current_function_decl));\n-\n-  size = GET_MODE_SIZE (mode);\n+  size = arm_size_return_regs ();\n \n   /* The prolog may have pushed some high registers to use as\n      work registers.  e.g. the testsuite file:"}]}