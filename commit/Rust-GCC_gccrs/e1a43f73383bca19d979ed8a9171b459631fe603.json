{"sha": "e1a43f73383bca19d979ed8a9171b459631fe603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFhNDNmNzMzODNiY2ExOWQ5NzllZDhhOTE3MWI0NTk2MzFmZTYwMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1996-01-20T01:41:05Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1996-01-20T01:41:05Z"}, "message": "Merged in a bunch of stuff related to store_constructor.  See ChangeLog.\n\nFrom-SVN: r11076", "tree": {"sha": "e80053468909653c97acd1d57f2d9cbac975584a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e80053468909653c97acd1d57f2d9cbac975584a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1a43f73383bca19d979ed8a9171b459631fe603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a43f73383bca19d979ed8a9171b459631fe603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1a43f73383bca19d979ed8a9171b459631fe603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a43f73383bca19d979ed8a9171b459631fe603/comments", "author": null, "committer": null, "parents": [{"sha": "69b4bf984720645e499d2e60508e00618b53c6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b4bf984720645e499d2e60508e00618b53c6fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b4bf984720645e499d2e60508e00618b53c6fa"}], "stats": {"total": 365, "additions": 253, "deletions": 112}, "files": [{"sha": "be7c78ccb7ec5ba11cf67144ec741e8904e47d80", "filename": "gcc/expr.c", "status": "modified", "additions": 253, "deletions": 112, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1a43f73383bca19d979ed8a9171b459631fe603/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1a43f73383bca19d979ed8a9171b459631fe603/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e1a43f73383bca19d979ed8a9171b459631fe603", "patch": "@@ -167,7 +167,7 @@ static void clear_by_pieces_1\tPROTO((rtx (*) (), enum machine_mode,\n \t\t\t\t       struct clear_by_pieces *));\n static int is_zeros_p\t\tPROTO((tree));\n static int mostly_zeros_p\tPROTO((tree));\n-static void store_constructor\tPROTO((tree, rtx));\n+static void store_constructor\tPROTO((tree, rtx, int));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int, int));\n static int get_inner_unaligned_p PROTO((tree));\n@@ -3212,6 +3212,8 @@ is_zeros_p (exp)\n       return REAL_VALUES_EQUAL (TREE_REAL_CST (exp), dconst0);\n \n     case CONSTRUCTOR:\n+      if (TREE_TYPE (exp) && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n+\treturn CONSTRUCTOR_ELTS (exp) == NULL_TREE;\n       for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n \tif (! is_zeros_p (TREE_VALUE (elt)))\n \t  return 0;\n@@ -3228,28 +3230,72 @@ static int\n mostly_zeros_p (exp)\n      tree exp;\n {\n-  tree elt;\n-  int elts = 0, zeros = 0;\n-\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n     {\n-      for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt), elts++)\n-\tif (mostly_zeros_p (TREE_VALUE (elt)))\n-\t  zeros++;\n+      int elts = 0, zeros = 0;\n+      tree elt = CONSTRUCTOR_ELTS (exp);\n+      if (TREE_TYPE (exp) && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n+\t{\n+\t  /* If there are no ranges of true bits, it is all zero.  */\n+\t  return elt == NULL_TREE;\n+\t}\n+      for (; elt; elt = TREE_CHAIN (elt))\n+\t{\n+\t  /* We do not handle the case where the index is a RANGE_EXPR,\n+\t     so the statistic will be somewhat inaccurate.\n+\t     We do make a more accurate count in store_constructor itself,\n+\t     so since this function is only used for nested array elements,\n+\t     this should be close enough. */\n+\t  if (mostly_zeros_p (TREE_VALUE (elt)))\n+\t    zeros++;\n+\t  elts++;\n+\t}\n \n       return 4 * zeros >= 3 * elts;\n     }\n \n   return is_zeros_p (exp);\n }\n \f\n+/* Helper function for store_constructor.\n+   TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.\n+   TYPE is the type of the CONSTRUCTOR, not the element type.\n+   CLEARED is as for store_constructor.  */\n+\n+static void\n+store_constructor_field (target, bitsize, bitpos,\n+\t\t\t mode, exp, type, cleared)\n+     rtx target;\n+     int bitsize, bitpos;\n+     enum machine_mode mode;\n+     tree exp, type;\n+     int cleared;\n+{\n+  if (TREE_CODE (exp) == CONSTRUCTOR\n+      && (bitpos % BITS_PER_UNIT) == 0)\n+    {\n+      bitpos /= BITS_PER_UNIT;\n+      store_constructor (exp,\n+\t\t\t change_address (target, VOIDmode,\n+\t\t\t\t\t plus_constant (XEXP (target, 0),\n+\t\t\t\t\t\t\tbitpos)),\n+\t\t\t cleared);\n+    }\n+  else\n+    store_field (target, bitsize, bitpos, mode, exp,\n+\t\t VOIDmode, 0, TYPE_ALIGN (type) / BITS_PER_UNIT,\n+\t\t int_size_in_bytes (type));\n+}\n+\n /* Store the value of constructor EXP into the rtx TARGET.\n-   TARGET is either a REG or a MEM.  */\n+   TARGET is either a REG or a MEM.\n+   CLEARED is true if TARGET is known to have been zero'd. */\n \n static void\n-store_constructor (exp, target)\n+store_constructor (exp, target, cleared)\n      tree exp;\n      rtx target;\n+     int cleared;\n {\n   tree type = TREE_TYPE (exp);\n \n@@ -3261,7 +3307,7 @@ store_constructor (exp, target)\n   if (GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER)\n     {\n       rtx temp = gen_reg_rtx (GET_MODE (target));\n-      store_constructor (exp, temp);\n+      store_constructor (exp, temp, 0);\n       emit_move_insn (target, temp);\n       return;\n     }\n@@ -3271,7 +3317,6 @@ store_constructor (exp, target)\n       || TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n       register tree elt;\n-      int cleared = CONSTRUCTOR_TARGET_CLEARED_P (exp);\n \n       /* Inform later passes that the whole union value is dead.  */\n       if (TREE_CODE (type) == UNION_TYPE\n@@ -3327,14 +3372,8 @@ store_constructor (exp, target)\n \t  if (field == 0)\n \t    continue;\n \n-\t  if (cleared)\n-\t    {\n-\t      if (is_zeros_p (TREE_VALUE (elt)))\n-\t\tcontinue;\n-\n-\t      else if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n-\t\tCONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = cleared;\n-\t    }\n+\t  if (cleared && is_zeros_p (TREE_VALUE (elt)))\n+\t    continue;\n \n \t  bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n \t  unsignedp = TREE_UNSIGNED (field);\n@@ -3374,7 +3413,6 @@ store_constructor (exp, target)\n \t\t\t\t  gen_rtx (PLUS, ptr_mode, XEXP (to_rtx, 0),\n \t\t\t\t\t   force_reg (ptr_mode, offset_rtx)));\n \t    }\n-\n \t  if (TREE_READONLY (field))\n \t    {\n \t      if (GET_CODE (to_rtx) == MEM)\n@@ -3383,39 +3421,65 @@ store_constructor (exp, target)\n \t      RTX_UNCHANGING_P (to_rtx) = 1;\n \t    }\n \n-\t  store_field (to_rtx, bitsize, bitpos, mode, TREE_VALUE (elt),\n-\t\t       /* The alignment of TARGET is\n-\t\t\t  at least what its type requires.  */\n-\t\t       VOIDmode, 0,\n-\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT,\n-\t\t       int_size_in_bytes (type));\n-\n-\t  if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n-\t    CONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = 0;\n+\t  store_constructor_field (to_rtx, bitsize, bitpos,\n+\t\t\t\t   mode, TREE_VALUE (elt), type, cleared);\n \t}\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       register tree elt;\n       register int i;\n+      int need_to_clear;\n       tree domain = TYPE_DOMAIN (type);\n       HOST_WIDE_INT minelt = TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain));\n       HOST_WIDE_INT maxelt = TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain));\n       tree elttype = TREE_TYPE (type);\n-      int cleared = CONSTRUCTOR_TARGET_CLEARED_P (exp);\n-\n-      /* If the constructor has fewer fields than the structure,\n-\t clear the whole structure first.  Similarly if this this is\n-\t static constructor of a non-BLKmode object.  */\n \n-      if (list_length (CONSTRUCTOR_ELTS (exp)) < maxelt - minelt + 1\n-\t  || mostly_zeros_p (exp)\n-\t  || (GET_CODE (target) == REG && TREE_STATIC (exp)))\n+      /* If the constructor has fewer elements than the array,\n+         clear the whole array first.  Similarly if this this is\n+         static constructor of a non-BLKmode object.  */\n+      if (cleared || (GET_CODE (target) == REG && TREE_STATIC (exp)))\n+\tneed_to_clear = 1;\n+      else\n+\t{\n+\t  HOST_WIDE_INT count = 0, zero_count = 0;\n+\t  need_to_clear = 0;\n+\t  /* This loop is a more accurate version of the loop in\n+\t     mostly_zeros_p (it handles RANGE_EXPR in an index).\n+\t     It is also needed to check for missing elements.  */\n+\t  for (elt = CONSTRUCTOR_ELTS (exp);\n+\t       elt != NULL_TREE;\n+\t       elt = TREE_CHAIN (elt), i++)\n+\t    {\n+\t      tree index = TREE_PURPOSE (elt);\n+\t      HOST_WIDE_INT this_node_count;\n+\t      if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n+\t\t{\n+\t\t  tree lo_index = TREE_OPERAND (index, 0);\n+\t\t  tree hi_index = TREE_OPERAND (index, 1);\n+\t\t  if (TREE_CODE (lo_index) != INTEGER_CST\n+\t\t      || TREE_CODE (hi_index) != INTEGER_CST)\n+\t\t    {\n+\t\t      need_to_clear = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t  this_node_count = TREE_INT_CST_LOW (hi_index)\n+\t\t    - TREE_INT_CST_LOW (lo_index) + 1;\n+\t\t}\n+\t      else\n+\t\tthis_node_count = 1;\n+\t      count += this_node_count;\n+\t      if (mostly_zeros_p (TREE_VALUE (elt)))\n+\t\tzero_count += this_node_count;\n+\t    }\n+\t  if (4 * zero_count >= 3 * count)\n+\t    need_to_clear = 1;\n+\t}\n+      if (need_to_clear)\n \t{\n \t  if (! cleared)\n \t    clear_storage (target, expr_size (exp),\n \t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n-\n \t  cleared = 1;\n \t}\n       else\n@@ -3433,38 +3497,123 @@ store_constructor (exp, target)\n \t  int bitsize;\n \t  int bitpos;\n \t  int unsignedp;\n+\t  tree value = TREE_VALUE (elt);\n \t  tree index = TREE_PURPOSE (elt);\n \t  rtx xtarget = target;\n \n-\t  if (cleared)\n-\t    {\n-\t      if (is_zeros_p (TREE_VALUE (elt)))\n-\t\tcontinue;\n-\n-\t      else if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n-\t\tCONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = cleared;\n-\t    }\n+\t  if (cleared && is_zeros_p (value))\n+\t    continue;\n \n \t  mode = TYPE_MODE (elttype);\n \t  bitsize = GET_MODE_BITSIZE (mode);\n \t  unsignedp = TREE_UNSIGNED (elttype);\n \n-\t  if ((index != 0 && TREE_CODE (index) != INTEGER_CST)\n+\t  if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n+\t    {\n+\t      tree lo_index = TREE_OPERAND (index, 0);\n+\t      tree hi_index = TREE_OPERAND (index, 1);\n+\t      rtx index_r, pos_rtx, addr, hi_r, loop_top, loop_end;\n+\t      struct nesting *loop;\n+\t\ttree position;\n+\n+\t      if (TREE_CODE (lo_index) == INTEGER_CST\n+\t\t  && TREE_CODE (hi_index) == INTEGER_CST)\n+\t\t{\n+\t\t  HOST_WIDE_INT lo = TREE_INT_CST_LOW (lo_index);\n+\t\t  HOST_WIDE_INT hi = TREE_INT_CST_LOW (hi_index);\n+\t\t  HOST_WIDE_INT count = hi - lo + 1;\n+\n+\t\t  /* If the range is constant and \"small\", unroll the loop.\n+\t\t     We must also use store_field if the target is not MEM. */\n+\t\t  if (GET_CODE (target) != MEM\n+\t\t      || count <= 2\n+\t\t      || (TREE_CODE (TYPE_SIZE (elttype)) == INTEGER_CST\n+\t\t\t  && TREE_INT_CST_LOW (TYPE_SIZE (elttype)) * count\n+\t\t\t  <= 40 * 8))\n+\t\t    {\n+\t\t      lo -= minelt;  hi -= minelt;\n+\t\t      for (; lo <= hi; lo++)\n+\t\t\t{\n+\t\t\t  bitpos = lo * TREE_INT_CST_LOW (TYPE_SIZE (elttype));\n+\t\t\t  store_constructor_field (target, bitsize, bitpos,\n+\t\t\t\t\t\t   mode, value, type, cleared);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  hi_r = expand_expr (hi_index, NULL_RTX, VOIDmode, 0);\n+\t\t  loop_top = gen_label_rtx ();\n+\t\t  loop_end = gen_label_rtx ();\n+\n+\t\t  unsignedp = TREE_UNSIGNED (domain);\n+\n+\t\t  index = build_decl (VAR_DECL, NULL_TREE, domain);\n+\n+\t\t  DECL_RTL (index) = index_r\n+\t\t    = gen_reg_rtx (promote_mode (domain, DECL_MODE (index),\n+\t\t\t\t\t\t &unsignedp, 0));\n+\n+\t\t  if (TREE_CODE (value) == SAVE_EXPR\n+\t\t      && SAVE_EXPR_RTL (value) == 0)\n+\t\t    {\n+\t\t      /* Make sure value gets expanded once before the loop. */\n+\t\t      expand_expr (value, const0_rtx, VOIDmode, 0);\n+\t\t      emit_queue ();\n+\t\t    }\n+\t\t  store_expr (lo_index, index_r, 0);\n+\t\t  loop = expand_start_loop (0);\n+\n+\t\t  /* Assign value to element index. */\n+\t\t  position = size_binop (EXACT_DIV_EXPR, TYPE_SIZE (elttype),\n+\t\t\t\t\t size_int (BITS_PER_UNIT));\n+\t\t  position = size_binop (MULT_EXPR,\n+\t\t\t\t\t size_binop (MINUS_EXPR, index,\n+\t\t\t\t\t\t     TYPE_MIN_VALUE (domain)),\n+\t\t\t\t\t position);\n+\t\t  pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n+\t\t  addr = gen_rtx (PLUS, Pmode, XEXP (target, 0), pos_rtx);\n+\t\t  xtarget = change_address (target, mode, addr);\n+\t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n+\t\t    store_constructor (exp, xtarget, cleared);\n+\t\t  else\n+\t\t    store_expr (value, xtarget, 0);\n+\n+\t\t  expand_exit_loop_if_false (loop,\n+\t\t\t\t\t     build (LT_EXPR, integer_type_node,\n+\t\t\t\t\t\t    index, hi_index));\n+\n+\t\t  expand_increment (build (PREINCREMENT_EXPR,\n+\t\t\t\t\t   TREE_TYPE (index),\n+\t\t\t\t\t   index, integer_one_node), 0);\n+\t\t  expand_end_loop ();\n+\t\t  emit_label (loop_end);\n+\n+\t\t  /* Needed by stupid register allocation. to extend the\n+\t\t     lifetime of pseudo-regs used by target past the end\n+\t\t     of the loop.  */\n+\t\t  emit_insn (gen_rtx (USE, GET_MODE (target), target));\n+\t\t}\n+\t    }\n+\t  else if ((index != 0 && TREE_CODE (index) != INTEGER_CST)\n \t      || TREE_CODE (TYPE_SIZE (elttype)) != INTEGER_CST)\n \t    {\n-\t      rtx pos_rtx, addr, xtarget;\n+\t      rtx pos_rtx, addr;\n \t      tree position;\n \n \t      if (index == 0)\n \t\tindex = size_int (i);\n \n+\t      if (minelt)\n+\t\tindex = size_binop (MINUS_EXPR, index,\n+\t\t\t\t    TYPE_MIN_VALUE (domain));\n \t      position = size_binop (EXACT_DIV_EXPR, TYPE_SIZE (elttype),\n \t\t\t\t     size_int (BITS_PER_UNIT));\n \t      position = size_binop (MULT_EXPR, index, position);\n \t      pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n \t      addr = gen_rtx (PLUS, Pmode, XEXP (target, 0), pos_rtx);\n \t      xtarget = change_address (target, mode, addr);\n-\t      store_expr (TREE_VALUE (elt), xtarget, 0);\n+\t      store_expr (value, xtarget, 0);\n \t    }\n \t  else\n \t    {\n@@ -3473,28 +3622,18 @@ store_constructor (exp, target)\n \t\t\t  * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n \t      else\n \t\tbitpos = (i * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n-\n-\t      store_field (xtarget, bitsize, bitpos, mode, TREE_VALUE (elt),\n-\t\t\t   /* The alignment of TARGET is\n-\t\t\t      at least what its type requires.  */\n-\t\t\t   VOIDmode, 0,\n-\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT,\n-\t\t\t   int_size_in_bytes (type));\n+\t      store_constructor_field (target, bitsize, bitpos,\n+\t\t\t\t       mode, value, type, cleared);\n \t    }\n-\n-\t  if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n-\t    CONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = 0;\n \t}\n     }\n   /* set constructor assignments */\n   else if (TREE_CODE (type) == SET_TYPE)\n     {\n-      tree elt;\n+      tree elt = CONSTRUCTOR_ELTS (exp);\n       rtx xtarget = XEXP (target, 0);\n       int set_word_size = TYPE_ALIGN (type);\n-      int nbytes = int_size_in_bytes (type);\n-      tree non_const_elements;\n-      int need_to_clear_first;\n+      int nbytes = int_size_in_bytes (type), nbits;\n       tree domain = TYPE_DOMAIN (type);\n       tree domain_min, domain_max, bitlength;\n \n@@ -3509,42 +3648,38 @@ store_constructor (exp, target)\n \t bzero/memset), and set the bits we want. */\n        \n       /* Check for all zeros. */\n-      if (CONSTRUCTOR_ELTS (exp) == NULL_TREE)\n+      if (elt == NULL_TREE)\n \t{\n-\t  clear_storage (target, expr_size (exp),\n-\t\t\t TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\t  if (!cleared)\n+\t    clear_storage (target, expr_size (exp),\n+\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n \t  return;\n \t}\n \n-      if (nbytes < 0)\n-\tabort ();\n-\n       domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));\n       domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));\n       bitlength = size_binop (PLUS_EXPR,\n \t\t\t      size_binop (MINUS_EXPR, domain_max, domain_min),\n \t\t\t      size_one_node);\n \n-      /* Check for range all ones, or at most a single range.\n-       (This optimization is only a win for big sets.) */\n-      if (GET_MODE (target) == BLKmode && nbytes > 16\n-\t  && TREE_CHAIN (CONSTRUCTOR_ELTS (exp)) == NULL_TREE)\n-\t{\n-\t  need_to_clear_first = 1;\n-\t  non_const_elements = CONSTRUCTOR_ELTS (exp);\n-\t}\n-      else\n+      if (nbytes < 0 || TREE_CODE (bitlength) != INTEGER_CST)\n+\tabort ();\n+      nbits = TREE_INT_CST_LOW (bitlength);\n+\n+      /* For \"small\" sets, or \"medium-sized\" (up to 32 bytes) sets that\n+\t are \"complicated\" (more than one range), initialize (the\n+\t constant parts) by copying from a constant.  */\t \n+      if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD\n+\t  || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))\n \t{\n-\t  int nbits = nbytes * BITS_PER_UNIT;\n \t  int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));\n \t  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);\n \t  char *bit_buffer = (char*) alloca (nbits);\n \t  HOST_WIDE_INT word = 0;\n \t  int bit_pos = 0;\n \t  int ibit = 0;\n \t  int offset = 0;  /* In bytes from beginning of set. */\n-\t  non_const_elements = get_set_constructor_bits (exp,\n-\t\t\t\t\t\t\t bit_buffer, nbits);\n+\t  elt = get_set_constructor_bits (exp, bit_buffer, nbits);\n \t  for (;;)\n \t    {\n \t      if (bit_buffer[ibit])\n@@ -3557,30 +3692,47 @@ store_constructor (exp, target)\n \t      bit_pos++;  ibit++;\n \t      if (bit_pos >= set_word_size || ibit == nbits)\n \t\t{\n-\t\t  rtx datum = GEN_INT (word);\n-\t\t  rtx to_rtx;\n-\t\t  /* The assumption here is that it is safe to use XEXP if\n-\t\t     the set is multi-word, but not if it's single-word. */\n-\t\t  if (GET_CODE (target) == MEM)\n-\t\t    to_rtx = change_address (target, mode,\n-\t\t\t\t\t     plus_constant (XEXP (target, 0),\n-\t\t\t\t\t\t\t    offset));\n-\t\t  else if (offset == 0) \n-\t\t    to_rtx = target;\n-\t\t  else\n-\t\t    abort ();\n-\t\t  emit_move_insn (to_rtx, datum);\n+\t\t  if (word != 0 || ! cleared)\n+\t\t    {\n+\t\t      rtx datum = GEN_INT (word);\n+\t\t      rtx to_rtx;\n+\t\t      /* The assumption here is that it is safe to use XEXP if\n+\t\t\t the set is multi-word, but not if it's single-word. */\n+\t\t      if (GET_CODE (target) == MEM)\n+\t\t\t{\n+\t\t\t  to_rtx = plus_constant (XEXP (target, 0), offset);\n+\t\t\t  to_rtx = change_address (target, mode, to_rtx);\n+\t\t\t}\n+\t\t      else if (offset == 0) \n+\t\t\tto_rtx = target;\n+\t\t      else\n+\t\t\tabort ();\n+\t\t      emit_move_insn (to_rtx, datum);\n+\t\t    }\n \t\t  if (ibit == nbits)\n \t\t    break;\n \t\t  word = 0;\n \t\t  bit_pos = 0;\n \t\t  offset += set_word_size / BITS_PER_UNIT;\n \t\t}\n \t    }\n-\t  need_to_clear_first = 0;\n \t}\n-\n-      for (elt = non_const_elements; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n+      else if (!cleared)\n+\t{\n+\t  /* Don't bother clearing storage if the set is all ones. */\n+\t  if (TREE_CHAIN (elt) != NULL_TREE\n+\t      || (TREE_PURPOSE (elt) == NULL_TREE\n+\t\t  ? nbits != 1\n+\t\t  : (TREE_CODE (TREE_VALUE (elt)) != INTEGER_CST\n+\t\t     || TREE_CODE (TREE_PURPOSE (elt)) != INTEGER_CST\n+\t\t     || (TREE_INT_CST_LOW (TREE_VALUE (elt))\n+\t\t\t - TREE_INT_CST_LOW (TREE_PURPOSE (elt)) + 1\n+\t\t\t != nbits))))\n+\t    clear_storage (target, expr_size (exp),\n+\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\t}\n+\t  \n+      for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n \t{\n \t  /* start of range of element or NULL */\n \t  tree startbit = TREE_PURPOSE (elt);\n@@ -3629,17 +3781,12 @@ store_constructor (exp, target)\n \t  if (TREE_CODE (startbit) == INTEGER_CST\n \t      && TREE_CODE (endbit) == INTEGER_CST\n \t      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n-\t      && (endb = TREE_INT_CST_LOW (endbit)) % BITS_PER_UNIT == 0)\n+\t      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)\n \t    {\n-\t\t\n-\t      if (need_to_clear_first\n-\t\t  && endb - startb != nbytes * BITS_PER_UNIT)\n-\t\tclear_storage (target, expr_size (exp),\n-\t\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT);\n-\t      need_to_clear_first = 0;\n \t      emit_library_call (memset_libfunc, 0,\n \t\t\t\t VOIDmode, 3,\n-\t\t\t\t plus_constant (XEXP (targetx, 0), startb),\n+\t\t\t\t plus_constant (XEXP (targetx, 0),\n+\t\t\t\t\t\tstartb / BITS_PER_UNIT),\n \t\t\t\t Pmode,\n \t\t\t\t constm1_rtx, TYPE_MODE (integer_type_node),\n \t\t\t\t GEN_INT ((endb - startb) / BITS_PER_UNIT),\n@@ -3648,12 +3795,6 @@ store_constructor (exp, target)\n \t  else\n #endif\n \t    {\n-\t      if (need_to_clear_first)\n-\t\t{\n-\t\t  clear_storage (target, expr_size (exp),\n-\t\t\t\t TYPE_ALIGN (type) / BITS_PER_UNIT);\n-\t\t  need_to_clear_first = 0;\n-\t\t}\n \t      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__setbits\"),\n \t\t\t\t 0, VOIDmode, 4, XEXP (targetx, 0), Pmode,\n \t\t\t\t bitlength_rtx, TYPE_MODE (sizetype),\n@@ -4884,7 +5025,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      RTX_UNCHANGING_P (target) = 1;\n \t    }\n \n-\t  store_constructor (exp, target);\n+\t  store_constructor (exp, target, 0);\n \t  return target;\n \t}\n "}]}