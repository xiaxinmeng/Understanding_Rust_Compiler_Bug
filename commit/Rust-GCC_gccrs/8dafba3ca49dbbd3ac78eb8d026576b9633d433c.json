{"sha": "8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRhZmJhM2NhNDlkYmJkM2FjNzhlYjhkMDI2NTc2Yjk2MzNkNDMzYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-09-05T04:24:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-09-05T04:24:30Z"}, "message": "cgraph.c (cgraph_mark_reachable_node): Split out from ...\n\n        * cgraph.c (cgraph_mark_reachable_node): Split out from ...\n        (cgraph_mark_needed_node): Remove needed argument.\n        * cgraph.h: Update to match.\n        * cgraphunit.c (decide_is_function_needed): Split out from ...\n        (cgraph_finalize_function): Reorg.  Avoid deferred_inline_function\n        if we generated the function.\n        (record_call_1): Update for cgraph_mark_reachable_node.\n        * varasm.c (mark_referenced): Likewise.\n        * objc/objc-act.c (mark_referenced_methods): Likewise.\n\n        * decl2.c (mark_member_pointers_and_eh_handlers): Update for\n        change in cgraph_mark_needed_node arguments.\n\nFrom-SVN: r71104", "tree": {"sha": "e52f1fb527a3257f89b40c552bfaabe7263e2310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e52f1fb527a3257f89b40c552bfaabe7263e2310"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/comments", "author": null, "committer": null, "parents": [{"sha": "dd37c5a069e7520f2583ea70f58237de7b90e6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd37c5a069e7520f2583ea70f58237de7b90e6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd37c5a069e7520f2583ea70f58237de7b90e6e2"}], "stats": {"total": 160, "additions": 110, "deletions": 50}, "files": [{"sha": "92437ba59e877cabbb5e0e8179857ffebb45aad2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -1,3 +1,15 @@\n+2003-09-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* cgraph.c (cgraph_mark_reachable_node): Split out from ...\n+\t(cgraph_mark_needed_node): Remove needed argument.\n+\t* cgraph.h: Update to match.\n+\t* cgraphunit.c (decide_is_function_needed): Split out from ...\n+\t(cgraph_finalize_function): Reorg.  Avoid deferred_inline_function\n+\tif we generated the function.\n+\t(record_call_1): Update for cgraph_mark_reachable_node.\n+\t* varasm.c (mark_referenced): Likewise.\n+\t* objc/objc-act.c (mark_referenced_methods): Likewise.\n+\n 2003-09-04  DJ Delorie  <dj@redhat.com>\n \n \t* targhooks.c: Add comment explaining the migration process."}, {"sha": "8b4c0ccf13d39cbaf26e94b19f3a07865eea4852", "filename": "gcc/cgraph.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -234,14 +234,11 @@ cgraph_remove_node (struct cgraph_node *node)\n   /* Do not free the structure itself so the walk over chain can continue.  */\n }\n \n-/* Notify finalize_compilation_unit that given node is reachable\n-   or needed.  */\n+/* Notify finalize_compilation_unit that given node is reachable.  */\n+\n void\n-cgraph_mark_needed_node (struct cgraph_node *node, int needed)\n+cgraph_mark_reachable_node (struct cgraph_node *node)\n {\n-  if (needed)\n-    node->needed = 1;\n-\n   if (!node->reachable && DECL_SAVED_TREE (node->decl))\n     {\n       node->reachable = 1;\n@@ -257,11 +254,20 @@ cgraph_mark_needed_node (struct cgraph_node *node, int needed)\n \n \t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n \t    if (!node2->reachable)\n-\t      cgraph_mark_needed_node (node2, 0);\n+\t      cgraph_mark_reachable_node (node2);\n \t}\n     }\n }\n \n+/* Likewise indicate that a node is needed, i.e. reachable via some\n+   external means.  */\n+\n+void\n+cgraph_mark_needed_node (struct cgraph_node *node)\n+{\n+  node->needed = 1;\n+  cgraph_mark_reachable_node (node);\n+}\n \n /* Record call from CALLER to CALLEE  */\n "}, {"sha": "aaa09a201e8858b6874bce7f45bb06beca3fb43d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -173,7 +173,8 @@ void cgraph_finalize_function (tree, tree);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_create_edges (tree, tree);\n void cgraph_optimize (void);\n-void cgraph_mark_needed_node (struct cgraph_node *, int);\n+void cgraph_mark_needed_node (struct cgraph_node *);\n+void cgraph_mark_reachable_node (struct cgraph_node *);\n bool cgraph_inline_p (tree, tree);\n \n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "1476c8b3b23ca04649f59e15d34bd0e93ce79140", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 73, "deletions": 38, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -62,6 +62,64 @@ static int overall_insns;\n    record_calls_1.  */\n static htab_t visited_nodes;\n \n+/* Determine if function DECL is needed.  That is, visible to something\n+   either outside this translation unit, something magic in the system\n+   configury, or (if not doing unit-at-a-time) to something we havn't\n+   seen yet.  */\n+\n+static bool\n+decide_is_function_needed (struct cgraph_node *node, tree decl)\n+{\n+  /* If we decided it was needed before, but at the time we didn't have\n+     the body of the function available, then it's still needed.  We have\n+     to go back and re-check its dependencies now.  */\n+  if (node->needed)\n+    return true;\n+\n+  /* Externally visible functions must be output.  The exception is\n+     COMDAT functions that must be output only when they are needed.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+    return true;\n+\n+  /* Constructors and destructors are reachable from the runtime by\n+     some mechanism.  */\n+  if (DECL_STATIC_CONSTRUCTOR (decl) || DECL_STATIC_DESTRUCTOR (decl))\n+    return true;\n+\n+  /* If the user told us it is used, then it must be so.  */\n+  if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+\n+  /* ??? If the assembler name is set by hand, it is possible to assemble\n+     the name later after finalizing the function and the fact is noticed\n+     in assemble_name then.  This is arguably a bug.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n+      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+    return true;\n+\n+  if (flag_unit_at_a_time)\n+    return false;\n+\n+  /* If not doing unit at a time, then we'll only defer this function\n+     if its marked for inlining.  Otherwise we want to emit it now.  */\n+\n+  /* \"extern inline\" functions are never output locally.  */\n+  if (DECL_EXTERNAL (decl))\n+    return false;\n+  /* ??? */\n+  if (node->origin)\n+    return false;\n+  if (!DECL_INLINE (decl)\n+      || (!node->local.disregard_inline_limits\n+\t  /* When declared inline, defer even the uninlinable functions.\n+\t     This allows them to be elliminated when unused.  */\n+\t  && !DECL_DECLARED_INLINE_P (decl) \n+\t  && (node->local.inlinable || !cgraph_default_inline_p (node))))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Analyze function once it is parsed.  Set up the local information\n    available - create cgraph edges for function calls via BODY.  */\n \n@@ -73,42 +131,16 @@ cgraph_finalize_function (tree decl, tree body ATTRIBUTE_UNUSED)\n   node->decl = decl;\n   node->local.finalized = true;\n \n-  /* Function now has DECL_SAVED_TREE set.  Enqueue it into cgraph_nodes_queue\n-     if needed.  */\n-  if (node->needed)\n-    cgraph_mark_needed_node (node, 0);\n+  /* If not unit at a time, then we need to create the call graph\n+     now, so that called functions can be queued and emitted now.  */\n   if (!flag_unit_at_a_time)\n     cgraph_analyze_function (node);\n-  if (/* Externally visible functions must be output.  The exception are\n-\t COMDAT functions that must be output only when they are needed.\n-\t Similarly are handled deferred functions and\n-\t external functions (GCC extension \"extern inline\") */\n-      (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-      /* ??? Constructors and destructors not called otherwise can be inlined\n-\t into single construction/destruction function per section to save some\n-\t resources.  For now just mark it as reachable.  */\n-      || DECL_STATIC_CONSTRUCTOR (decl)\n-      || DECL_STATIC_DESTRUCTOR (decl)\n-      /* Function whose name is output to the assembler file must be produced.\n-\t It is possible to assemble the name later after finalizing the function\n-\t and the fact is noticed in assemble_name then.  */\n-      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-      || lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-     cgraph_mark_needed_node (node, 1);\n-  /* When not doing unit-at-a-time deffer only inline functions.  */\n-  else if (!flag_unit_at_a_time\n-\t   && !DECL_EXTERNAL (decl)\n-\t   && !node->origin\n-\t   && (!DECL_INLINE (decl)\n-\t       || (!node->local.disregard_inline_limits\n-\t\t   /* When declared inline, deffer even the uninlinable functions.\n-\t\t      This allows them to be elliminated when unused.  */\n-\t\t   && !DECL_DECLARED_INLINE_P (decl) \n-\t\t   && (node->local.inlinable\n-\t\t       || !cgraph_default_inline_p (node)))))\n-     cgraph_mark_needed_node (node, 1);\n \n+  if (decide_is_function_needed (node, decl))\n+    cgraph_mark_needed_node (node);\n+\n+  /* If not unit at a time, go ahead and emit everything we've\n+     found to be reachable at this time.  */\n   if (!flag_unit_at_a_time)\n     while (cgraph_nodes_queue)\n       {\n@@ -118,7 +150,9 @@ cgraph_finalize_function (tree decl, tree body ATTRIBUTE_UNUSED)\n \t   cgraph_expand_function (n);\n       }\n \n-  (*debug_hooks->deferred_inline_function) (decl);\n+  /* If we've not yet emitted decl, tell the debug info about it.  */\n+  if (flag_unit_at_a_time || !node->reachable)\n+    (*debug_hooks->deferred_inline_function) (decl);\n }\n \n /* Walk tree and record all calls.  Called via walk_tree.  */\n@@ -133,7 +167,7 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n     {\n       tree decl = TREE_OPERAND (*tp, 0);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n-        cgraph_mark_needed_node (cgraph_node (decl), 1);\n+        cgraph_mark_needed_node (cgraph_node (decl));\n     }\n   else if (TREE_CODE (*tp) == CALL_EXPR)\n     {\n@@ -251,13 +285,14 @@ cgraph_finalize_compilation_unit (void)\n \tabort ();\n \n       cgraph_analyze_function (node);\n+\n       for (edge = node->callees; edge; edge = edge->next_callee)\n-      {\n \tif (!edge->callee->reachable)\n-\t    cgraph_mark_needed_node (edge->callee, 0);\n-      }\n+\t  cgraph_mark_reachable_node (edge->callee);\n+\n       cgraph_varpool_assemble_pending_decls ();\n     }\n+\n   /* Collect entry points to the unit.  */\n \n   if (cgraph_dump_file)"}, {"sha": "6f8668c608af9670f0ccd95e5408f6e2da012b6c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -1,3 +1,8 @@\n+2003-09-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl2.c (mark_member_pointers_and_eh_handlers): Update for\n+\tchange in cgraph_mark_needed_node arguments.\n+\n 2003-09-02  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR 12161"}, {"sha": "20d97d469a09ec5ea9eec8b6427b96e12527f42c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -2570,7 +2570,7 @@ mark_member_pointers_and_eh_handlers (tree *tp,\n     {\n     case PTRMEM_CST:\n       if (TYPE_PTRMEMFUNC_P (TREE_TYPE (*tp)))\n-\tcgraph_mark_needed_node (cgraph_node (PTRMEM_CST_MEMBER (*tp)), 1);\n+\tcgraph_mark_needed_node (cgraph_node (PTRMEM_CST_MEMBER (*tp)));\n       break;\n \n     /* EH handlers will emit EH tables referencing typeinfo.  */"}, {"sha": "0e1c1beb92f57c6aa9fff2c91ed4874525a93263", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -3981,13 +3981,14 @@ mark_referenced_methods ()\n       chain = CLASS_CLS_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)), 1);\n+\t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)));\n \t  chain = TREE_CHAIN (chain);\n \t}\n+\n       chain = CLASS_NST_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)), 1);\n+\t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)));\n \t  chain = TREE_CHAIN (chain);\n \t}\n     }"}, {"sha": "d327cb2d8c236e62ca9591793e9c2ea996e932fd", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dafba3ca49dbbd3ac78eb8d026576b9633d433c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8dafba3ca49dbbd3ac78eb8d026576b9633d433c", "patch": "@@ -1662,7 +1662,7 @@ mark_referenced (tree id)\n \t{\n \t  node = cgraph_node_for_identifier (id);\n \t  if (node)\n-\t    cgraph_mark_needed_node (node, 1);\n+\t    cgraph_mark_needed_node (node);\n \t}\n \n       vnode = cgraph_varpool_node_for_identifier (id);"}]}