{"sha": "fbf833b776811b8ac22c79ee52ff46d578da755b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJmODMzYjc3NjgxMWI4YWMyMmM3OWVlNTJmZjQ2ZDU3OGRhNzU1Yg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-10-06T16:13:41Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-10-06T16:13:41Z"}, "message": "re PR c++/55250 ([C++0x] enum declarations within constexpr function are allowed, constexpr declarations are not)\n\n/cp\n2014-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/55250\n\t* semantics.c (check_constexpr_bind_expr_vars): New.\n\t(check_constexpr_ctor_body, massage_constexpr_body): Use it.\n\t(build_constexpr_constructor_member_initializers): Handle\n\tBIND_EXPR in the main conditional.\n\n/testsuite\n2014-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/55250\n\t* g++.dg/cpp0x/constexpr-type-decl1.C: New.\n\t* g++.dg/cpp0x/constexpr-type-def1.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-type-def1.C: Likewise.\n\nFrom-SVN: r215954", "tree": {"sha": "fbc115d703cfe8f47d7e0b737588cd7b86e323a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbc115d703cfe8f47d7e0b737588cd7b86e323a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbf833b776811b8ac22c79ee52ff46d578da755b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf833b776811b8ac22c79ee52ff46d578da755b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbf833b776811b8ac22c79ee52ff46d578da755b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbf833b776811b8ac22c79ee52ff46d578da755b/comments", "author": null, "committer": null, "parents": [{"sha": "c4b64f5bcac6f7d5e1ae7d3026a3e228fb8adbbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b64f5bcac6f7d5e1ae7d3026a3e228fb8adbbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b64f5bcac6f7d5e1ae7d3026a3e228fb8adbbd"}], "stats": {"total": 205, "additions": 201, "deletions": 4}, "files": [{"sha": "6405be0947591cd60892781ad96c271bfd818b98", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fbf833b776811b8ac22c79ee52ff46d578da755b", "patch": "@@ -1,3 +1,11 @@\n+2014-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/55250\n+\t* semantics.c (check_constexpr_bind_expr_vars): New.\n+\t(check_constexpr_ctor_body, massage_constexpr_body): Use it.\n+\t(build_constexpr_constructor_member_initializers): Handle\n+\tBIND_EXPR in the main conditional.\n+\n 2014-10-02  Mark Wielaard  <mjw@redhat.com>\n \n \tPR debug/63239"}, {"sha": "b11ec0905cbf5a6824110683d6c17eb01003b353", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fbf833b776811b8ac22c79ee52ff46d578da755b", "patch": "@@ -7833,6 +7833,25 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n   return true;\n }\n \n+/* Subroutine of check_constexpr_ctor_body and massage_constexpr_body.\n+   In C++11 mode checks that the TYPE_DECLs in the BIND_EXPR_VARS of a \n+   BIND_EXPR conform to 7.1.5/3/4 on typedef and alias declarations.  */\n+\n+static bool\n+check_constexpr_bind_expr_vars (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == BIND_EXPR);\n+\n+  if (cxx_dialect >= cxx14)\n+    return true;\n+\n+  for (tree var = BIND_EXPR_VARS (t); var; var = DECL_CHAIN (var))\n+    if (TREE_CODE (var) == TYPE_DECL\n+\t&& DECL_IMPLICIT_TYPEDEF_P (var))\n+      return false;\n+  return true;\n+}\n+\n /* Make sure that there are no statements after LAST in the constructor\n    body represented by LIST.  */\n \n@@ -7850,7 +7869,7 @@ check_constexpr_ctor_body (tree last, tree list)\n \t    break;\n \t  if (TREE_CODE (t) == BIND_EXPR)\n \t    {\n-\t      if (BIND_EXPR_VARS (t))\n+\t      if (!check_constexpr_bind_expr_vars (t))\n \t\t{\n \t\t  ok = false;\n \t\t  break;\n@@ -7860,8 +7879,6 @@ check_constexpr_ctor_body (tree last, tree list)\n \t      else\n \t\tcontinue;\n \t    }\n-\t  /* We currently allow typedefs and static_assert.\n-\t     FIXME allow them in the standard, too.  */\n \t  if (TREE_CODE (t) != STATIC_ASSERT)\n \t    {\n \t      ok = false;\n@@ -7964,6 +7981,8 @@ build_constexpr_constructor_member_initializers (tree type, tree body)\n \t     \"a function-try-block\");\n       return error_mark_node;\n     }\n+  else if (TREE_CODE (body) == BIND_EXPR)\n+    ok = build_data_member_initialization (BIND_EXPR_BODY (body), &vec);\n   else if (EXPR_P (body))\n     ok = build_data_member_initialization (body, &vec);\n   else\n@@ -8055,7 +8074,8 @@ massage_constexpr_body (tree fun, tree body)\n         body = EH_SPEC_STMTS (body);\n       if (TREE_CODE (body) == MUST_NOT_THROW_EXPR)\n \tbody = TREE_OPERAND (body, 0);\n-      if (TREE_CODE (body) == BIND_EXPR)\n+      if (TREE_CODE (body) == BIND_EXPR\n+\t  && check_constexpr_bind_expr_vars (body))\n \tbody = BIND_EXPR_BODY (body);\n       body = constexpr_fn_retval (body);\n     }"}, {"sha": "582f18902202b45490a097cb6dccdc76a9a8ce22", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fbf833b776811b8ac22c79ee52ff46d578da755b", "patch": "@@ -1,3 +1,10 @@\n+2014-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/55250\n+\t* g++.dg/cpp0x/constexpr-type-decl1.C: New.\n+\t* g++.dg/cpp0x/constexpr-type-def1.C: Likewise.\n+\t* g++.dg/cpp1y/constexpr-type-def1.C: Likewise.\n+\n 2014-10-06  Marek Polacek  <polacek@redhat.com>\n \n \t* c-c++-common/raw-string-3.c: Use -std=gnu89 for C."}, {"sha": "0ef715e8830869789ffe1b4925b48903c0cbcd52", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-type-decl1.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-type-decl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-type-decl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-type-decl1.C?ref=fbf833b776811b8ac22c79ee52ff46d578da755b", "patch": "@@ -0,0 +1,58 @@\n+// PR c++/55250\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert((X),#X)\n+\n+struct GS { constexpr operator int() { return 1; } };\n+enum GE { y = 1 };\n+\n+constexpr int Test1(int x) { typedef int T; return T(x) + 1; }\n+constexpr int Test2(int x) { using T = int; return T(x) + 1; }\n+constexpr int Test3(int x) { typedef GS T; return x + T(); }\n+constexpr int Test4(int x) { using T = GS; return x + T(); }\n+constexpr int Test5(int x) { typedef GE T; return x + T::y; }\n+constexpr int Test6(int x) { using T = GE; return x + T::y; }\n+\n+SA(Test1(2) == 3);\n+SA(Test2(2) == 3);\n+SA(Test3(2) == 3);\n+SA(Test4(2) == 3);\n+SA(Test5(2) == 3);\n+SA(Test6(2) == 3);\n+\n+struct S1\n+{\n+  constexpr S1() { typedef int T; SA(T(1) == 1); }\n+};\n+\n+struct S2\n+{\n+  constexpr S2() { using T = int; SA(T(1) == 1); }\n+};\n+\n+struct S3\n+{\n+  constexpr S3() { typedef GS T; SA(T() == 1); }\n+};\n+\n+struct S4\n+{\n+  constexpr S4() { using T = GS; SA(T() == 1); }\n+};\n+\n+struct S5\n+{\n+  constexpr S5() { typedef GE T; SA(T::y == 1); }\n+};\n+\n+struct S6\n+{\n+  constexpr S6() { using T = GE; SA(T::y == 1); }\n+};\n+\n+S1 s1;\n+S2 s2;\n+S3 s3;\n+S4 s4;\n+S5 s5;\n+S6 s6;"}, {"sha": "1a72950b8b1555fd14a8edacf965d0c1c8d86ac3", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-type-def1.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-type-def1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-type-def1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-type-def1.C?ref=fbf833b776811b8ac22c79ee52ff46d578da755b", "patch": "@@ -0,0 +1,44 @@\n+// PR c++/55250\n+// { dg-do compile { target c++11 } }\n+\n+constexpr int Test1(int x) { enum E { y = 1 }; return x; }  // { dg-error \"not a return-statement\" \"\" { target { c++11_only } } }\n+\n+constexpr int Test2(int x) { struct T { }; return x; }  // { dg-error \"not a return-statement\" \"\" { target { c++11_only } } }\n+\n+constexpr int Test3(int x) { typedef enum E { y = 1 } EE; return x; }  // { dg-error \"not a return-statement\" \"\" { target { c++11_only } } }\n+\n+constexpr int Test4(int x) { typedef struct T { } TT; return x; }  // { dg-error \"not a return-statement\" \"\" { target { c++11_only } } }\n+\n+constexpr int Test5(int x) { using EE = enum E { y = 1 }; return x; }  // { dg-error \"not a return-statement\" \"\" { target { c++11_only } } }\n+\n+constexpr int Test6(int x) { using TT = struct T { }; return x; }  // { dg-error \"not a return-statement\" \"\" { target { c++11_only } } }\n+\n+struct S1\n+{\n+  constexpr S1() { enum E { y = 1 }; }  // { dg-error \"does not have empty body\" \"\" { target { c++11_only } } }\n+};\n+\n+struct S2\n+{\n+  constexpr S2() { struct T { }; }  // { dg-error \"does not have empty body\" \"\" { target { c++11_only } } }\n+};\n+\n+struct S3\n+{\n+  constexpr S3() { typedef enum E { y = 1 } EE; }  // { dg-error \"does not have empty body\" \"\" { target { c++11_only } } }\n+};\n+\n+struct S4\n+{\n+  constexpr S4() { typedef struct T { } TT; }  // { dg-error \"does not have empty body\" \"\" { target { c++11_only } } }\n+};\n+\n+struct S5\n+{\n+  constexpr S5() { using EE = enum E { y = 1 }; }  // { dg-error \"does not have empty body\" \"\" { target { c++11_only } } }\n+};\n+\n+struct S6\n+{\n+  constexpr S6() { using TT = struct T { }; }  // { dg-error \"does not have empty body\" \"\" { target { c++11_only } } }\n+};"}, {"sha": "648e09c99347d28bf9242e94d3e8e00ebec40391", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-type-def1.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-type-def1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbf833b776811b8ac22c79ee52ff46d578da755b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-type-def1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-type-def1.C?ref=fbf833b776811b8ac22c79ee52ff46d578da755b", "patch": "@@ -0,0 +1,60 @@\n+// PR c++/55250\n+// { dg-do compile { target c++14 } }\n+\n+#define SA(X) static_assert((X),#X)\n+\n+constexpr int Test1(int x) { enum E { y = 1 }; return x + y; }\n+\n+constexpr int Test2(int x) { struct T { constexpr operator int() { return 1; } }; return x + T(); }\n+\n+constexpr int Test3(int x) { typedef enum E { y = 1 } EE; return x + EE::y; }\n+\n+constexpr int Test4(int x) { typedef struct T { constexpr operator int() { return 1; } } TT; return x + TT(); }\n+\n+constexpr int Test5(int x) { using EE = enum E { y = 1 }; return x + EE::y; }\n+\n+constexpr int Test6(int x) { using TT = struct T { constexpr operator int() { return 1; } }; return x + TT(); }\n+\n+SA(Test1(2) == 3);\n+SA(Test2(2) == 3);\n+SA(Test3(2) == 3);\n+SA(Test4(2) == 3);\n+SA(Test5(2) == 3);\n+SA(Test6(2) == 3);\n+\n+struct S1\n+{\n+  constexpr S1() { enum E { y = 1 }; SA(y == 1); }\n+};\n+\n+struct S2\n+{\n+  constexpr S2() { struct T { constexpr operator int() { return 1; } }; SA(T() == 1); }\n+};\n+\n+struct S3\n+{\n+  constexpr S3() { typedef enum E { y = 1} EE; SA(EE::y == 1); }\n+};\n+\n+struct S4\n+{\n+  constexpr S4() { typedef struct T { constexpr operator int() { return 1; } } TT; SA(TT() == 1); }\n+};\n+\n+struct S5\n+{\n+  constexpr S5() { using EE = enum E { y = 1}; SA(EE::y == 1); }\n+};\n+\n+struct S6\n+{\n+  constexpr S6() { using TT = struct T { constexpr operator int() { return 1; } }; SA(TT() == 1); }\n+};\n+\n+S1 s1;\n+S2 s2;\n+S3 s3;\n+S4 s4;\n+S5 s5;\n+S6 s6;"}]}