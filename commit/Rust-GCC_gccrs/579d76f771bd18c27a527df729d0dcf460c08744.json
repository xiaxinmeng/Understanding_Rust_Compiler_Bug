{"sha": "579d76f771bd18c27a527df729d0dcf460c08744", "node_id": "C_kwDOANBUbNoAKDU3OWQ3NmY3NzFiZDE4YzI3YTUyN2RmNzI5ZDBkY2Y0NjBjMDg3NDQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-05T13:19:05Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-05T13:19:05Z"}, "message": "Remove lambda iterator from HIR::CallExpr\n\nThis removes the bad code style lambda iterators for arguments. They are\na bad design choice for static analysis code since the user of the api\nlooses scope to break/return outside from the caller api. This will need\nto be added to a style-guide in the future.\n\nFixes: #708", "tree": {"sha": "9cd6c4587fbfb98fc471a26940dc1d2d15684017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cd6c4587fbfb98fc471a26940dc1d2d15684017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579d76f771bd18c27a527df729d0dcf460c08744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579d76f771bd18c27a527df729d0dcf460c08744", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579d76f771bd18c27a527df729d0dcf460c08744", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579d76f771bd18c27a527df729d0dcf460c08744/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c28309d3553346d4f0337dbae49f4a8e48da01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c28309d3553346d4f0337dbae49f4a8e48da01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c28309d3553346d4f0337dbae49f4a8e48da01"}], "stats": {"total": 178, "additions": 87, "deletions": 91}, "files": [{"sha": "d6c6066882118d485826c28a35e49bd84ab73708", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=579d76f771bd18c27a527df729d0dcf460c08744", "patch": "@@ -74,11 +74,11 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n-      expr.iterate_params ([&] (HIR::Expr *argument) mutable -> bool {\n-\tBexpression *e = CompileExpr::Compile (argument, ctx);\n-\tvals.push_back (e);\n-\treturn true;\n-      });\n+      for (auto &argument : expr.get_arguments ())\n+\t{\n+\t  Bexpression *e = CompileExpr::Compile (argument.get (), ctx);\n+\t  vals.push_back (e);\n+\t}\n \n       translated\n \t= ctx->get_backend ()->constructor_expression (type, vals, -1,\n@@ -91,12 +91,12 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       rust_assert (fn != nullptr);\n \n       std::vector<Bexpression *> args;\n-      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\targs.push_back (compiled_expr);\n-\treturn true;\n-      });\n+      for (auto &argument : expr.get_arguments ())\n+\t{\n+\t  Bexpression *compiled_expr\n+\t    = CompileExpr::Compile (argument.get (), ctx);\n+\t  args.push_back (compiled_expr);\n+\t}\n \n       auto fncontext = ctx->peek_fn ();\n       translated"}, {"sha": "d66640d6f397a5c3ade4d5449b58dba581e2f3f2", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=579d76f771bd18c27a527df729d0dcf460c08744", "patch": "@@ -1578,14 +1578,10 @@ class StructExprStructBase : public StructExprStruct\n   }\n };\n \n-// Forward decl for Function - used in CallExpr\n-class Function;\n-\n // Function call expression HIR node\n class CallExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> function;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n@@ -1642,13 +1638,11 @@ class CallExpr : public ExprWithoutBlock\n \n   size_t num_params () const { return params.size (); }\n \n-  void iterate_params (std::function<bool (Expr *)> cb)\n+  std::vector<std::unique_ptr<Expr> > &get_arguments () { return params; }\n+\n+  const std::vector<std::unique_ptr<Expr> > &get_arguments () const\n   {\n-    for (auto &param : params)\n-      {\n-\tif (!cb (param.get ()))\n-\t  return;\n-      }\n+    return params;\n   }\n \n protected:"}, {"sha": "481c956ac41104cb3cbda245872a99c5d9114dfb", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=579d76f771bd18c27a527df729d0dcf460c08744", "patch": "@@ -165,10 +165,8 @@ class MarkLive : public MarkLiveBase\n   void visit (HIR::CallExpr &expr) override\n   {\n     expr.get_fnexpr ()->accept_vis (*this);\n-    expr.iterate_params ([&] (HIR::Expr *expr) -> bool {\n-      expr->accept_vis (*this);\n-      return true;\n-    });\n+    for (auto &argument : expr.get_arguments ())\n+      argument->accept_vis (*this);\n   }\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override"}, {"sha": "8de9d9d42a8f30542e1919b79b096c9a4f981542", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 68, "deletions": 63, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=579d76f771bd18c27a527df729d0dcf460c08744", "patch": "@@ -2383,27 +2383,28 @@ TypeCheckCallExpr::visit (ADTType &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-    StructFieldType *field = type.get_field (i);\n-    BaseType *field_tyty = field->get_field_type ();\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      StructFieldType *field = type.get_field (i);\n+      BaseType *field_tyty = field->get_field_type ();\n \n-    BaseType *arg = Resolver::TypeCheckExpr::Resolve (p, false);\n-    if (arg->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (p->get_locus (), \"failed to resolve argument type\");\n-\treturn false;\n-      }\n+      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"failed to resolve argument type\");\n+\t  return;\n+\t}\n \n-    auto res = field_tyty->coerce (arg);\n-    if (res->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\treturn false;\n-      }\n+      auto res = field_tyty->coerce (arg);\n+      if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  return;\n+\t}\n \n-    delete res;\n-    i++;\n-    return true;\n-  });\n+      delete res;\n+      i++;\n+    }\n \n   if (i != call.num_params ())\n     {\n@@ -2441,35 +2442,37 @@ TypeCheckCallExpr::visit (FnType &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"failed to resolve type for argument expr in CallExpr\");\n-\treturn false;\n-      }\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n \n-    auto resolved_argument_type = argument_expr_tyty;\n+      auto resolved_argument_type = argument_expr_tyty;\n \n-    // it might be a varadic function\n-    if (i < type.num_params ())\n-      {\n-\tauto fnparam = type.param_at (i);\n-\tresolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-\tif (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (param->get_locus (),\n-\t\t\t   \"Type Resolution failure on parameter\");\n-\t    return false;\n-\t  }\n-      }\n+      // it might be a varadic function\n+      if (i < type.num_params ())\n+\t{\n+\t  auto fnparam = type.param_at (i);\n+\t  resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n+\t  if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (argument->get_locus (),\n+\t\t\t     \"Type Resolution failure on parameter\");\n+\t      return;\n+\t    }\n+\t}\n \n-    context->insert_type (param->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), resolved_argument_type);\n \n-    i++;\n-    return true;\n-  });\n+      i++;\n+    }\n \n   if (i < call.num_params ())\n     {\n@@ -2505,29 +2508,31 @@ TypeCheckCallExpr::visit (FnPtr &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n-    auto fnparam = type.param_at (i);\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"failed to resolve type for argument expr in CallExpr\");\n-\treturn false;\n-      }\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n \n-    auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"Type Resolution failure on parameter\");\n-\treturn false;\n-      }\n+      auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n \n-    context->insert_type (param->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), resolved_argument_type);\n \n-    i++;\n-    return true;\n-  });\n+      i++;\n+    }\n \n   if (i != call.num_params ())\n     {"}, {"sha": "a70306df852b7256379486dc6de91c051a043c4f", "filename": "gcc/testsuite/rust/compile/tuple_struct3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579d76f771bd18c27a527df729d0dcf460c08744/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs?ref=579d76f771bd18c27a527df729d0dcf460c08744", "patch": "@@ -3,7 +3,6 @@ struct Foo(i32, i32, bool);\n fn main() {\n     let c = Foo(1, 2f32, true);\n     // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"unexpected number of arguments 1 expected 3\" \"\" { target *-*-* } .-2 }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-3 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-4 }\n+    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-3 }\n }"}]}