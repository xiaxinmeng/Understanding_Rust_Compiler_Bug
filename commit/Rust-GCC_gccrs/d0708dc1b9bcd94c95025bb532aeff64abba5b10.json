{"sha": "d0708dc1b9bcd94c95025bb532aeff64abba5b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA3MDhkYzFiOWJjZDk0Yzk1MDI1YmI1MzJhZWZmNjRhYmJhNWIxMA==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@redhat.com", "date": "2001-08-23T15:19:05Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2001-08-23T15:19:05Z"}, "message": "merge from glibc\n\nFrom-SVN: r45134", "tree": {"sha": "f688edd7f36f2750e7c04bb080696654313bc264", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f688edd7f36f2750e7c04bb080696654313bc264"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0708dc1b9bcd94c95025bb532aeff64abba5b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0708dc1b9bcd94c95025bb532aeff64abba5b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0708dc1b9bcd94c95025bb532aeff64abba5b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0708dc1b9bcd94c95025bb532aeff64abba5b10/comments", "author": null, "committer": null, "parents": [{"sha": "038c2f5067d3cdbe2fe6b996f19898d0091e29a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/038c2f5067d3cdbe2fe6b996f19898d0091e29a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/038c2f5067d3cdbe2fe6b996f19898d0091e29a4"}], "stats": {"total": 83, "additions": 69, "deletions": 14}, "files": [{"sha": "f6c1f7955515942dbcf5a4243d7a7f35f8fe9ee8", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0708dc1b9bcd94c95025bb532aeff64abba5b10/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0708dc1b9bcd94c95025bb532aeff64abba5b10/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=d0708dc1b9bcd94c95025bb532aeff64abba5b10", "patch": "@@ -1,3 +1,14 @@\n+2001-08-23  Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* regex.c (truncate_wchar): Use wcrtomb not wctomb.\n+\n+2001-08-23  Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* posix/regex.c [_LIBC] (convert_mbs_to_wcs): Use __mbrtowc\n+\tinstead of mbrtowc.\n+\t[_LIBC]: Use __iswctype instead of iswctype, __wcslen instead of\n+\twcslen, and __wcscoll instead of wcscoll.\n+\n 2001-08-22  Matt Kraai  <kraai@alumni.carnegiemellon.edu>\n \n  \t* fibheap.c (fibheap_init, fibnode_init): Remove."}, {"sha": "e68df05818c5ea40940f2d6ac5e8d699e4127417", "filename": "libiberty/regex.c", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0708dc1b9bcd94c95025bb532aeff64abba5b10/libiberty%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0708dc1b9bcd94c95025bb532aeff64abba5b10/libiberty%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fregex.c?ref=d0708dc1b9bcd94c95025bb532aeff64abba5b10", "patch": "@@ -1288,7 +1288,11 @@ convert_mbs_to_wcs (dest, src, len, offset_buffer, is_binary)\n   for( ; mb_remain > 0 ; ++wc_count, ++pdest, mb_remain -= consumed,\n \t psrc += consumed)\n     {\n+#ifdef _LIBC\n+      consumed = __mbrtowc (pdest, psrc, mb_remain, &mbs);\n+#else\n       consumed = mbrtowc (pdest, psrc, mb_remain, &mbs);\n+#endif\n \n       if (consumed <= 0)\n \t/* failed to convert. maybe src contains binary data.\n@@ -4627,9 +4631,16 @@ static unsigned char\n truncate_wchar (c)\n      CHAR_T c;\n {\n-  unsigned char buf[MB_LEN_MAX];\n-  int retval = wctomb(buf, c);\n-  return retval > 0 ? buf[0] : (unsigned char)c;\n+  unsigned char buf[MB_CUR_MAX];\n+  mbstate_t state;\n+  int retval;\n+  memset (&state, '\\0', sizeof (state));\n+# ifdef _LIBC\n+  retval = __wcrtomb (buf, c, &state);\n+# else\n+  retval = wcrtomb (buf, c, &state);\n+# endif\n+  return retval > 0 ? buf[0] : (unsigned char) c;\n }\n #endif /* WCHAR */\n \n@@ -6337,8 +6348,13 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\t  \t\t      & ~(uintptr_t)(__alignof__(wctype_t) - 1);\n \t\twctype = *((wctype_t*)alignedp);\n \t\tworkp += CHAR_CLASS_SIZE;\n+# ifdef _LIBC\n+\t\tif (__iswctype((wint_t)c, wctype))\n+\t\t  goto char_set_matched;\n+# else\n \t\tif (iswctype((wint_t)c, wctype))\n \t\t  goto char_set_matched;\n+# endif\n \t      }\n \n             /* match with collating_symbol?  */\n@@ -6374,12 +6390,20 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\tfor (workp2 = workp + coll_symbol_length ; workp < workp2 ;)\n \t\t  {\n \t\t    const CHAR_T *backup_d = d, *backup_dend = dend;\n-\t\t    length = wcslen(workp);\n+# ifdef _LIBC\n+\t\t    length = __wcslen (workp);\n+# else\n+\t\t    length = wcslen (workp);\n+# endif\n \n \t\t    /* If wcscoll(the collating symbol, whole string) > 0,\n \t\t       any substring of the string never match with the\n \t\t       collating symbol.  */\n-\t\t    if (wcscoll(workp, d) > 0)\n+# ifdef _LIBC\n+\t\t    if (__wcscoll (workp, d) > 0)\n+# else\n+\t\t    if (wcscoll (workp, d) > 0)\n+# endif\n \t\t      {\n \t\t\tworkp += length + 1;\n \t\t\tcontinue;\n@@ -6404,7 +6428,11 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\t\tstr_buf[i] = TRANSLATE(*d);\n \t\t\tstr_buf[i+1] = '\\0';\n \n-\t\t\tmatch = wcscoll(workp, str_buf);\n+# ifdef _LIBC\n+\t\t\tmatch = __wcscoll (workp, str_buf);\n+# else\n+\t\t\tmatch = wcscoll (workp, str_buf);\n+# endif\n \t\t\tif (match == 0)\n \t\t\t  goto char_set_matched;\n \n@@ -6515,12 +6543,20 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\tfor (workp2 = workp + equiv_class_length ; workp < workp2 ;)\n \t\t  {\n \t\t    const CHAR_T *backup_d = d, *backup_dend = dend;\n-\t\t    length = wcslen(workp);\n+# ifdef _LIBC\n+\t\t    length = __wcslen (workp);\n+# else\n+\t\t    length = wcslen (workp);\n+# endif\n \n \t\t    /* If wcscoll(the collating symbol, whole string) > 0,\n \t\t       any substring of the string never match with the\n \t\t       collating symbol.  */\n-\t\t    if (wcscoll(workp, d) > 0)\n+# ifdef _LIBC\n+\t\t    if (__wcscoll (workp, d) > 0)\n+# else\n+\t\t    if (wcscoll (workp, d) > 0)\n+# endif\n \t\t      {\n \t\t\tworkp += length + 1;\n \t\t\tbreak;\n@@ -6545,7 +6581,11 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\t\tstr_buf[i] = TRANSLATE(*d);\n \t\t\tstr_buf[i+1] = '\\0';\n \n-\t\t\tmatch = wcscoll(workp, str_buf);\n+# ifdef _LIBC\n+\t\t\tmatch = __wcscoll (workp, str_buf);\n+# else\n+\t\t\tmatch = wcscoll (workp, str_buf);\n+# endif\n \n \t\t\tif (match == 0)\n \t\t\t  goto char_set_matched;\n@@ -6568,7 +6608,7 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t      }\n \n             /* match with char_range?  */\n-#ifdef _LIBC\n+# ifdef _LIBC\n \t    if (nrules != 0)\n \t      {\n \t\tuint32_t collseqval;\n@@ -6591,7 +6631,7 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\t  }\n \t      }\n \t    else\n-#endif\n+# endif\n \t      {\n \t\t/* We set range_start_char at str_buf[0], range_end_char\n \t\t   at str_buf[4], and compared char at str_buf[2].  */\n@@ -6627,9 +6667,13 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n \t\t\trange_end_char = str_buf + 4;\n \t\t      }\n \n-\t\t    if (wcscoll(range_start_char, str_buf+2) <= 0 &&\n-\t\t\twcscoll(str_buf+2, range_end_char) <= 0)\n-\n+# ifdef _LIBC\n+\t\t    if (__wcscoll (range_start_char, str_buf+2) <= 0\n+\t\t\t&& __wcscoll (str_buf+2, range_end_char) <= 0)\n+# else\n+\t\t    if (wcscoll (range_start_char, str_buf+2) <= 0\n+\t\t\t&& wcscoll (str_buf+2, range_end_char) <= 0)\n+# endif\n \t\t      goto char_set_matched;\n \t\t  }\n \t      }"}]}