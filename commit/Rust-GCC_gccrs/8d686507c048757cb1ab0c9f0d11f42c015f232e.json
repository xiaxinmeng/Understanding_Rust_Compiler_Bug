{"sha": "8d686507c048757cb1ab0c9f0d11f42c015f232e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ2ODY1MDdjMDQ4NzU3Y2IxYWIwYzlmMGQxMWY0MmMwMTVmMjMyZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-10-25T22:59:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-25T22:59:40Z"}, "message": "tree-eh.c (do_return_redirection): Remove return_value_p parameter.\n\n\t* tree-eh.c (do_return_redirection): Remove return_value_p\n\tparameter.  Change all callers.\n\t(lower_try_finally_nofallthru): Remove local return_val.\n\t(lower_try_finally_onedest): Likewise.\n\t(lower_try_finally_copy): Likewise.\n\t(lower_try_finally_switch): Likewise.\n\nFrom-SVN: r180459", "tree": {"sha": "8c939b09ae84de4b45e8ec229bdf5ebc6c073a47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c939b09ae84de4b45e8ec229bdf5ebc6c073a47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d686507c048757cb1ab0c9f0d11f42c015f232e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d686507c048757cb1ab0c9f0d11f42c015f232e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d686507c048757cb1ab0c9f0d11f42c015f232e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d686507c048757cb1ab0c9f0d11f42c015f232e/comments", "author": null, "committer": null, "parents": [{"sha": "d7115452b2cdceacac0870693d9f44d58e2aab35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7115452b2cdceacac0870693d9f44d58e2aab35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7115452b2cdceacac0870693d9f44d58e2aab35"}], "stats": {"total": 94, "additions": 34, "deletions": 60}, "files": [{"sha": "593ac816f25bb15d70d5fa636826315c7ed510ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d686507c048757cb1ab0c9f0d11f42c015f232e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d686507c048757cb1ab0c9f0d11f42c015f232e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d686507c048757cb1ab0c9f0d11f42c015f232e", "patch": "@@ -1,3 +1,12 @@\n+2011-10-25  Ian Lance Taylor  <iant@google.com>\n+\n+\t* tree-eh.c (do_return_redirection): Remove return_value_p\n+\tparameter.  Change all callers.\n+\t(lower_try_finally_nofallthru): Remove local return_val.\n+\t(lower_try_finally_onedest): Likewise.\n+\t(lower_try_finally_copy): Likewise.\n+\t(lower_try_finally_switch): Likewise.\n+\n 2011-10-25  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/mmx.md (*mmx_maskmovq): Replace :SI with :P and"}, {"sha": "fbc444ca716146aca3f637459908e6e9e0ad69ec", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d686507c048757cb1ab0c9f0d11f42c015f232e/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d686507c048757cb1ab0c9f0d11f42c015f232e/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=8d686507c048757cb1ab0c9f0d11f42c015f232e", "patch": "@@ -711,66 +711,35 @@ verify_norecord_switch_expr (struct leh_state *state, gimple switch_expr)\n #define verify_norecord_switch_expr(state, switch_expr)\n #endif\n \n-/* Redirect a RETURN_EXPR pointed to by STMT_P to FINLAB.  Place in CONT_P\n-   whatever is needed to finish the return.  If MOD is non-null, insert it\n-   before the new branch.  RETURN_VALUE_P is a cache containing a temporary\n-   variable to be used in manipulating the value returned from the function.  */\n+/* Redirect a RETURN_EXPR pointed to by Q to FINLAB.  If MOD is\n+   non-null, insert it before the new branch.  */\n \n static void\n-do_return_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod,\n-\t\t       tree *return_value_p)\n+do_return_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod)\n {\n-  tree ret_expr;\n   gimple x;\n \n-  /* In the case of a return, the queue node must be a gimple statement. */\n+  /* In the case of a return, the queue node must be a gimple statement.  */\n   gcc_assert (!q->is_label);\n \n-  ret_expr = gimple_return_retval (q->stmt.g);\n+  /* Note that the return value may have already been computed, e.g.,\n \n-  if (ret_expr)\n-    {\n-      if (!*return_value_p)\n-        *return_value_p = ret_expr;\n-      else\n-        gcc_assert (*return_value_p == ret_expr);\n-      q->cont_stmt = q->stmt.g;\n-      /* The nasty part about redirecting the return value is that the\n-\t return value itself is to be computed before the FINALLY block\n-\t is executed.  e.g.\n-\n-\t\tint x;\n-\t\tint foo (void)\n-\t\t{\n-\t\t  x = 0;\n-\t\t  try {\n-\t\t    return x;\n-\t\t  } finally {\n-\t\t    x++;\n-\t\t  }\n-\t\t}\n-\n-\t  should return 0, not 1.  Arrange for this to happen by copying\n-\t  computed the return value into a local temporary.  This also\n-\t  allows us to redirect multiple return statements through the\n-\t  same destination block; whether this is a net win or not really\n-\t  depends, I guess, but it does make generation of the switch in\n-\t  lower_try_finally_switch easier.  */\n-\n-      if (TREE_CODE (ret_expr) == RESULT_DECL)\n+\tint x;\n+\tint foo (void)\n \t{\n-\t  if (!*return_value_p)\n-\t    *return_value_p = ret_expr;\n-\t  else\n-\t    gcc_assert (*return_value_p == ret_expr);\n-\t  q->cont_stmt = q->stmt.g;\n+\t  x = 0;\n+\t  try {\n+\t    return x;\n+\t  } finally {\n+\t    x++;\n+\t  }\n \t}\n-      else\n-\t  gcc_unreachable ();\n-    }\n-  else\n-      /* If we don't return a value, all return statements are the same.  */\n-      q->cont_stmt = q->stmt.g;\n+\n+     should return 0, not 1.  We don't have to do anything to make\n+     this happens because the return value has been placed in the\n+     RESULT_DECL already.  */\n+\n+  q->cont_stmt = q->stmt.g;\n \n   if (!q->repl_stmt)\n     q->repl_stmt = gimple_seq_alloc ();\n@@ -1041,7 +1010,7 @@ static void\n lower_try_finally_nofallthru (struct leh_state *state,\n \t\t\t      struct leh_tf_state *tf)\n {\n-  tree lab, return_val;\n+  tree lab;\n   gimple x;\n   gimple_seq finally;\n   struct goto_queue_node *q, *qe;\n@@ -1055,12 +1024,11 @@ lower_try_finally_nofallthru (struct leh_state *state,\n   x = gimple_build_label (lab);\n   gimple_seq_add_stmt (&tf->top_p_seq, x);\n \n-  return_val = NULL;\n   q = tf->goto_queue;\n   qe = q + tf->goto_queue_active;\n   for (; q < qe; ++q)\n     if (q->index < 0)\n-      do_return_redirection (q, lab, NULL, &return_val);\n+      do_return_redirection (q, lab, NULL);\n     else\n       do_goto_redirection (q, lab, NULL, tf);\n \n@@ -1126,9 +1094,8 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n   if (tf->may_return)\n     {\n       /* Reachable by return expressions only.  Redirect them.  */\n-      tree return_val = NULL;\n       for (; q < qe; ++q)\n-\tdo_return_redirection (q, finally_label, NULL, &return_val);\n+\tdo_return_redirection (q, finally_label, NULL);\n       replace_goto_queue (tf);\n     }\n   else\n@@ -1197,7 +1164,6 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n   if (tf->goto_queue)\n     {\n       struct goto_queue_node *q, *qe;\n-      tree return_val = NULL;\n       int return_index, index;\n       struct labels_s\n       {\n@@ -1230,7 +1196,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \t    = create_artificial_label (tf_loc);\n \n \t  if (index == return_index)\n-\t    do_return_redirection (q, lab, NULL, &return_val);\n+\t    do_return_redirection (q, lab, NULL);\n \t  else\n \t    do_goto_redirection (q, lab, NULL, tf);\n \n@@ -1257,7 +1223,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \t  lab = labels[index].label;\n \n \t  if (index == return_index)\n-\t    do_return_redirection (q, lab, NULL, &return_val);\n+\t    do_return_redirection (q, lab, NULL);\n \t  else\n \t    do_goto_redirection (q, lab, NULL, tf);\n \t}\n@@ -1280,7 +1246,6 @@ static void\n lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n {\n   struct goto_queue_node *q, *qe;\n-  tree return_val = NULL;\n   tree finally_tmp, finally_label;\n   int return_index, eh_index, fallthru_index;\n   int nlabels, ndests, j, last_case_index;\n@@ -1401,7 +1366,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \t\t\t\t   build_int_cst (integer_type_node,\n \t\t\t\t\t\t  return_index));\n \t  gimple_seq_add_stmt (&mod, x);\n-\t  do_return_redirection (q, finally_label, mod, &return_val);\n+\t  do_return_redirection (q, finally_label, mod);\n \t  switch_id = return_index;\n \t}\n       else"}]}