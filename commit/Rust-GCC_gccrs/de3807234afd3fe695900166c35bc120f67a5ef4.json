{"sha": "de3807234afd3fe695900166c35bc120f67a5ef4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUzODA3MjM0YWZkM2ZlNjk1OTAwMTY2YzM1YmMxMjBmNjdhNWVmNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-03T06:13:46Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-03T06:13:46Z"}, "message": "gjavah.c (options): Added `jni' entry.\n\n\t* gjavah.c (options): Added `jni' entry.\n\t(help): Document -jni.\n\t(flag_jni): New global.\n\t(process_file): Handle JNI output.  Don't print text from\n\t-prepend, -add, etc, when generating stubs.  Only remove `.class'\n\tsuffix if it actually exists.\n\t(main): Create a `.c' file when run with `--jni --stubs'.  Create\n\tcorrect output file name with `--jni'.\n\t(print_include): Mangle header name differently in JNI case.\n\t(HANDLE_METHOD): In JNI mode, call print_method_info to generate\n\tmethod list.\n\t(print_method_info): Handle JNI case.  Put signature info into\n\tmethod name.  Handle case when STREAM is NULL.\n\t(print_name_for_stub_or_jni): New function.\n\t(print_stub_or_jni): Renamed from `print_stub'.  Handle JNI.\n\t(print_cxx_classname): Handle JNI.\n\t(print_full_cxx_name): Likewise.\n\t(decode_signature_piece): Likewise.\n\t(overloaded_jni_method_exists_p): New function.\n\t(struct method_name): Added `signature' and `sig_length' fields.\n\t(HANDLE_END_FIELD): Do nothing in JNI mode.\n\nFrom-SVN: r31767", "tree": {"sha": "5df2046d6ef1586cc3a1275a5aea8d35e0a255d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5df2046d6ef1586cc3a1275a5aea8d35e0a255d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de3807234afd3fe695900166c35bc120f67a5ef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3807234afd3fe695900166c35bc120f67a5ef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de3807234afd3fe695900166c35bc120f67a5ef4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3807234afd3fe695900166c35bc120f67a5ef4/comments", "author": null, "committer": null, "parents": [{"sha": "cf8e13bbc889b696915cef8dbdce555d8f1617a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf8e13bbc889b696915cef8dbdce555d8f1617a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf8e13bbc889b696915cef8dbdce555d8f1617a6"}], "stats": {"total": 504, "additions": 397, "deletions": 107}, "files": [{"sha": "3e41ae56cf6853bdd24efbd142682d2e8354eb94", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de3807234afd3fe695900166c35bc120f67a5ef4/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de3807234afd3fe695900166c35bc120f67a5ef4/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=de3807234afd3fe695900166c35bc120f67a5ef4", "patch": "@@ -1,3 +1,27 @@\n+2000-02-02  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* gjavah.c (options): Added `jni' entry.\n+\t(help): Document -jni.\n+\t(flag_jni): New global.\n+\t(process_file): Handle JNI output.  Don't print text from\n+\t-prepend, -add, etc, when generating stubs.  Only remove `.class'\n+\tsuffix if it actually exists.\n+\t(main): Create a `.c' file when run with `--jni --stubs'.  Create\n+\tcorrect output file name with `--jni'.\n+\t(print_include): Mangle header name differently in JNI case.\n+\t(HANDLE_METHOD): In JNI mode, call print_method_info to generate\n+\tmethod list.\n+\t(print_method_info): Handle JNI case.  Put signature info into\n+\tmethod name.  Handle case when STREAM is NULL.\n+\t(print_name_for_stub_or_jni): New function.\n+\t(print_stub_or_jni): Renamed from `print_stub'.  Handle JNI.\n+\t(print_cxx_classname): Handle JNI.\n+\t(print_full_cxx_name): Likewise.\n+\t(decode_signature_piece): Likewise.\n+\t(overloaded_jni_method_exists_p): New function.\n+\t(struct method_name): Added `signature' and `sig_length' fields.\n+\t(HANDLE_END_FIELD): Do nothing in JNI mode.\n+\n 2000-02-02  Tom Tromey  <tromey@cygnus.com>\n \n \t* jv-scan.c: Include version.c, <getopt.h>."}, {"sha": "a9d3ae92033dcac96e5679fabf23eeec5c367697", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 373, "deletions": 107, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de3807234afd3fe695900166c35bc120f67a5ef4/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de3807234afd3fe695900166c35bc120f67a5ef4/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=de3807234afd3fe695900166c35bc120f67a5ef4", "patch": "@@ -45,6 +45,9 @@ FILE *out = NULL;\n /* Nonzero on failure.  */\n static int found_error = 0;\n \n+/* Nonzero if we're generating JNI output.  */\n+static int flag_jni = 0;\n+\n /* Directory to place resulting files in. Set by -d option. */\n const char *output_directory = \"\";\n \n@@ -105,6 +108,8 @@ struct method_name\n {\n   unsigned char *name;\n   int length;\n+  unsigned char *signature;\n+  int sig_length;\n   struct method_name *next;\n };\n \n@@ -115,9 +120,12 @@ static void print_field_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));\n static void print_mangled_classname PARAMS ((FILE*, JCF*, const char*, int));\n static int  print_cxx_classname PARAMS ((FILE*, const char*, JCF*, int));\n static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));\n-static void print_c_decl PARAMS ((FILE*, JCF*, int, int, int, const char *));\n-static void print_stub PARAMS ((FILE*, JCF*, int, int, int, const char *));\n-static void print_full_cxx_name PARAMS ((FILE*, JCF*, int, int, int, const char *));\n+static void print_c_decl PARAMS ((FILE*, JCF*, int, int, int, const char *,\n+\t\t\t\t  int));\n+static void print_stub_or_jni PARAMS ((FILE*, JCF*, int, int, int,\n+\t\t\t\t       const char *, int));\n+static void print_full_cxx_name PARAMS ((FILE*, JCF*, int, int, int,\n+\t\t\t\t\t const char *, int));\n static void decompile_method PARAMS ((FILE*, JCF*, int));\n static void add_class_decl PARAMS ((FILE*, JCF*, JCF_u2));\n \n@@ -161,13 +169,13 @@ static int method_pass;\n #define HANDLE_END_FIELD()\t\t\t\t\t\t      \\\n   if (field_pass)\t\t\t\t\t\t\t      \\\n     {\t\t\t\t\t\t\t\t\t      \\\n-      if (out && ! stubs)\t\t\t\t\t\t      \\\n+      if (out && ! stubs && ! flag_jni)\t\t\t\t\t      \\\n \tprint_field_info (out, jcf, current_field_name,\t\t\t      \\\n \t\t\t  current_field_signature,\t\t\t      \\\n  \t\t\t  current_field_flags);\t\t\t\t      \\\n     }\t\t\t\t\t\t\t\t\t      \\\n-  else\t\t\t\t\t\t\t\t\t      \\\n-    if (! stubs) add_class_decl (out, jcf, current_field_signature);\n+  else if (! stubs && ! flag_jni)\t\t\t\t\t      \\\n+    add_class_decl (out, jcf, current_field_signature);\n \n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n@@ -181,8 +189,9 @@ static int method_printed = 0;\n       if (out)\t\t\t\t\t\t\t\t      \\\n         print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS);\t      \\\n     }\t\t\t\t\t\t\t\t\t      \\\n-  else\t\t\t\t\t\t\t\t\t      \\\n-    if (! stubs) add_class_decl (out, jcf, SIGNATURE);\n+  else if (flag_jni)\t\t\t\t\t\t\t      \\\n+    print_method_info (NULL, jcf, NAME, SIGNATURE, ACCESS_FLAGS);\t      \\\n+  else if (! stubs) add_class_decl (out, jcf, SIGNATURE);\n \n #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n   if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);\n@@ -312,8 +321,7 @@ cxx_keyword_subst (str, length)\n   return NULL;\n }\n \n-/* Generate an access control keyword based on FLAGS.  Returns 0 if\n-   FLAGS matches the saved access information, nonzero otherwise.  */\n+/* Generate an access control keyword based on FLAGS.  */\n \n static void\n generate_access (stream, flags)\n@@ -362,6 +370,28 @@ name_is_method_p (name, length)\n   return 0;\n }\n \n+/* If there is already a method named NAME, whose signature is not\n+   SIGNATURE, then return true.  Otherwise return false.  */\n+static int\n+overloaded_jni_method_exists_p (name, length, signature, sig_length)\n+     const unsigned char *name;\n+     int length;\n+     const char *signature;\n+     int sig_length;\n+{\n+  struct method_name *p;\n+\n+  for (p = method_name_list; p != NULL; p = p->next)\n+    {\n+      if (p->length == length\n+\t  && ! memcmp (p->name, name, length)\n+\t  && (p->sig_length != sig_length\n+\t      || memcmp (p->signature, signature, sig_length)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n /* Get name of a field.  This handles renamings due to C++ clash.  */\n static char *\n get_field_name (jcf, name_index, flags)\n@@ -525,7 +555,7 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n     }\n \n   override = get_field_name (jcf, name_index, flags);\n-  print_c_decl (out, jcf, name_index, sig_index, 0, override);\n+  print_c_decl (out, jcf, name_index, sig_index, 0, override, flags);\n   fputs (\";\\n\", out);\n \n   if (override)\n@@ -543,7 +573,7 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n \n   method_declared = 0;\n   method_access = flags;\n-  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n+  if (stream && JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n     fprintf (stream, \"<not a UTF8 constant>\");\n   str = JPOOL_UTF_DATA (jcf, name_index);\n   length = JPOOL_UTF_LENGTH (jcf, name_index);\n@@ -576,9 +606,19 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n       memcpy (nn->name, str, length);\n       nn->length = length;\n       nn->next = method_name_list;\n+      nn->sig_length = JPOOL_UTF_LENGTH (jcf, sig_index);\n+      nn->signature = (char *) xmalloc (nn->sig_length);\n+      memcpy (nn->signature, JPOOL_UTF_DATA (jcf, sig_index),\n+\t      nn->sig_length);\n       method_name_list = nn;\n     }\n \n+  /* If we're not printing, then the rest of this function doesn't\n+     matter.  This happens during the first method pass in JNI mode.\n+     Eww.  */\n+  if (! stream)\n+    return;\n+\n   /* We can't generate a method whose name is a C++ reserved word.  We\n      can't just ignore the function, because that will cause incorrect\n      code to be generated if the function is virtual (not only for\n@@ -595,7 +635,7 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n \treturn;\n     }\n \n-  if (! stubs)\n+  if (! stubs && ! flag_jni)\n     {\n       method_printed = 1;\n \n@@ -610,7 +650,7 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n \t  if (! is_init)\n \t    fputs (\"virtual \", out);\n \t}\n-      print_c_decl (out, jcf, name_index, sig_index, is_init, override);\n+      print_c_decl (out, jcf, name_index, sig_index, is_init, override, flags);\n       \n       if ((flags & ACC_ABSTRACT))\n \tfputs (\" = 0\", out);\n@@ -619,10 +659,11 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n     }\n   else\n     {\n-      if (METHOD_IS_NATIVE(flags)) \n+      if (METHOD_IS_NATIVE (flags)) \n \t{\n \t  method_printed = 1;\n-\t  print_stub (out, jcf, name_index, sig_index, is_init, override);\n+\t  print_stub_or_jni (out, jcf, name_index, sig_index,\n+\t\t\t     is_init, override, flags);\n \t}\n     }\n }\n@@ -704,49 +745,86 @@ decode_signature_piece (stream, signature, limit, need_space)\n     {\n     case '[':\n       /* More spaghetti.  */\n+\n     array_loop:\n       for (signature++; (signature < limit\n \t\t\t && *signature >= '0'\n \t\t\t && *signature <= '9'); signature++)\n \t;\n       switch (*signature)\n \t{\n-\tcase 'B': ctype = \"jbyteArray\";  goto printit;\n-\tcase 'C': ctype = \"jcharArray\";  goto printit;\n-\tcase 'D': ctype = \"jdoubleArray\";  goto printit;\n-\tcase 'F': ctype = \"jfloatArray\";  goto printit;\n-\tcase 'I': ctype = \"jintArray\";  goto printit;\n-\tcase 'S': ctype = \"jshortArray\";  goto printit;\n-\tcase 'J': ctype = \"jlongArray\";  goto printit;\n-\tcase 'Z': ctype = \"jbooleanArray\";  goto printit;\n+\tcase 'B':\n+\t  ctype = \"jbyteArray\";\n+\t  break;\n+\tcase 'C':\n+\t  ctype = \"jcharArray\";\n+\t  break;\n+\tcase 'D':\n+\t  ctype = \"jdoubleArray\";\n+\t  break;\n+\tcase 'F':\n+\t  ctype = \"jfloatArray\";\n+\t  break;\n+\tcase 'I':\n+\t  ctype = \"jintArray\";\n+\t  break;\n+\tcase 'S':\n+\t  ctype = \"jshortArray\";\n+\t  break;\n+\tcase 'J':\n+\t  ctype = \"jlongArray\";\n+\t  break;\n+\tcase 'Z':\n+\t  ctype = \"jbooleanArray\";\n+\t  break;\n \tcase '[':\n \t  /* We have a nested array.  */\n \t  ++array_depth;\n-\t  fputs (\"JArray<\", stream);\n+\t  if (! flag_jni)\n+\t    fputs (\"JArray<\", stream);\n \t  goto array_loop;\n \n \tcase 'L':\n \t  /* We have to generate a reference to JArray here, so that\n \t     our output matches what the compiler does.  */\n \t  ++signature;\n \t  /* Space between `<' and `:' to avoid C++ digraphs.  */\n-\t  fputs (\"JArray< ::\", stream);\n+\t  if (! flag_jni)\n+\t    fputs (\"JArray< ::\", stream);\n \t  while (signature < limit && *signature != ';')\n \t    {\n \t      int ch = UTF8_GET (signature, limit);\n-\t      if (ch == '/')\n-\t\tfputs (\"::\", stream);\n-\t      else\n-\t\tjcf_print_char (stream, ch);\n+\t      if (! flag_jni)\n+\t\t{\n+\t\t  if (ch == '/')\n+\t\t    fputs (\"::\", stream);\n+\t\t  else\n+\t\t    jcf_print_char (stream, ch);\n+\t\t}\n \t    }\n-\t  fputs (\" *> *\", stream);\n+\t  if (! flag_jni)\n+\t    fputs (\" *> *\", stream);\n \t  *need_space = 0;\n-\t  ++signature;\n+\t  ctype = NULL;\n \t  break;\n \tdefault:\n \t  /* Unparseable signature.  */\n \t  return NULL;\n \t}\n+\n+      /* If the previous iterations left us with something to print,\n+\t print it.  For JNI, we always print `jobjectArray' in the\n+\t nested cases.  */\n+      if (flag_jni && ctype == NULL)\n+\t{\n+\t  ctype = \"jobjectArray\";\n+\t  *need_space = 1;\n+\t}\n+      /* The `printit' case will advance SIGNATURE for us.  If we\n+\t don't go there, we must advance past the `;' ourselves.  */\n+      if (ctype != NULL)\n+\tgoto printit;\n+      ++signature;\n       break;\n \n     case '(':\n@@ -764,6 +842,34 @@ decode_signature_piece (stream, signature, limit, need_space)\n     case 'Z': ctype = \"jboolean\";  goto printit;\n     case 'V': ctype = \"void\";  goto printit;\n     case 'L':\n+      if (flag_jni)\n+\t{\n+\t  /* We know about certain types and special-case their\n+\t     names.\n+\t     FIXME: something like java.lang.Exception should be\n+\t     printed as `jthrowable', because it is a subclass.  This\n+\t     means that gcjh must read the entire hierarchy and\n+\t     comprehend it.  */\n+\t  if (! strncmp (signature, \"Ljava/lang/String;\",\n+\t\t\t sizeof (\"Ljava/lang/String;\") -1))\n+\t    ctype = \"jstring\";\n+\t  else if (! strncmp (signature, \"Ljava/lang/Class;\",\n+\t\t\t      sizeof (\"Ljava/lang/Class;\") - 1))\n+\t    ctype = \"jclass\";\n+\t  else if (! strncmp (signature, \"Ljava/lang/Throwable;\",\n+\t\t\t      sizeof (\"Ljava/lang/Throwable;\") - 1))\n+\t    ctype = \"jthrowable\";\n+\t  else if (! strncmp (signature, \"Ljava/lang/ref/WeakReference;\",\n+\t\t\t      sizeof (\"Ljava/lang/ref/WeakReference;\") - 1))\n+\t    ctype = \"jweak\";\n+\t  else\n+\t    ctype = \"jobject\";\n+\n+\t  while (*signature && *signature != ';')\n+\t    ++signature;\n+\n+\t  goto printit;\n+\t}\n       /* Print a leading \"::\" so we look in the right namespace.  */\n       fputs (\"::\", stream);\n       ++signature;\n@@ -792,18 +898,21 @@ decode_signature_piece (stream, signature, limit, need_space)\n       break;\n     }\n \n-  while (array_depth-- > 0)\n-    fputs (\"> *\", stream);\n+  if (! flag_jni)\n+    {\n+      while (array_depth-- > 0)\n+\tfputs (\"> *\", stream);\n+    }\n \n   return signature;\n }\n \n static void\n DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, is_init,\n-\t\t     name_override),\n+\t\t     name_override, flags),\n       FILE* stream AND JCF* jcf\n       AND int name_index AND int signature_index\n-      AND int is_init AND const char *name_override)\n+      AND int is_init AND const char *name_override AND int flags)\n {\n   if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n     {\n@@ -850,16 +959,18 @@ DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, is_init,\n       if (need_space)\n \tfputs (\" \", stream);\n       print_full_cxx_name (stream, jcf, name_index, \n-\t\t\t   signature_index, is_init, name_override);\n+\t\t\t   signature_index, is_init, name_override,\n+\t\t\t   flags);\n     }\n }\n \n /* Print the unqualified method name followed by the signature. */\n static void\n-DEFUN(print_full_cxx_name, (stream, jcf, name_index, signature_index, is_init, name_override),\n+DEFUN(print_full_cxx_name, (stream, jcf, name_index, signature_index,\n+\t\t\t    is_init, name_override, flags),\n       FILE* stream AND JCF* jcf\n       AND int name_index AND int signature_index AND int is_init \n-      AND const char *name_override)\n+      AND const char *name_override AND int flags)\n {\n   int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n   const unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);\n@@ -879,13 +990,75 @@ DEFUN(print_full_cxx_name, (stream, jcf, name_index, signature_index, is_init, n\n       else\n \tprint_name (stream, jcf, name_index);\n     }\n-  \n+\n+  if (flag_jni)\n+    {\n+      unsigned char *signature = JPOOL_UTF_DATA (jcf, signature_index);\n+      int sig_len = JPOOL_UTF_LENGTH (jcf, signature_index);\n+      if (overloaded_jni_method_exists_p (JPOOL_UTF_DATA (jcf, name_index),\n+\t\t\t\t\t  JPOOL_UTF_LENGTH (jcf, name_index),\n+\t\t\t\t\t  signature, sig_len))\n+\t{\n+\t  /* If this method is overloaded by another native method,\n+\t     then include the argument information in the mangled\n+\t     name.  */\n+\t  unsigned char *limit = signature + sig_len;\n+\t  fputs (\"__\", stream);\n+\t  while (signature < limit)\n+\t    {\n+\t      int ch = UTF8_GET (signature, limit);\n+\t      if (ch == '(')\n+\t\t{\n+\t\t  /* Ignore.  */\n+\t\t}\n+\t      else if (ch == ')')\n+\t\t{\n+\t\t  /* Done.  */\n+\t\t  break;\n+\t\t}\n+\t      else if (ch == '_')\n+\t\tfputs (\"_1\", stream);\n+\t      else if (ch == ';')\n+\t\tfputs (\"_2\", stream);\n+\t      else if (ch == '[')\n+\t\tfputs (\"_3\", stream);\n+\t      else if (ch == '/')\n+\t\tfputs (\"_\", stream);\n+\t      else if ((ch >= '0' && ch <= '9')\n+\t\t       || (ch >= 'a' && ch <= 'z')\n+\t\t       || (ch >= 'A' && ch <= 'Z'))\n+\t\tfputc (ch, stream);\n+\t      else\n+\t\t{\n+\t\t  /* \"Unicode\" character.  FIXME: upper or lower case\n+\t\t     letters?  */\n+\t\t  fprintf (stream, \"_0%04x\", ch);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   if (is_method)\n     {\n       /* Have a method or a constructor.  Print signature pieces\n \t until done.  */\n       fputs (\" (\", stream);\n+\n       str = str0 + 1;\n+\n+      /* In JNI mode, add extra arguments.  */\n+      if (flag_jni)\n+\t{\n+\t  /* FIXME: it would be nice to know if we are printing a decl\n+\t     or a definition, and only print `env' for the latter.  */\n+\t  fputs (\"JNIEnv *env\", stream);\n+\n+\t  fputs ((flags & ACC_STATIC) ? \", jclass\" : \", jobject\", stream);\n+\n+\t  if (*str != ')')\n+\t    fputs (\", \", stream);\n+\t}\n+\n       while (str < limit && *str != ')')\n \t{\n \t  next = decode_signature_piece (stream, str, limit, &need_space);\n@@ -905,12 +1078,28 @@ DEFUN(print_full_cxx_name, (stream, jcf, name_index, signature_index, is_init, n\n     }\n }\n \n+/* This is a helper for print_stub_or_jni.  */\n static void\n-DEFUN(print_stub, (stream, jcf, name_index, signature_index, is_init,\n-\t\t     name_override),\n+DEFUN (print_name_for_stub_or_jni, (stream, jcf, name_index, signature_index,\n+\t\t\t\t    is_init, name_override, flags),\n+       FILE *stream AND JCF *jcf\n+       AND int name_index AND int signature_index\n+       AND int is_init AND const char *name_override AND int flags)\n+{\n+  char *prefix = flag_jni ? \"Java_\" : \"\\n\";\n+  print_cxx_classname (stream, prefix, jcf, jcf->this_class);\n+  fputs (flag_jni ? \"_\" : \"::\", stream);\n+  print_full_cxx_name (stream, jcf, name_index, \n+\t\t       signature_index, is_init, name_override,\n+\t\t       flags);\n+}\n+\n+static void\n+DEFUN(print_stub_or_jni, (stream, jcf, name_index, signature_index, is_init,\n+\t\t\t  name_override, flags),\n       FILE* stream AND JCF* jcf\n       AND int name_index AND int signature_index\n-      AND int is_init AND const char *name_override)\n+      AND int is_init AND const char *name_override AND int flags)\n {\n   if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n     {\n@@ -927,6 +1116,13 @@ DEFUN(print_stub, (stream, jcf, name_index, signature_index, is_init,\n       int is_method = str[0] == '(';\n       const unsigned char *next;\n \n+      /* Don't print fields in the JNI case.  */\n+      if (! is_method && flag_jni)\n+\treturn;\n+\n+      if (flag_jni && ! stubs)\n+\tfputs (\"extern \", stream);\n+\n       /* If printing a method, skip to the return signature and print\n \t that first.  However, there is no return value if this is a\n \t constructor.  */\n@@ -941,7 +1137,8 @@ DEFUN(print_stub, (stream, jcf, name_index, signature_index, is_init,\n \t}\n \n       /* If printing a field or an ordinary method, then print the\n-\t \"return value\" now.  */\n+\t \"return value\" now.  Note that a constructor can't be native,\n+\t so we don't bother checking this in the JNI case.  */\n       if (! is_method || ! is_init)\n \t{\n \t  next = decode_signature_piece (stream, str, limit, &need_space);\n@@ -953,17 +1150,29 @@ DEFUN(print_stub, (stream, jcf, name_index, signature_index, is_init,\n \t    }\n \t}\n \n+      /* When printing a JNI header we need to respect the space.  In\n+\t other cases we're just going to insert a newline anyway.  */\n+      if (flag_jni)\n+\tfputs (need_space && ! stubs ? \" \" : \"\\n\", stream);\n+\n       /* Now print the name of the thing.  */\n-      print_cxx_classname (stream, \"\\n\", jcf, jcf->this_class);\n-      fputs (\"::\", stream);\n-      print_full_cxx_name (stream, jcf, name_index, \n-\t\t\t   signature_index, is_init, name_override);\n-      fputs (\"\\n{\\n  JvFail (\\\"\", stream);\n-      print_cxx_classname (stream, \"\", jcf, jcf->this_class);\n-      fputs (\"::\", stream);\n-      print_full_cxx_name (stream, jcf, name_index, \n-\t\t\t   signature_index, is_init, name_override);\n-      fputs (\" not implemented\\\");\\n}\\n\\n\", stream);\n+      print_name_for_stub_or_jni (stream, jcf, name_index,\n+\t\t\t\t  signature_index, is_init, name_override,\n+\t\t\t\t  flags);\n+\n+      /* Print the body.  */\n+      if (stubs)\n+\t{\n+\t  if (flag_jni)\n+\t    fputs (\"\\n{\\n  (*env)->FatalError (\\\"\", stream);\n+\t  else\n+\t    fputs (\"\\n{\\n  JvFail (\\\"\", stream);\n+\t  print_name_for_stub_or_jni (stream, jcf, name_index,\n+\t\t\t\t      signature_index, is_init,\n+\t\t\t\t      name_override,\n+\t\t\t\t      flags);\n+\t  fputs (\" not implemented\\\");\\n}\\n\\n\", stream);\n+\t}\n     }\n }\n \n@@ -1006,13 +1215,14 @@ print_cxx_classname (stream, prefix, jcf, index)\n   fputs (prefix, stream);\n \n   /* Print a leading \"::\" so we look in the right namespace.  */\n-  fputs (\"::\", stream);\n+  if (! flag_jni)\n+    fputs (\"::\", stream);\n \n   while (s < limit)\n     {\n       c = UTF8_GET (s, limit);\n       if (c == '/')\n-\tfputs (\"::\", stream);\n+\tfputs (flag_jni ? \"_\" : \"::\", stream);\n       else\n \tjcf_print_char (stream, c);\n     }\n@@ -1084,7 +1294,9 @@ print_include (out, utf8, len)\n   all_includes = incl;\n \n   fputs (\"#include <\", out);\n-  jcf_print_utf8 (out, utf8, len);\n+  jcf_print_utf8_replace (out, utf8, len,\n+\t\t\t  '/',\n+\t\t\t  flag_jni ? '_' : '/');\n   fputs (\".h>\\n\", out);\n }\n \n@@ -1356,17 +1568,46 @@ DEFUN(process_file, (jcf, out),\n \n   if (written_class_count++ == 0 && out)\n     {\n+      char *cstart, *cstart2, *mode, *cend, *what, *jflag;\n+      if (flag_jni)\n+\t{\n+\t  cstart = \"/*\";\n+\t  cstart2 = \"  \";\n+\t  cend = \" */\";\n+\t  mode = \"\";\n+\t  what = \"JNI\";\n+\t  jflag = \" -jni\";\n+\t}\n+      else\n+\t{\n+\t  cstart = \"//\";\n+\t  cstart2 = \"//\";\n+\t  cend = \"\";\n+\t  mode = \" -*- c++ -*-\";\n+\t  what = \"CNI\";\n+\t  jflag = \"\";\n+\t}\n+\n       if (! stubs)\n-\tfputs (\"// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\\n\\n\",\n-\t       out);\n+\tfprintf (out, \"%s DO NOT EDIT THIS FILE - it is machine generated%s%s\\n\\n\",\n+\t\t cstart, mode, cend);\n       else\n \t{\n-\t  fputs (\"// This file was created by `gcjh -stubs'.  It is -*- c++ -*-.\\n\\\n-//\\n\\\n-// This file is intended to give you a head start on implementing native\\n\\\n-// methods using CNI.\\n\\\n-// Be aware: running `gcjh -stubs' once more for this class may overwrite any\\n\\\n-// edits you have made to this file.\\n\\n\", out);\n+\t  fprintf (out, \"%s This file was created by `gcjh -stubs%s'.%s\\n\\\n+%s\\n\\\n+%s This file is intended to give you a head start on implementing native\\n\\\n+%s methods using %s.\\n\\\n+%s Be aware: running `gcjh -stubs %s' once more for this class may\\n\\\n+%s overwrite any edits you have made to this file.%s\\n\\n\",\n+\t\t   cstart, jflag, mode,\n+\t\t   cstart2,\n+\t\t   cstart2,\n+\t\t   cstart2,\n+\t\t   what,\n+\t\t   cstart2,\n+\t\t   jflag,\n+\t\t   cstart2,\n+\t\t   cend);\n \t}\n     }\n \n@@ -1376,30 +1617,44 @@ DEFUN(process_file, (jcf, out),\n \t{\n \t  print_mangled_classname (out, jcf, \"#ifndef __\", jcf->this_class);\n \t  fprintf (out, \"__\\n\");\n-\t  \n+\n \t  print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n \t  fprintf (out, \"__\\n\\n\");\n-\t  \n-\t  /* We do this to ensure that inline methods won't be `outlined'\n-\t     by g++.  This works as long as method and fields are not\n-\t     added by the user.  */\n-\t  fprintf (out, \"#pragma interface\\n\");\n-\t  \n-\t  if (jcf->super_class)\n+\n+\t  if (flag_jni)\n \t    {\n-\t      int super_length;\n-\t      const unsigned char *supername =\n-\t\tsuper_class_name (jcf, &super_length);\n-\t      \n-\t      fputs (\"\\n\", out);\n-\t      print_include (out, supername, super_length);\n+\t      fprintf (out, \"#include <jni.h>\\n\\n\");\n+\t      fprintf (out, \"#ifdef __cplusplus\\n\");\n+\t      fprintf (out, \"extern \\\"C\\\"\\n\");\n+\t      fprintf (out, \"{\\n\");\n+\t      fprintf (out, \"#endif\\n\");\n+\t    }\n+\t  else  \n+\t    {\n+\t      /* We do this to ensure that inline methods won't be\n+\t\t `outlined' by g++.  This works as long as method and\n+\t\t fields are not added by the user.  */\n+\t      fprintf (out, \"#pragma interface\\n\");\n+\n+\t      if (jcf->super_class)\n+\t\t{\n+\t\t  int super_length;\n+\t\t  const unsigned char *supername =\n+\t\t    super_class_name (jcf, &super_length);\n+\n+\t\t  fputs (\"\\n\", out);\n+\t\t  print_include (out, supername, super_length);\n+\t\t}\n \t    }\n \t}\n       else\n \t{\n \t  /* Strip off the \".class\" portion of the name when printing\n \t     the include file name.  */\n-\t  print_include (out, jcf->classname, strlen (jcf->classname) - 6);\n+\t  int len = strlen (jcf->classname);\n+\t  if (len > 6 && ! strcmp (&jcf->classname[len - 6], \".class\"))\n+\t    len -= 6;\n+\t  print_include (out, jcf->classname, len);\n \t}\n     }\n \n@@ -1417,17 +1672,18 @@ DEFUN(process_file, (jcf, out),\n   jcf_parse_methods (jcf);\n \n   if (out)\n-    {\n-      fputs (\"\\n\", out);\n+    fputs (\"\\n\", out);\n \n+  if (out && ! flag_jni)\n+    {\n       if (! stubs)\n \tprint_class_decls (out, jcf, jcf->this_class);\n \n       for (i = 0; i < prepend_count; ++i)\n \tfprintf (out, \"%s\\n\", prepend_specs[i]);\n       if (prepend_count > 0)\n \tfputc ('\\n', out);\n-      \n+\n       if (! stubs)\n \t{\n \t  if (! print_cxx_classname (out, \"class \", jcf, jcf->this_class))\n@@ -1464,32 +1720,38 @@ DEFUN(process_file, (jcf, out),\n \n   jcf_parse_final_attributes (jcf);\n \n-  if (out)\n+  if (out && ! stubs)\n     {\n-      /* Generate friend decl if we still must.  */\n-      for (i = 0; i < friend_count; ++i)\n-\tfprintf (out, \"  friend %s\\n\", friend_specs[i]);\n-\n-      /* Generate extra declarations.  */\n-      if (add_count > 0)\n-\tfputc ('\\n', out);\n-      for (i = 0; i < add_count; ++i)\n-\tfprintf (out, \"  %s\\n\", add_specs[i]);\n-\n-      if (! stubs)\n-\tfputs (\"};\\n\", out);\n-\n-      if (append_count > 0)\n-\tfputc ('\\n', out);\n-      for (i = 0; i < append_count; ++i)\n-\tfprintf (out, \"%s\\n\", append_specs[i]);\n-\n-      if (!stubs)\n+      if (flag_jni)\n \t{\n-\t  print_mangled_classname (out, jcf, \n-\t\t\t\t   \"\\n#endif /* __\", jcf->this_class);\n-\t  fprintf (out, \"__ */\\n\");\n+\t      fprintf (out, \"\\n#ifdef __cplusplus\\n\");\n+\t      fprintf (out, \"}\\n\");\n+\t      fprintf (out, \"#endif\\n\");\n \t}\n+      else\n+\t{\n+\t  /* Generate friend decl if we still must.  */\n+\t  for (i = 0; i < friend_count; ++i)\n+\t    fprintf (out, \"  friend %s\\n\", friend_specs[i]);\n+\n+\t  /* Generate extra declarations.  */\n+\t  if (add_count > 0)\n+\t    fputc ('\\n', out);\n+\t  for (i = 0; i < add_count; ++i)\n+\t    fprintf (out, \"  %s\\n\", add_specs[i]);\n+\n+\t  if (! stubs)\n+\t    fputs (\"};\\n\", out);\n+\n+\t  if (append_count > 0)\n+\t    fputc ('\\n', out);\n+\t  for (i = 0; i < append_count; ++i)\n+\t    fprintf (out, \"%s\\n\", append_specs[i]);\n+\t}\n+\n+      print_mangled_classname (out, jcf, \n+\t\t\t       \"\\n#endif /* __\", jcf->this_class);\n+      fprintf (out, \"__ */\\n\");\n     }\n }\n \n@@ -1531,6 +1793,7 @@ static struct option options[] =\n   { \"MG\",        no_argument,       NULL, OPT_MG  },\n   { \"MD\",        no_argument,       NULL, OPT_MD  },\n   { \"MMD\",       no_argument,       NULL, OPT_MMD },\n+  { \"jni\",       no_argument,       &flag_jni, 1 },\n   { NULL,        no_argument,       NULL, 0 }\n };\n \n@@ -1547,6 +1810,7 @@ help ()\n   printf (\"Usage: gcjh [OPTION]... CLASS...\\n\\n\");\n   printf (\"Generate C++ header files from .class files\\n\\n\");\n   printf (\"  -stubs                  Generate an implementation stub file\\n\");\n+  printf (\"  -jni                    Generate a JNI header or stub\\n\");\n   printf (\"\\n\");\n   printf (\"  -add TEXT               Insert TEXT into class body\\n\");\n   printf (\"  -append TEXT            Insert TEXT after class declaration\\n\");\n@@ -1767,6 +2031,8 @@ DEFUN(main, (argc, argv),\n \t      char ch = classname[i];\n \t      if (ch == '.')\n \t\tch = '/';\n+\t      if (flag_jni && ch == '/')\n+\t\tch = '_';\n \t      current_output_file[dir_len++] = ch;\n \t    }\n \t  if (emit_dependencies)\n@@ -1785,7 +2051,7 @@ DEFUN(main, (argc, argv),\n \t\t}\n \t    }\n \t  strcpy (current_output_file + dir_len, \n-\t\t  stubs ? \".cc\" : \".h\");\n+\t\t  stubs ? (flag_jni ? \".c\" : \".cc\") : \".h\");\n \t  jcf_dependency_set_target (current_output_file);\n \t  if (! suppress_output)\n \t    {"}]}