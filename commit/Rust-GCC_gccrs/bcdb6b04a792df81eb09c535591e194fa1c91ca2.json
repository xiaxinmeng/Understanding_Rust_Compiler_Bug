{"sha": "bcdb6b04a792df81eb09c535591e194fa1c91ca2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNkYjZiMDRhNzkyZGY4MWViMDljNTM1NTkxZTE5NGZhMWM5MWNhMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:54:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:54:31Z"}, "message": "[multiple changes]\n\n2014-11-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb, freeze.adb: Minor reformatting.\n\t* gnat_rm.texi: Minor editing.\n\n2014-11-20  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Minor reformatting.\n\t(Process_Suppress_Unsuppress): Ignore suppress Elaboration_Check\n\tin SPARK.\n\n2014-11-20  Bob Duff  <duff@adacore.com>\n\n\t* gnat_rm.texi: Correction to documentation of\n\t'Unrestricted_Access in case of access to unconstrained array.\n\t* a-cofove.adb (Capacity): Fix bug -- was always\n\treturning Capacity_Range'Last.\n\t(Is_Sorted): Fix bug -- was always returning True, because\n\tContainer.Last = Last. That test isn't even needed, because the\n\tloop will go around zero times in that case, so deleted that\n\ttest rather than fixing it.\n\t(Reverse_Elements): Make sure to use the correct array bounds.\n\n2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Associations): In GNATProve mode, build\n\twrappers for functions and operators that are actuals only if\n\texpander is enabled. Wrappers play no role within a generic unit.\n\n2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_util.adb (Policy_In_Effect): Use the\n\tconfiguration level assertion flag.\n\nFrom-SVN: r217880", "tree": {"sha": "a166a042e46ffdda1e02b61c32e2d8322bded64f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a166a042e46ffdda1e02b61c32e2d8322bded64f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcdb6b04a792df81eb09c535591e194fa1c91ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcdb6b04a792df81eb09c535591e194fa1c91ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcdb6b04a792df81eb09c535591e194fa1c91ca2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcdb6b04a792df81eb09c535591e194fa1c91ca2/comments", "author": null, "committer": null, "parents": [{"sha": "d7d99211f9001bd2c1c5874e1bcf8bbb460aa2dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7d99211f9001bd2c1c5874e1bcf8bbb460aa2dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7d99211f9001bd2c1c5874e1bcf8bbb460aa2dc"}], "stats": {"total": 174, "additions": 106, "deletions": 68}, "files": [{"sha": "cf6060da43709d218c0be2800c00253a53829297", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -1,3 +1,37 @@\n+2014-11-20  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch13.adb, freeze.adb: Minor reformatting.\n+\t* gnat_rm.texi: Minor editing.\n+\n+2014-11-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Minor reformatting.\n+\t(Process_Suppress_Unsuppress): Ignore suppress Elaboration_Check\n+\tin SPARK.\n+\n+2014-11-20  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_rm.texi: Correction to documentation of\n+\t'Unrestricted_Access in case of access to unconstrained array.\n+\t* a-cofove.adb (Capacity): Fix bug -- was always\n+\treturning Capacity_Range'Last.\n+\t(Is_Sorted): Fix bug -- was always returning True, because\n+\tContainer.Last = Last. That test isn't even needed, because the\n+\tloop will go around zero times in that case, so deleted that\n+\ttest rather than fixing it.\n+\t(Reverse_Elements): Make sure to use the correct array bounds.\n+\n+2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Associations): In GNATProve mode, build\n+\twrappers for functions and operators that are actuals only if\n+\texpander is enabled. Wrappers play no role within a generic unit.\n+\n+2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_util.adb (Policy_In_Effect): Use the\n+\tconfiguration level assertion flag.\n+\n 2014-11-20  Arnaud Charlet  <charlet@adacore.com>\n \n \t* s-parame-ae653.ads: Update comments."}, {"sha": "df02dc01ee5074be9a2bf36bcd0b463f381a9e3c", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -150,7 +150,9 @@ is\n \n    function Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return Elemsc (Container)'Length;\n+      return (if Container.Elements_Ptr = null\n+              then Container.Elements'Length\n+              else Container.Elements_Ptr.all'Length);\n    end Capacity;\n \n    -----------\n@@ -160,8 +162,10 @@ is\n    procedure Clear (Container : in out Vector) is\n    begin\n       Container.Last := No_Index;\n+\n+      --  Free element, note that this is OK if Elements_Ptr is null\n+\n       Free (Container.Elements_Ptr);\n-      --  It's OK if Container.Elements_Ptr is null\n    end Clear;\n \n    --------------\n@@ -211,8 +215,7 @@ is\n       Current   : Index_Type) return Vector\n    is\n    begin\n-      return Result : Vector\n-        (Count_Type (Container.Last - Current + 1))\n+      return Result : Vector (Count_Type (Container.Last - Current + 1))\n       do\n          for X in Current .. Container.Last loop\n             Append (Result, Element (Container, X));\n@@ -268,16 +271,16 @@ is\n    function Elems (Container : in out Vector) return Maximal_Array_Ptr is\n    begin\n       return (if Container.Elements_Ptr = null\n-                then Container.Elements'Unrestricted_Access\n-                else Container.Elements_Ptr.all'Unrestricted_Access);\n+              then Container.Elements'Unrestricted_Access\n+              else Container.Elements_Ptr.all'Unrestricted_Access);\n    end Elems;\n \n    function Elemsc\n      (Container : Vector) return Maximal_Array_Ptr_Const is\n    begin\n       return (if Container.Elements_Ptr = null\n-                then Container.Elements'Unrestricted_Access\n-                else Container.Elements_Ptr.all'Unrestricted_Access);\n+              then Container.Elements'Unrestricted_Access\n+              else Container.Elements_Ptr.all'Unrestricted_Access);\n    end Elemsc;\n \n    ----------------\n@@ -313,9 +316,9 @@ is\n    begin\n       if Is_Empty (Container) then\n          raise Constraint_Error with \"Container is empty\";\n+      else\n+         return Get_Element (Container, 1);\n       end if;\n-\n-      return Get_Element (Container, 1);\n    end First_Element;\n \n    -----------------\n@@ -357,24 +360,15 @@ is\n       ---------------\n \n       function Is_Sorted (Container : Vector) return Boolean is\n-         Last : constant Index_Type := Last_Index (Container);\n-\n+         L : constant Capacity_Range := Length (Container);\n       begin\n-         if Container.Last <= Last then\n-            return True;\n-         end if;\n-\n-         declare\n-            L : constant Capacity_Range := Length (Container);\n-         begin\n-            for J in 1 .. L - 1 loop\n-               if Get_Element (Container, J + 1) <\n-                  Get_Element (Container, J)\n-               then\n-                  return False;\n-               end if;\n-            end loop;\n-         end;\n+         for J in 1 .. L - 1 loop\n+            if Get_Element (Container, J + 1) <\n+               Get_Element (Container, J)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n \n          return True;\n       end Is_Sorted;\n@@ -396,9 +390,9 @@ is\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n+         else\n+            Sort (Elems (Container) (1 .. Len));\n          end if;\n-\n-         Sort (Elems (Container) (1 .. Len));\n       end Sort;\n \n    end Generic_Sorting;\n@@ -442,9 +436,9 @@ is\n    begin\n       if Is_Empty (Container) then\n          raise Constraint_Error with \"Container is empty\";\n+      else\n+         return Get_Element (Container, Length (Container));\n       end if;\n-\n-      return Get_Element (Container, Length (Container));\n    end Last_Element;\n \n    ----------------\n@@ -464,7 +458,6 @@ is\n       L : constant Int := Int (Last_Index (Container));\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n-\n    begin\n       return Capacity_Range (N);\n    end Length;\n@@ -486,7 +479,6 @@ is\n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Capacity_Range := Capacity_Range (II);\n-\n       begin\n          Elems (Container) (I) := New_Item;\n       end;\n@@ -509,8 +501,8 @@ is\n          if Capacity > Formal_Vectors.Capacity (Container) then\n             declare\n                New_Elements : constant Elements_Array_Ptr :=\n-                 new Elements_Array (1 .. Capacity);\n-               L : constant Capacity_Range := Length (Container);\n+                                new Elements_Array (1 .. Capacity);\n+               L            : constant Capacity_Range := Length (Container);\n             begin\n                New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n                Free (Container.Elements_Ptr);\n@@ -532,7 +524,8 @@ is\n \n       declare\n          I, J : Capacity_Range;\n-         E    : Elements_Array renames Elems (Container).all;\n+         E    : Elements_Array renames\n+                  Elems (Container) (1 .. Length (Container));\n \n       begin\n          I := 1;\n@@ -640,8 +633,10 @@ is\n \n          Last := Index_Type (Last_As_Int);\n \n-         return (Capacity => Length, Last => Last, Elements_Ptr => <>,\n-                 Elements => (others => New_Item));\n+         return (Capacity     => Length,\n+                 Last         => Last,\n+                 Elements_Ptr => <>,\n+                 Elements     => (others => New_Item));\n       end;\n    end To_Vector;\n "}, {"sha": "532bde9a146cd886885896d11ad3172e72a58e64", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -7695,17 +7695,16 @@ package body Freeze is\n \n    procedure Set_SSO_From_Default (T : Entity_Id) is\n    begin\n-      --  Set default SSO for an array or record base type, except in the case\n-      --  of a type extension (which always inherits the SSO of its parent\n-      --  type).\n+      --  Set default SSO for an array or record base type, except in case of\n+      --  a type extension (which always inherits the SSO of its parent type).\n \n       if Is_Base_Type (T)\n         and then (Is_Array_Type (T)\n                    or else (Is_Record_Type (T)\n                              and then not (Is_Tagged_Type (T)\n                                             and then Is_Derived_Type (T))))\n       then\n-         if ((Bytes_Big_Endian       and then SSO_Set_Low_By_Default  (T))\n+         if ((Bytes_Big_Endian      and then SSO_Set_Low_By_Default  (T))\n                 or else\n             ((not Bytes_Big_Endian) and then SSO_Set_High_By_Default (T)))\n "}, {"sha": "6bf94620be678e16b3a83a344921afa09f26620e", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -9994,17 +9994,17 @@ called after P2 returns, it would be an erroneous use of a dangling\n pointer.\n \n For objects, it is possible to use @code{Unrestricted_Access} for any\n-type, but care must be exercised if it is used to create pointers to\n-unconstrained array objects.  In this case, the resulting pointer has\n-the same scope as the context of the attribute, and may not be\n-returned to some enclosing scope.  For instance, a function cannot use\n-@code{Unrestricted_Access} to create a pointer to unconstrained and\n-then return that value to the caller.  In addition, it is only valid\n-to create pointers to unconstrained arrays using this attribute if the\n-pointer has the normal default ``fat'' representation where a pointer\n-has two components, one points to the array and one points to the\n-bounds.  If a size clause is used to force ``thin'' representation for\n-a pointer to unconstrained where there is only space for a single\n+type. However, if the result is of an access-to-unconstrained array\n+subtype, then the resulting pointer has the same scope as the context\n+of the attribute, and must not be returned to some enclosing scope.\n+For instance, if a function uses @code{Unrestricted_Access} to create\n+an access-to-unconstrained-array and returns that value to the caller,\n+the result will involve dangling pointers. In addition, it is only\n+valid to create pointers to unconstrained arrays using this attribute\n+if the pointer has the normal default ``fat'' representation where a\n+pointer has two components, one points to the array and one points to\n+the bounds. If a size clause is used to force ``thin'' representation\n+for a pointer to unconstrained where there is only space for a single\n pointer, then the resulting pointer is not usable.\n \n In the simple case where a direct use of Unrestricted_Access attempts"}, {"sha": "6062a88d60f7d079b9c16c8c3a2a95bd524b4415", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -1087,7 +1087,8 @@ package body Sem_Ch12 is\n \n                else\n                   Parm_Type :=\n-                    Make_Identifier (Loc, Chars (Etype (Etype (Form_F))));\n+                    Make_Identifier (Loc,\n+                      Chars => Chars (First_Subtype (Etype (Form_F))));\n                end if;\n \n             --  If actual is present, use the type of its own formal\n@@ -1805,9 +1806,10 @@ package body Sem_Ch12 is\n                                                                     E_Function\n                      then\n                         --  If actual is an entity (function or operator),\n-                        --  build wrapper for it.\n+                        --  and expander is active, build wrapper for it.\n+                        --  Note that wrappers play no role within a generic.\n \n-                        if Present (Match) then\n+                        if Present (Match) and then Expander_Active then\n                            if Nkind (Match) = N_Operator_Symbol then\n \n                               --  If the name is a default, find its visible\n@@ -1835,6 +1837,7 @@ package body Sem_Ch12 is\n                         elsif Box_Present (Formal)\n                            and then Nkind (Defining_Entity (Analyzed_Formal)) =\n                                                     N_Defining_Operator_Symbol\n+                           and then Expander_Active\n                         then\n                            Append_To (Assoc,\n                              Build_Operator_Wrapper"}, {"sha": "8443daf6fcd46572737a24f1bf9b967e2ea016c8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -10971,10 +10971,8 @@ package body Sem_Ch13 is\n             --  in a flag of the base type!\n \n             if (Is_Record_Type (Typ) or else Is_Array_Type (Typ))\n-                 and then\n-               Typ = Bas_Typ\n+                 and then Typ = Bas_Typ\n             then\n-\n                --  For a type extension, always inherit from parent; otherwise\n                --  inherit if no default applies. Note: we do not check for\n                --  an explicit rep item on the parent type when inheriting,\n@@ -10983,10 +10981,9 @@ package body Sem_Ch13 is\n                if not Has_Rep_Item (First_Subtype (Typ),\n                                     Name_Scalar_Storage_Order, False)\n                  and then (Is_Tagged_Type (Bas_Typ)\n-                             or else\n-                           not (SSO_Set_Low_By_Default  (Bas_Typ)\n-                                  or else\n-                                SSO_Set_High_By_Default (Bas_Typ)))\n+                            or else not (SSO_Set_Low_By_Default  (Bas_Typ)\n+                                           or else\n+                                         SSO_Set_High_By_Default (Bas_Typ)))\n                then\n                   Set_Reverse_Storage_Order (Bas_Typ,\n                     Reverse_Storage_Order"}, {"sha": "7872328e063b36dd798570caffb249b0ae4a4d90", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -2730,7 +2730,7 @@ package body Sem_Prag is\n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n       --  83 mode (used for language pragmas that are not a standard part of\n-      --  Ada 83). This procedure does not raise Error_Pragma. Also notes use\n+      --  Ada 83). This procedure does not raise Pragma_Exit. Also notes use\n       --  of 95 pragma.\n \n       procedure Check_Arg_Count (Required : Nat);\n@@ -9046,6 +9046,15 @@ package body Sem_Prag is\n               (\"argument of pragma% is not valid check name\", Arg1);\n          end if;\n \n+         --  Warn that suppress of Elaboration_Check has no effect in SPARK\n+\n+         if C = Elaboration_Check and then SPARK_Mode = On then\n+            Error_Pragma_Arg\n+              (\"Suppress of Elaboration_Check ignored in SPARK??\", Arg1);\n+         end if;\n+\n+         --  One-argument case\n+\n          if Arg_Count = 1 then\n \n             --  Make an entry in the local scope suppress table. This is the\n@@ -20282,7 +20291,7 @@ package body Sem_Prag is\n          --  pragma Suppress (IDENTIFIER [, [On =>] NAME]);\n \n          when Pragma_Suppress =>\n-            Process_Suppress_Unsuppress (True);\n+            Process_Suppress_Unsuppress (Suppress_Case => True);\n \n          ------------------\n          -- Suppress_All --\n@@ -21120,7 +21129,7 @@ package body Sem_Prag is\n \n          when Pragma_Unsuppress =>\n             Ada_2005_Pragma;\n-            Process_Suppress_Unsuppress (False);\n+            Process_Suppress_Unsuppress (Suppress_Case => False);\n \n          ----------------------------\n          -- Unevaluated_Use_Of_Old --"}, {"sha": "fced97839664e3f33ed8ee271629cc0e85b76f39", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcdb6b04a792df81eb09c535591e194fa1c91ca2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bcdb6b04a792df81eb09c535591e194fa1c91ca2", "patch": "@@ -15726,10 +15726,11 @@ package body Sem_Util is\n       end if;\n \n       --  The context lacks policy pragmas, determine the mode based on whether\n-      --  assertions are enabled.\n+      --  assertions are enabled at the configuration level. This ensures that\n+      --  the policy is preserved when analyzing generics.\n \n       if Kind = No_Name then\n-         if Assertions_Enabled then\n+         if Assertions_Enabled_Config then\n             Kind := Name_Check;\n          else\n             Kind := Name_Ignore;"}]}