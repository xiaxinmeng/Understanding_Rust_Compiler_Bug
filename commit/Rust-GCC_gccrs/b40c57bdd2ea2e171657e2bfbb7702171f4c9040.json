{"sha": "b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwYzU3YmRkMmVhMmUxNzE2NTdlMmJmYmI3NzAyMTcxZjRjOTA0MA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-13T17:17:01Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-15T15:56:10Z"}, "message": "libstdc++: Convert the ranges algorithm entities into function objects\n\nThis is the standard way to inhibit ADL for these entities, which is required as\nper [algorithms.requirements] p2 and [specialized.algorithms] p4.  The\nconversion was done mostly mechanically with a custom Vim macro.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h: (adjacent_find, all_of, any_of,\n\tbinary_search, copy_if, count, count_if, equal_range, find, find_end,\n\tfind_first_of, find_if, find_if_not, for_each, generate, generate_n,\n\tincludes, inplace_merge, is_heap, is_heap_until, is_partitioned,\n\tis_permutation, is_sorted, is_sorted_until, lexicographical_compare,\n\tlower_bound, make_heap, max, max_element, merge, min, min_element,\n\tminmax, minmax_element, mismatch, next_permutation, none_of,\n\tnth_element, partial_sort, partial_sort_copy, partition, partition_copy,\n\tpartition_point, pop_heap, prev_permutation, push_heap, remove,\n\tremove_copy, remove_copy_if, remove_if, replace, replace_copy,\n\treplace_copy_if, replace_if, reverse, reverse_copy, rotate, rotate_copy,\n\tsearch, search_n, set_difference, set_intersection,\n\tset_symmetric_difference, set_union, shuffle, sort, sort_heap,\n\tstable_partition, stable_sort, swap_ranges, transform, unique,\n\tunique_copy, upper_bound): Convert into function objects.\n\t* include/bits/ranges_algobase.h: (equal, copy, move, copy_n, fill_n,\n\tfill, move_backward, copy_backward): Likewise.\n\t* include/bits/ranges_uninitialized.h (uninitialized_default_construct,\n\tuninitialized_default_construct_n, uninitialized_value_construct,\n\tuninitialized_value_construct_n, uninitialized_copy,\n\tuninitialized_copy_n, uninitialized_move, uninitialized_move_n,\n\tuninitialized_fill, uninitialized_fill_n, construct_at, destroy_at,\n\tdestroy, destroy_n): Likewise.", "tree": {"sha": "f1708a8084e01f75f56cd2e5b79d7a2af127dc51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1708a8084e01f75f56cd2e5b79d7a2af127dc51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/comments", "author": null, "committer": null, "parents": [{"sha": "90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a"}], "stats": {"total": 7082, "additions": 3796, "deletions": 3286}, "files": [{"sha": "cdb70789412b7586de7edaaa0ad23df9bb28d27a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "patch": "@@ -1,5 +1,29 @@\n 2020-02-15  Patrick Palka  <ppalka@redhat.com>\n \n+\t* include/bits/ranges_algo.h: (adjacent_find, all_of, any_of,\n+\tbinary_search, copy_if, count, count_if, equal_range, find, find_end,\n+\tfind_first_of, find_if, find_if_not, for_each, generate, generate_n,\n+\tincludes, inplace_merge, is_heap, is_heap_until, is_partitioned,\n+\tis_permutation, is_sorted, is_sorted_until, lexicographical_compare,\n+\tlower_bound, make_heap, max, max_element, merge, min, min_element,\n+\tminmax, minmax_element, mismatch, next_permutation, none_of,\n+\tnth_element, partial_sort, partial_sort_copy, partition, partition_copy,\n+\tpartition_point, pop_heap, prev_permutation, push_heap, remove,\n+\tremove_copy, remove_copy_if, remove_if, replace, replace_copy,\n+\treplace_copy_if, replace_if, reverse, reverse_copy, rotate, rotate_copy,\n+\tsearch, search_n, set_difference, set_intersection,\n+\tset_symmetric_difference, set_union, shuffle, sort, sort_heap,\n+\tstable_partition, stable_sort, swap_ranges, transform, unique,\n+\tunique_copy, upper_bound): Convert into function objects.\n+\t* include/bits/ranges_algobase.h: (equal, copy, move, copy_n, fill_n,\n+\tfill, move_backward, copy_backward): Likewise.\n+\t* include/bits/ranges_uninitialized.h (uninitialized_default_construct,\n+\tuninitialized_default_construct_n, uninitialized_value_construct,\n+\tuninitialized_value_construct_n, uninitialized_copy,\n+\tuninitialized_copy_n, uninitialized_move, uninitialized_move_n,\n+\tuninitialized_fill, uninitialized_fill_n, construct_at, destroy_at,\n+\tdestroy, destroy_n): Likewise.\n+\n \t* include/bits/ranges_algo.h (ranges::__find_end): Fold into ...\n \t(ranges::find_end): ... here.\n \t(ranges::__lexicographical_compare): Fold into ..."}, {"sha": "af6d17229982f6fc5ee1e13c334716415e32143e", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 3107, "deletions": 2740, "changes": 5847, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=b40c57bdd2ea2e171657e2bfbb7702171f4c9040"}, {"sha": "f3b800863dc1d49ab6c3f819296668718b85fdd2", "filename": "libstdc++-v3/include/bits/ranges_algobase.h", "status": "modified", "additions": 273, "deletions": 233, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h?ref=b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "patch": "@@ -71,88 +71,93 @@ namespace ranges\n \t__is_move_iterator<move_iterator<_Iterator>> = true;\n   } // namespace __detail\n \n-  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Pred = ranges::equal_to,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity>\n-    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-    constexpr bool\n-    equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n-\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n-    {\n-      // TODO: implement more specializations to at least have parity with\n-      // std::equal.\n-      if constexpr (__detail::__is_normal_iterator<_Iter1>\n-\t\t    || __detail::__is_normal_iterator<_Iter2>)\n-\treturn ranges::equal(std::__niter_base(std::move(__first1)),\n-\t\t\t     std::__niter_base(std::move(__last1)),\n-\t\t\t     std::__niter_base(std::move(__first2)),\n-\t\t\t     std::__niter_base(std::move(__last2)),\n+  struct __equal_fn\n+  {\n+    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n+      constexpr bool\n+      operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n+\t    _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n+      {\n+\t// TODO: implement more specializations to at least have parity with\n+\t// std::equal.\n+\tif constexpr (__detail::__is_normal_iterator<_Iter1>\n+\t\t      || __detail::__is_normal_iterator<_Iter2>)\n+\t  return (*this)(std::__niter_base(std::move(__first1)),\n+\t\t\t       std::__niter_base(std::move(__last1)),\n+\t\t\t       std::__niter_base(std::move(__first2)),\n+\t\t\t       std::__niter_base(std::move(__last2)),\n+\t\t\t       std::move(__pred),\n+\t\t\t       std::move(__proj1), std::move(__proj2));\n+\n+\tconstexpr bool __sized_iters\n+\t  = (sized_sentinel_for<_Sent1, _Iter1>\n+\t     && sized_sentinel_for<_Sent2, _Iter2>);\n+\tif constexpr (__sized_iters)\n+\t  {\n+\t    auto __d1 = ranges::distance(__first1, __last1);\n+\t    auto __d2 = ranges::distance(__first2, __last2);\n+\t    if (__d1 != __d2)\n+\t      return false;\n+\n+\t    using _ValueType1 = iter_value_t<_Iter1>;\n+\t    using _ValueType2 = iter_value_t<_Iter2>;\n+\t    constexpr bool __use_memcmp\n+\t      = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)\n+\t\t && is_same_v<_ValueType1, _ValueType2>\n+\t\t && is_pointer_v<_Iter1>\n+\t\t && is_pointer_v<_Iter2>\n+\t\t && is_same_v<_Pred, ranges::equal_to>\n+\t\t && is_same_v<_Proj1, identity>\n+\t\t && is_same_v<_Proj2, identity>);\n+\t    if constexpr (__use_memcmp)\n+\t      {\n+\t\tif (const size_t __len = (__last1 - __first1))\n+\t\t  return !std::__memcmp(__first1, __first2, __len);\n+\t\treturn true;\n+\t      }\n+\t    else\n+\t      {\n+\t\tfor (; __first1 != __last1; ++__first1, (void)++__first2)\n+\t\t  if (!(bool)std::__invoke(__pred,\n+\t\t\t\t\t   std::__invoke(__proj1, *__first1),\n+\t\t\t\t\t   std::__invoke(__proj2, *__first2)))\n+\t\t    return false;\n+\t\treturn true;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    for (; __first1 != __last1 && __first2 != __last2;\n+\t\t ++__first1, (void)++__first2)\n+\t      if (!(bool)std::__invoke(__pred,\n+\t\t\t\t       std::__invoke(__proj1, *__first1),\n+\t\t\t\t       std::__invoke(__proj2, *__first2)))\n+\t\treturn false;\n+\t    return __first1 == __last1 && __first2 == __last2;\n+\t  }\n+      }\n+\n+    template<input_range _Range1, input_range _Range2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n+\t\t\t\t     _Pred, _Proj1, _Proj2>\n+      constexpr bool\n+      operator()(_Range1&& __r1, _Range2&& __r2,\n+\t    _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n+      {\n+\treturn (*this)(ranges::begin(__r1), ranges::end(__r1),\n+\t\t\t     ranges::begin(__r2), ranges::end(__r2),\n \t\t\t     std::move(__pred),\n \t\t\t     std::move(__proj1), std::move(__proj2));\n+      }\n+  };\n \n-      constexpr bool __sized_iters\n-\t= (sized_sentinel_for<_Sent1, _Iter1>\n-\t   && sized_sentinel_for<_Sent2, _Iter2>);\n-      if constexpr (__sized_iters)\n-\t{\n-\t  auto __d1 = ranges::distance(__first1, __last1);\n-\t  auto __d2 = ranges::distance(__first2, __last2);\n-\t  if (__d1 != __d2)\n-\t    return false;\n-\n-\t  using _ValueType1 = iter_value_t<_Iter1>;\n-\t  using _ValueType2 = iter_value_t<_Iter2>;\n-\t  constexpr bool __use_memcmp\n-\t    = ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>)\n-\t       && is_same_v<_ValueType1, _ValueType2>\n-\t       && is_pointer_v<_Iter1>\n-\t       && is_pointer_v<_Iter2>\n-\t       && is_same_v<_Pred, ranges::equal_to>\n-\t       && is_same_v<_Proj1, identity>\n-\t       && is_same_v<_Proj2, identity>);\n-\t  if constexpr (__use_memcmp)\n-\t    {\n-\t      if (const size_t __len = (__last1 - __first1))\n-\t\treturn !std::__memcmp(__first1, __first2, __len);\n-\t      return true;\n-\t    }\n-\t  else\n-\t    {\n-\t      for (; __first1 != __last1; ++__first1, (void)++__first2)\n-\t\tif (!(bool)std::__invoke(__pred,\n-\t\t\t\t\t std::__invoke(__proj1, *__first1),\n-\t\t\t\t\t std::__invoke(__proj2, *__first2)))\n-\t\t  return false;\n-\t      return true;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (; __first1 != __last1 && __first2 != __last2;\n-\t       ++__first1, (void)++__first2)\n-\t    if (!(bool)std::__invoke(__pred,\n-\t\t\t\t     std::__invoke(__proj1, *__first1),\n-\t\t\t\t     std::__invoke(__proj2, *__first2)))\n-\t      return false;\n-\t  return __first1 == __last1 && __first2 == __last2;\n-\t}\n-    }\n-\n-  template<input_range _Range1, input_range _Range2,\n-\t   typename _Pred = ranges::equal_to,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity>\n-    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,\n-\t\t\t\t   _Pred, _Proj1, _Proj2>\n-    constexpr bool\n-    equal(_Range1&& __r1, _Range2&& __r2,\n-\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n-    {\n-      return ranges::equal(ranges::begin(__r1), ranges::end(__r1),\n-\t\t\t   ranges::begin(__r2), ranges::end(__r2),\n-\t\t\t   std::move(__pred),\n-\t\t\t   std::move(__proj1), std::move(__proj2));\n-    }\n+  inline constexpr __equal_fn equal{};\n \n   template<typename _Iter, typename _Out>\n     struct copy_result\n@@ -288,45 +293,55 @@ namespace ranges\n \t}\n     }\n \n-  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   weakly_incrementable _Out>\n-    requires indirectly_copyable<_Iter, _Out>\n-    constexpr copy_result<_Iter, _Out>\n-    copy(_Iter __first, _Sent __last, _Out __result)\n-    {\n-      return ranges::__copy_or_move<false>(std::move(__first),\n-\t\t\t\t\t   std::move(__last),\n-\t\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<input_range _Range, weakly_incrementable _Out>\n-    requires indirectly_copyable<iterator_t<_Range>, _Out>\n-    constexpr copy_result<safe_iterator_t<_Range>, _Out>\n-    copy(_Range&& __r, _Out __result)\n-    {\n-      return ranges::copy(ranges::begin(__r), ranges::end(__r),\n-\t\t\t  std::move(__result));\n-    }\n-\n-  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n-\t   weakly_incrementable _Out>\n-    requires indirectly_movable<_Iter, _Out>\n-    constexpr move_result<_Iter, _Out>\n-    move(_Iter __first, _Sent __last, _Out __result)\n-    {\n-      return ranges::__copy_or_move<true>(std::move(__first),\n-\t\t\t\t\t  std::move(__last),\n-\t\t\t\t\t  std::move(__result));\n-    }\n-\n-  template<input_range _Range, weakly_incrementable _Out>\n-    requires indirectly_movable<iterator_t<_Range>, _Out>\n-    constexpr move_result<safe_iterator_t<_Range>, _Out>\n-    move(_Range&& __r, _Out __result)\n-    {\n-      return ranges::move(ranges::begin(__r), ranges::end(__r),\n-\t\t\t  std::move(__result));\n-    }\n+  struct __copy_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     weakly_incrementable _Out>\n+      requires indirectly_copyable<_Iter, _Out>\n+      constexpr copy_result<_Iter, _Out>\n+      operator()(_Iter __first, _Sent __last, _Out __result) const\n+      {\n+\treturn ranges::__copy_or_move<false>(std::move(__first),\n+\t\t\t\t\t     std::move(__last),\n+\t\t\t\t\t     std::move(__result));\n+      }\n+\n+    template<input_range _Range, weakly_incrementable _Out>\n+      requires indirectly_copyable<iterator_t<_Range>, _Out>\n+      constexpr copy_result<safe_iterator_t<_Range>, _Out>\n+      operator()(_Range&& __r, _Out __result) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t\t    std::move(__result));\n+      }\n+  };\n+\n+  inline constexpr __copy_fn copy{};\n+\n+  struct __move_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     weakly_incrementable _Out>\n+      requires indirectly_movable<_Iter, _Out>\n+      constexpr move_result<_Iter, _Out>\n+      operator()(_Iter __first, _Sent __last, _Out __result) const\n+      {\n+\treturn ranges::__copy_or_move<true>(std::move(__first),\n+\t\t\t\t\t    std::move(__last),\n+\t\t\t\t\t    std::move(__result));\n+      }\n+\n+    template<input_range _Range, weakly_incrementable _Out>\n+      requires indirectly_movable<iterator_t<_Range>, _Out>\n+      constexpr move_result<safe_iterator_t<_Range>, _Out>\n+      operator()(_Range&& __r, _Out __result) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t\t    std::move(__result));\n+      }\n+  };\n+\n+  inline constexpr __move_fn move{};\n \n   template<bool _IsMove,\n \t   bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,\n@@ -420,127 +435,152 @@ namespace ranges\n \t}\n     }\n \n-  template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   bidirectional_iterator _Iter2>\n-    requires indirectly_copyable<_Iter1, _Iter2>\n-    constexpr copy_backward_result<_Iter1, _Iter2>\n-    copy_backward(_Iter1 __first, _Sent1 __last, _Iter2 __result)\n-    {\n-      return ranges::__copy_or_move_backward<false>(std::move(__first),\n-\t\t\t\t\t\t    std::move(__last),\n-\t\t\t\t\t\t    std::move(__result));\n-    }\n-\n-  template<bidirectional_range _Range, bidirectional_iterator _Iter>\n-    requires indirectly_copyable<iterator_t<_Range>, _Iter>\n-    constexpr copy_backward_result<safe_iterator_t<_Range>, _Iter>\n-    copy_backward(_Range&& __r, _Iter __result)\n-    {\n-      return ranges::copy_backward(ranges::begin(__r), ranges::end(__r),\n-\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   bidirectional_iterator _Iter2>\n-    requires indirectly_movable<_Iter1, _Iter2>\n-    constexpr move_backward_result<_Iter1, _Iter2>\n-    move_backward(_Iter1 __first, _Sent1 __last, _Iter2 __result)\n-    {\n-      return ranges::__copy_or_move_backward<true>(std::move(__first),\n-\t\t\t\t\t\t   std::move(__last),\n-\t\t\t\t\t\t   std::move(__result));\n-    }\n-\n-  template<bidirectional_range _Range, bidirectional_iterator _Iter>\n-    requires indirectly_movable<iterator_t<_Range>, _Iter>\n-    constexpr move_backward_result<safe_iterator_t<_Range>, _Iter>\n-    move_backward(_Range&& __r, _Iter __result)\n-    {\n-      return ranges::move_backward(ranges::begin(__r), ranges::end(__r),\n-\t\t\t\t   std::move(__result));\n-    }\n+  struct __copy_backward_fn\n+  {\n+    template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t     bidirectional_iterator _Iter2>\n+      requires indirectly_copyable<_Iter1, _Iter2>\n+      constexpr copy_backward_result<_Iter1, _Iter2>\n+      operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result) const\n+      {\n+\treturn ranges::__copy_or_move_backward<false>(std::move(__first),\n+\t\t\t\t\t\t      std::move(__last),\n+\t\t\t\t\t\t      std::move(__result));\n+      }\n+\n+    template<bidirectional_range _Range, bidirectional_iterator _Iter>\n+      requires indirectly_copyable<iterator_t<_Range>, _Iter>\n+      constexpr copy_backward_result<safe_iterator_t<_Range>, _Iter>\n+      operator()(_Range&& __r, _Iter __result) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t     std::move(__result));\n+      }\n+  };\n+\n+  inline constexpr __copy_backward_fn copy_backward{};\n+\n+  struct __move_backward_fn\n+  {\n+    template<bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t     bidirectional_iterator _Iter2>\n+      requires indirectly_movable<_Iter1, _Iter2>\n+      constexpr move_backward_result<_Iter1, _Iter2>\n+      operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result) const\n+      {\n+\treturn ranges::__copy_or_move_backward<true>(std::move(__first),\n+\t\t\t\t\t\t     std::move(__last),\n+\t\t\t\t\t\t     std::move(__result));\n+      }\n+\n+    template<bidirectional_range _Range, bidirectional_iterator _Iter>\n+      requires indirectly_movable<iterator_t<_Range>, _Iter>\n+      constexpr move_backward_result<safe_iterator_t<_Range>, _Iter>\n+      operator()(_Range&& __r, _Iter __result) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t     std::move(__result));\n+      }\n+  };\n+\n+  inline constexpr __move_backward_fn move_backward{};\n \n   template<typename _Iter, typename _Out>\n     using copy_n_result = copy_result<_Iter, _Out>;\n \n-  template<input_iterator _Iter, weakly_incrementable _Out>\n-    requires indirectly_copyable<_Iter, _Out>\n-    constexpr copy_n_result<_Iter, _Out>\n-    copy_n(_Iter __first, iter_difference_t<_Iter> __n, _Out __result)\n-    {\n-      if constexpr (random_access_iterator<_Iter>)\n-\treturn ranges::copy(__first, __first + __n, std::move(__result));\n-      else\n-\t{\n-\t  for (; __n > 0; --__n, (void)++__result, (void)++__first)\n-\t    *__result = *__first;\n-\t  return {std::move(__first), std::move(__result)};\n-\t}\n-    }\n-\n-  template<typename _Tp, output_iterator<const _Tp&> _Out>\n-    constexpr _Out\n-    fill_n(_Out __first, iter_difference_t<_Out> __n, const _Tp& __value)\n-    {\n-      // TODO: implement more specializations to be at least on par with\n-      // std::fill_n\n-      if (__n <= 0)\n-\treturn __first;\n-\n-      // TODO: is __is_byte the best condition?\n-      if constexpr (is_pointer_v<_Out> && __is_byte<_Tp>::__value)\n-\t{\n-\t  __builtin_memset(__first, static_cast<unsigned char>(__value), __n);\n-\t  return __first + __n;\n-\t}\n-      else if constexpr (is_scalar_v<_Tp>)\n-\t{\n-\t  const auto __tmp = __value;\n-\t  for (; __n > 0; --__n, (void)++__first)\n-\t    *__first = __tmp;\n-\t  return __first;\n-\t}\n-      else\n-\t{\n-\t  for (; __n > 0; --__n, (void)++__first)\n-\t    *__first = __value;\n-\t  return __first;\n-\t}\n-    }\n-\n-  template<typename _Tp,\n-\t   output_iterator<const _Tp&> _Out, sentinel_for<_Out> _Sent>\n-    constexpr _Out\n-    fill(_Out __first, _Sent __last, const _Tp& __value)\n-    {\n-      // TODO: implement more specializations to be at least on par with\n-      // std::fill\n-      if constexpr (sized_sentinel_for<_Sent, _Out>)\n-\t{\n-\t  const auto __len = __last - __first;\n-\t  return ranges::fill_n(__first, __len, __value);\n-\t}\n-      else if constexpr (is_scalar_v<_Tp>)\n-\t{\n-\t  const auto __tmp = __value;\n-\t  for (; __first != __last; ++__first)\n-\t    *__first = __tmp;\n-\t  return __first;\n-\t}\n-      else\n-\t{\n-\t  for (; __first != __last; ++__first)\n-\t    *__first = __value;\n+  struct __copy_n_fn\n+  {\n+    template<input_iterator _Iter, weakly_incrementable _Out>\n+      requires indirectly_copyable<_Iter, _Out>\n+      constexpr copy_n_result<_Iter, _Out>\n+      operator()(_Iter __first, iter_difference_t<_Iter> __n, _Out __result) const\n+      {\n+\tif constexpr (random_access_iterator<_Iter>)\n+\t  return ranges::copy(__first, __first + __n, std::move(__result));\n+\telse\n+\t  {\n+\t    for (; __n > 0; --__n, (void)++__result, (void)++__first)\n+\t      *__result = *__first;\n+\t    return {std::move(__first), std::move(__result)};\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __copy_n_fn copy_n{};\n+\n+  struct __fill_n_fn\n+  {\n+    template<typename _Tp, output_iterator<const _Tp&> _Out>\n+      constexpr _Out\n+      operator()(_Out __first, iter_difference_t<_Out> __n, const _Tp& __value) const\n+      {\n+\t// TODO: implement more specializations to be at least on par with\n+\t// std::fill_n\n+\tif (__n <= 0)\n \t  return __first;\n-\t}\n-    }\n \n-  template<typename _Tp, output_range<const _Tp&> _Range>\n-    constexpr safe_iterator_t<_Range>\n-    fill(_Range&& __r, const _Tp& __value)\n-    {\n-      return ranges::fill(ranges::begin(__r), ranges::end(__r), __value);\n-    }\n+\t// TODO: is __is_byte the best condition?\n+\tif constexpr (is_pointer_v<_Out> && __is_byte<_Tp>::__value)\n+\t  {\n+\t    __builtin_memset(__first, static_cast<unsigned char>(__value), __n);\n+\t    return __first + __n;\n+\t  }\n+\telse if constexpr (is_scalar_v<_Tp>)\n+\t  {\n+\t    const auto __tmp = __value;\n+\t    for (; __n > 0; --__n, (void)++__first)\n+\t      *__first = __tmp;\n+\t    return __first;\n+\t  }\n+\telse\n+\t  {\n+\t    for (; __n > 0; --__n, (void)++__first)\n+\t      *__first = __value;\n+\t    return __first;\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __fill_n_fn fill_n{};\n+\n+  struct __fill_fn\n+  {\n+    template<typename _Tp,\n+\t     output_iterator<const _Tp&> _Out, sentinel_for<_Out> _Sent>\n+      constexpr _Out\n+      operator()(_Out __first, _Sent __last, const _Tp& __value) const\n+      {\n+\t// TODO: implement more specializations to be at least on par with\n+\t// std::fill\n+\tif constexpr (sized_sentinel_for<_Sent, _Out>)\n+\t  {\n+\t    const auto __len = __last - __first;\n+\t    return ranges::fill_n(__first, __len, __value);\n+\t  }\n+\telse if constexpr (is_scalar_v<_Tp>)\n+\t  {\n+\t    const auto __tmp = __value;\n+\t    for (; __first != __last; ++__first)\n+\t      *__first = __tmp;\n+\t    return __first;\n+\t  }\n+\telse\n+\t  {\n+\t    for (; __first != __last; ++__first)\n+\t      *__first = __value;\n+\t    return __first;\n+\t  }\n+      }\n+\n+    template<typename _Tp, output_range<const _Tp&> _Range>\n+      constexpr safe_iterator_t<_Range>\n+      operator()(_Range&& __r, const _Tp& __value) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r), __value);\n+      }\n+  };\n+\n+  inline constexpr __fill_fn fill{};\n }\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}, {"sha": "fa4238b9181b62251d992d3ab898458da11609eb", "filename": "libstdc++-v3/include/bits/ranges_uninitialized.h", "status": "modified", "additions": 392, "deletions": 313, "changes": 705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c57bdd2ea2e171657e2bfbb7702171f4c9040/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_uninitialized.h?ref=b40c57bdd2ea2e171657e2bfbb7702171f4c9040", "patch": "@@ -78,11 +78,21 @@ namespace ranges\n \t   && __nothrow_forward_iterator<iterator_t<_Range>>);\n   } // namespace __detail\n \n-  template<__detail::__nothrow_input_iterator _Iter,\n-\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n-    requires destructible<iter_value_t<_Iter>>\n-    constexpr _Iter\n-    destroy(_Iter __first, _Sent __last) noexcept;\n+  struct __destroy_fn\n+  {\n+    template<__detail::__nothrow_input_iterator _Iter,\n+\t     __detail::__nothrow_sentinel<_Iter> _Sent>\n+      requires destructible<iter_value_t<_Iter>>\n+      constexpr _Iter\n+      operator()(_Iter __first, _Sent __last) const noexcept;\n+\n+    template<__detail::__nothrow_input_range _Range>\n+      requires destructible<range_value_t<_Range>>\n+      constexpr safe_iterator_t<_Range>\n+      operator()(_Range&& __r) const noexcept;\n+  };\n+\n+  inline constexpr __destroy_fn destroy{};\n \n   namespace __detail\n   {\n@@ -126,332 +136,396 @@ namespace ranges\n       };\n   } // namespace __detail\n \n-  template<__detail::__nothrow_forward_iterator _Iter,\n-\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n-    requires default_initializable<iter_value_t<_Iter>>\n-    _Iter\n-    uninitialized_default_construct(_Iter __first, _Sent __last)\n-    {\n-      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n-      if constexpr (is_trivially_default_constructible_v<_ValueType>)\n-\treturn ranges::next(__first, __last);\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__first);\n-\t  for (; __first != __last; ++__first)\n-\t    ::new (__detail::__voidify(*__first)) _ValueType;\n-\t  __guard.release();\n-\t  return __first;\n-\t}\n-    }\n+  struct __uninitialized_default_construct_fn\n+  {\n+    template<__detail::__nothrow_forward_iterator _Iter,\n+\t     __detail::__nothrow_sentinel<_Iter> _Sent>\n+      requires default_initializable<iter_value_t<_Iter>>\n+      _Iter\n+      operator()(_Iter __first, _Sent __last) const\n+      {\n+\tusing _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+\tif constexpr (is_trivially_default_constructible_v<_ValueType>)\n+\t  return ranges::next(__first, __last);\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__first);\n+\t    for (; __first != __last; ++__first)\n+\t      ::new (__detail::__voidify(*__first)) _ValueType;\n+\t    __guard.release();\n+\t    return __first;\n+\t  }\n+      }\n \n-  template<__detail::__nothrow_forward_range _Range>\n-    requires default_initializable<range_value_t<_Range>>\n-    safe_iterator_t<_Range>\n-    uninitialized_default_construct(_Range&& __r)\n-    {\n-      return ranges::uninitialized_default_construct(ranges::begin(__r),\n-\t\t\t\t\t\t     ranges::end(__r));\n-    }\n+    template<__detail::__nothrow_forward_range _Range>\n+      requires default_initializable<range_value_t<_Range>>\n+      safe_iterator_t<_Range>\n+      operator()(_Range&& __r) const\n+      {\n+\treturn (*this)(ranges::begin(__r),\n+\t\t\t\t\t\t       ranges::end(__r));\n+      }\n+  };\n \n-  template<__detail::__nothrow_forward_iterator _Iter>\n-    requires default_initializable<iter_value_t<_Iter>>\n-    _Iter\n-    uninitialized_default_construct_n(_Iter __first,\n-\t\t\t\t      iter_difference_t<_Iter> __n)\n-    {\n-      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n-      if constexpr (is_trivially_default_constructible_v<_ValueType>)\n-\treturn ranges::next(__first, __n);\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__first);\n-\t  for (; __n > 0; ++__first, (void) --__n)\n-\t    ::new (__detail::__voidify(*__first)) _ValueType;\n-\t  __guard.release();\n-\t  return __first;\n-\t}\n-    }\n+  inline constexpr __uninitialized_default_construct_fn\n+    uninitialized_default_construct{};\n \n-  template<__detail::__nothrow_forward_iterator _Iter,\n-\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n-    requires default_initializable<iter_value_t<_Iter>>\n-    _Iter\n-    uninitialized_value_construct(_Iter __first, _Sent __last)\n-    {\n-      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n-      if constexpr (is_trivial_v<_ValueType>\n-\t\t    && is_copy_assignable_v<_ValueType>)\n-\treturn ranges::fill(__first, __last, _ValueType());\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__first);\n-\t  for (; __first != __last; ++__first)\n-\t    ::new (__detail::__voidify(*__first)) _ValueType();\n-\t  __guard.release();\n-\t  return __first;\n-\t}\n-    }\n+  struct __uninitialized_default_construct_n_fn\n+  {\n+    template<__detail::__nothrow_forward_iterator _Iter>\n+      requires default_initializable<iter_value_t<_Iter>>\n+      _Iter\n+      operator()(_Iter __first,\n+\t\t\t\t\titer_difference_t<_Iter> __n) const\n+      {\n+\tusing _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+\tif constexpr (is_trivially_default_constructible_v<_ValueType>)\n+\t  return ranges::next(__first, __n);\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__first);\n+\t    for (; __n > 0; ++__first, (void) --__n)\n+\t      ::new (__detail::__voidify(*__first)) _ValueType;\n+\t    __guard.release();\n+\t    return __first;\n+\t  }\n+      }\n+  };\n \n-  template<__detail::__nothrow_forward_range _Range>\n-    requires default_initializable<range_value_t<_Range>>\n-    safe_iterator_t<_Range>\n-    uninitialized_value_construct(_Range&& __r)\n-    {\n-      return ranges::uninitialized_value_construct(ranges::begin(__r),\n-\t\t\t\t\t\t   ranges::end(__r));\n-    }\n+  inline constexpr __uninitialized_default_construct_n_fn\n+    uninitialized_default_construct_n;\n \n-  template<__detail::__nothrow_forward_iterator _Iter>\n-    requires default_initializable<iter_value_t<_Iter>>\n-    _Iter\n-    uninitialized_value_construct_n(_Iter __first, iter_difference_t<_Iter> __n)\n-    {\n-      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n-      if constexpr (is_trivial_v<_ValueType>\n-\t\t    && is_copy_assignable_v<_ValueType>)\n-\treturn ranges::fill_n(__first, __n, _ValueType());\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__first);\n-\t  for (; __n > 0; ++__first, (void) --__n)\n-\t    ::new (__detail::__voidify(*__first)) _ValueType();\n-\t  __guard.release();\n-\t  return __first;\n-\t}\n-    }\n+  struct __uninitialized_value_construct_fn\n+  {\n+    template<__detail::__nothrow_forward_iterator _Iter,\n+\t     __detail::__nothrow_sentinel<_Iter> _Sent>\n+      requires default_initializable<iter_value_t<_Iter>>\n+      _Iter\n+      operator()(_Iter __first, _Sent __last) const\n+      {\n+\tusing _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+\tif constexpr (is_trivial_v<_ValueType>\n+\t\t      && is_copy_assignable_v<_ValueType>)\n+\t  return ranges::fill(__first, __last, _ValueType());\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__first);\n+\t    for (; __first != __last; ++__first)\n+\t      ::new (__detail::__voidify(*__first)) _ValueType();\n+\t    __guard.release();\n+\t    return __first;\n+\t  }\n+      }\n+\n+    template<__detail::__nothrow_forward_range _Range>\n+      requires default_initializable<range_value_t<_Range>>\n+      safe_iterator_t<_Range>\n+      operator()(_Range&& __r) const\n+      {\n+\treturn (*this)(ranges::begin(__r),\n+\t\t\t\t\t\t     ranges::end(__r));\n+      }\n+  };\n+\n+  inline constexpr __uninitialized_value_construct_fn\n+    uninitialized_value_construct{};\n+\n+  struct __uninitialized_value_construct_n_fn\n+  {\n+    template<__detail::__nothrow_forward_iterator _Iter>\n+      requires default_initializable<iter_value_t<_Iter>>\n+      _Iter\n+      operator()(_Iter __first, iter_difference_t<_Iter> __n) const\n+      {\n+\tusing _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+\tif constexpr (is_trivial_v<_ValueType>\n+\t\t      && is_copy_assignable_v<_ValueType>)\n+\t  return ranges::fill_n(__first, __n, _ValueType());\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__first);\n+\t    for (; __n > 0; ++__first, (void) --__n)\n+\t      ::new (__detail::__voidify(*__first)) _ValueType();\n+\t    __guard.release();\n+\t    return __first;\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __uninitialized_value_construct_n_fn\n+    uninitialized_value_construct_n;\n \n   template<typename _Iter, typename _Out>\n     using uninitialized_copy_result = copy_result<_Iter, _Out>;\n \n-  template<input_iterator _Iter, sentinel_for<_Iter> _ISent,\n-\t   __detail::__nothrow_forward_iterator _Out,\n-\t   __detail::__nothrow_sentinel<_Out> _OSent>\n-    requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>\n-    uninitialized_copy_result<_Iter, _Out>\n-    uninitialized_copy(_Iter __ifirst, _ISent __ilast,\n-\t\t       _Out __ofirst, _OSent __olast)\n-    {\n-      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n-      if constexpr (sized_sentinel_for<_ISent, _Iter>\n-\t\t    && sized_sentinel_for<_OSent, _Out>\n-\t\t    && is_trivial_v<_OutType>\n-\t\t    && is_nothrow_assignable_v<_OutType,\n-\t\t\t\t\t       iter_reference_t<_Iter>>)\n-\t{\n-\t  auto __d1 = ranges::distance(__ifirst, __ilast);\n-\t  auto __d2 = ranges::distance(__ofirst, __olast);\n-\t  return ranges::copy_n(__ifirst, std::min(__d1, __d2), __ofirst);\n-\t}\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n-\t  for (; __ifirst != __ilast && __ofirst != __olast;\n-\t       ++__ofirst, (void)++__ifirst)\n-\t    ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);\n-\t  __guard.release();\n-\t  return {__ifirst, __ofirst};\n-\t}\n-    }\n+  struct __uninitialized_copy_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _ISent,\n+\t     __detail::__nothrow_forward_iterator _Out,\n+\t     __detail::__nothrow_sentinel<_Out> _OSent>\n+      requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>\n+      uninitialized_copy_result<_Iter, _Out>\n+      operator()(_Iter __ifirst, _ISent __ilast,\n+\t\t\t _Out __ofirst, _OSent __olast) const\n+      {\n+\tusing _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+\tif constexpr (sized_sentinel_for<_ISent, _Iter>\n+\t\t      && sized_sentinel_for<_OSent, _Out>\n+\t\t      && is_trivial_v<_OutType>\n+\t\t      && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t\t iter_reference_t<_Iter>>)\n+\t  {\n+\t    auto __d1 = ranges::distance(__ifirst, __ilast);\n+\t    auto __d2 = ranges::distance(__ofirst, __olast);\n+\t    return ranges::copy_n(__ifirst, std::min(__d1, __d2), __ofirst);\n+\t  }\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t    for (; __ifirst != __ilast && __ofirst != __olast;\n+\t\t ++__ofirst, (void)++__ifirst)\n+\t      ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);\n+\t    __guard.release();\n+\t    return {__ifirst, __ofirst};\n+\t  }\n+      }\n \n-  template<input_range _IRange, __detail::__nothrow_forward_range _ORange>\n-    requires constructible_from<range_value_t<_ORange>,\n-\t\t\t\trange_reference_t<_IRange>>\n-    uninitialized_copy_result<safe_iterator_t<_IRange>,\n-\t\t\t      safe_iterator_t<_ORange>>\n-    uninitialized_copy(_IRange&& __inr, _ORange&& __outr)\n-    {\n-      return ranges::uninitialized_copy(ranges::begin(__inr),\n-\t\t\t\t\tranges::end(__inr),\n-\t\t\t\t\tranges::begin(__outr),\n-\t\t\t\t\tranges::end(__outr));\n-    }\n+    template<input_range _IRange, __detail::__nothrow_forward_range _ORange>\n+      requires constructible_from<range_value_t<_ORange>,\n+\t\t\t\t  range_reference_t<_IRange>>\n+      uninitialized_copy_result<safe_iterator_t<_IRange>,\n+\t\t\t\tsafe_iterator_t<_ORange>>\n+      operator()(_IRange&& __inr, _ORange&& __outr) const\n+      {\n+\treturn (*this)(ranges::begin(__inr),\n+\t\t\t\t\t  ranges::end(__inr),\n+\t\t\t\t\t  ranges::begin(__outr),\n+\t\t\t\t\t  ranges::end(__outr));\n+      }\n+  };\n+\n+  inline constexpr __uninitialized_copy_fn uninitialized_copy{};\n \n   template<typename _Iter, typename _Out>\n     using uninitialized_copy_n_result = uninitialized_copy_result<_Iter, _Out>;\n \n+  struct __uninitialized_copy_n_fn\n+  {\n     template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,\n-      __detail::__nothrow_sentinel<_Out> _Sent>\n-    requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>\n-    uninitialized_copy_n_result<_Iter, _Out>\n-    uninitialized_copy_n(_Iter __ifirst, iter_difference_t<_Iter> __n,\n-\t\t\t _Out __ofirst, _Sent __olast)\n-    {\n-      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n-      if constexpr (sized_sentinel_for<_Sent, _Out>\n-\t\t    && is_trivial_v<_OutType>\n-\t\t    && is_nothrow_assignable_v<_OutType,\n-\t\t\t\t\t       iter_reference_t<_Iter>>)\n-\t{\n-\t  auto __d = ranges::distance(__ofirst, __olast);\n-\t  return ranges::copy_n(__ifirst, std::min(__n, __d), __ofirst);\n-\t}\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n-\t  for (; __n > 0 && __ofirst != __olast;\n-\t       ++__ofirst, (void)++__ifirst, (void)--__n)\n-\t    ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);\n-\t  __guard.release();\n-\t  return {__ifirst, __ofirst};\n-\t}\n-    }\n+\t     __detail::__nothrow_sentinel<_Out> _Sent>\n+      requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>\n+      uninitialized_copy_n_result<_Iter, _Out>\n+      operator()(_Iter __ifirst, iter_difference_t<_Iter> __n,\n+\t\t\t   _Out __ofirst, _Sent __olast) const\n+      {\n+\tusing _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+\tif constexpr (sized_sentinel_for<_Sent, _Out>\n+\t\t      && is_trivial_v<_OutType>\n+\t\t      && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t\t iter_reference_t<_Iter>>)\n+\t  {\n+\t    auto __d = ranges::distance(__ofirst, __olast);\n+\t    return ranges::copy_n(__ifirst, std::min(__n, __d), __ofirst);\n+\t  }\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t    for (; __n > 0 && __ofirst != __olast;\n+\t\t ++__ofirst, (void)++__ifirst, (void)--__n)\n+\t      ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);\n+\t    __guard.release();\n+\t    return {__ifirst, __ofirst};\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __uninitialized_copy_n_fn uninitialized_copy_n{};\n \n   template<typename _Iter, typename _Out>\n     using uninitialized_move_result = uninitialized_copy_result<_Iter, _Out>;\n \n-  template<input_iterator _Iter, sentinel_for<_Iter> _ISent,\n-\t   __detail::__nothrow_forward_iterator _Out,\n-\t   __detail::__nothrow_sentinel<_Out> _OSent>\n-    requires constructible_from<iter_value_t<_Out>,\n-\t\t\t\titer_rvalue_reference_t<_Iter>>\n-    uninitialized_move_result<_Iter, _Out>\n-    uninitialized_move(_Iter __ifirst, _ISent __ilast,\n-\t\t       _Out __ofirst, _OSent __olast)\n-    {\n-      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n-      if constexpr (sized_sentinel_for<_ISent, _Iter>\n-\t\t    && sized_sentinel_for<_OSent, _Out>\n-\t\t    && is_trivial_v<_OutType>\n-\t\t    && is_nothrow_assignable_v<_OutType,\n-\t\t\t\t\t       iter_rvalue_reference_t<_Iter>>)\n-\t{\n-\t  auto __d1 = ranges::distance(__ifirst, __ilast);\n-\t  auto __d2 = ranges::distance(__ofirst, __olast);\n-\t  return ranges::copy_n(std::make_move_iterator(__ifirst),\n-\t\t\t\tstd::min(__d1, __d2), __ofirst);\n-\t}\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n-\t  for (; __ifirst != __ilast && __ofirst != __olast;\n-\t       ++__ofirst, (void)++__ifirst)\n-\t    ::new (__detail::__voidify(*__ofirst))\n-\t\t  _OutType(ranges::iter_move(__ifirst));\n-\t  __guard.release();\n-\t  return {__ifirst, __ofirst};\n-\t}\n-    }\n+  struct __uninitialized_move_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _ISent,\n+\t     __detail::__nothrow_forward_iterator _Out,\n+\t     __detail::__nothrow_sentinel<_Out> _OSent>\n+      requires constructible_from<iter_value_t<_Out>,\n+\t\t\t\t  iter_rvalue_reference_t<_Iter>>\n+      uninitialized_move_result<_Iter, _Out>\n+      operator()(_Iter __ifirst, _ISent __ilast,\n+\t\t\t _Out __ofirst, _OSent __olast) const\n+      {\n+\tusing _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+\tif constexpr (sized_sentinel_for<_ISent, _Iter>\n+\t\t      && sized_sentinel_for<_OSent, _Out>\n+\t\t      && is_trivial_v<_OutType>\n+\t\t      && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t\t iter_rvalue_reference_t<_Iter>>)\n+\t  {\n+\t    auto __d1 = ranges::distance(__ifirst, __ilast);\n+\t    auto __d2 = ranges::distance(__ofirst, __olast);\n+\t    return ranges::copy_n(std::make_move_iterator(__ifirst),\n+\t\t\t\t  std::min(__d1, __d2), __ofirst);\n+\t  }\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t    for (; __ifirst != __ilast && __ofirst != __olast;\n+\t\t ++__ofirst, (void)++__ifirst)\n+\t      ::new (__detail::__voidify(*__ofirst))\n+\t\t    _OutType(ranges::iter_move(__ifirst));\n+\t    __guard.release();\n+\t    return {__ifirst, __ofirst};\n+\t  }\n+      }\n \n-  template<input_range _IRange, __detail::__nothrow_forward_range _ORange>\n-    requires constructible_from<range_value_t<_ORange>,\n-\t     range_rvalue_reference_t<_IRange>>\n-    uninitialized_move_result<safe_iterator_t<_IRange>,\n-\t\t\t      safe_iterator_t<_ORange>>\n-    uninitialized_move(_IRange&& __inr, _ORange&& __outr)\n-    {\n-      return ranges::uninitialized_move(ranges::begin(__inr),\n-\t\t\t\t\tranges::end(__inr),\n-\t\t\t\t\tranges::begin(__outr),\n-\t\t\t\t\tranges::end(__outr));\n-    }\n+    template<input_range _IRange, __detail::__nothrow_forward_range _ORange>\n+      requires constructible_from<range_value_t<_ORange>,\n+\t       range_rvalue_reference_t<_IRange>>\n+      uninitialized_move_result<safe_iterator_t<_IRange>,\n+\t\t\t\tsafe_iterator_t<_ORange>>\n+      operator()(_IRange&& __inr, _ORange&& __outr) const\n+      {\n+\treturn (*this)(ranges::begin(__inr),\n+\t\t\t\t\t  ranges::end(__inr),\n+\t\t\t\t\t  ranges::begin(__outr),\n+\t\t\t\t\t  ranges::end(__outr));\n+      }\n+  };\n+\n+  inline constexpr __uninitialized_move_fn uninitialized_move{};\n \n   template<typename _Iter, typename _Out>\n     using uninitialized_move_n_result = uninitialized_copy_result<_Iter, _Out>;\n \n-  template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,\n-    __detail::__nothrow_sentinel<_Out> _Sent>\n-      requires constructible_from<iter_value_t<_Out>,\n-\t\t\t\t  iter_rvalue_reference_t<_Iter>>\n-    uninitialized_move_n_result<_Iter, _Out>\n-    uninitialized_move_n(_Iter __ifirst, iter_difference_t<_Iter> __n,\n-\t\t\t _Out __ofirst, _Sent __olast)\n-    {\n-      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n-      if constexpr (sized_sentinel_for<_Sent, _Out>\n-\t\t    && is_trivial_v<_OutType>\n-\t\t    && is_nothrow_assignable_v<_OutType,\n-\t\t\t\t\t       iter_rvalue_reference_t<_Iter>>)\n-\t{\n-\t  auto __d = ranges::distance(__ofirst, __olast);\n-\t  return ranges::copy_n(std::make_move_iterator(__ifirst),\n-\t\t\t\tstd::min(__n, __d), __ofirst);\n-\t}\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n-\t  for (; __n > 0 && __ofirst != __olast;\n-\t       ++__ofirst, (void)++__ifirst, (void)--__n)\n-\t    ::new (__detail::__voidify(*__ofirst))\n-\t\t  _OutType(ranges::iter_move(__ifirst));\n-\t  __guard.release();\n-\t  return {__ifirst, __ofirst};\n-\t}\n-    }\n+  struct __uninitialized_move_n_fn\n+  {\n+    template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,\n+      __detail::__nothrow_sentinel<_Out> _Sent>\n+\trequires constructible_from<iter_value_t<_Out>,\n+\t\t\t\t    iter_rvalue_reference_t<_Iter>>\n+      uninitialized_move_n_result<_Iter, _Out>\n+      operator()(_Iter __ifirst, iter_difference_t<_Iter> __n,\n+\t\t\t   _Out __ofirst, _Sent __olast) const\n+      {\n+\tusing _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+\tif constexpr (sized_sentinel_for<_Sent, _Out>\n+\t\t      && is_trivial_v<_OutType>\n+\t\t      && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t\t iter_rvalue_reference_t<_Iter>>)\n+\t  {\n+\t    auto __d = ranges::distance(__ofirst, __olast);\n+\t    return ranges::copy_n(std::make_move_iterator(__ifirst),\n+\t\t\t\t  std::min(__n, __d), __ofirst);\n+\t  }\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t    for (; __n > 0 && __ofirst != __olast;\n+\t\t ++__ofirst, (void)++__ifirst, (void)--__n)\n+\t      ::new (__detail::__voidify(*__ofirst))\n+\t\t    _OutType(ranges::iter_move(__ifirst));\n+\t    __guard.release();\n+\t    return {__ifirst, __ofirst};\n+\t  }\n+      }\n+  };\n \n-  template<__detail::__nothrow_forward_iterator _Iter,\n-\t   __detail::__nothrow_sentinel<_Iter> _Sent, typename _Tp>\n-    requires constructible_from<iter_value_t<_Iter>, const _Tp&>\n-    _Iter\n-    uninitialized_fill(_Iter __first, _Sent __last, const _Tp& __x)\n-    {\n-      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n-      if constexpr (is_trivial_v<_ValueType>\n-\t\t    && is_nothrow_assignable_v<_ValueType, const _Tp&>)\n-\treturn ranges::fill(__first, __last, __x);\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__first);\n-\t  for (; __first != __last; ++__first)\n-\t    ::new (__detail::__voidify(*__first)) _ValueType(__x);\n-\t  __guard.release();\n-\t  return __first;\n-\t}\n-    }\n+  inline constexpr __uninitialized_move_n_fn uninitialized_move_n{};\n \n-  template<__detail::__nothrow_forward_range _Range, typename _Tp>\n-    requires constructible_from<range_value_t<_Range>, const _Tp&>\n-    safe_iterator_t<_Range>\n-    uninitialized_fill(_Range&& __r, const _Tp& __x)\n-    {\n-      return ranges::uninitialized_fill(ranges::begin(__r), ranges::end(__r),\n-\t\t\t\t\t__x);\n-    }\n+  struct __uninitialized_fill_fn\n+  {\n+    template<__detail::__nothrow_forward_iterator _Iter,\n+\t     __detail::__nothrow_sentinel<_Iter> _Sent, typename _Tp>\n+      requires constructible_from<iter_value_t<_Iter>, const _Tp&>\n+      _Iter\n+      operator()(_Iter __first, _Sent __last, const _Tp& __x) const\n+      {\n+\tusing _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+\tif constexpr (is_trivial_v<_ValueType>\n+\t\t      && is_nothrow_assignable_v<_ValueType, const _Tp&>)\n+\t  return ranges::fill(__first, __last, __x);\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__first);\n+\t    for (; __first != __last; ++__first)\n+\t      ::new (__detail::__voidify(*__first)) _ValueType(__x);\n+\t    __guard.release();\n+\t    return __first;\n+\t  }\n+      }\n \n-  template<__detail::__nothrow_forward_iterator _Iter, typename _Tp>\n-    requires constructible_from<iter_value_t<_Iter>, const _Tp&>\n-    _Iter\n-    uninitialized_fill_n(_Iter __first, iter_difference_t<_Iter> __n,\n-\t\t\t const _Tp& __x)\n-    {\n-      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n-      if constexpr (is_trivial_v<_ValueType>\n-\t\t    && is_nothrow_assignable_v<_ValueType, const _Tp&>)\n-\treturn ranges::fill_n(__first, __n, __x);\n-      else\n-\t{\n-\t  auto __guard = __detail::_DestroyGuard(&__first);\n-\t  for (; __n > 0; ++__first, (void)--__n)\n-\t    ::new (__detail::__voidify(*__first)) _ValueType(__x);\n-\t  __guard.release();\n-\t  return __first;\n-\t}\n-    }\n+    template<__detail::__nothrow_forward_range _Range, typename _Tp>\n+      requires constructible_from<range_value_t<_Range>, const _Tp&>\n+      safe_iterator_t<_Range>\n+      operator()(_Range&& __r, const _Tp& __x) const\n+      {\n+\treturn (*this)(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t\t  __x);\n+      }\n+  };\n \n-  template<typename _Tp, typename... _Args>\n-    requires requires { ::new (declval<void*>()) _Tp(declval<_Args>()...); }\n-    constexpr _Tp*\n-    construct_at(_Tp* __location, _Args&&... __args)\n-    {\n-      return ::new (__detail::__voidify(*__location))\n-\t\t   _Tp(std::forward<_Args>(__args)...);\n-    }\n+  inline constexpr __uninitialized_fill_fn uninitialized_fill{};\n \n-  template<destructible _Tp>\n-    constexpr void\n-    destroy_at(_Tp* __location) noexcept\n-    {\n-      if constexpr (is_array_v<_Tp>)\n-\tranges::destroy(ranges::begin(*__location), ranges::end(*__location));\n-      else\n-\t__location->~_Tp();\n-    }\n+  struct __uninitialized_fill_n_fn\n+  {\n+    template<__detail::__nothrow_forward_iterator _Iter, typename _Tp>\n+      requires constructible_from<iter_value_t<_Iter>, const _Tp&>\n+      _Iter\n+      operator()(_Iter __first, iter_difference_t<_Iter> __n,\n+\t\t\t   const _Tp& __x) const\n+      {\n+\tusing _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+\tif constexpr (is_trivial_v<_ValueType>\n+\t\t      && is_nothrow_assignable_v<_ValueType, const _Tp&>)\n+\t  return ranges::fill_n(__first, __n, __x);\n+\telse\n+\t  {\n+\t    auto __guard = __detail::_DestroyGuard(&__first);\n+\t    for (; __n > 0; ++__first, (void)--__n)\n+\t      ::new (__detail::__voidify(*__first)) _ValueType(__x);\n+\t    __guard.release();\n+\t    return __first;\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __uninitialized_fill_n_fn uninitialized_fill_n{};\n+\n+  struct __construct_at_fn\n+  {\n+    template<typename _Tp, typename... _Args>\n+      requires requires { ::new (declval<void*>()) _Tp(declval<_Args>()...); }\n+      constexpr _Tp*\n+      operator()(_Tp* __location, _Args&&... __args) const\n+      {\n+\treturn ::new (__detail::__voidify(*__location))\n+\t\t     _Tp(std::forward<_Args>(__args)...);\n+      }\n+  };\n+\n+  inline constexpr __construct_at_fn construct_at{};\n+\n+  struct __destroy_at_fn\n+  {\n+    template<destructible _Tp>\n+      constexpr void\n+      operator()(_Tp* __location) const noexcept\n+      {\n+\tif constexpr (is_array_v<_Tp>)\n+\t  ranges::destroy(ranges::begin(*__location), ranges::end(*__location));\n+\telse\n+\t  __location->~_Tp();\n+      }\n+  };\n+\n+  inline constexpr __destroy_at_fn destroy_at{};\n \n   template<__detail::__nothrow_input_iterator _Iter,\n \t   __detail::__nothrow_sentinel<_Iter> _Sent>\n     requires destructible<iter_value_t<_Iter>>\n     constexpr _Iter\n-    destroy(_Iter __first, _Sent __last) noexcept\n+    __destroy_fn::operator()(_Iter __first, _Sent __last) const noexcept\n     {\n       if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)\n \treturn ranges::next(__first, __last);\n@@ -466,23 +540,28 @@ namespace ranges\n   template<__detail::__nothrow_input_range _Range>\n     requires destructible<range_value_t<_Range>>\n     constexpr safe_iterator_t<_Range>\n-    destroy(_Range&& __r) noexcept\n-    { return ranges::destroy(ranges::begin(__r), ranges::end(__r)); }\n+    __destroy_fn::operator()(_Range&& __r) const noexcept\n+    { return (*this)(ranges::begin(__r), ranges::end(__r)); }\n \n-  template<__detail::__nothrow_input_iterator _Iter>\n-    requires destructible<iter_value_t<_Iter>>\n-    constexpr _Iter\n-    destroy_n(_Iter __first, iter_difference_t<_Iter> __n) noexcept\n-    {\n-      if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)\n-\treturn ranges::next(__first, __n);\n-      else\n-\t{\n-\t  for (; __n > 0; ++__first, (void)--__n)\n-\t    ranges::destroy_at(std::__addressof(*__first));\n-\t  return __first;\n-\t}\n-    }\n+  struct __destroy_n_fn\n+  {\n+    template<__detail::__nothrow_input_iterator _Iter>\n+      requires destructible<iter_value_t<_Iter>>\n+      constexpr _Iter\n+      operator()(_Iter __first, iter_difference_t<_Iter> __n) const noexcept\n+      {\n+\tif constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)\n+\t  return ranges::next(__first, __n);\n+\telse\n+\t  {\n+\t    for (; __n > 0; ++__first, (void)--__n)\n+\t      ranges::destroy_at(std::__addressof(*__first));\n+\t    return __first;\n+\t  }\n+      }\n+  };\n+\n+  inline constexpr __destroy_n_fn destroy_n{};\n }\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}]}