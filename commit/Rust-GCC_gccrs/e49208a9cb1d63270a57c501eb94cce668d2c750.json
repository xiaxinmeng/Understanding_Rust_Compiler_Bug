{"sha": "e49208a9cb1d63270a57c501eb94cce668d2c750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ5MjA4YTljYjFkNjMyNzBhNTdjNTAxZWI5NGNjZTY2OGQyYzc1MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:59:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:59:54Z"}, "message": "[multiple changes]\n\n2011-08-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-expect.adb: Minor reformatting.\n\n2011-08-05  Bob Duff  <duff@adacore.com>\n\n\t* a-fihema.adb: Comment out OS_Lib.\n\n2011-08-05  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Added a-c[oi]mutr.ad[sb]\n\t(unbounded multiway tree containers) and a-iteint.ads.\n\t* a-comutr.ads, a-comutr.adb:\n\tThis is the new Ada 2012 unit for unbounded multiway tree containers\n\t* a-cimutr.ads, a-cimutr.adb\n\tThis is the new Ada 2012 unit for indefinite multiway tree containers\n\t* a-iteint.ads: New file.\n\nFrom-SVN: r177449", "tree": {"sha": "d094856a065c7f72a53c9125b46daeb99a8304ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d094856a065c7f72a53c9125b46daeb99a8304ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e49208a9cb1d63270a57c501eb94cce668d2c750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e49208a9cb1d63270a57c501eb94cce668d2c750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e49208a9cb1d63270a57c501eb94cce668d2c750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e49208a9cb1d63270a57c501eb94cce668d2c750/comments", "author": null, "committer": null, "parents": [{"sha": "569dc494616700a3cf078da0cc631c36a4f15821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/569dc494616700a3cf078da0cc631c36a4f15821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/569dc494616700a3cf078da0cc631c36a4f15821"}], "stats": {"total": 5640, "additions": 5636, "deletions": 4}, "files": [{"sha": "24fdf5c84fe0c256cf36945c868314a2875524aa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -1,3 +1,21 @@\n+2011-08-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-expect.adb: Minor reformatting.\n+\n+2011-08-05  Bob Duff  <duff@adacore.com>\n+\n+\t* a-fihema.adb: Comment out OS_Lib.\n+\n+2011-08-05  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Added a-c[oi]mutr.ad[sb]\n+\t(unbounded multiway tree containers) and a-iteint.ads.\n+\t* a-comutr.ads, a-comutr.adb:\n+\tThis is the new Ada 2012 unit for unbounded multiway tree containers\n+\t* a-cimutr.ads, a-cimutr.adb\n+\tThis is the new Ada 2012 unit for indefinite multiway tree containers\n+\t* a-iteint.ads: New file.\n+\n 2011-08-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc-interface/Makefile.in (raise-gcc.o): Search"}, {"sha": "cc94f4fd44d397728d619a4841b457f86c779fe6", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -139,6 +139,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-crbtgk$(objext) \\\n   a-crbtgo$(objext) \\\n   a-crdlli$(objext) \\\n+  a-comutr$(objext) \\\n+  a-cimutr$(objext) \\\n   a-cwila1$(objext) \\\n   a-cwila9$(objext) \\\n   a-decima$(objext) \\"}, {"sha": "4328296b942bf71d5490ebde76db75c7c5c9511c", "filename": "gcc/ada/a-cimutr.adb", "status": "added", "additions": 2405, "deletions": 0, "changes": 2405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -0,0 +1,2405 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                   ADA.CONTAINERS.INDEFINITE_MULTIWAY_TREES               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Indefinite_Multiway_Trees is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Root_Node (Container : Tree) return Tree_Node_Access;\n+\n+   procedure Free_Element is\n+      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n+\n+   procedure Deallocate_Node (X : in out Tree_Node_Access);\n+\n+   procedure Deallocate_Children\n+     (Subtree : Tree_Node_Access;\n+      Count   : in out Count_Type);\n+\n+   procedure Deallocate_Subtree\n+     (Subtree : in out Tree_Node_Access;\n+      Count   : in out Count_Type);\n+\n+   function Equal_Children\n+     (Left_Subtree, Right_Subtree : Tree_Node_Access) return Boolean;\n+\n+   function Equal_Subtree\n+     (Left_Subtree, Right_Subtree : Tree_Node_Access) return Boolean;\n+\n+   procedure Iterate_Children\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Iterate_Subtree\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Copy_Children\n+     (Source : Children_Type;\n+      Parent : Tree_Node_Access;\n+      Count  : in out Count_Type);\n+\n+   procedure Copy_Subtree\n+     (Source : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Target : out Tree_Node_Access;\n+      Count  : in out Count_Type);\n+\n+   function Find_In_Children\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access;\n+\n+   function Find_In_Subtree\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access;\n+\n+   function Child_Count (Children : Children_Type) return Count_Type;\n+\n+   function Subtree_Node_Count\n+     (Subtree : Tree_Node_Access) return Count_Type;\n+\n+   function Is_Reachable (From, To : Tree_Node_Access) return Boolean;\n+\n+   procedure Remove_Subtree (Subtree : Tree_Node_Access);\n+\n+   procedure Insert_Subtree_Node\n+     (Subtree : Tree_Node_Access;\n+      Parent  : Tree_Node_Access;\n+      Before  : Tree_Node_Access);\n+\n+   procedure Insert_Subtree_List\n+     (First  : Tree_Node_Access;\n+      Last   : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Before : Tree_Node_Access);\n+\n+   procedure Splice_Children\n+     (Target_Parent : Tree_Node_Access;\n+      Before        : Tree_Node_Access;\n+      Source_Parent : Tree_Node_Access);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Tree) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      return Equal_Children (Root_Node (Left), Root_Node (Right));\n+   end \"=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Tree) is\n+      Source       : constant Children_Type := Container.Root.Children;\n+      Source_Count : constant Count_Type := Container.Count;\n+      Target_Count : Count_Type;\n+\n+   begin\n+      --  We first restore the target container to its\n+      --  default-initialized state, before we attempt any\n+      --  allocation, to ensure that invariants are preserved\n+      --  in the event that the allocation fails.\n+\n+      Container.Root.Children := Children_Type'(others => null);\n+      Container.Busy := 0;\n+      Container.Lock := 0;\n+      Container.Count := 0;\n+\n+      --  Copy_Children returns a count of the number of nodes\n+      --  that it allocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Copy_Children.\n+\n+      Target_Count := 0;\n+\n+      --  Now we attempt the allocation of subtrees. The invariants\n+      --  are satisfied even if the allocation fails.\n+\n+      Copy_Children (Source, Root_Node (Container), Target_Count);\n+      pragma Assert (Target_Count = Source_Count);\n+\n+      Container.Count := Source_Count;\n+   end Adjust;\n+\n+   -------------------\n+   -- Ancestor_Find --\n+   -------------------\n+\n+   function Ancestor_Find\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor\n+   is\n+      R : constant Tree_Node_Access := Root_Node (Container);\n+      N : Tree_Node_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      --  AI-0136 says to raise PE if Position equals the root node.\n+      --  This does not seem correct, as this value is just the limiting\n+      --  condition of the search.  For now we omit this check,\n+      --  pending a ruling from the ARG.  ???\n+      --\n+      --  if Is_Root (Position) then\n+      --     raise Program_Error with \"Position cursor designates root\";\n+      --  end if;\n+\n+      N := Position.Node;\n+      while N /= R loop\n+         if N.Element.all = Item then\n+            return Cursor'(Container'Unrestricted_Access, N);\n+         end if;\n+\n+         N := N.Parent;\n+      end loop;\n+\n+      return No_Element;\n+   end Ancestor_Find;\n+\n+   ------------------\n+   -- Append_Child --\n+   ------------------\n+\n+   procedure Append_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      First, Last : Tree_Node_Access;\n+      Element     : Element_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      Element := new Element_Type'(New_Item);\n+      First := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                   Element => Element,\n+                                   others  => <>);\n+\n+      Last := First;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+\n+         Element := new Element_Type'(New_Item);\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => Element,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => First,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => null);  -- null means \"insert at end of list\"\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Append_Child;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Tree; Source : Tree) is\n+      Source_Count : constant Count_Type := Source.Count;\n+      Target_Count : Count_Type;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Target.Clear;  -- checks busy bit\n+\n+      --  Copy_Children returns the number of nodes that it allocates,\n+      --  but it does this by incrementing the count value passed in,\n+      --  so we must initialize the count before calling Copy_Children.\n+\n+      Target_Count := 0;\n+\n+      --  Note that Copy_Children inserts the newly-allocated children\n+      --  into their parent list only after the allocation of all the\n+      --  children has succeeded. This preserves invariants even if\n+      --  the allocation fails.\n+\n+      Copy_Children (Source.Root.Children, Root_Node (Target), Target_Count);\n+      pragma Assert (Target_Count = Source_Count);\n+\n+      Target.Count := Source_Count;\n+   end Assign;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Tree) is\n+      Container_Count, Children_Count : Count_Type;\n+\n+   begin\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      --  We first set the container count to 0, in order to\n+      --  preserve invariants in case the deallocation fails.\n+      --  (This works because Deallocate_Children immediately\n+      --  removes the children from their parent, and then\n+      --  does the actual deallocation.)\n+\n+      Container_Count := Container.Count;\n+      Container.Count := 0;\n+\n+      --  Deallocate_Children returns the number of nodes that\n+      --  it deallocates, but it does this by incrementing the\n+      --  count value that is passed in, so we must first initialize\n+      --  the count return value before calling it.\n+\n+      Children_Count := 0;\n+\n+      --  See comment above.  Deallocate_Children immediately\n+      --  removes the children list from their parent node (here,\n+      --  the root of the tree), and only after that does it\n+      --  attempt the actual deallocation.  So even if the\n+      --  deallocation fails, the representation invariants\n+      --  for the tree are preserved.\n+\n+      Deallocate_Children (Root_Node (Container), Children_Count);\n+      pragma Assert (Children_Count = Container_Count);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Tree;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Tree) return Tree is\n+   begin\n+      return Target : Tree do\n+         Copy_Children\n+           (Source => Source.Root.Children,\n+            Parent => Root_Node (Target),\n+            Count  => Target.Count);\n+\n+         pragma Assert (Target.Count = Source.Count);\n+      end return;\n+   end Copy;\n+\n+   -------------------\n+   -- Copy_Children --\n+   -------------------\n+\n+   procedure Copy_Children\n+     (Source : Children_Type;\n+      Parent : Tree_Node_Access;\n+      Count  : in out Count_Type)\n+   is\n+      pragma Assert (Parent /= null);\n+      pragma Assert (Parent.Children.First = null);\n+      pragma Assert (Parent.Children.Last = null);\n+\n+      CC : Children_Type;\n+      C  : Tree_Node_Access;\n+\n+   begin\n+      --  We special-case the first allocation, in order\n+      --  to establish the representation invariants\n+      --  for type Children_Type.\n+\n+      C := Source.First;\n+\n+      if C = null then\n+         return;\n+      end if;\n+\n+      Copy_Subtree\n+        (Source => C,\n+         Parent => Parent,\n+         Target => CC.First,\n+         Count  => Count);\n+\n+      CC.Last := CC.First;\n+\n+      --  The representation invariants for the Children_Type\n+      --  list have been established, so we can now copy\n+      --  the remaining children of Source.\n+\n+      C := C.Next;\n+      while C /= null loop\n+         Copy_Subtree\n+           (Source => C,\n+            Parent => Parent,\n+            Target => CC.Last.Next,\n+            Count  => Count);\n+\n+         CC.Last.Next.Prev := CC.Last;\n+         CC.Last := CC.Last.Next;\n+\n+         C := C.Next;\n+      end loop;\n+\n+      --  We add the newly-allocated children to their parent list\n+      --  only after the allocation has succeeded, in order to\n+      --  preserve invariants of the parent.\n+\n+      Parent.Children := CC;\n+   end Copy_Children;\n+\n+   -----------------\n+   -- Child_Count --\n+   -----------------\n+\n+   function Child_Count (Parent : Cursor) return Count_Type is\n+   begin\n+      if Parent = No_Element then\n+         return 0;\n+      end if;\n+\n+      return Child_Count (Parent.Node.Children);\n+   end Child_Count;\n+\n+   function Child_Count (Children : Children_Type) return Count_Type is\n+      Result : Count_Type;\n+      Node   : Tree_Node_Access;\n+\n+   begin\n+      Result := 0;\n+      Node := Children.First;\n+      while Node /= null loop\n+         Result := Result + 1;\n+         Node := Node.Next;\n+      end loop;\n+      return Result;\n+   end Child_Count;\n+\n+   -----------------\n+   -- Child_Depth --\n+   -----------------\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Child = No_Element then\n+         raise Constraint_Error with \"Child cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Child.Container then\n+         raise Program_Error with \"Parent and Child in different containers\";\n+      end if;\n+\n+      Result := 0;\n+      N := Child.Node;\n+      while N /= Parent.Node loop\n+         Result := Result + 1;\n+         N := N.Parent;\n+\n+         if N = null then\n+            raise Program_Error with \"Parent is not ancestor of Child\";\n+         end if;\n+      end loop;\n+      return Result;\n+   end Child_Depth;\n+\n+   ------------------\n+   -- Copy_Subtree --\n+   ------------------\n+\n+   procedure Copy_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : Cursor)\n+   is\n+      Target_Subtree : Tree_Node_Access;\n+      Target_Count   : Count_Type;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Target'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Before cursor not child of Parent\";\n+         end if;\n+      end if;\n+\n+      if Source = No_Element then\n+         return;\n+      end if;\n+\n+      if Is_Root (Source) then\n+         raise Constraint_Error with \"Source cursor designates root\";\n+      end if;\n+\n+      --  Copy_Subtree returns a count of the number of nodes\n+      --  that it allocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Copy_Subtree.\n+\n+      Target_Count := 0;\n+\n+      Copy_Subtree\n+        (Source => Source.Node,\n+         Parent => Parent.Node,\n+         Target => Target_Subtree,\n+         Count  => Target_Count);\n+\n+      pragma Assert (Target_Subtree /= null);\n+      pragma Assert (Target_Subtree.Parent = Parent.Node);\n+      pragma Assert (Target_Count >= 1);\n+\n+      Insert_Subtree_Node\n+        (Subtree => Target_Subtree,\n+         Parent  => Parent.Node,\n+         Before  => Before.Node);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Target.Count := Target.Count + Target_Count;\n+   end Copy_Subtree;\n+\n+   procedure Copy_Subtree\n+     (Source : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Target : out Tree_Node_Access;\n+      Count  : in out Count_Type)\n+   is\n+   begin\n+      Target := new Tree_Node_Type'(Element => Source.Element,\n+                                    Parent  => Parent,\n+                                    others  => <>);\n+\n+      Count := Count + 1;\n+\n+      Copy_Children\n+        (Source => Source.Children,\n+         Parent => Target,\n+         Count  => Count);\n+   end Copy_Subtree;\n+\n+   -------------------------\n+   -- Deallocate_Children --\n+   -------------------------\n+\n+   procedure Deallocate_Children\n+     (Subtree : Tree_Node_Access;\n+      Count   : in out Count_Type)\n+   is\n+      pragma Assert (Subtree /= null);\n+\n+      CC : Children_Type := Subtree.Children;\n+      C  : Tree_Node_Access;\n+\n+   begin\n+      --  We immediately remove the children from their\n+      --  parent, in order to preserve invariants in case\n+      --  the deallocation fails.\n+\n+      Subtree.Children := Children_Type'(others => null);\n+\n+      while CC.First /= null loop\n+         C := CC.First;\n+         CC.First := C.Next;\n+\n+         Deallocate_Subtree (C, Count);\n+      end loop;\n+   end Deallocate_Children;\n+\n+   ---------------------\n+   -- Deallocate_Node --\n+   ---------------------\n+\n+   procedure Deallocate_Node (X : in out Tree_Node_Access) is\n+      procedure Free_Node is\n+         new Ada.Unchecked_Deallocation (Tree_Node_Type, Tree_Node_Access);\n+\n+   --  Start of processing for Deallocate_Node\n+\n+   begin\n+      if X /= null then\n+         Free_Element (X.Element);\n+         Free_Node (X);\n+      end if;\n+   end Deallocate_Node;\n+\n+   ------------------------\n+   -- Deallocate_Subtree --\n+   ------------------------\n+\n+   procedure Deallocate_Subtree\n+     (Subtree : in out Tree_Node_Access;\n+      Count   : in out Count_Type)\n+   is\n+   begin\n+      Deallocate_Children (Subtree, Count);\n+      Deallocate_Node (Subtree);\n+      Count := Count + 1;\n+   end Deallocate_Subtree;\n+\n+   ---------------------\n+   -- Delete_Children --\n+   ---------------------\n+\n+   procedure Delete_Children\n+     (Container : in out Tree;\n+      Parent    : Cursor)\n+   is\n+      Count : Count_Type;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      --  Deallocate_Children returns a count of the number of nodes\n+      --  that it deallocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Deallocate_Children.\n+\n+      Count := 0;\n+\n+      Deallocate_Children (Parent.Node, Count);\n+      pragma Assert (Count <= Container.Count);\n+\n+      Container.Count := Container.Count - Count;\n+   end Delete_Children;\n+\n+   -----------------\n+   -- Delete_Leaf --\n+   -----------------\n+\n+   procedure Delete_Leaf\n+     (Container : in out Tree;\n+      Position  : in out Cursor)\n+   is\n+      X : Tree_Node_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if not Is_Leaf (Position) then\n+         raise Constraint_Error with \"Position cursor does not designate leaf\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      X := Position.Node;\n+      Position := No_Element;\n+\n+      --  Restore represention invariants before attempting the\n+      --  actual deallocation.\n+\n+      Remove_Subtree (X);\n+      Container.Count := Container.Count - 1;\n+\n+      --  It is now safe to attempt the deallocation.  This leaf\n+      --  node has been disassociated from the tree, so even if\n+      --  the deallocation fails, representation invariants\n+      --  will remain satisfied.\n+\n+      Deallocate_Node (X);\n+   end Delete_Leaf;\n+\n+   --------------------\n+   -- Delete_Subtree --\n+   --------------------\n+\n+   procedure Delete_Subtree\n+     (Container : in out Tree;\n+      Position  : in out Cursor)\n+   is\n+      X     : Tree_Node_Access;\n+      Count : Count_Type;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      X := Position.Node;\n+      Position := No_Element;\n+\n+      --  Here is one case where a deallocation failure can\n+      --  result in the violation of a representation invariant.\n+      --  We disassociate the subtree from the tree now, but we\n+      --  only decrement the total node count after we attempt\n+      --  the deallocation. However, if the deallocation fails,\n+      --  the total node count will not get decremented.\n+      --\n+      --  One way around this dilemma is to count the nodes\n+      --  in the subtree before attempt to delete the subtree,\n+      --  but that is an O(n) operation, so it does not seem\n+      --  worth it.\n+      --\n+      --  Perhaps this is much ado about nothing, since the\n+      --  only way deallocation can fail is if Controlled\n+      --  Finalization fails: this propagates Program_Error\n+      --  so all bets are off anyway.  ???\n+\n+      Remove_Subtree (X);\n+\n+      --  Deallocate_Subtree returns a count of the number of nodes\n+      --  that it deallocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Deallocate_Subtree.\n+\n+      Count := 0;\n+\n+      Deallocate_Subtree (X, Count);\n+      pragma Assert (Count <= Container.Count);\n+\n+      --  See comments above. We would prefer to do this\n+      --  sooner, but there's no way to satisfy that goal\n+      --  without an potentially severe execution penalty.\n+\n+      Container.Count := Container.Count - Count;\n+   end Delete_Subtree;\n+\n+   -----------\n+   -- Depth --\n+   -----------\n+\n+   function Depth (Position : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Tree_Node_Access;\n+\n+   begin\n+      Result := 0;\n+      N := Position.Node;\n+      while N /= null loop\n+         N := N.Parent;\n+         Result := Result + 1;\n+      end loop;\n+      return Result;\n+   end Depth;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Position.Container.all) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      return Position.Node.Element.all;\n+   end Element;\n+\n+   --------------------\n+   -- Equal_Children --\n+   --------------------\n+\n+   function Equal_Children\n+     (Left_Subtree  : Tree_Node_Access;\n+      Right_Subtree : Tree_Node_Access) return Boolean\n+   is\n+      Left_Children  : Children_Type renames Left_Subtree.Children;\n+      Right_Children : Children_Type renames Right_Subtree.Children;\n+\n+      L, R : Tree_Node_Access;\n+\n+   begin\n+      if Child_Count (Left_Children) /= Child_Count (Right_Children) then\n+         return False;\n+      end if;\n+\n+      L := Left_Children.First;\n+      R := Right_Children.First;\n+      while L /= null loop\n+         if not Equal_Subtree (L, R) then\n+            return False;\n+         end if;\n+\n+         L := L.Next;\n+         R := R.Next;\n+      end loop;\n+\n+      return True;\n+   end Equal_Children;\n+\n+   -------------------\n+   -- Equal_Subtree --\n+   -------------------\n+\n+   function Equal_Subtree\n+     (Left_Position  : Cursor;\n+      Right_Position : Cursor) return Boolean\n+   is\n+   begin\n+      if Left_Position = No_Element then\n+         raise Constraint_Error with \"Left cursor has no element\";\n+      end if;\n+\n+      if Right_Position = No_Element then\n+         raise Constraint_Error with \"Right cursor has no element\";\n+      end if;\n+\n+      if Left_Position = Right_Position then\n+         return True;\n+      end if;\n+\n+      if Is_Root (Left_Position) then\n+         if not Is_Root (Right_Position) then\n+            return False;\n+         end if;\n+\n+         return Equal_Children (Left_Position.Node, Right_Position.Node);\n+      end if;\n+\n+      if Is_Root (Right_Position) then\n+         return False;\n+      end if;\n+\n+      return Equal_Subtree (Left_Position.Node, Right_Position.Node);\n+   end Equal_Subtree;\n+\n+   function Equal_Subtree\n+     (Left_Subtree  : Tree_Node_Access;\n+      Right_Subtree : Tree_Node_Access) return Boolean\n+   is\n+   begin\n+      if Left_Subtree.Element /= Right_Subtree.Element then\n+         return False;\n+      end if;\n+\n+      return Equal_Children (Left_Subtree, Right_Subtree);\n+   end Equal_Subtree;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : Tree;\n+      Item      : Element_Type) return Cursor\n+   is\n+      N : constant Tree_Node_Access :=\n+            Find_In_Children (Root_Node (Container), Item);\n+\n+   begin\n+      if N = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, N);\n+   end Find;\n+\n+   -----------------\n+   -- First_Child --\n+   -----------------\n+\n+   function First_Child (Parent : Cursor) return Cursor is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      Node := Parent.Node.Children.First;\n+\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Parent.Container, Node);\n+   end First_Child;\n+\n+   -------------------------\n+   -- First_Child_Element --\n+   -------------------------\n+\n+   function First_Child_Element (Parent : Cursor) return Element_Type is\n+   begin\n+      return Element (First_Child (Parent));\n+   end First_Child_Element;\n+\n+   ----------------------\n+   -- Find_In_Children --\n+   ----------------------\n+\n+   function Find_In_Children\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access\n+   is\n+      N, Result : Tree_Node_Access;\n+\n+   begin\n+      N := Subtree.Children.First;\n+      while N /= null loop\n+         Result := Find_In_Subtree (N, Item);\n+\n+         if Result /= null then\n+            return Result;\n+         end if;\n+\n+         N := N.Next;\n+      end loop;\n+\n+      return null;\n+   end Find_In_Children;\n+\n+   ---------------------\n+   -- Find_In_Subtree --\n+   ---------------------\n+\n+   function Find_In_Subtree\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor\n+   is\n+      Result : Tree_Node_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         Result := Find_In_Children (Position.Node, Item);\n+\n+      else\n+         Result := Find_In_Subtree (Position.Node, Item);\n+      end if;\n+\n+      if Result = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Result);\n+   end Find_In_Subtree;\n+\n+   function Find_In_Subtree\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access\n+   is\n+   begin\n+      if Subtree.Element.all = Item then\n+         return Subtree;\n+      end if;\n+\n+      return Find_In_Children (Subtree, Item);\n+   end Find_In_Subtree;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      if Position = No_Element then\n+         return False;\n+      end if;\n+\n+      return Position.Node.Parent /= null;\n+   end Has_Element;\n+\n+   ------------------\n+   -- Insert_Child --\n+   ------------------\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+   begin\n+      Insert_Child (Container, Parent, Before, New_Item, Position, Count);\n+   end Insert_Child;\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Last    : Tree_Node_Access;\n+      Element : Element_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Parent cursor not parent of Before\";\n+         end if;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := No_Element;  -- Need ruling from ARG ???\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      Position.Container := Parent.Container;\n+\n+      Element := new Element_Type'(New_Item);\n+      Position.Node := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                           Element => Element,\n+                                           others  => <>);\n+\n+      Last := Position.Node;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+\n+         Element := new Element_Type'(New_Item);\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => Element,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => Position.Node,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => Before.Node);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Insert_Child;\n+\n+   -------------------------\n+   -- Insert_Subtree_List --\n+   -------------------------\n+\n+   procedure Insert_Subtree_List\n+     (First  : Tree_Node_Access;\n+      Last   : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Before : Tree_Node_Access)\n+   is\n+      pragma Assert (Parent /= null);\n+      C : Children_Type renames Parent.Children;\n+\n+   begin\n+      --  This is a simple utility operation to\n+      --  insert a list of nodes (from First..Last)\n+      --  as children of Parent. The Before node\n+      --  specifies where the new children should be\n+      --  inserted relative to the existing children.\n+\n+      if First = null then\n+         pragma Assert (Last = null);\n+         return;\n+      end if;\n+\n+      pragma Assert (Last /= null);\n+      pragma Assert (Before = null or else Before.Parent = Parent);\n+\n+      if C.First = null then\n+         C.First := First;\n+         C.First.Prev := null;\n+         C.Last := Last;\n+         C.Last.Next := null;\n+\n+      elsif Before = null then  -- means \"insert after existing nodes\"\n+         C.Last.Next := First;\n+         First.Prev := C.Last;\n+         C.Last := Last;\n+         C.Last.Next := null;\n+\n+      elsif Before = C.First then\n+         Last.Next := C.First;\n+         C.First.Prev := Last;\n+         C.First := First;\n+         C.First.Prev := null;\n+\n+      else\n+         Before.Prev.Next := First;\n+         First.Prev := Before.Prev;\n+         Last.Next := Before;\n+         Before.Prev := Last;\n+      end if;\n+   end Insert_Subtree_List;\n+\n+   -------------------------\n+   -- Insert_Subtree_Node --\n+   -------------------------\n+\n+   procedure Insert_Subtree_Node\n+     (Subtree : Tree_Node_Access;\n+      Parent  : Tree_Node_Access;\n+      Before  : Tree_Node_Access)\n+   is\n+   begin\n+      --  This is a simple wrapper operation to insert\n+      --  a single child into the Parent's children list.\n+\n+      Insert_Subtree_List\n+        (First  => Subtree,\n+         Last   => Subtree,\n+         Parent => Parent,\n+         Before => Before);\n+   end Insert_Subtree_Node;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Tree) return Boolean is\n+   begin\n+      return Container.Root.Children.First = null;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Is_Leaf --\n+   -------------\n+\n+   function Is_Leaf (Position : Cursor) return Boolean is\n+   begin\n+      if Position = No_Element then\n+         return False;\n+      end if;\n+\n+      return Position.Node.Children.First = null;\n+   end Is_Leaf;\n+\n+   ------------------\n+   -- Is_Reachable --\n+   ------------------\n+\n+   function Is_Reachable (From, To : Tree_Node_Access) return Boolean is\n+      pragma Assert (From /= null);\n+      pragma Assert (To /= null);\n+\n+      N : Tree_Node_Access;\n+\n+   begin\n+      N := From;\n+      while N /= null loop\n+         if N = To then\n+            return True;\n+         end if;\n+\n+         N := N.Parent;\n+      end loop;\n+\n+      return False;\n+   end Is_Reachable;\n+\n+   -------------\n+   -- Is_Root --\n+   -------------\n+\n+   function Is_Root (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      return Position = Root (Position.Container.all);\n+   end Is_Root;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Tree;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      T : Tree renames Container'Unrestricted_Access.all;\n+      B : Integer renames T.Busy;\n+\n+   begin\n+      B := B + 1;\n+\n+      Iterate_Children\n+        (Container => Container'Unrestricted_Access,\n+         Subtree   => Root_Node (Container),\n+         Process   => Process);\n+\n+      B := B - 1;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         raise;\n+   end Iterate;\n+\n+   ----------------------\n+   -- Iterate_Children --\n+   ----------------------\n+\n+   procedure Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      declare\n+         B : Integer renames Parent.Container.Busy;\n+         C : Tree_Node_Access;\n+\n+      begin\n+         B := B + 1;\n+\n+         C := Parent.Node.Children.First;\n+         while C /= null loop\n+            Process (Position => Cursor'(Parent.Container, Node => C));\n+            C := C.Next;\n+         end loop;\n+\n+         B := B - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Iterate_Children;\n+\n+   procedure Iterate_Children\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      --  This is a helper function to recursively iterate over\n+      --  all the nodes in a subtree, in depth-first fashion.\n+      --  This particular helper just visits the children of this\n+      --  subtree, not the root of the subtree node itself.  This\n+      --  is useful when starting from the ultimate root of the\n+      --  entire tree (see Iterate), as that root does not have\n+      --  an element.\n+\n+      Node := Subtree.Children.First;\n+      while Node /= null loop\n+         Iterate_Subtree (Container, Node, Process);\n+         Node := Node.Next;\n+      end loop;\n+   end Iterate_Children;\n+\n+   ---------------------\n+   -- Iterate_Subtree --\n+   ---------------------\n+\n+   procedure Iterate_Subtree\n+     (Position  : Cursor;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      declare\n+         B : Integer renames Position.Container.Busy;\n+\n+      begin\n+         B := B + 1;\n+\n+         if Is_Root (Position) then\n+            Iterate_Children (Position.Container, Position.Node, Process);\n+\n+         else\n+            Iterate_Subtree (Position.Container, Position.Node, Process);\n+         end if;\n+\n+         B := B - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Iterate_Subtree;\n+\n+   procedure Iterate_Subtree\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      --  This is a helper function to recursively iterate over\n+      --  all the nodes in a subtree, in depth-first fashion.\n+      --  It first visits the root of the subtree, then visits\n+      --  its children.\n+\n+      Process (Cursor'(Container, Subtree));\n+      Iterate_Children (Container, Subtree, Process);\n+   end Iterate_Subtree;\n+\n+   ----------------\n+   -- Last_Child --\n+   ----------------\n+\n+   function Last_Child (Parent : Cursor) return Cursor is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      Node := Parent.Node.Children.Last;\n+\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return (Parent.Container, Node);\n+   end Last_Child;\n+\n+   ------------------------\n+   -- Last_Child_Element --\n+   ------------------------\n+\n+   function Last_Child_Element (Parent : Cursor) return Element_Type is\n+   begin\n+      return Element (Last_Child (Parent));\n+   end Last_Child_Element;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Tree; Source : in out Tree) is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors of Source (tree is busy)\";\n+      end if;\n+\n+      Target.Clear;  -- checks busy bit\n+\n+      Target.Root.Children := Source.Root.Children;\n+      Source.Root.Children := Children_Type'(others => null);\n+\n+      Node := Target.Root.Children.First;\n+      while Node /= null loop\n+         Node.Parent := Root_Node (Target);\n+         Node := Node.Next;\n+      end loop;\n+\n+      Target.Count := Source.Count;\n+      Source.Count := 0;\n+   end Move;\n+\n+   ------------------\n+   -- Next_Sibling --\n+   ------------------\n+\n+   function Next_Sibling (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Node.Next = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Position.Container, Position.Node.Next);\n+   end Next_Sibling;\n+\n+   procedure Next_Sibling (Position : in out Cursor) is\n+   begin\n+      Position := Next_Sibling (Position);\n+   end Next_Sibling;\n+\n+   ----------------\n+   -- Node_Count --\n+   ----------------\n+\n+   function Node_Count (Container : Tree) return Count_Type is\n+   begin\n+      --  Container.Count is the number of nodes we have actually\n+      --  allocated. We cache the value specifically so this Node_Count\n+      --  operation can execute in O(1) time, which makes it behave\n+      --  similarly to how the Length selector function behaves\n+      --  for other containers.\n+      --\n+      --  The cached node count value only describes the nodes\n+      --  we have allocated; the root node itself is not included\n+      --  in that count. The Node_Count operation returns a value\n+      --  that includes the root node (because the RM says so), so we\n+      --  must add 1 to our cached value.\n+\n+      return 1 + Container.Count;\n+   end Node_Count;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Node.Parent = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Position.Container, Position.Node.Parent);\n+   end Parent;\n+\n+   -------------------\n+   -- Prepent_Child --\n+   -------------------\n+\n+   procedure Prepend_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      First, Last : Tree_Node_Access;\n+      Element     : Element_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      Element := new Element_Type'(New_Item);\n+      First := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                   Element => Element,\n+                                   others  => <>);\n+\n+      Last := First;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+\n+         Element := new Element_Type'(New_Item);\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => Element,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => First,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => Parent.Node.Children.First);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Prepend_Child;\n+\n+   ----------------------\n+   -- Previous_Sibling --\n+   ----------------------\n+\n+   function Previous_Sibling (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Node.Prev = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Position.Container, Position.Node.Prev);\n+   end Previous_Sibling;\n+\n+   procedure Previous_Sibling (Position : in out Cursor) is\n+   begin\n+      Position := Previous_Sibling (Position);\n+   end Previous_Sibling;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      declare\n+         T : Tree renames Position.Container.all'Unrestricted_Access.all;\n+         B : Integer renames T.Busy;\n+         L : Integer renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Process (Position.Node.Element.all);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Tree)\n+   is\n+      procedure Read_Children (Subtree : Tree_Node_Access);\n+\n+      function Read_Subtree\n+        (Parent : Tree_Node_Access) return Tree_Node_Access;\n+\n+      Total_Count, Read_Count : Count_Type;\n+\n+      -------------------\n+      -- Read_Children --\n+      -------------------\n+\n+      procedure Read_Children (Subtree : Tree_Node_Access) is\n+         pragma Assert (Subtree /= null);\n+         pragma Assert (Subtree.Children.First = null);\n+         pragma Assert (Subtree.Children.Last = null);\n+\n+         Count : Count_Type;  -- number of child subtrees\n+         C     : Children_Type;\n+\n+      begin\n+         Count_Type'Read (Stream, Count);\n+\n+         if not Count'Valid then  -- Is this check necessary???\n+            raise Program_Error with \"attempt to read from corrupt stream\";\n+         end if;\n+\n+         if Count = 0 then\n+            return;\n+         end if;\n+\n+         C.First := Read_Subtree (Parent => Subtree);\n+         C.Last := C.First;\n+\n+         for J in Count_Type'(2) .. Count loop\n+            C.Last.Next := Read_Subtree (Parent => Subtree);\n+            C.Last.Next.Prev := C.Last;\n+            C.Last := C.Last.Next;\n+         end loop;\n+\n+         --  Now that the allocation and reads have completed successfully,\n+         --  it is safe to link the children to their parent.\n+\n+         Subtree.Children := C;\n+      end Read_Children;\n+\n+      ------------------\n+      -- Read_Subtree --\n+      ------------------\n+\n+      function Read_Subtree\n+        (Parent : Tree_Node_Access) return Tree_Node_Access\n+      is\n+         Element : constant Element_Access :=\n+                     new Element_Type'(Element_Type'Input (Stream));\n+\n+         Subtree : constant Tree_Node_Access :=\n+                     new Tree_Node_Type'\n+                           (Parent  => Parent,\n+                            Element => Element,\n+                            others  => <>);\n+\n+      begin\n+         Read_Count := Read_Count + 1;\n+\n+         Read_Children (Subtree);\n+\n+         return Subtree;\n+      end Read_Subtree;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Container.Clear;  -- checks busy bit\n+\n+      Count_Type'Read (Stream, Total_Count);\n+\n+      if not Total_Count'Valid then  -- Is this check necessary???\n+         raise Program_Error with \"attempt to read from corrupt stream\";\n+      end if;\n+\n+      if Total_Count = 0 then\n+         return;\n+      end if;\n+\n+      Read_Count := 0;\n+\n+      Read_Children (Root_Node (Container));\n+\n+      if Read_Count /= Total_Count then\n+         raise Program_Error with \"attempt to read from corrupt stream\";\n+      end if;\n+\n+      Container.Count := Total_Count;\n+   end Read;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to read tree cursor from stream\";\n+   end Read;\n+\n+   --------------------\n+   -- Remove_Subtree --\n+   --------------------\n+\n+   procedure Remove_Subtree (Subtree : Tree_Node_Access) is\n+      C : Children_Type renames Subtree.Parent.Children;\n+\n+   begin\n+      --  This is a utility operation to remove a subtree\n+      --  node from its parent's list of children.\n+\n+      if C.First = Subtree then\n+         pragma Assert (Subtree.Prev = null);\n+\n+         if C.Last = Subtree then\n+            pragma Assert (Subtree.Next = null);\n+            C.First := null;\n+            C.Last := null;\n+\n+         else\n+            C.First := Subtree.Next;\n+            C.First.Prev := null;\n+         end if;\n+\n+      elsif C.Last = Subtree then\n+         pragma Assert (Subtree.Next = null);\n+         C.Last := Subtree.Prev;\n+         C.Last.Next := null;\n+\n+      else\n+         Subtree.Prev.Next := Subtree.Next;\n+         Subtree.Next.Prev := Subtree.Prev;\n+      end if;\n+   end Remove_Subtree;\n+\n+   ----------------------\n+   -- Replace_Element --\n+   ----------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+      E, X : Element_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with elements (tree is locked)\";\n+      end if;\n+\n+      E := new Element_Type'(New_Item);\n+\n+      X := Position.Node.Element;\n+      Position.Node.Element := E;\n+\n+      Free_Element (X);\n+   end Replace_Element;\n+\n+   ------------------------------\n+   -- Reverse_Iterate_Children --\n+   ------------------------------\n+\n+   procedure Reverse_Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      declare\n+         B : Integer renames Parent.Container.Busy;\n+         C : Tree_Node_Access;\n+\n+      begin\n+         B := B + 1;\n+\n+         C := Parent.Node.Children.Last;\n+         while C /= null loop\n+            Process (Position => Cursor'(Parent.Container, Node => C));\n+            C := C.Prev;\n+         end loop;\n+\n+         B := B - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Reverse_Iterate_Children;\n+\n+   ----------\n+   -- Root --\n+   ----------\n+\n+   function Root (Container : Tree) return Cursor is\n+   begin\n+      return (Container'Unrestricted_Access, Root_Node (Container));\n+   end Root;\n+\n+   ---------------\n+   -- Root_Node --\n+   ---------------\n+\n+   function Root_Node (Container : Tree) return Tree_Node_Access is\n+   begin\n+      return Container.Root'Unrestricted_Access;\n+   end Root_Node;\n+\n+   ---------------------\n+   -- Splice_Children --\n+   ---------------------\n+\n+   procedure Splice_Children\n+     (Target          : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source          : in out Tree;\n+      Source_Parent   : Cursor)\n+   is\n+      Count : Count_Type;\n+\n+   begin\n+      if Target_Parent = No_Element then\n+         raise Constraint_Error with \"Target_Parent cursor has no element\";\n+      end if;\n+\n+      if Target_Parent.Container /= Target'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Target_Parent cursor not in Target container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error\n+              with \"Before cursor not in Target container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Target_Parent.Node then\n+            raise Constraint_Error\n+              with \"Before cursor not child of Target_Parent\";\n+         end if;\n+      end if;\n+\n+      if Source_Parent = No_Element then\n+         raise Constraint_Error with \"Source_Parent cursor has no element\";\n+      end if;\n+\n+      if Source_Parent.Container /= Source'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Source_Parent cursor not in Source container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         if Target_Parent = Source_Parent then\n+            return;\n+         end if;\n+\n+         if Target.Busy > 0 then\n+            raise Program_Error\n+              with \"attempt to tamper with cursors (Target tree is busy)\";\n+         end if;\n+\n+         if Is_Reachable (From => Target_Parent.Node,\n+                          To   => Source_Parent.Node)\n+         then\n+            raise Constraint_Error\n+              with \"Source_Parent is ancestor of Target_Parent\";\n+         end if;\n+\n+         Splice_Children\n+           (Target_Parent => Target_Parent.Node,\n+            Before        => Before.Node,\n+            Source_Parent => Source_Parent.Node);\n+\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Target tree is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Source tree is busy)\";\n+      end if;\n+\n+      --  We cache the count of the nodes we have allocated, so that\n+      --  operation Node_Count can execute in O(1) time. But that means\n+      --  we must count the nodes in the subtree we remove from Source\n+      --  and insert into Target, in order to keep the count accurate.\n+\n+      Count := Subtree_Node_Count (Source_Parent.Node);\n+      pragma Assert (Count >= 1);\n+\n+      Count := Count - 1;  -- because Source_Parent node does not move\n+\n+      Splice_Children\n+        (Target_Parent => Target_Parent.Node,\n+         Before        => Before.Node,\n+         Source_Parent => Source_Parent.Node);\n+\n+      Source.Count := Source.Count - Count;\n+      Target.Count := Target.Count + Count;\n+   end Splice_Children;\n+\n+   procedure Splice_Children\n+     (Container       : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source_Parent   : Cursor)\n+   is\n+   begin\n+      if Target_Parent = No_Element then\n+         raise Constraint_Error with \"Target_Parent cursor has no element\";\n+      end if;\n+\n+      if Target_Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Target_Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error\n+              with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Target_Parent.Node then\n+            raise Constraint_Error\n+              with \"Before cursor not child of Target_Parent\";\n+         end if;\n+      end if;\n+\n+      if Source_Parent = No_Element then\n+         raise Constraint_Error with \"Source_Parent cursor has no element\";\n+      end if;\n+\n+      if Source_Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Source_Parent cursor not in container\";\n+      end if;\n+\n+      if Target_Parent = Source_Parent then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      if Is_Reachable (From => Target_Parent.Node,\n+                       To   => Source_Parent.Node)\n+      then\n+         raise Constraint_Error\n+           with \"Source_Parent is ancestor of Target_Parent\";\n+      end if;\n+\n+      Splice_Children\n+        (Target_Parent => Target_Parent.Node,\n+         Before        => Before.Node,\n+         Source_Parent => Source_Parent.Node);\n+   end Splice_Children;\n+\n+   procedure Splice_Children\n+     (Target_Parent : Tree_Node_Access;\n+      Before        : Tree_Node_Access;\n+      Source_Parent : Tree_Node_Access)\n+   is\n+      CC : constant Children_Type := Source_Parent.Children;\n+      C  : Tree_Node_Access;\n+\n+   begin\n+      --  This is a utility operation to remove the children from\n+      --  Source parent and insert them into Target parent.\n+\n+      Source_Parent.Children := Children_Type'(others => null);\n+\n+      --  Fix up the Parent pointers of each child to designate\n+      --  its new Target parent.\n+\n+      C := CC.First;\n+      while C /= null loop\n+         C.Parent := Target_Parent;\n+         C := C.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => CC.First,\n+         Last   => CC.Last,\n+         Parent => Target_Parent,\n+         Before => Before);\n+   end Splice_Children;\n+\n+   --------------------\n+   -- Splice_Subtree --\n+   --------------------\n+\n+   procedure Splice_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : in out Tree;\n+      Position : in out Cursor)\n+   is\n+      Subtree_Count : Count_Type;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Target'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in Target container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in Target container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Before cursor not child of Parent\";\n+         end if;\n+      end if;\n+\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Source'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in Source container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         if Position.Node = Before.Node\n+           or else Position.Node.Next = Before.Node\n+         then\n+            return;\n+         end if;\n+\n+         if Target.Busy > 0 then\n+            raise Program_Error\n+              with \"attempt to tamper with cursors (Target tree is busy)\";\n+         end if;\n+\n+         if Is_Reachable (From => Parent.Node, To => Position.Node) then\n+            raise Constraint_Error with \"Position is ancestor of Parent\";\n+         end if;\n+\n+         Remove_Subtree (Position.Node);\n+\n+         Position.Node.Parent := Parent.Node;\n+         Insert_Subtree_Node (Position.Node, Parent.Node, Before.Node);\n+\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Target tree is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Source tree is busy)\";\n+      end if;\n+\n+      --  This is an unfortunate feature of this API: we must count\n+      --  the nodes in the subtree that we remove from the source tree,\n+      --  which is an O(n) operation. It would have been better if\n+      --  the Tree container did not have a Node_Count selector; a\n+      --  user that wants the number of nodes in the tree could\n+      --  simply call Subtree_Node_Count, with the understanding that\n+      --  such an operation is O(n).\n+      --\n+      --  Of course, we could choose to implement the Node_Count selector\n+      --  as an O(n) operation, which would turn this splice operation\n+      --  into an O(1) operation.  ???\n+\n+      Subtree_Count := Subtree_Node_Count (Position.Node);\n+      pragma Assert (Subtree_Count <= Source.Count);\n+\n+      Remove_Subtree (Position.Node);\n+      Source.Count := Source.Count - Subtree_Count;\n+\n+      Position.Node.Parent := Parent.Node;\n+      Insert_Subtree_Node (Position.Node, Parent.Node, Before.Node);\n+\n+      Target.Count := Target.Count + Subtree_Count;\n+\n+      Position.Container := Target'Unrestricted_Access;\n+   end Splice_Subtree;\n+\n+   procedure Splice_Subtree\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      Position  : Cursor)\n+   is\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Before cursor not child of Parent\";\n+         end if;\n+      end if;\n+\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         --  Should this be PE instead?  Need ARG confirmation.  ???\n+         raise Constraint_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Position.Node = Before.Node\n+        or else Position.Node.Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      if Is_Reachable (From => Parent.Node, To => Position.Node) then\n+         raise Constraint_Error with \"Position is ancestor of Parent\";\n+      end if;\n+\n+      Remove_Subtree (Position.Node);\n+\n+      Position.Node.Parent := Parent.Node;\n+      Insert_Subtree_Node (Position.Node, Parent.Node, Before.Node);\n+   end Splice_Subtree;\n+\n+   ------------------------\n+   -- Subtree_Node_Count --\n+   ------------------------\n+\n+   function Subtree_Node_Count (Position : Cursor) return Count_Type is\n+   begin\n+      if Position = No_Element then\n+         return 0;\n+      end if;\n+\n+      return Subtree_Node_Count (Position.Node);\n+   end Subtree_Node_Count;\n+\n+   function Subtree_Node_Count\n+     (Subtree : Tree_Node_Access) return Count_Type\n+   is\n+      Result : Count_Type;\n+      Node   : Tree_Node_Access;\n+\n+   begin\n+      Result := 1;\n+      Node := Subtree.Children.First;\n+      while Node /= null loop\n+         Result := Result + Subtree_Node_Count (Node);\n+         Node := Node.Next;\n+      end loop;\n+      return Result;\n+   end Subtree_Node_Count;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap\n+     (Container : in out Tree;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I = No_Element then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor not in container\";\n+      end if;\n+\n+      if Is_Root (I) then\n+         raise Program_Error with \"I cursor designates root\";\n+      end if;\n+\n+      if I = J then -- make this test sooner???\n+         return;\n+      end if;\n+\n+      if J = No_Element then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor not in container\";\n+      end if;\n+\n+      if Is_Root (J) then\n+         raise Program_Error with \"J cursor designates root\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with elements (tree is locked)\";\n+      end if;\n+\n+      declare\n+         EI : constant Element_Access := I.Node.Element;\n+\n+      begin\n+         I.Node.Element := J.Node.Element;\n+         J.Node.Element := EI;\n+      end;\n+   end Swap;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      declare\n+         T : Tree renames Position.Container.all'Unrestricted_Access.all;\n+         B : Integer renames T.Busy;\n+         L : Integer renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Process (Position.Node.Element.all);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Tree)\n+   is\n+      procedure Write_Children (Subtree : Tree_Node_Access);\n+      procedure Write_Subtree (Subtree : Tree_Node_Access);\n+\n+      --------------------\n+      -- Write_Children --\n+      --------------------\n+\n+      procedure Write_Children (Subtree : Tree_Node_Access) is\n+         CC : Children_Type renames Subtree.Children;\n+         C  : Tree_Node_Access;\n+\n+      begin\n+         Count_Type'Write (Stream, Child_Count (CC));\n+\n+         C := CC.First;\n+         while C /= null loop\n+            Write_Subtree (C);\n+            C := C.Next;\n+         end loop;\n+      end Write_Children;\n+\n+      -------------------\n+      -- Write_Subtree --\n+      -------------------\n+\n+      procedure Write_Subtree (Subtree : Tree_Node_Access) is\n+      begin\n+         Element_Type'Output (Stream, Subtree.Element.all);\n+         Write_Children (Subtree);\n+      end Write_Subtree;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Count_Type'Write (Stream, Container.Count);\n+      Write_Children (Root_Node (Container));\n+   end Write;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to write tree cursor to stream\";\n+   end Write;\n+\n+end Ada.Containers.Indefinite_Multiway_Trees;"}, {"sha": "609a87957666e2c9e7d51a10d2d13a4ee42dc9b8", "filename": "gcc/ada/a-cimutr.ads", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -0,0 +1,330 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                   ADA.CONTAINERS.INDEFINITE_MULTIWAY_TREES               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Finalization;\n+private with Ada.Streams;\n+\n+generic\n+   type Element_Type (<>) is private;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Indefinite_Multiway_Trees is\n+   pragma Preelaborate;\n+   pragma Remote_Types;\n+\n+   type Tree is tagged private;\n+   pragma Preelaborable_Initialization (Tree);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Tree : constant Tree;\n+\n+   No_Element : constant Cursor;\n+\n+   function Equal_Subtree\n+     (Left_Position  : Cursor;\n+      Right_Position : Cursor) return Boolean;\n+\n+   function \"=\" (Left, Right : Tree) return Boolean;\n+\n+   function Is_Empty (Container : Tree) return Boolean;\n+\n+   function Node_Count (Container : Tree) return Count_Type;\n+\n+   function Subtree_Node_Count (Position : Cursor) return Count_Type;\n+\n+   function Depth (Position : Cursor) return Count_Type;\n+\n+   function Is_Root (Position : Cursor) return Boolean;\n+\n+   function Is_Leaf (Position : Cursor) return Boolean;\n+\n+   function Root (Container : Tree) return Cursor;\n+\n+   procedure Clear (Container : in out Tree);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Assign (Target : in out Tree; Source : Tree);\n+\n+   function Copy (Source : Tree) return Tree;\n+\n+   procedure Move (Target : in out Tree; Source : in out Tree);\n+\n+   procedure Delete_Leaf\n+     (Container : in out Tree;\n+      Position  : in out Cursor);\n+\n+   procedure Delete_Subtree\n+     (Container : in out Tree;\n+      Position  : in out Cursor);\n+\n+   procedure Swap\n+     (Container : in out Tree;\n+      I, J      : Cursor);\n+\n+   function Find\n+     (Container : Tree;\n+      Item      : Element_Type) return Cursor;\n+\n+   function Find_In_Subtree\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor;\n+\n+   function Ancestor_Find\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor;\n+\n+   function Contains\n+     (Container : Tree;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Tree;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Iterate_Subtree\n+     (Position  : Cursor;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   function Child_Count (Parent : Cursor) return Count_Type;\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type;\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Children\n+     (Container : in out Tree;\n+      Parent    : Cursor);\n+\n+   procedure Copy_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : Cursor);\n+\n+   procedure Splice_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : in out Tree;\n+      Position : in out Cursor);\n+\n+   procedure Splice_Subtree\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      Position  : Cursor);\n+\n+   procedure Splice_Children\n+     (Target          : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source          : in out Tree;\n+      Source_Parent   : Cursor);\n+\n+   procedure Splice_Children\n+     (Container       : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source_Parent   : Cursor);\n+\n+   function Parent (Position : Cursor) return Cursor;\n+\n+   function First_Child (Parent : Cursor) return Cursor;\n+\n+   function First_Child_Element (Parent : Cursor) return Element_Type;\n+\n+   function Last_Child (Parent : Cursor) return Cursor;\n+\n+   function Last_Child_Element (Parent : Cursor) return Element_Type;\n+\n+   function Next_Sibling (Position : Cursor) return Cursor;\n+\n+   function Previous_Sibling (Position : Cursor) return Cursor;\n+\n+   procedure Next_Sibling (Position : in out Cursor);\n+\n+   procedure Previous_Sibling (Position : in out Cursor);\n+\n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Iterate_Children this way:\n+   --\n+   --  procedure Iterate_Children\n+   --    (Container : Tree;\n+   --     Parent    : Cursor;\n+   --     Process   : not null access procedure (Position : Cursor));\n+   --\n+   --  It seems that the Container parameter is there by mistake, but\n+   --  we need an official ruling from the ARG.  ???\n+\n+   procedure Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor));\n+\n+private\n+\n+   type Tree_Node_Type;\n+   type Tree_Node_Access is access all Tree_Node_Type;\n+\n+   type Children_Type is record\n+      First : Tree_Node_Access;\n+      Last  : Tree_Node_Access;\n+   end record;\n+\n+   type Element_Access is access Element_Type;\n+\n+   type Tree_Node_Type is record\n+      Parent   : Tree_Node_Access;\n+      Prev     : Tree_Node_Access;\n+      Next     : Tree_Node_Access;\n+      Children : Children_Type;\n+      Element  : Element_Access;\n+   end record;\n+\n+   use Ada.Finalization;\n+\n+   --  The Count component of type Tree represents the number of\n+   --  nodes that have been (dynamically) allocated.  It does not\n+   --  include the root node itself.  As implementors, we decide\n+   --  to cache this value, so that the selector function Node_Count\n+   --  can execute in O(1) time, in order to be consistent with\n+   --  the behavior of the Length selector function for other\n+   --  standard container library units. This does mean, however,\n+   --  that the two-container forms for Splice_XXX (that move subtrees\n+   --  across tree containers) will execute in O(n) time, because\n+   --  we must count the number of nodes in the subtree(s) that\n+   --  get moved.  (We resolve the tension between Node_Count\n+   --  and Splice_XXX in favor of Node_Count, under the assumption\n+   --  that Node_Count is the more common operation).\n+\n+   type Tree is new Controlled with record\n+      Root  : aliased Tree_Node_Type;\n+      Busy  : Integer := 0;\n+      Lock  : Integer := 0;\n+      Count : Count_Type := 0;\n+   end record;\n+\n+   overriding procedure Adjust (Container : in out Tree);\n+\n+   overriding procedure Finalize (Container : in out Tree) renames Clear;\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Tree);\n+\n+   for Tree'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Tree);\n+\n+   for Tree'Read use Read;\n+\n+   type Tree_Access is access all Tree;\n+   for Tree_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Tree_Access;\n+      Node      : Tree_Node_Access;\n+   end record;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   Empty_Tree : constant Tree := (Controlled with others => <>);\n+\n+   No_Element : constant Cursor := (others => <>);\n+\n+end Ada.Containers.Indefinite_Multiway_Trees;"}, {"sha": "d2250dec5f1a786f85b9ca00017f4aacca24f4b6", "filename": "gcc/ada/a-comutr.adb", "status": "added", "additions": 2448, "deletions": 0, "changes": 2448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -0,0 +1,2448 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--         A D A . C O N T A I N E R S . M U L T I W A Y _ T R E E S        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Multiway_Trees is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Root_Node (Container : Tree) return Tree_Node_Access;\n+\n+   procedure Deallocate_Node is\n+      new Ada.Unchecked_Deallocation (Tree_Node_Type, Tree_Node_Access);\n+\n+   procedure Deallocate_Children\n+     (Subtree : Tree_Node_Access;\n+      Count   : in out Count_Type);\n+\n+   procedure Deallocate_Subtree\n+     (Subtree : in out Tree_Node_Access;\n+      Count   : in out Count_Type);\n+\n+   function Equal_Children\n+     (Left_Subtree, Right_Subtree : Tree_Node_Access) return Boolean;\n+\n+   function Equal_Subtree\n+     (Left_Subtree, Right_Subtree : Tree_Node_Access) return Boolean;\n+\n+   procedure Iterate_Children\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Iterate_Subtree\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Copy_Children\n+     (Source : Children_Type;\n+      Parent : Tree_Node_Access;\n+      Count  : in out Count_Type);\n+\n+   procedure Copy_Subtree\n+     (Source : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Target : out Tree_Node_Access;\n+      Count  : in out Count_Type);\n+\n+   function Find_In_Children\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access;\n+\n+   function Find_In_Subtree\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access;\n+\n+   function Child_Count (Children : Children_Type) return Count_Type;\n+\n+   function Subtree_Node_Count\n+     (Subtree : Tree_Node_Access) return Count_Type;\n+\n+   function Is_Reachable (From, To : Tree_Node_Access) return Boolean;\n+\n+   procedure Remove_Subtree (Subtree : Tree_Node_Access);\n+\n+   procedure Insert_Subtree_Node\n+     (Subtree : Tree_Node_Access;\n+      Parent  : Tree_Node_Access;\n+      Before  : Tree_Node_Access);\n+\n+   procedure Insert_Subtree_List\n+     (First  : Tree_Node_Access;\n+      Last   : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Before : Tree_Node_Access);\n+\n+   procedure Splice_Children\n+     (Target_Parent : Tree_Node_Access;\n+      Before        : Tree_Node_Access;\n+      Source_Parent : Tree_Node_Access);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Tree) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      return Equal_Children (Root_Node (Left), Root_Node (Right));\n+   end \"=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Container : in out Tree) is\n+      Source       : constant Children_Type := Container.Root.Children;\n+      Source_Count : constant Count_Type := Container.Count;\n+      Target_Count : Count_Type;\n+\n+   begin\n+      --  We first restore the target container to its\n+      --  default-initialized state, before we attempt any\n+      --  allocation, to ensure that invariants are preserved\n+      --  in the event that the allocation fails.\n+\n+      Container.Root.Children := Children_Type'(others => null);\n+      Container.Busy := 0;\n+      Container.Lock := 0;\n+      Container.Count := 0;\n+\n+      --  Copy_Children returns a count of the number of nodes\n+      --  that it allocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Copy_Children.\n+\n+      Target_Count := 0;\n+\n+      --  Now we attempt the allocation of subtrees. The invariants\n+      --  are satisfied even if the allocation fails.\n+\n+      Copy_Children (Source, Root_Node (Container), Target_Count);\n+      pragma Assert (Target_Count = Source_Count);\n+\n+      Container.Count := Source_Count;\n+   end Adjust;\n+\n+   -------------------\n+   -- Ancestor_Find --\n+   -------------------\n+\n+   function Ancestor_Find\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor\n+   is\n+      R : constant Tree_Node_Access := Root_Node (Container);\n+      N : Tree_Node_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      --  AI-0136 says to raise PE if Position equals the root node.\n+      --  This does not seem correct, as this value is just the limiting\n+      --  condition of the search.  For now we omit this check,\n+      --  pending a ruling from the ARG.  ???\n+      --\n+      --  if Is_Root (Position) then\n+      --     raise Program_Error with \"Position cursor designates root\";\n+      --  end if;\n+\n+      N := Position.Node;\n+      while N /= R loop\n+         if N.Element = Item then\n+            return Cursor'(Container'Unrestricted_Access, N);\n+         end if;\n+\n+         N := N.Parent;\n+      end loop;\n+\n+      return No_Element;\n+   end Ancestor_Find;\n+\n+   ------------------\n+   -- Append_Child --\n+   ------------------\n+\n+   procedure Append_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      First, Last : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      First := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                   Element => New_Item,\n+                                   others  => <>);\n+\n+      Last := First;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => New_Item,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => First,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => null);  -- null means \"insert at end of list\"\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Append_Child;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Tree; Source : Tree) is\n+      Source_Count : constant Count_Type := Source.Count;\n+      Target_Count : Count_Type;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      Target.Clear;  -- checks busy bit\n+\n+      --  Copy_Children returns the number of nodes that it allocates,\n+      --  but it does this by incrementing the count value passed in,\n+      --  so we must initialize the count before calling Copy_Children.\n+\n+      Target_Count := 0;\n+\n+      --  Note that Copy_Children inserts the newly-allocated children\n+      --  into their parent list only after the allocation of all the\n+      --  children has succeeded. This preserves invariants even if\n+      --  the allocation fails.\n+\n+      Copy_Children (Source.Root.Children, Root_Node (Target), Target_Count);\n+      pragma Assert (Target_Count = Source_Count);\n+\n+      Target.Count := Source_Count;\n+   end Assign;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Tree) is\n+      Container_Count, Children_Count : Count_Type;\n+\n+   begin\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      --  We first set the container count to 0, in order to\n+      --  preserve invariants in case the deallocation fails.\n+      --  (This works because Deallocate_Children immediately\n+      --  removes the children from their parent, and then\n+      --  does the actual deallocation.)\n+\n+      Container_Count := Container.Count;\n+      Container.Count := 0;\n+\n+      --  Deallocate_Children returns the number of nodes that\n+      --  it deallocates, but it does this by incrementing the\n+      --  count value that is passed in, so we must first initialize\n+      --  the count return value before calling it.\n+\n+      Children_Count := 0;\n+\n+      --  See comment above.  Deallocate_Children immediately\n+      --  removes the children list from their parent node (here,\n+      --  the root of the tree), and only after that does it\n+      --  attempt the actual deallocation.  So even if the\n+      --  deallocation fails, the representation invariants\n+      --  for the tree are preserved.\n+\n+      Deallocate_Children (Root_Node (Container), Children_Count);\n+      pragma Assert (Children_Count = Container_Count);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Tree;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Tree) return Tree is\n+   begin\n+      return Target : Tree do\n+         Copy_Children\n+           (Source => Source.Root.Children,\n+            Parent => Root_Node (Target),\n+            Count  => Target.Count);\n+\n+         pragma Assert (Target.Count = Source.Count);\n+      end return;\n+   end Copy;\n+\n+   -------------------\n+   -- Copy_Children --\n+   -------------------\n+\n+   procedure Copy_Children\n+     (Source : Children_Type;\n+      Parent : Tree_Node_Access;\n+      Count  : in out Count_Type)\n+   is\n+      pragma Assert (Parent /= null);\n+      pragma Assert (Parent.Children.First = null);\n+      pragma Assert (Parent.Children.Last = null);\n+\n+      CC : Children_Type;\n+      C  : Tree_Node_Access;\n+\n+   begin\n+      --  We special-case the first allocation, in order\n+      --  to establish the representation invariants\n+      --  for type Children_Type.\n+\n+      C := Source.First;\n+\n+      if C = null then\n+         return;\n+      end if;\n+\n+      Copy_Subtree\n+        (Source => C,\n+         Parent => Parent,\n+         Target => CC.First,\n+         Count  => Count);\n+\n+      CC.Last := CC.First;\n+\n+      --  The representation invariants for the Children_Type\n+      --  list have been established, so we can now copy\n+      --  the remaining children of Source.\n+\n+      C := C.Next;\n+      while C /= null loop\n+         Copy_Subtree\n+           (Source => C,\n+            Parent => Parent,\n+            Target => CC.Last.Next,\n+            Count  => Count);\n+\n+         CC.Last.Next.Prev := CC.Last;\n+         CC.Last := CC.Last.Next;\n+\n+         C := C.Next;\n+      end loop;\n+\n+      --  We add the newly-allocated children to their parent list\n+      --  only after the allocation has succeeded, in order to\n+      --  preserve invariants of the parent.\n+\n+      Parent.Children := CC;\n+   end Copy_Children;\n+\n+   -----------------\n+   -- Child_Count --\n+   -----------------\n+\n+   function Child_Count (Parent : Cursor) return Count_Type is\n+   begin\n+      if Parent = No_Element then\n+         return 0;\n+      end if;\n+\n+      return Child_Count (Parent.Node.Children);\n+   end Child_Count;\n+\n+   function Child_Count (Children : Children_Type) return Count_Type is\n+      Result : Count_Type;\n+      Node   : Tree_Node_Access;\n+\n+   begin\n+      Result := 0;\n+      Node := Children.First;\n+      while Node /= null loop\n+         Result := Result + 1;\n+         Node := Node.Next;\n+      end loop;\n+      return Result;\n+   end Child_Count;\n+\n+   -----------------\n+   -- Child_Depth --\n+   -----------------\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Child = No_Element then\n+         raise Constraint_Error with \"Child cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Child.Container then\n+         raise Program_Error with \"Parent and Child in different containers\";\n+      end if;\n+\n+      Result := 0;\n+      N := Child.Node;\n+      while N /= Parent.Node loop\n+         Result := Result + 1;\n+         N := N.Parent;\n+\n+         if N = null then\n+            raise Program_Error with \"Parent is not ancestor of Child\";\n+         end if;\n+      end loop;\n+      return Result;\n+   end Child_Depth;\n+\n+   ------------------\n+   -- Copy_Subtree --\n+   ------------------\n+\n+   procedure Copy_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : Cursor)\n+   is\n+      Target_Subtree : Tree_Node_Access;\n+      Target_Count   : Count_Type;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Target'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Before cursor not child of Parent\";\n+         end if;\n+      end if;\n+\n+      if Source = No_Element then\n+         return;\n+      end if;\n+\n+      if Is_Root (Source) then\n+         raise Constraint_Error with \"Source cursor designates root\";\n+      end if;\n+\n+      --  Copy_Subtree returns a count of the number of nodes\n+      --  that it allocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Copy_Subtree.\n+\n+      Target_Count := 0;\n+\n+      Copy_Subtree\n+        (Source => Source.Node,\n+         Parent => Parent.Node,\n+         Target => Target_Subtree,\n+         Count  => Target_Count);\n+\n+      pragma Assert (Target_Subtree /= null);\n+      pragma Assert (Target_Subtree.Parent = Parent.Node);\n+      pragma Assert (Target_Count >= 1);\n+\n+      Insert_Subtree_Node\n+        (Subtree => Target_Subtree,\n+         Parent  => Parent.Node,\n+         Before  => Before.Node);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Target.Count := Target.Count + Target_Count;\n+   end Copy_Subtree;\n+\n+   procedure Copy_Subtree\n+     (Source : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Target : out Tree_Node_Access;\n+      Count  : in out Count_Type)\n+   is\n+   begin\n+      Target := new Tree_Node_Type'(Element => Source.Element,\n+                                    Parent  => Parent,\n+                                    others  => <>);\n+\n+      Count := Count + 1;\n+\n+      Copy_Children\n+        (Source => Source.Children,\n+         Parent => Target,\n+         Count  => Count);\n+   end Copy_Subtree;\n+\n+   -------------------------\n+   -- Deallocate_Children --\n+   -------------------------\n+\n+   procedure Deallocate_Children\n+     (Subtree : Tree_Node_Access;\n+      Count   : in out Count_Type)\n+   is\n+      pragma Assert (Subtree /= null);\n+\n+      CC : Children_Type := Subtree.Children;\n+      C  : Tree_Node_Access;\n+\n+   begin\n+      --  We immediately remove the children from their\n+      --  parent, in order to preserve invariants in case\n+      --  the deallocation fails.\n+\n+      Subtree.Children := Children_Type'(others => null);\n+\n+      while CC.First /= null loop\n+         C := CC.First;\n+         CC.First := C.Next;\n+\n+         Deallocate_Subtree (C, Count);\n+      end loop;\n+   end Deallocate_Children;\n+\n+   ------------------------\n+   -- Deallocate_Subtree --\n+   ------------------------\n+\n+   procedure Deallocate_Subtree\n+     (Subtree : in out Tree_Node_Access;\n+      Count   : in out Count_Type)\n+   is\n+   begin\n+      Deallocate_Children (Subtree, Count);\n+      Deallocate_Node (Subtree);\n+      Count := Count + 1;\n+   end Deallocate_Subtree;\n+\n+   ---------------------\n+   -- Delete_Children --\n+   ---------------------\n+\n+   procedure Delete_Children\n+     (Container : in out Tree;\n+      Parent    : Cursor)\n+   is\n+      Count : Count_Type;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      --  Deallocate_Children returns a count of the number of nodes\n+      --  that it deallocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Deallocate_Children.\n+\n+      Count := 0;\n+\n+      Deallocate_Children (Parent.Node, Count);\n+      pragma Assert (Count <= Container.Count);\n+\n+      Container.Count := Container.Count - Count;\n+   end Delete_Children;\n+\n+   -----------------\n+   -- Delete_Leaf --\n+   -----------------\n+\n+   procedure Delete_Leaf\n+     (Container : in out Tree;\n+      Position  : in out Cursor)\n+   is\n+      X : Tree_Node_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if not Is_Leaf (Position) then\n+         raise Constraint_Error with \"Position cursor does not designate leaf\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      X := Position.Node;\n+      Position := No_Element;\n+\n+      --  Restore represention invariants before attempting the\n+      --  actual deallocation.\n+\n+      Remove_Subtree (X);\n+      Container.Count := Container.Count - 1;\n+\n+      --  It is now safe to attempt the deallocation.  This leaf\n+      --  node has been disassociated from the tree, so even if\n+      --  the deallocation fails, representation invariants\n+      --  will remain satisfied.\n+\n+      Deallocate_Node (X);\n+   end Delete_Leaf;\n+\n+   --------------------\n+   -- Delete_Subtree --\n+   --------------------\n+\n+   procedure Delete_Subtree\n+     (Container : in out Tree;\n+      Position  : in out Cursor)\n+   is\n+      X     : Tree_Node_Access;\n+      Count : Count_Type;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      X := Position.Node;\n+      Position := No_Element;\n+\n+      --  Here is one case where a deallocation failure can\n+      --  result in the violation of a representation invariant.\n+      --  We disassociate the subtree from the tree now, but we\n+      --  only decrement the total node count after we attempt\n+      --  the deallocation. However, if the deallocation fails,\n+      --  the total node count will not get decremented.\n+      --\n+      --  One way around this dilemma is to count the nodes\n+      --  in the subtree before attempt to delete the subtree,\n+      --  but that is an O(n) operation, so it does not seem\n+      --  worth it.\n+      --\n+      --  Perhaps this is much ado about nothing, since the\n+      --  only way deallocation can fail is if Controlled\n+      --  Finalization fails: this propagates Program_Error\n+      --  so all bets are off anyway.  ???\n+\n+      Remove_Subtree (X);\n+\n+      --  Deallocate_Subtree returns a count of the number of nodes\n+      --  that it deallocates, but it works by incrementing the\n+      --  value that is passed in. We must therefore initialize\n+      --  the count value before calling Deallocate_Subtree.\n+\n+      Count := 0;\n+\n+      Deallocate_Subtree (X, Count);\n+      pragma Assert (Count <= Container.Count);\n+\n+      --  See comments above. We would prefer to do this\n+      --  sooner, but there's no way to satisfy that goal\n+      --  without an potentially severe execution penalty.\n+\n+      Container.Count := Container.Count - Count;\n+   end Delete_Subtree;\n+\n+   -----------\n+   -- Depth --\n+   -----------\n+\n+   function Depth (Position : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Tree_Node_Access;\n+\n+   begin\n+      Result := 0;\n+      N := Position.Node;\n+      while N /= null loop\n+         N := N.Parent;\n+         Result := Result + 1;\n+      end loop;\n+      return Result;\n+   end Depth;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Position.Container.all) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      return Position.Node.Element;\n+   end Element;\n+\n+   --------------------\n+   -- Equal_Children --\n+   --------------------\n+\n+   function Equal_Children\n+     (Left_Subtree  : Tree_Node_Access;\n+      Right_Subtree : Tree_Node_Access) return Boolean\n+   is\n+      Left_Children  : Children_Type renames Left_Subtree.Children;\n+      Right_Children : Children_Type renames Right_Subtree.Children;\n+\n+      L, R : Tree_Node_Access;\n+\n+   begin\n+      if Child_Count (Left_Children) /= Child_Count (Right_Children) then\n+         return False;\n+      end if;\n+\n+      L := Left_Children.First;\n+      R := Right_Children.First;\n+      while L /= null loop\n+         if not Equal_Subtree (L, R) then\n+            return False;\n+         end if;\n+\n+         L := L.Next;\n+         R := R.Next;\n+      end loop;\n+\n+      return True;\n+   end Equal_Children;\n+\n+   -------------------\n+   -- Equal_Subtree --\n+   -------------------\n+\n+   function Equal_Subtree\n+     (Left_Position  : Cursor;\n+      Right_Position : Cursor) return Boolean\n+   is\n+   begin\n+      if Left_Position = No_Element then\n+         raise Constraint_Error with \"Left cursor has no element\";\n+      end if;\n+\n+      if Right_Position = No_Element then\n+         raise Constraint_Error with \"Right cursor has no element\";\n+      end if;\n+\n+      if Left_Position = Right_Position then\n+         return True;\n+      end if;\n+\n+      if Is_Root (Left_Position) then\n+         if not Is_Root (Right_Position) then\n+            return False;\n+         end if;\n+\n+         return Equal_Children (Left_Position.Node, Right_Position.Node);\n+      end if;\n+\n+      if Is_Root (Right_Position) then\n+         return False;\n+      end if;\n+\n+      return Equal_Subtree (Left_Position.Node, Right_Position.Node);\n+   end Equal_Subtree;\n+\n+   function Equal_Subtree\n+     (Left_Subtree  : Tree_Node_Access;\n+      Right_Subtree : Tree_Node_Access) return Boolean\n+   is\n+   begin\n+      if Left_Subtree.Element /= Right_Subtree.Element then\n+         return False;\n+      end if;\n+\n+      return Equal_Children (Left_Subtree, Right_Subtree);\n+   end Equal_Subtree;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : Tree;\n+      Item      : Element_Type) return Cursor\n+   is\n+      N : constant Tree_Node_Access :=\n+            Find_In_Children (Root_Node (Container), Item);\n+\n+   begin\n+      if N = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, N);\n+   end Find;\n+\n+   -----------------\n+   -- First_Child --\n+   -----------------\n+\n+   function First_Child (Parent : Cursor) return Cursor is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      Node := Parent.Node.Children.First;\n+\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Parent.Container, Node);\n+   end First_Child;\n+\n+   -------------------------\n+   -- First_Child_Element --\n+   -------------------------\n+\n+   function First_Child_Element (Parent : Cursor) return Element_Type is\n+   begin\n+      return Element (First_Child (Parent));\n+   end First_Child_Element;\n+\n+   ----------------------\n+   -- Find_In_Children --\n+   ----------------------\n+\n+   function Find_In_Children\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access\n+   is\n+      N, Result : Tree_Node_Access;\n+\n+   begin\n+      N := Subtree.Children.First;\n+      while N /= null loop\n+         Result := Find_In_Subtree (N, Item);\n+\n+         if Result /= null then\n+            return Result;\n+         end if;\n+\n+         N := N.Next;\n+      end loop;\n+\n+      return null;\n+   end Find_In_Children;\n+\n+   ---------------------\n+   -- Find_In_Subtree --\n+   ---------------------\n+\n+   function Find_In_Subtree\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor\n+   is\n+      Result : Tree_Node_Access;\n+\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         Result := Find_In_Children (Position.Node, Item);\n+\n+      else\n+         Result := Find_In_Subtree (Position.Node, Item);\n+      end if;\n+\n+      if Result = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Result);\n+   end Find_In_Subtree;\n+\n+   function Find_In_Subtree\n+     (Subtree : Tree_Node_Access;\n+      Item    : Element_Type) return Tree_Node_Access\n+   is\n+   begin\n+      if Subtree.Element = Item then\n+         return Subtree;\n+      end if;\n+\n+      return Find_In_Children (Subtree, Item);\n+   end Find_In_Subtree;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      if Position = No_Element then\n+         return False;\n+      end if;\n+\n+      return Position.Node.Parent /= null;\n+   end Has_Element;\n+\n+   ------------------\n+   -- Insert_Child --\n+   ------------------\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+   begin\n+      Insert_Child (Container, Parent, Before, New_Item, Position, Count);\n+   end Insert_Child;\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Last : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Parent cursor not parent of Before\";\n+         end if;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := No_Element;  -- Need ruling from ARG ???\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      Position.Container := Parent.Container;\n+      Position.Node := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                           Element => New_Item,\n+                                           others  => <>);\n+\n+      Last := Position.Node;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => New_Item,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => Position.Node,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => Before.Node);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Insert_Child;\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Last : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Parent cursor not parent of Before\";\n+         end if;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := No_Element;  -- Need ruling from ARG  ???\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      Position.Container := Parent.Container;\n+      Position.Node := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                           Element => <>,\n+                                           others  => <>);\n+\n+      Last := Position.Node;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => <>,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => Position.Node,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => Before.Node);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Insert_Child;\n+\n+   -------------------------\n+   -- Insert_Subtree_List --\n+   -------------------------\n+\n+   procedure Insert_Subtree_List\n+     (First  : Tree_Node_Access;\n+      Last   : Tree_Node_Access;\n+      Parent : Tree_Node_Access;\n+      Before : Tree_Node_Access)\n+   is\n+      pragma Assert (Parent /= null);\n+      C : Children_Type renames Parent.Children;\n+\n+   begin\n+      --  This is a simple utility operation to\n+      --  insert a list of nodes (from First..Last)\n+      --  as children of Parent. The Before node\n+      --  specifies where the new children should be\n+      --  inserted relative to the existing children.\n+\n+      if First = null then\n+         pragma Assert (Last = null);\n+         return;\n+      end if;\n+\n+      pragma Assert (Last /= null);\n+      pragma Assert (Before = null or else Before.Parent = Parent);\n+\n+      if C.First = null then\n+         C.First := First;\n+         C.First.Prev := null;\n+         C.Last := Last;\n+         C.Last.Next := null;\n+\n+      elsif Before = null then  -- means \"insert after existing nodes\"\n+         C.Last.Next := First;\n+         First.Prev := C.Last;\n+         C.Last := Last;\n+         C.Last.Next := null;\n+\n+      elsif Before = C.First then\n+         Last.Next := C.First;\n+         C.First.Prev := Last;\n+         C.First := First;\n+         C.First.Prev := null;\n+\n+      else\n+         Before.Prev.Next := First;\n+         First.Prev := Before.Prev;\n+         Last.Next := Before;\n+         Before.Prev := Last;\n+      end if;\n+   end Insert_Subtree_List;\n+\n+   -------------------------\n+   -- Insert_Subtree_Node --\n+   -------------------------\n+\n+   procedure Insert_Subtree_Node\n+     (Subtree : Tree_Node_Access;\n+      Parent  : Tree_Node_Access;\n+      Before  : Tree_Node_Access)\n+   is\n+   begin\n+      --  This is a simple wrapper operation to insert\n+      --  a single child into the Parent's children list.\n+\n+      Insert_Subtree_List\n+        (First  => Subtree,\n+         Last   => Subtree,\n+         Parent => Parent,\n+         Before => Before);\n+   end Insert_Subtree_Node;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Tree) return Boolean is\n+   begin\n+      return Container.Root.Children.First = null;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Is_Leaf --\n+   -------------\n+\n+   function Is_Leaf (Position : Cursor) return Boolean is\n+   begin\n+      if Position = No_Element then\n+         return False;\n+      end if;\n+\n+      return Position.Node.Children.First = null;\n+   end Is_Leaf;\n+\n+   ------------------\n+   -- Is_Reachable --\n+   ------------------\n+\n+   function Is_Reachable (From, To : Tree_Node_Access) return Boolean is\n+      pragma Assert (From /= null);\n+      pragma Assert (To /= null);\n+\n+      N : Tree_Node_Access;\n+\n+   begin\n+      N := From;\n+      while N /= null loop\n+         if N = To then\n+            return True;\n+         end if;\n+\n+         N := N.Parent;\n+      end loop;\n+\n+      return False;\n+   end Is_Reachable;\n+\n+   -------------\n+   -- Is_Root --\n+   -------------\n+\n+   function Is_Root (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      return Position = Root (Position.Container.all);\n+   end Is_Root;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Tree;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      T : Tree renames Container'Unrestricted_Access.all;\n+      B : Integer renames T.Busy;\n+\n+   begin\n+      B := B + 1;\n+\n+      Iterate_Children\n+        (Container => Container'Unrestricted_Access,\n+         Subtree   => Root_Node (Container),\n+         Process   => Process);\n+\n+      B := B - 1;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         raise;\n+   end Iterate;\n+\n+   ----------------------\n+   -- Iterate_Children --\n+   ----------------------\n+\n+   procedure Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      declare\n+         B : Integer renames Parent.Container.Busy;\n+         C : Tree_Node_Access;\n+\n+      begin\n+         B := B + 1;\n+\n+         C := Parent.Node.Children.First;\n+         while C /= null loop\n+            Process (Position => Cursor'(Parent.Container, Node => C));\n+            C := C.Next;\n+         end loop;\n+\n+         B := B - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Iterate_Children;\n+\n+   procedure Iterate_Children\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      --  This is a helper function to recursively iterate over\n+      --  all the nodes in a subtree, in depth-first fashion.\n+      --  This particular helper just visits the children of this\n+      --  subtree, not the root of the subtree node itself.  This\n+      --  is useful when starting from the ultimate root of the\n+      --  entire tree (see Iterate), as that root does not have\n+      --  an element.\n+\n+      Node := Subtree.Children.First;\n+      while Node /= null loop\n+         Iterate_Subtree (Container, Node, Process);\n+         Node := Node.Next;\n+      end loop;\n+   end Iterate_Children;\n+\n+   ---------------------\n+   -- Iterate_Subtree --\n+   ---------------------\n+\n+   procedure Iterate_Subtree\n+     (Position  : Cursor;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      declare\n+         B : Integer renames Position.Container.Busy;\n+\n+      begin\n+         B := B + 1;\n+\n+         if Is_Root (Position) then\n+            Iterate_Children (Position.Container, Position.Node, Process);\n+\n+         else\n+            Iterate_Subtree (Position.Container, Position.Node, Process);\n+         end if;\n+\n+         B := B - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Iterate_Subtree;\n+\n+   procedure Iterate_Subtree\n+     (Container : Tree_Access;\n+      Subtree   : Tree_Node_Access;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      --  This is a helper function to recursively iterate over\n+      --  all the nodes in a subtree, in depth-first fashion.\n+      --  It first visits the root of the subtree, then visits\n+      --  its children.\n+\n+      Process (Cursor'(Container, Subtree));\n+      Iterate_Children (Container, Subtree, Process);\n+   end Iterate_Subtree;\n+\n+   ----------------\n+   -- Last_Child --\n+   ----------------\n+\n+   function Last_Child (Parent : Cursor) return Cursor is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      Node := Parent.Node.Children.Last;\n+\n+      if Node = null then\n+         return No_Element;\n+      end if;\n+\n+      return (Parent.Container, Node);\n+   end Last_Child;\n+\n+   ------------------------\n+   -- Last_Child_Element --\n+   ------------------------\n+\n+   function Last_Child_Element (Parent : Cursor) return Element_Type is\n+   begin\n+      return Element (Last_Child (Parent));\n+   end Last_Child_Element;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Tree; Source : in out Tree) is\n+      Node : Tree_Node_Access;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors of Source (tree is busy)\";\n+      end if;\n+\n+      Target.Clear;  -- checks busy bit\n+\n+      Target.Root.Children := Source.Root.Children;\n+      Source.Root.Children := Children_Type'(others => null);\n+\n+      Node := Target.Root.Children.First;\n+      while Node /= null loop\n+         Node.Parent := Root_Node (Target);\n+         Node := Node.Next;\n+      end loop;\n+\n+      Target.Count := Source.Count;\n+      Source.Count := 0;\n+   end Move;\n+\n+   ------------------\n+   -- Next_Sibling --\n+   ------------------\n+\n+   function Next_Sibling (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Node.Next = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Position.Container, Position.Node.Next);\n+   end Next_Sibling;\n+\n+   procedure Next_Sibling (Position : in out Cursor) is\n+   begin\n+      Position := Next_Sibling (Position);\n+   end Next_Sibling;\n+\n+   ----------------\n+   -- Node_Count --\n+   ----------------\n+\n+   function Node_Count (Container : Tree) return Count_Type is\n+   begin\n+      --  Container.Count is the number of nodes we have actually\n+      --  allocated. We cache the value specifically so this Node_Count\n+      --  operation can execute in O(1) time, which makes it behave\n+      --  similarly to how the Length selector function behaves\n+      --  for other containers.\n+      --\n+      --  The cached node count value only describes the nodes\n+      --  we have allocated; the root node itself is not included\n+      --  in that count. The Node_Count operation returns a value\n+      --  that includes the root node (because the RM says so), so we\n+      --  must add 1 to our cached value.\n+\n+      return 1 + Container.Count;\n+   end Node_Count;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Node.Parent = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Position.Container, Position.Node.Parent);\n+   end Parent;\n+\n+   -------------------\n+   -- Prepent_Child --\n+   -------------------\n+\n+   procedure Prepend_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      First, Last : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      First := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                   Element => New_Item,\n+                                   others  => <>);\n+\n+      Last := First;\n+\n+      for J in Count_Type'(2) .. Count loop\n+         --  Reclaim other nodes if Storage_Error.  ???\n+         Last.Next := new Tree_Node_Type'(Parent  => Parent.Node,\n+                                          Prev    => Last,\n+                                          Element => New_Item,\n+                                          others  => <>);\n+\n+         Last := Last.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => First,\n+         Last   => Last,\n+         Parent => Parent.Node,\n+         Before => Parent.Node.Children.First);\n+\n+      --  In order for operation Node_Count to complete\n+      --  in O(1) time, we cache the count value. Here we\n+      --  increment the total count by the number of nodes\n+      --  we just inserted.\n+\n+      Container.Count := Container.Count + Count;\n+   end Prepend_Child;\n+\n+   ----------------------\n+   -- Previous_Sibling --\n+   ----------------------\n+\n+   function Previous_Sibling (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Node.Prev = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Position.Container, Position.Node.Prev);\n+   end Previous_Sibling;\n+\n+   procedure Previous_Sibling (Position : in out Cursor) is\n+   begin\n+      Position := Previous_Sibling (Position);\n+   end Previous_Sibling;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      declare\n+         T : Tree renames Position.Container.all'Unrestricted_Access.all;\n+         B : Integer renames T.Busy;\n+         L : Integer renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Process (Position.Node.Element);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Tree)\n+   is\n+      procedure Read_Children (Subtree : Tree_Node_Access);\n+\n+      function Read_Subtree\n+        (Parent : Tree_Node_Access) return Tree_Node_Access;\n+\n+      Total_Count, Read_Count : Count_Type;\n+\n+      -------------------\n+      -- Read_Children --\n+      -------------------\n+\n+      procedure Read_Children (Subtree : Tree_Node_Access) is\n+         pragma Assert (Subtree /= null);\n+         pragma Assert (Subtree.Children.First = null);\n+         pragma Assert (Subtree.Children.Last = null);\n+\n+         Count : Count_Type;  -- number of child subtrees\n+         C     : Children_Type;\n+\n+      begin\n+         Count_Type'Read (Stream, Count);\n+\n+         if not Count'Valid then  -- Is this check necessary???\n+            raise Program_Error with \"attempt to read from corrupt stream\";\n+         end if;\n+\n+         if Count = 0 then\n+            return;\n+         end if;\n+\n+         C.First := Read_Subtree (Parent => Subtree);\n+         C.Last := C.First;\n+\n+         for J in Count_Type'(2) .. Count loop\n+            C.Last.Next := Read_Subtree (Parent => Subtree);\n+            C.Last.Next.Prev := C.Last;\n+            C.Last := C.Last.Next;\n+         end loop;\n+\n+         --  Now that the allocation and reads have completed successfully,\n+         --  it is safe to link the children to their parent.\n+\n+         Subtree.Children := C;\n+      end Read_Children;\n+\n+      ------------------\n+      -- Read_Subtree --\n+      ------------------\n+\n+      function Read_Subtree\n+        (Parent : Tree_Node_Access) return Tree_Node_Access\n+      is\n+         Subtree : constant Tree_Node_Access :=\n+                     new Tree_Node_Type'\n+                           (Parent  => Parent,\n+                            Element => Element_Type'Input (Stream),\n+                            others  => <>);\n+\n+      begin\n+         Read_Count := Read_Count + 1;\n+\n+         Read_Children (Subtree);\n+\n+         return Subtree;\n+      end Read_Subtree;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Container.Clear;  -- checks busy bit\n+\n+      Count_Type'Read (Stream, Total_Count);\n+\n+      if not Total_Count'Valid then  -- Is this check necessary???\n+         raise Program_Error with \"attempt to read from corrupt stream\";\n+      end if;\n+\n+      if Total_Count = 0 then\n+         return;\n+      end if;\n+\n+      Read_Count := 0;\n+\n+      Read_Children (Root_Node (Container));\n+\n+      if Read_Count /= Total_Count then\n+         raise Program_Error with \"attempt to read from corrupt stream\";\n+      end if;\n+\n+      Container.Count := Total_Count;\n+   end Read;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to read tree cursor from stream\";\n+   end Read;\n+\n+   --------------------\n+   -- Remove_Subtree --\n+   --------------------\n+\n+   procedure Remove_Subtree (Subtree : Tree_Node_Access) is\n+      C : Children_Type renames Subtree.Parent.Children;\n+\n+   begin\n+      --  This is a utility operation to remove a subtree\n+      --  node from its parent's list of children.\n+\n+      if C.First = Subtree then\n+         pragma Assert (Subtree.Prev = null);\n+\n+         if C.Last = Subtree then\n+            pragma Assert (Subtree.Next = null);\n+            C.First := null;\n+            C.Last := null;\n+\n+         else\n+            C.First := Subtree.Next;\n+            C.First.Prev := null;\n+         end if;\n+\n+      elsif C.Last = Subtree then\n+         pragma Assert (Subtree.Next = null);\n+         C.Last := Subtree.Prev;\n+         C.Last.Next := null;\n+\n+      else\n+         Subtree.Prev.Next := Subtree.Next;\n+         Subtree.Next.Prev := Subtree.Prev;\n+      end if;\n+   end Remove_Subtree;\n+\n+   ----------------------\n+   -- Replace_Element --\n+   ----------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with elements (tree is locked)\";\n+      end if;\n+\n+      Position.Node.Element := New_Item;\n+   end Replace_Element;\n+\n+   ------------------------------\n+   -- Reverse_Iterate_Children --\n+   ------------------------------\n+\n+   procedure Reverse_Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor))\n+   is\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      declare\n+         B : Integer renames Parent.Container.Busy;\n+         C : Tree_Node_Access;\n+\n+      begin\n+         B := B + 1;\n+\n+         C := Parent.Node.Children.Last;\n+         while C /= null loop\n+            Process (Position => Cursor'(Parent.Container, Node => C));\n+            C := C.Prev;\n+         end loop;\n+\n+         B := B - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Reverse_Iterate_Children;\n+\n+   ----------\n+   -- Root --\n+   ----------\n+\n+   function Root (Container : Tree) return Cursor is\n+   begin\n+      return (Container'Unrestricted_Access, Root_Node (Container));\n+   end Root;\n+\n+   ---------------\n+   -- Root_Node --\n+   ---------------\n+\n+   function Root_Node (Container : Tree) return Tree_Node_Access is\n+      type Root_Node_Access is access all Root_Node_Type;\n+      for Root_Node_Access'Storage_Size use 0;\n+      pragma Convention (C, Root_Node_Access);\n+\n+      function To_Tree_Node_Access is\n+         new Ada.Unchecked_Conversion (Root_Node_Access, Tree_Node_Access);\n+\n+   --  Start of processing for Root_Node\n+\n+   begin\n+      --  This is a utility function for converting from an access type\n+      --  that designates the distinguished root node to an access type\n+      --  designating a non-root node. The representation of a root node\n+      --  does not have an element, but is otherwise identical to a\n+      --  non-root node, so the conversion itself is safe.\n+\n+      return To_Tree_Node_Access (Container.Root'Unrestricted_Access);\n+   end Root_Node;\n+\n+   ---------------------\n+   -- Splice_Children --\n+   ---------------------\n+\n+   procedure Splice_Children\n+     (Target          : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source          : in out Tree;\n+      Source_Parent   : Cursor)\n+   is\n+      Count : Count_Type;\n+\n+   begin\n+      if Target_Parent = No_Element then\n+         raise Constraint_Error with \"Target_Parent cursor has no element\";\n+      end if;\n+\n+      if Target_Parent.Container /= Target'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Target_Parent cursor not in Target container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error\n+              with \"Before cursor not in Target container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Target_Parent.Node then\n+            raise Constraint_Error\n+              with \"Before cursor not child of Target_Parent\";\n+         end if;\n+      end if;\n+\n+      if Source_Parent = No_Element then\n+         raise Constraint_Error with \"Source_Parent cursor has no element\";\n+      end if;\n+\n+      if Source_Parent.Container /= Source'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Source_Parent cursor not in Source container\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         if Target_Parent = Source_Parent then\n+            return;\n+         end if;\n+\n+         if Target.Busy > 0 then\n+            raise Program_Error\n+              with \"attempt to tamper with cursors (Target tree is busy)\";\n+         end if;\n+\n+         if Is_Reachable (From => Target_Parent.Node,\n+                          To   => Source_Parent.Node)\n+         then\n+            raise Constraint_Error\n+              with \"Source_Parent is ancestor of Target_Parent\";\n+         end if;\n+\n+         Splice_Children\n+           (Target_Parent => Target_Parent.Node,\n+            Before        => Before.Node,\n+            Source_Parent => Source_Parent.Node);\n+\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Target tree is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Source tree is busy)\";\n+      end if;\n+\n+      --  We cache the count of the nodes we have allocated, so that\n+      --  operation Node_Count can execute in O(1) time. But that means\n+      --  we must count the nodes in the subtree we remove from Source\n+      --  and insert into Target, in order to keep the count accurate.\n+\n+      Count := Subtree_Node_Count (Source_Parent.Node);\n+      pragma Assert (Count >= 1);\n+\n+      Count := Count - 1;  -- because Source_Parent node does not move\n+\n+      Splice_Children\n+        (Target_Parent => Target_Parent.Node,\n+         Before        => Before.Node,\n+         Source_Parent => Source_Parent.Node);\n+\n+      Source.Count := Source.Count - Count;\n+      Target.Count := Target.Count + Count;\n+   end Splice_Children;\n+\n+   procedure Splice_Children\n+     (Container       : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source_Parent   : Cursor)\n+   is\n+   begin\n+      if Target_Parent = No_Element then\n+         raise Constraint_Error with \"Target_Parent cursor has no element\";\n+      end if;\n+\n+      if Target_Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Target_Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error\n+              with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Target_Parent.Node then\n+            raise Constraint_Error\n+              with \"Before cursor not child of Target_Parent\";\n+         end if;\n+      end if;\n+\n+      if Source_Parent = No_Element then\n+         raise Constraint_Error with \"Source_Parent cursor has no element\";\n+      end if;\n+\n+      if Source_Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error\n+           with \"Source_Parent cursor not in container\";\n+      end if;\n+\n+      if Target_Parent = Source_Parent then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      if Is_Reachable (From => Target_Parent.Node,\n+                       To   => Source_Parent.Node)\n+      then\n+         raise Constraint_Error\n+           with \"Source_Parent is ancestor of Target_Parent\";\n+      end if;\n+\n+      Splice_Children\n+        (Target_Parent => Target_Parent.Node,\n+         Before        => Before.Node,\n+         Source_Parent => Source_Parent.Node);\n+   end Splice_Children;\n+\n+   procedure Splice_Children\n+     (Target_Parent : Tree_Node_Access;\n+      Before        : Tree_Node_Access;\n+      Source_Parent : Tree_Node_Access)\n+   is\n+      CC : constant Children_Type := Source_Parent.Children;\n+      C  : Tree_Node_Access;\n+\n+   begin\n+      --  This is a utility operation to remove the children from\n+      --  Source parent and insert them into Target parent.\n+\n+      Source_Parent.Children := Children_Type'(others => null);\n+\n+      --  Fix up the Parent pointers of each child to designate\n+      --  its new Target parent.\n+\n+      C := CC.First;\n+      while C /= null loop\n+         C.Parent := Target_Parent;\n+         C := C.Next;\n+      end loop;\n+\n+      Insert_Subtree_List\n+        (First  => CC.First,\n+         Last   => CC.Last,\n+         Parent => Target_Parent,\n+         Before => Before);\n+   end Splice_Children;\n+\n+   --------------------\n+   -- Splice_Subtree --\n+   --------------------\n+\n+   procedure Splice_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : in out Tree;\n+      Position : in out Cursor)\n+   is\n+      Subtree_Count : Count_Type;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Target'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in Target container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in Target container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Before cursor not child of Parent\";\n+         end if;\n+      end if;\n+\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Source'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in Source container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         if Position.Node = Before.Node\n+           or else Position.Node.Next = Before.Node\n+         then\n+            return;\n+         end if;\n+\n+         if Target.Busy > 0 then\n+            raise Program_Error\n+              with \"attempt to tamper with cursors (Target tree is busy)\";\n+         end if;\n+\n+         if Is_Reachable (From => Parent.Node, To => Position.Node) then\n+            raise Constraint_Error with \"Position is ancestor of Parent\";\n+         end if;\n+\n+         Remove_Subtree (Position.Node);\n+\n+         Position.Node.Parent := Parent.Node;\n+         Insert_Subtree_Node (Position.Node, Parent.Node, Before.Node);\n+\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Target tree is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (Source tree is busy)\";\n+      end if;\n+\n+      --  This is an unfortunate feature of this API: we must count\n+      --  the nodes in the subtree that we remove from the source tree,\n+      --  which is an O(n) operation. It would have been better if\n+      --  the Tree container did not have a Node_Count selector; a\n+      --  user that wants the number of nodes in the tree could\n+      --  simply call Subtree_Node_Count, with the understanding that\n+      --  such an operation is O(n).\n+      --\n+      --  Of course, we could choose to implement the Node_Count selector\n+      --  as an O(n) operation, which would turn this splice operation\n+      --  into an O(1) operation.  ???\n+\n+      Subtree_Count := Subtree_Node_Count (Position.Node);\n+      pragma Assert (Subtree_Count <= Source.Count);\n+\n+      Remove_Subtree (Position.Node);\n+      Source.Count := Source.Count - Subtree_Count;\n+\n+      Position.Node.Parent := Parent.Node;\n+      Insert_Subtree_Node (Position.Node, Parent.Node, Before.Node);\n+\n+      Target.Count := Target.Count + Subtree_Count;\n+\n+      Position.Container := Target'Unrestricted_Access;\n+   end Splice_Subtree;\n+\n+   procedure Splice_Subtree\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      Position  : Cursor)\n+   is\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Parent cursor not in container\";\n+      end if;\n+\n+      if Before /= No_Element then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Before cursor not in container\";\n+         end if;\n+\n+         if Before.Node.Parent /= Parent.Node then\n+            raise Constraint_Error with \"Before cursor not child of Parent\";\n+         end if;\n+      end if;\n+\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         --  Should this be PE instead?  Need ARG confirmation.  ???\n+         raise Constraint_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Position.Node = Before.Node\n+        or else Position.Node.Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with cursors (tree is busy)\";\n+      end if;\n+\n+      if Is_Reachable (From => Parent.Node, To => Position.Node) then\n+         raise Constraint_Error with \"Position is ancestor of Parent\";\n+      end if;\n+\n+      Remove_Subtree (Position.Node);\n+\n+      Position.Node.Parent := Parent.Node;\n+      Insert_Subtree_Node (Position.Node, Parent.Node, Before.Node);\n+   end Splice_Subtree;\n+\n+   ------------------------\n+   -- Subtree_Node_Count --\n+   ------------------------\n+\n+   function Subtree_Node_Count (Position : Cursor) return Count_Type is\n+   begin\n+      if Position = No_Element then\n+         return 0;\n+      end if;\n+\n+      return Subtree_Node_Count (Position.Node);\n+   end Subtree_Node_Count;\n+\n+   function Subtree_Node_Count\n+     (Subtree : Tree_Node_Access) return Count_Type\n+   is\n+      Result : Count_Type;\n+      Node   : Tree_Node_Access;\n+\n+   begin\n+      Result := 1;\n+      Node := Subtree.Children.First;\n+      while Node /= null loop\n+         Result := Result + Subtree_Node_Count (Node);\n+         Node := Node.Next;\n+      end loop;\n+      return Result;\n+   end Subtree_Node_Count;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap\n+     (Container : in out Tree;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I = No_Element then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor not in container\";\n+      end if;\n+\n+      if Is_Root (I) then\n+         raise Program_Error with \"I cursor designates root\";\n+      end if;\n+\n+      if I = J then -- make this test sooner???\n+         return;\n+      end if;\n+\n+      if J = No_Element then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor not in container\";\n+      end if;\n+\n+      if Is_Root (J) then\n+         raise Program_Error with \"J cursor designates root\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error\n+           with \"attempt to tamper with elements (tree is locked)\";\n+      end if;\n+\n+      declare\n+         EI : constant Element_Type := I.Node.Element;\n+\n+      begin\n+         I.Node.Element := J.Node.Element;\n+         J.Node.Element := EI;\n+      end;\n+   end Swap;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor not in container\";\n+      end if;\n+\n+      if Is_Root (Position) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      declare\n+         T : Tree renames Position.Container.all'Unrestricted_Access.all;\n+         B : Integer renames T.Busy;\n+         L : Integer renames T.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Process (Position.Node.Element);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Tree)\n+   is\n+      procedure Write_Children (Subtree : Tree_Node_Access);\n+      procedure Write_Subtree (Subtree : Tree_Node_Access);\n+\n+      --------------------\n+      -- Write_Children --\n+      --------------------\n+\n+      procedure Write_Children (Subtree : Tree_Node_Access) is\n+         CC : Children_Type renames Subtree.Children;\n+         C  : Tree_Node_Access;\n+\n+      begin\n+         Count_Type'Write (Stream, Child_Count (CC));\n+\n+         C := CC.First;\n+         while C /= null loop\n+            Write_Subtree (C);\n+            C := C.Next;\n+         end loop;\n+      end Write_Children;\n+\n+      -------------------\n+      -- Write_Subtree --\n+      -------------------\n+\n+      procedure Write_Subtree (Subtree : Tree_Node_Access) is\n+      begin\n+         Element_Type'Output (Stream, Subtree.Element);\n+         Write_Children (Subtree);\n+      end Write_Subtree;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Count_Type'Write (Stream, Container.Count);\n+      Write_Children (Root_Node (Container));\n+   end Write;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to write tree cursor to stream\";\n+   end Write;\n+\n+end Ada.Containers.Multiway_Trees;"}, {"sha": "4a7dde060f9f7e96579f91b84d5f36422af0eb3a", "filename": "gcc/ada/a-comutr.ads", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -0,0 +1,378 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--         A D A . C O N T A I N E R S . M U L T I W A Y _ T R E E S        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Finalization;\n+private with Ada.Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Multiway_Trees is\n+   pragma Preelaborate;\n+   pragma Remote_Types;\n+\n+   type Tree is tagged private;\n+   pragma Preelaborable_Initialization (Tree);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Tree : constant Tree;\n+\n+   No_Element : constant Cursor;\n+\n+   function Equal_Subtree\n+     (Left_Position  : Cursor;\n+      Right_Position : Cursor) return Boolean;\n+\n+   function \"=\" (Left, Right : Tree) return Boolean;\n+\n+   function Is_Empty (Container : Tree) return Boolean;\n+\n+   function Node_Count (Container : Tree) return Count_Type;\n+\n+   function Subtree_Node_Count (Position : Cursor) return Count_Type;\n+\n+   function Depth (Position : Cursor) return Count_Type;\n+\n+   function Is_Root (Position : Cursor) return Boolean;\n+\n+   function Is_Leaf (Position : Cursor) return Boolean;\n+\n+   function Root (Container : Tree) return Cursor;\n+\n+   procedure Clear (Container : in out Tree);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Tree;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Assign (Target : in out Tree; Source : Tree);\n+\n+   function Copy (Source : Tree) return Tree;\n+\n+   procedure Move (Target : in out Tree; Source : in out Tree);\n+\n+   procedure Delete_Leaf\n+     (Container : in out Tree;\n+      Position  : in out Cursor);\n+\n+   procedure Delete_Subtree\n+     (Container : in out Tree;\n+      Position  : in out Cursor);\n+\n+   procedure Swap\n+     (Container : in out Tree;\n+      I, J      : Cursor);\n+\n+   function Find\n+     (Container : Tree;\n+      Item      : Element_Type) return Cursor;\n+\n+   function Find_In_Subtree\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor;\n+\n+   function Ancestor_Find\n+     (Container : Tree;\n+      Item      : Element_Type;\n+      Position  : Cursor) return Cursor;\n+\n+   function Contains\n+     (Container : Tree;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Tree;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Iterate_Subtree\n+     (Position  : Cursor;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   function Child_Count (Parent : Cursor) return Count_Type;\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type;\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append_Child\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Children\n+     (Container : in out Tree;\n+      Parent    : Cursor);\n+\n+   procedure Copy_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : Cursor);\n+\n+   procedure Splice_Subtree\n+     (Target   : in out Tree;\n+      Parent   : Cursor;\n+      Before   : Cursor;\n+      Source   : in out Tree;\n+      Position : in out Cursor);\n+\n+   procedure Splice_Subtree\n+     (Container : in out Tree;\n+      Parent    : Cursor;\n+      Before    : Cursor;\n+      Position  : Cursor);\n+\n+   procedure Splice_Children\n+     (Target          : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source          : in out Tree;\n+      Source_Parent   : Cursor);\n+\n+   procedure Splice_Children\n+     (Container       : in out Tree;\n+      Target_Parent   : Cursor;\n+      Before          : Cursor;\n+      Source_Parent   : Cursor);\n+\n+   function Parent (Position : Cursor) return Cursor;\n+\n+   function First_Child (Parent : Cursor) return Cursor;\n+\n+   function First_Child_Element (Parent : Cursor) return Element_Type;\n+\n+   function Last_Child (Parent : Cursor) return Cursor;\n+\n+   function Last_Child_Element (Parent : Cursor) return Element_Type;\n+\n+   function Next_Sibling (Position : Cursor) return Cursor;\n+\n+   function Previous_Sibling (Position : Cursor) return Cursor;\n+\n+   procedure Next_Sibling (Position : in out Cursor);\n+\n+   procedure Previous_Sibling (Position : in out Cursor);\n+\n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Iterate_Children this way:\n+   --\n+   --  procedure Iterate_Children\n+   --    (Container : Tree;\n+   --     Parent    : Cursor;\n+   --     Process   : not null access procedure (Position : Cursor));\n+   --\n+   --  It seems that the Container parameter is there by mistake, but\n+   --  we need an official ruling from the ARG.  ???\n+\n+   procedure Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate_Children\n+     (Parent  : Cursor;\n+      Process : not null access procedure (Position : Cursor));\n+\n+private\n+\n+   --  A node of this multiway tree comprises an element and a list of\n+   --  children (that are themselves trees).  The root node is distinguished\n+   --  because it contains only children: it does not have an element itself.\n+   --\n+   --  This design feature puts two design goals in tension:\n+   --   (1) treat the root node the same as any other node\n+   --   (2) not declare any objects of type Element_Type unnecessarily\n+   --\n+   --  To satisfy (1), we could simply declare the Root node of the tree\n+   --  using the normal Tree_Node_Type, but that would mean that (2) is not\n+   --  satisfied. To resolve the tension (in favor of (2)), we declare the\n+   --  component Root as having a different node type, without an Element\n+   --  component (thus satisfying goal (2)) but otherwise identical to a\n+   --  normal node, and then use Unchecked_Conversion to convert an access\n+   --  object designating the Root node component to the access type\n+   --  designating a normal, non-root node (thus satisfying goal (1)). We make\n+   --  an explicit check for Root when there is any attempt to manipulate the\n+   --  Element component of the node (a check required by the RM anyway).\n+   --\n+   --  In order to be explicit about node (and pointer) representation, we\n+   --  specify that the respective node types have convention C, to ensure\n+   --  that the layout of the components of the node records is the same,\n+   --  thus guaranteeing that (unchecked) conversions between access types\n+   --  designating each kind of node type is a meaningful conversion.\n+\n+   type Tree_Node_Type;\n+   type Tree_Node_Access is access all Tree_Node_Type;\n+   pragma Convention (C, Tree_Node_Access);\n+\n+   type Children_Type is record\n+      First : Tree_Node_Access;\n+      Last  : Tree_Node_Access;\n+   end record;\n+\n+   --  See the comment above.  This declaration must exactly\n+   --  match the declaration of Root_Node_Type (except for\n+   --  the Element component).\n+\n+   type Tree_Node_Type is record\n+      Parent   : Tree_Node_Access;\n+      Prev     : Tree_Node_Access;\n+      Next     : Tree_Node_Access;\n+      Children : Children_Type;\n+      Element  : Element_Type;\n+   end record;\n+   pragma Convention (C, Tree_Node_Type);\n+\n+   --  See the comment above.  This declaration must match\n+   --  the declaration of Tree_Node_Type (except for the\n+   --  Element component).\n+\n+   type Root_Node_Type is record\n+      Parent   : Tree_Node_Access;\n+      Prev     : Tree_Node_Access;\n+      Next     : Tree_Node_Access;\n+      Children : Children_Type;\n+   end record;\n+   pragma Convention (C, Root_Node_Type);\n+\n+   use Ada.Finalization;\n+\n+   --  The Count component of type Tree represents the number of\n+   --  nodes that have been (dynamically) allocated.  It does not\n+   --  include the root node itself.  As implementors, we decide\n+   --  to cache this value, so that the selector function Node_Count\n+   --  can execute in O(1) time, in order to be consistent with\n+   --  the behavior of the Length selector function for other\n+   --  standard container library units. This does mean, however,\n+   --  that the two-container forms for Splice_XXX (that move subtrees\n+   --  across tree containers) will execute in O(n) time, because\n+   --  we must count the number of nodes in the subtree(s) that\n+   --  get moved.  (We resolve the tension between Node_Count\n+   --  and Splice_XXX in favor of Node_Count, under the assumption\n+   --  that Node_Count is the more common operation).\n+\n+   type Tree is new Controlled with record\n+      Root  : aliased Root_Node_Type;\n+      Busy  : Integer := 0;\n+      Lock  : Integer := 0;\n+      Count : Count_Type := 0;\n+   end record;\n+\n+   overriding procedure Adjust (Container : in out Tree);\n+\n+   overriding procedure Finalize (Container : in out Tree) renames Clear;\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Tree);\n+\n+   for Tree'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Tree);\n+\n+   for Tree'Read use Read;\n+\n+   type Tree_Access is access all Tree;\n+   for Tree_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Tree_Access;\n+      Node      : Tree_Node_Access;\n+   end record;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   Empty_Tree : constant Tree := (Controlled with others => <>);\n+\n+   No_Element : constant Cursor := (others => <>);\n+\n+end Ada.Containers.Multiway_Trees;"}, {"sha": "fbfebec1ac548f518ecd9b1d19c980cd26c92ef7", "filename": "gcc/ada/a-fihema.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -35,7 +35,8 @@ with Ada.Unchecked_Conversion;\n with System;                  use System;\n with System.Address_Image;\n with System.IO;               use System.IO;\n-with System.OS_Lib;\n+--  ???with System.OS_Lib;\n+--  Breaks ravenscar runtimes\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n with System.Storage_Pools;    use System.Storage_Pools;\n@@ -88,7 +89,8 @@ package body Ada.Finalization.Heap_Management is\n       procedure Fail is\n       begin\n          Put_Line (\"Heap_Management: Fin_Assert failed: \" & Message);\n-         OS_Lib.OS_Abort;\n+         --  ???OS_Lib.OS_Abort;\n+         --  Breaks ravenscar runtimes\n       end Fail;\n \n    --  Start of processing for Fin_Assert"}, {"sha": "3e7e074cbb7a1ad6caf2e21e82c92b2b0caec8ff", "filename": "gcc/ada/a-iteint.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-iteint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fa-iteint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-iteint.ads?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -0,0 +1,46 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               A D A . I T E R A T O R . I N T E R F A C E S              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Cursor is private;\n+   No_Element : Cursor;\n+   pragma Unreferenced (No_Element);\n+package Ada.Iterator_Interfaces is\n+   type Forward_Iterator is limited interface;\n+   function First (Object : Forward_Iterator) return Cursor is abstract;\n+   function Next (Object : Forward_Iterator; Position : Cursor) return Cursor\n+     is abstract;\n+   type Reversible_Iterator is limited interface and Forward_Iterator;\n+   function Last (Object : Reversible_Iterator) return Cursor is abstract;\n+   function Previous (Object : Reversible_Iterator; Position : Cursor)\n+     return Cursor is abstract;\n+end Ada.Iterator_Interfaces;"}, {"sha": "c6e18efa5b7352a908e97d9225b4df3f4d4f1a6f", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2010, AdaCore                     --\n+--                     Copyright (C) 2000-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -926,7 +926,7 @@ package body GNAT.Expect is\n                   NOutput (Output'Range) := Output.all;\n                   Free (Output);\n \n-                  --  Here if current buffer size is OK\n+               --  Here if current buffer size is OK\n \n                else\n                   NOutput := Output;"}, {"sha": "e0b738b831fac5d1784873d0e1fe8ce2920cdaf8", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49208a9cb1d63270a57c501eb94cce668d2c750/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=e49208a9cb1d63270a57c501eb94cce668d2c750", "patch": "@@ -515,7 +515,10 @@ package body Impunit is\n      \"a-cbhase\",    -- Ada.Containers.Bounded_Hashed_Sets\n      \"a-cbhama\",    -- Ada.Containers.Bounded_Hashed_Maps\n      \"a-coinho\",    -- Ada.Containers.Indefinite_Holders\n+     \"a-comutr\",    -- Ada.Containers.Multiway_Trees\n+     \"a-cimutr\",    -- Ada.Containers.Indefinite_Multiway_Trees\n      \"a-extiin\",    -- Ada.Execution_Time.Interrupts\n+     \"a-iteint\",    -- Ada.Iterator_Interfaces\n \n    -----------------------------------------\n    -- GNAT Defined Additions to Ada 20012 --"}]}