{"sha": "b60cc080f355e078c923537a0d759467d21d39c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYwY2MwODBmMzU1ZTA3OGM5MjM1MzdhMGQ3NTk0NjdkMjFkMzljMA==", "commit": {"author": {"name": "Tobias Grosser", "email": "tobias@grosser.es", "date": "2012-07-04T09:15:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-07-04T09:15:09Z"}, "message": "Makefile.in (OBJS): Add graphite-optimize-isl.o.\n\n2012-07-04  Tobias Grosser <tobias@grosser.es>\n\tMichael Matz  <matz@suse.de>\n\n\t* Makefile.in (OBJS): Add graphite-optimize-isl.o.\n\t(graphite-optimize-isl.o): Add dependencies.\n\t* common.opt (floop-nest-optimize): New flag.\n\t* doc/invoke.texi (floop-nest-optimize): Document.\n\t* graphite-dependences.c (compute_deps): Export.\n\t* graphite-poly.h (compute_deps): Declare.\n\t* graphite-optimize-isl.c: New file.\n\t* graphite-poly.c (apply_poly_transforms): Run the loop\n\tnest optimizer.\n\t* tree-ssa-loop.c (gate_graphite_transforms): Enable graphite\n\tif -floop-nest-optimize is enabled.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\n\nFrom-SVN: r189249", "tree": {"sha": "a8b7e78be3d7f3b1da3b0902234480a072551a90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8b7e78be3d7f3b1da3b0902234480a072551a90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b60cc080f355e078c923537a0d759467d21d39c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60cc080f355e078c923537a0d759467d21d39c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b60cc080f355e078c923537a0d759467d21d39c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60cc080f355e078c923537a0d759467d21d39c0/comments", "author": {"login": "tobiasgrosser", "id": 521960, "node_id": "MDQ6VXNlcjUyMTk2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/521960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tobiasgrosser", "html_url": "https://github.com/tobiasgrosser", "followers_url": "https://api.github.com/users/tobiasgrosser/followers", "following_url": "https://api.github.com/users/tobiasgrosser/following{/other_user}", "gists_url": "https://api.github.com/users/tobiasgrosser/gists{/gist_id}", "starred_url": "https://api.github.com/users/tobiasgrosser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tobiasgrosser/subscriptions", "organizations_url": "https://api.github.com/users/tobiasgrosser/orgs", "repos_url": "https://api.github.com/users/tobiasgrosser/repos", "events_url": "https://api.github.com/users/tobiasgrosser/events{/privacy}", "received_events_url": "https://api.github.com/users/tobiasgrosser/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a9eca46a81b3f4139ad9b290a32f63a5ec6a13e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9eca46a81b3f4139ad9b290a32f63a5ec6a13e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9eca46a81b3f4139ad9b290a32f63a5ec6a13e"}], "stats": {"total": 530, "additions": 527, "deletions": 3}, "files": [{"sha": "bb615906ea527507f87bffe500f1b528f3aca9f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -1,3 +1,18 @@\n+2012-07-04  Tobias Grosser <tobias@grosser.es>\n+\tMichael Matz  <matz@suse.de>\n+\n+\t* Makefile.in (OBJS): Add graphite-optimize-isl.o.\n+\t(graphite-optimize-isl.o): Add dependencies.\n+\t* common.opt (floop-nest-optimize): New flag.\n+\t* doc/invoke.texi (floop-nest-optimize): Document.\n+\t* graphite-dependences.c (compute_deps): Export.\n+\t* graphite-poly.h (compute_deps): Declare.\n+\t* graphite-optimize-isl.c: New file.\n+\t* graphite-poly.c (apply_poly_transforms): Run the loop\n+\tnest optimizer.\n+\t* tree-ssa-loop.c (gate_graphite_transforms): Enable graphite\n+\tif -floop-nest-optimize is enabled.\n+\n 2012-07-03  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/predicates.md (logical_and_operand): New predicate."}, {"sha": "33775ac5a6d217aa2e15da35a5f42604a3ed516c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -1248,6 +1248,7 @@ OBJS = \\\n \tgraphite-clast-to-gimple.o \\\n \tgraphite-dependences.o \\\n \tgraphite-interchange.o \\\n+\tgraphite-optimize-isl.o \\\n \tgraphite-poly.o \\\n \tgraphite-scop-detection.o \\\n \tgraphite-sese-to-poly.o \\\n@@ -2560,6 +2561,9 @@ graphite-sese-to-poly.o : graphite-sese-to-poly.c $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) domwalk.h sese.h graphite-poly.h \\\n    graphite-sese-to-poly.h\n+graphite-optimize-isl.o : graphite-optimize-isl.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(SCEV_H) \\\n+    $(TREE_DUMP_H) sese.h graphite-poly.h\n tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n    $(TREE_DUMP_H) $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) $(OPTABS_H) \\"}, {"sha": "12f557acb4f7ff5e501c475697c647d758f6534f", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -1219,6 +1219,10 @@ floop-flatten\n Common Ignore\n Does nothing. Preserved for backward compatibility.\n \n+floop-nest-optimize\n+Common Report Var(flag_loop_optimize_isl) Optimization\n+Enable the ISL based loop nest optimizer\n+\n fstrict-volatile-bitfields\n Common Report Var(flag_strict_volatile_bitfields) Init(-1)\n Force bitfield accesses to match their type width"}, {"sha": "c8bfa3cb0bdb4c5b5b6e8f519a8e164f61a0f91a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -373,7 +373,7 @@ Objective-C and Objective-C++ Dialects}.\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n--floop-block -floop-interchange -floop-strip-mine @gol\n+-floop-block -floop-interchange -floop-strip-mine -floop-nest-optimize @gol\n -floop-parallelize-all -flto -flto-compression-level @gol\n -flto-partition=@var{alg} -flto-report -fmerge-all-constants @gol\n -fmerge-constants -fmodulo-sched -fmodulo-sched-allow-regmoves @gol\n@@ -7367,6 +7367,13 @@ GIMPLE -> GRAPHITE -> GIMPLE transformation.  Some minimal optimizations\n are also performed by the code generator CLooG, like index splitting and\n dead code elimination in loops.\n \n+@item -floop-nest-optimize\n+@opindex floop-nest-optimize\n+Enable the ISL based loop nest optimizer.  This is a generic loop nest\n+optimizer based on the Pluto optimization algorithms.  It calculates a loop\n+structure optimized for data-locality and parallelism.  This option\n+is experimental.\n+\n @item -floop-parallelize-all\n @opindex floop-parallelize-all\n Use the Graphite data dependence analysis to identify loops that can"}, {"sha": "1ef063d38898b4666b233a7a9c683b41e03931e0", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -443,7 +443,7 @@ subtract_commutative_associative_deps (scop_p scop,\n /* Compute the original data dependences in SCOP for all the reads and\n    writes in PBBS.  */\n \n-static void\n+void\n compute_deps (scop_p scop, VEC (poly_bb_p, heap) *pbbs,\n \t      isl_union_map **must_raw,\n \t      isl_union_map **may_raw,"}, {"sha": "45c33063f5766b095b94a9b93eaf3b0eada4c858", "filename": "gcc/graphite-optimize-isl.c", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -0,0 +1,471 @@\n+/* A scheduling optimizer for Graphite\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Tobias Grosser <tobias@grosser.es>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/schedule.h>\n+#include <isl/band.h>\n+#include <isl/aff.h>\n+#include <isl/options.h>\n+\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"sese.h\"\n+\n+#include \"graphite-poly.h\"\n+\n+static isl_union_set *\n+scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  isl_space *space = isl_set_get_space (scop->context);\n+  isl_union_set *res = isl_union_set_empty (space);\n+\n+  FOR_EACH_VEC_ELT (poly_bb_p, scop->bbs, i, pbb)\n+    res = isl_union_set_add_set (res, isl_set_copy (pbb->domain));\n+\n+  return res;\n+}\n+\n+static isl_union_map *\n+scop_get_dependences (scop_p scop)\n+{\n+  isl_union_map *dependences;\n+\n+  if (!scop->must_raw)\n+    compute_deps (scop, SCOP_BBS (scop),\n+\t\t  &scop->must_raw, &scop->may_raw,\n+\t\t  &scop->must_raw_no_source, &scop->may_raw_no_source,\n+\t\t  &scop->must_war, &scop->may_war,\n+\t\t  &scop->must_war_no_source, &scop->may_war_no_source,\n+\t\t  &scop->must_waw, &scop->may_waw,\n+\t\t  &scop->must_waw_no_source, &scop->may_waw_no_source);\n+\n+  dependences = isl_union_map_copy (scop->must_raw);\n+  dependences = isl_union_map_union (dependences,\n+\t\t\t\t     isl_union_map_copy (scop->must_war));\n+  dependences = isl_union_map_union (dependences,\n+\t\t\t\t     isl_union_map_copy (scop->must_waw));\n+  dependences = isl_union_map_union (dependences,\n+\t\t\t\t     isl_union_map_copy (scop->may_raw));\n+  dependences = isl_union_map_union (dependences,\n+\t\t\t\t     isl_union_map_copy (scop->may_war));\n+  dependences = isl_union_map_union (dependences,\n+\t\t\t\t     isl_union_map_copy (scop->may_waw));\n+\n+  return dependences;\n+}\n+\n+/* getTileMap - Create a map that describes a n-dimensonal tiling.\n+  \n+   getTileMap creates a map from a n-dimensional scattering space into an\n+   2*n-dimensional scattering space. The map describes a rectangular tiling.\n+  \n+   Example:\n+     scheduleDimensions = 2, parameterDimensions = 1, tileSize = 32\n+ \n+    tileMap := [p0] -> {[s0, s1] -> [t0, t1, s0, s1]:\n+                         t0 % 32 = 0 and t0 <= s0 < t0 + 32 and\n+                         t1 % 32 = 0 and t1 <= s1 < t1 + 32}\n+ \n+   Before tiling:\n+ \n+   for (i = 0; i < N; i++)\n+     for (j = 0; j < M; j++)\n+ \tS(i,j)\n+ \n+   After tiling:\n+ \n+   for (t_i = 0; t_i < N; i+=32)\n+     for (t_j = 0; t_j < M; j+=32)\n+ \tfor (i = t_i; i < min(t_i + 32, N); i++)  | Unknown that N % 32 = 0\n+ \t  for (j = t_j; j < t_j + 32; j++)        |   Known that M % 32 = 0\n+ \t    S(i,j)\n+   */\n+ \n+static isl_basic_map *\n+getTileMap(isl_ctx *ctx, int scheduleDimensions, int tileSize)\n+{\n+  int x;\n+  /* We construct\n+\n+     tileMap := [p0] -> {[s0, s1] -> [t0, t1, p0, p1, a0, a1]:\n+    \t                s0 = a0 * 32 and s0 = p0 and t0 <= p0 < t0 + 32 and\n+    \t                s1 = a1 * 32 and s1 = p1 and t1 <= p1 < t1 + 32}\n+\n+     and project out the auxilary dimensions a0 and a1.  */\n+  isl_space *Space = isl_space_alloc(ctx, 0, scheduleDimensions,\n+\t\t\t\t     scheduleDimensions * 3);\n+  isl_basic_map *tileMap = isl_basic_map_universe(isl_space_copy(Space));\n+\n+  isl_local_space *LocalSpace = isl_local_space_from_space(Space);\n+\n+  for (x = 0; x < scheduleDimensions; x++)\n+    {\n+      int sX = x;\n+      int tX = x;\n+      int pX = scheduleDimensions + x;\n+      int aX = 2 * scheduleDimensions + x;\n+\n+      isl_constraint *c;\n+\n+      /* sX = aX * tileSize; */\n+      c = isl_equality_alloc(isl_local_space_copy(LocalSpace));\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, sX, 1);\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, aX, -tileSize);\n+      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+\n+      /* pX = sX; */\n+      c = isl_equality_alloc(isl_local_space_copy(LocalSpace));\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, pX, 1);\n+      isl_constraint_set_coefficient_si(c, isl_dim_in, sX, -1);\n+      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+\n+      /* tX <= pX */\n+      c = isl_inequality_alloc(isl_local_space_copy(LocalSpace));\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, pX, 1);\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, tX, -1);\n+      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+\n+      /* pX <= tX + (tileSize - 1) */\n+      c = isl_inequality_alloc(isl_local_space_copy(LocalSpace));\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, tX, 1);\n+      isl_constraint_set_coefficient_si(c, isl_dim_out, pX, -1);\n+      isl_constraint_set_constant_si(c, tileSize - 1);\n+      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+    }\n+\n+  /* Project out auxilary dimensions.\n+\n+     The auxilary dimensions are transformed into existentially quantified ones.\n+     This reduces the number of visible scattering dimensions and allows Cloog\n+     to produces better code.  */\n+  tileMap = isl_basic_map_project_out(tileMap, isl_dim_out,\n+\t\t\t\t      2 * scheduleDimensions,\n+\t\t\t\t      scheduleDimensions);\n+  isl_local_space_free(LocalSpace);\n+  return tileMap;\n+}\n+\n+/* getScheduleForBand - Get the schedule for this band.\n+  \n+   Polly applies transformations like tiling on top of the isl calculated value.\n+   This can influence the number of scheduling dimension. The number of\n+   schedule dimensions is returned in the parameter 'Dimension'.  */\n+static bool DisableTiling = false;\n+\n+static isl_union_map *\n+getScheduleForBand(isl_band *Band, int *Dimensions)\n+{\n+  isl_union_map *PartialSchedule;\n+  isl_ctx *ctx;\n+  isl_space *Space;\n+  isl_basic_map *TileMap;\n+  isl_union_map *TileUMap;\n+\n+  PartialSchedule = isl_band_get_partial_schedule(Band);\n+  *Dimensions = isl_band_n_member(Band);\n+\n+  if (DisableTiling)\n+    return PartialSchedule;\n+\n+  /* It does not make any sense to tile a band with just one dimension.  */\n+  if (*Dimensions == 1)\n+    return PartialSchedule;\n+\n+  ctx = isl_union_map_get_ctx(PartialSchedule);\n+  Space = isl_union_map_get_space(PartialSchedule);\n+\n+  TileMap = getTileMap(ctx, *Dimensions, 32);\n+  TileUMap = isl_union_map_from_map(isl_map_from_basic_map(TileMap));\n+  TileUMap = isl_union_map_align_params(TileUMap, Space);\n+  *Dimensions = 2 * *Dimensions;\n+\n+  return isl_union_map_apply_range(PartialSchedule, TileUMap);\n+}\n+\n+/* Create a map that pre-vectorizes one scheduling dimension.\n+  \n+   getPrevectorMap creates a map that maps each input dimension to the same\n+   output dimension, except for the dimension DimToVectorize. DimToVectorize is\n+   strip mined by 'VectorWidth' and the newly created point loop of\n+   DimToVectorize is moved to the innermost level.\n+  \n+   Example (DimToVectorize=0, ScheduleDimensions=2, VectorWidth=4):\n+  \n+   | Before transformation\n+   |\n+   | A[i,j] -> [i,j]\n+   |\n+   | for (i = 0; i < 128; i++)\n+   |    for (j = 0; j < 128; j++)\n+   |      A(i,j);\n+  \n+     Prevector map:\n+     [i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and i = ip\n+  \n+   | After transformation:\n+   |\n+   | A[i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and i = ip\n+   |\n+   | for (it = 0; it < 128; it+=4)\n+   |    for (j = 0; j < 128; j++)\n+   |      for (ip = max(0,it); ip < min(128, it + 3); ip++)\n+   |        A(ip,j);\n+  \n+   The goal of this transformation is to create a trivially vectorizable loop.\n+   This means a parallel loop at the innermost level that has a constant number\n+   of iterations corresponding to the target vector width.\n+  \n+   This transformation creates a loop at the innermost level. The loop has a\n+   constant number of iterations, if the number of loop iterations at\n+   DimToVectorize can be devided by VectorWidth. The default VectorWidth is\n+   currently constant and not yet target specific. This function does not reason\n+   about parallelism.  */\n+static isl_map *\n+getPrevectorMap(isl_ctx *ctx, int DimToVectorize,\n+\t\tint ScheduleDimensions,\n+\t\tint VectorWidth)\n+{\n+  isl_space *Space;\n+  isl_local_space *LocalSpace, *LocalSpaceRange;\n+  isl_set *Modulo;\n+  isl_map *TilingMap;\n+  isl_constraint *c;\n+  isl_aff *Aff;\n+  int PointDimension; /* ip */\n+  int TileDimension;  /* it */\n+  isl_int VectorWidthMP;\n+  int i;\n+\n+  /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n+\n+  Space = isl_space_alloc(ctx, 0, ScheduleDimensions, ScheduleDimensions + 1);\n+  TilingMap = isl_map_universe(isl_space_copy(Space));\n+  LocalSpace = isl_local_space_from_space(Space);\n+  PointDimension = ScheduleDimensions;\n+  TileDimension = DimToVectorize;\n+\n+  /* Create an identity map for everything except DimToVectorize and map\n+     DimToVectorize to the point loop at the innermost dimension.  */\n+  for (i = 0; i < ScheduleDimensions; i++)\n+    {\n+      c = isl_equality_alloc(isl_local_space_copy(LocalSpace));\n+      isl_constraint_set_coefficient_si(c, isl_dim_in, i, -1);\n+\n+      if (i == DimToVectorize)\n+\tisl_constraint_set_coefficient_si(c, isl_dim_out, PointDimension, 1);\n+      else\n+\tisl_constraint_set_coefficient_si(c, isl_dim_out, i, 1);\n+\n+      TilingMap = isl_map_add_constraint(TilingMap, c);\n+    }\n+\n+  /* it % 'VectorWidth' = 0  */\n+  LocalSpaceRange = isl_local_space_range(isl_local_space_copy(LocalSpace));\n+  Aff = isl_aff_zero_on_domain(LocalSpaceRange);\n+  Aff = isl_aff_set_constant_si(Aff, VectorWidth);\n+  Aff = isl_aff_set_coefficient_si(Aff, isl_dim_in, TileDimension, 1);\n+  isl_int_init(VectorWidthMP);\n+  isl_int_set_si(VectorWidthMP, VectorWidth);\n+  Aff = isl_aff_mod(Aff, VectorWidthMP);\n+  isl_int_clear(VectorWidthMP);\n+  Modulo = isl_pw_aff_zero_set(isl_pw_aff_from_aff(Aff));\n+  TilingMap = isl_map_intersect_range(TilingMap, Modulo);\n+\n+  /* it <= ip */\n+  c = isl_inequality_alloc(isl_local_space_copy(LocalSpace));\n+  isl_constraint_set_coefficient_si(c, isl_dim_out, TileDimension, -1);\n+  isl_constraint_set_coefficient_si(c, isl_dim_out, PointDimension, 1);\n+  TilingMap = isl_map_add_constraint(TilingMap, c);\n+\n+  /* ip <= it + ('VectorWidth' - 1) */\n+  c = isl_inequality_alloc(LocalSpace);\n+  isl_constraint_set_coefficient_si(c, isl_dim_out, TileDimension, 1);\n+  isl_constraint_set_coefficient_si(c, isl_dim_out, PointDimension, -1);\n+  isl_constraint_set_constant_si(c, VectorWidth - 1);\n+  TilingMap = isl_map_add_constraint(TilingMap, c);\n+\n+  isl_map_dump(TilingMap);\n+\n+  return TilingMap;\n+}\n+\n+static bool EnablePollyVector = false;\n+\n+/* getScheduleForBandList - Get the scheduling map for a list of bands.\n+    \n+   We walk recursively the forest of bands to combine the schedules of the\n+   individual bands to the overall schedule. In case tiling is requested,\n+   the individual bands are tiled.  */\n+static isl_union_map *\n+getScheduleForBandList(isl_band_list *BandList)\n+{\n+  int NumBands, i;\n+  isl_union_map *Schedule;\n+  isl_ctx *ctx;\n+\n+  ctx = isl_band_list_get_ctx(BandList);\n+  NumBands = isl_band_list_n_band(BandList);\n+  Schedule = isl_union_map_empty(isl_space_params_alloc(ctx, 0));\n+\n+  for (i = 0; i < NumBands; i++)\n+    {\n+      isl_band *Band;\n+      isl_union_map *PartialSchedule;\n+      int ScheduleDimensions;\n+      isl_space *Space;\n+\n+      Band = isl_band_list_get_band(BandList, i);\n+      PartialSchedule = getScheduleForBand(Band, &ScheduleDimensions);\n+      Space = isl_union_map_get_space(PartialSchedule);\n+\n+      if (isl_band_has_children(Band))\n+\t{\n+\t  isl_band_list *Children;\n+\t  isl_union_map *SuffixSchedule;\n+\n+\t  Children = isl_band_get_children(Band);\n+\t  SuffixSchedule = getScheduleForBandList(Children);\n+\t  PartialSchedule = isl_union_map_flat_range_product(PartialSchedule,\n+\t\t\t\t\t\t\t     SuffixSchedule);\n+\t  isl_band_list_free(Children);\n+\t}\n+      else if (EnablePollyVector)\n+\t{\n+\t  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)\n+\t    {\n+\t      if (isl_band_member_is_zero_distance(Band, i))\n+\t\t{\n+\t\t  isl_map *TileMap;\n+\t\t  isl_union_map *TileUMap;\n+\n+\t\t  TileMap = getPrevectorMap(ctx, i, ScheduleDimensions, 4);\n+\t\t  TileUMap = isl_union_map_from_map(TileMap);\n+\t\t  TileUMap = isl_union_map_align_params(TileUMap,\n+\t\t\t\t\t\t\tisl_space_copy(Space));\n+\t\t  PartialSchedule = isl_union_map_apply_range(PartialSchedule,\n+\t\t\t\t\t\t\t      TileUMap);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      Schedule = isl_union_map_union(Schedule, PartialSchedule);\n+\n+      isl_band_free(Band);\n+      isl_space_free(Space);\n+    }\n+\n+  return Schedule;\n+}\n+\n+static isl_union_map *\n+getScheduleMap(isl_schedule *Schedule)\n+{\n+  isl_band_list *BandList = isl_schedule_get_band_forest(Schedule);\n+  isl_union_map *ScheduleMap = getScheduleForBandList(BandList);\n+  isl_band_list_free(BandList);\n+  return ScheduleMap;\n+}\n+\n+static int\n+getSingleMap(__isl_take isl_map *map, void *user)\n+{\n+  isl_map **singleMap = (isl_map **) user;\n+  *singleMap = map;\n+\n+  return 0;\n+}\n+\n+static void\n+apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  FOR_EACH_VEC_ELT (poly_bb_p, scop->bbs, i, pbb)\n+    {\n+      isl_set *domain = isl_set_copy (pbb->domain);\n+      isl_union_map *stmtBand;\n+      isl_map *stmtSchedule;\n+\n+      stmtBand = isl_union_map_intersect_domain(isl_union_map_copy(schedule_map),\n+\t\t\t\t\t\tisl_union_set_from_set(domain));\n+      isl_union_map_foreach_map(stmtBand, getSingleMap, &stmtSchedule);\n+      isl_map_free(pbb->transformed);\n+      pbb->transformed = stmtSchedule;\n+      isl_union_map_free(stmtBand);\n+    }\n+}\n+\n+static const int CONSTANT_BOUND = 20;\n+\n+bool\n+optimize_isl (scop_p scop)\n+{\n+\n+  isl_schedule *schedule;\n+  isl_union_set *domain;\n+  isl_union_map *validity, *proximity, *dependences;\n+  isl_union_map *schedule_map;\n+\n+  domain = scop_get_domains (scop);\n+  dependences = scop_get_dependences (scop);\n+  dependences = isl_union_map_gist_domain(dependences,\n+\t\t\t\t\t  isl_union_set_copy(domain));\n+  dependences = isl_union_map_gist_range(dependences,\n+\t\t\t\t\t isl_union_set_copy(domain));\n+  validity = dependences;\n+\n+  proximity = isl_union_map_copy (validity);\n+\n+  isl_options_set_schedule_max_constant_term(scop->ctx, CONSTANT_BOUND);\n+  isl_options_set_schedule_maximize_band_depth(scop->ctx, 1);\n+  isl_options_set_schedule_fuse(scop->ctx, ISL_SCHEDULE_FUSE_MIN);\n+  isl_options_set_on_error(scop->ctx, ISL_ON_ERROR_CONTINUE);\n+  schedule = isl_union_set_compute_schedule (domain, validity, proximity);\n+  isl_options_set_on_error(scop->ctx, ISL_ON_ERROR_ABORT);\n+\n+  if (!schedule)\n+    return false;\n+\n+  schedule_map = getScheduleMap (schedule);\n+\n+  apply_schedule_map_to_scop (scop, schedule_map);\n+\n+  isl_schedule_free (schedule);\n+  isl_union_map_free (schedule_map);\n+\n+  return true;\n+}\n+\n+#endif"}, {"sha": "e8e581ac5217745a7797b398d26d75c8142a6202", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -250,6 +250,11 @@ apply_poly_transforms (scop_p scop)\n \ttransform_done |= scop_do_interchange (scop);\n     }\n \n+  /* This pass needs to be run at the final stage, as it does not\n+     update the lst.  */\n+  if (flag_loop_optimize_isl)\n+    transform_done |= optimize_isl (scop);\n+\n   return transform_done;\n }\n "}, {"sha": "de1f06ff639e663cd2501c8983ff80f2cb8c3495", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -409,6 +409,7 @@ extern int scop_do_interchange (scop_p);\n extern int scop_do_strip_mine (scop_p, int);\n extern bool scop_do_block (scop_p);\n extern bool flatten_all_loops (scop_p);\n+extern bool optimize_isl(scop_p);\n extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n extern void debug_gmp_value (mpz_t);\n \n@@ -1549,4 +1550,20 @@ isl_map *reverse_loop_at_level (poly_bb_p, int);\n isl_union_map *reverse_loop_for_pbbs (scop_p, VEC (poly_bb_p, heap) *, int);\n __isl_give isl_union_map *extend_schedule (__isl_take isl_union_map *);\n \n+\n+void\n+compute_deps (scop_p scop, VEC (poly_bb_p, heap) *pbbs,\n+\t      isl_union_map **must_raw,\n+\t      isl_union_map **may_raw,\n+\t      isl_union_map **must_raw_no_source,\n+\t      isl_union_map **may_raw_no_source,\n+\t      isl_union_map **must_war,\n+\t      isl_union_map **may_war,\n+\t      isl_union_map **must_war_no_source,\n+\t      isl_union_map **may_war_no_source,\n+\t      isl_union_map **must_waw,\n+\t      isl_union_map **may_waw,\n+\t      isl_union_map **must_waw_no_source,\n+\t      isl_union_map **may_waw_no_source);\n+\n #endif"}, {"sha": "bef68e7341786e2a80f734ad55d1d05a47ffe153", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60cc080f355e078c923537a0d759467d21d39c0/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=b60cc080f355e078c923537a0d759467d21d39c0", "patch": "@@ -265,7 +265,8 @@ gate_graphite_transforms (void)\n       || flag_loop_interchange\n       || flag_loop_strip_mine\n       || flag_graphite_identity\n-      || flag_loop_parallelize_all)\n+      || flag_loop_parallelize_all\n+      || flag_loop_optimize_isl)\n     flag_graphite = 1;\n \n   return flag_graphite != 0;"}]}