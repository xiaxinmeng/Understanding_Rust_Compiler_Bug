{"sha": "8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJjNmNmOWI2M2E3MzhkODBlOGVkNTJjYjhmMWQ0OTRiZmYxYmVkMg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T23:52:08Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-06-10T23:52:08Z"}, "message": "Add MPW support.\n\nFrom-SVN: r12273", "tree": {"sha": "2a84c6a74511c973b5d90f25c3a68f183dcb3df9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a84c6a74511c973b5d90f25c3a68f183dcb3df9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2/comments", "author": null, "committer": null, "parents": [{"sha": "49ddab16992f33d251e22ec575b936a98e276a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ddab16992f33d251e22ec575b936a98e276a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ddab16992f33d251e22ec575b936a98e276a0e"}], "stats": {"total": 145, "additions": 143, "deletions": 2}, "files": [{"sha": "17bcbeaa1b2377041103768b5049ee0ad7202052", "filename": "gcc/pexecute.c", "status": "modified", "additions": 143, "deletions": 2, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2/gcc%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2/gcc%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpexecute.c?ref=8bc6cf9b63a738d80e8ed52cb8f1d494bff1bed2", "patch": "@@ -95,6 +95,11 @@ static char *install_error_msg = \"installation problem, cannot exec `%s'\";\n    On systems that don't support waiting for a particular child, PID is\n    ignored.  On systems like MSDOS that don't really multitask pwait\n    is just a mechanism to provide a consistent interface for the caller.\n+\n+   pfinish: finish generation of script\n+\n+   pfinish is necessary for systems like MPW where a script is generated that\n+   runs the requested programs.\n */\n \n #ifdef __MSDOS__\n@@ -299,7 +304,143 @@ pwait (pid, status, flags)\n \n #endif /* OS2 */\n \n-#if ! defined (__MSDOS__) && ! defined (_WIN32) && ! defined (OS2)\n+#ifdef MPW\n+\n+/* MPW pexecute doesn't actually run anything; instead, it writes out\n+   script commands that, when run, will do the actual executing.\n+\n+   For example, in GCC's case, GCC will write out several script commands:\n+\n+   cpp ...\n+   cc1 ...\n+   as ...\n+   ld ...\n+\n+   and then exit.  None of the above programs will have run yet.  The task\n+   that called GCC will then execute the script and cause cpp,etc. to run.\n+   The caller must invoke pfinish before calling exit.  This adds\n+   the finishing touches to the generated script.  */\n+\n+static int first_time = 1;\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  char tmpprogram[255];\n+  char *cp, *tmpname;\n+  int i;\n+\n+  mpwify_filename (program, tmpprogram);\n+  if (first_time)\n+    {\n+      printf (\"Set Failed 0\\n\");\n+      first_time = 0;\n+    }\n+\n+  fputs (\"If {Failed} == 0\\n\", stdout);\n+  /* If being verbose, output a copy of the command.  It should be\n+     accurate enough and escaped enough to be \"clickable\". */\n+  if (verbose_flag)\n+    {\n+      fputs (\"\\tEcho \", stdout);\n+      fputc ('\\'', stdout);\n+      fputs (tmpprogram, stdout);\n+      fputc ('\\'', stdout);\n+      fputc (' ', stdout);\n+      for (i=1; argv[i]; i++)\n+\t{\n+\t  fputc ('\\'', stdout);\n+\t  /* See if we have an argument that needs fixing. */\n+\t  if (strchr(argv[i], '/'))\n+\t    {\n+\t      tmpname = xmalloc (256);\n+\t      mpwify_filename (argv[i], tmpname);\n+\t      argv[i] = tmpname;\n+\t    }\n+\t  for (cp = argv[i]; *cp; cp++)\n+\t    {\n+\t      /* Write an Option-d escape char in front of special chars. */\n+\t      if (strchr(\"'+\", *cp))\n+\t\tfputc ('\\266', stdout);\n+\t      fputc (*cp, stdout);\n+\t    }\n+\t  fputc ('\\'', stdout);\n+\t  fputc (' ', stdout);\n+\t}\n+      fputs (\"\\n\", stdout);\n+    }\n+  fputs (\"\\t\", stdout);\n+  fputs (tmpprogram, stdout);\n+  fputc (' ', stdout);\n+\n+  for (i=1; argv[i]; i++)\n+    {\n+      /* See if we have an argument that needs fixing. */\n+      if (strchr(argv[i], '/'))\n+\t{\n+\t  tmpname = xmalloc (256);\n+\t  mpwify_filename (argv[i], tmpname);\n+\t  argv[i] = tmpname;\n+\t}\n+      if (strchr (argv[i], ' '))\n+\tfputc ('\\'', stdout);\n+      for (cp = argv[i]; *cp; cp++)\n+\t{\n+\t  /* Write an Option-d escape char in front of special chars. */\n+\t  if (strchr(\"'+\", *cp))\n+\t    fputc ('\\266', stdout);\n+\t  fputc (*cp, stdout);\n+\t}\n+      if (strchr (argv[i], ' '))\n+\tfputc ('\\'', stdout);\n+      fputc (' ', stdout);\n+    }\n+\n+  fputs (\"\\n\", stdout);\n+\n+  /* Output commands that arrange to clean up and exit if a failure occurs.\n+     We have to be careful to collect the status from the program that was\n+     run, rather than some other script command.  Also, we don't exit\n+     immediately, since necessary cleanups are at the end of the script. */\n+  fputs (\"\\tSet TmpStatus {Status}\\n\", stdout);\n+  fputs (\"\\tIf {TmpStatus} != 0\\n\", stdout);\n+  fputs (\"\\t\\tSet Failed {TmpStatus}\\n\", stdout);\n+  fputs (\"\\tEnd\\n\", stdout);\n+  fputs (\"End\\n\", stdout);\n+\n+  /* We're just composing a script, can't fail here. */\n+  return 0;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  *status = 0;\n+  return 0;\n+}\n+\n+/* Write out commands that will exit with the correct error code\n+   if something in the script failed. */\n+\n+void\n+pfinish ()\n+{\n+  printf (\"\\tExit \\\"{Failed}\\\"\\n\");\n+}\n+\n+#endif /* MPW */\n+\n+#if ! defined (__MSDOS__) && ! defined (_WIN32) && ! defined (OS2) \\\n+    && ! defined (MPW)\n \n #ifdef USG\n #define vfork fork\n@@ -436,4 +577,4 @@ pwait (pid, status, flags)\n   return pid;\n }\n \n-#endif /* !MSDOS && !WIN32 && !OS2 */\n+#endif /* !MSDOS && !WIN32 && !OS2 && !MPW */"}]}