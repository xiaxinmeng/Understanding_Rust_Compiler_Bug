{"sha": "1c6ab44ef793f6b243a344eba7f7883b727f734a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM2YWI0NGVmNzkzZjZiMjQzYTM0NGViYTdmNzg4M2I3MjdmNzM0YQ==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2007-04-27T16:20:12Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2007-04-27T16:20:12Z"}, "message": "intrinsic.texi (PRODUCT, [...]): New.\n\n2007-04-27  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* intrinsic.texi (PRODUCT, RESHAPE, SPACING, SPREAD, SUM, \n\tSYSTEM_CLOCK, TRANSFER, UNPACK): New.\n\t(DATE_AND_TIME, CPU_TIME, RRSPACING): Added cross references.\n\nFrom-SVN: r124222", "tree": {"sha": "85ee230eac6126d6110dd2b7221108177c93c472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85ee230eac6126d6110dd2b7221108177c93c472"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c6ab44ef793f6b243a344eba7f7883b727f734a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6ab44ef793f6b243a344eba7f7883b727f734a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c6ab44ef793f6b243a344eba7f7883b727f734a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6ab44ef793f6b243a344eba7f7883b727f734a/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4af96f9f619958bd62ae4280a01a9a51bd161063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af96f9f619958bd62ae4280a01a9a51bd161063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af96f9f619958bd62ae4280a01a9a51bd161063"}], "stats": {"total": 264, "additions": 238, "deletions": 26}, "files": [{"sha": "c57a8768b8a3d01633dfdb94f80528629101a47a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6ab44ef793f6b243a344eba7f7883b727f734a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6ab44ef793f6b243a344eba7f7883b727f734a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1c6ab44ef793f6b243a344eba7f7883b727f734a", "patch": "@@ -1,3 +1,9 @@\n+2007-04-27  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* intrinsic.texi (PRODUCT, RESHAPE, SPACING, SPREAD, SUM, \n+\tSYSTEM_CLOCK, TRANSFER, UNPACK): New.\n+\t(DATE_AND_TIME, CPU_TIME, RRSPACING): Added cross references.\n+\n 2007-04-26  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* intrinsic.texi (NULL, PACK, PRESENT, REPEAT, SCAN, SHAPE, "}, {"sha": "4f4ed67a492c5467531ab9e6db22a22e235526ec", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 232, "deletions": 26, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6ab44ef793f6b243a344eba7f7883b727f734a/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6ab44ef793f6b243a344eba7f7883b727f734a/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=1c6ab44ef793f6b243a344eba7f7883b727f734a", "patch": "@@ -2369,6 +2369,9 @@ program test_cpu_time\n     print '(\"Time = \",f6.3,\" seconds.\")',finish-start\n end program test_cpu_time\n @end smallexample\n+\n+@item @emph{See also}:\n+@ref{SYSTEM_CLOCK}, @ref{DATE_AND_TIME}\n @end table\n \n \n@@ -2548,6 +2551,9 @@ program test_time_and_date\n     print '(8i5))', values\n end program test_time_and_date\n @end smallexample\n+\n+@item @emph{See also}:\n+@ref{CPU_TIME}, @ref{SYSTEM_CLOCK}\n @end table\n \n \n@@ -7562,23 +7568,52 @@ END PROGRAM\n @node PRODUCT\n @section @code{PRODUCT} --- Product of array elements\n @cindex @code{PRODUCT} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@cindex array operation\n \n @table @asis\n @item @emph{Description}:\n+Multiplies the elements of @var{ARRAY} along dimension @var{DIM} if\n+the corresponding element in @var{MASK} is @code{TRUE}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = PRODUCT(ARRAY[, MASK])}\n+@code{RESULT = PRODUCT(ARRAY, DIM[, MASK])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)}, \n+@code{REAL(*)} or @code{COMPLEX(*)}.\n+@item @var{DIM}   @tab (Optional) shall be a scalar of type \n+@code{INTEGER} with a value in the range from 1 to n, where n \n+equals the rank of @var{ARRAY}.\n+@item @var{MASK}  @tab (Optional) shall be of type @code{LOGICAL} \n+and either be a scalar or an array of the same shape as @var{ARRAY}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result is of the same type as @var{ARRAY}.\n+\n+If @var{DIM} is absent, a scalar with the product of all elements in \n+@var{ARRAY} is returned. Otherwise, an array of rank n-1, where n equals \n+the rank of @var{ARRAY}, and a shape similar to that of @var{ARRAY} with \n+dimension @var{DIM} dropped is returned.\n+\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_product\n+  INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)\n+  print *, PRODUCT(x)                    ! all elements, product = 120\n+  print *, PRODUCT(x, MASK=MOD(x, 2)==1) ! odd elements, product = 15\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n @ref{SUM}\n @end table\n@@ -7990,22 +8025,50 @@ end program\n @cindex @code{RESHAPE} intrinsic\n @cindex array manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Reshapes @var{SOURCE} to correspond to @var{SHAPE}. If necessary,\n+the new array may be padded with elements from @var{PAD} or permuted\n+as defined by @var{ORDER}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = RESHAPE(SOURCE, SHAPE[, PAD, ORDER])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{SOURCE} @tab Shall be an array of any type.\n+@item @var{SHAPE}  @tab Shall be of type @code{INTEGER} and an \n+array of rank one. Its values must be positive or zero.\n+@item @var{PAD}    @tab (Optional) shall be an array of the same \n+type as @var{SOURCE}.\n+@item @var{ORDER}  @tab (Optional) shall be of type @code{INTEGER}\n+and an array of the same shape as @var{SHAPE}. Its values shall\n+be a permutation of the numbers from 1 to n, where n is the size of \n+@var{SHAPE}. If @var{ORDER} is absent, the natural ordering shall\n+be assumed.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result is an array of shape @var{SHAPE} with the same type as \n+@var{SOURCE}. \n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_reshape\n+  INTEGER, DIMENSION(4) :: x\n+  WRITE(*,*) SHAPE(x)                       ! prints \"4\"\n+  WRITE(*,*) SHAPE(RESHAPE(x, (/2, 2/)))    ! prints \"2 2\"\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n-@ref{SHAPE}, @ref{SIZE}\n+@ref{SHAPE}\n @end table\n \n \n@@ -8038,6 +8101,8 @@ The return value is of the same type and kind as @var{X}.\n The value returned is equal to\n @code{ABS(FRACTION(X)) * FLOAT(RADIX(X))**DIGITS(X)}.\n \n+@item @emph{See also}:\n+@ref{SPACING}\n @end table\n \n \n@@ -8444,7 +8509,7 @@ arrays must be allocated.\n \n @item @emph{Return value}:\n An @code{INTEGER} array of rank one with as many elements as @var{SOURCE} \n-has dimensions. The elements of the resulting array correspond to the extent\n+has dimensions. The elements of the resulting array correspond to the extend\n of @var{SOURCE} along the respective dimensions. If @var{SOURCE} is a scalar,\n the result is the rank one array of size zero.\n \n@@ -8789,23 +8854,42 @@ The return value is of type default @code{REAL}.\n @node SPACING\n @section @code{SPACING} --- Smallest distance between two numbers of a given type\n @cindex @code{SPACING} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n+Determines the distance between the argument @var{X} and the nearest \n+adjacent number of the same type.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = SPACING(X)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab Shall be of type @code{REAL(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result is of the same type as the input argument @var{X}.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_spacing\n+  INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37)\n+  INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200)\n+\n+  WRITE(*,*) spacing(1.0_SGL)      ! \"1.1920929E-07\"          on i686\n+  WRITE(*,*) spacing(1.0_DBL)      ! \"2.220446049250313E-016\" on i686\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{RRSPACING}\n @end table\n \n \n@@ -8815,21 +8899,44 @@ Elemental function\n @cindex @code{SPREAD} intrinsic\n @cindex array manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Replicates a @var{SOURCE} array @var{NCOPIES} times along a specified \n+dimension @var{DIM}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = SPREAD(SOURCE, DIM, NCOPIES)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{SOURCE}  @tab Shall be a scalar or an array of any type and \n+a rank less than seven.\n+@item @var{DIM}     @tab Shall be a scalar of type @code{INTEGER} with a \n+value in the range from 1 to n+1, where n equals the rank of @var{SOURCE}.\n+@item @var{NCOPIES} @tab Shall be a scalar of type @code{INTEGER}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result is an array of the same type as @var{SOURCE} and has rank n+1\n+where n equals the rank of @var{SOURCE}.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_spread\n+  INTEGER :: a = 1, b(2) = (/ 1, 2 /)\n+  WRITE(*,*) SPREAD(A, 1, 2)            ! \"1 1\"\n+  WRITE(*,*) SPREAD(B, 1, 2)            ! \"1 1 2 2\"\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{UNPACK}\n @end table\n \n \n@@ -9019,22 +9126,51 @@ To stat an open file: @ref{FSTAT}, to stat a link: @ref{LSTAT}\n @node SUM\n @section @code{SUM} --- Sum of array elements\n @cindex @code{SUM} intrinsic\n-@cindex array manipulation\n-\n-Intrinsic implemented, documentation pending.\n+@cindex array operation\n \n @table @asis\n @item @emph{Description}:\n+Adds the elements of @var{ARRAY} along dimension @var{DIM} if\n+the corresponding element in @var{MASK} is @code{TRUE}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = SUM(ARRAY[, MASK])}\n+@code{RESULT = SUM(ARRAY, DIM[, MASK])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)}, \n+@code{REAL(*)} or @code{COMPLEX(*)}.\n+@item @var{DIM}   @tab (Optional) shall be a scalar of type \n+@code{INTEGER} with a value in the range from 1 to n, where n \n+equals the rank of @var{ARRAY}.\n+@item @var{MASK}  @tab (Optional) shall be of type @code{LOGICAL} \n+and either be a scalar or an array of the same shape as @var{ARRAY}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result is of the same type as @var{ARRAY}.\n+\n+If @var{DIM} is absent, a scalar with the sum of all elements in @var{ARRAY}\n+is returned. Otherwise, an array of rank n-1, where n equals the rank of \n+@var{ARRAY},and a shape similar to that of @var{ARRAY} with dimension @var{DIM} \n+dropped is returned.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_sum\n+  INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)\n+  print *, SUM(x)                        ! all elements, sum = 15\n+  print *, SUM(x, MASK=MOD(x, 2)==1)     ! odd elements, sum = 9\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n @ref{PRODUCT}\n @end table\n@@ -9129,21 +9265,48 @@ Subroutine, non-elemental function\n @cindex time, current\n @cindex current time\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Determines the @var{COUNT} of milliseconds of wall clock time since \n+the Epoch (00:00:00 UTC, January 1, 1970) modulo @var{COUNT_MAX}, \n+@var{COUNT_RATE} determines the number of clock ticks per second.\n+@var{COUNT_RATE} and @var{COUNT_MAX} are constant and specific to \n+@command{gfortran}.\n+\n+If there is no clock, @var{COUNT} is set to @code{-HUGE(COUNT)}, and\n+@var{COUNT_RATE} and @var{COUNT_MAX} are set to zero \n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Subroutine\n \n @item @emph{Syntax}:\n+@code{CALL SYSTEM_CLOCK([COUNT, COUNT_RATE, COUNT_MAX])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{COUNT}      @tab (Optional) shall be a scalar of type default \n+@code{INTEGER} with @code{INTENT(OUT)}.\n+@item @var{COUNT_RATE} @tab (Optional) shall be a scalar of type default \n+@code{INTEGER} with @code{INTENT(OUT)}.\n+@item @var{COUNT_MAX}  @tab (Optional) shall be a scalar of type default \n+@code{INTEGER} with @code{INTENT(OUT)}.\n+@end multitable\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_system_clock\n+  INTEGER :: count, count_rate, count_max\n+  CALL SYSTEM_CLOCK(count, count_rate, count_max)\n+  WRITE(*,*) count, count_rate, count_max\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{DATE_AND_TIME}, @ref{CPU_TIME}\n @end table\n \n \n@@ -9360,23 +9523,43 @@ See @code{HUGE} for an example.\n @node TRANSFER\n @section @code{TRANSFER} --- Transfer bit patterns\n @cindex @code{TRANSFER} intrinsic\n-@cindex bit operations\n-\n-Intrinsic implemented, documentation pending.\n+@cindex type cast\n \n @table @asis\n @item @emph{Description}:\n+Interprets the bit pattern of @var{SOURCE} as a variable of the \n+same type and type parameters as @var{MOLD}.\n+\n+This is also known as @emph{casting} one type to another.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = TRANSFER(SOURCE, MOLD[, SIZE])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{SOURCE} @tab Shall be a scalar or an array of any type.\n+@item @var{MOLD}   @tab Shall be a scalar or an array of any type.\n+@item @var{SIZE}   @tab (Optional) shall be a scalar and of type \n+@code{INTEGER}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result has the same type as @var{MOLD} with the bit level \n+representation of @var{SOURCE}.\n+\n @item @emph{Example}:\n-@item @emph{See also}:\n+@smallexample\n+PROGRAM test_transfer\n+  integer :: x = 2143289344\n+  print *, transfer(x, 1.0)    ! prints \"NaN\" on i686\n+END PROGRAM\n+@end smallexample\n @end table\n \n \n@@ -9612,23 +9795,46 @@ Subroutine, non-elemental function\n @cindex @code{UNPACK} intrinsic\n @cindex array manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Store the elements of @var{VECTOR} in an array of higher rank.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = UNPACK(VECTOR, MASK, FIELD)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{VECTOR} @tab Shall be an array of any type and rank one. It \n+shall have at least as many elements as @var{MASK} has @code{TRUE} values.\n+@item @var{MASK}   @tab Shall be an array of type @code{LOGICAL}.\n+@item @var{FIELD}  @tab Shall be of the sam type as @var{VECTOR} and have\n+the same shape as @var{MASK}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The resulting array corresponds to @var{FIELD} with @code{TRUE} elements\n+of @var{MASK} replaced by values from @var{VECTOR} in array element order.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_unpack\n+  integer :: vector(2)  = (/1,1/)\n+  logical :: mask(2,2)  = (/ .TRUE., .FALSE., .FALSE., .TRUE. /)\n+  integer :: field(2,2) = 0, unity(2,2)\n+\n+  ! result: unity matrix\n+  unity = unpack(vector, reshape(mask, (/2,2/), field)\n+END PROGRAM\n+@end smallexample\n \n @item @emph{See also}:\n-@ref{PACK}\n+@ref{PACK}, @ref{SPREAD}\n @end table\n \n "}]}