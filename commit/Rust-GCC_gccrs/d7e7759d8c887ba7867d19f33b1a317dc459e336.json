{"sha": "d7e7759d8c887ba7867d19f33b1a317dc459e336", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlNzc1OWQ4Yzg4N2JhNzg2N2QxOWYzM2IxYTMxN2RjNDU5ZTMzNg==", "commit": {"author": {"name": "Benjamin Chelf", "email": "chelf@cabriolet.stanford.edu", "date": "2000-06-14T17:26:18Z"}, "committer": {"name": "Ben Chelf", "email": "chelf@gcc.gnu.org", "date": "2000-06-14T17:26:18Z"}, "message": "c-common.h (IF_COND): Moved here from cp/cp-tree.h.\n\n\t* c-common.h (IF_COND): Moved here from cp/cp-tree.h.\n\t(THEN_CLAUSE): Likewise.\n\t(ELSE_CLAUSE): Likewise.\n\t(WHILE_COND): Likewise.\n\t(WHILE_BODY): Likewise.\n\t(DO_COND): Likewise.\n\t(DO_BODY): Likewise.\n\t(RETURN_EXPR): Likewise.\n\t(EXPR_STMT_EXPR): Likewise.\n\t(FOR_INIT_STMT): Likewise.\n\t(FOR_COND): Likewise.\n\t(FOR_EXPR): Likewise.\n\t(FOR_BODY): Likewise.\n\t(SWITCH_COND): Likewise.\n\t(SWITCH_BODY): Likewise.\n\t(CASE_LOW): Likewise.\n\t(CASE_HIGH): Likewise.\n\t(GOTO_DESTINATION): Likewise.\n\t(COMPOUND_BODY): Likewise.\n\t(ASM_CV_QUAL): Likewise.\n\t(ASM_STRING): Likewise.\n\t(ASM_OUTPUTS): Likewise.\n\t(ASM_INPUTS): Likewise.\n\t(ASM_CLOBBERS): Likewise.\n\t(DECL_STMT_DECL): Likewise.\n\t(STMT_EXPR_STMT): Likewise.\n\t(LABEL_STMT_LABEL): Likewise.\n\t(SCOPE_BEGIN_P): Likewise.\n\t(SCOPE_END_P): Likewise.\n\t(SCOPE_STMT_BLOCK): Likewise.\n\t(SCOPE_NULLIFIED_P): Likewise.\n\t(SCOPE_NO_CLEANUPS_P): Likewise.\n\t(SCOPE_PARTIAL_P): Likewise.\n\t(ASM_VOLATILE_P): Likewise.\n\t(STMT_LINENO): Likewise.\n\t(STMT_LINENO_FOR_FN_P): Likewise.\n\n\t* c-common.def: Added SRCLOC, SIZEOF_EXPR, ARROW_EXPR,\n\tALIGNOF_EXPR, EXPR_STMT, COMPOUND_STMT, DECL_STMT, IF_STMT,\n\tFOR_STMT, WHILE_STMT, DO_STMT, RETURN_STMT, BREAK_STMT,\n\tCONTINUE_STMT, SWITCH_STMT, GOTO_STMT, LABEL_STMT, ASM_STMT,\n\tSCOPE_STMT, CASE_LABEL, STMT_EXPR.\n\n\t* gencheck.c (tree_codes[]): Added '#include \"c-common.def\"'.\n\n\t* cp/cp-tree.h (IF_COND): Move to c-common.h.\n\t(THEN_CLAUSE): Likewise.\n\t(ELSE_CLAUSE): Likewise.\n\t(WHILE_COND): Likewise.\n\t(WHILE_BODY): Likewise.\n\t(DO_COND): Likewise.\n\t(DO_BODY): Likewise.\n\t(RETURN_EXPR): Likewise.\n\t(EXPR_STMT_EXPR): Likewise.\n\t(FOR_INIT_STMT): Likewise.\n\t(FOR_COND): Likewise.\n\t(FOR_EXPR): Likewise.\n\t(FOR_BODY): Likewise.\n\t(SWITCH_COND): Likewise.\n\t(SWITCH_BODY): Likewise.\n\t(CASE_LOW): Likewise.\n\t(CASE_HIGH): Likewise.\n\t(GOTO_DESTINATION): Likewise.\n\t(COMPOUND_BODY): Likewise.\n\t(ASM_CV_QUAL): Likewise.\n\t(ASM_STRING): Likewise.\n\t(ASM_OUTPUTS): Likewise.\n\t(ASM_INPUTS): Likewise.\n\t(ASM_CLOBBERS): Likewise.\n\t(DECL_STMT_DECL): Likewise.\n\t(STMT_EXPR_STMT): Likewise.\n\t(LABEL_STMT_LABEL): Likewise.\n\t(SCOPE_BEGIN_P): Likewise.\n\t(SCOPE_END_P): Likewise.\n\t(SCOPE_STMT_BLOCK): Likewise.\n\t(SCOPE_NULLIFIED_P): Likewise.\n\t(SCOPE_NO_CLEANUPS_P): Likewise.\n\t(SCOPE_PARTIAL_P): Likewise.\n\t(ASM_VOLATILE_P): Likewise.\n\t(STMT_LINENO): Likewise.\n\t(STMT_LINENO_FOR_FN_P): Likewise.\n\n\t* cp/cp-tree.def: Removed SRCLOC, SIZEOF_EXPR, ARROW_EXPR,\n\tALIGNOF_EXPR, EXPR_STMT, COMPOUND_STMT, DECL_STMT, IF_STMT,\n\tFOR_STMT, WHILE_STMT, DO_STMT, RETURN_STMT, BREAK_STMT,\n\tCONTINUE_STMT, SWITCH_STMT, GOTO_STMT, LABEL_STMT, ASM_STMT,\n\tSCOPE_STMT, CASE_LABEL, STMT_EXPR.\n\n\t* cp/Makefile.in (CXX_TREE_H): Added $(srcdir)/../c-common.def.\n\n\t* cp/Make-lang.in (CXX_SRCS): Added $(srcdir)/c-common.def.\n\t(cc1plus$(exeext)): Added $(srcdir)/c-common.def.\n\n\t* cp/lex.c (cplus_tree_code_type[]): Added '#include \"c-common.def\"'.\n\t(cplus_tree_code_length[]): Added '#include \"c-common.def\"'.\n\t(cplus_tree_code_name[]): Added '#include \"c-common.def\"'.\n\nFrom-SVN: r34552", "tree": {"sha": "cc6aded9e99d8b7f38b907e70dbe50a75684a020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc6aded9e99d8b7f38b907e70dbe50a75684a020"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7e7759d8c887ba7867d19f33b1a317dc459e336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e7759d8c887ba7867d19f33b1a317dc459e336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e7759d8c887ba7867d19f33b1a317dc459e336", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e7759d8c887ba7867d19f33b1a317dc459e336/comments", "author": null, "committer": null, "parents": [{"sha": "c809addafec735a0301373bebe6e2be339edea6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c809addafec735a0301373bebe6e2be339edea6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c809addafec735a0301373bebe6e2be339edea6c"}], "stats": {"total": 454, "additions": 310, "deletions": 144}, "files": [{"sha": "57aac54ec4cd0836376101f60df731cb6742412b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -1,3 +1,50 @@\n+2000-06-14  Benjamin Chelf  <chelf@cabriolet.stanford.edu>\n+\n+\t* c-common.h (IF_COND): Moved here from cp/cp-tree.h.\n+\t(THEN_CLAUSE): Likewise.\n+\t(ELSE_CLAUSE): Likewise.\n+\t(WHILE_COND): Likewise.\n+\t(WHILE_BODY): Likewise.\n+\t(DO_COND): Likewise.\n+\t(DO_BODY): Likewise.\n+\t(RETURN_EXPR): Likewise.\n+\t(EXPR_STMT_EXPR): Likewise.\n+\t(FOR_INIT_STMT): Likewise.\n+\t(FOR_COND): Likewise.\n+\t(FOR_EXPR): Likewise.\n+\t(FOR_BODY): Likewise.\n+\t(SWITCH_COND): Likewise.\n+\t(SWITCH_BODY): Likewise.\n+\t(CASE_LOW): Likewise.\n+\t(CASE_HIGH): Likewise.\n+\t(GOTO_DESTINATION): Likewise.\n+\t(COMPOUND_BODY): Likewise.\n+\t(ASM_CV_QUAL): Likewise.\n+\t(ASM_STRING): Likewise.\n+\t(ASM_OUTPUTS): Likewise.\n+\t(ASM_INPUTS): Likewise.\n+\t(ASM_CLOBBERS): Likewise.\n+\t(DECL_STMT_DECL): Likewise.\n+\t(STMT_EXPR_STMT): Likewise.\n+\t(LABEL_STMT_LABEL): Likewise.\n+\t(SCOPE_BEGIN_P): Likewise.\n+\t(SCOPE_END_P): Likewise.\n+\t(SCOPE_STMT_BLOCK): Likewise.\n+\t(SCOPE_NULLIFIED_P): Likewise.\n+\t(SCOPE_NO_CLEANUPS_P): Likewise.\n+\t(SCOPE_PARTIAL_P): Likewise.\n+\t(ASM_VOLATILE_P): Likewise.\n+\t(STMT_LINENO): Likewise.\n+\t(STMT_LINENO_FOR_FN_P): Likewise.\n+\n+\t* c-common.def: Added SRCLOC, SIZEOF_EXPR, ARROW_EXPR,\n+\tALIGNOF_EXPR, EXPR_STMT, COMPOUND_STMT, DECL_STMT, IF_STMT,\n+\tFOR_STMT, WHILE_STMT, DO_STMT, RETURN_STMT, BREAK_STMT,\n+\tCONTINUE_STMT, SWITCH_STMT, GOTO_STMT, LABEL_STMT, ASM_STMT,\n+\tSCOPE_STMT, CASE_LABEL, STMT_EXPR.\n+\n+\t* gencheck.c (tree_codes[]): Added '#include \"c-common.def\"'.\n+\t\n 2000-06-14  David O'Brien  <obrien@FreeBSD.org>\n \n \t* gcc.c (main): Quiet compiler warnings.  argv is assumed to be"}, {"sha": "03ac0546d1a764ff335e0aaa785044cb03d2d9ef", "filename": "gcc/c-common.def", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -0,0 +1,63 @@\n+/* This file contains the definitions and documentation for the\n+   additional tree codes used in the GNU C++ compiler (see tree.def\n+   for the standard codes).\n+   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n+   Written by Benjamin Chelf <chelf@codesourcery.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Tree nodes relevent to both C and C++. These were originally in\n+cp-tree.def in the cp subdir. */\n+\n+/* A node to remember a source position.  */\n+DEFTREECODE (SRCLOC, \"srcloc\", 'x', 2)\n+\n+/* A whole bunch of tree codes for the initial, superficial parsing of\n+   templates.  */\n+DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\n+DEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\n+DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n+\n+DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n+DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n+DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n+DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n+DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n+DEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n+DEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n+DEFTREECODE (RETURN_STMT, \"return_stmt\", 'e', 1)\n+DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n+DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n+DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n+DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n+DEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n+DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n+\n+/* A SCOPE_STMT marks the beginning or end of a scope.  If\n+   SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n+   SCOPE_END_P holds, then this is the end of a scope.  If\n+   SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n+   this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n+   variables declared in this scope.  */\n+DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n+DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n+\n+/* A STMT_EXPR represents a statement-expression.  The\n+   STMT_EXPR_STMT is the statement given by the expression.  */\n+DEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)"}, {"sha": "4b5cb97760a60014a92efbb4877b7e0b15cf60c5", "filename": "gcc/c-common.h", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -163,3 +163,86 @@ extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n \n extern int self_promoting_args_p\t\tPARAMS ((tree));\n extern tree simple_type_promotes_to\t\tPARAMS ((tree));\n+\n+\n+/* These macros provide convenient access to the various _STMT nodes\n+   created when parsing template declarations.  */\n+#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n+#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n+#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n+#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n+#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n+#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n+#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n+#define RETURN_EXPR(NODE)       TREE_OPERAND (RETURN_STMT_CHECK (NODE), 0)\n+#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n+#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n+#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n+#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n+#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n+#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n+#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n+#define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n+#define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n+#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n+#define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n+#define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n+#define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n+#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n+#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n+#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n+#define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n+#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n+#define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n+\n+/* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n+#define SCOPE_BEGIN_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE))) \n+\n+/* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n+#define SCOPE_END_P(NODE) \\\n+  (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n+\n+/* The BLOCK containing the declarations contained in this scope.  */\n+#define SCOPE_STMT_BLOCK(NODE) \\\n+  (TREE_OPERAND (SCOPE_STMT_CHECK (NODE), 0))\n+\n+/* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n+#define SCOPE_NULLIFIED_P(NODE) \\\n+  (SCOPE_STMT_BLOCK ((NODE)) == NULL_TREE)\n+\n+/* Nonzero for a SCOPE_STMT which represents a lexical scope, but\n+   which should be treated as non-existant from the point of view of\n+   running cleanup actions.  */\n+#define SCOPE_NO_CLEANUPS_P(NODE) \\\n+  (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n+\n+/* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n+   For example, in:\n+  \n+     S s;\n+     l:\n+     S s2;\n+     goto l;\n+\n+   there is (implicitly) a new scope after `l', even though there are\n+   no curly braces.  In particular, when we hit the goto, we must\n+   destroy s2 and then re-construct it.  For the implicit scope,\n+   SCOPE_PARTIAL_P will be set.  */\n+#define SCOPE_PARTIAL_P(NODE) \\\n+  (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n+\n+/* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n+#define ASM_VOLATILE_P(NODE)\t\t\t\\\n+  (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n+\n+/* The line-number at which a statement began.  But if\n+   STMT_LINENO_FOR_FN_P does holds, then this macro gives the\n+   line number for the end of the current function instead.  */\n+#define STMT_LINENO(NODE)\t\t\t\\\n+  (TREE_COMPLEXITY ((NODE)))\n+\n+/* If non-zero, the STMT_LINENO for NODE is the line at which the\n+   function ended.  */\n+#define STMT_LINENO_FOR_FN_P(NODE) \t\t\\\n+  (TREE_LANG_FLAG_2 ((NODE)))"}, {"sha": "6ddb75803b120a40f0fe0977df432109b6a1924c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -1,3 +1,57 @@\n+2000-06-14  Benjamin Chelf  <chelf@cabriolet.stanford.edu>\n+\n+\t* cp-tree.h (IF_COND): Move to c-common.h.\n+\t(THEN_CLAUSE): Likewise.\n+\t(ELSE_CLAUSE): Likewise.\n+\t(WHILE_COND): Likewise.\n+\t(WHILE_BODY): Likewise.\n+\t(DO_COND): Likewise.\n+\t(DO_BODY): Likewise.\n+\t(RETURN_EXPR): Likewise.\n+\t(EXPR_STMT_EXPR): Likewise.\n+\t(FOR_INIT_STMT): Likewise.\n+\t(FOR_COND): Likewise.\n+\t(FOR_EXPR): Likewise.\n+\t(FOR_BODY): Likewise.\n+\t(SWITCH_COND): Likewise.\n+\t(SWITCH_BODY): Likewise.\n+\t(CASE_LOW): Likewise.\n+\t(CASE_HIGH): Likewise.\n+\t(GOTO_DESTINATION): Likewise.\n+\t(COMPOUND_BODY): Likewise.\n+\t(ASM_CV_QUAL): Likewise.\n+\t(ASM_STRING): Likewise.\n+\t(ASM_OUTPUTS): Likewise.\n+\t(ASM_INPUTS): Likewise.\n+\t(ASM_CLOBBERS): Likewise.\n+\t(DECL_STMT_DECL): Likewise.\n+\t(STMT_EXPR_STMT): Likewise.\n+\t(LABEL_STMT_LABEL): Likewise.\n+\t(SCOPE_BEGIN_P): Likewise.\n+\t(SCOPE_END_P): Likewise.\n+\t(SCOPE_STMT_BLOCK): Likewise.\n+\t(SCOPE_NULLIFIED_P): Likewise.\n+\t(SCOPE_NO_CLEANUPS_P): Likewise.\n+\t(SCOPE_PARTIAL_P): Likewise.\n+\t(ASM_VOLATILE_P): Likewise.\n+\t(STMT_LINENO): Likewise.\n+\t(STMT_LINENO_FOR_FN_P): Likewise.\n+\n+\t* cp-tree.def: Removed SRCLOC, SIZEOF_EXPR, ARROW_EXPR,\n+\tALIGNOF_EXPR, EXPR_STMT, COMPOUND_STMT, DECL_STMT, IF_STMT,\n+\tFOR_STMT, WHILE_STMT, DO_STMT, RETURN_STMT, BREAK_STMT,\n+\tCONTINUE_STMT, SWITCH_STMT, GOTO_STMT, LABEL_STMT, ASM_STMT,\n+\tSCOPE_STMT, CASE_LABEL, STMT_EXPR.\n+\n+\t* Makefile.in (CXX_TREE_H): Added $(srcdir)/../c-common.def.\n+\n+\t* Make-lang.in (CXX_SRCS): Added $(srcdir)/c-common.def.\n+\t(cc1plus$(exeext)): Added $(srcdir)/c-common.def.\n+\t\n+\t* lex.c (cplus_tree_code_type[]): Added '#include \"c-common.def\"'.\n+\t(cplus_tree_code_length[]): Added '#include \"c-common.def\"'.\n+\t(cplus_tree_code_name[]): Added '#include \"c-common.def\"'.\n+\t\n 2000-06-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (BINFO_OVERRIDE_ALONG_VIRTUAL_PATH): New macro."}, {"sha": "6763d624573c1420cb94379f8a0d4dd674213fd1", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -110,6 +110,7 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o $(LIBDEPS)\n \t  cxxmain.o underscore.o $(LIBS)\n \n CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/class.c $(srcdir)/cp/cp-tree.def \\\n+ $(srcdir)/c-common.def \\\n  $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cvt.c $(srcdir)/cp/decl.c \\\n  $(srcdir)/cp/decl.h $(srcdir)/cp/decl2.c $(srcdir)/cp/dump.c \\\n  $(srcdir)/cp/errfn.c $(srcdir)/cp/error.c $(srcdir)/cp/except.c \\\n@@ -123,7 +124,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/class.c $(srcdir)/cp/cp-tree.def \\\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o \\\n         c-pragma.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\\n-\t$(srcdir)/cp/gxx.gperf $(srcdir)/cp/cfns.gperf hash.o \\\n+\t$(srcdir)/c-common.def $(srcdir)/cp/gxx.gperf $(srcdir)/cp/cfns.gperf hash.o \\\n \t$(srcdir)/cp/operators.def\n \tcd cp; $(MAKE) $(LANG_FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus$(exeext)\n #\f"}, {"sha": "51708f84310f6fa6e75e9c8e5ff87a9109dbf2bd", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -203,7 +203,7 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n CXX_TREE_H = $(TREE_H) cp-tree.h $(srcdir)/../c-common.h cp-tree.def \\\n-\t$(srcdir)/../function.h $(srcdir)/../varray.h \\\n+\t$(srcdir)/../c-common.def $(srcdir)/../function.h $(srcdir)/../varray.h \\\n \t$(srcdir)/../../include/splay-tree.h \\\n \t$(srcdir)/../system.h $(CONFIG_H)\n PARSE_H = $(srcdir)/parse.h"}, {"sha": "6cc3af61123a10825387c9296c653f68505ef466", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -185,9 +185,6 @@ DEFTREECODE (OVERLOAD, \"overload\", 'x', 1)\n    tree structure.  */\n DEFTREECODE (WRAPPER, \"wrapper\", 'x', 1)\n \n-/* A node to remember a source position.  */\n-DEFTREECODE (SRCLOC, \"srcloc\", 'x', 2)\n-\n /* Used to represent deferred name lookup for dependent names while\n    parsing a template declaration.  The first argument is an\n    IDENTIFIER_NODE for the name in question.  The TREE_TYPE is\n@@ -205,27 +202,10 @@ DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", '1', 1)\n DEFTREECODE (CONST_CAST_EXPR, \"const_cast_expr\", '1', 1)\n DEFTREECODE (STATIC_CAST_EXPR, \"static_cast_expr\", '1', 1)\n DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", '1', 1)\n-DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\n-DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n-DEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\n DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", 'e', 2)\n DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", 'e', 1)\n DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", 'e', 3)\n \n-DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n-DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n-DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n-DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n-DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n-DEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n-DEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n-DEFTREECODE (RETURN_STMT, \"return_stmt\", 'e', 1)\n-DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n-DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n-DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n-DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n-DEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n-DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n /* A SUBOBJECT statement marks the point at which a sub-object is\n    fully constructed.  After this point, the SUBOBJECT_CLEANUP must be\n    run if an exception is thrown before the end of the enclosing\n@@ -244,23 +224,11 @@ DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 2)\n    the START_CATCH_TYPE.  If this is CATCH_ALL_TYPE, then the handler\n    catches all types.  */\n DEFTREECODE (START_CATCH_STMT, \"start_catch_stmt\", 'e', 0)\n-/* A SCOPE_STMT marks the beginning or end of a scope.  If\n-   SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n-   SCOPE_END_P holds, then this is the end of a scope.  If\n-   SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n-   this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n-   variables declared in this scope.  */\n-DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n-DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)\n DEFTREECODE (HANDLER, \"handler\", 'e', 2)\n \n-/* A STMT_EXPR represents a statement-expression.  The\n-   STMT_EXPR_STMT is the statement given by the expression.  */\n-DEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n-\n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n /* And some codes for expressing conversions for overload resolution.  */"}, {"sha": "9d5bb9273e0e16a161a9cd7f43288c3a03ff4bad", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 56, "deletions": 110, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -20,14 +20,15 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include \"c-common.h\"\n #include \"function.h\"\n #include \"splay-tree.h\"\n #include \"varray.h\"\n \n #ifndef _CP_TREE_H\n #define _CP_TREE_H\n \n+#include \"c-common.h\"\n+\n /* Usage of TREE_LANG_FLAG_?:\n    0: BINFO_MARKED (BINFO nodes).\n       COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n@@ -207,6 +208,7 @@ Boston, MA 02111-1307, USA.  */\n #define RECORD_OR_UNION_TYPE_CHECK(NODE)\tNODE\n \n #endif\n+\n \f\n /* ABI control.  */\n \n@@ -352,6 +354,37 @@ typedef struct ptrmem_cst\n #define SET_IDENTIFIER_NAMESPACE_VALUE(NODE, VAL) \\\n   set_namespace_binding (NODE, current_namespace, VAL)\n \n+#define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n+#define CLEANUP_DECL(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n+#define CLEANUP_EXPR(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n+   sense of `same'.  */\n+#define same_type_p(type1, type2) \\\n+  comptypes ((type1), (type2), COMPARE_STRICT)\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n+   top-level qualifiers.  */\n+#define same_type_ignoring_top_level_qualifiers_p(type1, type2) \\\n+  same_type_p (TYPE_MAIN_VARIANT (type1), TYPE_MAIN_VARIANT (type2))\n+\n+/* Non-zero if we are presently building a statement tree, rather\n+   than expanding each statement as we encounter it.  */\n+#define building_stmt_tree() (last_tree != NULL_TREE)\n+\n+/* Returns non-zero iff NODE is a declaration for the global function\n+   `main'.  */\n+#define DECL_MAIN_P(NODE)\t\t\t\t\\\n+   (DECL_EXTERN_C_FUNCTION_P (NODE)                     \\\n+    && DECL_NAME (NODE) != NULL_TREE\t\t\t\\\n+    && MAIN_NAME_P (DECL_NAME (NODE)))\n+\n+/* Returns non-zero iff ID_NODE is an IDENTIFIER_NODE whose name is\n+   `main'.  */\n+#define MAIN_NAME_P(ID_NODE) \\\n+   (strcmp (IDENTIFIER_POINTER (ID_NODE), \"main\") == 0)\n+\n+\n struct tree_binding\n {\n   struct tree_common common;\n@@ -1233,6 +1266,7 @@ extern void (*back_end_hook) PARAMS ((tree));\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n enum cplus_tree_code {\n   __DUMMY = LAST_AND_UNUSED_TREE_CODE,\n+#include \"c-common.def\"\n #include \"cp-tree.def\"\n   LAST_CPLUS_TREE_CODE\n };\n@@ -1939,10 +1973,26 @@ struct lang_decl\n   } u2;\n };\n \n+/* An un-parsed default argument looks like an identifier.  */\n+#define DEFARG_LENGTH(NODE)  (DEFAULT_ARG_CHECK(NODE)->identifier.length)\n+#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.pointer)\n+\n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n #define TREE_READONLY_DECL_P(NODE) \\\n   (TREE_READONLY (NODE) && DECL_P (NODE))\n \n+/* DECL_NEEDED_P holds of a declaration when we need to emit its\n+   definition.  This is true when the back-end tells us that\n+   the symbol has been referenced in the generated code.  If, however,\n+   we are not generating code, then it is also true when a symbol has\n+   just been used somewhere, even if it's not really needed.  We need\n+   anything that isn't comdat, but we don't know for sure whether or\n+   not something is comdat until end-of-file.  */\n+#define DECL_NEEDED_P(DECL)\t\t\t\t\t\\\n+  ((at_eof && !DECL_COMDAT (DECL))\t\t\t\t\\\n+   || (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME ((DECL))))\t\\\n+   || (flag_syntax_only && TREE_USED ((DECL))))\n+\n /* Non-zero iff DECL is memory-based.  The DECL_RTL of\n    certain const variables might be a CONST_INT, or a REG\n    in some cases.  We cannot use `memory_operand' as a test\n@@ -3107,74 +3157,19 @@ extern int flag_new_for_scope;\n #define THUNK_VCALL_OFFSET(DECL) \\\n   (DECL_LANG_SPECIFIC (DECL)->decl_flags.u2.vcall_offset)\n \n-/* DECL_NEEDED_P holds of a declaration when we need to emit its\n-   definition.  This is true when the back-end tells us that\n-   the symbol has been referenced in the generated code.  If, however,\n-   we are not generating code, then it is also true when a symbol has\n-   just been used somewhere, even if it's not really needed.  We need\n-   anything that isn't comdat, but we don't know for sure whether or\n-   not something is comdat until end-of-file.  */\n-#define DECL_NEEDED_P(DECL)\t\t\t\t\t\\\n-  ((at_eof && !DECL_COMDAT (DECL))\t\t\t\t\\\n-   || (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME ((DECL))))\t\\\n-   || (flag_syntax_only && TREE_USED ((DECL))))\n-\n-/* An un-parsed default argument looks like an identifier.  */\n-#define DEFARG_LENGTH(NODE)  (DEFAULT_ARG_CHECK(NODE)->identifier.length)\n-#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.pointer)\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n-#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n-#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n-#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n-#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n-#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n-#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n-#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n-#define RETURN_EXPR(NODE)       TREE_OPERAND (RETURN_STMT_CHECK (NODE), 0)\n-#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n-#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n-#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n-#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n-#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n-#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n-#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n-#define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n-#define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n-#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n #define TRY_STMTS(NODE)         TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n #define TRY_HANDLERS(NODE)      TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 1)\n-#define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n+\n /* Nonzero if this try block is a function try block.  */\n #define FN_TRY_BLOCK_P(NODE)    TREE_LANG_FLAG_3 (TRY_BLOCK_CHECK (NODE))\n #define HANDLER_PARMS(NODE)     TREE_OPERAND (HANDLER_CHECK (NODE), 0)\n #define HANDLER_BODY(NODE)      TREE_OPERAND (HANDLER_CHECK (NODE), 1)\n-#define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n-#define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n-#define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n-#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n-#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n-#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n-#define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n-#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n #define SUBOBJECT_CLEANUP(NODE) TREE_OPERAND (SUBOBJECT_CHECK (NODE), 0)\n-#define CLEANUP_DECL(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n-#define CLEANUP_EXPR(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n #define START_CATCH_TYPE(NODE)  TREE_TYPE (START_CATCH_STMT_CHECK (NODE))\n-#define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n-\n-/* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n-#define SCOPE_BEGIN_P(NODE) \\\n-  (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE))) \n \n-/* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n-#define SCOPE_END_P(NODE) \\\n-  (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n-\n-/* The BLOCK containing the declarations contained in this scope.  */\n-#define SCOPE_STMT_BLOCK(NODE) \\\n-  (TREE_OPERAND (SCOPE_STMT_CHECK (NODE), 0))\n \n /* Nonzero if this CTOR_STMT is for the beginning of a constructor.  */\n #define CTOR_BEGIN_P(NODE) \\\n@@ -3184,46 +3179,6 @@ extern int flag_new_for_scope;\n #define CTOR_END_P(NODE) \\\n   (!CTOR_BEGIN_P (NODE))\n \n-/* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n-#define SCOPE_NULLIFIED_P(NODE) \\\n-  (SCOPE_STMT_BLOCK ((NODE)) == NULL_TREE)\n-\n-/* Nonzero for a SCOPE_STMT which represents a lexical scope, but\n-   which should be treated as non-existant from the point of view of\n-   running cleanup actions.  */\n-#define SCOPE_NO_CLEANUPS_P(NODE) \\\n-  (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n-\n-/* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n-   For example, in:\n-  \n-     S s;\n-     l:\n-     S s2;\n-     goto l;\n-\n-   there is (implicitly) a new scope after `l', even though there are\n-   no curly braces.  In particular, when we hit the goto, we must\n-   destroy s2 and then re-construct it.  For the implicit scope,\n-   SCOPE_PARTIAL_P will be set.  */\n-#define SCOPE_PARTIAL_P(NODE) \\\n-  (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n-\n-/* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n-#define ASM_VOLATILE_P(NODE)\t\t\t\\\n-  (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n-\n-/* The line-number at which a statement began.  But if\n-   STMT_LINENO_FOR_FN_P does holds, then this macro gives the\n-   line number for the end of the current function instead.  */\n-#define STMT_LINENO(NODE)\t\t\t\\\n-  (TREE_COMPLEXITY ((NODE)))\n-\n-/* If non-zero, the STMT_LINENO for NODE is the line at which the\n-   function ended.  */\n-#define STMT_LINENO_FOR_FN_P(NODE) \t\t\\\n-  (TREE_LANG_FLAG_2 ((NODE)))\n-\n /* The parameters for a call-declarator.  */\n #define CALL_DECLARATOR_PARMS(NODE) \\\n   (TREE_PURPOSE (TREE_OPERAND ((NODE), 1)))\n@@ -3793,15 +3748,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \t\t\t\t   in the class body.  */\n #define SF_EXPAND            4  /* Generate RTL for this function.  */\n \n-/* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n-   sense of `same'.  */\n-#define same_type_p(type1, type2) \\\n-  comptypes ((type1), (type2), COMPARE_STRICT)\n-\n-/* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n-   top-level qualifiers.  */\n-#define same_type_ignoring_top_level_qualifiers_p(type1, type2) \\\n-  same_type_p (TYPE_MAIN_VARIANT (type1), TYPE_MAIN_VARIANT (type2))\n \n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, or if TYPE2\n    is derived from TYPE1, or if TYPE2 is a pointer (reference) to a\n@@ -3855,6 +3801,10 @@ enum tree_string_flags\n };\n \n /* in lex.c  */\n+/* Indexed by TREE_CODE, these tables give C-looking names to\n+   operators represented by TREE_CODES.  For example,\n+   opname_tab[(int) MINUS_EXPR] == \"-\".  */\n+extern const char **opname_tab, **assignop_tab;\n \n typedef struct operator_name_info_t\n {\n@@ -3871,7 +3821,6 @@ extern operator_name_info_t operator_name_info[];\n /* Similar, but for assignment operators.  */\n extern operator_name_info_t assignment_operator_name_info[];\n \n-\f\n /* in call.c */\n extern int check_dtor_name\t\t\tPARAMS ((tree, tree));\n extern int get_arglist_len_in_bytes\t\tPARAMS ((tree));\n@@ -4546,9 +4495,6 @@ extern void prep_stmt                           PARAMS ((tree));\n extern tree add_scope_stmt                      PARAMS ((int, int));\n extern void do_pushlevel                        PARAMS ((void));\n extern tree do_poplevel                         PARAMS ((void));\n-/* Non-zero if we are presently building a statement tree, rather\n-   than expanding each statement as we encounter it.  */\n-#define building_stmt_tree() (last_tree != NULL_TREE)\n \n /* in spew.c */\n extern void init_spew\t\t\t\tPARAMS ((void));"}, {"sha": "234207f2c18cc36a5a268b7ca39de123506e1a12", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -349,6 +349,7 @@ get_time_identifier (name)\n \n static char cplus_tree_code_type[] = {\n   'x',\n+#include \"c-common.def\"\n #include \"cp-tree.def\"\n };\n #undef DEFTREECODE\n@@ -361,6 +362,7 @@ static char cplus_tree_code_type[] = {\n \n static int cplus_tree_code_length[] = {\n   0,\n+#include \"c-common.def\"\n #include \"cp-tree.def\"\n };\n #undef DEFTREECODE\n@@ -371,6 +373,7 @@ static int cplus_tree_code_length[] = {\n \n static const char *cplus_tree_code_name[] = {\n   \"@@dummy\",\n+#include \"c-common.def\"\n #include \"cp-tree.def\"\n };\n #undef DEFTREECODE"}, {"sha": "12cc03823a0792b1c2da86f94cbeecec6093b6c9", "filename": "gcc/gencheck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fgencheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e7759d8c887ba7867d19f33b1a317dc459e336/gcc%2Fgencheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencheck.c?ref=d7e7759d8c887ba7867d19f33b1a317dc459e336", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n \n const char *tree_codes[] = {\n #include \"tree.def\"\n+#include \"c-common.def\"\n #include \"gencheck.h\"\n (char*)0\n };"}]}