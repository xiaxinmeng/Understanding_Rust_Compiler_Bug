{"sha": "4f469be30bf03ea36b23f390b7446f499cb5be5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0NjliZTMwYmYwM2VhMzZiMjNmMzkwYjc0NDZmNDk5Y2I1YmU1ZQ==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2008-05-20T12:45:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:45:54Z"}, "message": "prj.adb (Hash (Project_Id)): New function\n\n2008-05-20  Vincent Celier  <celier@adacore.com>\n\n\t* prj.adb (Hash (Project_Id)): New function\n\t(Project_Empty): Add new component Interfaces_Defined\n\n\t* prj.ads (Source_Data): New component Object_Linked\n\t(Language_Config): New components Object_Generated and Objects_Linked\n\t(Hash (Project_Id)): New function\n\t(Source_Data): New Boolean components In_Interfaces and\n\tDeclared_In_Interfaces.\n\t(Project_Data): New Boolean component Interfaces_Defined\n\n\t* prj-attr.adb: \n\tNew project level attribute Object_Generated and Objects_Linked\n\tAdd new project level attribute Interfaces\n\n\t* prj-dect.adb: Use functions Present and No throughout\n\t(Parse_Variable_Declaration): If a string type is specified as a simple\n\tname and is not found in the current project, look for it also in the\n\tancestors of the project.\n\n\t* prj-makr.adb: \n\tReplace procedure Make with procedures Initialize, Process and Finalize\n\tto implement H414-023: process different directories with different\n\tpatterns.\n\tUse functions Present and No throughout\n\n\t* prj-makr.ads: \n\tReplace procedure Make with procedures Initialize, Process and Finalize\n\n\t* prj-nmsc.adb\n\t(Add_Source): Set component Object_Exists and Object_Linked accordnig to\n\tthe language configuration.\n\t(Process_Project_Level_Array_Attributes): Process new attributes\n\tObject_Generated and Object_Linked.\n\t(Report_No_Sources): New Boolean parameter Continuation, defaulted to\n\tFalse, to indicate that the erreor/warning is a continuation.\n\t(Check): Call Report_No_Sources with Contnuation = True after the first\n\tcall.\n\t(Error_Msg): Process successively contnuation character and warning\n\tcharacter.\n\t(Find_Explicit_Sources): Check that all declared sources have been found\n\t(Check_File): Indicate in hash table Source_Names when a declared source\n\tis found.\n\t(Check_File): Set Other_Part when found\n\t(Find_Explicit_Sources): In multi language mode, check if all exceptions\n\tto the naming scheme have been found. For Ada, report an error if an\n\texception has not been found. Otherwise, disregard the exception.\n\t(Check_Interfaces): New procedure\n\t(Add_Source): When Other_Part is defined, set mutual pointers in spec\n\tand body.\n\t(Check): In multi-language mode, call Check_Interfaces\n\t(Process_Sources_In_Multi_Language_Mode): Set In_Interfaces to False\n\tfor an excluded source.\n\t(Remove_Source): A source replacing a source in the interfaces is also\n\tin the interfaces.\n\n\t* prj-pars.adb: Use function Present\n\n\t* prj-part.adb: Use functions Present and No throughout\n\t(Parse_Single_Project): Set the parent project for child projects\n\t(Create_Virtual_Extending_Project): Register project with no qualifier\n\t(Parse_Single_Project): Allow an abstract project to be extend several\n\ttimes. Do not allow an abstract project to extend a non abstract\n\tproject.\n\n\t* prj-pp.adb: Use functions Present and No throughout\n\t(Print): Take into account the full associative array attribute\n\tdeclarations.\n\n\t* prj-proc.adb: Use functions Present and No throughout\n\t(Expression): Call itself with the same From_Project_Node for the\n\tdefault value of an external reference.\n\n\t* prj-strt.adb: Use functions Present and No throughout\n\t(Parse_Variable_Reference): If a variable is specified as a simple name\n\tand is not found in the current project, look for it also in the\n\tancestors of the project.\n\n\t* prj-tree.ads, prj-tree.adb (Present): New function\n\t(No): New function\n\tUse functions Present and No throughout\n\t(Parent_Project_Of): New function\n\t(Set_Parent_Project_Of): New procedure\n\n\t* snames.ads, snames.adb: \n\tAdd new standard names Object_Generated and Objects_Linked\n\nFrom-SVN: r135623", "tree": {"sha": "4f65013f967ac2ea1c063adc21103b17e57712c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f65013f967ac2ea1c063adc21103b17e57712c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f469be30bf03ea36b23f390b7446f499cb5be5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f469be30bf03ea36b23f390b7446f499cb5be5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f469be30bf03ea36b23f390b7446f499cb5be5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f469be30bf03ea36b23f390b7446f499cb5be5e/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ddca462736ddb7385b51f03631fd77501a3d852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddca462736ddb7385b51f03631fd77501a3d852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ddca462736ddb7385b51f03631fd77501a3d852"}], "stats": {"total": 3683, "additions": 2125, "deletions": 1558}, "files": [{"sha": "1b56e84a07750a0f91e33e5183b264b727e12077", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -86,6 +86,7 @@ package body Prj.Attr is\n    \"LVlocally_removed_files#\" &\n    \"LVexcluded_source_files#\" &\n    \"SVsource_list_file#\" &\n+   \"LVinterfaces#\" &\n \n    --  Libraries\n \n@@ -109,6 +110,8 @@ package body Prj.Attr is\n    \"LVrun_path_option#\" &\n    \"Satoolchain_version#\" &\n    \"Satoolchain_description#\" &\n+   \"Saobject_generated#\" &\n+   \"Saobjects_linked#\" &\n \n    --  Configuration - Libraries\n "}, {"sha": "1e15fb207dae330a5f99f5e69d9e61f44103a79a", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -184,7 +184,7 @@ package body Prj.Dect is\n          --  an unknown package.\n \n          if Current_Attribute = Empty_Attribute then\n-            if Current_Package /= Empty_Node\n+            if Present (Current_Package)\n               and then Expression_Kind_Of (Current_Package, In_Tree) = Ignored\n             then\n                Pkg_Id := Package_Id_Of (Current_Package, In_Tree);\n@@ -194,7 +194,7 @@ package body Prj.Dect is\n                --  If not a valid attribute name, issue an error if inside\n                --  a package that need to be checked.\n \n-               Ignore := Current_Package /= Empty_Node and then\n+               Ignore := Present (Current_Package) and then\n                           Packages_To_Check /= All_Packages;\n \n                if Ignore then\n@@ -241,7 +241,7 @@ package body Prj.Dect is\n \n       --  Change obsolete names of attributes to the new names\n \n-      if Current_Package /= Empty_Node\n+      if Present (Current_Package)\n         and then Expression_Kind_Of (Current_Package, In_Tree) /= Ignored\n       then\n          case Name_Of (Attribute, In_Tree) is\n@@ -403,7 +403,7 @@ package body Prj.Dect is\n                   The_Project := Imported_Or_Extended_Project_Of\n                                    (Current_Project, In_Tree, Token_Name);\n \n-                  if The_Project = Empty_Node then\n+                  if No (The_Project) then\n                      Error_Msg (\"unknown project\", Location);\n                      Scan (In_Tree); --  past the project name\n \n@@ -414,7 +414,7 @@ package body Prj.Dect is\n                      --  If this is inside a package, a dot followed by the\n                      --  name of the package must followed the project name.\n \n-                     if Current_Package /= Empty_Node then\n+                     if Present (Current_Package) then\n                         Expect (Tok_Dot, \"`.`\");\n \n                         if Token /= Tok_Dot then\n@@ -445,7 +445,7 @@ package body Prj.Dect is\n \n                               --  Look for the package node\n \n-                              while The_Package /= Empty_Node\n+                              while Present (The_Package)\n                                 and then\n                                 Name_Of (The_Package, In_Tree) /= Token_Name\n                               loop\n@@ -457,7 +457,7 @@ package body Prj.Dect is\n                               --  If the package cannot be found in the\n                               --  project, issue an error.\n \n-                              if The_Package = Empty_Node then\n+                              if No (The_Package) then\n                                  The_Project := Empty_Node;\n                                  Error_Msg_Name_2 := Project_Name;\n                                  Error_Msg_Name_1 := Token_Name;\n@@ -473,7 +473,7 @@ package body Prj.Dect is\n                   end if;\n                end if;\n \n-               if The_Project /= Empty_Node then\n+               if Present (The_Project) then\n \n                   --  Looking for '<same attribute name>\n \n@@ -503,7 +503,7 @@ package body Prj.Dect is\n                   end if;\n                end if;\n \n-               if The_Project = Empty_Node then\n+               if No (The_Project) then\n \n                   --  If there were any problem, set the attribute id to null,\n                   --  so that the node will not be recorded.\n@@ -546,7 +546,7 @@ package body Prj.Dect is\n                --  for the attribute, issue an error.\n \n                if Current_Attribute /= Empty_Attribute\n-                 and then Expression /= Empty_Node\n+                 and then Present (Expression)\n                  and then Variable_Kind_Of (Current_Attribute) /=\n                  Expression_Kind_Of (Expression, In_Tree)\n                then\n@@ -639,10 +639,10 @@ package body Prj.Dect is\n          end if;\n       end if;\n \n-      if Case_Variable /= Empty_Node then\n+      if Present (Case_Variable) then\n          String_Type := String_Type_Of (Case_Variable, In_Tree);\n \n-         if String_Type = Empty_Node then\n+         if No (String_Type) then\n             Error_Msg (\"variable \"\"\" &\n                        Get_Name_String (Name_Of (Case_Variable, In_Tree)) &\n                        \"\"\" is not typed\",\n@@ -813,15 +813,15 @@ package body Prj.Dect is\n                      The_Variable : Project_Node_Id := Empty_Node;\n \n                   begin\n-                     if Current_Package /= Empty_Node then\n+                     if Present (Current_Package) then\n                         The_Variable :=\n                           First_Variable_Of (Current_Package, In_Tree);\n-                     elsif Current_Project /= Empty_Node then\n+                     elsif Present (Current_Project) then\n                         The_Variable :=\n                           First_Variable_Of (Current_Project, In_Tree);\n                      end if;\n \n-                     while The_Variable /= Empty_Node\n+                     while Present (The_Variable)\n                        and then Name_Of (The_Variable, In_Tree) /=\n                                 Token_Name\n                      loop\n@@ -831,7 +831,7 @@ package body Prj.Dect is\n                      --  It is an error to declare a variable in a case\n                      --  construction for the first time.\n \n-                     if The_Variable = Empty_Node then\n+                     if No (The_Variable) then\n                         Error_Msg\n                           (\"a variable cannot be declared \" &\n                            \"for the first time here\",\n@@ -928,8 +928,8 @@ package body Prj.Dect is\n          --  Insert an N_Declarative_Item in the tree, but only if\n          --  Current_Declaration is not an empty node.\n \n-         if Current_Declaration /= Empty_Node then\n-            if Current_Declarative_Item = Empty_Node then\n+         if Present (Current_Declaration) then\n+            if No (Current_Declarative_Item) then\n                Current_Declarative_Item :=\n                  Default_Project_Node\n                    (Of_Kind => N_Declarative_Item, In_Tree => In_Tree);\n@@ -1056,13 +1056,13 @@ package body Prj.Dect is\n                         First_Package_Of (Current_Project, In_Tree);\n \n          begin\n-            while Current /= Empty_Node\n+            while Present (Current)\n               and then Name_Of (Current, In_Tree) /= Token_Name\n             loop\n                Current := Next_Package_In_Project (Current, In_Tree);\n             end loop;\n \n-            if Current /= Empty_Node then\n+            if Present (Current) then\n                Error_Msg\n                  (\"package \"\"\" &\n                   Get_Name_String (Name_Of (Package_Declaration, In_Tree)) &\n@@ -1110,22 +1110,22 @@ package body Prj.Dect is\n                                     (Current_Project, In_Tree),\n                                    In_Tree);\n             begin\n-               while Clause /= Empty_Node loop\n+               while Present (Clause) loop\n                   --  Only non limited imported projects may be used in a\n                   --  renames declaration.\n \n                   The_Project :=\n                     Non_Limited_Project_Node_Of (Clause, In_Tree);\n-                  exit when The_Project /= Empty_Node\n+                  exit when Present (The_Project)\n                     and then Name_Of (The_Project, In_Tree) = Project_Name;\n                   Clause := Next_With_Clause_Of (Clause, In_Tree);\n                end loop;\n \n-               if Clause = Empty_Node then\n+               if No (Clause) then\n                   --  As we have not found the project in the imports, we check\n                   --  if it's the name of an eventual extended project.\n \n-                  if Extended /= Empty_Node\n+                  if Present (Extended)\n                     and then Name_Of (Extended, In_Tree) = Project_Name\n                   then\n                      Set_Project_Of_Renamed_Package_Of\n@@ -1152,8 +1152,8 @@ package body Prj.Dect is\n                   if Name_Of (Package_Declaration, In_Tree) /= Token_Name then\n                      Error_Msg (\"not the same package name\", Token_Ptr);\n                   elsif\n-                    Project_Of_Renamed_Package_Of\n-                      (Package_Declaration, In_Tree) /= Empty_Node\n+                    Present (Project_Of_Renamed_Package_Of\n+                               (Package_Declaration, In_Tree))\n                   then\n                      declare\n                         Current : Project_Node_Id :=\n@@ -1163,14 +1163,14 @@ package body Prj.Dect is\n                                        In_Tree);\n \n                      begin\n-                        while Current /= Empty_Node\n+                        while Present (Current)\n                           and then Name_Of (Current, In_Tree) /= Token_Name\n                         loop\n                            Current :=\n                              Next_Package_In_Project (Current, In_Tree);\n                         end loop;\n \n-                        if Current = Empty_Node then\n+                        if No (Current) then\n                            Error_Msg\n                              (\"\"\"\" &\n                               Get_Name_String (Token_Name) &\n@@ -1272,27 +1272,27 @@ package body Prj.Dect is\n          Set_Name_Of (String_Type, In_Tree, To => Token_Name);\n \n          Current := First_String_Type_Of (Current_Project, In_Tree);\n-         while Current /= Empty_Node\n+         while Present (Current)\n            and then\n            Name_Of (Current, In_Tree) /= Token_Name\n          loop\n             Current := Next_String_Type (Current, In_Tree);\n          end loop;\n \n-         if Current /= Empty_Node then\n+         if Present (Current) then\n             Error_Msg (\"duplicate string type name \"\"\" &\n                        Get_Name_String (Token_Name) &\n                        \"\"\"\",\n                        Token_Ptr);\n          else\n             Current := First_Variable_Of (Current_Project, In_Tree);\n-            while Current /= Empty_Node\n+            while Present (Current)\n               and then Name_Of (Current, In_Tree) /= Token_Name\n             loop\n                Current := Next_Variable (Current, In_Tree);\n             end loop;\n \n-            if Current /= Empty_Node then\n+            if Present (Current) then\n                Error_Msg (\"\"\"\" &\n                           Get_Name_String (Token_Name) &\n                           \"\"\" is already a variable name\", Token_Ptr);\n@@ -1399,8 +1399,8 @@ package body Prj.Dect is\n \n             if OK then\n                declare\n-                  Current : Project_Node_Id :=\n-                              First_String_Type_Of (Current_Project, In_Tree);\n+                  Proj    : Project_Node_Id := Current_Project;\n+                  Current : Project_Node_Id := Empty_Node;\n \n                begin\n                   if Project_String_Type_Name /= No_Name then\n@@ -1414,7 +1414,7 @@ package body Prj.Dect is\n \n                      begin\n                         if The_Project_Name_And_Node =\n-                          Tree_Private_Part.No_Project_Name_And_Node\n+                             Tree_Private_Part.No_Project_Name_And_Node\n                         then\n                            Error_Msg (\"unknown project \"\"\" &\n                                       Get_Name_String\n@@ -1426,22 +1426,45 @@ package body Prj.Dect is\n                            Current :=\n                              First_String_Type_Of\n                                (The_Project_Name_And_Node.Node, In_Tree);\n+                           while\n+                             Present (Current)\n+                             and then\n+                               Name_Of (Current, In_Tree) /= String_Type_Name\n+                           loop\n+                              Current := Next_String_Type (Current, In_Tree);\n+                           end loop;\n                         end if;\n                      end;\n-                  end if;\n \n-                  while Current /= Empty_Node\n-                    and then Name_Of (Current, In_Tree) /= String_Type_Name\n-                  loop\n-                     Current := Next_String_Type (Current, In_Tree);\n-                  end loop;\n+                  else\n+                     --  Look for a string type with the correct name in this\n+                     --  project or in any of its ancestors.\n+\n+                     loop\n+                        Current :=\n+                          First_String_Type_Of (Proj, In_Tree);\n+                        while\n+                          Present (Current)\n+                          and then\n+                            Name_Of (Current, In_Tree) /= String_Type_Name\n+                        loop\n+                           Current := Next_String_Type (Current, In_Tree);\n+                        end loop;\n+\n+                        exit when Present (Current);\n \n-                  if Current = Empty_Node then\n+                        Proj := Parent_Project_Of (Proj, In_Tree);\n+                        exit when No (Proj);\n+                     end loop;\n+                  end if;\n+\n+                  if No (Current) then\n                      Error_Msg (\"unknown string type \"\"\" &\n                                 Get_Name_String (String_Type_Name) &\n                                 \"\"\"\",\n                                 Type_Location);\n                      OK := False;\n+\n                   else\n                      Set_String_Type_Of\n                        (Variable, In_Tree, To => Current);\n@@ -1471,7 +1494,7 @@ package body Prj.Dect is\n          Optional_Index  => False);\n       Set_Expression_Of (Variable, In_Tree, To => Expression);\n \n-      if Expression /= Empty_Node then\n+      if Present (Expression) then\n          --  A typed string must have a single string value, not a list\n \n          if Kind_Of (Variable, In_Tree) = N_Typed_Variable_Declaration\n@@ -1491,27 +1514,27 @@ package body Prj.Dect is\n             The_Variable : Project_Node_Id := Empty_Node;\n \n          begin\n-            if Current_Package /= Empty_Node then\n+            if Present (Current_Package) then\n                The_Variable := First_Variable_Of (Current_Package, In_Tree);\n-            elsif Current_Project /= Empty_Node then\n-               The_Variable :=  First_Variable_Of (Current_Project, In_Tree);\n+            elsif Present (Current_Project) then\n+               The_Variable := First_Variable_Of (Current_Project, In_Tree);\n             end if;\n \n-            while The_Variable /= Empty_Node\n+            while Present (The_Variable)\n               and then Name_Of (The_Variable, In_Tree) /= Variable_Name\n             loop\n                The_Variable := Next_Variable (The_Variable, In_Tree);\n             end loop;\n \n-            if The_Variable = Empty_Node then\n-               if Current_Package /= Empty_Node then\n+            if No (The_Variable) then\n+               if Present (Current_Package) then\n                   Set_Next_Variable\n                     (Variable, In_Tree,\n                      To => First_Variable_Of (Current_Package, In_Tree));\n                   Set_First_Variable_Of\n                     (Current_Package, In_Tree, To => Variable);\n \n-               elsif Current_Project /= Empty_Node then\n+               elsif Present (Current_Project) then\n                   Set_Next_Variable\n                     (Variable, In_Tree,\n                      To => First_Variable_Of (Current_Project, In_Tree));\n@@ -1521,8 +1544,8 @@ package body Prj.Dect is\n \n             else\n                if Expression_Kind_Of (Variable, In_Tree) /= Undefined then\n-                  if\n-                    Expression_Kind_Of (The_Variable, In_Tree) = Undefined\n+                  if Expression_Kind_Of (The_Variable, In_Tree) =\n+                                                            Undefined\n                   then\n                      Set_Expression_Kind_Of\n                        (The_Variable, In_Tree,\n@@ -1543,7 +1566,6 @@ package body Prj.Dect is\n             end if;\n          end;\n       end if;\n-\n    end Parse_Variable_Declaration;\n \n end Prj.Dect;"}, {"sha": "a3997f0968bcb9678aa1fe8bbce665ddb8ac08ab", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 922, "deletions": 926, "changes": 1848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,7 +41,6 @@ with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n \n with System.Case_Util;          use System.Case_Util;\n with System.CRTL;\n-with System.Regexp;             use System.Regexp;\n \n package body Prj.Makr is\n \n@@ -50,6 +49,55 @@ package body Prj.Makr is\n    --  All the following need comments ??? All global variables and\n    --  subprograms must be fully commented.\n \n+   Very_Verbose : Boolean := False;\n+   --  Set in call to Initialize to indicate very verbose output\n+\n+   Project_File : Boolean := False;\n+   --  True when gnatname is creating/modifying a project file. False when\n+   --  gnatname is creating a configuration pragmas file.\n+\n+   Tree : constant Project_Node_Tree_Ref := new Project_Node_Tree_Data;\n+   --  The project tree where the project file is parsed\n+\n+   Args : Argument_List_Access;\n+   --  The list of arguments for calls to the compiler to get the unit names\n+   --  and kinds (spec or body) in the Ada sources.\n+\n+   Path_Name : String_Access;\n+\n+   Path_Last : Natural;\n+\n+   Directory_Last    : Natural := 0;\n+\n+   Output_Name      : String_Access;\n+   Output_Name_Last : Natural;\n+   Output_Name_Id   : Name_Id;\n+\n+   Project_Naming_File_Name : String_Access;\n+   --  String (1 .. Output_Name'Length +  Naming_File_Suffix'Length);\n+\n+   Project_Naming_Last : Natural;\n+   Project_Naming_Id   : Name_Id := No_Name;\n+\n+   Source_List_Path : String_Access;\n+   --  (1 .. Output_Name'Length + Source_List_File_Suffix'Length);\n+   Source_List_Last : Natural;\n+\n+   Source_List_FD : File_Descriptor;\n+\n+   Project_Node        : Project_Node_Id := Empty_Node;\n+   Project_Declaration : Project_Node_Id := Empty_Node;\n+   Source_Dirs_List    : Project_Node_Id := Empty_Node;\n+\n+   Project_Naming_Node     : Project_Node_Id := Empty_Node;\n+   Project_Naming_Decl     : Project_Node_Id := Empty_Node;\n+   Naming_Package          : Project_Node_Id := Empty_Node;\n+   Naming_Package_Comments : Project_Node_Id := Empty_Node;\n+\n+   Source_Files_Comments     : Project_Node_Id := Empty_Node;\n+   Source_Dirs_Comments      : Project_Node_Id := Empty_Node;\n+   Source_List_File_Comments : Project_Node_Id := Empty_Node;\n+\n    Naming_String : aliased String := \"naming\";\n \n    Gnatname_Packages : aliased String_List := (1 => Naming_String'Access);\n@@ -91,6 +139,36 @@ package body Prj.Makr is\n       Table_Initial        => 10,\n       Table_Increment      => 100,\n       Table_Name           => \"Prj.Makr.Processed_Directories\");\n+   --  The list of already processed directories for each section, to avoid\n+   --  processing several times the same directory in the same section.\n+\n+   package Source_Directories is new Table.Table\n+     (Table_Component_Type => String_Access,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Makr.Source_Directories\");\n+   --  The complete list of directories to be put in attribute Source_Dirs in\n+   --  the project file.\n+\n+   type Source is record\n+      File_Name : Name_Id;\n+      Unit_Name : Name_Id;\n+      Index     : Int := 0;\n+      Spec      : Boolean;\n+   end record;\n+\n+   package Sources is new Table.Table\n+     (Table_Component_Type => Source,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Makr.Sources\");\n+   --  The list of Ada sources found, with their unit name and kind, to be put\n+   --  in the source attribute and package Naming of the project file, or in\n+   --  the pragmas Source_File_Name in the configuration pragmas file.\n \n    ---------\n    -- Dup --\n@@ -112,566 +190,588 @@ package body Prj.Makr is\n       Fd := System.CRTL.dup2 (Integer (Old_Fd), Integer (New_Fd));\n    end Dup2;\n \n-   ----------\n-   -- Make --\n-   ----------\n+   --------------\n+   -- Finalize --\n+   --------------\n \n-   procedure Make\n-     (File_Path         : String;\n-      Project_File      : Boolean;\n-      Directories       : Argument_List;\n-      Name_Patterns     : Argument_List;\n-      Excluded_Patterns : Argument_List;\n-      Foreign_Patterns  : Argument_List;\n-      Preproc_Switches  : Argument_List;\n-      Very_Verbose      : Boolean)\n-   is\n-      Tree : constant Project_Node_Tree_Ref := new Project_Node_Tree_Data;\n+   procedure Finalize is\n+      Discard : Boolean;\n+      pragma Warnings (Off, Discard);\n \n-      Path_Name : String (1 .. File_Path'Length +\n-                            Project_File_Extension'Length);\n-      Path_Last : Natural := File_Path'Length;\n+      Current_Source_Dir : Project_Node_Id := Empty_Node;\n \n-      Directory_Last    : Natural := 0;\n+   begin\n+      if Project_File then\n+         --  If there were no already existing project file, or if the parsing\n+         --  was unsuccessful, create an empty project node with the correct\n+         --  name and its project declaration node.\n \n-      Output_Name      : String (Path_Name'Range);\n-      Output_Name_Last : Natural;\n-      Output_Name_Id   : Name_Id;\n+         if No (Project_Node) then\n+            Project_Node :=\n+              Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n+            Set_Name_Of (Project_Node, Tree, To => Output_Name_Id);\n+            Set_Project_Declaration_Of\n+              (Project_Node, Tree,\n+               To => Default_Project_Node\n+                 (Of_Kind => N_Project_Declaration, In_Tree => Tree));\n \n-      Project_Node        : Project_Node_Id := Empty_Node;\n-      Project_Declaration : Project_Node_Id := Empty_Node;\n-      Source_Dirs_List    : Project_Node_Id := Empty_Node;\n-      Current_Source_Dir  : Project_Node_Id := Empty_Node;\n+         end if;\n \n-      Project_Naming_Node     : Project_Node_Id := Empty_Node;\n-      Project_Naming_Decl     : Project_Node_Id := Empty_Node;\n-      Naming_Package          : Project_Node_Id := Empty_Node;\n-      Naming_Package_Comments : Project_Node_Id := Empty_Node;\n+      end if;\n \n-      Source_Files_Comments     : Project_Node_Id := Empty_Node;\n-      Source_Dirs_Comments      : Project_Node_Id := Empty_Node;\n-      Source_List_File_Comments : Project_Node_Id := Empty_Node;\n+      --  Delete the file if it already exists\n \n-      Project_Naming_File_Name : String (1 .. Output_Name'Length +\n-                                           Naming_File_Suffix'Length);\n+      Delete_File\n+        (Path_Name (Directory_Last + 1 .. Path_Last),\n+         Success => Discard);\n \n-      Project_Naming_Last : Natural;\n-      Project_Naming_Id   : Name_Id := No_Name;\n+      --  Create a new one\n \n-      Excluded_Expressions : array (Excluded_Patterns'Range) of Regexp;\n-      Regular_Expressions  : array (Name_Patterns'Range) of Regexp;\n-      Foreign_Expressions  : array (Foreign_Patterns'Range) of Regexp;\n+      if Opt.Verbose_Mode then\n+         Output.Write_Str (\"Creating new file \"\"\");\n+         Output.Write_Str (Path_Name (Directory_Last + 1 .. Path_Last));\n+         Output.Write_Line (\"\"\"\");\n+      end if;\n \n-      Source_List_Path : String (1 .. Output_Name'Length +\n-                                   Source_List_File_Suffix'Length);\n-      Source_List_Last : Natural;\n+      Output_FD := Create_New_File\n+        (Path_Name (Directory_Last + 1 .. Path_Last),\n+         Fmode => Text);\n \n-      Source_List_FD : File_Descriptor;\n+      --  Fails if project file cannot be created\n \n-      Args : Argument_List  (1 .. Preproc_Switches'Length + 6);\n+      if Output_FD = Invalid_FD then\n+         Prj.Com.Fail\n+           (\"cannot create new \"\"\", Path_Name (1 .. Path_Last), \"\"\"\");\n+      end if;\n \n-      type SFN_Pragma is record\n-         Unit  : Name_Id;\n-         File  : Name_Id;\n-         Index : Int := 0;\n-         Spec  : Boolean;\n-      end record;\n+      if Project_File then\n \n-      package SFN_Pragmas is new Table.Table\n-        (Table_Component_Type => SFN_Pragma,\n-         Table_Index_Type     => Natural,\n-         Table_Low_Bound      => 0,\n-         Table_Initial        => 50,\n-         Table_Increment      => 100,\n-         Table_Name           => \"Prj.Makr.SFN_Pragmas\");\n+         --  Delete the source list file, if it already exists\n \n-      procedure Process_Directory (Dir_Name : String; Recursively : Boolean);\n-      --  Look for Ada and foreign sources in a directory, according to the\n-      --  patterns. When Recursively is True, after looking for sources in\n-      --  Dir_Name, look also in its subdirectories, if any.\n+         declare\n+            Discard : Boolean;\n+            pragma Warnings (Off, Discard);\n+         begin\n+            Delete_File\n+              (Source_List_Path (1 .. Source_List_Last),\n+               Success => Discard);\n+         end;\n \n-      -----------------------\n-      -- Process_Directory --\n-      -----------------------\n+         --  And create a new source list file. Fail if file cannot be created.\n \n-      procedure Process_Directory (Dir_Name : String; Recursively : Boolean) is\n-         Matched : Matched_Type := False;\n-         Str     : String (1 .. 2_000);\n-         Canon   : String (1 .. 2_000);\n-         Last    : Natural;\n-         Dir     : Dir_Type;\n-         Process : Boolean := True;\n+         Source_List_FD := Create_New_File\n+           (Name  => Source_List_Path (1 .. Source_List_Last),\n+            Fmode => Text);\n \n-         Temp_File_Name         : String_Access := null;\n-         Save_Last_Pragma_Index : Natural := 0;\n-         File_Name_Id           : Name_Id := No_Name;\n-         SFN_Prag               : SFN_Pragma;\n+         if Source_List_FD = Invalid_FD then\n+            Prj.Com.Fail\n+              (\"cannot create file \"\"\",\n+               Source_List_Path (1 .. Source_List_Last),\n+               \"\"\"\");\n+         end if;\n \n-      begin\n-         --  Avoid processing the same directory more than once\n+         if Opt.Verbose_Mode then\n+            Output.Write_Str (\"Naming project file name is \"\"\");\n+            Output.Write_Str\n+              (Project_Naming_File_Name (1 .. Project_Naming_Last));\n+            Output.Write_Line (\"\"\"\");\n+         end if;\n \n-         for Index in 1 .. Processed_Directories.Last loop\n-            if Processed_Directories.Table (Index).all = Dir_Name then\n-               Process := False;\n-               exit;\n-            end if;\n-         end loop;\n+         --  Create the naming project node\n \n-         if Process then\n-            if Opt.Verbose_Mode then\n-               Output.Write_Str (\"Processing directory \"\"\");\n-               Output.Write_Str (Dir_Name);\n-               Output.Write_Line (\"\"\"\");\n-            end if;\n+         Project_Naming_Node :=\n+           Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n+         Set_Name_Of (Project_Naming_Node, Tree, To => Project_Naming_Id);\n+         Project_Naming_Decl :=\n+           Default_Project_Node\n+             (Of_Kind => N_Project_Declaration, In_Tree => Tree);\n+         Set_Project_Declaration_Of\n+           (Project_Naming_Node, Tree, Project_Naming_Decl);\n+         Naming_Package :=\n+           Default_Project_Node\n+             (Of_Kind => N_Package_Declaration, In_Tree => Tree);\n+         Set_Name_Of (Naming_Package, Tree, To => Name_Naming);\n \n-            Processed_Directories. Increment_Last;\n-            Processed_Directories.Table (Processed_Directories.Last) :=\n-              new String'(Dir_Name);\n+         --  Add an attribute declaration for Source_Files as an empty list (to\n+         --  indicate there are no sources in the naming project) and a package\n+         --  Naming (that will be filled later).\n \n-            --  Get the source file names from the directory. Fails if the\n-            --  directory does not exist.\n+         declare\n+            Decl_Item : constant Project_Node_Id :=\n+                          Default_Project_Node\n+                            (Of_Kind => N_Declarative_Item, In_Tree => Tree);\n \n-            begin\n-               Open (Dir, Dir_Name);\n-            exception\n-               when Directory_Error =>\n-                  Prj.Com.Fail (\"cannot open directory \"\"\", Dir_Name, \"\"\"\");\n-            end;\n+            Attribute : constant Project_Node_Id :=\n+                          Default_Project_Node\n+                            (Of_Kind       => N_Attribute_Declaration,\n+                             In_Tree       => Tree,\n+                             And_Expr_Kind => List);\n \n-            --  Process each regular file in the directory\n+            Expression : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Expression,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => List);\n \n-            File_Loop : loop\n-               Read (Dir, Str, Last);\n-               exit File_Loop when Last = 0;\n+            Term      : constant Project_Node_Id :=\n+                          Default_Project_Node\n+                            (Of_Kind       => N_Term,\n+                             In_Tree       => Tree,\n+                             And_Expr_Kind => List);\n \n-               --  Copy the file name and put it in canonical case to match\n-               --  against the patterns that have themselves already been put\n-               --  in canonical case.\n+            Empty_List : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind => N_Literal_String_List,\n+                              In_Tree => Tree);\n \n-               Canon (1 .. Last) := Str (1 .. Last);\n-               Canonical_Case_File_Name (Canon (1 .. Last));\n+         begin\n+            Set_First_Declarative_Item_Of\n+              (Project_Naming_Decl, Tree, To => Decl_Item);\n+            Set_Next_Declarative_Item (Decl_Item, Tree, Naming_Package);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n+            Set_Name_Of (Attribute, Tree, To => Name_Source_Files);\n+            Set_Expression_Of (Attribute, Tree, To => Expression);\n+            Set_First_Term (Expression, Tree, To => Term);\n+            Set_Current_Term (Term, Tree, To => Empty_List);\n+         end;\n \n-               if Is_Regular_File\n-                 (Dir_Name & Directory_Separator & Str (1 .. Last))\n-               then\n-                  Matched := True;\n+         --  Add a with clause on the naming project in the main project, if\n+         --  there is not already one.\n \n-                  Name_Len := Last;\n-                  Name_Buffer (1 .. Name_Len) := Str (1 .. Last);\n-                  File_Name_Id := Name_Find;\n+         declare\n+            With_Clause : Project_Node_Id :=\n+                                  First_With_Clause_Of (Project_Node, Tree);\n \n-                  --  First, check if the file name matches at least one of\n-                  --  the excluded expressions;\n+         begin\n+            while Present (With_Clause) loop\n+               exit when\n+                 Prj.Tree.Name_Of (With_Clause, Tree) = Project_Naming_Id;\n+               With_Clause := Next_With_Clause_Of (With_Clause, Tree);\n+            end loop;\n \n-                  for Index in Excluded_Expressions'Range loop\n-                     if\n-                       Match (Canon (1 .. Last), Excluded_Expressions (Index))\n-                     then\n-                        Matched := Excluded;\n-                        exit;\n-                     end if;\n-                  end loop;\n+            if No (With_Clause) then\n+               With_Clause := Default_Project_Node\n+                 (Of_Kind => N_With_Clause, In_Tree => Tree);\n+               Set_Next_With_Clause_Of\n+                 (With_Clause, Tree,\n+                  To => First_With_Clause_Of (Project_Node, Tree));\n+               Set_First_With_Clause_Of\n+                 (Project_Node, Tree, To => With_Clause);\n+               Set_Name_Of (With_Clause, Tree, To => Project_Naming_Id);\n \n-                  --  If it does not match any of the excluded expressions,\n-                  --  check if the file name matches at least one of the\n-                  --  regular expressions.\n+               --  We set the project node to something different than\n+               --  Empty_Node, so that Prj.PP does not generate a limited\n+               --  with clause.\n \n-                  if Matched = True then\n-                     Matched := False;\n+               Set_Project_Node_Of (With_Clause, Tree, Non_Empty_Node);\n \n-                     for Index in Regular_Expressions'Range loop\n-                        if\n-                          Match\n-                            (Canon (1 .. Last), Regular_Expressions (Index))\n-                        then\n-                           Matched := True;\n-                           exit;\n-                        end if;\n-                     end loop;\n-                  end if;\n+               Name_Len := Project_Naming_Last;\n+               Name_Buffer (1 .. Name_Len) :=\n+                 Project_Naming_File_Name (1 .. Project_Naming_Last);\n+               Set_String_Value_Of (With_Clause, Tree, To => Name_Find);\n+            end if;\n+         end;\n \n-                  if Very_Verbose\n-                    or else (Matched = True and then Opt.Verbose_Mode)\n-                  then\n-                     Output.Write_Str (\"   Checking \"\"\");\n-                     Output.Write_Str (Str (1 .. Last));\n-                     Output.Write_Line (\"\"\": \");\n-                  end if;\n+         Project_Declaration := Project_Declaration_Of (Project_Node, Tree);\n \n-                  --  If the file name matches one of the regular expressions,\n-                  --  parse it to get its unit name.\n+         --  Add a package Naming in the main project, that is a renaming of\n+         --  package Naming in the naming project.\n \n-                  if Matched = True then\n-                     declare\n-                        FD : File_Descriptor;\n-                        Success : Boolean;\n-                        Saved_Output : File_Descriptor;\n-                        Saved_Error  : File_Descriptor;\n+         declare\n+            Decl_Item  : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind => N_Declarative_Item,\n+                              In_Tree => Tree);\n \n-                     begin\n-                        --  If we don't have the path of the compiler yet,\n-                        --  get it now. The compiler name may have a prefix,\n-                        --  so we get the potentially prefixed name.\n+            Naming : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind => N_Package_Declaration,\n+                              In_Tree => Tree);\n \n-                        if Gcc_Path = null then\n-                           declare\n-                              Prefix_Gcc : String_Access :=\n-                                             Program_Name (Gcc);\n-                           begin\n-                              Gcc_Path :=\n-                                Locate_Exec_On_Path (Prefix_Gcc.all);\n-                              Free (Prefix_Gcc);\n-                           end;\n-\n-                           if Gcc_Path = null then\n-                              Prj.Com.Fail (\"could not locate \" & Gcc);\n-                           end if;\n-                        end if;\n+         begin\n+            Set_Next_Declarative_Item\n+              (Decl_Item, Tree,\n+               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n+            Set_First_Declarative_Item_Of\n+              (Project_Declaration, Tree, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Naming);\n+            Set_Name_Of (Naming, Tree, To => Name_Naming);\n+            Set_Project_Of_Renamed_Package_Of\n+              (Naming, Tree, To => Project_Naming_Node);\n \n-                        --  If we don't have yet the file name of the\n-                        --  temporary file, get it now.\n+            --  Attach the comments, if any, that were saved for package\n+            --  Naming.\n \n-                        if Temp_File_Name = null then\n-                           Create_Temp_File (FD, Temp_File_Name);\n+            Tree.Project_Nodes.Table (Naming).Comments :=\n+              Naming_Package_Comments;\n+         end;\n \n-                           if FD = Invalid_FD then\n-                              Prj.Com.Fail\n-                                (\"could not create temporary file\");\n-                           end if;\n+         --  Add an attribute declaration for Source_Dirs, initialized as an\n+         --  empty list.\n \n-                           Close (FD);\n-                           Delete_File (Temp_File_Name.all, Success);\n-                        end if;\n+         declare\n+            Decl_Item  : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind => N_Declarative_Item,\n+                              In_Tree => Tree);\n \n-                        Args (Args'Last) := new String'\n-                          (Dir_Name &\n-                           Directory_Separator &\n-                           Str (1 .. Last));\n+            Attribute : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Attribute_Declaration,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => List);\n \n-                        --  Create the temporary file\n+            Expression : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Expression,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => List);\n \n-                        FD := Create_Output_Text_File\n-                          (Name => Temp_File_Name.all);\n+            Term  : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Term, In_Tree => Tree,\n+                              And_Expr_Kind => List);\n \n-                        if FD = Invalid_FD then\n-                           Prj.Com.Fail\n-                             (\"could not create temporary file\");\n-                        end if;\n+         begin\n+            Set_Next_Declarative_Item\n+              (Decl_Item, Tree,\n+               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n+            Set_First_Declarative_Item_Of\n+              (Project_Declaration, Tree, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n+            Set_Name_Of (Attribute, Tree, To => Name_Source_Dirs);\n+            Set_Expression_Of (Attribute, Tree, To => Expression);\n+            Set_First_Term (Expression, Tree, To => Term);\n+            Source_Dirs_List :=\n+              Default_Project_Node\n+                (Of_Kind       => N_Literal_String_List,\n+                 In_Tree       => Tree,\n+                 And_Expr_Kind => List);\n+            Set_Current_Term (Term, Tree, To => Source_Dirs_List);\n \n-                        --  Save the standard output and error\n+            --  Attach the comments, if any, that were saved for attribute\n+            --  Source_Dirs.\n \n-                        Saved_Output := Dup (Standout);\n-                        Saved_Error  := Dup (Standerr);\n+            Tree.Project_Nodes.Table (Attribute).Comments :=\n+              Source_Dirs_Comments;\n+         end;\n \n-                        --  Set standard output and error to the temporary file\n+         --  Put the source directories in attribute Source_Dirs\n \n-                        Dup2 (FD, Standout);\n-                        Dup2 (FD, Standerr);\n+         for Source_Dir_Index in 1 .. Source_Directories.Last loop\n+            declare\n+               Expression : constant Project_Node_Id :=\n+                              Default_Project_Node\n+                                (Of_Kind       => N_Expression,\n+                                 In_Tree       => Tree,\n+                                 And_Expr_Kind => Single);\n \n-                        --  And spawn the compiler\n+               Term       : constant Project_Node_Id :=\n+                              Default_Project_Node\n+                                (Of_Kind       => N_Term,\n+                                 In_Tree       => Tree,\n+                                 And_Expr_Kind => Single);\n \n-                        Spawn (Gcc_Path.all, Args, Success);\n+               Value      : constant Project_Node_Id :=\n+                              Default_Project_Node\n+                                (Of_Kind       => N_Literal_String,\n+                                 In_Tree       => Tree,\n+                                 And_Expr_Kind => Single);\n \n-                        --  Restore the standard output and error\n+            begin\n+               if No (Current_Source_Dir) then\n+                  Set_First_Expression_In_List\n+                    (Source_Dirs_List, Tree, To => Expression);\n+               else\n+                  Set_Next_Expression_In_List\n+                    (Current_Source_Dir, Tree, To => Expression);\n+               end if;\n \n-                        Dup2 (Saved_Output, Standout);\n-                        Dup2 (Saved_Error, Standerr);\n+               Current_Source_Dir := Expression;\n+               Set_First_Term (Expression, Tree, To => Term);\n+               Set_Current_Term (Term, Tree, To => Value);\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer\n+                 (Source_Directories.Table (Source_Dir_Index).all);\n+               Set_String_Value_Of (Value, Tree, To => Name_Find);\n+            end;\n+         end loop;\n \n-                        --  Close the temporary file\n+         --  Add an attribute declaration for Source_Files or Source_List_File\n+         --  with the source list file name that will be created.\n \n-                        Close (FD);\n+         declare\n+            Decl_Item  : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind => N_Declarative_Item,\n+                              In_Tree => Tree);\n \n-                        --  And close the saved standard output and error to\n-                        --  avoid too many file descriptors.\n+            Attribute  : constant Project_Node_Id :=\n+                            Default_Project_Node\n+                              (Of_Kind       => N_Attribute_Declaration,\n+                               In_Tree       => Tree,\n+                               And_Expr_Kind => Single);\n \n-                        Close (Saved_Output);\n-                        Close (Saved_Error);\n+            Expression : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Expression,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => Single);\n \n-                        --  Now that standard output is restored, check if\n-                        --  the compiler ran correctly.\n+            Term       : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Term,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => Single);\n \n-                        --  Read the lines of the temporary file:\n-                        --  they should contain the kind and name of the unit.\n+            Value      : constant Project_Node_Id :=\n+                           Default_Project_Node\n+                             (Of_Kind       => N_Literal_String,\n+                              In_Tree       => Tree,\n+                              And_Expr_Kind => Single);\n \n-                        declare\n-                           File      : Text_File;\n-                           Text_Line : String (1 .. 1_000);\n-                           Text_Last : Natural;\n+         begin\n+            Set_Next_Declarative_Item\n+              (Decl_Item, Tree,\n+               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n+            Set_First_Declarative_Item_Of\n+              (Project_Declaration, Tree, To => Decl_Item);\n+            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n \n-                        begin\n-                           Open (File, Temp_File_Name.all);\n+            Set_Name_Of (Attribute, Tree, To => Name_Source_List_File);\n+            Set_Expression_Of (Attribute, Tree, To => Expression);\n+            Set_First_Term (Expression, Tree, To => Term);\n+            Set_Current_Term (Term, Tree, To => Value);\n+            Name_Len := Source_List_Last;\n+            Name_Buffer (1 .. Name_Len) :=\n+              Source_List_Path (1 .. Source_List_Last);\n+            Set_String_Value_Of (Value, Tree, To => Name_Find);\n \n-                           if not Is_Valid (File) then\n-                              Prj.Com.Fail\n-                                (\"could not read temporary file\");\n-                           end if;\n+            --  If there was no comments for attribute Source_List_File, put\n+            --  those for Source_Files, if they exist.\n \n-                           Save_Last_Pragma_Index := SFN_Pragmas.Last;\n+            if Present (Source_List_File_Comments) then\n+               Tree.Project_Nodes.Table (Attribute).Comments :=\n+                 Source_List_File_Comments;\n+            else\n+               Tree.Project_Nodes.Table (Attribute).Comments :=\n+                 Source_Files_Comments;\n+            end if;\n+         end;\n \n-                           if End_Of_File (File) then\n-                              if Opt.Verbose_Mode then\n-                                 if not Success then\n-                                    Output.Write_Str (\"      (process died) \");\n-                                 end if;\n-                              end if;\n+         --  Put the sources in the source list files and in the naming\n+         --  project.\n \n-                           else\n-                              Line_Loop : while not End_Of_File (File) loop\n-                                 Get_Line (File, Text_Line, Text_Last);\n+         for Source_Index in 1 .. Sources.Last loop\n \n-                                 --  Find the first closing parenthesis\n+            --  Add the corresponding attribute in the\n+            --  Naming package of the naming project.\n \n-                                 Char_Loop : for J in 1 .. Text_Last loop\n-                                    if Text_Line (J) = ')' then\n-                                       if J >= 13 and then\n-                                         Text_Line (1 .. 4) = \"Unit\"\n-                                       then\n-                                          --  Add entry to SFN_Pragmas table\n+            declare\n+               Current_Source : constant Source :=\n+                                  Sources.Table (Source_Index);\n \n-                                          Name_Len := J - 12;\n-                                          Name_Buffer (1 .. Name_Len) :=\n-                                            Text_Line (6 .. J - 7);\n-                                          SFN_Prag :=\n-                                            (Unit  => Name_Find,\n-                                             File  => File_Name_Id,\n-                                             Index => 0,\n-                                             Spec  => Text_Line (J - 5 .. J) =\n-                                                        \"(spec)\");\n+               Decl_Item : constant Project_Node_Id :=\n+                             Default_Project_Node\n+                               (Of_Kind =>\n+                                                N_Declarative_Item,\n+                                In_Tree => Tree);\n \n-                                          SFN_Pragmas.Increment_Last;\n-                                          SFN_Pragmas.Table\n-                                            (SFN_Pragmas.Last) := SFN_Prag;\n-                                       end if;\n-                                       exit Char_Loop;\n-                                    end if;\n-                                 end loop Char_Loop;\n-                              end loop Line_Loop;\n-                           end if;\n+               Attribute : constant Project_Node_Id :=\n+                             Default_Project_Node\n+                               (Of_Kind =>\n+                                                N_Attribute_Declaration,\n+                                In_Tree => Tree);\n+\n+               Expression : constant Project_Node_Id :=\n+                              Default_Project_Node\n+                                (Of_Kind       => N_Expression,\n+                                 And_Expr_Kind => Single,\n+                                 In_Tree       => Tree);\n+\n+               Term      : constant Project_Node_Id :=\n+                             Default_Project_Node\n+                               (Of_Kind       => N_Term,\n+                                And_Expr_Kind => Single,\n+                                In_Tree       => Tree);\n+\n+               Value     : constant Project_Node_Id :=\n+                             Default_Project_Node\n+                               (Of_Kind       => N_Literal_String,\n+                                And_Expr_Kind => Single,\n+                                In_Tree       => Tree);\n \n-                           if Save_Last_Pragma_Index = SFN_Pragmas.Last then\n-                              if Opt.Verbose_Mode then\n-                                 Output.Write_Line (\"      not a unit\");\n-                              end if;\n+            begin\n+               --  Add source file name to the source list file\n \n-                           else\n-                              if SFN_Pragmas.Last >\n-                                   Save_Last_Pragma_Index + 1\n-                              then\n-                                 for Index in Save_Last_Pragma_Index + 1 ..\n-                                                SFN_Pragmas.Last\n-                                 loop\n-                                    SFN_Pragmas.Table (Index).Index :=\n-                                      Int (Index - Save_Last_Pragma_Index);\n-                                 end loop;\n-                              end if;\n+               Get_Name_String (Current_Source.File_Name);\n+               Add_Char_To_Name_Buffer (ASCII.LF);\n+               if Write (Source_List_FD,\n+                         Name_Buffer (1)'Address,\n+                         Name_Len) /= Name_Len\n+               then\n+                  Prj.Com.Fail (\"disk full\");\n+               end if;\n \n-                              for Index in Save_Last_Pragma_Index + 1 ..\n-                                             SFN_Pragmas.Last\n-                              loop\n-                                 SFN_Prag := SFN_Pragmas.Table (Index);\n+               --  For an Ada source, add entry in package Naming\n+\n+               if Current_Source.Unit_Name /= No_Name then\n+                  Set_Next_Declarative_Item\n+                    (Decl_Item,\n+                     To      => First_Declarative_Item_Of\n+                       (Naming_Package, Tree),\n+                     In_Tree => Tree);\n+                  Set_First_Declarative_Item_Of\n+                    (Naming_Package,\n+                     To      => Decl_Item,\n+                     In_Tree => Tree);\n+                  Set_Current_Item_Node\n+                    (Decl_Item,\n+                     To      => Attribute,\n+                     In_Tree => Tree);\n+\n+                  --  Is it a spec or a body?\n+\n+                  if Current_Source.Spec then\n+                     Set_Name_Of\n+                       (Attribute, Tree,\n+                        To => Name_Spec);\n+                  else\n+                     Set_Name_Of\n+                       (Attribute, Tree,\n+                        To => Name_Body);\n+                  end if;\n \n-                                 if Opt.Verbose_Mode then\n-                                    if SFN_Prag.Spec then\n-                                       Output.Write_Str (\"      spec of \");\n+                  --  Get the name of the unit\n \n-                                    else\n-                                       Output.Write_Str (\"      body of \");\n-                                    end if;\n+                  Get_Name_String (Current_Source.Unit_Name);\n+                  To_Lower (Name_Buffer (1 .. Name_Len));\n+                  Set_Associative_Array_Index_Of\n+                    (Attribute, Tree, To => Name_Find);\n \n-                                    Output.Write_Line\n-                                      (Get_Name_String (SFN_Prag.Unit));\n-                                 end if;\n+                  Set_Expression_Of\n+                    (Attribute, Tree, To => Expression);\n+                  Set_First_Term\n+                    (Expression, Tree, To => Term);\n+                  Set_Current_Term\n+                    (Term, Tree, To => Value);\n \n-                                 if Project_File then\n+                  --  And set the name of the file\n \n-                                    --  Add the corresponding attribute in the\n-                                    --  Naming package of the naming project.\n+                  Set_String_Value_Of\n+                    (Value, Tree, To => Current_Source.File_Name);\n+                  Set_Source_Index_Of\n+                    (Value, Tree, To => Current_Source.Index);\n+               end if;\n+            end;\n+         end loop;\n \n-                                    declare\n-                                       Decl_Item : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                           (Of_Kind =>\n-                                                N_Declarative_Item,\n-                                            In_Tree => Tree);\n+         --  Close the source list file\n \n-                                       Attribute : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                           (Of_Kind =>\n-                                                N_Attribute_Declaration,\n-                                            In_Tree => Tree);\n-\n-                                       Expression : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                           (Of_Kind => N_Expression,\n-                                            And_Expr_Kind => Single,\n-                                            In_Tree => Tree);\n-\n-                                       Term : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                           (Of_Kind => N_Term,\n-                                            And_Expr_Kind => Single,\n-                                            In_Tree => Tree);\n-\n-                                       Value : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                           (Of_Kind       => N_Literal_String,\n-                                            And_Expr_Kind => Single,\n-                                            In_Tree       => Tree);\n-\n-                                    begin\n-                                       Set_Next_Declarative_Item\n-                                         (Decl_Item,\n-                                          To => First_Declarative_Item_Of\n-                                            (Naming_Package, Tree),\n-                                          In_Tree => Tree);\n-                                       Set_First_Declarative_Item_Of\n-                                         (Naming_Package,\n-                                          To => Decl_Item,\n-                                          In_Tree => Tree);\n-                                       Set_Current_Item_Node\n-                                         (Decl_Item,\n-                                          To => Attribute,\n-                                          In_Tree => Tree);\n-\n-                                       --  Is it a spec or a body?\n-\n-                                       if SFN_Prag.Spec then\n-                                          Set_Name_Of\n-                                            (Attribute, Tree,\n-                                             To => Name_Spec);\n-                                       else\n-                                          Set_Name_Of\n-                                            (Attribute, Tree,\n-                                             To => Name_Body);\n-                                       end if;\n+         Close (Source_List_FD);\n \n-                                       --  Get the name of the unit\n+         --  Output the project file\n \n-                                       Get_Name_String (SFN_Prag.Unit);\n-                                       To_Lower (Name_Buffer (1 .. Name_Len));\n-                                       Set_Associative_Array_Index_Of\n-                                         (Attribute, Tree, To => Name_Find);\n+         Prj.PP.Pretty_Print\n+           (Project_Node, Tree,\n+            W_Char                 => Write_A_Char'Access,\n+            W_Eol                  => Write_Eol'Access,\n+            W_Str                  => Write_A_String'Access,\n+            Backward_Compatibility => False);\n+         Close (Output_FD);\n \n-                                       Set_Expression_Of\n-                                         (Attribute, Tree, To => Expression);\n-                                       Set_First_Term\n-                                         (Expression, Tree, To => Term);\n-                                       Set_Current_Term\n-                                         (Term, Tree, To => Value);\n+         --  Delete the naming project file if it already exists\n \n-                                       --  And set the name of the file\n+         Delete_File\n+           (Project_Naming_File_Name (1 .. Project_Naming_Last),\n+            Success => Discard);\n \n-                                       Set_String_Value_Of\n-                                         (Value, Tree, To => File_Name_Id);\n-                                       Set_Source_Index_Of\n-                                         (Value, Tree, To => SFN_Prag.Index);\n-                                    end;\n-                                 end if;\n-                              end loop;\n+         --  Create a new one\n \n-                              if Project_File then\n-                                 --  Add source file name to source list\n-                                 --  file.\n+         if Opt.Verbose_Mode then\n+            Output.Write_Str (\"Creating new naming project file \"\"\");\n+            Output.Write_Str (Project_Naming_File_Name\n+                              (1 .. Project_Naming_Last));\n+            Output.Write_Line (\"\"\"\");\n+         end if;\n \n-                                 Last := Last + 1;\n-                                 Str (Last) := ASCII.LF;\n+         Output_FD := Create_New_File\n+           (Project_Naming_File_Name (1 .. Project_Naming_Last),\n+            Fmode => Text);\n \n-                                 if Write (Source_List_FD,\n-                                           Str (1)'Address,\n-                                           Last) /= Last\n-                                 then\n-                                    Prj.Com.Fail (\"disk full\");\n-                                 end if;\n-                              end if;\n-                           end if;\n+         --  Fails if naming project file cannot be created\n \n-                           Close (File);\n+         if Output_FD = Invalid_FD then\n+            Prj.Com.Fail\n+              (\"cannot create new \"\"\",\n+               Project_Naming_File_Name (1 .. Project_Naming_Last),\n+               \"\"\"\");\n+         end if;\n \n-                           Delete_File (Temp_File_Name.all, Success);\n-                        end;\n-                     end;\n+         --  Output the naming project file\n \n-                  --  File name matches none of the regular expressions\n+         Prj.PP.Pretty_Print\n+           (Project_Naming_Node, Tree,\n+            W_Char                 => Write_A_Char'Access,\n+            W_Eol                  => Write_Eol'Access,\n+            W_Str                  => Write_A_String'Access,\n+            Backward_Compatibility => False);\n+         Close (Output_FD);\n \n-                  else\n-                     --  If file is not excluded, see if this is foreign source\n+      else\n+         --  For each Ada source, write a pragma Source_File_Name to the\n+         --  configuration pragmas file.\n \n-                     if Matched /= Excluded then\n-                        for Index in Foreign_Expressions'Range loop\n-                           if Match (Canon (1 .. Last),\n-                                     Foreign_Expressions (Index))\n-                           then\n-                              Matched := True;\n-                              exit;\n-                           end if;\n-                        end loop;\n-                     end if;\n-\n-                     if Very_Verbose then\n-                        case Matched is\n-                           when False =>\n-                              Output.Write_Line (\"no match\");\n-\n-                           when Excluded =>\n-                              Output.Write_Line (\"excluded\");\n-\n-                           when True =>\n-                              Output.Write_Line (\"foreign source\");\n-                        end case;\n-                     end if;\n-\n-                     if Project_File and Matched = True then\n-\n-                        --  Add source file name to source list file\n+         for Index in 1 .. Sources.Last loop\n+            if Sources.Table (Index).Unit_Name /= No_Name then\n+               Write_A_String (\"pragma Source_File_Name\");\n+               Write_Eol;\n+               Write_A_String (\"  (\");\n+               Write_A_String\n+                 (Get_Name_String (Sources.Table (Index).Unit_Name));\n+               Write_A_String (\",\");\n+               Write_Eol;\n \n-                        Last := Last + 1;\n-                        Str (Last) := ASCII.LF;\n+               if Sources.Table (Index).Spec then\n+                  Write_A_String (\"   Spec_File_Name => \"\"\");\n \n-                        if Write (Source_List_FD,\n-                                  Str (1)'Address,\n-                                  Last) /= Last\n-                        then\n-                           Prj.Com.Fail (\"disk full\");\n-                        end if;\n-                     end if;\n-                  end if;\n+               else\n+                  Write_A_String (\"   Body_File_Name => \"\"\");\n                end if;\n-            end loop File_Loop;\n-\n-            Close (Dir);\n-         end if;\n-\n-         --  If Recursively is True, call itself for each subdirectory.\n-         --  We do that, even when this directory has already been processed,\n-         --  because all of its subdirectories may not have been processed.\n \n-         if Recursively then\n-            Open (Dir, Dir_Name);\n-\n-            loop\n-               Read (Dir, Str, Last);\n-               exit when Last = 0;\n+               Write_A_String\n+                 (Get_Name_String (Sources.Table (Index).File_Name));\n \n-               --  Do not call itself for \".\" or \"..\"\n+               Write_A_String (\"\"\"\");\n \n-               if Is_Directory\n-                 (Dir_Name & Directory_Separator & Str (1 .. Last))\n-                 and then Str (1 .. Last) /= \".\"\n-                 and then Str (1 .. Last) /= \"..\"\n-               then\n-                  Process_Directory\n-                    (Dir_Name & Directory_Separator & Str (1 .. Last),\n-                     Recursively => True);\n+               if Sources.Table (Index).Index /= 0 then\n+                  Write_A_String (\", Index =>\");\n+                  Write_A_String (Sources.Table (Index).Index'Img);\n                end if;\n-            end loop;\n \n-            Close (Dir);\n-         end if;\n-      end Process_Directory;\n+               Write_A_String (\");\");\n+               Write_Eol;\n+            end if;\n+         end loop;\n+\n+         Close (Output_FD);\n+      end if;\n+   end Finalize;\n \n-   --  Start of processing for Make\n+   ----------------\n+   -- Initialize --\n+   ----------------\n \n+   procedure Initialize\n+     (File_Path         : String;\n+      Project_File      : Boolean;\n+      Preproc_Switches  : Argument_List;\n+      Very_Verbose      : Boolean)\n+   is\n    begin\n+      Makr.Very_Verbose := Initialize.Very_Verbose;\n+      Makr.Project_File := Initialize.Project_File;\n+\n       --  Do some needed initializations\n \n       Csets.Initialize;\n@@ -680,12 +780,12 @@ package body Prj.Makr is\n       Prj.Initialize (No_Project_Tree);\n       Prj.Tree.Initialize (Tree);\n \n-      SFN_Pragmas.Set_Last (0);\n-\n-      Processed_Directories.Set_Last (0);\n+      Sources.Set_Last (0);\n+      Source_Directories.Set_Last (0);\n \n       --  Initialize the compiler switches\n \n+      Args := new Argument_List (1 .. Preproc_Switches'Length + 6);\n       Args (1) := new String'(\"-c\");\n       Args (2) := new String'(\"-gnats\");\n       Args (3) := new String'(\"-gnatu\");\n@@ -695,6 +795,10 @@ package body Prj.Makr is\n \n       --  Get the path and file names\n \n+      Path_Name := new\n+        String (1 .. File_Path'Length + Project_File_Extension'Length);\n+      Path_Last := File_Path'Length;\n+\n       if File_Names_Case_Sensitive then\n          Path_Name (1 .. Path_Last) := File_Path;\n       else\n@@ -722,31 +826,31 @@ package body Prj.Makr is\n             Path_Last := Path_Name'Last;\n          end if;\n \n-         Output_Name (1 .. Path_Last) := To_Lower (Path_Name (1 .. Path_Last));\n-         Output_Name_Last := Path_Last - Project_File_Extension'Length;\n+         Output_Name := new String'(To_Lower (Path_Name (1 .. Path_Last)));\n+         Output_Name_Last := Output_Name'Last - 4;\n \n          --  If there is already a project file with the specified name, parse\n          --  it to get the components that are not automatically generated.\n \n          if Is_Regular_File (Output_Name (1 .. Path_Last)) then\n             if Opt.Verbose_Mode then\n                Output.Write_Str (\"Parsing already existing project file \"\"\");\n-               Output.Write_Str (Output_Name (1 .. Output_Name_Last));\n+               Output.Write_Str (Output_Name.all);\n                Output.Write_Line (\"\"\"\");\n             end if;\n \n             Part.Parse\n               (In_Tree                => Tree,\n                Project                => Project_Node,\n-               Project_File_Name      => Output_Name (1 .. Output_Name_Last),\n+               Project_File_Name      => Output_Name.all,\n                Always_Errout_Finalize => False,\n                Store_Comments         => True,\n                Current_Directory      => Get_Current_Dir,\n                Packages_To_Check      => Packages_To_Check_By_Gnatname);\n \n             --  Fail if parsing was not successful\n \n-            if Project_Node = Empty_Node then\n+            if No (Project_Node) then\n                Fail (\"parsing of existing project file failed\");\n \n             else\n@@ -762,11 +866,11 @@ package body Prj.Makr is\n                   Previous    : Project_Node_Id := Empty_Node;\n \n                begin\n-                  while With_Clause /= Empty_Node loop\n+                  while Present (With_Clause) loop\n                      if Prj.Tree.Name_Of (With_Clause, Tree) =\n                           Project_Naming_Id\n                      then\n-                        if Previous = Empty_Node then\n+                        if No (Previous) then\n                            Set_First_With_Clause_Of\n                              (Project_Node, Tree,\n                               To => Next_With_Clause_Of (With_Clause, Tree));\n@@ -803,7 +907,7 @@ package body Prj.Makr is\n                   Comments     : Project_Node_Id;\n \n                begin\n-                  while Declaration /= Empty_Node loop\n+                  while Present (Declaration) loop\n                      Current_Node := Current_Item_Node (Declaration, Tree);\n \n                      Kind_Of_Node := Kind_Of (Current_Node, Tree);\n@@ -834,7 +938,7 @@ package body Prj.Makr is\n                               Naming_Package_Comments := Comments;\n                            end if;\n \n-                           if Previous = Empty_Node then\n+                           if No (Previous) then\n                               Set_First_Declarative_Item_Of\n                                 (Project_Declaration_Of (Project_Node, Tree),\n                                  Tree,\n@@ -874,12 +978,10 @@ package body Prj.Makr is\n          --  Create the project naming file name\n \n          Project_Naming_Last := Output_Name_Last;\n-         Project_Naming_File_Name (1 .. Project_Naming_Last) :=\n-           Output_Name (1 .. Project_Naming_Last);\n-         Project_Naming_File_Name\n-           (Project_Naming_Last + 1 ..\n-              Project_Naming_Last + Naming_File_Suffix'Length) :=\n-           Naming_File_Suffix;\n+         Project_Naming_File_Name :=\n+           new String'(Output_Name (1 .. Output_Name_Last) &\n+                       Naming_File_Suffix &\n+                       Project_File_Extension);\n          Project_Naming_Last :=\n            Project_Naming_Last + Naming_File_Suffix'Length;\n \n@@ -890,23 +992,17 @@ package body Prj.Makr is\n            Project_Naming_File_Name (1 .. Name_Len);\n          Project_Naming_Id := Name_Find;\n \n-         Project_Naming_File_Name\n-           (Project_Naming_Last + 1 ..\n-              Project_Naming_Last + Project_File_Extension'Length) :=\n-           Project_File_Extension;\n          Project_Naming_Last :=\n            Project_Naming_Last + Project_File_Extension'Length;\n \n          --  Create the source list file name\n \n          Source_List_Last := Output_Name_Last;\n-         Source_List_Path (1 .. Source_List_Last) :=\n-           Output_Name (1 .. Source_List_Last);\n-         Source_List_Path\n-           (Source_List_Last + 1 ..\n-              Source_List_Last + Source_List_File_Suffix'Length) :=\n-           Source_List_File_Suffix;\n-         Source_List_Last := Source_List_Last + Source_List_File_Suffix'Length;\n+         Source_List_Path :=\n+           new String'(Output_Name (1 .. Output_Name_Last) &\n+                       Source_List_File_Suffix);\n+         Source_List_Last :=\n+           Output_Name_Last + Source_List_File_Suffix'Length;\n \n          --  Add the project file extension to the project name\n \n@@ -915,6 +1011,7 @@ package body Prj.Makr is\n               Output_Name_Last + Project_File_Extension'Length) :=\n            Project_File_Extension;\n          Output_Name_Last := Output_Name_Last + Project_File_Extension'Length;\n+\n       end if;\n \n       --  Change the current directory to the directory of the project file,\n@@ -931,544 +1028,443 @@ package body Prj.Makr is\n                   \"\"\"\");\n          end;\n       end if;\n+   end Initialize;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   procedure Process\n+     (Directories       : Argument_List;\n+      Name_Patterns     : Regexp_List;\n+      Excluded_Patterns : Regexp_List;\n+      Foreign_Patterns  : Regexp_List)\n+  is\n+      procedure Process_Directory (Dir_Name : String; Recursively : Boolean);\n+      --  Look for Ada and foreign sources in a directory, according to the\n+      --  patterns. When Recursively is True, after looking for sources in\n+      --  Dir_Name, look also in its subdirectories, if any.\n \n-      if Project_File then\n+      -----------------------\n+      -- Process_Directory --\n+      -----------------------\n \n-         --  Delete the source list file, if it already exists\n+      procedure Process_Directory (Dir_Name : String; Recursively : Boolean) is\n+         Matched : Matched_Type := False;\n+         Str     : String (1 .. 2_000);\n+         Canon   : String (1 .. 2_000);\n+         Last    : Natural;\n+         Dir     : Dir_Type;\n+         Do_Process : Boolean := True;\n \n-         declare\n-            Discard : Boolean;\n-            pragma Warnings (Off, Discard);\n-         begin\n-            Delete_File\n-              (Source_List_Path (1 .. Source_List_Last),\n-               Success => Discard);\n-         end;\n+         Temp_File_Name         : String_Access := null;\n+         Save_Last_Source_Index : Natural := 0;\n+         File_Name_Id           : Name_Id := No_Name;\n \n-         --  And create a new source list file.\n-         --  Fail if file cannot be created.\n+         Current_Source : Source;\n \n-         Source_List_FD := Create_New_File\n-           (Name  => Source_List_Path (1 .. Source_List_Last),\n-            Fmode => Text);\n+      begin\n+         --  Avoid processing the same directory more than once\n \n-         if Source_List_FD = Invalid_FD then\n-            Prj.Com.Fail\n-              (\"cannot create file \"\"\",\n-               Source_List_Path (1 .. Source_List_Last),\n-               \"\"\"\");\n-         end if;\n-      end if;\n+         for Index in 1 .. Processed_Directories.Last loop\n+            if Processed_Directories.Table (Index).all = Dir_Name then\n+               Do_Process := False;\n+               exit;\n+            end if;\n+         end loop;\n \n-      --  Compile the regular expressions. Fails immediately if any of\n-      --  the specified strings is in error.\n+         if Do_Process then\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Processing directory \"\"\");\n+               Output.Write_Str (Dir_Name);\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n \n-      for Index in Excluded_Expressions'Range loop\n-         if Very_Verbose then\n-            Output.Write_Str (\"Excluded pattern: \"\"\");\n-            Output.Write_Str (Excluded_Patterns (Index).all);\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n+            Processed_Directories. Increment_Last;\n+            Processed_Directories.Table (Processed_Directories.Last) :=\n+              new String'(Dir_Name);\n \n-         begin\n-            Excluded_Expressions (Index) :=\n-              Compile (Pattern => Excluded_Patterns (Index).all, Glob => True);\n-         exception\n-            when Error_In_Regexp =>\n-               Prj.Com.Fail\n-                 (\"invalid regular expression \"\"\",\n-                  Excluded_Patterns (Index).all,\n-                  \"\"\"\");\n-         end;\n-      end loop;\n+            --  Get the source file names from the directory. Fails if the\n+            --  directory does not exist.\n \n-      for Index in Foreign_Expressions'Range loop\n-         if Very_Verbose then\n-            Output.Write_Str (\"Foreign pattern: \"\"\");\n-            Output.Write_Str (Foreign_Patterns (Index).all);\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n+            begin\n+               Open (Dir, Dir_Name);\n+            exception\n+               when Directory_Error =>\n+                  Prj.Com.Fail (\"cannot open directory \"\"\", Dir_Name, \"\"\"\");\n+            end;\n \n-         begin\n-            Foreign_Expressions (Index) :=\n-              Compile (Pattern => Foreign_Patterns (Index).all, Glob => True);\n-         exception\n-            when Error_In_Regexp =>\n-               Prj.Com.Fail\n-                 (\"invalid regular expression \"\"\",\n-                  Foreign_Patterns (Index).all,\n-                  \"\"\"\");\n-         end;\n-      end loop;\n+            --  Process each regular file in the directory\n \n-      for Index in Regular_Expressions'Range loop\n-         if Very_Verbose then\n-            Output.Write_Str (\"Pattern: \"\"\");\n-            Output.Write_Str (Name_Patterns (Index).all);\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n+            File_Loop : loop\n+               Read (Dir, Str, Last);\n+               exit File_Loop when Last = 0;\n \n-         begin\n-            Regular_Expressions (Index) :=\n-              Compile (Pattern => Name_Patterns (Index).all, Glob => True);\n+               --  Copy the file name and put it in canonical case to match\n+               --  against the patterns that have themselves already been put\n+               --  in canonical case.\n \n-         exception\n-            when Error_In_Regexp =>\n-               Prj.Com.Fail\n-                 (\"invalid regular expression \"\"\",\n-                  Name_Patterns (Index).all,\n-                  \"\"\"\");\n-         end;\n-      end loop;\n+               Canon (1 .. Last) := Str (1 .. Last);\n+               Canonical_Case_File_Name (Canon (1 .. Last));\n \n-      if Project_File then\n-         if Opt.Verbose_Mode then\n-            Output.Write_Str (\"Naming project file name is \"\"\");\n-            Output.Write_Str\n-              (Project_Naming_File_Name (1 .. Project_Naming_Last));\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n+               if Is_Regular_File\n+                 (Dir_Name & Directory_Separator & Str (1 .. Last))\n+               then\n+                  Matched := True;\n \n-         --  If there were no already existing project file, or if the parsing\n-         --  was unsuccessful, create an empty project node with the correct\n-         --  name and its project declaration node.\n+                  Name_Len := Last;\n+                  Name_Buffer (1 .. Name_Len) := Str (1 .. Last);\n+                  File_Name_Id := Name_Find;\n \n-         if Project_Node = Empty_Node then\n-            Project_Node :=\n-              Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n-            Set_Name_Of (Project_Node, Tree, To => Output_Name_Id);\n-            Set_Project_Declaration_Of\n-              (Project_Node, Tree,\n-               To => Default_Project_Node\n-                 (Of_Kind => N_Project_Declaration, In_Tree => Tree));\n+                  --  First, check if the file name matches at least one of\n+                  --  the excluded expressions;\n \n-         end if;\n+                  for Index in Excluded_Patterns'Range loop\n+                     if\n+                       Match (Canon (1 .. Last), Excluded_Patterns (Index))\n+                     then\n+                        Matched := Excluded;\n+                        exit;\n+                     end if;\n+                  end loop;\n \n-         --  Create the naming project node, and add an attribute declaration\n-         --  for Source_Files as an empty list, to indicate there are no\n-         --  sources in the naming project.\n+                  --  If it does not match any of the excluded expressions,\n+                  --  check if the file name matches at least one of the\n+                  --  regular expressions.\n \n-         Project_Naming_Node :=\n-           Default_Project_Node (Of_Kind => N_Project, In_Tree => Tree);\n-         Set_Name_Of (Project_Naming_Node, Tree, To => Project_Naming_Id);\n-         Project_Naming_Decl :=\n-           Default_Project_Node\n-             (Of_Kind => N_Project_Declaration, In_Tree => Tree);\n-         Set_Project_Declaration_Of\n-           (Project_Naming_Node, Tree, Project_Naming_Decl);\n-         Naming_Package :=\n-           Default_Project_Node\n-             (Of_Kind => N_Package_Declaration, In_Tree => Tree);\n-         Set_Name_Of (Naming_Package, Tree, To => Name_Naming);\n+                  if Matched = True then\n+                     Matched := False;\n \n-         declare\n-            Decl_Item : constant Project_Node_Id :=\n-                          Default_Project_Node\n-                            (Of_Kind => N_Declarative_Item, In_Tree => Tree);\n+                     for Index in Name_Patterns'Range loop\n+                        if\n+                          Match\n+                            (Canon (1 .. Last), Name_Patterns (Index))\n+                        then\n+                           Matched := True;\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n \n-            Attribute : constant Project_Node_Id :=\n-                          Default_Project_Node\n-                            (Of_Kind       => N_Attribute_Declaration,\n-                             In_Tree       => Tree,\n-                             And_Expr_Kind => List);\n+                  if Very_Verbose\n+                    or else (Matched = True and then Opt.Verbose_Mode)\n+                  then\n+                     Output.Write_Str (\"   Checking \"\"\");\n+                     Output.Write_Str (Str (1 .. Last));\n+                     Output.Write_Line (\"\"\": \");\n+                  end if;\n \n-            Expression : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Expression,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => List);\n+                  --  If the file name matches one of the regular expressions,\n+                  --  parse it to get its unit name.\n \n-            Term      : constant Project_Node_Id :=\n-                          Default_Project_Node\n-                            (Of_Kind       => N_Term,\n-                             In_Tree       => Tree,\n-                             And_Expr_Kind => List);\n-\n-            Empty_List : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Literal_String_List,\n-                              In_Tree => Tree);\n-\n-         begin\n-            Set_First_Declarative_Item_Of\n-              (Project_Naming_Decl, Tree, To => Decl_Item);\n-            Set_Next_Declarative_Item (Decl_Item, Tree, Naming_Package);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n-            Set_Name_Of (Attribute, Tree, To => Name_Source_Files);\n-            Set_Expression_Of (Attribute, Tree, To => Expression);\n-            Set_First_Term (Expression, Tree, To => Term);\n-            Set_Current_Term (Term, Tree, To => Empty_List);\n-         end;\n+                  if Matched = True then\n+                     declare\n+                        FD : File_Descriptor;\n+                        Success : Boolean;\n+                        Saved_Output : File_Descriptor;\n+                        Saved_Error  : File_Descriptor;\n \n-         --  Add a with clause on the naming project in the main project, if\n-         --  there is not already one.\n+                     begin\n+                        --  If we don't have the path of the compiler yet,\n+                        --  get it now. The compiler name may have a prefix,\n+                        --  so we get the potentially prefixed name.\n \n-         declare\n-            With_Clause : Project_Node_Id :=\n-                                  First_With_Clause_Of (Project_Node, Tree);\n+                        if Gcc_Path = null then\n+                           declare\n+                              Prefix_Gcc : String_Access :=\n+                                             Program_Name (Gcc);\n+                           begin\n+                              Gcc_Path :=\n+                                Locate_Exec_On_Path (Prefix_Gcc.all);\n+                              Free (Prefix_Gcc);\n+                           end;\n \n-         begin\n-            while With_Clause /= Empty_Node loop\n-               exit when\n-                 Prj.Tree.Name_Of (With_Clause, Tree) = Project_Naming_Id;\n-               With_Clause := Next_With_Clause_Of (With_Clause, Tree);\n-            end loop;\n+                           if Gcc_Path = null then\n+                              Prj.Com.Fail (\"could not locate \" & Gcc);\n+                           end if;\n+                        end if;\n \n-            if With_Clause = Empty_Node then\n-               With_Clause := Default_Project_Node\n-                 (Of_Kind => N_With_Clause, In_Tree => Tree);\n-               Set_Next_With_Clause_Of\n-                 (With_Clause, Tree,\n-                  To => First_With_Clause_Of (Project_Node, Tree));\n-               Set_First_With_Clause_Of\n-                 (Project_Node, Tree, To => With_Clause);\n-               Set_Name_Of (With_Clause, Tree, To => Project_Naming_Id);\n+                        --  If we don't have yet the file name of the\n+                        --  temporary file, get it now.\n \n-               --  We set the project node to something different than\n-               --  Empty_Node, so that Prj.PP does not generate a limited\n-               --  with clause.\n+                        if Temp_File_Name = null then\n+                           Create_Temp_File (FD, Temp_File_Name);\n \n-               Set_Project_Node_Of (With_Clause, Tree, Non_Empty_Node);\n+                           if FD = Invalid_FD then\n+                              Prj.Com.Fail\n+                                (\"could not create temporary file\");\n+                           end if;\n \n-               Name_Len := Project_Naming_Last;\n-               Name_Buffer (1 .. Name_Len) :=\n-                 Project_Naming_File_Name (1 .. Project_Naming_Last);\n-               Set_String_Value_Of (With_Clause, Tree, To => Name_Find);\n-            end if;\n-         end;\n+                           Close (FD);\n+                           Delete_File (Temp_File_Name.all, Success);\n+                        end if;\n \n-         Project_Declaration := Project_Declaration_Of (Project_Node, Tree);\n+                        Args (Args'Last) := new String'\n+                          (Dir_Name &\n+                           Directory_Separator &\n+                           Str (1 .. Last));\n \n-         --  Add a renaming declaration for package Naming in the main project\n+                        --  Create the temporary file\n \n-         declare\n-            Decl_Item  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Declarative_Item,\n-                              In_Tree => Tree);\n+                        FD := Create_Output_Text_File\n+                          (Name => Temp_File_Name.all);\n \n-            Naming : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Package_Declaration,\n-                              In_Tree => Tree);\n+                        if FD = Invalid_FD then\n+                           Prj.Com.Fail\n+                             (\"could not create temporary file\");\n+                        end if;\n \n-         begin\n-            Set_Next_Declarative_Item\n-              (Decl_Item, Tree,\n-               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n-            Set_First_Declarative_Item_Of\n-              (Project_Declaration, Tree, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Naming);\n-            Set_Name_Of (Naming, Tree, To => Name_Naming);\n-            Set_Project_Of_Renamed_Package_Of\n-              (Naming, Tree, To => Project_Naming_Node);\n+                        --  Save the standard output and error\n \n-            --  Attach the comments, if any, that were saved for package\n-            --  Naming.\n+                        Saved_Output := Dup (Standout);\n+                        Saved_Error  := Dup (Standerr);\n \n-            Tree.Project_Nodes.Table (Naming).Comments :=\n-              Naming_Package_Comments;\n-         end;\n+                        --  Set standard output and error to the temporary file\n \n-         --  Add an attribute declaration for Source_Dirs, initialized as an\n-         --  empty list. Directories will be added as they are read from the\n-         --  directory list file.\n+                        Dup2 (FD, Standout);\n+                        Dup2 (FD, Standerr);\n \n-         declare\n-            Decl_Item  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Declarative_Item,\n-                              In_Tree => Tree);\n+                        --  And spawn the compiler\n \n-            Attribute : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Attribute_Declaration,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => List);\n+                        Spawn (Gcc_Path.all, Args.all, Success);\n \n-            Expression : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Expression,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => List);\n+                        --  Restore the standard output and error\n \n-            Term  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Term, In_Tree => Tree,\n-                              And_Expr_Kind => List);\n+                        Dup2 (Saved_Output, Standout);\n+                        Dup2 (Saved_Error, Standerr);\n \n-         begin\n-            Set_Next_Declarative_Item\n-              (Decl_Item, Tree,\n-               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n-            Set_First_Declarative_Item_Of\n-              (Project_Declaration, Tree, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n-            Set_Name_Of (Attribute, Tree, To => Name_Source_Dirs);\n-            Set_Expression_Of (Attribute, Tree, To => Expression);\n-            Set_First_Term (Expression, Tree, To => Term);\n-            Source_Dirs_List :=\n-              Default_Project_Node\n-                (Of_Kind       => N_Literal_String_List,\n-                 In_Tree       => Tree,\n-                 And_Expr_Kind => List);\n-            Set_Current_Term (Term, Tree, To => Source_Dirs_List);\n+                        --  Close the temporary file\n \n-            --  Attach the comments, if any, that were saved for attribute\n-            --  Source_Dirs.\n+                        Close (FD);\n \n-            Tree.Project_Nodes.Table (Attribute).Comments :=\n-              Source_Dirs_Comments;\n-         end;\n+                        --  And close the saved standard output and error to\n+                        --  avoid too many file descriptors.\n \n-         --  Add an attribute declaration for Source_List_File with the\n-         --  source list file name that will be created.\n+                        Close (Saved_Output);\n+                        Close (Saved_Error);\n \n-         declare\n-            Decl_Item  : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind => N_Declarative_Item,\n-                              In_Tree => Tree);\n+                        --  Now that standard output is restored, check if\n+                        --  the compiler ran correctly.\n \n-            Attribute  : constant Project_Node_Id :=\n-                            Default_Project_Node\n-                              (Of_Kind       => N_Attribute_Declaration,\n-                               In_Tree       => Tree,\n-                               And_Expr_Kind => Single);\n+                        --  Read the lines of the temporary file:\n+                        --  they should contain the kind and name of the unit.\n \n-            Expression : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Expression,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => Single);\n+                        declare\n+                           File      : Text_File;\n+                           Text_Line : String (1 .. 1_000);\n+                           Text_Last : Natural;\n \n-            Term       : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Term,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => Single);\n+                        begin\n+                           Open (File, Temp_File_Name.all);\n \n-            Value      : constant Project_Node_Id :=\n-                           Default_Project_Node\n-                             (Of_Kind       => N_Literal_String,\n-                              In_Tree       => Tree,\n-                              And_Expr_Kind => Single);\n+                           if not Is_Valid (File) then\n+                              Prj.Com.Fail\n+                                (\"could not read temporary file\");\n+                           end if;\n \n-         begin\n-            Set_Next_Declarative_Item\n-              (Decl_Item, Tree,\n-               To => First_Declarative_Item_Of (Project_Declaration, Tree));\n-            Set_First_Declarative_Item_Of\n-              (Project_Declaration, Tree, To => Decl_Item);\n-            Set_Current_Item_Node (Decl_Item, Tree, To => Attribute);\n-            Set_Name_Of (Attribute, Tree, To => Name_Source_List_File);\n-            Set_Expression_Of (Attribute, Tree, To => Expression);\n-            Set_First_Term (Expression, Tree, To => Term);\n-            Set_Current_Term (Term, Tree, To => Value);\n-            Name_Len := Source_List_Last;\n-            Name_Buffer (1 .. Name_Len) :=\n-              Source_List_Path (1 .. Source_List_Last);\n-            Set_String_Value_Of (Value, Tree, To => Name_Find);\n+                           Save_Last_Source_Index := Sources.Last;\n \n-            --  If there was no comments for attribute Source_List_File, put\n-            --  those for Source_Files, if they exist.\n+                           if End_Of_File (File) then\n+                              if Opt.Verbose_Mode then\n+                                 if not Success then\n+                                    Output.Write_Str (\"      (process died) \");\n+                                 end if;\n+                              end if;\n \n-            if Source_List_File_Comments /= Empty_Node then\n-               Tree.Project_Nodes.Table (Attribute).Comments :=\n-                 Source_List_File_Comments;\n-            else\n-               Tree.Project_Nodes.Table (Attribute).Comments :=\n-                 Source_Files_Comments;\n-            end if;\n-         end;\n-      end if;\n+                           else\n+                              Line_Loop : while not End_Of_File (File) loop\n+                                 Get_Line (File, Text_Line, Text_Last);\n \n-      --  Process each directory\n+                                 --  Find the first closing parenthesis\n \n-      for Index in Directories'Range  loop\n+                                 Char_Loop : for J in 1 .. Text_Last loop\n+                                    if Text_Line (J) = ')' then\n+                                       if J >= 13 and then\n+                                         Text_Line (1 .. 4) = \"Unit\"\n+                                       then\n+                                          --  Add entry to Sources table\n \n-         declare\n-            Dir_Name    : constant String := Directories (Index).all;\n-            Last        : Natural := Dir_Name'Last;\n-            Recursively : Boolean := False;\n+                                          Name_Len := J - 12;\n+                                          Name_Buffer (1 .. Name_Len) :=\n+                                            Text_Line (6 .. J - 7);\n+                                          Current_Source :=\n+                                            (Unit_Name  => Name_Find,\n+                                             File_Name  => File_Name_Id,\n+                                             Index => 0,\n+                                             Spec  => Text_Line (J - 5 .. J) =\n+                                                        \"(spec)\");\n \n-         begin\n-            if Dir_Name'Length >= 4\n-              and then (Dir_Name (Last - 2 .. Last) = \"/**\")\n-            then\n-               Last := Last - 3;\n-               Recursively := True;\n-            end if;\n+                                          Sources.Append (Current_Source);\n+                                       end if;\n \n-            if Project_File then\n+                                       exit Char_Loop;\n+                                    end if;\n+                                 end loop Char_Loop;\n+                              end loop Line_Loop;\n+                           end if;\n \n-               --  Add the directory in the list for attribute Source_Dirs\n+                           if Save_Last_Source_Index = Sources.Last then\n+                              if Opt.Verbose_Mode then\n+                                 Output.Write_Line (\"      not a unit\");\n+                              end if;\n \n-               declare\n-                  Expression : constant Project_Node_Id :=\n-                                 Default_Project_Node\n-                                   (Of_Kind       => N_Expression,\n-                                    In_Tree       => Tree,\n-                                    And_Expr_Kind => Single);\n-\n-                  Term       : constant Project_Node_Id :=\n-                                 Default_Project_Node\n-                                   (Of_Kind       => N_Term,\n-                                    In_Tree       => Tree,\n-                                    And_Expr_Kind => Single);\n-\n-                  Value      : constant Project_Node_Id :=\n-                                 Default_Project_Node\n-                                   (Of_Kind       => N_Literal_String,\n-                                    In_Tree       => Tree,\n-                                    And_Expr_Kind => Single);\n+                           else\n+                              if Sources.Last >\n+                                   Save_Last_Source_Index + 1\n+                              then\n+                                 for Index in Save_Last_Source_Index + 1 ..\n+                                                Sources.Last\n+                                 loop\n+                                    Sources.Table (Index).Index :=\n+                                      Int (Index - Save_Last_Source_Index);\n+                                 end loop;\n+                              end if;\n \n-               begin\n-                  if Current_Source_Dir = Empty_Node then\n-                     Set_First_Expression_In_List\n-                       (Source_Dirs_List, Tree, To => Expression);\n-                  else\n-                     Set_Next_Expression_In_List\n-                       (Current_Source_Dir, Tree, To => Expression);\n-                  end if;\n+                              for Index in Save_Last_Source_Index + 1 ..\n+                                             Sources.Last\n+                              loop\n+                                 Current_Source := Sources.Table (Index);\n \n-                  Current_Source_Dir := Expression;\n-                  Set_First_Term (Expression, Tree, To => Term);\n-                  Set_Current_Term (Term, Tree, To => Value);\n-                  Name_Len := Dir_Name'Length;\n-                  Name_Buffer (1 .. Name_Len) := Dir_Name;\n-                  Set_String_Value_Of (Value, Tree, To => Name_Find);\n-               end;\n-            end if;\n+                                 if Opt.Verbose_Mode then\n+                                    if Current_Source.Spec then\n+                                       Output.Write_Str (\"      spec of \");\n \n-            Process_Directory (Dir_Name (Dir_Name'First .. Last), Recursively);\n-         end;\n+                                    else\n+                                       Output.Write_Str (\"      body of \");\n+                                    end if;\n \n-      end loop;\n+                                    Output.Write_Line\n+                                      (Get_Name_String\n+                                         (Current_Source.Unit_Name));\n+                                 end if;\n+                              end loop;\n+                           end if;\n \n-      if Project_File then\n-         Close (Source_List_FD);\n-      end if;\n+                           Close (File);\n \n-      declare\n-         Discard : Boolean;\n-         pragma Warnings (Off, Discard);\n+                           Delete_File (Temp_File_Name.all, Success);\n+                        end;\n+                     end;\n \n-      begin\n-         --  Delete the file if it already exists\n+                  --  File name matches none of the regular expressions\n \n-         Delete_File\n-           (Path_Name (Directory_Last + 1 .. Path_Last),\n-            Success => Discard);\n+                  else\n+                     --  If file is not excluded, see if this is foreign source\n \n-         --  Create a new one\n+                     if Matched /= Excluded then\n+                        for Index in Foreign_Patterns'Range loop\n+                           if Match (Canon (1 .. Last),\n+                                     Foreign_Patterns (Index))\n+                           then\n+                              Matched := True;\n+                              exit;\n+                           end if;\n+                        end loop;\n+                     end if;\n \n-         if Opt.Verbose_Mode then\n-            Output.Write_Str (\"Creating new file \"\"\");\n-            Output.Write_Str (Path_Name (Directory_Last + 1 .. Path_Last));\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n+                     if Very_Verbose then\n+                        case Matched is\n+                           when False =>\n+                              Output.Write_Line (\"no match\");\n \n-         Output_FD := Create_New_File\n-           (Path_Name (Directory_Last + 1 .. Path_Last),\n-            Fmode => Text);\n+                           when Excluded =>\n+                              Output.Write_Line (\"excluded\");\n \n-         --  Fails if project file cannot be created\n+                           when True =>\n+                              Output.Write_Line (\"foreign source\");\n+                        end case;\n+                     end if;\n \n-         if Output_FD = Invalid_FD then\n-            Prj.Com.Fail\n-              (\"cannot create new \"\"\", Path_Name (1 .. Path_Last), \"\"\"\");\n-         end if;\n+                     if Matched = True then\n \n-         if Project_File then\n+                        --  Add source file name without unit name\n \n-            --  Output the project file\n+                        Name_Len := 0;\n+                        Add_Str_To_Name_Buffer (Canon (1 .. Last));\n+                        Sources.Append\n+                          ((File_Name => Name_Find,\n+                            Unit_Name => No_Name,\n+                            Index     => 0,\n+                            Spec      => False));\n+                     end if;\n+                  end if;\n+               end if;\n+            end loop File_Loop;\n \n-            Prj.PP.Pretty_Print\n-              (Project_Node, Tree,\n-               W_Char => Write_A_Char'Access,\n-               W_Eol  => Write_Eol'Access,\n-               W_Str  => Write_A_String'Access,\n-               Backward_Compatibility => False);\n-            Close (Output_FD);\n+            Close (Dir);\n+         end if;\n \n-            --  Delete the naming project file if it already exists\n+         --  If Recursively is True, call itself for each subdirectory.\n+         --  We do that, even when this directory has already been processed,\n+         --  because all of its subdirectories may not have been processed.\n \n-            Delete_File\n-              (Project_Naming_File_Name (1 .. Project_Naming_Last),\n-               Success => Discard);\n+         if Recursively then\n+            Open (Dir, Dir_Name);\n \n-            --  Create a new one\n+            loop\n+               Read (Dir, Str, Last);\n+               exit when Last = 0;\n \n-            if Opt.Verbose_Mode then\n-               Output.Write_Str (\"Creating new naming project file \"\"\");\n-               Output.Write_Str (Project_Naming_File_Name\n-                                   (1 .. Project_Naming_Last));\n-               Output.Write_Line (\"\"\"\");\n-            end if;\n+               --  Do not call itself for \".\" or \"..\"\n \n-            Output_FD := Create_New_File\n-              (Project_Naming_File_Name (1 .. Project_Naming_Last),\n-               Fmode => Text);\n+               if Is_Directory\n+                 (Dir_Name & Directory_Separator & Str (1 .. Last))\n+                 and then Str (1 .. Last) /= \".\"\n+                 and then Str (1 .. Last) /= \"..\"\n+               then\n+                  Process_Directory\n+                    (Dir_Name & Directory_Separator & Str (1 .. Last),\n+                     Recursively => True);\n+               end if;\n+            end loop;\n \n-            --  Fails if naming project file cannot be created\n+            Close (Dir);\n+         end if;\n+      end Process_Directory;\n \n-            if Output_FD = Invalid_FD then\n-               Prj.Com.Fail\n-                 (\"cannot create new \"\"\",\n-                  Project_Naming_File_Name (1 .. Project_Naming_Last),\n-                  \"\"\"\");\n-            end if;\n+   --  Start of processing for Process\n \n-            --  Output the naming project file\n+   begin\n+      Processed_Directories.Set_Last (0);\n \n-            Prj.PP.Pretty_Print\n-              (Project_Naming_Node, Tree,\n-               W_Char => Write_A_Char'Access,\n-               W_Eol  => Write_Eol'Access,\n-               W_Str  => Write_A_String'Access,\n-               Backward_Compatibility => False);\n-            Close (Output_FD);\n+      --  Process each directory\n \n-         else\n-            --  Write to the output file each entry in the SFN_Pragmas table\n-            --  as an pragma Source_File_Name.\n+      for Index in Directories'Range  loop\n \n-            for Index in 1 .. SFN_Pragmas.Last loop\n-               Write_A_String (\"pragma Source_File_Name\");\n-               Write_Eol;\n-               Write_A_String (\"  (\");\n-               Write_A_String\n-                 (Get_Name_String (SFN_Pragmas.Table (Index).Unit));\n-               Write_A_String (\",\");\n-               Write_Eol;\n+         declare\n+            Dir_Name    : constant String := Directories (Index).all;\n+            Last        : Natural := Dir_Name'Last;\n+            Recursively : Boolean := False;\n+            Found       : Boolean;\n+            Canonical   : String (1 .. Dir_Name'Length) := Dir_Name;\n \n-               if SFN_Pragmas.Table (Index).Spec then\n-                  Write_A_String (\"   Spec_File_Name => \"\"\");\n+         begin\n+            Canonical_Case_File_Name (Canonical);\n \n-               else\n-                  Write_A_String (\"   Body_File_Name => \"\"\");\n+            Found := False;\n+            for J in 1 .. Source_Directories.Last loop\n+               if Source_Directories.Table (J).all = Canonical then\n+                  Found := True;\n+                  exit;\n                end if;\n+            end loop;\n \n-               Write_A_String\n-                 (Get_Name_String (SFN_Pragmas.Table (Index).File));\n-\n-               Write_A_String (\"\"\"\");\n-\n-               if SFN_Pragmas.Table (Index).Index /= 0 then\n-                  Write_A_String (\", Index =>\");\n-                  Write_A_String (SFN_Pragmas.Table (Index).Index'Img);\n-               end if;\n+            if not Found then\n+               Source_Directories.Append (new String'(Canonical));\n+            end if;\n \n-               Write_A_String (\");\");\n-               Write_Eol;\n-            end loop;\n+            if Dir_Name'Length >= 4\n+              and then (Dir_Name (Last - 2 .. Last) = \"/**\")\n+            then\n+               Last := Last - 3;\n+               Recursively := True;\n+            end if;\n \n-            Close (Output_FD);\n-         end if;\n-      end;\n+            Process_Directory (Dir_Name (Dir_Name'First .. Last), Recursively);\n+         end;\n \n-   end Make;\n+      end loop;\n+   end Process;\n \n    ----------------\n    -- Write_Char --"}, {"sha": "50a97e93b513a4dc187708315a6bb2a735d6cf4e", "filename": "gcc/ada/prj-makr.ads", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-makr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-makr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.ads?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,44 +25,58 @@\n \n --  Support for procedure Gnatname\n \n---  For arbitrary naming schemes, create or update a project file,\n---  or create a configuration pragmas file.\n+--  For arbitrary naming schemes, create or update a project file, or create a\n+--  configuration pragmas file.\n+\n+with System.Regexp; use System.Regexp;\n \n package Prj.Makr is\n \n-   procedure Make\n+   procedure Initialize\n      (File_Path         : String;\n       Project_File      : Boolean;\n-      Directories       : Argument_List;\n-      Name_Patterns     : Argument_List;\n-      Excluded_Patterns : Argument_List;\n-      Foreign_Patterns  : Argument_List;\n       Preproc_Switches  : Argument_List;\n       Very_Verbose      : Boolean);\n-   --  Create a project file or a configuration pragmas file\n+   --  Start the creation of a configuration pragmas file or the creation or\n+   --  modification of a project file, for gnatname.\n+   --\n+   --  When Project_File is False, File_Path is the name of a configuration\n+   --  pragmas file to create. When Project_File is True, File_Path is the name\n+   --  of a project file to create if it does not exist or to modify if it\n+   --  already exists.\n+   --\n+   --  Preproc_Switches is a list of switches to be used when invoking the\n+   --  compiler to get the name and kind of unit of a source file.\n+   --\n+   --  Very_Verbose controls the verbosity of the output, in conjunction with\n+   --  Opt.Verbose_Mode.\n+\n+   type Regexp_List is array (Positive range <>) of Regexp;\n+\n+   procedure Process\n+     (Directories       : Argument_List;\n+      Name_Patterns     : Regexp_List;\n+      Excluded_Patterns : Regexp_List;\n+      Foreign_Patterns  : Regexp_List);\n+   --  Look for source files in the specified directories, with the specified\n+   --  patterns.\n+   --\n+   --  Directories is the list of source directories where to look for sources.\n    --\n-   --  Project_File is the path name of the project file. If the project\n-   --  file already exists parse it and keep all the elements that are not\n-   --  automatically generated.\n+   --  Name_Patterns is a potentially empty list of file name patterns to check\n+   --  for Ada Sources.\n    --\n-   --  Directory_List_File is the path name of a text file that\n-   --  contains on each non empty line the path names of the source\n-   --  directories for the project file. The source directories\n-   --  are relative to the directory of the project file.\n+   --  Excluded_Patterns is a potentially empty list of file name patterns that\n+   --  should not be checked for Ada or non Ada sources.\n    --\n-   --  File_Name_Patterns is a GNAT.Regexp string pattern such as\n-   --  \".*\\.ads|.*\\.adb\" or any other pattern.\n+   --  Foreign_Patterns is a potentially empty list of file name patterns to\n+   --  check for non Ada sources.\n    --\n-   --  A project file (without any sources) is automatically generated\n-   --  with the name <project>_naming. It contains a package Naming with\n-   --  all the specs and bodies for the project.\n-   --  A file containing the source file names is automatically\n-   --  generated and used as the Source_File_List for the project file.\n-   --  It includes all sources that follow the Foreign_Patterns (except those\n-   --  that follow Excluded_Patterns).\n+   --  At least one of Name_Patterns and Foreign_Patterns is not empty\n \n-   --  Preproc_switches is a list of optional preprocessor switches -gnatep=\n-   --  and -gnateD that are used when invoking the compiler to find the\n-   --  unit name and kind.\n+   procedure Finalize;\n+   --  Write the configuration pragmas file or the project file indicated in a\n+   --  call to procedure Initialize, after one or several calls to procedure\n+   --  Process.\n \n end Prj.Makr;"}, {"sha": "01cef315b7d2f36c658b309c9e0d6ec0c83cd8ac", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 474, "deletions": 166, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -138,6 +138,9 @@ package body Prj.Nmsc is\n       Unit : Name_Id;\n       Next : Ada_Naming_Exception_Id := No_Ada_Naming_Exception;\n    end record;\n+   --  Comment needed???\n+\n+   --  Why is the following commented out ???\n    --  No_Unit : constant Unit_Info :=\n    --              (Specification, No_Name, No_Ada_Naming_Exception);\n \n@@ -165,6 +168,7 @@ package body Prj.Nmsc is\n       Location : Source_Ptr      := No_Location;\n    end record;\n    No_File_Found : constant File_Found := (No_File, False, No_Location);\n+   --  Comments needed ???\n \n    package Excluded_Sources_Htable is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n@@ -223,6 +227,7 @@ package body Prj.Nmsc is\n    --  Add a new source to the different lists: list of all sources in the\n    --  project tree, list of source of a project and list of sources of a\n    --  language.\n+   --\n    --  If Path is specified, the file is also added to Source_Paths_HT.\n    --  If Source_To_Replace is specified, it points to the source in the\n    --  extended project that the new file is overriding.\n@@ -272,6 +277,13 @@ package body Prj.Nmsc is\n    --  Check attribute Externally_Built of project Project in project tree\n    --  In_Tree and modify its data Data if it has the value \"true\".\n \n+   procedure Check_Interfaces\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref;\n+      Data    : in out Project_Data);\n+   --  If a list of sources is specified in attribute Interfaces, set\n+   --  In_Interfaces only for the sources specified in the list.\n+\n    procedure Check_Library_Attributes\n      (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n@@ -317,10 +329,10 @@ package body Prj.Nmsc is\n    --  efficiency to avoid system calls to recompute it.\n \n    procedure Get_Path_Names_And_Record_Ada_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      Current_Dir  : String);\n+     (Project     : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n+      Data        : in out Project_Data;\n+      Current_Dir : String);\n    --  Find the path names of the source files in the Source_Names table\n    --  in the source directories and record those that are Ada sources.\n \n@@ -356,10 +368,10 @@ package body Prj.Nmsc is\n    --  a specified language.\n \n    procedure Search_Directories\n-     (Project           : Project_Id;\n-      In_Tree           : Project_Tree_Ref;\n-      Data              : in out Project_Data;\n-      For_All_Sources   : Boolean);\n+     (Project         : Project_Id;\n+      In_Tree         : Project_Tree_Ref;\n+      Data            : in out Project_Data;\n+      For_All_Sources : Boolean);\n    --  Search the source directories to find the sources.\n    --  If For_All_Sources is True, check each regular file name against the\n    --  naming schemes of the different languages. Otherwise consider only the\n@@ -407,8 +419,10 @@ package body Prj.Nmsc is\n       Kind                  : out Source_Kind);\n    --  Check if the file name File_Name conforms to one of the naming\n    --  schemes of the project.\n+   --\n    --  If the file does not match one of the naming schemes, set Language\n    --  to No_Language_Index.\n+   --\n    --  Filename is the name of the file being investigated. It has been\n    --  normalized (case-folded). File_Name is the same value.\n \n@@ -422,6 +436,7 @@ package body Prj.Nmsc is\n       Data    : in out Project_Data);\n    --  Get the object directory, the exec directory and the source directories\n    --  of a project.\n+   --\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n@@ -448,6 +463,7 @@ package body Prj.Nmsc is\n       Data        : in out Project_Data);\n    --  Process the Source_Files and Source_List_File attributes, and store\n    --  the list of source files into the Source_Names htable.\n+   --\n    --  Lang indicates which language is being processed when in Ada_Only mode\n    --  (all languages are processed anyway when in Multi_Language mode).\n \n@@ -488,24 +504,26 @@ package body Prj.Nmsc is\n    --  is True and Create is a non null string, an attempt is made to create\n    --  the directory. If the directory does not exist and Project_Setup is\n    --  false, then Dir and Display are set to No_Name.\n+   --\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n    procedure Look_For_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      Current_Dir  : String);\n+     (Project     : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n+      Data        : in out Project_Data;\n+      Current_Dir : String);\n    --  Find all the sources of project Project in project tree In_Tree and\n    --  update its Data accordingly.\n+   --\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n    function Path_Name_Of\n      (File_Name : File_Name_Type;\n       Directory : Path_Name_Type) return String;\n-   --  Returns the path name of a (non project) file.\n-   --  Returns an empty string if file cannot be found.\n+   --  Returns the path name of a (non project) file. Returns an empty string\n+   --  if file cannot be found.\n \n    procedure Prepare_Ada_Naming_Exceptions\n      (List    : Array_Element_Id;\n@@ -533,6 +551,7 @@ package body Prj.Nmsc is\n       Current_Dir     : String);\n    --  Put a unit in the list of units of a project, if the file name\n    --  corresponds to a valid unit name.\n+   --\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n@@ -542,9 +561,9 @@ package body Prj.Nmsc is\n       Data              : in out Project_Data;\n       Language          : Language_Index;\n       Naming_Exceptions : Boolean);\n-   --  Record the sources of a language in a project.\n-   --  When Naming_Exceptions is True, mark the found sources as such, to\n-   --  later remove those that are not named in a list of sources.\n+   --  Record the sources of a language in a project. When Naming_Exceptions is\n+   --  True, mark the found sources as such, to later remove those that are not\n+   --  named in a list of sources.\n \n    procedure Remove_Source\n      (Id          : Source_Id;\n@@ -555,10 +574,11 @@ package body Prj.Nmsc is\n    --  ??? needs comment\n \n    procedure Report_No_Sources\n-     (Project   : Project_Id;\n-      Lang_Name : String;\n-      In_Tree   : Project_Tree_Ref;\n-      Location  : Source_Ptr);\n+     (Project      : Project_Id;\n+      Lang_Name    : String;\n+      In_Tree      : Project_Tree_Ref;\n+      Location     : Source_Ptr;\n+      Continuation : Boolean := False);\n    --  Report an error or a warning depending on the value of When_No_Sources\n    --  when there are no sources for language Lang_Name.\n \n@@ -570,8 +590,8 @@ package body Prj.Nmsc is\n      (Language : Language_Index;\n       Naming   : Naming_Data;\n       In_Tree  : Project_Tree_Ref) return File_Name_Type;\n-   --  Get the suffix for the source of a language from a package naming.\n-   --  If not specified, return the default for the language.\n+   --  Get the suffix for the source of a language from a package naming. If\n+   --  not specified, return the default for the language.\n \n    procedure Warn_If_Not_Sources\n      (Project     : Project_Id;\n@@ -608,6 +628,8 @@ package body Prj.Nmsc is\n    is\n       Source   : constant Source_Id := Data.Last_Source;\n       Src_Data : Source_Data := No_Source_Data;\n+      Config   : constant Language_Config :=\n+                   In_Tree.Languages_Data.Table (Lang_Id).Config;\n \n    begin\n       --  This is a new source so create an entry for it in the Sources table\n@@ -639,6 +661,14 @@ package body Prj.Nmsc is\n       Src_Data.Kind                := Kind;\n       Src_Data.Alternate_Languages := Alternate_Languages;\n       Src_Data.Other_Part          := Other_Part;\n+\n+      Src_Data.Object_Exists := Config.Object_Generated;\n+      Src_Data.Object_Linked := Config.Objects_Linked;\n+\n+      if Other_Part /= No_Source then\n+         In_Tree.Sources.Table (Other_Part).Other_Part := Id;\n+      end if;\n+\n       Src_Data.Unit                := Unit;\n       Src_Data.Index               := Index;\n       Src_Data.File                := File_Name;\n@@ -741,8 +771,7 @@ package body Prj.Nmsc is\n \n       if Data.Qualifier = Dry and then Data.Source_Dirs /= Nil_String then\n          Error_Msg\n-           (Project,\n-            In_Tree,\n+           (Project, In_Tree,\n             \"an abstract project need to have no language, no sources or no \" &\n             \"source directories\",\n             Data.Location);\n@@ -804,6 +833,7 @@ package body Prj.Nmsc is\n                Src_Data      : Source_Data;\n                Alt_Lang      : Alternate_Language_Id;\n                Alt_Lang_Data : Alternate_Language_Data;\n+               Continuation  : Boolean := False;\n \n             begin\n                Language := Data.First_Language_Processing;\n@@ -835,7 +865,9 @@ package body Prj.Nmsc is\n                           (In_Tree.Languages_Data.Table\n                              (Language).Display_Name),\n                         In_Tree,\n-                        Data.Location);\n+                        Data.Location,\n+                        Continuation);\n+                     Continuation := True;\n                   end if;\n \n                   Language := In_Tree.Languages_Data.Table (Language).Next;\n@@ -844,6 +876,14 @@ package body Prj.Nmsc is\n          end if;\n       end if;\n \n+      if Get_Mode = Multi_Language then\n+\n+         --  If a list of sources is specified in attribute Interfaces, set\n+         --  In_Interfaces only for the sources specified in the list.\n+\n+         Check_Interfaces (Project, In_Tree, Data);\n+      end if;\n+\n       --  If it is a library project file, check if it is a standalone library\n \n       if Data.Library then\n@@ -2197,6 +2237,69 @@ package body Prj.Nmsc is\n                           (Lang_Index).Config.Runtime_Library_Dir :=\n                           Element.Value.Value;\n \n+                     when Name_Object_Generated =>\n+                        declare\n+                           pragma Unsuppress (All_Checks);\n+                           Value : Boolean;\n+\n+                        begin\n+                           Value :=\n+                             Boolean'Value\n+                               (Get_Name_String (Element.Value.Value));\n+\n+                           In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Object_Generated := Value;\n+\n+                           --  If no object is generated, no object may be\n+                           --  linked.\n+\n+                           if not Value then\n+                              In_Tree.Languages_Data.Table\n+                                (Lang_Index).Config.Objects_Linked := False;\n+                           end if;\n+\n+                        exception\n+                           when Constraint_Error =>\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"invalid value \"\"\"\n+                                 & Get_Name_String (Element.Value.Value)\n+                                 & \"\"\" for Object_Generated\",\n+                                 Element.Value.Location);\n+                        end;\n+\n+                     when Name_Objects_Linked =>\n+                        declare\n+                           pragma Unsuppress (All_Checks);\n+                           Value : Boolean;\n+\n+                        begin\n+                           Value :=\n+                             Boolean'Value\n+                               (Get_Name_String (Element.Value.Value));\n+\n+                           --  No change if Object_Generated is False, as this\n+                           --  forces Objects_Linked to be False too.\n+\n+                           if In_Tree.Languages_Data.Table\n+                             (Lang_Index).Config.Object_Generated\n+                           then\n+                              In_Tree.Languages_Data.Table\n+                                (Lang_Index).Config.Objects_Linked :=\n+                                Value;\n+                           end if;\n+\n+                        exception\n+                           when Constraint_Error =>\n+                              Error_Msg\n+                                (Project,\n+                                 In_Tree,\n+                                 \"invalid value \"\"\"\n+                                 & Get_Name_String (Element.Value.Value)\n+                                 & \"\"\" for Objects_Linked\",\n+                                 Element.Value.Location);\n+                        end;\n                      when others =>\n                         null;\n                   end case;\n@@ -2661,6 +2764,139 @@ package body Prj.Nmsc is\n       end if;\n    end Check_If_Externally_Built;\n \n+   ----------------------\n+   -- Check_Interfaces --\n+   ----------------------\n+\n+   procedure Check_Interfaces\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref;\n+      Data    : in out Project_Data)\n+   is\n+      Interfaces : constant Prj.Variable_Value :=\n+                     Prj.Util.Value_Of\n+                       (Snames.Name_Interfaces,\n+                        Data.Decl.Attributes,\n+                        In_Tree);\n+\n+      List    : String_List_Id;\n+      Element : String_Element;\n+      Name    : File_Name_Type;\n+\n+      Source   : Source_Id;\n+      Src_Data : Source_Data;\n+\n+      Project_2 : Project_Id;\n+      Data_2     : Project_Data;\n+\n+   begin\n+      if not Interfaces.Default then\n+\n+         --  Set In_Interfaces to False for all sources. It will be set to True\n+         --  later for the sources in the Interfaces list.\n+\n+         Project_2 := Project;\n+         Data_2    := Data;\n+         loop\n+            Source := Data_2.First_Source;\n+            while Source /= No_Source loop\n+               Src_Data := In_Tree.Sources.Table (Source);\n+               Src_Data.In_Interfaces := False;\n+               In_Tree.Sources.Table (Source) := Src_Data;\n+               Source := Src_Data.Next_In_Project;\n+            end loop;\n+\n+            Project_2 := Data_2.Extends;\n+\n+            exit when Project_2 = No_Project;\n+\n+            Data_2 := In_Tree.Projects.Table (Project_2);\n+         end loop;\n+\n+         List := Interfaces.Values;\n+         while List /= Nil_String loop\n+            Element := In_Tree.String_Elements.Table (List);\n+            Get_Name_String (Element.Value);\n+            Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+            Name := Name_Find;\n+\n+            Project_2 := Project;\n+            Data_2 := Data;\n+            Big_Loop :\n+            loop\n+               Source := Data_2.First_Source;\n+               while Source /= No_Source loop\n+                  Src_Data := In_Tree.Sources.Table (Source);\n+                  if Src_Data.File = Name then\n+                     if not Src_Data.Locally_Removed then\n+                        In_Tree.Sources.Table (Source).In_Interfaces := True;\n+                        In_Tree.Sources.Table\n+                          (Source).Declared_In_Interfaces := True;\n+\n+                        if Src_Data.Other_Part /= No_Source then\n+                           In_Tree.Sources.Table\n+                             (Src_Data.Other_Part).In_Interfaces := True;\n+                           In_Tree.Sources.Table\n+                             (Src_Data.Other_Part).Declared_In_Interfaces :=\n+                             True;\n+                        end if;\n+\n+                        if Current_Verbosity = High then\n+                           Write_Str (\"   interface: \");\n+                           Write_Line (Get_Name_String (Src_Data.Path));\n+                        end if;\n+                     end if;\n+\n+                     exit Big_Loop;\n+                  end if;\n+\n+                  Source := Src_Data.Next_In_Project;\n+               end loop;\n+\n+               Project_2 := Data_2.Extends;\n+\n+               exit Big_Loop when Project_2 = No_Project;\n+\n+               Data_2 := In_Tree.Projects.Table (Project_2);\n+            end loop Big_Loop;\n+\n+            if Source = No_Source then\n+               Error_Msg_File_1 := File_Name_Type (Element.Value);\n+               Error_Msg_Name_1 := Data.Name;\n+\n+               Error_Msg\n+                 (Project,\n+                  In_Tree,\n+                  \"{ cannot be an interface of project %% \" &\n+                  \"as it is not one of its sources\",\n+                  Element.Location);\n+            end if;\n+\n+            List := Element.Next;\n+         end loop;\n+\n+         Data.Interfaces_Defined := True;\n+\n+      elsif Data.Extends /= No_Project then\n+         Data.Interfaces_Defined :=\n+           In_Tree.Projects.Table (Data.Extends).Interfaces_Defined;\n+\n+         if Data.Interfaces_Defined then\n+            Source := Data.First_Source;\n+            while Source /= No_Source loop\n+               Src_Data := In_Tree.Sources.Table (Source);\n+\n+               if not Src_Data.Declared_In_Interfaces then\n+                  Src_Data.In_Interfaces := False;\n+                  In_Tree.Sources.Table (Source) := Src_Data;\n+               end if;\n+\n+               Source := Src_Data.Next_In_Project;\n+            end loop;\n+         end if;\n+      end if;\n+   end Check_Interfaces;\n+\n    --------------------------\n    -- Check_Naming_Schemes --\n    --------------------------\n@@ -3616,17 +3852,17 @@ package body Prj.Nmsc is\n                         \"library project %% cannot extend project %% \" &\n                         \"that is not a library project\",\n                         Data.Location);\n+                     Continuation := Continuation_String'Access;\n \n-                  else\n+                  elsif Data.Library_Kind /= Static then\n                      Error_Msg\n                        (Project, In_Tree,\n                         Continuation.all &\n-                        \"library project %% cannot import project %% \" &\n-                        \"that is not a library project\",\n+                        \"shared library project %% cannot import project %% \" &\n+                        \"that is not a shared library project\",\n                         Data.Location);\n+                     Continuation := Continuation_String'Access;\n                   end if;\n-\n-                  Continuation := Continuation_String'Access;\n                end if;\n \n             elsif Data.Library_Kind /= Static and then\n@@ -5525,11 +5761,12 @@ package body Prj.Nmsc is\n \n       if Msg (First) = '\\' then\n          First := First + 1;\n+      end if;\n \n-         --  Warning character is always the first one in this package\n-         --  this is an undocumented kludge???\n+      --  Warning character is always the first one in this package\n+      --  this is an undocumented kludge???\n \n-      elsif Msg (First) = '?' then\n+      if Msg (First) = '?' then\n          First := First + 1;\n          Add (\"Warning: \");\n \n@@ -7364,7 +7601,9 @@ package body Prj.Nmsc is\n                end loop;\n \n                --  In Multi_Language mode, check whether the file is\n-               --  already there (??? Is this really needed, and why ?)\n+               --  already there: the same file name may be in the list; if\n+               --  the source is missing, the error will be on the first\n+               --  mention of the source file name.\n \n                case Get_Mode is\n                   when Ada_Only =>\n@@ -7475,6 +7714,62 @@ package body Prj.Nmsc is\n            (Project, In_Tree, Data,\n             For_All_Sources =>\n               Sources.Default and then Source_List_File.Default);\n+\n+         --  Check if all exceptions have been found.\n+         --  For Ada, it is an error if an exception is not found.\n+         --  For other language, the source is removed.\n+\n+         declare\n+            Source   : Source_Id;\n+            Src_Data : Source_Data;\n+\n+         begin\n+            Source := Data.First_Source;\n+            while Source /= No_Source loop\n+               Src_Data := In_Tree.Sources.Table (Source);\n+\n+               if Src_Data.Naming_Exception\n+                 and then Src_Data.Path = No_Path\n+               then\n+                  if Src_Data.Unit /= No_Name then\n+                     Error_Msg_Name_1 := Name_Id (Src_Data.Display_File);\n+                     Error_Msg_Name_2 := Name_Id (Src_Data.Unit);\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"source file %% for unit %% not found\",\n+                        No_Location);\n+\n+                  else\n+                     Remove_Source\n+                       (Source, No_Source, Project, Data, In_Tree);\n+                  end if;\n+               end if;\n+\n+               Source := Src_Data.Next_In_Project;\n+            end loop;\n+         end;\n+\n+         --  Check that all sources in Source_Files or the file\n+         --  Source_List_File has been found.\n+\n+         declare\n+            Name_Loc : Name_Location;\n+\n+         begin\n+            Name_Loc := Source_Names.Get_First;\n+            while Name_Loc /= No_Name_Location loop\n+               if (not Name_Loc.Except) and then (not Name_Loc.Found) then\n+                  Error_Msg_Name_1 := Name_Id (Name_Loc.Name);\n+                  Error_Msg\n+                    (Project,\n+                     In_Tree,\n+                     \"file %% not found\",\n+                     Name_Loc.Location);\n+               end if;\n+\n+               Name_Loc := Source_Names.Get_Next;\n+            end loop;\n+         end;\n       end if;\n \n       if Get_Mode = Ada_Only\n@@ -7496,12 +7791,12 @@ package body Prj.Nmsc is\n    -------------------------------------------\n \n    procedure Get_Path_Names_And_Record_Ada_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      Current_Dir  : String)\n+     (Project     : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n+      Data        : in out Project_Data;\n+      Current_Dir : String)\n    is\n-      Source_Dir      : String_List_Id := Data.Source_Dirs;\n+      Source_Dir      : String_List_Id;\n       Element         : String_Element;\n       Path            : Path_Name_Type;\n       Dir             : Dir_Type;\n@@ -7515,9 +7810,10 @@ package body Prj.Nmsc is\n       Source_Recorded : Boolean := False;\n \n    begin\n-      --  We look in all source directories for the file names in the\n-      --  hash table Source_Names\n+      --  We look in all source directories for the file names in the hash\n+      --  table Source_Names.\n \n+      Source_Dir := Data.Source_Dirs;\n       while Source_Dir /= Nil_String loop\n          Source_Recorded := False;\n          Element := In_Tree.String_Elements.Table (Source_Dir);\n@@ -8042,6 +8338,7 @@ package body Prj.Nmsc is\n       Alternate_Languages : Alternate_Language_Id := No_Alternate_Language;\n       Language          : Language_Index;\n       Source            : Source_Id;\n+      Other_Part        : Source_Id;\n       Add_Src           : Boolean;\n       Src_Ind           : Source_File_Index;\n       Src_Data          : Source_Data;\n@@ -8084,6 +8381,8 @@ package body Prj.Nmsc is\n          else\n             Name_Loc.Found := True;\n \n+            Source_Names.Set (File_Name, Name_Loc);\n+\n             if Name_Loc.Source = No_Source then\n                Check_Name := True;\n \n@@ -8115,6 +8414,8 @@ package body Prj.Nmsc is\n       end if;\n \n       if Check_Name then\n+         Other_Part := No_Source;\n+\n          Check_Naming_Schemes\n            (In_Tree               => In_Tree,\n             Data                  => Data,\n@@ -8149,11 +8450,16 @@ package body Prj.Nmsc is\n             while Source /= No_Source loop\n                Src_Data := In_Tree.Sources.Table (Source);\n \n-               if (Unit /= No_Name\n-                   and then Src_Data.Unit = Unit\n-                   and then Src_Data.Kind = Kind)\n-                 or else (Unit = No_Name\n-                          and then Src_Data.File = File_Name)\n+               if Unit /= No_Name\n+                 and then Src_Data.Unit = Unit\n+                 and then Src_Data.Kind /= Kind\n+               then\n+                  Other_Part := Source;\n+\n+               elsif (Unit /= No_Name\n+                       and then Src_Data.Unit = Unit\n+                       and then Src_Data.Kind = Kind)\n+                 or else (Unit = No_Name and then Src_Data.File = File_Name)\n                then\n                   --  Duplication of file/unit in same project is only\n                   --  allowed if order of source directories is known.\n@@ -8165,17 +8471,13 @@ package body Prj.Nmsc is\n                      elsif Unit /= No_Name then\n                         Error_Msg_Name_1 := Unit;\n                         Error_Msg\n-                          (Project, In_Tree,\n-                           \"duplicate unit %%\",\n-                           No_Location);\n+                          (Project, In_Tree, \"duplicate unit %%\", No_Location);\n                         Add_Src := False;\n \n                      else\n                         Error_Msg_File_1 := File_Name;\n                         Error_Msg\n-                          (Project, In_Tree,\n-                           \"duplicate source file \" &\n-                           \"name {\",\n+                          (Project, In_Tree, \"duplicate source file name {\",\n                            No_Location);\n                         Add_Src := False;\n                      end if;\n@@ -8203,17 +8505,13 @@ package body Prj.Nmsc is\n                      Error_Msg_Name_1 := In_Tree.Projects.Table (Project).Name;\n                      Error_Msg_Name_2 := Name_Id (Display_Path_Id);\n                      Error_Msg\n-                       (Project, In_Tree,\n-                        \"\\  project %%, %%\",\n-                        No_Location);\n+                       (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n \n                      Error_Msg_Name_1 :=\n                        In_Tree.Projects.Table (Src_Data.Project).Name;\n                      Error_Msg_Name_2 := Name_Id (Src_Data.Display_Path);\n                      Error_Msg\n-                       (Project, In_Tree,\n-                        \"\\  project %%, %%\",\n-                        No_Location);\n+                       (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n \n                      Add_Src := False;\n                   end if;\n@@ -8235,6 +8533,7 @@ package body Prj.Nmsc is\n                   Alternate_Languages => Alternate_Languages,\n                   File_Name           => File_Name,\n                   Display_File        => Display_File_Name,\n+                  Other_Part          => Other_Part,\n                   Unit                => Unit,\n                   Path                => Path_Id,\n                   Display_Path        => Display_Path_Id,\n@@ -8249,10 +8548,10 @@ package body Prj.Nmsc is\n    ------------------------\n \n    procedure Search_Directories\n-     (Project           : Project_Id;\n-      In_Tree           : Project_Tree_Ref;\n-      Data              : in out Project_Data;\n-      For_All_Sources   : Boolean)\n+     (Project         : Project_Id;\n+      In_Tree         : Project_Tree_Ref;\n+      Data            : in out Project_Data;\n+      For_All_Sources : Boolean)\n    is\n       Source_Dir        : String_List_Id;\n       Element           : String_Element;\n@@ -8278,11 +8577,12 @@ package body Prj.Nmsc is\n \n                declare\n                   Source_Directory : constant String :=\n-                    Name_Buffer (1 .. Name_Len) &\n-                  Directory_Separator;\n-                  Dir_Last         : constant Natural :=\n-                    Compute_Directory_Last\n-                      (Source_Directory);\n+                                       Name_Buffer (1 .. Name_Len) &\n+                                         Directory_Separator;\n+\n+                  Dir_Last : constant Natural :=\n+                                       Compute_Directory_Last\n+                                         (Source_Directory);\n \n                begin\n                   if Current_Verbosity = High then\n@@ -8302,6 +8602,7 @@ package body Prj.Nmsc is\n                      --  ??? Duplicate system call here, we just did a\n                      --  a similar one. Maybe Ada.Directories would be more\n                      --  appropriate here\n+\n                      if Is_Regular_File\n                        (Source_Directory & Name (1 .. Last))\n                      then\n@@ -8324,7 +8625,7 @@ package body Prj.Nmsc is\n \n                         declare\n                            FF : File_Found :=\n-                             Excluded_Sources_Htable.Get (File_Name);\n+                                  Excluded_Sources_Htable.Get (File_Name);\n \n                         begin\n                            if FF /= No_File_Found then\n@@ -8364,6 +8665,7 @@ package body Prj.Nmsc is\n             when Directory_Error =>\n                null;\n          end;\n+\n          Source_Dir := Element.Next;\n       end loop;\n \n@@ -8377,10 +8679,10 @@ package body Prj.Nmsc is\n    ----------------------\n \n    procedure Look_For_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      Current_Dir  : String)\n+     (Project     : Project_Id;\n+      In_Tree     : Project_Tree_Ref;\n+      Data        : in out Project_Data;\n+      Current_Dir : String)\n    is\n       procedure Remove_Locally_Removed_Files_From_Units;\n       --  Mark all locally removed sources as such in the Units table\n@@ -8396,11 +8698,13 @@ package body Prj.Nmsc is\n       ---------------------------------------------\n \n       procedure Remove_Locally_Removed_Files_From_Units is\n-         Excluded : File_Found := Excluded_Sources_Htable.Get_First;\n+         Excluded : File_Found;\n          OK       : Boolean;\n          Unit     : Unit_Data;\n          Extended : Project_Id;\n+\n       begin\n+         Excluded := Excluded_Sources_Htable.Get_First;\n          while Excluded /= No_File_Found loop\n             OK := False;\n \n@@ -8513,9 +8817,9 @@ package body Prj.Nmsc is\n                            File_Id := Name_Find;\n                         end if;\n \n-                        --  Put each naming exception in the Source_Names\n-                        --  hash table, but if there are repetition, don't\n-                        --  bother after the first instance.\n+                        --  Put each naming exception in the Source_Names hash\n+                        --  table, but if there are repetition, don't bother\n+                        --  after the first instance.\n \n                         if Source_Names.Get (File_Id) = No_Name_Location then\n                            Source_Found := True;\n@@ -8564,17 +8868,18 @@ package body Prj.Nmsc is\n       --------------------------------------------\n \n       procedure Process_Sources_In_Multi_Language_Mode is\n-         Source    : Source_Id := Data.First_Source;\n-         Src_Data  : Source_Data;\n-         Name_Loc  : Name_Location;\n-         OK        : Boolean;\n-         FF        : File_Found;\n+         Source   : Source_Id;\n+         Src_Data : Source_Data;\n+         Name_Loc : Name_Location;\n+         OK       : Boolean;\n+         FF       : File_Found;\n+\n       begin\n-         --  First, put all the naming exceptions, if any, in the Source_Names\n-         --  table.\n+         --  First, put all naming exceptions if any, in the Source_Names table\n \n          Unit_Exceptions.Reset;\n \n+         Source := Data.First_Source;\n          while Source /= No_Source loop\n             Src_Data := In_Tree.Sources.Table (Source);\n \n@@ -8585,8 +8890,7 @@ package body Prj.Nmsc is\n             then\n                Error_Msg_File_1 := Src_Data.File;\n                Error_Msg\n-                 (Project,\n-                  In_Tree,\n+                 (Project, In_Tree,\n                   \"{ cannot be both excluded and an exception file name\",\n                   No_Location);\n             end if;\n@@ -8612,7 +8916,7 @@ package body Prj.Nmsc is\n             if Src_Data.Unit /= No_Name then\n                declare\n                   Unit_Except : Unit_Exception :=\n-                    Unit_Exceptions.Get (Src_Data.Unit);\n+                                  Unit_Exceptions.Get (Src_Data.Unit);\n \n                begin\n                   Unit_Except.Name := Src_Data.Unit;\n@@ -8634,7 +8938,6 @@ package body Prj.Nmsc is\n            (Ada_Language_Index, Current_Dir, Project, In_Tree, Data);\n \n          FF := Excluded_Sources_Htable.Get_First;\n-\n          while FF /= No_File_Found loop\n             OK     := False;\n             Source := In_Tree.First_Source;\n@@ -8644,13 +8947,14 @@ package body Prj.Nmsc is\n \n                if Src_Data.File = FF.File then\n \n-                  --  Check that this is from this project or a\n-                  --  project that the current project extends.\n+                  --  Check that this is from this project or a project that\n+                  --  the current project extends.\n \n                   if Src_Data.Project = Project or else\n                     Is_Extending (Project, Src_Data.Project, In_Tree)\n                   then\n                      Src_Data.Locally_Removed := True;\n+                     Src_Data.In_Interfaces := False;\n                      In_Tree.Sources.Table (Source) := Src_Data;\n                      Add_Forbidden_File_Name (FF.File);\n                      OK := True;\n@@ -8772,6 +9076,7 @@ package body Prj.Nmsc is\n       In_Tree   : Project_Tree_Ref) return Boolean\n    is\n       Current : Project_Id := Extending;\n+\n    begin\n       loop\n          if Current = No_Project then\n@@ -8830,11 +9135,11 @@ package body Prj.Nmsc is\n \n          declare\n             Canonical_Path : constant String :=\n-              Normalize_Pathname\n-                (Get_Name_String (Path_Name),\n-                 Directory      => Current_Dir,\n-                 Resolve_Links  => Opt.Follow_Links_For_Files,\n-                 Case_Sensitive => False);\n+                               Normalize_Pathname\n+                                 (Get_Name_String (Path_Name),\n+                                  Directory      => Current_Dir,\n+                                  Resolve_Links  => Opt.Follow_Links_For_Files,\n+                                  Case_Sensitive => False);\n          begin\n             Name_Len := 0;\n             Add_Str_To_Name_Buffer (Canonical_Path);\n@@ -8854,8 +9159,8 @@ package body Prj.Nmsc is\n          Unit_Kind           => Unit_Kind,\n          Needs_Pragma        => Needs_Pragma);\n \n-      if Exception_Id = No_Ada_Naming_Exception and then\n-        Unit_Name = No_Name\n+      if Exception_Id = No_Ada_Naming_Exception\n+        and then Unit_Name = No_Name\n       then\n          if Current_Verbosity = High then\n             Write_Str  (\"   \"\"\");\n@@ -8902,31 +9207,27 @@ package body Prj.Nmsc is\n \n             --  Put the file name in the list of sources of the project\n \n-            String_Element_Table.Increment_Last\n-              (In_Tree.String_Elements);\n+            String_Element_Table.Increment_Last (In_Tree.String_Elements);\n             In_Tree.String_Elements.Table\n-              (String_Element_Table.Last\n-                 (In_Tree.String_Elements)) :=\n-              (Value         => Name_Id (Canonical_File_Name),\n-               Display_Value => Name_Id (File_Name),\n-               Location      => No_Location,\n-               Flag          => False,\n-               Next          => Nil_String,\n-               Index         => Unit_Ind);\n+              (String_Element_Table.Last (In_Tree.String_Elements)) :=\n+                (Value         => Name_Id (Canonical_File_Name),\n+                 Display_Value => Name_Id (File_Name),\n+                 Location      => No_Location,\n+                 Flag          => False,\n+                 Next          => Nil_String,\n+                 Index         => Unit_Ind);\n \n             if Current_Source = Nil_String then\n-               Data.Ada_Sources := String_Element_Table.Last\n-                 (In_Tree.String_Elements);\n+               Data.Ada_Sources :=\n+                 String_Element_Table.Last (In_Tree.String_Elements);\n                Data.Sources := Data.Ada_Sources;\n             else\n-               In_Tree.String_Elements.Table\n-                 (Current_Source).Next :=\n-                 String_Element_Table.Last\n-                   (In_Tree.String_Elements);\n+               In_Tree.String_Elements.Table (Current_Source).Next :=\n+                 String_Element_Table.Last (In_Tree.String_Elements);\n             end if;\n \n-            Current_Source := String_Element_Table.Last\n-                                (In_Tree.String_Elements);\n+            Current_Source :=\n+              String_Element_Table.Last (In_Tree.String_Elements);\n \n             --  Put the unit in unit list\n \n@@ -8951,9 +9252,9 @@ package body Prj.Nmsc is\n                   The_Unit_Data := In_Tree.Units.Table (The_Unit);\n \n                   if (The_Unit_Data.File_Names (Unit_Kind).Name =\n-                        Canonical_File_Name\n-                      and then\n-                      The_Unit_Data.File_Names (Unit_Kind).Path = Slash)\n+                                                          Canonical_File_Name\n+                        and then\n+                          The_Unit_Data.File_Names (Unit_Kind).Path = Slash)\n                     or else The_Unit_Data.File_Names (Unit_Kind).Name = No_File\n                     or else Project_Extends\n                       (Data.Extends,\n@@ -8981,21 +9282,21 @@ package body Prj.Nmsc is\n                         Display_Path => Path_Name,\n                         Project      => Project,\n                         Needs_Pragma => Needs_Pragma);\n-                     In_Tree.Units.Table (The_Unit) :=\n-                       The_Unit_Data;\n+                     In_Tree.Units.Table (The_Unit) := The_Unit_Data;\n                      Source_Recorded := True;\n \n                   elsif The_Unit_Data.File_Names (Unit_Kind).Project = Project\n-                    and then (Data.Known_Order_Of_Source_Dirs or else\n-                              The_Unit_Data.File_Names (Unit_Kind).Path =\n-                                Canonical_Path_Name)\n+                    and then (Data.Known_Order_Of_Source_Dirs\n+                                or else\n+                                  The_Unit_Data.File_Names (Unit_Kind).Path =\n+                                                           Canonical_Path_Name)\n                   then\n                      if Previous_Source = Nil_String then\n                         Data.Ada_Sources := Nil_String;\n                         Data.Sources := Nil_String;\n                      else\n-                        In_Tree.String_Elements.Table\n-                          (Previous_Source).Next := Nil_String;\n+                        In_Tree.String_Elements.Table (Previous_Source).Next :=\n+                          Nil_String;\n                         String_Element_Table.Decrement_Last\n                           (In_Tree.String_Elements);\n                      end if;\n@@ -9008,8 +9309,7 @@ package body Prj.Nmsc is\n \n                      if The_Location = No_Location then\n                         The_Location :=\n-                          In_Tree.Projects.Table\n-                            (Project).Location;\n+                          In_Tree.Projects.Table (Project).Location;\n                      end if;\n \n                      Err_Vars.Error_Msg_Name_1 := Unit_Name;\n@@ -9039,20 +9339,18 @@ package body Prj.Nmsc is\n \n                else\n                   --  First, check if there is no other unit with this file\n-                  --  name in another project. If it is, report an error.\n-                  --  Of course, we do that only for the first unit in the\n-                  --  source file.\n+                  --  name in another project. If it is, report error but note\n+                  --  we do that only for the first unit in the source file.\n \n-                  Unit_Prj := Files_Htable.Get\n-                    (In_Tree.Files_HT, Canonical_File_Name);\n+                  Unit_Prj :=\n+                    Files_Htable.Get (In_Tree.Files_HT, Canonical_File_Name);\n \n                   if not File_Name_Recorded and then\n                     Unit_Prj /= No_Unit_Project\n                   then\n                      Error_Msg_File_1 := File_Name;\n                      Error_Msg_Name_1 :=\n-                       In_Tree.Projects.Table\n-                         (Unit_Prj.Project).Name;\n+                       In_Tree.Projects.Table (Unit_Prj.Project).Name;\n                      Error_Msg\n                        (Project, In_Tree,\n                         \"{ is already a source of project %%\",\n@@ -9077,8 +9375,7 @@ package body Prj.Nmsc is\n                         Display_Path => Path_Name,\n                         Project      => Project,\n                         Needs_Pragma => Needs_Pragma);\n-                     In_Tree.Units.Table (The_Unit) :=\n-                       The_Unit_Data;\n+                     In_Tree.Units.Table (The_Unit) := The_Unit_Data;\n                      Source_Recorded := True;\n                   end if;\n                end if;\n@@ -9129,7 +9426,6 @@ package body Prj.Nmsc is\n \n                if Naming_Exceptions then\n                   Write_Str (\"naming exceptions\");\n-\n                else\n                   Write_Str (\"sources\");\n                end if;\n@@ -9205,15 +9501,13 @@ package body Prj.Nmsc is\n \n                if First_Error then\n                   Error_Msg\n-                    (Project, In_Tree,\n-                     \"source file { cannot be found\",\n+                    (Project, In_Tree, \"source file { cannot be found\",\n                      NL.Location);\n                   First_Error := False;\n \n                else\n                   Error_Msg\n-                    (Project, In_Tree,\n-                     \"\\source file { cannot be found\",\n+                    (Project, In_Tree, \"\\source file { cannot be found\",\n                      NL.Location);\n                end if;\n             end if;\n@@ -9225,11 +9519,13 @@ package body Prj.Nmsc is\n          --  of sources must be removed.\n \n          declare\n-            Source_Id : Other_Source_Id := Data.First_Other_Source;\n-            Prev_Id   : Other_Source_Id := No_Other_Source;\n+            Source_Id : Other_Source_Id;\n+            Prev_Id   : Other_Source_Id;\n             Source    : Other_Source;\n \n          begin\n+            Prev_Id := No_Other_Source;\n+            Source_Id := Data.First_Other_Source;\n             while Source_Id /= No_Other_Source loop\n                Source := In_Tree.Other_Sources.Table (Source_Id);\n \n@@ -9245,10 +9541,8 @@ package body Prj.Nmsc is\n \n                   if Prev_Id = No_Other_Source then\n                      Data.First_Other_Source := Source.Next;\n-\n                   else\n-                     In_Tree.Other_Sources.Table\n-                       (Prev_Id).Next := Source.Next;\n+                     In_Tree.Other_Sources.Table (Prev_Id).Next := Source.Next;\n                   end if;\n \n                   Source_Id := Source.Next;\n@@ -9278,7 +9572,6 @@ package body Prj.Nmsc is\n       In_Tree     : Project_Tree_Ref)\n    is\n       Src_Data : constant Source_Data := In_Tree.Sources.Table (Id);\n-\n       Source   : Source_Id;\n \n    begin\n@@ -9287,7 +9580,11 @@ package body Prj.Nmsc is\n          Write_Line (Id'Img);\n       end if;\n \n-      In_Tree.Sources.Table (Id).Replaced_By := Replaced_By;\n+      if Replaced_By /= No_Source then\n+         In_Tree.Sources.Table (Id).Replaced_By := Replaced_By;\n+         In_Tree.Sources.Table (Replaced_By).Declared_In_Interfaces :=\n+           In_Tree.Sources.Table (Id).Declared_In_Interfaces;\n+      end if;\n \n       --  Remove the source from the global source list\n \n@@ -9379,22 +9676,36 @@ package body Prj.Nmsc is\n    -----------------------\n \n    procedure Report_No_Sources\n-     (Project   : Project_Id;\n-      Lang_Name : String;\n-      In_Tree   : Project_Tree_Ref;\n-      Location  : Source_Ptr)\n+     (Project      : Project_Id;\n+      Lang_Name    : String;\n+      In_Tree      : Project_Tree_Ref;\n+      Location     : Source_Ptr;\n+      Continuation : Boolean := False)\n    is\n    begin\n       case When_No_Sources is\n          when Silent =>\n             null;\n \n          when Warning | Error =>\n-            Error_Msg_Warn := When_No_Sources = Warning;\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"<there are no \" & Lang_Name & \" sources in this project\",\n-               Location);\n+            declare\n+               Msg : constant String :=\n+                       \"<there are no \" &\n+                       Lang_Name &\n+                       \" sources in this project\";\n+\n+            begin\n+               Error_Msg_Warn := When_No_Sources = Warning;\n+\n+               if Continuation then\n+                  Error_Msg\n+                    (Project, In_Tree, \"\\\" & Msg, Location);\n+\n+               else\n+                  Error_Msg\n+                    (Project, In_Tree, Msg, Location);\n+               end if;\n+            end;\n       end case;\n    end Report_No_Sources;\n \n@@ -9438,6 +9749,7 @@ package body Prj.Nmsc is\n            Src_Index => 0,\n            In_Array  => Naming.Body_Suffix,\n            In_Tree   => In_Tree);\n+\n    begin\n       --  If no suffix for this language in package Naming, use the default\n \n@@ -9481,29 +9793,25 @@ package body Prj.Nmsc is\n       Specs       : Boolean;\n       Extending   : Boolean)\n    is\n-      Conv          : Array_Element_Id := Conventions;\n+      Conv          : Array_Element_Id;\n       Unit          : Name_Id;\n       The_Unit_Id   : Unit_Index;\n       The_Unit_Data : Unit_Data;\n       Location      : Source_Ptr;\n \n    begin\n+      Conv := Conventions;\n       while Conv /= No_Array_Element loop\n          Unit := In_Tree.Array_Elements.Table (Conv).Index;\n          Error_Msg_Name_1 := Unit;\n          Get_Name_String (Unit);\n          To_Lower (Name_Buffer (1 .. Name_Len));\n          Unit := Name_Find;\n-         The_Unit_Id := Units_Htable.Get\n-           (In_Tree.Units_HT, Unit);\n-         Location := In_Tree.Array_Elements.Table\n-                                            (Conv).Value.Location;\n+         The_Unit_Id := Units_Htable.Get (In_Tree.Units_HT, Unit);\n+         Location := In_Tree.Array_Elements.Table (Conv).Value.Location;\n \n          if The_Unit_Id = No_Unit_Index then\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"?unknown unit %%\",\n-               Location);\n+            Error_Msg (Project, In_Tree, \"?unknown unit %%\", Location);\n \n          else\n             The_Unit_Data := In_Tree.Units.Table (The_Unit_Id);"}, {"sha": "0cdd9ad3604a5440e6ff8b041232c9cbf7aab7b4", "filename": "gcc/ada/prj-pars.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -70,7 +70,7 @@ package body Prj.Pars is\n \n       --  If there were no error, process the tree\n \n-      if Project_Node /= Empty_Node then\n+      if Present (Project_Node) then\n          Prj.Proc.Process\n            (In_Tree                => In_Tree,\n             Project                => The_Project,"}, {"sha": "ab9208f9e94becd5479dc26979a37e7d068acf17", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 91, "deletions": 62, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -333,7 +333,8 @@ package body Prj.Part is\n          E => (Name           => Virtual_Name_Id,\n                Node           => Virtual_Project,\n                Canonical_Path => No_Path,\n-               Extended       => False));\n+               Extended       => False,\n+               Proj_Qualifier => Unspecified));\n    end Create_Virtual_Extending_Project;\n \n    ----------------------------\n@@ -396,32 +397,32 @@ package body Prj.Part is\n       --  Nothing to do if Proj is not defined or if it has already been\n       --  processed.\n \n-      if Proj /= Empty_Node and then not Processed_Hash.Get (Proj) then\n+      if Present (Proj) and then not Processed_Hash.Get (Proj) then\n          --  Make sure the project will not be processed again\n \n          Processed_Hash.Set (Proj, True);\n \n          Declaration := Project_Declaration_Of (Proj, In_Tree);\n \n-         if Declaration /= Empty_Node then\n+         if Present (Declaration) then\n             Extended := Extended_Project_Of (Declaration, In_Tree);\n          end if;\n \n          --  If this is a project that may need a virtual extending project\n          --  and it is not itself an extending project, put it in the list.\n \n-         if Potentially_Virtual and then Extended = Empty_Node then\n+         if Potentially_Virtual and then No (Extended) then\n             Virtual_Hash.Set (Proj, Proj);\n          end if;\n \n          --  Now check the projects it imports\n \n          With_Clause := First_With_Clause_Of (Proj, In_Tree);\n \n-         while With_Clause /= Empty_Node loop\n+         while Present (With_Clause) loop\n             Imported := Project_Node_Of (With_Clause, In_Tree);\n \n-            if Imported /= Empty_Node then\n+            if Present (Imported) then\n                Look_For_Virtual_Projects_For\n                  (Imported, In_Tree, Potentially_Virtual => True);\n             end if;\n@@ -512,7 +513,7 @@ package body Prj.Part is\n          --  virtual extending projects and check that there are no illegally\n          --  imported projects.\n \n-         if Project /= Empty_Node\n+         if Present (Project)\n            and then Is_Extending_All (Project, In_Tree)\n          then\n             --  First look for projects that potentially need a virtual\n@@ -549,10 +550,10 @@ package body Prj.Part is\n \n             begin\n                With_Clause := First_With_Clause_Of (Project, In_Tree);\n-               while With_Clause /= Empty_Node loop\n+               while Present (With_Clause) loop\n                   Imported := Project_Node_Of (With_Clause, In_Tree);\n \n-                  if Imported /= Empty_Node then\n+                  if Present (Imported) then\n                      Declaration := Project_Declaration_Of (Imported, In_Tree);\n \n                      if Extended_Project_Of (Declaration, In_Tree) /=\n@@ -561,7 +562,7 @@ package body Prj.Part is\n                         loop\n                            Imported :=\n                              Extended_Project_Of (Declaration, In_Tree);\n-                           exit when Imported = Empty_Node;\n+                           exit when No (Imported);\n                            Virtual_Hash.Remove (Imported);\n                            Declaration :=\n                              Project_Declaration_Of (Imported, In_Tree);\n@@ -578,7 +579,7 @@ package body Prj.Part is\n             declare\n                Proj : Project_Node_Id := Virtual_Hash.Get_First;\n             begin\n-               while Proj /= Empty_Node loop\n+               while Present (Proj) loop\n                   Create_Virtual_Extending_Project (Proj, Project, In_Tree);\n                   Proj := Virtual_Hash.Get_Next;\n                end loop;\n@@ -592,7 +593,7 @@ package body Prj.Part is\n             Project := Empty_Node;\n          end if;\n \n-         if Project = Empty_Node or else Always_Errout_Finalize then\n+         if No (Project) or else Always_Errout_Finalize then\n             Prj.Err.Finalize;\n          end if;\n       end;\n@@ -738,9 +739,9 @@ package body Prj.Part is\n       --  Set Current_Project to the last project in the current list, if the\n       --  list is not empty.\n \n-      if Current_Project /= Empty_Node then\n+      if Present (Current_Project) then\n          while\n-           Next_With_Clause_Of (Current_Project, In_Tree) /= Empty_Node\n+           Present (Next_With_Clause_Of (Current_Project, In_Tree))\n          loop\n             Current_Project := Next_With_Clause_Of (Current_Project, In_Tree);\n          end loop;\n@@ -797,7 +798,7 @@ package body Prj.Part is\n \n                   Previous_Project := Current_Project;\n \n-                  if Current_Project = Empty_Node then\n+                  if No (Current_Project) then\n \n                      --  First with clause of the context clause\n \n@@ -848,7 +849,7 @@ package body Prj.Part is\n \n                   --  Parse the imported project, if its project id is unknown\n \n-                  if Withed_Project = Empty_Node then\n+                  if No (Withed_Project) then\n                      Parse_Single_Project\n                        (In_Tree           => In_Tree,\n                         Project           => Withed_Project,\n@@ -865,13 +866,13 @@ package body Prj.Part is\n                      Extends_All := Is_Extending_All (Withed_Project, In_Tree);\n                   end if;\n \n-                  if Withed_Project = Empty_Node then\n+                  if No (Withed_Project) then\n \n                      --  If parsing unsuccessful, remove the context clause\n \n                      Current_Project := Previous_Project;\n \n-                     if Current_Project = Empty_Node then\n+                     if No (Current_Project) then\n                         Imported_Projects := Empty_Node;\n \n                      else\n@@ -936,8 +937,11 @@ package body Prj.Part is\n                                   Tree_Private_Part.Projects_Htable.Get_First\n                                     (In_Tree.Projects_HT);\n \n-      Name_From_Path    : constant Name_Id := Project_Name_From (Path_Name);\n-      Name_Of_Project   : Name_Id := No_Name;\n+      Name_From_Path  : constant Name_Id := Project_Name_From (Path_Name);\n+      Name_Of_Project : Name_Id := No_Name;\n+\n+      Duplicated : Boolean := False;\n+\n       First_With        : With_Id;\n       Imported_Projects : Project_Node_Id := Empty_Node;\n \n@@ -1021,9 +1025,11 @@ package body Prj.Part is\n             if Extended then\n \n                if A_Project_Name_And_Node.Extended then\n-                  Error_Msg\n-                    (\"cannot extend the same project file several times\",\n-                     Token_Ptr);\n+                  if A_Project_Name_And_Node.Proj_Qualifier /= Dry then\n+                     Error_Msg\n+                       (\"cannot extend the same project file several times\",\n+                        Token_Ptr);\n+                  end if;\n                else\n                   Error_Msg\n                     (\"cannot extend an already imported project file\",\n@@ -1092,7 +1098,7 @@ package body Prj.Part is\n       Tree.Reset_State;\n       Scan (In_Tree);\n \n-      if (not In_Configuration) and then (Name_From_Path = No_Name) then\n+      if not In_Configuration and then Name_From_Path = No_Name then\n \n          --  The project file name is not correct (no or bad extension, or not\n          --  following Ada identifier's syntax).\n@@ -1122,7 +1128,6 @@ package body Prj.Part is\n       Project_Stack.Table (Project_Stack.Last).Id := Project;\n       Set_Directory_Of (Project, In_Tree, Project_Directory);\n       Set_Path_Name_Of (Project, In_Tree,  Normed_Path_Name);\n-      Set_First_With_Clause_Of (Project, In_Tree, Imported_Projects);\n \n       --  Check if there is a qualifier before the reserved word \"project\"\n \n@@ -1279,7 +1284,7 @@ package body Prj.Part is\n          begin\n             --  Output a warning if the actual name is not the expected name\n \n-            if (not In_Configuration)\n+            if not In_Configuration\n               and then (Name_From_Path /= No_Name)\n               and then Expected_Name /= Name_From_Path\n             then\n@@ -1350,6 +1355,7 @@ package body Prj.Part is\n                --  Report an error if we already have a project with this name\n \n                if Project_Name /= No_Name then\n+                  Duplicated := True;\n                   Error_Msg_Name_1 := Project_Name;\n                   Error_Msg\n                     (\"duplicate project name %%\",\n@@ -1358,19 +1364,6 @@ package body Prj.Part is\n                     Name_Id (Path_Name_Of (Name_And_Node.Node, In_Tree));\n                   Error_Msg\n                     (\"\\already in %%\", Location_Of (Project, In_Tree));\n-\n-               else\n-                  --  Otherwise, add the name of the project to the hash table,\n-                  --  so that we can check that no other subsequent project\n-                  --  will have the same name.\n-\n-                  Tree_Private_Part.Projects_Htable.Set\n-                    (T => In_Tree.Projects_HT,\n-                     K => Name_Of_Project,\n-                     E => (Name           => Name_Of_Project,\n-                           Node           => Project,\n-                           Canonical_Path => Canonical_Path_Name,\n-                           Extended       => Extended));\n                end if;\n             end;\n          end if;\n@@ -1444,13 +1437,28 @@ package body Prj.Part is\n                         Current_Dir       => Current_Dir);\n                   end;\n \n-                  --  A project that extends an extending-all project is also\n-                  --  an extending-all project.\n+                  if Present (Extended_Project) then\n+\n+                     --  A project that extends an extending-all project is\n+                     --  also an extending-all project.\n+\n+                     if Is_Extending_All (Extended_Project, In_Tree) then\n+                        Set_Is_Extending_All (Project, In_Tree);\n+                     end if;\n+\n+                     --  An abstract project can only extend an abstract\n+                     --  project, otherwise we may have an abstract project\n+                     --  with sources, if it inherits sources from the project\n+                     --  it extends.\n \n-                  if Extended_Project /= Empty_Node\n-                    and then Is_Extending_All (Extended_Project, In_Tree)\n-                  then\n-                     Set_Is_Extending_All (Project, In_Tree);\n+                     if Proj_Qualifier = Dry and then\n+                       Project_Qualifier_Of (Extended_Project, In_Tree) /= Dry\n+                     then\n+                        Error_Msg\n+                          (\"an abstract project can only extend \" &\n+                           \"another abstract project\",\n+                           Qualifier_Location);\n+                     end if;\n                   end if;\n                end if;\n             end;\n@@ -1470,7 +1478,7 @@ package body Prj.Part is\n \n          begin\n             With_Clause_Loop :\n-            while With_Clause /= Empty_Node loop\n+            while Present (With_Clause) loop\n                Imported := Project_Node_Of (With_Clause, In_Tree);\n \n                if Is_Extending_All (With_Clause, In_Tree) then\n@@ -1510,30 +1518,34 @@ package body Prj.Part is\n          declare\n             Parent_Name  : constant Name_Id := Name_Find;\n             Parent_Found : Boolean := False;\n+            Parent_Node  : Project_Node_Id := Empty_Node;\n             With_Clause  : Project_Node_Id :=\n                              First_With_Clause_Of (Project, In_Tree);\n \n          begin\n             --  If there is an extended project, check its name\n \n-            if Extended_Project /= Empty_Node then\n+            if Present (Extended_Project) then\n+               Parent_Node := Extended_Project;\n                Parent_Found :=\n                  Name_Of (Extended_Project, In_Tree) = Parent_Name;\n             end if;\n \n             --  If the parent project is not the extended project,\n             --  check each imported project until we find the parent project.\n \n-            while not Parent_Found and then With_Clause /= Empty_Node loop\n-               Parent_Found :=\n-                 Name_Of (Project_Node_Of (With_Clause, In_Tree), In_Tree) =\n-                    Parent_Name;\n+            while not Parent_Found and then Present (With_Clause) loop\n+               Parent_Node := Project_Node_Of (With_Clause, In_Tree);\n+               Parent_Found := Name_Of (Parent_Node, In_Tree) = Parent_Name;\n                With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n             end loop;\n \n-            --  If the parent project was not found, report an error\n+            if Parent_Found then\n+               Set_Parent_Project_Of (Project, In_Tree, To => Parent_Node);\n+\n+            else\n+               --  If the parent project was not found, report an error\n \n-            if not Parent_Found then\n                Error_Msg_Name_1 := Name_Of_Project;\n                Error_Msg_Name_2 := Parent_Name;\n                Error_Msg (\"project %% does not import or extend project %%\",\n@@ -1561,7 +1573,9 @@ package body Prj.Part is\n             Packages_To_Check => Packages_To_Check);\n          Set_Project_Declaration_Of (Project, In_Tree, Project_Declaration);\n \n-         if Extended_Project /= Empty_Node then\n+         if Present (Extended_Project)\n+           and then Project_Qualifier_Of (Extended_Project, In_Tree) /= Dry\n+         then\n             Set_Extending_Project_Of\n               (Project_Declaration_Of (Extended_Project, In_Tree), In_Tree,\n                To => Project);\n@@ -1636,6 +1650,21 @@ package body Prj.Part is\n          end if;\n       end if;\n \n+      if not Duplicated and then Name_Of_Project /= No_Name then\n+\n+         --  Add the name of the project to the hash table, so that we can\n+         --  check that no other subsequent project will have the same name.\n+\n+         Tree_Private_Part.Projects_Htable.Set\n+           (T => In_Tree.Projects_HT,\n+            K => Name_Of_Project,\n+            E => (Name           => Name_Of_Project,\n+                  Node           => Project,\n+                  Canonical_Path => Canonical_Path_Name,\n+                  Extended       => Extended,\n+                  Proj_Qualifier => Proj_Qualifier));\n+      end if;\n+\n       declare\n          From_Ext : Extension_Origin := None;\n \n@@ -1723,19 +1752,19 @@ package body Prj.Part is\n       --  If we have a dot, check that it is followed by the correct extension\n \n       if First > 0 and then Canonical (First) = '.' then\n-         if ((not In_Configuration) and then\n-             Canonical (First .. Last) = Project_File_Extension and then\n-             First /= 1)\n-            or else\n-            (In_Configuration and then\n-             Canonical (First .. Last) = Config_Project_File_Extension and then\n-             First /= 1)\n+         if (not In_Configuration\n+              and then Canonical (First .. Last) = Project_File_Extension\n+              and then First /= 1)\n+           or else\n+             (In_Configuration\n+               and then\n+                 Canonical (First .. Last) = Config_Project_File_Extension\n+               and then First /= 1)\n          then\n             --  Look for the last directory separator, if any\n \n             First := First - 1;\n             Last := First;\n-\n             while First > 0\n               and then Canonical (First) /= '/'\n               and then Canonical (First) /= Dir_Sep"}, {"sha": "717a769c53147d498a53d14dadd2199942c80459", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -319,13 +319,13 @@ package body Prj.PP is\n \n       procedure Print (Node   : Project_Node_Id; Indent : Natural) is\n       begin\n-         if Node /= Empty_Node then\n+         if Present (Node) then\n \n             case Kind_Of (Node, In_Tree) is\n \n                when N_Project  =>\n                   pragma Debug (Indicate_Tested (N_Project));\n-                  if First_With_Clause_Of (Node, In_Tree) /= Empty_Node then\n+                  if Present (First_With_Clause_Of (Node, In_Tree)) then\n \n                      --  with clause(s)\n \n@@ -424,7 +424,7 @@ package body Prj.PP is\n                   pragma Debug (Indicate_Tested (N_Project_Declaration));\n \n                   if\n-                    First_Declarative_Item_Of (Node, In_Tree) /= Empty_Node\n+                    Present (First_Declarative_Item_Of (Node, In_Tree))\n                   then\n                      Print\n                        (First_Declarative_Item_Of (Node, In_Tree),\n@@ -498,12 +498,12 @@ package body Prj.PP is\n                        First_Literal_String (Node, In_Tree);\n \n                   begin\n-                     while String_Node /= Empty_Node loop\n+                     while Present (String_Node) loop\n                         Output_String (String_Value_Of (String_Node, In_Tree));\n                         String_Node :=\n                           Next_Literal_String (String_Node, In_Tree);\n \n-                        if String_Node /= Empty_Node then\n+                        if Present (String_Node) then\n                            Write_String (\", \");\n                         end if;\n                      end loop;\n@@ -543,7 +543,44 @@ package body Prj.PP is\n                   end if;\n \n                   Write_String (\" use \");\n-                  Print (Expression_Of (Node, In_Tree), Indent);\n+\n+                  if Present (Expression_Of (Node, In_Tree)) then\n+                     Print (Expression_Of (Node, In_Tree), Indent);\n+\n+                  else\n+                     --  Full associative array declaration\n+\n+                     if\n+                       Present (Associative_Project_Of (Node, In_Tree))\n+                     then\n+                        Output_Name\n+                          (Name_Of\n+                             (Associative_Project_Of (Node, In_Tree),\n+                              In_Tree));\n+\n+                        if\n+                          Present (Associative_Package_Of (Node, In_Tree))\n+                        then\n+                           Write_String (\".\");\n+                           Output_Name\n+                             (Name_Of\n+                                (Associative_Package_Of (Node, In_Tree),\n+                                 In_Tree));\n+                        end if;\n+\n+                     elsif\n+                       Present (Associative_Package_Of (Node, In_Tree))\n+                     then\n+                        Output_Name\n+                          (Name_Of\n+                             (Associative_Package_Of (Node, In_Tree),\n+                              In_Tree));\n+                     end if;\n+\n+                     Write_String (\"'\");\n+                     Output_Attribute_Name (Name_Of (Node, In_Tree));\n+                  end if;\n+\n                   Write_String (\";\");\n                   Write_End_Of_Line_Comment (Node);\n                   Print (First_Comment_After (Node, In_Tree), Indent);\n@@ -580,11 +617,11 @@ package body Prj.PP is\n                      Term : Project_Node_Id := First_Term (Node, In_Tree);\n \n                   begin\n-                     while Term /= Empty_Node loop\n+                     while Present (Term) loop\n                         Print (Term, Indent);\n                         Term := Next_Term (Term, In_Tree);\n \n-                        if Term /= Empty_Node then\n+                        if Present (Term) then\n                            Write_String (\" & \");\n                         end if;\n                      end loop;\n@@ -603,12 +640,12 @@ package body Prj.PP is\n                        First_Expression_In_List (Node, In_Tree);\n \n                   begin\n-                     while Expression /= Empty_Node loop\n+                     while Present (Expression) loop\n                         Print (Expression, Indent);\n                         Expression :=\n                           Next_Expression_In_List (Expression, In_Tree);\n \n-                        if Expression /= Empty_Node then\n+                        if Present (Expression) then\n                            Write_String (\", \");\n                         end if;\n                      end loop;\n@@ -618,13 +655,13 @@ package body Prj.PP is\n \n                when N_Variable_Reference =>\n                   pragma Debug (Indicate_Tested (N_Variable_Reference));\n-                  if Project_Node_Of (Node, In_Tree) /= Empty_Node then\n+                  if Present (Project_Node_Of (Node, In_Tree)) then\n                      Output_Name\n                        (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree));\n                      Write_String (\".\");\n                   end if;\n \n-                  if Package_Node_Of (Node, In_Tree) /= Empty_Node then\n+                  if Present (Package_Node_Of (Node, In_Tree)) then\n                      Output_Name\n                        (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n                      Write_String (\".\");\n@@ -637,7 +674,7 @@ package body Prj.PP is\n                   Write_String (\"external (\");\n                   Print (External_Reference_Of (Node, In_Tree), Indent);\n \n-                  if External_Default_Of (Node, In_Tree) /= Empty_Node then\n+                  if Present (External_Default_Of (Node, In_Tree)) then\n                      Write_String (\", \");\n                      Print (External_Default_Of (Node, In_Tree), Indent);\n                   end if;\n@@ -647,19 +684,19 @@ package body Prj.PP is\n                when N_Attribute_Reference =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Reference));\n \n-                  if Project_Node_Of (Node, In_Tree) /= Empty_Node\n+                  if Present (Project_Node_Of (Node, In_Tree))\n                     and then Project_Node_Of (Node, In_Tree) /= Project\n                   then\n                      Output_Name\n                        (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree));\n \n-                     if Package_Node_Of (Node, In_Tree) /= Empty_Node then\n+                     if Present (Package_Node_Of (Node, In_Tree)) then\n                         Write_String (\".\");\n                         Output_Name\n                           (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n                      end if;\n \n-                  elsif Package_Node_Of (Node, In_Tree) /= Empty_Node then\n+                  elsif Present (Package_Node_Of (Node, In_Tree)) then\n                      Output_Name\n                        (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n \n@@ -691,10 +728,10 @@ package body Prj.PP is\n \n                   begin\n                      Case_Item := First_Case_Item_Of (Node, In_Tree);\n-                     while Case_Item /= Empty_Node loop\n-                        if First_Declarative_Item_Of (Case_Item, In_Tree) /=\n-                             Empty_Node\n-                          or else not Eliminate_Empty_Case_Constructions\n+                     while Present (Case_Item) loop\n+                        if Present\n+                            (First_Declarative_Item_Of (Case_Item, In_Tree))\n+                           or else not Eliminate_Empty_Case_Constructions\n                         then\n                            Is_Non_Empty := True;\n                            exit;\n@@ -721,7 +758,7 @@ package body Prj.PP is\n                            Case_Item : Project_Node_Id :=\n                                          First_Case_Item_Of (Node, In_Tree);\n                         begin\n-                           while Case_Item /= Empty_Node loop\n+                           while Present (Case_Item) loop\n                               pragma Assert\n                                 (Kind_Of (Case_Item, In_Tree) = N_Case_Item);\n                               Print (Case_Item, Indent + Increment);\n@@ -742,27 +779,27 @@ package body Prj.PP is\n                when N_Case_Item =>\n                   pragma Debug (Indicate_Tested (N_Case_Item));\n \n-                  if First_Declarative_Item_Of (Node, In_Tree) /= Empty_Node\n+                  if Present (First_Declarative_Item_Of (Node, In_Tree))\n                     or else not Eliminate_Empty_Case_Constructions\n                   then\n                      Write_Empty_Line;\n                      Print (First_Comment_Before (Node, In_Tree), Indent);\n                      Start_Line (Indent);\n                      Write_String (\"when \");\n \n-                     if First_Choice_Of (Node, In_Tree) = Empty_Node then\n+                     if No (First_Choice_Of (Node, In_Tree)) then\n                         Write_String (\"others\");\n \n                      else\n                         declare\n                            Label : Project_Node_Id :=\n                                      First_Choice_Of (Node, In_Tree);\n                         begin\n-                           while Label /= Empty_Node loop\n+                           while Present (Label) loop\n                               Print (Label, Indent);\n                               Label := Next_Literal_String (Label, In_Tree);\n \n-                              if Label /= Empty_Node then\n+                              if Present (Label) then\n                                  Write_String (\" | \");\n                               end if;\n                            end loop;\n@@ -779,7 +816,7 @@ package body Prj.PP is\n                         First : constant Project_Node_Id :=\n                                   First_Declarative_Item_Of (Node, In_Tree);\n                      begin\n-                        if First = Empty_Node then\n+                        if No (First) then\n                            Write_Empty_Line;\n                         else\n                            Print (First, Indent + Increment);"}, {"sha": "13f1d947804a5c2640145eb397cb90397f821e78", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -463,7 +463,7 @@ package body Prj.Proc is\n \n       --  Process each term of the expression, starting with First_Term\n \n-      while The_Term /= Empty_Node loop\n+      while Present (The_Term) loop\n          The_Current_Term := Current_Term (The_Term, From_Project_Node_Tree);\n \n          case Kind_Of (The_Current_Term, From_Project_Node_Tree) is\n@@ -535,7 +535,7 @@ package body Prj.Proc is\n                   Value : Variable_Value;\n \n                begin\n-                  if String_Node /= Empty_Node then\n+                  if Present (String_Node) then\n \n                      --  If String_Node is nil, it is an empty list,\n                      --  there is nothing to do\n@@ -586,7 +586,7 @@ package body Prj.Proc is\n                           Next_Expression_In_List\n                             (String_Node, From_Project_Node_Tree);\n \n-                        exit when String_Node = Empty_Node;\n+                        exit when No (String_Node);\n \n                         Value :=\n                           Expression\n@@ -637,7 +637,7 @@ package body Prj.Proc is\n                   Index           : Name_Id := No_Name;\n \n                begin\n-                  if Term_Project /= Empty_Node and then\n+                  if Present (Term_Project) and then\n                      Term_Project /= From_Project_Node\n                   then\n                      --  This variable or attribute comes from another project\n@@ -650,7 +650,7 @@ package body Prj.Proc is\n                                        With_Name => The_Name);\n                   end if;\n \n-                  if Term_Package /= Empty_Node then\n+                  if Present (Term_Package) then\n \n                      --  This is an attribute of a package\n \n@@ -1003,11 +1003,11 @@ package body Prj.Proc is\n                   --  If there is a default value for the external reference,\n                   --  get its value.\n \n-                  if Default_Node /= Empty_Node then\n+                  if Present (Default_Node) then\n                      Def_Var := Expression\n                        (Project                => Project,\n                         In_Tree                => In_Tree,\n-                        From_Project_Node      => Default_Node,\n+                        From_Project_Node      => From_Project_Node,\n                         From_Project_Node_Tree => From_Project_Node_Tree,\n                         Pkg                    => Pkg,\n                         First_Term             =>\n@@ -1252,7 +1252,7 @@ package body Prj.Proc is\n       Current_Item := Empty_Node;\n \n       Current_Declarative_Item := Item;\n-      while Current_Declarative_Item /= Empty_Node loop\n+      while Present (Current_Declarative_Item) loop\n \n          --  Get its data\n \n@@ -1314,7 +1314,7 @@ package body Prj.Proc is\n                      In_Tree.Packages.Table (New_Pkg) :=\n                        The_New_Package;\n \n-                     if Project_Of_Renamed_Package /= Empty_Node then\n+                     if Present (Project_Of_Renamed_Package) then\n \n                         --  Renamed package\n \n@@ -1472,19 +1472,19 @@ package body Prj.Proc is\n \n                         if Pkg /= No_Package then\n                            In_Tree.Arrays.Table (New_Array) :=\n-                             (Name  => Current_Item_Name,\n-                              Value => No_Array_Element,\n-                              Next  =>\n+                             (Name   => Current_Item_Name,\n+                              Value  => No_Array_Element,\n+                              Next   =>\n                                 In_Tree.Packages.Table (Pkg).Decl.Arrays);\n \n                            In_Tree.Packages.Table (Pkg).Decl.Arrays :=\n                              New_Array;\n \n                         else\n                            In_Tree.Arrays.Table (New_Array) :=\n-                             (Name  => Current_Item_Name,\n-                              Value => No_Array_Element,\n-                              Next  =>\n+                             (Name   => Current_Item_Name,\n+                              Value  => No_Array_Element,\n+                              Next   =>\n                                 In_Tree.Projects.Table (Project).Decl.Arrays);\n \n                            In_Tree.Projects.Table (Project).Decl.Arrays :=\n@@ -1515,8 +1515,8 @@ package body Prj.Proc is\n                      pragma Assert (Orig_Project /= No_Project,\n                                     \"original project not found\");\n \n-                     if Associative_Package_Of\n-                          (Current_Item, From_Project_Node_Tree) = Empty_Node\n+                     if No (Associative_Package_Of\n+                              (Current_Item, From_Project_Node_Tree))\n                      then\n                         Orig_Array :=\n                           In_Tree.Projects.Table\n@@ -1732,7 +1732,7 @@ package body Prj.Proc is\n                                   (String_Type_Of (Current_Item,\n                                                    From_Project_Node_Tree),\n                                                    From_Project_Node_Tree);\n-                              while Current_String /= Empty_Node\n+                              while Present (Current_String)\n                                 and then\n                                   String_Value_Of\n                                     (Current_String, From_Project_Node_Tree) /=\n@@ -1746,7 +1746,7 @@ package body Prj.Proc is\n                               --  Report an error if the string value is not\n                               --  one for the string type.\n \n-                              if Current_String = Empty_Node then\n+                              if No (Current_String) then\n                                  Error_Msg_Name_1 := New_Value.Value;\n                                  Error_Msg_Name_2 :=\n                                    Name_Of\n@@ -1849,21 +1849,21 @@ package body Prj.Proc is\n \n                            if Pkg /= No_Package then\n                               In_Tree.Variable_Elements.Table (The_Variable) :=\n-                                (Next    =>\n+                                (Next   =>\n                                    In_Tree.Packages.Table\n                                      (Pkg).Decl.Variables,\n-                                 Name    => Current_Item_Name,\n-                                 Value   => New_Value);\n+                                 Name   => Current_Item_Name,\n+                                 Value  => New_Value);\n                               In_Tree.Packages.Table\n                                 (Pkg).Decl.Variables := The_Variable;\n \n                            else\n                               In_Tree.Variable_Elements.Table (The_Variable) :=\n-                                (Next    =>\n+                                (Next   =>\n                                    In_Tree.Projects.Table\n                                      (Project).Decl.Variables,\n-                                 Name    => Current_Item_Name,\n-                                 Value   => New_Value);\n+                                 Name   => Current_Item_Name,\n+                                 Value  => New_Value);\n                               In_Tree.Projects.Table\n                                 (Project).Decl.Variables :=\n                                   The_Variable;\n@@ -1957,9 +1957,9 @@ package body Prj.Proc is\n \n                               if Pkg /= No_Package then\n                                  In_Tree.Arrays.Table (The_Array) :=\n-                                   (Name  => Current_Item_Name,\n-                                    Value => No_Array_Element,\n-                                    Next  =>\n+                                   (Name   => Current_Item_Name,\n+                                    Value  => No_Array_Element,\n+                                    Next   =>\n                                       In_Tree.Packages.Table\n                                         (Pkg).Decl.Arrays);\n \n@@ -1968,9 +1968,9 @@ package body Prj.Proc is\n \n                               else\n                                  In_Tree.Arrays.Table (The_Array) :=\n-                                   (Name  => Current_Item_Name,\n-                                    Value => No_Array_Element,\n-                                    Next  =>\n+                                   (Name   => Current_Item_Name,\n+                                    Value  => No_Array_Element,\n+                                    Next   =>\n                                       In_Tree.Projects.Table\n                                         (Project).Decl.Arrays);\n \n@@ -2019,7 +2019,7 @@ package body Prj.Proc is\n                                      not Case_Insensitive\n                                        (Current_Item, From_Project_Node_Tree),\n                                    Value  => New_Value,\n-                                   Next => In_Tree.Arrays.Table\n+                                   Next   => In_Tree.Arrays.Table\n                                              (The_Array).Value);\n                               In_Tree.Arrays.Table\n                                 (The_Array).Value := The_Array_Element;\n@@ -2068,8 +2068,8 @@ package body Prj.Proc is\n                      --  If a project was specified for the case variable,\n                      --  get its id.\n \n-                     if Project_Node_Of\n-                       (Variable_Node, From_Project_Node_Tree) /= Empty_Node\n+                     if Present (Project_Node_Of\n+                                   (Variable_Node, From_Project_Node_Tree))\n                      then\n                         Name :=\n                           Name_Of\n@@ -2084,8 +2084,8 @@ package body Prj.Proc is\n                      --  If a package were specified for the case variable,\n                      --  get its id.\n \n-                     if Package_Node_Of\n-                       (Variable_Node, From_Project_Node_Tree) /= Empty_Node\n+                     if Present (Package_Node_Of\n+                                   (Variable_Node, From_Project_Node_Tree))\n                      then\n                         Name :=\n                           Name_Of\n@@ -2121,8 +2121,8 @@ package body Prj.Proc is\n \n                      if Var_Id = No_Variable\n                         and then\n-                        Package_Node_Of\n-                          (Variable_Node, From_Project_Node_Tree) = Empty_Node\n+                        No (Package_Node_Of\n+                              (Variable_Node, From_Project_Node_Tree))\n                      then\n                         Var_Id := In_Tree.Projects.Table\n                                     (The_Project).Decl.Variables;\n@@ -2172,14 +2172,14 @@ package body Prj.Proc is\n                   Case_Item :=\n                     First_Case_Item_Of (Current_Item, From_Project_Node_Tree);\n                   Case_Item_Loop :\n-                     while Case_Item /= Empty_Node loop\n+                     while Present (Case_Item) loop\n                         Choice_String :=\n                           First_Choice_Of (Case_Item, From_Project_Node_Tree);\n \n                         --  When Choice_String is nil, it means that it is\n                         --  the \"when others =>\" alternative.\n \n-                        if Choice_String = Empty_Node then\n+                        if No (Choice_String) then\n                            Decl_Item :=\n                              First_Declarative_Item_Of\n                                (Case_Item, From_Project_Node_Tree);\n@@ -2189,7 +2189,7 @@ package body Prj.Proc is\n                         --  Look into all the alternative of this case item\n \n                         Choice_Loop :\n-                           while Choice_String /= Empty_Node loop\n+                           while Present (Choice_String) loop\n                               if Case_Value =\n                                 String_Value_Of\n                                   (Choice_String, From_Project_Node_Tree)\n@@ -2211,7 +2211,7 @@ package body Prj.Proc is\n \n                   --  If there is an alternative, then we process it\n \n-                  if Decl_Item /= Empty_Node then\n+                  if Present (Decl_Item) then\n                      Process_Declarative_Items\n                        (Project                => Project,\n                         In_Tree                => In_Tree,\n@@ -2486,7 +2486,7 @@ package body Prj.Proc is\n       With_Clause : Project_Node_Id;\n \n    begin\n-      if From_Project_Node = Empty_Node then\n+      if No (From_Project_Node) then\n          Project := No_Project;\n \n       else\n@@ -2591,7 +2591,7 @@ package body Prj.Proc is\n \n             With_Clause :=\n               First_With_Clause_Of (From_Project_Node, From_Project_Node_Tree);\n-            while With_Clause /= Empty_Node loop\n+            while Present (With_Clause) loop\n                declare\n                   New_Project : Project_Id;\n                   New_Data    : Project_Data;\n@@ -2602,7 +2602,7 @@ package body Prj.Proc is\n                     Non_Limited_Project_Node_Of\n                       (With_Clause, From_Project_Node_Tree);\n \n-                  if Proj_Node /= Empty_Node then\n+                  if Present (Proj_Node) then\n                      Recursive_Process\n                        (In_Tree                => In_Tree,\n                         Project                => New_Project,\n@@ -2799,7 +2799,7 @@ package body Prj.Proc is\n             With_Clause :=\n               First_With_Clause_Of\n                 (From_Project_Node, From_Project_Node_Tree);\n-            while With_Clause /= Empty_Node loop\n+            while Present (With_Clause) loop\n                declare\n                   New_Project : Project_Id;\n                   New_Data    : Project_Data;\n@@ -2810,7 +2810,7 @@ package body Prj.Proc is\n                     Non_Limited_Project_Node_Of\n                       (With_Clause, From_Project_Node_Tree);\n \n-                  if Proj_Node = Empty_Node then\n+                  if No (Proj_Node) then\n                      Recursive_Process\n                        (In_Tree                => In_Tree,\n                         Project                => New_Project,"}, {"sha": "862b6ff630257c7a31e453e8316072eb6e1df425", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -244,7 +244,7 @@ package body Prj.Strt is\n \n          --  Change name of obsolete attributes\n \n-         if Reference /= Empty_Node then\n+         if Present (Reference) then\n             case Name_Of (Reference, In_Tree) is\n                when Snames.Name_Specification =>\n                   Set_Name_Of (Reference, In_Tree, To => Snames.Name_Spec);\n@@ -716,7 +716,7 @@ package body Prj.Strt is\n                          (Current_Project, In_Tree, Names.Table (1).Name);\n                   end if;\n \n-                  if The_Project = Empty_Node then\n+                  if No (The_Project) then\n \n                      --  If it is neither a project name nor a package name,\n                      --  report an error.\n@@ -734,7 +734,7 @@ package body Prj.Strt is\n                         The_Package :=\n                           First_Package_Of (Current_Project, In_Tree);\n \n-                        while The_Package /= Empty_Node\n+                        while Present (The_Package)\n                           and then Name_Of (The_Package, In_Tree) /=\n                                                       Names.Table (1).Name\n                         loop\n@@ -745,7 +745,7 @@ package body Prj.Strt is\n                         --  If it has not been already declared, report an\n                         --  error.\n \n-                        if The_Package = Empty_Node then\n+                        if No (The_Package) then\n                            Error_Msg_Name_1 := Names.Table (1).Name;\n                            Error_Msg (\"package % not yet defined\",\n                                       Names.Table (1).Location);\n@@ -820,7 +820,7 @@ package body Prj.Strt is\n                      --  If the long project exists, then this is the prefix\n                      --  of the attribute.\n \n-                     if The_Project /= Empty_Node then\n+                     if Present (The_Project) then\n                         First_Attribute := Attribute_First;\n                         The_Package     := Empty_Node;\n \n@@ -841,7 +841,7 @@ package body Prj.Strt is\n \n                         --  If short project does not exist, report an error\n \n-                        if The_Project = Empty_Node then\n+                        if No (The_Project) then\n                            Error_Msg_Name_1 := Long_Project;\n                            Error_Msg_Name_2 := Short_Project;\n                            Error_Msg (\"unknown projects % or %\",\n@@ -855,7 +855,7 @@ package body Prj.Strt is\n \n                            The_Package :=\n                              First_Package_Of (The_Project, In_Tree);\n-                           while The_Package /= Empty_Node\n+                           while Present (The_Package)\n                              and then Name_Of (The_Package, In_Tree) /=\n                              Names.Table (Names.Last).Name\n                            loop\n@@ -865,7 +865,7 @@ package body Prj.Strt is\n \n                            --  If it has not, then we report an error\n \n-                           if The_Package = Empty_Node then\n+                           if No (The_Package) then\n                               Error_Msg_Name_1 :=\n                                 Names.Table (Names.Last).Name;\n                               Error_Msg_Name_2 := Short_Project;\n@@ -926,7 +926,7 @@ package body Prj.Strt is\n \n                The_Package := First_Package_Of (Current_Project, In_Tree);\n \n-               while The_Package /= Empty_Node\n+               while Present (The_Package)\n                  and then Name_Of (The_Package, In_Tree) /=\n                             Names.Table (1).Name\n                loop\n@@ -939,10 +939,10 @@ package body Prj.Strt is\n                The_Project := Imported_Or_Extended_Project_Of\n                               (Current_Project, In_Tree, Names.Table (1).Name);\n \n-               if The_Project /= Empty_Node then\n+               if Present (The_Project) then\n                   Specified_Project := The_Project;\n \n-               elsif The_Package = Empty_Node then\n+               elsif No (The_Package) then\n                   Error_Msg_Name_1 := Names.Table (1).Name;\n                   Error_Msg (\"unknown package or project %\",\n                              Names.Table (1).Location);\n@@ -1004,7 +1004,7 @@ package body Prj.Strt is\n                   The_Project := Imported_Or_Extended_Project_Of\n                                    (Current_Project, In_Tree, Long_Project);\n \n-                  if The_Project /= Empty_Node then\n+                  if Present (The_Project) then\n                      Specified_Project := The_Project;\n \n                   else\n@@ -1017,7 +1017,7 @@ package body Prj.Strt is\n                        Imported_Or_Extended_Project_Of\n                          (Current_Project, In_Tree, Short_Project);\n \n-                     if The_Project = Empty_Node then\n+                     if No (The_Project) then\n                         --  Unknown prefix, report an error\n \n                         Error_Msg_Name_1 := Long_Project;\n@@ -1034,15 +1034,15 @@ package body Prj.Strt is\n \n                         The_Package := First_Package_Of (The_Project, In_Tree);\n \n-                        while The_Package /= Empty_Node\n+                        while Present (The_Package)\n                           and then Name_Of (The_Package, In_Tree) /=\n                                               Names.Table (Names.Last - 1).Name\n                         loop\n                            The_Package :=\n                              Next_Package_In_Project (The_Package, In_Tree);\n                         end loop;\n \n-                        if The_Package = Empty_Node then\n+                        if No (The_Package) then\n \n                            --  The package does not exist, report an error\n \n@@ -1065,7 +1065,7 @@ package body Prj.Strt is\n          Set_Project_Node_Of (Variable, In_Tree, To => Specified_Project);\n          Set_Package_Node_Of (Variable, In_Tree, To => Specified_Package);\n \n-         if Specified_Project /= Empty_Node then\n+         if Present (Specified_Project) then\n             The_Project := Specified_Project;\n          else\n             The_Project := Current_Project;\n@@ -1078,10 +1078,10 @@ package body Prj.Strt is\n          --  If a package was specified, check if the variable has been\n          --  declared in this package.\n \n-         if Specified_Package /= Empty_Node then\n+         if Present (Specified_Package) then\n             Current_Variable :=\n               First_Variable_Of (Specified_Package, In_Tree);\n-            while Current_Variable /= Empty_Node\n+            while Present (Current_Variable)\n               and then\n               Name_Of (Current_Variable, In_Tree) /= Variable_Name\n             loop\n@@ -1093,12 +1093,12 @@ package body Prj.Strt is\n             --  a package, first check if the variable has been declared in\n             --  the package.\n \n-            if Specified_Project = Empty_Node\n-              and then Current_Package /= Empty_Node\n+            if No (Specified_Project)\n+              and then Present (Current_Package)\n             then\n                Current_Variable :=\n                  First_Variable_Of (Current_Package, In_Tree);\n-               while Current_Variable /= Empty_Node\n+               while Present (Current_Variable)\n                  and then Name_Of (Current_Variable, In_Tree) /= Variable_Name\n                loop\n                   Current_Variable :=\n@@ -1107,29 +1107,47 @@ package body Prj.Strt is\n             end if;\n \n             --  If we have not found the variable in the package, check if the\n-            --  variable has been declared in the project.\n+            --  variable has been declared in the project, or in any of its\n+            --  ancestors.\n \n-            if Current_Variable = Empty_Node then\n-               Current_Variable := First_Variable_Of (The_Project, In_Tree);\n-               while Current_Variable /= Empty_Node\n-                 and then Name_Of (Current_Variable, In_Tree) /= Variable_Name\n-               loop\n-                  Current_Variable :=\n-                    Next_Variable (Current_Variable, In_Tree);\n-               end loop;\n+            if No (Current_Variable) then\n+               declare\n+                  Proj : Project_Node_Id := The_Project;\n+\n+               begin\n+                  loop\n+                     Current_Variable := First_Variable_Of (Proj, In_Tree);\n+                     while\n+                       Present (Current_Variable)\n+                       and then\n+                       Name_Of (Current_Variable, In_Tree) /= Variable_Name\n+                     loop\n+                        Current_Variable :=\n+                          Next_Variable (Current_Variable, In_Tree);\n+                     end loop;\n+\n+                     exit when Present (Current_Variable);\n+\n+                     Proj := Parent_Project_Of (Proj, In_Tree);\n+\n+                     Set_Project_Node_Of (Variable, In_Tree, To => Proj);\n+\n+                     exit when No (Proj);\n+                  end loop;\n+               end;\n             end if;\n          end if;\n \n          --  If the variable was not found, report an error\n \n-         if Current_Variable = Empty_Node then\n+         if No (Current_Variable) then\n             Error_Msg_Name_1 := Variable_Name;\n             Error_Msg\n               (\"unknown variable %\", Names.Table (Names.Last).Location);\n          end if;\n       end if;\n \n-      if Current_Variable /= Empty_Node then\n+      if Present (Current_Variable) then\n          Set_Expression_Kind_Of\n            (Variable, In_Tree,\n             To => Expression_Kind_Of (Current_Variable, In_Tree));\n@@ -1185,9 +1203,9 @@ package body Prj.Strt is\n \n       --  Add the literal of the string type to the Choices table\n \n-      if String_Type /= Empty_Node then\n+      if Present (String_Type) then\n          Current_String := First_Literal_String (String_Type, In_Tree);\n-         while Current_String /= Empty_Node loop\n+         while Present (Current_String) loop\n             Add (This_String => String_Value_Of (Current_String, In_Tree));\n             Current_String := Next_Literal_String (Current_String, In_Tree);\n          end loop;\n@@ -1290,7 +1308,7 @@ package body Prj.Strt is\n                   --  If Current_Expression is empty, it means that the\n                   --  expression is the first in the string list.\n \n-                  if Current_Expression = Empty_Node then\n+                  if No (Current_Expression) then\n                      Set_First_Expression_In_List\n                        (Term_Id, In_Tree, To => Next_Expression);\n                   else\n@@ -1382,7 +1400,7 @@ package body Prj.Strt is\n                Current_Package => Current_Package);\n             Set_Current_Term (Term, In_Tree, To => Reference);\n \n-            if Reference /= Empty_Node then\n+            if Present (Reference) then\n \n                --  If we don't know the expression kind (first term), then it\n                --  has the kind of the variable or attribute reference.\n@@ -1425,7 +1443,7 @@ package body Prj.Strt is\n \n             --  Same checks as above for the expression kind\n \n-            if Reference /= Empty_Node then\n+            if Present (Reference) then\n                if Expr_Kind = Undefined then\n                   Expr_Kind := Expression_Kind_Of (Reference, In_Tree);\n "}, {"sha": "0f9f5de986fbd9828e0fcfec3956c783e86d99d9", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 185, "deletions": 129, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -94,13 +94,13 @@ package body Prj.Tree is\n \n    begin\n       pragma Assert\n-        (To /= Empty_Node\n+        (Present (To)\n           and then\n          In_Tree.Project_Nodes.Table (To).Kind /= N_Comment);\n \n       Zone := In_Tree.Project_Nodes.Table (To).Comments;\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n \n          --  Create new N_Comment_Zones node\n \n@@ -122,6 +122,7 @@ package body Prj.Tree is\n             Field1           => Empty_Node,\n             Field2           => Empty_Node,\n             Field3           => Empty_Node,\n+            Field4           => Empty_Node,\n             Flag1            => False,\n             Flag2            => False,\n             Comments         => Empty_Node);\n@@ -171,12 +172,13 @@ package body Prj.Tree is\n                Field1           => Empty_Node,\n                Field2           => Empty_Node,\n                Field3           => Empty_Node,\n+               Field4           => Empty_Node,\n                Comments         => Empty_Node);\n \n             --  If this is the first comment, put it in the right field of\n             --  the node Zone.\n \n-            if Previous = Empty_Node then\n+            if No (Previous) then\n                case Where is\n                   when Before =>\n                      In_Tree.Project_Nodes.Table (Zone).Field1 :=\n@@ -228,7 +230,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n@@ -246,7 +248,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n           (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n       return In_Tree.Project_Nodes.Table (Node).Field3;\n@@ -262,7 +264,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n           (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -277,7 +279,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n@@ -295,7 +297,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -312,13 +314,13 @@ package body Prj.Tree is\n       Zone : Project_Node_Id;\n \n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n       --  If there is not already an N_Comment_Zones associated, create a new\n       --  one and associate it with node Node.\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n          Project_Node_Table.Increment_Last (In_Tree.Project_Nodes);\n          Zone := Project_Node_Table.Last (In_Tree.Project_Nodes);\n          In_Tree.Project_Nodes.Table (Zone) :=\n@@ -337,6 +339,7 @@ package body Prj.Tree is\n          Field1           => Empty_Node,\n          Field2           => Empty_Node,\n          Field3           => Empty_Node,\n+         Field4           => Empty_Node,\n          Flag1            => False,\n          Flag2            => False,\n          Comments         => Empty_Node);\n@@ -356,7 +359,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -372,7 +375,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -412,6 +415,7 @@ package body Prj.Tree is\n          Field1           => Empty_Node,\n          Field2           => Empty_Node,\n          Field3           => Empty_Node,\n+         Field4           => Empty_Node,\n          Flag1            => False,\n          Flag2            => False,\n          Comments         => Empty_Node);\n@@ -447,6 +451,7 @@ package body Prj.Tree is\n                Field1           => Empty_Node,\n                Field2           => Empty_Node,\n                Field3           => Empty_Node,\n+               Field4           => Empty_Node,\n                Flag1            => False,\n                Flag2            => False,\n                Comments         => Empty_Node);\n@@ -480,12 +485,13 @@ package body Prj.Tree is\n                   Field1           => Empty_Node,\n                   Field2           => Empty_Node,\n                   Field3           => Empty_Node,\n+                  Field4           => Empty_Node,\n                   Comments         => Empty_Node);\n \n                --  Link it to the N_Comment_Zones node, if it is the first,\n                --  otherwise to the previous one.\n \n-               if Previous = Empty_Node then\n+               if No (Previous) then\n                   In_Tree.Project_Nodes.Table (Zone).Field1 :=\n                     Project_Node_Table.Last (In_Tree.Project_Nodes);\n \n@@ -518,7 +524,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Path_Name_Type is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return In_Tree.Project_Nodes.Table (Node).Directory;\n@@ -534,10 +540,10 @@ package body Prj.Tree is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n          return No_Name;\n       else\n          return In_Tree.Project_Nodes.Table (Zone).Value;\n@@ -553,7 +559,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Variable_Kind is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n            and then\n              (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n                 or else\n@@ -588,7 +594,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Attribute_Declaration\n@@ -612,7 +618,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -628,7 +634,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return Path_Name_Type (In_Tree.Project_Nodes.Table (Node).Value);\n@@ -643,7 +649,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n       return In_Tree.Project_Nodes.Table (Node).Field3;\n@@ -659,7 +665,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -676,7 +682,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -692,7 +698,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -709,7 +715,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -725,10 +731,10 @@ package body Prj.Tree is\n    is\n       Zone : Project_Node_Id := Empty_Node;\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n          return Empty_Node;\n \n       else\n@@ -748,10 +754,10 @@ package body Prj.Tree is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n          return Empty_Node;\n \n       else\n@@ -770,10 +776,10 @@ package body Prj.Tree is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n          return Empty_Node;\n \n       else\n@@ -792,10 +798,10 @@ package body Prj.Tree is\n       Zone : Project_Node_Id := Empty_Node;\n \n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       Zone := In_Tree.Project_Nodes.Table (Node).Comments;\n \n-      if Zone = Empty_Node then\n+      if No (Zone) then\n          return Empty_Node;\n \n       else\n@@ -813,7 +819,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration\n                or else\n@@ -838,7 +844,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String_List);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -854,7 +860,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n          In_Tree.Project_Nodes.Table (Node).Kind =\n            N_String_Type_Declaration);\n@@ -871,7 +877,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return In_Tree.Project_Nodes.Table (Node).Packages;\n@@ -887,7 +893,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return In_Tree.Project_Nodes.Table (Node).Field3;\n@@ -903,7 +909,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -919,7 +925,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n@@ -938,7 +944,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -953,7 +959,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n          and then\n          In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n       return In_Tree.Project_Nodes.Table (Node).Flag1;\n@@ -988,7 +994,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n       return In_Tree.Project_Nodes.Table (Node).Flag2;\n@@ -1003,7 +1009,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n               or else\n@@ -1020,7 +1026,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Boolean is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause);\n       return In_Tree.Project_Nodes.Table (Node).Flag1;\n@@ -1042,27 +1048,27 @@ package body Prj.Tree is\n    begin\n       --  First check all the imported projects\n \n-      while With_Clause /= Empty_Node loop\n+      while Present (With_Clause) loop\n \n          --  Only non limited imported project may be used as prefix\n          --  of variable or attributes.\n \n          Result := Non_Limited_Project_Node_Of (With_Clause, In_Tree);\n-         exit when Result /= Empty_Node\n+         exit when Present (Result)\n            and then Name_Of (Result, In_Tree) = With_Name;\n          With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n       end loop;\n \n       --  If it is not an imported project, it might be an extended project\n \n-      if With_Clause = Empty_Node then\n+      if No (With_Clause) then\n          Result := Project;\n          loop\n             Result :=\n               Extended_Project_Of\n                 (Project_Declaration_Of (Result, In_Tree), In_Tree);\n \n-            exit when Result = Empty_Node\n+            exit when No (Result)\n               or else Name_Of (Result, In_Tree) = With_Name;\n          end loop;\n       end if;\n@@ -1078,7 +1084,7 @@ package body Prj.Tree is\n      (Node    : Project_Node_Id;\n       In_Tree : Project_Node_Tree_Ref) return Project_Node_Kind is\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       return In_Tree.Project_Nodes.Table (Node).Kind;\n    end Kind_Of;\n \n@@ -1090,7 +1096,7 @@ package body Prj.Tree is\n      (Node    : Project_Node_Id;\n       In_Tree : Project_Node_Tree_Ref) return Source_Ptr is\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       return In_Tree.Project_Nodes.Table (Node).Location;\n    end Location_Of;\n \n@@ -1102,7 +1108,7 @@ package body Prj.Tree is\n      (Node    : Project_Node_Id;\n       In_Tree : Project_Node_Tree_Ref) return Name_Id is\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       return In_Tree.Project_Nodes.Table (Node).Name;\n    end Name_Of;\n \n@@ -1116,7 +1122,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n       return In_Tree.Project_Nodes.Table (Node).Field3;\n@@ -1131,7 +1137,7 @@ package body Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Project_Node_Id is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n       return In_Tree.Project_Nodes.Table (Node).Comments;\n@@ -1147,7 +1153,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -1163,7 +1169,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -1180,7 +1186,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -1196,7 +1202,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n       return In_Tree.Project_Nodes.Table (Node).Field3;\n@@ -1213,7 +1219,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n          In_Tree.Project_Nodes.Table (Node).Kind =\n            N_String_Type_Declaration);\n@@ -1230,7 +1236,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -1247,7 +1253,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Typed_Variable_Declaration\n@@ -1268,12 +1274,21 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_With_Clause_Of;\n \n+   --------\n+   -- No --\n+   --------\n+\n+   function No (Node : Project_Node_Id) return Boolean is\n+   begin\n+      return Node = Empty_Node;\n+   end No;\n+\n    ---------------------------------\n    -- Non_Limited_Project_Node_Of --\n    ---------------------------------\n@@ -1284,7 +1299,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n       return In_Tree.Project_Nodes.Table (Node).Field3;\n@@ -1300,7 +1315,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n       return In_Tree.Project_Nodes.Table (Node).Pkg_Id;\n@@ -1316,7 +1331,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                or else\n@@ -1334,14 +1349,23 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n              In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause));\n       return In_Tree.Project_Nodes.Table (Node).Path_Name;\n    end Path_Name_Of;\n \n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Node : Project_Node_Id) return Boolean is\n+   begin\n+      return Node /= Empty_Node;\n+   end Present;\n+\n    ----------------------------\n    -- Project_Declaration_Of --\n    ----------------------------\n@@ -1352,7 +1376,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n@@ -1368,12 +1392,28 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       return In_Tree.Project_Nodes.Table (Node).Qualifier;\n    end Project_Qualifier_Of;\n \n+   -----------------------\n+   -- Parent_Project_Of --\n+   -----------------------\n+\n+   function Parent_Project_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n+   is\n+   begin\n+      pragma Assert\n+        (Present (Node)\n+          and then\n+            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      return In_Tree.Project_Nodes.Table (Node).Field4;\n+   end Parent_Project_Of;\n+\n    -------------------------------------------\n    -- Project_File_Includes_Unkept_Comments --\n    -------------------------------------------\n@@ -1398,7 +1438,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n               or else\n@@ -1418,7 +1458,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n       return In_Tree.Project_Nodes.Table (Node).Field1;\n@@ -1534,7 +1574,7 @@ package body Prj.Tree is\n                --  an end of line node specified, associate the comment with\n                --  this node.\n \n-               elsif End_Of_Line_Node /= Empty_Node then\n+               elsif Present (End_Of_Line_Node) then\n                   declare\n                      Zones : constant Project_Node_Id :=\n                                Comment_Zones_Of (End_Of_Line_Node, In_Tree);\n@@ -1559,13 +1599,13 @@ package body Prj.Tree is\n \n                if Comments.Last > 0 and then\n                  not Comments.Table (1).Follows_Empty_Line then\n-                  if Previous_Line_Node /= Empty_Node then\n+                  if Present (Previous_Line_Node) then\n                      Add_Comments\n                        (To      => Previous_Line_Node,\n                         Where   => After,\n                         In_Tree => In_Tree);\n \n-                  elsif Previous_End_Node /= Empty_Node then\n+                  elsif Present (Previous_End_Node) then\n                      Add_Comments\n                        (To      => Previous_End_Node,\n                         Where   => After_End,\n@@ -1617,7 +1657,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n@@ -1636,7 +1676,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-         (Node /= Empty_Node\n+         (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration);\n       In_Tree.Project_Nodes.Table (Node).Field3 := To;\n@@ -1653,7 +1693,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Attribute_Declaration));\n@@ -1671,7 +1711,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n@@ -1690,7 +1730,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -1707,7 +1747,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -1724,7 +1764,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -1741,7 +1781,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Directory := To;\n@@ -1767,7 +1807,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n            and then\n              (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n                 or else\n@@ -1802,7 +1842,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Attribute_Declaration\n@@ -1826,7 +1866,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -1843,7 +1883,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_External_Value);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -1860,7 +1900,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Construction);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -1877,7 +1917,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -1951,7 +1991,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Case_Item);\n       In_Tree.Project_Nodes.Table (Node).Field3 := To;\n@@ -1968,7 +2008,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Comment);\n       In_Tree.Project_Nodes.Table (Node).Comments := To;\n@@ -1985,7 +2025,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration\n                or else\n@@ -2011,7 +2051,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String_List);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -2028,7 +2068,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n          In_Tree.Project_Nodes.Table (Node).Kind =\n            N_String_Type_Declaration);\n@@ -2046,7 +2086,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Packages := To;\n@@ -2063,7 +2103,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Field3 := To;\n@@ -2080,7 +2120,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -2097,7 +2137,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n@@ -2116,7 +2156,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -2132,7 +2172,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n@@ -2150,7 +2190,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n              In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause);\n       In_Tree.Project_Nodes.Table (Node).Flag1 := True;\n@@ -2166,7 +2206,7 @@ package body Prj.Tree is\n       To      : Project_Node_Kind)\n    is\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       In_Tree.Project_Nodes.Table (Node).Kind := To;\n    end Set_Kind_Of;\n \n@@ -2180,7 +2220,7 @@ package body Prj.Tree is\n       To      : Source_Ptr)\n    is\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       In_Tree.Project_Nodes.Table (Node).Location := To;\n    end Set_Location_Of;\n \n@@ -2195,7 +2235,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -2212,7 +2252,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Value := Name_Id (To);\n@@ -2229,7 +2269,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Project_Declaration);\n       In_Tree.Project_Nodes.Table (Node).Field3 := To;\n@@ -2245,7 +2285,7 @@ package body Prj.Tree is\n       To      : Name_Id)\n    is\n    begin\n-      pragma Assert (Node /= Empty_Node);\n+      pragma Assert (Present (Node));\n       In_Tree.Project_Nodes.Table (Node).Name := To;\n    end Set_Name_Of;\n \n@@ -2260,7 +2300,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Declarative_Item);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -2287,7 +2327,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Expression);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -2304,7 +2344,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -2321,7 +2361,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n       In_Tree.Project_Nodes.Table (Node).Field3 := To;\n@@ -2338,7 +2378,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n          In_Tree.Project_Nodes.Table (Node).Kind =\n            N_String_Type_Declaration);\n@@ -2356,7 +2396,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -2373,7 +2413,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Typed_Variable_Declaration\n@@ -2394,7 +2434,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -2411,7 +2451,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n       In_Tree.Project_Nodes.Table (Node).Pkg_Id := To;\n@@ -2428,7 +2468,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Variable_Reference\n                or else\n@@ -2447,7 +2487,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Project\n                or else\n@@ -2483,7 +2523,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n          and then\n            In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Field2 := To;\n@@ -2500,11 +2540,27 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n       In_Tree.Project_Nodes.Table (Node).Qualifier := To;\n    end Set_Project_Qualifier_Of;\n \n+   ---------------------------\n+   -- Set_Parent_Project_Of --\n+   ---------------------------\n+\n+   procedure Set_Parent_Project_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id)\n+   is\n+   begin\n+      pragma Assert\n+        (Present (Node)\n+          and then In_Tree.Project_Nodes.Table (Node).Kind = N_Project);\n+      In_Tree.Project_Nodes.Table (Node).Field4 := To;\n+   end Set_Parent_Project_Of;\n+\n    -----------------------------------------------\n    -- Set_Project_File_Includes_Unkept_Comments --\n    -----------------------------------------------\n@@ -2532,7 +2588,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n                or else\n@@ -2559,7 +2615,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             In_Tree.Project_Nodes.Table (Node).Kind = N_Package_Declaration);\n       In_Tree.Project_Nodes.Table (Node).Field1 := To;\n@@ -2576,7 +2632,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n             or else\n@@ -2596,7 +2652,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Variable_Reference\n@@ -2624,7 +2680,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n                or else\n@@ -2644,7 +2700,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n             (In_Tree.Project_Nodes.Table (Node).Kind = N_Literal_String\n               or else\n@@ -2663,7 +2719,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind =\n               N_Variable_Reference\n@@ -2688,7 +2744,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (Node /= Empty_Node\n+        (Present (Node)\n           and then\n            (In_Tree.Project_Nodes.Table (Node).Kind = N_With_Clause\n               or else\n@@ -2709,7 +2765,7 @@ package body Prj.Tree is\n    is\n    begin\n       pragma Assert\n-        (For_Typed_Variable /= Empty_Node\n+        (Present (For_Typed_Variable)\n           and then\n            (In_Tree.Project_Nodes.Table (For_Typed_Variable).Kind =\n                                      N_Typed_Variable_Declaration));\n@@ -2721,15 +2777,15 @@ package body Prj.Tree is\n                                In_Tree);\n \n       begin\n-         while Current_String /= Empty_Node\n+         while Present (Current_String)\n            and then\n              String_Value_Of (Current_String, In_Tree) /= Value\n          loop\n             Current_String :=\n               Next_Literal_String (Current_String, In_Tree);\n          end loop;\n \n-         return Current_String /= Empty_Node;\n+         return Present (Current_String);\n       end;\n \n    end Value_Is_Valid;"}, {"sha": "94526660e202f73b8d7703d2ce64a63f592262c2", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -90,6 +90,14 @@ package Prj.Tree is\n    --  of the fields in each node of Project_Node_Kind, look at package\n    --  Tree_Private_Part.\n \n+   function Present (Node : Project_Node_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Return True iff Node /= Empty_Node\n+\n+   function No (Node : Project_Node_Id) return Boolean;\n+   pragma Inline (No);\n+   --  Return True iff Node = Empty_Node\n+\n    procedure Initialize (Tree : Project_Node_Tree_Ref);\n    --  Initialize the Project File tree: empty the Project_Nodes table\n    --  and reset the Projects_Htable.\n@@ -262,10 +270,15 @@ package Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Boolean;\n    --  Valid only for N_Comment nodes\n \n+   function Parent_Project_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n+   pragma Inline (Parent_Project_Of);\n+   --  Valid only for N_Project nodes\n+\n    function Project_File_Includes_Unkept_Comments\n      (Node    : Project_Node_Id;\n-      In_Tree : Project_Node_Tree_Ref)\n-      return Boolean;\n+      In_Tree : Project_Node_Tree_Ref) return Boolean;\n    --  Valid only for N_Project nodes\n \n    function Directory_Of\n@@ -631,6 +644,11 @@ package Prj.Tree is\n       To      : Project_Node_Id);\n    pragma Inline (Set_Next_Comment);\n \n+   procedure Set_Parent_Project_Of\n+     (Node    : Project_Node_Id;\n+      In_Tree : Project_Node_Tree_Ref;\n+      To      : Project_Node_Id);\n+\n    procedure Set_Project_File_Includes_Unkept_Comments\n      (Node    : Project_Node_Id;\n       In_Tree : Project_Node_Tree_Ref;\n@@ -972,6 +990,9 @@ package Prj.Tree is\n          Field3 : Project_Node_Id := Empty_Node;\n          --  See below the meaning for each Project_Node_Kind\n \n+         Field4 : Project_Node_Id := Empty_Node;\n+         --  See below the meaning for each Project_Node_Kind\n+\n          Flag1 : Boolean := False;\n          --  This flag is significant only for:\n          --    N_Attribute_Declaration and N_Attribute_Reference\n@@ -1019,6 +1040,7 @@ package Prj.Tree is\n       --    --  Field1:    first with clause\n       --    --  Field2:    project declaration\n       --    --  Field3:    first string type\n+      --    --  Field4:    parent project, if any\n       --    --  Value:     extended project path name (if any)\n \n       --    N_With_Clause,\n@@ -1028,6 +1050,7 @@ package Prj.Tree is\n       --    --  Field1:    project node\n       --    --  Field2:    next with clause\n       --    --  Field3:    project node or empty if \"limited with\"\n+      --    --  Field4:    not used\n       --    --  Value:     literal string withed\n \n       --    N_Project_Declaration,\n@@ -1037,6 +1060,7 @@ package Prj.Tree is\n       --    --  Field1:    first declarative item\n       --    --  Field2:    extended project\n       --    --  Field3:    extending project\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Declarative_Item,\n@@ -1046,6 +1070,7 @@ package Prj.Tree is\n       --    --  Field1:    current item node\n       --    --  Field2:    next declarative item\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Package_Declaration,\n@@ -1055,6 +1080,7 @@ package Prj.Tree is\n       --    --  Field1:    project of renamed package (if any)\n       --    --  Field2:    first declarative item\n       --    --  Field3:    next package in project\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_String_Type_Declaration,\n@@ -1064,6 +1090,7 @@ package Prj.Tree is\n       --    --  Field1:    first literal string\n       --    --  Field2:    next string type\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Literal_String,\n@@ -1073,6 +1100,7 @@ package Prj.Tree is\n       --    --  Field1:    next literal string\n       --    --  Field2:    not used\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     string value\n \n       --    N_Attribute_Declaration,\n@@ -1082,6 +1110,7 @@ package Prj.Tree is\n       --    --  Field1:    expression\n       --    --  Field2:    project of full associative array\n       --    --  Field3:    package of full associative array\n+      --    --  Field4:    not used\n       --    --  Value:     associative array index\n       --    --             (if an associative array element)\n \n@@ -1092,6 +1121,7 @@ package Prj.Tree is\n       --    --  Field1:    expression\n       --    --  Field2:    type of variable (N_String_Type_Declaration)\n       --    --  Field3:    next variable\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Variable_Declaration,\n@@ -1105,6 +1135,7 @@ package Prj.Tree is\n       --    --             N_Variable_Declaration and\n       --    --             N_Typed_Variable_Declaration\n       --    --  Field3:    next variable\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Expression,\n@@ -1123,6 +1154,7 @@ package Prj.Tree is\n       --    --  Field1:    current term\n       --    --  Field2:    next term in the expression\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Literal_String_List,\n@@ -1135,6 +1167,7 @@ package Prj.Tree is\n       --    --  Field1:    first expression\n       --    --  Field2:    not used\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Variable_Reference,\n@@ -1144,6 +1177,7 @@ package Prj.Tree is\n       --    --  Field1:    project (if specified)\n       --    --  Field2:    package (if specified)\n       --    --  Field3:    type of variable (N_String_Type_Declaration), if any\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_External_Value,\n@@ -1162,6 +1196,7 @@ package Prj.Tree is\n       --    --  Field1:    project\n       --    --  Field2:    package (if attribute of a package)\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     associative array index\n       --    --             (if an associative array element)\n \n@@ -1172,6 +1207,7 @@ package Prj.Tree is\n       --    --  Field1:    case variable reference\n       --    --  Field2:    first case item\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Case_Item\n@@ -1182,6 +1218,7 @@ package Prj.Tree is\n       --    --             for when others\n       --    --  Field2:    first declarative item\n       --    --  Field3:    next case item\n+      --    --  Field4:    not used\n       --    --  Value:     not used\n \n       --    N_Comment_zones\n@@ -1192,6 +1229,7 @@ package Prj.Tree is\n       --    --  Field2:    comment after the construct\n       --    --  Field3:    comment before the \"end\" of the construct\n       --    --  Value:     end of line comment\n+      --    --  Field4:    not used\n       --    --  Comments:  comment after the \"end\" of the construct\n \n       --    N_Comment\n@@ -1201,6 +1239,7 @@ package Prj.Tree is\n       --    --  Field1:    not used\n       --    --  Field2:    not used\n       --    --  Field3:    not used\n+      --    --  Field4:    not used\n       --    --  Value:     comment\n       --    --  Flag1:     comment is preceded by an empty line\n       --    --  Flag2:     comment is followed by an empty line\n@@ -1229,13 +1268,17 @@ package Prj.Tree is\n \n          Extended : Boolean;\n          --  True when the project is being extended by another project\n+\n+         Proj_Qualifier : Project_Qualifier;\n+         --  The project qualifier of the project, if any\n       end record;\n \n       No_Project_Name_And_Node : constant Project_Name_And_Node :=\n         (Name           => No_Name,\n          Node           => Empty_Node,\n          Canonical_Path => No_Path,\n-         Extended       => True);\n+         Extended       => True,\n+         Proj_Qualifier => Unspecified);\n \n       package Projects_Htable is new GNAT.Dynamic_HTables.Simple_HTable\n         (Header_Num => Header_Num,"}, {"sha": "0435509988eaa7937d771b83bb7af73143d8a062", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -122,6 +122,7 @@ package body Prj is\n                       Sources                        => Nil_String,\n                       First_Source                   => No_Source,\n                       Last_Source                    => No_Source,\n+                      Interfaces_Defined             => False,\n                       Unit_Based_Language_Name       => No_Name,\n                       Unit_Based_Language_Index      => No_Language_Index,\n                       Imported_Directories_Switches  => null,\n@@ -599,6 +600,11 @@ package body Prj is\n       return Hash (Get_Name_String (Name));\n    end Hash;\n \n+   function Hash (Project : Project_Id) return Header_Num is\n+   begin\n+      return Header_Num (Project mod Max_Header_Num);\n+   end Hash;\n+\n    -----------\n    -- Image --\n    -----------"}, {"sha": "c547eb66397037be5c6d22f0ce5ac2713e13b295", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 71, "deletions": 40, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -307,7 +307,8 @@ package Prj is\n       Language : Language_Index);\n    --  Output the name of a language\n \n-   type Header_Num is range 0 .. 6150;\n+   Max_Header_Num : constant := 6150;\n+   type Header_Num is range 0 .. Max_Header_Num;\n    --  Size for hash table below. The upper bound is an arbitrary value, the\n    --  value here was chosen after testing to determine a good compromise\n    --  between speed of access and memory usage.\n@@ -317,6 +318,9 @@ package Prj is\n    function Hash (Name : Path_Name_Type) return Header_Num;\n    --  Used for computing hash values for names put into above hash table\n \n+   function Hash (Project : Project_Id) return Header_Num;\n+   --  Used for hash tables where Project_Id is the Key\n+\n    type Language_Kind is (File_Based, Unit_Based);\n    --  Type for the kind of language. All languages are file based, except Ada\n    --  which is unit based.\n@@ -420,6 +424,13 @@ package Prj is\n       --  shared libraries. Specified in the configuration. When not specified,\n       --  there is no need for such switch.\n \n+      Object_Generated             : Boolean := True;\n+      --  False in no object file is generated\n+\n+      Objects_Linked               : Boolean := True;\n+      --  False if object files are not use to link executables and build\n+      --  libraries.\n+\n       Runtime_Library_Dir        : Name_Id := No_Name;\n       --  Path name of the runtime library directory, if any\n \n@@ -527,6 +538,8 @@ package Prj is\n                            Compiler_Driver_Path         => null,\n                            Compiler_Required_Switches   => No_Name_List,\n                            Compilation_PIC_Option       => No_Name_List,\n+                           Object_Generated             => True,\n+                           Objects_Linked               => True,\n                            Runtime_Library_Dir          => No_Name,\n                            Mapping_File_Switches        => No_Name_List,\n                            Mapping_Spec_Suffix          => No_File,\n@@ -616,6 +629,13 @@ package Prj is\n       Compiled            : Boolean               := True;\n       --  False when there is no compiler for the language\n \n+      In_Interfaces       : Boolean               := True;\n+      --  False when the source is not included in interfaces, when attribute\n+      --  Interfaces is declared.\n+\n+      Declared_In_Interfaces : Boolean            := False;\n+      --  True when source is declared in attribute Interfaces\n+\n       Alternate_Languages : Alternate_Language_Id := No_Alternate_Language;\n       --  List of languages a header file may also be, in addition of\n       --  language Language_Name.\n@@ -667,6 +687,10 @@ package Prj is\n       Object_Exists       : Boolean               := True;\n       --  True if an object file exists\n \n+      Object_Linked          : Boolean               := True;\n+      --  False if the object file is not use to link executables or included\n+      --  in libraries.\n+\n       Object              : File_Name_Type        := No_File;\n       --  File name of the object file\n \n@@ -714,42 +738,45 @@ package Prj is\n    end record;\n \n    No_Source_Data : constant Source_Data :=\n-                      (Project             => No_Project,\n-                       Language_Name       => No_Name,\n-                       Language            => No_Language_Index,\n-                       Lang_Kind           => File_Based,\n-                       Compiled            => True,\n-                       Alternate_Languages => No_Alternate_Language,\n-                       Kind                => Spec,\n-                       Dependency          => None,\n-                       Other_Part          => No_Source,\n-                       Unit                => No_Name,\n-                       Index               => 0,\n-                       Locally_Removed     => False,\n-                       Get_Object          => False,\n-                       Replaced_By         => No_Source,\n-                       File                => No_File,\n-                       Display_File        => No_File,\n-                       Path                => No_Path,\n-                       Display_Path        => No_Path,\n-                       Source_TS           => Empty_Time_Stamp,\n-                       Object_Project      => No_Project,\n-                       Object_Exists       => True,\n-                       Object              => No_File,\n-                       Current_Object_Path => No_Path,\n-                       Object_Path         => No_Path,\n-                       Object_TS           => Empty_Time_Stamp,\n-                       Dep_Name            => No_File,\n-                       Current_Dep_Path    => No_Path,\n-                       Dep_Path            => No_Path,\n-                       Dep_TS              => Empty_Time_Stamp,\n-                       Switches            => No_File,\n-                       Switches_Path       => No_Path,\n-                       Switches_TS         => Empty_Time_Stamp,\n-                       Naming_Exception    => False,\n-                       Next_In_Sources     => No_Source,\n-                       Next_In_Project     => No_Source,\n-                       Next_In_Lang        => No_Source);\n+                      (Project                => No_Project,\n+                       Language_Name          => No_Name,\n+                       Language               => No_Language_Index,\n+                       Lang_Kind              => File_Based,\n+                       Compiled               => True,\n+                       In_Interfaces          => True,\n+                       Declared_In_Interfaces => False,\n+                       Alternate_Languages    => No_Alternate_Language,\n+                       Kind                   => Spec,\n+                       Dependency             => None,\n+                       Other_Part             => No_Source,\n+                       Unit                   => No_Name,\n+                       Index                  => 0,\n+                       Locally_Removed        => False,\n+                       Get_Object             => False,\n+                       Replaced_By            => No_Source,\n+                       File                   => No_File,\n+                       Display_File           => No_File,\n+                       Path                   => No_Path,\n+                       Display_Path           => No_Path,\n+                       Source_TS              => Empty_Time_Stamp,\n+                       Object_Project         => No_Project,\n+                       Object_Exists          => True,\n+                       Object_Linked          => True,\n+                       Object                 => No_File,\n+                       Current_Object_Path    => No_Path,\n+                       Object_Path            => No_Path,\n+                       Object_TS              => Empty_Time_Stamp,\n+                       Dep_Name               => No_File,\n+                       Current_Dep_Path       => No_Path,\n+                       Dep_Path               => No_Path,\n+                       Dep_TS                 => Empty_Time_Stamp,\n+                       Switches               => No_File,\n+                       Switches_Path          => No_Path,\n+                       Switches_TS            => Empty_Time_Stamp,\n+                       Naming_Exception       => False,\n+                       Next_In_Sources        => No_Source,\n+                       Next_In_Project        => No_Source,\n+                       Next_In_Lang           => No_Source);\n \n    package Source_Data_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Source_Data,\n@@ -1267,9 +1294,6 @@ package Prj is\n       Dir_Path : String_Access;\n       --  Same as Directory, but as an access to String\n \n-      Library : Boolean := False;\n-      --  True if this is a library project\n-\n       Library_Dir : Path_Name_Type := No_Path;\n       --  If a library project, path name of the directory where the library\n       --  resides.\n@@ -1303,6 +1327,9 @@ package Prj is\n       --  be different from Library_ALI_Dir for platforms where the file names\n       --  are case-insensitive.\n \n+      Library : Boolean := False;\n+      --  True if this is a library project\n+\n       Library_Name : Name_Id := No_Name;\n       --  If a library project, name of the library\n \n@@ -1339,6 +1366,10 @@ package Prj is\n       Last_Source  : Source_Id := No_Source;\n       --  Head and tail of the list of sources\n \n+      Interfaces_Defined      : Boolean := False;\n+      --  True if attribute Interfaces is declared for the project or any\n+      --  project it extends.\n+\n       Unit_Based_Language_Name  : Name_Id := No_Name;\n       Unit_Based_Language_Index : Language_Index := No_Language_Index;\n       --  The name and index, if any, of the unit-based language of some"}, {"sha": "7e589fbfd4c6bdf2b9ef5923af3afd7c32e8931f", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -771,6 +771,8 @@ package body Snames is\n      \"mapping_body_suffix#\" &\n      \"metrics#\" &\n      \"naming#\" &\n+     \"object_generated#\" &\n+     \"objects_linked#\" &\n      \"objects_path#\" &\n      \"objects_path_file#\" &\n      \"object_dir#\" &"}, {"sha": "17779913af6a97de0145573bd381b4e34a7f3975", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f469be30bf03ea36b23f390b7446f499cb5be5e/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=4f469be30bf03ea36b23f390b7446f499cb5be5e", "patch": "@@ -1092,56 +1092,58 @@ package Snames is\n    Name_Mapping_Body_Suffix            : constant Name_Id := N + 710;\n    Name_Metrics                        : constant Name_Id := N + 711;\n    Name_Naming                         : constant Name_Id := N + 712;\n-   Name_Objects_Path                   : constant Name_Id := N + 713;\n-   Name_Objects_Path_File              : constant Name_Id := N + 714;\n-   Name_Object_Dir                     : constant Name_Id := N + 715;\n-   Name_Pic_Option                     : constant Name_Id := N + 716;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 717;\n-   Name_Prefix                         : constant Name_Id := N + 718;\n-   Name_Project                        : constant Name_Id := N + 719;\n-   Name_Roots                          : constant Name_Id := N + 720;\n-   Name_Required_Switches              : constant Name_Id := N + 721;\n-   Name_Run_Path_Option                : constant Name_Id := N + 722;\n-   Name_Runtime_Project                : constant Name_Id := N + 723;\n-   Name_Shared_Library_Minimum_Switches : constant Name_Id := N + 724;\n-   Name_Shared_Library_Prefix          : constant Name_Id := N + 725;\n-   Name_Shared_Library_Suffix          : constant Name_Id := N + 726;\n-   Name_Separate_Suffix                : constant Name_Id := N + 727;\n-   Name_Source_Dirs                    : constant Name_Id := N + 728;\n-   Name_Source_Files                   : constant Name_Id := N + 729;\n-   Name_Source_List_File               : constant Name_Id := N + 730;\n-   Name_Spec                           : constant Name_Id := N + 731;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 732;\n-   Name_Specification                  : constant Name_Id := N + 733;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 734;\n-   Name_Specification_Suffix           : constant Name_Id := N + 735;\n-   Name_Stack                          : constant Name_Id := N + 736;\n-   Name_Switches                       : constant Name_Id := N + 737;\n-   Name_Symbolic_Link_Supported        : constant Name_Id := N + 738;\n-   Name_Sync                           : constant Name_Id := N + 739;\n-   Name_Synchronize                    : constant Name_Id := N + 740;\n-   Name_Toolchain_Description          : constant Name_Id := N + 741;\n-   Name_Toolchain_Version              : constant Name_Id := N + 742;\n-   Name_Runtime_Library_Dir            : constant Name_Id := N + 743;\n+   Name_Object_Generated               : constant Name_Id := N + 713;\n+   Name_Objects_Linked                 : constant Name_Id := N + 714;\n+   Name_Objects_Path                   : constant Name_Id := N + 715;\n+   Name_Objects_Path_File              : constant Name_Id := N + 716;\n+   Name_Object_Dir                     : constant Name_Id := N + 717;\n+   Name_Pic_Option                     : constant Name_Id := N + 718;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 719;\n+   Name_Prefix                         : constant Name_Id := N + 720;\n+   Name_Project                        : constant Name_Id := N + 721;\n+   Name_Roots                          : constant Name_Id := N + 722;\n+   Name_Required_Switches              : constant Name_Id := N + 723;\n+   Name_Run_Path_Option                : constant Name_Id := N + 724;\n+   Name_Runtime_Project                : constant Name_Id := N + 725;\n+   Name_Shared_Library_Minimum_Switches : constant Name_Id := N + 726;\n+   Name_Shared_Library_Prefix          : constant Name_Id := N + 727;\n+   Name_Shared_Library_Suffix          : constant Name_Id := N + 728;\n+   Name_Separate_Suffix                : constant Name_Id := N + 729;\n+   Name_Source_Dirs                    : constant Name_Id := N + 730;\n+   Name_Source_Files                   : constant Name_Id := N + 731;\n+   Name_Source_List_File               : constant Name_Id := N + 732;\n+   Name_Spec                           : constant Name_Id := N + 733;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 734;\n+   Name_Specification                  : constant Name_Id := N + 735;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 736;\n+   Name_Specification_Suffix           : constant Name_Id := N + 737;\n+   Name_Stack                          : constant Name_Id := N + 738;\n+   Name_Switches                       : constant Name_Id := N + 739;\n+   Name_Symbolic_Link_Supported        : constant Name_Id := N + 740;\n+   Name_Sync                           : constant Name_Id := N + 741;\n+   Name_Synchronize                    : constant Name_Id := N + 742;\n+   Name_Toolchain_Description          : constant Name_Id := N + 743;\n+   Name_Toolchain_Version              : constant Name_Id := N + 744;\n+   Name_Runtime_Library_Dir            : constant Name_Id := N + 745;\n \n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 744;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 746;\n \n    --  Ada 2005 reserved words\n \n-   First_2005_Reserved_Word            : constant Name_Id := N + 745;\n-   Name_Interface                      : constant Name_Id := N + 745;\n-   Name_Overriding                     : constant Name_Id := N + 746;\n-   Name_Synchronized                   : constant Name_Id := N + 747;\n-   Last_2005_Reserved_Word             : constant Name_Id := N + 747;\n+   First_2005_Reserved_Word            : constant Name_Id := N + 747;\n+   Name_Interface                      : constant Name_Id := N + 747;\n+   Name_Overriding                     : constant Name_Id := N + 748;\n+   Name_Synchronized                   : constant Name_Id := N + 749;\n+   Last_2005_Reserved_Word             : constant Name_Id := N + 749;\n \n    subtype Ada_2005_Reserved_Words is\n      Name_Id range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 747;\n+   Last_Predefined_Name                : constant Name_Id := N + 749;\n \n    ---------------------------------------\n    -- Subtypes Defining Name Categories --"}]}