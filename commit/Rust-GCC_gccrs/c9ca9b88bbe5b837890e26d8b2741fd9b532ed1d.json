{"sha": "c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzljYTliODhiYmU1YjgzNzg5MGUyNmQ4YjI3NDFmZDliNTMyZWQxZA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-10T16:22:47Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-10T16:22:47Z"}, "message": "arm-protos.h (arm_set_return_address, [...]): Add prototypes.\n\n\t* config/arm/arm-protos.h (arm_set_return_address,\n\tthumb_set_return_address): Add prototypes.\n\t* config/arm/arm.h (ARM_FT_EXCEPTION_HANDLER): Remove.\n\t* config/arm/arm.c (arm_compute_func_type,\n\tuse_return_insn, arm_compute_save_reg0_reg12_mask,\n\tarm_compute_save_reg_mask, arm_output_function_prologue,\n\tarm_output_epilogue): Replace ARM_FT_EXCEPTION_HANDLER with\n\tcurrent_function_calls_eh_return.\n\t(thumb_exit, thumb_pushpop, thumb_unexpanded_epilogue): Replace\n\told eh code.\n\t(arm_set_return_address, thumb_set_return_address): New functions.\n\t* config/arm/arm.h (MUST_USE_SJLJ_EXCEPTIONS, DWARF2_UNWIND_INFO,\n\tARM_EH_STACKADJ_REGNUM, EH_RETURN_STACKADJ_RTX): Define.\n\t* config/arm/arm.md (VUNSPEC_EH_RETURN): Add.\n\t(epilogue): Use the stackadj register.\n\t(eh_return, arm_eh_return, thumb_eh_return): New pattern.\n\nFrom-SVN: r85757", "tree": {"sha": "96cfc069e4732b07c0d7b674918a451d0b47ad81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96cfc069e4732b07c0d7b674918a451d0b47ad81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/comments", "author": null, "committer": null, "parents": [{"sha": "f97b53df7861000942c76bf84914ce247db96769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f97b53df7861000942c76bf84914ce247db96769", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f97b53df7861000942c76bf84914ce247db96769"}], "stats": {"total": 323, "additions": 247, "deletions": 76}, "files": [{"sha": "6ec2c5d359ac17f95fc5d4f3eab5d8d60c9a54d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "patch": "@@ -1,3 +1,22 @@\n+2004-08-10  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm-protos.h (arm_set_return_address,\n+\tthumb_set_return_address): Add prototypes.\n+\t* config/arm/arm.h (ARM_FT_EXCEPTION_HANDLER): Remove.\n+\t* config/arm/arm.c (arm_compute_func_type,\n+\tuse_return_insn, arm_compute_save_reg0_reg12_mask,\n+\tarm_compute_save_reg_mask, arm_output_function_prologue,\n+\tarm_output_epilogue): Replace ARM_FT_EXCEPTION_HANDLER with\n+\tcurrent_function_calls_eh_return.\n+\t(thumb_exit, thumb_pushpop, thumb_unexpanded_epilogue): Replace\n+\told eh code.\n+\t(arm_set_return_address, thumb_set_return_address): New functions.\n+\t* config/arm/arm.h (MUST_USE_SJLJ_EXCEPTIONS, DWARF2_UNWIND_INFO,\n+\tARM_EH_STACKADJ_REGNUM, EH_RETURN_STACKADJ_RTX): Define.\n+\t* config/arm/arm.md (VUNSPEC_EH_RETURN): Add.\n+\t(epilogue): Use the stackadj register.\n+\t(eh_return, arm_eh_return, thumb_eh_return): New pattern.\n+\n 2004-08-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/3144"}, {"sha": "e2224557dc1968caa989a4baac81ce871cede3c7", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "patch": "@@ -151,6 +151,7 @@ extern int arm_is_longcall_p (rtx, int, int);\n extern int    arm_emit_vector_const (FILE *, rtx);\n extern const char * arm_output_load_gr (rtx *);\n extern const char *vfp_output_fstmx (rtx *);\n+extern void arm_set_return_address (rtx, rtx);\n \n #if defined TREE_CODE\n extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n@@ -194,6 +195,7 @@ extern int thumb_go_if_legitimate_address (enum machine_mode, rtx);\n extern rtx arm_return_addr (int, rtx);\n extern void thumb_reload_out_hi (rtx *);\n extern void thumb_reload_in_hi (rtx *);\n+extern void thumb_set_return_address (rtx, rtx);\n #endif\n \n /* Defined in pe.c.  */"}, {"sha": "240d96c67a423fb13708d881ade782caff680d07", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 164, "deletions": 73, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "patch": "@@ -87,7 +87,7 @@ static const char *shift_op (rtx, HOST_WIDE_INT *);\n static struct machine_function *arm_init_machine_status (void);\n static int number_of_first_bit_set (int);\n static void replace_symbols_in_block (tree, rtx, rtx);\n-static void thumb_exit (FILE *, int, rtx);\n+static void thumb_exit (FILE *, int);\n static void thumb_pushpop (FILE *, int, int, int *, int);\n static rtx is_jump_table (rtx);\n static HOST_WIDE_INT get_jump_table_size (rtx);\n@@ -1142,19 +1142,14 @@ arm_compute_func_type (void)\n   if (a != NULL_TREE)\n     type |= ARM_FT_NAKED;\n \n-  if (cfun->machine->eh_epilogue_sp_ofs != NULL_RTX)\n-    type |= ARM_FT_EXCEPTION_HANDLER;\n+  a = lookup_attribute (\"isr\", attr);\n+  if (a == NULL_TREE)\n+    a = lookup_attribute (\"interrupt\", attr);\n+  \n+  if (a == NULL_TREE)\n+    type |= TARGET_INTERWORK ? ARM_FT_INTERWORKED : ARM_FT_NORMAL;\n   else\n-    {\n-      a = lookup_attribute (\"isr\", attr);\n-      if (a == NULL_TREE)\n-\ta = lookup_attribute (\"interrupt\", attr);\n-      \n-      if (a == NULL_TREE)\n-\ttype |= TARGET_INTERWORK ? ARM_FT_INTERWORKED : ARM_FT_NORMAL;\n-      else\n-\ttype |= arm_isr_value (TREE_VALUE (a));\n-    }\n+    type |= arm_isr_value (TREE_VALUE (a));\n   \n   return type;\n }\n@@ -1205,7 +1200,7 @@ use_return_insn (int iscond, rtx sibling)\n   if (current_function_pretend_args_size\n       || cfun->machine->uses_anonymous_args\n       /* Or if the function calls __builtin_eh_return () */\n-      || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n+      || current_function_calls_eh_return\n       /* Or if the function calls alloca */\n       || current_function_calls_alloca\n       /* Or if there is a stack adjustment.  However, if the stack pointer\n@@ -8899,7 +8894,7 @@ output_ascii_pseudo_op (FILE *stream, const unsigned char *p, int len)\n   fputs (\"\\\"\\n\", stream);\n }\n \f\n-/* Compute the register sabe mask for registers 0 through 12\n+/* Compute the register save mask for registers 0 through 12\n    inclusive.  This code is used by arm_compute_save_reg_mask.  */\n static unsigned long\n arm_compute_save_reg0_reg12_mask (void)\n@@ -8955,6 +8950,20 @@ arm_compute_save_reg0_reg12_mask (void)\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n     }\n \n+  /* Save registers so the exception handler can modify them.  */\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i;\n+      \n+      for (i = 0; ; i++)\n+\t{\n+\t  reg = EH_RETURN_DATA_REGNO (i);\n+\t  if (reg == INVALID_REGNUM)\n+\t    break;\n+\t  save_reg_mask |= 1 << reg;\n+\t}\n+    }\n+\n   return save_reg_mask;\n }\n \n@@ -8999,7 +9008,8 @@ arm_compute_save_reg_mask (void)\n   if (regs_ever_live [LR_REGNUM]\n \t  || (save_reg_mask\n \t      && optimize_size\n-\t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL))\n+\t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n+\t      && !current_function_calls_eh_return))\n     save_reg_mask |= 1 << LR_REGNUM;\n \n   if (cfun->machine->lr_save_eliminated)\n@@ -9356,9 +9366,6 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n     case ARM_FT_INTERWORKED:\n       asm_fprintf (f, \"\\t%@ Function supports interworking.\\n\");\n       break;\n-    case ARM_FT_EXCEPTION_HANDLER:\n-      asm_fprintf (f, \"\\t%@ C++ Exception Handler.\\n\");\n-      break;\n     case ARM_FT_ISR:\n       asm_fprintf (f, \"\\t%@ Interrupt Service Routine.\\n\");\n       break;\n@@ -9390,6 +9397,9 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n   if (cfun->machine->lr_save_eliminated)\n     asm_fprintf (f, \"\\t%@ link register save eliminated.\\n\");\n \n+  if (current_function_calls_eh_return)\n+    asm_fprintf (f, \"\\t@ Calls __builtin_eh_return.\\n\");\n+\n #ifdef AOF_ASSEMBLER\n   if (flag_pic)\n     asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", IP_REGNUM, PIC_OFFSET_TABLE_REGNUM);\n@@ -9409,7 +9419,6 @@ arm_output_epilogue (rtx sibling)\n   int floats_offset = 0;\n   rtx operands[3];\n   FILE * f = asm_out_file;\n-  rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   unsigned int lrm_count = 0;\n   int really_return = (sibling == NULL);\n   int start_reg;\n@@ -9438,7 +9447,7 @@ arm_output_epilogue (rtx sibling)\n       return \"\";\n     }\n \n-  if (ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n+  if (current_function_calls_eh_return\n       && ! really_return)\n     /* If we are throwing an exception, then we really must\n        be doing a return,  so we can't tail-call.  */\n@@ -9572,7 +9581,9 @@ arm_output_epilogue (rtx sibling)\n \t only need to restore the LR register (the return address), but to\n \t save time we can load it directly into the PC, unless we need a\n \t special function exit sequence, or we are not really returning.  */\n-      if (really_return && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)\n+      if (really_return\n+\t  && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n+\t  && !current_function_calls_eh_return)\n \t/* Delete the LR from the register mask, so that the LR on\n \t   the stack is loaded into the PC in the register mask.  */\n \tsaved_regs_mask &= ~ (1 << LR_REGNUM);\n@@ -9677,7 +9688,8 @@ arm_output_epilogue (rtx sibling)\n       if (ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n \t  && really_return\n \t  && current_function_pretend_args_size == 0\n-\t  && saved_regs_mask & (1 << LR_REGNUM))\n+\t  && saved_regs_mask & (1 << LR_REGNUM)\n+\t  && !current_function_calls_eh_return)\n \t{\n \t  saved_regs_mask &= ~ (1 << LR_REGNUM);\n \t  saved_regs_mask |=   (1 << PC_REGNUM);\n@@ -9687,12 +9699,7 @@ arm_output_epilogue (rtx sibling)\n \t to load use the LDR instruction - it is faster.  */\n       if (saved_regs_mask == (1 << LR_REGNUM))\n \t{\n-\t  /* The exception handler ignores the LR, so we do\n-\t     not really need to load it off the stack.  */\n-\t  if (eh_ofs)\n-\t    asm_fprintf (f, \"\\tadd\\t%r, %r, #4\\n\", SP_REGNUM, SP_REGNUM);\n-\t  else\n-\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n+\t  asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n \t}\n       else if (saved_regs_mask)\n \t{\n@@ -9719,13 +9726,14 @@ arm_output_epilogue (rtx sibling)\n   if (!really_return || saved_regs_mask & (1 << PC_REGNUM))\n     return \"\";\n \n+  /* Stack adjustment for exception handler.  */\n+  if (current_function_calls_eh_return)\n+    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM, \n+\t\t ARM_EH_STACKADJ_REGNUM);\n+\n   /* Generate the return instruction.  */\n   switch ((int) ARM_FUNC_TYPE (func_type))\n     {\n-    case ARM_FT_EXCEPTION_HANDLER:\n-      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, EXCEPTION_LR_REGNUM);\n-      break;\n-\n     case ARM_FT_ISR:\n     case ARM_FT_FIQ:\n       asm_fprintf (f, \"\\tsubs\\t%r, %r, #4\\n\", PC_REGNUM, LR_REGNUM);\n@@ -9978,6 +9986,7 @@ thumb_force_lr_save (void)\n /* Compute the distance from register FROM to register TO.\n    These can be the arg pointer (26), the soft frame pointer (25),\n    the stack pointer (13) or the hard frame pointer (11).\n+   In thumb mode r7 is used as the soft frame pointer, if needed.\n    Typical stack layout looks like this:\n \n        old stack pointer -> |    |\n@@ -12443,7 +12452,7 @@ number_of_first_bit_set (int mask)\n    If 'reg_containing_return_addr' is -1, then the return address is\n    actually on the stack, at the stack pointer.  */\n static void\n-thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n+thumb_exit (FILE *f, int reg_containing_return_addr)\n {\n   unsigned regs_available_for_popping;\n   unsigned regs_to_pop;\n@@ -12458,15 +12467,8 @@ thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n   regs_to_pop = 0;\n   pops_needed = 0;\n \n-  /* There is an assumption here, that if eh_ofs is not NULL, the\n-     normal return address will have been pushed.  */\n-  if (reg_containing_return_addr == -1 || eh_ofs)\n+  if (reg_containing_return_addr == -1)\n     {\n-      /* When we are generating a return for __builtin_eh_return, \n-\t reg_containing_return_addr must specify the return regno.  */\n-      if (eh_ofs && reg_containing_return_addr == -1)\n-\tabort ();\n-\n       regs_to_pop |= 1 << LR_REGNUM;\n       ++pops_needed;\n     }\n@@ -12482,8 +12484,8 @@ thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n      return.  */\n   if (pops_needed == 0)\n     {\n-      if (eh_ofs)\n-\tasm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, REGNO (eh_ofs));\n+      if (current_function_calls_eh_return)\n+\tasm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, ARM_EH_STACKADJ_REGNUM);\n \n       asm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n       return;\n@@ -12493,17 +12495,10 @@ thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n      just pop the return address straight into the PC.  */\n   else if (!TARGET_INTERWORK\n \t   && !TARGET_BACKTRACE\n-\t   && !is_called_in_ARM_mode (current_function_decl))\n+\t   && !is_called_in_ARM_mode (current_function_decl)\n+\t   && !current_function_calls_eh_return)\n     {\n-      if (eh_ofs)\n-\t{\n-\t  asm_fprintf (f, \"\\tadd\\t%r, #4\\n\", SP_REGNUM);\n-\t  asm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, REGNO (eh_ofs));\n-\t  asm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n-\t}\n-      else\n-\tasm_fprintf (f, \"\\tpop\\t{%r}\\n\", PC_REGNUM);\n-\n+      asm_fprintf (f, \"\\tpop\\t{%r}\\n\", PC_REGNUM);\n       return;\n     }\n \n@@ -12512,7 +12507,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n \n   /* If returning via __builtin_eh_return, the bottom three registers\n      all contain information needed for the return.  */\n-  if (eh_ofs)\n+  if (current_function_calls_eh_return)\n     size = 12;\n   else\n     {\n@@ -12723,8 +12718,8 @@ thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n       asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", LAST_ARG_REGNUM, IP_REGNUM);\n     }\n \n-  if (eh_ofs)\n-    asm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, REGNO (eh_ofs));\n+  if (current_function_calls_eh_return)\n+    asm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, ARM_EH_STACKADJ_REGNUM);\n \n   /* Return to caller.  */\n   asm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n@@ -12745,11 +12740,11 @@ thumb_pushpop (FILE *f, int mask, int push, int *cfa_offset, int real_regs)\n   int lo_mask = mask & 0xFF;\n   int pushed_words = 0;\n \n-  if (lo_mask == 0 && !push && (mask & (1 << 15)))\n+  if (lo_mask == 0 && !push && (mask & (1 << PC_REGNUM)))\n     {\n       /* Special case.  Do not generate a POP PC statement here, do it in\n \t thumb_exit() */\n-      thumb_exit (f, -1, NULL_RTX);\n+      thumb_exit (f, -1);\n       return;\n     }\n       \n@@ -12782,13 +12777,14 @@ thumb_pushpop (FILE *f, int mask, int push, int *cfa_offset, int real_regs)\n   else if (!push && (mask & (1 << PC_REGNUM)))\n     {\n       /* Catch popping the PC.  */\n-      if (TARGET_INTERWORK || TARGET_BACKTRACE)\n+      if (TARGET_INTERWORK || TARGET_BACKTRACE\n+\t  || current_function_calls_eh_return)\n \t{\n \t  /* The PC is never poped directly, instead\n \t     it is popped into r3 and then BX is used.  */\n \t  fprintf (f, \"}\\n\");\n \n-\t  thumb_exit (f, -1, NULL_RTX);\n+\t  thumb_exit (f, -1);\n \n \t  return;\n \t}\n@@ -12942,7 +12938,6 @@ thumb_unexpanded_epilogue (void)\n   int live_regs_mask = 0;\n   int high_regs_pushed = 0;\n   int had_to_push_lr;\n-  rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n \n   if (return_used_this_function)\n     return \"\";\n@@ -13050,8 +13045,7 @@ thumb_unexpanded_epilogue (void)\n   if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n     {\n       if (had_to_push_lr\n-\t  && !is_called_in_ARM_mode (current_function_decl)\n-\t  && !eh_ofs)\n+\t  && !is_called_in_ARM_mode (current_function_decl))\n \tlive_regs_mask |= 1 << PC_REGNUM;\n \n       /* Either no argument registers were pushed or a backtrace\n@@ -13061,17 +13055,15 @@ thumb_unexpanded_epilogue (void)\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE, NULL,\n \t\t       live_regs_mask);\n       \n-      if (eh_ofs)\n-\tthumb_exit (asm_out_file, 2, eh_ofs);\n       /* We have either just popped the return address into the\n \t PC or it is was kept in LR for the entire function or\n \t it is still on the stack because we do not want to\n \t return by doing a pop {pc}.  */\n-      else if ((live_regs_mask & (1 << PC_REGNUM)) == 0)\n+      if ((live_regs_mask & (1 << PC_REGNUM)) == 0)\n \tthumb_exit (asm_out_file,\n \t\t    (had_to_push_lr\n \t\t     && is_called_in_ARM_mode (current_function_decl)) ?\n-\t\t    -1 : LR_REGNUM, NULL_RTX);\n+\t\t    -1 : LR_REGNUM);\n     }\n   else\n     {\n@@ -13092,11 +13084,8 @@ thumb_unexpanded_epilogue (void)\n \t\t   SP_REGNUM, SP_REGNUM,\n \t\t   current_function_pretend_args_size);\n       \n-      if (eh_ofs)\n-\tthumb_exit (asm_out_file, 2, eh_ofs);\n-      else\n-\tthumb_exit (asm_out_file,\n-\t\t    had_to_push_lr ? LAST_ARG_REGNUM : LR_REGNUM, NULL_RTX);\n+      thumb_exit (asm_out_file,\n+\t\t  had_to_push_lr ? LAST_ARG_REGNUM : LR_REGNUM);\n     }\n \n   return \"\";\n@@ -14595,3 +14584,105 @@ arm_cxx_cdtor_returns_this (void)\n {\n   return TARGET_AAPCS_BASED;\n }\n+\n+\n+void\n+arm_set_return_address (rtx source, rtx scratch)\n+{\n+  arm_stack_offsets *offsets;\n+  HOST_WIDE_INT delta;\n+  rtx addr;\n+  unsigned long saved_regs;\n+\n+  saved_regs = arm_compute_save_reg_mask ();\n+\n+  if ((saved_regs & (1 << LR_REGNUM)) == 0)\n+    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);\n+  else\n+    {\n+      if (frame_pointer_needed)\n+\taddr = plus_constant(hard_frame_pointer_rtx, -4);\n+      else\n+\t{\n+\t  /* LR will be the first saved register.  */\n+\t  offsets = arm_get_frame_offsets ();\n+\t  delta = offsets->outgoing_args - (offsets->frame + 4);\n+\n+\t  \n+\t  if (delta >= 4096)\n+\t    {\n+\t      emit_insn (gen_addsi3 (scratch, stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (delta & ~4095)));\n+\t      addr = scratch;\n+\t      delta &= 4095;\n+\t    }\n+\t  else\n+\t    addr = stack_pointer_rtx;\n+\n+\t  addr = plus_constant (addr, delta);\n+\t}\n+      emit_move_insn (gen_rtx_MEM (Pmode, addr), source);\n+    }\n+}\n+\n+\n+void\n+thumb_set_return_address (rtx source, rtx scratch)\n+{\n+  arm_stack_offsets *offsets;\n+  bool lr_saved;\n+  HOST_WIDE_INT delta;\n+  int reg;\n+  rtx addr;\n+\n+  emit_insn (gen_rtx_USE (VOIDmode, source));\n+  lr_saved = FALSE;\n+  for (reg = 0; reg <= LAST_LO_REGNUM; reg++)\n+    {\n+      if (THUMB_REG_PUSHED_P (reg))\n+\t{\n+\t  lr_saved = TRUE;\n+\t  break;\n+\t}\n+    }\n+  lr_saved |= thumb_force_lr_save ();\n+\n+  if (lr_saved)\n+    {\n+      offsets = arm_get_frame_offsets ();\n+\n+      /* Find the saved regs.  */\n+      if (frame_pointer_needed)\n+\t{\n+\t  delta = offsets->soft_frame - offsets->saved_args;\n+\t  reg = THUMB_HARD_FRAME_POINTER_REGNUM;\n+\t}\n+      else\n+\t{\n+\t  delta = offsets->outgoing_args - offsets->saved_args;\n+\t  reg = SP_REGNUM;\n+\t}\n+      /* Allow for the stack frame.  */\n+      if (TARGET_BACKTRACE)\n+\tdelta -= 16;\n+      /* The link register is always the first saved register.  */\n+      delta -= 4;\n+      \n+      /* Construct the address.  */\n+      addr = gen_rtx_REG (SImode, reg);\n+      if ((reg != SP_REGNUM && delta >= 128)\n+\t  || delta >= 1024)\n+\t{\n+\t  emit_insn (gen_movsi (scratch, GEN_INT (delta)));\n+\t  emit_insn (gen_addsi3 (scratch, scratch, stack_pointer_rtx));\n+\t  addr = scratch;\n+\t}\n+      else\n+\taddr = plus_constant (addr, delta);\n+\n+      emit_move_insn (gen_rtx_MEM (Pmode, addr), source);\n+    }\n+  else\n+    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);\n+}\n+"}, {"sha": "5dfd4a0596dc434a5ae461441a40d301659b1d97", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "patch": "@@ -963,8 +963,17 @@ extern const char * structure_size_string;\n #define FIRST_HI_REGNUM\t\t8\n #define LAST_HI_REGNUM\t\t11\n \n+/* We use sjlj exceptions for backwards compatibility.  */\n+#define MUST_USE_SJLJ_EXCEPTIONS 1\n+/* We can generate DWARF2 Unwind info, even though we don't use it.  */\n+#define DWARF2_UNWIND_INFO 1\n+\t\t\t     \n+/* Use r0 and r1 to pass exception handling information.  */\n+#define EH_RETURN_DATA_REGNO(N) (((N) < 2) ? N : INVALID_REGNUM)\n+\n /* The register that holds the return address in exception handlers.  */\n-#define EXCEPTION_LR_REGNUM\t2\n+#define ARM_EH_STACKADJ_REGNUM\t2\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (SImode, ARM_EH_STACKADJ_REGNUM)\n \n /* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n    as an invisible last argument (possible since varargs don't exist in\n@@ -1592,7 +1601,6 @@ enum reg_class\n #define ARM_FT_UNKNOWN\t\t 0 /* Type has not yet been determined.  */\n #define ARM_FT_NORMAL\t\t 1 /* Your normal, straightforward function.  */\n #define ARM_FT_INTERWORKED\t 2 /* A function that supports interworking.  */\n-#define ARM_FT_EXCEPTION_HANDLER 3 /* A C++ exception handler.  */\n #define ARM_FT_ISR\t\t 4 /* An interrupt service routine.  */\n #define ARM_FT_FIQ\t\t 5 /* A fast interrupt service routine.  */\n #define ARM_FT_EXCEPTION\t 6 /* An ARM exception handler (subcase of ISR).  */"}, {"sha": "88aea2776868c75385ab8f088b85b62be1cb9ee3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c9ca9b88bbe5b837890e26d8b2741fd9b532ed1d", "patch": "@@ -117,6 +117,8 @@\n    (VUNSPEC_WCMP_EQ  11) ; Used by the iWMMXt WCMPEQ instructions\n    (VUNSPEC_WCMP_GTU 12) ; Used by the iWMMXt WCMPGTU instructions\n    (VUNSPEC_WCMP_GT  13) ; Used by the iwMMXT WCMPGT instructions\n+   (VUNSPEC_EH_RETURN 20); Use to overrite the return address for exception\n+\t\t\t ; handling.\n   ]\n )\n \f\n@@ -9703,9 +9705,11 @@\n )\n \n (define_expand \"epilogue\"\n-  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]\n+  [(clobber (const_int 0))]\n   \"TARGET_EITHER\"\n   \"\n+  if (current_function_calls_eh_return)\n+    emit_insn (gen_prologue_use (gen_rtx_REG (Pmode, 2)));\n   if (TARGET_THUMB)\n     thumb_expand_epilogue ();\n   else if (USE_RETURN_INSN (FALSE))\n@@ -10224,6 +10228,53 @@\n   \"%@ %0 needed for prologue\"\n )\n \n+\n+;; Patterns for exception handling\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\" \"\"))]\n+  \"TARGET_EITHER\"\n+  \"\n+  {\n+    if (TARGET_ARM)\n+      emit_insn (gen_arm_eh_return (operands[0]));\n+    else\n+      emit_insn (gen_thumb_eh_return (operands[0]));\n+    DONE;\n+  }\"\n+)\n+\t\t\t\t   \n+;; We can't expand this before we know where the link register is stored.\n+(define_insn_and_split \"arm_eh_return\"\n+  [(unspec_volatile [(match_operand:SI 0 \"s_register_operand\" \"r\")]\n+\t\t    VUNSPEC_EH_RETURN)\n+   (clobber (match_scratch:SI 1 \"=&r\"))]\n+  \"TARGET_ARM\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  {\n+    arm_set_return_address (operands[0], operands[1]);\n+    DONE;\n+  }\"\n+)\n+\n+(define_insn_and_split \"thumb_eh_return\"\n+  [(unspec_volatile [(match_operand:SI 0 \"s_register_operand\" \"l\")]\n+\t\t    VUNSPEC_EH_RETURN)\n+   (clobber (match_scratch:SI 1 \"=&l\"))]\n+  \"TARGET_THUMB\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  {\n+    thumb_set_return_address (operands[0], operands[1]);\n+    DONE;\n+  }\"\n+)\n+\n ;; Load the FPA co-processor patterns\n (include \"fpa.md\")\n ;; Load the Maverick co-processor patterns"}]}