{"sha": "d8747845fded660e09bab98470f77753a4216b6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg3NDc4NDVmZGVkNjYwZTA5YmFiOTg0NzBmNzc3NTNhNDIxNmI2ZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-04-14T17:35:23Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-04-14T17:35:23Z"}, "message": "PR c++/70652 - [6 Regression] r234966 causes bootstrap to fail\n\nPR c++/70652 - [6 Regression] r234966 causes bootstrap to fail\n  Revert patch for c++/69517, c++/70019, and c++/70588.\n\nFrom-SVN: r234981", "tree": {"sha": "83cb3798bea28b1aa1cc72277814a9f1a15bffd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83cb3798bea28b1aa1cc72277814a9f1a15bffd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8747845fded660e09bab98470f77753a4216b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8747845fded660e09bab98470f77753a4216b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8747845fded660e09bab98470f77753a4216b6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8747845fded660e09bab98470f77753a4216b6e/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "851285595028bdbb0eed29766e6eece1a884138e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851285595028bdbb0eed29766e6eece1a884138e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851285595028bdbb0eed29766e6eece1a884138e"}], "stats": {"total": 919, "additions": 47, "deletions": 872}, "files": [{"sha": "17de27f41c78d6e85eddccd5f3d8066d71f2f264", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -1,3 +1,10 @@\n+2016-04-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\tPR c++/70019\n+\tPR c++/70588\n+\t* doc/extend.texi (Variable Length): Revert.\n+\n 2016-04-14  Marek Polacek  <polacek@redhat.com>\n \t    Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "feb38c2922f70a2020613542dcbefd5e83ec140b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -1,3 +1,10 @@\n+2016-04-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\tPR c++/70019\n+\tPR c++/70588\n+\t* cp-tree.h, decl.c, init.c, typeck2.c: Revert.\n+\n 2016-04-14  Jason Merrill  <jason@redhat.com>\n \n \t* call.c, decl.c, error.c, cp-tree.h, decl.c: Revert empty"}, {"sha": "a3cd834a1055745bc65127534ec3d308cad81ac5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -5944,7 +5944,6 @@ extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n extern tree get_nsdmi\t\t\t\t(tree, bool);\n extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree throw_bad_array_length              (void);\n extern tree throw_bad_array_new_length\t\t(void);\n extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **, int,\n@@ -5966,7 +5965,6 @@ extern tree scalar_constant_value\t\t(tree);\n extern tree decl_really_constant_value\t\t(tree);\n extern int diagnose_uninitialized_cst_or_ref_member (tree, bool, bool);\n extern tree build_vtbl_address                  (tree);\n-extern tree build_vla_check                     (tree, tree = NULL_TREE);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);"}, {"sha": "380bc79ea53292266ded6e6225315136159a7b0d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -5892,16 +5892,6 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t    }\n \t}\n \n-      if (variably_modified_type_p (type, NULL_TREE))\n-\t{\n-\t  /* Require VLAs to have their initializers fully braced\n-\t     to avoid initializing the wrong elements.  */\n-\t  if (complain & tf_error)\n-\t    error (\"missing braces around initializer for a variable length \"\n-\t\t   \"array %qT\", type);\n-\t  return error_mark_node;\n-\t}\n-\n       warning (OPT_Wmissing_braces, \"missing braces around initializer for %qT\",\n \t       type);\n     }\n@@ -6054,10 +6044,6 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n     /* There is no way to make a variable-sized class type in GNU C++.  */\n     gcc_assert (TREE_CONSTANT (TYPE_SIZE (type)));\n \n-  /* Initializer exression used to check invalid VLA bounds and excess\n-     initializer elements.  */\n-  tree saved_init_for_vla_check = NULL_TREE;\n-\n   if (init && BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n       int init_len = vec_safe_length (CONSTRUCTOR_ELTS (init));\n@@ -6209,9 +6195,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t      && PAREN_STRING_LITERAL_P (DECL_INITIAL (decl)))\n \t    warning (0, \"array %qD initialized by parenthesized string literal %qE\",\n \t\t     decl, DECL_INITIAL (decl));\n-\n-\t  saved_init_for_vla_check = init;\n-\t  init = NULL_TREE;\n+\t  init = NULL;\n \t}\n     }\n   else\n@@ -6225,33 +6209,6 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n       check_for_uninitialized_const_var (decl);\n     }\n \n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && variably_modified_type_p (type, NULL_TREE)\n-      && !processing_template_decl)\n-    {\n-      /* Statically check for overflow in VLA bounds and build\n-\t an expression that checks at runtime whether the VLA\n-\t is erroneous due to invalid (runtime) bounds.\n-\t Another expression to check for excess initializers\n-\t is built in build_vec_init.  */\n-      tree check = build_vla_check (TREE_TYPE (decl), saved_init_for_vla_check);\n-\n-      if (flag_exceptions && current_function_decl\n-\t  /* Avoid instrumenting constexpr functions for now.\n-\t     Those must be checked statically, and the (non-\n-\t     constexpr) dynamic instrumentation would cause\n-\t     them to be rejected.  See c++/70507.  */\n-\t  && !DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n-\t{\n-\t  /* Use the runtime check only when exceptions are enabled.\n-\t     Otherwise let bad things happen...  */\n-\t  check = build3 (COND_EXPR, void_type_node, check,\n-\t\t\t  throw_bad_array_length (), void_node);\n-\n-\t  finish_expr_stmt (check);\n-\t}\n-    }\n-\n   if (init && init != error_mark_node)\n     init_code = build2 (INIT_EXPR, type, decl, init);\n "}, {"sha": "5997d53ddb5503dd727c09f52026289f4b7f3772", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -2262,20 +2262,6 @@ diagnose_uninitialized_cst_or_ref_member (tree type, bool using_new, bool compla\n   return diagnose_uninitialized_cst_or_ref_member_1 (type, type, using_new, complain);\n }\n \n-/* Call __cxa_throw_bad_array_length to indicate that the size calculation\n-   in the bounds of a variable length array overflowed.  */\n-\n-tree\n-throw_bad_array_length (void)\n-{\n-  tree fn = get_identifier (\"__cxa_throw_bad_array_length\");\n-  if (!get_global_value_if_present (fn, &fn))\n-    fn = push_throw_library_fn (fn, build_function_type_list (void_type_node,\n-                                                             NULL_TREE));\n-\n-  return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n-}\n-\n /* Call __cxa_bad_array_new_length to indicate that the size calculation\n    overflowed.  Pretend it returns sizetype so that it plays nicely in the\n    COND_EXPR.  */\n@@ -4723,304 +4709,3 @@ build_vec_delete (tree base, tree maxindex,\n \n   return rval;\n }\n-\n-\n-/* The implementation of build_vla_check() that recursively builds\n-   an expression to determine whether the VLA TYPE is erroneous due\n-   either to its bounds being invalid or to integer overflow in\n-   the computation of its total size.\n-   CHECK is the boolean expression being built, initialized to\n-   boolean_false_node.\n-   VLASIZE is used internally to pass the incrementally computed\n-   size of the VLA object down to its recursive invocations.\n-   MAX_VLASIZE is the maximum valid size of the VLA in bytes.\n-   CST_SIZE is the product of the VLA's constant dimensions.  */\n-\n-static tree\n-build_vla_size_check (tree check,\n-\t\t      tree type,\n-\t\t      tree vlasize,\n-\t\t      tree max_vlasize,\n-\t\t      offset_int *cst_size)\n-{\n-  tree vmul = builtin_decl_explicit (BUILT_IN_MUL_OVERFLOW);\n-\n-  tree vlasizeaddr = build_unary_op (input_location, ADDR_EXPR, vlasize, 0);\n-\n-  bool overflow = false;\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      /* Compute the upper bound of this array type.  */\n-      tree inner_nelts = array_type_nelts_top (type);\n-      tree inner_nelts_cst = maybe_constant_value (inner_nelts);\n-\n-      if (TREE_CODE (inner_nelts_cst) == INTEGER_CST)\n-\t{\n-\t  /* The upper bound is a constant expression.  Compute the product\n-\t     of the constant upper bounds seen so far so that overflow can\n-\t     be diagnosed.  */\n-\t  offset_int result = wi::mul (wi::to_offset (inner_nelts_cst),\n-\t\t\t\t       *cst_size, SIGNED, &overflow);\n-\t  *cst_size = overflow ? 0 : result;\n-\t}\n-\n-      /* Check for overflow in the VLAs (runtime) upper bounds.  */\n-      tree vflowcheck = build_call_expr (vmul, 3, inner_nelts,\n-\t\t\t\t\t vlasize, vlasizeaddr);\n-\n-      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t   check, vflowcheck);\n-\n-      /* Recursively check for overflow in the remaining major bounds.  */\n-      check = build_vla_size_check (check, TREE_TYPE (type),\n-\t\t\t\t    vlasize, max_vlasize,\n-\t\t\t\t    cst_size);\n-    }\n-  else\n-    {\n-      /* Get the size of the VLA element type in bytes.  */\n-      tree typesize = TYPE_SIZE_UNIT (type);\n-\n-      /* See if the size, when multipled by the product of the VLA's\n-\t constant dimensions, is within range of size_t.  If not,\n-\t the VLA is definitely erroneous amd must be diagnosed at\n-\t compile time.  */\n-      offset_int result = wi::mul (wi::to_offset (typesize), *cst_size,\n-\t\t\t\t   SIGNED, &overflow);\n-      *cst_size = overflow ? 0 : result;\n-\n-      /* Multiply the (non-constant) VLA size so far by the element size,\n-\t checking for overflow, and replacing the value of vlasize with\n-\t the product in the absence of overflow.  This size is the total\n-\t runtime size of the VLA in bytes.  */\n-      tree vflowcheck = build_call_expr (vmul, 3, typesize,\n-\t\t\t\t\t vlasize, vlasizeaddr);\n-\n-      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t   check, vflowcheck);\n-\n-      /* Check to see if the final VLA size exceeds the maximum.  */\n-      tree sizecheck = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t    max_vlasize, vlasize);\n-\n-      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t   check, sizecheck);\n-\n-      /* Also check to see if the final array size is zero (the size\n-\t is unsigned so the earlier overflow check detects negative\n-\t values as well.  */\n-      tree zerocheck = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t    vlasize, size_zero_node);\n-\n-      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t   check, zerocheck);\n-    }\n-\n-  /* Diagnose overflow determined at compile time.  */\n-  if (overflow)\n-    {\n-      error (\"integer overflow in variable array size\");\n-      /* Reset to suppress any further diagnostics.  */\n-      *cst_size = 0;\n-    }\n-\n-  return check;\n-}\n-\n-/* The implementation of build_vla_check() that recursively builds\n-   an expression to determine whether the VLA initializer-list for\n-   TYPE is erroneous due to excess initializers.\n-   CHECK is the boolean expression being built, initialized to\n-   the result of build_vla_size_check().\n-   INIT is the VLA initializer expression to check against TYPE.\n-   On the first (non-recursive) call, INIT_ELTS is set either to 1,\n-   or to the number of elements in the initializer-list for VLAs\n-   of unspecified (major) bound.  On subsequent (recursive) calls.\n-   it is set to NULL and computed from the number of elements in\n-   the (nested) initializer-list.\n-*/\n-\n-static tree\n-build_vla_init_check (tree check, tree type, tree init, tree init_elts)\n-{\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      /* Compute the upper bound of this array type unless it has\n-\t already been computed by the caller for an array of unspecified\n-\t bound, as in 'T a[];'  */\n-      tree inner_nelts = init_elts ? init_elts : array_type_nelts_top (type);\n-\n-      size_t len;\n-\n-      if (TREE_CODE (init) == CONSTRUCTOR)\n-\t{\n-\t  /* The initializer of this array is itself an array.  Build\n-\t     an expression to check if the number of elements in the\n-\t     initializer array exceeds the upper bound of the type\n-\t     of the object being initialized.  */\n-\t  if (vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init))\n-\t    {\n-\t      len = v->length ();\n-\t      tree initelts = build_int_cstu (size_type_node, len);\n-\t      tree initcheck = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t    inner_nelts, initelts);\n-\n-\t      check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t   check, initcheck);\n-\n-\t      constructor_elt *ce;\n-\t      HOST_WIDE_INT i;\n-\n-\t      /* Iterate over all non-empty initializers in this array,\n-\t\t recursively building expressions to see if the elements\n-\t\t of each are in excess of the corresponding (runtime)\n-\t\t bound of the array type.  */\n-\t      FOR_EACH_VEC_SAFE_ELT (v, i, ce)\n-\t\tcheck = build_vla_init_check (check, TREE_TYPE (type),\n-\t\t\t\t\t      ce->value, NULL_TREE);\n-\t    }\n-\t}\n-      else if (TREE_CODE (init) == STRING_CST\n-\t       && (len = TREE_STRING_LENGTH (init)))\n-\t{\n-\t  /* The initializer of this array is a string.  */\n-\t  tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n-\t  len /= TYPE_PRECISION (ctype) / BITS_PER_UNIT;\n-\n-\t  /* A C++ string literal initializer must have at most as many\n-\t     characters as there are elements in the array, including\n-\t     the terminating NUL.  */\n-\t  tree initelts = build_int_cstu (size_type_node, len);\n-\t  tree initcheck = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\tinner_nelts, initelts);\n-\t  check = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t       check, initcheck);\n-\t}\n-      else if (TREE_CODE (init) == ERROR_MARK)\n-\t{\n-\t  // No checking is possible.\n-\t  check = boolean_false_node;\n-\t}\n-      else\n-\t{\n-\t  /* What's this array initializer?  */\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-  return check;\n-}\n-\n-/* Build an expression to determine whether the VLA TYPE is erroneous.\n-   INIT is the VLA initializer expression or NULL_TREE when the VLA is\n-   not initialized.  */\n-\n-tree\n-build_vla_check (tree type, tree init /* = NULL_TREE */)\n-{\n-  tree check = boolean_false_node;\n-\n-  /* The product of all constant dimensions of the VLA, initialized\n-     to either 1 in the common case or to the number of elements in\n-     the VLA's initializer-list for VLAs of unspecified (major)\n-     bound.  */\n-  offset_int cst_size = 1;\n-\n-  /* The initial size of the VLA to start the computation of the total\n-     size with.  Like CST_SIZE above, initialized to 1 or the number\n-     of elements in the VLA's initializer-list for VLAs of unspecified\n-     bound.  */\n-  tree initial_size = size_one_node;\n-\n-  /* For a VLA of unspecified (major) bound, the number of elements\n-     it is initialized with determined from the initializer-list.  */\n-  tree initial_elts = NULL_TREE;\n-\n-  if (init)\n-    {\n-      /* Determine the upper bound of the VLA of unspecified bound,\n-\t as in 'T a[];' if this is such a VLA.  Such a VLA can be\n-\t initialized with any number of elements but the number of\n-\t elements so determined must be used to check the total size\n-\t of the VLA.  */\n-      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n-\n-      if (tree dom = TYPE_DOMAIN (type))\n-\tif (tree max = TYPE_MAX_VALUE (dom))\n-\t  if (integer_zerop (max))\n-\t    {\n-\t      if (TREE_CODE (init) == CONSTRUCTOR)\n-\t\t{\n-\t\t  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init);\n-\n-\t\t  /* Since the upper bound of every array must be positive\n-\t\t     a VLA with an unspecified major bound must be initized\n-\t\t     by a non-empty initializer list.  */\n-\t\t  gcc_assert (v != NULL);\n-\n-\t\t  cst_size = v->length ();\n-\t\t}\n-\t      else if (TREE_CODE (init) == STRING_CST)\n-\t\t{\n-\t\t  /* The initializer is a (possibly empty) string consisting\n-\t\t     at a minumum of one character, the terminating NUL.\n-\t\t     This condition implies a definition like\n-\t\t       char s [][N] = \"\";\n-\t\t     which is an error but even though it has been diagnosed\n-\t\t     by this point the initializer still winds up here.  */\n-\t\t  size_t nchars = TREE_STRING_LENGTH (init);\n-\t\t  tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n-\t\t  nchars /= TYPE_PRECISION (ctype) / BITS_PER_UNIT;\n-\n-\t\t  cst_size = nchars + 1;\n-\t\t}\n-\n-\t      initial_elts = wide_int_to_tree (size_type_node, cst_size);\n-\t      initial_size = initial_elts;\n-\t    }\n-    }\n-\n-  /* Build a variable storing the total runtime size of the VLA and\n-     initialize it either to 1 (in the common case) or to the number\n-     of topmost elements in the initializer-list when the VLA is\n-     an array of unspecified (major) bound.  */\n-  tree vlasize = build_decl (input_location,\n-\t\t\t     VAR_DECL, NULL_TREE, sizetype);\n-  DECL_ARTIFICIAL (vlasize) = 1;\n-  DECL_IGNORED_P (vlasize) = 1;\n-  DECL_CONTEXT (vlasize) = current_function_decl;\n-  DECL_INITIAL (vlasize) = initial_size;\n-  vlasize = pushdecl (vlasize);\n-  add_decl_expr (vlasize);\n-\n-  /* Impose a lenient limit on the size of the biggest VLA in bytes.\n-     FIXME: Tighten up the limit to make it more useful and make it\n-     configurable for users with unusual requirements.  */\n-  tree max_vlasize\n-    = fold_build2 (RSHIFT_EXPR, size_type_node,\n-\t\t   build_all_ones_cst (size_type_node),\n-\t\t   integer_one_node);\n-\n-  /* Build an expression that checks the runtime bounds of the VLA\n-     for invalid values and the total size of the VLA for overflow.  */\n-  check = build_vla_size_check (check, type, vlasize, max_vlasize, &cst_size);\n-\n-  if (wi::ltu_p (wi::to_offset (max_vlasize), cst_size))\n-    {\n-      /* Issue the warning only in the \"topmost\" (non-recursive) call\n-\t to avoid duplicating diagnostics.  This is only a warning to\n-\t allow programs to be portable to more permissive environments.  */\n-      warning (OPT_Wvla, \"size of variable length array exceeds maximum \"\n-\t       \"of %qE bytes\",  max_vlasize);\n-    }\n-\n-  if (init)\n-    {\n-      /* Build an expression that checks the VLA initializer expression\n-\t against the type of the VLA for excess elements.  */\n-      check = build_vla_init_check (check, type, init, initial_elts);\n-    }\n-\n-  return check;\n-}"}, {"sha": "b921689808a174199d73bc4534c9725c1a290a0b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -603,7 +603,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n       array_type_p = true;\n       if ((TREE_SIDE_EFFECTS (init)\n \t   && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t  || variably_modified_type_p (type, NULL_TREE))\n+\t  || array_of_runtime_bound_p (type))\n \t{\n \t  /* For an array, we only need/want a single cleanup region rather\n \t     than one per element.  */\n@@ -845,7 +845,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n      will perform the dynamic initialization.  */\n   if (value != error_mark_node\n       && (TREE_SIDE_EFFECTS (value)\n-\t  || variably_modified_type_p (type, NULL_TREE)\n+\t  || array_of_runtime_bound_p (type)\n \t  || ! reduced_constant_expression_p (value)))\n     return split_nonconstant_init (decl, value);\n   /* If the value is a constant, just put it in DECL_INITIAL.  If DECL"}, {"sha": "a5a8b23df275b70f047a3af9f79fa18a8542dcc0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -1638,48 +1638,14 @@ foo (int n)\n You can use the function @code{alloca} to get an effect much like\n variable-length arrays.  The function @code{alloca} is available in\n many other C implementations (but not in all).  On the other hand,\n-variable-length arrays are available in GCC for all targets and\n-provide type safety.\n+variable-length arrays are more elegant.\n \n There are other differences between these two methods.  Space allocated\n with @code{alloca} exists until the containing @emph{function} returns.\n The space for a variable-length array is deallocated as soon as the array\n name's scope ends, unless you also use @code{alloca} in this scope.\n \n-Unlike GCC, G++ instruments variable-length arrays (@xref{Variable Length})\n-with checks for erroneous uses: when a variable-length array object is\n-created its runtime bounds are checked to detect non-positive values,\n-integer overflows, sizes in excess of SIZE_MAX / 2 bytes, and excess\n-initializers.  When an erroneous variable-length array is detected\n-the runtime arranges for an exception to be thrown that matches a handler\n-of type @code{std::bad_array_length}.\n-\n-Also unlike GCC, G++ allows variable-length arrays to be initialized.\n-However, unlike initializer lists for ordinary multidimensional arrays,\n-those for multidimensional variable-length arrays must be enclosed in\n-pairs of curly braces delimiting each sequence of values to use to\n-initialize each subarray.  Initializer lists that aren't unambiguously\n-enclosed in braces are rejected with an error.  For example, in the\n-following function, the initializer list for the ordinary @code{array}\n-is accepted even though it isn't fully enclosed in braces.  The same\n-initializer list, however, wouldn't be accepted for a multidimensional\n-variable-length array.  To initialize the variable-length array @code{vla},\n-the elements of the subarray @code{vla[m]} must be enclosed in braces\n-as shown.  As with ordinary arrays, elements that aren't initialized\n-explicitly are default-initialized.\n-\n-@smallexample\n-void\n-foo (int m, int n)\n-@{\n-  int array[2][3] = @{ 1, 2, 4, 5, 6 @};\n-  int vla[m][n] = @{ @{ 1, 2 @}, @{ 4, 5, 6 @} @};\n-@}\n-@end smallexample\n-\n-\n-In C programs (but not in C++) variable-length arrays can also be declared\n-as function arguments:\n+You can also use variable-length arrays as arguments to functions:\n \n @smallexample\n struct entry"}, {"sha": "44f71b5c10e8ce114bcfa8cd97061ee25bcaa689", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -1,3 +1,17 @@\n+2016-04-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69517\n+\tPR c++/70019\n+\tPR c++/70588\n+\t* c-c++-common/ubsan/vla-1.c: Revert.\n+\t* g++.dg/cpp1y/vla11.C: Same.\n+\t* g++.dg/cpp1y/vla12.C: Same.\n+\t* g++.dg/cpp1y/vla13.C: Same.\n+\t* g++.dg/cpp1y/vla14.C: Same.\n+\t* g++.dg/cpp1y/vla3.C: Same.\n+\t* gcc/testsuite/g++.dg/init/array24.C: Same.\n+\t* g++.dg/ubsan/vla-1.C: Same.\n+\n 2016-04-14  Marek Polacek  <polacek@redhat.com>\n \t    Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "52ade3aab7566dce3ca7ef931ac65895005d5e13", "filename": "gcc/testsuite/c-c++-common/ubsan/vla-1.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fvla-1.c?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -87,24 +87,18 @@ fn12 (void)\n int\n main (void)\n {\n-#if __cplusplus\n-#  define TRY(stmt)   do { try { stmt; } catch (...) { } } while (0)\n-#else\n-#  define TRY(stmt)   stmt\n-#endif\n-\n-  TRY (fn1 ());\n-  TRY (fn2 ());\n-  TRY (fn3 ());\n-  TRY (fn4 ());\n-  TRY (fn5 ());\n-  TRY (fn6 ());\n-  TRY (fn7 ());\n-  TRY (fn8 ());\n-  TRY (fn9 ());\n-  TRY (fn10 ());\n-  TRY (fn11 ());\n-  TRY (fn12 ());\n+  fn1 ();\n+  fn2 ();\n+  fn3 ();\n+  fn4 ();\n+  fn5 ();\n+  fn6 ();\n+  fn7 ();\n+  fn8 ();\n+  fn9 ();\n+  fn10 ();\n+  fn11 ();\n+  fn12 ();\n   return 0;\n }\n "}, {"sha": "f938f3b199e0f0d348868babbfc1fb18c0681a0f", "filename": "gcc/testsuite/g++.dg/cpp1y/vla12.C", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla12.C?ref=851285595028bdbb0eed29766e6eece1a884138e", "patch": "@@ -1,99 +0,0 @@\n-// Test to verify that variable length arrays the product of whose constant\n-// bounds overflows or exceeds the implementation-defined limit are diagnosed.\n-// { dg-do compile { target c++11 } }\n-// { dg-additional-options \"-Wno-error=vla\" }\n-\n-#define INT_MAX    __INT_MAX__\n-#define LONG_MAX   __LONG_MAX__\n-#define SIZE_MAX   __SIZE_MAX__\n-\n-typedef __SIZE_TYPE__ size_t;\n-\n-#define MAX (SIZE_MAX / 2)\n-\n-void test (int x)\n-{\n-  const size_t amax = MAX;\n-\n-  // The following are valid and shouldn't elicit a bounds overflow warning.\n-  {\n-    char a [x][amax];         // { dg-warning \"forbids\" }\n-    (void)a;\n-  }\n-\n-  {\n-    char a [amax][x];         // { dg-warning \"forbids\" }\n-    (void)a;\n-  }\n-\n-  // The following is invalid and should be diagnosed.  Unfortunately,\n-  // when the VLA maximum size is (SIZE_MAX / 2), G++ also issues\n-  // a (bogus) -Woverflow because it computes the array bound in\n-  // a signed type (ssize_t) instead of size_t, in addition to\n-  // rejecting the declaration with error: size of array \u2018a\u2019 is too\n-  // large, before the VLA constant bound check has had a chance to\n-  // see it.  So the test is disabled.\n-  // {\n-  //   char a [x][amax + 1];\n-  //   (void)a;\n-  // }\n-\n-  {\n-    char a [x][x][amax];      // { dg-warning \"forbids\" }\n-    (void)a;\n-  }\n-\n-  {\n-    char a [x][amax][x];      // { dg-warning \"forbids\" }\n-    (void)a;\n-  }\n-\n-  {\n-    char a [amax][x][x];      // { dg-warning \"forbids\" }\n-    (void)a;\n-  }\n-\n-  {\n-    char a [2][x][amax];      // { dg-warning \"forbids|exceeds maximum\" }\n-    (void)a;\n-  }\n-\n-  {\n-    // Unfortunately, the following is rejected with a different error\n-    // earlier during parsing and before the VLA checking gets to see\n-    // it: error: size of array \u2018a\u2019 is too large\n-    // Ditto for other multidimensional VLAs where the overflow occurs\n-    // in the computation of the product of adjacent constant bounds.\n-    // char a [x][amax][amax];\n-    // char b [x][2][amax];\n-    // That error above also leads to the following error when using\n-    // the variable below.\n-    //   error:\u2019 was not declared in this scope\n-    // (void)a;\n-  }\n-\n-  {\n-    char a [amax][x][amax];   // { dg-warning \"forbids|exceeds maximum\" }\n-    (void)a;\n-  }\n-\n-  {\n-    char a [amax][amax][x];   // { dg-warning \"forbids|exceeds maximum\" }\n-    (void)a;\n-  }\n-\n-  {\n-    struct A256 { __attribute__ ((aligned (256))) char a; };\n-\n-    enum {\n-      M = 1024,\n-      N = MAX / (sizeof (A256) * M)\n-    };\n-\n-    A256 a [x][M][x][N];      // { dg-warning \"forbids\" }\n-    (void)a;\n-\n-    A256 b [2][x][M][x][N];   // { dg-warning \"forbids|exceeds maximum\" }\n-    (void)b;\n-  }\n-}"}, {"sha": "d473a638dfb2047f62903aee752cba0d42e9c99d", "filename": "gcc/testsuite/g++.dg/cpp1y/vla13.C", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla13.C?ref=851285595028bdbb0eed29766e6eece1a884138e", "patch": "@@ -1,260 +0,0 @@\n-// PR c++/70019 - VLA size overflow not detected\n-// Runtime test to verify that attempting to initialize a VLA with a string\n-// or character array that's longer than the non-constant (runtime) bound\n-// of the VLA causes an exception to be thrown.  For a compile-time version\n-// of the test see vla14.C.\n-\n-// { dg-do run { target c++11 } }\n-// { dg-additional-options \"-Wno-vla\" }\n-\n-#pragma GCC diagnostic ignored \"-Wvla\"\n-\n-#define SIZE_MAX   __SIZE_MAX__\n-\n-// The size of the largest allowed VLA in bytes.  Bigger objects\n-// cause an exception to be thrown.  Unless the maximum size is\n-// obscenely large, smaller objects should be successfully created\n-// provided there's enough stack space.  See TEST_NEAR_VLA_MAX_SIZE\n-// below.\n-#define MAX   (__SIZE_MAX__ / 2)\n-\n-// Define to non-zero to exercise very large VLAs with size just\n-// below the implementation-defined maximum.\n-#define TEST_NEAR_VLA_MAX_SIZE    0\n-\n-// Define to zero to enable tests that cause an ICE due to c++/58646.\n-#define BUG_58646 1\n-\n-// Define to zero to enable tests that cause an ICE due to c++/69487.\n-#define BUG_69487 1\n-\n-// Helper macro to make it possible to pass as one multpile arguments\n-// to another macro.\n-#define Init(...) __VA_ARGS__\n-\n-typedef __SIZE_TYPE__ size_t;\n-\n-// Incremented for each test failure.\n-int fail;\n-\n-// Used to convert a constant array dimension to a non-constant one.\n-template <class T>\n-T d (T n)\n-{\n-  return n;\n-}\n-\n-// Verify either that an expected exception has been thrown or that\n-// one hasn't been thrown if one isn't expected.\n-int __attribute__ ((noclone, noinline))\n-sink (void *p, int line, bool expect, const char *expr)\n-{\n-  if (!p != expect)\n-    {\n-      __builtin_printf (\"line %i: Assertion failed: '%s': \"\n-                        \"exception unexpectedly %sthrown\\n\",\n-                        line, expr, !p ? \"\" : \"not \");\n-      ++fail;\n-    }\n-  else\n-    {\n-#if defined DEBUG && DEBUG\n-    __builtin_printf (\"line %i: Assertion passed: '%s': \"\n-\t\t      \"exception %sthrown as expected\\n\",\n-\t\t      line, expr, !p ? \"\" : \"not \");\n-#endif\n-    }\n-  return 0;\n-}\n-\n-template <class T, int>\n-int test ();\n-\n-#define _CAT(name, line) name ## line\n-#define CAT(name, line) _CAT (name, line)\n-\n-#define STR(...) #__VA_ARGS__\n-\n-// Macro to define a unique specialization of a function template to\n-// exercise a VLA of type T, rank N, with dimensions given by Dims\n-// and initializer Init.  Expect is true when the VLA initialization\n-// is expected to trigger an exception.\n-// The macro creates a unique global dummy int object and initializes\n-// it with the result of the function.  The dummy object servers no\n-// other purpose but to call the function.  The function verifies\n-// the expected postconditions.\n-#define TEST(T, Dims, Init, Expect)                                     \\\n-  template <>                                                           \\\n-  int test<T, __LINE__>()                                               \\\n-  {                                                                     \\\n-    const char str[] = \"char a\" #Dims \" = { \" STR (Init) \" }\";          \\\n-    try {                                                               \\\n-      T a Dims = { Init };                                              \\\n-      return sink (a, __LINE__, Expect, str);                           \\\n-    }                                                                   \\\n-    catch (...) {                                                       \\\n-      return sink (0, __LINE__, Expect, str);                           \\\n-    }                                                                   \\\n-  }                                                                     \\\n-  const int CAT (dummy, __LINE__) = test<T, __LINE__>()\n-\n-\n-// Create and run a test function exercising a VLA definition\n-//    +-- Element Type\n-//    |     +-- VLA Dimensions\n-//    |     |        +-- VLA Initializer\n-//    |     |        |\n-//    |     |        |             +-- Expect Exception\n-//    |     |        |             |\n-//    V     V        V             V\n-TEST (char, [d(-1)], \"\",           true);\n-\n-TEST (char, [d(0)],  \"\",           true);\n-TEST (char, [d(0)],  (\"\"),         true);\n-\n-TEST (char, [d(1)],  \"\",           false);\n-TEST (char, [d(1)],  (\"\"),         false);\n-\n-TEST (char, [d(1)],  \"1\",          true);\n-TEST (char, [d(1)],  (\"1\"),        true);\n-\n-TEST (char, [d(1)],  \"12\",         true);\n-TEST (char, [d(1)],  \"1234567890\", true);\n-\n-TEST (char, [d(2)], \"\",           false);\n-TEST (char, [d(2)], (\"\"),         false);\n-\n-TEST (char, [d(2)], \"1\",          false);\n-TEST (char, [d(2)], \"12\",         true);\n-TEST (char, [d(2)], \"123\",        true);\n-TEST (char, [d(2)], \"1234567890\", true);\n-\n-TEST (char, [d(3)], \"\",           false);\n-TEST (char, [d(3)], \"1\",          false);\n-TEST (char, [d(3)], \"12\",         false);\n-TEST (char, [d(3)], \"123\",        true);\n-TEST (char, [d(3)], \"1234\",       true);\n-TEST (char, [d(3)], \"1234567890\", true);\n-\n-#if TEST_NEAR_VLA_MAX_SIZE\n-\n-#  if !BUG_69487\n-// The following crash due to c++/69487.\n-TEST (char, [d(MAX)], \"\",           false);\n-TEST (char, [d(MAX)], \"1\",          false);\n-TEST (char, [d(MAX)], \"12\",         false);\n-TEST (char, [d(MAX)], \"1234567890\", false);\n-#  endif\n-\n-TEST (char, [d(MAX)], Init (),                             false);\n-TEST (char, [d(MAX)], Init (1),                            false);\n-TEST (char, [d(MAX)], Init (1, 2),                         false);\n-TEST (char, [d(MAX)], Init (1, 2, 3, 4, 5, 6, 7, 8, 9, 0), false);\n-#endif\n-\n-TEST (char, [d(SIZE_MAX / 2 + 1)], \"\", true);\n-TEST (char, [d(SIZE_MAX - 2)],     \"\", true);\n-TEST (char, [d(SIZE_MAX - 1)],     \"\", true);\n-\n-TEST (wchar_t, [d(1)], L\"\",           false);\n-TEST (wchar_t, [d(1)], (L\"\"),         false);\n-TEST (wchar_t, [d(1)], L\"1\",          true);\n-TEST (wchar_t, [d(1)], L\"12\",         true);\n-TEST (wchar_t, [d(1)], L\"1234567890\", true);\n-\n-TEST (wchar_t, [d(2)], L\"\",           false);\n-TEST (wchar_t, [d(2)], L\"1\",          false);\n-TEST (wchar_t, [d(2)], L\"12\",         true);\n-TEST (wchar_t, [d(2)], L\"123\",        true);\n-TEST (wchar_t, [d(2)], L\"1234567890\", true);\n-\n-TEST (char, [d(1)][d(1)], Init (\"\"),        false);\n-TEST (char, [1]   [d(1)], Init (\"\"),        false);\n-TEST (char, [d(1)][1],    Init (\"\"),        false);\n-\n-TEST (char, [d(1)][d(1)], Init (\"1\"),       true);\n-\n-// The following is accepted at compile time but throws an exception\n-// at runtime since in C++ a one-element array cannot be initialized\n-// with a string literal of length one because there isn't room for\n-// the terminating NUL\n-TEST (char, [1][d(1)],    Init (\"1\"),       true);\n-\n-// The following is rejected at compile-time since a one-element array\n-// cannot be initialized with a string literal of length one because\n-// there isn't room for the terminating NUL (see vla14.C).\n-// TEST (char, [d(1)][1],    Init (\"1\"),       false);\n-\n-TEST (char, [d(1)][d(1)], Init (\"12\"),      true);\n-TEST (char, [d(1)][d(1)], Init (\"1\", \"2\"),  true);\n-TEST (char, [d(1)][d(1)], Init (\"1\", \"23\"), true);\n-\n-TEST (char, [d(2)][d(2)], Init (\"\", \"\"),    false);\n-TEST (char, [d(2)][d(2)], Init (\"\", \"1\"),   false);\n-TEST (char, [d(2)][d(2)], Init (\"1\", \"\"),   false);\n-TEST (char, [d(2)][d(2)], Init (\"1\", \"1\"),  false);\n-TEST (char, [2][d(2)],    Init (\"\",  \"1\"),  false);\n-TEST (char, [2][d(2)],    Init (\"1\", \"\"),   false);\n-TEST (char, [2][d(2)],    Init (\"1\", \"1\"),  false);\n-TEST (char, [d(2)][2],    Init (\"\",  \"1\"),  false);\n-TEST (char, [d(2)][2],    Init (\"1\", \"\"),   false);\n-TEST (char, [d(2)][2],    Init (\"1\", \"1\"),  false);\n-\n-TEST (char, [2][d(2)],    Init (\"1\", \"23\"), true);\n-TEST (char, [d(2)][d(2)], Init (\"1\", \"23\"), true);\n-TEST (char, [d(2)][d(2)], Init (\"1\", \"23\"), true);\n-TEST (char, [d(2)][d(2)], Init (\"12\",\"3\"),  true);\n-\n-#if TEST_NEAR_VLA_MAX_SIZE\n-#  if !BUG_69487\n-   // The following crash due to c++/69487.\n-TEST (char, [1][d(MAX)], Init (\"\"),           false);\n-TEST (char, [1][d(MAX)], Init (\"1\"),          false);\n-TEST (char, [1][d(MAX)], Init (\"12\"),         false);\n-TEST (char, [1][d(MAX)], Init (\"1234567890\"), false);\n-#  endif\n-\n-#  if !BUG_58646\n-// The following causes an ICE due to c++/58646.\n-TEST (char, [1][d(MAX)], Init (),                               false);\n-#  endif\n-\n-TEST (char, [1][d(MAX)], Init ({1}),                            false);\n-TEST (char, [1][d(MAX)], Init ({1, 2}),                         false);\n-TEST (char, [1][d(MAX)], Init ({1, 2, 3}),                      false);\n-TEST (char, [1][d(MAX)], Init ({1, 2, 3, 4, 5, 6, 7, 8, 9, 0}), false);\n-\n-TEST (char, [d(MAX)][1], Init ({1}),                            false);\n-TEST (char, [d(MAX)][1], Init ({1}, {2}),                       false);\n-TEST (char, [d(MAX)][1], Init ({1}, {2}, {3}),                  false);\n-TEST (char, [d(MAX)][1], Init ({1}, {2}, {3}, {4}, {5},\n-\t\t\t       {6}, {7}, {8}, {9}, {0}),        false);\n-#endif   // TEST_NEAR_VLA_MAX_SIZE\n-\n-// The following are expected to throw due to excessive size.\n-TEST (char, [2][d(MAX)], Init ({1}),                                 true);\n-TEST (char, [2][d(MAX)], Init ({1, 2}),                              true);\n-TEST (char, [2][d(MAX)], Init ({1}, {2}),                            true);\n-TEST (char, [2][d(MAX)], Init ({1, 2}, {3, 4}),                      true);\n-TEST (char, [2][d(MAX)], Init ({1, 2, 3}, {4, 5, 6}),                true);\n-TEST (char, [2][d(MAX)], Init ({1, 2, 3, 4}, {5, 6, 7, 8}),          true);\n-\n-TEST (char, [d(MAX)][2], Init ({1}),                                 true);\n-TEST (char, [d(MAX)][2], Init ({1, 2}),                              true);\n-TEST (char, [d(MAX)][2], Init ({1}, {2}),                            true);\n-TEST (char, [d(MAX)][2], Init ({1, 2}, {3, 4}),                      true);\n-TEST (char, [d(MAX)][2], Init ({1, 2}, {3, 4}, {5, 6}),              true);\n-TEST (char, [d(MAX)][2], Init ({1, 2}, {3, 4}, {5, 6}, {7, 8}),      true);\n-\n-TEST (char, [d(MAX)][d(MAX)], Init ({1}),                            true);\n-TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}),                         true);\n-TEST (char, [d(MAX)][d(MAX)], Init ({1}, {2}),                       true);\n-TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}, {3, 4}),                 true);\n-TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}, {3, 4}, {5, 6}),         true);\n-TEST (char, [d(MAX)][d(MAX)], Init ({1, 2}, {3, 4}, {5, 6}, {7, 8}), true);\n-\n-int main ()\n-{\n-  if (fail)\n-    __builtin_abort ();\n-}"}, {"sha": "4a0e82774f21314529295318bd741785072a0f9f", "filename": "gcc/testsuite/g++.dg/cpp1y/vla14.C", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla14.C?ref=851285595028bdbb0eed29766e6eece1a884138e", "patch": "@@ -1,48 +0,0 @@\n-// PR c++/70019 - VLA size overflow not detected\n-// Compile-time test to verify that attempting to initialize a VLA with\n-// a string that's longer than the VLA's constant bound is diagnosed at\n-// compile time.  For a runtime version of the test see vla13.C.\n-\n-// { dg-do run }\n-// { dg-additional-options \"-Wno-vla\" }\n-\n-\n-void test (int n)\n-{\n-  char a1[n][1] = { { \"a\" } };   // { dg-error \"initializer-string for array of chars is too long\" }\n-  (void)a1;\n-\n-  char a2[1][n] = { { \"a\" } };\n-  (void)a2;\n-\n-  char a3[n][1][1] = { { { \"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n-  (void)a3;\n-\n-  char a4[1][1][n] = { { { \"a\" } } };\n-  (void)a4;\n-\n-  char a5[1][n][1] = { { { \"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n-  (void)a5;\n-\n-  char a6[n][1][n] = { { { \"a\" } } };\n-  (void)a6;\n-\n-\n-  wchar_t a7[n][1] = { { L\"a\" } };   // { dg-error \"initializer-string for array of chars is too long\" }\n-  (void)a7;\n-\n-  wchar_t a8[1][n] = { { L\"a\" } };\n-  (void)a8;\n-\n-  wchar_t a9[n][1][1] = { { { L\"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n-  (void)a9;\n-\n-  wchar_t a10[1][1][n] = { { { L\"a\" } } };\n-  (void)a10;\n-\n-  wchar_t a11[][n][1] = { { { L\"a\" } } };   // { dg-error \"initializer-string for array of chars is too long\" }\n-  (void)a11;\n-\n-  wchar_t a12[n][1][n] = { { { L\"a\" } } };\n-  (void)a12;\n-}"}, {"sha": "9b2d6b3072c41aff694008fc6156e4a92772e255", "filename": "gcc/testsuite/g++.dg/cpp1y/vla3.C", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851285595028bdbb0eed29766e6eece1a884138e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C?ref=851285595028bdbb0eed29766e6eece1a884138e", "patch": "@@ -1,43 +0,0 @@\n-// Test for throwing bad_array_length on invalid array length.\n-// { dg-do run { target c++14 } }\n-// { dg-additional-options \"-Wno-vla\" }\n-\n-namespace std\n-{\n-struct exception\n-{\n-  virtual ~exception ();\n-  virtual const char* what () const throw ();\n-};\n-}\n-\n-int f(int i)\n-{\n-  int ar[i]{1,2,3,4};\n-  return ar[i-1];\n-}\n-\n-void g(int i)\n-{\n-  int ar[i];\n-  ar[0] = 42;\n-}\n-\n-int main()\n-{\n-  int ok = 0;\n-  f(4);\t\t\t\t// OK\n-  try {\n-    f(3);\t\t\t// too small\n-  }\n-  catch (std::exception &e) {\n-    ++ok;\n-  }\n-  try { g(-24); }\t\t// negative\n-  catch (std::exception &e) {\n-    ++ok;\n-  }\n-\n-  if (ok != 2)\n-    __builtin_abort ();\n-}"}, {"sha": "2d72df40382b681d984f0fb35e822d16509e58ff", "filename": "gcc/testsuite/g++.dg/init/array24.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -3,5 +3,5 @@\n \n void foo(int i)\n {\n-  int x[][i] = { { 0 } };\n+  int x[][i] = { 0 };\n }"}, {"sha": "311cdb1d77a740e81ff245adb809437052603eca", "filename": "gcc/testsuite/g++.dg/ubsan/vla-1.C", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvla-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8747845fded660e09bab98470f77753a4216b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvla-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvla-1.C?ref=d8747845fded660e09bab98470f77753a4216b6e", "patch": "@@ -1,8 +1,5 @@\n // { dg-do run }\n-// Disable exceptions to prevent the erroneous initializer from\n-// throwing before the sanitizer instrumentation has detected\n-// the problem.\n-// { dg-options \"-Wno-vla -fno-exceptions -fsanitize=undefined\" }\n+// { dg-options \"-Wno-vla -fsanitize=undefined\" }\n // { dg-output \"index 1 out of bounds\" }\n \n void f(int i) {"}]}