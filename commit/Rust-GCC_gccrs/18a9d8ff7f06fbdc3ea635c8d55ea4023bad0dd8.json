{"sha": "18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhOWQ4ZmY3ZjA2ZmJkYzNlYTYzNWM4ZDU1ZWE0MDIzYmFkMGRkOA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-16T11:23:56Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-16T11:23:56Z"}, "message": "cppmain.c (scan_translation_unit): Don't worry about putting a space after hashes.\n\n\t* cppmain.c (scan_translation_unit): Don't worry about\n\tputting a space after hashes.\n\t* cpplib.c (directive_diagnostics): New.\n\t(_cpp_handle_directive): Update to use directive_diagnostics.\n\t(run_directive): Don't toggle prevent_expansion.\n\t(do_line): Backup in case of the line extension.\n\t* cpplib.h (cpp_lexer_pos): Remove.\n\t* cppmacro.c (_cpp_create_definition): Precede a leading #\n\twith whitespace.\n\n\t* gcc.dg/cpp/line5.c: New testcase.\n\nFrom-SVN: r45645", "tree": {"sha": "b5637b92895c1d89a6ebec87518678bddc00a55f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5637b92895c1d89a6ebec87518678bddc00a55f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/comments", "author": null, "committer": null, "parents": [{"sha": "27553bf3253625f6c3e56d36599b9e7cf188bfe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27553bf3253625f6c3e56d36599b9e7cf188bfe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27553bf3253625f6c3e56d36599b9e7cf188bfe8"}], "stats": {"total": 260, "additions": 145, "deletions": 115}, "files": [{"sha": "4f0ad86c6be69bb7bd01c6c9624f2e02e7be3588", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -1,3 +1,15 @@\n+2001-09-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppmain.c (scan_translation_unit): Don't worry about\n+\tputting a space after hashes.\n+\t* cpplib.c (directive_diagnostics): New.\n+\t(_cpp_handle_directive): Update to use directive_diagnostics.\n+\t(run_directive): Don't toggle prevent_expansion.\n+\t(do_line): Backup in case of the line extension.\n+\t* cpplib.h (cpp_lexer_pos): Remove.\n+\t* cppmacro.c (_cpp_create_definition): Precede a leading #\n+\twith whitespace.\n+\n 2001-09-15  Richard Henderson  <rth@redhat.com>\n \n \t* c-typeck.c (comptypes): Handle zero-length arrays properly."}, {"sha": "b3eb24daad4c9845a021ab7db322d778d319d37e", "filename": "gcc/cpplib.c", "status": "modified", "additions": 108, "deletions": 98, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -82,6 +82,8 @@ static void skip_rest_of_line\tPARAMS ((cpp_reader *));\n static void check_eol\t\tPARAMS ((cpp_reader *));\n static void start_directive\tPARAMS ((cpp_reader *));\n static void end_directive\tPARAMS ((cpp_reader *, int));\n+static void directive_diagnostics\n+\tPARAMS ((cpp_reader *, const directive *, int));\n static void run_directive\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t const char *, size_t));\n static int glue_header_name\tPARAMS ((cpp_reader *, cpp_token *));\n@@ -248,8 +250,57 @@ end_directive (pfile, skip_line)\n   pfile->directive = 0;\n }\n \n-/* Check if a token's name matches that of a known directive.  Put in\n-   this file to save exporting dtable and other unneeded information.  */\n+/* Output diagnostics for a directive DIR.  INDENTED is non-zero if\n+   the '#' was indented.  */\n+\n+static void\n+directive_diagnostics (pfile, dir, indented)\n+     cpp_reader *pfile;\n+     const directive *dir;\n+     int indented;\n+{\n+  if (pfile->state.line_extension)\n+    {\n+      if (CPP_PEDANTIC (pfile)\n+\t  && ! pfile->state.skipping)\n+\tcpp_pedwarn (pfile, \"style of line directive is a GCC extension\");\n+    }\n+  else\n+    {\n+      /* Issue -pedantic warnings for extensions.   */\n+      if (CPP_PEDANTIC (pfile)\n+\t  && ! pfile->state.skipping\n+\t  && dir->origin == EXTENSION)\n+\tcpp_pedwarn (pfile, \"#%s is a GCC extension\", dir->name);\n+\n+      /* Traditionally, a directive is ignored unless its # is in\n+\t column 1.  Therefore in code intended to work with K+R\n+\t compilers, directives added by C89 must have their #\n+\t indented, and directives present in traditional C must not.\n+\t This is true even of directives in skipped conditional\n+\t blocks.  */\n+      if (CPP_WTRADITIONAL (pfile))\n+\t{\n+\t  if (dir == &dtable[T_ELIF])\n+\t    cpp_warning (pfile, \"suggest not using #elif in traditional C\");\n+\t  else if (indented && dir->origin == KANDR)\n+\t    cpp_warning (pfile,\n+\t\t\t \"traditional C ignores #%s with the # indented\",\n+\t\t\t dir->name);\n+\t  else if (!indented && dir->origin != KANDR)\n+\t    cpp_warning (pfile,\n+\t\t \"suggest hiding #%s from traditional C with an indented #\",\n+\t\t\t dir->name);\n+\t}\n+    }\n+}\n+\n+/* Check if we have a known directive.  INDENTED is non-zero if the\n+   '#' of the directive was indented.  This function is in this file\n+   to save unnecessarily exporting dtable etc. to cpplex.c.  Returns\n+   non-zero if the line of tokens has been handled, zero if we should\n+   continue processing the line.  */\n+\n int\n _cpp_handle_directive (pfile, indented)\n      cpp_reader *pfile;\n@@ -260,125 +311,80 @@ _cpp_handle_directive (pfile, indented)\n   int skip = 1;\n \n   start_directive (pfile);\n-\n-  /* Lex the directive name directly.  */\n   _cpp_lex_token (pfile, &dname);\n \n   if (dname.type == CPP_NAME)\n     {\n-      unsigned int index = dname.val.node->directive_index;\n-      if (index)\n-\tdir = &dtable[index - 1];\n+      if (dname.val.node->directive_index)\n+\tdir = &dtable[dname.val.node->directive_index - 1];\n     }\n-  else if (dname.type == CPP_NUMBER)\n+  /* We do not recognise the # followed by a number extension in\n+     assembler code.  */\n+  else if (dname.type == CPP_NUMBER && CPP_OPTION (pfile, lang) != CLK_ASM)\n     {\n-      /* # followed by a number is equivalent to #line.  Do not\n-\t recognize this form in assembly language source files or\n-\t skipped conditional groups.  Complain about this form if\n-\t we're being pedantic, but not if this is regurgitated input\n-\t (preprocessed or fed back in by the C++ frontend).  */\n-      if (! pfile->state.skipping && CPP_OPTION (pfile, lang) != CLK_ASM)\n-\t{\n-\t  dir = &dtable[T_LINE];\n-\t  pfile->state.line_extension = 1;\n-\t  _cpp_backup_tokens (pfile, 1);\n-\t  if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, preprocessed))\n-\t    cpp_pedwarn (pfile, \"# followed by integer\");\n-\t}\n+      dir = &dtable[T_LINE];\n+      pfile->state.line_extension = 1;\n     }\n \n-  pfile->directive = dir;\n   if (dir)\n     {\n-      /* Make sure we lex headers correctly, whether skipping or not.  */\n-      pfile->state.angled_headers = dir->flags & INCL;\n-\n-      /* If we are rescanning preprocessed input, only directives tagged\n-\t with IN_I are honored, and the warnings below are suppressed.  */\n-      if (CPP_OPTION (pfile, preprocessed))\n+      /* If we have a directive that is not an opening conditional,\n+\t invalidate any control macro.  */\n+      if (! (dir->flags & IF_COND))\n+\tpfile->mi_valid = false;\n+\n+      /* Kluge alert.  In order to be sure that code like this\n+\n+\t #define HASH #\n+\t HASH define foo bar\n+\n+\t does not cause '#define foo bar' to get executed when\n+\t compiled with -save-temps, we recognize directives in\n+\t -fpreprocessed mode only if the # is in column 1.  cppmacro.c\n+\t puts a space in fron of any '#' at the start of a macro.  */\n+      if (CPP_OPTION (pfile, preprocessed)\n+\t  && (indented || !(dir->flags & IN_I)))\n \t{\n-\t  /* Kluge alert.  In order to be sure that code like this\n-\t     #define HASH #\n-\t     HASH define foo bar\n-\t     does not cause '#define foo bar' to get executed when\n-\t     compiled with -save-temps, we recognize directives in\n-\t     -fpreprocessed mode only if the # is in column 1 and the\n-\t     directive name starts in column 2.  This output can only\n-\t     be generated by the directive callbacks in cppmain.c (see\n-\t     also the special case in scan_buffer).  */\n-\t  if (dir->flags & IN_I && !indented && !(dname.flags & PREV_WHITE))\n-\t    (*dir->handler) (pfile);\n-\t  /* That check misses '# 123' linemarkers.  Let them through too.  */\n-\t  else if (dname.type == CPP_NUMBER)\n-\t    (*dir->handler) (pfile);\n-\t  else\n-\t    {\n-\t      /* We don't want to process this directive.  Put back the\n-\t\t tokens so caller will see them (and issue an error,\n-\t\t probably).  */\n-\t      _cpp_backup_tokens (pfile, 1);\n-\t      skip = 0;\n-\t    }\n+\t  skip = 0;\n+\t  dir = 0;\n \t}\n       else\n \t{\n-\t  /* Traditionally, a directive is ignored unless its # is in\n-\t     column 1.  Therefore in code intended to work with K+R\n-\t     compilers, directives added by C89 must have their #\n-\t     indented, and directives present in traditional C must\n-\t     not.  This is true even of directives in skipped\n-\t     conditional blocks.  */\n-\t  if (CPP_WTRADITIONAL (pfile))\n-\t    {\n-\t      if (dir == &dtable[T_ELIF])\n-\t\tcpp_warning (pfile,\n-\t\t\t     \"suggest not using #elif in traditional C\");\n-\t      else if (indented && dir->origin == KANDR)\n-\t\tcpp_warning (pfile,\n-\t\t\t     \"traditional C ignores #%s with the # indented\",\n-\t\t\t     dir->name);\n-\t      else if (!indented && dir->origin != KANDR)\n-\t\tcpp_warning (pfile,\n-\t     \"suggest hiding #%s from traditional C with an indented #\",\n-\t\t\t     dir->name);\n-\t    }\n-\n-\t  /* If we are skipping a failed conditional group, all\n-\t     non-conditional directives are ignored.  */\n-\t  if (! pfile->state.skipping || (dir->flags & COND))\n-\t    {\n-\t      /* Issue -pedantic warnings for extensions.   */\n-\t      if (CPP_PEDANTIC (pfile) && dir->origin == EXTENSION)\n-\t\tcpp_pedwarn (pfile, \"#%s is a GCC extension\", dir->name);\n-\n-\t      /* If we have a directive that is not an opening\n-\t\t conditional, invalidate any control macro.  */\n-\t      if (! (dir->flags & IF_COND))\n-\t\tpfile->mi_valid = false;\n-\n-\t      (*dir->handler) (pfile);\n-\t    }\n+\t  /* In failed conditional groups, all non-conditional\n+\t     directives are ignored.  Before doing that, whether\n+\t     skipping or not, we should lex angle-bracketed headers\n+\t     correctly, and maybe output some diagnostics.  */\n+\t  pfile->state.angled_headers = dir->flags & INCL;\n+\t  if (! CPP_OPTION (pfile, preprocessed))\n+\t    directive_diagnostics (pfile, dir, indented);\n+\t  if (pfile->state.skipping && !(dir->flags & COND))\n+\t    dir = 0;\n \t}\n     }\n-  else if (dname.type != CPP_EOF && ! pfile->state.skipping)\n+  else if (dname.type == CPP_EOF)\n+    ;\t/* CPP_EOF is the \"null directive\".  */\n+  else\n     {\n       /* An unknown directive.  Don't complain about it in assembly\n \t source: we don't know where the comments are, and # may\n \t introduce assembler pseudo-ops.  Don't complain about invalid\n \t directives in skipped conditional groups (6.10 p4).  */\n       if (CPP_OPTION (pfile, lang) == CLK_ASM)\n-\t{\n-\t  /* Output the # and this token for the assembler.  */\n-\t  _cpp_backup_tokens (pfile, 1);\n-\t  skip = 0;\n-\t}\n-      else\n+\tskip = 0;\n+      else if (!pfile->state.skipping)\n \tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n \t\t   cpp_token_as_text (pfile, &dname));\n     }\n \n-  if (pfile->state.in_directive)\n-    end_directive (pfile, skip);\n+  if (dir)\n+    {\n+      pfile->directive = dir;\n+      (*pfile->directive->handler) (pfile);\n+    }\n+  else if (skip == 0)\n+    _cpp_backup_tokens (pfile, 1);\n+\n+  end_directive (pfile, skip);\n   return skip;\n }\n \n@@ -394,11 +400,10 @@ run_directive (pfile, dir_no, buf, count)\n   cpp_push_buffer (pfile, (const U_CHAR *) buf, count,\n \t\t   /* from_stage3 */ true, 1);\n   start_directive (pfile);\n-  pfile->buffer->saved_flags = 0; /* We don't want to recognise directives.  */\n-  pfile->state.prevent_expansion++;\n+  /* We don't want a leading # to be interpreted as a directive.  */\n+  pfile->buffer->saved_flags = 0;\n   pfile->directive = &dtable[dir_no];\n   (void) (*pfile->directive->handler) (pfile);\n-  pfile->state.prevent_expansion--;\n   end_directive (pfile, 1);\n   _cpp_pop_buffer (pfile);\n }\n@@ -708,6 +713,11 @@ do_line (pfile)\n   /* C99 raised the minimum limit on #line numbers.  */\n   cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n \n+  /* Putting this in _cpp_handle_directive risks two calls to\n+     _cpp_backup_tokens in some circumstances, which can segfault.  */\n+  if (pfile->state.line_extension)\n+    _cpp_backup_tokens (pfile, 1);\n+\n   /* #line commands expand macros.  */\n   cpp_get_token (pfile, &token);\n   if (token.type != CPP_NUMBER"}, {"sha": "ad7418755a5c28b1d329a0812967b1e43b1e62c2", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -41,7 +41,6 @@ typedef struct cpp_token cpp_token;\n typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n typedef struct cpp_macro cpp_macro;\n-typedef struct cpp_lexer_pos cpp_lexer_pos;\n typedef struct cpp_callbacks cpp_callbacks;\n \n struct answer;\n@@ -186,13 +185,6 @@ struct cpp_token\n   } val;\n };\n \n-/* The position of a token in the current file.  */\n-struct cpp_lexer_pos\n-{\n-  unsigned int line;\n-  unsigned short col;\n-};\n-\n /* A standalone character.  We may want to make it unsigned for the\n    same reason we use unsigned char - to avoid signedness issues.  */\n typedef int cppchar_t;"}, {"sha": "80c01541cef8406e9f6b254ca82e67383f3127ce", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -1321,8 +1321,12 @@ _cpp_create_definition (pfile, node)\n   /* Don't count the CPP_EOF.  */\n   macro->count--;\n \n-  /* Clear the whitespace flag from the leading token.  */\n-  macro->expansion[0].flags &= ~PREV_WHITE;\n+  /* Clear the whitespace flag from the leading token, but put a space\n+     in front of a leading # which might be used to fake a directive.  */\n+  if (macro->expansion[0].type == CPP_HASH)\n+    macro->expansion[0].flags |= PREV_WHITE;\n+  else\n+    macro->expansion[0].flags &= ~PREV_WHITE;\n \n   /* Implement the macro-defined-to-itself optimisation.  */\n   macro->disabled = (macro->count == 1 && !macro->fun_like"}, {"sha": "5451ccc31f4474ad38f094b00bea7cd4ed78ed76", "filename": "gcc/cppmain.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -233,13 +233,6 @@ scan_translation_unit (pfile)\n       if ((token->flags & (PREV_WHITE | AVOID_LPASTE | BOL)) == AVOID_LPASTE\n \t  && cpp_avoid_paste (pfile, &tokens[1 - index], token))\n \ttoken->flags |= PREV_WHITE;\n-      /* Special case '# <directive name>': insert a space between\n-\t the # and the token.  This will prevent it from being\n-\t treated as a directive when this code is re-preprocessed.\n-\t XXX Should do this only at the beginning of a line, but how?  */\n-      else if (token->type == CPP_NAME && token->val.node->directive_index\n-\t       && tokens[1 - index].type == CPP_HASH)\n-\ttoken->flags |= PREV_WHITE;\n \n       cpp_output_token (token, print.outf);\n       if (token->type == CPP_STRING || token->type == CPP_WSTRING"}, {"sha": "40333a375d396c29559c79c9361422c24a4c2556", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -1,3 +1,7 @@\n+2001-09-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/line5.c: New testcase.\n+\n 2001-09-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* gcc.dg/cpp/macro9.c: New test."}, {"sha": "d0c04b79c13520ffa269e6ebae200bb08606d2d7", "filename": "gcc/testsuite/gcc.dg/cpp/line5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline5.c?ref=18a9d8ff7f06fbdc3ea635c8d55ea4023bad0dd8", "patch": "@@ -0,0 +1,15 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options \"-fpreprocessed\" } */\n+\n+/* Source: Neil Booth, 16 Sep 2001.\n+\n+   This file, with an indented line marker, is not possible without\n+   user editing of preprocessed output, or the user using\n+   -fpreprocessed on raw source.  Nevertheless, we should not\n+   segfault.  This is a test that we don't back up two tokens in\n+   cpplib.c - one to back up over the number, and one when we\n+   recognise that it's not a valid directive in preprocessed input.  */\n+\n+ # 1 \"foo.c\""}]}