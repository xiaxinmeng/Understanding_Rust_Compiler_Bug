{"sha": "a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2NGQwZjFlOWIwM2ZhM2U3MTMzMWI3NjZlODMwMGNmOTNiMmRmZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-05-17T16:28:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-05-17T16:28:07Z"}, "message": "Makefile.in (tree-ssa-forwprop.o): Depend on langhooks.h.\n\n\n\t* Makefile.in (tree-ssa-forwprop.o): Depend on langhooks.h.\n\t* tree-ssa-forwprop.c: Include langhooks.h.\n\t(forward_propagate_addr_expr_into_variable_array_index): New.\n\t(forward_propagate_addr_expr): New.\n\t(tree_ssa_forward_propagate_single_use_vars): Loop over all\n\tthe statements in the block instead of just the last statement.\n\tCall forward_propagate_addr_expr as needed.\n\t(pass_forwprop): Update the SSA graph after forward propagation is\n\tcomplete.\n\n\t* g++.dg/tree-ssa/pr18414.C: New test.\n\t* gcc.dg/tree-ssa/pr18414.C: New test.\n\t* gcc.dg/tree-ssa/pr17141-1.C: New test.\n\t* gcc.dg/tree-ssa/pr17141-2.C: New test.\n\nFrom-SVN: r99837", "tree": {"sha": "86002af17658fce2dd1e335b8fc562dc574e089f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86002af17658fce2dd1e335b8fc562dc574e089f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/comments", "author": null, "committer": null, "parents": [{"sha": "79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d0dfa314d6b7d1db89735809d7f7f19b5efd86"}], "stats": {"total": 419, "additions": 408, "deletions": 11}, "files": [{"sha": "82f286f44e046bfc97391c0d131c676852c11c77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -1,3 +1,15 @@\n+2005-05-17  Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.in (tree-ssa-forwprop.o): Depend on langhooks.h.\n+\t* tree-ssa-forwprop.c: Include langhooks.h.\n+\t(forward_propagate_addr_expr_into_variable_array_index): New.\n+\t(forward_propagate_addr_expr): New.\n+\t(tree_ssa_forward_propagate_single_use_vars): Loop over all\n+\tthe statements in the block instead of just the last statement.\n+\tCall forward_propagate_addr_expr as needed.\n+\t(pass_forwprop): Update the SSA graph after forward propagation is\n+\tcomplete.\n+\n 2005-05-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* unwind-dw2-fde-glibc.c (base_from_cb_data,"}, {"sha": "62ac422337ad98c2084382d7354c7c81652d3c39", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -1665,7 +1665,8 @@ tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DIAGNOSTIC_H) $(TIMEVAR_H)\n tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n-   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H)\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n+   langhooks.h\n tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \\"}, {"sha": "712d9b9f8c6a4a28073715efef367a1ddae76e0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -1,3 +1,10 @@\n+2005-05-17  Jeff Law  <law@redhat.com>\n+\n+\t* g++.dg/tree-ssa/pr18414.C: New test.\n+\t* gcc.dg/tree-ssa/pr18414.C: New test.\n+\t* gcc.dg/tree-ssa/pr17141-1.C: New test.\n+\t* gcc.dg/tree-ssa/pr17141-2.C: New test.\n+\n 2005-05-17  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* gcc.dg/compat/generate-random.c: Do not include"}, {"sha": "59e3c9bc9b4009486cf817bba5ef3ce160939b84", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr14814.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr14814.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr14814.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr14814.C?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-forwprop2\" } */\n+\n+class YY { public:\n+  YY(const YY &v) { e[0] = v.e[0]; e[1] = v.e[1]; e[2] = v.e[2]; }\n+  double &y() { return e[1]; }\n+  double e[3];  };\n+\n+class XX { public:\n+  YY direction() const { return v; }\n+  YY v;  };\n+\n+int foo(XX& r) {\n+  if (r.direction().y() < 0.000001) return 0;\n+  return 1; }\n+\n+/* { dg-final { scan-tree-dump-times \"&this\" 0 \"forwprop2\" } } */\n+/* { dg-final { scan-tree-dump-times \"&r\" 0 \"forwprop2\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop2\" } } */\n+"}, {"sha": "a5bf8c85e0227db22d1dc91eaac576c5b3e56bd4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14814.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14814.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14814.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14814.c?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-forwprop2\" } */\n+\n+\n+struct YY {\n+  double e[3];  };\n+\n+static inline double *y(struct YY* this_1) { return &this_1->e[1]; }\n+\n+struct XX {\n+  struct YY v;\n+ };\n+\n+static inline struct YY direction (const struct  XX* this_1) { return this_1->v;}\n+\n+int foo(const struct XX* r) {\n+  struct YY t = direction(r);\n+  if (*y(&t) < 0.000001) return 0;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"&\" 0 \"forwprop2\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop2\" } } */\n+\n+"}, {"sha": "420c723da7feadd8aaf07f0f8f8e29c26fd7373c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr17141-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-1.c?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-forwprop2\" } */\n+\n+\n+struct A { int i; };\n+int\n+foo(struct A *locp, int str)\n+{\n+  int T355, *T356;\n+  T356 = &locp->i;\n+  *T356 = str;\n+  return locp->i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"&\" 0 \"forwprop2\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop2\" } } */\n+\n+"}, {"sha": "37782cafe8f293a592c1ea9a2ee36d051cd93950", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr17141-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-2.c?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+\n+\n+void abort (void);\n+struct a\n+{\n+  int i;\n+} *a;\n+int f(void)\n+{\n+  int *ii = &a->i;\n+  void *l;\n+  a->i = 1;\n+  if (*ii)\n+   l = &&l1;\n+  else\n+   l = &&l2;\n+  goto *l;\n+l1:\n+  return 0;\n+l2:\n+  abort ();\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"&\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"abort\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fb3dcaf6ea81ea01439b74bed99422f6154d2c14", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 294, "deletions": 10, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a564d0f1e9b03fa3e71331b766e8300cf93b2dff/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=a564d0f1e9b03fa3e71331b766e8300cf93b2dff", "patch": "@@ -1,4 +1,4 @@\n-/* Forward propagation of single use variables.\n+/* Forward propagation of expressions for single use variables.\n    Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -33,13 +33,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-flow.h\"\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n+#include \"langhooks.h\"\n \n-/* This pass performs simple forward propagation of single use variables\n-   from their definition site into their single use site.\n+/* This pass propagates the RHS of assignment statements into use\n+   sites of the LHS of the assignment.  It's basically a specialized\n+   form of tree combination.\n \n-   Right now we only bother forward propagating into COND_EXPRs since those\n-   are relatively common cases where forward propagation creates valid\n-   gimple code without the expression needing to fold.  i.e.\n+   Note carefully that after propagation the resulting statement\n+   must still be a proper gimple statement.  Right now we simply\n+   only perform propagations we know will result in valid gimple\n+   code.  One day we'll want to generalize this code.\n+\n+   One class of common cases we handle is forward propagating a single use\n+   variale into a COND_EXPR.  \n \n      bb0:\n        x = a COND b;\n@@ -107,6 +113,37 @@ Boston, MA 02111-1307, USA.  */\n    a statement, we put it back on the worklist to examine on the next\n    iteration of the main loop.\n \n+   A second class of propagation opportunities arises for ADDR_EXPR\n+   nodes.\n+\n+     ptr = &x->y->z;\n+     res = *ptr;\n+\n+   Will get turned into\n+\n+     res = x->y->z;\n+\n+   Or\n+\n+     ptr = &x[0];\n+     ptr2 = ptr + <constant>;\n+\n+   Will get turned into\n+\n+     ptr2 = &x[constant/elementsize];\n+\n+  Or\n+\n+     ptr = &x[0];\n+     offset = index * element_size;\n+     offset_p = (pointer) offset;\n+     ptr2 = ptr + offset_p\n+\n+  Will get turned into:\n+\n+     ptr2 = &x[index];\n+\n+\n    This will (of course) be extended as other needs arise.  */\n \n /* Given an SSA_NAME VAR, return true if and only if VAR is defined by\n@@ -397,6 +434,230 @@ forward_propagate_into_cond (tree cond_expr)\n     }\n }\n \n+/* STMT defines LHS which is contains the address of the 0th element\n+   in an array.  USE_STMT uses LHS to compute the address of an\n+   arbitrary element within the array.  The (variable) byte offset\n+   of the element is contained in OFFSET.\n+\n+   We walk back through the use-def chains of OFFSET to verify that\n+   it is indeed computing the offset of an element within the array\n+   and extract the index corresponding to the given byte offset.\n+\n+   We then try to fold the entire address expression into a form\n+   &array[index].\n+\n+   If we are successful, we replace the right hand side of USE_STMT\n+   with the new address computation.  */\n+\n+static bool\n+forward_propagate_addr_into_variable_array_index (tree offset, tree lhs,\n+\t\t\t\t\t\t  tree stmt, tree use_stmt)\n+{\n+  tree index;\n+\n+  /* The offset must be defined by a simple MODIFY_EXPR statement.  */\n+  if (TREE_CODE (offset) != MODIFY_EXPR)\n+    return false;\n+\n+  /* The RHS of the statement which defines OFFSET must be a gimple\n+     cast of another SSA_NAME.  */\n+  offset = TREE_OPERAND (offset, 1);\n+  if (!is_gimple_cast (offset))\n+    return false;\n+\n+  offset = TREE_OPERAND (offset, 0);\n+  if (TREE_CODE (offset) != SSA_NAME)\n+    return false;\n+\n+  /* Get the defining statement of the offset before type\n+     conversion.  */\n+  offset = SSA_NAME_DEF_STMT (offset);\n+\n+  /* The statement which defines OFFSET before type conversion\n+     must be a simple MODIFY_EXPR.  */\n+  if (TREE_CODE (offset) != MODIFY_EXPR)\n+    return false;\n+\n+  /* The RHS of the statement which defines OFFSET must be a\n+     multiplication of an object by the size of the array elements. \n+     This implicitly verifies that the size of the array elements\n+     is constant.  */\n+  offset = TREE_OPERAND (offset, 1);\n+  if (TREE_CODE (offset) != MULT_EXPR\n+      || TREE_CODE (TREE_OPERAND (offset, 1)) != INTEGER_CST\n+      || !simple_cst_equal (TREE_OPERAND (offset, 1),\n+\t\t\t    TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (lhs)))))\n+    return false;\n+\n+  /* The first operand to the MULT_EXPR is the desired index.  */\n+  index = TREE_OPERAND (offset, 0);\n+\n+  /* Replace the pointer addition with array indexing.  */\n+  TREE_OPERAND (use_stmt, 1) = unshare_expr (TREE_OPERAND (stmt, 1));\n+  TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 0), 1) = index;\n+\n+  /* That should have created gimple, so there is no need to\n+     record information to undo the propagation.  */\n+  fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt)));\n+  mark_new_vars_to_rename (use_stmt);\n+  update_stmt (use_stmt);\n+  return true;\n+}\n+\n+/* STMT is a statement of the form SSA_NAME = ADDR_EXPR <whatever>.\n+\n+   Try to forward propagate the ADDR_EXPR into the uses of the SSA_NAME.\n+   Often this will allow for removal of an ADDR_EXPR and INDIRECT_REF\n+   node or for recovery of array indexing from pointer arithmetic.  */\n+\n+static bool\n+forward_propagate_addr_expr (tree stmt)\n+{\n+  int stmt_loop_depth = bb_for_stmt (stmt)->loop_depth;\n+  tree name = TREE_OPERAND (stmt, 0);\n+  use_operand_p imm_use;\n+  tree use_stmt, lhs, rhs, array_ref;\n+\n+  /* We require that the SSA_NAME holding the result of the ADDR_EXPR\n+     be used only once.  That may be overly conservative in that we\n+     could propagate into multiple uses.  However, that would effectively\n+     be un-cseing the ADDR_EXPR, which is probably not what we want.  */\n+  single_imm_use (name, &imm_use, &use_stmt);\n+  if (!use_stmt)\n+    return false;\n+\n+  /* If the use is not in a simple assignment statement, then\n+     there is nothing we can do.  */\n+  if (TREE_CODE (use_stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  /* If the use is in a deeper loop nest, then we do not want\n+     to propagate the ADDR_EXPR into the loop as that is likely\n+     adding expression evaluations into the loop.  */\n+  if (bb_for_stmt (use_stmt)->loop_depth > stmt_loop_depth)\n+    return false;\n+\n+  /* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS.  */\n+  lhs = TREE_OPERAND (use_stmt, 0);\n+  while (TREE_CODE (lhs) == COMPONENT_REF || TREE_CODE (lhs) == ARRAY_REF)\n+    lhs = TREE_OPERAND (lhs, 0);\n+\n+  /* Now see if the LHS node is an INDIRECT_REF using NAME.  If so, \n+     propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n+  if (TREE_CODE (lhs) == INDIRECT_REF && TREE_OPERAND (lhs, 0) == name)\n+    {\n+      /* This should always succeed in creating gimple, so there is\n+\t no need to save enough state to undo this propagation.  */\n+      TREE_OPERAND (lhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt)));\n+      mark_new_vars_to_rename (use_stmt);\n+      update_stmt (use_stmt);\n+      return true;\n+    }\n+\n+  /* Trivial case.  The use statement could be a trivial copy.  We\n+     go ahead and handle that case here since it's trivial and\n+     removes the need to run copy-prop before this pass to get\n+     the best results.  Also note that by handling this case here\n+     we can catch some cascading effects, ie the single use is\n+     in a copy, and the copy is used later by a single INDIRECT_REF\n+     for example.  */\n+  if (TREE_CODE (lhs) == SSA_NAME && TREE_OPERAND (use_stmt, 1) == name)\n+    {\n+      TREE_OPERAND (use_stmt, 1) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      mark_new_vars_to_rename (use_stmt);\n+      update_stmt (use_stmt);\n+      return true;\n+    }\n+\n+  /* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the RHS.  */\n+  rhs = TREE_OPERAND (use_stmt, 1);\n+  while (TREE_CODE (rhs) == COMPONENT_REF || TREE_CODE (rhs) == ARRAY_REF)\n+    rhs = TREE_OPERAND (rhs, 0);\n+\n+  /* Now see if the RHS node is an INDIRECT_REF using NAME.  If so, \n+     propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n+  if (TREE_CODE (rhs) == INDIRECT_REF && TREE_OPERAND (rhs, 0) == name)\n+    {\n+      /* This should always succeed in creating gimple, so there is\n+         no need to save enough state to undo this propagation.  */\n+      TREE_OPERAND (rhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n+      fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt)));\n+      mark_new_vars_to_rename (use_stmt);\n+      update_stmt (use_stmt);\n+      return true;\n+    }\n+\n+  /* The remaining cases are all for turning pointer arithmetic into\n+     array indexing.  They only apply when we have the address of\n+     element zero in an array.  If that is not the case then there\n+     is nothing to do.  */\n+  array_ref = TREE_OPERAND (TREE_OPERAND (stmt, 1), 0);\n+  if (TREE_CODE (array_ref) != ARRAY_REF\n+      || TREE_CODE (TREE_TYPE (TREE_OPERAND (array_ref, 0))) != ARRAY_TYPE\n+      || !integer_zerop (TREE_OPERAND (array_ref, 1)))\n+    return false;\n+\n+  /* If the use of the ADDR_EXPR must be a PLUS_EXPR, or else there\n+     is nothing to do. */\n+  if (TREE_CODE (rhs) != PLUS_EXPR)\n+    return false;\n+\n+  /* Try to optimize &x[0] + C where C is a multiple of the size\n+     of the elements in X into &x[C/element size].  */\n+  if (TREE_OPERAND (rhs, 0) == name\n+      && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n+    {\n+      tree orig = unshare_expr (rhs);\n+      TREE_OPERAND (rhs, 0) = unshare_expr (TREE_OPERAND (stmt, 1));\n+\n+      /* If folding succeeds, then we have just exposed new variables\n+\t in USE_STMT which will need to be renamed.  If folding fails,\n+\t then we need to put everything back the way it was.  */\n+      if (fold_stmt (bsi_stmt_ptr (bsi_for_stmt (use_stmt))))\n+\t{\n+\t  mark_new_vars_to_rename (use_stmt);\n+\t  update_stmt (use_stmt);\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  TREE_OPERAND (use_stmt, 1) = orig;\n+\t  update_stmt (use_stmt);\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Try to optimize &x[0] + OFFSET where OFFSET is defined by\n+     converting a multiplication of an index by the size of the\n+     array elements, then the result is converted into the proper\n+     type for the arithmetic.  */\n+  if (TREE_OPERAND (rhs, 0) == name\n+      && TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME\n+      /* Avoid problems with IVopts creating PLUS_EXPRs with a\n+\t different type than their operands.  */\n+      && lang_hooks.types_compatible_p (TREE_TYPE (name), TREE_TYPE (rhs)))\n+    {\n+      tree offset_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n+      return forward_propagate_addr_into_variable_array_index (offset_stmt, lhs,\n+\t\t\t\t\t\t\t       stmt, use_stmt);\n+    }\n+\t      \n+  /* Same as the previous case, except the operands of the PLUS_EXPR\n+     were reversed.  */\n+  if (TREE_OPERAND (rhs, 1) == name\n+      && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+      /* Avoid problems with IVopts creating PLUS_EXPRs with a\n+\t different type than their operands.  */\n+      && lang_hooks.types_compatible_p (TREE_TYPE (name), TREE_TYPE (rhs)))\n+    {\n+      tree offset_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n+      return forward_propagate_addr_into_variable_array_index (offset_stmt, lhs,\n+\t\t\t\t\t\t\t       stmt, use_stmt);\n+    }\n+  return false;\n+}\n+\n /* Main entry point for the forward propagation optimizer.  */\n \n static void\n@@ -406,9 +667,32 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      tree last = last_stmt (bb);\n-      if (last && TREE_CODE (last) == COND_EXPR)\n-\tforward_propagate_into_cond (last);\n+      block_stmt_iterator bsi;\n+\n+      /* Note we update BSI within the loop as necessary.  */\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  /* If this statement sets an SSA_NAME to an address,\n+\t     try to propagate the address into the uses of the SSA_NAME.  */\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME)\n+\t    {\n+\t      if (forward_propagate_addr_expr (stmt))\n+\t\tbsi_remove (&bsi);\n+\t      else\n+\t\tbsi_next (&bsi);\n+\t    }\n+\t  else if (TREE_CODE (stmt) == COND_EXPR)\n+\t    {\n+\t      forward_propagate_into_cond (stmt);\n+\t      bsi_next (&bsi);\n+\t    }\n+\t  else\n+\t    bsi_next (&bsi);\n+\t}\n     }\n }\n \n@@ -433,6 +717,6 @@ struct tree_opt_pass pass_forwprop = {\n   0,\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t/* todo_flags_start */\n   TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n-  | TODO_verify_ssa,\n+  | TODO_update_ssa | TODO_verify_ssa,\n   0\t\t\t\t\t/* letter */\n };"}]}