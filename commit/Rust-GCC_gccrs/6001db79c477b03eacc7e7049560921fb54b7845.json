{"sha": "6001db79c477b03eacc7e7049560921fb54b7845", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwMWRiNzljNDc3YjAzZWFjYzdlNzA0OTU2MDkyMWZiNTRiNzg0NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-07T19:15:36Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-07T19:15:36Z"}, "message": "lra: Avoid cycling on certain subreg reloads [PR96796]\n\nThis PR is about LRA cycling for a reload of the form:\n\n----------------------------------------------------------------------------\nChanging pseudo 196 in operand 1 of insn 103 on equiv [r105:DI*0x8+r140:DI]\n      Creating newreg=287, assigning class ALL_REGS to slow/invalid mem r287\n      Creating newreg=288, assigning class ALL_REGS to slow/invalid mem r288\n  103: r203:SI=r288:SI<<0x1+r196:DI#0\n      REG_DEAD r196:DI\n    Inserting slow/invalid mem reload before:\n  316: r287:DI=[r105:DI*0x8+r140:DI]\n  317: r288:SI=r287:DI#0\n----------------------------------------------------------------------------\n\nThe problem is with r287.  We rightly give it a broad starting class of\nPOINTER_AND_FP_REGS (reduced from ALL_REGS by preferred_reload_class).\nHowever, we never make forward progress towards narrowing it down to\na specific choice of class (POINTER_REGS or FP_REGS).\n\nI think in practice we rely on two things to narrow a reload pseudo's\nclass down to a specific choice:\n\n(1) a restricted class is specified when the pseudo is created\n\n    This happens for input address reloads, where the class is taken\n    from the target's chosen base register class.  It also happens\n    for simple REG reloads, where the class is taken from the chosen\n    alternative's constraints.\n\n(2) uses of the reload pseudo as a direct input operand\n\n    In this case get_reload_reg tries to reuse the existing register\n    and narrow its class, instead of creating a new reload pseudo.\n\nHowever, neither occurs here.  As described above, r287 rightly\nstarts out with a wide choice of class, ultimately derived from\nALL_REGS, so we don't get (1).  And as the comments in the PR\nexplain, r287 is never used as an input reload, only the subreg is,\nso we don't get (2):\n\n----------------------------------------------------------------------------\n         Choosing alt 13 in insn 317:  (0) r  (1) w {*movsi_aarch64}\n      Creating newreg=291, assigning class FP_REGS to r291\n  317: r288:SI=r291:SI\n    Inserting insn reload before:\n  320: r291:SI=r287:DI#0\n----------------------------------------------------------------------------\n\nIMO, in this case we should rely on the reload of r316 to narrow\ndown the class of r278.  Currently we do:\n\n----------------------------------------------------------------------------\n         Choosing alt 7 in insn 316:  (0) r  (1) m {*movdi_aarch64}\n      Creating newreg=289 from oldreg=287, assigning class GENERAL_REGS to r289\n  316: r289:DI=[r105:DI*0x8+r140:DI]\n    Inserting insn reload after:\n  318: r287:DI=r289:DI\n---------------------------------------------------\n\ni.e. we create a new pseudo register r289 and give *that* pseudo\nGENERAL_REGS instead.  This is because get_reload_reg only narrows\ndown the existing class for OP_IN and OP_INOUT, not OP_OUT.\n\nBut if we have a reload pseudo in a reload instruction and have chosen\na specific class for the reload pseudo, I think we should simply install\nit for OP_OUT reloads too, if the class is a subset of the existing class.\nWe will need to pick such a register whatever happens (for r289 in the\nexample above).  And as explained in the PR, doing this actually avoids\nan unnecessary move via the FP registers too.\n\nThe patch is quite aggressive in that it does this for all reload\npseudos in all reload instructions.  I wondered about reusing the\ncondition for a reload move in in_class_p:\n\n          INSN_UID (curr_insn) >= new_insn_uid_start\n          && curr_insn_set != NULL\n          && ((OBJECT_P (SET_SRC (curr_insn_set))\n               && ! CONSTANT_P (SET_SRC (curr_insn_set)))\n              || (GET_CODE (SET_SRC (curr_insn_set)) == SUBREG\n                  && OBJECT_P (SUBREG_REG (SET_SRC (curr_insn_set)))\n                  && ! CONSTANT_P (SUBREG_REG (SET_SRC (curr_insn_set)))))))\n\nbut I can't really justify that on first principles.  I think we\nshould apply the rule consistently until we have a specific reason\nfor doing otherwise.\n\ngcc/\n\tPR rtl-optimization/96796\n\t* lra-constraints.c (in_class_p): Add a default-false\n\tallow_all_reload_class_changes_p parameter.  Do not treat\n\treload moves specially when the parameter is true.\n\t(get_reload_reg): Try to narrow the class of an existing OP_OUT\n\treload if we're reloading a reload pseudo in a reload instruction.\n\ngcc/testsuite/\n\tPR rtl-optimization/96796\n\t* gcc.c-torture/compile/pr96796.c: New test.", "tree": {"sha": "cf48331c6a0d67cfad658e3388a8ef0846a4caf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf48331c6a0d67cfad658e3388a8ef0846a4caf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6001db79c477b03eacc7e7049560921fb54b7845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6001db79c477b03eacc7e7049560921fb54b7845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6001db79c477b03eacc7e7049560921fb54b7845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6001db79c477b03eacc7e7049560921fb54b7845/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec5096f48bbd7db83cbe94bdd3235c5808a5979a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5096f48bbd7db83cbe94bdd3235c5808a5979a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5096f48bbd7db83cbe94bdd3235c5808a5979a"}], "stats": {"total": 109, "additions": 99, "deletions": 10}, "files": [{"sha": "161b721efb13b0f17e05adc109fbb40baf055b76", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001db79c477b03eacc7e7049560921fb54b7845/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001db79c477b03eacc7e7049560921fb54b7845/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=6001db79c477b03eacc7e7049560921fb54b7845", "patch": "@@ -236,12 +236,17 @@ get_reg_class (int regno)\n    CL.  Use elimination first if REG is a hard register.  If REG is a\n    reload pseudo created by this constraints pass, assume that it will\n    be allocated a hard register from its allocno class, but allow that\n-   class to be narrowed to CL if it is currently a superset of CL.\n+   class to be narrowed to CL if it is currently a superset of CL and\n+   if either:\n+\n+   - ALLOW_ALL_RELOAD_CLASS_CHANGES_P is true or\n+   - the instruction we're processing is not a reload move.\n \n    If NEW_CLASS is nonnull, set *NEW_CLASS to the new allocno class of\n    REGNO (reg), or NO_REGS if no change in its class was needed.  */\n static bool\n-in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)\n+in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class,\n+\t    bool allow_all_reload_class_changes_p = false)\n {\n   enum reg_class rclass, common_class;\n   machine_mode reg_mode;\n@@ -266,7 +271,8 @@ in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)\n \t typically moves that have many alternatives, and restricting\n \t reload pseudos for one alternative may lead to situations\n \t where other reload pseudos are no longer allocatable.  */\n-      || (INSN_UID (curr_insn) >= new_insn_uid_start\n+      || (!allow_all_reload_class_changes_p\n+\t  && INSN_UID (curr_insn) >= new_insn_uid_start\n \t  && curr_insn_set != NULL\n \t  && ((OBJECT_P (SET_SRC (curr_insn_set))\n \t       && ! CONSTANT_P (SET_SRC (curr_insn_set)))\n@@ -598,13 +604,12 @@ canonicalize_reload_addr (rtx addr)\n   return addr;\n }\n \n-/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse already\n-   created input reload pseudo (only if TYPE is not OP_OUT).  Don't\n-   reuse pseudo if IN_SUBREG_P is true and the reused pseudo should be\n-   wrapped up in SUBREG.  The result pseudo is returned through\n-   RESULT_REG.  Return TRUE if we created a new pseudo, FALSE if we\n-   reused the already created input reload pseudo.  Use TITLE to\n-   describe new registers for debug purposes.  */\n+/* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse an existing\n+   reload pseudo.  Don't reuse an existing reload pseudo if IN_SUBREG_P\n+   is true and the reused pseudo should be wrapped up in a SUBREG.\n+   The result pseudo is returned through RESULT_REG.  Return TRUE if we\n+   created a new pseudo, FALSE if we reused an existing reload pseudo.\n+   Use TITLE to describe new registers for debug purposes.  */\n static bool\n get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n \t\tenum reg_class rclass, bool in_subreg_p,\n@@ -616,6 +621,35 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n \n   if (type == OP_OUT)\n     {\n+      /* Output reload registers tend to start out with a conservative\n+\t choice of register class.  Usually this is ALL_REGS, although\n+\t a target might narrow it (for performance reasons) through\n+\t targetm.preferred_reload_class.  It's therefore quite common\n+\t for a reload instruction to require a more restrictive class\n+\t than the class that was originally assigned to the reload register.\n+\n+\t In these situations, it's more efficient to refine the choice\n+\t of register class rather than create a second reload register.\n+\t This also helps to avoid cycling for registers that are only\n+\t used by reload instructions.  */\n+      if (REG_P (original)\n+\t  && (int) REGNO (original) >= new_regno_start\n+\t  && INSN_UID (curr_insn) >= new_insn_uid_start\n+\t  && in_class_p (original, rclass, &new_class, true))\n+\t{\n+\t  unsigned int regno = REGNO (original);\n+\t  if (lra_dump_file != NULL)\n+\t    {\n+\t      fprintf (lra_dump_file, \"\t Reuse r%d for output \", regno);\n+\t      dump_value_slim (lra_dump_file, original, 1);\n+\t    }\n+\t  if (new_class != lra_get_allocno_class (regno))\n+\t    lra_change_class (regno, new_class, \", change to\", false);\n+\t  if (lra_dump_file != NULL)\n+\t    fprintf (lra_dump_file, \"\\n\");\n+\t  *result_reg = original;\n+\t  return false;\n+\t}\n       *result_reg\n \t= lra_create_new_reg_with_unique_value (mode, original, rclass, title);\n       return true;"}, {"sha": "8808e62fe7779fb478f85f12eaee63c5f8ab245e", "filename": "gcc/testsuite/gcc.c-torture/compile/pr96796.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6001db79c477b03eacc7e7049560921fb54b7845/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr96796.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6001db79c477b03eacc7e7049560921fb54b7845/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr96796.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr96796.c?ref=6001db79c477b03eacc7e7049560921fb54b7845", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-additional-options \"-fcommon\" } */\n+\n+struct S0 {\n+  signed f0 : 8;\n+  unsigned f1;\n+  unsigned f4;\n+};\n+struct S1 {\n+  long f3;\n+  char f4;\n+} g_3_4;\n+\n+int g_5, func_1_l_32, func_50___trans_tmp_31;\n+static struct S0 g_144, g_834, g_1255, g_1261;\n+\n+int g_273[120] = {};\n+int *g_555;\n+char **g_979;\n+static int g_1092_0;\n+static int g_1193;\n+int safe_mul_func_int16_t_s_s(int si1, int si2) { return si1 * si2; }\n+static struct S0 *func_50();\n+int func_1() { func_50(g_3_4, g_5, func_1_l_32, 8, 3); }\n+void safe_div_func_int64_t_s_s(int *);\n+void safe_mod_func_uint32_t_u_u(struct S0);\n+struct S0 *func_50(int p_51, struct S0 p_52, struct S1 p_53, int p_54,\n+                   int p_55) {\n+  int __trans_tmp_30;\n+  char __trans_tmp_22;\n+  short __trans_tmp_19;\n+  long l_985_1;\n+  long l_1191[8];\n+  safe_div_func_int64_t_s_s(g_273);\n+  __builtin_printf((char*)g_1261.f4);\n+  safe_mod_func_uint32_t_u_u(g_834);\n+  g_144.f0 += 1;\n+  for (;;) {\n+    struct S1 l_1350 = {&l_1350};\n+    for (; p_53.f3; p_53.f3 -= 1)\n+      for (; g_1193 <= 2; g_1193 += 1) {\n+        __trans_tmp_19 = safe_mul_func_int16_t_s_s(l_1191[l_985_1 + p_53.f3],\n+                                                   p_55 % (**g_979 = 10));\n+        __trans_tmp_22 = g_1255.f1 * p_53.f4;\n+        __trans_tmp_30 = __trans_tmp_19 + __trans_tmp_22;\n+        if (__trans_tmp_30)\n+          g_1261.f0 = p_51;\n+        else {\n+          g_1255.f0 = p_53.f3;\n+          int *l_1422 = g_834.f0 = g_144.f4 != (*l_1422)++ > 0 < 0 ^ 51;\n+          g_555 = ~0;\n+          g_1092_0 |= func_50___trans_tmp_31;\n+        }\n+      }\n+  }\n+}"}]}