{"sha": "6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFhM2M2MGQ3ZjU0YThkMjhlYzIyYjYwNDViYTBiZDc5ZTBmMzU0Yg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-12-04T23:04:59Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-12-04T23:04:59Z"}, "message": "c-typeck.c (null_pointer_constant_p): New function.\n\n\t* c-typeck.c (null_pointer_constant_p): New function.\n\t(build_conditional_expr, build_c_cast, convert_for_assignment,\n\tbuild_binary_op): Use it.\n\ntestsuite:\n\t* gcc.dg/c90-const-expr-5.c, gcc.dg/c99-const-expr-5.c: New tests.\n\nFrom-SVN: r108022", "tree": {"sha": "57f2351c8ddd1d0c929a34d992db282e82ab724b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57f2351c8ddd1d0c929a34d992db282e82ab724b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1344f9a3189ed48181c844c7d2cc1f70511ab898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1344f9a3189ed48181c844c7d2cc1f70511ab898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1344f9a3189ed48181c844c7d2cc1f70511ab898"}], "stats": {"total": 138, "additions": 120, "deletions": 18}, "files": [{"sha": "15da7d4a1421415bd946620e19bc3182b19d721b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "patch": "@@ -1,3 +1,9 @@\n+2005-12-04  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* c-typeck.c (null_pointer_constant_p): New function.\n+\t(build_conditional_expr, build_c_cast, convert_for_assignment,\n+\tbuild_binary_op): Use it.\n+\n 2005-12-04  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (binary_op_error): Do not allow NOP_EXPR."}, {"sha": "36c9bc0702c811c8741381a293c7ec55551e2f75", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "patch": "@@ -74,6 +74,7 @@ static int missing_braces_mentioned;\n static int require_constant_value;\n static int require_constant_elements;\n \n+static bool null_pointer_constant_p (tree);\n static tree qualify_type (tree, tree);\n static int tagged_types_tu_compatible_p (tree, tree);\n static int comp_target_types (tree, tree);\n@@ -106,6 +107,23 @@ static int lvalue_or_else (tree, enum lvalue_use);\n static int lvalue_p (tree);\n static void record_maybe_used_decl (tree);\n static int comptypes_internal (tree, tree);\n+\f\n+/* Return true if EXP is a null pointer constant, false otherwise.  */\n+\n+static bool\n+null_pointer_constant_p (tree expr)\n+{\n+  /* This should really operate on c_expr structures, but they aren't\n+     yet available everywhere required.  */\n+  tree type = TREE_TYPE (expr);\n+  return (TREE_CODE (expr) == INTEGER_CST\n+\t  && !TREE_CONSTANT_OVERFLOW (expr)\n+\t  && integer_zerop (expr)\n+\t  && (INTEGRAL_TYPE_P (type)\n+\t      || (TREE_CODE (type) == POINTER_TYPE\n+\t\t  && VOID_TYPE_P (TREE_TYPE (type))\n+\t\t  && TYPE_QUALS (TREE_TYPE (type)) == TYPE_UNQUALIFIED)));\n+}\n \f/* This is a cache to hold if two types are compatible or not.  */\n \n struct tagged_tu_seen_cache {\n@@ -3205,9 +3223,9 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     {\n       if (comp_target_types (type1, type2))\n \tresult_type = common_pointer_type (type1, type2);\n-      else if (integer_zerop (orig_op1) && TREE_TYPE (type1) == void_type_node)\n+      else if (null_pointer_constant_p (orig_op1))\n \tresult_type = qualify_type (type2, type1);\n-      else if (integer_zerop (orig_op2) && TREE_TYPE (type2) == void_type_node)\n+      else if (null_pointer_constant_p (orig_op2))\n \tresult_type = qualify_type (type1, type2);\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n@@ -3233,7 +3251,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n-      if (!integer_zerop (op2))\n+      if (!null_pointer_constant_p (orig_op2))\n \tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n@@ -3243,7 +3261,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     }\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n-      if (!integer_zerop (op1))\n+      if (!null_pointer_constant_p (orig_op1))\n \tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n@@ -3481,7 +3499,7 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n-\t  && !(integer_zerop (value) && TREE_TYPE (otype) == void_type_node))\n+\t  && !null_pointer_constant_p (value))\n \tpedwarn (\"ISO C forbids conversion of object pointer to function pointer type\");\n \n       ovalue = value;\n@@ -3834,7 +3852,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t    }\n \n \t  /* Can convert integer zero to any pointer type.  */\n-\t  if (integer_zerop (rhs))\n+\t  if (null_pointer_constant_p (rhs))\n \t    {\n \t      rhs = null_pointer_node;\n \t      break;\n@@ -3972,7 +3990,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)\n \t\t  ||\n \t\t  (VOID_TYPE_P (ttr)\n-\t\t   && !integer_zerop (rhs)\n+\t\t   && !null_pointer_constant_p (rhs)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n \t    WARN_FOR_ASSIGNMENT (G_(\"ISO C forbids passing argument %d of \"\n \t\t\t\t    \"%qE between function pointer \"\n@@ -4062,7 +4080,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       /* An explicit constant 0 can convert to a pointer,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n-      if (!integer_zerop (rhs))\n+      if (!null_pointer_constant_p (rhs))\n \tWARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\"pointer from integer without a cast\"),\n \t\t\t     G_(\"assignment makes pointer from integer \"\n@@ -7900,14 +7918,14 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t    {\n \t      /* op0 != orig_op0 detects the case of something\n \t\t whose value is 0 but which isn't a valid null ptr const.  */\n-\t      if (pedantic && (!integer_zerop (op0) || op0 != orig_op0)\n+\t      if (pedantic && !null_pointer_constant_p (orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n \t\tpedwarn (\"ISO C forbids comparison of %<void *%>\"\n \t\t\t \" with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n-\t      if (pedantic && (!integer_zerop (op1) || op1 != orig_op1)\n+\t      if (pedantic && !null_pointer_constant_p (orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n \t\tpedwarn (\"ISO C forbids comparison of %<void *%>\"\n \t\t\t \" with function pointer\");\n@@ -7920,11 +7938,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (result_type == NULL_TREE)\n \t    result_type = ptr_type_node;\n \t}\n-      else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n-\t       && integer_zerop (op1))\n+      else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \tresult_type = type0;\n-      else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n-\t       && integer_zerop (op0))\n+      else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \tresult_type = type1;\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -7964,15 +7980,13 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      pedwarn (\"comparison of distinct pointer types lacks a cast\");\n \t    }\n \t}\n-      else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n-\t       && integer_zerop (op1))\n+      else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n \t  result_type = type0;\n \t  if (pedantic || extra_warnings)\n \t    pedwarn (\"ordered comparison of pointer with integer zero\");\n \t}\n-      else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n-\t       && integer_zerop (op0))\n+      else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  result_type = type1;\n \t  if (pedantic)"}, {"sha": "fb0d84d7141ab19a64698edeba6c399a574d37cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "patch": "@@ -1,3 +1,7 @@\n+2005-12-04  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/c90-const-expr-5.c, gcc.dg/c99-const-expr-5.c: New tests.\n+\n 2005-12-04  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/format/cast-1.c: New test."}, {"sha": "132932b565a4f8eb596dee4eb24616c87d53270e", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-5.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c?ref=6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "patch": "@@ -0,0 +1,39 @@\n+/* Test null pointer constants: typedefs for void should be OK but not\n+   qualified void.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+typedef void V;\n+int *p;\n+long *q;\n+int j;\n+void (*fp)(void);\n+\n+void\n+f (void)\n+{\n+  /* (V *)0 is a null pointer constant, so the assignment should be\n+     diagnosed.  */\n+  q = (j ? p : (V *)0); /* { dg-error \"error: assignment from incompatible pointer type\" } */\n+  q = (j ? p : (void *)0); /* { dg-error \"error: assignment from incompatible pointer type\" } */\n+  /* And this conversion should be valid.  */\n+  (void (*)(void))(V *)0;\n+  (void (*)(void))(void *)0;\n+  /* Pointers to qualified void are not valid null pointer\n+     constants.  */\n+  fp = (const void *)0; /* { dg-error \"error: ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+  fp = (void *)0;\n+  fp = (V *)0;\n+  fp = 0;\n+  fp == 0;\n+  0 == fp;\n+  fp == (void *)0;\n+  (void *)0 == fp;\n+  fp == (V *)0;\n+  (V *)0 == fp;\n+  fp == (V *)1; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  (V *)1 == fp; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  fp == (const void *)0; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  (const void *)0 == fp; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+}"}, {"sha": "e7fdf2c644bfd5d189089bc550ece3ea9e1ba3cc", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-5.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-5.c?ref=6aa3c60d7f54a8d28ec22b6045ba0bd79e0f354b", "patch": "@@ -0,0 +1,39 @@\n+/* Test null pointer constants: typedefs for void should be OK but not\n+   qualified void.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+typedef void V;\n+int *p;\n+long *q;\n+int j;\n+void (*fp)(void);\n+\n+void\n+f (void)\n+{\n+  /* (V *)0 is a null pointer constant, so the assignment should be\n+     diagnosed.  */\n+  q = (j ? p : (V *)0); /* { dg-error \"error: assignment from incompatible pointer type\" } */\n+  q = (j ? p : (void *)0); /* { dg-error \"error: assignment from incompatible pointer type\" } */\n+  /* And this conversion should be valid.  */\n+  (void (*)(void))(V *)0;\n+  (void (*)(void))(void *)0;\n+  /* Pointers to qualified void are not valid null pointer\n+     constants.  */\n+  fp = (const void *)0; /* { dg-error \"error: ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+  fp = (void *)0;\n+  fp = (V *)0;\n+  fp = 0;\n+  fp == 0;\n+  0 == fp;\n+  fp == (void *)0;\n+  (void *)0 == fp;\n+  fp == (V *)0;\n+  (V *)0 == fp;\n+  fp == (V *)1; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  (V *)1 == fp; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  fp == (const void *)0; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  (const void *)0 == fp; /* { dg-error \"error: ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+}"}]}