{"sha": "fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJkZWMxNGU4MGU5Mzk5Y2QzMDFlZDMwMzQwMjY4YmRjNWI1YzJlYg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-12-07T18:03:53Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-12-07T18:03:53Z"}, "message": "re PR tree-optimization/81303 (410.bwaves regression caused by r249919)\n\n\tPR tree-optimization/81303\n\t* Makefile.in (gimple-loop-interchange.o): New object file.\n\t* common.opt (floop-interchange): Reuse the option from graphite.\n\t* doc/invoke.texi (-floop-interchange): Ditto.  New document for\n\t-floop-interchange and mention it for -O3.\n\t* opts.c (default_options_table): Enable -floop-interchange at -O3.\n\t* gimple-loop-interchange.cc: New file.\n\t* params.def (PARAM_LOOP_INTERCHANGE_MAX_NUM_STMTS): New parameter.\n\t(PARAM_LOOP_INTERCHANGE_STRIDE_RATIO): New parameter.\n\t* passes.def (pass_linterchange): New pass.\n\t* timevar.def (TV_LINTERCHANGE): New time var.\n\t* tree-pass.h (make_pass_linterchange): New declaration.\n\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Change to external\n\tinterchange.  Record IV before/after increment in new parameters.\n\t* tree-ssa-loop-ivopts.h (create_canonical_iv): New declaration.\n\t* tree-vect-loop.c (vect_is_simple_reduction): Factor out reduction\n\tpath check into...\n\t(check_reduction_path): ...New function here.\n\t* tree-vectorizer.h (check_reduction_path): New declaration.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/loop-interchange-1.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-1b.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-2.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-3.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-4.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-5.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-6.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-7.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-8.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-9.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-10.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-11.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-12.c: New test.\n\t* gcc.dg/tree-ssa/loop-interchange-13.c: New test.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r255472", "tree": {"sha": "6174dc33b68cbeea645678d9d23bde9cd4603643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6174dc33b68cbeea645678d9d23bde9cd4603643"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/comments", "author": null, "committer": null, "parents": [{"sha": "75214935bee043e659ca7172a84451ded10e8987", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75214935bee043e659ca7172a84451ded10e8987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75214935bee043e659ca7172a84451ded10e8987"}], "stats": {"total": 3140, "additions": 3032, "deletions": 108}, "files": [{"sha": "fd9ae5c5c00a74850d500b7307c01c43b2b0cb22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -1,3 +1,26 @@\n+2017-12-07  Bin Cheng  <bin.cheng@arm.com>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/81303\n+\t* Makefile.in (gimple-loop-interchange.o): New object file.\n+\t* common.opt (floop-interchange): Reuse the option from graphite.\n+\t* doc/invoke.texi (-floop-interchange): Ditto.  New document for\n+\t-floop-interchange and mention it for -O3.\n+\t* opts.c (default_options_table): Enable -floop-interchange at -O3.\n+\t* gimple-loop-interchange.cc: New file.\n+\t* params.def (PARAM_LOOP_INTERCHANGE_MAX_NUM_STMTS): New parameter.\n+\t(PARAM_LOOP_INTERCHANGE_STRIDE_RATIO): New parameter.\n+\t* passes.def (pass_linterchange): New pass.\n+\t* timevar.def (TV_LINTERCHANGE): New time var.\n+\t* tree-pass.h (make_pass_linterchange): New declaration.\n+\t* tree-ssa-loop-ivcanon.c (create_canonical_iv): Change to external\n+\tinterchange.  Record IV before/after increment in new parameters.\n+\t* tree-ssa-loop-ivopts.h (create_canonical_iv): New declaration.\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Factor out reduction\n+\tpath check into...\n+\t(check_reduction_path): ...New function here.\n+\t* tree-vectorizer.h (check_reduction_path): New declaration.\n+\n 2017-12-07  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/83252"}, {"sha": "216fb0d8d45c6842f722c4de58f3dee926280566", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -1302,6 +1302,7 @@ OBJS = \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n \tgimple-laddress.o \\\n+\tgimple-loop-interchange.o \\\n \tgimple-loop-jam.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\"}, {"sha": "6fab2abd931fb41cc5cc115d3a2f34dd70621565", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -1504,8 +1504,8 @@ Common Alias(floop-nest-optimize)\n Enable loop nest transforms.  Same as -floop-nest-optimize.\n \n floop-interchange\n-Common Alias(floop-nest-optimize)\n-Enable loop nest transforms.  Same as -floop-nest-optimize.\n+Common Report Var(flag_loop_interchange) Optimization\n+Enable loop interchange on trees.\n \n floop-block\n Common Alias(floop-nest-optimize)"}, {"sha": "50740c5e90593500c2275d760eff4786c57c6a35", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -7409,6 +7409,7 @@ by @option{-O2} and also turns on the following optimization flags:\n -ftree-loop-vectorize @gol\n -ftree-loop-distribution @gol\n -ftree-loop-distribute-patterns @gol\n+-floop-interchange @gol\n -fsplit-paths @gol\n -ftree-slp-vectorize @gol\n -fvect-cost-model @gol\n@@ -8508,12 +8509,10 @@ Perform loop optimizations on trees.  This flag is enabled by default\n at @option{-O} and higher.\n \n @item -ftree-loop-linear\n-@itemx -floop-interchange\n @itemx -floop-strip-mine\n @itemx -floop-block\n @itemx -floop-unroll-and-jam\n @opindex ftree-loop-linear\n-@opindex floop-interchange\n @opindex floop-strip-mine\n @opindex floop-block\n @opindex floop-unroll-and-jam\n@@ -8608,6 +8607,25 @@ ENDDO\n @end smallexample\n and the initialization loop is transformed into a call to memset zero.\n \n+@item -floop-interchange\n+@opindex floop-interchange\n+Perform loop interchange outside of graphite.  This flag can improve cache\n+performance on loop nest and allow further loop optimizations, like\n+vectorization, to take place.  For example, the loop\n+@smallexample\n+for (int i = 0; i < N; i++)\n+  for (int j = 0; j < N; j++)\n+    for (int k = 0; k < N; k++)\n+      c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+@end smallexample\n+is transformed to\n+@smallexample\n+for (int i = 0; i < N; i++)\n+  for (int k = 0; k < N; k++)\n+    for (int j = 0; j < N; j++)\n+      c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+@end smallexample\n+\n @item -ftree-loop-im\n @opindex ftree-loop-im\n Perform loop invariant motion on trees.  This pass moves only invariants that\n@@ -10479,6 +10497,12 @@ The size of L1 cache, in kilobytes.\n @item l2-cache-size\n The size of L2 cache, in kilobytes.\n \n+@item loop-interchange-max-num-stmts\n+The maximum number of stmts in a loop to be interchanged.\n+\n+@item loop-interchange-stride-ratio\n+The minimum ratio between stride of two loops for interchange to be profitable.\n+\n @item min-insn-to-prefetch-ratio\n The minimum ratio between the number of instructions and the\n number of prefetches to enable prefetching in a loop."}, {"sha": "6554a42e1fb2c619da98c37a624471adcb62e68a", "filename": "gcc/gimple-loop-interchange.cc", "status": "added", "additions": 2039, "deletions": 0, "changes": 2039, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,2039 @@\n+/* Loop interchange.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"is-a.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify-me.h\"\n+#include \"cfgloop.h\"\n+#include \"params.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"tree-ssa-loop-ivopts.h\"\n+#include \"tree-ssa-dce.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-vectorizer.h\"\n+\n+/* This pass performs loop interchange: for example, the loop nest\n+\n+   for (int j = 0; j < N; j++)\n+     for (int k = 0; k < N; k++)\n+       for (int i = 0; i < N; i++)\n+\t c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+\n+   is transformed to\n+\n+   for (int i = 0; i < N; i++)\n+     for (int j = 0; j < N; j++)\n+       for (int k = 0; k < N; k++)\n+\t c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+\n+   This pass implements loop interchange in the following steps:\n+\n+     1) Find perfect loop nest for each innermost loop and compute data\n+\tdependence relations for it.  For above example, loop nest is\n+\t<loop_j, loop_k, loop_i>.\n+     2) From innermost to outermost loop, this pass tries to interchange\n+\teach loop pair.  For above case, it firstly tries to interchange\n+\t<loop_k, loop_i> and loop nest becomes <loop_j, loop_i, loop_k>.\n+\tThen it tries to interchange <loop_j, loop_i> and loop nest becomes\n+\t<loop_i, loop_j, loop_k>.  The overall effect is to move innermost\n+\tloop to the outermost position.  For loop pair <loop_i, loop_j>\n+\tto be interchanged, we:\n+     3) Check if data dependence relations are valid for loop interchange.\n+     4) Check if both loops can be interchanged in terms of transformation.\n+     5) Check if interchanging the two loops is profitable.\n+     6) Interchange the two loops by mapping induction variables.\n+\n+   This pass also handles reductions in loop nest.  So far we only support\n+   simple reduction of inner loop and double reduction of the loop nest.  */\n+\n+/* Maximum number of stmts in each loop that should be interchanged.  */\n+#define MAX_NUM_STMT    (PARAM_VALUE (PARAM_LOOP_INTERCHANGE_MAX_NUM_STMTS))\n+/* Maximum number of data references in loop nest.  */\n+#define MAX_DATAREFS    (PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n+\n+/* Comparison ratio of access stride between inner/outer loops to be\n+   interchanged.  This is the minimum stride ratio for loop interchange\n+   to be profitable.  */\n+#define OUTER_STRIDE_RATIO  (PARAM_VALUE (PARAM_LOOP_INTERCHANGE_STRIDE_RATIO))\n+/* The same as above, but we require higher ratio for interchanging the\n+   innermost two loops.  */\n+#define INNER_STRIDE_RATIO  ((OUTER_STRIDE_RATIO) + 1)\n+\n+/* Vector of strides that DR accesses in each level loop of a loop nest.  */\n+#define DR_ACCESS_STRIDE(dr) ((vec<tree> *) dr->aux)\n+\n+/* Structure recording loop induction variable.  */\n+typedef struct induction\n+{\n+  /* IV itself.  */\n+  tree var;\n+  /* IV's initializing value, which is the init arg of the IV PHI node.  */\n+  tree init_val;\n+  /* IV's initializing expr, which is (the expanded result of) init_val.  */\n+  tree init_expr;\n+  /* IV's step.  */\n+  tree step;\n+} *induction_p;\n+\n+/* Enum type for loop reduction variable.  */\n+enum reduction_type\n+{\n+  UNKNOWN_RTYPE = 0,\n+  SIMPLE_RTYPE,\n+  DOUBLE_RTYPE\n+};\n+\n+/* Structure recording loop reduction variable.  */\n+typedef struct reduction\n+{\n+  /* Reduction itself.  */\n+  tree var;\n+  /* PHI node defining reduction variable.  */\n+  gphi *phi;\n+  /* Init and next variables of the reduction.  */\n+  tree init;\n+  tree next;\n+  /* Lcssa PHI node if reduction is used outside of its definition loop.  */\n+  gphi *lcssa_phi;\n+  /* Stmts defining init and next.  */\n+  gimple *producer;\n+  gimple *consumer;\n+  /* If init is loaded from memory, this is the loading memory reference.  */\n+  tree init_ref;\n+  /* If reduction is finally stored to memory, this is the stored memory\n+     reference.  */\n+  tree fini_ref;\n+  enum reduction_type type;\n+} *reduction_p;\n+\n+\n+/* Dump reduction RE.  */\n+\n+static void\n+dump_reduction (reduction_p re)\n+{\n+  if (re->type == SIMPLE_RTYPE)\n+    fprintf (dump_file, \"  Simple reduction:  \");\n+  else if (re->type == DOUBLE_RTYPE)\n+    fprintf (dump_file, \"  Double reduction:  \");\n+  else\n+    fprintf (dump_file, \"  Unknown reduction:  \");\n+\n+  print_gimple_stmt (dump_file, re->phi, 0);\n+}\n+\n+/* Dump LOOP's induction IV.  */\n+static void\n+dump_induction (struct loop *loop, induction_p iv)\n+{\n+  fprintf (dump_file, \"  Induction:  \");\n+  print_generic_expr (dump_file, iv->var, TDF_SLIM);\n+  fprintf (dump_file, \" = {\");\n+  print_generic_expr (dump_file, iv->init_expr, TDF_SLIM);\n+  fprintf (dump_file, \", \");\n+  print_generic_expr (dump_file, iv->step, TDF_SLIM);\n+  fprintf (dump_file, \"}_%d\\n\", loop->num);\n+}\n+\n+/* Loop candidate for interchange.  */\n+\n+struct loop_cand\n+{\n+  loop_cand (struct loop *, struct loop *);\n+  ~loop_cand ();\n+\n+  reduction_p find_reduction_by_stmt (gimple *);\n+  void classify_simple_reduction (reduction_p);\n+  bool analyze_iloop_reduction_var (tree);\n+  bool analyze_oloop_reduction_var (loop_cand *, tree);\n+  bool analyze_induction_var (tree, tree);\n+  bool analyze_carried_vars (loop_cand *);\n+  bool analyze_lcssa_phis (void);\n+  bool can_interchange_p (loop_cand *);\n+  bool supported_operations (basic_block, loop_cand *, int *);\n+  void undo_simple_reduction (reduction_p, bitmap);\n+\n+  /* The loop itself.  */\n+  struct loop *m_loop;\n+  /* The outer loop for interchange.  It equals to loop if this loop cand\n+     itself represents the outer loop.  */\n+  struct loop *m_outer;\n+  /* Vector of induction variables in loop.  */\n+  vec<induction_p> m_inductions;\n+  /* Vector of reduction variables in loop.  */\n+  vec<reduction_p> m_reductions;\n+  /* Lcssa PHI nodes of this loop.  */\n+  vec<gphi *> m_lcssa_nodes;\n+  /* Single exit edge of this loop.  */\n+  edge m_exit;\n+  /* Basic blocks of this loop.  */\n+  basic_block *m_bbs;\n+};\n+\n+/* Constructor.  */\n+\n+loop_cand::loop_cand (struct loop *loop, struct loop *outer)\n+  : m_loop (loop), m_outer (outer),\n+    m_exit (single_exit (loop)), m_bbs (get_loop_body (loop))\n+{\n+    m_inductions.create (3);\n+    m_reductions.create (3);\n+    m_lcssa_nodes.create (3);\n+}\n+\n+/* Destructor.  */\n+\n+loop_cand::~loop_cand ()\n+{\n+  induction_p iv;\n+  for (unsigned i = 0; m_inductions.iterate (i, &iv); ++i)\n+    free (iv);\n+\n+  reduction_p re;\n+  for (unsigned i = 0; m_reductions.iterate (i, &re); ++i)\n+    free (re);\n+\n+  m_inductions.release ();\n+  m_reductions.release ();\n+  m_lcssa_nodes.release ();\n+  free (m_bbs);\n+}\n+\n+/* Return single use stmt of VAR in LOOP, otherwise return NULL.  */\n+\n+static gimple *\n+single_use_in_loop (tree var, struct loop *loop)\n+{\n+  gimple *stmt, *res = NULL;\n+  use_operand_p use_p;\n+  imm_use_iterator iterator;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iterator, var)\n+    {\n+      stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n+\tcontinue;\n+\n+      if (res)\n+\treturn NULL;\n+\n+      res = stmt;\n+    }\n+  return res;\n+}\n+\n+/* Return true if E is unsupported in loop interchange, i.e, E is a complex\n+   edge or part of irreducible loop.  */\n+\n+static inline bool\n+unsupported_edge (edge e)\n+{\n+  return (e->flags & (EDGE_COMPLEX | EDGE_IRREDUCIBLE_LOOP));\n+}\n+\n+/* Return the reduction if STMT is one of its lcssa PHI, producer or consumer\n+   stmt.  */\n+\n+reduction_p\n+loop_cand::find_reduction_by_stmt (gimple *stmt)\n+{\n+  gphi *phi = dyn_cast <gphi *> (stmt);\n+  reduction_p re;\n+\n+  for (unsigned i = 0; m_reductions.iterate (i, &re); ++i)\n+    if ((phi != NULL && phi == re->lcssa_phi)\n+\t|| (stmt == re->producer || stmt == re->consumer))\n+      return re;\n+\n+  return NULL;\n+}\n+\n+/* Return true if all stmts in BB can be supported by loop interchange,\n+   otherwise return false.  ILOOP is not NULL if this loop_cand is the\n+   outer loop in loop nest.  Add the number of supported statements to\n+   NUM_STMTS.  */\n+\n+bool\n+loop_cand::supported_operations (basic_block bb, loop_cand *iloop,\n+\t\t\t\t int *num_stmts)\n+{\n+  int bb_num_stmts = 0;\n+  gphi_iterator psi;\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      if (gimple_has_side_effects (stmt))\n+\treturn false;\n+\n+      bb_num_stmts++;\n+      if (gcall *call = dyn_cast <gcall *> (stmt))\n+\t{\n+\t  /* In basic block of outer loop, the call should be cheap since\n+\t     it will be moved to inner loop.  */\n+\t  if (iloop != NULL\n+\t      && !gimple_inexpensive_call_p (call))\n+\t    return false;\n+\t  continue;\n+\t}\n+\n+      if (!iloop || !gimple_vuse (stmt))\n+\tcontinue;\n+\n+      /* Support stmt accessing memory in outer loop only if it is for inner\n+\t loop's reduction.  */\n+      if (iloop->find_reduction_by_stmt (stmt))\n+\tcontinue;\n+\n+      tree lhs;\n+      /* Support loop invariant memory reference if it's only used once by\n+\t inner loop.  */\n+      /* ???  How's this checking for invariantness?  */\n+      if (gimple_assign_single_p (stmt)\n+\t  && (lhs = gimple_assign_lhs (stmt)) != NULL_TREE\n+\t  && TREE_CODE (lhs) == SSA_NAME\n+\t  && single_use_in_loop (lhs, iloop->m_loop))\n+\tcontinue;\n+\n+      return false;\n+    }\n+  *num_stmts += bb_num_stmts;\n+\n+  /* Allow PHI nodes in any basic block of inner loop, PHI nodes in outer\n+     loop's header, or PHI nodes in dest bb of inner loop's exit edge.  */\n+  if (!iloop || bb == m_loop->header\n+      || bb == iloop->m_exit->dest)\n+    return true;\n+\n+  /* Don't allow any other PHI nodes.  */\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    if (!virtual_operand_p (PHI_RESULT (psi.phi ())))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true if current loop_cand be interchanged.  ILOOP is not NULL if\n+   current loop_cand is outer loop in loop nest.  */\n+\n+bool\n+loop_cand::can_interchange_p (loop_cand *iloop)\n+{\n+  /* For now we only support at most one reduction.  */\n+  unsigned allowed_reduction_num = 1;\n+\n+  /* Only support reduction if the loop nest to be interchanged is the\n+     innermostin two loops.  */\n+  if ((iloop == NULL && m_loop->inner != NULL)\n+       || (iloop != NULL && iloop->m_loop->inner != NULL))\n+    allowed_reduction_num = 0;\n+\n+  if (m_reductions.length () > allowed_reduction_num\n+      || (m_reductions.length () == 1\n+\t  && m_reductions[0]->type == UNKNOWN_RTYPE))\n+    return false;\n+\n+  /* Only support lcssa PHI node which is for reduction.  */\n+  if (m_lcssa_nodes.length () > allowed_reduction_num)\n+    return false;\n+\n+  int num_stmts = 0;\n+  /* Check basic blocks other than loop header/exit.  */\n+  for (unsigned i = 0; i < m_loop->num_nodes; i++)\n+    {\n+      basic_block bb = m_bbs[i];\n+\n+      /* Skip basic blocks of inner loops.  */\n+      if (bb->loop_father != m_loop)\n+\tcontinue;\n+\n+      /* Check if basic block has any unsupported operation.  */\n+      if (!supported_operations (bb, iloop, &num_stmts))\n+\treturn false;\n+\n+      /* Check if loop has too many stmts.  */\n+      if (num_stmts > MAX_NUM_STMT)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Programmers and optimizers (like loop store motion) may optimize code:\n+\n+     for (int i = 0; i < N; i++)\n+       for (int j = 0; j < N; j++)\n+\t a[i] += b[j][i] * c[j][i];\n+\n+   into reduction:\n+\n+     for (int i = 0; i < N; i++)\n+       {\n+\t // producer.  Note sum can be intitialized to a constant.\n+\t int sum = a[i];\n+\t for (int j = 0; j < N; j++)\n+\t   {\n+\t     sum += b[j][i] * c[j][i];\n+\t   }\n+\t // consumer.\n+\t a[i] = sum;\n+       }\n+\n+   The result code can't be interchanged without undoing the optimization.\n+   This function classifies this kind reduction and records information so\n+   that we can undo the store motion during interchange.  */\n+\n+void\n+loop_cand::classify_simple_reduction (reduction_p re)\n+{\n+  gimple *producer, *consumer;\n+\n+  /* Check init variable of reduction and how it is initialized.  */\n+  if (TREE_CODE (re->init) == SSA_NAME)\n+    {\n+      producer = SSA_NAME_DEF_STMT (re->init);\n+      re->producer = producer;\n+      basic_block bb = gimple_bb (producer);\n+      if (!bb || bb->loop_father != m_outer)\n+\treturn;\n+\n+      if (!gimple_assign_load_p (producer))\n+\treturn;\n+\n+      re->init_ref = gimple_assign_rhs1 (producer);\n+    }\n+  else if (!CONSTANT_CLASS_P (re->init))\n+    return;\n+\n+  /* Check how reduction variable is used.  */\n+  consumer = single_use_in_loop (PHI_RESULT (re->lcssa_phi), m_outer);\n+  if (!consumer\n+      || !gimple_store_p (consumer))\n+    return;\n+\n+  re->fini_ref = gimple_get_lhs (consumer);\n+  re->consumer = consumer;\n+\n+  /* Simple reduction with constant initializer.  */\n+  if (!re->init_ref)\n+    {\n+      gcc_assert (CONSTANT_CLASS_P (re->init));\n+      re->init_ref = unshare_expr (re->fini_ref);\n+    }\n+\n+  /* Require memory references in producer and consumer are the same so\n+     that we can undo reduction during interchange.  */\n+  if (re->init_ref && !operand_equal_p (re->init_ref, re->fini_ref, 0))\n+    return;\n+\n+  re->type = SIMPLE_RTYPE;\n+}\n+\n+/* Analyze reduction variable VAR for inner loop of the loop nest to be\n+   interchanged.  Return true if analysis succeeds.  */\n+\n+bool\n+loop_cand::analyze_iloop_reduction_var (tree var)\n+{\n+  gphi *phi = as_a <gphi *> (SSA_NAME_DEF_STMT (var));\n+  gphi *lcssa_phi = NULL, *use_phi;\n+  tree init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (m_loop));\n+  tree next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (m_loop));\n+  reduction_p re;\n+  gimple *stmt, *next_def, *single_use = NULL;\n+  use_operand_p use_p;\n+  imm_use_iterator iterator;\n+\n+  if (TREE_CODE (next) != SSA_NAME)\n+    return false;\n+\n+  next_def = SSA_NAME_DEF_STMT (next);\n+  basic_block bb = gimple_bb (next_def);\n+  if (!bb || !flow_bb_inside_loop_p (m_loop, bb))\n+    return false;\n+\n+  /* In restricted reduction, the var is (and must be) used in defining\n+     the updated var.  The process can be depicted as below:\n+\n+\t\tvar ;; = PHI<init, next>\n+\t\t |\n+\t\t |\n+\t\t v\n+      +---------------------+\n+      | reduction operators | <-- other operands\n+      +---------------------+\n+\t\t |\n+\t\t |\n+\t\t v\n+\t\tnext\n+\n+     In terms loop interchange, we don't change how NEXT is computed based\n+     on VAR and OTHER OPERANDS.  In case of double reduction in loop nest\n+     to be interchanged, we don't changed it at all.  In the case of simple\n+     reduction in inner loop, we only make change how VAR/NEXT is loaded or\n+     stored.  With these conditions, we can relax restrictions on reduction\n+     in a way that reduction operation is seen as black box.  In general,\n+     we can ignore reassociation of reduction operator; we can handle fake\n+     reductions in which VAR is not even used to compute NEXT.  */\n+  if (! single_imm_use (var, &use_p, &single_use)\n+      || ! flow_bb_inside_loop_p (m_loop, gimple_bb (single_use)))\n+    return false;\n+\n+  /* Check the reduction operation.  We require a left-associative operation.\n+     For FP math we also need to be allowed to associate operations.  */\n+  if (gassign *ass = dyn_cast <gassign *> (single_use))\n+    {\n+      enum tree_code code = gimple_assign_rhs_code (ass);\n+      if (! (associative_tree_code (code)\n+\t     || (code == MINUS_EXPR\n+\t\t && use_p->use == gimple_assign_rhs1_ptr (ass)))\n+\t  || (FLOAT_TYPE_P (TREE_TYPE (var))\n+\t      && ! flag_associative_math))\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  /* Handle and verify a series of stmts feeding the reduction op.  */\n+  if (single_use != next_def\n+      && !check_reduction_path (UNKNOWN_LOCATION, m_loop, phi, next,\n+\t\t\t\tgimple_assign_rhs_code (single_use)))\n+    return false;\n+\n+  /* Only support cases in which INIT is used in inner loop.  */\n+  if (TREE_CODE (init) == SSA_NAME)\n+    FOR_EACH_IMM_USE_FAST (use_p, iterator, init)\n+      {\n+\tstmt = USE_STMT (use_p);\n+\tif (is_gimple_debug (stmt))\n+\t  continue;\n+\n+\tif (!flow_bb_inside_loop_p (m_loop, gimple_bb (stmt)))\n+\t  return false;\n+      }\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iterator, next)\n+    {\n+      stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      /* Or else it's used in PHI itself.  */\n+      use_phi = dyn_cast <gphi *> (stmt);\n+      if (use_phi == phi)\n+\tcontinue;\n+\n+      if (use_phi != NULL\n+\t  && lcssa_phi == NULL\n+\t  && gimple_bb (stmt) == m_exit->dest\n+\t  && PHI_ARG_DEF_FROM_EDGE (use_phi, m_exit) == next)\n+\tlcssa_phi = use_phi;\n+      else\n+\treturn false;\n+    }\n+  if (!lcssa_phi)\n+    return false;\n+\n+  re = XCNEW (struct reduction);\n+  re->var = var;\n+  re->init = init;\n+  re->next = next;\n+  re->phi = phi;\n+  re->lcssa_phi = lcssa_phi;\n+\n+  classify_simple_reduction (re);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_reduction (re);\n+\n+  m_reductions.safe_push (re);\n+  return true;\n+}\n+\n+/* Analyze reduction variable VAR for outer loop of the loop nest to be\n+   interchanged.  ILOOP is not NULL and points to inner loop.  For the\n+   moment, we only support double reduction for outer loop, like:\n+\n+     for (int i = 0; i < n; i++)\n+       {\n+\t int sum = 0;\n+\n+\t for (int j = 0; j < n; j++)    // outer loop\n+\t   for (int k = 0; k < n; k++)  // inner loop\n+\t     sum += a[i][k]*b[k][j];\n+\n+\t s[i] = sum;\n+       }\n+\n+   Note the innermost two loops are the loop nest to be interchanged.\n+   Return true if analysis succeeds.  */\n+\n+bool\n+loop_cand::analyze_oloop_reduction_var (loop_cand *iloop, tree var)\n+{\n+  gphi *phi = as_a <gphi *> (SSA_NAME_DEF_STMT (var));\n+  gphi *lcssa_phi = NULL, *use_phi;\n+  tree init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (m_loop));\n+  tree next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (m_loop));\n+  reduction_p re;\n+  gimple *stmt, *next_def;\n+  use_operand_p use_p;\n+  imm_use_iterator iterator;\n+\n+  if (TREE_CODE (next) != SSA_NAME)\n+    return false;\n+\n+  next_def = SSA_NAME_DEF_STMT (next);\n+  basic_block bb = gimple_bb (next_def);\n+  if (!bb || !flow_bb_inside_loop_p (m_loop, bb))\n+    return false;\n+\n+  /* Find inner loop's simple reduction that uses var as initializer.  */\n+  reduction_p inner_re = NULL;\n+  for (unsigned i = 0; iloop->m_reductions.iterate (i, &inner_re); ++i)\n+    if (inner_re->init == var || operand_equal_p (inner_re->init, var, 0))\n+      break;\n+\n+  if (inner_re == NULL\n+      || inner_re->type != UNKNOWN_RTYPE\n+      || inner_re->producer != phi)\n+    return false;\n+\n+  /* In case of double reduction, outer loop's reduction should be updated\n+     by inner loop's simple reduction.  */\n+  if (next_def != inner_re->lcssa_phi)\n+    return false;\n+\n+  /* Outer loop's reduction should only be used to initialize inner loop's\n+     simple reduction.  */\n+  if (! single_imm_use (var, &use_p, &stmt)\n+      || stmt != inner_re->phi)\n+    return false;\n+\n+  /* Check this reduction is correctly used outside of loop via lcssa phi.  */\n+  FOR_EACH_IMM_USE_FAST (use_p, iterator, next)\n+    {\n+      stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      /* Or else it's used in PHI itself.  */\n+      use_phi = dyn_cast <gphi *> (stmt);\n+      if (use_phi == phi)\n+\tcontinue;\n+\n+      if (lcssa_phi == NULL\n+\t  && use_phi != NULL\n+\t  && gimple_bb (stmt) == m_exit->dest\n+\t  && PHI_ARG_DEF_FROM_EDGE (use_phi, m_exit) == next)\n+\tlcssa_phi = use_phi;\n+      else\n+\treturn false;\n+    }\n+  if (!lcssa_phi)\n+    return false;\n+\n+  re = XCNEW (struct reduction);\n+  re->var = var;\n+  re->init = init;\n+  re->next = next;\n+  re->phi = phi;\n+  re->lcssa_phi = lcssa_phi;\n+  re->type = DOUBLE_RTYPE;\n+  inner_re->type = DOUBLE_RTYPE;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_reduction (re);\n+\n+  m_reductions.safe_push (re);\n+  return true;\n+}\n+\n+/* Return true if VAR is induction variable of current loop whose scev is\n+   specified by CHREC.  */\n+\n+bool\n+loop_cand::analyze_induction_var (tree var, tree chrec)\n+{\n+  gphi *phi = as_a <gphi *> (SSA_NAME_DEF_STMT (var));\n+  tree init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (m_loop));\n+\n+  /* Var is loop invariant, though it's unlikely to happen.  */\n+  if (tree_does_not_contain_chrecs (chrec))\n+    {\n+      struct induction *iv = XCNEW (struct induction);\n+      iv->var = var;\n+      iv->init_val = init;\n+      iv->init_expr = chrec;\n+      iv->step = build_int_cst (TREE_TYPE (chrec), 0);\n+      m_inductions.safe_push (iv);\n+      return true;\n+    }\n+\n+  if (TREE_CODE (chrec) != POLYNOMIAL_CHREC\n+      || CHREC_VARIABLE (chrec) != (unsigned) m_loop->num\n+      || tree_contains_chrecs (CHREC_LEFT (chrec), NULL)\n+      || tree_contains_chrecs (CHREC_RIGHT (chrec), NULL))\n+    return false;\n+\n+  struct induction *iv = XCNEW (struct induction);\n+  iv->var = var;\n+  iv->init_val = init;\n+  iv->init_expr = CHREC_LEFT (chrec);\n+  iv->step = CHREC_RIGHT (chrec);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_induction (m_loop, iv);\n+\n+  m_inductions.safe_push (iv);\n+  return true;\n+}\n+\n+/* Return true if all loop carried variables defined in loop header can\n+   be successfully analyzed.  */\n+\n+bool\n+loop_cand::analyze_carried_vars (loop_cand *iloop)\n+{\n+  edge e = loop_preheader_edge (m_outer);\n+  gphi_iterator gsi;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nLoop(%d) carried vars:\\n\", m_loop->num);\n+\n+  for (gsi = gsi_start_phis (m_loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+\n+      tree var = PHI_RESULT (phi);\n+      if (virtual_operand_p (var))\n+\tcontinue;\n+\n+      tree chrec = analyze_scalar_evolution (m_loop, var);\n+      chrec = instantiate_scev (e, m_loop, chrec);\n+\n+      /* Analyze var as reduction variable.  */\n+      if (chrec_contains_undetermined (chrec)\n+\t  || chrec_contains_symbols_defined_in_loop (chrec, m_outer->num))\n+\t{\n+\t  if (iloop && !analyze_oloop_reduction_var (iloop, var))\n+\t    return false;\n+\t  if (!iloop && !analyze_iloop_reduction_var (var))\n+\t    return false;\n+\t}\n+      /* Analyze var as induction variable.  */\n+      else if (!analyze_induction_var (var, chrec))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return TRUE if loop closed PHI nodes can be analyzed successfully.  */\n+\n+bool\n+loop_cand::analyze_lcssa_phis (void)\n+{\n+  gphi_iterator gsi;\n+  for (gsi = gsi_start_phis (m_exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+\n+      if (virtual_operand_p (PHI_RESULT (phi)))\n+\tcontinue;\n+\n+      /* TODO: We only support lcssa phi for reduction for now.  */\n+      if (!find_reduction_by_stmt (phi))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* CONSUMER is a stmt in BB storing reduction result into memory object.\n+   When the reduction is intialized from constant value, we need to add\n+   a stmt loading from the memory object to target basic block in inner\n+   loop during undoing the reduction.  Problem is that memory reference\n+   may use ssa variables not dominating the target basic block.  This\n+   function finds all stmts on which CONSUMER depends in basic block BB,\n+   records and returns them via STMTS.  */\n+\n+static void\n+find_deps_in_bb_for_stmt (gimple_seq *stmts, basic_block bb, gimple *consumer)\n+{\n+  auto_vec<gimple *, 4> worklist;\n+  use_operand_p use_p;\n+  ssa_op_iter iter;\n+  gimple *stmt, *def_stmt;\n+  gimple_stmt_iterator gsi;\n+\n+  /* First clear flag for stmts in bb.  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    gimple_set_plf (gsi_stmt (gsi), GF_PLF_1, false);\n+\n+  /* DFS search all depended stmts in bb and mark flag for these stmts.  */\n+  worklist.safe_push (consumer);\n+  while (!worklist.is_empty ())\n+    {\n+      stmt = worklist.pop ();\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  def_stmt = SSA_NAME_DEF_STMT (USE_FROM_PTR (use_p));\n+\n+\t  if (is_a <gphi *> (def_stmt)\n+\t      || gimple_bb (def_stmt) != bb\n+\t      || gimple_plf (def_stmt, GF_PLF_1))\n+\t    continue;\n+\n+\t  worklist.safe_push (def_stmt);\n+\t}\n+      gimple_set_plf (stmt, GF_PLF_1, true);\n+    }\n+  for (gsi = gsi_start_bb_nondebug (bb);\n+       !gsi_end_p (gsi) && (stmt = gsi_stmt (gsi)) != consumer;)\n+    {\n+      /* Move dep stmts to sequence STMTS.  */\n+      if (gimple_plf (stmt, GF_PLF_1))\n+\t{\n+\t  gsi_remove (&gsi, false);\n+\t  gimple_seq_add_stmt_without_update (stmts, stmt);\n+\t}\n+      else\n+\tgsi_next_nondebug (&gsi);\n+    }\n+}\n+\n+/* User can write, optimizers can generate simple reduction RE for inner\n+   loop.  In order to make interchange valid, we have to undo reduction by\n+   moving producer and consumer stmts into the inner loop.  For example,\n+   below code:\n+\n+     init = MEM_REF[idx];\t\t//producer\n+     loop:\n+       var = phi<init, next>\n+       next = var op ...\n+     reduc_sum = phi<next>\n+     MEM_REF[idx] = reduc_sum\t\t//consumer\n+\n+   is transformed into:\n+\n+     loop:\n+       new_var = MEM_REF[idx];\t\t//producer after moving\n+       next = new_var op ...\n+       MEM_REF[idx] = next;\t\t//consumer after moving\n+\n+   Note if the reduction variable is initialized to constant, like:\n+\n+     var = phi<0.0, next>\n+\n+   we compute new_var as below:\n+\n+     loop:\n+       tmp = MEM_REF[idx];\n+       new_var = !first_iteration ? tmp : 0.0;\n+\n+   so that the initial const is used in the first iteration of loop.  Also\n+   record ssa variables for dead code elimination in DCE_SEEDS.  */\n+\n+void\n+loop_cand::undo_simple_reduction (reduction_p re, bitmap dce_seeds)\n+{\n+  gimple *stmt;\n+  gimple_stmt_iterator from, to = gsi_after_labels (m_loop->header);\n+  gimple_seq stmts = NULL;\n+  tree new_var;\n+\n+  /* Prepare the initialization stmts and insert it to inner loop.  */\n+  if (re->producer != NULL)\n+    {\n+      gimple_set_vuse (re->producer, NULL_TREE);\n+      from = gsi_for_stmt (re->producer);\n+      gsi_remove (&from, false);\n+      gimple_seq_add_stmt_without_update (&stmts, re->producer);\n+      new_var = re->init;\n+    }\n+  else\n+    {\n+      /* Find all stmts on which expression \"MEM_REF[idx]\" depends.  */\n+      find_deps_in_bb_for_stmt (&stmts, gimple_bb (re->consumer), re->consumer);\n+      /* Because we generate new stmt loading from the MEM_REF to TMP.  */\n+      tree cond, tmp = copy_ssa_name (re->var);\n+      stmt = gimple_build_assign (tmp, re->init_ref);\n+      gimple_seq_add_stmt_without_update (&stmts, stmt);\n+\n+      /* Init new_var to MEM_REF or CONST depending on if it is the first\n+\t iteration.  */\n+      induction_p iv = m_inductions[0];\n+      cond = fold_build2 (NE_EXPR, boolean_type_node, iv->var, iv->init_val);\n+      new_var = copy_ssa_name (re->var);\n+      stmt = gimple_build_assign (new_var, COND_EXPR, cond, tmp, re->init);\n+      gimple_seq_add_stmt_without_update (&stmts, stmt);\n+    }\n+  gsi_insert_seq_before (&to, stmts, GSI_SAME_STMT);\n+\n+  /* Replace all uses of reduction var with new variable.  */\n+  use_operand_p use_p;\n+  imm_use_iterator iterator;\n+  FOR_EACH_IMM_USE_STMT (stmt, iterator, re->var)\n+    {\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, iterator)\n+\tSET_USE (use_p, new_var);\n+\n+      update_stmt (stmt);\n+    }\n+\n+  /* Move consumer stmt into inner loop, just after reduction next's def.  */\n+  unlink_stmt_vdef (re->consumer);\n+  release_ssa_name (gimple_vdef (re->consumer));\n+  gimple_set_vdef (re->consumer, NULL_TREE);\n+  gimple_set_vuse (re->consumer, NULL_TREE);\n+  gimple_assign_set_rhs1 (re->consumer, re->next);\n+  from = gsi_for_stmt (re->consumer);\n+  to = gsi_for_stmt (SSA_NAME_DEF_STMT (re->next));\n+  gsi_move_after (&from, &to);\n+\n+  /* Mark the reduction variables for DCE.  */\n+  bitmap_set_bit (dce_seeds, SSA_NAME_VERSION (re->var));\n+  bitmap_set_bit (dce_seeds, SSA_NAME_VERSION (PHI_RESULT (re->lcssa_phi)));\n+}\n+\n+/* Free DATAREFS and its auxiliary memory.  */\n+\n+static void\n+free_data_refs_with_aux (vec<data_reference_p> datarefs)\n+{\n+  data_reference_p dr;\n+  for (unsigned i = 0; datarefs.iterate (i, &dr); ++i)\n+    if (dr->aux != NULL)\n+      {\n+\tDR_ACCESS_STRIDE (dr)->release ();\n+\tfree (dr->aux);\n+      }\n+\n+  free_data_refs (datarefs);\n+}\n+\n+/* Class for loop interchange transformation.  */\n+\n+class tree_loop_interchange\n+{\n+public:\n+  tree_loop_interchange (vec<struct loop *> loop_nest)\n+    : m_loop_nest (loop_nest), m_niters_iv_var (NULL_TREE),\n+      m_dce_seeds (BITMAP_ALLOC (NULL)) { }\n+  ~tree_loop_interchange () { BITMAP_FREE (m_dce_seeds); }\n+  bool interchange (vec<data_reference_p>, vec<ddr_p>);\n+\n+private:\n+  void update_data_info (unsigned, unsigned, vec<data_reference_p>, vec<ddr_p>);\n+  bool valid_data_dependences (unsigned, unsigned, vec<ddr_p>);\n+  void interchange_loops (loop_cand &, loop_cand &);\n+  void map_inductions_to_loop (loop_cand &, loop_cand &);\n+  void move_code_to_inner_loop (struct loop *, struct loop *, basic_block *);\n+\n+  /* The whole loop nest in which interchange is ongoing.  */\n+  vec<struct loop *> m_loop_nest;\n+  /* We create new IV which is only used in loop's exit condition check.\n+     In case of 3-level loop nest interchange, when we interchange the\n+     innermost two loops, new IV created in the middle level loop does\n+     not need to be preserved in interchanging the outermost two loops\n+     later.  We record the IV so that it can be skipped.  */\n+  tree m_niters_iv_var;\n+  /* Bitmap of seed variables for dead code elimination after interchange.  */\n+  bitmap m_dce_seeds;\n+};\n+\n+/* Update data refs' access stride and dependence information after loop\n+   interchange.  I_IDX/O_IDX gives indices of interchanged loops in loop\n+   nest.  DATAREFS are data references.  DDRS are data dependences.  */\n+\n+void\n+tree_loop_interchange::update_data_info (unsigned i_idx, unsigned o_idx,\n+\t\t\t\t\t vec<data_reference_p> datarefs,\n+\t\t\t\t\t vec<ddr_p> ddrs)\n+{\n+  struct data_reference *dr;\n+  struct data_dependence_relation *ddr;\n+\n+  /* Update strides of data references.  */\n+  for (unsigned i = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      vec<tree> *stride = DR_ACCESS_STRIDE (dr);\n+      gcc_assert (stride->length () > i_idx);\n+      std::swap ((*stride)[i_idx], (*stride)[o_idx]);\n+    }\n+  /* Update data dependences.  */\n+  for (unsigned i = 0; ddrs.iterate (i, &ddr); ++i)\n+    if (DDR_ARE_DEPENDENT (ddr) != chrec_known)\n+      {\n+        for (unsigned j = 0; j < DDR_NUM_DIST_VECTS (ddr); ++j)\n+\t  {\n+\t    lambda_vector dist_vect = DDR_DIST_VECT (ddr, j);\n+\t    std::swap (dist_vect[i_idx], dist_vect[o_idx]);\n+\t  }\n+      }\n+}\n+\n+/* Check data dependence relations, return TRUE if it's valid to interchange\n+   two loops specified by I_IDX/O_IDX.  Theoretically, interchanging the two\n+   loops is valid only if dist vector, after interchanging, doesn't have '>'\n+   as the leftmost non-'=' direction.  Practically, this function have been\n+   conservative here by not checking some valid cases.  */\n+\n+bool\n+tree_loop_interchange::valid_data_dependences (unsigned i_idx, unsigned o_idx,\n+\t\t\t\t\t       vec<ddr_p> ddrs)\n+{\n+  struct data_dependence_relation *ddr;\n+\n+  for (unsigned i = 0; ddrs.iterate (i, &ddr); ++i)\n+    {\n+      /* Skip no-dependence case.  */\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\tcontinue;\n+\n+      for (unsigned j = 0; j < DDR_NUM_DIST_VECTS (ddr); ++j)\n+\t{\n+\t  lambda_vector dist_vect = DDR_DIST_VECT (ddr, j);\n+\t  unsigned level = dependence_level (dist_vect, m_loop_nest.length ());\n+\n+\t  /* If there is no carried dependence.  */\n+\t  if (level == 0)\n+\t    continue;\n+\n+\t  level --;\n+\n+\t  /* If dependence is not carried by any loop in between the two\n+\t     loops [oloop, iloop] to interchange.  */\n+\t  if (level < o_idx || level > i_idx)\n+\t    continue;\n+\n+\t  /* Be conservative, skip case if either direction at i_idx/o_idx\n+\t     levels is not '=' or '<'.  */\n+\t  if (dist_vect[i_idx] < 0 || dist_vect[o_idx] < 0)\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Interchange two loops specified by ILOOP and OLOOP.  */\n+\n+void\n+tree_loop_interchange::interchange_loops (loop_cand &iloop, loop_cand &oloop)\n+{\n+  reduction_p re;\n+  gimple_stmt_iterator gsi;\n+  tree i_niters, o_niters, var_after;\n+\n+  /* Undo inner loop's simple reduction.  */\n+  for (unsigned i = 0; iloop.m_reductions.iterate (i, &re); ++i)\n+    if (re->type != DOUBLE_RTYPE)\n+      {\n+\tif (re->producer)\n+\t  reset_debug_uses (re->producer);\n+\n+\tiloop.undo_simple_reduction (re, m_dce_seeds);\n+      }\n+\n+  /* Only need to reset debug uses for double reduction.  */\n+  for (unsigned i = 0; oloop.m_reductions.iterate (i, &re); ++i)\n+    {\n+      gcc_assert (re->type == DOUBLE_RTYPE);\n+      reset_debug_uses (SSA_NAME_DEF_STMT (re->var));\n+      reset_debug_uses (SSA_NAME_DEF_STMT (re->next));\n+    }\n+\n+  /* Prepare niters for both loops.  */\n+  struct loop *loop_nest = m_loop_nest[0];\n+  edge instantiate_below = loop_preheader_edge (loop_nest);\n+  gsi = gsi_last_bb (loop_preheader_edge (loop_nest)->src);\n+  i_niters = number_of_latch_executions (iloop.m_loop);\n+  i_niters = analyze_scalar_evolution (loop_outer (iloop.m_loop), i_niters);\n+  i_niters = instantiate_scev (instantiate_below, loop_outer (iloop.m_loop),\n+\t\t\t       i_niters);\n+  i_niters = force_gimple_operand_gsi (&gsi, unshare_expr (i_niters), true,\n+\t\t\t\t       NULL_TREE, false, GSI_CONTINUE_LINKING);\n+  o_niters = number_of_latch_executions (oloop.m_loop);\n+  if (oloop.m_loop != loop_nest)\n+    {\n+      o_niters = analyze_scalar_evolution (loop_outer (oloop.m_loop), o_niters);\n+      o_niters = instantiate_scev (instantiate_below, loop_outer (oloop.m_loop),\n+\t\t\t\t   o_niters);\n+    }\n+  o_niters = force_gimple_operand_gsi (&gsi, unshare_expr (o_niters), true,\n+\t\t\t\t       NULL_TREE, false, GSI_CONTINUE_LINKING);\n+\n+  /* Move src's code to tgt loop.  This is necessary when src is the outer\n+     loop and tgt is the inner loop.  */\n+  move_code_to_inner_loop (oloop.m_loop, iloop.m_loop, oloop.m_bbs);\n+\n+  /* Map outer loop's IV to inner loop, and vice versa.  */\n+  map_inductions_to_loop (oloop, iloop);\n+  map_inductions_to_loop (iloop, oloop);\n+\n+  /* Create canonical IV for both loops.  Note canonical IV for outer/inner\n+     loop is actually from inner/outer loop.  Also we record the new IV\n+     created for the outer loop so that it can be skipped in later loop\n+     interchange.  */\n+  create_canonical_iv (oloop.m_loop, oloop.m_exit,\n+\t\t       i_niters, &m_niters_iv_var, &var_after);\n+  bitmap_set_bit (m_dce_seeds, SSA_NAME_VERSION (var_after));\n+  create_canonical_iv (iloop.m_loop, iloop.m_exit,\n+\t\t       o_niters, NULL, &var_after);\n+  bitmap_set_bit (m_dce_seeds, SSA_NAME_VERSION (var_after));\n+\n+  /* Scrap niters estimation of interchanged loops.  */\n+  iloop.m_loop->any_upper_bound = false;\n+  iloop.m_loop->any_likely_upper_bound = false;\n+  free_numbers_of_iterations_estimates (iloop.m_loop);\n+  oloop.m_loop->any_upper_bound = false;\n+  oloop.m_loop->any_likely_upper_bound = false;\n+  free_numbers_of_iterations_estimates (oloop.m_loop);\n+\n+  /* ???  The association between the loop data structure and the\n+     CFG changed, so what was loop N at the source level is now\n+     loop M.  We should think of retaining the association or breaking\n+     it fully by creating a new loop instead of re-using the \"wrong\" one.  */\n+}\n+\n+/* Map induction variables of SRC loop to TGT loop.  The function firstly\n+   creates the same IV of SRC loop in TGT loop, then deletes the original\n+   IV and re-initialize it using the newly created IV.  For example, loop\n+   nest:\n+\n+     for (i = 0; i < N; i++)\n+       for (j = 0; j < M; j++)\n+\t {\n+\t   //use of i;\n+\t   //use of j;\n+\t }\n+\n+   will be transformed into:\n+\n+     for (jj = 0; jj < M; jj++)\n+       for (ii = 0; ii < N; ii++)\n+\t {\n+\t   //use of ii;\n+\t   //use of jj;\n+\t }\n+\n+   after loop interchange.  */\n+\n+void\n+tree_loop_interchange::map_inductions_to_loop (loop_cand &src, loop_cand &tgt)\n+{\n+  induction_p iv;\n+  edge e = tgt.m_exit;\n+  gimple_stmt_iterator incr_pos = gsi_last_bb (e->src), gsi;\n+\n+  /* Map source loop's IV to target loop.  */\n+  for (unsigned i = 0; src.m_inductions.iterate (i, &iv); ++i)\n+    {\n+      gimple *use_stmt, *stmt = SSA_NAME_DEF_STMT (iv->var);\n+      gcc_assert (is_a <gphi *> (stmt));\n+\n+      use_operand_p use_p;\n+      /* Only map original IV to target loop.  */\n+      if (m_niters_iv_var != iv->var)\n+\t{\n+\t  /* Map the IV by creating the same one in target loop.  */\n+\t  tree var_before, var_after;\n+\t  tree base = unshare_expr (iv->init_expr);\n+\t  tree step = unshare_expr (iv->step);\n+\t  create_iv (base, step, SSA_NAME_VAR (iv->var),\n+\t\t     tgt.m_loop, &incr_pos, false, &var_before, &var_after);\n+\t  bitmap_set_bit (m_dce_seeds, SSA_NAME_VERSION (var_before));\n+\t  bitmap_set_bit (m_dce_seeds, SSA_NAME_VERSION (var_after));\n+\n+\t  /* Replace uses of the original IV var with newly created IV var.  */\n+\t  imm_use_iterator imm_iter;\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, iv->var)\n+\t    {\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\tSET_USE (use_p, var_before);\n+\n+\t      update_stmt (use_stmt);\n+\t    }\n+\t}\n+\n+      /* Mark all uses for DCE.  */\n+      ssa_op_iter op_iter;\n+      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, op_iter, SSA_OP_USE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (use) == SSA_NAME\n+\t      && ! SSA_NAME_IS_DEFAULT_DEF (use))\n+\t    bitmap_set_bit (m_dce_seeds, SSA_NAME_VERSION (use));\n+\t}\n+\n+      /* Delete definition of the original IV in the source loop.  */\n+      gsi = gsi_for_stmt (stmt);\n+      remove_phi_node (&gsi, true);\n+    }\n+}\n+\n+/* Move stmts of outer loop to inner loop.  */\n+\n+void\n+tree_loop_interchange::move_code_to_inner_loop (struct loop *outer,\n+\t\t\t\t\t\tstruct loop *inner,\n+\t\t\t\t\t\tbasic_block *outer_bbs)\n+{\n+  basic_block oloop_exit_bb = single_exit (outer)->src;\n+  gimple_stmt_iterator gsi, to;\n+\n+  for (unsigned i = 0; i < outer->num_nodes; i++)\n+    {\n+      basic_block bb = outer_bbs[i];\n+\n+      /* Skip basic blocks of inner loop.  */\n+      if (flow_bb_inside_loop_p (inner, bb))\n+\tcontinue;\n+\n+      /* Move code from header/latch to header/latch.  */\n+      if (bb == outer->header)\n+\tto = gsi_after_labels (inner->header);\n+      else if (bb == outer->latch)\n+\tto = gsi_after_labels (inner->latch);\n+      else\n+\t/* Otherwise, simply move to exit->src.  */\n+\tto = gsi_last_bb (single_exit (inner)->src);\n+\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (oloop_exit_bb == bb\n+\t      && stmt == gsi_stmt (gsi_last_bb (oloop_exit_bb)))\n+\t    {\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\n+\t  if (gimple_vuse (stmt))\n+\t    gimple_set_vuse (stmt, NULL_TREE);\n+\t  if (gimple_vdef (stmt))\n+\t    {\n+\t      unlink_stmt_vdef (stmt);\n+\t      release_ssa_name (gimple_vdef (stmt));\n+\t      gimple_set_vdef (stmt, NULL_TREE);\n+\t    }\n+\n+\t  reset_debug_uses (stmt);\n+\t  gsi_move_before (&gsi, &to);\n+\t}\n+    }\n+}\n+\n+/* Given data reference DR in LOOP_NEST, the function computes DR's access\n+   stride at each level of loop from innermost LOOP to outer.  On success,\n+   it saves access stride at each level loop in a vector which is pointed\n+   by DR->aux.  For example:\n+\n+     int arr[100][100][100];\n+     for (i = 0; i < 100; i++)       ;(DR->aux)strides[0] = 40000\n+       for (j = 100; j > 0; j--)     ;(DR->aux)strides[1] = 400\n+\t for (k = 0; k < 100; k++)   ;(DR->aux)strides[2] = 4\n+\t   arr[i][j - 1][k] = 0;  */\n+\n+static void\n+compute_access_stride (struct loop *loop_nest, struct loop *loop,\n+\t\t       data_reference_p dr)\n+{\n+  vec<tree> *strides = new vec<tree> ();\n+  basic_block bb = gimple_bb (DR_STMT (dr));\n+\n+  while (!flow_bb_inside_loop_p (loop, bb))\n+    {\n+      strides->safe_push (build_int_cst (sizetype, 0));\n+      loop = loop_outer (loop);\n+    }\n+  gcc_assert (loop == bb->loop_father);\n+\n+  tree ref = DR_REF (dr);\n+  tree scev_base = build_fold_addr_expr (ref);\n+  tree scev = analyze_scalar_evolution (loop, scev_base);\n+  scev = instantiate_scev (loop_preheader_edge (loop_nest), loop, scev);\n+  if (! chrec_contains_undetermined (scev))\n+    {\n+      tree sl = scev;\n+      struct loop *expected = loop;\n+      while (TREE_CODE (sl) == POLYNOMIAL_CHREC)\n+\t{\n+\t  struct loop *sl_loop = get_chrec_loop (sl);\n+\t  while (sl_loop != expected)\n+\t    {\n+\t      strides->safe_push (size_int (0));\n+\t      expected = loop_outer (expected);\n+\t    }\n+\t  strides->safe_push (CHREC_RIGHT (sl));\n+\t  sl = CHREC_LEFT (sl);\n+\t  expected = loop_outer (expected);\n+\t}\n+      if (! tree_contains_chrecs (sl, NULL))\n+\twhile (expected != loop_outer (loop_nest))\n+\t  {\n+\t    strides->safe_push (size_int (0));\n+\t    expected = loop_outer (expected);\n+\t  }\n+    }\n+\n+  dr->aux = strides;\n+}\n+\n+/* Given loop nest LOOP_NEST with innermost LOOP, the function computes\n+   access strides with respect to each level loop for all data refs in\n+   DATAREFS from inner loop to outer loop.  On success, it returns the\n+   outermost loop that access strides can be computed successfully for\n+   all data references.  If access strides cannot be computed at least\n+   for two levels of loop for any data reference, it returns NULL.  */\n+\n+static struct loop *\n+compute_access_strides (struct loop *loop_nest, struct loop *loop,\n+\t\t\tvec<data_reference_p> datarefs)\n+{\n+  unsigned i, j, num_loops = (unsigned) -1;\n+  data_reference_p dr;\n+  vec<tree> *stride;\n+\n+  for (i = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      compute_access_stride (loop_nest, loop, dr);\n+      stride = DR_ACCESS_STRIDE (dr);\n+      if (stride->length () < num_loops)\n+\t{\n+\t  num_loops = stride->length ();\n+\t  if (num_loops < 2)\n+\t    return NULL;\n+\t}\n+    }\n+\n+  for (i = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      stride = DR_ACCESS_STRIDE (dr);\n+      if (stride->length () > num_loops)\n+\tstride->truncate (num_loops);\n+\n+      for (j = 0; j < (num_loops >> 1); ++j)\n+\tstd::swap ((*stride)[j], (*stride)[num_loops - j - 1]);\n+    }\n+\n+  loop = superloop_at_depth (loop, loop_depth (loop) + 1 - num_loops);\n+  gcc_assert (loop_nest == loop || flow_loop_nested_p (loop_nest, loop));\n+  return loop;\n+}\n+\n+/* Prune access strides for data references in DATAREFS by removing strides\n+   of loops that isn't in current LOOP_NEST.  */\n+\n+static void\n+prune_access_strides_not_in_loop (struct loop *loop_nest,\n+\t\t\t\t  struct loop *innermost,\n+\t\t\t\t  vec<data_reference_p> datarefs)\n+{\n+  data_reference_p dr;\n+  unsigned num_loops = loop_depth (innermost) - loop_depth (loop_nest) + 1;\n+  gcc_assert (num_loops > 1);\n+\n+  /* Block remove strides of loops that is not in current loop nest.  */\n+  for (unsigned i = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      vec<tree> *stride = DR_ACCESS_STRIDE (dr);\n+      if (stride->length () > num_loops)\n+\tstride->block_remove (0, stride->length () - num_loops);\n+    }\n+}\n+\n+/* Dump access strides for all DATAREFS.  */\n+\n+static void\n+dump_access_strides (vec<data_reference_p> datarefs)\n+{\n+  data_reference_p dr;\n+  fprintf (dump_file, \"Access Strides for DRs:\\n\");\n+  for (unsigned i = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      fprintf (dump_file, \"  \");\n+      print_generic_expr (dump_file, DR_REF (dr), TDF_SLIM);\n+      fprintf (dump_file, \":\\t\\t<\");\n+\n+      vec<tree> *stride = DR_ACCESS_STRIDE (dr);\n+      unsigned num_loops = stride->length ();\n+      for (unsigned j = 0; j < num_loops; ++j)\n+\t{\n+\t  print_generic_expr (dump_file, (*stride)[j], TDF_SLIM);\n+\t  fprintf (dump_file, \"%s\", (j < num_loops - 1) ? \",\\t\" : \">\\n\");\n+\t}\n+    }\n+}\n+\n+/* Return true if it's profitable to interchange two loops whose index\n+   in whole loop nest vector are I_IDX/O_IDX respectively.  The function\n+   computes and compares three types information from all DATAREFS:\n+     1) Access stride for loop I_IDX and O_IDX.\n+     2) Number of invariant memory references with respect to I_IDX before\n+\tand after loop interchange.\n+     3) Flags indicating if all memory references access sequential memory\n+\tin ILOOP, before and after loop interchange.\n+   If INNMOST_LOOP_P is true, the two loops for interchanging are the two\n+   innermost loops in loop nest.  This function also dumps information if\n+   DUMP_INFO_P is true.  */\n+\n+static bool\n+should_interchange_loops (unsigned i_idx, unsigned o_idx,\n+\t\t\t  vec<data_reference_p> datarefs,\n+\t\t\t  bool innermost_loops_p, bool dump_info_p = true)\n+{\n+  unsigned HOST_WIDE_INT ratio;\n+  unsigned i, j, num_old_inv_drs = 0, num_new_inv_drs = 0;\n+  struct data_reference *dr;\n+  bool all_seq_dr_before_p = true, all_seq_dr_after_p = true;\n+  widest_int iloop_strides = 0, oloop_strides = 0;\n+  unsigned num_unresolved_drs = 0;\n+  unsigned num_resolved_ok_drs = 0;\n+  unsigned num_resolved_not_ok_drs = 0;\n+\n+  if (dump_info_p && dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nData ref strides:\\n\\tmem_ref:\\t\\tiloop\\toloop\\n\");\n+\n+  for (i = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      vec<tree> *stride = DR_ACCESS_STRIDE (dr);\n+      tree iloop_stride = (*stride)[i_idx], oloop_stride = (*stride)[o_idx];\n+\n+      bool subloop_stride_p = false;\n+      /* Data ref can't be invariant or sequential access at current loop if\n+\t its address changes with respect to any subloops.  */\n+      for (j = i_idx + 1; j < stride->length (); ++j)\n+\tif (!integer_zerop ((*stride)[j]))\n+\t  {\n+\t    subloop_stride_p = true;\n+\t    break;\n+\t  }\n+\n+      if (integer_zerop (iloop_stride))\n+\t{\n+\t  if (!subloop_stride_p)\n+\t    num_old_inv_drs++;\n+\t}\n+      if (integer_zerop (oloop_stride))\n+\t{\n+\t  if (!subloop_stride_p)\n+\t    num_new_inv_drs++;\n+\t}\n+\n+      if (TREE_CODE (iloop_stride) == INTEGER_CST\n+\t  && TREE_CODE (oloop_stride) == INTEGER_CST)\n+\t{\n+\t  iloop_strides = wi::add (iloop_strides, wi::to_widest (iloop_stride));\n+\t  oloop_strides = wi::add (oloop_strides, wi::to_widest (oloop_stride));\n+\t}\n+      else if (multiple_of_p (TREE_TYPE (iloop_stride),\n+\t\t\t      iloop_stride, oloop_stride))\n+\tnum_resolved_ok_drs++;\n+      else if (multiple_of_p (TREE_TYPE (iloop_stride),\n+\t\t\t      oloop_stride, iloop_stride))\n+\tnum_resolved_not_ok_drs++;\n+      else\n+\tnum_unresolved_drs++;\n+\n+      /* Data ref can't be sequential access if its address changes in sub\n+\t loop.  */\n+      if (subloop_stride_p)\n+\t{\n+\t  all_seq_dr_before_p = false;\n+\t  all_seq_dr_after_p = false;\n+\t  continue;\n+\t}\n+      /* Track if all data references are sequential accesses before/after loop\n+\t interchange.  Note invariant is considered sequential here.  */\n+      tree access_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n+      if (all_seq_dr_before_p\n+\t  && ! (integer_zerop (iloop_stride)\n+\t\t|| operand_equal_p (access_size, iloop_stride, 0)))\n+\tall_seq_dr_before_p = false;\n+      if (all_seq_dr_after_p\n+\t  && ! (integer_zerop (oloop_stride)\n+\t\t|| operand_equal_p (access_size, oloop_stride, 0)))\n+\tall_seq_dr_after_p = false;\n+    }\n+\n+  if (dump_info_p && dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\toverall:\\t\\t\");\n+      print_decu (iloop_strides, dump_file);\n+      fprintf (dump_file, \"\\t\");\n+      print_decu (oloop_strides, dump_file);\n+      fprintf (dump_file, \"\\n\");\n+\n+      fprintf (dump_file, \"Invariant data ref: before(%d), after(%d)\\n\",\n+\t       num_old_inv_drs, num_new_inv_drs);\n+      fprintf (dump_file, \"All consecutive stride: before(%s), after(%s)\\n\",\n+\t       all_seq_dr_before_p ? \"true\" : \"false\",\n+\t       all_seq_dr_after_p ? \"true\" : \"false\");\n+      fprintf (dump_file, \"OK to interchage with variable strides: %d\\n\",\n+\t       num_resolved_ok_drs);\n+      fprintf (dump_file, \"Not OK to interchage with variable strides: %d\\n\",\n+\t       num_resolved_not_ok_drs);\n+      fprintf (dump_file, \"Variable strides we cannot decide: %d\\n\",\n+\t       num_unresolved_drs);\n+    }\n+\n+  if (num_unresolved_drs != 0 || num_resolved_not_ok_drs != 0)\n+    return false;\n+\n+  /* We use different stride comparison ratio for interchanging innermost\n+     two loops or not.  The idea is to be conservative in interchange for\n+     the innermost loops.  */\n+  ratio = innermost_loops_p ? INNER_STRIDE_RATIO : OUTER_STRIDE_RATIO;\n+  /* Do interchange if it gives better data locality behavior.  */\n+  if (wi::gtu_p (iloop_strides, wi::mul (oloop_strides, ratio)))\n+    return true;\n+  if (wi::gtu_p (iloop_strides, oloop_strides))\n+    {\n+      /* Or it creates more invariant memory references.  */\n+      if ((!all_seq_dr_before_p || all_seq_dr_after_p)\n+\t  && num_new_inv_drs > num_old_inv_drs)\n+\treturn true;\n+      /* Or it makes all memory references sequential.  */\n+      if (num_new_inv_drs >= num_old_inv_drs\n+\t  && !all_seq_dr_before_p && all_seq_dr_after_p)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Try to interchange inner loop of a loop nest to outer level.  */\n+\n+bool\n+tree_loop_interchange::interchange (vec<data_reference_p> datarefs,\n+\t\t\t\t    vec<ddr_p> ddrs)\n+{\n+  bool changed_p = false;\n+  /* In each iteration we try to interchange I-th loop with (I+1)-th loop.\n+     The overall effect is to push inner loop to outermost level in whole\n+     loop nest.  */\n+  for (unsigned i = m_loop_nest.length (); i > 1; --i)\n+    {\n+      unsigned i_idx = i - 1, o_idx = i - 2;\n+\n+      /* Check validity for loop interchange.  */\n+      if (!valid_data_dependences (i_idx, o_idx, ddrs))\n+\tbreak;\n+\n+      loop_cand iloop (m_loop_nest[i_idx], m_loop_nest[o_idx]);\n+      loop_cand oloop (m_loop_nest[o_idx], m_loop_nest[o_idx]);\n+\n+      /* Check if we can do transformation for loop interchange.  */\n+      if (!iloop.analyze_carried_vars (NULL)\n+\t  || !iloop.analyze_lcssa_phis ()\n+\t  || !oloop.analyze_carried_vars (&iloop)\n+\t  || !oloop.analyze_lcssa_phis ()\n+\t  || !iloop.can_interchange_p (NULL)\n+\t  || !oloop.can_interchange_p (&iloop))\n+\tbreak;\n+\n+      /* Check profitability for loop interchange.  */\n+      if (should_interchange_loops (i_idx, o_idx, datarefs,\n+\t\t\t\t    iloop.m_loop->inner == NULL))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Loop_pair<outer:%d, inner:%d> is interchanged\\n\\n\",\n+\t\t     oloop.m_loop->num, iloop.m_loop->num);\n+\n+\t  changed_p = true;\n+\t  interchange_loops (iloop, oloop);\n+\t  /* No need to update if there is no further loop interchange.  */\n+\t  if (o_idx > 0)\n+\t    update_data_info (i_idx, o_idx, datarefs, ddrs);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Loop_pair<outer:%d, inner:%d> is not interchanged\\n\\n\",\n+\t\t     oloop.m_loop->num, iloop.m_loop->num);\n+\t}\n+    }\n+\n+  simple_dce_from_worklist (m_dce_seeds);\n+  return changed_p;\n+}\n+\n+\n+/* Loop interchange pass.  */\n+\n+namespace {\n+\n+const pass_data pass_data_linterchange =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"linterchange\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  TV_LINTERCHANGE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_linterchange : public gimple_opt_pass\n+{\n+public:\n+  pass_linterchange (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_linterchange, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_linterchange (m_ctxt); }\n+  virtual bool gate (function *) { return flag_loop_interchange; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_linterchange\n+\n+\n+/* Return true if LOOP has proper form for interchange.  We check three\n+   conditions in the function:\n+     1) In general, a loop can be interchanged only if it doesn't have\n+\tbasic blocks other than header, exit and latch besides possible\n+\tinner loop nest.  This basically restricts loop interchange to\n+\tbelow form loop nests:\n+\n+          header<---+\n+            |       |\n+            v       |\n+        INNER_LOOP  |\n+            |       |\n+            v       |\n+          exit--->latch\n+\n+     2) Data reference in basic block that executes in different times\n+\tthan loop head/exit is not allowed.\n+     3) Record the innermost outer loop that doesn't form rectangle loop\n+\tnest with LOOP.  */\n+\n+static bool\n+proper_loop_form_for_interchange (struct loop *loop, struct loop **min_outer)\n+{\n+  edge e0, e1, exit;\n+\n+  /* Don't interchange if loop has unsupported information for the moment.  */\n+  if (loop->safelen > 0\n+      || loop->constraints != 0\n+      || loop->can_be_parallel\n+      || loop->dont_vectorize\n+      || loop->force_vectorize\n+      || loop->in_oacc_kernels_region\n+      || loop->orig_loop_num != 0\n+      || loop->simduid != NULL_TREE)\n+    return false;\n+\n+  /* Don't interchange if outer loop has basic block other than header, exit\n+     and latch.  */\n+  if (loop->inner != NULL\n+      && loop->num_nodes != loop->inner->num_nodes + 3)\n+    return false;\n+\n+  if ((exit = single_dom_exit (loop)) == NULL)\n+    return false;\n+\n+  /* Check control flow on loop header/exit blocks.  */\n+  if (loop->header == exit->src\n+      && (EDGE_COUNT (loop->header->preds) != 2\n+\t  || EDGE_COUNT (loop->header->succs) != 2))\n+    return false;\n+  else if (loop->header != exit->src\n+\t   && (EDGE_COUNT (loop->header->preds) != 2\n+\t       || !single_succ_p (loop->header)\n+\t       || unsupported_edge (single_succ_edge (loop->header))\n+\t       || EDGE_COUNT (exit->src->succs) != 2\n+\t       || !single_pred_p (exit->src)\n+\t       || unsupported_edge (single_pred_edge (exit->src))))\n+    return false;\n+\n+  e0 = EDGE_PRED (loop->header, 0);\n+  e1 = EDGE_PRED (loop->header, 1);\n+  if (unsupported_edge (e0) || unsupported_edge (e1)\n+      || (e0->src != loop->latch && e1->src != loop->latch)\n+      || (e0->src->loop_father == loop && e1->src->loop_father == loop))\n+    return false;\n+\n+  e0 = EDGE_SUCC (exit->src, 0);\n+  e1 = EDGE_SUCC (exit->src, 1);\n+  if (unsupported_edge (e0) || unsupported_edge (e1)\n+      || (e0->dest != loop->latch && e1->dest != loop->latch)\n+      || (e0->dest->loop_father == loop && e1->dest->loop_father == loop))\n+    return false;\n+\n+  /* Don't interchange if any reference is in basic block that doesn't\n+     dominate exit block.  */\n+  basic_block *bbs = get_loop_body (loop);\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      if (bb->loop_father != loop\n+\t  || bb == loop->header || bb == exit->src\n+\t  || dominated_by_p (CDI_DOMINATORS, exit->src, bb))\n+\tcontinue;\n+\n+      for (gimple_stmt_iterator gsi = gsi_start_bb_nondebug (bb);\n+\t   !gsi_end_p (gsi); gsi_next_nondebug (&gsi))\n+\tif (gimple_vuse (gsi_stmt (gsi)))\n+\t  {\n+\t    free (bbs);\n+\t    return false;\n+\t  }\n+    }\n+  free (bbs);\n+\n+  tree niters = number_of_latch_executions (loop);\n+  niters = analyze_scalar_evolution (loop_outer (loop), niters);\n+  if (!niters || chrec_contains_undetermined (niters))\n+    return false;\n+\n+  /* Record the innermost outer loop that doesn't form rectangle loop nest.  */\n+  for (loop_p loop2 = loop_outer (loop);\n+       loop2 && flow_loop_nested_p (*min_outer, loop2);\n+       loop2 = loop_outer (loop2))\n+    {\n+      niters = instantiate_scev (loop_preheader_edge (loop2),\n+\t\t\t\t loop_outer (loop), niters);\n+      if (!evolution_function_is_invariant_p (niters, loop2->num))\n+\t{\n+\t  *min_outer = loop2;\n+\t  break;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Return true if any two adjacent loops in loop nest [INNERMOST, LOOP_NEST]\n+   should be interchanged by looking into all DATAREFS.  */\n+\n+static bool\n+should_interchange_loop_nest (struct loop *loop_nest, struct loop *innermost,\n+\t\t\t      vec<data_reference_p> datarefs)\n+{\n+  unsigned idx = loop_depth (innermost) - loop_depth (loop_nest);\n+  gcc_assert (idx > 0);\n+\n+  /* Check if any two adjacent loops should be interchanged.  */\n+  for (struct loop *loop = innermost;\n+       loop != loop_nest; loop = loop_outer (loop), idx--)\n+    if (should_interchange_loops (idx, idx - 1, datarefs,\n+\t\t\t\t  loop == innermost, false))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Given loop nest LOOP_NEST and data references DATAREFS, compute data\n+   dependences for loop interchange and store it in DDRS.  Note we compute\n+   dependences directly rather than call generic interface so that we can\n+   return on unknown dependence instantly.  */\n+\n+static bool\n+tree_loop_interchange_compute_ddrs (vec<loop_p> loop_nest,\n+\t\t\t\t    vec<data_reference_p> datarefs,\n+\t\t\t\t    vec<ddr_p> *ddrs)\n+{\n+  struct data_reference *a, *b;\n+  struct loop *innermost = loop_nest.last ();\n+\n+  for (unsigned i = 0; datarefs.iterate (i, &a); ++i)\n+    {\n+      bool a_outer_p = gimple_bb (DR_STMT (a))->loop_father != innermost;\n+      for (unsigned j = i + 1; datarefs.iterate (j, &b); ++j)\n+\tif (DR_IS_WRITE (a) || DR_IS_WRITE (b))\n+\t  {\n+\t    bool b_outer_p = gimple_bb (DR_STMT (b))->loop_father != innermost;\n+\t    /* Don't support multiple write references in outer loop.  */\n+\t    if (a_outer_p && b_outer_p && DR_IS_WRITE (a) && DR_IS_WRITE (b))\n+\t      return false;\n+\n+\t    ddr_p ddr = initialize_data_dependence_relation (a, b, loop_nest);\n+\t    ddrs->safe_push (ddr);\n+\t    compute_affine_dependence (ddr, loop_nest[0]);\n+\n+\t    /* Give up if ddr is unknown dependence or classic direct vector\n+\t       is not available.  */\n+\t    if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n+\t\t|| (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n+\t\t    && DDR_NUM_DIR_VECTS (ddr) == 0))\n+\t      return false;\n+\n+\t    /* If either data references is in outer loop of nest, we require\n+\t       no dependence here because the data reference need to be moved\n+\t       into inner loop during interchange.  */\n+\t    if (a_outer_p && b_outer_p\n+\t\t&& operand_equal_p (DR_REF (a), DR_REF (b), 0))\n+\t      continue;\n+\t    if (DDR_ARE_DEPENDENT (ddr) != chrec_known\n+\t\t&& (a_outer_p || b_outer_p))\n+\t      return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Prune DATAREFS by removing any data reference not inside of LOOP.  */\n+\n+static inline void\n+prune_datarefs_not_in_loop (struct loop *loop, vec<data_reference_p> datarefs)\n+{\n+  unsigned i, j;\n+  struct data_reference *dr;\n+\n+  for (i = 0, j = 0; datarefs.iterate (i, &dr); ++i)\n+    {\n+      if (flow_bb_inside_loop_p (loop, gimple_bb (DR_STMT (dr))))\n+\tdatarefs[j++] = dr;\n+      else\n+\t{\n+\t  if (dr->aux)\n+\t    {\n+\t      DR_ACCESS_STRIDE (dr)->release ();\n+\t      free (dr->aux);\n+\t    }\n+\t  free_data_ref (dr);\n+\t}\n+    }\n+  datarefs.truncate (j);\n+}\n+\n+/* Find and store data references in DATAREFS for LOOP nest.  If there's\n+   difficult data reference in a basic block, we shrink the loop nest to\n+   inner loop of that basic block's father loop.  On success, return the\n+   outer loop of the result loop nest.  */\n+\n+static struct loop *\n+prepare_data_references (struct loop *loop, vec<data_reference_p> *datarefs)\n+{\n+  struct loop *loop_nest = loop;\n+  vec<data_reference_p> *bb_refs;\n+  basic_block bb, *bbs = get_loop_body_in_dom_order (loop);\n+\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    bbs[i]->aux = NULL;\n+\n+  /* Find data references for all basic blocks.  Shrink loop nest on difficult\n+     data reference.  */\n+  for (unsigned i = 0; loop_nest && i < loop->num_nodes; ++i)\n+    {\n+      bb = bbs[i];\n+      if (!flow_bb_inside_loop_p (loop_nest, bb))\n+\tcontinue;\n+\n+      bb_refs = new vec<data_reference_p> ();\n+      if (find_data_references_in_bb (loop, bb, bb_refs) == chrec_dont_know)\n+        {\n+\t  loop_nest = bb->loop_father->inner;\n+\t  if (loop_nest && !loop_nest->inner)\n+\t    loop_nest = NULL;\n+\n+\t  free_data_refs (*bb_refs);\n+          delete bb_refs;\n+        }\n+      else if (bb_refs->is_empty ())\n+\tdelete bb_refs;\n+      else\n+\tbb->aux = bb_refs;\n+    }\n+\n+  /* Collect all data references in loop nest.  */\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = bbs[i];\n+      if (!bb->aux)\n+\tcontinue;\n+\n+      bb_refs = (vec<data_reference_p> *) bb->aux;\n+      if (loop_nest && flow_bb_inside_loop_p (loop_nest, bb))\n+\tdatarefs->safe_splice (*bb_refs);\n+      else\n+\tfree_data_refs (*bb_refs);\n+\n+      delete bb_refs;\n+      bb->aux = NULL;\n+    }\n+  free (bbs);\n+\n+  return loop_nest;\n+}\n+\n+/* Given innermost LOOP, return true if perfect loop nest can be found and\n+   data dependences can be computed.  If succeed, record the perfect loop\n+   nest in LOOP_NEST; record all data references in DATAREFS and record all\n+   data dependence relations in DDRS.\n+\n+   We do support a restricted form of imperfect loop nest, i.e, loop nest\n+   with load/store in outer loop initializing/finalizing simple reduction\n+   of the innermost loop.  For such outer loop reference, we require that\n+   it has no dependence with others sinve it will be moved to inner loop\n+   in interchange.  */\n+\n+static bool\n+prepare_perfect_loop_nest (struct loop *loop, vec<loop_p> *loop_nest,\n+\t\t\t   vec<data_reference_p> *datarefs, vec<ddr_p> *ddrs)\n+{\n+  struct loop *start_loop = NULL, *innermost = loop;\n+  struct loop *outermost = loops_for_fn (cfun)->tree_root;\n+\n+  /* Find loop nest from the innermost loop.  The outermost is the innermost\n+     outer*/\n+  while (loop->num != 0 && loop->inner == start_loop\n+\t && flow_loop_nested_p (outermost, loop))\n+    {\n+      if (!proper_loop_form_for_interchange (loop, &outermost))\n+\tbreak;\n+\n+      start_loop = loop;\n+      /* If this loop has sibling loop, the father loop won't be in perfect\n+\t loop nest.  */\n+      if (loop->next != NULL)\n+\tbreak;\n+\n+      loop = loop_outer (loop);\n+    }\n+  if (!start_loop || !start_loop->inner)\n+    return false;\n+\n+  /* Prepare the data reference vector for the loop nest, pruning outer\n+     loops we cannot handle.  */\n+  start_loop = prepare_data_references (start_loop, datarefs);\n+  if (!start_loop\n+      /* Check if there is no data reference.  */\n+      || datarefs->is_empty ()\n+      /* Check if there are too many of data references.  */\n+      || (int) datarefs->length () > MAX_DATAREFS)\n+    return false;\n+\n+  /* Compute access strides for all data references, pruning outer\n+     loops we cannot analyze refs in.  */\n+  start_loop = compute_access_strides (start_loop, innermost, *datarefs);\n+  if (!start_loop)\n+    return false;\n+\n+  /* Check if any interchange is profitable in the loop nest.  */\n+  if (!should_interchange_loop_nest (start_loop, innermost, *datarefs))\n+    return false;\n+\n+  /* Check if data dependences can be computed for loop nest starting from\n+     start_loop.  */\n+  loop = start_loop;\n+  do {\n+    loop_nest->truncate (0);\n+\n+    if (loop != start_loop)\n+      prune_datarefs_not_in_loop (start_loop, *datarefs);\n+\n+    if (find_loop_nest (start_loop, loop_nest)\n+\t&& tree_loop_interchange_compute_ddrs (*loop_nest, *datarefs, ddrs))\n+      {\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file,\n+\t\t   \"\\nConsider loop interchange for loop_nest<%d - %d>\\n\",\n+\t\t   start_loop->num, innermost->num);\n+\n+\tif (loop != start_loop)\n+\t  prune_access_strides_not_in_loop (start_loop, innermost, *datarefs);\n+\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  dump_access_strides (*datarefs);\n+\n+\treturn true;\n+      }\n+\n+    free_dependence_relations (*ddrs);\n+    *ddrs = vNULL;\n+    /* Try to compute data dependences with the outermost loop stripped.  */\n+    loop = start_loop;\n+    start_loop = start_loop->inner;\n+  } while (start_loop && start_loop->inner);\n+\n+  return false;\n+}\n+\n+/* Main entry for loop interchange pass.  */\n+\n+unsigned int\n+pass_linterchange::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 2)\n+    return 0;\n+\n+  bool changed_p = false;\n+  struct loop *loop;\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n+    {\n+      vec<loop_p> loop_nest = vNULL;\n+      vec<data_reference_p> datarefs = vNULL;\n+      vec<ddr_p> ddrs = vNULL;\n+      if (prepare_perfect_loop_nest (loop, &loop_nest, &datarefs, &ddrs))\n+\t{\n+\t  tree_loop_interchange loop_interchange (loop_nest);\n+\t  changed_p |= loop_interchange.interchange (datarefs, ddrs);\n+\t}\n+      free_dependence_relations (ddrs);\n+      free_data_refs_with_aux (datarefs);\n+      loop_nest.release ();\n+    }\n+\n+  if (changed_p)\n+    scev_reset_htab ();\n+\n+  return changed_p ? (TODO_update_ssa_only_virtuals) : 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_linterchange (gcc::context *ctxt)\n+{\n+  return new pass_linterchange (ctxt);\n+}"}, {"sha": "98fbf537caaad49dabe182668f0b9f9d23a7e6d0", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -527,6 +527,7 @@ static const struct default_options default_options_table[] =\n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribution, NULL, 1 },\n+    { OPT_LEVELS_3_PLUS, OPT_floop_interchange, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_fpredictive_commoning, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_fsplit_paths, NULL, 1 },\n     /* Inlining of functions reducing size is a good idea with -Os"}, {"sha": "923ebc8e66c0c3ad0d654b2f0f38d647eac97c96", "filename": "gcc/params.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -790,6 +790,20 @@ DEFPARAM (PARAM_L2_CACHE_SIZE,\n \t  \"The size of L2 cache.\",\n \t  512, 0, 0)\n \n+/* Maximum number of statements in loop nest for loop interchange.  */\n+\n+DEFPARAM (PARAM_LOOP_INTERCHANGE_MAX_NUM_STMTS,\n+\t  \"loop-interchange-max-num-stmts\",\n+\t  \"The maximum number of stmts in loop nest for loop interchange.\",\n+\t  64, 0, 0)\n+\n+/* Minimum stride ratio for loop interchange to be profitiable.  */\n+\n+DEFPARAM (PARAM_LOOP_INTERCHANGE_STRIDE_RATIO,\n+\t  \"loop-interchange-stride-ratio\",\n+\t  \"The minimum stride ratio for loop interchange to be profitable\",\n+\t  2, 0, 0)\n+\n /* Whether we should use canonical types rather than deep \"structural\"\n    type checking.  Setting this value to 1 (the default) improves\n    compilation performance in the C++ and Objective-C++ front end;"}, {"sha": "06dcd1989105a8aeecadf233f756ef62a2bc209c", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -279,6 +279,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_cd_dce);\n \t  NEXT_PASS (pass_iv_canon);\n \t  NEXT_PASS (pass_loop_distribution);\n+\t  NEXT_PASS (pass_linterchange);\n \t  NEXT_PASS (pass_copy_prop);\n \t  NEXT_PASS (pass_graphite);\n \t  PUSH_INSERT_PASSES_WITHIN (pass_graphite)"}, {"sha": "fd46db71d2b52cc4f0817dd448ad021fe403e00e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -1,3 +1,22 @@\n+2017-12-07  Bin Cheng  <bin.cheng@arm.com>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/81303\n+\t* gcc.dg/tree-ssa/loop-interchange-1.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-1b.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-2.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-3.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-4.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-5.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-6.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-7.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-8.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-9.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-10.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-11.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-12.c: New test.\n+\t* gcc.dg/tree-ssa/loop-interchange-13.c: New test.\n+\n 2017-12-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/83164"}, {"sha": "8bd3ba78e73f61c3fbb4802c144fdc62e37f9bd9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-1.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fassociative-math -fno-signed-zeros -fno-trapping-math -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-4.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+double u[1782225];\n+\n+static int __attribute__((noinline))\n+foo (int N, int *res)\n+{\n+  int i, j;\n+  double sum = 0;\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      sum = sum + u[i + 1335 * j];\n+\n+  for (i = 0; i < N; i++)\n+    u[1336 * i] *= 2;\n+\n+  *res = sum + N + u[1336 * 2] + u[1336];\n+}\n+\n+extern void abort ();\n+\n+int\n+main (void)\n+{\n+  int i, j, res;\n+\n+  for (i = 0; i < 1782225; i++)\n+    u[i] = 2;\n+\n+  foo (1335, &res);\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 3565793)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\"} } */"}, {"sha": "b9c9fac0c01eaab39fa36482e2d27195867924a8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-10.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-10.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M];\n+int __attribute__((noinline))\n+double_reduc (int n)\n+{\n+  int sum = 0;\n+  for (int j = 0; j < n; j++)\n+    {\n+      for (int i = 0; i < n; i++)\n+\tsum = sum + a[i][j]*b[i][j];\n+    }\n+  return sum;\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    {\n+      a[i][j] = i;\n+      b[i][j] = j;\n+    }\n+}\n+\n+int main (void)\n+{\n+  for (int i = 0; i < M; ++i)\n+    init (i);\n+\n+  int sum = double_reduc (M);\n+\n+  if (sum != 1065369600)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\" } } */"}, {"sha": "becec948c301e7398b15b5b82da8b56b0a9a5c58", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-11.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-11.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M];\n+\n+void\n+simple_reduc_1 (int n, int *p)\n+{\n+  for (int j = 0; j < n; j++)\n+    {\n+      int sum = p[j];\n+      for (int i = 0; i < n; i++)\n+\t{\n+\t  sum = sum + b[i][j];\n+\t  b[i][j] += a[i][j];\n+\t}\n+\n+      p[j] = sum;\n+    }\n+}\n+/* { dg-final { scan-tree-dump-not \"Loop_pair<outer:., inner:.> is interchanged\" \"linterchange\" } } */"}, {"sha": "affb3680ea09a0f25bad9f765035969425b76866", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-12.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-12.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-4.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+unsigned u[1024];\n+\n+static void __attribute__((noinline,noclone,noipa))\n+foo (int N, unsigned *res)\n+{\n+  int i, j;\n+  unsigned sum = 1;\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      sum = u[i + 2 * j] / sum;\n+\n+  *res = sum;\n+}\n+\n+extern void abort ();\n+\n+int\n+main (void)\n+{\n+  int i, j;\n+  unsigned res;\n+\n+  u[0] = 10;\n+  u[1] = 200;\n+  u[2] = 10;\n+  u[3] = 10;\n+\n+  foo (2, &res);\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"is interchanged\" \"linterchange\"} } */"}, {"sha": "38b71e005998d80efd8ee078c8f7a7934d13007d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-13.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-13.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-4.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+unsigned u[1024];\n+\n+static void __attribute__((noinline,noclone,noipa))\n+foo (int N, int M, unsigned *res)\n+{\n+  int i, j;\n+  unsigned sum = 0;\n+  if (N > 0)\n+    for (i = 0; i < M; i++)\n+      for (j = 0; j < N; j++)\n+\tsum = u[i + 3 * j] - sum;\n+\n+  *res = sum;\n+}\n+\n+extern void abort ();\n+\n+int\n+main (void)\n+{\n+  int i, j;\n+  unsigned res;\n+\n+  u[0] = 1;\n+  u[1] = 2;\n+  u[2] = 4;\n+  u[3] = 5;\n+  u[4] = 7;\n+  u[5] = 8;\n+\n+  foo (2, 3, &res);\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 13)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"is interchanged\" \"linterchange\"} } */"}, {"sha": "f5f765bb902231f17ba1a3edbe5b651c98885ef9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-1b.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-1b.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-4.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+double u[1782225];\n+\n+static void __attribute__((noinline))\n+foo (int N, double *res)\n+{\n+  int i, j;\n+  double sum = 0;\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      sum = sum + u[i + 1335 * j];\n+\n+  *res = sum;\n+}\n+\n+extern void abort ();\n+\n+int\n+main (void)\n+{\n+  int i, j;\n+  double res;\n+\n+  for (i = 0; i < 1782225; i++)\n+    u[i] = 0;\n+  u[0] = __DBL_MAX__;\n+  u[1335] = -__DBL_MAX__;\n+  u[1] = __DBL_MAX__;\n+  u[1336] = -__DBL_MAX__;\n+\n+  foo (1335, &res);\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 0.0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"is interchanged\" \"linterchange\"} } */"}, {"sha": "25745275a4ef6629b4fe704a3192ea349304dc74", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-2.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-5.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#define N 100\n+#define M 1111\n+int A[N][M];\n+\n+static int __attribute__((noinline))\n+foo (void)\n+{\n+  int i, j;\n+\n+  for( i = 0; i < M; i++)\n+    for( j = 0; j < N; j++)\n+      A[j][i] = 5 * A[j][i];\n+\n+  return A[0][0] + A[N-1][M-1];\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  int j;\n+\n+  for (j = 0; j < M; j++)\n+    A[i][j] = 2;\n+}\n+\n+int\n+main (void)\n+{\n+  int i, j, res;\n+\n+  for (i = 0; i < N; i++)\n+    init (i);\n+\n+  res = foo ();\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 20)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\"} } */"}, {"sha": "98d3d2f183bbe3c862ccee3d4eb305969aafa678", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-3.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-3.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-6.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#define N 100\n+#define M 200\n+\n+static int __attribute__((noinline))\n+foo (int A[N][M])\n+{\n+  int i, j;\n+\n+  /* This loop should be interchanged. */\n+  for(j = 0; j < M; j++)\n+    for(i = 0; i < N; i++)\n+      A[i][j] = A[i][j] + A[i][j];\n+\n+  return A[0][0] + A[N-1][M-1];\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int *arr, int i)\n+{\n+  int j;\n+\n+  for (j = 0; j < M; j++)\n+    arr[j] = 2;\n+}\n+\n+int\n+main (void)\n+{\n+  int A[N][M];\n+  int i, j, res;\n+\n+  for (i = 0; i < N; i++)\n+    init (A[i], i);\n+\n+  res = foo (A);\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 8)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\"} } */"}, {"sha": "a919a6c38bf773381eb2f3982cf504c5d1041bbf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-4.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-4.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+/* Copied from graphite/interchange-7.c */\n+\n+#define DEBUG 0\n+#if DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#define N 111\n+#define M 1111\n+\n+static int __attribute__((noinline))\n+foo (double *a)\n+{\n+  int i,j;\n+  int r = 0;\n+\n+  for (i = 0; i < N; ++i)\n+    for (j = 0; j < M; ++j)\n+      r += a[j * N + i];\n+\n+  return r;\n+}\n+\n+extern void abort ();\n+\n+int\n+main (void)\n+{\n+  double A[N*M];\n+  int i, res;\n+\n+  for (i = 0; i < N*M; i++)\n+    A[i] = 2;\n+\n+  res = foo (A);\n+\n+#if DEBUG\n+  fprintf (stderr, \"res = %d \\n\", res);\n+#endif\n+\n+  if (res != 246642)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\" { xfail *-*-* } } } */"}, {"sha": "9d0d13964a1088bd7138bc460ab6b446061e7953", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-5.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-5.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M], c[M][M], d[M][M];\n+void __attribute__((noinline))\n+matrix_mul_1 (int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    for (int j = 0; j < n; j++)\n+      for (int k = 0; k < n; k++)\n+        c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+}\n+\n+void __attribute__((noinline))\n+matrix_mul_2 (int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      for (int j = 0; j < n; j++)\n+\t{\n+\t  for (int k = 0; k < n; k++)\n+\t    d[i][j] = d[i][j] + a[i][k]*b[k][j];\n+\n+\t  asm volatile (\"\" ::: \"memory\");\n+\t}\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    {\n+      a[i][j] = i;\n+      b[i][j] = j;\n+      c[i][j] = 0;\n+      d[i][j] = 0;\n+    }\n+}\n+\n+static int __attribute__((noinline))\n+check (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    if (c[i][j] != d[i][j])\n+      return 0;\n+\n+  return 1;\n+}\n+\n+int main (void)\n+{\n+  for (int i = 0; i < M; ++i)\n+    init (i);\n+\n+  matrix_mul_1 (M);\n+  matrix_mul_2 (M);\n+\n+  for (int i = 0; i < M; ++i)\n+    if (!check (i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\" } } */\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is not interchanged\" 1 \"linterchange\" } } */"}, {"sha": "2802836f31c3d3f623e5c85108dbb6545ce35b75", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-6.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-6.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M], c[M][M], d[M][M];\n+void __attribute__((noinline))\n+matrix_mul_1 (int n)\n+{\n+    for (int j = 0; j < n; j++)\n+      for (int k = 0; k < n; k++)\n+  for (int i = 0; i < n; i++)\n+        c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+}\n+\n+void __attribute__((noinline))\n+matrix_mul_2 (int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      for (int j = 0; j < n; j++)\n+\t{\n+\t  for (int k = 0; k < n; k++)\n+\t    d[i][j] = d[i][j] + a[i][k]*b[k][j];\n+\n+\t  asm volatile (\"\" ::: \"memory\");\n+\t}\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    {\n+      a[i][j] = i;\n+      b[i][j] = j;\n+      c[i][j] = 0;\n+      d[i][j] = 0;\n+    }\n+}\n+\n+static int __attribute__((noinline))\n+check (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    if (c[i][j] != d[i][j])\n+      return 0;\n+\n+  return 1;\n+}\n+\n+int main (void)\n+{\n+  for (int i = 0; i < M; ++i)\n+    init (i);\n+\n+  matrix_mul_1 (M);\n+  matrix_mul_2 (M);\n+\n+  for (int i = 0; i < M; ++i)\n+    if (!check (i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 2 \"linterchange\" } } */"}, {"sha": "2c589c13c158331e4d3c997487cada53b27e5093", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-7.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-7.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M], c[M][M], d[M][M];\n+void __attribute__((noinline))\n+matrix_mul_1 (int n)\n+{\n+      for (int k = 0; k < n; k++)\n+    for (int j = 0; j < n; j++)\n+  for (int i = 0; i < n; i++)\n+        c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+}\n+\n+void __attribute__((noinline))\n+matrix_mul_2 (int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      for (int j = 0; j < n; j++)\n+\t{\n+\t  for (int k = 0; k < n; k++)\n+\t    d[i][j] = d[i][j] + a[i][k]*b[k][j];\n+\n+\t  asm volatile (\"\" ::: \"memory\");\n+\t}\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    {\n+      a[i][j] = i;\n+      b[i][j] = j;\n+      c[i][j] = 0;\n+      d[i][j] = 0;\n+    }\n+}\n+\n+static int __attribute__((noinline))\n+check (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    if (c[i][j] != d[i][j])\n+      return 0;\n+\n+  return 1;\n+}\n+\n+int main (void)\n+{\n+  for (int i = 0; i < M; ++i)\n+    init (i);\n+\n+  matrix_mul_1 (M);\n+  matrix_mul_2 (M);\n+\n+  for (int i = 0; i < M; ++i)\n+    if (!check (i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 2 \"linterchange\" } } */"}, {"sha": "7546c7331e13a20595dedf45586c7528914d7bcc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-8.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-8.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M], c[M][M], d[M][M];\n+void __attribute__((noinline))\n+matrix_mul_1 (int n)\n+{\n+  for (int i = 0; i < n; i++)\n+      for (int k = 0; k < n; k++)\n+    for (int j = 0; j < n; j++)\n+        c[i][j] = c[i][j] + a[i][k]*b[k][j];\n+}\n+\n+void __attribute__((noinline))\n+matrix_mul_2 (int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      for (int j = 0; j < n; j++)\n+\t{\n+\t  for (int k = 0; k < n; k++)\n+\t    d[i][j] = d[i][j] + a[i][k]*b[k][j];\n+\n+\t  asm volatile (\"\" ::: \"memory\");\n+\t}\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    {\n+      a[i][j] = i;\n+      b[i][j] = j;\n+      c[i][j] = 0;\n+      d[i][j] = 0;\n+    }\n+}\n+\n+static int __attribute__((noinline))\n+check (int i)\n+{\n+  for (int j = 0; j < M; j++)\n+    if (c[i][j] != d[i][j])\n+      return 0;\n+\n+  return 1;\n+}\n+\n+int main (void)\n+{\n+  for (int i = 0; i < M; ++i)\n+    init (i);\n+\n+  matrix_mul_1 (M);\n+  matrix_mul_2 (M);\n+\n+  for (int i = 0; i < M; ++i)\n+    if (!check (i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Loop_pair<outer:., inner:.> is interchanged\" \"linterchange\" } } */"}, {"sha": "2215739f98a76551f30cd5a4b87a931cdd812d6f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-9.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-interchange-9.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -floop-interchange -fdump-tree-linterchange-details\" } */\n+\n+#define M 256\n+int a[M][M], b[M][M], c[M], d[M];\n+void __attribute__((noinline))\n+simple_reduc_1 (int n)\n+{\n+  for (int j = 0; j < n; j++)\n+    {\n+      int sum = c[j];\n+      for (int i = 0; i < n; i++)\n+\tsum = sum + a[i][j]*b[i][j];\n+\n+      c[j] = sum;\n+    }\n+}\n+\n+void __attribute__((noinline))\n+simple_reduc_2 (int n)\n+{\n+  for (int j = 0; j < n; j++)\n+    {\n+      int sum = d[j];\n+      for (int i = 0; i < n; i++)\n+\tsum = sum + a[i][j]*b[i][j];\n+\n+      asm volatile (\"\" ::: \"memory\");\n+      d[j] = sum;\n+    }\n+}\n+\n+extern void abort ();\n+\n+static void __attribute__((noinline))\n+init (int i)\n+{\n+  c[i] = 0;\n+  d[i] = 0;\n+  for (int j = 0; j < M; j++)\n+    {\n+      a[i][j] = i;\n+      b[i][j] = j;\n+    }\n+}\n+\n+int main (void)\n+{\n+  for (int i = 0; i < M; ++i)\n+    init (i);\n+\n+  simple_reduc_1 (M);\n+  simple_reduc_2 (M);\n+\n+  for (int i = 0; i < M; ++i)\n+    if (c[i] != d[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop_pair<outer:., inner:.> is interchanged\" 1 \"linterchange\" } } */"}, {"sha": "caa36459dec8353148976b034d3938afd924715c", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -184,6 +184,7 @@ DEFTIMEVAR (TV_TREE_LOOP\t     , \"tree loop optimization\")\n DEFTIMEVAR (TV_TREE_NOLOOP           , \"loopless fn\")\n DEFTIMEVAR (TV_TREE_LOOP_BOUNDS\t     , \"tree loop bounds\")\n DEFTIMEVAR (TV_LIM                   , \"tree loop invariant motion\")\n+DEFTIMEVAR (TV_LINTERCHANGE          , \"tree loop interchange\")\n DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv\")\n DEFTIMEVAR (TV_SCEV_CONST            , \"scev constant prop\")\n DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")"}, {"sha": "97ace1e4428197e8d3c9bc8367f565aeb9530c30", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -368,6 +368,7 @@ extern gimple_opt_pass *make_pass_tree_loop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_no_loop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_loop_init (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lim (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_linterchange (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_unswitch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_loop_split (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_loop_jam (gcc::context *ctxt);"}, {"sha": "ae66ace3d7fd8d94922a4817cdf66c8773a69fed", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -76,10 +76,13 @@ enum unroll_level\n };\n \n /* Adds a canonical induction variable to LOOP iterating NITER times.  EXIT\n-   is the exit edge whose condition is replaced.  */\n+   is the exit edge whose condition is replaced.  The ssa versions of the new\n+   IV before and after increment will be stored in VAR_BEFORE and VAR_AFTER\n+   if they are not NULL.  */\n \n-static void\n-create_canonical_iv (struct loop *loop, edge exit, tree niter)\n+void\n+create_canonical_iv (struct loop *loop, edge exit, tree niter,\n+\t\t     tree *var_before = NULL, tree *var_after = NULL)\n {\n   edge in;\n   tree type, var;\n@@ -112,7 +115,9 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n   create_iv (niter,\n \t     build_int_cst (type, -1),\n \t     NULL_TREE, loop,\n-\t     &incr_at, false, NULL, &var);\n+\t     &incr_at, false, var_before, &var);\n+  if (var_after)\n+    *var_after = var;\n \n   cmp = (exit->flags & EDGE_TRUE_VALUE) ? EQ_EXPR : NE_EXPR;\n   gimple_cond_set_code (cond, cmp);"}, {"sha": "a723f46dae4b85a2b862c20b7a4b71e84152c1aa", "filename": "gcc/tree-ssa-loop-ivopts.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-ssa-loop-ivopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-ssa-loop-ivopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.h?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -32,4 +32,6 @@ extern tree strip_offset (tree, unsigned HOST_WIDE_INT *);\n bool may_be_nonaddressable_p (tree expr);\n void tree_ssa_iv_optimize (void);\n \n+void create_canonical_iv (struct loop *, edge, tree,\n+\t\t\t  tree * = NULL, tree * = NULL);\n #endif /* GCC_TREE_SSA_LOOP_IVOPTS_H */"}, {"sha": "6a2de9ae57692cc13ff82084fafd9c316e2cf41a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 110, "deletions": 100, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -2626,6 +2626,114 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n }\n \n \n+/* Return true if the reduction PHI in LOOP with latch arg LOOP_ARG and\n+   reduction operation CODE has a handled computation expression.  */\n+\n+bool\n+check_reduction_path (location_t loc, loop_p loop, gphi *phi, tree loop_arg,\n+\t\t      enum tree_code code)\n+{\n+  auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n+  auto_bitmap visited;\n+  tree lookfor = PHI_RESULT (phi);\n+  ssa_op_iter curri;\n+  use_operand_p curr = op_iter_init_phiuse (&curri, phi, SSA_OP_USE);\n+  while (USE_FROM_PTR (curr) != loop_arg)\n+    curr = op_iter_next_use (&curri);\n+  curri.i = curri.numops;\n+  do\n+    {\n+      path.safe_push (std::make_pair (curri, curr));\n+      tree use = USE_FROM_PTR (curr);\n+      if (use == lookfor)\n+\tbreak;\n+      gimple *def = SSA_NAME_DEF_STMT (use);\n+      if (gimple_nop_p (def)\n+\t  || ! flow_bb_inside_loop_p (loop, gimple_bb (def)))\n+\t{\n+pop:\n+\t  do\n+\t    {\n+\t      std::pair<ssa_op_iter, use_operand_p> x = path.pop ();\n+\t      curri = x.first;\n+\t      curr = x.second;\n+\t      do\n+\t\tcurr = op_iter_next_use (&curri);\n+\t      /* Skip already visited or non-SSA operands (from iterating\n+\t         over PHI args).  */\n+\t      while (curr != NULL_USE_OPERAND_P\n+\t\t     && (TREE_CODE (USE_FROM_PTR (curr)) != SSA_NAME\n+\t\t\t || ! bitmap_set_bit (visited,\n+\t\t\t\t\t      SSA_NAME_VERSION\n+\t\t\t\t\t        (USE_FROM_PTR (curr)))));\n+\t    }\n+\t  while (curr == NULL_USE_OPERAND_P && ! path.is_empty ());\n+\t  if (curr == NULL_USE_OPERAND_P)\n+\t    break;\n+\t}\n+      else\n+\t{\n+\t  if (gimple_code (def) == GIMPLE_PHI)\n+\t    curr = op_iter_init_phiuse (&curri, as_a <gphi *>(def), SSA_OP_USE);\n+\t  else\n+\t    curr = op_iter_init_use (&curri, def, SSA_OP_USE);\n+\t  while (curr != NULL_USE_OPERAND_P\n+\t\t && (TREE_CODE (USE_FROM_PTR (curr)) != SSA_NAME\n+\t\t     || ! bitmap_set_bit (visited,\n+\t\t\t\t\t  SSA_NAME_VERSION\n+\t\t\t\t\t    (USE_FROM_PTR (curr)))))\n+\t    curr = op_iter_next_use (&curri);\n+\t  if (curr == NULL_USE_OPERAND_P)\n+\t    goto pop;\n+\t}\n+    }\n+  while (1);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      dump_printf_loc (MSG_NOTE, loc, \"reduction path: \");\n+      unsigned i;\n+      std::pair<ssa_op_iter, use_operand_p> *x;\n+      FOR_EACH_VEC_ELT (path, i, x)\n+\t{\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, USE_FROM_PTR (x->second));\n+\t  dump_printf (MSG_NOTE, \" \");\n+\t}\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  /* Check whether the reduction path detected is valid.  */\n+  bool fail = path.length () == 0;\n+  bool neg = false;\n+  for (unsigned i = 1; i < path.length (); ++i)\n+    {\n+      gimple *use_stmt = USE_STMT (path[i].second);\n+      tree op = USE_FROM_PTR (path[i].second);\n+      if (! has_single_use (op)\n+\t  || ! is_gimple_assign (use_stmt))\n+\t{\n+\t  fail = true;\n+\t  break;\n+\t}\n+      if (gimple_assign_rhs_code (use_stmt) != code)\n+\t{\n+\t  if (code == PLUS_EXPR\n+\t      && gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t    {\n+\t      /* Track whether we negate the reduction value each iteration.  */\n+\t      if (gimple_assign_rhs2 (use_stmt) == op)\n+\t\tneg = ! neg;\n+\t    }\n+\t  else\n+\t    {\n+\t      fail = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return ! fail && ! neg;\n+}\n+\n+\n /* Function vect_is_simple_reduction\n \n    (1) Detect a cross-iteration def-use cycle that represents a simple\n@@ -3128,106 +3236,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n     }\n \n   /* Look for the expression computing loop_arg from loop PHI result.  */\n-  auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n-  auto_bitmap visited;\n-  tree lookfor = PHI_RESULT (phi);\n-  ssa_op_iter curri;\n-  use_operand_p curr = op_iter_init_phiuse (&curri, as_a <gphi *>(phi),\n-\t\t\t\t\t    SSA_OP_USE);\n-  while (USE_FROM_PTR (curr) != loop_arg)\n-    curr = op_iter_next_use (&curri);\n-  curri.i = curri.numops;\n-  do\n-    {\n-      path.safe_push (std::make_pair (curri, curr));\n-      tree use = USE_FROM_PTR (curr);\n-      if (use == lookfor)\n-\tbreak;\n-      gimple *def = SSA_NAME_DEF_STMT (use);\n-      if (gimple_nop_p (def)\n-\t  || ! flow_bb_inside_loop_p (loop, gimple_bb (def)))\n-\t{\n-pop:\n-\t  do\n-\t    {\n-\t      std::pair<ssa_op_iter, use_operand_p> x = path.pop ();\n-\t      curri = x.first;\n-\t      curr = x.second;\n-\t      do\n-\t\tcurr = op_iter_next_use (&curri);\n-\t      /* Skip already visited or non-SSA operands (from iterating\n-\t         over PHI args).  */\n-\t      while (curr != NULL_USE_OPERAND_P\n-\t\t     && (TREE_CODE (USE_FROM_PTR (curr)) != SSA_NAME\n-\t\t\t || ! bitmap_set_bit (visited,\n-\t\t\t\t\t      SSA_NAME_VERSION\n-\t\t\t\t\t        (USE_FROM_PTR (curr)))));\n-\t    }\n-\t  while (curr == NULL_USE_OPERAND_P && ! path.is_empty ());\n-\t  if (curr == NULL_USE_OPERAND_P)\n-\t    break;\n-\t}\n-      else\n-\t{\n-\t  if (gimple_code (def) == GIMPLE_PHI)\n-\t    curr = op_iter_init_phiuse (&curri, as_a <gphi *>(def), SSA_OP_USE);\n-\t  else\n-\t    curr = op_iter_init_use (&curri, def, SSA_OP_USE);\n-\t  while (curr != NULL_USE_OPERAND_P\n-\t\t && (TREE_CODE (USE_FROM_PTR (curr)) != SSA_NAME\n-\t\t     || ! bitmap_set_bit (visited,\n-\t\t\t\t\t  SSA_NAME_VERSION\n-\t\t\t\t\t    (USE_FROM_PTR (curr)))))\n-\t    curr = op_iter_next_use (&curri);\n-\t  if (curr == NULL_USE_OPERAND_P)\n-\t    goto pop;\n-\t}\n-    }\n-  while (1);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"reduction path: \");\n-      unsigned i;\n-      std::pair<ssa_op_iter, use_operand_p> *x;\n-      FOR_EACH_VEC_ELT (path, i, x)\n-\t{\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, USE_FROM_PTR (x->second));\n-\t  dump_printf (MSG_NOTE, \" \");\n-\t}\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n-\n-  /* Check whether the reduction path detected is valid.  */\n-  bool fail = path.length () == 0;\n-  bool neg = false;\n-  for (unsigned i = 1; i < path.length (); ++i)\n-    {\n-      gimple *use_stmt = USE_STMT (path[i].second);\n-      tree op = USE_FROM_PTR (path[i].second);\n-      if (! has_single_use (op)\n-\t  || ! is_gimple_assign (use_stmt))\n-\t{\n-\t  fail = true;\n-\t  break;\n-\t}\n-      if (gimple_assign_rhs_code (use_stmt) != code)\n-\t{\n-\t  if (code == PLUS_EXPR\n-\t      && gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n-\t    {\n-\t      /* Track whether we negate the reduction value each iteration.  */\n-\t      if (gimple_assign_rhs2 (use_stmt) == op)\n-\t\tneg = ! neg;\n-\t    }\n-\t  else\n-\t    {\n-\t      fail = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  if (! fail && ! neg)\n+  if (check_reduction_path (vect_location, loop, as_a <gphi *> (phi), loop_arg,\n+\t\t\t    code))\n     return def_stmt;\n \n   if (dump_enabled_p ())"}, {"sha": "56811e5e14b419f5196858fc36e2c907f85d9a3e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdec14e80e9399cd301ed30340268bdc5b5c2eb/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=fbdec14e80e9399cd301ed30340268bdc5b5c2eb", "patch": "@@ -1255,6 +1255,9 @@ extern tree vect_create_addr_base_for_vector_ref (gimple *, gimple_seq *,\n /* FORNOW: Used in tree-parloops.c.  */\n extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *,\n \t\t\t\t\t    bool *, bool);\n+/* Used in gimple-loop-interchange.c.  */\n+extern bool check_reduction_path (location_t, loop_p, gphi *, tree,\n+\t\t\t\t  enum tree_code);\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info);\n extern tree vect_build_loop_niters (loop_vec_info, bool * = NULL);"}]}