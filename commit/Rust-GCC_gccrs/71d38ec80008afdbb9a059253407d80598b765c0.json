{"sha": "71d38ec80008afdbb9a059253407d80598b765c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkMzhlYzgwMDA4YWZkYmI5YTA1OTI1MzQwN2Q4MDU5OGI3NjVjMA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2021-05-11T23:54:01Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2021-05-11T23:54:01Z"}, "message": "preprocessor: Support C2X #elifdef, #elifndef\n\nC2X adds #elifdef and #elifndef preprocessor directives; these have\nalso been proposed for C++.  Implement these directives in libcpp\naccordingly.\n\nIn this implementation, #elifdef and #elifndef are treated as\nnon-directives for any language version other than c2x and gnu2x (if\nthe feature is accepted for C++, it can trivially be enabled for\nrelevant C++ versions).  In strict conformance modes for prior\nlanguage versions, this is required, as illustrated by the\nc11-elifdef-1.c test added.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\nlibcpp/\n\t* include/cpplib.h (struct cpp_options): Add elifdef.\n\t* init.c (struct lang_flags): Add elifdef.\n\t(lang_defaults): Update to include elifdef initializers.\n\t(cpp_set_lang): Set elifdef for pfile based on language.\n\t* directives.c (STDC2X, ELIFDEF): New macros.\n\t(EXTENSION): Increase value to 3.\n\t(DIRECTIVE_TABLE): Add #elifdef and #elifndef.\n\t(_cpp_handle_directive): Do not treat ELIFDEF directives as\n\tdirectives for language versions without the #elifdef feature.\n\t(do_elif): Handle #elifdef and #elifndef.\n\t(do_elifdef, do_elifndef): New functions.\n\ngcc/testsuite/\n\t* gcc.dg/cpp/c11-elifdef-1.c, gcc.dg/cpp/c2x-elifdef-1.c,\n\tgcc.dg/cpp/c2x-elifdef-2.c: New tests.", "tree": {"sha": "61d4686bb430d8369941427a4d05c34522007f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61d4686bb430d8369941427a4d05c34522007f48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d38ec80008afdbb9a059253407d80598b765c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d38ec80008afdbb9a059253407d80598b765c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d38ec80008afdbb9a059253407d80598b765c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d38ec80008afdbb9a059253407d80598b765c0/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "415bcabf134b90794a134ca5dadfaf44496645d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415bcabf134b90794a134ca5dadfaf44496645d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415bcabf134b90794a134ca5dadfaf44496645d5"}], "stats": {"total": 259, "additions": 224, "deletions": 35}, "files": [{"sha": "2d5809a8378c733fe176cf5994a72d329dd46bf9", "filename": "gcc/testsuite/gcc.dg/cpp/c11-elifdef-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d38ec80008afdbb9a059253407d80598b765c0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc11-elifdef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d38ec80008afdbb9a059253407d80598b765c0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc11-elifdef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc11-elifdef-1.c?ref=71d38ec80008afdbb9a059253407d80598b765c0", "patch": "@@ -0,0 +1,16 @@\n+/* Test #elifdef and #elifndef not in C11.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#define A\n+#undef B\n+\n+#if 0\n+#elifdef A\n+#error \"#elifdef A applied\"\n+#endif\n+\n+#if 0\n+#elifndef B\n+#error \"#elifndef B applied\"\n+#endif"}, {"sha": "b23e3117daf0296ac9b6cab1d7511a1865ca5348", "filename": "gcc/testsuite/gcc.dg/cpp/c2x-elifdef-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d38ec80008afdbb9a059253407d80598b765c0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc2x-elifdef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d38ec80008afdbb9a059253407d80598b765c0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc2x-elifdef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc2x-elifdef-1.c?ref=71d38ec80008afdbb9a059253407d80598b765c0", "patch": "@@ -0,0 +1,57 @@\n+/* Test #elifdef and #elifndef in C2x.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+#define A\n+#undef B\n+\n+#if 0\n+#elifdef A\n+#define M1 1\n+#endif\n+\n+#if M1 != 1\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef B\n+#error \"#elifdef B applied\"\n+#endif\n+\n+#if 0\n+#elifndef A\n+#error \"#elifndef A applied\"\n+#endif\n+\n+#if 0\n+#elifndef B\n+#define M2 2\n+#endif\n+\n+#if M2 != 2\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef A\n+#else\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifndef B\n+#else\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+/* As with #elif, the syntax of the new directives is relaxed after a\n+   non-skipped group.  */\n+\n+#if 1\n+#elifdef x * y\n+#endif\n+\n+#if 1\n+#elifndef !\n+#endif"}, {"sha": "9132832416d0d1042e083bd1987cc47e02b11d1a", "filename": "gcc/testsuite/gcc.dg/cpp/c2x-elifdef-2.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d38ec80008afdbb9a059253407d80598b765c0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc2x-elifdef-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d38ec80008afdbb9a059253407d80598b765c0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc2x-elifdef-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fc2x-elifdef-2.c?ref=71d38ec80008afdbb9a059253407d80598b765c0", "patch": "@@ -0,0 +1,63 @@\n+/* Test #elifdef and #elifndef in C2x: erroneous usages.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+#define A\n+#undef B\n+\n+#elifdef A /* { dg-error \"#elifdef without #if\" } */\n+#elifdef B /* { dg-error \"#elifdef without #if\" } */\n+#elifndef A /* { dg-error \"#elifndef without #if\" } */\n+#elifndef B /* { dg-error \"#elifndef without #if\" } */\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifdef A /* { dg-error \"#elifdef after #else\" } */\n+#endif\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifdef B /* { dg-error \"#elifdef after #else\" } */\n+#endif\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifndef A /* { dg-error \"#elifndef after #else\" } */\n+#endif\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifndef B /* { dg-error \"#elifndef after #else\" } */\n+#endif\n+\n+#if 0\n+#elifdef A = /* { dg-error \"extra tokens at end of #elifdef directive\" } */\n+#endif\n+\n+#if 0\n+#elifdef B = /* { dg-error \"extra tokens at end of #elifdef directive\" } */\n+#endif\n+\n+#if 0\n+#elifndef A = /* { dg-error \"extra tokens at end of #elifndef directive\" } */\n+#endif\n+\n+#if 0\n+#elifndef B = /* { dg-error \"extra tokens at end of #elifndef directive\" } */\n+#endif\n+\n+#if 0\n+#elifdef /* { dg-error \"no macro name given in #elifdef directive\" } */\n+#endif\n+\n+#if 0\n+#elifndef /* { dg-error \"no macro name given in #elifndef directive\" } */\n+#endif\n+\n+#if 0\n+#elifdef , /* { dg-error \"macro names must be identifiers\" } */\n+#endif\n+\n+#if 0\n+#elifndef , /* { dg-error \"macro names must be identifiers\" } */\n+#endif"}, {"sha": "261a584c550936a9f725893cd51887008819995e", "filename": "libcpp/directives.c", "status": "modified", "additions": 58, "deletions": 10, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d38ec80008afdbb9a059253407d80598b765c0/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d38ec80008afdbb9a059253407d80598b765c0/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=71d38ec80008afdbb9a059253407d80598b765c0", "patch": "@@ -56,24 +56,30 @@ struct pragma_entry\n \n /* Values for the origin field of struct directive.  KANDR directives\n    come from traditional (K&R) C.  STDC89 directives come from the\n-   1989 C standard.  EXTENSION directives are extensions.  */\n+   1989 C standard.  STDC2X directives come from the C2X standard.  EXTENSION\n+   directives are extensions.  */\n #define KANDR\t\t0\n #define STDC89\t\t1\n-#define EXTENSION\t2\n+#define STDC2X\t\t2\n+#define EXTENSION\t3\n \n /* Values for the flags field of struct directive.  COND indicates a\n    conditional; IF_COND an opening conditional.  INCL means to treat\n    \"...\" and <...> as q-char and h-char sequences respectively.  IN_I\n    means this directive should be handled even if -fpreprocessed is in\n    effect (these are the directives with callback hooks).\n \n-   EXPAND is set on directives that are always macro-expanded.  */\n+   EXPAND is set on directives that are always macro-expanded.\n+\n+   ELIFDEF is set on directives that are only handled for standards with the\n+   #elifdef / #elifndef feature.  */\n #define COND\t\t(1 << 0)\n #define IF_COND\t\t(1 << 1)\n #define INCL\t\t(1 << 2)\n #define IN_I\t\t(1 << 3)\n #define EXPAND\t\t(1 << 4)\n #define DEPRECATED\t(1 << 5)\n+#define ELIFDEF\t\t(1 << 6)\n \n /* Defines one #-directive, including how to handle it.  */\n typedef void (*directive_handler) (cpp_reader *);\n@@ -148,6 +154,8 @@ static void cpp_pop_definition (cpp_reader *, struct def_pragma_macro *);\n   D(undef,\tT_UNDEF,\tKANDR,     IN_I)\t\t\t\\\n   D(line,\tT_LINE,\t\tKANDR,     EXPAND)\t\t\t\\\n   D(elif,\tT_ELIF,\t\tSTDC89,    COND | EXPAND)\t\t\\\n+  D(elifdef,\tT_ELIFDEF,\tSTDC2X,    COND | ELIFDEF)\t\t\\\n+  D(elifndef,\tT_ELIFNDEF,\tSTDC2X,    COND | ELIFDEF)\t\t\\\n   D(error,\tT_ERROR,\tSTDC89,    0)\t\t\t\t\\\n   D(pragma,\tT_PRAGMA,\tSTDC89,    IN_I)\t\t\t\\\n   D(warning,\tT_WARNING,\tEXTENSION, 0)\t\t\t\t\\\n@@ -437,7 +445,11 @@ _cpp_handle_directive (cpp_reader *pfile, bool indented)\n   if (dname->type == CPP_NAME)\n     {\n       if (dname->val.node.node->is_directive)\n-\tdir = &dtable[dname->val.node.node->directive_index];\n+\t{\n+\t  dir = &dtable[dname->val.node.node->directive_index];\n+\t  if ((dir->flags & ELIFDEF) && !CPP_OPTION (pfile, elifdef))\n+\t    dir = 0;\n+\t}\n     }\n   /* We do not recognize the # followed by a number extension in\n      assembler code.  */\n@@ -2079,21 +2091,22 @@ do_else (cpp_reader *pfile)\n     }\n }\n \n-/* Handle a #elif directive by not changing if_stack either.  See the\n-   comment above do_else.  */\n+/* Handle a #elif, #elifdef or #elifndef directive by not changing if_stack\n+   either.  See the comment above do_else.  */\n static void\n do_elif (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, CPP_DL_ERROR, \"#elif without #if\");\n+    cpp_error (pfile, CPP_DL_ERROR, \"#%s without #if\", pfile->directive->name);\n   else\n     {\n       if (ifs->type == T_ELSE)\n \t{\n-\t  cpp_error (pfile, CPP_DL_ERROR, \"#elif after #else\");\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"#%s after #else\",\n+\t\t     pfile->directive->name);\n \t  cpp_error_with_line (pfile, CPP_DL_ERROR, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n@@ -2107,15 +2120,50 @@ do_elif (cpp_reader *pfile)\n \tpfile->state.skipping = 1;\n       else\n \t{\n-\t  pfile->state.skipping = ! _cpp_parse_expr (pfile, false);\n-\t  ifs->skip_elses = ! pfile->state.skipping;\n+\t  if (pfile->directive == &dtable[T_ELIF])\n+\t    pfile->state.skipping = !_cpp_parse_expr (pfile, false);\n+\t  else\n+\t    {\n+\t      cpp_hashnode *node = lex_macro_node (pfile, false);\n+\n+\t      if (node)\n+\t\t{\n+\t\t  bool macro_defined = _cpp_defined_macro_p (node);\n+\t\t  if (!_cpp_maybe_notify_macro_use (pfile, node,\n+\t\t\t\t\t\t    pfile->directive_line))\n+\t\t    /* It wasn't a macro after all.  */\n+\t\t    macro_defined = false;\n+\t\t  bool skip = (pfile->directive == &dtable[T_ELIFDEF]\n+\t\t\t       ? !macro_defined\n+\t\t\t       : macro_defined);\n+\t\t  if (pfile->cb.used)\n+\t\t    pfile->cb.used (pfile, pfile->directive_line, node);\n+\t\t  check_eol (pfile, false);\n+\t\t  pfile->state.skipping = skip;\n+\t\t}\n+\t    }\n+\t  ifs->skip_elses = !pfile->state.skipping;\n \t}\n \n       /* Invalidate any controlling macro.  */\n       ifs->mi_cmacro = 0;\n     }\n }\n \n+/* Handle a #elifdef directive.  */\n+static void\n+do_elifdef (cpp_reader *pfile)\n+{\n+  do_elif (pfile);\n+}\n+\n+/* Handle a #elifndef directive.  */\n+static void\n+do_elifndef (cpp_reader *pfile)\n+{\n+  do_elif (pfile);\n+}\n+\n /* #endif pops the if stack and resets pfile->state.skipping.  */\n static void\n do_endif (cpp_reader *pfile)"}, {"sha": "2cdaf19362ac8cab8699877eda92398dbc294a9a", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d38ec80008afdbb9a059253407d80598b765c0/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d38ec80008afdbb9a059253407d80598b765c0/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=71d38ec80008afdbb9a059253407d80598b765c0", "patch": "@@ -497,6 +497,9 @@ struct cpp_options\n   /* Nonzero for the '::' token.  */\n   unsigned char scope;\n \n+  /* Nonzero for the '#elifdef' and '#elifndef' directives.  */\n+  unsigned char elifdef;\n+\n   /* Nonzero means tokenize C++20 module directives.  */\n   unsigned char module_directives;\n "}, {"sha": "d5d4e994d2ad6c0c0229f351154c7e833c1da5bf", "filename": "libcpp/init.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d38ec80008afdbb9a059253407d80598b765c0/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d38ec80008afdbb9a059253407d80598b765c0/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=71d38ec80008afdbb9a059253407d80598b765c0", "patch": "@@ -95,34 +95,35 @@ struct lang_flags\n   char scope;\n   char dfp_constants;\n   char size_t_literals;\n+  char elifdef;\n };\n \n static const struct lang_flags lang_defaults[] =\n-{ /*              c99 c++ xnum xid c11 std digr ulit rlit udlit bincst digsep trig u8chlit vaopt scope dfp szlit */\n-  /* GNUC89   */  { 0,  0,  1,  0,  0,  0,  1,   0,   0,   0,    0,     0,     0,   0,      1,   1,     0,   0 },\n-  /* GNUC99   */  { 1,  0,  1,  1,  0,  0,  1,   1,   1,   0,    0,     0,     0,   0,      1,   1,     0,   0 },\n-  /* GNUC11   */  { 1,  0,  1,  1,  1,  0,  1,   1,   1,   0,    0,     0,     0,   0,      1,   1,     0,   0 },\n-  /* GNUC17   */  { 1,  0,  1,  1,  1,  0,  1,   1,   1,   0,    0,     0,     0,   0,      1,   1,     0,   0 },\n-  /* GNUC2X   */  { 1,  0,  1,  1,  1,  0,  1,   1,   1,   0,    1,     1,     0,   1,      1,   1,     1,   0 },\n-  /* STDC89   */  { 0,  0,  0,  0,  0,  1,  0,   0,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0 },\n-  /* STDC94   */  { 0,  0,  0,  0,  0,  1,  1,   0,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0 },\n-  /* STDC99   */  { 1,  0,  1,  1,  0,  1,  1,   0,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0 },\n-  /* STDC11   */  { 1,  0,  1,  1,  1,  1,  1,   1,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0 },\n-  /* STDC17   */  { 1,  0,  1,  1,  1,  1,  1,   1,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0 },\n-  /* STDC2X   */  { 1,  0,  1,  1,  1,  1,  1,   1,   0,   0,    1,     1,     1,   1,      0,   1,     1,   0 },\n-  /* GNUCXX   */  { 0,  1,  1,  1,  0,  0,  1,   0,   0,   0,    0,     0,     0,   0,      1,   1,     0,   0 },\n-  /* CXX98    */  { 0,  1,  0,  1,  0,  1,  1,   0,   0,   0,    0,     0,     1,   0,      0,   1,     0,   0 },\n-  /* GNUCXX11 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    0,     0,     0,   0,      1,   1,     0,   0 },\n-  /* CXX11    */  { 1,  1,  0,  1,  1,  1,  1,   1,   1,   1,    0,     0,     1,   0,      0,   1,     0,   0 },\n-  /* GNUCXX14 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   0,      1,   1,     0,   0 },\n-  /* CXX14    */  { 1,  1,  0,  1,  1,  1,  1,   1,   1,   1,    1,     1,     1,   0,      0,   1,     0,   0 },\n-  /* GNUCXX17 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0 },\n-  /* CXX17    */  { 1,  1,  1,  1,  1,  1,  1,   1,   1,   1,    1,     1,     0,   1,      0,   1,     0,   0 },\n-  /* GNUCXX20 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0 },\n-  /* CXX20    */  { 1,  1,  1,  1,  1,  1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0 },\n-  /* GNUCXX23 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1 },\n-  /* CXX23    */  { 1,  1,  1,  1,  1,  1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1 },\n-  /* ASM      */  { 0,  0,  1,  0,  0,  0,  0,   0,   0,   0,    0,     0,     0,   0,      0,   0,     0,   0 }\n+{ /*              c99 c++ xnum xid c11 std digr ulit rlit udlit bincst digsep trig u8chlit vaopt scope dfp szlit elifdef */\n+  /* GNUC89   */  { 0,  0,  1,  0,  0,  0,  1,   0,   0,   0,    0,     0,     0,   0,      1,   1,     0,   0,   0 },\n+  /* GNUC99   */  { 1,  0,  1,  1,  0,  0,  1,   1,   1,   0,    0,     0,     0,   0,      1,   1,     0,   0,   0 },\n+  /* GNUC11   */  { 1,  0,  1,  1,  1,  0,  1,   1,   1,   0,    0,     0,     0,   0,      1,   1,     0,   0,   0 },\n+  /* GNUC17   */  { 1,  0,  1,  1,  1,  0,  1,   1,   1,   0,    0,     0,     0,   0,      1,   1,     0,   0,   0 },\n+  /* GNUC2X   */  { 1,  0,  1,  1,  1,  0,  1,   1,   1,   0,    1,     1,     0,   1,      1,   1,     1,   0,   1 },\n+  /* STDC89   */  { 0,  0,  0,  0,  0,  1,  0,   0,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0,   0 },\n+  /* STDC94   */  { 0,  0,  0,  0,  0,  1,  1,   0,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0,   0 },\n+  /* STDC99   */  { 1,  0,  1,  1,  0,  1,  1,   0,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0,   0 },\n+  /* STDC11   */  { 1,  0,  1,  1,  1,  1,  1,   1,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0,   0 },\n+  /* STDC17   */  { 1,  0,  1,  1,  1,  1,  1,   1,   0,   0,    0,     0,     1,   0,      0,   0,     0,   0,   0 },\n+  /* STDC2X   */  { 1,  0,  1,  1,  1,  1,  1,   1,   0,   0,    1,     1,     1,   1,      0,   1,     1,   0,   1 },\n+  /* GNUCXX   */  { 0,  1,  1,  1,  0,  0,  1,   0,   0,   0,    0,     0,     0,   0,      1,   1,     0,   0,   0 },\n+  /* CXX98    */  { 0,  1,  0,  1,  0,  1,  1,   0,   0,   0,    0,     0,     1,   0,      0,   1,     0,   0,   0 },\n+  /* GNUCXX11 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    0,     0,     0,   0,      1,   1,     0,   0,   0 },\n+  /* CXX11    */  { 1,  1,  0,  1,  1,  1,  1,   1,   1,   1,    0,     0,     1,   0,      0,   1,     0,   0,   0 },\n+  /* GNUCXX14 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   0,      1,   1,     0,   0,   0 },\n+  /* CXX14    */  { 1,  1,  0,  1,  1,  1,  1,   1,   1,   1,    1,     1,     1,   0,      0,   1,     0,   0,   0 },\n+  /* GNUCXX17 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0,   0 },\n+  /* CXX17    */  { 1,  1,  1,  1,  1,  1,  1,   1,   1,   1,    1,     1,     0,   1,      0,   1,     0,   0,   0 },\n+  /* GNUCXX20 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0,   0 },\n+  /* CXX20    */  { 1,  1,  1,  1,  1,  1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0,   0 },\n+  /* GNUCXX23 */  { 1,  1,  1,  1,  1,  0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1,   0 },\n+  /* CXX23    */  { 1,  1,  1,  1,  1,  1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1,   0 },\n+  /* ASM      */  { 0,  0,  1,  0,  0,  0,  0,   0,   0,   0,    0,     0,     0,   0,      0,   0,     0,   0,   0 }\n };\n \n /* Sets internal flags correctly for a given language.  */\n@@ -151,6 +152,7 @@ cpp_set_lang (cpp_reader *pfile, enum c_lang lang)\n   CPP_OPTION (pfile, scope)\t\t\t = l->scope;\n   CPP_OPTION (pfile, dfp_constants)\t\t = l->dfp_constants;\n   CPP_OPTION (pfile, size_t_literals)\t\t = l->size_t_literals;\n+  CPP_OPTION (pfile, elifdef)\t\t\t = l->elifdef;\n }\n \n /* Initialize library global state.  */"}]}