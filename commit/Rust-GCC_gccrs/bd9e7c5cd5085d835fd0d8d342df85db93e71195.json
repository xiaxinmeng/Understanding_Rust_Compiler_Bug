{"sha": "bd9e7c5cd5085d835fd0d8d342df85db93e71195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5ZTdjNWNkNTA4NWQ4MzVmZDBkOGQzNDJkZjg1ZGI5M2U3MTE5NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-03-31T22:16:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-03-31T22:16:35Z"}, "message": "pex-win32.c (<errno.h>): Include.\n\n\t* pex-win32.c (<errno.h>): Include.\n\t(fix_argv): Remove.\n\t(argv_to_cmdline): New function.\n\t(std_suffixes): New variable.\n\t(no_suffixes): Likewise.\n\t(find_executable): New function.\n\t(win32_spawn): Likewise.\n\t(spawn_script): Use win32_spawn instead of _spawnv[p].\n\t(pex_win32_exec_child): Replace MSVCRT calls with Win32 API calls.\n\t(pex_win32_wait): Likewise.\n\nFrom-SVN: r112592", "tree": {"sha": "4a074182328bd353ff64888bb27683b06b5caff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a074182328bd353ff64888bb27683b06b5caff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd9e7c5cd5085d835fd0d8d342df85db93e71195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9e7c5cd5085d835fd0d8d342df85db93e71195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9e7c5cd5085d835fd0d8d342df85db93e71195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9e7c5cd5085d835fd0d8d342df85db93e71195/comments", "author": null, "committer": null, "parents": [{"sha": "16659fcf3307e1d41924bd4176053f2a2643fb38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16659fcf3307e1d41924bd4176053f2a2643fb38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16659fcf3307e1d41924bd4176053f2a2643fb38"}], "stats": {"total": 593, "additions": 335, "deletions": 258}, "files": [{"sha": "c12f9ca6d3131aa06bfe80a527430b8da4519a28", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9e7c5cd5085d835fd0d8d342df85db93e71195/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9e7c5cd5085d835fd0d8d342df85db93e71195/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=bd9e7c5cd5085d835fd0d8d342df85db93e71195", "patch": "@@ -1,3 +1,16 @@\n+2006-03-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* pex-win32.c (<errno.h>): Include.\n+\t(fix_argv): Remove.\n+\t(argv_to_cmdline): New function.\n+\t(std_suffixes): New variable.\n+\t(no_suffixes): Likewise.\n+\t(find_executable): New function.\n+\t(win32_spawn): Likewise.\n+\t(spawn_script): Use win32_spawn instead of _spawnv[p].\n+\t(pex_win32_exec_child): Replace MSVCRT calls with Win32 API calls.\n+\t(pex_win32_wait): Likewise.\n+\n 2006-03-24  Jim Blandy  <jimb@codesourcery.com>\n \n \t* pex-common.c (pex_run): Simplify output name handling."}, {"sha": "3a75c5be004dc204d780f2bccd895c11645be86c", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 322, "deletions": 258, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9e7c5cd5085d835fd0d8d342df85db93e71195/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9e7c5cd5085d835fd0d8d342df85db93e71195/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=bd9e7c5cd5085d835fd0d8d342df85db93e71195", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02110-1301, USA.  */\n #include <fcntl.h>\n #include <signal.h>\n #include <sys/stat.h>\n+#include <errno.h>\n \n /* mingw32 headers may not define the following.  */\n \n@@ -72,115 +73,6 @@ backslashify (char *s)\n   return;\n }\n \n-/* This is a kludge to get around the Microsoft C spawn functions' propensity\n-   to remove the outermost set of double quotes from all arguments.  */\n-\n-static const char * const *\n-fix_argv (char * const *argvec)\n-{\n-  char **argv;\n-  int i;\n-  char *command0;\n-\n-  /* See whether we need to change anything.  */\n-  for (command0 = argvec[0]; *command0 != '\\0'; command0++)\n-    if (*command0 == '/')\n-      break;\n-  if (*command0 == '\\0')\n-    {\n-      for (i = 1; argvec[i] != NULL; i++)\n-\tif (strpbrk (argvec[i], \"\\\" \\t\") != NULL)\n-\t  break;\n-\n-      if (argvec[i] == NULL)\n-\treturn (const char * const *) argvec;\n-    }\n-\n-  for (i = 0; argvec[i] != NULL; i++)\n-    ;\n-  argv = XNEWVEC (char *, i + 2);\n-\n-  argv++;\t/* Leave space at the beginning of argv\n-\t\t   for potential #! handling */\n-\n-  for (i = 0; argvec[i] != NULL; i++)\n-    argv[i] = xstrdup (argvec[i]);\n-  argv[i] = NULL;\n-\n-  backslashify (argv[0]);\n-\n-  for (i = 1; argv[i] != 0; i++)\n-    {\n-      int len, j;\n-      char *temp, *newtemp;\n-\n-      temp = argv[i];\n-      len = strlen (temp);\n-      for (j = 0; j < len; j++)\n-        {\n-          if (temp[j] == '\"')\n-            {\n-              newtemp = XNEWVEC (char, len + 2);\n-              strncpy (newtemp, temp, j);\n-              newtemp [j] = '\\\\';\n-              strncpy (&newtemp [j+1], &temp [j], len-j);\n-              newtemp [len+1] = 0;\n-              temp = newtemp;\n-              len++;\n-              j++;\n-            }\n-        }\n-\n-      if (argv[i] != temp)\n-\t{\n-\t  free (argv[i]);\n-\t  argv[i] = temp;\n-\t}\n-    }\n-\n-  for (i = 0; argv[i] != 0; i++)\n-    {\n-      if (strpbrk (argv[i], \" \\t\"))\n-        {\n-\t  int len, trailing_backslash;\n-\t  char *temp;\n-\n-\t  len = strlen (argv[i]);\n-\t  trailing_backslash = 0;\n-\n-\t  /* There is an added complication when an arg with embedded white\n-\t     space ends in a backslash (such as in the case of -iprefix arg\n-\t     passed to cpp). The resulting quoted strings gets misinterpreted\n-\t     by the command interpreter -- it thinks that the ending quote\n-\t     is escaped by the trailing backslash and things get confused.\n-\t     We handle this case by escaping the trailing backslash, provided\n-\t     it was not escaped in the first place.  */\n-\t  if (len > 1\n-\t      && argv[i][len-1] == '\\\\'\n-\t      && argv[i][len-2] != '\\\\')\n-\t    {\n-\t      trailing_backslash = 1;\n-\t      ++len;\t\t\t/* to escape the final backslash. */\n-\t    }\n-\n-\t  len += 2;\t\t\t/* and for the enclosing quotes. */\n-\n-\t  temp = XNEWVEC (char, len + 1);\n-\t  temp[0] = '\"';\n-\t  strcpy (temp + 1, argv[i]);\n-\t  if (trailing_backslash)\n-\t    temp[len - 2] = '\\\\';\n-\t  temp[len - 1] = '\"';\n-\t  temp[len] = '\\0';\n-\n-\t  free (argv[i]);\n-\t  argv[i] = temp;\n-\t}\n-    }\n-\n-  return (const char * const *) argv;\n-}\n-\n static int pex_win32_open_read (struct pex_obj *, const char *, int);\n static int pex_win32_open_write (struct pex_obj *, const char *, int);\n static long pex_win32_exec_child (struct pex_obj *, int, const char *,\n@@ -422,8 +314,225 @@ msys_rootify (const char *executable)\n }\n #endif\n \n+/* Return a Windows command-line from ARGV.  It is the caller's\n+   responsibility to free the string returned.  */\n+\n+static char *\n+argv_to_cmdline (char *const *argv)\n+{\n+  char *cmdline;\n+  char *p;\n+  size_t cmdline_len;\n+  int i, j, k;\n+\n+  cmdline_len = 0;\n+  for (i = 0; argv[i]; i++)\n+    {\n+      /* We quote every last argument.  This simplifies the problem;\n+\t we need only escape embedded double-quotes and immediately\n+\t preceeding backslash characters.  A sequence of backslach characters\n+\t that is not follwed by a double quote character will not be\n+\t escaped.  */\n+      for (j = 0; argv[i][j]; j++)\n+\t{\n+\t  if (argv[i][j] == '\"')\n+\t    {\n+\t      /* Escape preceeding backslashes.  */\n+\t      for (k = j - 1; k >= 0 && argv[i][k] == '\\\\'; k--)\n+\t\tcmdline_len++;\n+\t      /* Escape the qote character.  */\n+\t      cmdline_len++;\n+\t    }\n+\t}\n+      /* Trailing backslashes also need to be escaped because they will be\n+         followed by the terminating quote.  */\n+      for (k = j - 1; k >= 0 && argv[i][k] == '\\\\'; k--)\n+\tcmdline_len++;\n+      cmdline_len += j;\n+      cmdline_len += 3;  /* for leading and trailing quotes and space */\n+    }\n+  cmdline = xmalloc (cmdline_len);\n+  p = cmdline;\n+  for (i = 0; argv[i]; i++)\n+    {\n+      *p++ = '\"';\n+      for (j = 0; argv[i][j]; j++)\n+\t{\n+\t  if (argv[i][j] == '\"')\n+\t    {\n+\t      for (k = j - 1; k >= 0 && argv[i][k] == '\\\\'; k--)\n+\t\t*p++ = '\\\\';\n+\t      *p++ = '\\\\';\n+\t    }\n+\t  *p++ = argv[i][j];\n+\t}\n+      for (k = j - 1; k >= 0 && argv[i][k] == '\\\\'; k--)\n+\t*p++ = '\\\\';\n+      *p++ = '\"';\n+      *p++ = ' ';\n+    }\n+  p[-1] = '\\0';\n+  return cmdline;\n+}\n+\n+static const char *const\n+std_suffixes[] = {\n+  \".com\",\n+  \".exe\",\n+  \".bat\",\n+  \".cmd\",\n+  0\n+};\n+static const char *const\n+no_suffixes[] = {\n+  \"\",\n+  0\n+};\n+\n+/* Returns the full path to PROGRAM.  If SEARCH is true, look for\n+   PROGRAM in each directory in PATH.  */\n+\n+static char *\n+find_executable (const char *program, BOOL search)\n+{\n+  char *full_executable;\n+  char *e;\n+  size_t fe_len;\n+  const char *path = 0;\n+  const char *const *ext;\n+  const char *p, *q;\n+  size_t proglen = strlen (program);\n+  int has_extension = !!strchr (program, '.');\n+  int has_slash = (strchr (program, '/') || strchr (program, '\\\\'));\n+  HANDLE h;\n+\n+  if (has_slash)\n+    search = FALSE;\n+\n+  if (search)\n+    path = getenv (\"PATH\");\n+  if (!path)\n+    path = \"\";\n+\n+  fe_len = 0;\n+  for (p = path; *p; p = q)\n+    {\n+      q = p;\n+      while (*q != ';' && *q != '\\0')\n+\tq++;\n+      if ((size_t)(q - p) > fe_len)\n+\tfe_len = q - p;\n+      if (*q == ';')\n+\tq++;\n+    }\n+  fe_len = fe_len + 1 + proglen + (has_extension ? 1 : 5);\n+  full_executable = xmalloc (fe_len);\n+\n+  p = path;\n+  do\n+    {\n+      q = p;\n+      while (*q != ';' && *q != '\\0')\n+\tq++;\n+\n+      e = full_executable;\n+      memcpy (e, p, q - p);\n+      e += (q - p);\n+      if (q - p)\n+\t*e++ = '\\\\';\n+      strcpy (e, program);\n+\n+      if (*q == ';')\n+\tq++;\n+\n+      for (e = full_executable; *e; e++)\n+\tif (*e == '/')\n+\t  *e = '\\\\';\n+\n+      /* At this point, e points to the terminating NUL character for\n+         full_executable.  */\n+      for (ext = has_extension ? no_suffixes : std_suffixes; *ext; ext++)\n+\t{\n+\t  /* Remove any current extension.  */\n+\t  *e = '\\0';\n+\t  /* Add the new one.  */\n+\t  strcat (full_executable, *ext);\n+\n+\t  /* Attempt to open this file.  */\n+\t  h = CreateFile (full_executable, GENERIC_READ,\n+\t\t\t  FILE_SHARE_READ | FILE_SHARE_WRITE,\n+\t\t\t  0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n+\t  if (h != INVALID_HANDLE_VALUE)\n+\t    goto found;\n+\t}\n+      p = q;\n+    }\n+  while (*p);\n+  free (full_executable);\n+  return 0;\n+\n+ found:\n+  CloseHandle (h);\n+  return full_executable;\n+}\n+\n+/* Low-level process creation function.  */\n+\n+static long\n+win32_spawn (const char *executable,\n+\t     BOOL search,\n+\t     char *const *argv,\n+\t     DWORD dwCreationFlags,\n+\t     LPSTARTUPINFO si,\n+\t     LPPROCESS_INFORMATION pi)\n+{\n+  char *full_executable;\n+  char *cmdline;\n+\n+  full_executable = NULL;\n+  cmdline = NULL;\n+\n+  full_executable = find_executable (executable, search);\n+  if (!full_executable)\n+    goto error;\n+  cmdline = argv_to_cmdline (argv);\n+  if (!cmdline)\n+    goto error;\n+    \n+  /* Create the child process.  */  \n+  if (!CreateProcess (full_executable, cmdline, \n+\t\t      /*lpProcessAttributes=*/NULL,\n+\t\t      /*lpThreadAttributes=*/NULL,\n+\t\t      /*bInheritHandles=*/TRUE,\n+\t\t      dwCreationFlags,\n+\t\t      /*lpEnvironment=*/NULL,\n+\t\t      /*lpCurrentDirectory=*/NULL,\n+\t\t      si,\n+\t\t      pi))\n+    {\n+      free (full_executable);\n+      return -1;\n+    }\n+\n+  /* Clean up.  */\n+  CloseHandle (pi->hThread);\n+  free (full_executable);\n+\n+  return (long) pi->hProcess;\n+\n+ error:\n+  if (cmdline)\n+    free (cmdline);\n+  if (full_executable)\n+    free (full_executable);\n+  return -1;\n+}\n+\n static long\n-spawn_script (const char *executable, const char * const * argv)\n+spawn_script (const char *executable, char *const *argv,\n+\t      DWORD dwCreationFlags,\n+\t      LPSTARTUPINFO si,\n+\t      LPPROCESS_INFORMATION pi)\n {\n   int pid = -1;\n   int save_errno = errno;\n@@ -455,17 +564,21 @@ spawn_script (const char *executable, const char * const * argv)\n \t      executable = strrchr (executable1, '\\\\') + 1;\n \t      if (!executable)\n \t\texecutable = executable1;\n-\t      pid = _spawnvp (_P_NOWAIT, executable, argv);\n+\t      pid = win32_spawn (executable, TRUE, argv, \n+\t\t\t\t dwCreationFlags, si, pi);\n #else\n \t      if (strchr (executable1, '\\\\') == NULL)\n-\t\tpid = _spawnvp (_P_NOWAIT, executable1, argv);\n+\t\tpid = win32_spawn (executable1, TRUE, argv, \n+\t\t\t\t   dwCreationFlags, si, pi);\n \t      else if (executable1[0] != '\\\\')\n-\t\tpid = _spawnv (_P_NOWAIT, executable1, argv);\n+\t\tpid = win32_spawn (executable1, FALSE, argv, \n+\t\t\t\t   dwCreationFlags, si, pi);\n \t      else\n \t\t{\n \t\t  const char *newex = mingw_rootify (executable1);\n \t\t  *avhere = newex;\n-\t\t  pid = _spawnv (_P_NOWAIT, newex, argv);\n+\t\t  pid = win32_spawn (newex, FALSE, argv, \n+\t\t\t\t     dwCreationFlags, si, pi);\n \t\t  if (executable1 != newex)\n \t\t    free ((char *) newex);\n \t\t  if (pid < 0)\n@@ -474,7 +587,8 @@ spawn_script (const char *executable, const char * const * argv)\n \t\t      if (newex != executable1)\n \t\t\t{\n \t\t\t  *avhere = newex;\n-\t\t\t  pid = _spawnv (_P_NOWAIT, newex, argv);\n+\t\t\t  pid = win32_spawn (newex, FALSE, argv, \n+\t\t\t\t\t     dwCreationFlags, si, pi);\n \t\t\t  free ((char *) newex);\n \t\t\t}\n \t\t    }\n@@ -496,149 +610,95 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n \t\t      int in, int out, int errdes, const char **errmsg,\n \t\t      int *err)\n {\n-  int org_in, org_out, org_errdes;\n   long pid;\n-  const char * const * newargv;\n-\n-  org_in = -1;\n-  org_out = -1;\n-  org_errdes = -1;\n-\n-  if (in != STDIN_FILE_NO)\n-    {\n-      org_in = _dup (STDIN_FILE_NO);\n-      if (org_in < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup\";\n-\t  return -1;\n-\t}\n-      if (_dup2 (in, STDIN_FILE_NO) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup2\";\n-\t  return -1;\n-\t}\n-      if (_close (in) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_close\";\n-\t  return -1;\n-\t}\n-    }\n-\n-  if (out != STDOUT_FILE_NO)\n-    {\n-      org_out = _dup (STDOUT_FILE_NO);\n-      if (org_out < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup\";\n-\t  return -1;\n-\t}\n-      if (_dup2 (out, STDOUT_FILE_NO) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup2\";\n-\t  return -1;\n-\t}\n-      if (_close (out) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_close\";\n-\t  return -1;\n-\t}\n-    }\n-\n-  if (errdes != STDERR_FILE_NO\n-      || (flags & PEX_STDERR_TO_STDOUT) != 0)\n+  HANDLE stdin_handle;\n+  HANDLE stdout_handle;\n+  HANDLE stderr_handle;\n+  DWORD dwCreationFlags;\n+  OSVERSIONINFO version_info;\n+  STARTUPINFO si;\n+  PROCESS_INFORMATION pi;\n+\n+  stdin_handle = INVALID_HANDLE_VALUE;\n+  stdout_handle = INVALID_HANDLE_VALUE;\n+  stderr_handle = INVALID_HANDLE_VALUE;\n+\n+  stdin_handle = (HANDLE) _get_osfhandle (in);\n+  stdout_handle = (HANDLE) _get_osfhandle (out);\n+  if (!(flags & PEX_STDERR_TO_STDOUT))\n+    stderr_handle = (HANDLE) _get_osfhandle (errdes);\n+  else\n+    stderr_handle = stdout_handle;\n+\n+  /* Determine the version of Windows we are running on.  */\n+  version_info.dwOSVersionInfoSize = sizeof (version_info); \n+  GetVersionEx (&version_info);\n+  if (version_info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)\n+    /* On Windows 95/98/ME the CREATE_NO_WINDOW flag is not\n+       supported, so we cannot avoid creating a console window.  */\n+    dwCreationFlags = 0;\n+  else\n     {\n-      org_errdes = _dup (STDERR_FILE_NO);\n-      if (org_errdes < 0)\n+      HANDLE conout_handle;\n+\n+      /* Determine whether or not we have an associated console.  */\n+      conout_handle = CreateFile(\"CONOUT$\", \n+\t\t\t\t GENERIC_WRITE,\n+\t\t\t\t FILE_SHARE_WRITE,\n+\t\t\t\t /*lpSecurityAttributes=*/NULL,\n+\t\t\t\t OPEN_EXISTING,\n+\t\t\t\t FILE_ATTRIBUTE_NORMAL,\n+\t\t\t\t /*hTemplateFile=*/NULL);\n+      if (conout_handle == INVALID_HANDLE_VALUE)\n+\t/* There is no console associated with this process.  Since\n+\t   the child is a console process, the OS would normally\n+\t   create a new console Window for the child.  Since we'll be\n+\t   redirecting the child's standard streams, we do not need\n+\t   the console window.  */ \n+\tdwCreationFlags = CREATE_NO_WINDOW;\n+      else \n \t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup\";\n-\t  return -1;\n-\t}\n-      if (_dup2 ((flags & PEX_STDERR_TO_STDOUT) != 0 ? STDOUT_FILE_NO : errdes,\n-\t\t STDERR_FILE_NO) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup2\";\n-\t  return -1;\n-\t}\n-      if (errdes != STDERR_FILE_NO)\n-\t{\n-\t  if (_close (errdes) < 0)\n-\t    {\n-\t      *err = errno;\n-\t      *errmsg = \"_close\";\n-\t      return -1;\n-\t    }\n+\t  /* There is a console associated with the process, so the OS\n+\t     will not create a new console.  And, if we use\n+\t     CREATE_NO_WINDOW in this situation, the child will have\n+\t     no associated console.  Therefore, if the child's\n+\t     standard streams are connected to the console, the output\n+\t     will be discarded.  */\n+\t  CloseHandle(conout_handle);\n+\t  dwCreationFlags = 0;\n \t}\n     }\n \n-  newargv = fix_argv (argv);\n-  pid = (((flags & PEX_SEARCH) != 0 ? _spawnvp : _spawnv)\n-\t (_P_NOWAIT, executable, newargv));\n-\n+  /* Since the child will be a console process, it will, by default,\n+     connect standard input/output to its console.  However, we want\n+     the child to use the handles specifically designated above.  In\n+     addition, if there is no console (such as when we are running in\n+     a Cygwin X window), then we must redirect the child's\n+     input/output, as there is no console for the child to use.  */\n+  memset (&si, 0, sizeof (si));\n+  si.cb = sizeof (si);\n+  si.dwFlags = STARTF_USESTDHANDLES;\n+  si.hStdInput = stdin_handle;\n+  si.hStdOutput = stdout_handle;\n+  si.hStdError = stderr_handle;\n+\n+  /* Create the child process.  */  \n+  pid = win32_spawn (executable, (flags & PEX_SEARCH) != 0,\n+\t\t     argv, dwCreationFlags, &si, &pi);\n   if (pid == -1)\n-    pid = spawn_script (executable, newargv);\n-\n+    pid = spawn_script (executable, argv, dwCreationFlags, &si, &pi);\n   if (pid == -1)\n     {\n-      *err = errno;\n-      *errmsg = ((flags & PEX_SEARCH) != 0) ? \"_spawnvp\" : \"_spawnv\";\n+      *err = ENOENT;\n+      *errmsg = \"CreateProcess\";\n     }\n \n-  if (in != STDIN_FILE_NO)\n-    {\n-      if (_dup2 (org_in, STDIN_FILE_NO) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup2\";\n-\t  return -1;\n-\t}\n-      if (_close (org_in) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_close\";\n-\t  return -1;\n-\t}\n-    }\n-\n-  if (out != STDOUT_FILE_NO)\n-    {\n-      if (_dup2 (org_out, STDOUT_FILE_NO) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup2\";\n-\t  return -1;\n-\t}\n-      if (_close (org_out) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_close\";\n-\t  return -1;\n-\t}\n-    }\n-\n-  if (errdes != STDERR_FILE_NO\n-      || (flags & PEX_STDERR_TO_STDOUT) != 0)\n-    {\n-      if (_dup2 (org_errdes, STDERR_FILE_NO) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_dup2\";\n-\t  return -1;\n-\t}\n-      if (_close (org_errdes) < 0)\n-\t{\n-\t  *err = errno;\n-\t  *errmsg = \"_close\";\n-\t  return -1;\n-\t}\n-    }\n+  /* Close the standard output and standard error handles in the\n+     parent.  */ \n+  if (out != STDOUT_FILENO)\n+    obj->funcs->close (obj, out);\n+  if (errdes != STDERR_FILENO)\n+    obj->funcs->close (obj, errdes);\n \n   return pid;\n }\n@@ -656,30 +716,34 @@ pex_win32_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, long pid,\n \t\tint *status, struct pex_time *time, int done ATTRIBUTE_UNUSED,\n \t\tconst char **errmsg, int *err)\n {\n-  int termstat;\n+  DWORD termstat;\n+  HANDLE h;\n \n   if (time != NULL)\n     memset (time, 0, sizeof *time);\n \n+  h = (HANDLE) pid;\n+\n   /* FIXME: If done is non-zero, we should probably try to kill the\n      process.  */\n-\n-  if (_cwait (&termstat, pid, WAIT_CHILD) < 0)\n+  if (WaitForSingleObject (h, INFINITE) != WAIT_OBJECT_0)\n     {\n-      *err = errno;\n-      *errmsg = \"_cwait\";\n+      CloseHandle (h);\n+      *err = ECHILD;\n+      *errmsg = \"WaitForSingleObject\";\n       return -1;\n     }\n \n-  /* cwait returns the child process exit code in termstat.  A value\n-     of 3 indicates that the child caught a signal, but not which one.\n-     Since only SIGABRT, SIGFPE and SIGINT do anything, we report\n-     SIGABRT.  */\n-\n+  GetExitCodeProcess (h, &termstat);\n+  CloseHandle (h);\n+ \n+  /* A value of 3 indicates that the child caught a signal, but not\n+     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we\n+     report SIGABRT.  */\n   if (termstat == 3)\n     *status = SIGABRT;\n   else\n-    *status = ((termstat & 0xff) << 8);\n+    *status = (termstat & 0xff) << 8;\n \n   return 0;\n }"}]}