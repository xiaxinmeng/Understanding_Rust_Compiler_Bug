{"sha": "3f84bf08c48ea4e037a74f1122c6420ce557518d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4NGJmMDhjNDhlYTRlMDM3YTc0ZjExMjJjNjQyMGNlNTU3NTE4ZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-08-07T00:51:34Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-08-07T00:51:34Z"}, "message": "ipa-prop.c (count_formal_params_1): New function.\n\n2009-08-07  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (count_formal_params_1): New function.\n\t(ipa_get_vector_of_formal_parms): New function.\n\t(get_vector_of_formal_parm_types): New function.\n\t(ipa_modify_formal_parameters): New function.\n\t(ipa_modify_call_arguments): New function.\n\t(index_in_adjustments_multiple_times_p): New function.\n\t(ipa_combine_adjustments): New function.\n\t(ipa_dump_param_adjustments): New function.\n\n\t* ipa-prop.h (struct ipa_parm_adjustment): New type.\n\t(ipa_get_vector_of_formal_parms): Declare.\n\t(ipa_modify_formal_parameters): Declare.\n\t(ipa_modify_call_arguments): Declare.\n\t(ipa_combine_adjustments): Declare.\n\t(ipa_dump_param_adjustments): Declare.\n\t(build_ref_for_offset): Declare.\n\n\t* Makefile.in (tree-sra.o): Add ipa-prop.h to dependencies.\n\n\t* tree-sra.c: Include ipa-prop.c.\n\t(build_ref_for_offset): Make public.\n\nFrom-SVN: r150551", "tree": {"sha": "e32de0fb2f6c7763918d428281ac22fa32a5626e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e32de0fb2f6c7763918d428281ac22fa32a5626e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f84bf08c48ea4e037a74f1122c6420ce557518d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f84bf08c48ea4e037a74f1122c6420ce557518d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f84bf08c48ea4e037a74f1122c6420ce557518d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f84bf08c48ea4e037a74f1122c6420ce557518d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26ba353ea7d38958f52a7282c18ed08acf5cd29e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ba353ea7d38958f52a7282c18ed08acf5cd29e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ba353ea7d38958f52a7282c18ed08acf5cd29e"}], "stats": {"total": 573, "additions": 562, "deletions": 11}, "files": [{"sha": "75129f68720514df9dde1f02f5967661c0083c93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f84bf08c48ea4e037a74f1122c6420ce557518d", "patch": "@@ -1,3 +1,24 @@\n+2009-08-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (count_formal_params_1): New function.\n+\t(ipa_get_vector_of_formal_parms): New function.\n+\t(get_vector_of_formal_parm_types): New function.\n+\t(ipa_modify_formal_parameters): New function.\n+\t(ipa_modify_call_arguments): New function.\n+\t(index_in_adjustments_multiple_times_p): New function.\n+\t(ipa_combine_adjustments): New function.\n+\t(ipa_dump_param_adjustments): New function.\n+\t* ipa-prop.h (struct ipa_parm_adjustment): New type.\n+\t(ipa_get_vector_of_formal_parms): Declare.\n+\t(ipa_modify_formal_parameters): Declare.\n+\t(ipa_modify_call_arguments): Declare.\n+\t(ipa_combine_adjustments): Declare.\n+\t(ipa_dump_param_adjustments): Declare.\n+\t(build_ref_for_offset): Declare.\n+\t* Makefile.in (tree-sra.o): Add ipa-prop.h to dependencies.\n+\t* tree-sra.c: Include ipa-prop.c.\n+\t(build_ref_for_offset): Make public. \n+\n 2009-08-06  Thomas Schwinge  <tschwinge@gnu.org>\n \n \t* gcc/doc/extend.texi (__builtin_extract_return_address)"}, {"sha": "dd52a037cb51bea680fd58f985184ded8a5daab9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3f84bf08c48ea4e037a74f1122c6420ce557518d", "patch": "@@ -2887,8 +2887,8 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h \\\n    tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(TOPLEV_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \\\n-   $(TM_H) $(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) statistics.h \\\n-   $(TREE_DUMP_H) $(TIMEVAR_H) $(PARAMS_H) $(TARGET_H) $(FLAGS_H)\n+   $(TM_H) $(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n+   statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) $(PARAMS_H) $(TARGET_H) $(FLAGS_H)\n tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n     $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \\"}, {"sha": "fcc4f70435c70941fb3bac9ac8bacb8324059c8e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 466, "deletions": 8, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3f84bf08c48ea4e037a74f1122c6420ce557518d", "patch": "@@ -142,23 +142,30 @@ ipa_populate_param_decls (struct cgraph_node *node,\n     }\n }\n \n+/* Return how many formal parameters FNDECL has.  */\n+\n+static inline int\n+count_formal_params_1 (tree fndecl)\n+{\n+  tree parm;\n+  int count = 0;\n+\n+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n+    count++;\n+\n+  return count;\n+}\n+\n /* Count number of formal parameters in NOTE. Store the result to the\n    appropriate field of INFO.  */\n \n static void\n ipa_count_formal_params (struct cgraph_node *node,\n \t\t\t struct ipa_node_params *info)\n {\n-  tree fndecl;\n-  tree fnargs;\n-  tree parm;\n   int param_num;\n \n-  fndecl = node->decl;\n-  fnargs = DECL_ARGUMENTS (fndecl);\n-  param_num = 0;\n-  for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n-    param_num++;\n+  param_num = count_formal_params_1 (node->decl);\n   ipa_set_param_count (info, param_num);\n }\n \n@@ -1303,3 +1310,454 @@ ipa_print_all_params (FILE * f)\n   for (node = cgraph_nodes; node; node = node->next)\n     ipa_print_node_params (f, node);\n }\n+\n+/* Return a heap allocated vector containing formal parameters of FNDECL.  */\n+\n+VEC(tree, heap) *\n+ipa_get_vector_of_formal_parms (tree fndecl)\n+{\n+  VEC(tree, heap) *args;\n+  int count;\n+  tree parm;\n+\n+  count = count_formal_params_1 (fndecl);\n+  args = VEC_alloc (tree, heap, count);\n+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n+    VEC_quick_push (tree, args, parm);\n+\n+  return args;\n+}\n+\n+/* Return a heap allocated vector containing types of formal parameters of\n+   function type FNTYPE.  */\n+\n+static inline VEC(tree, heap) *\n+get_vector_of_formal_parm_types (tree fntype)\n+{\n+  VEC(tree, heap) *types;\n+  int count = 0;\n+  tree t;\n+\n+  for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n+    count++;\n+\n+  types = VEC_alloc (tree, heap, count);\n+  for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n+    VEC_quick_push (tree, types, TREE_VALUE (t));\n+\n+  return types;\n+}\n+\n+/* Modify the function declaration FNDECL and its type according to the plan in\n+   ADJUSTMENTS.  It also sets base fields of individual adjustments structures\n+   to reflect the actual parameters being modified which are determined by the\n+   base_index field.  */\n+\n+void\n+ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n+\t\t\t      const char *synth_parm_prefix)\n+{\n+  VEC(tree, heap) *oparms, *otypes;\n+  tree orig_type, new_type = NULL;\n+  tree old_arg_types, t, new_arg_types = NULL;\n+  tree parm, *link = &DECL_ARGUMENTS (fndecl);\n+  int i, len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+  tree new_reversed = NULL;\n+  bool care_for_types, last_parm_void;\n+\n+  if (!synth_parm_prefix)\n+    synth_parm_prefix = \"SYNTH\";\n+\n+  oparms = ipa_get_vector_of_formal_parms (fndecl);\n+  orig_type = TREE_TYPE (fndecl);\n+  old_arg_types = TYPE_ARG_TYPES (orig_type);\n+\n+  /* The following test is an ugly hack, some functions simply don't have any\n+     arguments in their type.  This is probably a bug but well... */\n+  care_for_types = (old_arg_types != NULL_TREE);\n+  if (care_for_types)\n+    {\n+      last_parm_void = (TREE_VALUE (tree_last (old_arg_types))\n+\t\t\t== void_type_node);\n+      otypes = get_vector_of_formal_parm_types (orig_type);\n+      if (last_parm_void)\n+\tgcc_assert (VEC_length (tree, oparms) + 1 == VEC_length (tree, otypes));\n+      else\n+\tgcc_assert (VEC_length (tree, oparms) == VEC_length (tree, otypes));\n+    }\n+  else\n+    {\n+      last_parm_void = false;\n+      otypes = NULL;\n+    }\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      gcc_assert (link);\n+\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      parm = VEC_index (tree, oparms, adj->base_index);\n+      adj->base = parm;\n+\n+      if (adj->copy_param)\n+\t{\n+\t  if (care_for_types)\n+\t    new_arg_types = tree_cons (NULL_TREE, VEC_index (tree, otypes,\n+\t\t\t\t\t\t\t     adj->base_index),\n+\t\t\t\t       new_arg_types);\n+\t  *link = parm;\n+\t  link = &TREE_CHAIN (parm);\n+\t}\n+      else if (!adj->remove_param)\n+\t{\n+\t  tree new_parm;\n+\t  tree ptype;\n+\n+\t  if (adj->by_ref)\n+\t    ptype = build_pointer_type (adj->type);\n+\t  else\n+\t    ptype = adj->type;\n+\n+\t  if (care_for_types)\n+\t    new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n+\n+\t  new_parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE,\n+\t\t\t\t ptype);\n+\t  DECL_NAME (new_parm) = create_tmp_var_name (synth_parm_prefix);\n+\n+\t  DECL_ARTIFICIAL (new_parm) = 1;\n+\t  DECL_ARG_TYPE (new_parm) = ptype;\n+\t  DECL_CONTEXT (new_parm) = fndecl;\n+\t  TREE_USED (new_parm) = 1;\n+\t  DECL_IGNORED_P (new_parm) = 1;\n+\t  layout_decl (new_parm, 0);\n+\n+\t  add_referenced_var (new_parm);\n+\t  mark_sym_for_renaming (new_parm);\n+\t  adj->base = parm;\n+\t  adj->reduction = new_parm;\n+\n+\t  *link = new_parm;\n+\n+\t  link = &TREE_CHAIN (new_parm);\n+\t}\n+    }\n+\n+  *link = NULL_TREE;\n+\n+  if (care_for_types)\n+    {\n+      new_reversed = nreverse (new_arg_types);\n+      if (last_parm_void)\n+\t{\n+\t  if (new_reversed)\n+\t    TREE_CHAIN (new_arg_types) = void_list_node;\n+\t  else\n+\t    new_reversed = void_list_node;\n+\t}\n+    }\n+\n+  /* Use copy_node to preserve as much as possible from original type\n+     (debug info, attribute lists etc.)\n+     Exception is METHOD_TYPEs must have THIS argument.\n+     When we are asked to remove it, we need to build new FUNCTION_TYPE\n+     instead.  */\n+  if (TREE_CODE (orig_type) != METHOD_TYPE\n+       || (VEC_index (ipa_parm_adjustment_t, adjustments, 0)->copy_param\n+\t && VEC_index (ipa_parm_adjustment_t, adjustments, 0)->base_index == 0))\n+    {\n+      new_type = copy_node (orig_type);\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+    }\n+  else\n+    {\n+      new_type\n+        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n+\t\t\t\t\t\t\t new_reversed));\n+      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n+      DECL_VINDEX (fndecl) = NULL_TREE;\n+    }\n+\n+  /* This is a new type, not a copy of an old type.  Need to reassociate\n+     variants.  We can handle everything except the main variant lazily.  */\n+  t = TYPE_MAIN_VARIANT (orig_type);\n+  if (orig_type != t)\n+    {\n+      TYPE_MAIN_VARIANT (new_type) = t;\n+      TYPE_NEXT_VARIANT (new_type) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = new_type;\n+    }\n+  else\n+    {\n+      TYPE_MAIN_VARIANT (new_type) = new_type;\n+      TYPE_NEXT_VARIANT (new_type) = NULL;\n+    }\n+\n+  TREE_TYPE (fndecl) = new_type;\n+  if (otypes)\n+    VEC_free (tree, heap, otypes);\n+  VEC_free (tree, heap, oparms);\n+}\n+\n+/* Modify actual arguments of a function call CS as indicated in ADJUSTMENTS.\n+   If this is a directly recursive call, CS must be NULL.  Otherwise it must\n+   contain the corresponding call graph edge.  */\n+\n+void\n+ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n+\t\t\t   ipa_parm_adjustment_vec adjustments)\n+{\n+  VEC(tree, heap) *vargs;\n+  gimple new_stmt;\n+  gimple_stmt_iterator gsi;\n+  tree callee_decl;\n+  int i, len;\n+\n+  len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+  vargs = VEC_alloc (tree, heap, len);\n+\n+  gsi = gsi_for_stmt (stmt);\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+\n+      if (adj->copy_param)\n+\t{\n+\t  tree arg = gimple_call_arg (stmt, adj->base_index);\n+\n+\t  VEC_quick_push (tree, vargs, arg);\n+\t}\n+      else if (!adj->remove_param)\n+\t{\n+\t  tree expr, orig_expr;\n+\t  bool allow_ptr, repl_found;\n+\n+\t  orig_expr = expr = gimple_call_arg (stmt, adj->base_index);\n+\t  if (TREE_CODE (expr) == ADDR_EXPR)\n+\t    {\n+\t      allow_ptr = false;\n+\t      expr = TREE_OPERAND (expr, 0);\n+\t    }\n+\t  else\n+\t    allow_ptr = true;\n+\n+\t  repl_found = build_ref_for_offset (&expr, TREE_TYPE (expr),\n+\t\t\t\t\t     adj->offset, adj->type,\n+\t\t\t\t\t     allow_ptr);\n+\t  if (repl_found)\n+\t    {\n+\t      if (adj->by_ref)\n+\t\texpr = build_fold_addr_expr (expr);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree ptrtype = build_pointer_type (adj->type);\n+\t      expr = orig_expr;\n+\t      if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n+\t\texpr = build_fold_addr_expr (expr);\n+\t      if (!useless_type_conversion_p (ptrtype, TREE_TYPE (expr)))\n+\t\texpr = fold_convert (ptrtype, expr);\n+\t      expr = fold_build2 (POINTER_PLUS_EXPR, ptrtype, expr,\n+\t\t\t\t  build_int_cst (size_type_node,\n+\t\t\t\t\t\t adj->offset / BITS_PER_UNIT));\n+\t      if (!adj->by_ref)\n+\t\texpr = fold_build1 (INDIRECT_REF, adj->type, expr);\n+\t    }\n+\t  expr = force_gimple_operand_gsi (&gsi, expr,\n+\t\t\t\t\t   adj->by_ref\n+\t\t\t\t\t   || is_gimple_reg_type (adj->type),\n+\t\t\t\t\t   NULL, true, GSI_SAME_STMT);\n+\t  VEC_quick_push (tree, vargs, expr);\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"replacing stmt:\");\n+      print_gimple_stmt (dump_file, gsi_stmt (gsi), 0, 0);\n+    }\n+\n+  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n+  new_stmt = gimple_build_call_vec (callee_decl, vargs);\n+  VEC_free (tree, heap, vargs);\n+  if (gimple_call_lhs (stmt))\n+    gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n+\n+  gimple_set_block (new_stmt, gimple_block (stmt));\n+  if (gimple_has_location (stmt))\n+    gimple_set_location (new_stmt, gimple_location (stmt));\n+  gimple_call_copy_flags (new_stmt, stmt);\n+  gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"with stmt:\");\n+      print_gimple_stmt (dump_file, new_stmt, 0, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  gsi_replace (&gsi, new_stmt, true);\n+  if (cs)\n+    cgraph_set_call_stmt (cs, new_stmt);\n+  update_ssa (TODO_update_ssa);\n+  free_dominance_info (CDI_DOMINATORS);\n+}\n+\n+/* Return true iff BASE_INDEX is in ADJUSTMENTS more than once.  */\n+\n+static bool\n+index_in_adjustments_multiple_times_p (int base_index,\n+\t\t\t\t       ipa_parm_adjustment_vec adjustments)\n+{\n+  int i, len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+  bool one = false;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+\n+      if (adj->base_index == base_index)\n+\t{\n+\t  if (one)\n+\t    return true;\n+\t  else\n+\t    one = true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+\n+/* Return adjustments that should have the same effect on function parameters\n+   and call arguments as if they were first changed according to adjustments in\n+   INNER and then by adjustments in OUTER.  */\n+\n+ipa_parm_adjustment_vec\n+ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n+\t\t\t ipa_parm_adjustment_vec outer)\n+{\n+  int i, outlen = VEC_length (ipa_parm_adjustment_t, outer);\n+  int inlen = VEC_length (ipa_parm_adjustment_t, inner);\n+  int removals = 0;\n+  ipa_parm_adjustment_vec adjustments, tmp;\n+\n+  tmp = VEC_alloc (ipa_parm_adjustment_t, heap, inlen);\n+  for (i = 0; i < inlen; i++)\n+    {\n+      struct ipa_parm_adjustment *n;\n+      n = VEC_index (ipa_parm_adjustment_t, inner, i);\n+\n+      if (n->remove_param)\n+\tremovals++;\n+      else\n+\tVEC_quick_push (ipa_parm_adjustment_t, tmp, n);\n+    }\n+\n+  adjustments = VEC_alloc (ipa_parm_adjustment_t, heap, outlen + removals);\n+  for (i = 0; i < outlen; i++)\n+    {\n+      struct ipa_parm_adjustment *r;\n+      struct ipa_parm_adjustment *out = VEC_index (ipa_parm_adjustment_t,\n+\t\t\t\t\t\t   outer, i);\n+      struct ipa_parm_adjustment *in = VEC_index (ipa_parm_adjustment_t, tmp,\n+\t\t\t\t\t\t  out->base_index);\n+\n+      gcc_assert (!in->remove_param);\n+      if (out->remove_param)\n+\t{\n+\t  if (!index_in_adjustments_multiple_times_p (in->base_index, tmp))\n+\t    {\n+\t      r = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n+\t      memset (r, 0, sizeof (*r));\n+\t      r->remove_param = true;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      r = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n+      memset (r, 0, sizeof (*r));\n+      r->base_index = in->base_index;\n+      r->type = out->type;\n+\n+      /* FIXME:  Create nonlocal value too.  */\n+\n+      if (in->copy_param && out->copy_param)\n+\tr->copy_param = true;\n+      else if (in->copy_param)\n+\tr->offset = out->offset;\n+      else if (out->copy_param)\n+\tr->offset = in->offset;\n+      else\n+\tr->offset = in->offset + out->offset;\n+    }\n+\n+  for (i = 0; i < inlen; i++)\n+    {\n+      struct ipa_parm_adjustment *n = VEC_index (ipa_parm_adjustment_t,\n+\t\t\t\t\t\t inner, i);\n+\n+      if (n->remove_param)\n+\tVEC_quick_push (ipa_parm_adjustment_t, adjustments, n);\n+    }\n+\n+  VEC_free (ipa_parm_adjustment_t, heap, tmp);\n+  return adjustments;\n+}\n+\n+/* Dump the adjustments in the vector ADJUSTMENTS to dump_file in a human\n+   friendly way, assuming they are meant to be applied to FNDECL.  */\n+\n+void\n+ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n+\t\t\t    tree fndecl)\n+{\n+  int i, len = VEC_length (ipa_parm_adjustment_t, adjustments);\n+  bool first = true;\n+  VEC(tree, heap) *parms = ipa_get_vector_of_formal_parms (fndecl);\n+\n+  fprintf (file, \"IPA param adjustments: \");\n+  for (i = 0; i < len; i++)\n+    {\n+      struct ipa_parm_adjustment *adj;\n+      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+\n+      if (!first)\n+\tfprintf (file, \"                 \");\n+      else\n+\tfirst = false;\n+\n+      fprintf (file, \"%i. base_index: %i - \", i, adj->base_index);\n+      print_generic_expr (file, VEC_index (tree, parms, adj->base_index), 0);\n+      if (adj->base)\n+\t{\n+\t  fprintf (file, \", base: \");\n+\t  print_generic_expr (file, adj->base, 0);\n+\t}\n+      if (adj->reduction)\n+\t{\n+\t  fprintf (file, \", reduction: \");\n+\t  print_generic_expr (file, adj->reduction, 0);\n+\t}\n+      if (adj->new_ssa_base)\n+\t{\n+\t  fprintf (file, \", new_ssa_base: \");\n+\t  print_generic_expr (file, adj->new_ssa_base, 0);\n+\t}\n+\n+      if (adj->copy_param)\n+\tfprintf (file, \", copy_param\");\n+      else if (adj->remove_param)\n+\tfprintf (file, \", remove_param\");\n+      else\n+\tfprintf (file, \", offset %li\", (long) adj->offset);\n+      if (adj->by_ref)\n+\tfprintf (file, \", by_ref\");\n+      print_node_brief (file, \", type: \", adj->type, 0);\n+      fprintf (file, \"\\n\");\n+    }\n+  VEC_free (tree, heap, parms);\n+}\n+"}, {"sha": "4794f691fba3669c95632a61cf26bc32fcea827f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3f84bf08c48ea4e037a74f1122c6420ce557518d", "patch": "@@ -403,4 +403,75 @@ void ipa_print_all_params (FILE *);\n void ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node);\n void ipa_print_all_jump_functions (FILE * f);\n \n+/* Structure to describe transformations of formal parameters and actual\n+   arguments.  Each instance describes one new parameter and they are meant to\n+   be stored in a vector.  Additionally, most users will probably want to store\n+   adjustments about parameters that are being removed altogether so that SSA\n+   names belonging to them can be replaced by SSA names of an artificial\n+   variable.  */\n+struct ipa_parm_adjustment\n+{\n+  /* The original PARM_DECL itself, helpful for processing of the body of the\n+     function itself.  Intended for traversing function bodies.\n+     ipa_modify_formal_parameters, ipa_modify_call_arguments and\n+     ipa_combine_adjustments ignore this and use base_index.\n+     ipa_modify_formal_parameters actually sets this.  */\n+  tree base;\n+\n+  /* Type of the new parameter.  However, if by_ref is true, the real type will\n+     be a pointer to this type.  */\n+  tree type;\n+\n+  /* The new declaration when creating/replacing a parameter.  Created by\n+     ipa_modify_formal_parameters, useful for functions modifying the body\n+     accordingly. */\n+  tree reduction;\n+\n+  /* New declaration of a substitute variable that we may use to replace all\n+     non-default-def ssa names when a parm decl is going away.  */\n+  tree new_ssa_base;\n+\n+  /* If non-NULL and the original parameter is to be removed (copy_param below\n+     is NULL), this is going to be its nonlocalized vars value.  */\n+  tree nonlocal_value;\n+\n+  /* Offset into the original parameter (for the cases when the new parameter\n+     is a component of an original one).  */\n+  HOST_WIDE_INT offset;\n+\n+  /* Zero based index of the original parameter this one is based on.  (ATM\n+     there is no way to insert a new parameter out of the blue because there is\n+     no need but if it arises the code can be easily exteded to do so.)  */\n+  int base_index;\n+\n+  /* This new parameter is an unmodified parameter at index base_index. */\n+  unsigned copy_param : 1;\n+\n+  /* This adjustment describes a parameter that is about to be removed\n+     completely.  Most users will probably need to book keep those so that they\n+     don't leave behinfd any non default def ssa names belonging to them.  */\n+  unsigned remove_param : 1;\n+\n+  /* The parameter is to be passed by reference.  */\n+  unsigned by_ref : 1;\n+};\n+\n+typedef struct ipa_parm_adjustment ipa_parm_adjustment_t;\n+DEF_VEC_O (ipa_parm_adjustment_t);\n+DEF_VEC_ALLOC_O (ipa_parm_adjustment_t, heap);\n+\n+typedef VEC (ipa_parm_adjustment_t, heap) *ipa_parm_adjustment_vec;\n+\n+VEC(tree, heap) *ipa_get_vector_of_formal_parms (tree fndecl);\n+void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec,\n+\t\t\t\t   const char *);\n+void ipa_modify_call_arguments (struct cgraph_edge *, gimple,\n+\t\t\t\tipa_parm_adjustment_vec);\n+ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n+\t\t\t\t\t\t ipa_parm_adjustment_vec);\n+void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n+\n+/* From tree-sra.c:  */\n+bool build_ref_for_offset (tree *, tree, HOST_WIDE_INT, tree, bool);\n+\n #endif /* IPA_PROP_H */"}, {"sha": "33be0f6aaca6606a340dfc6e93cb90b58b1ec2ad", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f84bf08c48ea4e037a74f1122c6420ce557518d/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=3f84bf08c48ea4e037a74f1122c6420ce557518d", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"tree-flow.h\"\n+#include \"ipa-prop.h\"\n #include \"diagnostic.h\"\n #include \"statistics.h\"\n #include \"tree-dump.h\"\n@@ -1119,7 +1120,7 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n    minor rewrite of fold_stmt.\n  */\n \n-static bool\n+bool\n build_ref_for_offset (tree *expr, tree type, HOST_WIDE_INT offset,\n \t\t      tree exp_type, bool allow_ptr)\n {"}]}