{"sha": "1a291106384cabc73da0bc0f457b1cd3a4015970", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEyOTExMDYzODRjYWJjNzNkYTBiYzBmNDU3YjFjZDNhNDAxNTk3MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-27T22:05:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-27T22:05:53Z"}, "message": "Implement P1814R0, CTAD for alias templates.\n\nThis patch implements C++20 class template argument deduction for alias\ntemplates, which works by a moderately arcane transformation of the\ndeduction guides for the underlying class template.  When implementing it,\nit seemed that I could simplify the rules in the draft a bit and get\nessentially the same effect; I'll be emailing the committee to that effect\nsoon.\n\ngcc/cp/\n\t* pt.c (rewrite_tparm_list): Factor out of build_deduction_guide.\n\t(maybe_aggr_guide): Check for copy-init here.\n\t(alias_ctad_tweaks, deduction_guides_for): New.\n\t(ctor_deduction_guides_for): Factor out of do_class_deduction.\n\t(ctad_template_p): New.\n\t* parser.c (cp_parser_simple_type_specifier): Use it.\n\t* constraint.cc (append_constraint): New.\ngcc/c-family/\n\t* c-cppbuiltin.c (c_cpp_builtins): Update __cpp_deduction_guides.\n\nFrom-SVN: r278786", "tree": {"sha": "3f4b4913ffbd60d6a8230235c945963f61958534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f4b4913ffbd60d6a8230235c945963f61958534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a291106384cabc73da0bc0f457b1cd3a4015970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a291106384cabc73da0bc0f457b1cd3a4015970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a291106384cabc73da0bc0f457b1cd3a4015970", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a291106384cabc73da0bc0f457b1cd3a4015970/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f41df916c2d6d7598cb5e67cdaebdc86910e902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f41df916c2d6d7598cb5e67cdaebdc86910e902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f41df916c2d6d7598cb5e67cdaebdc86910e902"}], "stats": {"total": 586, "additions": 473, "deletions": 113}, "files": [{"sha": "a26b1f28ead0302353ab894a1f9bc5b4a1fbbf9b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -1,3 +1,7 @@\n+2019-11-27  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Update __cpp_deduction_guides.\n+\n 2019-11-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/61414"}, {"sha": "6491545bc3bbcf647a6bc18878c531c4ea775dd3", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -980,7 +980,8 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_capture_star_this=201603L\");\n \t  cpp_define (pfile, \"__cpp_inline_variables=201606L\");\n \t  cpp_define (pfile, \"__cpp_aggregate_bases=201603L\");\n-\t  cpp_define (pfile, \"__cpp_deduction_guides=201703L\");\n+\t  if (cxx_dialect <= cxx17)\n+\t    cpp_define (pfile, \"__cpp_deduction_guides=201703L\");\n \t  cpp_define (pfile, \"__cpp_noexcept_function_type=201510L\");\n \t  /* Old macro, superseded by\n \t     __cpp_nontype_template_parameter_auto.  */\n@@ -1000,6 +1001,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_conditional_explicit=201806L\");\n \t  cpp_define (pfile, \"__cpp_consteval=201811L\");\n \t  cpp_define (pfile, \"__cpp_constinit=201907L\");\n+\t  cpp_define (pfile, \"__cpp_deduction_guides=201907L\");\n \t  cpp_define (pfile, \"__cpp_nontype_template_parameter_class=201806L\");\n \t  cpp_define (pfile, \"__cpp_impl_destroying_delete=201806L\");\n \t  cpp_define (pfile, \"__cpp_constexpr_dynamic_alloc=201907L\");"}, {"sha": "ec37f5ec4f2477e9c1ddee22c460e23bbbe235dd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -1,3 +1,14 @@\n+2019-11-16  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P1814R0, CTAD for alias templates.\n+\t* pt.c (rewrite_tparm_list): Factor out of build_deduction_guide.\n+\t(maybe_aggr_guide): Check for copy-init here.\n+\t(alias_ctad_tweaks, deduction_guides_for): New.\n+\t(ctor_deduction_guides_for): Factor out of do_class_deduction.\n+\t(ctad_template_p): New.\n+\t* parser.c (cp_parser_simple_type_specifier): Use it.\n+\t* constraint.cc (append_constraint): New.\n+\n 2019-11-16  Jason Merrill  <jason@redhat.com>\n \n \t* cxx-pretty-print.c (pp_cxx_unqualified_id): Handle alias"}, {"sha": "acc7e1322d0d1d5010c109edde72c35a2e927fe1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -4398,7 +4398,7 @@ build_converted_constant_bool_expr (tree expr, tsubst_flags_t complain)\n \n /* Do any initial processing on the arguments to a function call.  */\n \n-static vec<tree, va_gc> *\n+vec<tree, va_gc> *\n resolve_args (vec<tree, va_gc> *args, tsubst_flags_t complain)\n {\n   unsigned int ix;"}, {"sha": "533277a758fe50b4fc3f98041b98064af86a84cf", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -1116,6 +1116,25 @@ build_constraints (tree tr, tree dr)\n   return (tree)ci;\n }\n \n+/* Add constraint RHS to the end of CONSTRAINT_INFO ci.  */\n+\n+tree\n+append_constraint (tree ci, tree rhs)\n+{\n+  tree tr = ci ? CI_TEMPLATE_REQS (ci) : NULL_TREE;\n+  tree dr = ci ? CI_DECLARATOR_REQS (ci) : NULL_TREE;\n+  dr = combine_constraint_expressions (dr, rhs);\n+  if (ci)\n+    {\n+      CI_DECLARATOR_REQS (ci) = dr;\n+      tree ac = combine_constraint_expressions (tr, dr);\n+      CI_ASSOCIATED_CONSTRAINTS (ci) = ac;\n+    }\n+  else\n+    ci = build_constraints (tr, dr);\n+  return ci;\n+}\n+\n /* A mapping from declarations to constraint information.  */\n \n static GTY ((cache)) decl_tree_cache_map *decl_constraints;"}, {"sha": "7e810b8ee7b05a98db147df163aa48c728e9122b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -6320,6 +6320,7 @@ extern tree build_converted_constant_expr\t(tree, tree, tsubst_flags_t);\n extern tree build_converted_constant_bool_expr\t(tree, tsubst_flags_t);\n extern tree perform_direct_initialization_if_possible (tree, tree, bool,\n                                                        tsubst_flags_t);\n+extern vec<tree,va_gc> *resolve_args (vec<tree,va_gc>*, tsubst_flags_t);\n extern tree in_charge_arg_for_name\t\t(tree);\n extern tree build_cxx_call\t\t\t(tree, int, tree *,\n \t\t\t\t\t\t tsubst_flags_t,\n@@ -6820,6 +6821,7 @@ extern tree make_constrained_auto\t\t(tree, tree);\n extern tree make_constrained_decltype_auto\t(tree, tree);\n extern tree make_template_placeholder\t\t(tree);\n extern bool template_placeholder_p\t\t(tree);\n+extern bool ctad_template_p\t\t\t(tree);\n extern tree do_auto_deduction                   (tree, tree, tree,\n                                                  tsubst_flags_t\n \t\t\t\t\t\t = tf_warning_or_error,"}, {"sha": "ed2441644f1a314c1969928325e17340f91be06b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -18082,8 +18082,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t\t\t\t\t\t /*ambiguous_decls=*/NULL,\n \t\t\t\t\t\t token->location);\n \t      if (tmpl && tmpl != error_mark_node\n-\t\t  && (DECL_CLASS_TEMPLATE_P (tmpl)\n-\t\t      || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))\n+\t\t  && ctad_template_p (tmpl))\n \t\ttype = make_template_placeholder (tmpl);\n \t      else if (flag_concepts && tmpl && concept_definition_p (tmpl))\n \t\ttype = cp_parser_placeholder_type_specifier (parser, loc,"}, {"sha": "5088dc125ce61adcfc2e3b0f9033bee8cefcb59b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 376, "deletions": 105, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -27784,6 +27784,29 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n   return newdecl;\n }\n \n+/* As rewrite_template_parm, but for the whole TREE_LIST representing a\n+   template parameter.  */\n+\n+static tree\n+rewrite_tparm_list (tree oldelt, unsigned index, unsigned level,\n+\t\t    tree targs, unsigned targs_index, tsubst_flags_t complain)\n+{\n+  tree olddecl = TREE_VALUE (oldelt);\n+  tree newdecl = rewrite_template_parm (olddecl, index, level,\n+\t\t\t\t\ttargs, complain);\n+  if (newdecl == error_mark_node)\n+    return error_mark_node;\n+  tree newdef = tsubst_template_arg (TREE_PURPOSE (oldelt),\n+\t\t\t\t     targs, complain, NULL_TREE);\n+  tree list = build_tree_list (newdef, newdecl);\n+  TEMPLATE_PARM_CONSTRAINTS (list)\n+    = tsubst_constraint_info (TEMPLATE_PARM_CONSTRAINTS (oldelt),\n+\t\t\t      targs, complain, NULL_TREE);\n+  int depth = TMPL_ARGS_DEPTH (targs);\n+  TMPL_ARG (targs, depth, targs_index) = template_parm_to_arg (list);\n+  return list;\n+}\n+\n /* Returns a C++17 class deduction guide template based on the constructor\n    CTOR.  As a special case, CTOR can be a RECORD_TYPE for an implicit default\n    guide, REFERENCE_TYPE for an implicit copy/move guide, or TREE_LIST for an\n@@ -27897,19 +27920,12 @@ build_deduction_guide (tree type, tree ctor, tree outer_args, tsubst_flags_t com\n \t      unsigned index = i + clen;\n \t      unsigned level = 1;\n \t      tree oldelt = TREE_VEC_ELT (ftparms, i);\n-\t      tree olddecl = TREE_VALUE (oldelt);\n-\t      tree newdecl = rewrite_template_parm (olddecl, index, level,\n-\t\t\t\t\t\t    tsubst_args, complain);\n-\t      if (newdecl == error_mark_node)\n+\t      tree newelt\n+\t\t= rewrite_tparm_list (oldelt, index, level,\n+\t\t\t\t      tsubst_args, i, complain);\n+\t      if (newelt == error_mark_node)\n \t\tok = false;\n-\t      tree newdef = tsubst_template_arg (TREE_PURPOSE (oldelt),\n-\t\t\t\t\t\t tsubst_args, complain, ctor);\n-\t      tree list = build_tree_list (newdef, newdecl);\n-\t      TEMPLATE_PARM_CONSTRAINTS (list)\n-\t\t= tsubst_constraint_info (TEMPLATE_PARM_CONSTRAINTS (oldelt),\n-\t\t\t\t\t  tsubst_args, complain, ctor);\n-\t      TREE_VEC_ELT (new_vec, index) = list;\n-\t      TMPL_ARG (tsubst_args, depth, i) = template_parm_to_arg (list);\n+\t      TREE_VEC_ELT (new_vec, index) = newelt;\n \t    }\n \n \t  /* Now we have a final set of template parms to substitute into the\n@@ -27984,20 +28000,48 @@ collect_ctor_idx_types (tree ctor, tree list)\n   return list;\n }\n \n+/* Return whether ETYPE is, or is derived from, a specialization of TMPL.  */\n+\n+static bool\n+is_spec_or_derived (tree etype, tree tmpl)\n+{\n+  if (!etype || !CLASS_TYPE_P (etype))\n+    return false;\n+\n+  tree type = TREE_TYPE (tmpl);\n+  tree tparms = (INNERMOST_TEMPLATE_PARMS\n+\t\t (DECL_TEMPLATE_PARMS (tmpl)));\n+  tree targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n+  int err = unify (tparms, targs, type, etype,\n+\t\t   UNIFY_ALLOW_DERIVED, /*explain*/false);\n+  ggc_free (targs);\n+  return !err;\n+}\n+\n /* Return a C++20 aggregate deduction candidate for TYPE initialized from\n    INIT.  */\n \n static tree\n-maybe_aggr_guide (tree type, tree init)\n+maybe_aggr_guide (tree tmpl, tree init, vec<tree,va_gc> *args)\n {\n   if (cxx_dialect < cxx2a)\n     return NULL_TREE;\n \n   if (init == NULL_TREE)\n     return NULL_TREE;\n+\n+  tree type = TREE_TYPE (tmpl);\n   if (!CP_AGGREGATE_TYPE_P (type))\n     return NULL_TREE;\n \n+  /* No aggregate candidate for copy-initialization.  */\n+  if (args->length() == 1)\n+    {\n+      tree val = (*args)[0];\n+      if (is_spec_or_derived (tmpl, TREE_TYPE (val)))\n+\treturn NULL_TREE;\n+    }\n+\n   /* If we encounter a problem, we just won't add the candidate.  */\n   tsubst_flags_t complain = tf_none;\n \n@@ -28039,92 +28083,369 @@ maybe_aggr_guide (tree type, tree init)\n   return NULL_TREE;\n }\n \n-/* Return whether ETYPE is, or is derived from, a specialization of TMPL.  */\n+/* UGUIDES are the deduction guides for the underlying template of alias\n+   template TMPL; adjust them to be deduction guides for TMPL.  */\n \n-static bool\n-is_spec_or_derived (tree etype, tree tmpl)\n-{\n-  if (!etype || !CLASS_TYPE_P (etype))\n-    return false;\n+static tree\n+alias_ctad_tweaks (tree tmpl, tree uguides)\n+{\n+  /* [over.match.class.deduct]: When resolving a placeholder for a deduced\n+     class type (9.2.8.2) where the template-name names an alias template A,\n+     the defining-type-id of A must be of the form\n+\n+     typename(opt) nested-name-specifier(opt) template(opt) simple-template-id\n+\n+     as specified in 9.2.8.2. The guides of A are the set of functions or\n+     function templates formed as follows. For each function or function\n+     template f in the guides of the template named by the simple-template-id\n+     of the defining-type-id, the template arguments of the return type of f\n+     are deduced from the defining-type-id of A according to the process in\n+     13.10.2.5 with the exception that deduction does not fail if not all\n+     template arguments are deduced. Let g denote the result of substituting\n+     these deductions into f. If substitution succeeds, form a function or\n+     function template f' with the following properties and add it to the set\n+     of guides of A:\n+\n+     * The function type of f' is the function type of g.\n+\n+     * If f is a function template, f' is a function template whose template\n+     parameter list consists of all the template parameters of A (including\n+     their default template arguments) that appear in the above deductions or\n+     (recursively) in their default template arguments, followed by the\n+     template parameters of f that were not deduced (including their default\n+     template arguments), otherwise f' is not a function template.\n+\n+     * The associated constraints (13.5.2) are the conjunction of the\n+     associated constraints of g and a constraint that is satisfied if and only\n+     if the arguments of A are deducible (see below) from the return type.\n+\n+     * If f is a copy deduction candidate (12.4.1.8), then f' is considered to\n+     be so as well.\n+\n+     * If f was generated from a deduction-guide (12.4.1.8), then f' is\n+     considered to be so as well.\n+\n+     * The explicit-specifier of f' is the explicit-specifier of g (if\n+     any).  */\n+\n+  /* This implementation differs from the above in two significant ways:\n+\n+     1) We include all template parameters of A, not just some.\n+     2) The added constraint is same_type instead of deducible.\n+\n+     I believe that while it's probably possible to construct a testcase that\n+     behaves differently with this simplification, it should have the same\n+     effect for real uses.  Including all template parameters means that we\n+     deduce all parameters of A when resolving the call, so when we're in the\n+     constraint we don't need to deduce them again, we can just check whether\n+     the deduction produced the desired result.  */\n+\n+  tsubst_flags_t complain = tf_warning_or_error;\n+  tree atype = TREE_TYPE (tmpl);\n+  tree aguides = NULL_TREE;\n+  tree atparms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n+  unsigned natparms = TREE_VEC_LENGTH (atparms);\n+  tree utype = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n+  for (ovl_iterator iter (uguides); iter; ++iter)\n+    {\n+      tree f = *iter;\n+      tree in_decl = f;\n+      location_t loc = DECL_SOURCE_LOCATION (f);\n+      tree ret = TREE_TYPE (TREE_TYPE (f));\n+      tree fprime = f;\n+      if (TREE_CODE (f) == TEMPLATE_DECL)\n+\t{\n+\t  processing_template_decl_sentinel ptds (/*reset*/false);\n+\t  ++processing_template_decl;\n+\n+\t  /* Deduce template arguments for f from the type-id of A.  */\n+\t  tree ftparms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (f));\n+\t  unsigned len = TREE_VEC_LENGTH (ftparms);\n+\t  tree targs = make_tree_vec (len);\n+\t  int err = unify (ftparms, targs, ret, utype, UNIFY_ALLOW_NONE, false);\n+\t  gcc_assert (!err);\n+\n+\t  /* The number of parms for f' is the number of parms for A plus\n+\t     non-deduced parms of f.  */\n+\t  unsigned ndlen = 0;\n+\t  unsigned j;\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n+\t      ++ndlen;\n+\t  tree gtparms = make_tree_vec (natparms + ndlen);\n+\n+\t  /* First copy over the parms of A.  */\n+\t  for (j = 0; j < natparms; ++j)\n+\t    TREE_VEC_ELT (gtparms, j) = TREE_VEC_ELT (atparms, j);\n+\t  /* Now rewrite the non-deduced parms of f.  */\n+\t  for (unsigned i = 0; ndlen && i < len; ++i)\n+\t    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n+\t      {\n+\t\t--ndlen;\n+\t\tunsigned index = j++;\n+\t\tunsigned level = 1;\n+\t\ttree oldlist = TREE_VEC_ELT (ftparms, i);\n+\t\ttree list = rewrite_tparm_list (oldlist, index, level,\n+\t\t\t\t\t\ttargs, i, complain);\n+\t\tTREE_VEC_ELT (gtparms, index) = list;\n+\t      }\n+\t  gtparms = build_tree_list (size_one_node, gtparms);\n+\n+\t  /* Substitute the deduced arguments plus the rewritten template\n+\t     parameters into f to get g.  This covers the type, copyness,\n+\t     guideness, and explicit-specifier.  */\n+\t  tree g = tsubst_decl (DECL_TEMPLATE_RESULT (f), targs, complain);\n+\t  if (g == error_mark_node)\n+\t    return error_mark_node;\n+\t  DECL_USE_TEMPLATE (g) = 0;\n+\t  fprime = build_template_decl (g, gtparms, false);\n+\t  DECL_TEMPLATE_RESULT (fprime) = g;\n+\t  TREE_TYPE (fprime) = TREE_TYPE (g);\n+\t  tree gtargs = template_parms_to_args (gtparms);\n+\t  DECL_TEMPLATE_INFO (g) = build_template_info (fprime, gtargs);\n+\t  DECL_PRIMARY_TEMPLATE (fprime) = fprime;\n+\n+\t  /* Substitute the associated constraints.  */\n+\t  tree ci = get_constraints (f);\n+\t  if (ci)\n+\t    ci = tsubst_constraint_info (ci, targs, complain, in_decl);\n+\t  if (ci == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  /* Add a constraint that the return type matches the instantiation of\n+\t     A with the same template arguments.  */\n+\t  ret = TREE_TYPE (TREE_TYPE (fprime));\n+\t  if (!same_type_p (atype, ret)\n+\t      /* FIXME this should mean they don't compare as equivalent.  */\n+\t      || dependent_alias_template_spec_p (atype, nt_opaque))\n+\t    {\n+\t      tree same = finish_trait_expr (loc, CPTK_IS_SAME_AS, atype, ret);\n+\t      ci = append_constraint (ci, same);\n+\t    }\n+\n+\t  if (ci)\n+\t    set_constraints (fprime, ci);\n+\t}\n+      else\n+\t{\n+\t  /* For a non-template deduction guide, if the arguments of A aren't\n+\t     deducible from the return type, don't add the candidate.  */\n+\t  tree targs = make_tree_vec (natparms);\n+\t  int err = unify (atparms, targs, utype, ret, UNIFY_ALLOW_NONE, false);\n+\t  for (unsigned i = 0; !err && i < natparms; ++i)\n+\t    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n+\t      err = true;\n+\t  if (err)\n+\t    continue;\n+\t}\n \n+      aguides = lookup_add (fprime, aguides);\n+    }\n+\n+  return aguides;\n+}\n+\n+/* Return artificial deduction guides built from the constructors of class\n+   template TMPL.  */\n+\n+static tree\n+ctor_deduction_guides_for (tree tmpl, tsubst_flags_t complain)\n+{\n   tree type = TREE_TYPE (tmpl);\n-  tree tparms = (INNERMOST_TEMPLATE_PARMS\n-\t\t (DECL_TEMPLATE_PARMS (tmpl)));\n-  tree targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n-  int err = unify (tparms, targs, type, etype,\n-\t\t   UNIFY_ALLOW_DERIVED, /*explain*/false);\n-  ggc_free (targs);\n-  return !err;\n+  tree outer_args = NULL_TREE;\n+  if (DECL_CLASS_SCOPE_P (tmpl)\n+      && CLASSTYPE_TEMPLATE_INSTANTIATION (DECL_CONTEXT (tmpl)))\n+    {\n+      outer_args = CLASSTYPE_TI_ARGS (DECL_CONTEXT (tmpl));\n+      type = TREE_TYPE (most_general_template (tmpl));\n+    }\n+\n+  tree cands = NULL_TREE;\n+\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (type)); iter; ++iter)\n+    {\n+      /* Skip inherited constructors.  */\n+      if (iter.using_p ())\n+\tcontinue;\n+\n+      tree guide = build_deduction_guide (type, *iter, outer_args, complain);\n+      cands = lookup_add (guide, cands);\n+    }\n+\n+  /* Add implicit default constructor deduction guide.  */\n+  if (!TYPE_HAS_USER_CONSTRUCTOR (type))\n+    {\n+      tree guide = build_deduction_guide (type, type, outer_args,\n+\t\t\t\t\t  complain);\n+      cands = lookup_add (guide, cands);\n+    }\n+\n+  /* Add copy guide.  */\n+  {\n+    tree gtype = build_reference_type (type);\n+    tree guide = build_deduction_guide (type, gtype, outer_args,\n+\t\t\t\t\tcomplain);\n+    cands = lookup_add (guide, cands);\n+  }\n+\n+  return cands;\n+}\n+\n+static GTY((deletable)) hash_map<tree, tree_pair_p> *dguide_cache;\n+\n+/* Return the non-aggregate deduction guides for deducible template TMPL.  The\n+   aggregate candidate is added separately because it depends on the\n+   initializer.  */\n+\n+static tree\n+deduction_guides_for (tree tmpl, tsubst_flags_t complain)\n+{\n+  tree guides = NULL_TREE;\n+  if (DECL_ALIAS_TEMPLATE_P (tmpl))\n+    {\n+      tree under = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n+      tree tinfo = get_template_info (under);\n+      guides = deduction_guides_for (TI_TEMPLATE (tinfo), complain);\n+    }\n+  else\n+    {\n+      guides = lookup_qualified_name (CP_DECL_CONTEXT (tmpl),\n+\t\t\t\t      dguide_name (tmpl),\n+\t\t\t\t      /*type*/false, /*complain*/false,\n+\t\t\t\t      /*hidden*/false);\n+      if (guides == error_mark_node)\n+\tguides = NULL_TREE;\n+    }\n+\n+  /* Cache the deduction guides for a template.  We also remember the result of\n+     lookup, and rebuild everything if it changes; should be very rare.  */\n+  tree_pair_p cache = NULL;\n+  if (tree_pair_p &r\n+      = hash_map_safe_get_or_insert<hm_ggc> (dguide_cache, tmpl))\n+    {\n+      cache = r;\n+      if (cache->purpose == guides)\n+\treturn cache->value;\n+    }\n+  else\n+    {\n+      r = cache = ggc_cleared_alloc<tree_pair_s> ();\n+      cache->purpose = guides;\n+    }\n+\n+  tree cands = NULL_TREE;\n+  if (DECL_ALIAS_TEMPLATE_P (tmpl))\n+    cands = alias_ctad_tweaks (tmpl, guides);\n+  else\n+    {\n+      cands = ctor_deduction_guides_for (tmpl, complain);\n+      for (ovl_iterator it (guides); it; ++it)\n+\tcands = lookup_add (*it, cands);\n+    }\n+\n+  cache->value = cands;\n+  return cands;\n+}\n+\n+/* Return whether TMPL is a (class template argument-) deducible template.  */\n+\n+bool\n+ctad_template_p (tree tmpl)\n+{\n+  /* A deducible template is either a class template or is an alias template\n+     whose defining-type-id is of the form\n+\n+      typename(opt) nested-name-specifier(opt) template(opt) simple-template-id\n+\n+     where the nested-name-specifier (if any) is non-dependent and the\n+     template-name of the simple-template-id names a deducible template.  */\n+\n+  if (DECL_CLASS_TEMPLATE_P (tmpl)\n+      || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl))\n+    return true;\n+  if (!DECL_ALIAS_TEMPLATE_P (tmpl))\n+    return false;\n+  tree orig = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n+  if (tree tinfo = get_template_info (orig))\n+    return ctad_template_p (TI_TEMPLATE (tinfo));\n+  return false;\n }\n \n /* Deduce template arguments for the class template placeholder PTYPE for\n    template TMPL based on the initializer INIT, and return the resulting\n    type.  */\n \n static tree\n-do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n-\t\t    tsubst_flags_t complain)\n+do_class_deduction (tree ptype, tree tmpl, tree init,\n+\t\t    int flags, tsubst_flags_t complain)\n {\n-  if (!DECL_CLASS_TEMPLATE_P (tmpl))\n+  /* We should have handled this in the caller.  */\n+  if (DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl))\n+    return ptype;\n+\n+  /* Look through alias templates that just rename another template.  */\n+  tmpl = get_underlying_template (tmpl);\n+  if (!ctad_template_p (tmpl))\n     {\n-      /* We should have handled this in the caller.  */\n-      if (DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl))\n-\treturn ptype;\n       if (complain & tf_error)\n-\terror (\"non-class template %qT used without template arguments\", tmpl);\n+\terror (\"non-deducible template %qT used without template arguments\", tmpl);\n       return error_mark_node;\n     }\n+  else if (cxx_dialect < cxx2a && DECL_ALIAS_TEMPLATE_P (tmpl))\n+    {\n+      /* This doesn't affect conforming C++17 code, so just pedwarn.  */\n+      if (complain & tf_warning_or_error)\n+\tpedwarn (input_location, 0, \"alias template deduction only available \"\n+\t\t \"with %<-std=c++2a%> or %<-std=gnu++2a%>\");\n+    }\n+\n   if (init && TREE_TYPE (init) == ptype)\n     /* Using the template parm as its own argument.  */\n     return ptype;\n \n   tree type = TREE_TYPE (tmpl);\n \n   bool try_list_ctor = false;\n-  bool copy_init = false;\n \n   releasing_vec rv_args = NULL;\n   vec<tree,va_gc> *&args = *&rv_args;\n   if (init == NULL_TREE)\n     args = make_tree_vector ();\n   else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n-      if (CONSTRUCTOR_NELTS (init) == 1)\n+      try_list_ctor = TYPE_HAS_LIST_CTOR (type);\n+      if (try_list_ctor && CONSTRUCTOR_NELTS (init) == 1)\n \t{\n \t  /* As an exception, the first phase in 16.3.1.7 (considering the\n \t     initializer list as a single argument) is omitted if the\n \t     initializer list consists of a single expression of type cv U,\n \t     where U is a specialization of C or a class derived from a\n \t     specialization of C.  */\n \t  tree elt = CONSTRUCTOR_ELT (init, 0)->value;\n-\t  copy_init = is_spec_or_derived (TREE_TYPE (elt), tmpl);\n+\t  if (is_spec_or_derived (TREE_TYPE (elt), tmpl))\n+\t    try_list_ctor = false;\n \t}\n-      try_list_ctor = !copy_init && TYPE_HAS_LIST_CTOR (type);\n       if (try_list_ctor || is_std_init_list (type))\n \targs = make_tree_vector_single (init);\n       else\n \targs = make_tree_vector_from_ctor (init);\n     }\n+  else if (TREE_CODE (init) == TREE_LIST)\n+    args = make_tree_vector_from_list (init);\n   else\n-    {\n-      if (TREE_CODE (init) == TREE_LIST)\n-\targs = make_tree_vector_from_list (init);\n-      else\n-\targs = make_tree_vector_single (init);\n+    args = make_tree_vector_single (init);\n \n-      if (args->length() == 1)\n-\tcopy_init = is_spec_or_derived (TREE_TYPE ((*args)[0]), tmpl);\n-    }\n+  /* Do this now to avoid problems with erroneous args later on.  */\n+  args = resolve_args (args, complain);\n+  if (args == NULL)\n+    return error_mark_node;\n \n-  tree dname = dguide_name (tmpl);\n-  tree cands = lookup_qualified_name (CP_DECL_CONTEXT (tmpl), dname,\n-\t\t\t\t      /*type*/false, /*complain*/false,\n-\t\t\t\t      /*hidden*/false);\n-  bool elided = false;\n+  tree cands = deduction_guides_for (tmpl, complain);\n   if (cands == error_mark_node)\n-    cands = NULL_TREE;\n+    return error_mark_node;\n \n   /* Prune explicit deduction guides in copy-initialization context.  */\n+  bool elided = false;\n   if (flags & LOOKUP_ONLYCONVERTING)\n     {\n       for (lkp_iterator iter (cands); !elided && iter; ++iter)\n@@ -28143,37 +28464,8 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n \t}\n     }\n \n-  tree outer_args = NULL_TREE;\n-  if (DECL_CLASS_SCOPE_P (tmpl)\n-      && CLASSTYPE_TEMPLATE_INSTANTIATION (DECL_CONTEXT (tmpl)))\n-    {\n-      outer_args = CLASSTYPE_TI_ARGS (DECL_CONTEXT (tmpl));\n-      type = TREE_TYPE (most_general_template (tmpl));\n-    }\n-\n-  bool saw_ctor = false;\n-  // FIXME cache artificial deduction guides\n-  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (type)); iter; ++iter)\n-    {\n-      /* Skip inherited constructors.  */\n-      if (iter.using_p ())\n-\tcontinue;\n-\n-      tree guide = build_deduction_guide (type, *iter, outer_args, complain);\n-      if (guide == error_mark_node)\n-\treturn error_mark_node;\n-      if ((flags & LOOKUP_ONLYCONVERTING)\n-\t  && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n-\telided = true;\n-      else\n-\tcands = lookup_add (guide, cands);\n-\n-      saw_ctor = true;\n-    }\n-\n-  if (!copy_init)\n-    if (tree guide = maybe_aggr_guide (type, init))\n-      cands = lookup_add (guide, cands);\n+  if (tree guide = maybe_aggr_guide (tmpl, init, args))\n+    cands = lookup_add (guide, cands);\n \n   tree call = error_mark_node;\n \n@@ -28202,28 +28494,6 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n \t}\n     }\n \n-  /* Maybe generate an implicit deduction guide.  */\n-  if (call == error_mark_node && args->length () < 2)\n-    {\n-      tree gtype = NULL_TREE;\n-\n-      if (args->length () == 1)\n-\t/* Generate a copy guide.  */\n-\tgtype = build_reference_type (type);\n-      else if (!saw_ctor)\n-\t/* Generate a default guide.  */\n-\tgtype = type;\n-\n-      if (gtype)\n-\t{\n-\t  tree guide = build_deduction_guide (type, gtype, outer_args,\n-\t\t\t\t\t      complain);\n-\t  if (guide == error_mark_node)\n-\t    return error_mark_node;\n-\t  cands = lookup_add (guide, cands);\n-\t}\n-    }\n-\n   if (elided && !cands)\n     {\n       error (\"cannot deduce template arguments for copy-initialization\"\n@@ -28245,7 +28515,8 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n       --cp_unevaluated_operand;\n     }\n \n-  if (call == error_mark_node && (complain & tf_warning_or_error))\n+  if (call == error_mark_node\n+      && (complain & tf_warning_or_error))\n     {\n       error (\"class template argument deduction failed:\");\n "}, {"sha": "8817860b4d3715a186be5701e9f04bf3e44f7a4f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -2338,6 +2338,9 @@ lookup_mark (tree ovl, bool val)\n tree\n lookup_add (tree fns, tree lookup)\n {\n+  if (fns == error_mark_node || lookup == error_mark_node)\n+    return error_mark_node;\n+\n   if (lookup || TREE_CODE (fns) == TEMPLATE_DECL)\n     {\n       lookup = ovl_make (fns, lookup);"}, {"sha": "e98573729f374e296bfbc582abec6f56bdb0ad48", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction46.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction46.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction46.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction46.C?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -3,4 +3,4 @@\n \n template<class S> struct C;\n template<> struct C<int> { C(int, int) {} };\n-auto k = C{0, 0};  // { dg-error \"cannot deduce\" }\n+auto k = C{0, 0};  // { dg-error \"\" }"}, {"sha": "ed47eb38f1b5aebfe206acda130265b3272e71e8", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-alias1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias1.C?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -0,0 +1,27 @@\n+// Testcase from P1814R0\n+// { dg-do compile { target c++2a } }\n+\n+template <class T> struct identity { using type = T; };\n+template <class T> using identity_t = typename identity<T>::type;\n+template <class T> concept Int = __is_same_as (T, int);\n+\n+template <class T, class U> struct C {\n+  C(T, U);\t\t\t// #1 { dg-message \"constraint\" }\n+};\n+template<class T, class U>\n+C(T, U) -> C<T, identity_t<U>>; // #2 { dg-message \"constraint\" }\n+\n+template<class V>\n+using A = C<V *, V *>;\n+\n+template<Int W>\n+using B = A<W>;\n+    \n+int i{};\n+double d{};\n+A a1(&i, &i); // { dg-bogus \"\" \"Deduces A<int>\" }\n+A a2(i, i);   // { dg-error \"\" \"cannot deduce V * from i\" }\n+A a3(&i, &d); // { dg-error \"\" } #1: Cannot deduce (V*, V*) from (int *, double *) \n+                              // #2: Cannot deduce A<V> from C<int *, double *>\n+B b1(&i, &i); // { dg-bogus \"\" \"Deduces B<int>\" }\n+B b2(&d, &d); // { dg-error \"\" \"cannot deduce B<W> from C<double *, double *>\" }"}, {"sha": "d855f7d11ce9e56a5eb35ea90742a7a62609a3d6", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-alias2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias2.C?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -0,0 +1,22 @@\n+// Test that a non-template deduction guide that doesn't match the alias is\n+// ignored.\n+// { dg-do compile { target c++2a } }\n+\n+template <class T> struct identity { using type = T; };\n+template <class T> using identity_t = typename identity<T>::type;\n+\n+template <class T, class U> struct C {\n+  C(T, U);\t\t\t// #1\n+};\n+\n+C(char*, char*) -> C<int,int>;  // #3\n+\n+template<class V>\n+using A = C<V *, V *>;\n+\n+char c;\n+A a4 (&c, &c);\t\t\t// ignores #3 because C<int,int> is not an A<V>\n+\n+static_assert (__is_same_as(decltype(a4),A<char>));\n+\n+C c2 (&c, &c);\t\t\t// { dg-error \"conversion\" } deduces with #3"}, {"sha": "2df42cdfec5a423a8c1d84ecf73a19ca9a3a9044", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit11.C?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -9,7 +9,7 @@ struct A {\n };\n \n int i;\n-A a1 = { i, i }; // { dg-error \"deduction|cannot\" }\n+A a1 = { i, i }; // { dg-error \"deduction|cannot|no match\" }\n A a2{ i, i };\n A a3{ 0, i };\n A a4 = { 0, i };"}, {"sha": "9b6e2f59d2c57854ef61c683b8e9d3d62d8bf8aa", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a291106384cabc73da0bc0f457b1cd3a4015970/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=1a291106384cabc73da0bc0f457b1cd3a4015970", "patch": "@@ -358,8 +358,8 @@\n \n #ifndef __cpp_deduction_guides\n #  error \"__cpp_deduction_guides\"\n-#elif __cpp_deduction_guides != 201703\n-#  error \"__cpp_deduction_guides != 201703\"\n+#elif __cpp_deduction_guides != 201907\n+#  error \"__cpp_deduction_guides != 201907\"\n #endif\n \n #ifndef __cpp_if_constexpr"}]}