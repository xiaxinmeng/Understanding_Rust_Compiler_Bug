{"sha": "582db8e43021e33373aafbb03eafe6985fc4a0e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgyZGI4ZTQzMDIxZTMzMzczYWFmYmIwM2VhZmU2OTg1ZmM0YTBlOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-24T01:19:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-24T01:19:04Z"}, "message": "tree.h (unsave_expr_1): New function.\n\n\t* tree.h (unsave_expr_1): New function.\n\t(lang_unsave): New variable.\n\t(get_callee_fndecl): New function.\n\t* tree.c (unsave_expr_now_r): New function.\n\t(lang_unsave): Define.\n\t(unsave_expr_1): Likewise.\n\t(unsave_expr_now_r): Split out from unsave_expr_now.\n\t(unsave_expr_now): Call lang_unsave if it is non-NULL.  Otherwise,\n\tcall unsave_expr_now_r.\n\t(get_callee_fndecl): Define.\n\nFrom-SVN: r30646", "tree": {"sha": "4c2d383db592a8c376ae9fdeeabe92711772da13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c2d383db592a8c376ae9fdeeabe92711772da13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/582db8e43021e33373aafbb03eafe6985fc4a0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582db8e43021e33373aafbb03eafe6985fc4a0e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/582db8e43021e33373aafbb03eafe6985fc4a0e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582db8e43021e33373aafbb03eafe6985fc4a0e8/comments", "author": null, "committer": null, "parents": [{"sha": "87d35858fcc210973b63d09665d9677be6f4ec6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d35858fcc210973b63d09665d9677be6f4ec6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d35858fcc210973b63d09665d9677be6f4ec6a"}], "stats": {"total": 157, "additions": 116, "deletions": 41}, "files": [{"sha": "03f507f9ad796bdd7d8fba85a97b502a53a0399f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/582db8e43021e33373aafbb03eafe6985fc4a0e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/582db8e43021e33373aafbb03eafe6985fc4a0e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=582db8e43021e33373aafbb03eafe6985fc4a0e8", "patch": "@@ -1,5 +1,16 @@\n 1999-11-23  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* tree.h (unsave_expr_1): New function.\n+\t(lang_unsave): New variable.\n+\t(get_callee_fndecl): New function.\n+\t* tree.c (unsave_expr_now_r): New function.\n+\t(lang_unsave): Define.\n+\t(unsave_expr_1): Likewise.\n+\t(unsave_expr_now_r): Split out from unsave_expr_now.\n+\t(unsave_expr_now): Call lang_unsave if it is non-NULL.  Otherwise,\n+\tcall unsave_expr_now_r.\n+\t(get_callee_fndecl): Define.\n+\n \t* Makefile.in (gencheck): Don't depend on lang_tree_files.\n \t(gencheck.o): Do depend on lang_tree_files.\n "}, {"sha": "82b00e7d59aff49f4ee9d0e3030ae7910ee2f5ac", "filename": "gcc/tree.c", "status": "modified", "additions": 90, "deletions": 35, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/582db8e43021e33373aafbb03eafe6985fc4a0e8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/582db8e43021e33373aafbb03eafe6985fc4a0e8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=582db8e43021e33373aafbb03eafe6985fc4a0e8", "patch": "@@ -48,6 +48,8 @@ Boston, MA 02111-1307, USA.  */\n /* obstack.[ch] explicitly declined to prototype this. */\n extern int _obstack_allocated_p PROTO ((struct obstack *h, PTR obj));\n \n+static void unsave_expr_now_r PROTO ((tree));\n+\n /* Tree nodes of permanent duration are allocated in this obstack.\n    They are the identifier nodes, and everything outside of\n    the bodies and parameters of function definitions.  */\n@@ -275,8 +277,12 @@ static void build_real_from_int_cst_1 PROTO((PTR));\n static void mark_type_hash PROTO ((void *));\n static void fix_sizetype PROTO ((tree));\n \n-/* If non-null, a language specific helper for unsave_expr_now. */\n-\n+/* If non-null, these are language-specific helper functions for\n+   unsave_expr_now.  If present, LANG_UNSAVE is called before its\n+   argument (an UNSAVE_EXPR) is to be unsaved, and all other\n+   processing in unsave_expr_now is aborted.  LANG_UNSAVE_EXPR_NOW is\n+   called from unsave_expr_1 for language-specific tree codes.  */\n+void (*lang_unsave) PROTO((tree *));\n void (*lang_unsave_expr_now) PROTO((tree));\n \n /* The string used as a placeholder instead of a source file name for\n@@ -2419,27 +2425,14 @@ first_rtl_op (code)\n     }\n }\n \n-/* Modify a tree in place so that all the evaluate only once things\n-   are cleared out.  Return the EXPR given.  \n-\n-   LANG_UNSAVE_EXPR_NOW, if set, is a pointer to a function to handle\n-   language specific nodes.\n-*/\n+/* Perform any modifications to EXPR required when it is unsaved.  Does\n+   not recurse into EXPR's subtrees.  */\n \n-tree\n-unsave_expr_now (expr)\n+void\n+unsave_expr_1 (expr)\n      tree expr;\n {\n-  enum tree_code code;\n-  register int i;\n-  int first_rtl;\n-\n-  if (expr == NULL_TREE)\n-    return expr;\n-\n-  code = TREE_CODE (expr);\n-  first_rtl = first_rtl_op (code);\n-  switch (code)\n+  switch (TREE_CODE (expr))\n     {\n     case SAVE_EXPR:\n       if (!SAVE_EXPR_PERSISTENT_P (expr))\n@@ -2453,53 +2446,86 @@ unsave_expr_now (expr)\n       \n     case RTL_EXPR:\n       /* I don't yet know how to emit a sequence multiple times.  */\n-      if (RTL_EXPR_SEQUENCE (expr) != 0)\n+      if (RTL_EXPR_SEQUENCE (expr))\n \tabort ();\n       break;\n \n     case CALL_EXPR:\n       CALL_EXPR_RTL (expr) = 0;\n-      if (TREE_OPERAND (expr, 1)\n-\t  && TREE_CODE (TREE_OPERAND (expr, 1)) == TREE_LIST)\n-\t{\n-\t  tree exp = TREE_OPERAND (expr, 1);\n-\t  while (exp)\n-\t    {\n-\t      unsave_expr_now (TREE_VALUE (exp));\n-\t      exp = TREE_CHAIN (exp);\n-\t    }\n-\t}\n       break;\n \n     default:\n       if (lang_unsave_expr_now)\n \t(*lang_unsave_expr_now) (expr);\n       break;\n     }\n+}\n+\n+/* Helper function for unsave_expr_now.  */\n+\n+static void\n+unsave_expr_now_r (expr)\n+     tree expr;\n+{\n+  enum tree_code code;\n+\n+  unsave_expr_1 (expr);\n \n+  code = TREE_CODE (expr);\n+  if (code == CALL_EXPR \n+      && TREE_OPERAND (expr, 1)\n+      && TREE_CODE (TREE_OPERAND (expr, 1)) == TREE_LIST)\n+    {\n+      tree exp = TREE_OPERAND (expr, 1);\n+      while (exp)\n+\t{\n+\t  unsave_expr_now_r (TREE_VALUE (exp));\n+\t  exp = TREE_CHAIN (exp);\n+\t}\n+    }\n+ \n   switch (TREE_CODE_CLASS (code))\n     {\n     case 'c':  /* a constant */\n     case 't':  /* a type node */\n     case 'x':  /* something random, like an identifier or an ERROR_MARK.  */\n     case 'd':  /* A decl node */\n     case 'b':  /* A block node */\n-      return expr;\n+      break;\n \n     case 'e':  /* an expression */\n     case 'r':  /* a reference */\n     case 's':  /* an expression with side effects */\n     case '<':  /* a comparison expression */\n     case '2':  /* a binary arithmetic expression */\n     case '1':  /* a unary arithmetic expression */\n-      for (i = first_rtl - 1; i >= 0; i--)\n-\tunsave_expr_now (TREE_OPERAND (expr, i));\n-      return expr;\n+      {\n+\tint i;\n+\t\n+\tfor (i = first_rtl_op (code) - 1; i >= 0; i--)\n+\t  unsave_expr_now_r (TREE_OPERAND (expr, i));\n+      }\n+      break;\n \n     default:\n       abort ();\n     }\n }\n+\n+/* Modify a tree in place so that all the evaluate only once things\n+   are cleared out.  Return the EXPR given.  */\n+\n+tree\n+unsave_expr_now (expr)\n+     tree expr;\n+{\n+  if (lang_unsave)\n+    (*lang_unsave) (&expr);\n+  else\n+    unsave_expr_now_r (expr);\n+\n+  return expr;\n+}\n \f\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.  */\n@@ -4816,6 +4842,35 @@ decl_type_context (decl)\n   return NULL_TREE;\n }\n \n+/* CALL is a CALL_EXPR.  Return the declaration for the function\n+   called, or NULL_TREE if the called function cannot be \n+   determined.  */\n+\n+tree\n+get_callee_fndecl (call)\n+     tree call;\n+{\n+  tree addr;\n+\n+  /* It's invalid to call this function with anything but a\n+     CALL_EXPR.  */\n+  if (TREE_CODE (call) != CALL_EXPR)\n+    abort ();\n+\n+  /* The first operand to the CALL is the address of the function\n+     called.  */\n+  addr = TREE_OPERAND (call, 0);\n+\n+  /* If the address is just `&f' for some function `f', then we know\n+     that `f' is being called.  */\n+  if (TREE_CODE (addr) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (addr, 0)) == FUNCTION_DECL)\n+    return TREE_OPERAND (addr, 0);\n+\n+  /* We couldn't figure out what was being called.  */\n+  return NULL_TREE;\n+}\n+\n /* Print debugging information about the obstack O, named STR.  */\n \n void"}, {"sha": "d8056891fc0259f13c7edc938642dadf6ad41256", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/582db8e43021e33373aafbb03eafe6985fc4a0e8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/582db8e43021e33373aafbb03eafe6985fc4a0e8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=582db8e43021e33373aafbb03eafe6985fc4a0e8", "patch": "@@ -1845,20 +1845,28 @@ extern tree save_expr\t\t\tPROTO((tree));\n extern int first_rtl_op\t\t\tPROTO((enum tree_code));\n \n /* unsave_expr (EXP) returns an expression equivalent to EXP but it\n-   can be used multiple times and will evaluate EXP, in its entirety\n+   can be used multiple times and will evaluate EXP in its entirety\n    each time.  */\n \n extern tree unsave_expr\t\t\tPROTO((tree));\n \n-/* unsave_expr_now (EXP) resets EXP in place, so that it can be\n-   expanded again.  */\n+/* Reset EXP in place so that it can be expaned again.  Does not\n+   recurse into subtrees.  */\n+\n+extern void unsave_expr_1               PROTO((tree));\n+\n+/* Like unsave_expr_1, but recurses into all subtrees.  */\n \n extern tree unsave_expr_now\t\tPROTO((tree));\n \n-/* If non-null, a language specific helper for unsave_expr_now. */\n+/* If non-null, these are language-specific helper functions for\n+   unsave_expr_now.  If present, LANG_UNSAVE is called before its\n+   argument (an UNSAVE_EXPR) is to be unsaved, and all other\n+   processing in unsave_expr_now is aborted.  LANG_UNSAVE_EXPR_NOW is\n+   called from unsave_expr_1 for language-specific tree codes.  */\n+extern void (*lang_unsave)              PROTO((tree *));\n+extern void (*lang_unsave_expr_now)     PROTO((tree));\n \n-extern void (*lang_unsave_expr_now)      PROTO((tree));\n-  \n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.\n \n@@ -2045,6 +2053,7 @@ extern tree get_set_constructor_bytes\t\tPROTO((tree,\n extern int get_alias_set                        PROTO((tree));\n extern int new_alias_set\t\t\tPROTO((void));\n extern int (*lang_get_alias_set)                PROTO((tree));\n+extern tree get_callee_fndecl                   PROTO((tree));\n \f\n /* In stmt.c */\n "}]}