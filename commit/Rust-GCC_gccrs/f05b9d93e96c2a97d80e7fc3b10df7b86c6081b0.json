{"sha": "f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA1YjlkOTNlOTZjMmE5N2Q4MGU3ZmMzYjEwZGY3Yjg2YzYwODFiMA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-06T10:10:14Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-06T10:10:14Z"}, "message": "In gcc/: 2010-10-06 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented fast enumeration for Objective-C.\n        * c-parser.c (objc_could_be_foreach_context): New.\n        (c_lex_one_token): Recognize RID_IN keyword in a potential\n        Objective-C foreach context.\n        (c_parser_declaration_or_fndef): Added parameter.  Accept\n        Objective-C RID_IN keyword as terminating a declaration; in that\n        case, return the declaration in the new parameter.\n        (c_parser_extenral_declaration): Updated calls to\n        c_parser_declaration_or_fndef.\n        (c_parser_declaration_or_fndef): Same change.\n        (c_parser_compound_statement_nostart): Same change.\n        (c_parser_label): Same change.\n        (c_parser_objc_methodprotolist): Same change.\n        (c_parser_omp_for_loop): Same change.\n        (c_parser_for_statement): Detect and parse Objective-C foreach\n        statements.\n        (c_parser_omp_for_loop): Updated call to check_for_loop_decls().\n        * c-decl.c (check_for_loop_decls): Added parameter to allow ObjC\n        fast enumeration parsing code to turn off the c99 error but still\n        perform checks on the loop declarations.\n        * c-tree.h (check_for_loop_decls): Updated declaration.\n        * doc/objc.texi: Document fast enumeration.\n\nIn gcc/c-family/:\n2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented fast enumeration for Objective-C.\n        * c-common.h (objc_finish_foreach_loop): New.\n        * stub-objc.c (objc_finish_foreach_loop): New.\n\nIn gcc/objc/:\n2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented fast enumeration for Objective-C.\n        * objc-act.c (build_fast_enumeration_state_template): New.\n        (TAG_ENUMERATION_MUTATION): New.\n        (TAG_FAST_ENUMERATION_STATE): New.\n        (synth_module_prologue): Call build_fast_enumeration_state_template() and set up\n        objc_enumeration_mutation_decl.\n        (objc_create_temporary_var): Allow providing a name to temporary\n        variables.\n        (objc_build_exc_ptr): Updated calls to\n        objc_create_temporary_var().\n        (next_sjlj_build_try_catch_finally): Same change.\n        (objc_finish_foreach_loop): New.\n        * objc-act.h: Added OCTI_FAST_ENUM_STATE_TEMP,\n        OCTI_ENUM_MUTATION_DECL, objc_fast_enumeration_state_template,\n        objc_enumeration_mutation_decl.\n\n        Merge from 'apple/trunk' branch on FSF servers.\n\n        2006-04-12 Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4507230\n        * objc-act.c (objc_type_valid_for_messaging): New routine to check\n        for valid objc object types.\n        (objc_finish_foreach_loop): Check for invalid objc objects in\n        foreach header.\n\nIn gcc/testsuite/:\n2010-10-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented fast enumeration for Objective-C.\n        * objc.dg/foreach-1.m: New.\n        * objc.dg/foreach-2.m: New.\n        * objc.dg/foreach-3.m: New.\n        * objc.dg/foreach-4.m: New.\n        * objc.dg/foreach-5.m: New.\n        * objc.dg/foreach-6.m: New.\n        * objc.dg/foreach-7.m: New.\n\n        Merge from 'apple/trunk' branch on FSF servers:\n        2006-04-13 Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4502236\n        * objc.dg/objc-foreach-5.m: New.\n\n        2006-04-12 Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4507230\n        * objc.dg/objc-foreach-4.m: New.\n\n        2006-03-13  Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4472881\n        * objc.dg/objc-foreach-3.m: New.\n\n        2005-03-07 Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4468498\n        * objc.dg/objc-foreach-2.m: New.\n\n        2006-02-15   Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4294910\n        * objc.dg/objc-foreach-1.m: New\n\nIn libobjc/:\n2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented fast enumeration for Objective-C.\n        * Makefile.in (C_SOURCE_FILES): Added objc-foreach.c.\n        (OBJC_H): Added runtime.h\n        * objc-foreach.c: New file.\n        * objc/runtime.h: New file.\n\nFrom-SVN: r165019", "tree": {"sha": "9dd722f6e098569456083c38fb1b313e672cd799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dd722f6e098569456083c38fb1b313e672cd799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b938bc48d844e85327c603e01bb6c303462c2613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b938bc48d844e85327c603e01bb6c303462c2613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b938bc48d844e85327c603e01bb6c303462c2613"}], "stats": {"total": 2592, "additions": 2546, "deletions": 46}, "files": [{"sha": "6a62f7ad7742033f572c9f0efcce8e1505f11f55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -1,3 +1,28 @@\n+2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented fast enumeration for Objective-C.\t\n+\t* c-parser.c (objc_could_be_foreach_context): New.\n+\t(c_lex_one_token): Recognize RID_IN keyword in a potential\n+\tObjective-C foreach context.\n+\t(c_parser_declaration_or_fndef): Added parameter.  Accept\n+\tObjective-C RID_IN keyword as terminating a declaration; in that\n+\tcase, return the declaration in the new parameter.\n+\t(c_parser_extenral_declaration): Updated calls to\n+\tc_parser_declaration_or_fndef.\n+\t(c_parser_declaration_or_fndef): Same change.\n+\t(c_parser_compound_statement_nostart): Same change.\n+\t(c_parser_label): Same change.\n+\t(c_parser_objc_methodprotolist): Same change.\n+\t(c_parser_omp_for_loop): Same change.\n+\t(c_parser_for_statement): Detect and parse Objective-C foreach\n+\tstatements.\n+\t(c_parser_omp_for_loop): Updated call to check_for_loop_decls().\n+\t* c-decl.c (check_for_loop_decls): Added parameter to allow ObjC\n+\tfast enumeration parsing code to turn off the c99 error but still\n+\tperform checks on the loop declarations.\n+\t* c-tree.h (check_for_loop_decls): Updated declaration.\n+\t* doc/objc.texi: Document fast enumeration.\n+\t\n 2010-10-06  Nick Clifton  <nickc@redhat.com>\n \n \t* config/mn10300/mn10300.h (FIRST_PSEUDO_REGISTER): Increment by"}, {"sha": "acb00d46369b730555729e7d1c17eedee9d9d9a1", "filename": "gcc/c-decl.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -8310,16 +8310,23 @@ finish_function (void)\n \f\n /* Check the declarations given in a for-loop for satisfying the C99\n    constraints.  If exactly one such decl is found, return it.  LOC is\n-   the location of the opening parenthesis of the for loop.  */\n+   the location of the opening parenthesis of the for loop.  The last\n+   parameter allows you to control the \"for loop initial declarations\n+   are only allowed in C99 mode\".  Normally, you should pass\n+   flag_isoc99 as that parameter.  But in some cases (Objective-C\n+   foreach loop, for example) we want to run the checks in this\n+   function even if not in C99 mode, so we allow the caller to turn\n+   off the error about not being in C99 mode.\n+*/\n \n tree\n-check_for_loop_decls (location_t loc)\n+check_for_loop_decls (location_t loc, bool turn_off_iso_c99_error)\n {\n   struct c_binding *b;\n   tree one_decl = NULL_TREE;\n   int n_decls = 0;\n \n-  if (!flag_isoc99)\n+  if (!turn_off_iso_c99_error)\n     {\n       static bool hint = true;\n       /* If we get here, declarations have been used in a for loop without"}, {"sha": "c601968aac1049073d1cc2bc04d245e13fcb282f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -1,3 +1,9 @@\n+2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented fast enumeration for Objective-C.\n+\t* c-common.h (objc_finish_foreach_loop): New.\n+\t* stub-objc.c (objc_finish_foreach_loop): New.\n+\n 2010-10-05  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-common.h (struct diagnostic_context): Don't declare here."}, {"sha": "5c35465b1cb8d5dbd298f0b126d60360955c44c7", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -1007,6 +1007,7 @@ extern int objc_static_init_needed_p (void);\n extern tree objc_generate_static_init_call (tree);\n extern tree objc_generate_write_barrier (tree, enum tree_code, tree);\n extern void objc_set_method_opt (bool);\n+extern void objc_finish_foreach_loop (location_t, tree, tree, tree, tree, tree);\n \n /* The following are provided by the C and C++ front-ends, and called by\n    ObjC/ObjC++.  */"}, {"sha": "52675840d9902b19c02abcbd437201cd7c3e053d", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -355,3 +355,11 @@ objc_generate_write_barrier (tree ARG_UNUSED (lhs),\n {\n   return 0;\n }\n+\n+void\n+objc_finish_foreach_loop (location_t ARG_UNUSED (location), tree ARG_UNUSED (object_expression),\n+\t\t\t  tree ARG_UNUSED (collection_expression), tree ARG_UNUSED (for_body),\n+\t\t\t  tree ARG_UNUSED (break_label), tree ARG_UNUSED (continue_label))\n+{\n+  return;\n+}"}, {"sha": "eb7844853b7ac2fcadf541bb19ac7b7ef9387de0", "filename": "gcc/c-parser.c", "status": "modified", "additions": 194, "deletions": 33, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -185,6 +185,11 @@ typedef struct GTY(()) c_parser {\n   /* True if we are in a context where the Objective-C \"PQ\" keywords\n      are considered keywords.  */\n   BOOL_BITFIELD objc_pq_context : 1;\n+  /* True if we are parsing a (potential) Objective-C foreach\n+     statement.  This is set to true after we parsed 'for (' and while\n+     we wait for 'in' or ';' to decide if it's a standard C for loop or an\n+     Objective-C foreach loop.  */\n+  BOOL_BITFIELD objc_could_be_foreach_context : 1;\n   /* The following flag is needed to contextualize Objective-C lexical\n      analysis.  In some cases (e.g., 'int NSObject;'), it is\n      undesirable to bind an identifier to an Objective-C class, even\n@@ -253,6 +258,26 @@ c_lex_one_token (c_parser *parser, c_token *token)\n \t\t    token->keyword = rid_code;\n \t\t    break;\n \t\t  }\n+\t\telse if (parser->objc_could_be_foreach_context\n+\t\t\t && rid_code == RID_IN)\n+\t\t  {\n+\t\t    /* We are in Objective-C, inside a (potential)\n+\t\t       foreach context (which means after having\n+\t\t       parsed 'for (', but before having parsed ';'),\n+\t\t       and we found 'in'.  We consider it the keyword\n+\t\t       which terminates the declaration at the\n+\t\t       beginning of a foreach-statement.  Note that\n+\t\t       this means you can't use 'in' for anything else\n+\t\t       in that context; in particular, in Objective-C\n+\t\t       you can't use 'in' as the name of the running\n+\t\t       variable in a C for loop.  We could potentially\n+\t\t       try to add code here to disambiguate, but it\n+\t\t       seems a reasonable limitation.\n+\t\t    */\n+\t\t    token->type = CPP_KEYWORD;\n+\t\t    token->keyword = rid_code;\n+\t\t    break;\n+\t\t  }\n \t\t/* Else, \"pq\" keywords outside of the \"pq\" context are\n \t\t   not keywords, and we fall through to the code for\n \t\t   normal tokens.\n@@ -947,7 +972,7 @@ typedef enum c_dtr_syn {\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n-\t\t\t\t\t   bool, bool);\n+\t\t\t\t\t   bool, bool, tree *);\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n@@ -1170,7 +1195,7 @@ c_parser_external_declaration (c_parser *parser)\n \t an @interface or @protocol with prefix attributes).  We can\n \t only tell which after parsing the declaration specifiers, if\n \t any, and the first declarator.  */\n-      c_parser_declaration_or_fndef (parser, true, true, true, false, true);\n+      c_parser_declaration_or_fndef (parser, true, true, true, false, true, NULL);\n       break;\n     }\n }\n@@ -1189,6 +1214,8 @@ c_parser_external_declaration (c_parser *parser)\n    (old-style parameter declarations) they are diagnosed.  If\n    START_ATTR_OK is true, the declaration specifiers may start with\n    attributes; otherwise they may not.\n+   OBJC_FOREACH_OBJECT_DECLARATION can be used to get back the parsed\n+   declaration when parsing an Objective-C foreach statement.\n \n    declaration:\n      declaration-specifiers init-declarator-list[opt] ;\n@@ -1235,6 +1262,10 @@ c_parser_external_declaration (c_parser *parser)\n    specifiers, but only at top level (elsewhere they conflict with\n    other syntax).\n \n+   In Objective-C, declarations of the looping variable in a foreach\n+   statement are exceptionally terminated by 'in' (for example, 'for\n+   (NSObject *object in array) { ... }').\n+\n    OpenMP:\n \n    declaration:\n@@ -1243,7 +1274,8 @@ c_parser_external_declaration (c_parser *parser)\n static void\n c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t       bool static_assert_ok, bool empty_ok,\n-\t\t\t       bool nested, bool start_attr_ok)\n+\t\t\t       bool nested, bool start_attr_ok,\n+\t\t\t       tree *objc_foreach_object_declaration)\n {\n   struct c_declspecs *specs;\n   tree prefix_attrs;\n@@ -1375,7 +1407,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  || c_parser_next_token_is (parser, CPP_COMMA)\n \t  || c_parser_next_token_is (parser, CPP_SEMICOLON)\n \t  || c_parser_next_token_is_keyword (parser, RID_ASM)\n-\t  || c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+\t  || c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE)\n+\t  || c_parser_next_token_is_keyword (parser, RID_IN))\n \t{\n \t  tree asm_name = NULL_TREE;\n \t  tree postfix_attrs = NULL_TREE;\n@@ -1421,7 +1454,15 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t\t    all_prefix_attrs));\n \t      if (d)\n \t\tfinish_decl (d, UNKNOWN_LOCATION, NULL_TREE,\n-\t\t    \t     NULL_TREE, asm_name);\n+\t\t\t     NULL_TREE, asm_name);\n+\t      \n+\t      if (c_parser_next_token_is_keyword (parser, RID_IN))\n+\t\t{\n+\t\t  if (d)\n+\t\t    *objc_foreach_object_declaration = d;\n+\t\t  else\n+\t\t    *objc_foreach_object_declaration = error_mark_node;\t\t    \n+\t\t}\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n@@ -1438,6 +1479,15 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      c_parser_consume_token (parser);\n \t      return;\n \t    }\n+\t  else if (c_parser_next_token_is_keyword (parser, RID_IN))\n+\t    {\n+\t      /* This can only happen in Objective-C: we found the\n+\t\t 'in' that terminates the declaration inside an\n+\t\t Objective-C foreach statement.  Do not consume the\n+\t\t token, so that the caller can use it to determine\n+\t\t that this indeed is a foreach context.  */\n+\t      return;\n+\t    }\n \t  else\n \t    {\n \t      c_parser_error (parser, \"expected %<,%> or %<;%>\");\n@@ -1484,7 +1534,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       while (c_parser_next_token_is_not (parser, CPP_EOF)\n \t     && c_parser_next_token_is_not (parser, CPP_OPEN_BRACE))\n \tc_parser_declaration_or_fndef (parser, false, false, false,\n-\t\t\t\t       true, false);\n+\t\t\t\t       true, false, NULL);\n       store_parm_decls ();\n       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus\n \t= c_parser_peek_token (parser)->location;\n@@ -3743,7 +3793,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t{\n \t  last_label = false;\n \t  mark_valid_location_for_stdc_pragma (false);\n-\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true);\n+\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true, NULL);\n \t  if (last_stmt)\n \t    pedwarn_c90 (loc,\n \t\t\t (pedantic && !flag_isoc99)\n@@ -3771,7 +3821,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t      last_label = false;\n \t      mark_valid_location_for_stdc_pragma (false);\n \t      c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t     true);\n+\t\t\t\t\t     true, NULL);\n \t      /* Following the old parser, __extension__ does not\n \t\t disable this diagnostic.  */\n \t      restore_extension_diagnostics (ext);\n@@ -3911,7 +3961,7 @@ c_parser_label (c_parser *parser)\n \t  c_parser_declaration_or_fndef (parser, /*fndef_ok*/ false,\n \t\t\t\t\t /*static_assert_ok*/ true,\n \t\t\t\t\t /*nested*/ true, /*empty_ok*/ false,\n-\t\t\t\t\t /*start_attr_ok*/ true);\n+\t\t\t\t\t /*start_attr_ok*/ true, NULL);\n \t}\n     }\n }\n@@ -4427,29 +4477,89 @@ c_parser_do_statement (c_parser *parser)\n    Note in particular that the nested function does not include a\n    trailing ';', whereas the \"declaration\" production includes one.\n    Also, can we reject bad declarations earlier and cheaper than\n-   check_for_loop_decls?  */\n+   check_for_loop_decls?\n+\n+   In Objective-C, there are two additional variants:\n+\n+   foreach-statement:\n+     for ( expression in expresssion ) statement\n+     for ( declaration in expression ) statement\n+\n+   This is inconsistent with C, because the second variant is allowed\n+   even if c99 is not enabled.\n+\n+   The rest of the comment documents these Objective-C foreach-statement.\n+\n+   Here is the canonical example of the first variant:\n+    for (object in array)    { do something with object }\n+   we call the first expression (\"object\") the \"object_expression\" and \n+   the second expression (\"array\") the \"collection_expression\".\n+   object_expression must be an lvalue of type \"id\" (a generic Objective-C\n+   object) because the loop works by assigning to object_expression the\n+   various objects from the collection_expression.  collection_expression\n+   must evaluate to something of type \"id\" which responds to the method\n+   countByEnumeratingWithState:objects:count:.\n+\n+   The canonical example of the second variant is:\n+    for (id object in array)    { do something with object }\n+   which is completely equivalent to\n+    {\n+      id object;\n+      for (object in array) { do something with object }\n+    }\n+   Note that initizializing 'object' in some way (eg, \"for ((object =\n+   xxx) in array) { do something with object }\") is possibly\n+   technically valid, but completely pointless as 'object' will be\n+   assigned to something else as soon as the loop starts.  We should\n+   most likely reject it (TODO).\n+\n+   The beginning of the Objective-C foreach-statement looks exactly\n+   like the beginning of the for-statement, and we can tell it is a\n+   foreach-statement only because the initial declaration or\n+   expression is terminated by 'in' instead of ';'.\n+*/\n \n static void\n c_parser_for_statement (c_parser *parser)\n {\n   tree block, cond, incr, save_break, save_cont, body;\n+  /* The following are only used when parsing an ObjC foreach statement.  */\n+  tree object_expression, collection_expression;\n   location_t loc = c_parser_peek_token (parser)->location;\n   location_t for_loc = c_parser_peek_token (parser)->location;\n+  bool is_foreach_statement = false;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));\n   c_parser_consume_token (parser);\n-  block = c_begin_compound_stmt (flag_isoc99);\n+  /* Open a compound statement in Objective-C as well, just in case this is\n+     as foreach expression.  */\n+  block = c_begin_compound_stmt (flag_isoc99 || c_dialect_objc ());\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       /* Parse the initialization declaration or expression.  */\n+      cond = error_mark_node;\n+      object_expression = error_mark_node;\n+\n       if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t{\n \t  c_parser_consume_token (parser);\n \t  c_finish_expr_stmt (loc, NULL_TREE);\n \t}\n       else if (c_parser_next_token_starts_declaration (parser))\n \t{\n-\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true);\n-\t  check_for_loop_decls (for_loc);\n+\t  parser->objc_could_be_foreach_context = true;\n+\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true, \n+\t\t\t\t\t &object_expression);\n+\t  parser->objc_could_be_foreach_context = false;\n+\t  \n+\t  if (c_parser_next_token_is_keyword (parser, RID_IN))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      is_foreach_statement = true;\n+\t      if (check_for_loop_decls (for_loc, true) == NULL_TREE)\n+\t\tc_parser_error (parser, \"multiple iterating variables in fast enumeration\");\n+\t    }\n+\t  else\n+\t    check_for_loop_decls (for_loc, flag_isoc99);\n \t}\n       else if (c_parser_next_token_is_keyword (parser, RID_EXTENSION))\n \t{\n@@ -4466,36 +4576,84 @@ c_parser_for_statement (c_parser *parser)\n \t      int ext;\n \t      ext = disable_extension_diagnostics ();\n \t      c_parser_consume_token (parser);\n+\t      parser->objc_could_be_foreach_context = true;\n \t      c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t     true);\n+\t\t\t\t\t     true, &object_expression);\n+\t      parser->objc_could_be_foreach_context = false;\n+\t      \n \t      restore_extension_diagnostics (ext);\n-\t      check_for_loop_decls (for_loc);\n+\t      if (c_parser_next_token_is_keyword (parser, RID_IN))\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  is_foreach_statement = true;\n+\t\t  if (check_for_loop_decls (for_loc, true) == NULL_TREE)\n+\t\t    c_parser_error (parser, \"multiple iterating variables in fast enumeration\");\n+\t\t}\n+\t      else\n+\t\tcheck_for_loop_decls (for_loc, flag_isoc99);\n \t    }\n \t  else\n \t    goto init_expr;\n \t}\n       else\n \t{\n \tinit_expr:\n-\t  c_finish_expr_stmt (loc, c_parser_expression (parser).value);\n-\t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t  {\n+\t    tree init_expression;\n+\t    parser->objc_could_be_foreach_context = true;\n+\t    init_expression = c_parser_expression (parser).value;\n+\t    parser->objc_could_be_foreach_context = false;\n+\t    if (c_parser_next_token_is_keyword (parser, RID_IN))\n+\t      {\n+\t\tc_parser_consume_token (parser);\n+\t\tis_foreach_statement = true;\n+\t\tif (! lvalue_p (init_expression))\n+\t\t  c_parser_error (parser, \"invalid iterating variable in fast enumeration\");\n+\t\tobject_expression = c_process_expr_stmt (loc, init_expression);\n+\n+\t      }\n+\t    else\n+\t      {\n+\t\tc_finish_expr_stmt (loc, init_expression);\n+\t\tc_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t      }\n+\t  }\n \t}\n-      /* Parse the loop condition.  */\n-      if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+      /* Parse the loop condition.  In the case of a foreach\n+\t statement, there is no loop condition.  */\n+      if (!is_foreach_statement)\n \t{\n-\t  c_parser_consume_token (parser);\n-\t  cond = NULL_TREE;\n+\t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      cond = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      cond = c_parser_condition (parser);\n+\t      c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t    }\n \t}\n-      else\n+      /* Parse the increment expression (the third expression in a\n+\t for-statement).  In the case of a foreach-statement, this is\n+\t the expression that follows the 'in'.  */\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n-\t  cond = c_parser_condition (parser);\n-\t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t  if (is_foreach_statement)\n+\t    {\n+\t      c_parser_error (parser, \"missing collection in fast enumeration\");\n+\t      collection_expression = error_mark_node;\n+\t    }\n+\t  else\n+\t    incr = c_process_expr_stmt (loc, NULL_TREE);\n \t}\n-      /* Parse the increment expression.  */\n-      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\tincr = c_process_expr_stmt (loc, NULL_TREE);\n       else\n-\tincr = c_process_expr_stmt (loc, c_parser_expression (parser).value);\n+\t{\n+\t  if (is_foreach_statement)\n+\t    collection_expression = c_process_expr_stmt (loc, c_parser_expression (parser).value);\n+\t  else\n+\t    incr = c_process_expr_stmt (loc, c_parser_expression (parser).value);\n+\t}\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   else\n@@ -4508,8 +4666,11 @@ c_parser_for_statement (c_parser *parser)\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n   body = c_parser_c99_block_statement (parser);\n-  c_finish_loop (loc, cond, incr, body, c_break_label, c_cont_label, true);\n-  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n+  if (is_foreach_statement)\n+    objc_finish_foreach_loop (loc, object_expression, collection_expression, body, c_break_label, c_cont_label);\n+  else\n+    c_finish_loop (loc, cond, incr, body, c_break_label, c_cont_label, true);\n+  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99 || c_dialect_objc ()));\n   c_break_label = save_break;\n   c_cont_label = save_cont;\n }\n@@ -6790,7 +6951,7 @@ c_parser_objc_methodprotolist (c_parser *parser)\n \t    }\n \t  else\n \t    c_parser_declaration_or_fndef (parser, false, false, true,\n-\t\t\t\t\t false, true);\n+\t\t\t\t\t   false, true, NULL);\n \t  break;\n \t}\n     }\n@@ -8439,8 +8600,8 @@ c_parser_omp_for_loop (location_t loc,\n \t{\n \t  if (i > 0)\n \t    VEC_safe_push (tree, gc, for_block, c_begin_compound_stmt (true));\n-\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true);\n-\t  decl = check_for_loop_decls (for_loc);\n+\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true, NULL);\n+\t  decl = check_for_loop_decls (for_loc, flag_isoc99);\n \t  if (decl == NULL)\n \t    goto error_init;\n \t  if (DECL_INITIAL (decl) == error_mark_node)"}, {"sha": "0d94cebd84d15559b67c64c2822c1587c65f3bb9", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -429,7 +429,7 @@ extern struct c_declarator *build_array_declarator (location_t, tree,\n \t\t\t\t\t\t    bool, bool);\n extern tree build_enumerator (location_t, location_t, struct c_enum_contents *,\n \t\t\t      tree, tree);\n-extern tree check_for_loop_decls (location_t);\n+extern tree check_for_loop_decls (location_t, bool);\n extern void mark_forward_parm_decls (void);\n extern void declare_parm_level (void);\n extern void undeclared_variable (location_t, tree);"}, {"sha": "2bb80d15254e9778e0151a91d737476198b300e2", "filename": "gcc/doc/objc.texi", "status": "modified", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fdoc%2Fobjc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fdoc%2Fobjc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fobjc.texi?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -20,6 +20,7 @@ several resources on the Internet that present the language.\n * compatibility_alias::\n * Exceptions::\n * Synchronization::\n+* Fast enumeration::\n @end menu\n \n @node Executing code before main\n@@ -739,3 +740,218 @@ Because of the interactions between synchronization and exception\n handling, you can only use @code{@@synchronized} when compiling with\n exceptions enabled, that is with the command line option\n @option{-fobjc-exceptions}.\n+\n+\n+@c =========================================================================\n+@node Fast enumeration\n+@section Fast enumeration\n+\n+@menu\n+* Using fast enumeration::\n+* c99-like fast enumeration syntax::\n+* Fast enumeration details::\n+* Fast enumeration protocol::\n+@end menu\n+\n+@c ================================\n+@node Using fast enumeration\n+@subsection Using fast enumeration\n+\n+GNU Objective-C provides support for the fast enumeration syntax:\n+\n+@smallexample\n+  id array = @dots{};\n+  id object;\n+\n+  for (object in array)\n+  @{\n+    /* Do something with 'object' */\n+  @}\n+@end smallexample\n+\n+@code{array} needs to be an Objective-C object (usually a collection\n+object, for example an array, a dictionary or a set) which implements\n+the ``Fast Enumeration Protocol'' (see below).  If you are using a\n+Foundation library such as GNUstep Base or Apple Cocoa Foundation, all\n+collection objects in the library implement this protocol and can be\n+used in this way.\n+\n+The code above would iterate over all objects in @code{array}.  For\n+each of them, it assigns it to @code{object}, then executes the\n+@code{Do something with 'object'} statements.\n+\n+Here is a fully worked-out example using a Foundation library (which\n+provides the implementation of @code{NSArray}, @code{NSString} and\n+@code{NSLog}):\n+\n+@smallexample\n+  NSArray *array = [NSArray arrayWithObjects: @@\"1\", @@\"2\", @@\"3\", nil];\n+  NSString *object;\n+\n+  for (object in array)\n+    NSLog (@@\"Iterating over %@@\", object);\n+@end smallexample\n+\n+\n+@c ================================\n+@node c99-like fast enumeration syntax\n+@subsection c99-like fast enumeration syntax\n+\n+A c99-like declaration syntax is also allowed:\n+\n+@smallexample\n+  id array = @dots{};\n+\n+  for (id object in array)\n+  @{\n+    /* Do something with 'object'  */\n+  @}\n+@end smallexample\n+\n+this is completely equivalent to:\n+\n+@smallexample\n+  id array = @dots{};\n+\n+  @{\n+    id object;\n+    for (object in array)\n+    @{\n+      /* Do something with 'object'  */\n+    @}\n+  @}\n+@end smallexample\n+\n+but can save some typing.\n+\n+Note that the option @option{-std=c99} is not required to allow this\n+syntax in Objective-C.\n+\n+@c ================================\n+@node Fast enumeration details\n+@subsection Fast enumeration details\n+\n+Here is a more technical description with the gory details.  Consider the code\n+\n+@smallexample\n+  for (@var{object expression} in @var{collection expression})\n+  @{\n+    @var{statements}\n+  @}\n+@end smallexample\n+\n+here is what happens when you run it:\n+\n+@itemize @bullet\n+@item\n+@code{@var{collection expression}} is evaluated exactly once and the\n+result is used as the collection object to iterate over.  This means\n+it is safe to write code such as @code{for (object in [NSDictionary\n+keyEnumerator]) @dots{}}.\n+\n+@item\n+the iteration is implemented by the compiler by repeatedly getting\n+batches of objects from the collection object using the fast\n+enumeration protocol (see below), then iterating over all objects in\n+the batch.  This is faster than a normal enumeration where objects are\n+retrieved one by one (hence the name ``fast enumeration'').\n+\n+@item\n+if there are no objects in the collection, then\n+@code{@var{object expression}} is set to @code{nil} and the loop\n+immediately terminates.\n+\n+@item\n+if there are objects in the collection, then for each object in the\n+collection (in the order they are returned) @code{@var{object expression}}\n+is set to the object, then @code{@var{statements}} are executed.\n+\n+@item\n+@code{@var{statements}} can contain @code{break} and @code{continue}\n+commands, which will abort the iteration or skip to the next loop\n+iteration as expected.\n+\n+@item\n+when the iteration ends because there are no more objects to iterate\n+over, @code{@var{object expression}} is set to @code{nil}.  This allows\n+you to determine whether the iteration finished because a @code{break}\n+command was used (in which case @code{@var{object expression}} will remain\n+set to the last object that was iterated over) or because it iterated\n+over all the objects (in which case @code{@var{object expression}} will be\n+set to @code{nil}).\n+\n+@item\n+@code{@var{statements}} must not make any changes to the collection\n+object; if they do, it is a hard error and the fast enumeration\n+terminates by invoking @code{objc_enumerationMutation}, a runtime\n+function that normally aborts the program but which can be customized\n+by Foundation libraries via @code{objc_set_mutation_handler} to do\n+something different, such as raising an exception.\n+\n+@end itemize\n+\n+@c ================================\n+@node Fast enumeration protocol\n+@subsection Fast enumeration protocol\n+\n+If you want your own collection object to be usable with fast\n+enumeration, you need to have it implement the method\n+\n+@smallexample\n+- (unsigned long) countByEnumeratingWithState: (NSFastEnumerationState *)state \n+                                      objects: (id *)objects\n+                                        count: (unsigneld long)len;\n+@end smallexample\n+\n+where @code{NSFastEnumerationState} must be defined in your code as follows:\n+\n+@smallexample\n+typdef struct\n+@{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+@} NSFastEnumerationState;\n+@end smallexample\n+\n+If no @code{NSFastEnumerationState} is defined in your code, the\n+compiler will automatically replace @code{NSFastEnumerationState *}\n+with @code{struct __objcFastEnumerationState *}, where that type is\n+silently defined by the compiler in an identical way.  This can be\n+confusing and we recommend that you define\n+@code{NSFastEnumerationState} (as shown above) instead.\n+\n+The method is called repeatedly during a fast enumeration to retrieve\n+batches of objects.  Each invocation of the method should retrieve the\n+next batch of objects.\n+\n+The return value of the method is the number of objects in the current\n+batch; this should not exceed @code{len}, which is the maximum size of\n+a batch as requested by the caller.  The batch itself is returned in\n+the @code{itemsPtr} field of the @code{NSFastEnumerationState} struct.\n+\n+To help with returning the objects, the @code{objects} array is a C\n+array preallocated by the caller (on the stack) of size @code{len}.\n+In many cases you can put the objects you want to return in that\n+@code{objects} array, then do @code{itemsPtr = objects}.  But you\n+don't have to; if your collection already has the objects to return in\n+some form of C array, it could return them from there instead.\n+\n+The @code{state} and @code{extra} fields of the\n+@code{NSFastEnumerationState} structure allows your collection object\n+to keep track of the state of the enumeration.  In a simple array\n+implementation, @code{state} may keep track of the index of the last\n+object that was returned, and @code{extra} may be unused.\n+\n+The @code{mutationsPtr} field of the @code{NSFastEnumerationState} is\n+used to keep track of mutations.  It should point to a number; before\n+working on each object, the fast enumeration loop will check that this\n+number has not changed.  If it has, a mutation has happened and the\n+fast enumeration will abort.  So, @code{mutationsPtr} could be set to\n+point to some sort of version number of your collection, which is\n+increased by one every time there is a change (for example when an\n+object is added or removed).  Or, if you are content with less strict\n+mutation checks, it could point to the number of objects in your\n+collection or some other value that can be checked to perform an\n+approximate check that the collection has not been mutated."}, {"sha": "eed86bd4a0659e6c9ea23ae7229d27c5b15760d0", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -1,12 +1,40 @@\n+2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented fast enumeration for Objective-C.\n+\t* objc-act.c (build_fast_enumeration_state_template): New.\n+\t(TAG_ENUMERATION_MUTATION): New.\n+\t(TAG_FAST_ENUMERATION_STATE): New.\n+\t(synth_module_prologue): Call build_fast_enumeration_state_template() and set up\n+\tobjc_enumeration_mutation_decl.\n+\t(objc_create_temporary_var): Allow providing a name to temporary\n+\tvariables.\n+\t(objc_build_exc_ptr): Updated calls to\n+\tobjc_create_temporary_var().\n+\t(next_sjlj_build_try_catch_finally): Same change.\n+\t(objc_finish_foreach_loop): New.\n+\t* objc-act.h: Added OCTI_FAST_ENUM_STATE_TEMP,\n+\tOCTI_ENUM_MUTATION_DECL, objc_fast_enumeration_state_template,\n+\tobjc_enumeration_mutation_decl.\n+\n+\tMerge from 'apple/trunk' branch on FSF servers.\n+\n+\t2006-04-12 Fariborz Jahanian <fjahanian@apple.com>\n+\n+        Radar 4507230\n+\t* objc-act.c (objc_type_valid_for_messaging): New routine to check\n+\tfor valid objc object types.\n+\t(objc_finish_foreach_loop): Check for invalid objc objects in\n+\tforeach header.\n+\t\n 2010-10-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\n \n \t2005-10-17  Fariborz Jahanian <fjahanian@apple.com>\n \n         Radar 4290840\n-\t* objc-act.c (objc_start_method_definition): Check for error_mark_node for\n-\tthe selector name and make a quick exit.\n+\t* objc-act.c (objc_start_method_definition): Check for\n+\terror_mark_node for the selector name and make a quick exit.\n \t\n 2010-10-04  Andi Kleen <ak@linux.intel.com>\n "}, {"sha": "730efba48d832c832277780f6203b4c362a6cc3b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 579, "deletions": 6, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -171,6 +171,8 @@ static tree get_class_ivars (tree, bool);\n static tree generate_protocol_list (tree);\n static void build_protocol_reference (tree);\n \n+static void build_fast_enumeration_state_template (void);\n+\n #ifdef OBJCPLUS\n static void objc_generate_cxx_cdtors (void);\n #endif\n@@ -240,6 +242,7 @@ static void generate_struct_by_value_array (void)\n      ATTRIBUTE_NORETURN;\n static void mark_referenced_methods (void);\n static void generate_objc_image_info (void);\n+static bool objc_type_valid_for_messaging (tree typ);\n \n /*** Private Interface (data) ***/\n \n@@ -274,6 +277,9 @@ static void generate_objc_image_info (void);\n \n #define PROTOCOL_OBJECT_CLASS_NAME\t\"Protocol\"\n \n+#define TAG_ENUMERATION_MUTATION        \"objc_enumerationMutation\"\n+#define TAG_FAST_ENUMERATION_STATE      \"__objcFastEnumerationState\"\n+\n static const char *TAG_GETCLASS;\n static const char *TAG_GETMETACLASS;\n static const char *TAG_MSGSEND;\n@@ -1952,6 +1958,17 @@ synth_module_prologue (void)\n   self_id = get_identifier (\"self\");\n   ucmd_id = get_identifier (\"_cmd\");\n \n+  /* Declare struct _objc_fast_enumeration_state { ... };  */\n+  build_fast_enumeration_state_template ();\n+  \n+  /* void objc_enumeration_mutation (id) */\n+  type = build_function_type (void_type_node,\n+\t\t\t      tree_cons (NULL_TREE, objc_object_type, NULL_TREE));\n+  objc_enumeration_mutation_decl \n+    = add_builtin_function (TAG_ENUMERATION_MUTATION, type, 0, NOT_BUILT_IN, \n+\t\t\t    NULL, NULL_TREE);\n+  TREE_NOTHROW (objc_enumeration_mutation_decl) = 0;\n+\n #ifdef OBJCPLUS\n   pop_lang_context ();\n #endif\n@@ -3596,13 +3613,25 @@ get_class_ivars (tree interface, bool inherited)\n   return ivar_chain;\n }\n \n+/* Create a temporary variable of type 'type'.  If 'name' is set, uses\n+   the specified name, else use no name.  Returns the declaration of\n+   the type.  The 'name' is mostly useful for debugging.\n+*/\n static tree\n-objc_create_temporary_var (tree type)\n+objc_create_temporary_var (tree type, const char *name)\n {\n   tree decl;\n \n-  decl = build_decl (input_location,\n-\t\t     VAR_DECL, NULL_TREE, type);\n+  if (name != NULL)\n+    {\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (name), type);\n+    }\n+  else\n+    {\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, NULL_TREE, type);\n+    }\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n@@ -3687,7 +3716,7 @@ objc_build_exc_ptr (void)\n       tree var = cur_try_context->caught_decl;\n       if (!var)\n \t{\n-\t  var = objc_create_temporary_var (objc_object_type);\n+\t  var = objc_create_temporary_var (objc_object_type, NULL);\n \t  cur_try_context->caught_decl = var;\n \t}\n       return var;\n@@ -3888,10 +3917,10 @@ next_sjlj_build_try_catch_finally (void)\n \n   /* Create the declarations involved.  */\n   t = xref_tag (RECORD_TYPE, get_identifier (UTAG_EXCDATA));\n-  stack_decl = objc_create_temporary_var (t);\n+  stack_decl = objc_create_temporary_var (t, NULL);\n   cur_try_context->stack_decl = stack_decl;\n \n-  rethrow_decl = objc_create_temporary_var (objc_object_type);\n+  rethrow_decl = objc_create_temporary_var (objc_object_type, NULL);\n   cur_try_context->rethrow_decl = rethrow_decl;\n   TREE_CHAIN (rethrow_decl) = stack_decl;\n \n@@ -9980,4 +10009,548 @@ objc_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n #endif\n }\n \n+/* This routine returns true if TYP is a valid objc object type, \n+   suitable for messaging; false otherwise.\n+*/\n+\n+static bool\n+objc_type_valid_for_messaging (tree typ)\n+{\n+  if (!POINTER_TYPE_P (typ))\n+    return false;\n+\n+  do\n+    typ = TREE_TYPE (typ);  /* Remove indirections.  */\n+  while (POINTER_TYPE_P (typ));\n+\n+  if (TREE_CODE (typ) != RECORD_TYPE)\n+    return false;\n+\n+  return objc_is_object_id (typ) || TYPE_HAS_OBJC_INFO (typ);\n+}\n+\n+/* Begin code generation for fast enumeration (foreach) ... */\n+\n+/* Defines\n+\n+  struct __objcFastEnumerationState\n+   {\n+     unsigned long state;\n+     id            *itemsPtr;\n+     unsigned long *mutationsPtr;\n+     unsigned long extra[5];\n+   };\n+\n+   Confusingly enough, NSFastEnumeration is then defined by libraries\n+   to be the same structure.  \n+*/\n+\n+static void\n+build_fast_enumeration_state_template (void)\n+{\n+  tree decls, *chain = NULL;\n+\n+  /* { */\n+  objc_fast_enumeration_state_template = objc_start_struct (get_identifier \n+\t\t\t\t\t\t\t    (TAG_FAST_ENUMERATION_STATE));\n+\n+  /* unsigned long state; */\n+  decls = add_field_decl (long_unsigned_type_node, \"state\", &chain);\n+\n+  /* id            *itemsPtr; */\n+  add_field_decl (build_pointer_type (objc_object_type), \n+\t\t  \"itemsPtr\", &chain);\n+\n+  /* unsigned long *mutationsPtr; */\n+  add_field_decl (build_pointer_type (long_unsigned_type_node), \n+\t\t  \"mutationsPtr\", &chain);\n+\n+  /* unsigned long extra[5]; */\n+  add_field_decl (build_sized_array_type (long_unsigned_type_node, 5), \n+\t\t  \"extra\", &chain);\n+\n+  /* } */\n+  objc_finish_struct (objc_fast_enumeration_state_template, decls);\n+}\n+\n+/*\n+  'objc_finish_foreach_loop()' generates the code for an Objective-C\n+  foreach loop.  The 'location' argument is the location of the 'for'\n+  that starts the loop.  The 'object_expression' is the expression of\n+  the 'object' that iterates; the 'collection_expression' is the\n+  expression of the collection that we iterate over (we need to make\n+  sure we evaluate this only once); the 'for_body' is the set of\n+  statements to be executed in each iteration; 'break_label' and\n+  'continue_label' are the break and continue labels which we need to\n+  emit since the <statements> may be jumping to 'break_label' (if they\n+  contain 'break') or to 'continue_label' (if they contain\n+  'continue').\n+\n+  The syntax is\n+  \n+  for (<object expression> in <collection expression>)\n+    <statements>\n+\n+  which is compiled into the following blurb:\n+\n+  {\n+    id __objc_foreach_collection;\n+    __objc_fast_enumeration_state __objc_foreach_enum_state;\n+    unsigned long __objc_foreach_batchsize;\n+    id __objc_foreach_items[16];\n+    __objc_foreach_collection = <collection expression>;\n+    __objc_foreach_enum_state = { 0 };\n+    __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16];\n+    \n+    if (__objc_foreach_batchsize == 0)\n+      <object expression> = nil;\n+    else\n+      {\n+\tunsigned long __objc_foreach_mutations_pointer = *__objc_foreach_enum_state.mutationsPtr;\n+        next_batch:\n+\t  {\n+\t    unsigned long __objc_foreach_index;\n+            __objc_foreach_index = 0;\n+\n+            next_object:\n+\t    if (__objc_foreach_mutation_pointer != *__objc_foreach_enum_state.mutationsPtr) objc_enumeration_mutation (<collection expression>);\n+\t    <object expression> = enumState.itemsPtr[__objc_foreach_index];\n+\t    <statements> [PS: inside <statments>, 'break' jumps to break_label and 'continue' jumps to continue_label]\n+\n+            continue_label:\n+            __objc_foreach_index++;\n+            if (__objc_foreach_index < __objc_foreach_batchsize) goto next_object;\n+\t    __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16];\n+         }\n+       if (__objc_foreach_batchsize != 0) goto next_batch;\n+       <object expression> = nil;\n+       break_label:\n+      }\n+  }\n+\n+  'statements' may contain a 'continue' or 'break' instruction, which\n+  the user expects to 'continue' or 'break' the entire foreach loop.\n+  We are provided the labels that 'break' and 'continue' jump to, so\n+  we place them where we want them to jump to when they pick them.\n+  \n+  Optimization TODO: we could cache the IMP of\n+  countByEnumeratingWithState:objects:count:.\n+*/\n+\n+/* If you need to debug objc_finish_foreach_loop(), uncomment the following line.  */\n+/* #define DEBUG_OBJC_FINISH_FOREACH_LOOP 1 */\n+\n+#ifdef DEBUG_OBJC_FINISH_FOREACH_LOOP\n+#include \"tree-pretty-print.h\"\n+#endif\n+\n+void\n+objc_finish_foreach_loop (location_t location, tree object_expression, tree collection_expression, tree for_body, \n+\t\t\t  tree break_label, tree continue_label)\n+{\n+  /* A tree representing the __objcFastEnumerationState struct type,\n+     or NSFastEnumerationState struct, whatever we are using.  */\n+  tree objc_fast_enumeration_state_type;\n+\n+  /* The trees representing the declarations of each of the local variables.  */\n+  tree objc_foreach_collection_decl;\n+  tree objc_foreach_enum_state_decl;\n+  tree objc_foreach_items_decl;\n+  tree objc_foreach_batchsize_decl;\n+  tree objc_foreach_mutations_pointer_decl;\n+  tree objc_foreach_index_decl;\n+\n+  /* A tree representing the selector countByEnumeratingWithState:objects:count:.  */\n+  tree selector_name;\n+\n+  /* A tree representing the local bind.  */\n+  tree bind;\n+\n+  /* A tree representing the external 'if (__objc_foreach_batchsize)' */\n+  tree first_if;\n+\n+  /* A tree representing the 'else' part of 'first_if'  */\n+  tree first_else;\n+\n+  /* A tree representing the 'next_batch' label.  */\n+  tree next_batch_label_decl;\n+\n+  /* A tree representing the binding after the 'next_batch' label.  */\n+  tree next_batch_bind;\n+\n+  /* A tree representing the 'next_object' label.  */\n+  tree next_object_label_decl;\n+\n+  /* Temporary variables.  */\n+  tree t;\n+  int i;\n+\n+  if (object_expression == error_mark_node)\n+    return;\n+\n+  if (collection_expression == error_mark_node)\n+    return;\n+\n+  if (!objc_type_valid_for_messaging (TREE_TYPE (object_expression)))\n+    {\n+      error (\"iterating variable in fast enumeration is not an object\");\n+      return;\n+    }\n+\n+  if (!objc_type_valid_for_messaging (TREE_TYPE (collection_expression)))\n+    {\n+      error (\"collection in fast enumeration is not an object\");\n+      return;\n+    }\n+\n+  /* TODO: Check that object_expression is either a variable\n+     declaration, or an lvalue.  */\n+\n+  /* This kludge is an idea from apple.  We use the\n+     __objcFastEnumerationState struct implicitly defined by the\n+     compiler, unless a NSFastEnumerationState struct has been defined\n+     (by a Foundation library such as GNUstep Base) in which case, we\n+     use that one.\n+  */\n+  objc_fast_enumeration_state_type = objc_fast_enumeration_state_template;\n+  {\n+    tree objc_NSFastEnumeration_type = lookup_name (get_identifier (\"NSFastEnumerationState\"));\n+\n+    if (objc_NSFastEnumeration_type)\n+      {\n+\t/* TODO: We really need to check that\n+\t   objc_NSFastEnumeration_type is the same as ours!  */\n+\tif (TREE_CODE (objc_NSFastEnumeration_type) == TYPE_DECL)\n+\t  {\n+\t    /* If it's a typedef, use the original type.  */\n+\t    if (DECL_ORIGINAL_TYPE (objc_NSFastEnumeration_type))\n+\t      objc_fast_enumeration_state_type = DECL_ORIGINAL_TYPE (objc_NSFastEnumeration_type);\n+\t    else\n+\t      objc_fast_enumeration_state_type = TREE_TYPE (objc_NSFastEnumeration_type);\t      \n+\t  }\n+      }\n+  }\n+\n+  /* { */\n+  /* Done by c-parser.c.  */\n+\n+  /* type object; */\n+  /* Done by c-parser.c.  */\n+\n+  /*  id __objc_foreach_collection */\n+  objc_foreach_collection_decl = objc_create_temporary_var (objc_object_type, \"__objc_foreach_collection\");\n+\n+  /*  __objcFastEnumerationState __objc_foreach_enum_state; */\n+  objc_foreach_enum_state_decl = objc_create_temporary_var (objc_fast_enumeration_state_type, \"__objc_foreach_enum_state\");\n+  TREE_CHAIN (objc_foreach_enum_state_decl) = objc_foreach_collection_decl;\n+\n+  /* id __objc_foreach_items[16]; */\n+  objc_foreach_items_decl = objc_create_temporary_var (build_sized_array_type (objc_object_type, 16), \"__objc_foreach_items\");\n+  TREE_CHAIN (objc_foreach_items_decl) = objc_foreach_enum_state_decl;\n+\n+  /* unsigned long __objc_foreach_batchsize; */\n+  objc_foreach_batchsize_decl = objc_create_temporary_var (long_unsigned_type_node, \"__objc_foreach_batchsize\");\n+  TREE_CHAIN (objc_foreach_batchsize_decl) = objc_foreach_items_decl;\n+\n+  /* Generate the local variable binding.  */\n+  bind = build3 (BIND_EXPR, void_type_node, objc_foreach_batchsize_decl, NULL, NULL);\n+  SET_EXPR_LOCATION (bind, location);\n+  TREE_SIDE_EFFECTS (bind) = 1;\n+  \n+  /*  __objc_foreach_collection = <collection expression>; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_collection_decl, collection_expression);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n+  /*  __objc_foreach_enum_state.state = 0; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t\t     get_identifier (\"state\")),\n+\t      build_int_cst (long_unsigned_type_node, 0));\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n+  /*  __objc_foreach_enum_state.itemsPtr = NULL; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t\t     get_identifier (\"itemsPtr\")),\n+\t      null_pointer_node);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n+  /*  __objc_foreach_enum_state.mutationsPtr = NULL; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t\t     get_identifier (\"mutationsPtr\")),\n+\t      null_pointer_node);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n+  /*  __objc_foreach_enum_state.extra[0] = 0; */\n+  /*  __objc_foreach_enum_state.extra[1] = 0; */\n+  /*  __objc_foreach_enum_state.extra[2] = 0; */\n+  /*  __objc_foreach_enum_state.extra[3] = 0; */\n+  /*  __objc_foreach_enum_state.extra[4] = 0; */\n+  for (i = 0; i < 5 ; i++)\n+    {\n+      t = build2 (MODIFY_EXPR, void_type_node,\n+\t\t  build_array_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t\t       get_identifier (\"extra\")),\n+\t\t\t\t   build_int_cst (NULL_TREE, i)),\n+\t\t  build_int_cst (long_unsigned_type_node, 0));\n+      SET_EXPR_LOCATION (t, location);\n+      append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+    }\n+    \n+  /* __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16]; */\n+  selector_name = get_identifier (\"countByEnumeratingWithState:objects:count:\");\n+#ifdef OBJCPLUS\n+  t = objc_finish_message_expr (objc_foreach_collection_decl, selector_name,\n+\t\t\t\t/* Parameters.  */\n+\t\t\t\ttree_cons    /* &__objc_foreach_enum_state */\n+\t\t\t\t(NULL_TREE, build_fold_addr_expr_loc (location, objc_foreach_enum_state_decl),\n+\t\t\t\t tree_cons   /* __objc_foreach_items  */\n+\t\t\t\t (NULL_TREE, objc_foreach_items_decl,\n+\t\t\t\t  tree_cons  /* 16 */\n+\t\t\t\t  (NULL_TREE, build_int_cst (NULL_TREE, 16), NULL_TREE))));\n+#else\n+  /* In C, we need to decay the __objc_foreach_items array that we are passing.  */\n+  {\n+    struct c_expr array;\n+    array.value = objc_foreach_items_decl;\n+    t = objc_finish_message_expr (objc_foreach_collection_decl, selector_name,\n+\t\t\t\t  /* Parameters.  */\n+\t\t\t\t  tree_cons    /* &__objc_foreach_enum_state */\n+\t\t\t\t  (NULL_TREE, build_fold_addr_expr_loc (location, objc_foreach_enum_state_decl),\n+\t\t\t\t   tree_cons   /* __objc_foreach_items  */\n+\t\t\t\t   (NULL_TREE, default_function_array_conversion (location, array).value,\n+\t\t\t\t    tree_cons  /* 16 */\n+\t\t\t\t    (NULL_TREE, build_int_cst (NULL_TREE, 16), NULL_TREE))));\n+  }\n+#endif\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_batchsize_decl, t);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n+  /* if (__objc_foreach_batchsize == 0) */\n+  first_if = build3 (COND_EXPR, void_type_node, \n+\t\t     /* Condition.  */\n+\t\t     c_fully_fold \n+\t\t     (c_common_truthvalue_conversion \n+\t\t      (location, \n+\t\t       build_binary_op (location,\n+\t\t\t\t\tEQ_EXPR, \n+\t\t\t\t\tobjc_foreach_batchsize_decl,\n+\t\t\t\t\tbuild_int_cst (long_unsigned_type_node, 0), 1)),\n+\t\t      false, NULL),\n+\t\t     /* Then block (we fill it in later).  */\n+\t\t     NULL_TREE,\n+\t\t     /* Else block (we fill it in later).  */\n+\t\t     NULL_TREE);\n+  SET_EXPR_LOCATION (first_if, location);\n+  append_to_statement_list (first_if, &BIND_EXPR_BODY (bind));\n+\n+  /* then <object expression> = nil; */\n+  t = build2 (MODIFY_EXPR, void_type_node, object_expression, convert (objc_object_type, null_pointer_node));\n+  SET_EXPR_LOCATION (t, location);\n+  COND_EXPR_THEN (first_if) = t;\n+\n+  /* Now we build the 'else' part of the if; once we finish building\n+     it, we attach it to first_if as the 'else' part.  */\n+\n+  /* else */\n+  /* { */\n+\n+  /* unsigned long __objc_foreach_mutations_pointer; */\n+  objc_foreach_mutations_pointer_decl = objc_create_temporary_var (long_unsigned_type_node, \"__objc_foreach_mutations_pointer\");\n+\n+  /* Generate the local variable binding.  */\n+  first_else = build3 (BIND_EXPR, void_type_node, objc_foreach_mutations_pointer_decl, NULL, NULL);\n+  SET_EXPR_LOCATION (first_else, location);\n+  TREE_SIDE_EFFECTS (first_else) = 1;\n+\n+  /* __objc_foreach_mutations_pointer = *__objc_foreach_enum_state.mutationsPtr; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_mutations_pointer_decl, \n+\t      build_indirect_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t\t      get_identifier (\"mutationsPtr\")),\n+\t\t\t\t  RO_UNARY_STAR));\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n+\n+  /* next_batch: */\n+  next_batch_label_decl = create_artificial_label (location);\n+  t = build1 (LABEL_EXPR, void_type_node, next_batch_label_decl); \n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n+  \n+  /* { */\n+\n+  /* unsigned long __objc_foreach_index; */\n+  objc_foreach_index_decl = objc_create_temporary_var (long_unsigned_type_node, \"__objc_foreach_index\");\n+\n+  /* Generate the local variable binding.  */\n+  next_batch_bind = build3 (BIND_EXPR, void_type_node, objc_foreach_index_decl, NULL, NULL);\n+  SET_EXPR_LOCATION (next_batch_bind, location);\n+  TREE_SIDE_EFFECTS (next_batch_bind) = 1;\n+  append_to_statement_list (next_batch_bind, &BIND_EXPR_BODY (first_else));\n+\n+  /* __objc_foreach_index = 0; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_index_decl,\n+\t      build_int_cst (long_unsigned_type_node, 0));\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* next_object: */\n+  next_object_label_decl = create_artificial_label (location);\n+  t = build1 (LABEL_EXPR, void_type_node, next_object_label_decl);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* if (__objc_foreach_mutation_pointer != *__objc_foreach_enum_state.mutationsPtr) objc_enumeration_mutation (<collection expression>); */\n+  t = build3 (COND_EXPR, void_type_node, \n+\t      /* Condition.  */\n+\t      c_fully_fold \n+\t      (c_common_truthvalue_conversion \n+\t       (location, \n+\t\tbuild_binary_op \n+\t\t(location,\n+\t\t NE_EXPR, \n+\t\t objc_foreach_mutations_pointer_decl,\n+\t\t build_indirect_ref (location, \n+\t\t\t\t     objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t       get_identifier (\"mutationsPtr\")),\n+\t\t\t\t     RO_UNARY_STAR), 1)),\n+\t       false, NULL),\n+\t      /* Then block.  */\n+\t      build_function_call (input_location,\n+\t\t\t\t   objc_enumeration_mutation_decl,\n+\t\t\t\t   tree_cons (NULL, collection_expression, NULL)),\n+\t      /* Else block.  */\n+\t      NULL_TREE);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* <object expression> = enumState.itemsPtr[__objc_foreach_index]; */\n+  t = build2 (MODIFY_EXPR, void_type_node, object_expression, \n+\t      build_array_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t\t\t\t\t\t\t   get_identifier (\"itemsPtr\")),\n+\t\t\t       objc_foreach_index_decl));\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* <statements> [PS: in <statments>, 'break' jumps to break_label and 'continue' jumps to continue_label] */\n+  append_to_statement_list (for_body, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* continue_label: */\n+  if (continue_label)\n+    {\n+      t = build1 (LABEL_EXPR, void_type_node, continue_label);\n+      SET_EXPR_LOCATION (t, location);\n+      append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+    }\n+\n+  /* __objc_foreach_index++; */\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_index_decl, \n+\t      build_binary_op (location,\n+\t\t\t       PLUS_EXPR,\n+\t\t\t       objc_foreach_index_decl,\n+\t\t\t       build_int_cst (long_unsigned_type_node, 1), 1));\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* if (__objc_foreach_index < __objc_foreach_batchsize) goto next_object; */\n+  t = build3 (COND_EXPR, void_type_node, \n+\t      /* Condition.  */\n+\t      c_fully_fold \n+\t      (c_common_truthvalue_conversion \n+\t       (location, \n+\t\tbuild_binary_op (location,\n+\t\t\t\t LT_EXPR, \n+\t\t\t\t objc_foreach_index_decl,\n+\t\t\t\t objc_foreach_batchsize_decl, 1)),\n+\t       false, NULL),\n+\t      /* Then block.  */\n+\t      build1 (GOTO_EXPR, void_type_node, next_object_label_decl),\n+\t      /* Else block.  */\n+\t      NULL_TREE);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+  \n+  /* __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16]; */\n+#ifdef OBJCPLUS\n+  t = objc_finish_message_expr (objc_foreach_collection_decl, selector_name,\n+\t\t\t\t/* Parameters.  */\n+\t\t\t\ttree_cons    /* &__objc_foreach_enum_state */\n+\t\t\t\t(NULL_TREE, build_fold_addr_expr_loc (location, objc_foreach_enum_state_decl),\n+\t\t\t\t tree_cons   /* __objc_foreach_items  */\n+\t\t\t\t (NULL_TREE, objc_foreach_items_decl,\n+\t\t\t\t  tree_cons  /* 16 */\n+\t\t\t\t  (NULL_TREE, build_int_cst (NULL_TREE, 16), NULL_TREE))));\n+#else\n+  /* In C, we need to decay the __objc_foreach_items array that we are passing.  */\n+  {\n+    struct c_expr array;\n+    array.value = objc_foreach_items_decl;\n+    t = objc_finish_message_expr (objc_foreach_collection_decl, selector_name,\n+\t\t\t\t  /* Parameters.  */\n+\t\t\t\t  tree_cons    /* &__objc_foreach_enum_state */\n+\t\t\t\t  (NULL_TREE, build_fold_addr_expr_loc (location, objc_foreach_enum_state_decl),\n+\t\t\t\t   tree_cons   /* __objc_foreach_items  */\n+\t\t\t\t   (NULL_TREE, default_function_array_conversion (location, array).value,\n+\t\t\t\t    tree_cons  /* 16 */\n+\t\t\t\t    (NULL_TREE, build_int_cst (NULL_TREE, 16), NULL_TREE))));\n+  }\n+#endif\n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_batchsize_decl, t);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n+\n+  /* } */\n+\n+  /* if (__objc_foreach_batchsize != 0) goto next_batch; */\n+  t = build3 (COND_EXPR, void_type_node, \n+\t      /* Condition.  */\n+\t      c_fully_fold \n+\t      (c_common_truthvalue_conversion \n+\t       (location, \n+\t\tbuild_binary_op (location,\n+\t\t\t\t NE_EXPR, \n+\t\t\t\t objc_foreach_batchsize_decl,\n+\t\t\t\t build_int_cst (long_unsigned_type_node, 0), 1)),\n+\t       false, NULL),\n+\t      /* Then block.  */\n+\t      build1 (GOTO_EXPR, void_type_node, next_batch_label_decl),\n+\t      /* Else block.  */\n+\t      NULL_TREE);\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n+\n+  /* <object expression> = nil; */\n+  t = build2 (MODIFY_EXPR, void_type_node, object_expression, convert (objc_object_type, null_pointer_node));\n+  SET_EXPR_LOCATION (t, location);\n+  append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n+\n+  /* break_label: */\n+  if (break_label)\n+    {\n+      t = build1 (LABEL_EXPR, void_type_node, break_label);\n+      SET_EXPR_LOCATION (t, location);\n+      append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n+    }\n+\n+  /* } */\n+  COND_EXPR_ELSE (first_if) = first_else;\n+\n+  /* Do the whole thing.  */\n+  add_stmt (bind);\n+\n+#ifdef DEBUG_OBJC_FINISH_FOREACH_LOOP\n+  /* This will print to stderr the whole blurb generated by the\n+     compiler while compiling (assuming the compiler doesn't crash\n+     before getting here).\n+   */\n+  debug_generic_stmt (bind);\n+#endif\n+\n+  /* } */\n+  /* Done by c-parser.c  */\n+}\n+\n #include \"gt-objc-objc-act.h\""}, {"sha": "9f6ddcac7249e7b7b98e748b5bd4e39d2358e7a9", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -269,6 +269,9 @@ enum objc_tree_index\n     OCTI_ASSIGN_GLOBAL_DECL,\n     OCTI_ASSIGN_STRONGCAST_DECL,\n \n+    OCTI_FAST_ENUM_STATE_TEMP,\n+    OCTI_ENUM_MUTATION_DECL,\n+\n     OCTI_MAX\n };\n \n@@ -433,5 +436,9 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n #define string_class_decl\tobjc_global_trees[OCTI_STRING_CLASS_DECL]\n #define internal_const_str_type\tobjc_global_trees[OCTI_INTERNAL_CNST_STR_TYPE]\n #define UOBJC_SUPER_decl\tobjc_global_trees[OCTI_SUPER_DECL]\n+#define objc_fast_enumeration_state_template\t\\\n+                                objc_global_trees[OCTI_FAST_ENUM_STATE_TEMP]\n+#define objc_enumeration_mutation_decl\t\t\\\n+                                objc_global_trees[OCTI_ENUM_MUTATION_DECL]\n \n #endif /* GCC_OBJC_ACT_H */"}, {"sha": "e95e2b88874068f3251761d4f842bb3d0ff009a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -1,8 +1,45 @@\n+2010-10-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented fast enumeration for Objective-C.\n+\t* objc.dg/foreach-1.m: New.\n+\t* objc.dg/foreach-2.m: New.\n+\t* objc.dg/foreach-3.m: New.\n+\t* objc.dg/foreach-4.m: New.\n+\t* objc.dg/foreach-5.m: New.\n+\t* objc.dg/foreach-6.m: New.\n+\t* objc.dg/foreach-7.m: New.\n+\n+\tMerge from 'apple/trunk' branch on FSF servers:\n+\t2006-04-13 Fariborz Jahanian <fjahanian@apple.com>\n+\n+\tRadar 4502236\n+\t* objc.dg/objc-foreach-5.m: New.\t\n+\n+\t2006-04-12 Fariborz Jahanian <fjahanian@apple.com>\n+\n+\tRadar 4507230\n+\t* objc.dg/objc-foreach-4.m: New.\n+\n+\t2006-03-13  Fariborz Jahanian <fjahanian@apple.com>\n+\n+\tRadar 4472881\n+\t* objc.dg/objc-foreach-3.m: New.\n+\n+\t2005-03-07 Fariborz Jahanian <fjahanian@apple.com>\n+\n+        Radar 4468498\n+\t* objc.dg/objc-foreach-2.m: New.\n+\n+\t2006-02-15   Fariborz Jahanian <fjahanian@apple.com>\n+\n+\tRadar 4294910\n+\t* objc.dg/objc-foreach-1.m: New\n+\n 2010-10-06  Hariharan Sandanagobalane <hariharan@picochip.com>\n \n \t* gcc.c-torture/execute/cmpsi-2.c : Unsigned comparisons should use\n \tunsigned values.\n-\n+\t\n 2010-10-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc++/28050"}, {"sha": "541b5835c356938e4107adf2a01916d61c0752a7", "filename": "gcc/testsuite/objc.dg/foreach-1.m", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-1.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,81 @@\n+/* Test basic Objective-C foreach syntax.  This tests iterations that\n+   do nothing.\n+*/\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+extern void abort (void);\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+@interface Object (NSFastEnumeration)\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned int)len;\n+@end\n+\n+int main (void)\n+{\n+  int test_variable = 0;\n+  int counter = 0;\n+  id array = nil;\n+  id object = nil;\n+\n+  /* Test that 'for (object in array)' is recognized and that nothing\n+     happens if array is nil.  */\n+  for (object in array)\n+    test_variable = 8;\n+\n+  if (test_variable == 8)\n+    abort ();\n+\n+  if (object != nil)\n+    abort ();\n+\n+  /* Test that if nothing is done, object is set to nil.  */\n+  object = [Object new];\n+\n+  for (object in array)\n+    ;\n+\n+  if (object != nil)\n+    abort ();\n+\n+  /* Test that you can reference 'object' inside the body.  */\n+  for (object in array)\n+    object = nil;\n+\n+  if (object != nil)\n+    abort ();\n+\n+  /* Test that 'for (id element in array) is recognized (and works).  */\n+  for (id element in array)\n+    test_variable = 8;\n+\n+  if (test_variable == 8)\n+    abort ();\n+\n+  /* Test that you can reference 'object' inside the body.  */\n+  for (id element in array)\n+    element = nil;\n+\n+  /* Test that C for loops still work.  */\n+  test_variable = 0;\n+\n+  for (counter = 0; counter < 4; counter++)\n+    test_variable++;\n+\n+  if (test_variable != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e158502181395a51eabf5f12d9ff97187aff79dc", "filename": "gcc/testsuite/objc.dg/foreach-2.m", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-2.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,279 @@\n+/* Test basic Objective-C foreach syntax.  This tests iterations, with\n+   the basic syntax 'for (object in array) statements'\n+*/\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+#include <objc/NXConstStr.h>\n+#include <stdlib.h>\n+extern void abort (void);\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+\n+ /* A mini-array implementation that can be used to test fast\n+    enumeration.  You create the array with some objects; you can\n+    mutate the array, and you can fast-enumerate it.\n+ */\n+@interface MyArray : Object\n+{\n+  unsigned int length;\n+  id *objects;\n+  unsigned long mutated;\n+}\n+- (id) initWithLength: (unsigned int)l  objects: (id *)o;\n+- (void) mutate;\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned long)len;\n+@end\n+\n+@implementation MyArray : Object\n+- (id) initWithLength: (unsigned int)l\n+\t      objects: (id *)o\n+{\n+  length = l;\n+  objects = o;\n+  mutated = 0;\n+}\n+- (void) mutate\n+{\n+  mutated = 1;\n+}\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState*)state \n+\t\t  \t\t     objects: (id*)stackbuf\n+\t\t\t \t       count: (unsigned long)len\n+{\n+  unsigned long i, batch_size;\n+\n+  /* We keep how many objects we served in the state->state counter.  So the next batch\n+     will contain up to length - state->state objects.  */\n+  batch_size = length - state->state;\n+\n+  /* Make obvious adjustments.  */\n+  if (batch_size < 0)\n+    batch_size = 0;\n+\n+  if (batch_size > len)\n+    batch_size = len;\n+\n+  /* Copy the objects.  */\n+  for (i = 0; i < batch_size; i++)\n+    stackbuf[i] = objects[i];\n+\n+  state->state += batch_size;\n+  state->itemsPtr = stackbuf;\n+  state->mutationsPtr = &mutated;\n+\n+  return batch_size;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyArray *array;\n+  Object *object;\n+  int test_variable, counter, i;\n+  id *objects;\n+\n+  array = [[MyArray alloc] initWithLength: 0\n+\t\t\t   objects: NULL];\n+\n+  /* Test that an empty array does nothing.  */\n+  for (object in array)\n+    abort ();\n+\n+  if (object != nil)\n+    abort ();\n+\n+  /* Test iterating over 1 object.  */\n+  objects = malloc (sizeof (id) * 1);\n+  objects[0] = @\"One Object\";\n+\n+  array = [[MyArray alloc] initWithLength: 1\n+\t\t\t   objects: objects];\n+  \n+  for (object in array)\n+    printf (\"%p\\n\", object);\n+  \n+  /* Test iterating over 20 objects.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  \n+  for (object in array)\n+    printf (\"%p\\n\", object);\n+\n+  /* Test iterating over 200 objects.  */\n+  objects = malloc (sizeof (id) * 200);\n+  for (i = 0; i < 200; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 200\n+\t\t\t   objects: objects];\n+  \n+  counter = 0;\n+  for (object in array)\n+    {\n+      if (object != nil)\n+\tcounter++;\n+    }\n+\n+  if (counter != 200)\n+    abort ();\n+\n+  printf (\"Counter was %d (should be 200)\\n\", counter);\n+\n+  /* Test iterating again over the same array.  */\n+  counter = 0;\n+  for (object in array)\n+    {\n+      if (object != nil)\n+\tcounter++;\n+    }\n+\n+  if (counter != 200)\n+    abort ();\n+\n+  printf (\"Counter was %d (should be 200)\\n\", counter);\n+\n+  /* Test nested iterations.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (object in array)\n+    {\n+      id another_object;\n+      for (another_object in array)\n+\tif (another_object != nil)\n+\t  counter++;\n+    }\n+\n+  printf (\"Counter was %d (should be 400)\\n\", counter);\n+\n+  if (counter != 400)\n+    abort ();\n+\n+  /* Test 'continue'.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (object in array)\n+    {\n+      if (counter == 15)\n+\tcontinue;\n+\n+      counter++;\n+    }\n+\n+  printf (\"Counter was %d (should be 15)\\n\", counter);\n+\n+  if (counter != 15)\n+    abort ();\n+\n+  /* Test 'break'.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (object in array)\n+    {\n+      counter++;\n+\n+      if (counter == 15)\n+\tbreak;\n+    }\n+\n+  printf (\"Counter was %d (should be 15)\\n\", counter);\n+\n+  if (counter != 15)\n+    abort ();\n+\n+  /* Test 'break' and 'continue' in nested iterations.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (object in array)\n+    {\n+      int local_counter = 0;\n+      id another_object;\n+\n+      /* Each internal loop should increase counter by 24.  */\n+      for (another_object in array)\n+\t{\n+\t  local_counter++;\n+\t  \n+\t  if (local_counter == 10)\n+\t    {\n+\t      counter = counter + 20;\n+\t      break;\n+\t    }\n+\n+\t  if (local_counter >= 5)\n+\t    continue;\n+\n+\t  counter++;\n+\t}\n+\n+      /* Exit after 4 iterations.  */\n+      if (counter == 96)\n+\tbreak;\n+    }\n+\n+  printf (\"Counter was %d (should be 96)\\n\", counter);\n+\n+  if (counter != 96)\n+    abort ();\n+\n+  /* Test that if we 'break', the object is set to the last one, while\n+     if we run out of objects, it is set to 'nil'.  */\n+  for (object in array)\n+    ;\n+\n+  if (object != nil)\n+    abort ();\n+\n+  for (object in array)\n+    break;\n+\n+  if (object == nil)\n+    abort ();\n+\n+  /* Test that C for loops still work.  */\n+  test_variable = 0;\n+\n+  for (counter = 0; counter < 4; counter++)\n+    test_variable++;\n+\n+  if (test_variable != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "893631fd423cf8a45d154ee0566116a334ea7310", "filename": "gcc/testsuite/objc.dg/foreach-3.m", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-3.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,114 @@\n+/* Test basic Objective-C foreach syntax.  This tests the mutation.\n+*/\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* FIXME: This test should be run, and it succeeds if the program\n+   aborts at the right time (when the mutation happens).  It currently\n+   works, but how do we tell the testsuite to test for it ?\n+*/\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+#include <objc/NXConstStr.h>\n+#include <stdlib.h>\n+extern void abort (void);\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+\n+ /* A mini-array implementation that can be used to test fast\n+    enumeration.  You create the array with some objects; you can\n+    mutate the array, and you can fast-enumerate it.\n+ */\n+@interface MyArray : Object\n+{\n+  unsigned int length;\n+  id *objects;\n+  unsigned long mutated;\n+}\n+- (id) initWithLength: (unsigned int)l  objects: (id *)o;\n+- (void) mutate;\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned long)len;\n+@end\n+\n+@implementation MyArray : Object\n+- (id) initWithLength: (unsigned int)l\n+\t      objects: (id *)o\n+{\n+  length = l;\n+  objects = o;\n+  mutated = 0;\n+}\n+- (void) mutate\n+{\n+  mutated = 1;\n+}\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState*)state \n+\t\t  \t\t     objects: (id*)stackbuf\n+\t\t\t \t       count: (unsigned long)len\n+{\n+  unsigned long i, batch_size;\n+\n+  /* Change the mutationsPtr if 'mutate' is called.  */\n+  state->mutationsPtr = &mutated;\n+\n+  /* We keep how many objects we served in the state->state counter.  So the next batch\n+     will contain up to length - state->state objects.  */\n+  batch_size = length - state->state;\n+\n+  /* Make obvious adjustments.  */\n+  if (batch_size < 0)\n+    batch_size = 0;\n+\n+  if (batch_size > len)\n+    batch_size = len;\n+\n+  /* Copy the objects.  */\n+  for (i = 0; i < batch_size; i++)\n+    stackbuf[i] = objects[i];\n+\n+  state->state += batch_size;\n+  state->itemsPtr = stackbuf;\n+\n+  return batch_size;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyArray *array;\n+  Object *object;\n+  int counter, i;\n+  id *objects;\n+\n+  /* Test iterating over 20 objects, mutating after 15.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  \n+  counter = 0;\n+  for (object in array)\n+    {\n+      counter++;\n+      printf (\"%d\\n\", counter);\n+      if (counter == 14)\n+\t{\n+\t  printf (\"Mutating (should abort at next iteration)\\n\");\n+\t  [array mutate];\n+\t}\n+    }\n+\n+  return 0;\n+}"}, {"sha": "c9cd977b0958207d2a782cf6bca109f870e8b37a", "filename": "gcc/testsuite/objc.dg/foreach-4.m", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-4.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,259 @@\n+/* Test basic Objective-C foreach syntax.  This tests iterations, with\n+   the declaration syntax 'for (id object in array) statements'\n+*/\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+#include <objc/NXConstStr.h>\n+#include <stdlib.h>\n+extern void abort (void);\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+\n+ /* A mini-array implementation that can be used to test fast\n+    enumeration.  You create the array with some objects; you can\n+    mutate the array, and you can fast-enumerate it.\n+ */\n+@interface MyArray : Object\n+{\n+  unsigned int length;\n+  id *objects;\n+  unsigned long mutated;\n+}\n+- (id) initWithLength: (unsigned int)l  objects: (id *)o;\n+- (void) mutate;\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned long)len;\n+@end\n+\n+@implementation MyArray : Object\n+- (id) initWithLength: (unsigned int)l\n+\t      objects: (id *)o\n+{\n+  length = l;\n+  objects = o;\n+  mutated = 0;\n+}\n+- (void) mutate\n+{\n+  mutated = 1;\n+}\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState*)state \n+\t\t  \t\t     objects: (id*)stackbuf\n+\t\t\t \t       count: (unsigned long)len\n+{\n+  unsigned long i, batch_size;\n+\n+  /* We keep how many objects we served in the state->state counter.  So the next batch\n+     will contain up to length - state->state objects.  */\n+  batch_size = length - state->state;\n+\n+  /* Make obvious adjustments.  */\n+  if (batch_size < 0)\n+    batch_size = 0;\n+\n+  if (batch_size > len)\n+    batch_size = len;\n+\n+  /* Copy the objects.  */\n+  for (i = 0; i < batch_size; i++)\n+    stackbuf[i] = objects[i];\n+\n+  state->state += batch_size;\n+  state->itemsPtr = stackbuf;\n+  state->mutationsPtr = &mutated;\n+\n+  return batch_size;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyArray *array;\n+  int test_variable, counter, i;\n+  id *objects;\n+\n+  array = [[MyArray alloc] initWithLength: 0\n+\t\t\t   objects: NULL];\n+\n+  /* Test that an empty array does nothing.  */\n+  for (id object in array)\n+    abort ();\n+\n+  /* Test iterating over 1 object.  */\n+  objects = malloc (sizeof (id) * 1);\n+  objects[0] = @\"One Object\";\n+\n+  array = [[MyArray alloc] initWithLength: 1\n+\t\t\t   objects: objects];\n+  \n+  for (id object in array)\n+    printf (\"%p\\n\", object);\n+  \n+  /* Test iterating over 20 objects.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  \n+  for (id object in array)\n+    printf (\"%p\\n\", object);\n+\n+  /* Test iterating over 200 objects.  */\n+  objects = malloc (sizeof (id) * 200);\n+  for (i = 0; i < 200; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 200\n+\t\t\t   objects: objects];\n+  \n+  counter = 0;\n+  for (id object in array)\n+    {\n+      if (object != nil)\n+\tcounter++;\n+    }\n+\n+  if (counter != 200)\n+    abort ();\n+\n+  printf (\"Counter was %d (should be 200)\\n\", counter);\n+\n+  /* Test iterating again over the same array.  */\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      if (object != nil)\n+\tcounter++;\n+    }\n+\n+  if (counter != 200)\n+    abort ();\n+\n+  printf (\"Counter was %d (should be 200)\\n\", counter);\n+\n+  /* Test nested iterations.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      for (id another_object in array)\n+\tif (another_object != nil)\n+\t  counter++;\n+    }\n+\n+  printf (\"Counter was %d (should be 400)\\n\", counter);\n+\n+  if (counter != 400)\n+    abort ();\n+\n+  /* Test 'continue'.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      if (counter == 15)\n+\tcontinue;\n+\n+      counter++;\n+    }\n+\n+  printf (\"Counter was %d (should be 15)\\n\", counter);\n+\n+  if (counter != 15)\n+    abort ();\n+\n+  /* Test 'break'.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      counter++;\n+\n+      if (counter == 15)\n+\tbreak;\n+    }\n+\n+  printf (\"Counter was %d (should be 15)\\n\", counter);\n+\n+  if (counter != 15)\n+    abort ();\n+\n+  /* Test 'break' and 'continue' in nested iterations.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      int local_counter = 0;\n+\n+      /* Each internal loop should increase counter by 24.  */\n+      for (id another_object in array)\n+\t{\n+\t  local_counter++;\n+\t  \n+\t  if (local_counter == 10)\n+\t    {\n+\t      counter = counter + 20;\n+\t      break;\n+\t    }\n+\n+\t  if (local_counter >= 5)\n+\t    continue;\n+\n+\t  counter++;\n+\t}\n+\n+      /* Exit after 4 iterations.  */\n+      if (counter == 96)\n+\tbreak;\n+    }\n+\n+  printf (\"Counter was %d (should be 96)\\n\", counter);\n+\n+  if (counter != 96)\n+    abort ();\n+\n+  /* Test that C for loops still work.  */\n+  test_variable = 0;\n+\n+  for (counter = 0; counter < 4; counter++)\n+    test_variable++;\n+\n+  if (test_variable != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b3579970ea0862ab6c85db2d32d0c882f261994e", "filename": "gcc/testsuite/objc.dg/foreach-5.m", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-5.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,258 @@\n+/* Test basic Objective-C foreach syntax.  This tests that if you\n+   define your own NSFastEnumeration struct, the compiler picks it up.\n+*/\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-do run } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+#include <objc/NXConstStr.h>\n+#include <stdlib.h>\n+extern void abort (void);\n+\n+typedef struct\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+} NSFastEnumerationState;\n+\n+/* A mini-array implementation that can be used to test fast\n+   enumeration.  You create the array with some objects; you can\n+   mutate the array, and you can fast-enumerate it.\n+*/\n+@interface MyArray : Object\n+{\n+  unsigned int length;\n+  id *objects;\n+  unsigned long mutated;\n+}\n+- (id) initWithLength: (unsigned int)l  objects: (id *)o;\n+- (void) mutate;\n+- (unsigned long)countByEnumeratingWithState: (NSFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned long)len;\n+@end\n+\n+@implementation MyArray : Object\n+- (id) initWithLength: (unsigned int)l\n+\t      objects: (id *)o\n+{\n+  length = l;\n+  objects = o;\n+  mutated = 0;\n+}\n+- (void) mutate\n+{\n+  mutated = 1;\n+}\n+- (unsigned long)countByEnumeratingWithState: (NSFastEnumerationState*)state \n+\t\t  \t\t     objects: (id*)stackbuf\n+\t\t\t \t       count: (unsigned long)len\n+{\n+  unsigned long i, batch_size;\n+\n+  /* We keep how many objects we served in the state->state counter.  So the next batch\n+     will contain up to length - state->state objects.  */\n+  batch_size = length - state->state;\n+\n+  /* Make obvious adjustments.  */\n+  if (batch_size < 0)\n+    batch_size = 0;\n+\n+  if (batch_size > len)\n+    batch_size = len;\n+\n+  /* Copy the objects.  */\n+  for (i = 0; i < batch_size; i++)\n+    stackbuf[i] = objects[i];\n+\n+  state->state += batch_size;\n+  state->itemsPtr = stackbuf;\n+  state->mutationsPtr = &mutated;\n+\n+  return batch_size;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyArray *array;\n+  int test_variable, counter, i;\n+  id *objects;\n+\n+  array = [[MyArray alloc] initWithLength: 0\n+\t\t\t   objects: NULL];\n+\n+  /* Test that an empty array does nothing.  */\n+  for (id object in array)\n+    abort ();\n+\n+  /* Test iterating over 1 object.  */\n+  objects = malloc (sizeof (id) * 1);\n+  objects[0] = @\"One Object\";\n+\n+  array = [[MyArray alloc] initWithLength: 1\n+\t\t\t   objects: objects];\n+  \n+  for (id object in array)\n+    printf (\"%p\\n\", object);\n+  \n+  /* Test iterating over 20 objects.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  \n+  for (id object in array)\n+    printf (\"%p\\n\", object);\n+\n+  /* Test iterating over 200 objects.  */\n+  objects = malloc (sizeof (id) * 200);\n+  for (i = 0; i < 200; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 200\n+\t\t\t   objects: objects];\n+  \n+  counter = 0;\n+  for (id object in array)\n+    {\n+      if (object != nil)\n+\tcounter++;\n+    }\n+\n+  if (counter != 200)\n+    abort ();\n+\n+  printf (\"Counter was %d (should be 200)\\n\", counter);\n+\n+  /* Test iterating again over the same array.  */\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      if (object != nil)\n+\tcounter++;\n+    }\n+\n+  if (counter != 200)\n+    abort ();\n+\n+  printf (\"Counter was %d (should be 200)\\n\", counter);\n+\n+  /* Test nested iterations.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      for (id another_object in array)\n+\tif (another_object != nil)\n+\t  counter++;\n+    }\n+\n+  printf (\"Counter was %d (should be 400)\\n\", counter);\n+\n+  if (counter != 400)\n+    abort ();\n+\n+  /* Test 'continue'.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      if (counter == 15)\n+\tcontinue;\n+\n+      counter++;\n+    }\n+\n+  printf (\"Counter was %d (should be 15)\\n\", counter);\n+\n+  if (counter != 15)\n+    abort ();\n+\n+  /* Test 'break'.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      counter++;\n+\n+      if (counter == 15)\n+\tbreak;\n+    }\n+\n+  printf (\"Counter was %d (should be 15)\\n\", counter);\n+\n+  if (counter != 15)\n+    abort ();\n+\n+  /* Test 'break' and 'continue' in nested iterations.  */\n+  objects = malloc (sizeof (id) * 20);\n+  for (i = 0; i < 20; i++)\n+    objects[i] = @\"object\";\n+  \n+  array = [[MyArray alloc] initWithLength: 20\n+\t\t\t   objects: objects];\n+  counter = 0;\n+  for (id object in array)\n+    {\n+      int local_counter = 0;\n+\n+      /* Each internal loop should increase counter by 24.  */\n+      for (id another_object in array)\n+\t{\n+\t  local_counter++;\n+\t  \n+\t  if (local_counter == 10)\n+\t    {\n+\t      counter = counter + 20;\n+\t      break;\n+\t    }\n+\n+\t  if (local_counter >= 5)\n+\t    continue;\n+\n+\t  counter++;\n+\t}\n+\n+      /* Exit after 4 iterations.  */\n+      if (counter == 96)\n+\tbreak;\n+    }\n+\n+  printf (\"Counter was %d (should be 96)\\n\", counter);\n+\n+  if (counter != 96)\n+    abort ();\n+\n+  /* Test that C for loops still work.  */\n+  test_variable = 0;\n+\n+  for (counter = 0; counter < 4; counter++)\n+    test_variable++;\n+\n+  if (test_variable != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "7a6b9609d8a1d0ec7827c6015ace4625d8ea5335", "filename": "gcc/testsuite/objc.dg/foreach-6.m", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-6.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,52 @@\n+/* Test basic Objective-C foreach syntax.  This tests warnings and errors.  */\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+extern void abort (void);\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+@interface Object (NSFastEnumeration)\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned int)len;\n+- (id) enumerator;\n+@end\n+\n+int main (void)\n+{\n+  id array = nil;\n+  id object = nil;\n+\n+  for (object in array) /* Ok */\n+    ;\n+\n+  for (object in nil) /* Ok */\n+    ;\n+\n+  for (object in) /* { dg-error \"missing collection in fast enumeration\" } */\n+    ;\n+\n+  for (object = nil in array) /* { dg-error \"invalid iterating variable in fast enumeration\" } */\n+    ;\n+\n+  for (object in [object enumerator]) /* Ok */\n+    ;\n+\n+  for (12 in array) /* { dg-error \"invalid iterating variable in fast enumeration\" } */\n+    ; /* { dg-error \"iterating variable in fast enumeration is not an object\" } */\n+\n+  for (object in 12)\n+    ; /* { dg-error \"collection in fast enumeration is not an object\" } */\n+\n+  return 0;\n+}"}, {"sha": "42bca82e3b953f6e0b9c4dd97ffbac48073a83d1", "filename": "gcc/testsuite/objc.dg/foreach-7.m", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fforeach-7.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,60 @@\n+/* Test basic Objective-C foreach syntax.  This tests warnings and errors.  */\n+/* FIXME: Run this test with the NeXT runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include <objc/Object.h>\n+extern void abort (void);\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+@interface Object (NSFastEnumeration)\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned int)len;\n+- (id) enumerator;\n+@end\n+\n+void function (void)\n+{\n+  return;\n+}\n+\n+id object_function (void)\n+{\n+  return nil;\n+}\n+\n+int main (void)\n+{\n+  id array = nil;\n+  id object = nil;\n+\n+  for (typedef int my_typedef in array) /* { dg-error \"declaration of non-variable\" } */\n+    ; /* { dg-error \"iterating variable in fast enumeration is not an object\" } */\n+\n+  for (function () in nil) /* { dg-error \"invalid iterating variable in fast enumeration\" } */\n+    ; /* { dg-error \"iterating variable in fast enumeration is not an object\" } */\n+\n+  for (object_function () in nil) /* { dg-error \"invalid iterating variable in fast enumeration\" } */\n+    ;\n+\n+  for ([object enumerator] in array) /* { dg-error \"invalid iterating variable in fast enumeration\" } */\n+    ;\n+\n+  for (object = nil in array) /* { dg-error \"invalid iterating variable in fast enumeration\" } */\n+    ;\n+\n+  for (id key, value in array) /* { dg-error \"multiple iterating variables in fast enumeration\" } */\n+    ;\n+\n+  return 0;\n+}\n+"}, {"sha": "81f5dae0c2f292ee9171e73643ca32d58566be17", "filename": "gcc/testsuite/objc.dg/objc-foreach-1.m", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-1.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,41 @@\n+/* Syntax check for the new foreach statement. */\n+/* { dg-do compile } */\n+\n+typedef struct objc_class *Class;\n+\n+typedef struct objc_object {\n+ Class isa;\n+} *id;\n+\n+\n+@interface MyList \n+@end\n+\n+@implementation MyList\n+- (unsigned int)countByEnumeratingWithState:(struct __objcFastEnumerationState *)state objects:(id *)items count:(unsigned int)stackcount\n+{\n+        return 0;\n+}\n+- (void)addObject:object {\n+}\n+\n+@end\n+\n+@interface MyList (BasicTest)\n+- (void)compilerTestAgainst;\n+@end\n+void BEGIN();\n+void INFORLOOP();\n+void END();\n+@implementation MyList (BasicTest)\n+- (void)compilerTestAgainst {\n+\n+\tBEGIN();\n+\tfor (id elem in (self)) \n+\t  if (elem)\n+\t    INFORLOOP();\n+\n+\tEND();\n+}\n+@end\n+"}, {"sha": "a01f004fec6cf7262867c533beb622200fa3b8c4", "filename": "gcc/testsuite/objc.dg/objc-foreach-2.m", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-2.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,41 @@\n+/* Syntax check for the new foreach statement. */\n+/* { dg-do compile } */\n+\n+typedef struct objc_class *Class;\n+\n+typedef struct objc_object {\n+ Class isa;\n+} *id;\n+\n+\n+@interface MyList \n+@end\n+\n+@implementation MyList\n+- (unsigned int)countByEnumeratingWithState:(struct __objcFastEnumerationState *)state objects:(id *)items count:(unsigned int)stackcount\n+{\n+        return 0;\n+}\n+- (void)addObject:object {\n+}\n+\n+@end\n+\n+@interface MyList (BasicTest)\n+- (void)compilerTestAgainst;\n+@end\n+void BEGIN();\n+void INFORLOOP();\n+void END();\n+@implementation MyList (BasicTest)\n+- (void)compilerTestAgainst {\n+\n+\tid elem;\n+\tBEGIN();\n+\tfor (elem in (self)) \n+\t  if (elem)\n+\t    INFORLOOP();\n+\tEND();\n+}\n+@end\n+"}, {"sha": "922db39e7481e8b6a20d7e23ae2e32ad8fb8a465", "filename": "gcc/testsuite/objc.dg/objc-foreach-3.m", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-3.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,42 @@\n+/* Syntax check for the new foreach statement. \n+   Use of declaration in loop-header without requiring c99 mode. */\n+/* { dg-do compile } */\n+\n+typedef struct objc_class *Class;\n+\n+typedef struct objc_object {\n+ Class isa;\n+} *id;\n+\n+\n+@interface MyList \n+@end\n+\n+@implementation MyList\n+- (unsigned int)countByEnumeratingWithState:(struct __objcFastEnumerationState *)state objects:(id *)items count:(unsigned int)stackcount\n+{\n+        return 0;\n+}\n+- (void)addObject:object {\n+}\n+\n+@end\n+\n+@interface MyList (BasicTest)\n+- (void)compilerTestAgainst;\n+@end\n+void BEGIN();\n+void INFORLOOP();\n+void END();\n+@implementation MyList (BasicTest)\n+- (void)compilerTestAgainst {\n+\n+\tBEGIN();\n+\tfor (id elem in (self)) \n+\t  if (elem)\n+\t    INFORLOOP();\n+\n+\tEND();\n+}\n+@end\n+"}, {"sha": "76e429e69417012087e71819511497ee52a02f2d", "filename": "gcc/testsuite/objc.dg/objc-foreach-4.m", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-4.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,17 @@\n+/* Test for valid objc objects used in a for-each statement. */\n+/* FIXME: Run this test with the GNU runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+/* { dg-do compile { target *-*-darwin* } } */\n+#include <Foundation/Foundation.h>\n+\n+// gcc -o foo foo.m -framework Foundation\n+\n+int main (int argc, char const* argv[]) {\n+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n+    NSArray * arr = [NSArray arrayWithObjects:@\"A\", @\"B\", @\"C\", nil];\n+    for (NSString * foo in arr) { \n+      NSLog(@\"foo is %@\", foo);\n+    }\n+    [pool release];\n+    return 0;\n+}"}, {"sha": "95a950375a492b16a3360b8de250af88e44352e9", "filename": "gcc/testsuite/objc.dg/objc-foreach-5.m", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fobjc-foreach-5.m?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,37 @@\n+/* FIXME: Run this test with the GNU runtime as well.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+/* { dg-do compile { target *-*-darwin* } } */\n+#import <Foundation/Foundation.h>\n+\n+NSArray * createTestVictim(unsigned capacity) {\n+    NSMutableArray * arr = [[NSMutableArray alloc] initWithCapacity:capacity];\n+    int x = 0;\n+\n+    for(x = 0; x < capacity; x++) {\n+        NSNumber * num = [NSNumber numberWithInteger:x];\n+        [arr addObject:num];\n+    }\n+    \n+    NSArray * immutableCopy = [arr copy];\n+    [arr release];\n+    \n+    return immutableCopy;\n+}\n+\n+void addStuffUp(NSArray * values) {\n+    NSInteger accumulator = 0;\n+//    for (id item in values) {\n+    id item;\n+    for (item in values) {\n+        accumulator += [item integerValue];\n+    }\n+}\n+\n+int main (int argc, char const* argv[]) {\n+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n+    NSArray * target = createTestVictim(10);\n+    addStuffUp(target);\n+    [pool release];\n+    return 0;\n+}\n+/* { dg-final { scan-assembler \"_addStuffUp:\" } } */"}, {"sha": "ac51fcb3c50517cfcf1b856781ab0205d94e1018", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -1,3 +1,11 @@\n+2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented fast enumeration for Objective-C.\n+\t* Makefile.in (C_SOURCE_FILES): Added objc-foreach.c.\n+\t(OBJC_H): Added runtime.h\n+\t* objc-foreach.c: New file.\n+\t* objc/runtime.h: New file.\n+\t\n 2010-09-30  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* objc/deprecated/struct_objc_class.h: Add padding"}, {"sha": "d99ab26a0a67302db2d09bebfb9be8e2872c103f", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -120,6 +120,7 @@ OBJC_H = \\\n   message.h \\\n   objc-api.h \\\n   objc-decls.h \\\n+  runtime.h \\\n   thr.h \\\n   \\\n   hash.h \\\n@@ -163,6 +164,7 @@ C_SOURCE_FILES = \\\n    init.c \\\n    memory.c \\\n    nil_method.c \\\n+   objc-foreach.c \\\n    objc-sync.c \\\n    objects.c \\\n    sarray.c \\"}, {"sha": "83a91011d12cb979065e72ccec986722cf911c75", "filename": "libobjc/objc-foreach.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2Fobjc-foreach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2Fobjc-foreach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-foreach.c?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,52 @@\n+/* GNU Objective C Runtime 'fast enumeration' implementation\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/*\n+  This file implements objc_enumeration_mutation() and\n+  objc_set_enumeration_mutation_handler(), the two functions required\n+  to handle mutations during a fast enumeration.\n+*/\n+#include \"objc/runtime.h\"           /* For objc_enumerationMutation() and objc_set_enumeration_mutation_handler() */\n+#include \"objc-private/error.h\"     /* For _objc_abort() */\n+\n+/* The enumeration mutation handler currently in use.  */\n+static void (*__objc_enumeration_mutation_handler)(id) = NULL;\n+\n+void\n+objc_set_enumeration_mutation_handler (void (*handler)(id))\n+{\n+  __objc_enumeration_mutation_handler = handler;\n+}\n+\n+void\n+objc_enumerationMutation (id collection)\n+{\n+  if (__objc_enumeration_mutation_handler != NULL)\n+    (*__objc_enumeration_mutation_handler) (collection);\n+\n+  /* We always abort if we get here; there is no point in going on as\n+     the next iteration in the fast enumeration would probably go\n+     deeply wrong.  */\n+  _objc_abort (\"Collection %p mutated during fast enumeration\", collection);\n+}  "}, {"sha": "7b16f1b09eac08c1ce9a19c37870ce394132addf", "filename": "libobjc/objc/runtime.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=f05b9d93e96c2a97d80e7fc3b10df7b86c6081b0", "patch": "@@ -0,0 +1,88 @@\n+/* GNU Objective-C Runtime API.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __objc_runtime_INCLUDE_GNU\n+#define __objc_runtime_INCLUDE_GNU\n+\n+#include \"objc.h\"\n+\n+/* The following is temporary, until all code from objc-api.h has been\n+   moved into this file and objc-api.h will include runtime.h.  */\n+#include \"objc-api.h\"\n+\n+/* 'objc_enumerationMutation()' is called when a collection is\n+   mutated while being \"fast enumerated\".  That is a hard error, and\n+   objc_enumerationMutation is called to deal with it.  'collection'\n+   is the collection object that was mutated during an enumeration.\n+\n+   objc_enumerationMutation() will invoke the mutation handler if any\n+   is set.  Then, it will abort the program.\n+\n+   Compatibility note: the Apple runtime will not abort the program\n+   after calling the mutation handler.\n+ */\n+objc_EXPORT void objc_enumerationMutation (id collection);\n+\n+/* 'objc_set_enumeration_mutation_handler' can be used to set a\n+   function that will be called (instead of aborting) when a fast\n+   enumeration is mutated during enumeration.  The handler will be\n+   called with the 'collection' being mutated as the only argument and\n+   it should not return; it should either exit the program, or could\n+   throw an exception.  The recommended implementation is to throw an\n+   exception - the user can then use exception handlers to deal with\n+   it.\n+\n+   This function is not thread safe (other threads may be trying to\n+   invoke the enumeration mutation handler while you are changing it!)\n+   and should be called during during the program initialization\n+   before threads are started.  It is mostly reserved for \"Foundation\"\n+   libraries; in the case of GNUstep, GNUstep Base may be using this\n+   function to improve the standard enumeration mutation handling.\n+   You probably shouldn't use this function unless you are writing\n+   your own Foundation library.\n+*/\n+objc_EXPORT void objc_set_enumeration_mutation_handler (void (*handler)(id));\n+\n+/* This structure (used during fast enumeration) is automatically\n+   defined by the compiler (it is as if this definition was always\n+   included in all Objective-C files).  Note that it is usually\n+   defined again with the name of NSFastEnumeration by \"Foundation\"\n+   libraries such as GNUstep Base.  And if NSFastEnumeration is\n+   defined, the compiler will use it instead of\n+   __objcFastEnumerationState when doing fast enumeration.\n+*/\n+/*\n+struct __objcFastEnumerationState\n+{\n+  unsigned long state;\n+  id            *itemsPtr;\n+  unsigned long *mutationsPtr;\n+  unsigned long extra[5];\n+};\n+*/\n+/* For compatibility with the Apple/NeXT runtime.  */\n+#define objc_setEnumerationMutationHandler objc_set_enumeration_mutation_handler\n+\n+#endif"}]}