{"sha": "5527bf14a5a334ea3509a3dd927b070bc92fb363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUyN2JmMTRhNWEzMzRlYTM1MDlhM2RkOTI3YjA3MGJjOTJmYjM2Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-30T23:58:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-30T23:58:03Z"}, "message": "Makefile.in (OBJS): Add doloop.o.\n\n\t* Makefile.in (OBJS): Add doloop.o.\n\t* doloop.c: New file.\n\n\t* final.c (insn_current_reference_address): Return 0 before final.\n\t* flags.h (flag_branch_on_count_reg): Fix typos in commentary.\n\t* jump.c (any_uncondjump_p): Likewise.\n\t* loop.c (indirect_jump_in_function): Make static.\n\t(strength_reduce): Call doloop_optimize.\n\t(insert_bct, instrument_loop_bct): Remove.\n\t* loop.h (doloop_optimize): Prototype.\n\t* recog.c (split_all_insns): Split all INSN_P.\n\t* toplev.c (flag_branch_on_count_reg): Default on.\n\n\t* config/c4x/c4x.c (c4x_optimization_options): Don't set\n\tflag_branch_on_count_reg.\n\t* config/i386/i386.c (override_options): Likewise.\n\t* config/rs6000/rs6000.c (optimization_options): Likewise.\n\n\t* config/i386/i386.md (decrement_and_branch_on_count): Remove.\n\t(doloop_end): New.\n\t(dbra_ge): Remove, as well as all it's splitters.\n\n\t* config/rs6000/rs6000.md (decrement_and_branch_on_count): Remove.\n\t(doloop_end): New.\n\n\t* config/ia64/ia64-protos.h (ar_lc_reg_operand): Declare.\n\t(ia64_register_move_cost): Declare.\n\t* config/ia64/ia64.c (ar_lc_reg_operand): New.\n\t(struct ia64_frame_info): Add ar_size.\n\t(ia64_compute_frame_size): Set it.\n\t(save_restore_insns): Save and restore ar.lc.\n\t(ia64_register_move_cost): New, moved from header file.  Handle\n\tapplication registers.\n\t(REG_AR_PFS, REG_AR_EC): Remove.  Replace with AR_*_REGNUM numbers.\n\t(emit_insn_group_barriers): Special case doloop_end_internal.\n\t(ia64_epilogue_uses): Mark ar.lc live at end.\n\t* config/ia64/ia64.h (AR_CCV_REGNUM, AR_LC_REGNUM): New registers.\n\t(AR_EC_REGNUM, AR_PFS_REGNUM): New registers.\n\t(FIRST_PSEUDO_REGISTER): Make room.\n\t(AR_M_REGNO_P, AR_I_REGNO_P, AR_REGNO_P): New.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Update.\n\t(REG_ALLOC_ORDER): Update.\n\t(HARD_REGNO_MODE_OK): Update.\n\t(REGISTER_NAMES): Update.\n\t(enum reg_class): Add AR_M_REGS and AR_I_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.\n\t(REGNO_REG_CLASS): Update.\n\t(LEGITIMATE_ADDRESS_DISP): Displacement range is 9 bits, not 10.\n\t(REGISTER_MOVE_COST): Move out of line.\n\t(PREDICATE_CODES): Update.\n\t* config/ia64/ia64.md (movdi patterns): Handle ar register classes.\n\t(addsi3_plus1_alt, adddi3_plus1_alt): New.\n\t(shladd_elim splitter): Allow constants in the predicate.\n\t(doloop_end, doloop_end_internal): New.\n\nFrom-SVN: r35358", "tree": {"sha": "f605097b66b55020e4f570dfecd70e09c3318697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f605097b66b55020e4f570dfecd70e09c3318697"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5527bf14a5a334ea3509a3dd927b070bc92fb363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5527bf14a5a334ea3509a3dd927b070bc92fb363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5527bf14a5a334ea3509a3dd927b070bc92fb363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5527bf14a5a334ea3509a3dd927b070bc92fb363/comments", "author": null, "committer": null, "parents": [{"sha": "1cf0acdd19587bcfc635db6688b6a7143f0cadfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cf0acdd19587bcfc635db6688b6a7143f0cadfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cf0acdd19587bcfc635db6688b6a7143f0cadfe"}], "stats": {"total": 1758, "additions": 1246, "deletions": 512}, "files": [{"sha": "edc2df41f9f8f8bde641ca99b9f9e509ccf8fbc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -1,3 +1,84 @@\n+2000-07-30  Michael Hayes  <mhayes@cygnus.com>\n+\t    Richard Henderson  <rth@cygnus.com>\n+\n+\t* Makefile.in (OBJS): Add doloop.o.\n+\t* doloop.c: New file.\n+\n+\t* final.c (insn_current_reference_address): Return 0 before final.\n+\t* flags.h (flag_branch_on_count_reg): Fix typos in commentary.\n+\t* jump.c (any_uncondjump_p): Likewise.\n+\t* loop.c (indirect_jump_in_function): Make static.\n+\t(strength_reduce): Call doloop_optimize.\n+\t(insert_bct, instrument_loop_bct): Remove.\n+\t* loop.h (doloop_optimize): Prototype.\n+\t* recog.c (split_all_insns): Split all INSN_P.\n+\t* toplev.c (flag_branch_on_count_reg): Default on.\n+\n+\t* config/c4x/c4x.c (c4x_optimization_options): Don't set\n+\tflag_branch_on_count_reg.\n+\t* config/i386/i386.c (override_options): Likewise.\n+\t* config/rs6000/rs6000.c (optimization_options): Likewise.\n+\n+\t* config/i386/i386.md (decrement_and_branch_on_count): Remove.\n+\t(doloop_end): New.\n+\t(dbra_ge): Remove, as well as all it's splitters.\n+\n+\t* config/rs6000/rs6000.md (decrement_and_branch_on_count): Remove.\n+\t(doloop_end): New.\n+\n+\t* config/ia64/ia64-protos.h (ar_lc_reg_operand): Declare.\n+\t(ia64_register_move_cost): Declare.\n+\t* config/ia64/ia64.c (ar_lc_reg_operand): New.\n+\t(struct ia64_frame_info): Add ar_size.\n+\t(ia64_compute_frame_size): Set it.\n+\t(save_restore_insns): Save and restore ar.lc.\n+\t(ia64_register_move_cost): New, moved from header file.  Handle\n+\tapplication registers.\n+\t(REG_AR_PFS, REG_AR_EC): Remove.  Replace with AR_*_REGNUM numbers.\n+\t(emit_insn_group_barriers): Special case doloop_end_internal.\n+\t(ia64_epilogue_uses): Mark ar.lc live at end.\n+\t* config/ia64/ia64.h (AR_CCV_REGNUM, AR_LC_REGNUM): New registers.\n+\t(AR_EC_REGNUM, AR_PFS_REGNUM): New registers.\n+\t(FIRST_PSEUDO_REGISTER): Make room.\n+\t(AR_M_REGNO_P, AR_I_REGNO_P, AR_REGNO_P): New.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Update.\n+\t(REG_ALLOC_ORDER): Update.\n+\t(HARD_REGNO_MODE_OK): Update.\n+\t(REGISTER_NAMES): Update.\n+\t(enum reg_class): Add AR_M_REGS and AR_I_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.\n+\t(REGNO_REG_CLASS): Update.\n+\t(LEGITIMATE_ADDRESS_DISP): Displacement range is 9 bits, not 10.\n+\t(REGISTER_MOVE_COST): Move out of line.\n+\t(PREDICATE_CODES): Update.\n+\t* config/ia64/ia64.md (movdi patterns): Handle ar register classes.\n+\t(addsi3_plus1_alt, adddi3_plus1_alt): New.\n+\t(shladd_elim splitter): Allow constants in the predicate.\n+\t(doloop_end, doloop_end_internal): New.\n+\n+2000-07-30  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genattrtab.c (struct insn_def): Add lineno member.\n+\t(struct insn_ent): Likewise.\n+\t(struct attr_desc): Likewise.\n+\t(struct delay_desc): Likewise.\n+\t(struct function_unit_op): Likewise.\n+\t(struct function_unit): Likewise.\n+\t(check_attr_value): Use message_with_line.\n+\t(check_defs): Likewise.\n+\t(expand_units): Likewise.\n+\t(check_attr_test): Take a lineno argument.\n+\t(gen_attr): Likewise.\n+\t(gen_insn): Likewise.\n+\t(gen_delay): Likewise.\n+\t(gen_unit): Likewise.\n+\t(main): Give it to them.\n+\t(convert_set_attr_alternative): Take an insn_def argument\n+\tinstead of num_alt and insn_index.\n+\t(convert_set_attr): Likewise.\n+\t(write_test_expr): Protect INSN_ADDRESSES load\n+\twith INSN_ADDRESSES_SET_P.\n+\n 2000-07-30  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (init_propagate_block_info): Use pc_set."}, {"sha": "ddd150aa8b64a325a5973aad8a49906db6a1e0da", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -689,7 +689,7 @@ OBJS = diagnostic.o\t\t\t\t\t\t\t      \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o  \\\n  builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o   \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o  \\\n- integrate.o jump.o cse.o loop.o unroll.o flow.o combine.o varray.o\t      \\\n+ integrate.o jump.o cse.o loop.o doloop.o unroll.o flow.o combine.o varray.o  \\\n  regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n  insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o regrename.o    \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o    \\\n@@ -1338,6 +1338,8 @@ profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h $(LOOP_H) insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n    $(BASIC_BLOCK_H) function.h toplev.h varray.h except.h cselib.h\n+doloop.o : doloop.c $(CONFIG_H) system.h $(RTL_H) flags.h $(LOOP_H) \\\n+   insn-flags.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H)\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n    hard-reg-set.h varray.h $(BASIC_BLOCK_H)"}, {"sha": "261215f8da26a9dec7f3bb757e5653076e4b3a14", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -295,10 +295,6 @@ c4x_optimization_options (level, size)\n      instructions.  The benefit we gain we get by scheduling before\n      register allocation is probably marginal anyhow.  */\n   flag_schedule_insns = 0;\n-\n-  /* When optimizing, enable use of RPTB instruction.  */\n-  if (level >= 1)\n-    flag_branch_on_count_reg = 1;\n }\n \n "}, {"sha": "c5289ab836f59e172c8bacc10174a3b9e1398252", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -630,10 +630,6 @@ override_options ()\n   if (flag_fast_math)\n     target_flags &= ~MASK_IEEE_FP;\n \n-  /* If we're planning on using `loop', use it.  */\n-  if (TARGET_USE_LOOP && optimize)\n-    flag_branch_on_count_reg = 1;\n-\n   /* It makes no sense to ask for just SSE builtins, so MMX is also turned\n      on by -msse.  */\n   if (TARGET_SSE)"}, {"sha": "0c0612489594ad7f1e7c4b7b77e47187022b6828", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 33, "deletions": 102, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -8327,27 +8327,32 @@\n ;; This is all complicated by the fact that since this is a jump insn\n ;; we must handle our own reloads.\n \n-(define_expand \"decrement_and_branch_on_count\"\n-  [(parallel [(set (pc) (if_then_else\n-\t\t\t  (ne (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t\t      (const_int 1))\n-\t\t\t  (label_ref (match_operand 1 \"\" \"\"))\n-\t\t\t  (pc)))\n-\t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (const_int -1)))\n-\t      (clobber (match_scratch:SI 2 \"\"))\n-\t      (clobber (reg:CC 17))])]\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))        ; max iterations\n+   (use (match_operand 3 \"\" \"\"))        ; loop level \n+   (use (match_operand 4 \"\" \"\"))]       ; label\n   \"TARGET_USE_LOOP\"\n-  \"\")\n+  \"                                 \n+{\n+  /* Only use cloop on innermost loops.  */\n+  if (INTVAL (operands[3]) > 1)\n+    FAIL;\n+  if (GET_MODE (operands[0]) != SImode)\n+    FAIL;\n+  emit_jump_insn (gen_doloop_end_internal (operands[4], operands[0],\n+\t\t\t\t\t   operands[0]));\n+  DONE;\n+}\")\n \n-(define_insn \"*dbra_ne\"\n+(define_insn \"doloop_end_internal\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"c,*r,*r\")\n+\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"c,?*r,?*r\")\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_operand:SI 2 \"register_operand\" \"=1,*r,*m*r\")\n+   (set (match_operand:SI 2 \"register_operand\" \"=1,1,*m*r\")\n \t(plus:SI (match_dup 1)\n \t\t (const_int -1)))\n    (clobber (match_scratch:SI 3 \"=X,X,r\"))\n@@ -8372,55 +8377,24 @@\n \t\t      (const_string \"ibr\")\n \t\t      (const_string \"multi\")))])\n \n-(define_insn \"*dbra_ge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:SI 1 \"register_operand\" \"c,*r,*r\")\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"register_operand\" \"=1,*r,*m*r\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"=X,X,r\"))\n-   (clobber (reg:CC 17))]\n-  \"TARGET_USE_LOOP && find_reg_note (insn, REG_NONNEG, 0)\"\n-  \"*\n-{\n-  if (which_alternative != 0)\n-    return \\\"#\\\";\n-  if (get_attr_length (insn) == 2)\n-    return \\\"loop\\\\t%l0\\\";\n-  else\n-    return \\\"dec{l}\\\\t%1\\;jne\\\\t%l0\\\";\n-}\"\n-  [(set (attr \"type\")\n-\t(if_then_else (and (eq_attr \"alternative\" \"0\")\n-\t\t\t   (and (ge (minus (match_dup 0) (pc))\n-\t\t\t            (const_int -128))\n-\t\t\t        (lt (minus (match_dup 0) (pc))\n-\t\t\t            (const_int 124))))\n-\t\t      (const_string \"ibr\")\n-\t\t      (const_string \"multi\")))\n-   (set_attr \"ppro_uops\" \"many\")])\n-\n (define_split\n   [(set (pc)\n \t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t  (const_int 1))\n \t\t      (match_operand 0 \"\" \"\")\n \t\t      (pc)))\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n+   (set (match_dup 1)\n \t(plus:SI (match_dup 1)\n \t\t (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"\"))\n+   (clobber (match_scratch:SI 2 \"\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_USE_LOOP && reload_completed\n-   && ! (REGNO (operands[1]) == 2 && rtx_equal_p (operands[1], operands[2]))\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (parallel [(set (reg:CCZ 17)\n-\t\t   (compare:CCZ (plus:SI (match_dup 2) (const_int -1))\n+  \"TARGET_USE_LOOP\n+   && reload_completed\n+   && REGNO (operands[1]) != 2\"\n+  [(parallel [(set (reg:CCZ 17)\n+\t\t   (compare:CCZ (plus:SI (match_dup 1) (const_int -1))\n \t\t\t\t (const_int 0)))\n-\t      (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))])\n+\t      (set (match_dup 1) (plus:SI (match_dup 1) (const_int -1)))])\n    (set (pc) (if_then_else (ne (reg:CCZ 17) (const_int 0))\n \t\t\t   (match_dup 0)\n \t\t\t   (pc)))]\n@@ -8432,12 +8406,15 @@\n \t\t\t  (const_int 1))\n \t\t      (match_operand 0 \"\" \"\")\n \t\t      (pc)))\n-   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+   (set (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n \t(plus:SI (match_dup 1)\n \t\t (const_int -1)))\n    (clobber (match_scratch:SI 3 \"\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_USE_LOOP && reload_completed\"\n+  \"TARGET_USE_LOOP\n+   && reload_completed\n+   && (! REG_P (operands[2])\n+       || ! rtx_equal_p (operands[1], operands[2]))\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (reg:CCZ 17)\n \t\t   (compare:CCZ (plus:SI (match_dup 3) (const_int -1))\n@@ -8448,52 +8425,6 @@\n \t\t\t   (match_dup 0)\n \t\t\t   (pc)))]\n   \"\")\n-\n-(define_split\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t  (const_int 0))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (reg:CC 17))]\n-  \"TARGET_USE_LOOP && reload_completed\n-   && ! (REGNO (operands[1]) == 2 && rtx_equal_p (operands[1], operands[2]))\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (parallel [(set (reg:CCNO 17)\n-\t\t   (compare:CCNO (plus:SI (match_dup 2) (const_int -1))\n-\t\t\t\t (const_int 0)))\n-\t      (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))])\n-   (set (pc) (if_then_else (lt (reg:CCNO 17) (const_int 0))\n-\t\t\t   (match_dup 0)\n-\t\t\t   (pc)))]\n-  \"\")\n-  \n-(define_split\n-  [(set (pc)\n-\t(if_then_else (ge (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t  (const_int 0))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"memory_operand\" \"\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (reg:CC 17))]\n-  \"TARGET_USE_LOOP && reload_completed\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (parallel [(set (reg:CCNO 17)\n-\t\t   (compare:CCNO (plus:SI (match_dup 3) (const_int -1))\n-\t\t\t\t (const_int 0)))\n-\t      (set (match_dup 3) (plus:SI (match_dup 3) (const_int -1)))])\n-   (set (match_dup 2) (match_dup 3))\n-   (set (pc) (if_then_else (lt (reg:CCNO 17) (const_int 0))\n-\t\t\t   (match_dup 0)\n-\t\t\t   (pc)))]\n-  \"\")\n \f\n ;; Call instructions.\n "}, {"sha": "12ea516f6cf0161190ac8ca2930c5e0cb9ed12f7", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -59,6 +59,8 @@ extern void ia64_function_prologue PARAMS((FILE *, int));\n extern void ia64_funtion_epilogue PARAMS((FILE *, int));\n extern int ia64_direct_return PARAMS((void));\n extern int predicate_operator PARAMS((rtx, enum machine_mode));\n+extern int ar_lc_reg_operand PARAMS((rtx, enum machine_mode));\n+\n extern int ia64_move_ok PARAMS((rtx, rtx));\n \n extern void ia64_expand_load_address PARAMS((rtx, rtx));\n@@ -102,6 +104,7 @@ extern int ia64_valid_type_attribute PARAMS((tree, tree, tree, tree));\n extern void ia64_encode_section_info PARAMS((tree));\n #endif /* TREE_CODE */\n \n+extern int ia64_register_move_cost PARAMS((enum reg_class, enum reg_class));\n extern int ia64_epilogue_uses PARAMS((int));\n extern void ia64_file_start PARAMS((FILE *));\n extern void ia64_expand_prologue PARAMS((void));"}, {"sha": "7153620b18322c360170db9dddaf0785292c422d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 94, "deletions": 18, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -559,6 +559,19 @@ predicate_operator (op, mode)\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && (code == EQ || code == NE));\n }\n+\n+/* Return 1 if this is the ar.lc register.  */\n+\n+int\n+ar_lc_reg_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_MODE (op) == DImode\n+\t  && (mode == DImode || mode == VOIDmode)\n+\t  && GET_CODE (op) == REG\n+\t  && REGNO (op) == AR_LC_REGNUM);\n+}\n \f\n /* Return 1 if the operands of a move are ok.  */\n \n@@ -683,6 +696,7 @@ struct ia64_frame_info\n   long fr_pad_size;\t\t/* # bytes needed to align FP save area.  */\n   long pr_size;\t\t\t/* # bytes needed to store predicate regs.  */\n   long br_size;\t\t\t/* # bytes needed to store branch regs.  */\n+  long ar_size;\t\t\t/* # bytes needed to store AR regs.  */\n   HARD_REG_SET mask;\t\t/* mask of saved registers.  */\n   int initialized;\t\t/* != 0 is frame size already calculated.  */\n };\n@@ -713,6 +727,7 @@ ia64_compute_frame_size (size)\n   int fr_pad_size = 0;\n   int pr_size = 0;\n   int br_size = 0;\n+  int ar_size = 0;\n   int pretend_pad_size = 0;\n   int tmp;\n   int regno;\n@@ -772,6 +787,13 @@ ia64_compute_frame_size (size)\n   else\n     fr_pad_size = 0;\n \n+  /* AR.LC, for reasons unexplained, is call saved.  */\n+  if (regs_ever_live[AR_LC_REGNUM])\n+    {\n+      SET_HARD_REG_BIT (mask, AR_LC_REGNUM);\n+      ar_size = 8;\n+    }\n+\n   /* If we have an odd number of words of pretend arguments written to the\n      stack, then the FR save area will be unaligned.  We pad below this area\n      to keep things 16 byte aligned.  This needs to be kept distinct, to\n@@ -780,7 +802,7 @@ ia64_compute_frame_size (size)\n   pretend_pad_size = current_function_pretend_args_size % 16;\n \n   /* The 16 bytes is for the scratch area.  */\n-  tmp = (size + gr_size + fr_pad_size + fr_size + pr_size + br_size\n+  tmp = (size + gr_size + fr_pad_size + fr_size + pr_size + br_size + ar_size\n \t + current_function_outgoing_args_size + 16);\n   tmp += (current_function_pretend_args_size\n \t  ? current_function_pretend_args_size - 16\n@@ -810,6 +832,7 @@ ia64_compute_frame_size (size)\n   current_frame_info.fr_pad_size = fr_pad_size;\n   current_frame_info.pr_size = pr_size;\n   current_frame_info.br_size = br_size;\n+  current_frame_info.ar_size = ar_size;\n   COPY_HARD_REG_SET (current_frame_info.mask, mask);\n   current_frame_info.initialized = reload_completed;\n \n@@ -822,8 +845,11 @@ save_restore_insns (save_p)\n {\n   rtx insn;\n \n-  if (current_frame_info.gr_size + current_frame_info.fr_size\n-      + current_frame_info.br_size + current_frame_info.pr_size)\n+  if (current_frame_info.gr_size\n+      + current_frame_info.fr_size\n+      + current_frame_info.br_size\n+      + current_frame_info.pr_size\n+      + current_frame_info.ar_size)\n     {\n       rtx tmp_reg = gen_rtx_REG (DImode, GR_REG (2));\n       rtx tmp_post_inc = gen_rtx_POST_INC (DImode, tmp_reg);\n@@ -833,6 +859,7 @@ save_restore_insns (save_p)\n \t\t       + current_frame_info.fr_pad_size\n \t\t       + current_frame_info.br_size\n \t\t       + current_frame_info.pr_size\n+\t\t       + current_frame_info.ar_size\n \t\t       + current_frame_info.var_size\n \t\t       + current_frame_info.pretend_size\n \t\t       + current_frame_info.pretend_pad_size));\n@@ -961,6 +988,29 @@ save_restore_insns (save_p)\n \t    if (save_p)\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t  }\n+\n+      if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_LC_REGNUM))\n+\t{\n+\t  rtx src, dest;\n+\n+\t  if (save_p)\n+\t    {\n+\t      src = gen_rtx_REG (DImode, AR_LC_REGNUM);\n+\t      dest = gen_rtx_MEM (DImode, tmp_post_inc);\n+\t    }\n+\t  else\n+\t    {\n+\t      src = gen_rtx_MEM (DImode, tmp_post_inc);\n+\t      dest = gen_rtx_REG (DImode, AR_LC_REGNUM);\n+\t    }\n+\n+\t  insn = emit_insn (gen_movdi (tmp2_reg, src));\n+\t  if (save_p)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_insn (gen_movdi (dest, tmp2_reg));\n+\t  if (save_p)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n     }\n }\n \n@@ -2149,6 +2199,28 @@ ia64_print_operand (file, x, code)\n   return;\n }\n \f\n+/* Calulate the cost of moving data from a register in class FROM to\n+   one in class TO.  */\n+\n+int\n+ia64_register_move_cost (from, to)\n+     enum reg_class from, to;\n+{\n+  int from_hard, to_hard;\n+  int from_gr, to_gr;\n+\n+  from_hard = (from == BR_REGS || from == AR_M_REGS || from == AR_I_REGS);\n+  to_hard = (to == BR_REGS || to == AR_M_REGS || to == AR_I_REGS);\n+  from_gr = (from == GENERAL_REGS);\n+  to_gr = (to == GENERAL_REGS);\n+\n+  if (from_hard && to_hard)\n+    return 8;\n+  else if ((from_hard && !to_gr) || (!from_gr && to_hard))\n+    return 6;\n+\n+  return 2;\n+}\n \n /* This function returns the register class required for a secondary\n    register when copying between one of the registers in CLASS, and X,\n@@ -2382,14 +2454,11 @@ ia64_override_options ()\n    complex).  */\n #define REG_GP\t\t(GR_REG (1))\n #define REG_RP\t\t(BR_REG (0))\n-#define REG_AR_PFS\t(FIRST_PSEUDO_REGISTER)\n #define REG_AR_CFM\t(FIRST_PSEUDO_REGISTER + 1)\n-/* ??? This will eventually need to be a hard register.  */\n-#define REG_AR_EC\t(FIRST_PSEUDO_REGISTER + 2)\n /* This is used for volatile asms which may require a stop bit immediately\n    before and after them.  */\n-#define REG_VOLATILE\t(FIRST_PSEUDO_REGISTER + 3)\n-#define NUM_REGS\t(FIRST_PSEUDO_REGISTER + 4)\n+#define REG_VOLATILE\t(FIRST_PSEUDO_REGISTER + 2)\n+#define NUM_REGS\t(FIRST_PSEUDO_REGISTER + 3)\n \n /* For each register, we keep track of how many times it has been\n    written in the current instruction group.  If a register is written\n@@ -2521,15 +2590,13 @@ rws_access_reg (regno, flags, pred)\n \t  /* Branches have several RAW exceptions that allow to avoid\n \t     barriers.  */\n \n-\t  if (REGNO_REG_CLASS (regno) == BR_REGS || regno == REG_AR_PFS)\n+\t  if (REGNO_REG_CLASS (regno) == BR_REGS || regno == AR_PFS_REGNUM)\n \t    /* RAW dependencies on branch regs are permissible as long\n \t       as the writer is a non-branch instruction.  Since we\n \t       never generate code that uses a branch register written\n \t       by a branch instruction, handling this case is\n \t       easy.  */\n-\t    /* ??? This assumes that we don't emit br.cloop, br.cexit, br.ctop,\n-\t       br.wexit, br.wtop.  This is true currently.  */\n-\t      return 0;\n+\t    return 0;\n \n \t  if (REGNO_REG_CLASS (regno) == PR_REGS\n \t      && ! rws_sum[regno].written_by_fp)\n@@ -2678,7 +2745,7 @@ rtx_needs_barrier (x, flags, pred)\n       new_flags.is_write = 0;\n       /* ??? Why is this here?  It seems unnecessary.  */\n       need_barrier |= rws_access_reg (REG_GP, new_flags, pred);\n-      need_barrier |= rws_access_reg (REG_AR_EC, new_flags, pred);\n+      need_barrier |= rws_access_reg (AR_EC_REGNUM, new_flags, pred);\n \n       /* Avoid multiple register writes, in case this is a pattern with\n \t multiple CALL rtx.  This avoids an abort in rws_access_reg.  */\n@@ -2688,7 +2755,7 @@ rtx_needs_barrier (x, flags, pred)\n \t{\n \t  new_flags.is_write = 1;\n \t  need_barrier |= rws_access_reg (REG_RP, new_flags, pred);\n-\t  need_barrier |= rws_access_reg (REG_AR_PFS, new_flags, pred);\n+\t  need_barrier |= rws_access_reg (AR_PFS_REGNUM, new_flags, pred);\n \t  need_barrier |= rws_access_reg (REG_AR_CFM, new_flags, pred);\n \t}\n       break;\n@@ -2877,7 +2944,7 @@ rtx_needs_barrier (x, flags, pred)\n \t  /* Alloc must always be the first instruction.  Currently, we\n \t     only emit it at the function start, so we don't need to worry\n \t     about emitting a stop bit before it.  */\n-\t  need_barrier = rws_access_reg (REG_AR_PFS, flags, pred);\n+\t  need_barrier = rws_access_reg (AR_PFS_REGNUM, flags, pred);\n \n \t  new_flags.is_write = 1;\n \t  need_barrier |= rws_access_reg (REG_AR_CFM, new_flags, pred);\n@@ -2892,7 +2959,7 @@ rtx_needs_barrier (x, flags, pred)\n \n \tcase 4: /* mov ar.pfs= */\n \t  new_flags.is_write = 1;\n-\t  need_barrier = rws_access_reg (REG_AR_PFS, new_flags, pred);\n+\t  need_barrier = rws_access_reg (AR_PFS_REGNUM, new_flags, pred);\n \t  break;\n \n \tcase 5: /* set_bsp  */\n@@ -2920,10 +2987,10 @@ rtx_needs_barrier (x, flags, pred)\n     case RETURN:\n       new_flags.is_write = 0;\n       need_barrier  = rws_access_reg (REG_RP, flags, pred);\n-      need_barrier |= rws_access_reg (REG_AR_PFS, flags, pred);\n+      need_barrier |= rws_access_reg (AR_PFS_REGNUM, flags, pred);\n \n       new_flags.is_write = 1;\n-      need_barrier |= rws_access_reg (REG_AR_EC, new_flags, pred);\n+      need_barrier |= rws_access_reg (AR_EC_REGNUM, new_flags, pred);\n       need_barrier |= rws_access_reg (REG_AR_CFM, new_flags, pred);\n       break;\n \n@@ -3042,6 +3109,12 @@ emit_insn_group_barriers (insns)\n \t      if (INSN_CODE (insn) == CODE_FOR_epilogue_deallocate_stack)\n \t\tpat = XVECEXP (pat, 0, 0);\n \n+\t      /* ??? Similarly, the pattern we use for br.cloop\n+\t\t confuses the code above.  The second element of the\n+\t\t vector is representative.  */\n+\t      else if (INSN_CODE (insn) == CODE_FOR_doloop_end_internal)\n+\t\tpat = XVECEXP (pat, 0, 1);\n+\n \t      memset (rws_insn, 0, sizeof (rws_insn));\n \t      need_barrier |= rtx_needs_barrier (pat, flags, 0);\n \n@@ -3164,6 +3237,9 @@ ia64_epilogue_uses (regno)\n   if (regno == R_BR (0))\n     return 1;\n \n+  if (regno == AR_LC_REGNUM)\n+    return 1;\n+\n   return 0;\n }\n "}, {"sha": "ab298f40d2b98d3f4816c57c0bf6ddff498c84c0", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -535,12 +535,11 @@ while (0)\n /* Register Basics */\n \n /* Number of hardware registers known to the compiler.  \n-   We have 128 general registers, 128 floating point registers, 64 predicate\n-   registers, 8 branch registers, and one frame pointer register.  */\n+   We have 128 general registers, 128 floating point registers,\n+   64 predicate registers, 8 branch registers, one frame pointer,\n+   and several \"application\" registers.  */\n \n-/* ??? Should add ar.lc, ar.ec and probably also ar.pfs.  */\n-\n-#define FIRST_PSEUDO_REGISTER 330\n+#define FIRST_PSEUDO_REGISTER 334\n \n /* Ranges for the various kinds of registers.  */\n #define ADDL_REGNO_P(REGNO) ((unsigned HOST_WIDE_INT) (REGNO) <= 3)\n@@ -561,10 +560,23 @@ while (0)\n #define IN_REG(REGNO) ((REGNO) + 112)\n #define LOC_REG(REGNO) ((REGNO) + 32)\n \n+#define AR_CCV_REGNUM\t330\n+#define AR_LC_REGNUM\t331\n+#define AR_EC_REGNUM\t332\n+#define AR_PFS_REGNUM\t333\n+\n #define IN_REGNO_P(REGNO) ((REGNO) >= IN_REG (0) && (REGNO) <= IN_REG (7))\n #define LOC_REGNO_P(REGNO) ((REGNO) >= LOC_REG (0) && (REGNO) <= LOC_REG (79))\n #define OUT_REGNO_P(REGNO) ((REGNO) >= OUT_REG (0) && (REGNO) <= OUT_REG (7))\n \n+#define AR_M_REGNO_P(REGNO) ((REGNO) == AR_CCV_REGNUM)\n+#define AR_I_REGNO_P(REGNO) ((REGNO) >= AR_LC_REGNUM \\\n+\t\t\t     && (REGNO) < FIRST_PSEUDO_REGISTER)\n+#define AR_REGNO_P(REGNO) ((REGNO) >= AR_CCV_REGNUM \\\n+\t\t\t   && (REGNO) < FIRST_PSEUDO_REGISTER)\n+\n+\n+\n /* ??? Don't really need two sets of macros.  I like this one better because\n    it is less typing.  */\n #define R_GR(REGNO) GR_REG (REGNO)\n@@ -619,14 +631,14 @@ while (0)\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   /* Branch registers.  */\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t\\\n-  /*FP RA*/\t\t\t\t\t\t\\\n-  1, 1,\t\t\t\t\t\t\t\\\n+  /*FP RA CCV LC EC PFS */\t\t\t\t\\\n+     1, 1,  1, 1, 1,  1\t\t\t\t\t\\\n  }\n \n-/* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n-   general) by function calls as well as for fixed registers.  This macro\n-   therefore identifies the registers that are not available for general\n-   allocation of values that must live across function calls.  */\n+/* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered\n+   (in general) by function calls as well as for fixed registers.  This\n+   macro therefore identifies the registers that are not available for\n+   general allocation of values that must live across function calls.  */\n \n #define CALL_USED_REGISTERS \\\n { /* General registers.  */\t\t\t\t\\\n@@ -654,8 +666,8 @@ while (0)\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   /* Branch registers.  */\t\t\t\t\\\n   1, 0, 0, 0, 0, 0, 1, 1,\t\t\t\t\\\n-  /*FP RA*/\t\t\t\t\t\t\\\n-  1, 1,\t\t\t\t\t\t\t\\\n+  /*FP RA CCV LC EC PFS */\t\t\t\t\\\n+     1, 1,  1, 1, 1,  1\t\t\t\t\t\\\n }\n \n /* Define this macro if the target machine has register windows.  This C\n@@ -787,10 +799,10 @@ while (0)\n   R_PR (0),\t\t\t\t\t\t\t\t   \\\n   /* Special branch registers.  */\t\t\t\t\t   \\\n   R_BR (0),\t\t\t\t\t\t\t\t   \\\n-  /* Frame pointer.  Return address.  */\t\t\t\t   \\\n+  /* Other fixed registers.  */\t\t\t\t\t\t   \\\n   FRAME_POINTER_REGNUM, RETURN_ADDRESS_POINTER_REGNUM,\t\t\t   \\\n+  AR_CCV_REGNUM, AR_LC_REGNUM, AR_EC_REGNUM, AR_PFS_REGNUM\t\t   \\\n }\n-\n \f\n /* How Values Fit in Registers */\n \n@@ -815,6 +827,7 @@ while (0)\n   (FR_REGNO_P (REGNO) ? (MODE) != CCmode\t\t\t\t\\\n    : PR_REGNO_P (REGNO) ? (MODE) == CCmode\t\t\t\t\\\n    : GR_REGNO_P (REGNO) ? (MODE) != XFmode\t\t\t\t\\\n+   : AR_REGNO_P (REGNO) ? (MODE) == DImode\t\t\t\t\\\n    : 1)\n \n /* A C expression that is nonzero if it is desirable to choose register\n@@ -877,6 +890,8 @@ enum reg_class\n   GR_REGS,\n   FR_REGS,\n   GR_AND_FR_REGS,\n+  AR_M_REGS,\n+  AR_I_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -890,7 +905,8 @@ enum reg_class\n    constants.  These names are used in writing some of the debugging dumps.  */\n #define REG_CLASS_NAMES \\\n { \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"ADDL_REGS\", \"GR_REGS\", \\\n-  \"FR_REGS\", \"GR_AND_FR_REGS\", \"ALL_REGS\" }\n+  \"FR_REGS\", \"GR_AND_FR_REGS\", \"AR_M_REGS\", \"AR_I_REGS\", \\\n+  \"ALL_REGS\" }\n \n /* An initializer containing the contents of the register classes, as integers\n    which are bit masks.  The Nth integer specifies the contents of class N.\n@@ -901,35 +917,43 @@ enum reg_class\n   /* NO_REGS.  */\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x000 },\t\t\t\\\n+    0x00000000, 0x00000000, 0x0000 },\t\t\t\\\n   /* PR_REGS.  */\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0xFFFFFFFF, 0xFFFFFFFF, 0x000 },\t\t\t\\\n+    0xFFFFFFFF, 0xFFFFFFFF, 0x0000 },\t\t\t\\\n   /* BR_REGS.  */\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x0FF },\t\t\t\\\n+    0x00000000, 0x00000000, 0x00FF },\t\t\t\\\n   /* ADDL_REGS.  */\t\t\t\t\t\\\n   { 0x0000000F, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x000 },\t\t\t\\\n+    0x00000000, 0x00000000, 0x0000 },\t\t\t\\\n   /* GR_REGS.  */\t\t\t\t\t\\\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n-    0x00000000, 0x00000000, 0x300 },\t\t\t\\\n+    0x00000000, 0x00000000, 0x0300 },\t\t\t\\\n   /* FR_REGS.  */\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n-    0x00000000, 0x00000000, 0x000 },\t\t\t\\\n+    0x00000000, 0x00000000, 0x0000 },\t\t\t\\\n   /* GR_AND_FR_REGS.  */\t\t\t\t\\\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n-    0x00000000, 0x00000000, 0x300 },\t\t\t\\\n+    0x00000000, 0x00000000, 0x0300 },\t\t\t\\\n+  /* AR_M_REGS.  */\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x0400 },\t\t\t\\\n+  /* AR_I_REGS.  */\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x00000000, 0x00000000, 0x3800 },\t\t\t\\\n   /* ALL_REGS.  */\t\t\t\t\t\\\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n-    0xFFFFFFFF, 0xFFFFFFFF, 0x3FF },\t\t\t\\\n+    0xFFFFFFFF, 0xFFFFFFFF, 0x3FFF },\t\t\t\\\n }\n \n /* A C expression whose value is a register class containing hard register\n@@ -944,6 +968,8 @@ enum reg_class\n  : FR_REGNO_P (REGNO) ? FR_REGS\t\t\\\n  : PR_REGNO_P (REGNO) ? PR_REGS\t\t\\\n  : BR_REGNO_P (REGNO) ? BR_REGS\t\t\\\n+ : AR_M_REGNO_P (REGNO) ? AR_I_REGS\t\\\n+ : AR_I_REGNO_P (REGNO) ? AR_M_REGS\t\\\n  : NO_REGS)\n \n /* A macro whose definition is the name of the class to which a valid base\n@@ -968,6 +994,8 @@ enum reg_class\n  : (CHAR) == 'a' ? ADDL_REGS\t\t\\\n  : (CHAR) == 'b' ? BR_REGS\t\t\\\n  : (CHAR) == 'c' ? PR_REGS\t\t\\\n+ : (CHAR) == 'd' ? AR_M_REGS\t\t\\\n+ : (CHAR) == 'e' ? AR_I_REGS\t\t\\\n  : NO_REGS)\n \n /* A C expression which is nonzero if register number NUM is suitable for use\n@@ -1816,8 +1844,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    && rtx_equal_p (R, XEXP (X, 0))\t\t\t\t\t\\\n    && (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n        || (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t   && INTVAL (XEXP (X, 1)) >= -512\t\t\t\t\\\n-\t   && INTVAL (XEXP (X, 1)) < 512)))\n+\t   && INTVAL (XEXP (X, 1)) >= -256\t\t\t\t\\\n+\t   && INTVAL (XEXP (X, 1)) < 256)))\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -1926,10 +1954,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    one in class TO.  */\n \n #define REGISTER_MOVE_COST(FROM, TO) \\\n-((FROM) == BR_REGS && (TO) == BR_REGS ? 8\t\t\t\t\\\n- : (((FROM) == BR_REGS && (TO) != GENERAL_REGS)\t\t\t\t\\\n-    || ((TO) == BR_REGS && (FROM) != GENERAL_REGS)) ? 6\t\t\t\\\n- : 2)\n+  ia64_register_move_cost((FROM), (TO))\n \n /* A C expression for the cost of moving data of mode M between a register and\n    memory.  */\n@@ -2363,7 +2388,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   /* Branch registers.  */\t\t\t\t\t\t\\\n   \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\",\t\t\t\\\n   /* Frame pointer.  Return address.  */\t\t\t\t\\\n-  \"sfp\", \"retaddr\"\t\t\t\t\t\t\t\\\n+  \"sfp\", \"retaddr\", \"ar.ccv\", \"ar.lc\", \"ar.ec\", \"ar.pfs\"\t\t\\\n }\n \n /* If defined, a C initializer for an array of structures containing a name and\n@@ -2749,7 +2774,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"normal_comparison_operator\", {EQ, NE, GT, LE, GTU, LEU}},\t\t\\\n { \"adjusted_comparison_operator\", {LT, GE, LTU, GEU}},\t\t\t\\\n { \"call_multiple_values_operation\", {PARALLEL}},\t\t\t\\\n-{ \"predicate_operator\", {NE, EQ}},\n+{ \"predicate_operator\", {NE, EQ}},\t\t\t\t\t\\\n+{ \"ar_lc_reg_operand\", {REG}},\n \n /* An alias for a machine mode name.  This is the machine mode that elements of\n    a jump-table should have.  */"}, {"sha": "f43012056bee8658908f42ab5ea36473d75d9a29", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 86, "deletions": 32, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -368,10 +368,12 @@\n (define_insn \"\"\n   [(cond_exec\n      (match_operator 2 \"predicate_operator\"\n-       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c,c,c,c,c\")\n+       [(match_operand:CC 3 \"register_operand\" \"c,c,c,c,c,c,c,c,c,c\")\n         (const_int 0)])\n-     (set (match_operand:DI 0 \"register_operand\"  \"=r,r,r, r,*f,*f, r,*b\")\n-\t  (match_operand:DI 1 \"nonmemory_operand\" \"rO,J,i,*f,rO,*f,*b,rO\")))]\n+     (set (match_operand:DI 0 \"register_operand\"\n+\t\t\t      \"=r,r,r, r,*f,*f,   r,*b*e, r,*d\")\n+\t  (match_operand:DI 1 \"nonmemory_operand\"\n+\t\t\t      \"rO,J,i,*f,rO,*f,*b*e,  rO,*d,rO\")))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"*\n {\n@@ -383,6 +385,8 @@\n     \\\"(%J2) setf.sig %0 = %r1\\\",\n     \\\"(%J2) mov %0 = %1\\\",\n     \\\"(%J2) mov %0 = %1\\\",\n+    \\\"(%J2) mov %0 = %r1\\\",\n+    \\\"(%J2) mov %0 = %1\\\",\n     \\\"(%J2) mov %0 = %r1\\\"\n   };\n \n@@ -403,14 +407,14 @@\n \n   return alt[which_alternative];\n }\"\n-  [(set_attr \"type\" \"A,A,L,M,M,F,I,I\")\n+  [(set_attr \"type\" \"A,A,L,M,M,F,I,I,M,M\")\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movdi_internal_astep\"\n   [(set (match_operand:DI 0 \"destination_operand\"\n-\t\t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b\")\n+\t\t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q,   r,*b*e, r,*d\")\n \t(match_operand:DI 1 \"move_operand\"\n-\t\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO\"))]\n+\t\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b*e,  rO,*d,rO\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"*\n {\n@@ -426,6 +430,8 @@\n     \\\"ldf8 %0 = %1%P1\\\",\n     \\\"stf8 %0 = %1%P0\\\",\n     \\\"mov %0 = %1\\\",\n+    \\\"mov %0 = %r1\\\",\n+    \\\"mov %0 = %1\\\",\n     \\\"mov %0 = %r1\\\"\n   };\n \n@@ -435,14 +441,14 @@\n \n   return alt[which_alternative];\n }\"\n-  [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I\")\n+  [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I,M,M\")\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"destination_operand\"\n-\t\t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b\")\n+\t\t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q,   r,*b*e, r,*d\")\n \t(match_operand:DI 1 \"move_operand\"\n-\t\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO\"))]\n+\t\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b*e,  rO,*d,rO\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"*\n {\n@@ -458,6 +464,8 @@\n     \\\"%,ldf8 %0 = %1%P1\\\",\n     \\\"%,stf8 %0 = %1%P0\\\",\n     \\\"%,mov %0 = %1\\\",\n+    \\\"%,mov %0 = %r1\\\",\n+    \\\"%,mov %0 = %1\\\",\n     \\\"%,mov %0 = %r1\\\"\n   };\n \n@@ -467,7 +475,7 @@\n \n   return alt[which_alternative];\n }\"\n-  [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I\")])\n+  [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I,M,M\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -1104,6 +1112,15 @@\n   \"add %0 = %1, %2, 1\"\n   [(set_attr \"type\" \"A\")])\n \n+(define_insn \"*addsi3_plus1_alt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 2))\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"add %0 = %1, %1, 1\"\n+  [(set_attr \"type\" \"A\")])\n+\n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"reg_or_8bit_operand\" \"\")\n@@ -1299,6 +1316,18 @@\n   \"add %0 = %1, %2, 1\"\n   [(set_attr \"type\" \"A\")])\n \n+;; This has some of the same problems as shladd.  We let the shladd\n+;; eliminator hack handle it, which results in the 1 being forced into\n+;; a register, but not more ugliness here.\n+(define_insn \"*adddi3_plus1_alt\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 2))\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"add %0 = %1, %1, 1\"\n+  [(set_attr \"type\" \"A\")])\n+\n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"reg_or_8bit_operand\" \"rK\")\n@@ -1862,31 +1891,20 @@\n ;; doesn't succeed, then this remain a shladd pattern, and will be reloaded\n ;; incorrectly.\n \n-(define_insn \"*shladd_elim\"\n+(define_insn_and_split \"*shladd_elim\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t   (match_operand:DI 2 \"shladd_operand\" \"n\"))\n-\t\t\t  (match_operand:DI 3 \"register_operand\" \"r\"))\n+\t\t\t  (match_operand:DI 3 \"nonmemory_operand\" \"r\"))\n \t\t (match_operand:DI 4 \"nonmemory_operand\" \"rI\")))]\n   \"reload_in_progress\"\n-  \"#\"\n-  [(set_attr \"type\" \"unknown\")])\n-\n-;; ??? Need to emit an instruction group barrier here because this gets split\n-;; after md_reorg.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t\t   (match_operand:DI 2 \"shladd_operand\" \"\"))\n-\t\t\t  (match_operand:DI 3 \"register_operand\" \"\"))\n-\t\t (match_operand:DI 4 \"reg_or_14bit_operand\" \"\")))]\n+  \"* abort ();\"\n   \"reload_completed\"\n   [(set (match_dup 0) (plus:DI (mult:DI (match_dup 1) (match_dup 2))\n \t\t\t       (match_dup 3)))\n-   (unspec_volatile [(const_int 0)] 2)\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n-  \"\")\n+  \"\"\n+  [(set_attr \"type\" \"unknown\")])\n \n (define_insn \"ashrdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -2465,6 +2483,42 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n+;; :: Counted loop operations\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))\t; max iterations\n+   (use (match_operand 3 \"\" \"\"))\t; loop level\n+   (use (match_operand 4 \"\" \"\"))]\t; label\n+  \"\"\n+  \"\n+{\n+  /* Only use cloop on innermost loops.  */\n+  if (INTVAL (operands[3]) > 1)\n+    FAIL;\n+  emit_jump_insn (gen_doloop_end_internal (gen_rtx_REG (DImode, AR_LC_REGNUM),\n+\t\t\t\t\t   operands[4]));\n+  DONE;\n+}\")\n+\n+(define_insn \"doloop_end_internal\"\n+  [(set (pc) (if_then_else (ne (match_operand:DI 0 \"ar_lc_reg_operand\" \"\")\n+\t\t\t       (const_int 0))\n+\t\t(label_ref (match_operand 1 \"\" \"\"))\n+\t\t(pc)))\n+   (set (match_dup 0) (if_then_else:DI (ne (match_dup 0) (const_int 0))\n+\t\t\t (match_dup 0)\n+\t\t\t (plus:DI (match_dup 0) (const_int -1))))]\n+  \"\"\n+  \"br.cloop.sptk.few %l1\"\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n ;; :: Set flag operations\n ;; ::\n ;; ::::::::::::::::::::\n@@ -2706,32 +2760,32 @@\n ;; Errata 72 workaround.\n (define_insn \"*cmovdi_internal_astep\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t  \"=r,*f,Q,*b,r,*f,Q,*b,r,*f,Q,*b\")\n+\t\t\"=r,*f,Q,*b*d*e,r,*f,Q,*b*d*e,r,*f,Q,*b*d*e\")\n \t(if_then_else:DI\n \t  (match_operator:CC 4 \"predicate_operator\"\n \t    [(match_operand:CC 1 \"register_operand\"\n \t\t\t       \"c,c,c,c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n \t  (match_operand:DI 2 \"general_operand\"\n-\t\t    \"0,0,0,0,ri*f*b,rO,*f,r,ri*f*b,rO,*f,r\")\n+\t\t\"0,0,0,0,ri*f*b*d*e,rO,*f,r,ri*f*b*d*e,rO,*f,r\")\n \t  (match_operand:DI 3 \"general_operand\"\n-\t\t    \"ri*f*b,rO,*f,r,0,0,0,0,ri*f*b,rO,*f,r\")))]\n+\t\t\"ri*f*b*d*e,rO,*f,r,0,0,0,0,ri*f*b*d*e,rO,*f,r\")))]\n   \"TARGET_A_STEP\"\n   \"* abort ();\"\n   [(set_attr \"predicable\" \"no\")])\n \n (define_insn \"*cmovdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t  \"=r,m,*f,Q,*b,r,m,*f,Q,*b,r,m,*f,Q,*b\")\n+\t\t\"=r,m,*f,Q,*b*d*e,r,m,*f,Q,*b*d*e,r,m,*f,Q,*b*d*e\")\n \t(if_then_else:DI\n \t  (match_operator:CC 4 \"predicate_operator\"\n \t    [(match_operand:CC 1 \"register_operand\"\n \t\t\t       \"c,c,c,c,c,c,c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n \t  (match_operand:DI 2 \"general_operand\"\n-\t\t    \"0,0,0,0,0,rim*f*b,rO,rOQ,*f,r,rim*f*b,rO,rOQ,*f,r\")\n+\t\t\"0,0,0,0,0,rim*f*b*d*e,rO,rOQ,*f,r,rim*f*b*d*e,rO,rOQ,*f,r\")\n \t  (match_operand:DI 3 \"general_operand\"\n-\t\t    \"rim*f*b,rO,rOQ,*f,r,0,0,0,0,0,rim*f*b,rO,rOQ,*f,r\")))]\n+\t\t\"rim*f*b*d*e,rO,rOQ,*f,r,0,0,0,0,0,rim*f*b*d*e,rO,rOQ,*f,r\")))]\n   \"! TARGET_A_STEP\"\n   \"* abort ();\"\n   [(set_attr \"predicable\" \"no\")])"}, {"sha": "76446067866f4655ec9f343e9985a9a07a63eb9a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -400,11 +400,6 @@ optimization_options (level, size)\n      int level;\n      int size ATTRIBUTE_UNUSED;\n {\n-#ifdef HAVE_decrement_and_branch_on_count\n-  /* When optimizing, enable use of BCT instruction.  */\n-  if (level >= 1)\n-      flag_branch_on_count_reg = 1;\n-#endif\n }\n \f\n /* Do anything needed at the start of the asm file.  */"}, {"sha": "428fac8329d8616eb3466549dbafd62ae2b684fe", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -13291,16 +13291,30 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n ;; Define the subtract-one-and-jump insns, starting with the template\n ;; so loop.c knows what to generate.\n \n-(define_expand \"decrement_and_branch_on_count\"\n-  [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))\t; max iterations\n+   (use (match_operand 3 \"\" \"\"))\t; loop level\n+   (use (match_operand 4 \"\" \"\"))]\t; label\n   \"\"\n   \"\n {\n+  /* Only use this on innermost loops.  */\n+  if (INTVAL (operands[3]) > 1)\n+    FAIL;\n   if (TARGET_POWERPC64)\n-    emit_jump_insn (gen_ctrdi (operands[0], operands[1]));\n+    {\n+      if (GET_MODE (operands[0]) != DImode)\n+\tFAIL;\n+      emit_jump_insn (gen_ctrdi (operands[0], operands[4]));\n+    }\n   else\n-    emit_jump_insn (gen_ctrsi (operands[0], operands[1]));\n+    {\n+      if (GET_MODE (operands[0]) != SImode)\n+\tFAIL;\n+      emit_jump_insn (gen_ctrsi (operands[0], operands[4]));\n+    }\n   DONE;\n }\")\n "}, {"sha": "3933e3ff7c8735f76795b8b763a5179f36eda6ed", "filename": "gcc/doloop.c", "status": "added", "additions": 846, "deletions": 0, "changes": 846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -0,0 +1,846 @@\n+/* Perform doloop optimizations\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"insn-flags.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"loop.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"tm_p.h\"\n+\n+\n+/* This module is used to modify loops with a determinable number of\n+   iterations to use special low-overhead looping instructions.\n+\n+   It first validates whether the loop is well behaved and has a\n+   determinable number of iterations (either at compile or run-time).\n+   It then modifies the loop to use a low-overhead looping pattern as\n+   follows:\n+\n+   1. A pseudo register is allocated as the loop iteration counter.\n+\n+   2. The number of loop iterations is calculated and is stored\n+      in the loop counter.\n+\n+   3. At the end of the loop, the jump insn is replaced by the\n+      doloop_end pattern.  The compare must remain because it might be\n+      used elsewhere.  If the loop-variable or condition register are\n+      used elsewhere, they will be eliminated by flow.\n+\n+   4. An optional doloop_begin pattern is inserted at the top of the\n+      loop.\n+*/\n+\n+\n+#ifdef HAVE_doloop_end\n+\n+static rtx doloop_condition_get\n+  PARAMS ((rtx));\n+static unsigned HOST_WIDE_INT doloop_iterations_max\n+  PARAMS ((const struct loop_info *, enum machine_mode, int));\n+static int doloop_valid_p\n+  PARAMS ((const struct loop *, rtx));\n+static int doloop_modify\n+  PARAMS ((const struct loop *, rtx, rtx, rtx, rtx, rtx));\n+static int doloop_modify_runtime\n+  PARAMS ((const struct loop *, rtx, rtx, rtx, enum machine_mode, rtx));\n+\n+\n+/* Return the loop termination condition for PATTERN or zero\n+   if it is not a decrement and branch jump insn.  */\n+static rtx\n+doloop_condition_get (pattern)\n+     rtx pattern;\n+{\n+  rtx cmp;\n+  rtx inc;\n+  rtx reg;\n+  rtx condition;\n+\n+  /* The canonical doloop pattern we expect is:\n+\n+     (parallel [(set (pc) (if_then_else (condition)\n+                                        (label_ref (label))\n+                                        (pc)))\n+                (set (reg) (plus (reg) (const_int -1)))\n+                (additional clobbers and uses)])\n+\n+     Some machines (IA-64) make the decrement conditional on\n+     the condition as well, so we don't bother verifying the\n+     actual decrement.  In summary, the branch must be the\n+     first entry of the parallel (also required by jump.c),\n+     and the second entry of the parallel must be a set of\n+     the loop counter register.  */\n+\n+  if (GET_CODE (pattern) != PARALLEL)\n+    return 0;\n+\n+  cmp = XVECEXP (pattern, 0, 0);\n+  inc = XVECEXP (pattern, 0, 1);\n+\n+  /* Check for (set (reg) (something)).  */\n+  if (GET_CODE (inc) != SET || ! REG_P (SET_DEST (inc)))\n+    return 0;\n+\n+  /* Extract loop counter register.  */\n+  reg = SET_DEST (inc);\n+\n+  /* Check for (set (pc) (if_then_else (condition)\n+                                       (label_ref (label))\n+                                       (pc))).  */\n+  if (GET_CODE (cmp) != SET\n+      || SET_DEST (cmp) != pc_rtx\n+      || GET_CODE (SET_SRC (cmp)) != IF_THEN_ELSE\n+      || GET_CODE (XEXP (SET_SRC (cmp), 1)) != LABEL_REF\n+      || XEXP (SET_SRC (cmp), 2) != pc_rtx)\n+    return 0;\n+\n+  /* Extract loop termination condition.  */\n+  condition = XEXP (SET_SRC (cmp), 0);\n+\n+  if ((GET_CODE (condition) != GE && GET_CODE (condition) != NE)\n+      || GET_CODE (XEXP (condition, 1)) != CONST_INT)\n+    return 0;\n+\n+  if (XEXP (condition, 0) == reg)\n+    return condition;\n+\n+  if (GET_CODE (XEXP (condition, 0)) == PLUS\n+      && XEXP (XEXP (condition, 0), 0) == reg)\n+    return condition;\n+\n+  /* ??? If a machine uses a funny comparison, we could return a\n+     canonicalised form here.  */\n+\n+  return 0;\n+}\n+\n+\n+/* Return an estimate of the maximum number of loop iterations for the\n+   loop specified by LOOP or zero if the loop is not normal.\n+   MODE is the mode of the iteration count and NONNEG is non-zero if\n+   the the iteration count has been proved to be non-negative.  */\n+static unsigned HOST_WIDE_INT\n+doloop_iterations_max (loop_info, mode, nonneg)\n+     const struct loop_info *loop_info;\n+     enum machine_mode mode;\n+     int nonneg;\n+{\n+  unsigned HOST_WIDE_INT n_iterations_max;\n+  enum rtx_code code;\n+  rtx min_value;\n+  rtx max_value;\n+  HOST_WIDE_INT abs_inc;\n+  int neg_inc;\n+\n+  neg_inc = 0;\n+  abs_inc = INTVAL (loop_info->increment);\n+  if (abs_inc < 0)\n+    {\n+      abs_inc = -abs_inc;\n+      neg_inc = 1;\n+    }\n+\n+  if (neg_inc)\n+    {\n+      code = swap_condition (loop_info->comparison_code);\n+      min_value = loop_info->final_equiv_value;\n+      max_value = loop_info->initial_equiv_value;\n+    }\n+  else\n+    {\n+      code = loop_info->comparison_code;\n+      min_value = loop_info->initial_equiv_value;\n+      max_value = loop_info->final_equiv_value;\n+    }\n+\n+  /* Since the loop has a VTOP, we know that the initial test will be\n+     true and thus the value of max_value should be greater than the\n+     value of min_value.  Thus the difference should always be positive\n+     and the code must be LT, LE, LTU, LEU, or NE.  Otherwise the loop is\n+     not normal, e.g., `for (i = 0; i < 10; i--)'.  */\n+  switch (code)\n+    {\n+    case LTU:\n+    case LEU:\n+      {\n+\tunsigned HOST_WIDE_INT umax;\n+\tunsigned HOST_WIDE_INT umin;\n+\n+\tif (GET_CODE (min_value) == CONST_INT)\n+\t  umin = INTVAL (min_value);\n+\telse\n+\t  umin = 0;\n+\n+\tif (GET_CODE (max_value) == CONST_INT)\n+\t  umax = INTVAL (max_value);\n+\telse\n+\t  umax = (2U << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n+\n+\tn_iterations_max = umax - umin;\n+\tbreak;\n+      }\n+\n+    case LT:\n+    case LE:\n+      {\n+\tHOST_WIDE_INT smax;\n+\tHOST_WIDE_INT smin;\n+\n+\tif (GET_CODE (min_value) == CONST_INT)\n+\t  smin = INTVAL (min_value);\n+\telse\n+\t  smin = -(1U << (GET_MODE_BITSIZE (mode) - 1));\n+\n+\tif (GET_CODE (max_value) == CONST_INT)\n+\t  smax = INTVAL (max_value);\n+\telse\n+\t  smax = (1U << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n+\n+\tn_iterations_max = smax - smin;\n+\tbreak;\n+      }\n+\n+    case NE:\n+      if (GET_CODE (min_value) == CONST_INT\n+\t  && GET_CODE (max_value) == CONST_INT)\n+\tn_iterations_max = INTVAL (max_value) - INTVAL (min_value);\n+      else\n+\t/* We need to conservatively assume that we might have the maximum\n+\t   number of iterations without any additional knowledge.  */\n+\tn_iterations_max = (2U << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  n_iterations_max /= abs_inc;\n+\n+  /* If we know that the iteration count is non-negative then adjust\n+     n_iterations_max if it is so large that it appears negative.  */\n+  if (nonneg && n_iterations_max > (1U << (GET_MODE_BITSIZE (mode) - 1)))\n+    n_iterations_max = (1U << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n+\n+  return n_iterations_max;\n+}\n+\n+\n+/* Return non-zero if the loop specified by LOOP is suitable for\n+   the use of special low-overhead looping instructions.  */\n+static int\n+doloop_valid_p (loop, jump_insn)\n+     const struct loop *loop;\n+     rtx jump_insn;\n+{\n+  const struct loop_info *loop_info = LOOP_INFO (loop);\n+\n+  /* The loop must have a conditional jump at the end.  */\n+  if (! any_condjump_p (jump_insn)\n+      || ! onlyjump_p (jump_insn))\n+    {\n+      if (loop_dump_stream)\n+  \tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Invalid jump at loop end.\\n\");\n+      return 0;\n+    }\n+\n+  /* Give up if a loop has been completely unrolled.  */\n+  if (loop_info->n_iterations == loop_info->unroll_number)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Loop completely unrolled.\\n\");\n+      return 0;\n+    }\n+\n+  /* The loop must have a single exit target.  A break or return\n+     statement within a loop will generate multiple loop exits.\n+     Another example of a loop that currently generates multiple exit\n+     targets is for (i = 0; i < (foo ? 8 : 4); i++) { }.  */\n+  if (loop_info->has_multiple_exit_targets)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Loop has multiple exit targets.\\n\");\n+      return 0;\n+    }\n+\n+  /* An indirect jump may jump out of the loop.  */\n+  if (loop_info->has_indirect_jump)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Indirect jump in function.\\n\");\n+      return 0;\n+    }\n+\n+  /* A called function may clobber any special registers required for\n+     low-overhead looping.  */\n+  if (loop_info->has_call)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Function call in loop.\\n\");\n+      return 0;\n+    }\n+\n+ /* Some targets (eg, PPC) use the count register for branch on table\n+    instructions.  ??? This should be a target specific check.  */\n+  if (loop_info->has_tablejump)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Computed branch in the loop.\\n\");\n+      return 0;\n+    }\n+\n+  if (! loop_info->increment)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Could not determine iteration info.\\n\");\n+      return 0;\n+    }\n+\n+  if (GET_CODE (loop_info->increment) != CONST_INT)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Increment not an integer constant.\\n\");\n+      return 0;\n+    }\n+\n+  /* There is no guarantee that a NE loop will terminate if the\n+     absolute increment is not unity.  ??? We could compute this\n+     condition at run-time and have a additional jump around the loop\n+     to ensure an infinite loop.  */\n+  if (loop_info->comparison_code == NE\n+      && INTVAL (loop_info->increment) != -1\n+      && INTVAL (loop_info->increment) != 1)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: NE loop with non-unity increment.\\n\");\n+      return 0;\n+    }\n+\n+  /* Check for loops that may not terminate under special conditions.  */\n+  if (! loop_info->n_iterations\n+      && ((loop_info->comparison_code == LEU\n+\t   && INTVAL (loop_info->increment) > 0)\n+\t  || (loop_info->comparison_code == GEU\n+\t      && INTVAL (loop_info->increment) < 0)))\n+    {\n+      /* If the comparison is LEU and the comparison value is UINT_MAX\n+\t then the loop will not terminate.  Similarly, if the\n+\t comparison code is GEU and the initial value is 0, the loop\n+\t will not terminate.\n+\n+\t Note that with LE and GE, the loop behaviour can be\n+\t implementation dependent if an overflow occurs, say between\n+\t INT_MAX and INT_MAX + 1.  We thus don't have to worry about\n+\t these two cases.\n+\n+\t ??? We could compute these conditions at run-time and have a\n+\t additional jump around the loop to ensure an infinite loop.\n+\t However, it is very unlikely that this is the intended\n+\t behaviour of the loop and checking for these rare boundary\n+\t conditions would pessimize all other code.  */\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Possible infinite iteration case ignored.\\n\");\n+    }\n+\n+  return 1;\n+}\n+\n+\n+/* Modify the loop to use the low-overhead looping insn where LOOP\n+   describes the loop, ITERATIONS is an RTX containing the desired\n+   number of loop iterations, ITERATIONS_MAX is a CONST_INT specifying\n+   the maximum number of loop iterations, and DOLOOP_INSN is the\n+   low-overhead looping insn to emit at the end of the loop.  This\n+   returns non-zero if it was successful.  */\n+static int\n+doloop_modify (loop, iterations, iterations_max,\n+\t       doloop_seq, start_label, condition)\n+     const struct loop *loop;\n+     rtx iterations;\n+     rtx iterations_max;\n+     rtx doloop_seq;\n+     rtx start_label;\n+     rtx condition;\n+{\n+  rtx counter_reg;\n+  rtx count;\n+  rtx sequence;\n+  rtx jump_insn;\n+  int nonneg = 0;\n+  int decrement_count;\n+\n+  jump_insn = prev_nonnote_insn (loop->end);\n+\n+  if (loop_dump_stream)\n+    {\n+      fprintf (loop_dump_stream, \"Doloop: Inserting doloop pattern (\");\n+      if (GET_CODE (iterations) == CONST_INT)\n+\tfprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC,\n+\t\t INTVAL (iterations));\n+      else\n+\tfputs (\"runtime\", loop_dump_stream);\n+      fputs (\" iterations).\", loop_dump_stream);\n+    }\n+\n+  /* Discard original jump to continue loop.  The original compare\n+     result may still be live, so it cannot be discarded explicitly.  */\n+  delete_insn (jump_insn);\n+\n+  /* Emit the label that will delimit the start of the loop.  */\n+  emit_label_after (start_label, loop->start);\n+  LABEL_NUSES (start_label)++;\n+\n+  counter_reg = XEXP (condition, 0);\n+  if (GET_CODE (counter_reg) == PLUS)\n+    counter_reg = XEXP (counter_reg, 0);\n+\n+  start_sequence ();\n+\n+  count = iterations;\n+  decrement_count = 0;\n+  switch (GET_CODE (condition))\n+    {\n+    case NE:\n+      /* Currently only NE tests against zero and one are supported.  */\n+      if (XEXP (condition, 1) == const0_rtx)\n+\tdecrement_count = 1;\n+      else if (XEXP (condition, 1) != const1_rtx)\n+\tabort ();\n+      break;\n+\n+    case GE:\n+      /* Currently only GE tests against zero are supported.  */\n+      if (XEXP (condition, 1) != const0_rtx)\n+\tabort ();\n+\n+      /* The iteration count needs decrementing for a GE test.  */\n+      decrement_count = 1;\n+\n+      /* Determine if the iteration counter will be non-negative.\n+\t Note that the maximum value loaded is iterations_max - 1.  */\n+      if ((unsigned HOST_WIDE_INT) INTVAL (iterations_max)\n+\t  <= (1U << (GET_MODE_BITSIZE (GET_MODE (counter_reg)) - 1)))\n+\tnonneg = 1;\n+      break;\n+\n+      /* Abort if an invalid doloop pattern has been generated.  */\n+    default:\n+      abort();\n+    }\n+\n+  if (decrement_count)\n+    {\n+      if (GET_CODE (count) == CONST_INT)\n+\tcount = GEN_INT (INTVAL (count) - 1);\n+      else\n+\tcount = expand_binop (GET_MODE (counter_reg), sub_optab,\n+\t\t\t      count, GEN_INT (1),\n+\t\t\t      0, 0, OPTAB_LIB_WIDEN);\n+    }\n+\n+  /* Insert initialization of the count register into the loop header.  */\n+  convert_move (counter_reg, count, 1);\n+  sequence = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_before (sequence, loop->start);\n+\n+  /* Some targets (eg, C4x) need to initialize special looping\n+     registers.  */\n+#ifdef HAVE_doloop_begin\n+  {\n+    rtx init;\n+\n+    init = gen_doloop_begin (counter_reg,\n+\t\t\t     GET_CODE (iterations) == CONST_INT\n+\t\t\t     ? iterations : const0_rtx, iterations_max,\n+\t\t\t     GEN_INT (loop->level));\n+    if (init)\n+      {\n+\tstart_sequence ();\n+\temit_insn (init);\n+\tsequence = gen_sequence ();\n+\tend_sequence ();\n+\temit_insn_after (sequence, loop->start);\n+      }\n+  }\n+#endif\n+\n+  /* Insert the new low-overhead looping insn.  */\n+  emit_jump_insn_before (doloop_seq, loop->end);\n+  jump_insn = prev_nonnote_insn (loop->end);\n+  JUMP_LABEL (jump_insn) = start_label;\n+\n+  /* Add a REG_NONNEG note if the actual or estimated maximum number\n+     of iterations is non-negative.  */\n+  if (nonneg)\n+    {\n+      REG_NOTES (jump_insn)\n+\t= gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX, REG_NOTES (jump_insn));\n+    }\n+  return 1;\n+}\n+\n+\n+/* Handle the more complex case, where the bounds are not known at\n+   compile time.  In this case we generate a run_time calculation of\n+   the number of iterations.  We rely on the existence of a run-time\n+   guard to ensure that the loop executes at least once, i.e.,\n+   initial_value obeys the loop comparison condition.  If a guard is\n+   not present, we emit one.  The loop to modify is described by LOOP.\n+   ITERATIONS_MAX is a CONST_INT specifying the estimated maximum\n+   number of loop iterations.  DOLOOP_INSN is the low-overhead looping\n+   insn to insert.  Returns non-zero if loop successfully modified.  */\n+static int\n+doloop_modify_runtime (loop, iterations_max,\n+\t\t       doloop_seq, start_label, mode, condition)\n+     const struct loop *loop;\n+     rtx iterations_max;\n+     rtx doloop_seq;\n+     rtx start_label;\n+     enum machine_mode mode;\n+     rtx condition;\n+{\n+  const struct loop_info *loop_info = LOOP_INFO (loop);\n+  HOST_WIDE_INT abs_inc;\n+  int neg_inc;\n+  rtx diff;\n+  rtx sequence;\n+  rtx iterations;\n+  rtx initial_value;\n+  rtx final_value;\n+  rtx increment;\n+  int unsigned_p;\n+  enum rtx_code comparison_code;\n+\n+  increment = loop_info->increment;\n+  initial_value = loop_info->initial_value;\n+  final_value = loop_info->final_value;\n+\n+  neg_inc = 0;\n+  abs_inc = INTVAL (increment);\n+  if (abs_inc < 0)\n+    {\n+      abs_inc = -abs_inc;\n+      neg_inc = 1;\n+    }\n+\n+  comparison_code = loop_info->comparison_code;\n+  unsigned_p = (comparison_code == LTU\n+\t\t|| comparison_code == LEU\n+\t\t|| comparison_code == GTU\n+\t\t|| comparison_code == GEU\n+\t\t|| comparison_code == NE);\n+\n+  /* The number of iterations (prior to any loop unrolling) is given by:\n+     (abs (final - initial) + abs_inc - 1) / abs_inc.\n+\n+     However, it is possible for the summation to overflow, and a\n+     safer method is:\n+\n+     abs (final - initial) / abs_inc + (abs (final - initial) % abs_inc) != 0\n+\n+     If the loop has been unrolled, then the loop body has been\n+     preconditioned to iterate a multiple of unroll_number times.\n+     The number of iterations of the loop body is simply:\n+     abs (final - initial) / (abs_inc * unroll_number).\n+\n+     The division and modulo operations can be avoided by requiring\n+     that the increment is a power of 2 (precondition_loop_p enforces\n+     this requirement).  Nevertheless, the RTX_COSTS should be checked\n+     to see if a fast divmod is available.  */\n+\n+  start_sequence ();\n+  /* abs (final - initial)  */\n+  diff = expand_binop (mode, sub_optab,\n+\t\t       copy_rtx (neg_inc ? initial_value : final_value),\n+\t\t       copy_rtx (neg_inc ? final_value : initial_value),\n+\t\t       NULL_RTX, unsigned_p, OPTAB_LIB_WIDEN);\n+\n+  if (loop_info->unroll_number == 1)\n+    {\n+      if (abs_inc != 1)\n+\t{\n+\t  int shift_count;\n+\t  rtx extra;\n+\t  rtx label;\n+\n+\t  shift_count = exact_log2 (abs_inc);\n+\t  if (shift_count < 0)\n+\t    abort ();\n+\n+\t  /* abs (final - initial) / abs_inc  */\n+\t  iterations = expand_binop (GET_MODE (diff), lshr_optab,\n+\t\t\t\t     diff, GEN_INT (shift_count),\n+\t\t\t\t     NULL_RTX, 1,\n+\t\t\t\t     OPTAB_LIB_WIDEN);\n+\n+\t  /* abs (final - initial) % abs_inc  */\n+\t  extra = expand_binop (GET_MODE (iterations), and_optab,\n+\t\t\t\tdiff, GEN_INT (abs_inc - 1),\n+\t\t\t\tNULL_RTX, 1,\n+\t\t\t\tOPTAB_LIB_WIDEN);\n+\n+\t  /* If (abs (final - initial) % abs_inc == 0) jump past\n+\t     following increment instruction.  */\n+\t  label = gen_label_rtx();\n+\t  emit_cmp_and_jump_insns (extra, const0_rtx, EQ, NULL_RTX,\n+\t\t\t\t   GET_MODE (extra), 0, 0, label);\n+\t  JUMP_LABEL (get_last_insn ()) = label;\n+\t  LABEL_NUSES (label)++;\n+\n+\t  /* Increment the iteration count by one.  */\n+\t  iterations = expand_binop (GET_MODE (iterations), add_optab,\n+\t\t\t\t     iterations, GEN_INT (1),\n+\t\t\t\t     iterations, 1,\n+\t\t\t\t     OPTAB_LIB_WIDEN);\n+\n+\t  emit_label (label);\n+\t}\n+      else\n+\titerations = diff;\n+    }\n+  else\n+    {\n+      int shift_count;\n+\n+      /* precondition_loop_p has preconditioned the loop so that the\n+\t iteration count of the loop body is always a power of 2.\n+\t Since we won't get an overflow calculating the loop count,\n+\t the code we emit is simpler.  */\n+      shift_count = exact_log2 (loop_info->unroll_number * abs_inc);\n+      if (shift_count < 0)\n+\tabort ();\n+\n+      iterations = expand_binop (GET_MODE (diff), lshr_optab,\n+\t\t\t\t diff, GEN_INT (shift_count),\n+\t\t\t\t NULL_RTX, 1,\n+\t\t\t\t OPTAB_LIB_WIDEN);\n+    }\n+\n+\n+  /* If there is a NOTE_INSN_LOOP_VTOP, we have a `for' or `while'\n+     style loop, with a loop exit test at the start.  Thus, we can\n+     assume that the loop condition was true when the loop was\n+     entered.\n+\n+     `do-while' loops require special treatment since the exit test is\n+     not executed before the start of the loop.  We need to determine\n+     if the loop will terminate after the first pass and to limit the\n+     iteration count to one if necessary.  */\n+  if (! loop->vtop)\n+    {\n+      rtx label;\n+\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"Doloop: Do-while loop.\\n\");\n+\n+      /* A `do-while' loop must iterate at least once.  If the\n+\t iteration count is bogus, we set the iteration count to 1.\n+\t Note that if the loop has been unrolled, then the loop body\n+\t is guaranteed to execute at least once.  */\n+      if (loop_info->unroll_number == 1)\n+\t{\n+\t  /*  Emit insns to test if the loop will immediately\n+\t      terminate and to set the iteration count to 1 if true.  */\n+\t  label = gen_label_rtx();\n+\t  emit_cmp_and_jump_insns (copy_rtx (initial_value),\n+\t\t\t\t   copy_rtx (loop_info->comparison_value),\n+\t\t\t\t   comparison_code, NULL_RTX, mode, 0, 0,\n+\t\t\t\t   label);\n+\t  JUMP_LABEL (get_last_insn ()) = label;\n+\t  LABEL_NUSES (label)++;\n+\t  emit_move_insn (iterations, const1_rtx);\n+\t  emit_label (label);\n+\t}\n+    }\n+\n+  sequence = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_before (sequence, loop->start);\n+\n+  return doloop_modify (loop, iterations, iterations_max, doloop_seq,\n+\t\t\tstart_label, condition);\n+}\n+\n+\n+/* This is the main entry point.  Process loop described by LOOP\n+   validating that the loop is suitable for conversion to use a low\n+   overhead looping instruction, replacing the jump insn where\n+   suitable.  We distinguish between loops with compile-time bounds\n+   and those with run-time bounds.  Information from LOOP is used to\n+   compute the number of iterations and to determine whether the loop\n+   is a candidate for this optimization.  Returns non-zero if loop\n+   successfully modified.  */\n+int\n+doloop_optimize (loop)\n+     const struct loop *loop;\n+{\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  rtx initial_value;\n+  rtx final_value;\n+  rtx increment;\n+  rtx jump_insn;\n+  enum machine_mode mode;\n+  unsigned HOST_WIDE_INT n_iterations;\n+  unsigned HOST_WIDE_INT n_iterations_max;\n+  rtx doloop_seq, doloop_pat, doloop_reg;\n+  rtx iterations;\n+  rtx iterations_max;\n+  rtx start_label;\n+  rtx condition;\n+\n+  if (loop_dump_stream)\n+    fprintf (loop_dump_stream,\n+\t     \"Doloop: Processing loop %d, enclosed levels %d.\\n\",\n+\t     loop->num, loop->level);\n+\n+  jump_insn = prev_nonnote_insn (loop->end);\n+\n+  /* Check that loop is a candidate for a low-overhead looping insn.  */\n+  if (! doloop_valid_p (loop, jump_insn))\n+    return 0;\n+\n+  /* Determine if the loop can be safely, and profitably,\n+     preconditioned.  While we don't precondition the loop in a loop\n+     unrolling sense, this test ensures that the loop is well behaved\n+     and that the increment is a constant integer.  */\n+  if (! precondition_loop_p (loop, &initial_value, &final_value,\n+\t\t\t     &increment, &mode))\n+    {\n+      if (loop_dump_stream)\n+      \tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Cannot precondition loop.\\n\");\n+      return 0;\n+    }\n+\n+  /* Determine or estimate the maximum number of loop iterations.  */\n+  n_iterations = loop_info->n_iterations;\n+  if (n_iterations)\n+    {\n+      /* This is the simple case where the initial and final loop\n+\t values are constants.  */\n+      n_iterations_max = n_iterations;\n+    }\n+  else\n+    {\n+      int nonneg = find_reg_note (jump_insn, REG_NONNEG, 0) != 0;\n+\n+      /* This is the harder case where the initial and final loop\n+\t values may not be constants.  */\n+      n_iterations_max = doloop_iterations_max (loop_info, mode, nonneg);\n+\n+      if (! n_iterations_max)\n+\t{\n+\t  /* We have something like `for (i = 0; i < 10; i--)'.  */\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"Doloop: Not normal loop.\\n\");\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* Account for loop unrolling in the iteration count.  This will\n+     have no effect if loop_iterations could not determine the number\n+     of iterations.  */\n+  n_iterations /= loop_info->unroll_number;\n+  n_iterations_max /= loop_info->unroll_number;\n+\n+  if (n_iterations && n_iterations < 3)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Too few iterations (%ld) to be profitable.\\n\",\n+\t\t (long int) n_iterations);\n+      return 0;\n+    }\n+\n+  iterations = GEN_INT (n_iterations);\n+  iterations_max = GEN_INT (n_iterations_max);\n+\n+  /* Generate looping insn.  If the pattern FAILs then give up trying\n+     to modify the loop since there is some aspect the back-end does\n+     not like.  */\n+  start_label = gen_label_rtx ();\n+  doloop_reg = gen_reg_rtx (mode);\n+  doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n+\t\t\t       GEN_INT (loop->level), start_label);\n+  if (! doloop_seq && mode != word_mode)\n+    {\n+      PUT_MODE (doloop_reg, word_mode);\n+      doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n+\t\t\t\t   GEN_INT (loop->level), start_label);\n+    }\n+  if (! doloop_seq)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Target unwilling to use doloop pattern!\\n\");\n+      return 0;\n+    }\n+\n+  /* A raw define_insn may yield a plain pattern.  If a sequence\n+     was involved, the last must be the jump instruction.  */\n+  if (GET_CODE (doloop_seq) == SEQUENCE)\n+    {\n+      doloop_pat = XVECEXP (doloop_seq, 0, XVECLEN (doloop_seq, 0) - 1);\n+      if (GET_CODE (doloop_pat) == JUMP_INSN)\n+\tdoloop_pat = PATTERN (doloop_pat);\n+      else\n+\tdoloop_pat = NULL_RTX;\n+    }\n+  else\n+    doloop_pat = doloop_seq;\n+\n+  if (! doloop_pat\n+      || ! (condition = doloop_condition_get (doloop_pat)))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Doloop: Unrecognizable doloop pattern!\\n\");\n+      return 0;\n+    }\n+\n+  if (n_iterations != 0)\n+    /* Handle the simpler case, where we know the iteration count at\n+       compile time.  */\n+    return doloop_modify (loop, iterations, iterations_max, doloop_seq,\n+\t\t\t  start_label, condition);\n+  else\n+    /* Handle the harder case, where we must add additional runtime tests.  */\n+    return doloop_modify_runtime (loop, iterations_max, doloop_seq,\n+\t\t\t\t  start_label, mode, condition);\n+}\n+\n+#endif /* HAVE_doloop_end */"}, {"sha": "7bdd403e64852bf00d2d51818b20ac9ad429cdfd", "filename": "gcc/final.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -918,9 +918,14 @@ int\n insn_current_reference_address (branch)\n      rtx branch;\n {\n-  rtx dest;\n-  rtx seq = NEXT_INSN (PREV_INSN (branch));\n-  int seq_uid = INSN_UID (seq);\n+  rtx dest, seq;\n+  int seq_uid;\n+\n+  if (! INSN_ADDRESSES_SET_P ())\n+    return 0;\n+\n+  seq = NEXT_INSN (PREV_INSN (branch));\n+  seq_uid = INSN_UID (seq);\n   if (GET_CODE (branch) != JUMP_INSN)\n     /* This can happen for example on the PA; the objective is to know the\n        offset to address something in front of the start of the function.\n@@ -929,6 +934,7 @@ insn_current_reference_address (branch)\n        any alignment we'd encounter, so we skip the call to align_fuzz.  */\n     return insn_current_address;\n   dest = JUMP_LABEL (branch);\n+\n   /* BRANCH has no proper alignment chain set, so use SEQ.  */\n   if (INSN_SHUID (branch) < INSN_SHUID (dest))\n     {"}, {"sha": "de5b099d6c03a220bdad66604331bad3bc25cfae", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -375,7 +375,7 @@ extern int flag_schedule_speculative;\n extern int flag_schedule_speculative_load;\n extern int flag_schedule_speculative_load_dangerous;\n \n-/* flag_on_branch_count_reg means try to replace add-1,compare,branch tupple\n+/* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n    by a cheaper branch, on a count register. */\n extern int flag_branch_on_count_reg;\n "}, {"sha": "98a7c434bf4d6f0be7941c9e9db5e5967e7b0dbd", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -2217,7 +2217,7 @@ any_uncondjump_p (insn)\n /* Return true when insn is a conditional jump.  This function works for\n    instructions containing PC sets in PARALLELs.  The instruction may have\n    various other effects so before removing the jump you must verify\n-   safe_to_remove_jump_p.\n+   onlyjump_p.\n \n    Note that unlike condjump_p it returns false for unconditional jumps.  */\n "}, {"sha": "f812b2e4c76c2bc4f36f938843ce86b6d559e332", "filename": "gcc/loop.c", "status": "modified", "additions": 6, "deletions": 300, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -327,16 +327,8 @@ typedef struct rtx_pair {\n    && INSN_LUID (INSN) >= INSN_LUID (START)\t\\\n    && INSN_LUID (INSN) <= INSN_LUID (END))\n \n-#ifdef HAVE_decrement_and_branch_on_count\n-/* Test whether BCT applicable and safe.  */\n-static void insert_bct PARAMS ((struct loop *));\n-\n-/* Auxiliary function that inserts the BCT pattern into the loop.  */\n-static void instrument_loop_bct PARAMS ((rtx, rtx, rtx));\n-#endif /* HAVE_decrement_and_branch_on_count */\n-\n /* Indirect_jump_in_function is computed once per function.  */\n-int indirect_jump_in_function = 0;\n+static int indirect_jump_in_function;\n static int indirect_jump_in_function_p PARAMS ((rtx));\n \n static int compute_luids PARAMS ((rtx, rtx, int));\n@@ -5025,12 +5017,10 @@ strength_reduce (loop, insn_count, flags)\n \t  && unrolled_insn_copies <= insn_count))\n     unroll_loop (loop, insn_count, end_insert_before, 1);\n \n-#ifdef HAVE_decrement_and_branch_on_count\n-  /* Instrument the loop with BCT insn.  */\n-  if (HAVE_decrement_and_branch_on_count && (flags & LOOP_BCT)\n-      && flag_branch_on_count_reg)\n-    insert_bct (loop);\n-#endif  /* HAVE_decrement_and_branch_on_count */\n+#ifdef HAVE_doloop_end\n+  if (HAVE_doloop_end && (flags & LOOP_BCT) && flag_branch_on_count_reg)\n+    doloop_optimize (loop);\n+#endif  /* HAVE_doloop_end  */\n \n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n@@ -9187,6 +9177,7 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n   return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n }\n \n+\n /* Given a jump insn JUMP, return the condition that will cause it to branch\n    to its JUMP_LABEL.  If the condition cannot be understood, or is an\n    inequality floating-point comparison which needs to be reversed, 0 will\n@@ -9242,291 +9233,6 @@ get_condition_for_loop (loop, x)\n \t\t\t XEXP (comparison, 1), XEXP (comparison, 0));\n }\n \n-#ifdef HAVE_decrement_and_branch_on_count\n-/* Instrument loop for insertion of bct instruction.  We distinguish between\n-   loops with compile-time bounds and those with run-time bounds. \n-   Information from loop_iterations() is used to compute compile-time bounds.\n-   Run-time bounds should use loop preconditioning, but currently ignored.\n- */\n-\n-static void\n-insert_bct (loop)\n-     struct loop *loop;\n-{\n-  unsigned HOST_WIDE_INT n_iterations;\n-  rtx loop_start = loop->start;\n-  rtx loop_end = loop->end;\n-  struct loop_info *loop_info = LOOP_INFO (loop);  \n-  int loop_num = loop->num;\n-\n-#if 0\n-  int increment_direction, compare_direction;\n-  /* If the loop condition is <= or >=, the number of iteration\n-      is 1 more than the range of the bounds of the loop.  */\n-  int add_iteration = 0;\n-  enum machine_mode loop_var_mode = word_mode;\n-#endif\n-\n-  /* It's impossible to instrument a competely unrolled loop.  */\n-  if (loop_info->unroll_number == loop_info->n_iterations)\n-    return;\n-\n-  /* Make sure that the count register is not in use.  */\n-  if (loop_info->used_count_register)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT instrumentation failed: count register already in use\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* Make sure that the function has no indirect jumps.  */\n-  if (indirect_jump_in_function)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT instrumentation failed: indirect jump in function\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* Make sure that the last loop insn is a conditional jump.  */\n-  if (GET_CODE (PREV_INSN (loop_end)) != JUMP_INSN\n-      || ! onlyjump_p (PREV_INSN (loop_end))\n-      || ! any_condjump_p (PREV_INSN (loop_end)))\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT instrumentation failed: invalid jump at loop end\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* Make sure that the loop does not contain a function call\n-     (the count register might be altered by the called function).  */\n-  if (loop_info->has_call)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT instrumentation failed: function call in loop\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* Make sure that the loop does not jump via a table.\n-     (the count register might be used to perform the branch on table).  */\n-  if (loop_info->has_tablejump)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT instrumentation failed: computed branch in the loop\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* Account for loop unrolling in instrumented iteration count.  */\n-  if (loop_info->unroll_number > 1)\n-    n_iterations = loop_info->n_iterations / loop_info->unroll_number;\n-  else\n-    n_iterations = loop_info->n_iterations;\n-\n-  if (n_iterations != 0 && n_iterations < 3)\n-    {\n-      /* Allow an enclosing outer loop to benefit if possible.  */\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: Too few iterations to benefit from BCT optimization\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* Try to instrument the loop.  */\n-\n-  /* Handle the simpler case, where the bounds are known at compile time.  */\n-  if (n_iterations > 0)\n-    {\n-      struct loop *outer_loop;\n-      struct loop_info *outer_loop_info;\n-\n-      /* Mark all enclosing loops that they cannot use count register.  */\n-      for (outer_loop = loop; outer_loop; outer_loop = outer_loop->outer)\n-\t{\n-\t  outer_loop_info = LOOP_INFO (outer_loop);\n-\t  outer_loop_info->used_count_register = 1;\n-\t}\n-      instrument_loop_bct (loop_start, loop_end, GEN_INT (n_iterations));\n-      return;\n-    }\n-\n-  /* Handle the more complex case, that the bounds are NOT known\n-     at compile time.  In this case we generate run_time calculation\n-     of the number of iterations.  */\n-\n-  if (loop_info->iteration_var == 0)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT Runtime Instrumentation failed: no loop iteration variable found\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  if (GET_MODE_CLASS (GET_MODE (loop_info->iteration_var)) != MODE_INT\n-      || GET_MODE_SIZE (GET_MODE (loop_info->iteration_var)) != UNITS_PER_WORD)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT Runtime Instrumentation failed: loop variable not integer\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-\n-  /* With runtime bounds, if the compare is of the form '!=' we give up */\n-  if (loop_info->comparison_code == NE)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"insert_bct %d: BCT Runtime Instrumentation failed: runtime bounds with != comparison\\n\",\n-\t\t loop_num);\n-      return;\n-    }\n-/* Use common loop preconditioning code instead.  */\n-#if 0\n-  else\n-    {\n-      /* We rely on the existence of run-time guard to ensure that the\n-\t loop executes at least once.  */\n-      rtx sequence;\n-      rtx iterations_num_reg;\n-\n-      unsigned HOST_WIDE_INT increment_value_abs\n-\t= INTVAL (increment) * increment_direction;\n-\n-      /* make sure that the increment is a power of two, otherwise (an\n-\t expensive) divide is needed.  */\n-      if (exact_log2 (increment_value_abs) == -1)\n-\t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n-\t\t     \"insert_bct: not instrumenting BCT because the increment is not power of 2\\n\");\n-\t  return;\n-\t}\n-\n-      /* compute the number of iterations */\n-      start_sequence ();\n-      {\n-\trtx temp_reg;\n-\n-\t/* Again, the number of iterations is calculated by:\n-\t   ;\n-\t   ;                  compare-val - initial-val + (increment -1) + additional-iteration\n-\t   ; num_iterations = -----------------------------------------------------------------\n-\t   ;                                           increment\n-\t */\n-\t/* ??? Do we have to call copy_rtx here before passing rtx to\n-\t   expand_binop?  */\n-\tif (compare_direction > 0)\n-\t  {\n-\t    /* <, <= :the loop variable is increasing */\n-\t    temp_reg = expand_binop (loop_var_mode, sub_optab,\n-\t\t\t\t     comparison_value, initial_value,\n-\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t  }\n-\telse\n-\t  {\n-\t    temp_reg = expand_binop (loop_var_mode, sub_optab,\n-\t\t\t\t     initial_value, comparison_value,\n-\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t  }\n-\n-\tif (increment_value_abs - 1 + add_iteration != 0)\n-\t  temp_reg = expand_binop (loop_var_mode, add_optab, temp_reg,\n-\t\t\t\t   GEN_INT (increment_value_abs - 1\n-\t\t\t\t\t    + add_iteration),\n-\t\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\n-\tif (increment_value_abs != 1)\n-\t  iterations_num_reg = expand_binop (loop_var_mode, asr_optab,\n-\t\t\t\t\t     temp_reg,\n-\t\t\t\t\t     GEN_INT (exact_log2 (increment_value_abs)),\n-\t\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\telse\n-\t  iterations_num_reg = temp_reg;\n-      }\n-      sequence = gen_sequence ();\n-      end_sequence ();\n-      emit_insn_before (sequence, loop_start);\n-      instrument_loop_bct (loop_start, loop_end, iterations_num_reg);\n-    }\n-\n-  return;\n-#endif /* Complex case */\n-}\n-\n-/* Instrument loop by inserting a bct in it as follows:\n-   1. A new counter register is created.\n-   2. In the head of the loop the new variable is initialized to the value\n-   passed in the loop_num_iterations parameter.\n-   3. At the end of the loop, comparison of the register with 0 is generated.\n-   The created comparison follows the pattern defined for the\n-   decrement_and_branch_on_count insn, so this insn will be generated.\n-   4. The branch on the old variable are deleted.  The compare must remain\n-   because it might be used elsewhere.  If the loop-variable or condition\n-   register are used elsewhere, they will be eliminated by flow.  */\n-\n-static void\n-instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n-     rtx loop_start, loop_end;\n-     rtx loop_num_iterations;\n-{\n-  rtx counter_reg;\n-  rtx start_label;\n-  rtx sequence;\n-\n-  if (HAVE_decrement_and_branch_on_count)\n-    {\n-      if (loop_dump_stream)\n-\t{\n-\t  fputs (\"instrument_bct: Inserting BCT (\", loop_dump_stream);\n-\t  if (GET_CODE (loop_num_iterations) == CONST_INT)\n-\t    fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC,\n-\t\t     INTVAL (loop_num_iterations));\n-\t  else\n-\t    fputs (\"runtime\", loop_dump_stream);\n-\t  fputs (\" iterations)\", loop_dump_stream);\n-\t}\n-\n-      /* Discard original jump to continue loop.  Original compare result\n-\t may still be live, so it cannot be discarded explicitly.  */\n-      delete_insn (PREV_INSN (loop_end));\n-\n-      /* Insert the label which will delimit the start of the loop.  */\n-      start_label = gen_label_rtx ();\n-      emit_label_after (start_label, loop_start);\n-\n-      /* Insert initialization of the count register into the loop header.  */\n-      start_sequence ();\n-      counter_reg = gen_reg_rtx (word_mode);\n-      emit_insn (gen_move_insn (counter_reg, loop_num_iterations));\n-      sequence = gen_sequence ();\n-      end_sequence ();\n-      emit_insn_before (sequence, loop_start);\n-\n-      /* Insert new comparison on the count register instead of the\n-\t old one, generating the needed BCT pattern (that will be\n-\t later recognized by assembly generation phase).  */\n-      sequence = emit_jump_insn_before (\n-\tgen_decrement_and_branch_on_count (counter_reg, start_label),\n-\tloop_end);\n-\n-      if (GET_CODE (sequence) != JUMP_INSN)\n-\tabort ();\n-      JUMP_LABEL (sequence) = start_label;\n-      LABEL_NUSES (start_label)++;\n-    }\n-}\n-#endif /* HAVE_decrement_and_branch_on_count */\n \n /* Scan the function and determine whether it has indirect (computed) jumps.\n "}, {"sha": "7d4c7cea41a8e5a2aafe30777357cbe623ef9720", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -254,3 +254,5 @@ int loop_insn_first_p PARAMS ((rtx, rtx));\n typedef rtx (*loop_insn_callback ) PARAMS ((struct loop *, rtx, int, int));\n void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n \n+/* Forward declarations for non-static functions declared in doloop.c.  */\n+int doloop_optimize PARAMS ((const struct loop *));"}, {"sha": "9bbd10b3dddbc778b1a1ebf1b2a09bd7483557ca", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -2626,7 +2626,7 @@ split_all_insns (upd_life)\n \t  /* Can't use `next_real_insn' because that might go across\n \t     CODE_LABELS and short-out basic blocks.  */\n \t  next = NEXT_INSN (insn);\n-\t  if (GET_CODE (insn) != INSN)\n+\t  if (! INSN_P (insn))\n \t    ;\n \n \t  /* Don't split no-op move insns.  These should silently"}, {"sha": "2e06176b65aef67c4d7427d6f2c952078df9d896", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5527bf14a5a334ea3509a3dd927b070bc92fb363/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5527bf14a5a334ea3509a3dd927b070bc92fb363", "patch": "@@ -746,9 +746,9 @@ int flag_schedule_speculative_load_dangerous = 0;\n \n int flag_single_precision_constant;\n \n-/* flag_on_branch_count_reg means try to replace add-1,compare,branch tupple\n-   by a cheaper branch, on a count register. */\n-int flag_branch_on_count_reg;\n+/* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n+   by a cheaper branch on a count register. */\n+int flag_branch_on_count_reg = 1;\n \n /* -finhibit-size-directive inhibits output of .size for ELF.\n    This is used only for compiling crtstuff.c, "}]}