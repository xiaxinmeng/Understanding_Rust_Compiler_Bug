{"sha": "838dfd8a4ef2572d4831643b01d70f78ba6e7747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM4ZGZkOGE0ZWYyNTcyZDQ4MzE2NDNiMDFkNzBmNzhiYTZlNzc0Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-21T12:51:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-21T12:51:56Z"}, "message": "ChangeLog: Follow spelling conventions.\n\n\t* ChangeLog: Follow spelling conventions.\n\t* ChangeLog.2: Likewise.\n\t* call.c: Likewise.\n\t* class.c: Likewise.\n\t* cp-tree.h: Likewise.\n\t* cvt.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* except.c: Likewise.\n\t* friend.c: Likewise.\n\t* g++spec.c: Likewise.\n\t* init.c: Likewise.\n\t* lex.c: Likewise.\n\t* mangle.c: Likewise.\n\t* method.c: Likewise.\n\t* operators.def: Likewise.\n\t* optimize.c: Likewise.\n\t* pt.c: Likewise.\n\t* rtti.c: Likewise.\n\t* search.c: Likewise.\n\t* semantics.c: Likewise.\n\t* spew.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\nFrom-SVN: r57387", "tree": {"sha": "f9f92f248e52e649957fe2bf5fc9b58a2f9423e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9f92f248e52e649957fe2bf5fc9b58a2f9423e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/838dfd8a4ef2572d4831643b01d70f78ba6e7747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838dfd8a4ef2572d4831643b01d70f78ba6e7747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/838dfd8a4ef2572d4831643b01d70f78ba6e7747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838dfd8a4ef2572d4831643b01d70f78ba6e7747/comments", "author": null, "committer": null, "parents": [{"sha": "42cd531a93f8698c46118016981e654256ac8398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42cd531a93f8698c46118016981e654256ac8398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42cd531a93f8698c46118016981e654256ac8398"}], "stats": {"total": 355, "additions": 191, "deletions": 164}, "files": [{"sha": "634ccbbba3e5ff227e560b68e4c2e81b0fb8c287", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -1,3 +1,30 @@\n+2002-09-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* ChangeLog: Follow spelling conventions.\n+\t* ChangeLog.2: Likewise.\n+\t* call.c: Likewise.\n+\t* class.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* except.c: Likewise.\n+\t* friend.c: Likewise.\n+\t* g++spec.c: Likewise.\n+\t* init.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* method.c: Likewise.\n+\t* operators.def: Likewise.\n+\t* optimize.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* spew.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\n 2002-09-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (grokdeclarator): Use assert, not internal_error. Don't\n@@ -4261,7 +4288,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \tPR c++/3621\n \t* spew.c (yylex): Only copy the token's lineno, if it is\n-\tnon-zero.\n+\tnonzero.\n \n 2001-07-26  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -4399,7 +4426,7 @@ Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n 2001-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tRemove old-abi remnants. Remove comments about old abi\n-\tbehaviour. Remove references to 'new-abi' in comments.\n+\tbehavior. Remove references to 'new-abi' in comments.\n \t* cp-tree.h: Adjust comments.\n \t(vbase_offsets_in_vtable_p): Delete.\n \t(vcall_offsets_in_vtable_p): Delete.\n@@ -5601,7 +5628,7 @@ Thu Apr  5 16:54:29 2001  J\"orn Rennecke <amylaar@redhat.com>\n \t(maybe_commonize_var): Allow inlining functions even if they have\n \tstatic local variables, use comdat_linkage for them if flag_weak.\n \t(check_initializer): Call obscure_complex_init if\n-\tgrok_reference_init returned non-zero.\n+\tgrok_reference_init returned nonzero.\n \t(save_function_data): Clear x_local_names.\n \t(pop_cp_function_context): Free x_local_names.\n \t(mark_inlined_fns): Remove.\n@@ -12748,7 +12775,7 @@ Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(add_method): Used functions are hidden by local functions.\n \t(check_bases_and_members): Handle using-decls before finalizing\n \tCLASSTYPE_METHOD_VEC.\n-\t* call.c (add_function_candidate): Add ctype parm; if non-zero,\n+\t* call.c (add_function_candidate): Add ctype parm; if nonzero,\n \toverride the type of 'this' accordingly.\n \t(add_template_candidate, add_template_candidate_real): Add ctype parm.\n \t(convert_class_to_reference, build_user_type_conversion_1,"}, {"sha": "26dc387a37ead28dc4d45165e310f3ed2368e541", "filename": "gcc/cp/ChangeLog.2", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2FChangeLog.2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2FChangeLog.2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog.2?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -1264,7 +1264,7 @@ Wed Oct 13 22:01:35 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n 1999-10-06  Brendan Kehoe  <brendan@cygnus.com>\n \n-\t* decl.c (grokdeclarator): Only warn about non-zero arrays if\n+\t* decl.c (grokdeclarator): Only warn about nonzero arrays if\n \t!in_system_header (linux socketbits.h can give this for\n \t__cmsg_data, which is using a GNU extension).\n \n@@ -19205,7 +19205,7 @@ Mon Mar  4 22:38:39 1996  Gerald Baumgartner  <gb@alexander.cs.purdue.edu>\n \n \t* sig.c (build_signature_pointer_or_reference_type): Align\n \tsignature pointers/references on 8-byte boundaries so they can be\n-\tgrabbed 2 words at a time on a Sparc.\n+\tgrabbed 2 words at a time on a SPARC.\n \n Tue Mar  5 10:21:01 1996  Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "194707666a4b36cf8c929bf33b02194e5937b3b7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -647,7 +647,7 @@ null_ptr_cst_p (t)\n }\n \n \n-/* Returns non-zero if PARMLIST consists of only default parms and/or\n+/* Returns nonzero if PARMLIST consists of only default parms and/or\n    ellipsis.  */\n \n int\n@@ -938,7 +938,7 @@ standard_conversion (to, from, expr)\n   return conv;\n }\n \n-/* Returns non-zero if T1 is reference-related to T2.  */\n+/* Returns nonzero if T1 is reference-related to T2.  */\n \n static int\n reference_related_p (t1, t2)\n@@ -958,7 +958,7 @@ reference_related_p (t1, t2)\n \t      && DERIVED_FROM_P (t1, t2)));\n }\n \n-/* Returns non-zero if T1 is reference-compatible with T2.  */\n+/* Returns nonzero if T1 is reference-compatible with T2.  */\n \n static int\n reference_compatible_p (t1, t2)\n@@ -1623,7 +1623,7 @@ is_complete (t)\n   return COMPLETE_TYPE_P (complete_type (t));\n }\n \n-/* Returns non-zero if TYPE is a promoted arithmetic type.  */\n+/* Returns nonzero if TYPE is a promoted arithmetic type.  */\n \n static int\n promoted_arithmetic_type_p (type)\n@@ -3874,7 +3874,7 @@ enforce_access (basetype_path, decl)\n \n /* Perform the conversions in CONVS on the expression EXPR. \n    FN and ARGNUM are used for diagnostics.  ARGNUM is zero based, -1\n-   indicates the `this' argument of a method.  INNER is non-zero when\n+   indicates the `this' argument of a method.  INNER is nonzero when\n    being called to continue a conversion chain. It is negative when a\n    reference binding will be applied, positive otherwise.  */\n \n@@ -4118,7 +4118,7 @@ convert_arg_to_ellipsis (arg)\n   \n   if (arg != error_mark_node && ! pod_type_p (TREE_TYPE (arg)))\n     {\n-      /* Undefined behaviour [expr.call] 5.2.2/7.  We used to just warn\n+      /* Undefined behavior [expr.call] 5.2.2/7.  We used to just warn\n \t here and do a bitwise copy, but now cp_expr_size will abort if we\n \t try to do that.  */\n       error (\"cannot pass objects of non-POD type `%#T' through `...'\",\n@@ -4146,7 +4146,7 @@ build_x_va_arg (expr, type)\n   \n   if (! pod_type_p (type))\n     {\n-      /* Undefined behaviour [expr.call] 5.2.2/7.  */\n+      /* Undefined behavior [expr.call] 5.2.2/7.  */\n       warning (\"cannot receive objects of non-POD type `%#T' through `...'\",\n \t\t  type);\n     }\n@@ -4906,7 +4906,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n   return call;\n }\n \n-/* Returns non-zero iff standard conversion sequence ICS1 is a proper\n+/* Returns nonzero iff standard conversion sequence ICS1 is a proper\n    subsequence of ICS2.  */\n \n static int\n@@ -4946,7 +4946,7 @@ is_subseq (ics1, ics2)\n     }\n }\n \n-/* Returns non-zero iff DERIVED is derived from BASE.  The inputs may\n+/* Returns nonzero iff DERIVED is derived from BASE.  The inputs may\n    be any _TYPE nodes.  */\n \n int\n@@ -5044,7 +5044,7 @@ compare_ics (ics1, ics2)\n   tree deref_to_type2 = NULL_TREE;\n   int rank1, rank2;\n \n-  /* REF_BINDING is non-zero if the result of the conversion sequence\n+  /* REF_BINDING is nonzero if the result of the conversion sequence\n      is a reference type.   In that case TARGET_TYPE is the\n      type referred to by the reference.  */\n   tree target_type1;\n@@ -5743,7 +5743,7 @@ tourney (candidates)\n   return champ;\n }\n \n-/* Returns non-zero if things of type FROM can be converted to TO.  */\n+/* Returns nonzero if things of type FROM can be converted to TO.  */\n \n int\n can_convert (to, from)\n@@ -5752,7 +5752,7 @@ can_convert (to, from)\n   return can_convert_arg (to, from, NULL_TREE);\n }\n \n-/* Returns non-zero if ARG (of type FROM) can be converted to TO.  */\n+/* Returns nonzero if ARG (of type FROM) can be converted to TO.  */\n \n int\n can_convert_arg (to, from, arg)"}, {"sha": "7f365e76899873004d65380e7a50f0cb07f6bbff", "filename": "gcc/cp/class.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -532,7 +532,7 @@ build_vtable (class_type, name, vtable_type)\n \n /* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,\n    or even complete.  If this does not exist, create it.  If COMPLETE is\n-   non-zero, then complete the definition of it -- that will render it\n+   nonzero, then complete the definition of it -- that will render it\n    impossible to actually build the vtable, but is useful to get at those\n    which are known to exist in the runtime.  */\n \n@@ -593,7 +593,7 @@ copy_virtuals (binfo)\n /* Build the primary virtual function table for TYPE.  If BINFO is\n    non-NULL, build the vtable starting with the initial approximation\n    that it is the same as the one which is the head of the association\n-   list.  Returns a non-zero value if a new vtable is actually\n+   list.  Returns a nonzero value if a new vtable is actually\n    created.  */\n \n static int\n@@ -645,7 +645,7 @@ build_primary_vtable (binfo, type)\n    FOR_TYPE is the most derived type which caused this table to\n    be needed.\n \n-   Returns non-zero if we haven't met BINFO before.\n+   Returns nonzero if we haven't met BINFO before.\n \n    The order in which vtables are built (by calling this function) for\n    an object must remain the same, otherwise a binary incompatibility\n@@ -676,7 +676,7 @@ build_secondary_vtable (binfo, for_type)\n }\n \n /* Create a new vtable for BINFO which is the hierarchy dominated by\n-   T. Return non-zero if we actually created a new vtable.  */\n+   T. Return nonzero if we actually created a new vtable.  */\n \n static int\n make_new_vtable (t, binfo)\n@@ -2158,7 +2158,7 @@ layout_vtable_decl (binfo, n)\n       layout_decl (vtable, 0);\n \n       /* At one time the vtable info was grabbed 2 words at a time.  This\n-\t fails on Sparc unless you have 8-byte alignment.  */\n+\t fails on SPARC unless you have 8-byte alignment.  */\n       DECL_ALIGN (vtable) = MAX (TYPE_ALIGN (double_type_node),\n \t\t\t\t DECL_ALIGN (vtable));\n     }\n@@ -2645,7 +2645,7 @@ modify_all_vtables (t, vfuns_p, virtuals)\n /* Here, we already know that they match in every respect.\n    All we have to check is where they had their declarations.\n \n-   Return non-zero iff FNDECL1 is declared in a class which has a\n+   Return nonzero iff FNDECL1 is declared in a class which has a\n    proper base class containing FNDECL2.  We don't care about\n    ambiguity or accessibility.  */\n \n@@ -3454,7 +3454,7 @@ record_subobject_offset (type, offset, offsets)\n   return 0;\n }\n \n-/* Returns non-zero if TYPE is an empty class type and there is\n+/* Returns nonzero if TYPE is an empty class type and there is\n    already an entry in OFFSETS for the same TYPE as the same OFFSET.  */\n \n static int\n@@ -3483,13 +3483,13 @@ check_subobject_offset (type, offset, offsets)\n \n /* Walk through all the subobjects of TYPE (located at OFFSET).  Call\n    F for every subobject, passing it the type, offset, and table of\n-   OFFSETS.  If VBASES_P is non-zero, then even virtual non-primary\n+   OFFSETS.  If VBASES_P is nonzero, then even virtual non-primary\n    bases should be traversed; otherwise, they are ignored.  \n \n    If MAX_OFFSET is non-NULL, then subobjects with an offset greater\n    than MAX_OFFSET will not be walked.\n \n-   If F returns a non-zero value, the traversal ceases, and that value\n+   If F returns a nonzero value, the traversal ceases, and that value\n    is returned.  Otherwise, returns zero.  */\n \n static int\n@@ -3588,7 +3588,7 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n }\n \n /* Record all of the empty subobjects of TYPE (located at OFFSET) in\n-   OFFSETS.  If VBASES_P is non-zero, virtual bases of TYPE are\n+   OFFSETS.  If VBASES_P is nonzero, virtual bases of TYPE are\n    examined.  */\n \n static void\n@@ -3602,8 +3602,8 @@ record_subobject_offsets (type, offset, offsets, vbases_p)\n \t\t\t  offsets, /*max_offset=*/NULL_TREE, vbases_p);\n }\n \n-/* Returns non-zero if any of the empty subobjects of TYPE (located at\n-   OFFSET) conflict with entries in OFFSETS.  If VBASES_P is non-zero,\n+/* Returns nonzero if any of the empty subobjects of TYPE (located at\n+   OFFSET) conflict with entries in OFFSETS.  If VBASES_P is nonzero,\n    virtual bases of TYPE are examined.  */\n \n static int\n@@ -3671,7 +3671,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n \t offset zero -- its S component would be at the same address\n \t as the S we already allocated.  So, we have to skip ahead.\n \t Since all data members, including those whose type is an\n-\t empty class, have non-zero size, any overlap can happen only\n+\t empty class, have nonzero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n       if (layout_conflict_p (TREE_TYPE (decl),\n@@ -3708,7 +3708,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n    past the end of the class, and should be correctly aligned for a\n    class of the type indicated by BINFO; OFFSETS gives the offsets of\n    the empty bases allocated so far. T is the most derived\n-   type.  Return non-zero iff we added it at the end.  */\n+   type.  Return nonzero iff we added it at the end.  */\n \n static bool\n layout_empty_base (binfo, eoc, offsets, t)\n@@ -3756,7 +3756,7 @@ layout_empty_base (binfo, eoc, offsets, t)\n    indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n    *BASE_ALIGN is a running maximum of the alignments of any base\n    class.  OFFSETS gives the location of empty base subobjects.  T is\n-   the most derived type.  Return non-zero if the new object cannot be\n+   the most derived type.  Return nonzero if the new object cannot be\n    nearly-empty.  */\n \n static bool\n@@ -3818,7 +3818,7 @@ build_base_field (rli, binfo, empty_p, offsets, t)\n \n /* Layout all of the non-virtual base classes.  Record empty\n    subobjects in OFFSETS.  T is the most derived type.  Return\n-   non-zero if the type cannot be nearly empty.  */\n+   nonzero if the type cannot be nearly empty.  */\n \n static bool\n build_base_fields (rli, empty_p, offsets, t)\n@@ -4018,7 +4018,7 @@ build_clone (fn, name)\n }\n \n /* Produce declarations for all appropriate clones of FN.  If\n-   UPDATE_METHOD_VEC_P is non-zero, the clones are added to the\n+   UPDATE_METHOD_VEC_P is nonzero, the clones are added to the\n    CLASTYPE_METHOD_VEC as well.  */\n \n void\n@@ -4934,7 +4934,7 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n     }\n \n   /* We make all structures have at least one element, so that they\n-     have non-zero size.  The class may be empty even if it has\n+     have nonzero size.  The class may be empty even if it has\n      basetypes.  Therefore, we add the fake field after all the other\n      fields; if there are already FIELD_DECLs on the list, their\n      offsets will not be disturbed.  */\n@@ -5400,7 +5400,7 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n     }\n }\n \n-/* Return non-zero if the dynamic type of INSTANCE is known, and\n+/* Return nonzero if the dynamic type of INSTANCE is known, and\n    equivalent to the static type.  We also handle the case where\n    INSTANCE is really a pointer. Return negative if this is a\n    ctor/dtor. There the dynamic type is known, but this might not be\n@@ -5746,7 +5746,7 @@ pop_lang_context ()\n /* Given an OVERLOAD and a TARGET_TYPE, return the function that\n    matches the TARGET_TYPE.  If there is no satisfactory match, return\n    error_mark_node, and issue an error message if COMPLAIN is\n-   non-zero.  Permit pointers to member function if PTRMEM is non-zero.\n+   nonzero.  Permit pointers to member function if PTRMEM is nonzero.\n    If TEMPLATE_ONLY, the name of the overloaded function\n    was a template-id, and EXPLICIT_TARGS are the explicitly provided\n    template arguments.  */\n@@ -6587,7 +6587,7 @@ get_primary_binfo (binfo)\n   return result;\n }\n \n-/* If INDENTED_P is zero, indent to INDENT. Return non-zero.  */\n+/* If INDENTED_P is zero, indent to INDENT. Return nonzero.  */\n \n static int\n maybe_indent_hierarchy (stream, indent, indented_p)"}, {"sha": "077dec4298d17c41545df6cf7e0dba7b262eda11", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -318,11 +318,11 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n #define same_type_ignoring_top_level_qualifiers_p(TYPE1, TYPE2) \\\n   same_type_p (TYPE_MAIN_VARIANT (TYPE1), TYPE_MAIN_VARIANT (TYPE2))\n \n-/* Non-zero if we are presently building a statement tree, rather\n+/* Nonzero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n #define building_stmt_tree() (last_tree != NULL_TREE)\n \n-/* Returns non-zero iff NODE is a declaration for the global function\n+/* Returns nonzero iff NODE is a declaration for the global function\n    `main'.  */\n #define DECL_MAIN_P(NODE)\t\t\t\t\\\n    (DECL_EXTERN_C_FUNCTION_P (NODE)                     \\\n@@ -901,13 +901,13 @@ struct language_function GTY(())\n #define current_function_returns_abnormally \\\n   cp_function_chain->returns_abnormally\n \n-/* Non-zero if we should generate RTL for functions that we process.\n+/* Nonzero if we should generate RTL for functions that we process.\n    When this is zero, we just accumulate tree structure, without\n    interacting with the back end.  */\n \n #define expanding_p cp_function_chain->x_expanding_p\n \n-/* Non-zero if we are in the semantic analysis phase for the current\n+/* Nonzero if we are in the semantic analysis phase for the current\n    function.  */\n \n #define doing_semantic_analysis_p() (!expanding_p)\n@@ -1789,7 +1789,7 @@ struct lang_decl GTY(())\n        && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)))\t\\\n    || (flag_syntax_only && TREE_USED (DECL)))\n \n-/* Non-zero iff DECL is memory-based.  The DECL_RTL of\n+/* Nonzero iff DECL is memory-based.  The DECL_RTL of\n    certain const variables might be a CONST_INT, or a REG\n    in some cases.  We cannot use `memory_operand' as a test\n    here because on most RISC machines, a variable's address\n@@ -1891,22 +1891,22 @@ struct lang_decl GTY(())\n /* Discriminator for name mangling.  */\n #define DECL_DISCRIMINATOR(NODE) (LANG_DECL_U2_CHECK (NODE, 1)->discriminator)\n \n-/* Non-zero if the VTT parm has been added to NODE.  */\n+/* Nonzero if the VTT parm has been added to NODE.  */\n #define DECL_HAS_VTT_PARM_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.has_vtt_parm_p)\n \n-/* Non-zero if NODE is a FUNCTION_DECL for which a VTT parameter is\n+/* Nonzero if NODE is a FUNCTION_DECL for which a VTT parameter is\n    required.  */\n #define DECL_NEEDS_VTT_PARM_P(NODE)\t\t\t\\\n   (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (NODE))\t\\\n    && (DECL_BASE_CONSTRUCTOR_P (NODE)\t\t\t\\\n        || DECL_BASE_DESTRUCTOR_P (NODE)))\n \n-/* Non-zero if NODE is a user-defined conversion operator.  */\n+/* Nonzero if NODE is a user-defined conversion operator.  */\n #define DECL_CONV_FN_P(NODE) \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)))\n \n-/* Non-zero if NODE, which is a TEMPLATE_DECL, is a template\n+/* Nonzero if NODE, which is a TEMPLATE_DECL, is a template\n    conversion operator to a type dependent on the innermost template\n    args.  */\n #define DECL_TEMPLATE_CONV_FN_P(NODE) \\\n@@ -1927,7 +1927,7 @@ struct lang_decl GTY(())\n   (IDENTIFIER_OPNAME_P (DECL_NAME (NODE))\t\t\\\n    ? DECL_LANG_SPECIFIC (NODE)->u.f.operator_code : ERROR_MARK)\n \n-/* Non-zero if NODE is an assignment operator.  */\n+/* Nonzero if NODE is an assignment operator.  */\n #define DECL_ASSIGNMENT_OPERATOR_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.assignment_operator_p)\n \n@@ -2107,7 +2107,7 @@ struct lang_decl GTY(())\n #define ORIGINAL_NAMESPACE(NODE)  \\\n   (DECL_NAMESPACE_ALIAS (NODE) ? DECL_NAMESPACE_ALIAS (NODE) : (NODE))\n \n-/* Non-zero if NODE is the std namespace.  */\n+/* Nonzero if NODE is the std namespace.  */\n #define DECL_NAMESPACE_STD_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == NAMESPACE_DECL\t\t\t\\\n    && CP_DECL_CONTEXT (NODE) == global_namespace\t\\\n@@ -2200,7 +2200,7 @@ struct lang_decl GTY(())\n    only one level of arguments, but which is a TREE_VEC containing as\n    its only entry the TREE_VEC for that level.  */\n \n-/* Non-zero if the template arguments is actually a vector of vectors,\n+/* Nonzero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */\n #define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \\\n   ((NODE) != NULL_TREE\t\t\t\t\t\t\\\n@@ -2383,7 +2383,7 @@ struct lang_decl GTY(())\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n-/* Returns non-zero if DECL has external linkage, as specified by the\n+/* Returns nonzero if DECL has external linkage, as specified by the\n    language standard.  (This predicate may hold even when the\n    corresponding entity is not actually given external linkage in the\n    object file; see decl_linkage for details.)  */\n@@ -2801,7 +2801,7 @@ enum ptrmemfunc_vbit_where_t\n #define DECL_PRIMARY_TEMPLATE(NODE) \\\n   (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)))\n \n-/* Returns non-zero if NODE is a primary template.  */\n+/* Returns nonzero if NODE is a primary template.  */\n #define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == (NODE))\n \n #define CLASSTYPE_TEMPLATE_LEVEL(NODE) \\\n@@ -2840,7 +2840,7 @@ enum ptrmemfunc_vbit_where_t\n #define SET_CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n   (CLASSTYPE_USE_TEMPLATE (NODE) = 3)\n \n-/* Non-zero if DECL is a friend function which is an instantiation\n+/* Nonzero if DECL is a friend function which is an instantiation\n    from the point of view of the compiler, but not from the point of\n    view of the language.  For example given:\n       template <class T> struct S { friend void f(T) {}; };\n@@ -2850,13 +2850,13 @@ enum ptrmemfunc_vbit_where_t\n #define DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION(DECL) \\\n   (DECL_TEMPLATE_INFO (DECL) && !DECL_USE_TEMPLATE (DECL))\n \n-/* Non-zero if TYPE is a partial instantiation of a template class,\n+/* Nonzero if TYPE is a partial instantiation of a template class,\n    i.e., an instantiation whose instantiation arguments involve\n    template types.  */\n #define PARTIAL_INSTANTIATION_P(TYPE) \\\n   (LANG_TYPE_CLASS_CHECK (TYPE)->is_partial_instantiation)\n \n-/* Non-zero iff we are currently processing a declaration for an\n+/* Nonzero iff we are currently processing a declaration for an\n    entity with its own template parameter list, and which is not a\n    full specialization.  */\n #define PROCESSING_REAL_TEMPLATE_DECL_P() \\\n@@ -3249,7 +3249,7 @@ extern GTY(()) varray_type local_classes;\n \t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] == '_')\n #endif /* !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL) */\n \n-/* Returns non-zero iff NODE is a declaration for the global function\n+/* Returns nonzero iff NODE is a declaration for the global function\n    `main'.  */\n #define DECL_MAIN_P(NODE)\t\t\t\t\\\n    (DECL_EXTERN_C_FUNCTION_P (NODE)                     \\"}, {"sha": "6905a049e45be9365a4564b147977f5085b9b6d8", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -1014,7 +1014,7 @@ convert_force (type, expr, convtype)\n    allowed (references private members, etc).\n    If no conversion exists, NULL_TREE is returned.\n \n-   If (FOR_SURE & 1) is non-zero, then we allow this type conversion\n+   If (FOR_SURE & 1) is nonzero, then we allow this type conversion\n    to take place immediately.  Otherwise, we build a SAVE_EXPR\n    which can be evaluated if the results are ever needed.\n "}, {"sha": "30f5512a710db73241e96f6a7158c045c3bb618f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -659,7 +659,7 @@ namespace_bindings_p ()\n   return b->namespace_p;\n }\n \n-/* If KEEP is non-zero, make a BLOCK node for the next binding level,\n+/* If KEEP is nonzero, make a BLOCK node for the next binding level,\n    unconditionally.  Otherwise, use the normal logic to decide whether\n    or not to create a BLOCK.  */\n \n@@ -688,7 +688,7 @@ declare_namespace_level ()\n   current_binding_level->namespace_p = 1;\n }\n \n-/* Returns non-zero if this scope was created to store template\n+/* Returns nonzero if this scope was created to store template\n    parameters.  */\n \n int\n@@ -1740,7 +1740,7 @@ clear_identifier_class_values ()\n     IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n }\n \n-/* Returns non-zero if T is a virtual function table.  */\n+/* Returns nonzero if T is a virtual function table.  */\n \n int\n vtable_decl_p (t, data)\n@@ -1750,7 +1750,7 @@ vtable_decl_p (t, data)\n   return (TREE_CODE (t) == VAR_DECL && DECL_VIRTUAL_P (t));\n }\n \n-/* Returns non-zero if T is a TYPE_DECL for a type with virtual\n+/* Returns nonzero if T is a TYPE_DECL for a type with virtual\n    functions.  */\n \n int\n@@ -1779,8 +1779,8 @@ struct walk_globals_data {\n };\n \n /* Walk the vtable declarations in NAMESPACE.  Whenever one is found\n-   for which P returns non-zero, call F with its address.  If any call\n-   to F returns a non-zero value, return a non-zero value.  */\n+   for which P returns nonzero, call F with its address.  If any call\n+   to F returns a nonzero value, return a nonzero value.  */\n \n static int\n walk_vtables_r (namespace, data)\n@@ -1800,8 +1800,8 @@ walk_vtables_r (namespace, data)\n }\n \n /* Walk the vtable declarations.  Whenever one is found for which P\n-   returns non-zero, call F with its address.  If any call to F\n-   returns a non-zero value, return a non-zero value.  */\n+   returns nonzero, call F with its address.  If any call to F\n+   returns a nonzero value, return a nonzero value.  */\n int\n walk_vtables (p, f, data)\n      walk_globals_pred p;\n@@ -1848,8 +1848,8 @@ walk_namespaces (f, data)\n }\n \n /* Walk the global declarations in NAMESPACE.  Whenever one is found\n-   for which P returns non-zero, call F with its address.  If any call\n-   to F returns a non-zero value, return a non-zero value.  */\n+   for which P returns nonzero, call F with its address.  If any call\n+   to F returns a nonzero value, return a nonzero value.  */\n \n static int\n walk_globals_r (namespace, data)\n@@ -1882,8 +1882,8 @@ walk_globals_r (namespace, data)\n }\n \n /* Walk the global declarations.  Whenever one is found for which P\n-   returns non-zero, call F with its address.  If any call to F\n-   returns a non-zero value, return a non-zero value.  */\n+   returns nonzero, call F with its address.  If any call to F\n+   returns a nonzero value, return a nonzero value.  */\n \n int\n walk_globals (p, f, data)\n@@ -2559,7 +2559,7 @@ pop_everything ()\n \n /* The type TYPE is being declared.  If it is a class template, or a\n    specialization of a class template, do any processing required and\n-   perform error-checking.  If IS_FRIEND is non-zero, this TYPE is\n+   perform error-checking.  If IS_FRIEND is nonzero, this TYPE is\n    being declared a friend.  B is the binding level at which this TYPE\n    should be bound.\n \n@@ -5292,7 +5292,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n      int thislevel_only;\n {\n   register struct cp_binding_level *level;\n-  /* Non-zero if, we should look past a template parameter level, even\n+  /* Nonzero if, we should look past a template parameter level, even\n      if THISLEVEL_ONLY.  */\n   int allow_template_parms_p = 1;\n \n@@ -5375,7 +5375,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t\t are in the pseudo-global level created for the\n \t\t template parameters, rather than the (surrounding)\n \t\t namespace level.  Thus, we keep going one more level,\n-\t\t even though THISLEVEL_ONLY is non-zero.  */\n+\t\t even though THISLEVEL_ONLY is nonzero.  */\n \t      allow_template_parms_p = 0;\n \t      continue;\n \t    }\n@@ -5399,7 +5399,7 @@ set_current_level_tags_transparency (tags_transparent)\n    Otherwise return 0.  However, the value can never be 0\n    in the cases in which this is used.\n \n-   C++: If NAME is non-zero, this is the new name to install.  This is\n+   C++: If NAME is nonzero, this is the new name to install.  This is\n    done when replacing anonymous tags with real tag names.  */\n \n static tree\n@@ -6022,7 +6022,7 @@ check_for_out_of_scope_variable (tree decl)\n    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n    Otherwise we prefer non-TYPE_DECLs.\n \n-   If NONCLASS is non-zero, we don't look for the NAME in class scope,\n+   If NONCLASS is nonzero, we don't look for the NAME in class scope,\n    using IDENTIFIER_CLASS_VALUE.  */\n \n static tree\n@@ -6425,7 +6425,7 @@ typedef struct predefined_identifier\n   const char *const name;\n   /* The place where the IDENTIFIER_NODE should be stored.  */\n   tree *const node;\n-  /* Non-zero if this is the name of a constructor or destructor.  */\n+  /* Nonzero if this is the name of a constructor or destructor.  */\n   const int ctor_or_dtor_p;\n } predefined_identifier;\n \n@@ -8394,7 +8394,7 @@ declare_global_var (name, type)\n }\n \n /* Returns a pointer to the `atexit' function.  Note that if\n-   FLAG_USE_CXA_ATEXIT is non-zero, then this will actually be the new\n+   FLAG_USE_CXA_ATEXIT is nonzero, then this will actually be the new\n    `__cxa_atexit' function specified in the IA64 C++ ABI.  */\n \n static tree\n@@ -11985,7 +11985,7 @@ require_complete_types_for_parms (parms)\n     }\n }\n \n-/* Returns non-zero if T is a local variable.  */\n+/* Returns nonzero if T is a local variable.  */\n \n int\n local_variable_p (t)\n@@ -12003,7 +12003,7 @@ local_variable_p (t)\n   return 0;\n }\n \n-/* Returns non-zero if T is an automatic local variable or a label.\n+/* Returns nonzero if T is an automatic local variable or a label.\n    (These are the declarations that need to be remapped when the code\n    containing them is duplicated.)  */\n \n@@ -12253,7 +12253,7 @@ grokparms (first_parm)\n       first parameter is a reference to non-const qualified T.\n \n    This function can be used as a predicate. Positive values indicate\n-   a copy constructor and non-zero values indicate a copy assignment\n+   a copy constructor and nonzero values indicate a copy assignment\n    operator.  */\n \n int\n@@ -12890,7 +12890,7 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \t  && template_class_depth (current_class_type)\n \t  && PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t{\n-\t  /* Since GLOBALIZE is non-zero, we are not looking at a\n+\t  /* Since GLOBALIZE is nonzero, we are not looking at a\n \t     definition of this tag.  Since, in addition, we are currently\n \t     processing a (member) template declaration of a template\n \t     class, we must be very careful; consider:"}, {"sha": "90a4d4a571bfafa073326004a96b9d50aef48506", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -50,10 +50,10 @@ extern cpp_reader *parse_in;\n /* This structure contains information about the initializations\n    and/or destructions required for a particular priority level.  */\n typedef struct priority_info_s {\n-  /* Non-zero if there have been any initializations at this priority\n+  /* Nonzero if there have been any initializations at this priority\n      throughout the translation unit.  */\n   int initializations_p;\n-  /* Non-zero if there have been any destructions at this priority\n+  /* Nonzero if there have been any destructions at this priority\n      throughout the translation unit.  */\n   int destructions_p;\n } *priority_info;\n@@ -536,7 +536,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n       return error_mark_node;\n     }\n \n-  /* Deleting ptr to void is undefined behaviour [expr.delete/3].  */\n+  /* Deleting ptr to void is undefined behavior [expr.delete/3].  */\n   if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n     {\n       warning (\"deleting `%T' is undefined\", type);\n@@ -1950,7 +1950,7 @@ import_export_decl (decl)\n }\n \n /* Here, we only decide whether or not the tinfo node should be\n-   emitted with the vtable.  IS_IN_LIBRARY is non-zero iff the\n+   emitted with the vtable.  IS_IN_LIBRARY is nonzero iff the\n    typeinfo for TYPE should be in the runtime library.  */\n \n void\n@@ -2226,7 +2226,7 @@ static splay_tree priority_info_map;\n    initialization and destruction of objects with static storage\n    duration.  The function generated takes two parameters of type\n    `int': __INITIALIZE_P and __PRIORITY.  If __INITIALIZE_P is\n-   non-zero, it performs initializations.  Otherwise, it performs\n+   nonzero, it performs initializations.  Otherwise, it performs\n    destructions.  It only performs those initializations or\n    destructions with the indicated __PRIORITY.  The generated function\n    returns no value.  \n@@ -2373,7 +2373,7 @@ get_priority_info (priority)\n }\n \n /* Set up to handle the initialization or destruction of DECL.  If\n-   INITP is non-zero, we are initializing the variable.  Otherwise, we\n+   INITP is nonzero, we are initializing the variable.  Otherwise, we\n    are destroying it.  */\n \n static tree\n@@ -3999,7 +3999,7 @@ pop_scope (t)\n }\n \n /* [basic.lookup.koenig] */\n-/* A non-zero return value in the functions below indicates an error.  */\n+/* A nonzero return value in the functions below indicates an error.  */\n \n struct arg_lookup\n {\n@@ -4742,7 +4742,7 @@ mark_used (decl)\n    nonterminals. AGGR is the class, union or struct tag. SCOPE is the\n    explicit scope used (NULL for no scope resolution). ID is the\n    name. DEFN_P is true, if this is a definition of the class and\n-   NEW_TYPE_P is set to non-zero, if we push into the scope containing\n+   NEW_TYPE_P is set to nonzero, if we push into the scope containing\n    the to be defined aggregate.\n    \n    Return a TYPE_DECL for the type declared by ID in SCOPE.  */"}, {"sha": "afe4bbd3967e4d6d0abb1f22a87f5d361539f74c", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -796,7 +796,7 @@ build_throw (exp)\n \n /* Make sure TYPE is complete, pointer to complete, reference to\n    complete, or pointer to cv void. Issue diagnostic on failure.\n-   Return the zero on failure and non-zero on success. FROM can be\n+   Return the zero on failure and nonzero on success. FROM can be\n    the expr or decl from whence TYPE came, if available.  */\n \n static int"}, {"sha": "b71baa572827de8452fcae98e14075be7b99efbd", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -30,7 +30,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Friend data structures are described in cp-tree.h.  */\n \n-/* Returns non-zero if SUPPLICANT is a friend of TYPE.  */\n+/* Returns nonzero if SUPPLICANT is a friend of TYPE.  */\n \n int\n is_friend (type, supplicant)"}, {"sha": "6e5de08e0312ff74ae9fa043b9c5acb4551a3718", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -51,10 +51,10 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n {\n   int i, j;\n \n-  /* If non-zero, the user gave us the `-p' or `-pg' flag.  */ \n+  /* If nonzero, the user gave us the `-p' or `-pg' flag.  */\n   int saw_profile_flag = 0;\n \n-  /* If non-zero, the user gave us the `-v' flag.  */ \n+  /* If nonzero, the user gave us the `-v' flag.  */\n   int saw_verbose_flag = 0;\n \n   /* This will be 0 if we encounter a situation where we should not\n@@ -73,7 +73,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   /* The new argument list will be contained in this.  */\n   const char **arglist;\n \n-  /* Non-zero if we saw a `-xfoo' language specification on the\n+  /* Nonzero if we saw a `-xfoo' language specification on the\n      command line.  Used to avoid adding our own -xc++ if the user\n      already gave a language for the file.  */\n   int saw_speclang = 0;"}, {"sha": "c2110d1c80061f9d61b82db6945c64f0a9c10635", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -840,7 +840,7 @@ expand_virtual_init (binfo, decl)\n /* If an exception is thrown in a constructor, those base classes already\n    constructed must be destroyed.  This function creates the cleanup\n    for BINFO, which has just been constructed.  If FLAG is non-NULL,\n-   it is a DECL which is non-zero when this base needs to be\n+   it is a DECL which is nonzero when this base needs to be\n    destroyed.  */\n \n static void\n@@ -886,7 +886,7 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n \n /* Construct the virtual base-classes of THIS_REF (whose address is\n    THIS_PTR).  The object has the indicated TYPE.  The construction\n-   actually takes place only if FLAG is non-zero.  INIT_LIST is list\n+   actually takes place only if FLAG is nonzero.  INIT_LIST is list\n    of initializations for constructors to perform.  */\n \n static void"}, {"sha": "2342c2320c7a4d780ab7aa48d5044aa6cf573e87", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -540,7 +540,7 @@ const short rid_to_yy[RID_MAX] =\n   /* RID_REINTCAST */\tREINTERPRET_CAST,\n   /* RID_STATCAST */\tSTATIC_CAST,\n \n-  /* Objective C */\n+  /* Objective-C */\n   /* RID_ID */\t\t\t0,\n   /* RID_AT_ENCODE */\t\t0,\n   /* RID_AT_END */\t\t0,"}, {"sha": "c7bd31299dbca0b5f29577498136f2870bd327df", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -75,7 +75,7 @@\n # define MANGLE_TRACE_TREE(FN, NODE)\n #endif\n \n-/* Non-zero if NODE is a class template-id.  We can't rely on\n+/* Nonzero if NODE is a class template-id.  We can't rely on\n    CLASSTYPE_USE_TEMPLATE here because of tricky bugs in the parser\n    that hard to distinguish A<T> from A, where A<T> is the type as\n    instantiated outside of the template, and A is the type used\n@@ -214,7 +214,7 @@ static void write_java_integer_type_codes PARAMS ((tree));\n #define write_string(STRING)                                          \\\n   obstack_grow (&G.name_obstack, (STRING), strlen (STRING))\n \n-/* Non-zero if NODE1 and NODE2 are both TREE_LIST nodes and have the\n+/* Nonzero if NODE1 and NODE2 are both TREE_LIST nodes and have the\n    same purpose (context, which may be a type) and value (template\n    decl).  See write_template_prefix for more information on what this\n    is used for.  */\n@@ -230,7 +230,7 @@ static void write_java_integer_type_codes PARAMS ((tree));\n #define write_unsigned_number(NUMBER) \\\n   write_number ((NUMBER), /*unsigned_p=*/1, 10)\n \n-/* If DECL is a template instance, return non-zero and, if\n+/* If DECL is a template instance, return nonzero and, if\n    TEMPLATE_INFO is non-NULL, set *TEMPLATE_INFO to its template info.\n    Otherwise return zero.  */\n \n@@ -370,7 +370,7 @@ add_substitution (node)\n     dump_substitution_candidates ();\n }\n \n-/* Helper function for find_substitution.  Returns non-zero if NODE,\n+/* Helper function for find_substitution.  Returns nonzero if NODE,\n    which may be a decl or a CLASS_TYPE, is a template-id with template\n    name of substitution_index[INDEX] in the ::std namespace.  */\n \n@@ -403,7 +403,7 @@ is_std_substitution (node, index)\n \t      == subst_identifiers[index]));\n }\n \n-/* Helper function for find_substitution.  Returns non-zero if NODE,\n+/* Helper function for find_substitution.  Returns nonzero if NODE,\n    which may be a decl or a CLASS_TYPE, is the template-id\n    ::std::identifier<char>, where identifier is\n    substitution_index[INDEX].  */\n@@ -463,7 +463,7 @@ is_std_substitution_char (node, index)\n    candidates for entities appearing earlier in the same mangling\n \n    If a substitution is found, write its mangled representation and\n-   return non-zero.  If none is found, just return zero.  */\n+   return nonzero.  If none is found, just return zero.  */\n \n static int\n find_substitution (node)\n@@ -665,7 +665,7 @@ write_encoding (decl)\n \t  ::= <nested-name>\n \t  ::= <local-name>  \n \n-   If IGNORE_LOCAL_SCOPE is non-zero, this production of <name> is\n+   If IGNORE_LOCAL_SCOPE is nonzero, this production of <name> is\n    called from <local-name>, which mangles the enclosing scope\n    elsewhere and then uses this function to mangle just the part\n    underneath the function scope.  So don't use the <local-name>\n@@ -1341,7 +1341,7 @@ static void\n write_type (type)\n      tree type;\n {\n-  /* This gets set to non-zero if TYPE turns out to be a (possibly\n+  /* This gets set to nonzero if TYPE turns out to be a (possibly\n      CV-qualified) builtin type.  */\n   int is_builtin_type = 0;\n \n@@ -1645,7 +1645,7 @@ write_function_type (type)\n }\n \n /* Non-terminal <bare-function-type>.  TYPE is a FUNCTION_TYPE or\n-   METHOD_TYPE.  If INCLUDE_RETURN_TYPE is non-zero, the return value\n+   METHOD_TYPE.  If INCLUDE_RETURN_TYPE is nonzero, the return value\n    is mangled before the parameter types.  If non-NULL, DECL is\n    FUNCTION_DECL for the function whose type is being emitted.\n \n@@ -1670,7 +1670,7 @@ write_bare_function_type (type, include_return_type_p, decl)\n }\n \n /* Write the mangled representation of a method parameter list of\n-   types given in PARM_TYPES.  If METHOD_P is non-zero, the function is \n+   types given in PARM_TYPES.  If METHOD_P is nonzero, the function is\n    considered a non-static method, and the this parameter is omitted.\n    If non-NULL, DECL is the FUNCTION_DECL for the function whose\n    parameters are being emitted.  */"}, {"sha": "0689a7d440744daa701640deb41c54667aa7f99b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -350,7 +350,7 @@ make_thunk (function, delta, vcall_index)\n }\n \n /* Emit the definition of a C++ multiple inheritance vtable thunk.  If\n-   EMIT_P is non-zero, the thunk is emitted immediately.  */\n+   EMIT_P is nonzero, the thunk is emitted immediately.  */\n \n void\n use_thunk (thunk_fndecl, emit_p)"}, {"sha": "b3e20d66239ea15e5a1204a91380b729e94b3a6c", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -54,7 +54,7 @@ Boston, MA 02111-1307, USA.  */\n \n    ASSN_P\n \n-     A boolean value.  If non-zero, this is an assignment operator.  \n+     A boolean value.  If nonzero, this is an assignment operator.\n \n    Before including this file, you should define DEFOPERATOR\n    to take these arguments.  "}, {"sha": "0910bef6e125ce68113e63c104707489862a0938", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -93,9 +93,9 @@ calls_setjmp_r (tp, walk_subtrees, data)\n   return setjmp_call_p (*tp) ? *tp : NULL_TREE;\n }\n \n-/* Returns non-zero if FN calls `setjmp' or some other function that\n+/* Returns nonzero if FN calls `setjmp' or some other function that\n    can return more than once.  This function is conservative; it may\n-   occasionally return a non-zero value even when FN does not actually\n+   occasionally return a nonzero value even when FN does not actually\n    call `setjmp'.  */\n \n int\n@@ -133,7 +133,7 @@ update_cloned_parm (parm, cloned_parm)\n }\n \n /* FN is a function that has a complete body.  Clone the body as\n-   necessary.  Returns non-zero if there's no longer any need to\n+   necessary.  Returns nonzero if there's no longer any need to\n    process the main body.  */\n \n int"}, {"sha": "c5585d98929dcd683f10ec5517ead0f6f05d57aa", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -402,7 +402,7 @@ maybe_end_member_template_processing ()\n     }\n }\n \n-/* Returns non-zero iff T is a member template function.  We must be\n+/* Returns nonzero iff T is a member template function.  We must be\n    careful as in\n \n      template <class T> class C { void f(); }\n@@ -439,7 +439,7 @@ is_member_template (t)\n }\n \n #if 0 /* UNUSED */\n-/* Returns non-zero iff T is a member template class.  See\n+/* Returns nonzero iff T is a member template class.  See\n    is_member_template for a description of what precisely constitutes\n    a member template.  */\n \n@@ -647,7 +647,7 @@ reset_specialization ()\n   template_header_count = 0;\n }\n \n-/* We've just seen a template header.  If SPECIALIZATION is non-zero,\n+/* We've just seen a template header.  If SPECIALIZATION is nonzero,\n    it was of the form template <>.  */\n \n static void \n@@ -744,7 +744,7 @@ retrieve_local_specialization (tmpl)\n   return (tree) htab_find (local_specializations, tmpl);\n }\n \n-/* Returns non-zero iff DECL is a specialization of TMPL.  */\n+/* Returns nonzero iff DECL is a specialization of TMPL.  */\n \n int\n is_specialization_of (decl, tmpl)\n@@ -947,7 +947,7 @@ print_candidates (fns)\n    NULL_TREE if none is available.  In that case, the functions in\n    TEMPLATE_ID are non-members.\n \n-   If NEED_MEMBER_TEMPLATE is non-zero the function is known to be a\n+   If NEED_MEMBER_TEMPLATE is nonzero the function is known to be a\n    specialization of a member template.\n \n    The template args (those explicitly specified and those deduced)\n@@ -2132,12 +2132,12 @@ struct template_parm_data\n   int current_arg;\n \n   /* An array whose size is the number of template parameters.  The\n-     elements are non-zero if the parameter has been used in any one\n+     elements are nonzero if the parameter has been used in any one\n      of the arguments processed so far.  */\n   int* parms;\n \n   /* An array whose size is the number of template arguments.  The\n-     elements are non-zero if the argument makes use of template\n+     elements are nonzero if the argument makes use of template\n      parameters of this level.  */\n   int* arg_uses_template_parms;\n };\n@@ -2355,8 +2355,8 @@ process_partial_specialization (decl)\n \n /* Check that a template declaration's use of default arguments is not\n    invalid.  Here, PARMS are the template parameters.  IS_PRIMARY is\n-   non-zero if DECL is the thing declared by a primary template.\n-   IS_PARTIAL is non-zero if DECL is a partial specialization.  */\n+   nonzero if DECL is the thing declared by a primary template.\n+   IS_PARTIAL is nonzero if DECL is a partial specialization.  */\n \n static void\n check_default_tmpl_args (decl, parms, is_primary, is_partial)\n@@ -2503,7 +2503,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n /* Worker for push_template_decl_real, called via\n    for_each_template_parm.  DATA is really an int, indicating the\n    level of the parameters we are interested in.  If T is a template\n-   parameter of that level, return non-zero.  */\n+   parameter of that level, return nonzero.  */\n \n static int\n template_parm_this_level_p (t, data)\n@@ -2525,7 +2525,7 @@ template_parm_this_level_p (t, data)\n    previously existing one, if appropriate.  Returns the DECL, or an\n    equivalent one, if it is replaced via a call to duplicate_decls.  \n \n-   If IS_FRIEND is non-zero, DECL is a friend declaration.  */\n+   If IS_FRIEND is nonzero, DECL is a friend declaration.  */\n \n tree\n push_template_decl_real (decl, is_friend)\n@@ -3512,7 +3512,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n    messages are issued even if COMPLAIN is zero; for instance, if a\n    template argument is composed from a local class.\n \n-   If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n+   If REQUIRE_ALL_ARGUMENTS is nonzero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n    deduction for any unspecified trailing arguments.  */\n@@ -3885,7 +3885,7 @@ maybe_get_template_decl_from_type_decl (decl)\n    IN_DECL, if non-NULL, is the template declaration we are trying to\n    instantiate.  \n \n-   If ENTERING_SCOPE is non-zero, we are about to enter the scope of\n+   If ENTERING_SCOPE is nonzero, we are about to enter the scope of\n    the class we are looking up.\n    \n    Issue error and warning messages under control of COMPLAIN.\n@@ -4480,9 +4480,9 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n /* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, \n    BOUND_TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX in T, \n    call FN with the parameter and the DATA.\n-   If FN returns non-zero, the iteration is terminated, and\n+   If FN returns nonzero, the iteration is terminated, and\n    for_each_template_parm returns 1.  Otherwise, the iteration\n-   continues.  If FN never returns a non-zero value, the value\n+   continues.  If FN never returns a nonzero value, the value\n    returned by for_each_template_parm is 0.  If FN is NULL, it is\n    considered to be the function which always returns 1.  */\n \n@@ -5546,7 +5546,7 @@ tsubst_template_parms (parms, args, complain)\n /* Substitute the ARGS into the indicated aggregate (or enumeration)\n    type T.  If T is not an aggregate or enumeration type, it is\n    handled as if by tsubst.  IN_DECL is as for tsubst.  If\n-   ENTERING_SCOPE is non-zero, T is the context for a template which\n+   ENTERING_SCOPE is nonzero, T is the context for a template which\n    we are presently tsubst'ing.  Return the substituted value.  */\n \n static tree\n@@ -8553,7 +8553,7 @@ template_decl_level (decl)\n \n /* Decide whether ARG can be unified with PARM, considering only the\n    cv-qualifiers of each type, given STRICT as documented for unify.\n-   Returns non-zero iff the unification is OK on that basis.*/\n+   Returns nonzero iff the unification is OK on that basis.*/\n \n static int\n check_cv_quals_for_unify (strict, arg, parm)\n@@ -9653,7 +9653,7 @@ mark_class_instantiated (t, extern_p)\n \n /* Perform an explicit instantiation of template class T.  STORAGE, if\n    non-null, is the RID for extern, inline or static.  COMPLAIN is\n-   non-zero if this is called from the parser, zero if called recursively,\n+   nonzero if this is called from the parser, zero if called recursively,\n    since the standard is unclear (as detailed below).  */\n  \n void\n@@ -9897,7 +9897,7 @@ regenerate_decl_from_template (decl, tmpl)\n }\n \n /* Produce the definition of D, a _DECL generated from a template.  If\n-   DEFER_OK is non-zero, then we don't have to actually do the\n+   DEFER_OK is nonzero, then we don't have to actually do the\n    instantiation now; we just have to do it sometime.  */\n \n tree\n@@ -10458,7 +10458,7 @@ current_instantiation ()\n }\n \n /* [temp.param] Check that template non-type parm TYPE is of an allowable\n-   type. Return zero for ok, non-zero for disallowed. Issue error and\n+   type. Return zero for ok, nonzero for disallowed. Issue error and\n    warning messages under control of COMPLAIN.  */\n \n static int"}, {"sha": "6d6e8189862533a20b126787854c8a6194ee1003", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -697,7 +697,7 @@ qualifier_flags (type)\n   return flags;\n }\n \n-/* Return non-zero, if the pointer chain TYPE ends at an incomplete type, or\n+/* Return nonzero, if the pointer chain TYPE ends at an incomplete type, or\n    contains a pointer to member of an incomplete class.  */\n \n static int\n@@ -977,7 +977,7 @@ class_initializer (desc, target, trail)\n   return init;  \n }\n \n-/* Returns non-zero if the typeinfo for type should be placed in \n+/* Returns nonzero if the typeinfo for type should be placed in\n    the runtime library.  */\n \n static int\n@@ -1006,7 +1006,7 @@ typeinfo_in_lib_p (type)\n }\n \n /* Generate the initializer for the type info describing\n-   TYPE. VAR_DESC is a . NON_PUBLIC_P is set non-zero, if the VAR_DECL\n+   TYPE. VAR_DESC is a . NON_PUBLIC_P is set nonzero, if the VAR_DECL\n    should not be exported from this object file.  This should only be\n    called at the end of translation, when we know that no further\n    types will be completed.  */\n@@ -1407,7 +1407,7 @@ emit_support_tinfos ()\n     }\n }\n \n-/* Return non-zero, iff T is a type_info variable which has not had a\n+/* Return nonzero, iff T is a type_info variable which has not had a\n    definition emitted for it.  */\n \n int"}, {"sha": "ae3b1023dad94b6884528d79cf268e749aa324a2", "filename": "gcc/cp/search.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -577,7 +577,7 @@ current_scope ()\n   return current_class_type;\n }\n \n-/* Returns non-zero if we are currently in a function scope.  Note\n+/* Returns nonzero if we are currently in a function scope.  Note\n    that this function returns zero if we are within a local class, but\n    not within a member function body of the local class.  */\n \n@@ -862,7 +862,7 @@ dfs_accessible_p (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Returns non-zero if it is OK to access DECL through an object\n+/* Returns nonzero if it is OK to access DECL through an object\n    indiated by BINFO in the context of DERIVED.  */\n \n static int\n@@ -925,7 +925,7 @@ protected_accessible_p (decl, derived, binfo)\n   return 1;\n }\n \n-/* Returns non-zero if SCOPE is a friend of a type which would be able\n+/* Returns nonzero if SCOPE is a friend of a type which would be able\n    to access DECL through the object indicated by BINFO.  */\n \n static int\n@@ -1014,7 +1014,7 @@ type_access_control (type, val)\n }\n \n /* DECL is a declaration from a base class of TYPE, which was the\n-   class used to name DECL.  Return non-zero if, in the current\n+   class used to name DECL.  Return nonzero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,\n    then we can tell in what context the access is occurring by looking\n    at the most derived class along the path indicated by BINFO.  */\n@@ -1028,7 +1028,7 @@ accessible_p (type, decl)\n   tree binfo;\n   tree t;\n \n-  /* Non-zero if it's OK to access DECL if it has protected\n+  /* Nonzero if it's OK to access DECL if it has protected\n      accessibility in TYPE.  */\n   int protected_ok = 0;\n \n@@ -1146,15 +1146,15 @@ struct lookup_field_info {\n   /* If non-NULL, the lookup was ambiguous, and this is a list of the\n      candidates.  */\n   tree ambiguous;\n-  /* If non-zero, we are looking for types, not data members.  */\n+  /* If nonzero, we are looking for types, not data members.  */\n   int want_type;\n-  /* If non-zero, RVAL was found by looking through a dependent base.  */\n+  /* If nonzero, RVAL was found by looking through a dependent base.  */\n   int from_dep_base_p;\n   /* If something went wrong, a message indicating what.  */\n   const char *errstr;\n };\n \n-/* Returns non-zero if BINFO is not hidden by the value found by the\n+/* Returns nonzero if BINFO is not hidden by the value found by the\n    lookup so far.  If BINFO is hidden, then there's no need to look in\n    it.  DATA is really a struct lookup_field_info.  Called from\n    lookup_field via breadth_first_search.  */\n@@ -1185,7 +1185,7 @@ lookup_field_queue_p (binfo, data)\n    \n      template <typename T> struct S { S* sp; }\n \n-   Returns non-zero if DECL is such a declaration in a class TYPE.  */\n+   Returns nonzero if DECL is such a declaration in a class TYPE.  */\n \n static int\n template_self_reference_p (type, decl)\n@@ -1692,7 +1692,7 @@ adjust_result_of_qualified_name_lookup (tree decl,\n    returned and the walk is terminated.  At each node, FN is passed a\n    BINFO indicating the path from the curently visited base-class to\n    TYPE.  Before each base-class is walked QFN is called.  If the\n-   value returned is non-zero, the base-class is walked; otherwise it\n+   value returned is nonzero, the base-class is walked; otherwise it\n    is not.  If QFN is NULL, it is treated as a function which always\n    returns 1.  Both FN and QFN are passed the DATA whenever they are\n    called.  */\n@@ -1929,7 +1929,7 @@ check_final_overrider (overrider, basefn)\n    virtual functions in TYPE's hierarchy which FNDECL overrides.\n    We do not look in TYPE itself, only its bases.\n    \n-   Returns non-zero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we\n+   Returns nonzero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we\n    find that it overrides anything.\n    \n    We check that every function which is overridden, is correctly"}, {"sha": "7edfa98fd6f1562d24934df31a63f3f80f1cef04", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -79,7 +79,7 @@ static tree clear_decl_rtl PARAMS ((tree *, int *, void *));\n       (SUBSTMT) = (COND);\t\t\t\t\\\n   } while (0)\n \n-/* Returns non-zero if the current statement is a full expression,\n+/* Returns nonzero if the current statement is a full expression,\n    i.e. temporaries created during that statement should be destroyed\n    at the end of the statement.  */\n \n@@ -801,7 +801,7 @@ finish_handler (handler)\n   RECHAIN_STMTS (handler, HANDLER_BODY (handler));\n }\n \n-/* Begin a compound-statement.  If HAS_NO_SCOPE is non-zero, the\n+/* Begin a compound-statement.  If HAS_NO_SCOPE is nonzero, the\n    compound-statement does not define a scope.  Returns a new\n    COMPOUND_STMT if appropriate.  */\n \n@@ -840,7 +840,7 @@ begin_compound_stmt (has_no_scope)\n }\n \n /* Finish a compound-statement, which may be given by COMPOUND_STMT.\n-   If HAS_NO_SCOPE is non-zero, the compound statement does not define\n+   If HAS_NO_SCOPE is nonzero, the compound statement does not define\n    a scope.  */\n \n tree\n@@ -1572,7 +1572,7 @@ reset_type_access_control ()\n }\n \n /* Begin a function definition declared with DECL_SPECS, ATTRIBUTES,\n-   and DECLARATOR.  Returns non-zero if the function-declaration is\n+   and DECLARATOR.  Returns nonzero if the function-declaration is\n    valid.  */\n \n int\n@@ -1696,7 +1696,7 @@ check_template_template_default_arg (tree argument)\n }\n \n /* Finish a parameter list, indicated by PARMS.  If ELLIPSIS is\n-   non-zero, the parameter list was terminated by a `...'.  */\n+   nonzero, the parameter list was terminated by a `...'.  */\n \n tree\n finish_parmlist (parms, ellipsis)\n@@ -2022,7 +2022,7 @@ finish_template_decl (parms)\n \n /* Finish processing a template-id (which names a type) of the form\n    NAME < ARGS >.  Return the TYPE_DECL for the type named by the\n-   template-id.  If ENTERING_SCOPE is non-zero we are about to enter\n+   template-id.  If ENTERING_SCOPE is nonzero we are about to enter\n    the scope of template-id indicated.  */\n \n tree"}, {"sha": "8633bb8c4c5d11dd9ac41cf20c8d735eece1e769", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -832,7 +832,7 @@ yylex ()\n }\n \n /* Unget character CH from the input stream.\n-   If RESCAN is non-zero, then we want to `see' this\n+   If RESCAN is nonzero, then we want to `see' this\n    character as the next input token.  */\n \n void"}, {"sha": "ea2e0e1ede06f1d47cfa6edc3e4c3e33c02621c0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -57,7 +57,7 @@ static tree handle_init_priority_attribute PARAMS ((tree *, tree, tree, int, boo\n \n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n-   non-zero, rvalues of class type are considered lvalues.  */\n+   nonzero, rvalues of class type are considered lvalues.  */\n \n static cp_lvalue_kind\n lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n@@ -1092,7 +1092,7 @@ is_aggr_type_2 (t1, t2)\n   return IS_AGGR_TYPE (t1) && IS_AGGR_TYPE (t2);\n }\n \n-/* Returns non-zero if CODE is the code for a statement.  */\n+/* Returns nonzero if CODE is the code for a statement.  */\n \n int\n cp_statement_code_p (code)\n@@ -2362,7 +2362,7 @@ cp_copy_res_decl_for_inlining (result, fn, caller, decl_map_,\n   return var;\n }\n \n-/* Record that we're about to start inlining FN, and return non-zero if\n+/* Record that we're about to start inlining FN, and return nonzero if\n    that's OK.  Used for lang_hooks.tree_inlining.start_inlining.  */\n \n int\n@@ -2549,7 +2549,7 @@ name_p (tree node)\n \t  || TREE_CODE (node) == SCOPE_REF);\n }\n \n-/* Returns non-zero if TYPE is a character type, including wchar_t.  */\n+/* Returns nonzero if TYPE is a character type, including wchar_t.  */\n \n int\n char_type_p (type)"}, {"sha": "d32d81cceb86056f6dd7d3c3aa097f15fae6afbb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838dfd8a4ef2572d4831643b01d70f78ba6e7747/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=838dfd8a4ef2572d4831643b01d70f78ba6e7747", "patch": "@@ -5580,7 +5580,7 @@ build_ptrmemfunc1 (type, delta, pfn)\n    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we\n    want to be.\n \n-   If FORCE is non-zero, then force this conversion, even if\n+   If FORCE is nonzero, then force this conversion, even if\n    we would rather not do it.  Usually set when using an explicit\n    cast.\n \n@@ -5895,7 +5895,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n }\n \n /* Convert RHS to be of type TYPE.\n-   If EXP is non-zero, it is the target of the initialization.\n+   If EXP is nonzero, it is the target of the initialization.\n    ERRTYPE is a string to use in error messages.\n \n    Two major differences between the behavior of\n@@ -6298,9 +6298,9 @@ check_return_expr (retval)\n }\n \n \f\n-/* Returns non-zero if the pointer-type FROM can be converted to the\n+/* Returns nonzero if the pointer-type FROM can be converted to the\n    pointer-type TO via a qualification conversion.  If CONSTP is -1,\n-   then we return non-zero if the pointers are similar, and the\n+   then we return nonzero if the pointers are similar, and the\n    cv-qualification signature of FROM is a proper subset of that of TO.\n \n    If CONSTP is positive, then all outer pointers have been\n@@ -6464,7 +6464,7 @@ cp_type_quals (type)\n   return TYPE_QUALS (type);\n }\n \n-/* Returns non-zero if the TYPE contains a mutable member */\n+/* Returns nonzero if the TYPE contains a mutable member */\n \n int\n cp_has_mutable_p (type)\n@@ -6537,7 +6537,7 @@ casts_away_constness_r (t1, t2)\n   *t2 = cp_build_qualified_type (*t2, quals2);\n }\n \n-/* Returns non-zero if casting from TYPE1 to TYPE2 casts away\n+/* Returns nonzero if casting from TYPE1 to TYPE2 casts away\n    constness.  */\n \n static int"}]}