{"sha": "dc419b9f8d6f998186706aa1afa50db1ca7efae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM0MTliOWY4ZDZmOTk4MTg2NzA2YWExYWZhNTBkYjFjYTdlZmFlNQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-03-02T19:58:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-10T13:34:57Z"}, "message": "[Ada] Ada_2020 AI12-0220: Pre/Postconditions on Access_To_Subprogram types\n\n2020-06-10  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* einfo.ads (Access_Subprogram_Wrapper): New attribute of\n\tSubprogram_Type entities. Denotes subprogram constructed for\n\tAccess_To_Subprogram types that include pre- and postconditions.\n\t* einfo.adb: Subprogram bodies for Access_Subprogram_Wrapper.\n\t* exp_ch6.adb (Expand_Call): An indirect call through an\n\tAccess_To_subprogram that includes contracts is rewritten as a\n\tcall to the corresponding Access_ ubprogram_Wrapper. Handle\n\tderived types that inherit contract from parent.\n\t* sem_prag.adb (Build_Access_Subprogram_Wrapper): Build\n\tsubprogram declaration for subprogram that incorporates the\n\tcontracts of an Access_To_Subprogram type declaration. Build\n\tcorresponding body and attach it to freeze actions for type.\n\t* sem_util.ads, sem_util.adb (Is_Access_Subprogram_Wrapper):\n\tUtility that uses signature of the subprogram to determine\n\twhether it is a generated wrapper for an Access_To_Subprogram\n\ttype.", "tree": {"sha": "6e0f24e81862e5d24801e93afc8ce6b9d5203958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e0f24e81862e5d24801e93afc8ce6b9d5203958"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc419b9f8d6f998186706aa1afa50db1ca7efae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc419b9f8d6f998186706aa1afa50db1ca7efae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc419b9f8d6f998186706aa1afa50db1ca7efae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc419b9f8d6f998186706aa1afa50db1ca7efae5/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "057548bc5f3a067f881cd6985419956b0f2696fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/057548bc5f3a067f881cd6985419956b0f2696fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/057548bc5f3a067f881cd6985419956b0f2696fc"}], "stats": {"total": 312, "additions": 309, "deletions": 3}, "files": [{"sha": "ee1aecb9cd8ada4279a8f0e1efd1bbdd753ede7d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=dc419b9f8d6f998186706aa1afa50db1ca7efae5", "patch": "@@ -282,6 +282,7 @@ package body Einfo is\n \n    --    SPARK_Pragma                    Node40\n \n+   --    Access_Subprogram_Wrapper       Node41\n    --    Original_Protected_Subprogram   Node41\n    --    SPARK_Aux_Pragma                Node41\n \n@@ -738,6 +739,12 @@ package body Einfo is\n       return Node30 (Implementation_Base_Type (Id));\n    end Access_Disp_Table_Elab_Flag;\n \n+   function Access_Subprogram_Wrapper (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Subprogram_Type);\n+      return Node41 (Id);\n+   end Access_Subprogram_Wrapper;\n+\n    function Activation_Record_Component (Id : E) return E is\n    begin\n       pragma Assert (Ekind_In (Id, E_Constant,\n@@ -3902,6 +3909,12 @@ package body Einfo is\n       Set_Node30 (Id, V);\n    end Set_Access_Disp_Table_Elab_Flag;\n \n+   procedure Set_Access_Subprogram_Wrapper (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Subprogram_Type);\n+      Set_Node41 (Id, V);\n+   end Set_Access_Subprogram_Wrapper;\n+\n    procedure Set_Anonymous_Designated_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n@@ -11411,6 +11424,9 @@ package body Einfo is\n          =>\n             Write_Str (\"SPARK_Aux_Pragma\");\n \n+         when E_Subprogram_Type =>\n+            Write_Str (\"Access_Subprogram_Wrapper\");\n+\n          when others =>\n             Write_Str (\"Field41??\");\n       end case;"}, {"sha": "e28fcd0e66380791274ec1d6bfd1e354ec0e963e", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=dc419b9f8d6f998186706aa1afa50db1ca7efae5", "patch": "@@ -372,6 +372,15 @@ package Einfo is\n --       on attribute 'Position applied to an object of the type; it is used by\n --       the IP routine to avoid performing this elaboration twice.\n \n+--    Access_Subprogram_Wrapper (Node41)\n+--       Entity created for access_to_subprogram types that have pre/post\n+--       conditions. Wrapper subprogram is created when analyzing corresponding\n+--       aspect, and inherits said aspects. Body of subprogram includes code\n+--       to check contracts, and a direct call to the designated subprogram.\n+--       The body is part of the freeze actions for the type.\n+--       The Subprogram_Type created for the Access_To_Subprogram carries the\n+--       Access_Subprogram_Wrapper for use in the expansion of indirect calls.\n+\n --    Activation_Record_Component (Node31)\n --       Defined for E_Variable, E_Constant, E_Loop_Parameter, and formal\n --       parameter entities. Used in Opt.Unnest_Subprogram_Mode, in which case\n@@ -6721,6 +6730,7 @@ package Einfo is\n    --    Extra_Accessibility_Of_Result       (Node19)\n    --    Directly_Designated_Type            (Node20)\n    --    Extra_Formals                       (Node28)\n+   --    Access_Subprogram_Wrapper           (Node41)\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n    --    Last_Formal                         (synth)\n@@ -7068,6 +7078,7 @@ package Einfo is\n    function Accept_Address                      (Id : E) return L;\n    function Access_Disp_Table                   (Id : E) return L;\n    function Access_Disp_Table_Elab_Flag         (Id : E) return E;\n+   function Access_Subprogram_Wrapper           (Id : E) return E;\n    function Activation_Record_Component         (Id : E) return E;\n    function Actual_Subtype                      (Id : E) return E;\n    function Address_Taken                       (Id : E) return B;\n@@ -7775,6 +7786,7 @@ package Einfo is\n    procedure Set_Accept_Address                  (Id : E; V : L);\n    procedure Set_Access_Disp_Table               (Id : E; V : L);\n    procedure Set_Access_Disp_Table_Elab_Flag     (Id : E; V : E);\n+   procedure Set_Access_Subprogram_Wrapper       (Id : E; V : E);\n    procedure Set_Activation_Record_Component     (Id : E; V : E);\n    procedure Set_Actual_Subtype                  (Id : E; V : E);\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n@@ -8606,6 +8618,7 @@ package Einfo is\n    pragma Inline (Accept_Address);\n    pragma Inline (Access_Disp_Table);\n    pragma Inline (Access_Disp_Table_Elab_Flag);\n+   pragma Inline (Access_Subprogram_Wrapper);\n    pragma Inline (Activation_Record_Component);\n    pragma Inline (Actual_Subtype);\n    pragma Inline (Address_Taken);\n@@ -9222,6 +9235,7 @@ package Einfo is\n    pragma Inline (Set_Accept_Address);\n    pragma Inline (Set_Access_Disp_Table);\n    pragma Inline (Set_Access_Disp_Table_Elab_Flag);\n+   pragma Inline (Set_Access_Subprogram_Wrapper);\n    pragma Inline (Set_Activation_Record_Component);\n    pragma Inline (Set_Actual_Subtype);\n    pragma Inline (Set_Address_Taken);"}, {"sha": "11b6983c0308191420072f11603545a1900e3414", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=dc419b9f8d6f998186706aa1afa50db1ca7efae5", "patch": "@@ -2380,13 +2380,76 @@ package body Exp_Ch6 is\n    procedure Expand_Call (N : Node_Id) is\n       Post_Call : List_Id;\n \n+      --  If this is an indirect call through an Access_To_Subprogram\n+      --  with contract specifications, it is rewritten as a call to\n+      --  the corresponding Access_Subprogram_Wrapper with the same\n+      --  actuals, whose body contains a naked indirect call (which\n+      --  itself must not be rewritten, to prevent infinite recursion).\n+\n+      Must_Rewrite_Indirect_Call : constant Boolean :=\n+        Ada_Version >= Ada_2020\n+          and then Nkind (Name (N)) = N_Explicit_Dereference\n+          and then Ekind (Etype (Name (N))) = E_Subprogram_Type\n+          and then Present\n+            (Access_Subprogram_Wrapper (Etype (Name (N))));\n+\n    begin\n       pragma Assert (Nkind_In (N, N_Entry_Call_Statement,\n                                   N_Function_Call,\n                                   N_Procedure_Call_Statement));\n \n-      Expand_Call_Helper (N, Post_Call);\n-      Insert_Post_Call_Actions (N, Post_Call);\n+      --  Check that this is not the call in the body of the wrapper.\n+\n+      if Must_Rewrite_Indirect_Call\n+        and then (not Is_Overloadable (Current_Scope)\n+             or else not Is_Access_Subprogram_Wrapper (Current_Scope))\n+      then\n+         declare\n+            Loc : constant Source_Ptr := Sloc (N);\n+            Wrapper : constant Entity_Id :=\n+              Access_Subprogram_Wrapper (Etype (Name (N)));\n+            Ptr      : constant Node_Id   := Prefix (Name (N));\n+            Ptr_Type : constant Entity_Id := Etype (Ptr);\n+            Parms    : constant List_Id   := Parameter_Associations (N);\n+            Typ      : constant Entity_Id := Etype (N);\n+            New_N    : Node_Id;\n+\n+         begin\n+            --  The last actual in the call is the pointer itself.\n+            --  If the aspect is inherited, convert the pointer to the\n+            --  parent type that specifies the contract.\n+\n+            if Is_Derived_Type (Ptr_Type)\n+              and then Ptr_Type /= Etype (Last_Formal (Wrapper))\n+            then\n+               Append\n+                (Make_Type_Conversion (Loc,\n+                   New_Occurrence_Of\n+                    (Etype (Last_Formal (Wrapper)), Loc), Ptr),\n+                   Parms);\n+\n+            else\n+               Append (Ptr, Parms);\n+            end if;\n+\n+            if Nkind (N) = N_Procedure_Call_Statement then\n+               New_N := Make_Procedure_Call_Statement (Loc,\n+                  Name  => New_Occurrence_Of (Wrapper, Loc),\n+                  Parameter_Associations => Parms);\n+            else\n+               New_N := Make_Function_Call (Loc,\n+                  Name => New_Occurrence_Of (Wrapper, Loc),\n+                  Parameter_Associations => Parms);\n+            end if;\n+\n+            Rewrite (N, New_N);\n+            Analyze_And_Resolve (N, Typ);\n+         end;\n+\n+      else\n+         Expand_Call_Helper (N, Post_Call);\n+         Insert_Post_Call_Actions (N, Post_Call);\n+      end if;\n    end Expand_Call;\n \n    ------------------------"}, {"sha": "c464eacd0dcbae697bbb1ebad56e18cae0cc5853", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 197, "deletions": 1, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=dc419b9f8d6f998186706aa1afa50db1ca7efae5", "patch": "@@ -4522,6 +4522,185 @@ package body Sem_Prag is\n          --  a class-wide precondition only if one of its ancestors has an\n          --  explicit class-wide precondition.\n \n+         procedure Build_Access_Subprogram_Wrapper\n+           (Decl : Node_Id;\n+            Prag : Node_Id);\n+         --  When an access_to_subprogram type has pre/postconditions, we\n+         --  build a subprogram that includes these contracts and is invoked\n+         --  by any indirect call through the corresponding access type.\n+\n+         procedure Build_Access_Subprogram_Wrapper_Body\n+           (Decl : Node_Id;\n+            New_Decl : Node_Id);\n+         --  Build the wrapper body, which holds the indirect call through\n+         --  an access_to_subprogram, and whose expansion incorporates the\n+         --  contracts of the access type declaration.\n+\n+         -------------------------------------\n+         -- Build_Access_Subprogram_Wrapper --\n+         -------------------------------------\n+\n+         procedure Build_Access_Subprogram_Wrapper\n+           (Decl : Node_Id;\n+            Prag : Node_Id)\n+         is\n+            Loc      : constant Source_Ptr := Sloc (Decl);\n+            Id       : constant Entity_Id  := Defining_Identifier (Decl);\n+            Type_Def : constant Node_Id := Type_Definition (Decl);\n+            Specs   :  constant List_Id := Parameter_Specifications (Type_Def);\n+            Profile : constant List_Id  := New_List;\n+\n+            Form_P   : Node_Id;\n+            New_P    : Node_Id;\n+            New_Decl : Node_Id;\n+            Spec     : Node_Id;\n+            Subp     : Entity_Id;\n+\n+         begin\n+            if Ekind_In (Id, E_Access_Subprogram_Type,\n+               E_Access_Protected_Subprogram_Type,\n+               E_Anonymous_Access_Protected_Subprogram_Type,\n+               E_Anonymous_Access_Subprogram_Type)\n+            then\n+               null;\n+\n+            else\n+               Error_Msg_N\n+                 (\"illegal pre/postcondition on access type\", N);\n+               return;\n+            end if;\n+\n+            Subp := Make_Temporary (Loc, 'A');\n+            Form_P := First (Specs);\n+\n+            while Present (Form_P) loop\n+               New_P := New_Copy_Tree (Form_P);\n+               Set_Defining_Identifier (New_P,\n+                 Make_Defining_Identifier\n+                  (Loc, Chars (Defining_Identifier (Form_P))));\n+               Append (New_P, Profile);\n+               Next (Form_P);\n+            end loop;\n+\n+            --  Add to parameter specifications the access parameter that\n+            --  is passed from an indirect call.\n+\n+            Append (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier => Make_Temporary (Loc, 'P'),\n+                 Parameter_Type  =>  New_Occurrence_Of (Id, Loc)),\n+               Profile);\n+\n+            if Nkind (Type_Def) = N_Access_Procedure_Definition then\n+               Spec :=\n+                 Make_Procedure_Specification (Loc,\n+                   Defining_Unit_Name       => Subp,\n+                   Parameter_Specifications => Profile);\n+            else\n+               Spec :=\n+                 Make_Function_Specification (Loc,\n+                   Defining_Unit_Name       => Subp,\n+                   Parameter_Specifications => Profile,\n+                   Result_Definition        =>\n+                     New_Copy_Tree\n+                       (Result_Definition (Type_Definition (Decl))));\n+            end if;\n+\n+            New_Decl :=\n+              Make_Subprogram_Declaration (Loc, Specification => Spec);\n+            Set_Aspect_Specifications (New_Decl,\n+              New_Copy_List_Tree (Aspect_Specifications (Decl)));\n+\n+            declare\n+               Asp : Node_Id;\n+\n+            begin\n+               Asp := First (Aspect_Specifications (New_Decl));\n+               while Present (Asp) loop\n+                  Set_Aspect_Rep_Item (Asp, Empty);\n+                  Set_Entity (Asp, Empty);\n+                  Set_Analyzed (Asp, False);\n+                  Next (Asp);\n+               end loop;\n+            end;\n+\n+            Insert_After (Prag, New_Decl);\n+            Set_Access_Subprogram_Wrapper (Designated_Type (Id), Subp);\n+            Build_Access_Subprogram_Wrapper_Body (Decl, New_Decl);\n+         end Build_Access_Subprogram_Wrapper;\n+\n+         ------------------------------------------\n+         -- Build_Access_Subprogram_Wrapper_Body --\n+         ------------------------------------------\n+\n+         procedure Build_Access_Subprogram_Wrapper_Body\n+           (Decl : Node_Id;\n+            New_Decl : Node_Id)\n+         is\n+            Loc       : constant Source_Ptr := Sloc (Decl);\n+            Actuals   : constant List_Id := New_List;\n+            Type_Def  : constant Node_Id := Type_Definition (Decl);\n+            Type_Id   : constant Entity_Id := Defining_Identifier (Decl);\n+            Spec_Node : constant Node_Id :=\n+              New_Copy_Tree (Specification (New_Decl));\n+\n+            Act       : Node_Id;\n+            Body_Node : Node_Id;\n+            Call_Stmt : Node_Id;\n+            Ptr       : Entity_Id;\n+         begin\n+            if not Expander_Active then\n+               return;\n+            end if;\n+\n+            Set_Defining_Unit_Name (Spec_Node,\n+              Make_Defining_Identifier\n+                (Loc, Chars (Defining_Unit_Name (Spec_Node))));\n+\n+            --  Create List of actuals for indirect call. The last\n+            --  parameter of the subprogram is the access value itself.\n+\n+            Act := First (Parameter_Specifications (Spec_Node));\n+\n+            while Present (Act) loop\n+               Append_To (Actuals,\n+                 Make_Identifier (Loc, Chars (Defining_Identifier (Act))));\n+               Next (Act);\n+               exit when Act = Last (Parameter_Specifications (Spec_Node));\n+            end loop;\n+\n+            Ptr :=\n+              Defining_Identifier\n+                (Last (Parameter_Specifications (Spec_Node)));\n+\n+            if Nkind (Type_Def) = N_Access_Procedure_Definition then\n+               Call_Stmt := Make_Procedure_Call_Statement (Loc,\n+                 Name =>\n+                    Make_Explicit_Dereference\n+                      (Loc, New_Occurrence_Of (Ptr, Loc)),\n+                 Parameter_Associations => Actuals);\n+            else\n+               Call_Stmt := Make_Simple_Return_Statement (Loc,\n+                 Expression =>\n+                   Make_Function_Call (Loc,\n+                 Name => Make_Explicit_Dereference\n+                          (Loc, New_Occurrence_Of (Ptr, Loc)),\n+                 Parameter_Associations => Actuals));\n+            end if;\n+\n+            Body_Node := Make_Subprogram_Body (Loc,\n+              Specification => Spec_Node,\n+              Declarations  => New_List,\n+              Handled_Statement_Sequence =>\n+                Make_Handled_Sequence_Of_Statements (Loc,\n+                  Statements    => New_List (Call_Stmt)));\n+\n+            --  Place body in list of freeze actions for the type.\n+\n+            Ensure_Freeze_Node (Type_Id);\n+            Append_Freeze_Actions (Type_Id, New_List (Body_Node));\n+         end Build_Access_Subprogram_Wrapper_Body;\n+\n          -----------------------------\n          -- Inherits_Class_Wide_Pre --\n          -----------------------------\n@@ -4763,6 +4942,16 @@ package body Sem_Prag is\n          then\n             null;\n \n+         elsif Ada_Version >= Ada_2020\n+           and then Nkind (Subp_Decl) = N_Full_Type_Declaration\n+         then\n+\n+            --  Access_To_Subprogram type has pre/postconditions.\n+            --  Build wrapper subprogram to carry the contract items.\n+\n+            Build_Access_Subprogram_Wrapper (Subp_Decl, N);\n+            return;\n+\n          --  Otherwise the placement is illegal\n \n          else\n@@ -30141,12 +30330,19 @@ package body Sem_Prag is\n                elsif Present (Generic_Parent (Specification (Stmt))) then\n                   return Stmt;\n \n-               --  Ada 2020: contract on formal subprogram\n+               --  Ada 2020: contract on formal subprogram or on generated\n+               --  Access_Subprogram_Wrapper, which appears after the related\n+               --  Access_Subprogram declaration.\n \n                elsif Is_Generic_Actual_Subprogram (Defining_Entity (Stmt))\n                  and then Ada_Version >= Ada_2020\n                then\n                   return Stmt;\n+\n+               elsif Is_Access_Subprogram_Wrapper (Defining_Entity (Stmt))\n+                 and then Ada_Version >= Ada_2020\n+               then\n+                  return Stmt;\n                end if;\n             end if;\n "}, {"sha": "d4ff2f1a1796c47b6f35f64a08ac8e8fe6cd0fab", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=dc419b9f8d6f998186706aa1afa50db1ca7efae5", "patch": "@@ -11505,6 +11505,19 @@ package body Sem_Util is\n       return False;\n    end Has_Non_Null_Statements;\n \n+   ----------------------------------\n+   -- Is_Access_Subprogram_Wrapper --\n+   ----------------------------------\n+\n+   function Is_Access_Subprogram_Wrapper (E : Entity_Id) return Boolean is\n+      Formal : constant Entity_Id := Last_Formal (E);\n+   begin\n+      return Present (Formal)\n+        and then Ekind (Etype (Formal)) in Access_Subprogram_Kind\n+        and then Access_Subprogram_Wrapper\n+           (Directly_Designated_Type (Etype (Formal))) = E;\n+   end Is_Access_Subprogram_Wrapper;\n+\n    ---------------------------------\n    -- Side_Effect_Free_Statements --\n    ---------------------------------"}, {"sha": "e477c3849bb64a87ebd4aac8f7e2417aebc9a58e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc419b9f8d6f998186706aa1afa50db1ca7efae5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=dc419b9f8d6f998186706aa1afa50db1ca7efae5", "patch": "@@ -1519,6 +1519,10 @@ package Sem_Util is\n    --  pragma Initialize_Scalars or by the binder. Return an expression created\n    --  at source location Loc, which denotes the invalid value.\n \n+   function Is_Access_Subprogram_Wrapper (E : Entity_Id) return Boolean;\n+   --  True if E is the constructed wrapper for an access_to_subprogram\n+   --  type with Pre/Postconditions.\n+\n    function Is_Actual_Out_Parameter (N : Node_Id) return Boolean;\n    --  Determines if N is an actual parameter of out mode in a subprogram call\n "}]}