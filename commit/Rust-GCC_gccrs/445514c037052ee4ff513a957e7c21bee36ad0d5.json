{"sha": "445514c037052ee4ff513a957e7c21bee36ad0d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ1NTE0YzAzNzA1MmVlNGZmNTEzYTk1N2U3YzIxYmVlMzZhZDBkNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-20T15:57:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-02T08:58:17Z"}, "message": "[Ada] Get rid of more references to Universal_Integer in expanded code\n\n2020-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb (Build_Array_Aggr_Code): Set the type of the PAT\n\ton the zero used to clear the array.\n\t* exp_attr.adb (Expand_N_Attribute_Reference)\n\t<Attribute_Alignment>: In the CW case, directly convert from the\n\talignment's type to the target type if the parent is an\n\tunchecked conversion.\n\t* sem_res.adb (Set_String_Literal_Subtype): In the dynamic case,\n\tuse the general expression for the upper bound only when needed.\n\tSet the base type of the index as the type of the low bound.\n\t(Simplify_Type_Conversion): Do an intermediate conversion to the\n\troot type of the target type if the operand is an integer\n\tliteral.\n\t* tbuild.adb (Convert_To): Get rid of an intermediate conversion\n\tto Universal_Integer if the inner expression has integer tyoe.\n\t* libgnat/a-sequio.adb (Byte_Swap): Make use of an equivalent\n\tstatic expression in the case statement.", "tree": {"sha": "082a4533cf86230f4d2321b18cb14dfec30109b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/082a4533cf86230f4d2321b18cb14dfec30109b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/445514c037052ee4ff513a957e7c21bee36ad0d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445514c037052ee4ff513a957e7c21bee36ad0d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445514c037052ee4ff513a957e7c21bee36ad0d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445514c037052ee4ff513a957e7c21bee36ad0d5/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0f920c96ac463c9d9195df2f40185535a5b8ec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f920c96ac463c9d9195df2f40185535a5b8ec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0f920c96ac463c9d9195df2f40185535a5b8ec3"}], "stats": {"total": 124, "additions": 86, "deletions": 38}, "files": [{"sha": "05508d821d4dea42ec6687b9b45ecc913a9924ab", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=445514c037052ee4ff513a957e7c21bee36ad0d5", "patch": "@@ -2043,12 +2043,15 @@ package body Exp_Aggr is\n         and then Is_Bit_Packed_Array (Typ)\n         and then Is_Modular_Integer_Type (Packed_Array_Impl_Type (Typ))\n       then\n-         Append_To (New_Code,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Copy_Tree (Into),\n-             Expression =>\n-               Unchecked_Convert_To (Typ,\n-                 Make_Integer_Literal (Loc, Uint_0))));\n+         declare\n+            Zero : constant Node_Id := Make_Integer_Literal (Loc, Uint_0);\n+         begin\n+            Analyze_And_Resolve (Zero, Packed_Array_Impl_Type (Typ));\n+            Append_To (New_Code,\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Copy_Tree (Into),\n+                Expression => Unchecked_Convert_To (Typ, Zero)));\n+         end;\n       end if;\n \n       --  If the component type contains tasks, we need to build a Master"}, {"sha": "a4957b38f59c887dd88bb1561dbf4c4fd65a4b4b", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=445514c037052ee4ff513a957e7c21bee36ad0d5", "patch": "@@ -2459,12 +2459,20 @@ package body Exp_Attr is\n \n             New_Node := Build_Get_Alignment (Loc, New_Node);\n \n+            --  Case where the context is an unchecked conversion to a specific\n+            --  integer type. We directly convert from the alignment's type.\n+\n+            if Nkind (Parent (N)) = N_Unchecked_Type_Conversion then\n+               Rewrite (N, New_Node);\n+               Analyze_And_Resolve (N);\n+               return;\n+\n             --  Case where the context is a specific integer type with which\n             --  the original attribute was compatible. But the alignment has a\n             --  specific type in a-tags.ads (Standard.Natural) so, in order to\n             --  preserve type compatibility, we must convert explicitly.\n \n-            if Typ /= Standard_Natural then\n+            elsif Typ /= Standard_Natural then\n                New_Node := Convert_To (Typ, New_Node);\n             end if;\n "}, {"sha": "95a95a2d372409886e88eec8271e0c13e78f659b", "filename": "gcc/ada/libgnat/a-sequio.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Flibgnat%2Fa-sequio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Flibgnat%2Fa-sequio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-sequio.adb?ref=445514c037052ee4ff513a957e7c21bee36ad0d5", "patch": "@@ -73,7 +73,7 @@ package body Ada.Sequential_IO is\n    procedure Byte_Swap (Siz : in out size_t) is\n       use System.Byte_Swapping;\n    begin\n-      case Siz'Size is\n+      case size_t'Size is\n          when 32     => Siz := size_t (Bswap_32 (U32 (Siz)));\n          when 64     => Siz := size_t (Bswap_64 (U64 (Siz)));\n          when others => raise Program_Error;"}, {"sha": "ee9772cfca83b7f57eed504736946050212c82e0", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=445514c037052ee4ff513a957e7c21bee36ad0d5", "patch": "@@ -266,7 +266,8 @@ package body Sem_Res is\n    procedure Simplify_Type_Conversion (N : Node_Id);\n    --  Called after N has been resolved and evaluated, but before range checks\n    --  have been applied. Currently simplifies a combination of floating-point\n-   --  to integer conversion and Rounding or Truncation attribute.\n+   --  to integer conversion and Rounding or Truncation attribute, and also the\n+   --  conversion of an integer literal to a dynamic integer type.\n \n    function Unique_Fixed_Point_Type (N : Node_Id) return Entity_Id;\n    --  A universal_fixed expression in an universal context is unambiguous if\n@@ -12477,37 +12478,51 @@ package body Sem_Res is\n \n       --  If the lower bound is not static we create a range for the string\n       --  literal, using the index type and the known length of the literal.\n-      --  The index type is not necessarily Positive, so the upper bound is\n-      --  computed as T'Val (T'Pos (Low_Bound) + L - 1).\n+      --  If the length is 1, then the upper bound is set to a mere copy of\n+      --  the lower bound; or else, if the index type is a signed integer,\n+      --  then the upper bound is computed as Low_Bound + L - 1; otherwise,\n+      --  the upper bound is computed as T'Val (T'Pos (Low_Bound) + L - 1).\n \n       else\n          declare\n-            Index_List : constant List_Id   := New_List;\n-            Index_Type : constant Entity_Id := Etype (First_Index (Typ));\n-            High_Bound : constant Node_Id   :=\n-                           Make_Attribute_Reference (Loc,\n-                             Attribute_Name => Name_Val,\n-                             Prefix         =>\n-                               New_Occurrence_Of (Index_Type, Loc),\n-                             Expressions    => New_List (\n-                               Make_Op_Add (Loc,\n-                                 Left_Opnd  =>\n-                                   Make_Attribute_Reference (Loc,\n-                                     Attribute_Name => Name_Pos,\n-                                     Prefix         =>\n-                                       New_Occurrence_Of (Index_Type, Loc),\n-                                     Expressions    =>\n-                                       New_List (New_Copy_Tree (Low_Bound))),\n-                                 Right_Opnd =>\n-                                   Make_Integer_Literal (Loc,\n-                                     String_Length (Strval (N)) - 1))));\n-\n+            Length        : constant Nat := String_Length (Strval (N));\n+            Index_List    : constant List_Id   := New_List;\n+            Index_Type    : constant Entity_Id := Etype (First_Index (Typ));\n             Array_Subtype : Entity_Id;\n             Drange        : Node_Id;\n+            High_Bound    : Node_Id;\n             Index         : Node_Id;\n             Index_Subtype : Entity_Id;\n \n          begin\n+            if Length = 1 then\n+               High_Bound := New_Copy_Tree (Low_Bound);\n+\n+            elsif Is_Signed_Integer_Type (Index_Type) then\n+               High_Bound :=\n+                 Make_Op_Add (Loc,\n+                   Left_Opnd  => New_Copy_Tree (Low_Bound),\n+                   Right_Opnd => Make_Integer_Literal (Loc, Length - 1));\n+\n+            else\n+               High_Bound :=\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Val,\n+                   Prefix         =>\n+                     New_Occurrence_Of (Index_Type, Loc),\n+                   Expressions    => New_List (\n+                     Make_Op_Add (Loc,\n+                       Left_Opnd  =>\n+                         Make_Attribute_Reference (Loc,\n+                           Attribute_Name => Name_Pos,\n+                           Prefix         =>\n+                             New_Occurrence_Of (Index_Type, Loc),\n+                           Expressions    =>\n+                             New_List (New_Copy_Tree (Low_Bound))),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc, Length - 1))));\n+            end if;\n+\n             if Is_Integer_Type (Index_Type) then\n                Set_String_Literal_Low_Bound\n                  (Subtype_Id, Make_Integer_Literal (Loc, 1));\n@@ -12522,10 +12537,10 @@ package body Sem_Res is\n                     Attribute_Name => Name_First,\n                     Prefix         =>\n                       New_Occurrence_Of (Base_Type (Index_Type), Loc)));\n-               Set_Etype (String_Literal_Low_Bound (Subtype_Id), Index_Type);\n             end if;\n \n-            Analyze_And_Resolve (String_Literal_Low_Bound (Subtype_Id));\n+            Analyze_And_Resolve\n+              (String_Literal_Low_Bound (Subtype_Id), Base_Type (Index_Type));\n \n             --  Build bona fide subtype for the string, and wrap it in an\n             --  unchecked conversion, because the back end expects the\n@@ -12611,6 +12626,19 @@ package body Sem_Res is\n                     Relocate_Node (First (Expressions (Operand))));\n                   Set_Float_Truncate (N, Truncate);\n                end;\n+\n+            --  Special processing for the conversion of an integer literal to\n+            --  a dynamic type: we first convert the literal to the root type\n+            --  and then convert the result to the target type, the goal being\n+            --  to avoid doing range checks in Universal_Integer type.\n+\n+            elsif Is_Integer_Type (Target_Typ)\n+              and then not Is_Generic_Type (Root_Type (Target_Typ))\n+              and then Nkind (Operand) = N_Integer_Literal\n+              and then Opnd_Typ = Universal_Integer\n+            then\n+               Convert_To_And_Rewrite (Root_Type (Target_Typ), Operand);\n+               Analyze_And_Resolve (Operand);\n             end if;\n          end;\n       end if;"}, {"sha": "1302d97ea85cd0489373650fe9ceca57b78ab236", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445514c037052ee4ff513a957e7c21bee36ad0d5/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=445514c037052ee4ff513a957e7c21bee36ad0d5", "patch": "@@ -116,10 +116,19 @@ package body Tbuild is\n       Result : Node_Id;\n \n    begin\n-      if Present (Etype (Expr))\n-        and then (Etype (Expr)) = Typ\n-      then\n+      if Present (Etype (Expr)) and then Etype (Expr) = Typ then\n          return Relocate_Node (Expr);\n+\n+      --  Case where the expression is a conversion to universal integer of\n+      --  an expression with an integer type, and we can thus eliminate the\n+      --  intermediate conversion to universal integer.\n+\n+      elsif Nkind (Expr) = N_Type_Conversion\n+        and then Entity (Subtype_Mark (Expr)) = Universal_Integer\n+        and then Is_Integer_Type (Etype (Expression (Expr)))\n+      then\n+         return Convert_To (Typ, Expression (Expr));\n+\n       else\n          Result :=\n            Make_Type_Conversion (Sloc (Expr),\n@@ -853,8 +862,8 @@ package body Tbuild is\n       then\n          return Relocate_Node (Expr);\n \n-      --  Cases where the inner expression is itself an unchecked conversion\n-      --  to the same type, and we can thus eliminate the outer conversion.\n+      --  Case where the expression is itself an unchecked conversion to\n+      --  the same type, and we can thus eliminate the outer conversion.\n \n       elsif Nkind (Expr) = N_Unchecked_Type_Conversion\n         and then Entity (Subtype_Mark (Expr)) = Typ"}]}