{"sha": "21318741bb4f00d87f558a2f11d462fa61381e80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEzMTg3NDFiYjRmMDBkODdmNTU4YTJmMTFkNDYyZmE2MTM4MWU4MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-02T18:29:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-02T18:29:56Z"}, "message": "c-common.c (c_common_nodes_and_builtins): Make sizetype_endlink reference the language-equivalent of sizetype.\n\n\t* c-common.c (c_common_nodes_and_builtins): Make sizetype_endlink\n\treference the language-equivalent of sizetype.\n\t* c-typeck.c (comptypes): Treat sizetype like its language equivalent.\n\t* fold-const.c (size_binop, size_diffop): Put back checks.\n\t* gcse.c (dump_hash_table): Fix minor error in last change.\n\t* stor-layout.c (set_sizetype): Set TYPE_DOMAIN of sizetype.\n\tClear TYPE_{NEXT,MAIN}_VARIANT and TYPE_{POINTER,REFERENCE}_to of\n\tall sizetypes.\n\t* cp/typeck.c (comptypes): Treat sizetype like its language equivalent.\n\nFrom-SVN: r32291", "tree": {"sha": "012b815e352352c505a47f997f46e1b9d2d6618a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/012b815e352352c505a47f997f46e1b9d2d6618a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21318741bb4f00d87f558a2f11d462fa61381e80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21318741bb4f00d87f558a2f11d462fa61381e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21318741bb4f00d87f558a2f11d462fa61381e80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21318741bb4f00d87f558a2f11d462fa61381e80/comments", "author": null, "committer": null, "parents": [{"sha": "42f602d842e3fe935b626e082eff27d5621ea2b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f602d842e3fe935b626e082eff27d5621ea2b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f602d842e3fe935b626e082eff27d5621ea2b3"}], "stats": {"total": 78, "additions": 55, "deletions": 23}, "files": [{"sha": "0d08e6b69717109d372bfd8a8a6142d22d2282e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -1,3 +1,14 @@\n+Thu Mar  2 13:29:46 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* c-common.c (c_common_nodes_and_builtins): Make sizetype_endlink\n+\treference the language-equivalent of sizetype.\n+\t* c-typeck.c (comptypes): Treat sizetype like its language equivalent.\n+\t* fold-const.c (size_binop, size_diffop): Put back checks.\n+\t* gcse.c (dump_hash_table): Fix minor error in last change.\n+\t* stor-layout.c (set_sizetype): Set TYPE_DOMAIN of sizetype.\n+\tClear TYPE_{NEXT,MAIN}_VARIANT and TYPE_{POINTER,REFERENCE}_to of\n+\tall sizetypes.\n+\n Thu Mar  2 12:48:45 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* calls.c (expand_call)  Do not attempt to combine stack adjustments"}, {"sha": "262022fb4e28d274c6b02327c9e2032765976247", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -3547,7 +3547,7 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \n   ptr_ftype = build_function_type (ptr_type_node, NULL_TREE);\n   ptr_ftype_unsigned = build_function_type (ptr_type_node, unsigned_endlink);\n-  sizetype_endlink = tree_cons (NULL_TREE, sizetype, endlink);\n+  sizetype_endlink = tree_cons (NULL_TREE, TYPE_DOMAIN (sizetype), endlink);\n   /* We realloc here because sizetype could be int or unsigned.  S'ok.  */\n   ptr_ftype_sizetype = build_function_type (ptr_type_node, sizetype_endlink);\n "}, {"sha": "6d85c359280bc31beba1a4df8b67216a77367b7c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -436,6 +436,16 @@ comptypes (type1, type2)\n       || TREE_CODE (t1) == ERROR_MARK || TREE_CODE (t2) == ERROR_MARK)\n     return 1;\n \n+  /* If either type is the internal version of sizetype, return the\n+     language version.  */\n+  if (TREE_CODE (t1) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t1)\n+      && TYPE_DOMAIN (t1) != 0)\n+    t1 = TYPE_DOMAIN (t1);\n+\n+  if (TREE_CODE (t2) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t2)\n+      && TYPE_DOMAIN (t2) != 0)\n+    t2 = TYPE_DOMAIN (t2);\n+\n   /* Treat an enum type as the integer type of the same width and \n      signedness.  */\n "}, {"sha": "d7e697afbf1d2801692cfac2148fd020a55cf0c3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -1,3 +1,7 @@\n+Thu Mar  2 13:32:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* typeck.c (comptypes): Treat sizetype like its language equivalent.\n+\n 2000-03-01  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* typeck.c (maybe_warn_about_returning_address_of_local): Reorganize"}, {"sha": "8fc3ab8a6674af6b7e4616297f7f4209a41cc1c6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -934,17 +934,15 @@ comptypes (t1, t2, strict)\n   if (t2 == error_mark_node)\n     return 0;\n \n-  /* If this is a strict comparison with a sizetype, the actual types\n-     won't be the same (since we need to set TYPE_IS_SIZETYPE, so verify\n-     if they are both the same size and signedness.  */\n-  if (strict == COMPARE_STRICT\n-      && TREE_CODE (t2) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t2) \n-      && TREE_CODE (t1) == INTEGER_TYPE\n-      && TREE_UNSIGNED (t1) == TREE_UNSIGNED (t2)\n-      && TYPE_MODE (t1) == TYPE_MODE (t2)\n-      && TYPE_MIN_VALUE (t1) == TYPE_MIN_VALUE (t2)\n-      && TYPE_MAX_VALUE (t1) == TYPE_MAX_VALUE (t2))\n-    return 1;\n+  /* If either type is the internal version of sizetype, return the\n+     language version.  */\n+  if (TREE_CODE (t1) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t1)\n+      && TYPE_DOMAIN (t1) != 0)\n+    t1 = TYPE_DOMAIN (t1);\n+\n+  if (TREE_CODE (t2) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t2)\n+      && TYPE_DOMAIN (t2) != 0)\n+    t2 = TYPE_DOMAIN (t2);\n \n   if (strict & COMPARE_RELAXED)\n     {"}, {"sha": "7a4a48566bca2aaa0a7c0abd7efbabb9c1aedda4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -1868,8 +1868,8 @@ size_binop (code, arg0, arg1)\n {\n   tree type = TREE_TYPE (arg0);\n \n-  if (TREE_CODE (type) != INTEGER_TYPE \n-      || TREE_CODE (TREE_TYPE (arg1)) != INTEGER_TYPE)\n+  if (TREE_CODE (type) != INTEGER_TYPE || ! TYPE_IS_SIZETYPE (type)\n+      || type != TREE_TYPE (arg1))\n     abort ();\n \n   /* Handle the special case of two integer constants faster.  */\n@@ -1905,8 +1905,8 @@ size_diffop (arg0, arg1)\n   tree type = TREE_TYPE (arg0);\n   tree ctype;\n \n-  if (TREE_CODE (type) != INTEGER_TYPE \n-      || TREE_CODE (TREE_TYPE (arg1)) != INTEGER_TYPE)\n+  if (TREE_CODE (type) != INTEGER_TYPE || ! TYPE_IS_SIZETYPE (type)\n+      || type != TREE_TYPE (arg1))\n     abort ();\n \n   /* If the type is already signed, just do the simple thing.  */"}, {"sha": "1ac98296e4fd490c5770a8df56d85dec6a98de95", "filename": "gcc/gcse.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -2009,12 +2009,13 @@ dump_hash_table (file, name, table, table_size, total_size)\n \t   name, table_size, total_size);\n \n   for (i = 0; i < total_size; i++)\n-    {\n-      fprintf (file, \"Index %d (hash value %d)\\n  \",\n-\t       expr->bitmap_index, hash_val[i]);\n-      print_rtl (file, flat_table[i]->expr);\n-      fprintf (file, \"\\n\");\n-    }\n+    if (flat_table[i] != 0)\n+      {\n+\tfprintf (file, \"Index %d (hash value %d)\\n  \",\n+\t\t expr->bitmap_index, hash_val[i]);\n+\tprint_rtl (file, flat_table[i]->expr);\n+\tfprintf (file, \"\\n\");\n+      }\n \n   fprintf (file, \"\\n\");\n "}, {"sha": "ab925694e314e310e19b579b2a23a9573f826b4f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21318741bb4f00d87f558a2f11d462fa61381e80/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=21318741bb4f00d87f558a2f11d462fa61381e80", "patch": "@@ -1402,6 +1402,7 @@ set_sizetype (type)\n \n   /* Make copies of nodes since we'll be setting TYPE_IS_SIZETYPE.  */\n   sizetype = copy_node (type);\n+  TYPE_DOMAIN (sizetype) = type;\n   bitsizetype = make_node (INTEGER_TYPE);\n   TYPE_NAME (bitsizetype) = TYPE_NAME (type);\n   TYPE_PRECISION (bitsizetype) = precision;\n@@ -1430,8 +1431,15 @@ set_sizetype (type)\n \n   TYPE_NAME (bitsizetype) = get_identifier (\"bit_size_type\");\n \n+  /* Show is a sizetype, is a main type, and has no pointers to it.  */\n   for (i = 0; i < sizeof sizetype_tab / sizeof sizetype_tab[0]; i++)\n-    TYPE_IS_SIZETYPE (sizetype_tab[i]) = 1;\n+    {\n+      TYPE_IS_SIZETYPE (sizetype_tab[i]) = 1;\n+      TYPE_MAIN_VARIANT (sizetype_tab[i]) = sizetype_tab[i];\n+      TYPE_NEXT_VARIANT (sizetype_tab[i]) = 0;\n+      TYPE_POINTER_TO (sizetype_tab[i]) = 0;\n+      TYPE_REFERENCE_TO (sizetype_tab[i]) = 0;\n+    }\n \n   ggc_add_tree_root ((tree *) &sizetype_tab,\n \t\t     sizeof sizetype_tab / sizeof (tree));"}]}