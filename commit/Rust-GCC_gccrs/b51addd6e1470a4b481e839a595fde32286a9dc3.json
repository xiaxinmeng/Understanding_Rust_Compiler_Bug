{"sha": "b51addd6e1470a4b481e839a595fde32286a9dc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUxYWRkZDZlMTQ3MGE0YjQ4MWU4MzlhNTk1ZmRlMzIyODZhOWRjMw==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-03-06T11:50:16Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-03-06T11:50:16Z"}, "message": "[ARC] Cleanup unused functions.\n\nRemove unused pieces of code.\n\ngcc/\n2018-03-06  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.c (arc_finalize_pic): Remove function.\n\t(arc_must_save_register): We use single base PIC register, remove\n\tchecks to save/restore the PIC register.\n\t(arc_expand_prologue): Likewise.\n\t* config/arc/arc-protos.h (arc_set_default_type_attributes):\n\tRemove.\n\t(arc_verify_short): Likewise.\n\t(arc_attr_type): Likewise.\n\t* config/arc/arc.c (arc_set_default_type_attributes): Remove.\n\t(walk_stores): Likewise.\n\t(arc_address_cost): Make it static.\n\t(arc_verify_short): Likewise.\n\t(branch_dest): Likewise.\n\t(arc_attr_type): Likewise.\n\t* config/arc/arc.c (TARGET_ADJUST_INSN_LENGTH): Remove.\n\t(TARGET_INSN_LENGTH_PARAMETERS): Likewise.\n\t(arc_final_prescan_insn): Remove inserting the nops due to\n\thardware hazards.  It is done in reorg step.\n\t(insn_length_variant_t): Remove.\n\t(insn_length_parameters_t): Likewise.\n\t(arc_insn_length_parameters): Likewise.\n\t(arc_get_insn_variants): Likewise.\n\t* config/arc/arc.h (TARGET_UPSIZE_DBR): Remove.\n\nFrom-SVN: r258275", "tree": {"sha": "345e89c02f5cfeff909ea94dd3547fd831264fb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/345e89c02f5cfeff909ea94dd3547fd831264fb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b51addd6e1470a4b481e839a595fde32286a9dc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51addd6e1470a4b481e839a595fde32286a9dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b51addd6e1470a4b481e839a595fde32286a9dc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51addd6e1470a4b481e839a595fde32286a9dc3/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "155958ddfeaf5b657357440bf3127243c61cc951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155958ddfeaf5b657357440bf3127243c61cc951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155958ddfeaf5b657357440bf3127243c61cc951"}], "stats": {"total": 503, "additions": 30, "deletions": 473}, "files": [{"sha": "130aec7ad027c03ebbc65e2e2e9b5568281f647c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b51addd6e1470a4b481e839a595fde32286a9dc3", "patch": "@@ -1,3 +1,29 @@\n+2018-03-06  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t * config/arc/arc.c (arc_finalize_pic): Remove function.\n+\t (arc_must_save_register): We use single base PIC register, remove\n+\t checks to save/restore the PIC register.\n+\t (arc_expand_prologue): Likewise.\n+\t * config/arc/arc-protos.h (arc_set_default_type_attributes):\n+\t Remove.\n+\t (arc_verify_short): Likewise.\n+\t (arc_attr_type): Likewise.\n+\t * config/arc/arc.c (arc_set_default_type_attributes): Remove.\n+\t (walk_stores): Likewise.\n+\t (arc_address_cost): Make it static.\n+\t (arc_verify_short): Likewise.\n+\t (branch_dest): Likewise.\n+\t (arc_attr_type): Likewise.\n+\t * config/arc/arc.c (TARGET_ADJUST_INSN_LENGTH): Remove.\n+\t (TARGET_INSN_LENGTH_PARAMETERS): Likewise.\n+\t (arc_final_prescan_insn): Remove inserting the nops due to\n+\t hardware hazards.  It is done in reorg step.\n+\t (insn_length_variant_t): Remove.\n+\t (insn_length_parameters_t): Likewise.\n+\t (arc_insn_length_parameters): Likewise.\n+\t (arc_get_insn_variants): Likewise.\n+\t * config/arc/arc.h (TARGET_UPSIZE_DBR): Remove.\n+\n 2018-03-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR inline-asm/84683"}, {"sha": "75cfedab7f1b8b173ebd0fc0f2f1daece1573975", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=b51addd6e1470a4b481e839a595fde32286a9dc3", "patch": "@@ -32,7 +32,6 @@ extern bool arc_double_limm_p (rtx);\n extern void arc_print_operand (FILE *, rtx, int);\n extern void arc_print_operand_address (FILE *, rtx);\n extern void arc_final_prescan_insn (rtx_insn *, rtx *, int);\n-extern void arc_set_default_type_attributes(tree type);\n extern const char *arc_output_libcall (const char *);\n extern bool prepare_extend_operands (rtx *operands, enum rtx_code code,\n \t\t\t\t     machine_mode omode);\n@@ -97,10 +96,8 @@ extern void split_addsi (rtx *);\n extern void split_subsi (rtx *);\n extern void arc_pad_return (void);\n extern void arc_split_move (rtx *);\n-extern int arc_verify_short (rtx_insn *insn, int unalign, int);\n extern const char *arc_short_long (rtx_insn *insn, const char *, const char *);\n extern rtx arc_regno_use_in (unsigned int, rtx);\n-extern int arc_attr_type (rtx_insn *);\n extern bool arc_scheduling_not_expected (void);\n extern bool arc_sets_cc_p (rtx_insn *insn);\n extern int arc_label_align (rtx_insn *label);"}, {"sha": "32fcb81880a2e52933e600e7e14f10db757e8eef", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 4, "deletions": 467, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=b51addd6e1470a4b481e839a595fde32286a9dc3", "patch": "@@ -457,8 +457,6 @@ static void arc_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n static rtx arc_legitimize_address_0 (rtx, rtx, machine_mode mode);\n \n-static void arc_finalize_pic (void);\n-\n /* initialize the GCC target structure.  */\n #undef  TARGET_COMP_TYPE_ATTRIBUTES\n #define TARGET_COMP_TYPE_ATTRIBUTES arc_comp_type_attributes\n@@ -590,10 +588,6 @@ static void arc_finalize_pic (void);\n \n #define TARGET_LEGITIMIZE_ADDRESS arc_legitimize_address\n \n-#define TARGET_ADJUST_INSN_LENGTH arc_adjust_insn_length\n-\n-#define TARGET_INSN_LENGTH_PARAMETERS arc_insn_length_parameters\n-\n #undef TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P\n #define TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P\t\\\n   arc_no_speculation_in_delay_slots_p\n@@ -2109,14 +2103,6 @@ arc_comp_type_attributes (const_tree type1,\n   return 1;\n }\n \n-/* Set the default attributes for TYPE.  */\n-\n-void\n-arc_set_default_type_attributes (tree type ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable();\n-}\n-\n /* Misc. utilities.  */\n \n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n@@ -2346,7 +2332,7 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n-int\n+static int\n arc_address_cost (rtx addr, machine_mode, addr_space_t, bool speed)\n {\n   switch (GET_CODE (addr))\n@@ -2681,10 +2667,6 @@ arc_must_save_register (int regno, struct function *func)\n       && !firq_auto_save_p)\n     return true;\n \n-  if (flag_pic && crtl->uses_pic_offset_table\n-      && regno == PIC_OFFSET_TABLE_REGNUM)\n-    return true;\n-\n   return false;\n }\n \n@@ -3274,10 +3256,6 @@ arc_expand_prologue (void)\n \temit_insn (gen_stack_tie (stack_pointer_rtx,\n \t\t\t\t  hard_frame_pointer_rtx));\n     }\n-\n-  /* Setup the gp register, if needed.  */\n-  if (crtl->uses_pic_offset_table)\n-    arc_finalize_pic ();\n }\n \n /* Do any necessary cleanup after a function to restore stack, frame,\n@@ -3523,37 +3501,6 @@ arc_unspec_offset (rtx loc, int unspec)\n \t\t\t\t\t       unspec));\n }\n \n-/* Emit special PIC prologues and epilogues.  */\n-/* If the function has any GOTOFF relocations, then the GOTBASE\n-   register has to be setup in the prologue\n-   The instruction needed at the function start for setting up the\n-   GOTBASE register is\n-      add rdest, pc,\n-   ----------------------------------------------------------\n-   The rtl to be emitted for this should be:\n-     set (reg basereg)\n-         (plus (reg pc)\n-               (const (unspec (symref _DYNAMIC) 3)))\n-   ----------------------------------------------------------  */\n-\n-static void\n-arc_finalize_pic (void)\n-{\n-  rtx pat;\n-  rtx baseptr_rtx = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n-\n-  if (crtl->uses_pic_offset_table == 0)\n-    return;\n-\n-  gcc_assert (flag_pic != 0);\n-\n-  pat = gen_rtx_SYMBOL_REF (Pmode, \"_DYNAMIC\");\n-  pat = arc_unspec_offset (pat, ARC_UNSPEC_GOT);\n-  pat = gen_rtx_SET (baseptr_rtx, pat);\n-\n-  emit_insn (pat);\n-}\n-\f\n /* !TARGET_BARREL_SHIFTER support.  */\n /* Emit a shift insn to set OP0 to OP1 shifted by OP2; CODE specifies what\n    kind of shift.  */\n@@ -4927,42 +4874,6 @@ arc_ccfsm_cond_exec_p (void)\n \t  && ARC_CCFSM_COND_EXEC_P (&arc_ccfsm_current));\n }\n \n-/* Like next_active_insn, but return NULL if we find an ADDR_(DIFF_)VEC,\n-   and look inside SEQUENCEs.  */\n-\n-static rtx_insn *\n-arc_next_active_insn (rtx_insn *insn, struct arc_ccfsm *statep)\n-{\n-  rtx pat;\n-\n-  do\n-    {\n-      if (statep)\n-\tarc_ccfsm_post_advance (insn, statep);\n-      insn = NEXT_INSN (insn);\n-      if (!insn || BARRIER_P (insn))\n-\treturn NULL;\n-      if (statep)\n-\tarc_ccfsm_advance (insn, statep);\n-    }\n-  while (NOTE_P (insn)\n-\t || (cfun->machine->arc_reorg_started\n-\t     && LABEL_P (insn) && !label_to_alignment (insn))\n-\t || (NONJUMP_INSN_P (insn)\n-\t     && (GET_CODE (PATTERN (insn)) == USE\n-\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)));\n-  if (!LABEL_P (insn))\n-    {\n-      gcc_assert (INSN_P (insn));\n-      pat = PATTERN (insn);\n-      if (GET_CODE (pat) == ADDR_VEC || GET_CODE (pat) == ADDR_DIFF_VEC)\n-\treturn NULL;\n-      if (GET_CODE (pat) == SEQUENCE)\n-\treturn as_a <rtx_insn *> (XVECEXP (pat, 0, 0));\n-    }\n-  return insn;\n-}\n-\n /* When deciding if an insn should be output short, we want to know something\n    about the following insns:\n    - if another insn follows which we know we can output as a short insn\n@@ -4987,7 +4898,7 @@ arc_next_active_insn (rtx_insn *insn, struct arc_ccfsm *statep)\n    zero if the current insn is aligned to a 4-byte-boundary, two otherwise.\n    If CHECK_ATTR is greater than 0, check the iscompact attribute first.  */\n \n-int\n+static int\n arc_verify_short (rtx_insn *insn, int, int check_attr)\n {\n   enum attr_iscompact iscompact;\n@@ -5034,23 +4945,6 @@ arc_final_prescan_insn (rtx_insn *insn, rtx *opvec ATTRIBUTE_UNUSED,\n   if (TARGET_DUMPISIZE)\n     fprintf (asm_out_file, \"\\n; at %04x\\n\", INSN_ADDRESSES (INSN_UID (insn)));\n \n-  /* Output a nop if necessary to prevent a hazard.\n-     Don't do this for delay slots: inserting a nop would\n-     alter semantics, and the only time we would find a hazard is for a\n-     call function result - and in that case, the hazard is spurious to\n-     start with.  */\n-  if (PREV_INSN (insn)\n-      && PREV_INSN (NEXT_INSN (insn)) == insn\n-      && arc_hazard (prev_real_insn (insn), insn))\n-    {\n-      current_output_insn =\n-\temit_insn_before (gen_nop (), NEXT_INSN (PREV_INSN (insn)));\n-      final_scan_insn (current_output_insn, asm_out_file, optimize, 1, NULL);\n-      current_output_insn = insn;\n-    }\n-  /* Restore extraction data which might have been clobbered by arc_hazard.  */\n-  extract_constrain_insn_cached (insn);\n-\n   if (!cfun->machine->prescan_initialized)\n     {\n       /* Clear lingering state from branch shortening.  */\n@@ -5116,7 +5010,7 @@ arc_frame_pointer_required (void)\n \n /* Return the destination address of a branch.  */\n \n-int\n+static int\n branch_dest (rtx branch)\n {\n   rtx pat = PATTERN (branch);\n@@ -7193,61 +7087,6 @@ arc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n     }\n }\n \n-\n-/* This was in rtlanal.c, and can go in there when we decide we want\n-   to submit the change for inclusion in the GCC tree.  */\n-/* Like note_stores, but allow the callback to have side effects on the rtl\n-   (like the note_stores of yore):\n-   Call FUN on each register or MEM that is stored into or clobbered by X.\n-   (X would be the pattern of an insn).  DATA is an arbitrary pointer,\n-   ignored by note_stores, but passed to FUN.\n-   FUN may alter parts of the RTL.\n-\n-   FUN receives three arguments:\n-   1. the REG, MEM, CC0 or PC being stored in or clobbered,\n-   2. the SET or CLOBBER rtx that does the store,\n-   3. the pointer DATA provided to note_stores.\n-\n-  If the item being stored in or clobbered is a SUBREG of a hard register,\n-  the SUBREG will be passed.  */\n-\n-/* For now.  */ static\n-void\n-walk_stores (rtx x, void (*fun) (rtx, rtx, void *), void *data)\n-{\n-  int i;\n-\n-  if (GET_CODE (x) == COND_EXEC)\n-    x = COND_EXEC_CODE (x);\n-\n-  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n-    {\n-      rtx dest = SET_DEST (x);\n-\n-      while ((GET_CODE (dest) == SUBREG\n-\t      && (!REG_P (SUBREG_REG (dest))\n-\t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER))\n-\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\tdest = XEXP (dest, 0);\n-\n-      /* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions,\n-\t each of whose first operand is a register.  */\n-      if (GET_CODE (dest) == PARALLEL)\n-\t{\n-\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t    if (XEXP (XVECEXP (dest, 0, i), 0) != 0)\n-\t      (*fun) (XEXP (XVECEXP (dest, 0, i), 0), x, data);\n-\t}\n-      else\n-\t(*fun) (dest, x, data);\n-    }\n-\n-  else if (GET_CODE (x) == PARALLEL)\n-    for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-      walk_stores (XVECEXP (x, 0, i), fun, data);\n-}\n-\n static bool\n arc_pass_by_reference (cumulative_args_t ca_v ATTRIBUTE_UNUSED,\n \t\t       machine_mode mode ATTRIBUTE_UNUSED,\n@@ -9047,308 +8886,6 @@ arc_adjust_insn_length (rtx_insn *insn, int len, bool)\n   return len;\n }\n \n-/* Values for length_sensitive.  */\n-enum\n-{\n-  ARC_LS_NONE,// Jcc\n-  ARC_LS_25, // 25 bit offset, B\n-  ARC_LS_21, // 21 bit offset, Bcc\n-  ARC_LS_U13,// 13 bit unsigned offset, LP\n-  ARC_LS_10, // 10 bit offset, B_s, Beq_s, Bne_s\n-  ARC_LS_9,  //  9 bit offset, BRcc\n-  ARC_LS_8,  //  8 bit offset, BRcc_s\n-  ARC_LS_U7, //  7 bit unsigned offset, LPcc\n-  ARC_LS_7   //  7 bit offset, Bcc_s\n-};\n-\n-/* While the infrastructure patch is waiting for review, duplicate the\n-   struct definitions, to allow this file to compile.  */\n-#if 1\n-typedef struct\n-{\n-  unsigned align_set;\n-  /* Cost as a branch / call target or call return address.  */\n-  int target_cost;\n-  int fallthrough_cost;\n-  int branch_cost;\n-  int length;\n-  /* 0 for not length sensitive, 1 for largest offset range,\n- *      2 for next smaller etc.  */\n-  unsigned length_sensitive : 8;\n-  bool enabled;\n-} insn_length_variant_t;\n-\n-typedef struct insn_length_parameters_s\n-{\n-  int align_unit_log;\n-  int align_base_log;\n-  int max_variants;\n-  int (*get_variants) (rtx_insn *, int, bool, bool, insn_length_variant_t *);\n-} insn_length_parameters_t;\n-\n-static void\n-arc_insn_length_parameters (insn_length_parameters_t *ilp) ATTRIBUTE_UNUSED;\n-#endif\n-\n-static int\n-arc_get_insn_variants (rtx_insn *insn, int len, bool, bool target_p,\n-\t\t       insn_length_variant_t *ilv)\n-{\n-  if (!NONDEBUG_INSN_P (insn))\n-    return 0;\n-  enum attr_type type;\n-  /* shorten_branches doesn't take optimize_size into account yet for the\n-     get_variants mechanism, so turn this off for now.  */\n-  if (optimize_size)\n-    return 0;\n-  if (rtx_sequence *pat = dyn_cast <rtx_sequence *> (PATTERN (insn)))\n-    {\n-      /* The interaction of a short delay slot insn with a short branch is\n-\t too weird for shorten_branches to piece together, so describe the\n-\t entire SEQUENCE.  */\n-      rtx_insn *inner;\n-      if (TARGET_UPSIZE_DBR\n-\t  && get_attr_length (pat->insn (1)) <= 2\n-\t  && (((type = get_attr_type (inner = pat->insn (0)))\n-\t       == TYPE_UNCOND_BRANCH)\n-\t      || type == TYPE_BRANCH)\n-\t  && get_attr_delay_slot_filled (inner) == DELAY_SLOT_FILLED_YES)\n-\t{\n-\t  int n_variants\n-\t    = arc_get_insn_variants (inner, get_attr_length (inner), true,\n-\t\t\t\t     target_p, ilv+1);\n-\t  /* The short variant gets split into a higher-cost aligned\n-\t     and a lower cost unaligned variant.  */\n-\t  gcc_assert (n_variants);\n-\t  gcc_assert (ilv[1].length_sensitive == ARC_LS_7\n-\t\t      || ilv[1].length_sensitive == ARC_LS_10);\n-\t  gcc_assert (ilv[1].align_set == 3);\n-\t  ilv[0] = ilv[1];\n-\t  ilv[0].align_set = 1;\n-\t  ilv[0].branch_cost += 1;\n-\t  ilv[1].align_set = 2;\n-\t  n_variants++;\n-\t  for (int i = 0; i < n_variants; i++)\n-\t    ilv[i].length += 2;\n-\t  /* In case an instruction with aligned size is wanted, and\n-\t     the short variants are unavailable / too expensive, add\n-\t     versions of long branch + long delay slot.  */\n-\t  for (int i = 2, end = n_variants; i < end; i++, n_variants++)\n-\t    {\n-\t      ilv[n_variants] = ilv[i];\n-\t      ilv[n_variants].length += 2;\n-\t    }\n-\t  return n_variants;\n-\t}\n-      return 0;\n-    }\n-  insn_length_variant_t *first_ilv = ilv;\n-  type = get_attr_type (insn);\n-  bool delay_filled\n-    = (get_attr_delay_slot_filled (insn) == DELAY_SLOT_FILLED_YES);\n-  int branch_align_cost = delay_filled ? 0 : 1;\n-  int branch_unalign_cost = delay_filled ? 0 : TARGET_UNALIGN_BRANCH ? 0 : 1;\n-  /* If the previous instruction is an sfunc call, this insn is always\n-     a target, even though the middle-end is unaware of this.  */\n-  bool force_target = false;\n-  rtx_insn *prev = prev_active_insn (insn);\n-  if (prev && arc_next_active_insn (prev, 0) == insn\n-      && ((NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n-\t  ? CALL_ATTR (as_a <rtx_sequence *> (PATTERN (prev))->insn (0),\n-\t\t       NON_SIBCALL)\n-\t  : (CALL_ATTR (prev, NON_SIBCALL)\n-\t     && NEXT_INSN (PREV_INSN (prev)) == prev)))\n-    force_target = true;\n-\n-  switch (type)\n-    {\n-    case TYPE_BRCC:\n-      /* Short BRCC only comes in no-delay-slot version, and without limm  */\n-      if (!delay_filled)\n-\t{\n-\t  ilv->align_set = 3;\n-\t  ilv->length = 2;\n-\t  ilv->branch_cost = 1;\n-\t  ilv->enabled = (len == 2);\n-\t  ilv->length_sensitive = ARC_LS_8;\n-\t  ilv++;\n-\t}\n-      /* Fall through.  */\n-    case TYPE_BRCC_NO_DELAY_SLOT:\n-      /* doloop_fallback* patterns are TYPE_BRCC_NO_DELAY_SLOT for\n-\t (delay slot) scheduling purposes, but they are longer.  */\n-      if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t  && GET_CODE (XVECEXP (PATTERN (insn), 0, 1)) == SET)\n-\treturn 0;\n-      /* Standard BRCC: 4 bytes, or 8 bytes with limm.  */\n-      ilv->length = ((type == TYPE_BRCC) ? 4 : 8);\n-      ilv->align_set = 3;\n-      ilv->branch_cost = branch_align_cost;\n-      ilv->enabled = (len <= ilv->length);\n-      ilv->length_sensitive = ARC_LS_9;\n-      if ((target_p || force_target)\n-\t  || (!delay_filled && TARGET_UNALIGN_BRANCH))\n-\t{\n-\t  ilv[1] = *ilv;\n-\t  ilv->align_set = 1;\n-\t  ilv++;\n-\t  ilv->align_set = 2;\n-\t  ilv->target_cost = 1;\n-\t  ilv->branch_cost = branch_unalign_cost;\n-\t}\n-      ilv++;\n-\n-      rtx op, op0;\n-      op = XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 0);\n-      op0 = XEXP (op, 0);\n-\n-      if (GET_CODE (op0) == ZERO_EXTRACT\n-\t  && satisfies_constraint_L (XEXP (op0, 2)))\n-\top0 = XEXP (op0, 0);\n-      if (satisfies_constraint_Rcq (op0))\n-\t{\n-\t  ilv->length = ((type == TYPE_BRCC) ? 6 : 10);\n-\t  ilv->align_set = 3;\n-\t  ilv->branch_cost = 1 + branch_align_cost;\n-\t  ilv->fallthrough_cost = 1;\n-\t  ilv->enabled = true;\n-\t  ilv->length_sensitive = ARC_LS_21;\n-\t  if (!delay_filled && TARGET_UNALIGN_BRANCH)\n-\t    {\n-\t      ilv[1] = *ilv;\n-\t      ilv->align_set = 1;\n-\t      ilv++;\n-\t      ilv->align_set = 2;\n-\t      ilv->branch_cost = 1 + branch_unalign_cost;\n-\t    }\n-\t  ilv++;\n-\t}\n-      ilv->length = ((type == TYPE_BRCC) ? 8 : 12);\n-      ilv->align_set = 3;\n-      ilv->branch_cost = 1 + branch_align_cost;\n-      ilv->fallthrough_cost = 1;\n-      ilv->enabled = true;\n-      ilv->length_sensitive = ARC_LS_21;\n-      if ((target_p || force_target)\n-\t  || (!delay_filled && TARGET_UNALIGN_BRANCH))\n-\t{\n-\t  ilv[1] = *ilv;\n-\t  ilv->align_set = 1;\n-\t  ilv++;\n-\t  ilv->align_set = 2;\n-\t  ilv->target_cost = 1;\n-\t  ilv->branch_cost = 1 + branch_unalign_cost;\n-\t}\n-      ilv++;\n-      break;\n-\n-    case TYPE_SFUNC:\n-      ilv->length = 12;\n-      goto do_call;\n-    case TYPE_CALL_NO_DELAY_SLOT:\n-      ilv->length = 8;\n-      goto do_call;\n-    case TYPE_CALL:\n-      ilv->length = 4;\n-      ilv->length_sensitive\n-\t= GET_CODE (PATTERN (insn)) == COND_EXEC ? ARC_LS_21 : ARC_LS_25;\n-    do_call:\n-      ilv->align_set = 3;\n-      ilv->fallthrough_cost = branch_align_cost;\n-      ilv->enabled = true;\n-      if ((target_p || force_target)\n-\t  || (!delay_filled && TARGET_UNALIGN_BRANCH))\n-\t{\n-\t  ilv[1] = *ilv;\n-\t  ilv->align_set = 1;\n-\t  ilv++;\n-\t  ilv->align_set = 2;\n-\t  ilv->target_cost = 1;\n-\t  ilv->fallthrough_cost = branch_unalign_cost;\n-\t}\n-      ilv++;\n-      break;\n-    case TYPE_UNCOND_BRANCH:\n-      /* Strictly speaking, this should be ARC_LS_10 for equality comparisons,\n-\t but that makes no difference at the moment.  */\n-      ilv->length_sensitive = ARC_LS_7;\n-      ilv[1].length_sensitive = ARC_LS_25;\n-      goto do_branch;\n-    case TYPE_BRANCH:\n-      ilv->length_sensitive = ARC_LS_10;\n-      ilv[1].length_sensitive = ARC_LS_21;\n-    do_branch:\n-      ilv->align_set = 3;\n-      ilv->length = 2;\n-      ilv->branch_cost = branch_align_cost;\n-      ilv->enabled = (len == ilv->length);\n-      ilv++;\n-      ilv->length = 4;\n-      ilv->align_set = 3;\n-      ilv->branch_cost = branch_align_cost;\n-      ilv->enabled = true;\n-      if ((target_p || force_target)\n-\t  || (!delay_filled && TARGET_UNALIGN_BRANCH))\n-\t{\n-\t  ilv[1] = *ilv;\n-\t  ilv->align_set = 1;\n-\t  ilv++;\n-\t  ilv->align_set = 2;\n-\t  ilv->target_cost = 1;\n-\t  ilv->branch_cost = branch_unalign_cost;\n-\t}\n-      ilv++;\n-      break;\n-    case TYPE_JUMP:\n-      return 0;\n-    default:\n-      /* For every short insn, there is generally also a long insn.\n-\t trap_s is an exception.  */\n-      if ((len & 2) == 0 || recog_memoized (insn) == CODE_FOR_trap_s)\n-\treturn 0;\n-      ilv->align_set = 3;\n-      ilv->length = len;\n-      ilv->enabled = 1;\n-      ilv++;\n-      ilv->align_set = 3;\n-      ilv->length = len + 2;\n-      ilv->enabled = 1;\n-      if (target_p || force_target)\n-\t{\n-\t  ilv[1] = *ilv;\n-\t  ilv->align_set = 1;\n-\t  ilv++;\n-\t  ilv->align_set = 2;\n-\t  ilv->target_cost = 1;\n-\t}\n-      ilv++;\n-    }\n-  /* If the previous instruction is an sfunc call, this insn is always\n-     a target, even though the middle-end is unaware of this.\n-     Therefore, if we have a call predecessor, transfer the target cost\n-     to the fallthrough and branch costs.  */\n-  if (force_target)\n-    {\n-      for (insn_length_variant_t *p = first_ilv; p < ilv; p++)\n-\t{\n-\t  p->fallthrough_cost += p->target_cost;\n-\t  p->branch_cost += p->target_cost;\n-\t  p->target_cost = 0;\n-\t}\n-    }\n-\n-  return ilv - first_ilv;\n-}\n-\n-static void\n-arc_insn_length_parameters (insn_length_parameters_t *ilp)\n-{\n-  ilp->align_unit_log = 1;\n-  ilp->align_base_log = 1;\n-  ilp->max_variants = 7;\n-  ilp->get_variants = arc_get_insn_variants;\n-}\n-\n /* Return a copy of COND from *STATEP, inverted if that is indicated by the\n    CC field of *STATEP.  */\n \n@@ -10267,7 +9804,7 @@ arc_regno_use_in (unsigned int regno, rtx x)\n /* Return the integer value of the \"type\" attribute for INSN, or -1 if\n    INSN can't have attributes.  */\n \n-int\n+static int\n arc_attr_type (rtx_insn *insn)\n {\n   if (NONJUMP_INSN_P (insn)"}, {"sha": "a8d03ced643842562fc314a21d1cb48558209e85", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51addd6e1470a4b481e839a595fde32286a9dc3/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=b51addd6e1470a4b481e839a595fde32286a9dc3", "patch": "@@ -141,9 +141,6 @@ extern const char *arc_cpu_to_as (int argc, const char **argv);\n /* Should we try to unalign likely taken branches without a delay slot.  */\n #define TARGET_UNALIGN_BRANCH (TARGET_ARC700 && !optimize_size)\n \n-/* Should we upsize short delayed branches with a short delay insn?  */\n-#define TARGET_UPSIZE_DBR (TARGET_ARC700 && !optimize_size)\n-\n /* Should we add padding before a return insn to avoid mispredict?  */\n #define TARGET_PAD_RETURN (TARGET_ARC700 && !optimize_size)\n "}]}