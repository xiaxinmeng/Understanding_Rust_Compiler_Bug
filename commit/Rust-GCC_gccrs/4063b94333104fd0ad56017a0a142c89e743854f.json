{"sha": "4063b94333104fd0ad56017a0a142c89e743854f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA2M2I5NDMzMzEwNGZkMGFkNTYwMTdhMGExNDJjODllNzQzODU0Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-02T08:27:23Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-02T08:27:23Z"}, "message": "cppexp.c: New FINISHED dummy token.\n\n\t* cppexp.c:  New FINISHED dummy token.  Combine operator initial\n\tflags and initial priority into a single constant.  New\n\tEQUALITY macro.  New operator flag SHORT_CIRCUIT.\n\t(_parse_cpp_expr): Implement new constants.  Take left operand\n\tchecks out of reduction loop.  Handle SHORT_CIRCUIT.  End of\n\tparse indicated by reducing FINISHED token.  Remove new lines\n\tfrom cpp_error messages.\n\nFrom-SVN: r32863", "tree": {"sha": "210331f17ddc259e14af80e953ee9ac04bd0ad64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/210331f17ddc259e14af80e953ee9ac04bd0ad64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4063b94333104fd0ad56017a0a142c89e743854f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4063b94333104fd0ad56017a0a142c89e743854f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4063b94333104fd0ad56017a0a142c89e743854f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4063b94333104fd0ad56017a0a142c89e743854f/comments", "author": null, "committer": null, "parents": [{"sha": "93fd8bf764b64c5914090779633b1209c2422dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fd8bf764b64c5914090779633b1209c2422dc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93fd8bf764b64c5914090779633b1209c2422dc6"}], "stats": {"total": 386, "additions": 200, "deletions": 186}, "files": [{"sha": "9f8c23501deeeb1193174f3c4162dc8780a4a942", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4063b94333104fd0ad56017a0a142c89e743854f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4063b94333104fd0ad56017a0a142c89e743854f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4063b94333104fd0ad56017a0a142c89e743854f", "patch": "@@ -1,3 +1,13 @@\n+2000-04-02  Neil Booth <NeilB@earthling.net>\n+\n+\t* cppexp.c:  New FINISHED dummy token.  Combine operator initial\n+\tflags and initial priority into a single constant.  New\n+\tEQUALITY macro.  New operator flag SHORT_CIRCUIT.\n+\t(_parse_cpp_expr): Implement new constants.  Take left operand\n+\tchecks out of reduction loop.  Handle SHORT_CIRCUIT.  End of\n+\tparse indicated by reducing FINISHED token.  Remove new lines\n+\tfrom cpp_error messages.\n+\n 2000-04-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* emit-rtl.c (gen_rtx_CONST_INT): Create cached CONST_INTs on the"}, {"sha": "4fc4d577c18a36f662b0c24780623cef20690acd", "filename": "gcc/cppexp.c", "status": "modified", "additions": 190, "deletions": 186, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4063b94333104fd0ad56017a0a142c89e743854f/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4063b94333104fd0ad56017a0a142c89e743854f/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=4063b94333104fd0ad56017a0a142c89e743854f", "patch": "@@ -102,14 +102,15 @@ static struct operation lex PARAMS ((cpp_reader *, int));\n #define NAME 308\n #define INT 309\n #define CHAR 310\n+#define FINISHED 311\n \n struct operation\n {\n   short op;\n-  U_CHAR prio; /* Priority of op (relative to it right operand).  */\n+  U_CHAR prio;         /* Priority of op.  */\n   U_CHAR flags;\n-  U_CHAR unsignedp;    /* true if value should be treated as unsigned */\n-  HOST_WIDEST_INT value;        /* The value logically \"right\" of op.  */\n+  U_CHAR unsignedp;    /* True if value should be treated as unsigned.  */\n+  HOST_WIDEST_INT value; /* The value logically \"right\" of op.  */\n };\n \n /* Parse and convert an integer for #if.  Accepts decimal, hex, or octal\n@@ -636,60 +637,79 @@ right_shift (pfile, a, unsignedp, b)\n     return a >> b;\n }\n \f\n-/* Operator precedence table.\n+/* Operator precedence and flags table.\n \n After an operator is returned from the lexer, if it has priority less\n than or equal to the operator on the top of the stack, we reduce the\n-stack one operator and repeat the test.  As equal priorities reduce,\n-this is naturally left-associative.\n+stack by one operator and repeat the test.  Since equal priorities\n+reduce, this is naturally left-associative.\n \n We handle right-associative operators by clearing the lower bit of all\n left-associative operators, and setting it for right-associative ones.\n-After the reduction phase, when an operator is pushed onto the stack,\n-its RIGHT_ASSOC bit is cleared.  This means that at reduction time, a\n-right-associative operator of otherwise equal precedence to the\n-operator on the top of the stack will have a greater priority by 1,\n-avoiding a reduction pass and making the logic right-associative.\n+After the reduction phase of a new operator, just before it is pushed\n+onto the stack, its RIGHT_ASSOC bit is cleared.  The effect is that\n+during the reduction phase, the current right-associative operator has\n+a priority one greater than any other operator of otherwise equal\n+precedence that has been pushed on the top of the stack.  This avoids\n+a reduction pass, and effectively makes the logic right-associative.\n \n The remaining cases are '(' and ')'.  We handle '(' by skipping the\n reduction phase completely.  ')' is given lower priority than\n everything else, including '(', effectively forcing a reduction of the\n-parenthesised expression.  If there is no matching '(', the expression\n-will be reduced to the beginning, the ')' pushed, and the reduction\n-pass forced by the next ')', or the end of the expression, will meet\n-it and output an appropriate error message.  */\n-\n-#define RIGHT_ASSOC               1\n-#define PREVENT_REDUCE_PRIO (0 << 1)\n-#define FORCE_REDUCE_PRIO   (1 << 1)\n-#define CLOSE_PAREN_PRIO    (2 << 1)\n-#define OPEN_PAREN_PRIO     (3 << 1)\n-#define COMMA_PRIO          (4 << 1)\n-#define COND_PRIO          ((5 << 1) + RIGHT_ASSOC)\n-#define COLON_PRIO          (6 << 1)\n-#define OROR_PRIO           (7 << 1)\n-#define ANDAND_PRIO         (8 << 1)\n-#define OR_PRIO             (9 << 1)\n-#define XOR_PRIO           (10 << 1)\n-#define AND_PRIO           (11 << 1)\n-#define EQUAL_PRIO         (12 << 1)\n-#define LESS_PRIO          (13 << 1)\n-#define SHIFT_PRIO         (14 << 1)\n-#define PLUS_PRIO          (15 << 1)\n-#define MUL_PRIO           (16 << 1)\n-#define UNARY_PRIO        ((17 << 1) + RIGHT_ASSOC)\n-\n-#define LEFT_OPERAND_REQUIRED 1\n-#define RIGHT_OPERAND_REQUIRED 2\n-#define HAVE_VALUE 4\n+parenthesised expression.  If there is no matching '(', the stack will\n+be reduced all the way to the beginning, exiting the parser in the\n+same way as the ultra-low priority end-of-expression dummy operator.\n+The exit code checks to see if the operator that caused it is ')', and\n+if so outputs an appropriate error message.\n+\n+The parser assumes all shifted operators require a right operand\n+unless the flag NO_R_OPERAND is set, and similarly for NO_L_OPERAND.\n+These semantics are automatically checked, any extra semantics need to\n+be handled with operator-specific code.  */\n+\n+#define FLAG_BITS  8\n+#define FLAG_MASK ((1 << FLAG_BITS) - 1)\n+#define PRIO_SHIFT (FLAG_BITS + 1)\n+#define EXTRACT_PRIO(cnst) (cnst >> FLAG_BITS)\n+#define EXTRACT_FLAGS(cnst) (cnst & FLAG_MASK)\n+\n+/* Flags.  */\n+#define HAVE_VALUE     (1 << 0)\n+#define NO_L_OPERAND   (1 << 1)\n+#define NO_R_OPERAND   (1 << 2)\n+#define SHORT_CIRCUIT  (1 << 3)\n+\n+/* Priority and flag combinations.  */\n+#define RIGHT_ASSOC         (1 << FLAG_BITS)\n+#define FORCE_REDUCE_PRIO   (0 << PRIO_SHIFT)\n+#define CLOSE_PAREN_PRIO    (1 << PRIO_SHIFT)\n+#define OPEN_PAREN_PRIO    ((2 << PRIO_SHIFT) | NO_L_OPERAND)\n+#define COMMA_PRIO          (3 << PRIO_SHIFT)\n+#define COND_PRIO          ((4 << PRIO_SHIFT) | RIGHT_ASSOC | SHORT_CIRCUIT)\n+#define COLON_PRIO         ((5 << PRIO_SHIFT) | SHORT_CIRCUIT)\n+#define OROR_PRIO          ((6 << PRIO_SHIFT) | SHORT_CIRCUIT)\n+#define ANDAND_PRIO        ((7 << PRIO_SHIFT) | SHORT_CIRCUIT)\n+#define OR_PRIO             (8 << PRIO_SHIFT)\n+#define XOR_PRIO            (9 << PRIO_SHIFT)\n+#define AND_PRIO           (10 << PRIO_SHIFT)\n+#define EQUAL_PRIO         (11 << PRIO_SHIFT)\n+#define LESS_PRIO          (12 << PRIO_SHIFT)\n+#define SHIFT_PRIO         (13 << PRIO_SHIFT)\n+#define PLUS_PRIO          (14 << PRIO_SHIFT)\n+#define MUL_PRIO           (15 << PRIO_SHIFT)\n+#define UNARY_PRIO        ((16 << PRIO_SHIFT) | RIGHT_ASSOC | NO_L_OPERAND)\n \n #define COMPARE(OP) \\\n-  top->unsignedp = 0;\\\n+  top->unsignedp = 0; \\\n   top->value = (unsigned1 || unsigned2) \\\n-  ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 : (v1 OP v2)\n+  ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 \\\n+  : (v1 OP v2)\n+#define EQUALITY(OP) \\\n+  top->value = v1 OP v2; \\\n+  top->unsignedp = 0;\n #define LOGICAL(OP) \\\n-\t      top->value = v1 OP v2;\\\n-\t      top->unsignedp = unsigned1 || unsigned2;\n+  top->value = v1 OP v2; \\\n+  top->unsignedp = unsigned1 || unsigned2;\n \n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n@@ -698,8 +718,8 @@ int\n _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n {\n-  /* The implementation is an operator precedence parser,\n-     i.e. a bottom-up parser, using a stack for not-yet-reduced tokens.\n+  /* The implementation is an operator precedence parser, i.e. a\n+     bottom-up parser, using a stack for not-yet-reduced tokens.\n \n      The stack base is 'stack', and the current stack pointer is 'top'.\n      There is a stack element for each operator (only),\n@@ -712,59 +732,60 @@ _cpp_parse_expr (pfile)\n   struct operation init_stack[INIT_STACK_SIZE];\n   struct operation *stack = init_stack;\n   struct operation *limit = stack + INIT_STACK_SIZE;\n-  register struct operation *top = stack;\n-  int skip_evaluation = 0;\n+  register struct operation *top = stack + 1;\n   long old_written = CPP_WRITTEN (pfile);\n+  int skip_evaluation = 0;\n   int result;\n \n   pfile->parsing_if_directive++;\n-  top->prio = PREVENT_REDUCE_PRIO;\n-  top->flags = 0;\n+  /* We've finished when we try to reduce this.  */\n+  top->op = FINISHED;\n+  /* Nifty way to catch missing '('.  */\n+  top->prio = EXTRACT_PRIO(CLOSE_PAREN_PRIO);\n+  /* Avoid missing right operand checks.  */\n+  top->flags = NO_R_OPERAND;\n+\n   for (;;)\n     {\n       unsigned int prio;\n+      unsigned int flags;\n       struct operation op;\n-      U_CHAR flags = 0;\n \n       /* Read a token */\n       op = lex (pfile, skip_evaluation);\n \n-      /* See if the token is an operand, in which case go to set_value.\n-\t If the token is an operator, figure out its left and right\n-\t priorities, and then goto maybe_reduce.  */\n-\n+      /* If the token is an operand, push its value and get next\n+\t token.  If it is an operator, get its priority and flags, and\n+\t try to reduce the expression on the stack.  */\n       switch (op.op)\n \t{\n \tcase NAME:\n \t  cpp_ice (pfile, \"lex returns a NAME\");\n-\t  goto syntax_error;\n \tcase ERROR:\n \t  goto syntax_error;\n \tdefault:\n \t  cpp_error (pfile, \"invalid character in #if\");\n \t  goto syntax_error;\n \n-\tcase INT:  case CHAR:\n+\tcase INT:\n+\tcase CHAR:\n \tpush_immediate:\n \t  /* Push a value onto the stack.  */\n \t  if (top->flags & HAVE_VALUE)\n \t    {\n-\t      cpp_error (pfile, \"suspected missing binary operator in #if\");\n+\t      cpp_error (pfile, \"missing binary operator\");\n \t      goto syntax_error;\n \t    }\n \t  top->value = op.value;\n \t  top->unsignedp = op.unsignedp;\n \t  top->flags |= HAVE_VALUE;\n \t  continue;\n \n-\tcase '+':  case '-':\n-\t  prio = PLUS_PRIO;\n-\t  if (top->flags & HAVE_VALUE)\n-\t      break;\n-\t  /* else fall through */\n-\tcase '!':  case '~':\n-\t  flags |= RIGHT_OPERAND_REQUIRED;\n-\t  prio = UNARY_PRIO;  goto maybe_reduce;\n+\tcase '+':\n+\tcase '-':    prio = PLUS_PRIO;  if (top->flags & HAVE_VALUE) break;\n+          /* else unary; fall through */\n+\tcase '!':\n+\tcase '~':    prio = UNARY_PRIO;  break;\n \n \tcase '*':\n \tcase '/':\n@@ -783,40 +804,41 @@ _cpp_parse_expr (pfile)\n \tcase ANDAND: prio = ANDAND_PRIO;  break;\n \tcase OROR:   prio = OROR_PRIO;  break;\n \tcase ',':    prio = COMMA_PRIO;  break;\n-\tcase '(':    prio = OPEN_PAREN_PRIO;  goto skip_reduction;\n-\tcase ')':\n-\t  prio = CLOSE_PAREN_PRIO;\n-\t  flags = HAVE_VALUE;\t/* At least, we will have after reduction.  */\n-\t  goto maybe_reduce;\n-        case ':':    prio = COLON_PRIO;  goto maybe_reduce;\n-        case '?':    prio = COND_PRIO;   goto maybe_reduce;\n-\tcase 0:      prio = FORCE_REDUCE_PRIO;  goto maybe_reduce;\n+\tcase '(':    prio = OPEN_PAREN_PRIO; break;\n+\tcase ')':    prio = CLOSE_PAREN_PRIO;  break;\n+        case ':':    prio = COLON_PRIO;  break;\n+        case '?':    prio = COND_PRIO;  break;\n+\tcase 0:      prio = FORCE_REDUCE_PRIO;  break;\n \t}\n \n-      /* Binary operation.  */\n-      flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n+      /* Separate the operator's code into priority and flags.  */\n+      flags = EXTRACT_FLAGS(prio);\n+      prio = EXTRACT_PRIO(prio);\n+      if (op.op == '(')\n+\tgoto skip_reduction;\n \n-    maybe_reduce:\n       /* Check for reductions.  Then push the operator.  */\n       while (prio <= top->prio)\n \t{\n-\t  HOST_WIDEST_INT v1 = top[-1].value, v2 = top[0].value;\n-\t  unsigned int unsigned1 = top[-1].unsignedp;\n-\t  unsigned int unsigned2 = top[0].unsignedp;\n-\t  top--;\n-\t  if ((top[1].flags & LEFT_OPERAND_REQUIRED)\n-\t      && ! (top[0].flags & HAVE_VALUE))\n-\t    {\n-\t      cpp_error (pfile, \"syntax error - missing left operand\");\n-\t      goto syntax_error;\n-\t    }\n-\t  if ((top[1].flags & RIGHT_OPERAND_REQUIRED)\n-\t      && ! (top[1].flags & HAVE_VALUE))\n+\t  HOST_WIDEST_INT v1, v2;\n+\t  unsigned int unsigned1, unsigned2;\n+\t  \n+\t  /* Most operators that can appear on the stack require a\n+\t     right operand.  Check this before trying to reduce.  */\n+\t  if ((top->flags & (HAVE_VALUE | NO_R_OPERAND)) == 0)\n \t    {\n-\t      cpp_error (pfile, \"syntax error - missing right operand\");\n+\t      if (top->op == '(')\n+\t\tcpp_error (pfile, \"void expression between '(' and ')'\");\n+\t      else\n+\t\tcpp_error (pfile, \"operator has no right operand\");\n \t      goto syntax_error;\n \t    }\n-\t  /* top[0].value = (top[1].op)(v1, v2);*/\n+\n+\t  unsigned2 = top->unsignedp, v2 = top->value;\n+\t  top--;\n+\t  unsigned1 = top->unsignedp, v1 = top->value;\n+\n+\t  /* Now set top->value = (top[1].op)(v1, v2); */\n \t  switch (top[1].op)\n \t    {\n \t    case '+':\n@@ -839,7 +861,8 @@ _cpp_parse_expr (pfile)\n \t      if (!(top->flags & HAVE_VALUE))\n \t\t{ /* Unary '-' */\n \t\t  top->value = - v2;\n-\t\t  if (!skip_evaluation && (top->value & v2) < 0 && !unsigned2)\n+\t\t  if (!skip_evaluation && (top->value & v2) < 0\n+\t\t      && !unsigned2)\n \t\t    integer_overflow (pfile);\n \t\t  top->unsignedp = unsigned2;\n \t\t  top->flags |= HAVE_VALUE;\n@@ -860,13 +883,13 @@ _cpp_parse_expr (pfile)\n \t      else if (!skip_evaluation)\n \t\t{\n \t\t  top->value = v1 * v2;\n-\t\t  if (v1\n-\t\t      && (top->value / v1 != v2\n-\t\t\t  || (top->value & v1 & v2) < 0))\n+\t\t  if (v1 && (top->value / v1 != v2\n+\t\t             || (top->value & v1 & v2) < 0))\n \t\t    integer_overflow (pfile);\n \t\t}\n \t      break;\n \t    case '/':\n+\t    case '%':\n \t      if (skip_evaluation)\n \t\tbreak;\n \t      if (v2 == 0)\n@@ -875,61 +898,41 @@ _cpp_parse_expr (pfile)\n \t\t  v2 = 1;\n \t\t}\n \t      top->unsignedp = unsigned1 || unsigned2;\n-\t      if (top->unsignedp)\n-\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 / v2;\n-\t      else\n+\t      if (top[1].op == '/')\n \t\t{\n-\t\t  top->value = v1 / v2;\n-\t\t  if ((top->value & v1 & v2) < 0)\n-\t\t    integer_overflow (pfile);\n+\t\t  if (top->unsignedp)\n+\t\t    top->value = (unsigned HOST_WIDEST_INT) v1 / v2;\n+\t\t  else\n+\t\t    {\n+\t\t      top->value = v1 / v2;\n+\t\t      if ((top->value & v1 & v2) < 0)\n+\t\t\tinteger_overflow (pfile);\n+\t\t    }\n \t\t}\n-\t      break;\n-\t    case '%':\n-\t      if (skip_evaluation)\n-\t\tbreak;\n-\t      if (v2 == 0)\n+\t      else\n \t\t{\n-\t\t  cpp_error (pfile, \"division by zero in #if\");\n-\t\t  v2 = 1;\n+\t\t  if (top->unsignedp)\n+\t\t    top->value = (unsigned HOST_WIDEST_INT) v1 % v2;\n+\t\t  else\n+\t\t    top->value = v1 % v2;\n \t\t}\n-\t      top->unsignedp = unsigned1 || unsigned2;\n-\t      if (top->unsignedp)\n-\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 % v2;\n-\t      else\n-\t\ttop->value = v1 % v2;\n \t      break;\n \t    case '!':\n-\t      if (top->flags & HAVE_VALUE)\n-\t\t{\n-\t\t  cpp_error (pfile, \"syntax error\");\n-\t\t  goto syntax_error;\n-\t\t}\n \t      top->value = ! v2;\n \t      top->unsignedp = 0;\n \t      top->flags |= HAVE_VALUE;\n \t      break;\n \t    case '~':\n-\t      if (top->flags & HAVE_VALUE)\n-\t\t{\n-\t\t  cpp_error (pfile, \"syntax error\");\n-\t\t  goto syntax_error;\n-\t\t}\n \t      top->value = ~ v2;\n \t      top->unsignedp = unsigned2;\n \t      top->flags |= HAVE_VALUE;\n \t      break;\n \t    case '<':  COMPARE(<);  break;\n \t    case '>':  COMPARE(>);  break;\n-\t    case LEQ:  COMPARE(<=); break;\n-\t    case GEQ:  COMPARE(>=); break;\n-\t    case EQUAL:\n-\t      top->value = (v1 == v2);\n-\t      top->unsignedp = 0;\n-\t      break;\n-\t    case NOTEQUAL:\n-\t      top->value = (v1 != v2);\n-\t      top->unsignedp = 0;\n-\t      break;\n+\t    case LEQ:  COMPARE(<=);  break;\n+\t    case GEQ:  COMPARE(>=);  break;\n+\t    case EQUAL:    EQUALITY(==);  break;\n+\t    case NOTEQUAL: EQUALITY(!=);  break;\n \t    case LSH:\n \t      if (skip_evaluation)\n \t\tbreak;\n@@ -975,51 +978,63 @@ _cpp_parse_expr (pfile)\n \t\t\t     \"syntax error ':' without preceding '?'\");\n \t\t  goto syntax_error;\n \t\t}\n-\t      else if (! (top[1].flags & HAVE_VALUE)\n-\t\t       || !(top[-1].flags & HAVE_VALUE)\n-\t\t       || !(top[0].flags & HAVE_VALUE))\n-\t\t{\n-\t\t  cpp_error (pfile, \"bad syntax for ?: operator\");\n-\t\t  goto syntax_error;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  top--;\n-\t\t  if (top->value) skip_evaluation--;\n-\t\t  top->value = top->value ? v1 : v2;\n-\t\t  top->unsignedp = unsigned1 || unsigned2;\n-\t\t}\n+\t      top--;\n+\t      if (top->value) skip_evaluation--;\n+\t      top->value = top->value ? v1 : v2;\n+\t      top->unsignedp = unsigned1 || unsigned2;\n \t      break;\n-\t    case ')':\n-\t      cpp_error (pfile, \"missing '(' in expression\");\n-\t      goto syntax_error;\n \t    case '(':\n \t      if (op.op != ')')\n \t\t{\n \t\t  cpp_error (pfile, \"missing ')' in expression\");\n \t\t  goto syntax_error;\n \t\t}\n-\t      if (!(top[1].flags & HAVE_VALUE))\n-\t\t{\n-\t\t  cpp_error (pfile, \"void expression between '(' and ')'\");\n-\t\t  goto syntax_error;\n-\t\t}\n \t      op.value = v2;\n \t      op.unsignedp = unsigned2;\n \t      goto push_immediate;\n \t    default:\n \t      if (ISGRAPH (top[1].op))\n-\t\tcpp_error (pfile, \"unimplemented operator '%c'\\n\", top[1].op);\n+\t\tcpp_error (pfile, \"unimplemented operator '%c'\", top[1].op);\n \t      else\n-\t\tcpp_error (pfile, \"unimplemented operator '\\\\%03o'\\n\",\n+\t\tcpp_error (pfile, \"unimplemented operator '\\\\%03o'\",\n \t\t\t   top[1].op);\n+\t      break;\n+\t    case FINISHED:\n+\t      /* Reducing this dummy operator indicates we've finished.  */\n+\t      if (op.op == ')')\n+\t\t{\n+\t\t  cpp_error (pfile, \"missing '(' in expression\");\n+\t\t  goto syntax_error;\n+\t\t}\n+\t      goto done;\n \t    }\n \t}\n \n-      if (op.op == 0)\n-\tbreak;\n+      /* Handle short-circuit evaluations.  */\n+      if (flags & SHORT_CIRCUIT)\n+\tswitch (op.op)\n+\t  {\n+\t  case OROR:    if (top->value) skip_evaluation++; break;\n+\t  case ANDAND:\n+\t  case '?':     if (!top->value) skip_evaluation++; break;\n+\t  case ':':\n+\t    if (top[-1].value) /* Was '?' condition true?  */\n+\t      skip_evaluation++;\n+\t    else\n+\t      skip_evaluation--;\n+\t  }\n \n     skip_reduction:\n+      /* Check we have a left operand iff we need one.  */\n+      if (((flags & NO_L_OPERAND) != 0) ^ ((top->flags & HAVE_VALUE) == 0))\n+\t{\n+\t  if (flags & NO_L_OPERAND)\n+\t    cpp_error (pfile, \"missing binary operator\");\n+\t  else\n+\t    cpp_error (pfile, \"operator has no left operand\");\n+\t  goto syntax_error;\n+\t}\n+\n       /* Check for and handle stack overflow.  */\n       top++;\n       if (top == limit)\n@@ -1040,40 +1055,29 @@ _cpp_parse_expr (pfile)\n \t}\n       \n       top->flags = flags;\n-      top->prio = prio & ~RIGHT_ASSOC;\n+      top->prio = prio & ~EXTRACT_PRIO(RIGHT_ASSOC);\n       top->op = op.op;\n-\n-      /* Handle short circuiting.  */\n-      if ((op.op == OROR && top[-1].value)\n-\t  || (op.op == ANDAND && !top[-1].value)\n-\t  || (op.op == '?' && !top[-1].value))\n-\t{\n-\t  skip_evaluation++;\n-\t}\n-      else if (op.op == ':')\n-\t{\n-\t  if (top[-2].value) /* Was condition true? */\n-\t    skip_evaluation++;\n-\t  else\n-\t    skip_evaluation--;\n-\t}\n     }\n \n+ done:\n+  result = (top[1].value != 0);\n   if (top != stack)\n-    cpp_ice (pfile, \"unbalanced stack in #if expression\");\n-  if (!(top->flags & HAVE_VALUE))\n-    cpp_error (pfile, \"#if with no expression\");\n-  result = (top->value != 0);\n+    {\n+      cpp_ice (pfile, \"unbalanced stack in #if expression\");\n+      goto syntax_error;\n+    }\n+  else if (!(top[1].flags & HAVE_VALUE))\n+    {\n+      cpp_error (pfile, \"#if with no expression\");\n+    syntax_error:\n+      _cpp_skip_rest_of_line (pfile);\n+      result = 0;  /* Return 0 on syntax error.  */\n+    }\n \n- tidy_up:\n-  pfile->parsing_if_directive--;\n-  CPP_SET_WRITTEN (pfile, old_written);\n+  /* Free dynamic stack if we allocated one.  */\n   if (stack != init_stack)\n     free (stack);\n+  pfile->parsing_if_directive--;\n+  CPP_SET_WRITTEN (pfile, old_written);\n   return result;\n-\n- syntax_error:\n-  _cpp_skip_rest_of_line (pfile);\n-  result = 0;\n-  goto tidy_up;\n }"}]}