{"sha": "2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNhMzk2MjA4Y2IzNWEzYWNiOGQwNDQyNGI0MGI5YTIzZDY1ZmNkMQ==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-12-23T04:53:48Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-12-23T04:53:48Z"}, "message": "re PR target/18511 (cc1plus segfaults when compiling libstdc++-v3/src/localename.cc)\n\n\tPR target/18511\n\t* reload1.c (emit_output_reload_insns): Check if OLD is a hard\n\tregister before calling regno_clobbered_p.\n\t* reload.c: Update comment for regno_clobbered_p.\n\nFrom-SVN: r92531", "tree": {"sha": "b2c906a5834e8a57edba5eff762f36253c809198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2c906a5834e8a57edba5eff762f36253c809198"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/comments", "author": null, "committer": null, "parents": [{"sha": "a5370cf0e6274ed7a4c75327761ceb88b9eeb2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5370cf0e6274ed7a4c75327761ceb88b9eeb2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5370cf0e6274ed7a4c75327761ceb88b9eeb2ab"}], "stats": {"total": 13, "additions": 11, "deletions": 2}, "files": [{"sha": "97fed21b855c4a85ebd454453e45f7d3af5da33f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "patch": "@@ -1,3 +1,10 @@\n+2004-12-23  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/18511\n+\t* reload1.c (emit_output_reload_insns): Check if OLD is a hard\n+\tregister before calling regno_clobbered_p.\n+\t* reload.c: Update comment for regno_clobbered_p.\n+\n 2004-12-22  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (override_options): Respect user disable of"}, {"sha": "9c0836a53b7114c6740aa2f471236bcdfe9fb4c4", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "patch": "@@ -6940,7 +6940,8 @@ find_inc_amount (rtx x, rtx inced)\n }\n \f\n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.\n-   If SETS is nonzero, also consider SETs.  */\n+   If SETS is nonzero, also consider SETs.  REGNO must refer to a hard\n+   register.  */\n \n int\n regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,"}, {"sha": "1fec0cdcc43b12a739947ff1bf6aa4e2fc4fbc76", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca396208cb35a3acb8d04424b40b9a23d65fcd1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2ca396208cb35a3acb8d04424b40b9a23d65fcd1", "patch": "@@ -6705,7 +6705,8 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t  || !(set = single_set (insn))\n \t  || rtx_equal_p (old, SET_DEST (set))\n \t  || !reg_mentioned_p (old, SET_SRC (set))\n-\t  || !regno_clobbered_p (REGNO (old), insn, rl->mode, 0))\n+\t  || !((REGNO (old) < FIRST_PSEUDO_REGISTER)\n+\t       && regno_clobbered_p (REGNO (old), insn, rl->mode, 0)))\n \tgen_reload (old, reloadreg, rl->opnum,\n \t\t    rl->when_needed);\n     }"}]}