{"sha": "b78d48ddc2033b298e199c970e6fb465e288a317", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4ZDQ4ZGRjMjAzM2IyOThlMTk5Yzk3MGU2ZmI0NjVlMjg4YTMxNw==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2003-10-31T15:50:49Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2003-10-31T15:50:49Z"}, "message": "rs6000.c (rs6000_mixed_function_arg): New.\n\n2003-10-31  Fariborz Jahanian  <fjahanian@apple.com>\n            David Edelsohn  <edelsohn@gnu.org>\n\n        * config/rs6000/rs6000.c (rs6000_mixed_function_arg): New.\n        (function_arg): Call it.\n        (rs6000_function_value): Widen integral return value to mode based\n        on TARGET_32BIT, not word_mode.\n        * config/rs6000/rs6000.h (PROMOTE_MODE): Likewise.\n\nCo-Authored-By: David Edelsohn <edelsohn@gnu.org>\n\nFrom-SVN: r73151", "tree": {"sha": "4710c3c4ee9d5e8de576ca6d8fdee3ea1ec01806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4710c3c4ee9d5e8de576ca6d8fdee3ea1ec01806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b78d48ddc2033b298e199c970e6fb465e288a317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78d48ddc2033b298e199c970e6fb465e288a317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78d48ddc2033b298e199c970e6fb465e288a317", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78d48ddc2033b298e199c970e6fb465e288a317/comments", "author": null, "committer": null, "parents": [{"sha": "3dc5f34a79fcc27557f1dcb0c142f487c009fe23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc5f34a79fcc27557f1dcb0c142f487c009fe23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dc5f34a79fcc27557f1dcb0c142f487c009fe23"}], "stats": {"total": 214, "additions": 128, "deletions": 86}, "files": [{"sha": "4b0602206d90c9fff83824864d035979f769d41d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78d48ddc2033b298e199c970e6fb465e288a317/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78d48ddc2033b298e199c970e6fb465e288a317/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b78d48ddc2033b298e199c970e6fb465e288a317", "patch": "@@ -1,3 +1,12 @@\n+2003-10-31  Fariborz Jahanian  <fjahanian@apple.com>\n+\t    David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): New.\n+\t(function_arg): Call it.\n+\t(rs6000_function_value): Widen integral return value to mode based\n+\ton TARGET_32BIT, not word_mode.\n+\t* config/rs6000/rs6000.h (PROMOTE_MODE): Likewise.\n+\n 2003-10-31  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* .cvsignore: No longer ignore gengtype-lex.c, gengtype-yacc.c,"}, {"sha": "4297314ae1b3676e9d25ff542a8368543be2e2bd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 118, "deletions": 85, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78d48ddc2033b298e199c970e6fb465e288a317/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78d48ddc2033b298e199c970e6fb465e288a317/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b78d48ddc2033b298e199c970e6fb465e288a317", "patch": "@@ -347,6 +347,8 @@ static int rs6000_get_some_local_dynamic_name_1 (rtx *, void *);\n static rtx rs6000_complex_function_value (enum machine_mode);\n static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree);\n+static rtx rs6000_mixed_function_arg (CUMULATIVE_ARGS *,\n+\t\t\t\t      enum machine_mode, tree, int);\n static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree,\n \t\t\t\t    int *, int);\n@@ -3211,7 +3213,7 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n \t  || (ud4 == 0 && ud3 == 0 && ud2 == 0 && ! (ud1 & 0x8000)))\n \t{\n \t  if (ud1 & 0x8000)\n-\t    emit_move_insn (dest, GEN_INT (((ud1  ^ 0x8000) -  0x8000)));\n+\t    emit_move_insn (dest, GEN_INT (((ud1 ^ 0x8000) -  0x8000)));\n \t  else\n \t    emit_move_insn (dest, GEN_INT (ud1));\n \t}\n@@ -3894,6 +3896,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n /* Determine where to put a SIMD argument on the SPE.  */\n+\n static rtx\n rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n \t\t\t tree type)\n@@ -3919,17 +3922,121 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r2));\n \t}\n       else\n-\treturn NULL;\n+\treturn NULL_RTX;\n     }\n   else\n     {\n       if (cum->sysv_gregno <= GP_ARG_MAX_REG)\n \treturn gen_rtx_REG (mode, cum->sysv_gregno);\n       else\n-\treturn NULL;\n+\treturn NULL_RTX;\n     }\n }\n \n+/* Determine where to place an argument in 64-bit mode with 32-bit ABI.  */\n+\n+static rtx\n+rs6000_mixed_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+\t\t\t   tree type, int align_words)\n+{\n+  if (mode == DFmode)\n+    {\n+      /* -mpowerpc64 with 32bit ABI splits up a DFmode argument\n+\t in vararg list into zero, one or two GPRs */\n+      if (align_words >= GP_ARG_NUM_REG)\n+\treturn gen_rtx_PARALLEL (DFmode,\n+\t\t gen_rtvec (2,\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       NULL_RTX, const0_rtx), \n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (mode,\n+\t\t\t\t\t\t\t    cum->fregno),\n+\t\t\t\t\t       const0_rtx)));\n+      else if (align_words + RS6000_ARG_SIZE (mode, type)\n+\t       > GP_ARG_NUM_REG)\n+\t/* If this is partially on the stack, then we only\n+\t   include the portion actually in registers here. */\n+\treturn gen_rtx_PARALLEL (DFmode,\n+\t\t gen_rtvec (2,   \n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t    GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t    + align_words),\n+\t\t\t\t\t       const0_rtx),\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (mode,\n+\t\t\t\t\t\t\t    cum->fregno),\n+\t\t\t\t\t       const0_rtx)));\n+\n+      /* split a DFmode arg into two GPRs */\n+      return gen_rtx_PARALLEL (DFmode,\n+\t       gen_rtvec (3,\n+\t\t\t  gen_rtx_EXPR_LIST (VOIDmode,       \n+\t\t\t\t\t     gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t  GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t  + align_words),\n+\t\t\t\t\t     const0_rtx),\n+\t\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t     gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t  GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t  + align_words + 1),\n+\t\t\t\t\t     GEN_INT (4)),\n+\t\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t     gen_rtx_REG (mode, cum->fregno),\n+\t\t\t\t\t     const0_rtx)));\n+    }\n+  /* -mpowerpc64 with 32bit ABI splits up a DImode argument into one\n+     or two GPRs */\n+  else if (mode == DImode)\n+    {\n+      if (align_words < GP_ARG_NUM_REG - 1)\n+\treturn gen_rtx_PARALLEL (DImode,\n+\t\t gen_rtvec (2,\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t    GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t    + align_words),\n+\t\t\t\t\t       const0_rtx),\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t    GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t    + align_words + 1),\n+\t\t\t\t\t       GEN_INT (4))));\n+      else if (align_words == GP_ARG_NUM_REG - 1)\n+\t  return gen_rtx_PARALLEL (DImode,\n+\t\t   gen_rtvec (2,\n+\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t NULL_RTX, const0_rtx),\n+\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t      GP_ARG_MIN_REG\n+\t\t\t\t\t\t\t      + align_words),\n+\t\t\t\t\t\t const0_rtx)));\n+    }\n+  else if (mode == BLKmode && align_words <= (GP_ARG_NUM_REG - 1))\n+    {\n+      int k;\n+      int size = int_size_in_bytes (type);\n+      int no_units = size / 4;\n+      int max_no_words = GP_ARG_NUM_REG - align_words;\n+      int rtlvec_len = no_units < max_no_words ? no_units : max_no_words;\n+      rtx *rtlvec = (rtx *) alloca (rtlvec_len * sizeof (rtx));\n+\n+      memset ((char *) rtlvec, 0, rtlvec_len * sizeof (rtx));\n+\n+      for (k=0; k < rtlvec_len; k++)\n+\trtlvec[k] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t       gen_rtx_REG (SImode,\n+\t\t\t\t\t\t    GP_ARG_MIN_REG\n+\t\t\t\t\t\t    + align_words + k),\n+\t\t\t\t       k == 0 ? const0_rtx : GEN_INT (k*4));\n+\n+      return gen_rtx_PARALLEL (BLKmode, gen_rtvec_v (k, rtlvec));\n+  }\n+\n+  return NULL_RTX;\n+}\n+\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -4029,7 +4136,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  if (cum->fregno <= FP_ARG_V4_MAX_REG)\n \t    return gen_rtx_REG (mode, cum->fregno);\n \t  else\n-\t    return NULL;\n+\t    return NULL_RTX;\n \t}\n       else\n \t{\n@@ -4051,7 +4158,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  if (gregno + n_words - 1 <= GP_ARG_MAX_REG)\n \t    return gen_rtx_REG (mode, gregno);\n \t  else\n-\t    return NULL;\n+\t    return NULL_RTX;\n \t}\n     }\n   else\n@@ -4063,6 +4170,10 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n         return NULL_RTX;\n \n+      if (TARGET_32BIT && TARGET_POWERPC64\n+\t  && (mode == DFmode || mode == DImode || mode == BLKmode))\n+\treturn rs6000_mixed_function_arg (cum, mode, type, align_words);\n+\n       if (USE_FP_FOR_ARG_P (*cum, mode, type))\n \t{\n \t  if (! type\n@@ -4075,53 +4186,6 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t      || (align_words < GP_ARG_NUM_REG))))\n \t    return gen_rtx_REG (mode, cum->fregno);\n \n-\t  if (TARGET_32BIT && TARGET_POWERPC64 && mode == DFmode)\n-\t    {\n-              /* -mpowerpc64 with 32bit ABI splits up a DFmode argument\n-\t\t in vararg list into zero, one or two GPRs */\n-\t      if (align_words >= GP_ARG_NUM_REG)\n-\t\treturn gen_rtx_PARALLEL (DFmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\tNULL_RTX, const0_rtx), \n-\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\tgen_rtx_REG (mode,\n-\t\t\t\t\t\t\t     cum->fregno),\n-\t\t\t\t\t\tconst0_rtx)));\n-\t      else if (align_words + RS6000_ARG_SIZE (mode, type)\n-\t\t       > GP_ARG_NUM_REG)\n-\t\t/* If this is partially on the stack, then we only\n-\t\t   include the portion actually in registers here. */\n-\t\treturn gen_rtx_PARALLEL (DFmode,\n-\t\t  gen_rtvec (2,   \n-\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\tgen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t     GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t     + align_words),\n-\t\t\t\t\t\tconst0_rtx),\n-\t\t\t     gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\tgen_rtx_REG (mode,\n-\t\t\t\t\t\t\t     cum->fregno),\n-\t\t\t\t\t\tconst0_rtx)));\n-\n-\t      /* split a DFmode arg into two GPRs */\n-\t      return gen_rtx_PARALLEL (DFmode,\n-\t\tgen_rtvec (3,\n-\t\t\t   gen_rtx_EXPR_LIST (VOIDmode,       \n-\t\t\t\t\t      gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t   GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t   + align_words),\n-\t\t\t\t\t      const0_rtx),\n-\t\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t      gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t   GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t   + align_words + 1),\n-\t\t\t\t\t      GEN_INT (4)),\n-\t\t\t   gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t      gen_rtx_REG (mode, cum->fregno),\n-\t\t\t\t\t      const0_rtx)));\n-            }\n-\n           return gen_rtx_PARALLEL (mode,\n \t    gen_rtvec (2,\n \t\t       gen_rtx_EXPR_LIST (VOIDmode,\n@@ -4142,37 +4206,6 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\tgen_rtx_REG (mode, cum->fregno),\n \t\t\t\tconst0_rtx)));\n \t}\n-      /* -mpowerpc64 with 32bit ABI splits up a DImode argument into one\n-\t or two GPRs */\n-      else if (TARGET_32BIT && TARGET_POWERPC64 && mode == DImode\n-\t       && align_words < GP_ARG_NUM_REG - 1)\n-\t{\n-\t  return gen_rtx_PARALLEL (DImode,\n-\t    gen_rtvec (2,\n-\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (SImode,\n-\t\t\t\t\t\t       GP_ARG_MIN_REG\n-\t\t\t\t\t\t       + align_words),\n-\t\t\t\t\t  const0_rtx),\n-\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (SImode,\n-\t\t\t\t\t\t       GP_ARG_MIN_REG\n-\t\t\t\t\t\t       + align_words + 1),\n-\t\t\t\t\t  GEN_INT (4))));\n-\t}\n-      else if (TARGET_32BIT && TARGET_POWERPC64 && mode == DImode\n-\t       && align_words == GP_ARG_NUM_REG - 1)\n-\t{\n-\t  return gen_rtx_PARALLEL (DImode,\n-\t    gen_rtvec (2,\n-\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t  NULL_RTX, const0_rtx),\n-\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (SImode,\n-\t\t\t\t\t\t       GP_ARG_MIN_REG\n-\t\t\t\t\t\t       + align_words),\n-\t\t\t\t\t  const0_rtx)));\n-\t}\n       else if (align_words < GP_ARG_NUM_REG)\n \treturn gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n       else\n@@ -11365,7 +11398,7 @@ rs6000_emit_prologue (void)\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n   rtx frame_ptr_rtx = gen_rtx_REG (Pmode, 12);\n   rtx frame_reg_rtx = sp_reg_rtx;\n-  rtx cr_save_rtx = NULL;\n+  rtx cr_save_rtx = NULL_RTX;\n   rtx insn;\n   int saving_FPRs_inline;\n   int using_store_multiple;\n@@ -15456,7 +15489,7 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   if ((INTEGRAL_TYPE_P (valtype)\n        && TYPE_PRECISION (valtype) < BITS_PER_WORD)\n       || POINTER_TYPE_P (valtype))\n-    mode = word_mode;\n+    mode = TARGET_32BIT ? SImode : DImode;\n   else\n     mode = TYPE_MODE (valtype);\n "}, {"sha": "e36c6c1b13b793a1902f81d5df06f90f4da3684a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78d48ddc2033b298e199c970e6fb465e288a317/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78d48ddc2033b298e199c970e6fb465e288a317/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b78d48ddc2033b298e199c970e6fb465e288a317", "patch": "@@ -604,7 +604,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n       && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n-    (MODE) = word_mode;\n+    (MODE) = TARGET_32BIT ? SImode : DImode;\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */"}]}