{"sha": "0b07a57e8cd8f14480f00da041212a84f1b3ab30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIwN2E1N2U4Y2Q4ZjE0NDgwZjAwZGEwNDEyMTJhODRmMWIzYWIzMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2012-09-18T14:31:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-09-18T14:31:38Z"}, "message": "* c-ada-spec.c: Style fixes.\n\nFrom-SVN: r191428", "tree": {"sha": "d61c88ae8fc8e8db3b61c650f4ff2e87446a5780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d61c88ae8fc8e8db3b61c650f4ff2e87446a5780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b07a57e8cd8f14480f00da041212a84f1b3ab30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b07a57e8cd8f14480f00da041212a84f1b3ab30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b07a57e8cd8f14480f00da041212a84f1b3ab30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b07a57e8cd8f14480f00da041212a84f1b3ab30/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da5182be67bc33df9c1159856ccddeb159dc5a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da5182be67bc33df9c1159856ccddeb159dc5a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da5182be67bc33df9c1159856ccddeb159dc5a24"}], "stats": {"total": 180, "additions": 92, "deletions": 88}, "files": [{"sha": "7221f160222a733ad3ea7ce4c369af541980d286", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b07a57e8cd8f14480f00da041212a84f1b3ab30/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b07a57e8cd8f14480f00da041212a84f1b3ab30/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0b07a57e8cd8f14480f00da041212a84f1b3ab30", "patch": "@@ -1,3 +1,7 @@\n+2012-09-18 Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* c-ada-spec.c: Style fixes.\n+\n 2012-09-18 Thomas Quinot  <quinot@adacore.com>\n \n \t* c.opt (-fada-spec-parent): Define new command line switch."}, {"sha": "e7225162e4b34789b3ee9fe182c8b9e653af3739", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b07a57e8cd8f14480f00da041212a84f1b3ab30/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b07a57e8cd8f14480f00da041212a84f1b3ab30/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=0b07a57e8cd8f14480f00da041212a84f1b3ab30", "patch": "@@ -130,7 +130,7 @@ print_ada_macros (pretty_printer *pp, cpp_hashnode **macros, int max_ada_macros)\n \n   for (j = 0; j < max_ada_macros; j++)\n     {\n-      cpp_hashnode *node = macros [j];\n+      cpp_hashnode *node = macros[j];\n       const cpp_macro *macro = node->value.macro;\n       unsigned i;\n       int supported = 1, prev_is_one = 0, buffer_len, param_len;\n@@ -345,10 +345,10 @@ print_ada_macros (pretty_printer *pp, cpp_hashnode **macros, int max_ada_macros)\n \n \t  pp_string (pp, \"   --  arg-macro: \");\n \n-\t  if (*start == '(' && buffer [-1] == ')')\n+\t  if (*start == '(' && buffer[-1] == ')')\n \t    {\n \t      start++;\n-\t      buffer [-1] = '\\0';\n+\t      buffer[-1] = '\\0';\n \t      is_function = 1;\n \t      pp_string (pp, \"function \");\n \t    }\n@@ -595,7 +595,7 @@ collect_ada_nodes (tree t, const char *source_file)\n   for (n = t; n; n = TREE_CHAIN (n))\n     if (!DECL_IS_BUILTIN (n)\n \t&& LOCATION_FILE (decl_sloc (n, false)) == source_file)\n-      to_dump [i++] = n;\n+      to_dump[i++] = n;\n }\n \n /* Call back for walk_tree to clear the TREE_VISITED flag of TP.  */\n@@ -763,16 +763,16 @@ append_withs (const char *s, int limited_access)\n     }\n \n   for (i = 0; i < with_len; i++)\n-    if (!strcmp (s, withs [i].s)\n-\t&& source_file_base == withs [i].in_file)\n+    if (!strcmp (s, withs[i].s)\n+\t&& source_file_base == withs[i].in_file)\n       {\n-\twiths [i].limited &= limited_access;\n+\twiths[i].limited &= limited_access;\n \treturn;\n       }\n \n-  withs [with_len].s = xstrdup (s);\n-  withs [with_len].in_file = source_file_base;\n-  withs [with_len].limited = limited_access;\n+  withs[with_len].s = xstrdup (s);\n+  withs[with_len].in_file = source_file_base;\n+  withs[with_len].limited = limited_access;\n   with_len++;\n }\n \n@@ -787,7 +787,7 @@ reset_ada_withs (void)\n     return;\n \n   for (i = 0; i < with_len; i++)\n-    free (withs [i].s);\n+    free (withs[i].s);\n   free (withs);\n   withs = NULL;\n   withs_max = 4096;\n@@ -805,7 +805,7 @@ dump_ada_withs (FILE *f)\n \n   for (i = 0; i < with_len; i++)\n     fprintf\n-      (f, \"%swith %s;\\n\", withs [i].limited ? \"limited \" : \"\", withs [i].s);\n+      (f, \"%swith %s;\\n\", withs[i].limited ? \"limited \" : \"\", withs[i].s);\n }\n \n /* Return suitable Ada package name from FILE.  */\n@@ -840,7 +840,7 @@ get_ada_package (const char *file)\n     switch (*base)\n       {\n \tcase '+':\n-\t  res [i] = 'p';\n+\t  res[i] = 'p';\n \t  break;\n \n \tcase '.':\n@@ -970,8 +970,8 @@ to_ada_name (const char *name, int *space_found)\n   for (names = ada_reserved; *names; names++)\n     if (!strcasecmp (name, *names))\n       {\n-\ts [len2++] = 'c';\n-\ts [len2++] = '_';\n+\ts[len2++] = 'c';\n+\ts[len2++] = '_';\n \tfound = true;\n \tbreak;\n       }\n@@ -981,81 +981,81 @@ to_ada_name (const char *name, int *space_found)\n     for (names = c_duplicates; *names; names++)\n       if (!strcmp (name, *names))\n \t{\n-\t  s [len2++] = 'c';\n-\t  s [len2++] = '_';\n+\t  s[len2++] = 'c';\n+\t  s[len2++] = '_';\n \t  found = true;\n \t  break;\n \t}\n \n-  for (j = 0; name [j] == '_'; j++)\n-    s [len2++] = 'u';\n+  for (j = 0; name[j] == '_'; j++)\n+    s[len2++] = 'u';\n \n   if (j > 0)\n-    s [len2++] = '_';\n+    s[len2++] = '_';\n   else if (*name == '.' || *name == '$')\n     {\n-      s [0] = 'a';\n-      s [1] = 'n';\n-      s [2] = 'o';\n-      s [3] = 'n';\n+      s[0] = 'a';\n+      s[1] = 'n';\n+      s[2] = 'o';\n+      s[3] = 'n';\n       len2 = 4;\n       j++;\n     }\n \n   /* Replace unsuitable characters for Ada identifiers.  */\n \n   for (; j < len; j++)\n-    switch (name [j])\n+    switch (name[j])\n       {\n \tcase ' ':\n \t  if (space_found)\n \t    *space_found = true;\n-\t  s [len2++] = '_';\n+\t  s[len2++] = '_';\n \t  break;\n \n \t/* ??? missing some C++ operators.  */\n \tcase '=':\n-\t  s [len2++] = '_';\n+\t  s[len2++] = '_';\n \n-\t  if (name [j + 1] == '=')\n+\t  if (name[j + 1] == '=')\n \t    {\n \t      j++;\n-\t      s [len2++] = 'e';\n-\t      s [len2++] = 'q';\n+\t      s[len2++] = 'e';\n+\t      s[len2++] = 'q';\n \t    }\n \t  else\n \t    {\n-\t      s [len2++] = 'a';\n-\t      s [len2++] = 's';\n+\t      s[len2++] = 'a';\n+\t      s[len2++] = 's';\n \t    }\n \t  break;\n \n \tcase '!':\n-\t  s [len2++] = '_';\n-\t  if (name [j + 1] == '=')\n+\t  s[len2++] = '_';\n+\t  if (name[j + 1] == '=')\n \t    {\n \t      j++;\n-\t      s [len2++] = 'n';\n-\t      s [len2++] = 'e';\n+\t      s[len2++] = 'n';\n+\t      s[len2++] = 'e';\n \t    }\n \t  break;\n \n \tcase '~':\n-\t  s [len2++] = '_';\n-\t  s [len2++] = 't';\n-\t  s [len2++] = 'i';\n+\t  s[len2++] = '_';\n+\t  s[len2++] = 't';\n+\t  s[len2++] = 'i';\n \t  break;\n \n \tcase '&':\n \tcase '|':\n \tcase '^':\n-\t  s [len2++] = '_';\n-\t  s [len2++] = name [j] == '&' ? 'a' : name [j] == '|' ? 'o' : 'x';\n+\t  s[len2++] = '_';\n+\t  s[len2++] = name[j] == '&' ? 'a' : name[j] == '|' ? 'o' : 'x';\n \n-\t  if (name [j + 1] == '=')\n+\t  if (name[j + 1] == '=')\n \t    {\n \t      j++;\n-\t      s [len2++] = 'e';\n+\t      s[len2++] = 'e';\n \t    }\n \t  break;\n \n@@ -1065,101 +1065,101 @@ to_ada_name (const char *name, int *space_found)\n \tcase '/':\n \tcase '(':\n \tcase '[':\n-\t  if (s [len2 - 1] != '_')\n-\t    s [len2++] = '_';\n+\t  if (s[len2 - 1] != '_')\n+\t    s[len2++] = '_';\n \n-\t  switch (name [j + 1]) {\n+\t  switch (name[j + 1]) {\n \t    case '\\0':\n \t      j++;\n-\t      switch (name [j - 1]) {\n-\t\tcase '+': s [len2++] = 'p'; break;  /* + */\n-\t\tcase '-': s [len2++] = 'm'; break;  /* - */\n-\t\tcase '*': s [len2++] = 't'; break;  /* * */\n-\t\tcase '/': s [len2++] = 'd'; break;  /* / */\n+\t      switch (name[j - 1]) {\n+\t\tcase '+': s[len2++] = 'p'; break;  /* + */\n+\t\tcase '-': s[len2++] = 'm'; break;  /* - */\n+\t\tcase '*': s[len2++] = 't'; break;  /* * */\n+\t\tcase '/': s[len2++] = 'd'; break;  /* / */\n \t      }\n \t      break;\n \n \t    case '=':\n \t      j++;\n-\t      switch (name [j - 1]) {\n-\t\tcase '+': s [len2++] = 'p'; break;  /* += */\n-\t\tcase '-': s [len2++] = 'm'; break;  /* -= */\n-\t\tcase '*': s [len2++] = 't'; break;  /* *= */\n-\t\tcase '/': s [len2++] = 'd'; break;  /* /= */\n+\t      switch (name[j - 1]) {\n+\t\tcase '+': s[len2++] = 'p'; break;  /* += */\n+\t\tcase '-': s[len2++] = 'm'; break;  /* -= */\n+\t\tcase '*': s[len2++] = 't'; break;  /* *= */\n+\t\tcase '/': s[len2++] = 'd'; break;  /* /= */\n \t      }\n-\t      s [len2++] = 'a';\n+\t      s[len2++] = 'a';\n \t      break;\n \n \t    case '-':  /* -- */\n \t      j++;\n-\t      s [len2++] = 'm';\n-\t      s [len2++] = 'm';\n+\t      s[len2++] = 'm';\n+\t      s[len2++] = 'm';\n \t      break;\n \n \t    case '+':  /* ++ */\n \t      j++;\n-\t      s [len2++] = 'p';\n-\t      s [len2++] = 'p';\n+\t      s[len2++] = 'p';\n+\t      s[len2++] = 'p';\n \t      break;\n \n \t    case ')':  /* () */\n \t      j++;\n-\t      s [len2++] = 'o';\n-\t      s [len2++] = 'p';\n+\t      s[len2++] = 'o';\n+\t      s[len2++] = 'p';\n \t      break;\n \n \t    case ']':  /* [] */\n \t      j++;\n-\t      s [len2++] = 'o';\n-\t      s [len2++] = 'b';\n+\t      s[len2++] = 'o';\n+\t      s[len2++] = 'b';\n \t      break;\n \t  }\n \n \t  break;\n \n \tcase '<':\n \tcase '>':\n-\t  c = name [j] == '<' ? 'l' : 'g';\n-\t  s [len2++] = '_';\n+\t  c = name[j] == '<' ? 'l' : 'g';\n+\t  s[len2++] = '_';\n \n-\t  switch (name [j + 1]) {\n+\t  switch (name[j + 1]) {\n \t    case '\\0':\n-\t      s [len2++] = c;\n-\t      s [len2++] = 't';\n+\t      s[len2++] = c;\n+\t      s[len2++] = 't';\n \t      break;\n \t    case '=':\n \t      j++;\n-\t      s [len2++] = c;\n-\t      s [len2++] = 'e';\n+\t      s[len2++] = c;\n+\t      s[len2++] = 'e';\n \t      break;\n \t    case '>':\n \t      j++;\n-\t      s [len2++] = 's';\n-\t      s [len2++] = 'r';\n+\t      s[len2++] = 's';\n+\t      s[len2++] = 'r';\n \t      break;\n \t    case '<':\n \t      j++;\n-\t      s [len2++] = 's';\n-\t      s [len2++] = 'l';\n+\t      s[len2++] = 's';\n+\t      s[len2++] = 'l';\n \t      break;\n \t    default:\n \t      break;\n \t  }\n \t  break;\n \n \tcase '_':\n-\t  if (len2 && s [len2 - 1] == '_')\n-\t    s [len2++] = 'u';\n+\t  if (len2 && s[len2 - 1] == '_')\n+\t    s[len2++] = 'u';\n \t  /* fall through */\n \n \tdefault:\n-\t  s [len2++] = name [j];\n+\t  s[len2++] = name[j];\n       }\n \n-  if (s [len2 - 1] == '_')\n-    s [len2++] = 'u';\n+  if (s[len2 - 1] == '_')\n+    s[len2++] = 'u';\n \n-  s [len2] = '\\0';\n+  s[len2] = '\\0';\n \n   return s;\n }\n@@ -1376,7 +1376,7 @@ dump_ada_import (pretty_printer *buffer, tree t)\n \n   if (is_stdcall)\n     pp_string (buffer, \"pragma Import (Stdcall, \");\n-  else if (name [0] == '_' && name [1] == 'Z')\n+  else if (name[0] == '_' && name[1] == 'Z')\n     pp_string (buffer, \"pragma Import (CPP, \");\n   else\n     pp_string (buffer, \"pragma Import (C, \");\n@@ -1433,7 +1433,7 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n {\n   tree arg;\n   const tree node = TREE_TYPE (func);\n-  char buf [16];\n+  char buf[16];\n   int num = 0, num_args = 0, have_args = true, have_ellipsis = false;\n \n   /* Compute number of arguments.  */\n@@ -3071,7 +3071,7 @@ print_ada_struct_decl (pretty_printer *buffer, tree node, tree type,\n   tree tmp;\n   int is_union =\n     TREE_CODE (node) == UNION_TYPE || TREE_CODE (node) == QUAL_UNION_TYPE;\n-  char buf [16];\n+  char buf[16];\n   int field_num = 0;\n   int field_spc = spc + INDENT_INCR;\n   int need_semicolon;\n@@ -3328,7 +3328,7 @@ collect_source_ref (const char *filename)\n     }\n \n   for (i = 0; i < source_refs_used; i++)\n-    if (filename == source_refs [i])\n+    if (filename == source_refs[i])\n       return;\n \n   if (source_refs_used == source_refs_allocd)\n@@ -3337,7 +3337,7 @@ collect_source_ref (const char *filename)\n       source_refs = XRESIZEVEC (const char *, source_refs, source_refs_allocd);\n     }\n \n-  source_refs [source_refs_used++] = filename;\n+  source_refs[source_refs_used++] = filename;\n }\n \n /* Main entry point: dump all Ada specs corresponding to SOURCE_REFS\n@@ -3355,7 +3355,7 @@ dump_ada_specs (void (*collect_all_refs)(const char *),\n \n   /* Iterate over the list of files to dump specs for */\n   for (i = 0; i < source_refs_used; i++)\n-    dump_ads (source_refs [i], collect_all_refs, cpp_check);\n+    dump_ads (source_refs[i], collect_all_refs, cpp_check);\n \n   /* Free files table.  */\n   free (source_refs);"}]}