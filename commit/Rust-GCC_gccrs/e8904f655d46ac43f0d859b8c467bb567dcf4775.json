{"sha": "e8904f655d46ac43f0d859b8c467bb567dcf4775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5MDRmNjU1ZDQ2YWM0M2YwZDg1OWI4YzQ2N2JiNTY3ZGNmNDc3NQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-03-23T12:35:44Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-03-23T12:35:44Z"}, "message": "Thread_Wait.java: New file.\n\n2000-03-23  Bryce McKinlay  <bryce@albatross.co.nz>\n\n        * libjava.lang/Thread_Wait.java: New file.\n        * libjava.lang/Thread_Sleep.java: New file.\n        * libjava.lang/Thread_Monitor.java: New file.\n        * libjava.lang/Thread_Wait.out: New file.\n        * libjava.lang/Thread_Sleep.out: New file.\n        * libjava.lang/Thread_Monitor.out: New file.\n        * libjava.lang/Thread_Interrupt.java: New file.\n        * libjava.lang/Thread_Wait_2.java: New file.\n        * libjava.lang/Thread_Wait_2.out: New file.\n        * libjava.lang/Thread_Wait_Interrupt.java: New file.\n        * libjava.lang/Thread_Wait_Interrupt.out: New file.\n        * libjava.lang/Thread_Interrupt.out: New file.\n        * libjava.lang/Thread_Join.java: New file.\n        * libjava.lang/Thread_Join.out: New file.\n        * libjava.lang/Thread_Alive.java: New file.\n        * libjava.lang/Thread_Alive.out: New file.\n\nFrom-SVN: r32706", "tree": {"sha": "b8f3ddf8bdcae58d2eff8369b44d65dcfb4363fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f3ddf8bdcae58d2eff8369b44d65dcfb4363fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8904f655d46ac43f0d859b8c467bb567dcf4775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8904f655d46ac43f0d859b8c467bb567dcf4775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8904f655d46ac43f0d859b8c467bb567dcf4775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8904f655d46ac43f0d859b8c467bb567dcf4775/comments", "author": null, "committer": null, "parents": [{"sha": "8034da37ce34e442aa8e04f3f1618b70b00ed10e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8034da37ce34e442aa8e04f3f1618b70b00ed10e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8034da37ce34e442aa8e04f3f1618b70b00ed10e"}], "stats": {"total": 683, "additions": 683, "deletions": 0}, "files": [{"sha": "6e945cec91093bc1bfaf9975c8ea3ab23f18991c", "filename": "libjava/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FChangeLog?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -1,3 +1,22 @@\n+2000-03-23  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* libjava.lang/Thread_Wait.java: New file.\n+\t* libjava.lang/Thread_Sleep.java: New file.\n+\t* libjava.lang/Thread_Monitor.java: New file.\n+\t* libjava.lang/Thread_Wait.out: New file.\n+\t* libjava.lang/Thread_Sleep.out: New file.\n+\t* libjava.lang/Thread_Monitor.out: New file.\n+\t* libjava.lang/Thread_Interrupt.java: New file.\n+\t* libjava.lang/Thread_Wait_2.java: New file.\n+\t* libjava.lang/Thread_Wait_2.out: New file.\n+\t* libjava.lang/Thread_Wait_Interrupt.java: New file.\n+\t* libjava.lang/Thread_Wait_Interrupt.out: New file.\n+\t* libjava.lang/Thread_Interrupt.out: New file.\n+\t* libjava.lang/Thread_Join.java: New file.\n+\t* libjava.lang/Thread_Join.out: New file.\n+\t* libjava.lang/Thread_Alive.java: New file.\n+\t* libjava.lang/Thread_Alive.out: New file.\n+\n 2000-03-22  Tom Tromey  <tromey@cygnus.com>\n \n \t* libjava.compile/iface.java: New file."}, {"sha": "d97ea25c5d3c95b7e00ab461bc58cf6e96ca3fec", "filename": "libjava/testsuite/libjava.lang/Thread_Alive.java", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Alive.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Alive.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Alive.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,47 @@\n+// Test the status of the isAlive() flag before, during, and after thread \n+// execution. Check that thread's threadgroup is null after thread exits.\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+public class Thread_Alive implements Runnable\n+{\n+  public static void main(String args[]) throws InterruptedException\n+  {\n+    Thread_Alive ta = new Thread_Alive();\n+    Thread t = new Thread(ta);\n+    System.out.println(t.isAlive());\n+    t.start();\n+    System.out.println(t.isAlive());\n+\n+    Thread.sleep(100);\n+    \n+    synchronized (ta)\n+    {\n+      ta.notifyAll();\n+    }\n+\n+    t.join();\n+    System.out.println(t.isAlive());\n+    \n+    try\n+    {\n+      t.start();\n+      System.out.println(\"Error: dead thread can be restarted.\");\n+    }\n+    catch (IllegalThreadStateException x)\n+    {\n+      System.out.println (\"ok\");\n+    }\n+\n+    System.out.println(t.getThreadGroup());\n+  }\n+  \n+  public synchronized void run()\n+  {\n+    try\n+    {\n+      wait();\n+    }\n+    catch (InterruptedException x) {}\n+  }\n+  \n+}"}, {"sha": "1d1790d9207089a8d2fef65070a8f08cd5919211", "filename": "libjava/testsuite/libjava.lang/Thread_Alive.out", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Alive.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Alive.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Alive.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,5 @@\n+false\n+true\n+false\n+ok\n+null"}, {"sha": "5412549e713a54b9754f01fd31deb731c8c440de", "filename": "libjava/testsuite/libjava.lang/Thread_Interrupt.java", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Interrupt.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Interrupt.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Interrupt.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,134 @@\n+// Test interrupt() behaviour on a thread in wait(), sleep(), and spinning \n+// in a loop.\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+class Waiter extends Thread\n+{\n+  public synchronized void run()\n+  {\n+    System.out.println (\"wait()\");\n+    try\n+    {\n+      wait();\n+      System.out.println(\"Error: wait() completed normally.\");\n+    }\n+    catch (InterruptedException x)\n+    {\n+      if (isInterrupted() || interrupted()) \n+        System.out.println(\"Error: interrupt flag is still set.\");\n+    \n+    }\n+      System.out.println(\"interrupted - ok\");\n+  }\n+}\n+\n+class Sleeper extends Thread\n+{\n+  public void run()\n+  {\n+    System.out.println (\"sleep()\");\n+    try\n+    {\n+      sleep(2000);\n+      System.out.println(\"Error: sleep() completed normally.\");\n+    }\n+    catch (InterruptedException x)\n+    {\n+      if (isInterrupted() || interrupted()) \n+        System.out.println(\"Error: interrupt flag is still set.\");\n+    \n+      System.out.println(\"interrupted - ok\");\n+    }\n+  }\n+}\n+\n+class Looper extends Thread\n+{\n+  public void run()\n+  {\n+    System.out.println (\"Busy waiting\");\n+\n+    int count = 0;\n+    for (int i=0; i < 1000000; i++)\n+      {\n+        Thread.yield();\n+\tcount += 5;\n+\tif (isInterrupted ())\n+\t  break;\n+      }\n+    synchronized (this)\n+    {  \n+      if (interrupted ())\n+\t{\n+\t  System.out.println (\"interrupted - ok\");\n+\t  if (isInterrupted () || interrupted ())\n+\t    System.out.println(\"Error: interrupt flag is still set.\");\n+\t}\n+      else\n+\tSystem.out.println (\"Error: Busy wait was not interrupted.\");          \n+    }\n+  }\n+}\n+\n+class Joiner extends Thread\n+{\n+  public void run()\n+  {\n+    System.out.println(\"join()\");\n+    try\n+    {\n+      join(2000);\n+      System.out.println(\"Error: join() completed normally??!\");\n+    }\n+    catch (InterruptedException x)\n+    {\n+      if (isInterrupted() || interrupted()) \n+        System.out.println(\"Error: interrupt flag is still set.\");\n+    \n+      System.out.println(\"interrupted - ok\");\n+    }\n+\n+  }\n+}\n+\n+public class Thread_Interrupt\n+{\n+  public static void main(String args[])\n+  {\n+    Waiter w = new Waiter();\n+    w.start ();\n+    sleep_and_interrupt (w);\n+    \n+    Sleeper s = new Sleeper();\n+    s.start ();\n+    sleep_and_interrupt (s);\n+\n+    Looper l = new Looper ();\n+    l.start ();\n+    sleep_and_interrupt (l);\n+\n+    Joiner j = new Joiner ();\n+    j.start ();\n+    sleep_and_interrupt (j);\n+  }\n+  \n+  public static void sleep_and_interrupt(Thread t)\n+  {\n+    try\n+    {\n+      Thread.sleep (250);\n+      t.interrupt ();\n+      long t1 = System.currentTimeMillis();\n+      t.join (5000);\n+      long time = System.currentTimeMillis() - t1;\n+      if (time > 2900)\n+        {\n+\t  System.out.println (\"Error: join() from main thread timed out\");\n+\t}\n+    }\n+    catch (InterruptedException x)\n+    {\n+      System.out.println(\"Error: main thread interrupted.\");\n+    }\n+  }\n+}"}, {"sha": "b3a5c3100b45a3e59f092356341f53ef996b0398", "filename": "libjava/testsuite/libjava.lang/Thread_Interrupt.out", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Interrupt.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Interrupt.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Interrupt.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,8 @@\n+wait()\n+interrupted - ok\n+sleep()\n+interrupted - ok\n+Busy waiting\n+interrupted - ok\n+join()\n+interrupted - ok"}, {"sha": "711b05cf0f8a415fb9edda60e0bfe58663388d8d", "filename": "libjava/testsuite/libjava.lang/Thread_Join.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Join.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Join.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Join.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,68 @@\n+// Many threads join a single thread.\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+class Sleeper implements Runnable\n+{\n+  int num = -1;\n+  \n+  public Sleeper(int num)\n+  {\n+    this.num = num;\n+  }\n+  \n+  public void run()\n+  {\n+    System.out.println(\"sleeping\");\n+    try\n+    {\n+      Thread.sleep(500);\n+    }\n+    catch (InterruptedException x)\n+    {\n+      System.out.println(\"sleep() interrupted\");\n+    }\n+    System.out.println(\"done\");\n+  }\n+}\n+\n+class Joiner implements Runnable\n+{\n+  Thread join_target;\n+  \n+  public Joiner(Thread t)\n+  {\n+    this.join_target = t;\n+  }\n+  \n+  public void run()\n+  {\n+    try\n+    {\n+      long start = System.currentTimeMillis();\n+      join_target.join(2000);\n+      if ((System.currentTimeMillis() - start) > 1900)\n+        System.out.println(\"Error: Join timed out\");\n+      else\n+        System.out.println(\"ok\");\n+    }\n+    catch (InterruptedException x)\n+    {\n+      System.out.println(\"join() interrupted\");\n+    }\n+  }\n+  \n+}\n+\n+public class Thread_Join\n+{\n+  public static void main(String[] args)\n+  {\n+    Thread primary = new Thread(new Sleeper(1));\n+    primary.start();\n+    for (int i=0; i < 10; i++)\n+    {\n+      Thread t = new Thread(new Joiner(primary));\n+      t.start();\n+    }\n+  }\n+}"}, {"sha": "ac72ef3f9420e9becb3fcc49d344305a6af4450d", "filename": "libjava/testsuite/libjava.lang/Thread_Join.out", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Join.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Join.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Join.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,12 @@\n+sleeping\n+done\n+ok\n+ok\n+ok\n+ok\n+ok\n+ok\n+ok\n+ok\n+ok\n+ok"}, {"sha": "f1ffa674c37278e2fec62223755170e6d99f608f", "filename": "libjava/testsuite/libjava.lang/Thread_Monitor.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Monitor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Monitor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Monitor.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,65 @@\n+// Test that monitor locks work and are recursive.\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+class T implements Runnable\n+{\n+  public int count = 0;\n+  Counter c;\n+  \n+  public T (Counter c)\n+  {\n+    this.c = c;\n+  }\n+\n+  public void run()\n+  {\n+    while (true)\n+      {\n+        // NOTE: double-synchronization here.\n+\tsynchronized (c)\n+\t{\n+\t  if (c.getCount() <= 100000)\n+\t    count++;\n+\t  else\n+\t    break;\n+\t}\n+      }\n+  }\n+}\n+\n+class Counter\n+{\n+  int i = 0;\n+  public synchronized int getCount ()\n+  {\n+    return ++i; \n+  }\n+}\n+\n+public class Thread_Monitor\n+{\n+  public static void main(String args[])\n+  {\n+    Counter c = new Counter();\n+    T t1 = new T(c);\n+    T t2 = new T(c);\n+    \n+    Thread th1 = new Thread(t1);\n+    Thread th2 = new Thread(t2);\n+    th1.start();\n+    th2.start();\n+    try\n+    {\n+      th1.join();\n+      th2.join();\n+    } \n+    catch (InterruptedException x)\n+    {\n+      System.out.println(\"failed: Interrupted\");\n+    }\n+    if (t1.count + t2.count == 100000)\n+      System.out.println (\"ok\");\n+    else\n+      System.out.println (\"failed: total count incorrect\");\n+  }\n+}"}, {"sha": "9766475a4185a151dc9d56d614ffb9aaea3bfd42", "filename": "libjava/testsuite/libjava.lang/Thread_Monitor.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Monitor.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Monitor.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Monitor.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1 @@\n+ok"}, {"sha": "e7f4a81532c0aa46146df7741856638e9c7c7be4", "filename": "libjava/testsuite/libjava.lang/Thread_Sleep.java", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Sleep.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Sleep.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Sleep.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,24 @@\n+// Test that Thread.sleep() works.\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+public class Thread_Sleep\n+{\n+  public static void main(String args[])\n+  {\n+    try\n+    {\n+      long start = System.currentTimeMillis();\n+      System.out.println(\"sleeping\");\n+      Thread.sleep(1000);\n+      long end = System.currentTimeMillis();\n+      if ((end - start) > 1100 || (end - start) < 990)\n+        System.out.println (\"failed\");\n+      else\n+\tSystem.out.println(\"ok\");\n+    }\n+    catch (InterruptedException x)\n+    {\n+      System.out.println(\"error: Thread interrupted.\");\n+    }\n+  }\n+}"}, {"sha": "1622a213afab3624b7a7fe98041b275d45777c2c", "filename": "libjava/testsuite/libjava.lang/Thread_Sleep.out", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Sleep.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Sleep.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Sleep.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,2 @@\n+sleeping\n+ok"}, {"sha": "5ca12ed5d4b83631b803b2a2f48a50dda096a6cd", "filename": "libjava/testsuite/libjava.lang/Thread_Wait.java", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,49 @@\n+// Test basic thread creation and wait/notify functionality.\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+public class Thread_Wait implements Runnable\n+{\n+  public static void main(String args[])\n+  {\n+    new Thread_Wait();\n+  }\n+  \n+  public Thread_Wait()\n+  {\n+    System.out.println(\"creating thread\");\n+    Thread t = new Thread(this);\n+    t.start();\n+    \n+    try\n+    {\n+      Thread.sleep(100);\n+    }\n+    catch (Exception x)\n+    {\n+      System.out.println(\"exception occured: \" + x);\n+    }\n+\n+    synchronized (this)\n+    {\n+      System.out.println(\"notifying other thread\");\n+      notify();\n+    }\n+  }\n+  \n+  public void run()\n+  {\n+    System.out.println (\"new thread running\");\n+    synchronized (this)\n+    {\n+      try\n+      {\n+\twait();\n+      }\n+      catch (Exception x)\n+      {\n+        System.out.println(\"exception occured: \" + x);\n+      }\n+    }    \n+    System.out.println (\"thread notified okay\");\n+  }\n+}"}, {"sha": "09cbb785c047848d2c98bd75a525de2b6ee32731", "filename": "libjava/testsuite/libjava.lang/Thread_Wait.out", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,4 @@\n+creating thread\n+new thread running\n+notifying other thread\n+thread notified okay"}, {"sha": "a03cb943812a4dae1dcf0207e67e4bf68a71318a", "filename": "libjava/testsuite/libjava.lang/Thread_Wait_2.java", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_2.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_2.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_2.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,144 @@\n+// Create many threads waiting on a monitor. Interrupt some of them. Do the \n+// others wake up correctly with notify() and/or notifyAll()?\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+import java.util.Vector;\n+\n+class Waiter extends Thread\n+{\n+  Object monitor;\n+  int thread_num;\n+  boolean interrupted = false;\n+  boolean notified = false;\n+\n+  Waiter (Object monitor, int thread_num)\n+  {\n+    this.monitor = monitor;\n+    this.thread_num = thread_num;\n+  }  \n+  \n+  public void run()\n+  {\n+    synchronized (monitor)\n+      {\n+\ttry\n+\t{\n+\t  monitor.wait();\n+\t  notified = true;\n+\t}\n+\tcatch (InterruptedException x)\n+\t{\n+\t  interrupted = true;\n+\t}\n+      }\n+    \n+  }\n+}\n+\n+public class Thread_Wait_2\n+{\n+  static Vector threads;\n+  static Object monitor = new Object();\n+  \n+  static final int NUM_THREADS = 10;\n+  \n+  public static void main(String args[])\n+  {\n+    \n+    \n+    try\n+    {\n+      makeThreads ();\n+      \n+      Thread.sleep(250);\n+      \n+      // Interrupt a few threads...\n+      Waiter i1 = (Waiter) threads.elementAt(3);\n+      Waiter i2 = (Waiter) threads.elementAt(4);\n+      Waiter i3 = (Waiter) threads.elementAt(9);\n+      i1.interrupt();\n+      i2.interrupt();\n+      i3.interrupt();\n+      \n+      // Call notify the exact number of times required to wake the remaining\n+      // threads.\n+      synchronized (monitor)\n+      {\n+\tfor (int i=0; i < NUM_THREADS -3 ; i++)\n+\t{\n+\t  monitor.notify ();\n+\t}\n+      }\n+      \n+      joinAll();\n+      printStatus();\n+      \n+      // Repeat all the above, but use notifyAll() instead.\n+      makeThreads();\n+\n+      Thread.sleep(250);\n+      \n+      // Interrupt a few threads...\n+      i1 = (Waiter) threads.elementAt(0);\n+      i2 = (Waiter) threads.elementAt(1);\n+      i3 = (Waiter) threads.elementAt(9);\n+      i1.interrupt();\n+      i2.interrupt();\n+      i3.interrupt();\n+      \n+      // Call notifyAll to wake the remaining threads.\n+      synchronized (monitor)\n+      {\n+        monitor.notifyAll ();\n+      }\n+\n+      joinAll();\n+      printStatus();\n+\n+    }\n+    catch (InterruptedException x)\n+    {\n+      System.out.println (x);\n+    }\n+\n+\n+  }\n+  \n+  static void makeThreads()\n+  {\n+    threads = new Vector(NUM_THREADS);\n+    \n+    for (int i=0; i < NUM_THREADS; i++)\n+      {\n+\tWaiter w = new Waiter(monitor, i);\n+\tw.start();\n+\tthreads.addElement(w);\n+      }\n+  }\n+  \n+  static void joinAll()\n+  {\n+    try\n+    {\n+      for (int i=0; i < threads.size(); i++)\n+\t{\n+          Thread t = (Thread) threads.elementAt(i);\n+\t  t.join();\n+\t}\n+    }\n+    catch (InterruptedException x) {}\n+  }\n+  \n+  static void printStatus()\n+  {\n+    for (int i=0; i < threads.size(); i++)\n+      {\n+        Waiter w = (Waiter) threads.elementAt(i);\n+\tif (w.interrupted)\n+\t  System.out.println (i + \" interrupted.\");\n+\tif (w.notified)\n+\t  System.out.println (i + \" notified.\");\n+      }\n+  }\n+  \n+}"}, {"sha": "4a71f07f900a0ce8c42d72b55da8fa242ce5726d", "filename": "libjava/testsuite/libjava.lang/Thread_Wait_2.out", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_2.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_2.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_2.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,20 @@\n+0 notified.\n+1 notified.\n+2 notified.\n+3 interrupted.\n+4 interrupted.\n+5 notified.\n+6 notified.\n+7 notified.\n+8 notified.\n+9 interrupted.\n+0 interrupted.\n+1 interrupted.\n+2 notified.\n+3 notified.\n+4 notified.\n+5 notified.\n+6 notified.\n+7 notified.\n+8 notified.\n+9 interrupted."}, {"sha": "be7b5551614191fc9d8ee823904a83aaa20baf5b", "filename": "libjava/testsuite/libjava.lang/Thread_Wait_Interrupt.java", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_Interrupt.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_Interrupt.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_Interrupt.java?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,76 @@\n+// Create two threads waiting on a monitor. Interrupt one of them. Does the \n+// other wake up correctly?\n+// Origin: Bryce McKinlay <bryce@albatross.co.nz>\n+\n+class Waiter extends Thread\n+{\n+  Object monitor;\n+  int thread_num;\n+  boolean interrupted = false;\n+  boolean notified = false; \n+\n+  Waiter (Object monitor, int thread_num)\n+  {\n+    this.monitor = monitor;\n+    this.thread_num = thread_num;\n+  }\n+  \n+  public void run()\n+  {\n+    synchronized (monitor)\n+      {\n+        System.out.println (\"Thread waiting.\");\n+\ttry\n+\t{\n+\t  long start = System.currentTimeMillis();\n+\t  monitor.wait(1000);\n+\t  long time = System.currentTimeMillis() - start;\n+\t  if (time > 990)\n+\t    System.out.println (\"Error: wait on thread \" + thread_num \n+\t                        + \" timed out.\");\n+\t  else\n+\t    notified = true;\n+\t}\n+\tcatch (InterruptedException x)\n+\t{\n+\t  interrupted = true;\n+\t}\n+      }\n+    \n+  }\n+}\n+\n+public class Thread_Wait_Interrupt\n+{\n+  public static void main(String args[])\n+  {\n+    Object monitor = new Object();\n+    Waiter w1 = new Waiter(monitor, 1);\n+    Waiter w2 = new Waiter(monitor, 2);\n+    w1.start();\n+    w2.start();\n+    try\n+    {\n+      Thread.sleep(250);\n+\n+      synchronized (monitor)\n+      {\n+\tw1.interrupt();\n+\tmonitor.notify();\n+      }\n+\n+      w1.join();\n+      w2.join();\n+      System.out.println(\"join ok\");\n+      System.out.println(\"Thread 1 \" + \n+                         (w1.interrupted ? \"interrupted ok\" : \"error\"));\n+      System.out.println(\"Thread 2 \" +\n+                         (w2.notified ? \"notified ok\" : \"error\"));\n+\n+    }\n+    catch (InterruptedException x)\n+    {\n+      System.out.println (x);\n+    }\n+  }\n+}"}, {"sha": "4f3b1667814e3d541edd324a8823a28c90b99fe0", "filename": "libjava/testsuite/libjava.lang/Thread_Wait_Interrupt.out", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_Interrupt.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8904f655d46ac43f0d859b8c467bb567dcf4775/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_Interrupt.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FThread_Wait_Interrupt.out?ref=e8904f655d46ac43f0d859b8c467bb567dcf4775", "patch": "@@ -0,0 +1,5 @@\n+Thread waiting.\n+Thread waiting.\n+join ok\n+Thread 1 interrupted ok\n+Thread 2 notified ok"}]}