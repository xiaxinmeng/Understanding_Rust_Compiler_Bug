{"sha": "ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYxNTRmNzgzZmYwNWU4MzRkYmZhMDdhZDg0OGRkNmQ2ZjZmMTcxNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-06T19:09:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-06T19:09:26Z"}, "message": "local-alloc.c (local_alloc): Use xmalloc/xcalloc, not alloca.\n\n\t* local-alloc.c (local_alloc): Use xmalloc/xcalloc, not alloca.\n\t(update_equiv_regs): Likewise.\n\t(block_alloc): Likewise.\n\t* reg-stack.c (reg_to_stack): Likewise.\n\t(convert_regs_2): Likewise.\n\t* reload1.c (reload_as_needed): Likewise.\n\nFrom-SVN: r30434", "tree": {"sha": "87cace2499c0c4f87ac63051263d863a58b39a9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87cace2499c0c4f87ac63051263d863a58b39a9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/comments", "author": null, "committer": null, "parents": [{"sha": "951a525fefc72be228eb70c7fd1586be9235afab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951a525fefc72be228eb70c7fd1586be9235afab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/951a525fefc72be228eb70c7fd1586be9235afab"}], "stats": {"total": 58, "additions": 33, "deletions": 25}, "files": [{"sha": "c511909523595c659f6f8485ae765510f45afb5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "patch": "@@ -1,3 +1,12 @@\n+Sat Nov  6 10:00:34 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* local-alloc.c (local_alloc): Use xmalloc/xcalloc, not alloca.\n+\t(update_equiv_regs): Likewise.\n+\t(block_alloc): Likewise.\n+\t* reg-stack.c (reg_to_stack): Likewise.\n+\t(convert_regs_2): Likewise.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t\n Sat Nov  6 09:57:59 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (dbxout.o): Depend on ggc.h."}, {"sha": "0e01668d11514be67711b49c17c9c556133298d4", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "patch": "@@ -411,9 +411,6 @@ local_alloc ()\n       next_qty = 0;\n \n       block_alloc (b);\n-#ifdef USE_C_ALLOCA\n-      alloca (0);\n-#endif\n     }\n \n   free (qty_phys_reg);\n@@ -687,17 +684,13 @@ update_equiv_regs ()\n {\n   /* Set when an attempt should be made to replace a register with the\n      associated reg_equiv_replacement entry at the end of this function.  */\n-  char *reg_equiv_replace\n-    = (char *) alloca (max_regno * sizeof *reg_equiv_replace);\n+  char *reg_equiv_replace;\n   rtx insn;\n   int block, depth;\n \n-  reg_equiv_init_insns = (rtx *) alloca (max_regno * sizeof (rtx));\n-  reg_equiv_replacement = (rtx *) alloca (max_regno * sizeof (rtx));\n-\n-  bzero ((char *) reg_equiv_init_insns, max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_replacement, max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_replace, max_regno * sizeof *reg_equiv_replace);\n+  reg_equiv_replace = (char *) xcalloc (max_regno, sizeof *reg_equiv_replace);\n+  reg_equiv_init_insns = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_replacement = (rtx *) xcalloc (max_regno, sizeof (rtx));\n \n   init_alias_analysis ();\n \n@@ -1017,6 +1010,9 @@ update_equiv_regs ()\n \n   /* Clean up.  */\n   end_alias_analysis ();\n+  free (reg_equiv_replace);\n+  free (reg_equiv_init_insns);\n+  free (reg_equiv_replacement);\n }\n \n /* Mark REG as having no known equivalence.\n@@ -1080,9 +1076,8 @@ block_alloc (b)\n \n   /* +2 to leave room for a post_mark_life at the last insn and for\n      the birth of a CLOBBER in the first insn.  */\n-  regs_live_at = (HARD_REG_SET *) alloca ((2 * insn_count + 2)\n-\t\t\t\t\t  * sizeof (HARD_REG_SET));\n-  bzero ((char *) regs_live_at, (2 * insn_count + 2) * sizeof (HARD_REG_SET));\n+  regs_live_at = (HARD_REG_SET *) xcalloc ((2 * insn_count + 2),\n+\t\t\t\t\t   sizeof (HARD_REG_SET));\n \n   /* Initialize table of hardware registers currently live.  */\n \n@@ -1321,7 +1316,7 @@ block_alloc (b)\n      number of suggested registers they need so we allocate those with\n      the most restrictive needs first.  */\n \n-  qty_order = (int *) alloca (next_qty * sizeof (int));\n+  qty_order = (int *) xmalloc (next_qty * sizeof (int));\n   for (i = 0; i < next_qty; i++)\n     qty_order[i] = i;\n \n@@ -1491,6 +1486,10 @@ block_alloc (b)\n \tfor (i = qty_first_reg[q]; i >= 0; i = reg_next_in_qty[i])\n \t  reg_renumber[i] = qty_phys_reg[q] + reg_offset[i];\n       }\n+\n+  /* Clean up.  */\n+  free (regs_live_at);\n+  free (qty_order);\n }\n \f\n /* Compare two quantities' priority for getting real registers."}, {"sha": "98b877867455f5b945aeef5c474c83527bc15411", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "patch": "@@ -435,8 +435,7 @@ reg_to_stack (first, file)\n   life_analysis (first, max_reg_num (), file, 0);\n \n   /* Set up block info for each basic block.  */\n-  bi = (block_info) alloca ((n_basic_blocks + 1) * sizeof (*bi));\n-  memset (bi, 0, (n_basic_blocks + 1) * sizeof (*bi));\n+  bi = (block_info) xcalloc ((n_basic_blocks + 1), sizeof (*bi));\n   for (i = n_basic_blocks - 1; i >= 0; --i)\n     BASIC_BLOCK (i)->aux = bi + i;\n   EXIT_BLOCK_PTR->aux = bi + n_basic_blocks;\n@@ -483,7 +482,9 @@ reg_to_stack (first, file)\n \t\t     !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n     }\n \n+  /* Clean up.  */\n   VARRAY_FREE (stack_regs_mentioned_data);\n+  free (bi);\n }\n \f\n /* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the\n@@ -2616,7 +2617,7 @@ convert_regs_2 (file, block)\n   basic_block *stack, *sp;\n   int inserted;\n \n-  stack = (basic_block *) alloca (sizeof (*stack) * n_basic_blocks);\n+  stack = (basic_block *) xmalloc (sizeof (*stack) * n_basic_blocks);\n   sp = stack;\n \n   *sp++ = block;"}, {"sha": "3526ae9f134a4a6e0b915311e42364bbecff033b", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff154f783ff05e834dbfa07ad848dd6d6f6f1717/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "patch": "@@ -4309,9 +4309,8 @@ reload_as_needed (live_known)\n \n   bzero ((char *) spill_reg_rtx, sizeof spill_reg_rtx);\n   bzero ((char *) spill_reg_store, sizeof spill_reg_store);\n-  reg_last_reload_reg = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero ((char *) reg_last_reload_reg, max_regno * sizeof (rtx));\n-  reg_has_output_reload = (char *) alloca (max_regno);\n+  reg_last_reload_reg = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_has_output_reload = (char *) xmalloc (max_regno);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n   set_initial_elim_offsets ();\n@@ -4573,11 +4572,11 @@ reload_as_needed (live_known)\n \t    && INSN_CLOBBERS_REGNO_P (insn, i))\n \t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i);\n #endif\n-\n-#ifdef USE_C_ALLOCA\n-      alloca (0);\n-#endif\n     }\n+\n+  /* Clean up.  */\n+  free (reg_last_reload_reg);\n+  free (reg_has_output_reload);\n }\n \n /* Discard all record of any value reloaded from X,"}]}