{"sha": "820cc88fbd53803f1b57374bfc78e628c6879fc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIwY2M4OGZiZDUzODAzZjFiNTczNzRiZmM3OGU2MjhjNjg3OWZjMA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-07-08T23:37:11Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-07-08T23:37:11Z"}, "message": "Makefile.in (TREE_H): Add treestruct.def.\n\n2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* Makefile.in (TREE_H): Add treestruct.def.\n\t(c-decl.o): Add pointer-set.h\n\t* c-decl.c (diagnose_mismatched_decls): Don't attempt to look at\n\tvisibility on regular DECL's.\n\t(merge_decls): Fix the copying of decl nodes of various types for\n\tthe new structures.  Don't update RTL, section name, weak status,\n\tetc, on DECL's without RTL.\n\t(grokdeclarator): DECL_ARG_TYPE_AS_WRITTEN is gone.\n\tDon't check volatile on non-variable types.\n\t(store_parm_decls_oldstyle): Use pointer_set instead of DECL_WEAK\n\tto check whether we have seen arguments.\n\t* c-objc-common.c (c_tree_printer): Reverse order of tests so that\n\tflag is checked before field (flag is common, field is not).\n\t* dwarf2out.c (decl_ultimate_origin):  Only DECL's with\n\tTS_DECL_COMMON could have an origin.\n\t(add_location_or_const_value_attribute): Don't check section name\n\ton non-var/function decls.\n\t(dwarf2out_var_location): Reverse order of tests.\n\t* emit-rtl.c (set_reg_attrs_for_parm): DECL_CHECK is dead, replace\n\twith DECL_WRTL_CHECK.\n\t* expmed.c (make_tree): rtl is now in decl_with_rtl.\n\t* fold-const.c (fold_binary): Don't check weakness on\n\tnon-var/function decls.\n\t(tree_expr_nonzero_p): Ditto.\n\t(fold_checksum_tree): Use tree_decl_extra as sizeof\n\tbuffer.\n\t* ggc-page.c (extra_order_size_table): Add sizes for\n\ttree_decl_non_common, tree_parm_decl,  tree_var_decl, and\n\ttree_field_decl.\n\t* gimplify.c (gimplify_bind_expr): Only set\n\tDECL_SEEN_IN_BIND_EXPR_P on VAR_DECL.\n\t* integrate.c (copy_decl_for_inlining): Don't set RTL on decl's\n\twithout RTL.\n\t* langhooks-def.h (LANG_HOOK_INIT_TS): New.\n\t* langhooks.h (init_ts). New langhook.\n\t* passes.c (rest_of_decl_compilation): Reverse order of tests.\n\t* print-tree.c (print_node): Update to only print fields that\n\texist in the structures the passed decl has.\n\t* toplev.c (wrapup_global_declarations): Don't reset\n\tDECL_DEFER_OUTPUT on DECL's that don't contain it.\n\t* tree-browser.c (browse_tree): DECL_ARG_TYPE_AS_WRITTEN removed.\n\t* tree-inline.c (remap_decl): Ditto.\n\t* tree-outof-ssa.c (create_temp): Reverse order of tests.\n\t* tree-pretty-print.c (print_declaration): Don't print\n\tDECL_REGISTER on things that don't contain it.\n\t* tree-vrp.c (expr_computes_nonzero): Don't check weakness on\n\tnon-var/function decls.\n\t* tree.c (tree_contains_struct): New structure.\n\t(init_priority_for_decl): New hashtable.\n\t(tree_int_map): New structure.\n\t(tree_int_map_eq): New function.\n\t(tree_int_map_marked_p): Ditto.\n\t(tree_int_map_hash): Ditto.\n\t(tree_map): Move to tree.h.\n\t(tree_map_eq): Externalize.\n\t(tree_map_hash): Ditto.\n\t(tree_map_marked_p): Ditto.\n\t(init_ttree): Set up tree_contains_struct and call langhook.\n\t(decl_assembler_name): Use DECL_NON_COMMON_CHECK..\n\t(tree_code_size): Update for new structures.\n\t(tree_node_structure): Update for new structures.\n\t(make_node_stat): Don't try to set DECL_IN_SYSTEM_HEADER on decls\n\twithout the field.\n\t(copy_node_stat):  Copy init priority.\n\t(build_decl_stat): Ditto for visibility.\n\t(ts_enum_names): New.\n\t(tree_contains_struct_check_failed): New function.\n\t(decl_init_priority_lookup): Ditto.\n\t(decl_init_priority_insert): Ditto.\n\t* treestruct.def: New file.\n\t* tree.h (CODE_CONTAINS_STRUCT): New macro.\n\t(CONTAINS_STRUCT_CHECK): Ditto.\n\t(tree_contains_struct_check_failed): New prototype.\n\t(DECL_CHECK): Removed.\n\t(DECL_MINIMAL_CHECK): New.\n\t(DECL_COMMON_CHECK): Ditto.\n\t(DECL_WRTL_CHECK): Ditto.\n\t(DECL_NON_COMMON_CHECK): Ditto.\n\t(DECL_WITH_VIS_CHECK): Ditto.\n\t(VAR_OR_FUNCTION_DECL_P): Ditto\n\t(struct tree_decl_minimal): New structure.\n\t(struct tree_decl_common): Ditto.\n\t(struct tree_decl_with_rtl): Ditto.\n\t(struct tree_decl_with_vis): Ditto.\n\t(struct tree_decl_non_common): Ditto.\n\t(struct tree_field_decl): Ditto.\n\t(struct tree_parm_decl): Ditto.\n\t(struct tree_var_decl): Ditto.\n\t(struct tree_function_decl): Ditto.\n\t(struct tree_const_decl): Ditto.\n\t(struct tree_result_decl): Ditto.\n\t(union tree_node): Add new structures.\n\t* var-tracking.c (track_expr_p): Reverse order of tests.\n\n\t* doc/c-tree.texi: Add documentation on DECL node internal structure.\n\n\n2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* utils.c (create_param_decl): DECL_ARG_TYPE_AS_WRITTEN is\n\tremoved.\n\n2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* Make-lang.in: Add gt-cp-lang.h.\n\t(cp-lang.o): Ditto.\n\t* class.c (create_vtable_ptr): Stop setting DECL_ASSEMBLER_NAME on\n\tthe field.\n\t* config-lang.in: Add cp-lang.c to gtfiles.\n\t* cp-lang.c: Include hashtab.h.\n\t(cp_init_ts): New function.\n\t(LANG_HOOK_INIT_TS): Use macro.\n\t(decl_shadowed_for_var_lookup): New function.\n\t(decl_shadowed_for_var_insert): Ditto.\n\t* cp-tree.h (THUNK_FUNCTION_CHECK): Use decl_common.\n\t(NON_THUNK_FUNCTION_CHECK): Ditto.\n\t(DECL_NAMESPACE_ASSOCIATIONS): Use decl_non_common.\n\t(DECL_INIT_PRIORITY): Ditto.\n\t(DECL_HAS_SHADOWED_FOR_VAR_P): Ditto.\n\t(DECL_SHADOWED_FOR_VAR): Use hashtable.\n\t(SET_DECL_SHADOWED_FOR_VAR): Ditto.\n\t* decl.c (duplicate_decls): Update for new/updated structures.\n\t(poplevel): Use SET_DECL_SHADOWED_FOR_VAR.\n\t* decl2.c (start_static_initialization_or_destruction): Deal with\n\tpriority.\n\t* pt.c (tsubst_decl): Check TS_DECL_WRTL before doing\n\tSET_DECL_RTL.\n\t* tree.c (handle_init_priority_attribute): Handle priority.\n\n2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* objc-act.c (objc_push_parm): DECL_ARG_TYPE_AS_WRITTEN is\n\tremoved.\n\t* objc-act.h (KEYWORD_ARG_NAME): Use decl_non_common.\n\t(KEYWORD_KEY_NAME): Use decl_minimal.\n\t(METHOD_SEL_NAME): Ditto..\n\t(METHOD_SEL_ARGS): Use decl_non_common.\n\t(METHOD_ADD_ARGS): Ditto.\n\t(METHOD_ADD_ARGS_ELLIPSIS_P): Use decl_common.\n\t(METHOD_DEFINITION): Ditto.\n\t(METHOD_ENCODING): Ditto.\n\t* objc-lang.c: (objc_init_ts): New function.\n\n2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* trans-decl.c (create_function_arglist): DECL_ARG_TYPE_AS_WRITTEN\n\tis removed.\n\nFrom-SVN: r101799", "tree": {"sha": "e8e5667e9ce5aa5fc7514d5caa37a74c88e3f391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8e5667e9ce5aa5fc7514d5caa37a74c88e3f391"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/820cc88fbd53803f1b57374bfc78e628c6879fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820cc88fbd53803f1b57374bfc78e628c6879fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820cc88fbd53803f1b57374bfc78e628c6879fc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820cc88fbd53803f1b57374bfc78e628c6879fc0/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c249f608702bff661796e3c188a848601cb4861c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c249f608702bff661796e3c188a848601cb4861c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c249f608702bff661796e3c188a848601cb4861c"}], "stats": {"total": 2474, "additions": 1712, "deletions": 762}, "files": [{"sha": "498406c772288228cfa920b8807690ce0a3c7a0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1,3 +1,101 @@\n+2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Makefile.in (TREE_H): Add treestruct.def.\n+\t(c-decl.o): Add pointer-set.h\n+\t* c-decl.c (diagnose_mismatched_decls): Don't attempt to look at\n+\tvisibility on regular DECL's.\n+\t(merge_decls): Fix the copying of decl nodes of various types for\n+\tthe new structures.  Don't update RTL, section name, weak status,\n+\tetc, on DECL's without RTL.\t\n+\t(grokdeclarator): DECL_ARG_TYPE_AS_WRITTEN is gone.\n+\tDon't check volatile on non-variable types.\n+\t(store_parm_decls_oldstyle): Use pointer_set instead of DECL_WEAK\n+\tto check whether we have seen arguments.\n+\t* c-objc-common.c (c_tree_printer): Reverse order of tests so that\n+\tflag is checked before field (flag is common, field is not).\t\n+\t* dwarf2out.c (decl_ultimate_origin):  Only DECL's with\n+\tTS_DECL_COMMON could have an origin.\n+\t(add_location_or_const_value_attribute): Don't check section name\n+\ton non-var/function decls.\n+\t(dwarf2out_var_location): Reverse order of tests.\n+\t* emit-rtl.c (set_reg_attrs_for_parm): DECL_CHECK is dead, replace\n+\twith DECL_WRTL_CHECK.\n+\t* expmed.c (make_tree): rtl is now in decl_with_rtl.\n+\t* fold-const.c (fold_binary): Don't check weakness on\n+\tnon-var/function decls.\n+\t(tree_expr_nonzero_p): Ditto.\n+\t(fold_checksum_tree): Use tree_decl_extra as sizeof\n+\tbuffer.\n+\t* ggc-page.c (extra_order_size_table): Add sizes for\n+\ttree_decl_non_common, tree_parm_decl,  tree_var_decl, and\n+\ttree_field_decl.\n+\t* gimplify.c (gimplify_bind_expr): Only set\n+\tDECL_SEEN_IN_BIND_EXPR_P on VAR_DECL.\n+\t* integrate.c (copy_decl_for_inlining): Don't set RTL on decl's\n+\twithout RTL.\n+\t* langhooks-def.h (LANG_HOOK_INIT_TS): New.\n+\t* langhooks.h (init_ts). New langhook.\n+\t* passes.c (rest_of_decl_compilation): Reverse order of tests.\n+\t* print-tree.c (print_node): Update to only print fields that\n+\texist in the structures the passed decl has.\n+\t* toplev.c (wrapup_global_declarations): Don't reset\n+\tDECL_DEFER_OUTPUT on DECL's that don't contain it.\n+\t* tree-browser.c (browse_tree): DECL_ARG_TYPE_AS_WRITTEN removed.\n+\t* tree-inline.c (remap_decl): Ditto.\n+\t* tree-outof-ssa.c (create_temp): Reverse order of tests.\n+\t* tree-pretty-print.c (print_declaration): Don't print\n+\tDECL_REGISTER on things that don't contain it.\n+\t* tree-vrp.c (expr_computes_nonzero): Don't check weakness on\n+\tnon-var/function decls.\n+\t* tree.c (tree_contains_struct): New structure.\n+\t(init_priority_for_decl): New hashtable.\n+\t(tree_int_map): New structure.\n+\t(tree_int_map_eq): New function.\n+\t(tree_int_map_marked_p): Ditto.\n+\t(tree_int_map_hash): Ditto.\n+\t(tree_map): Move to tree.h.\n+\t(tree_map_eq): Externalize.\n+\t(tree_map_hash): Ditto.\n+\t(tree_map_marked_p): Ditto.\n+\t(init_ttree): Set up tree_contains_struct and call langhook.\n+\t(decl_assembler_name): Use DECL_NON_COMMON_CHECK..\n+\t(tree_code_size): Update for new structures.\n+\t(tree_node_structure): Update for new structures.\n+\t(make_node_stat): Don't try to set DECL_IN_SYSTEM_HEADER on decls\n+\twithout the field.\n+\t(copy_node_stat):  Copy init priority.\n+\t(build_decl_stat): Ditto for visibility.\n+\t(ts_enum_names): New.\n+\t(tree_contains_struct_check_failed): New function.\n+\t(decl_init_priority_lookup): Ditto.\n+\t(decl_init_priority_insert): Ditto.\n+\t* treestruct.def: New file.\n+\t* tree.h (CODE_CONTAINS_STRUCT): New macro.\n+\t(CONTAINS_STRUCT_CHECK): Ditto.\n+\t(tree_contains_struct_check_failed): New prototype.\n+\t(DECL_CHECK): Removed.\n+\t(DECL_MINIMAL_CHECK): New.\n+\t(DECL_COMMON_CHECK): Ditto.\n+\t(DECL_WRTL_CHECK): Ditto.\n+\t(DECL_NON_COMMON_CHECK): Ditto.\n+\t(DECL_WITH_VIS_CHECK): Ditto.\n+\t(VAR_OR_FUNCTION_DECL_P): Ditto\n+\t(struct tree_decl_minimal): New structure.\n+\t(struct tree_decl_common): Ditto.\n+\t(struct tree_decl_with_rtl): Ditto.\n+\t(struct tree_decl_with_vis): Ditto.\n+\t(struct tree_decl_non_common): Ditto.\n+\t(struct tree_field_decl): Ditto.\n+\t(struct tree_parm_decl): Ditto.\n+\t(struct tree_var_decl): Ditto.\n+\t(struct tree_function_decl): Ditto.\n+\t(struct tree_const_decl): Ditto.\n+\t(struct tree_result_decl): Ditto.\n+\t(union tree_node): Add new structures.\n+\t* var-tracking.c (track_expr_p): Reverse order of tests.\n+\t\n+\t* doc/c-tree.texi: Add documentation on DECL node internal structure.\n+\n 2005-07-08  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* cfgexpand.c (tree_expand_cfg): Don't use FINALIZE_PIC."}, {"sha": "244643cd5315b70c226c443bedc8e1ffb1ea4afc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -711,7 +711,7 @@ RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \\\n RTL_H = $(RTL_BASE_H) genrtl.h\n PARAMS_H = params.h params.def\n TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h builtins.def \\\n-          input.h statistics.h vec.h\n+          input.h statistics.h vec.h treestruct.def\n BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \\\n           hard-reg-set.h cfghooks.h $(OBSTACK_H)\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n@@ -1457,7 +1457,8 @@ c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \\\n     opts.h $(C_PRAGMA_H) gt-c-decl.h $(CGRAPH_H) $(HASHTAB_H) libfuncs.h \\\n     except.h $(LANGHOOKS_DEF_H) $(TREE_DUMP_H) $(C_COMMON_H) $(CPPLIB_H) \\\n-    $(DIAGNOSTIC_H) input.h langhooks.h $(TREE_GIMPLE_H) tree-mudflap.h\n+    $(DIAGNOSTIC_H) input.h langhooks.h $(TREE_GIMPLE_H) tree-mudflap.h  \\\n+    pointer-set.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(TREE_H) $(C_TREE_H) $(TARGET_H) $(FLAGS_H) intl.h output.h $(EXPR_H) \\\n     $(RTL_H) toplev.h $(TM_P_H) langhooks.h $(GGC_H) $(TREE_FLOW_H) \\"}, {"sha": "de7f06cf4d2f5a9c069a8fe9aea4af8de5ba060d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1,3 +1,8 @@\n+2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* utils.c (create_param_decl): DECL_ARG_TYPE_AS_WRITTEN is\n+\tremoved.\n+\n 2005-07-07  Pascal Obry  <obry@adacore.com>\n \n \t* g-socthi-mingw.adb (C_Inet_Addr): New body used to convert the"}, {"sha": "ab86a490fb896bc0afa2561748153ceb804568bb", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1494,7 +1494,6 @@ create_param_decl (tree param_name, tree param_type, bool readonly)\n     }\n \n   DECL_ARG_TYPE (param_decl) = param_type;\n-  DECL_ARG_TYPE_AS_WRITTEN (param_decl) = param_type;\n   TREE_READONLY (param_decl) = readonly;\n   return param_decl;\n }"}, {"sha": "67c72a58d8c3a1205256a9f4a70754fa68abc89e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 177, "deletions": 156, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -60,6 +60,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"libfuncs.h\"\n #include \"except.h\"\n #include \"langhooks-def.h\"\n+#include \"pointer-set.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -1471,7 +1472,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \n   /* warnings */\n   /* All decls must agree on a visibility.  */\n-  if (DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)\n+  if (CODE_CONTAINS_STRUCT (TREE_CODE (newdecl), TS_DECL_WITH_VIS) \n+      && DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n       warning (0, \"redeclaration of %q+D with different visibility \"\n@@ -1638,8 +1640,6 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  }\n     }\n \n-  /* Keep the old rtl since we can safely use it.  */\n-  COPY_DECL_RTL (olddecl, newdecl);\n \n   /* Merge the type qualifiers.  */\n   if (TREE_READONLY (newdecl))\n@@ -1674,153 +1674,178 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n    if (DECL_INITIAL (newdecl) == 0)\n     DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n-  /* Merge the section attribute.\n-     We want to issue an error if the sections conflict but that must be\n-     done later in decl_attributes since we are called before attributes\n-     are assigned.  */\n-  if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n-    DECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n-\n-  /* Copy the assembler name.\n-     Currently, it can only be defined in the prototype.  */\n-  COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n-\n-  /* Use visibility of whichever declaration had it specified */\n-  if (DECL_VISIBILITY_SPECIFIED (olddecl))\n-    {\n-      DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n-      DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n-    }\n-\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-    {\n-      DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n-      DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n-      DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n-      DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n-\t|= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n-      TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n-      TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n-      DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n-      DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n-      DECL_IS_NOVOPS (newdecl) |= DECL_IS_NOVOPS (olddecl);\n-    }\n-\n-  /* Merge the storage class information.  */\n-  merge_weak (newdecl, olddecl);\n-\n-  /* For functions, static overrides non-static.  */\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-    {\n-      TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n-      /* This is since we don't automatically\n-\t copy the attributes of NEWDECL into OLDDECL.  */\n-      TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-      /* If this clears `static', clear it in the identifier too.  */\n-      if (!TREE_PUBLIC (olddecl))\n-\tTREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n-    }\n-  if (DECL_EXTERNAL (newdecl))\n-    {\n-      TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n-      DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n-\n-      /* An extern decl does not override previous storage class.  */\n-      TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n-      if (!DECL_EXTERNAL (newdecl))\n-\t{\n-\t  DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n-\t  DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n-\t}\n-    }\n-  else\n-    {\n-      TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n-      TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-    }\n-\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-    {\n-      /* If we're redefining a function previously defined as extern\n-\t inline, make sure we emit debug info for the inline before we\n-\t throw it away, in case it was inlined into a function that hasn't\n-\t been written out yet.  */\n-      if (new_is_definition && DECL_INITIAL (olddecl))\n-\t{\n-\t  if (TREE_USED (olddecl)\n-\t      /* In unit-at-a-time mode we never inline re-defined extern\n-\t         inline functions.  */\n-\t      && !flag_unit_at_a_time\n-\t      && cgraph_function_possibly_inlined_p (olddecl))\n-\t    (*debug_hooks->outlining_inline_function) (olddecl);\n-\n-\t  /* The new defn must not be inline.  */\n-\t  DECL_INLINE (newdecl) = 0;\n-\t  DECL_UNINLINABLE (newdecl) = 1;\n-\t}\n-      else\n-\t{\n-\t  /* If either decl says `inline', this fn is inline,\n-\t     unless its definition was passed already.  */\n-\t  if (DECL_DECLARED_INLINE_P (newdecl)\n-\t      || DECL_DECLARED_INLINE_P (olddecl))\n-\t    DECL_DECLARED_INLINE_P (newdecl) = 1;\n-\n-\t  DECL_UNINLINABLE (newdecl) = DECL_UNINLINABLE (olddecl)\n-\t    = (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl));\n-\t}\n+   if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))\n+     {\n+       /* Merge the section attribute.\n+\t  We want to issue an error if the sections conflict but that must be\n+\t  done later in decl_attributes since we are called before attributes\n+\t  are assigned.  */\n+       if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n+\t DECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n+       \n+       /* Copy the assembler name.\n+\t  Currently, it can only be defined in the prototype.  */\n+       COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n+\n+       /* Use visibility of whichever declaration had it specified */\n+       if (DECL_VISIBILITY_SPECIFIED (olddecl))\n+\t {\n+\t   DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n+\t   DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n+\t }\n+       \n+       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t {\n+\t   DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n+\t   DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n+\t   DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n+\t   DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n+\t     |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n+\t   TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n+\t   TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n+\t   DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n+\t   DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n+\t   DECL_IS_NOVOPS (newdecl) |= DECL_IS_NOVOPS (olddecl);\n+\t }\n+       \n+       /* Merge the storage class information.  */\n+       merge_weak (newdecl, olddecl);\n \n-      if (DECL_BUILT_IN (olddecl))\n-\t{\n-\t  /* If redeclaring a builtin function, it stays built in.\n-\t     But it gets tagged as having been declared.  */\n-\t  DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n-\t  DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n-\t  C_DECL_DECLARED_BUILTIN (newdecl) = 1;\n-\t  if (new_is_prototype)\n-\t    C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n-\t  else\n-\t    C_DECL_BUILTIN_PROTOTYPE (newdecl)\n-\t      = C_DECL_BUILTIN_PROTOTYPE (olddecl);\n-\t}\n+       /* For functions, static overrides non-static.  */\n+       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t {\n+\t   TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n+\t   /* This is since we don't automatically\n+\t      copy the attributes of NEWDECL into OLDDECL.  */\n+\t   TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n+\t   /* If this clears `static', clear it in the identifier too.  */\n+\t   if (!TREE_PUBLIC (olddecl))\n+\t     TREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n+\t }\n+     }\n+   \n+   if (DECL_EXTERNAL (newdecl))\n+     {\n+       TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n+       DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n+\n+       /* An extern decl does not override previous storage class.  */\n+       TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n+       if (!DECL_EXTERNAL (newdecl))\n+\t {\n+\t   DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n+\t   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n+\t }\n+     }\n+   else\n+     {\n+       TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n+       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n+     }\n+   \n+   if (TREE_CODE (newdecl) == FUNCTION_DECL) \n+     {\n+       /* If we're redefining a function previously defined as extern\n+\t  inline, make sure we emit debug info for the inline before we\n+\t  throw it away, in case it was inlined into a function that hasn't\n+\t  been written out yet.  */\n+       if (new_is_definition && DECL_INITIAL (olddecl))\n+\t {\n+\t   if (TREE_USED (olddecl)\n+\t       /* In unit-at-a-time mode we never inline re-defined extern\n+\t\t  inline functions.  */\n+\t       && !flag_unit_at_a_time\n+\t       && cgraph_function_possibly_inlined_p (olddecl))\n+\t     (*debug_hooks->outlining_inline_function) (olddecl);\n+\n+\t   /* The new defn must not be inline.  */\n+\t   DECL_INLINE (newdecl) = 0;\n+\t   DECL_UNINLINABLE (newdecl) = 1;\n+\t }\n+       else\n+\t {\n+\t   /* If either decl says `inline', this fn is inline,\n+\t      unless its definition was passed already.  */\n+\t   if (DECL_DECLARED_INLINE_P (newdecl)\n+\t       || DECL_DECLARED_INLINE_P (olddecl))\n+\t     DECL_DECLARED_INLINE_P (newdecl) = 1;\n+\n+\t   DECL_UNINLINABLE (newdecl) = DECL_UNINLINABLE (olddecl)\n+\t     = (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl));\n+\t }\n \n-      /* Also preserve various other info from the definition.  */\n-      if (!new_is_definition)\n-\t{\n-\t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n-\t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n-\t  DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n-\t  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n-\t  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n-\n-\t  /* Set DECL_INLINE on the declaration if we've got a body\n-\t     from which to instantiate.  */\n-\t  if (DECL_INLINE (olddecl) && !DECL_UNINLINABLE (newdecl))\n-\t    {\n-\t      DECL_INLINE (newdecl) = 1;\n-\t      DECL_ABSTRACT_ORIGIN (newdecl)\n-\t\t= DECL_ABSTRACT_ORIGIN (olddecl);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* If a previous declaration said inline, mark the\n-\t     definition as inlinable.  */\n-\t  if (DECL_DECLARED_INLINE_P (newdecl)\n-\t      && !DECL_UNINLINABLE (newdecl))\n-\t    DECL_INLINE (newdecl) = 1;\n-\t}\n-    }\n+       if (DECL_BUILT_IN (olddecl))\n+\t {\n+\t   /* If redeclaring a builtin function, it stays built in.\n+\t      But it gets tagged as having been declared.  */\n+\t   DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n+\t   DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n+\t   C_DECL_DECLARED_BUILTIN (newdecl) = 1;\n+\t   if (new_is_prototype)\n+\t     C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n+\t   else\n+\t     C_DECL_BUILTIN_PROTOTYPE (newdecl)\n+\t       = C_DECL_BUILTIN_PROTOTYPE (olddecl);\n+\t }\n \n-  /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n+       /* Also preserve various other info from the definition.  */\n+       if (!new_is_definition)\n+\t {\n+\t   DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n+\t   DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+\t   DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n+\t   DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n+\t   DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n+\n+\t   /* Set DECL_INLINE on the declaration if we've got a body\n+\t      from which to instantiate.  */\n+\t   if (DECL_INLINE (olddecl) && !DECL_UNINLINABLE (newdecl))\n+\t     {\n+\t       DECL_INLINE (newdecl) = 1;\n+\t       DECL_ABSTRACT_ORIGIN (newdecl)\n+\t\t = DECL_ABSTRACT_ORIGIN (olddecl);\n+\t     }\n+\t }\n+       else\n+\t {\n+\t   /* If a previous declaration said inline, mark the\n+\t      definition as inlinable.  */\n+\t   if (DECL_DECLARED_INLINE_P (newdecl)\n+\t       && !DECL_UNINLINABLE (newdecl))\n+\t     DECL_INLINE (newdecl) = 1;\n+\t }\n+     }\n+   \n+   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID and DECL_CONTEXT.  */\n   {\n     unsigned olddecl_uid = DECL_UID (olddecl);\n     tree olddecl_context = DECL_CONTEXT (olddecl);\n-\n+    \n     memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t    (char *) newdecl + sizeof (struct tree_common),\n-\t    sizeof (struct tree_decl) - sizeof (struct tree_common));\n+\t    sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n+    switch (TREE_CODE (olddecl))\n+      {\n+      case FIELD_DECL:\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case LABEL_DECL:\n+      case RESULT_DECL:\n+      case CONST_DECL:\n+      case TYPE_DECL:\n+      case FUNCTION_DECL:\n+\tmemcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n+\t\t(char *) newdecl + sizeof (struct tree_decl_common),\n+\t\ttree_code_size (TREE_CODE (olddecl)) - sizeof (struct tree_decl_common));\n+\tbreak;\n+\n+      default:\n+\t\n+\tmemcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n+\t\t(char *) newdecl + sizeof (struct tree_decl_common),\n+\t\tsizeof (struct tree_decl_non_common) - sizeof (struct tree_decl_common));\n+      }\n     DECL_UID (olddecl) = olddecl_uid;\n     DECL_CONTEXT (olddecl) = olddecl_context;\n   }\n@@ -4475,7 +4500,6 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  promoted_type = c_type_promotes_to (type);\n \n \tDECL_ARG_TYPE (decl) = promoted_type;\n-\tDECL_ARG_TYPE_AS_WRITTEN (decl) = type_as_written;\n \tif (declspecs->inline_p)\n \t  pedwarn (\"parameter %q+D declared %<inline%>\", decl);\n       }\n@@ -4680,8 +4704,11 @@ grokdeclarator (const struct c_declarator *declarator,\n \n     /* If a type has volatile components, it should be stored in memory.\n        Otherwise, the fact that those components are volatile\n-       will be ignored, and would even crash the compiler.  */\n-    if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (decl)))\n+       will be ignored, and would even crash the compiler.\n+       Of course, this only makes sense on  VAR,PARM, and RESULT decl's.   */\n+    if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (decl))\n+\t&& (TREE_CODE (decl) == VAR_DECL ||  TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == RESULT_DECL))\n       {\n \t/* It is not an error for a structure with volatile fields to\n \t   be declared register, but reset DECL_REGISTER since it\n@@ -6088,13 +6115,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n   struct c_binding *b;\n   tree parm, decl, last;\n   tree parmids = arg_info->parms;\n-\n-  /* We use DECL_WEAK as a flag to show which parameters have been\n-     seen already, since it is not used on PARM_DECL.  */\n-#ifdef ENABLE_CHECKING\n-  for (b = current_scope->bindings; b; b = b->prev)\n-    gcc_assert (TREE_CODE (b->decl) != PARM_DECL || !DECL_WEAK (b->decl));\n-#endif\n+  struct pointer_set_t *seen_args = pointer_set_create ();\n \n   if (!in_system_header)\n     warning (OPT_Wold_style_definition, \"%Jold-style function definition\",\n@@ -6120,7 +6141,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t    error (\"%q+D declared as a non-parameter\", decl);\n \t  /* If the declaration is already marked, we have a duplicate\n \t     name.  Complain and ignore the duplicate.  */\n-\t  else if (DECL_WEAK (decl))\n+\t  else if (pointer_set_contains (seen_args, decl))\n \t    {\n \t      error (\"multiple parameters named %q+D\", decl);\n \t      TREE_PURPOSE (parm) = 0;\n@@ -6151,7 +6172,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n-      DECL_WEAK (decl) = 1;\n+      pointer_set_insert (seen_args, decl);\n     }\n \n   /* Now examine the parms chain for incomplete declarations\n@@ -6170,7 +6191,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n-      if (!DECL_WEAK (parm))\n+      if (!pointer_set_contains (seen_args, parm))\n \t{\n \t  error (\"declaration for parameter %q+D but no such parameter\", parm);\n \n@@ -6193,18 +6214,18 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n     {\n       last = TREE_PURPOSE (parm);\n       DECL_ARGUMENTS (fndecl) = last;\n-      DECL_WEAK (last) = 0;\n \n       for (parm = TREE_CHAIN (parm); parm; parm = TREE_CHAIN (parm))\n \tif (TREE_PURPOSE (parm))\n \t  {\n \t    TREE_CHAIN (last) = TREE_PURPOSE (parm);\n \t    last = TREE_PURPOSE (parm);\n-\t    DECL_WEAK (last) = 0;\n \t  }\n       TREE_CHAIN (last) = 0;\n     }\n \n+  pointer_set_destroy (seen_args);\n+\n   /* If there was a previous prototype,\n      set the DECL_ARG_TYPE of each argument according to\n      the type previously specified, and report any mismatches.  */"}, {"sha": "310d042598331d1bdd39546cb9d748914b964adf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1,3 +1,30 @@\n+2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* Make-lang.in: Add gt-cp-lang.h.\n+\t(cp-lang.o): Ditto.\t\n+\t* class.c (create_vtable_ptr): Stop setting DECL_ASSEMBLER_NAME on\n+\tthe field.\n+\t* config-lang.in: Add cp-lang.c to gtfiles.\n+\t* cp-lang.c: Include hashtab.h.\n+\t(cp_init_ts): New function.\n+\t(LANG_HOOK_INIT_TS): Use macro.\n+\t(decl_shadowed_for_var_lookup): New function.\n+\t(decl_shadowed_for_var_insert): Ditto.\n+\t* cp-tree.h (THUNK_FUNCTION_CHECK): Use decl_common.\n+\t(NON_THUNK_FUNCTION_CHECK): Ditto.\n+\t(DECL_NAMESPACE_ASSOCIATIONS): Use decl_non_common.\n+\t(DECL_INIT_PRIORITY): Ditto.\n+\t(DECL_HAS_SHADOWED_FOR_VAR_P): Ditto.\n+\t(DECL_SHADOWED_FOR_VAR): Use hashtable.\n+\t(SET_DECL_SHADOWED_FOR_VAR): Ditto.\n+\t* decl.c (duplicate_decls): Update for new/updated structures.\n+\t(poplevel): Use SET_DECL_SHADOWED_FOR_VAR.\n+\t* decl2.c (start_static_initialization_or_destruction): Deal with\n+\tpriority. \n+\t* pt.c (tsubst_decl): Check TS_DECL_WRTL before doing\n+\tSET_DECL_RTL.\n+\t* tree.c (handle_init_priority_attribute): Handle priority.\n+\n 2005-07-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/21799"}, {"sha": "632e2abaffd84a3fc369fe774dce91645c360e50", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -110,7 +110,7 @@ $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf\n \t\t$(srcdir)/cp/cfns.gperf > $(srcdir)/cp/cfns.h\n \n gtype-cp.h gt-cp-call.h gt-cp-decl.h gt-cp-decl2.h : s-gtype; @true\n-gt-cp-pt.h gt-cp-repo.h gt-cp-parser.h gt-cp-method.h : s-gtype; @true\n+gt-cp-pt.h gt-cp-repo.h gt-cp-parser.h gt-cp-method.h gt-cp-lang.h : s-gtype; @true\n gt-cp-tree.h gt-cp-mangle.h gt-cp-name-lookup.h gt-cp-typeck2.h: s-gtype; @true\n gt-cp-rtti.h: s-gtype ; @true\n \n@@ -237,7 +237,7 @@ cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h \\\n   c-pragma.h toplev.h output.h input.h cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) c-common.h gtype-cp.h \\\n-  $(DIAGNOSTIC_H) cp/cp-objcp-common.h\n+  $(DIAGNOSTIC_H) cp/cp-objcp-common.h gt-cp-lang.h\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\"}, {"sha": "5dbec4602a4847e10ccb2f494c850676f8e28133", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -4130,7 +4130,6 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n       tree field;\n \n       field = build_decl (FIELD_DECL, get_vfield_name (t), vtbl_ptr_type_node);\n-      SET_DECL_ASSEMBLER_NAME (field, get_identifier (VFIELD_BASE));\n       DECL_VIRTUAL_P (field) = 1;\n       DECL_ARTIFICIAL (field) = 1;\n       DECL_FIELD_CONTEXT (field) = t;"}, {"sha": "dcf84ca2aed54ae0ce24194c21686f083ef07803", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -34,4 +34,4 @@ stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3\"\n \n-gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c \\$(srcdir)/cp/class.c\"\n+gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/c-lex.c \\$(srcdir)/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-lang.c\""}, {"sha": "1e3fb4d01950ec57d8ad1cdacf629d7f2884341b", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -32,8 +32,10 @@ Boston, MA 02110-1301, USA.  */\n #include \"diagnostic.h\"\n #include \"debug.h\"\n #include \"cp-objcp-common.h\"\n+#include \"hashtab.h\"\n \n enum c_language_kind c_language = clk_cxx;\n+static void cp_init_ts (void);\n \n /* Lang hooks common to C++ and ObjC++ are declared in cp/cp-objcp-common.h;\n    consequently, there should be very few hooks below.  */\n@@ -46,6 +48,8 @@ enum c_language_kind c_language = clk_cxx;\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tcxx_printable_name\n #undef LANG_HOOKS_FOLD_OBJ_TYPE_REF\n #define LANG_HOOKS_FOLD_OBJ_TYPE_REF cp_fold_obj_type_ref\n+#undef LANG_HOOKS_INIT_TS\n+#define LANG_HOOKS_INIT_TS cp_init_ts\n \n /* Each front end provides its own lang hook initializer.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n@@ -106,10 +110,79 @@ objcp_tsubst_copy_and_build (tree t ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n+     htab_t shadowed_var_for_decl;\n+\n+\n+static void\n+cp_init_ts (void)\n+{\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[USING_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[TEMPLATE_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[ALIAS_DECL][TS_DECL_NON_COMMON] = 1;\n+\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[USING_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[TEMPLATE_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[ALIAS_DECL][TS_DECL_WITH_VIS] = 1;\n+\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[USING_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[TEMPLATE_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[ALIAS_DECL][TS_DECL_WRTL] = 1;\n+  \n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[USING_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[TEMPLATE_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[ALIAS_DECL][TS_DECL_COMMON] = 1;\n+ \n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[USING_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[TEMPLATE_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[ALIAS_DECL][TS_DECL_MINIMAL] = 1;\n+\n+  shadowed_var_for_decl = htab_create_ggc (512, tree_map_hash,\n+\t\t\t\t\t   tree_map_eq, 0);\n+\n+}\n+\n+/* Lookup a shadowed var for FROM, and return it if we find one.  */\n+\n+tree \n+decl_shadowed_for_var_lookup (tree from)\n+{\n+  struct tree_map *h, in;\n+  in.from = from;\n+\n+  h = htab_find_with_hash (shadowed_var_for_decl, &in, \n+\t\t\t   htab_hash_pointer (from));\n+  if (h)\n+    return h->to;\n+  return NULL_TREE;\n+}\n+\n+/* Insert a mapping FROM->TO in the shadowed var hashtable.  */\n+\n+void\n+decl_shadowed_for_var_insert (tree from, tree to)\n+{\n+  struct tree_map *h;\n+  void **loc;\n+\n+  h = ggc_alloc (sizeof (struct tree_map));\n+  h->hash = htab_hash_pointer (from);\n+  h->from = from;\n+  h->to = to;\n+  loc = htab_find_slot_with_hash (shadowed_var_for_decl, h, h->hash, INSERT);\n+  *(struct tree_map **) loc = h;\n+}\n+\n void\n finish_file (void)\n {\n   cp_finish_file ();\n }\n \n+#include \"gt-cp-cp-lang.h\"\n #include \"gtype-cp.h\""}, {"sha": "b897ee26bec8a204932b9e2b86eb3cc2de77082d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -174,15 +174,15 @@ struct diagnostic_context;\n #define NON_THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != FUNCTION_DECL &&\t\t\t\t\\\n-\tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl.lang_specific\t\\\n-\t&& __t->decl.lang_specific->decl_flags.thunk_p)\t\t\t\\\n+ \tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl_common.lang_specific\t\\\n+\t&& __t->decl_common.lang_specific->decl_flags.thunk_p)\t\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n     __t; })\n #define THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != FUNCTION_DECL || !__t->decl.lang_specific\t\\\n-\t|| !__t->decl.lang_specific->decl_flags.thunk_p)\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n+    if (TREE_CODE (__t) != FUNCTION_DECL || !__t->decl_common.lang_specific\t\\\n+\t|| !__t->decl_common.lang_specific->decl_flags.thunk_p)\t\t\\\n+      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0); \t\\\n      __t; })\n #else\n #define NON_THUNK_FUNCTION_CHECK(NODE) (NODE)\n@@ -1992,7 +1992,7 @@ struct lang_decl GTY(())\n /* In a NAMESPACE_DECL, the list of namespaces which have associated\n    themselves with this one.  */\n #define DECL_NAMESPACE_ASSOCIATIONS(NODE) \\\n-  (NAMESPACE_DECL_CHECK (NODE)->decl.saved_tree)\n+  (NAMESPACE_DECL_CHECK (NODE)->decl_non_common.saved_tree)\n \n /* In a NAMESPACE_DECL, points to the original namespace if this is\n    a namespace alias.  */\n@@ -2007,15 +2007,13 @@ struct lang_decl GTY(())\n    && CP_DECL_CONTEXT (NODE) == global_namespace\t\\\n    && DECL_NAME (NODE) == std_identifier)\n \n-/* In a non-local VAR_DECL with static storage duration, this is the\n-   initialization priority.  If this value is zero, the NODE will be\n-   initialized at the DEFAULT_INIT_PRIORITY.  */\n-#define DECL_INIT_PRIORITY(NODE) (VAR_DECL_CHECK (NODE)->decl.u2.i)\n-\n /* In a TREE_LIST concatenating using directives, indicate indirect\n    directives  */\n #define TREE_INDIRECT_USING(NODE) (TREE_LIST_CHECK (NODE)->common.lang_flag_0)\n \n+extern tree decl_shadowed_for_var_lookup (tree);\n+extern void decl_shadowed_for_var_insert (tree, tree);\n+\n /* Non zero if this is a using decl for a dependent scope. */\n #define DECL_DEPENDENT_P(NODE) DECL_LANG_FLAG_0 (USING_DECL_CHECK (NODE))\n \n@@ -2025,9 +2023,18 @@ struct lang_decl GTY(())\n /* The decls named by a using decl.  */\n #define USING_DECL_DECLS(NODE) DECL_INITIAL (USING_DECL_CHECK (NODE))\n \n+/* In a VAR_DECL, true if we have a shadowed local variable\n+   in the shadowed var table for this VAR_DECL.  */\n+#define DECL_HAS_SHADOWED_FOR_VAR_P(NODE) \\\n+  (VAR_DECL_CHECK (NODE)->decl_with_vis.shadowed_for_var_p)\n+\n /* In a VAR_DECL for a variable declared in a for statement,\n    this is the shadowed (local) variable.  */\n-#define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT_FLD(VAR_DECL_CHECK (NODE))\n+#define DECL_SHADOWED_FOR_VAR(NODE) \\\n+  (DECL_HAS_SHADOWED_FOR_VAR_P(NODE) ? decl_shadowed_for_var_lookup (NODE) : NULL)\n+\n+#define SET_DECL_SHADOWED_FOR_VAR(NODE, VAL) \\\n+  (decl_shadowed_for_var_insert (NODE, VAL))\n \n /* In a FUNCTION_DECL, this is nonzero if this function was defined in\n    the class definition.  We have saved away the text of the function,\n@@ -2300,7 +2307,7 @@ struct lang_decl GTY(())\n /* Nonzero if NODE is a FUNCTION_DECL for a built-in function, and we have\n    not yet seen a prototype for that function.  */\n #define DECL_ANTICIPATED(NODE) \\\n-  (DECL_LANG_SPECIFIC (DECL_CHECK (NODE))->decl_flags.anticipated_p)\n+  (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->decl_flags.anticipated_p)\n \n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n@@ -2622,7 +2629,7 @@ struct lang_decl GTY(())\n    TEMPLATE_PARM_INDEX for the parameter is available as the\n    DECL_INITIAL (for a PARM_DECL) or as the TREE_TYPE (for a\n    TYPE_DECL).  */\n-#define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS (NODE)\n+#define DECL_TEMPLATE_PARMS(NODE)       DECL_NON_COMMON_CHECK (NODE)->decl_non_common.arguments\n #define DECL_INNERMOST_TEMPLATE_PARMS(NODE) \\\n    INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (NODE))\n #define DECL_NTPARMS(NODE) \\"}, {"sha": "ee6a89b71f6ada088df366a3d4ae06c4904cd53b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -608,7 +608,10 @@ poplevel (int keep, int reverse, int functionbody)\n \t      /* Keep track of what should have happened when we\n \t\t popped the binding.  */\n \t      if (ob && ob->value)\n-\t\tDECL_SHADOWED_FOR_VAR (link) = ob->value;\n+\t\t{\n+\t\t  SET_DECL_SHADOWED_FOR_VAR (link, ob->value);\n+\t\t  DECL_HAS_SHADOWED_FOR_VAR_P (link) = 1;\n+\t\t}\n \n \t      /* Add it to the list of dead variables in the next\n \t\t outermost binding to that we can remove these when we\n@@ -1805,6 +1808,13 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n       DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n     }\n+  /* Init priority used to be merged from newdecl to olddecl by the memcpy, \n+     so keep this behavior.  */\n+  if (TREE_CODE (newdecl) == VAR_DECL && DECL_HAS_INIT_PRIORITY_P (newdecl))\n+    {\n+      SET_DECL_INIT_PRIORITY (olddecl, DECL_INIT_PRIORITY (newdecl));\n+      DECL_HAS_INIT_PRIORITY_P (olddecl) = 1;\n+    }\n \n   /* The DECL_LANG_SPECIFIC information in OLDDECL will be replaced\n      with that from NEWDECL below.  */\n@@ -1819,12 +1829,15 @@ duplicate_decls (tree newdecl, tree olddecl)\n     {\n       int function_size;\n \n-      function_size = sizeof (struct tree_decl);\n+      function_size = sizeof (struct tree_decl_common);\n \n       memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t      (char *) newdecl + sizeof (struct tree_common),\n \t      function_size - sizeof (struct tree_common));\n \n+      memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n+\t      (char *) newdecl + sizeof (struct tree_decl_common),\n+\t      sizeof (struct tree_function_decl) - sizeof (struct tree_decl_common));\n       if (DECL_TEMPLATE_INSTANTIATION (newdecl))\n \t/* If newdecl is a template instantiation, it is possible that\n \t   the following sequence of events has occurred:\n@@ -1853,12 +1866,34 @@ duplicate_decls (tree newdecl, tree olddecl)\n     }\n   else\n     {\n+      size_t size = tree_code_size (TREE_CODE (olddecl));\n       memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t      (char *) newdecl + sizeof (struct tree_common),\n-\t      sizeof (struct tree_decl) - sizeof (struct tree_common)\n-\t      + TREE_CODE_LENGTH (TREE_CODE (newdecl)) * sizeof (char *));\n+\t      sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n+      switch (TREE_CODE (olddecl))       \n+\t{\n+\tcase LABEL_DECL:\n+\tcase VAR_DECL:\n+\tcase RESULT_DECL:\n+\tcase PARM_DECL:\n+\tcase FIELD_DECL:\n+\tcase TYPE_DECL:\n+\tcase CONST_DECL:\n+\t  {\n+\t    memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n+\t\t    (char *) newdecl + sizeof (struct tree_decl_common),\n+\t\t    size - sizeof (struct tree_decl_common)\n+\t\t    + TREE_CODE_LENGTH (TREE_CODE (newdecl)) * sizeof (char *));\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n+\t\t  (char *) newdecl + sizeof (struct tree_decl_common),\n+\t\t  sizeof (struct tree_decl_non_common) - sizeof (struct tree_decl_common)\n+\t\t  + TREE_CODE_LENGTH (TREE_CODE (newdecl)) * sizeof (char *));\n+\t  break;\n+\t}\n     }\n-\n   DECL_UID (olddecl) = olddecl_uid;\n   if (olddecl_friend)\n     DECL_FRIEND_P (olddecl) = 1;"}, {"sha": "22166e8b398234271953983eea8b7b40c253e937", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -2321,14 +2321,15 @@ static tree\n start_static_initialization_or_destruction (tree decl, int initp)\n {\n   tree guard_if_stmt = NULL_TREE;\n-  int priority;\n+  int priority = 0;\n   tree cond;\n   tree guard;\n   tree init_cond;\n   priority_info pi;\n \n-  /* Figure out the priority for this declaration.  */\n-  priority = DECL_INIT_PRIORITY (decl);\n+    /* Figure out the priority for this declaration.  */\n+  if (DECL_HAS_INIT_PRIORITY_P (decl))\n+    priority = DECL_INIT_PRIORITY (decl);\n   if (!priority)\n     priority = DEFAULT_INIT_PRIORITY;\n "}, {"sha": "4e2812811c8b25e6bc3070ddac10c582ef0b8ed2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1081,10 +1081,12 @@ check_for_out_of_scope_variable (tree decl)\n   if (!(TREE_CODE (decl) == VAR_DECL && DECL_DEAD_FOR_LOCAL (decl)))\n     return decl;\n \n-  shadowed = DECL_SHADOWED_FOR_VAR (decl);\n+  shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (decl) \n+    ? DECL_SHADOWED_FOR_VAR (decl) : NULL_TREE ;\n   while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n \t && DECL_DEAD_FOR_LOCAL (shadowed))\n-    shadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n+    shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (shadowed) \n+      ? DECL_SHADOWED_FOR_VAR (shadowed) : NULL_TREE;\n   if (!shadowed)\n     shadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (decl));\n   if (shadowed)"}, {"sha": "0fcb5e85a54f65fe449ee24ae132056a5383a4ee", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -2251,9 +2251,10 @@ reduce_template_parm_level (tree index, tree type, int levels)\n \t\t\t\t     decl, type);\n       TEMPLATE_PARM_DESCENDANTS (index) = t;\n \n-      /* Template template parameters need this.  */\n-      DECL_TEMPLATE_PARMS (decl)\n-\t= DECL_TEMPLATE_PARMS (TEMPLATE_PARM_DECL (index));\n+\t/* Template template parameters need this.  */\n+      if (TREE_CODE (decl) != CONST_DECL)\n+\tDECL_TEMPLATE_PARMS (decl)\n+\t  = DECL_TEMPLATE_PARMS (TEMPLATE_PARM_DECL (index));\n     }\n \n   return TEMPLATE_PARM_DESCENDANTS (index);\n@@ -6646,12 +6647,14 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tDECL_CONTEXT (r) = ctx;\n \t/* Clear out the mangled name and RTL for the instantiation.  */\n \tSET_DECL_ASSEMBLER_NAME (r, NULL_TREE);\n-\tSET_DECL_RTL (r, NULL_RTX);\n+\tif (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_WRTL))\n+\t  SET_DECL_RTL (r, NULL_RTX);\n \n \t/* Don't try to expand the initializer until someone tries to use\n \t   this variable; otherwise we run into circular dependencies.  */\n \tDECL_INITIAL (r) = NULL_TREE;\n-\tSET_DECL_RTL (r, NULL_RTX);\n+\tif (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_WRTL))\n+\t  SET_DECL_RTL (r, NULL_RTX);\n \tDECL_SIZE (r) = DECL_SIZE_UNIT (r) = 0;\n \n \t/* Even if the original location is out of scope, the newly"}, {"sha": "e0eb1ac6ef74ed26470ded94f25157f4d6e4206a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1841,7 +1841,8 @@ handle_init_priority_attribute (tree* node,\n \n   if (SUPPORTS_INIT_PRIORITY)\n     {\n-      DECL_INIT_PRIORITY (decl) = pri;\n+      SET_DECL_INIT_PRIORITY (decl, pri);\n+      DECL_HAS_INIT_PRIORITY_P (decl) = 1;\n       return NULL_TREE;\n     }\n   else\n@@ -2128,7 +2129,7 @@ decl_linkage (tree decl)\n      template instantiations have internal linkage (in the object\n      file), but the symbols should still be treated as having external\n      linkage from the point of view of the language.  */\n-  if (DECL_LANG_SPECIFIC (decl) && DECL_COMDAT (decl))\n+  if (TREE_CODE (decl) != TYPE_DECL && DECL_LANG_SPECIFIC (decl) && DECL_COMDAT (decl))\n     return lk_external;\n \n   /* Things in local scope do not have linkage, if they don't have"}, {"sha": "fc00d82afb0d87d97eb6f47d8920e2e3adb31dba", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -847,6 +847,15 @@ internal representation, except for declarations of functions\n (represented by @code{FUNCTION_DECL} nodes), which are described in\n @ref{Functions}.\n \n+@menu\n+* Working with declarations::  Macros and functions that work on\n+declarations.\n+* Internal structure:: How declaration nodes are represented. \n+@end menu\n+\n+@node Working with declarations\n+@subsection Working with declarations\n+\n Some macros can be used with any kind of declaration.  These include:\n @ftable @code\n @item DECL_NAME\n@@ -991,6 +1000,179 @@ Back ends can safely ignore these nodes.\n \n @end table\n \n+@node Internal structure\n+@subsection Internal structure\n+\n+@code{DECL} nodes are represented internally as a hierarchy of\n+structures.\n+\n+@menu\n+* Current structure hierarchy::  The current DECL node structure\n+hierarchy.\n+* Adding new DECL node types:: How to add a new DECL node to a\n+frontend.\n+@end menu\n+\n+@node Current structure hierarchy\n+@subsubsection Current structure hierarchy\n+\n+@table @code\n+\n+@item struct tree_decl_minimal\n+This is the minimal structure to inherit from in order for common\n+@code{DECL} macros to work.  The fields it contains are a unique ID,\n+source location, context, and name.\n+\n+@item struct tree_decl_common\n+This structure inherits from @code{struct tree_decl_minimal}.  It\n+contains fields that most @code{DECL} nodes need, such as a field to\n+store alignment, machine mode, size, and attributes.\n+\n+@item struct tree_field_decl\n+This structure inherits from @code{struct tree_decl_common}.  It is\n+used to represent @code{FIELD_DECL}.\n+\n+@item struct tree_label_decl\n+This structure inherits from @code{struct tree_decl_common}.  It is\n+used to represent @code{LABEL_DECL}.\n+\n+@item struct tree_translation_unit_decl\n+This structure inherits from @code{struct tree_decl_common}.  It is\n+used to represent @code{TRANSLATION_UNIT_DECL}.\n+\n+@item struct tree_decl_with_rtl\n+This structure inherits from @code{struct tree_decl_common}.  It\n+contains a field to store the low-level RTL associated with a\n+@code{DECL} node.\n+\n+@item struct tree_result_decl\n+This structure inherits from @code{struct tree_decl_with_rtl}.  It is\n+used to represent @code{RESULT_DECL}.\n+\n+@item struct tree_const_decl\n+This structure inherits from @code{struct tree_decl_with_rtl}.  It is\n+used to represent @code{CONST_DECL}.\n+\n+@item struct tree_parm_decl\n+This structure inherits from @code{struct tree_decl_with_rtl}.  It is\n+used to represent @code{PARM_DECL}.  \n+\n+@item struct tree_decl_with_vis\n+This structure inherits from @code{struct tree_decl_with_rtl}.  It\n+contains fields necessary to store visibility information, as well as\n+a section name and assembler name.\n+\n+@item struct tree_var_decl\n+This structure inherits from @code{struct tree_decl_with_vis}.  It is\n+used to represent @code{VAR_DECL}.  \n+\n+@item struct tree_function_decl\n+This structure inherits from @code{struct tree_decl_with_vis}.  It is\n+used to represent @code{FUNCTION_DECL}.  \n+\n+@end table\n+@node Adding new DECL node types\n+@subsubsection Adding new DECL node types\n+\n+Adding a new @code{DECL} tree consists of the following steps\n+\n+@table @asis\n+\n+@item Add a new tree code for the @code{DECL} node\n+For language specific @code{DECL} nodes, there is a @file{.def} file\n+in each frontend directory where the tree code should be added.\n+For @code{DECL} nodes that are part of the middle-end, the code should\n+be added to @file{tree.def}.\n+\n+@item Create a new structure type for the @code{DECL} node\n+These structures should inherit from one of the existing structures in\n+the language hierarchy by using that structure as the first member.\n+\n+@smallexample\n+struct tree_foo_decl\n+@{\n+   struct tree_decl_with_vis common;\n+@}\n+@end smallexample\n+\n+Would create a structure name @code{tree_foo_decl} that inherits from\n+@code{struct tree_decl_with_vis}.\n+\n+For language specific @code{DECL} nodes, this new structure type\n+should go in the appropriate @file{.h} file.\n+For @code{DECL} nodes that are part of the middle-end, the structure\n+type should go in @file{tree.h}.\n+\n+@item Add a member to the tree structure enumerator for the node\n+For garbage collection and dynamic checking purposes, each @code{DECL}\n+node structure type is required to have a unique enumerator value\n+specified with it.\n+For language specific @code{DECL} nodes, this new enumerator value\n+should go in the approriate @file{.def} file.\n+For @code{DECL} nodes that are part of the middle-end, the enumerator\n+values are specified in @file{treestruct.def}.\n+\n+@item Update @code{union tree_node}\n+In order to make your new structure type usable, it must be added to\n+@code{union tree_node}.\n+For language specific @code{DECL} nodes, a new entry should be added\n+to the approriate @file{.h} file of the form\n+@smallexample\n+  struct tree_foo_decl GTY ((tag (\"TS_VAR_DECL\"))) foo_decl;\n+@end smallexample\n+For @code{DECL} nodes that are part of the middle-end, the additional\n+member goes directly into @code{union tree_node} in @file{tree.h}.\n+\n+@item Update dynamic checking info\n+In order to be able to check whether accessing a named portion of\n+@code{union tree_node} is legal, and whether a certain @code{DECL} node\n+contains one of the enumerated @code{DECL} node structures in the\n+hierarchy, a simple lookup table is used.\n+This lookup table needs to be kept up to date with the tree structure\n+hierarchy, or else checking and containment macros will fail\n+inapproriately.\n+\n+For language specific @code{DECL} nodes, their is an @code{init_ts}\n+function in an approriate @file{.c} file, which initializes the lookup\n+table.\n+Code setting up the table for new @code{DECL} nodes should be added\n+there.\n+For each @code{DECL} tree code and enumerator value representing a\n+member of the inheritance  hierarchy, the table should contain 1 if\n+that tree code inherits (directly or indirectly) from that member.\n+Thus, a @code{FOO_DECL} node derived from @code{struct decl_with_rtl},\n+and enumerator value @code{TS_FOO_DECL}, would be set up as follows\n+@smallexample\n+tree_contains_struct[FOO_DECL][TS_FOO_DECL] = 1;\n+tree_contains_struct[FOO_DECL][TS_DECL_WRTL] = 1;\n+tree_contains_struct[FOO_DECL][TS_DECL_COMMON] = 1;\n+tree_contains_struct[FOO_DECL][TS_DECL_MINIMAL] = 1;\n+@end smallexample\n+\n+For @code{DECL} nodes that are part of the middle-end, the setup code\n+goes into @file{tree.c}.\n+\n+@item Add macros to access any new fields and flags\n+\n+Each added field or flag should have a macro that is used to access\n+it, that performs approriate checking to ensure only the right type of\n+@code{DECL} nodes access the field.\n+\n+These macros generally take the following form\n+@smallexample\n+#define FOO_DECL_FIELDNAME(NODE) FOO_DECL_CHECK(NODE)->foo_decl.fieldname\n+@end smallexample\n+However, if the structure is simply a base class for further\n+structures, something like the following should be used\n+@smallexample\n+#define BASE_STRUCT_CHECK(T) CONTAINS_STRUCT_CHECK(T, TS_BASE_STRUCT)\n+#define BASE_STRUCT_FIELDNAME(NODE) \\\n+   (BASE_STRUCT_CHECK(NODE)->base_struct.fieldname\n+@end smallexample\n+\n+@end table\n+\n+\n @c ---------------------------------------------------------------------\n @c Functions\n @c ---------------------------------------------------------------------"}, {"sha": "b4be05218619da7cb5df9f9bab6f37ce8ae0ba06", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -4631,6 +4631,9 @@ dwarf_form_name (unsigned int form)\n static tree\n decl_ultimate_origin (tree decl)\n {\n+  if (!CODE_CONTAINS_STRUCT (TREE_CODE (decl), TS_DECL_COMMON))\n+    return NULL_TREE;\n+\n   /* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the\n      nodes in the function to point to themselves; ignore that if\n      we're trying to output the abstract instance of this function.  */\n@@ -10143,7 +10146,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t XXX: If you split a variable across multiple sections, this\n \t won't notice.  */\n \n-      if (DECL_SECTION_NAME (decl))\n+      if (VAR_OR_FUNCTION_DECL_P (decl) && DECL_SECTION_NAME (decl))\n \t{\n \t  tree sectree = DECL_SECTION_NAME (decl);\n \t  secname = TREE_STRING_POINTER (sectree);"}, {"sha": "fc34f6ecb51a476f651f158172cda3fa42295731", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -954,7 +954,7 @@ set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n void\n set_decl_rtl (tree t, rtx x)\n {\n-  DECL_CHECK (t)->decl.rtl = x;\n+  DECL_WRTL_CHECK (t)->decl_with_rtl.rtl = x;\n \n   if (!x)\n     return;"}, {"sha": "a58ae0ff57817793fa0c3321b7f0026dd8d98e57", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -4939,7 +4939,7 @@ make_tree (tree type, rtx x)\n \n       /* Note that we do *not* use SET_DECL_RTL here, because we do not\n \t want set_decl_rtl to go adjusting REG_ATTRS for this temporary.  */\n-      t->decl.rtl = x;\n+      t->decl_with_rtl.rtl = x;\n \n       return t;\n     }"}, {"sha": "beee337487b63589742ff6b7b0512117b8b364ba", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -8736,7 +8736,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t object against zero, then we know the result.  */\n       if ((code == EQ_EXPR || code == NE_EXPR)\n \t  && TREE_CODE (arg0) == ADDR_EXPR\n-\t  && DECL_P (TREE_OPERAND (arg0, 0))\n+\t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg0, 0))\n \t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n \t  && integer_zerop (arg1))\n \treturn constant_boolean_node (code != EQ_EXPR, type);\n@@ -8746,13 +8746,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t have access to attributes for externs), then we know the result.  */\n       if ((code == EQ_EXPR || code == NE_EXPR)\n \t  && TREE_CODE (arg0) == ADDR_EXPR\n-\t  && DECL_P (TREE_OPERAND (arg0, 0))\n+\t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg0, 0))\n \t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n \t  && ! lookup_attribute (\"alias\",\n \t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg0, 0)))\n \t  && ! DECL_EXTERNAL (TREE_OPERAND (arg0, 0))\n \t  && TREE_CODE (arg1) == ADDR_EXPR\n-\t  && DECL_P (TREE_OPERAND (arg1, 0))\n+\t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg1, 0))\n \t  && ! DECL_WEAK (TREE_OPERAND (arg1, 0))\n \t  && ! lookup_attribute (\"alias\",\n \t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg1, 0)))\n@@ -10181,14 +10181,14 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n {\n   void **slot;\n   enum tree_code code;\n-  char buf[sizeof (struct tree_decl)];\n+  char buf[sizeof (struct tree_decl_non_common)];\n   int i, len;\n   \n recursive_label:\n \n   gcc_assert ((sizeof (struct tree_exp) + 5 * sizeof (tree)\n-\t       <= sizeof (struct tree_decl))\n-\t      && sizeof (struct tree_type) <= sizeof (struct tree_decl));\n+\t       <= sizeof (struct tree_decl_non_common))\n+\t      && sizeof (struct tree_type) <= sizeof (struct tree_decl_non_common));\n   if (expr == NULL)\n     return;\n   slot = htab_find_slot (ht, expr, INSERT);\n@@ -10834,7 +10834,7 @@ tree_expr_nonzero_p (tree t)\n \t  return false;\n \n \t/* Weak declarations may link to NULL.  */\n-\tif (DECL_P (base))\n+\tif (VAR_OR_FUNCTION_DECL_P (base))\n \t  return !DECL_WEAK (base);\n \n \t/* Constants are never weak.  */"}, {"sha": "4d6a44bd7f47b04c28306d217599ab3bcea3c612", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1,3 +1,8 @@\n+2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* trans-decl.c (create_function_arglist): DECL_ARG_TYPE_AS_WRITTEN\n+\tis removed.\n+\n 2005-07-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* primary.c (gfc_match_rvalue): Handle ENTRY the same way"}, {"sha": "ad53cbdc5a7032cc66ea9a135c7f43967ff343e9", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1217,7 +1217,6 @@ create_function_arglist (gfc_symbol * sym)\n \t  /* Fill in arg stuff.  */\n \t  DECL_CONTEXT (parm) = fndecl;\n \t  DECL_ARG_TYPE (parm) = type;\n-\t  DECL_ARG_TYPE_AS_WRITTEN (parm) = type;\n \t  /* All implementation args are read-only.  */\n \t  TREE_READONLY (parm) = 1;\n "}, {"sha": "85b73adf8afb492aef6faf83f25679a16d7530e0", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -186,7 +186,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n static const size_t extra_order_size_table[] = {\n   sizeof (struct stmt_ann_d),\n-  sizeof (struct tree_decl),\n+  sizeof (struct tree_decl_non_common),\n+  sizeof (struct tree_field_decl),\n+  sizeof (struct tree_parm_decl),\n+  sizeof (struct tree_var_decl),\n   sizeof (struct tree_list),\n   TREE_EXP_SIZE (2),\n   RTL_SIZE (2),\t\t\t/* MEM, PLUS, etc.  */"}, {"sha": "13cf0267fc350eb938c25523ace3e3bae4e27500", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -860,7 +860,8 @@ gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n   /* Mark variables seen in this bind expr.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n     {\n-      DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n+      if (TREE_CODE (t) == VAR_DECL)\n+\tDECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n \n       /* Preliminarily mark non-addressed complex variables as eligible\n \t for promotion to gimple registers.  We'll transform their uses\n@@ -3035,7 +3036,8 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t\t When optimizing, the return_slot pass marks more functions\n \t\t as safe after we have escape info.  */\n \t      use_target = false;\n-\t    else if (DECL_GIMPLE_FORMAL_TEMP_P (*to_p))\n+\t    else if (TREE_CODE (*to_p) != PARM_DECL \n+\t\t     && DECL_GIMPLE_FORMAL_TEMP_P (*to_p))\n \t      /* Don't use the original target if it's a formal temp; we\n \t\t don't want to take their addresses.  */\n \t      use_target = false;"}, {"sha": "eadf6606830205aa1ef454d9c5c95755b7a57900", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -137,7 +137,8 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n   DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (decl);\n \n   /* The new variable/label has no RTL, yet.  */\n-  if (!TREE_STATIC (copy) && !DECL_EXTERNAL (copy))\n+  if (CODE_CONTAINS_STRUCT (TREE_CODE (copy), TS_DECL_WRTL) \n+      && !TREE_STATIC (copy) && !DECL_EXTERNAL (copy))\n     SET_DECL_RTL (copy, NULL_RTX);\n \n   /* These args would always appear unused, if not for this.  */"}, {"sha": "b1eed198a8fdca93f6a1a05353c7ba8f288f4ceb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1,3 +1,10 @@\n+2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* java-tree.h (LABEL_RETURN_LABELS): Use decl_non_common.\n+\t(LABEL_PENDING_CHAIN): Ditto.\n+\t(LABEL_PC): Ditto.\n+\t(DECL_BIT_INDEX): Ditto.\t\n+\n 2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n \n \tPR java/18119"}, {"sha": "5b6343578796427e7f29eb746e65a71df87f36ee", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -850,11 +850,11 @@ union lang_tree_node\n #define FIELD_THISN(DECL) DECL_LANG_FLAG_7 (VAR_OR_FIELD_CHECK (DECL))\n \n /* In a LABEL_DECL, a TREE_VEC that saves the type_map at that point. */\n-#define LABEL_TYPE_STATE(NODE) (DECL_INITIAL (LABEL_DECL_CHECK (NODE)))\n+#define LABEL_TYPE_STATE(NODE) (LABEL_DECL_CHECK (NODE)->label_decl.java_field_1)\n \n /* In the label of a subroutine, a dummy label that records the\n    state following a merge of all the ret instructions in this subroutine. */\n-#define LABEL_RETURN_LABEL(DECL) DECL_ARGUMENTS(DECL)\n+#define LABEL_RETURN_LABEL(DECL) (LABEL_DECL_CHECK (DECL)->label_decl.java_field_2)\n \n /* In the label of a sub-routine, records the type state at return.\n    A local may be TYPE_UNUSED, which means that the local is not\n@@ -869,14 +869,14 @@ union lang_tree_node\n \n /* In the label of a sub-routine, a chain of the return location labels. */\n #define LABEL_RETURN_LABELS(node) \\\n-  (LABEL_DECL_CHECK (LABEL_RETURN_LABEL (node))->decl.result)\n+  (LABEL_DECL_CHECK (LABEL_RETURN_LABEL (node))->label_decl.java_field_3)\n \n /* In a LABEL_DECL, the next pending label.\n    See pending_blocks in expr.c. */\n-#define LABEL_PENDING_CHAIN(NODE) (LABEL_DECL_CHECK (NODE)->decl.result)\n+#define LABEL_PENDING_CHAIN(NODE) (LABEL_DECL_CHECK (NODE)->label_decl.java_field_3)\n \n /* In a LABEL_DECL, the corresponding bytecode program counter. */\n-#define LABEL_PC(NODE) (LABEL_DECL_CHECK (NODE)->decl.u2.i)\n+#define LABEL_PC(NODE) (LABEL_DECL_CHECK (NODE)->label_decl.java_field_4)\n \n /* Used during verification to mark the label has \"changed\". (See JVM Spec). */\n #define LABEL_CHANGED(NODE) DECL_LANG_FLAG_6 (LABEL_DECL_CHECK (NODE))\n@@ -969,7 +969,7 @@ union lang_tree_node\n    that specifies if this decl is definitively assigned.\n    The value -1 means the variable has been definitely assigned (and not\n    definitely unassigned).  The value -2 means we already reported an error. */\n-#define DECL_BIT_INDEX(DECL) VAR_OR_FIELD_CHECK (DECL)->decl.pointer_alias_set\n+#define DECL_BIT_INDEX(DECL) VAR_OR_FIELD_CHECK (DECL)->decl_common.pointer_alias_set\n \n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl_func GTY(())"}, {"sha": "a17927a2eb26f09dd9e732959847c2527ec3d48f", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -126,6 +126,7 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n #define LANG_HOOKS_BUILTIN_FUNCTION\tbuiltin_function\n #define LANG_HOOKS_EXPR_TO_DECL\t\tlhd_expr_to_decl\n #define LANG_HOOKS_TO_TARGET_CHARSET\tlhd_to_target_charset\n+#define LANG_HOOKS_INIT_TS\t\tlhd_do_nothing\n \n #define LANG_HOOKS_FUNCTION_INIT\tlhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_FINAL\tlhd_do_nothing_f\n@@ -301,6 +302,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_GIMPLIFY_EXPR, \\\n   LANG_HOOKS_FOLD_OBJ_TYPE_REF, \\\n   LANG_HOOKS_BUILTIN_FUNCTION, \\\n+  LANG_HOOKS_INIT_TS,          \\\n   LANG_HOOKS_EXPR_TO_DECL, \\\n }\n "}, {"sha": "cdb547c7cf3140078f9e95a2393cbc0d28b7e0f2", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -412,6 +412,9 @@ struct lang_hooks\n \t\t\t    enum built_in_class bt_class,\n \t\t\t    const char *library_name, tree attrs);\n \n+  /* Used to set up the tree_contains_structure array for a frontend. */\n+  void (*init_ts) (void);\n+\n   /* Called by recompute_tree_invarant_for_addr_expr to go from EXPR\n      to a contained expression or DECL, possibly updating *TC, *TI or\n      *SE if in the process TREE_CONSTANT, TREE_INVARIANT or"}, {"sha": "9bd62da8e4fec85190b0e763965a9c812417a6bb", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1,3 +1,17 @@\n+2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* objc-act.c (objc_push_parm): DECL_ARG_TYPE_AS_WRITTEN is\n+\tremoved.\n+\t* objc-act.h (KEYWORD_ARG_NAME): Use decl_non_common.\n+\t(KEYWORD_KEY_NAME): Use decl_minimal.\n+\t(METHOD_SEL_NAME): Ditto..\n+\t(METHOD_SEL_ARGS): Use decl_non_common.\n+\t(METHOD_ADD_ARGS): Ditto.\n+\t(METHOD_ADD_ARGS_ELLIPSIS_P): Use decl_common.\n+\t(METHOD_DEFINITION): Ditto.\n+\t(METHOD_ENCODING): Ditto.\n+\t* objc-lang.c: (objc_init_ts): New function.\n+\n 2005-07-07  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc-act.c (objc_build_struct): Pass in an actual @interface"}, {"sha": "ee7b0287271574073d4061ad348c0946fb7fb1be", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -8244,7 +8244,6 @@ objc_push_parm (tree parm)\n   else if (TREE_CODE (TREE_TYPE (parm)) == FUNCTION_TYPE)\n     TREE_TYPE (parm) = build_pointer_type (TREE_TYPE (parm));\n \n-  DECL_ARG_TYPE_AS_WRITTEN (parm) = TREE_TYPE (parm);\n   DECL_ARG_TYPE (parm)\n     = lang_hooks.types.type_promotes_to (TREE_TYPE (parm));\n "}, {"sha": "d801865688bb77813c25fae3d992ee697698083c", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -44,16 +44,16 @@ enum gimplify_status objc_gimplify_expr (tree *, tree *, tree *);\n #define OBJC_INFO_SLOT_ELTS\t\t2\n \n /* KEYWORD_DECL */\n-#define KEYWORD_KEY_NAME(DECL) ((DECL)->decl.name)\n-#define KEYWORD_ARG_NAME(DECL) ((DECL)->decl.arguments)\n+#define KEYWORD_KEY_NAME(DECL) ((DECL)->decl_minimal.name)\n+#define KEYWORD_ARG_NAME(DECL) ((DECL)->decl_non_common.arguments)\n \n /* INSTANCE_METHOD_DECL, CLASS_METHOD_DECL */\n-#define METHOD_SEL_NAME(DECL) ((DECL)->decl.name)\n-#define METHOD_SEL_ARGS(DECL) ((DECL)->decl.arguments)\n-#define METHOD_ADD_ARGS(DECL) ((DECL)->decl.result)\n-#define METHOD_ADD_ARGS_ELLIPSIS_P(DECL) ((DECL)->decl.lang_flag_0)\n-#define METHOD_DEFINITION(DECL) ((DECL)->decl.initial)\n-#define METHOD_ENCODING(DECL) ((DECL)->decl.context)\n+#define METHOD_SEL_NAME(DECL) ((DECL)->decl_minimal.name)\n+#define METHOD_SEL_ARGS(DECL) ((DECL)->decl_non_common.arguments)\n+#define METHOD_ADD_ARGS(DECL) ((DECL)->decl_non_common.result)\n+#define METHOD_ADD_ARGS_ELLIPSIS_P(DECL) ((DECL)->decl_common.lang_flag_0)\n+#define METHOD_DEFINITION(DECL) ((DECL)->decl_common.initial)\n+#define METHOD_ENCODING(DECL) ((DECL)->decl_minimal.context)\n \n /* CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,"}, {"sha": "b94f037c54789b5ba85aed38cd244cf5870f3580", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -34,6 +34,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"c-objc-common.h\"\n \n enum c_language_kind c_language = clk_objc;\n+static void objc_init_ts (void);\n \n /* Lang hooks common to C and ObjC are declared in c-objc-common.h;\n    consequently, there should be very few hooks below.  */\n@@ -48,6 +49,8 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_GIMPLIFY_EXPR objc_gimplify_expr\n #undef LANG_HOOKS_GET_CALLEE_FNDECL\n #define LANG_HOOKS_GET_CALLEE_FNDECL\tobjc_get_callee_fndecl\n+#undef LANG_HOOKS_INIT_TS\n+#define LANG_HOOKS_INIT_TS objc_init_ts\n \n /* Each front end provides its own lang hook initializer.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n@@ -97,6 +100,30 @@ const char * const tree_code_name[] = {\n /* Lang hook routines common to C and ObjC appear in c-objc-common.c;\n    there should be very few (if any) routines below.  */\n \n+static void\n+objc_init_ts (void)\n+{\n+  tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[KEYWORD_DECL][TS_DECL_NON_COMMON] = 1;\n+  \n+  tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[KEYWORD_DECL][TS_DECL_WITH_VIS] = 1;\n+\n+  tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[KEYWORD_DECL][TS_DECL_WRTL] = 1;\n+  \n+  tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[KEYWORD_DECL][TS_DECL_MINIMAL] = 1;\n+  \n+  tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[KEYWORD_DECL][TS_DECL_COMMON] = 1;\n+}\n+\n void\n finish_file (void)\n {"}, {"sha": "8d1411a89e72c93883c015fcddcd9d638b7b8b4d", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -137,7 +137,7 @@ rest_of_decl_compilation (tree decl,\n \n   /* Can't defer this, because it needs to happen before any\n      later function definitions are processed.  */\n-  if (DECL_REGISTER (decl) && DECL_ASSEMBLER_NAME_SET_P (decl))\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl) && DECL_REGISTER (decl))\n     make_decl_rtl (decl);\n \n   /* Forward declarations for nested functions are not \"external\","}, {"sha": "9bd79f4452e95dd1a2b670df54ef7d3cf307e916", "filename": "gcc/print-tree.c", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -167,11 +167,13 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   int len;\n   int i;\n   expanded_location xloc;\n+  enum tree_code code;\n \n   if (node == 0)\n     return;\n-\n-  class = TREE_CODE_CLASS (TREE_CODE (node));\n+  \n+  code = TREE_CODE (node);\n+  class = TREE_CODE_CLASS (code);\n \n   /* Don't get too deep in nesting.  If the user wants to see deeper,\n      it is easy to use the address of a lowest-level node\n@@ -319,21 +321,23 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (DECL_IGNORED_P (node))\n \tfputs (\" ignored\", file);\n       if (DECL_ABSTRACT (node))\n-\tfputs (\" abstract\", file);\n-      if (DECL_IN_SYSTEM_HEADER (node))\n-\tfputs (\" in_system_header\", file);\n-      if (DECL_COMMON (node))\n-\tfputs (\" common\", file);\n+\tfputs (\" abstract\", file);      \n       if (DECL_EXTERNAL (node))\n \tfputs (\" external\", file);\n-      if (DECL_WEAK (node))\n-\tfputs (\" weak\", file);\n-      if (DECL_REGISTER (node) && TREE_CODE (node) != FIELD_DECL\n-\t  && TREE_CODE (node) != FUNCTION_DECL\n-\t  && TREE_CODE (node) != LABEL_DECL)\n-\tfputs (\" regdecl\", file);\n       if (DECL_NONLOCAL (node))\n \tfputs (\" nonlocal\", file);\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+\t{\n+\t  if (DECL_WEAK (node))\n+\t    fputs (\" weak\", file);\n+\t  if (DECL_IN_SYSTEM_HEADER (node))\n+\t    fputs (\" in_system_header\", file);\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL)\n+\t  && TREE_CODE (node) != LABEL_DECL\n+\t  && TREE_CODE (node) != FUNCTION_DECL\n+\t  && DECL_REGISTER (node))\n+\tfputs (\" regdecl\", file);\n \n       if (TREE_CODE (node) == TYPE_DECL && TYPE_DECL_SUPPRESS_DEBUG (node))\n \tfputs (\" suppress-debug\", file);\n@@ -357,6 +361,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n       if (TREE_CODE (node) == VAR_DECL && DECL_IN_TEXT_SECTION (node))\n \tfputs (\" in-text-section\", file);\n+      if (TREE_CODE (node) == VAR_DECL && DECL_COMMON (node))\n+\tfputs (\" common\", file);\n       if (TREE_CODE (node) == VAR_DECL && DECL_THREAD_LOCAL_P (node))\n \t{\n \t  enum tls_model kind = DECL_TLS_MODEL (node);\n@@ -384,7 +390,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n       if (DECL_VIRTUAL_P (node))\n \tfputs (\" virtual\", file);\n-      if (DECL_DEFER_OUTPUT (node))\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS)  && DECL_DEFER_OUTPUT (node))\n \tfputs (\" defer-output\", file);\n \n       if (DECL_PRESERVE_P (node))\n@@ -450,13 +456,20 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t}\n \n       print_node_brief (file, \"context\", DECL_CONTEXT (node), indent + 4);\n+\n       print_node_brief (file, \"attributes\",\n \t\t\tDECL_ATTRIBUTES (node), indent + 4);\n-      print_node_brief (file, \"abstract_origin\",\n-\t\t\tDECL_ABSTRACT_ORIGIN (node), indent + 4);\n-\n-      print_node (file, \"arguments\", DECL_ARGUMENTS (node), indent + 4);\n-      print_node (file, \"result\", DECL_RESULT_FLD (node), indent + 4);\n+      \n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+\t{\n+\t  print_node_brief (file, \"abstract_origin\",\n+\t\t\t    DECL_ABSTRACT_ORIGIN (node), indent + 4);\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+\t{\n+\t  print_node (file, \"arguments\", DECL_ARGUMENTS (node), indent + 4);\n+\t  print_node (file, \"result\", DECL_RESULT_FLD (node), indent + 4);\n+\t}\n       print_node_brief (file, \"initial\", DECL_INITIAL (node), indent + 4);\n \n       lang_hooks.print_decl (file, node, indent);\n@@ -470,8 +483,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (TREE_CODE (node) == PARM_DECL)\n \t{\n \t  print_node (file, \"arg-type\", DECL_ARG_TYPE (node), indent + 4);\n-\t  print_node (file, \"arg-type-as-written\",\n-\t\t      DECL_ARG_TYPE_AS_WRITTEN (node), indent + 4);\n \n \t  if (DECL_INCOMING_RTL (node) != 0)\n \t    {"}, {"sha": "8e7da03c7e00f508862e39b57240310a5220939e", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -704,7 +704,8 @@ wrapup_global_declarations (tree *vec, int len)\n \n       /* We're not deferring this any longer.  Assignment is\n \t conditional to avoid needlessly dirtying PCH pages.  */\n-      if (DECL_DEFER_OUTPUT (decl) != 0)\n+      if (CODE_CONTAINS_STRUCT (TREE_CODE (decl), TS_DECL_WITH_VIS)\n+\t  && DECL_DEFER_OUTPUT (decl) != 0)\n \tDECL_DEFER_OUTPUT (decl) = 0;\n \n       if (TREE_CODE (decl) == VAR_DECL && DECL_SIZE (decl) == 0)"}, {"sha": "0c3eba0b631c735faa517d24ee177ec549fadca5", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -313,13 +313,6 @@ browse_tree (tree begin)\n \t    TB_WF;\n \t  break;\n \n-\tcase TB_ARG_TYPE_AS_WRITTEN:\n-\t  if (head && TREE_CODE (head) == PARM_DECL)\n-\t    TB_SET_HEAD (DECL_ARG_TYPE_AS_WRITTEN (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n \tcase TB_ARG_TYPE:\n \t  if (head && TREE_CODE (head) == PARM_DECL)\n \t    TB_SET_HEAD (DECL_ARG_TYPE (head));"}, {"sha": "ca00892ab0d13b6466ce4aca3d92d37ca54f78fc", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -209,9 +209,6 @@ remap_decl (tree decl, inline_data *id)\n       TREE_TYPE (t) = remap_type (TREE_TYPE (t), id);\n       if (TREE_CODE (t) == TYPE_DECL)\n         DECL_ORIGINAL_TYPE (t) = remap_type (DECL_ORIGINAL_TYPE (t), id);\n-      else if (TREE_CODE (t) == PARM_DECL)\n-        DECL_ARG_TYPE_AS_WRITTEN (t)\n-\t  = remap_type (DECL_ARG_TYPE_AS_WRITTEN (t), id);\n \n       /* Remap sizes as necessary.  */\n       walk_tree (&DECL_SIZE (t), copy_body_r, id, NULL);"}, {"sha": "1d61de214f0054bfb8b24647d5e129d15b03cc6d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -1578,7 +1578,7 @@ print_declaration (pretty_printer *buffer, tree t, int spc, int flags)\n   if (TREE_CODE (t) == TYPE_DECL)\n     pp_string (buffer, \"typedef \");\n \n-  if (DECL_REGISTER (t))\n+  if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_WRTL) && DECL_REGISTER (t))\n     pp_string (buffer, \"register \");\n \n   if (TREE_PUBLIC (t) && DECL_EXTERNAL (t))"}, {"sha": "5655e119943e717a1d6f81ba677edbb0d635c467", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -111,7 +111,7 @@ expr_computes_nonzero (tree expr)\n      has requested not to remove NULL pointer checks.  */\n   if (flag_delete_null_pointer_checks\n       && TREE_CODE (expr) == ADDR_EXPR\n-      && DECL_P (TREE_OPERAND (expr, 0))\n+      && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (expr, 0))\n       && !DECL_WEAK (TREE_OPERAND (expr, 0)))\n     return true;\n "}, {"sha": "20cd722ec0f194fa2526c10fb4eb1b7b920903ec", "filename": "gcc/tree.c", "status": "modified", "additions": 214, "deletions": 23, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -133,44 +133,48 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n \n /* General tree->tree mapping  structure for use in hash tables.  */\n \n-struct tree_map GTY(())\n-{\n-  hashval_t hash;\n-  tree from;\n-  tree to;\n-};\n \n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n      htab_t debug_expr_for_decl;\n \n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n      htab_t value_expr_for_decl;\n \n+static GTY ((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n+  htab_t init_priority_for_decl;\n+\n+struct tree_int_map GTY(())\n+{\n+  tree from;\n+  unsigned short to;\n+};\n+static unsigned int tree_int_map_hash (const void *);\n+static int tree_int_map_eq (const void *, const void *);\n+static int tree_int_map_marked_p (const void *);\n static void set_type_quals (tree, int);\n static int type_hash_eq (const void *, const void *);\n static hashval_t type_hash_hash (const void *);\n-static int tree_map_eq (const void *, const void *);\n-static hashval_t tree_map_hash (const void *);\n static hashval_t int_cst_hash_hash (const void *);\n static int int_cst_hash_eq (const void *, const void *);\n static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n static tree make_vector_type (tree, int, enum machine_mode);\n static int type_hash_marked_p (const void *);\n-static int tree_map_marked_p (const void *);\n static unsigned int type_hash_list (tree, hashval_t);\n static unsigned int attribute_hash_list (tree, hashval_t);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n \n+unsigned char tree_contains_struct[256][64];\n \f\n /* Init tree.c.  */\n \n void\n init_ttree (void)\n {\n+\n   /* Initialize the hash table of types.  */\n   type_hash_table = htab_create_ggc (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n \t\t\t\t     type_hash_eq, 0);\n@@ -180,12 +184,62 @@ init_ttree (void)\n \n   value_expr_for_decl = htab_create_ggc (512, tree_map_hash,\n \t\t\t\t\t tree_map_eq, 0);\n+  init_priority_for_decl = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t\t    tree_int_map_eq, 0);\n \n   int_cst_hash_table = htab_create_ggc (1024, int_cst_hash_hash,\n \t\t\t\t\tint_cst_hash_eq, NULL);\n   \n   int_cst_node = make_node (INTEGER_CST);\n \n+  tree_contains_struct[FUNCTION_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[TYPE_DECL][TS_DECL_NON_COMMON] = 1;\n+  \n+\n+  tree_contains_struct[CONST_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[VAR_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[PARM_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[RESULT_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[FUNCTION_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[TYPE_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[LABEL_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[FIELD_DECL][TS_DECL_COMMON] = 1;\n+\n+\n+  tree_contains_struct[CONST_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[VAR_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[PARM_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[RESULT_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[FUNCTION_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[LABEL_DECL][TS_DECL_WRTL] = 1; \n+\n+  tree_contains_struct[CONST_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[VAR_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[PARM_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[RESULT_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[FUNCTION_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[TYPE_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[LABEL_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[FIELD_DECL][TS_DECL_MINIMAL] = 1;\n+\n+  tree_contains_struct[VAR_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[FUNCTION_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[TYPE_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_WITH_VIS] = 1;\n+  \n+  tree_contains_struct[VAR_DECL][TS_VAR_DECL] = 1;\n+  tree_contains_struct[FIELD_DECL][TS_FIELD_DECL] = 1;\n+  tree_contains_struct[PARM_DECL][TS_PARM_DECL] = 1;\n+  tree_contains_struct[LABEL_DECL][TS_LABEL_DECL] = 1;\n+  tree_contains_struct[RESULT_DECL][TS_RESULT_DECL] = 1;\n+  tree_contains_struct[CONST_DECL][TS_CONST_DECL] = 1;\n+  tree_contains_struct[TYPE_DECL][TS_TYPE_DECL] = 1;\n+  tree_contains_struct[FUNCTION_DECL][TS_FUNCTION_DECL] = 1;\n+\n+  lang_hooks.init_ts ();\n }\n \n \f\n@@ -197,7 +251,7 @@ decl_assembler_name (tree decl)\n {\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n     lang_hooks.set_decl_assembler_name (decl);\n-  return DECL_CHECK (decl)->decl.assembler_name;\n+  return DECL_WITH_VIS_CHECK (decl)->decl_with_vis.assembler_name;\n }\n \n /* Compute the number of bytes occupied by a tree with code CODE.\n@@ -209,7 +263,29 @@ tree_code_size (enum tree_code code)\n   switch (TREE_CODE_CLASS (code))\n     {\n     case tcc_declaration:  /* A decl node */\n-      return sizeof (struct tree_decl);\n+      {\n+\tswitch (code)\n+\t  {\n+\t  case FIELD_DECL:\n+\t    return sizeof (struct tree_field_decl);\n+\t  case PARM_DECL:\n+\t    return sizeof (struct tree_parm_decl);\n+\t  case VAR_DECL:\n+\t    return sizeof (struct tree_var_decl);\n+\t  case LABEL_DECL:\n+\t    return sizeof (struct tree_label_decl);\n+\t  case RESULT_DECL:\n+\t    return sizeof (struct tree_result_decl);\n+\t  case CONST_DECL:\n+\t    return sizeof (struct tree_const_decl);\n+\t  case TYPE_DECL:\n+\t    return sizeof (struct tree_type_decl);\n+\t  case FUNCTION_DECL:\n+\t    return sizeof (struct tree_function_decl);\n+\t  default:\n+\t    return sizeof (struct tree_decl_non_common);\n+\t  }\n+      }\n \n     case tcc_type:  /* a type node */\n       return sizeof (struct tree_type);\n@@ -395,12 +471,13 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       if (code != FUNCTION_DECL)\n \tDECL_ALIGN (t) = 1;\n       DECL_USER_ALIGN (t) = 0;\n-      DECL_IN_SYSTEM_HEADER (t) = in_system_header;\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+\tDECL_IN_SYSTEM_HEADER (t) = in_system_header;\n+      /* We have not yet computed the alias set for this declaration.  */\n+      DECL_POINTER_ALIAS_SET (t) = -1;\n       DECL_SOURCE_LOCATION (t) = input_location;\n       DECL_UID (t) = next_decl_uid++;\n \n-      /* We have not yet computed the alias set for this declaration.  */\n-      DECL_POINTER_ALIAS_SET (t) = -1;\n       break;\n \n     case tcc_type:\n@@ -480,6 +557,11 @@ copy_node_stat (tree node MEM_STAT_DECL)\n \t  SET_DECL_VALUE_EXPR (t, DECL_VALUE_EXPR (node));\n \t  DECL_HAS_VALUE_EXPR_P (t) = 1;\n \t}\n+      if (TREE_CODE (node) == VAR_DECL && DECL_HAS_INIT_PRIORITY_P (node))\n+\t{\n+\t  SET_DECL_INIT_PRIORITY (t, DECL_INIT_PRIORITY (node));\n+\t  DECL_HAS_INIT_PRIORITY_P (t) = 1;\n+\t}\n       \n     }\n   else if (TREE_CODE_CLASS (code) == tcc_type)\n@@ -1814,9 +1896,31 @@ tree_node_structure (tree t)\n   enum tree_code code = TREE_CODE (t);\n \n   switch (TREE_CODE_CLASS (code))\n-    {\n+    {      \n     case tcc_declaration:\n-      return TS_DECL;\n+      {\n+\tswitch (code)\n+\t  {\n+\t  case FIELD_DECL:\n+\t    return TS_FIELD_DECL;\n+\t  case PARM_DECL:\n+\t    return TS_PARM_DECL;\n+\t  case VAR_DECL:\n+\t    return TS_VAR_DECL;\n+\t  case LABEL_DECL:\n+\t    return TS_LABEL_DECL;\n+\t  case RESULT_DECL:\n+\t    return TS_RESULT_DECL;\n+\t  case CONST_DECL:\n+\t    return TS_CONST_DECL;\n+\t  case TYPE_DECL:\n+\t    return TS_TYPE_DECL;\n+\t  case FUNCTION_DECL:\n+\t    return TS_FUNCTION_DECL;\n+\t  default:\n+\t    return TS_DECL_NON_COMMON;\n+\t  }\n+      }\n     case tcc_type:\n       return TS_TYPE;\n     case tcc_reference:\n@@ -2877,10 +2981,13 @@ build_decl_stat (enum tree_code code, tree name, tree type MEM_STAT_DECL)\n   else if (code == FUNCTION_DECL)\n     DECL_MODE (t) = FUNCTION_MODE;\n \n-  /* Set default visibility to whatever the user supplied with\n-     visibility_specified depending on #pragma GCC visibility.  */\n-  DECL_VISIBILITY (t) = default_visibility;\n-  DECL_VISIBILITY_SPECIFIED (t) = visibility_options.inpragma;\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      /* Set default visibility to whatever the user supplied with\n+\t visibility_specified depending on #pragma GCC visibility.  */\n+      DECL_VISIBILITY (t) = default_visibility;\n+      DECL_VISIBILITY_SPECIFIED (t) = visibility_options.inpragma;\n+    }\n \n   return t;\n }\n@@ -3513,7 +3620,7 @@ build_variant_type_copy (tree type)\n \f\n /* Return true if the from tree in both tree maps are equal.  */\n \n-static int\n+int\n tree_map_eq (const void *va, const void *vb)\n {\n   const struct tree_map  *a = va, *b = vb;\n@@ -3522,7 +3629,7 @@ tree_map_eq (const void *va, const void *vb)\n \n /* Hash a from tree in a tree_map.  */\n \n-static hashval_t\n+unsigned int\n tree_map_hash (const void *item)\n {\n   return (((const struct tree_map *) item)->hash);\n@@ -3532,14 +3639,73 @@ tree_map_hash (const void *item)\n    purposes.  We simply return true if the from tree is marked, so that this\n    structure goes away when the from tree goes away.  */\n \n-static int\n+int\n tree_map_marked_p (const void *p)\n {\n   tree from = ((struct tree_map *) p)->from;\n \n   return ggc_marked_p (from);\n }\n \n+/* Return true if the trees in the tree_int_map *'s VA and VB are equal.  */\n+\n+static int\n+tree_int_map_eq (const void *va, const void *vb)\n+{\n+  const struct tree_int_map  *a = va, *b = vb;\n+  return (a->from == b->from);\n+}\n+\n+/* Hash a from tree in the tree_int_map * ITEM.  */\n+\n+static unsigned int\n+tree_int_map_hash (const void *item)\n+{\n+  return htab_hash_pointer (((const struct tree_int_map *)item)->from);\n+}\n+\n+/* Return true if this tree int map structure is marked for garbage collection\n+   purposes.  We simply return true if the from tree_int_map *P's from tree is marked, so that this\n+   structure goes away when the from tree goes away.  */\n+\n+static int\n+tree_int_map_marked_p (const void *p)\n+{\n+  tree from = ((struct tree_int_map *) p)->from;\n+\n+  return ggc_marked_p (from);\n+}\n+/* Lookup an init priority for FROM, and return it if we find one.  */\n+\n+unsigned short\n+decl_init_priority_lookup (tree from)\n+{\n+  struct tree_int_map *h, in;\n+  in.from = from;\n+\n+  h = htab_find_with_hash (init_priority_for_decl, \n+\t\t\t   &in, htab_hash_pointer (from));\n+  if (h)\n+    return h->to;\n+  return 0;\n+}\n+\n+/* Insert a mapping FROM->TO in the init priority hashtable.  */\n+\n+void\n+decl_init_priority_insert (tree from, unsigned short to)\n+{\n+  struct tree_int_map *h;\n+  void **loc;\n+\n+  h = ggc_alloc (sizeof (struct tree_int_map));\n+  h->from = from;\n+  h->to = to;\n+  loc = htab_find_slot_with_hash (init_priority_for_decl, h, \n+\t\t\t\t  htab_hash_pointer (from), INSERT);\n+  *(struct tree_int_map **) loc = h;\n+}  \n+\n /* Print out the statistics for the DECL_DEBUG_EXPR hash table.  */\n \n static void\n@@ -5664,6 +5830,31 @@ tree_class_check_failed (const tree node, const enum tree_code_class cl,\n      TREE_CODE_CLASS_STRING (TREE_CODE_CLASS (TREE_CODE (node))),\n      tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n }\n+#undef DEFTREESTRUCT\n+#define DEFTREESTRUCT(VAL, NAME) NAME,\n+\n+static const char *ts_enum_names[] = {\n+#include \"treestruct.def\"\n+};\n+#undef DEFTREESTRUCT\n+\n+#define TS_ENUM_NAME(EN) (ts_enum_names[(EN)])\n+\n+/* Similar to tree_class_check_failed, except that we check for\n+   whether CODE contains the tree structure identified by EN.  */\n+\n+void\n+tree_contains_struct_check_failed (const tree node, \n+\t\t\t\t   const enum tree_node_structure_enum en,\n+\t\t\t\t   const char *file, int line, \n+\t\t\t\t   const char *function)\n+{\n+  internal_error\n+    (\"tree check: expected tree that contains %qs structure, have %qs  in %s, at %s:%d\",\n+     TS_ENUM_NAME(en),\n+     tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n+}\n+\n \n /* Similar to above, except that the check is for the bounds of a TREE_VEC's\n    (dynamically sized) vector.  */"}, {"sha": "eb9ebdcd05dc3df2595712efff93f778387b4961", "filename": "gcc/tree.h", "status": "modified", "additions": 658, "deletions": 480, "changes": 1138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -40,6 +40,9 @@ enum tree_code {\n \n #undef DEFTREECODE\n \n+extern unsigned char tree_contains_struct[256][64];\n+#define CODE_CONTAINS_STRUCT(CODE, STRUCT) (tree_contains_struct[(CODE)][(STRUCT)])\n+\n /* Number of language-independent tree codes.  */\n #define NUM_TREE_CODES ((int) LAST_AND_UNUSED_TREE_CODE)\n \n@@ -97,8 +100,14 @@ extern const enum tree_code_class tree_code_type[];\n #define DECL_P(CODE)\\\n         (TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_declaration)\n \n+/* Nonzero if DECL represents a VAR_DECL or FUNCTION_DECL.  */\n+\n+#define VAR_OR_FUNCTION_DECL_P(DECL)\\\n+  (TREE_CODE (DECL) == VAR_DECL || TREE_CODE (DECL) == FUNCTION_DECL)\n+\n /* Nonzero if CODE represents a INDIRECT_REF.  Keep these checks in\n    ascending code order.  */\n+\n #define INDIRECT_REF_P(CODE)\\\n   (TREE_CODE (CODE) == INDIRECT_REF \\\n    || TREE_CODE (CODE) == ALIGN_INDIRECT_REF \\\n@@ -433,6 +442,13 @@ struct tree_common GTY(())\n        TREE_NO_WARNING in\n            ... any expr or decl node\n */\n+#undef DEFTREESTRUCT\n+#define DEFTREESTRUCT(ENUM, NAME) ENUM,\n+enum tree_node_structure_enum {\n+#include \"treestruct.def\"\n+  LAST_TS_ENUM\n+};\n+#undef DEFTREESTRUCT\n \n /* Define accessors for the fields that all tree nodes have\n    (though some fields are not used for all kinds of nodes).  */\n@@ -536,6 +552,13 @@ struct tree_common GTY(())\n \t\t\t     (CODE1), (CODE2), (CODE3), (CODE4), (CODE5), 0);\\\n     __t; })\n \n+#define CONTAINS_STRUCT_CHECK(T, STRUCT) __extension__\t\t\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+  if (tree_contains_struct[TREE_CODE(__t)][(STRUCT)] != 1)\t\t\\\n+      tree_contains_struct_check_failed (__t, (STRUCT), __FILE__, __LINE__,\t\\\n+\t\t\t       __FUNCTION__);\t\t\t\t\\\n+    __t; })\n+\n #define TREE_CLASS_CHECK(T, CLASS) __extension__\t\t\t\\\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n     if (TREE_CODE_CLASS (TREE_CODE(__t)) != (CLASS))\t\t\t\\\n@@ -612,6 +635,11 @@ struct tree_common GTY(())\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n+extern void tree_contains_struct_check_failed (const tree,\n+\t\t\t\t\t       const enum tree_node_structure_enum,\t\t\t\t     \n+\t\t\t\t\t       const char *, int, const char *)\n+  ATTRIBUTE_NORETURN;\n+\n extern void tree_check_failed (const tree, const char *, int, const char *,\n \t\t\t       ...) ATTRIBUTE_NORETURN;\n extern void tree_not_check_failed (const tree, const char *, int, const char *,\n@@ -631,6 +659,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n #else /* not ENABLE_TREE_CHECKING, or not gcc */\n \n+#define CONTAINS_STRUCT_CHECK(T, ENUM)          (T)\n #define TREE_CHECK(T, CODE)\t\t\t(T)\n #define TREE_NOT_CHECK(T, CODE)\t\t\t(T)\n #define TREE_CHECK2(T, CODE1, CODE2)\t\t(T)\n@@ -657,7 +686,11 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #include \"tree-check.h\"\n \n #define TYPE_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_type)\n-#define DECL_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_declaration)\n+#define DECL_MINIMAL_CHECK(T)   CONTAINS_STRUCT_CHECK (T, TS_DECL_MINIMAL)\n+#define DECL_COMMON_CHECK(T)    CONTAINS_STRUCT_CHECK (T, TS_DECL_COMMON)\n+#define DECL_WRTL_CHECK(T)      CONTAINS_STRUCT_CHECK (T, TS_DECL_WRTL)\n+#define DECL_WITH_VIS_CHECK(T)  CONTAINS_STRUCT_CHECK (T, TS_DECL_WITH_VIS)\n+#define DECL_NON_COMMON_CHECK(T) CONTAINS_STRUCT_CHECK (T, TS_DECL_NON_COMMON)\n #define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_constant)\n #define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_statement)\n #define FUNC_OR_METHOD_CHECK(T)\tTREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)\n@@ -946,7 +979,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define TYPE_SIZES_GIMPLIFIED(NODE) (TYPE_CHECK (NODE)->common.constant_flag)\n \n /* In a decl (most significantly a FIELD_DECL), means an unsigned field.  */\n-#define DECL_UNSIGNED(NODE) (DECL_CHECK (NODE)->common.unsigned_flag)\n+#define DECL_UNSIGNED(NODE) (DECL_COMMON_CHECK (NODE)->common.unsigned_flag)\n \n /* In a BIT_FIELD_REF, means the bitfield is to be interpreted as unsigned.  */\n #define BIT_FIELD_REF_UNSIGNED(NODE) \\\n@@ -986,7 +1019,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n /* In a RESULT_DECL or PARM_DECL, means that it is passed by invisible\n    reference (and the TREE_TYPE is a pointer to the true type).  */\n-#define DECL_BY_REFERENCE(NODE) (DECL_CHECK (NODE)->common.private_flag)\n+#define DECL_BY_REFERENCE(NODE) (DECL_COMMON_CHECK (NODE)->common.private_flag)\n \n /* In a CALL_EXPR, means that the call is the jump from a thunk to the\n    thunked-to function.  */\n@@ -1884,43 +1917,44 @@ struct tree_binfo GTY (())\n \t\t || TREE_CODE (SSA_NAME_VAR (DECL)) == PARM_DECL \\\n \t\t || TREE_CODE (SSA_NAME_VAR (DECL)) == RESULT_DECL)))\n \n-/* This is the name of the object as written by the user.\n-   It is an IDENTIFIER_NODE.  */\n-#define DECL_NAME(NODE) (DECL_CHECK (NODE)->decl.name)\n \n-/* The name of the object as the assembler will see it (but before any\n-   translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n-   as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n-#define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)\n \n-/* Returns nonzero if the DECL_ASSEMBLER_NAME for NODE has been set.  If zero,\n-   the NODE might still have a DECL_ASSEMBLER_NAME -- it just hasn't been set\n-   yet.  */\n-#define DECL_ASSEMBLER_NAME_SET_P(NODE) \\\n-  (DECL_CHECK (NODE)->decl.assembler_name != NULL_TREE)\n \n-/* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n-#define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n-  (DECL_CHECK (NODE)->decl.assembler_name = (NAME))\n+/* Enumerate visibility settings.  */\n+#ifndef SYMBOL_VISIBILITY_DEFINED\n+#define SYMBOL_VISIBILITY_DEFINED\n+enum symbol_visibility\n+{\n+  VISIBILITY_DEFAULT,\n+  VISIBILITY_INTERNAL,\n+  VISIBILITY_HIDDEN,\n+  VISIBILITY_PROTECTED\n+};\n+#endif\n \n-/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if DECL1's\n-   DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n-   the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n-   semantics of using this macro, are different than saying:\n+struct function;\n \n-     SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n \n-   which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n+/* This is the name of the object as written by the user.\n+   It is an IDENTIFIER_NODE.  */\n+#define DECL_NAME(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.name)\n \n-#define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n-  (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n-   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2,\t\t\t\t\\\n-\t\t\t\t     DECL_ASSEMBLER_NAME (DECL1))\t\\\n-   : (void) 0)\n+/* Every ..._DECL node gets a unique number.  */\n+#define DECL_UID(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.uid)\n \n-/* Records the section name in a section attribute.  Used to pass\n-   the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n-#define DECL_SECTION_NAME(NODE) (DECL_CHECK (NODE)->decl.section_name)\n+/* These two fields describe where in the source code the declaration\n+   was.  If the declaration appears in several places (as for a C\n+   function that is declared first and then defined later), this\n+   information should refer to the definition.  */\n+#define DECL_SOURCE_LOCATION(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.locus)\n+#define DECL_SOURCE_FILE(NODE) LOCATION_FILE (DECL_SOURCE_LOCATION (NODE))\n+#define DECL_SOURCE_LINE(NODE) LOCATION_LINE (DECL_SOURCE_LOCATION (NODE))\n+#ifdef USE_MAPPED_LOCATION\n+#define DECL_IS_BUILTIN(DECL) \\\n+  (DECL_SOURCE_LOCATION (DECL) <= BUILTINS_LOCATION)\n+#else\n+#define DECL_IS_BUILTIN(DECL) (DECL_SOURCE_LINE(DECL) == 0)\n+#endif\n \n /*  For FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or\n     QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,\n@@ -1929,226 +1963,103 @@ struct tree_binfo GTY (())\n     the RECORD_TYPE or UNION_TYPE for the containing type, or\n     NULL_TREE or a TRANSLATION_UNIT_DECL if the given decl has \"file\n     scope\".  */\n-#define DECL_CONTEXT(NODE) (DECL_CHECK (NODE)->decl.context)\n-#define DECL_FIELD_CONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.context)\n+#define DECL_CONTEXT(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.context)\n+#define DECL_FIELD_CONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl_minimal.context)\n+struct tree_decl_minimal GTY(())\n+{\n+  struct tree_common common;\n+  location_t locus;\n+  unsigned int uid;\n+  tree name;\n+  tree context;\n+};\n+\n+/* For any sort of a ..._DECL node, this points to the original (abstract)\n+   decl node which this decl is an instance of, or else it is NULL indicating\n+   that this decl is not an instance of some other decl.  For example,\n+   in a nested declaration of an inline function, this points back to the\n+   definition.  */\n+#define DECL_ABSTRACT_ORIGIN(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.abstract_origin)\n+\n+/* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract\n+   origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */\n+#define DECL_ORIGIN(NODE) \\\n+  (DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : (NODE))\n+\n+/* Nonzero for any sort of ..._DECL node means this decl node represents an\n+   inline instance of some original (abstract) decl from an inline function;\n+   suppress any warnings about shadowing some other variable.  FUNCTION_DECL\n+   nodes can also have their abstract origin set to themselves.  */\n+#define DECL_FROM_INLINE(NODE) (DECL_ABSTRACT_ORIGIN (NODE) != NULL_TREE \\\n+\t\t\t\t&& DECL_ABSTRACT_ORIGIN (NODE) != (NODE))\n+\n /* In a DECL this is the field where attributes are stored.  */\n-#define DECL_ATTRIBUTES(NODE) (DECL_CHECK (NODE)->decl.attributes)\n-/* In a FIELD_DECL, this is the field position, counting in bytes, of the\n-   byte containing the bit closest to the beginning of the structure.  */\n-#define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.arguments)\n-/* In a FIELD_DECL, this is the offset, in bits, of the first bit of the\n-   field from DECL_FIELD_OFFSET.  */\n-#define DECL_FIELD_BIT_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.u2.t)\n-/* In a FIELD_DECL, this indicates whether the field was a bit-field and\n-   if so, the type that was originally specified for it.\n-   TREE_TYPE may have been modified (in finish_struct).  */\n-#define DECL_BIT_FIELD_TYPE(NODE) (FIELD_DECL_CHECK (NODE)->decl.result)\n-/* In FUNCTION_DECL, a chain of ..._DECL nodes.\n-   VAR_DECL and PARM_DECL reserve the arguments slot for language-specific\n-   uses.  */\n-#define DECL_ARGUMENTS(NODE) (DECL_CHECK (NODE)->decl.arguments)\n-/* This field is used to reference anything in decl.result and is meant only\n-   for use by the garbage collector.  */\n-#define DECL_RESULT_FLD(NODE) (DECL_CHECK (NODE)->decl.result)\n-/* In FUNCTION_DECL, holds the decl for the return value.  */\n-#define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.result)\n-/* For a TYPE_DECL, holds the \"original\" type.  (TREE_TYPE has the copy.) */\n-#define DECL_ORIGINAL_TYPE(NODE) (TYPE_DECL_CHECK (NODE)->decl.result)\n-/* In PARM_DECL, holds the type as written (perhaps a function or array).  */\n-#define DECL_ARG_TYPE_AS_WRITTEN(NODE) (PARM_DECL_CHECK (NODE)->decl.result)\n+#define DECL_ATTRIBUTES(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.attributes)\n+\n /* For a FUNCTION_DECL, holds the tree of BINDINGs.\n    For a TRANSLATION_UNIT_DECL, holds the namespace's BLOCK.\n    For a VAR_DECL, holds the initial value.\n    For a PARM_DECL, not used--default\n    values for parameters are encoded in the type of the function,\n    not in the PARM_DECL slot.\n+   For a FIELD_DECL, this is used for enumeration values and the C\n+   frontend uses it for temporarily storing bitwidth of bitfields. \n \n    ??? Need to figure out some way to check this isn't a PARM_DECL.  */\n-#define DECL_INITIAL(NODE) (DECL_CHECK (NODE)->decl.initial)\n-/* For a PARM_DECL, records the data type used to pass the argument,\n-   which may be different from the type seen in the program.  */\n-#define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)->decl.initial)\n-/* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n-   if nonzero, indicates that the field occupies the type.  */\n-#define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)->decl.initial)\n-/* These two fields describe where in the source code the declaration\n-   was.  If the declaration appears in several places (as for a C\n-   function that is declared first and then defined later), this\n-   information should refer to the definition.  */\n-#define DECL_SOURCE_LOCATION(NODE) (DECL_CHECK (NODE)->decl.locus)\n-#define DECL_SOURCE_FILE(NODE) LOCATION_FILE (DECL_SOURCE_LOCATION (NODE))\n-#define DECL_SOURCE_LINE(NODE) LOCATION_LINE (DECL_SOURCE_LOCATION (NODE))\n-#ifdef USE_MAPPED_LOCATION\n-#define DECL_IS_BUILTIN(DECL) \\\n-  (DECL_SOURCE_LOCATION (DECL) <= BUILTINS_LOCATION)\n-#else\n-#define DECL_IS_BUILTIN(DECL) (DECL_SOURCE_LINE(DECL) == 0)\n-#endif\n+#define DECL_INITIAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.initial)\n+\n /* Holds the size of the datum, in bits, as a tree expression.\n    Need not be constant.  */\n-#define DECL_SIZE(NODE) (DECL_CHECK (NODE)->decl.size)\n+#define DECL_SIZE(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.size)\n /* Likewise for the size in bytes.  */\n-#define DECL_SIZE_UNIT(NODE) (DECL_CHECK (NODE)->decl.size_unit)\n+#define DECL_SIZE_UNIT(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.size_unit)\n /* Holds the alignment required for the datum, in bits.  */\n-#define DECL_ALIGN(NODE) (DECL_CHECK (NODE)->decl.u1.a.align)\n+#define DECL_ALIGN(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.u1.a.align)\n /* The alignment of NODE, in bytes.  */\n #define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)\n /* For FIELD_DECLs, off_align holds the number of low-order bits of\n    DECL_FIELD_OFFSET which are known to be always zero.\n    DECL_OFFSET_ALIGN thus returns the alignment that DECL_FIELD_OFFSET\n    has.  */\n-#define DECL_OFFSET_ALIGN(NODE) \\\n-  (((unsigned HOST_WIDE_INT)1) << FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align)\n-/* Specify that DECL_ALIGN(NODE) is a multiple of X.  */\n-#define SET_DECL_OFFSET_ALIGN(NODE, X) \\\n-  (FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align\t= exact_log2 ((X) & -(X)))\n-/* 1 if the alignment for this type was requested by \"aligned\" attribute,\n-   0 if it is the default for this type.  */\n-#define DECL_USER_ALIGN(NODE) (DECL_CHECK (NODE)->decl.user_align)\n+#define DECL_USER_ALIGN(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.user_align)\n /* Holds the machine mode corresponding to the declaration of a variable or\n    field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a\n    FIELD_DECL.  */\n-#define DECL_MODE(NODE) (DECL_CHECK (NODE)->decl.mode)\n-/* Holds the RTL expression for the value of a variable or function.\n-   This value can be evaluated lazily for functions, variables with\n-   static storage duration, and labels.  */\n-#define DECL_RTL(NODE)\t\t\t\t\t\\\n-  (DECL_CHECK (NODE)->decl.rtl\t\t\t\t\\\n-   ? (NODE)->decl.rtl\t\t\t\t\t\\\n-   : (make_decl_rtl (NODE), (NODE)->decl.rtl))\n-/* Set the DECL_RTL for NODE to RTL.  */\n-#define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)\n-/* Returns nonzero if the DECL_RTL for NODE has already been set.  */\n-#define DECL_RTL_SET_P(NODE)  (DECL_CHECK (NODE)->decl.rtl != NULL)\n-/* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n-   NODE1, it will not be set for NODE2; this is a lazy copy.  */\n-#define COPY_DECL_RTL(NODE1, NODE2) \\\n-  (DECL_CHECK (NODE2)->decl.rtl = DECL_CHECK (NODE1)->decl.rtl)\n-/* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */\n-#define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n-\n-/* For PARM_DECL, holds an RTL for the stack slot or register\n-   where the data was actually passed.  */\n-#define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->decl.u2.r)\n-\n-/* For FUNCTION_DECL, this holds a pointer to a structure (\"struct function\")\n-   that describes the status of this function.  */\n-#define DECL_STRUCT_FUNCTION(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u2.f)\n+#define DECL_MODE(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.mode)\n \n /* For FUNCTION_DECL, if it is built-in, this identifies which built-in\n    operation it is.  Note, however, that this field is overloaded, with\n    DECL_BUILT_IN_CLASS as the discriminant, so the latter must always be\n    checked before any access to the former.  */\n-#define DECL_FUNCTION_CODE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u1.f)\n-\n-/* The DECL_VINDEX is used for FUNCTION_DECLS in two different ways.\n-   Before the struct containing the FUNCTION_DECL is laid out,\n-   DECL_VINDEX may point to a FUNCTION_DECL in a base class which\n-   is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual\n-   function.  When the class is laid out, this pointer is changed\n-   to an INTEGER_CST node which is suitable for use as an index\n-   into the virtual function table.  */\n-#define DECL_VINDEX(NODE) (DECL_CHECK (NODE)->decl.vindex)\n-\n-/* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in\n-   which this FIELD_DECL is defined.  This information is needed when\n-   writing debugging information about vfield and vbase decls for C++.  */\n-#define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.vindex)\n-\n-extern tree decl_debug_expr_lookup (tree);\n-extern void decl_debug_expr_insert (tree, tree);\n-\n-/* For VAR_DECL, this is set to either an expression that it was split\n-   from (if DECL_DEBUG_EXPR_IS_FROM is true), otherwise a tree_list of\n-   subexpressions that it was split into.  */\n-#define DECL_DEBUG_EXPR(NODE) \\\n-  (decl_debug_expr_lookup (VAR_DECL_CHECK (NODE)))\n-\n-#define SET_DECL_DEBUG_EXPR(NODE, VAL) \\\n-  (decl_debug_expr_insert (VAR_DECL_CHECK (NODE), (VAL)))\n-\n+#define DECL_FUNCTION_CODE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_common.u1.f)\n #define DECL_DEBUG_EXPR_IS_FROM(NODE) \\\n-  (DECL_CHECK (NODE)->decl.debug_expr_is_from)\n-\n-/* Every ..._DECL node gets a unique number.  */\n-#define DECL_UID(NODE) (DECL_CHECK (NODE)->decl.uid)\n-\n-/* For any sort of a ..._DECL node, this points to the original (abstract)\n-   decl node which this decl is an instance of, or else it is NULL indicating\n-   that this decl is not an instance of some other decl.  For example,\n-   in a nested declaration of an inline function, this points back to the\n-   definition.  */\n-#define DECL_ABSTRACT_ORIGIN(NODE) (DECL_CHECK (NODE)->decl.abstract_origin)\n-\n-/* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract\n-   origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */\n-#define DECL_ORIGIN(NODE) \\\n-  (DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : (NODE))\n-\n-/* Nonzero for any sort of ..._DECL node means this decl node represents an\n-   inline instance of some original (abstract) decl from an inline function;\n-   suppress any warnings about shadowing some other variable.  FUNCTION_DECL\n-   nodes can also have their abstract origin set to themselves.  */\n-#define DECL_FROM_INLINE(NODE) (DECL_ABSTRACT_ORIGIN (NODE) != NULL_TREE \\\n-\t\t\t\t&& DECL_ABSTRACT_ORIGIN (NODE) != (NODE))\n+  (DECL_COMMON_CHECK (NODE)->decl_common.debug_expr_is_from)\n \n /* Nonzero for a given ..._DECL node means that the name of this node should\n    be ignored for symbolic debug purposes.  */ \n-#define DECL_IGNORED_P(NODE) (DECL_CHECK (NODE)->decl.ignored_flag)\n+#define DECL_IGNORED_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)\n \n /* Nonzero for a given ..._DECL node means that this node represents an\n    \"abstract instance\" of the given declaration (e.g. in the original\n    declaration of an inline function).  When generating symbolic debugging\n    information, we mustn't try to generate any address information for nodes\n    marked as \"abstract instances\" because we don't actually generate\n    any code or allocate any data space for such instances.  */\n-#define DECL_ABSTRACT(NODE) (DECL_CHECK (NODE)->decl.abstract_flag)\n-\n-/* Nonzero for a given ..._DECL node means that no warnings should be\n-   generated just because this node is unused.  */\n-#define DECL_IN_SYSTEM_HEADER(NODE) \\\n-  (DECL_CHECK (NODE)->decl.in_system_header_flag)\n-\n-/* Nonzero for a given ..._DECL node means that this node should be\n-   put in .common, if possible.  If a DECL_INITIAL is given, and it\n-   is not error_mark_node, then the decl cannot be put in .common.  */\n-#define DECL_COMMON(NODE) (DECL_CHECK (NODE)->decl.common_flag)\n+#define DECL_ABSTRACT(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.abstract_flag)\n \n /* Language-specific decl information.  */\n-#define DECL_LANG_SPECIFIC(NODE) (DECL_CHECK (NODE)->decl.lang_specific)\n+#define DECL_LANG_SPECIFIC(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_specific)\n \n-/* In a VAR_DECL or FUNCTION_DECL,\n-   nonzero means external reference:\n+/* In a VAR_DECL or FUNCTION_DECL, nonzero means external reference:\n    do not allocate storage, and refer to a definition elsewhere.  */\n-#define DECL_EXTERNAL(NODE) (DECL_CHECK (NODE)->decl.external_flag)\n+#define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.decl_flag_2)\n \n /* In a VAR_DECL for a RECORD_TYPE, sets number for non-init_priority\n    initializations.  */\n #define DEFAULT_INIT_PRIORITY 65535\n #define MAX_INIT_PRIORITY 65535\n #define MAX_RESERVED_INIT_PRIORITY 100\n \n-/* In a TYPE_DECL\n-   nonzero means the detail info about this type is not dumped into stabs.\n-   Instead it will generate cross reference ('x') of names.\n-   This uses the same flag as DECL_EXTERNAL.  */\n-#define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n-  (TYPE_DECL_CHECK (NODE)->decl.external_flag)\n-\n-/* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */\n-#define DECL_REGISTER(NODE) (DECL_CHECK (NODE)->decl.regdecl_flag)\n-\n-/* In LABEL_DECL nodes, nonzero means that an error message about\n-   jumping into such a binding contour has been printed for this label.  */\n-#define DECL_ERROR_ISSUED(NODE) (LABEL_DECL_CHECK (NODE)->decl.regdecl_flag)\n-\n-/* In a FIELD_DECL, indicates this field should be bit-packed.  */\n-#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl.regdecl_flag)\n-\n-/* In a FUNCTION_DECL with a nonzero DECL_CONTEXT, indicates that a\n-   static chain is not needed.  */\n-#define DECL_NO_STATIC_CHAIN(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.regdecl_flag)\n \n /* Nonzero in a ..._DECL means this variable is ref'd from a nested function.\n    For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.\n@@ -2157,51 +2068,120 @@ extern void decl_debug_expr_insert (tree, tree);\n \n    Also set in some languages for variables, etc., outside the normal\n    lexical scope, such as class instance variables.  */\n-#define DECL_NONLOCAL(NODE) (DECL_CHECK (NODE)->decl.nonlocal_flag)\n+#define DECL_NONLOCAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.nonlocal_flag)\n \n-/* Nonzero in a FUNCTION_DECL means this function can be substituted\n-   where it is called.  */\n-#define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inline_flag)\n+/* Used in VAR_DECLs to indicate that the variable is a vtable.\n+   Used in FIELD_DECLs for vtable pointers.\n+   Used in FUNCTION_DECLs to indicate that the function is virtual.  */\n+#define DECL_VIRTUAL_P(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.virtual_flag)\n \n-/* Nonzero in a FUNCTION_DECL means that this function was declared inline,\n-   such as via the `inline' keyword in C/C++.  This flag controls the linkage\n-   semantics of 'inline'; whether or not the function is inlined is\n-   controlled by DECL_INLINE.  */\n-#define DECL_DECLARED_INLINE_P(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.declared_inline_flag)\n+/* Used to indicate that this DECL represents a compiler-generated entity.  */\n+#define DECL_ARTIFICIAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.artificial_flag)\n \n-/* Nonzero in a decl means that the gimplifier has seen (or placed)\n-   this variable in a BIND_EXPR.  */\n-#define DECL_SEEN_IN_BIND_EXPR_P(NODE) \\\n-  (DECL_CHECK (NODE)->decl.seen_in_bind_expr)\n+/* Additional flags for language-specific uses.  */\n+#define DECL_LANG_FLAG_0(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_0)\n+#define DECL_LANG_FLAG_1(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_1)\n+#define DECL_LANG_FLAG_2(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_2)\n+#define DECL_LANG_FLAG_3(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_3)\n+#define DECL_LANG_FLAG_4(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_4)\n+#define DECL_LANG_FLAG_5(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_5)\n+#define DECL_LANG_FLAG_6(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_6)\n+#define DECL_LANG_FLAG_7(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_7)\n \n-/* In a VAR_DECL, nonzero if the decl is a register variable with\n-   an explicit asm specification.  */\n-#define DECL_HARD_REGISTER(NODE)  (VAR_DECL_CHECK (NODE)->decl.inline_flag)\n+/* Used to indicate an alias set for the memory pointed to by this\n+   particular FIELD_DECL, PARM_DECL, or VAR_DECL, which must have\n+   pointer (or reference) type.  */\n+#define DECL_POINTER_ALIAS_SET(NODE) \\\n+  (DECL_COMMON_CHECK (NODE)->decl_common.pointer_alias_set)\n \n-/* Value of the decls's visibility attribute */\n-#define DECL_VISIBILITY(NODE) (DECL_CHECK (NODE)->decl.visibility)\n+/* Nonzero if an alias set has been assigned to this declaration.  */\n+#define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n+  (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n \n-/* Nonzero means that the decl had its visibility specified rather than\n-   being inferred.  */\n-#define DECL_VISIBILITY_SPECIFIED(NODE) \\\n-  (DECL_CHECK (NODE)->decl.visibility_specified)\n+/* Nonzero for a decl which is at file scope.  */\n+#define DECL_FILE_SCOPE_P(EXP) \t\t\t\t\t\\\n+  (! DECL_CONTEXT (EXP)\t\t\t\t\t\t\\\n+   || TREE_CODE (DECL_CONTEXT (EXP)) == TRANSLATION_UNIT_DECL)\n \n-/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n-#define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n+/* Nonzero for a decl that is decorated using attribute used.\n+   This indicates compiler tools that this decl needs to be preserved.  */\n+#define DECL_PRESERVE_P(DECL) \\\n+  DECL_COMMON_CHECK (DECL)->decl_common.preserve_flag\n+ \n+/* For function local variables of COMPLEX type, indicates that the\n+   variable is not aliased, and that all modifications to the variable\n+   have been adjusted so that they are killing assignments.  Thus the\n+   variable may now be treated as a GIMPLE register, and use real\n+   instead of virtual ops in SSA form.  */\n+#define DECL_COMPLEX_GIMPLE_REG_P(DECL) \\\n+  DECL_COMMON_CHECK (DECL)->decl_common.gimple_reg_flag\n \n-/* In a VAR_DECL, the model to use if the data should be allocated from\n-   thread-local storage.  */\n-#define DECL_TLS_MODEL(NODE) (VAR_DECL_CHECK (NODE)->decl.tls_model)\n+struct tree_decl_common GTY(())\n+{\n+  struct tree_decl_minimal common;\n+  tree size;\n \n-/* In a VAR_DECL, nonzero if the data should be allocated from\n-   thread-local storage.  */\n-#define DECL_THREAD_LOCAL_P(NODE) \\\n-  (VAR_DECL_CHECK (NODE)->decl.tls_model != TLS_MODEL_NONE)\n+  ENUM_BITFIELD(machine_mode) mode : 8;\n \n-/* In a FUNCTION_DECL, the saved representation of the body of the\n-   entire function.  */\n-#define DECL_SAVED_TREE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.saved_tree)\n+  unsigned nonlocal_flag : 1;\n+  unsigned virtual_flag : 1;\n+  unsigned ignored_flag : 1;\n+  unsigned abstract_flag : 1;\n+  unsigned artificial_flag : 1;\n+  unsigned user_align : 1;\n+  unsigned preserve_flag: 1;\n+  unsigned debug_expr_is_from : 1;\n+\n+  unsigned lang_flag_0 : 1;\n+  unsigned lang_flag_1 : 1;\n+  unsigned lang_flag_2 : 1;\n+  unsigned lang_flag_3 : 1;\n+  unsigned lang_flag_4 : 1;\n+  unsigned lang_flag_5 : 1;\n+  unsigned lang_flag_6 : 1;\n+  unsigned lang_flag_7 : 1;\n+ \n+  /* In LABEL_DECL, this is DECL_ERROR_ISSUED.\n+     In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */\n+  unsigned decl_flag_0 : 1;\n+  /* In FIELD_DECL, this is DECL_PACKED\n+     In PARM_DECL, this is DECL_TRANSPARENT_UNION.  */\n+  unsigned decl_flag_1 : 1;\n+  /* In FIELD_DECL, this is DECL_BIT_FIELD\n+     In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL. \n+     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG*/  \n+  unsigned decl_flag_2 : 1;  \n+  /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P\n+     In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR.  */\n+  unsigned decl_flag_3 : 1;  \n+  /* Logically, this would go in a theoretical base shared by var and parm \n+     decl. */\n+  unsigned gimple_reg_flag : 1;\n+  \n+  union tree_decl_u1 {\n+    /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n+       DECL_FUNCTION_CODE.  */\n+    enum built_in_function f;\n+    /* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this\n+       is used by language-dependent code.  */\n+    HOST_WIDE_INT i;\n+    /* DECL_ALIGN and DECL_OFFSET_ALIGN.  (These are not used for\n+       FUNCTION_DECLs).  */\n+    struct tree_decl_u1_a {\n+      unsigned int align : 24;\n+      unsigned int off_align : 8;\n+    } a;\n+  } GTY ((skip)) u1;\n+\n+  tree size_unit;\n+  tree initial;\n+  tree attributes;\n+  tree abstract_origin;\n+  \n+  HOST_WIDE_INT pointer_alias_set; \n+  /* Points to a structure whose details depend on the language in use.  */\n+  struct lang_decl *lang_specific;\n+};\n \n extern tree decl_value_expr_lookup (tree);\n extern void decl_value_expr_insert (tree, tree);\n@@ -2211,80 +2191,185 @@ extern void decl_value_expr_insert (tree, tree);\n    decl itself.  This should only be used for debugging; once this field has\n    been set, the decl itself may not legitimately appear in the function.  */\n #define DECL_HAS_VALUE_EXPR_P(NODE) \\\n-  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl.has_value_expr)\n+  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_3)\n #define DECL_VALUE_EXPR(NODE) \\\n-  (decl_value_expr_lookup (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)))\n+  (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE))) \n #define SET_DECL_VALUE_EXPR(NODE, VAL)\t\t\t\\\n-  (decl_value_expr_insert (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL), VAL))\n+  (decl_value_expr_insert (DECL_WRTL_CHECK (NODE), VAL))\n \n-/* Nonzero in a FUNCTION_DECL means this function should be treated\n-   as if it were a malloc, meaning it returns a pointer that is\n-   not an alias.  */\n-#define DECL_IS_MALLOC(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.malloc_flag)\n+/* Holds the RTL expression for the value of a variable or function.\n+   This value can be evaluated lazily for functions, variables with\n+   static storage duration, and labels.  */\n+#define DECL_RTL(NODE)\t\t\t\t\t\\\n+  (DECL_WRTL_CHECK (NODE)->decl_with_rtl.rtl\t\t\\\n+   ? (NODE)->decl_with_rtl.rtl\t\t\t\t\t\\\n+   : (make_decl_rtl (NODE), (NODE)->decl_with_rtl.rtl))\n \n-/* Nonzero in a FUNCTION_DECL means this function may return more\n-   than once.  */\n-#define DECL_IS_RETURNS_TWICE(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.returns_twice_flag)\n+/* Set the DECL_RTL for NODE to RTL.  */\n+#define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)\n \n-/* Nonzero in a FUNCTION_DECL means this function should be treated\n-   as \"pure\" function (like const function, but may read global memory).  */\n-#define DECL_IS_PURE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.pure_flag)\n+/* Returns nonzero if NODE is a tree node that can contain RTL.  */\n+#define HAS_RTL_P(NODE) (CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WRTL))\n+\n+/* Returns nonzero if the DECL_RTL for NODE has already been set.  */\n+#define DECL_RTL_SET_P(NODE)  (HAS_RTL_P (NODE) && DECL_WRTL_CHECK (NODE)->decl_with_rtl.rtl != NULL)\n+\n+/* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n+   NODE1, it will not be set for NODE2; this is a lazy copy.  */\n+#define COPY_DECL_RTL(NODE1, NODE2) \\\n+  (DECL_WRTL_CHECK (NODE2)->decl_with_rtl.rtl = DECL_WRTL_CHECK (NODE1)->decl_with_rtl.rtl)\n+\n+/* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */\n+#define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n+\n+/* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */\n+#define DECL_REGISTER(NODE) (DECL_WRTL_CHECK (NODE)->decl_common.decl_flag_0)\n+\n+struct tree_decl_with_rtl GTY(())\n+{\n+  struct tree_decl_common common;\n+  rtx rtl;\n+};\n+\n+/* In a FIELD_DECL, this is the field position, counting in bytes, of the\n+   byte containing the bit closest to the beginning of the structure.  */\n+#define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.offset)\n+\n+/* In a FIELD_DECL, this is the offset, in bits, of the first bit of the\n+   field from DECL_FIELD_OFFSET.  */\n+#define DECL_FIELD_BIT_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.bit_offset)\n+\n+/* In a FIELD_DECL, this indicates whether the field was a bit-field and\n+   if so, the type that was originally specified for it.\n+   TREE_TYPE may have been modified (in finish_struct).  */\n+#define DECL_BIT_FIELD_TYPE(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.bit_field_type)\n+\n+/* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n+   if nonzero, indicates that the field occupies the type.  */\n+#define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.qualifier)\n+\n+/* For FIELD_DECLs, off_align holds the number of low-order bits of\n+   DECL_FIELD_OFFSET which are known to be always zero.\n+   DECL_OFFSET_ALIGN thus returns the alignment that DECL_FIELD_OFFSET\n+   has.  */\n+#define DECL_OFFSET_ALIGN(NODE) \\\n+  (((unsigned HOST_WIDE_INT)1) << FIELD_DECL_CHECK (NODE)->decl_common.u1.a.off_align)\n+\n+/* Specify that DECL_ALIGN(NODE) is a multiple of X.  */\n+#define SET_DECL_OFFSET_ALIGN(NODE, X) \\\n+  (FIELD_DECL_CHECK (NODE)->decl_common.u1.a.off_align = exact_log2 ((X) & -(X)))\n+/* 1 if the alignment for this type was requested by \"aligned\" attribute,\n+   0 if it is the default for this type.  */\n+\n+/* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in\n+   which this FIELD_DECL is defined.  This information is needed when\n+   writing debugging information about vfield and vbase decls for C++.  */\n+#define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.fcontext)\n+\n+/* In a FIELD_DECL, indicates this field should be bit-packed.  */\n+#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)\n \n-/* Nonzero in a FUNCTION_DECL means this function should be treated\n-   as \"novops\" function (function that does not read global memory,\n-   but may have arbitrary side effects).  */\n-#define DECL_IS_NOVOPS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.novops_flag)\n-     \n /* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n    specially.  */\n-#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl.bit_field_flag)\n+#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)\n \n-/* Unused in FUNCTION_DECL.  */\n+/* Used in a FIELD_DECL to indicate that we cannot form the address of\n+   this component.  */\n+#define DECL_NONADDRESSABLE_P(NODE) \\\n+  (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_3)\n \n-/* In a VAR_DECL that's static,\n-   nonzero if the space is in the text section.  */\n-#define DECL_IN_TEXT_SECTION(NODE) (VAR_DECL_CHECK (NODE)->decl.bit_field_flag)\n+struct tree_field_decl GTY(())\n+{\n+  struct tree_decl_common common;\n+\n+  tree offset;\t\n+  tree bit_field_type;\t\n+  tree qualifier;\n+  tree bit_offset;\n+  tree fcontext;\n+ \n+};\n \n-/* In a FUNCTION_DECL, nonzero means a built in function.  */\n-#define DECL_BUILT_IN(NODE) (DECL_BUILT_IN_CLASS (NODE) != NOT_BUILT_IN)\n+/* A numeric unique identifier for a LABEL_DECL.  The UID allocation is\n+   dense, unique within any one function, and may be used to index arrays.\n+   If the value is -1, then no UID has been assigned.  */\n+#define LABEL_DECL_UID(NODE) \\\n+  (LABEL_DECL_CHECK (NODE)->decl_common.pointer_alias_set)\n \n-/* For a builtin function, identify which part of the compiler defined it.  */\n-#define DECL_BUILT_IN_CLASS(NODE) \\\n-   (FUNCTION_DECL_CHECK (NODE)->decl.built_in_class)\n+/* In LABEL_DECL nodes, nonzero means that an error message about\n+   jumping into such a binding contour has been printed for this label.  */\n+#define DECL_ERROR_ISSUED(NODE) (LABEL_DECL_CHECK (NODE)->decl_common.decl_flag_0)\n \n-/* Used in VAR_DECLs to indicate that the variable is a vtable.\n-   Used in FIELD_DECLs for vtable pointers.\n-   Used in FUNCTION_DECLs to indicate that the function is virtual.  */\n-#define DECL_VIRTUAL_P(NODE) (DECL_CHECK (NODE)->decl.virtual_flag)\n+struct tree_label_decl GTY(())\n+{\n+  struct tree_decl_with_rtl common;\n+  /* Java's verifier has some need to store information about labels,\n+     and was using fields that no longer exist on labels.  \n+     Once the verifier doesn't need these anymore, they should be removed.  */\n+  tree java_field_1;\n+  tree java_field_2;\n+  tree java_field_3;\n+  unsigned int java_field_4;\n \n-/* Used to indicate that the linkage status of this DECL is not yet known,\n-   so it should not be output now.  */\n-#define DECL_DEFER_OUTPUT(NODE) (DECL_CHECK (NODE)->decl.defer_output)\n+};\n+\n+struct tree_result_decl GTY(())\n+{\n+  struct tree_decl_with_rtl common;\n+};\n+\n+struct tree_const_decl GTY(())\n+{\n+  struct tree_decl_with_rtl common;\n+};\n+\n+/* For a PARM_DECL, records the data type used to pass the argument,\n+   which may be different from the type seen in the program.  */\n+#define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)->decl_common.initial)\n+\n+/* For PARM_DECL, holds an RTL for the stack slot or register\n+   where the data was actually passed.  */\n+#define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->parm_decl.incoming_rtl)\n \n /* Used in PARM_DECLs whose type are unions to indicate that the\n    argument should be passed in the same way that the first union\n    alternative would be passed.  */\n #define DECL_TRANSPARENT_UNION(NODE) \\\n-  (PARM_DECL_CHECK (NODE)->decl.transparent_union)\n+  (PARM_DECL_CHECK (NODE)->decl_common.decl_flag_1)\n \n-/* Used in FUNCTION_DECLs to indicate that they should be run automatically\n-   at the beginning or end of execution.  */\n-#define DECL_STATIC_CONSTRUCTOR(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.static_ctor_flag)\n+struct tree_parm_decl GTY(())\n+{\n+  struct tree_decl_with_rtl common;\n+  rtx incoming_rtl;  \n+};\n \n-#define DECL_STATIC_DESTRUCTOR(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.static_dtor_flag)\n \n-/* Used to indicate that this DECL represents a compiler-generated entity.  */\n-#define DECL_ARTIFICIAL(NODE) (DECL_CHECK (NODE)->decl.artificial_flag)\n+/* Nonzero in a decl means that the gimplifier has seen (or placed)\n+   this variable in a BIND_EXPR.  */\n+#define DECL_SEEN_IN_BIND_EXPR_P(NODE) \\\n+  (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.seen_in_bind_expr)\n \n-/* Used to indicate that this DECL has weak linkage.  */\n-#define DECL_WEAK(NODE) (DECL_CHECK (NODE)->decl.weak_flag)\n+/* Used to indicate that the linkage status of this DECL is not yet known,\n+   so it should not be output now.  */\n+#define DECL_DEFER_OUTPUT(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.defer_output)\n+\n+/* Nonzero for a given ..._DECL node means that no warnings should be\n+   generated just because this node is unused.  */\n+#define DECL_IN_SYSTEM_HEADER(NODE) \\\n+  (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.in_system_header_flag)\n+\n+  /* Used to indicate that this DECL has weak linkage.  */\n+#define DECL_WEAK(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.weak_flag)\n+\n+/* Internal to the gimplifier.  Indicates that the value is a formal\n+   temporary controlled by the gimplifier.  */\n+#define DECL_GIMPLE_FORMAL_TEMP_P(DECL) \\\n+  DECL_WITH_VIS_CHECK (DECL)->decl_with_vis.gimple_formal_temp\n+\n+/* Used to indicate that the pointer to this DECL cannot be treated as\n+   an address constant.  */\n+#define DECL_NON_ADDR_CONST_P(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.non_addr_const_p)\n \n-/* Used in TREE_PUBLIC decls to indicate that copies of this DECL in\n-   multiple translation units should be merged.  */\n-#define DECL_ONE_ONLY(NODE) (DECL_CHECK (NODE)->decl.transparent_union)\n \n /* Used in a DECL to indicate that, even if it TREE_PUBLIC, it need\n    not be put out unless it is needed in this translation unit.\n@@ -2295,210 +2380,300 @@ extern void decl_value_expr_insert (tree, tree);\n    back-end; it is up to front-ends which set this flag to ensure\n    that there will never be any harm, other than bloat, in putting out\n    something which is DECL_COMDAT.  */\n-#define DECL_COMDAT(NODE) (DECL_CHECK (NODE)->decl.comdat_flag)\n+#define DECL_COMDAT(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.comdat_flag)\n \n-/* Used in FUNCTION_DECLs to indicate that function entry and exit should\n-   be instrumented with calls to support routines.  */\n-#define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.no_instrument_function_entry_exit)\n+/* The name of the object as the assembler will see it (but before any\n+   translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n+   as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n+#define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)\n \n-/* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n-   disabled in this function.  */\n-#define DECL_NO_LIMIT_STACK(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.no_limit_stack)\n+/* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME. \n+   This is true of all DECL nodes except FIELD_DECL.  */\n+#define HAS_DECL_ASSEMBLER_NAME_P(NODE) \\\n+  (CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WITH_VIS))\n \n-/* Additional flags for language-specific uses.  */\n-#define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)\n-#define DECL_LANG_FLAG_1(NODE) (DECL_CHECK (NODE)->decl.lang_flag_1)\n-#define DECL_LANG_FLAG_2(NODE) (DECL_CHECK (NODE)->decl.lang_flag_2)\n-#define DECL_LANG_FLAG_3(NODE) (DECL_CHECK (NODE)->decl.lang_flag_3)\n-#define DECL_LANG_FLAG_4(NODE) (DECL_CHECK (NODE)->decl.lang_flag_4)\n-#define DECL_LANG_FLAG_5(NODE) (DECL_CHECK (NODE)->decl.lang_flag_5)\n-#define DECL_LANG_FLAG_6(NODE) (DECL_CHECK (NODE)->decl.lang_flag_6)\n-#define DECL_LANG_FLAG_7(NODE) (DECL_CHECK (NODE)->decl.lang_flag_7)\n+/* Returns nonzero if the DECL_ASSEMBLER_NAME for NODE has been set.  If zero,\n+   the NODE might still have a DECL_ASSEMBLER_NAME -- it just hasn't been set\n+   yet.  */\n+#define DECL_ASSEMBLER_NAME_SET_P(NODE) \\\n+  (HAS_DECL_ASSEMBLER_NAME_P (NODE) &&  DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.assembler_name != NULL_TREE)\n \n-/* Used to indicate that the pointer to this DECL cannot be treated as\n-   an address constant.  */\n-#define DECL_NON_ADDR_CONST_P(NODE) (DECL_CHECK (NODE)->decl.non_addr_const_p)\n+/* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n+#define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n+  (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.assembler_name = (NAME))\n \n-/* Used in a FIELD_DECL to indicate that we cannot form the address of\n-   this component.  */\n-#define DECL_NONADDRESSABLE_P(NODE) \\\n-  (FIELD_DECL_CHECK (NODE)->decl.non_addressable)\n+/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if DECL1's\n+   DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n+   the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n+   semantics of using this macro, are different than saying:\n \n-/* Used to indicate an alias set for the memory pointed to by this\n-   particular FIELD_DECL, PARM_DECL, or VAR_DECL, which must have\n-   pointer (or reference) type.  */\n-#define DECL_POINTER_ALIAS_SET(NODE) \\\n-  (DECL_CHECK (NODE)->decl.pointer_alias_set)\n+     SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n \n+   which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n \n-/* A numeric unique identifier for a LABEL_DECL.  The UID allocation is\n-   dense, unique within any one function, and may be used to index arrays.\n-   If the value is -1, then no UID has been assigned.  */\n-#define LABEL_DECL_UID(NODE) \\\n-  (LABEL_DECL_CHECK (NODE)->decl.pointer_alias_set)\n+#define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n+  (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n+   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2,\t\t\t\t\\\n+\t\t\t\t     DECL_ASSEMBLER_NAME (DECL1))\t\\\n+   : (void) 0)\n \n-/* Nonzero if an alias set has been assigned to this declaration.  */\n-#define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n-  (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n+/* Records the section name in a section attribute.  Used to pass\n+   the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n+#define DECL_SECTION_NAME(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.section_name)\n \n-/* Nonzero for a decl which is at file scope.  */\n-#define DECL_FILE_SCOPE_P(EXP) \t\t\t\t\t\\\n-  (! DECL_CONTEXT (EXP)\t\t\t\t\t\t\\\n-   || TREE_CODE (DECL_CONTEXT (EXP)) == TRANSLATION_UNIT_DECL)\n+/* Value of the decls's visibility attribute */\n+#define DECL_VISIBILITY(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.visibility)\n+\n+/* Nonzero means that the decl had its visibility specified rather than\n+   being inferred.  */\n+#define DECL_VISIBILITY_SPECIFIED(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.visibility_specified)\n+\n+/* Used in TREE_PUBLIC decls to indicate that copies of this DECL in\n+   multiple translation units should be merged.  */\n+#define DECL_ONE_ONLY(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.one_only)\n+\n+struct tree_decl_with_vis GTY(())\n+{\n+ struct tree_decl_with_rtl common;\n+ tree assembler_name;\n+ tree section_name;\n+  \n+ /* Belong to VAR_DECL exclusively.  */\n+ unsigned defer_output:1;\n+ unsigned hard_register:1;\n+ unsigned thread_local:1;\n+ unsigned common_flag:1; \n+ unsigned in_text_section : 1;\n+ unsigned gimple_formal_temp : 1;\n+ unsigned non_addr_const_p : 1; \n+ /* Used by C++.  Might become a generic decl flag.  */\n+ unsigned shadowed_for_var_p : 1;\n+ \n+ /* Don't belong to VAR_DECL exclusively.  */\n+ unsigned in_system_header_flag : 1;\n+ unsigned weak_flag:1;\n+ unsigned seen_in_bind_expr : 1;\n+ unsigned comdat_flag : 1;\n+ ENUM_BITFIELD(symbol_visibility) visibility : 2;\n+ unsigned visibility_specified : 1;\n+ /* Belong to FUNCTION_DECL exclusively.  */\n+ unsigned one_only : 1;\n+ unsigned init_priority_p:1;\n+\n+ /* Belongs to VAR_DECL exclusively.  */\n+ ENUM_BITFIELD(tls_model) tls_model : 3;\n+ /* 13 unused bits. */\n+};\n+\n+/* In a VAR_DECL that's static,\n+   nonzero if the space is in the text section.  */\n+#define DECL_IN_TEXT_SECTION(NODE) (VAR_DECL_CHECK (NODE)->decl_with_vis.in_text_section)\n+\n+/* Nonzero for a given ..._DECL node means that this node should be\n+   put in .common, if possible.  If a DECL_INITIAL is given, and it\n+   is not error_mark_node, then the decl cannot be put in .common.  */\n+#define DECL_COMMON(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.common_flag)\n+\n+/* In a VAR_DECL, nonzero if the decl is a register variable with\n+   an explicit asm specification.  */\n+#define DECL_HARD_REGISTER(NODE)  (VAR_DECL_CHECK (NODE)->decl_with_vis.hard_register)\n+\n+extern tree decl_debug_expr_lookup (tree);\n+extern void decl_debug_expr_insert (tree, tree);\n+/* For VAR_DECL, this is set to either an expression that it was split\n+   from (if DECL_DEBUG_EXPR_IS_FROM is true), otherwise a tree_list of\n+   subexpressions that it was split into.  */\n+#define DECL_DEBUG_EXPR(NODE) \\\n+  (decl_debug_expr_lookup (VAR_DECL_CHECK (NODE)))\n+\n+#define SET_DECL_DEBUG_EXPR(NODE, VAL) \\\n+  (decl_debug_expr_insert (VAR_DECL_CHECK (NODE), VAL))\n+\n+\n+extern unsigned short decl_init_priority_lookup (tree);\n+extern void decl_init_priority_insert (tree, unsigned short);\n+\n+/* In a non-local VAR_DECL with static storage duration, this is the\n+   initialization priority.  If this value is zero, the NODE will be\n+   initialized at the DEFAULT_INIT_PRIORITY.  Only used by C++ FE*/\n+\n+#define DECL_HAS_INIT_PRIORITY_P(NODE) \\\n+  (VAR_DECL_CHECK (NODE)->decl_with_vis.init_priority_p)\n+#define DECL_INIT_PRIORITY(NODE) \\\n+  (decl_init_priority_lookup (VAR_DECL_CHECK (NODE)))\n+#define SET_DECL_INIT_PRIORITY(NODE, VAL) \\\n+  (decl_init_priority_insert (VAR_DECL_CHECK (NODE), VAL))\n+\n+/* In a VAR_DECL, the model to use if the data should be allocated from\n+   thread-local storage.  */\n+#define DECL_TLS_MODEL(NODE) (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model)\n+\n+/* In a VAR_DECL, nonzero if the data should be allocated from\n+   thread-local storage.  */\n+#define DECL_THREAD_LOCAL_P(NODE) \\\n+  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model != TLS_MODEL_NONE)\n+\n+struct tree_var_decl GTY(())\n+{\n+  struct tree_decl_with_vis common;\n+};\n+\n+\n+/* This field is used to reference anything in decl.result and is meant only\n+   for use by the garbage collector.  */\n+#define DECL_RESULT_FLD(NODE) (DECL_NON_COMMON_CHECK (NODE)->decl_non_common.result)\n+\n+/* The DECL_VINDEX is used for FUNCTION_DECLS in two different ways.\n+   Before the struct containing the FUNCTION_DECL is laid out,\n+   DECL_VINDEX may point to a FUNCTION_DECL in a base class which\n+   is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual\n+   function.  When the class is laid out, this pointer is changed\n+   to an INTEGER_CST node which is suitable for use as an index\n+   into the virtual function table.  \n+   C++ also uses this field in namespaces, hence the DECL_NON_COMMON_CHECK.  */\n+#define DECL_VINDEX(NODE) (DECL_NON_COMMON_CHECK (NODE)->decl_non_common.vindex)\n+\n+struct tree_decl_non_common GTY(())\n+\n+{\n+  struct tree_decl_with_vis common;\n+  /* C++ uses this in namespaces.  */\n+  tree saved_tree;\n+  /* C++ uses this in templates.  */\n+  tree arguments;\t\n+  /* Almost all FE's use this.  */\n+  tree result; \n+  /* C++ uses this in namespaces.  */\n+  tree vindex;\n+};\n+\n+/* In FUNCTION_DECL, holds the decl for the return value.  */\n+#define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_non_common.result)\n+\n+/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n+#define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.uninlinable)\n+\n+/* In a FUNCTION_DECL, the saved representation of the body of the\n+   entire function.  */\n+#define DECL_SAVED_TREE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_non_common.saved_tree)\n+\n+/* Nonzero in a FUNCTION_DECL means this function should be treated\n+   as if it were a malloc, meaning it returns a pointer that is\n+   not an alias.  */\n+#define DECL_IS_MALLOC(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.malloc_flag)\n+\n+/* Nonzero in a FUNCTION_DECL means this function may return more\n+   than once.  */\n+#define DECL_IS_RETURNS_TWICE(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.returns_twice_flag)\n+\n+/* Nonzero in a FUNCTION_DECL means this function should be treated\n+   as \"pure\" function (like const function, but may read global memory).  */\n+#define DECL_IS_PURE(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.pure_flag)\n+\n+/* Nonzero in a FUNCTION_DECL means this function should be treated\n+   as \"novops\" function (function that does not read global memory,\n+   but may have arbitrary side effects).  */\n+#define DECL_IS_NOVOPS(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.novops_flag)\n+\n+/* Used in FUNCTION_DECLs to indicate that they should be run automatically\n+   at the beginning or end of execution.  */\n+#define DECL_STATIC_CONSTRUCTOR(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.static_ctor_flag)\n+\n+#define DECL_STATIC_DESTRUCTOR(NODE) \\\n+(FUNCTION_DECL_CHECK (NODE)->function_decl.static_dtor_flag)\n+\n+/* Used in FUNCTION_DECLs to indicate that function entry and exit should\n+   be instrumented with calls to support routines.  */\n+#define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.no_instrument_function_entry_exit)\n+\n+/* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n+   disabled in this function.  */\n+#define DECL_NO_LIMIT_STACK(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.no_limit_stack)\n+\n+/* In a FUNCTION_DECL with a nonzero DECL_CONTEXT, indicates that a\n+   static chain is not needed.  */\n+#define DECL_NO_STATIC_CHAIN(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.regdecl_flag)\n \n /* Nonzero for a decl that cgraph has decided should be inlined into\n    at least one call site.  It is not meaningful to look at this\n    directly; always use cgraph_function_possibly_inlined_p.  */\n #define DECL_POSSIBLY_INLINED(DECL) \\\n-  FUNCTION_DECL_CHECK (DECL)->decl.possibly_inlined\n+  FUNCTION_DECL_CHECK (DECL)->function_decl.possibly_inlined\n \n-/* Nonzero for a decl that is decorated using attribute used.\n-   This indicates compiler tools that this decl needs to be preserved.  */\n-#define DECL_PRESERVE_P(DECL) \\\n-  DECL_CHECK (DECL)->decl.preserve_flag\n+/* Nonzero in a FUNCTION_DECL means this function can be substituted\n+   where it is called.  */\n+#define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.inline_flag)\n \n-/* Internal to the gimplifier.  Indicates that the value is a formal\n-   temporary controlled by the gimplifier.  */\n-#define DECL_GIMPLE_FORMAL_TEMP_P(DECL) \\\n-  DECL_CHECK (DECL)->decl.gimple_formal_temp\n+/* Nonzero in a FUNCTION_DECL means that this function was declared inline,\n+   such as via the `inline' keyword in C/C++.  This flag controls the linkage\n+   semantics of 'inline'; whether or not the function is inlined is\n+   controlled by DECL_INLINE.  */\n+#define DECL_DECLARED_INLINE_P(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.declared_inline_flag)\n \n-/* For function local variables of COMPLEX type, indicates that the\n-   variable is not aliased, and that all modifications to the variable\n-   have been adjusted so that they are killing assignments.  Thus the\n-   variable may now be treated as a GIMPLE register, and use real\n-   instead of virtual ops in SSA form.  */\n-#define DECL_COMPLEX_GIMPLE_REG_P(DECL) \\\n-  DECL_CHECK (DECL)->decl.gimple_reg_flag\n+/* For FUNCTION_DECL, this holds a pointer to a structure (\"struct function\")\n+   that describes the status of this function.  */\n+#define DECL_STRUCT_FUNCTION(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.f)\n \n-/* Enumerate visibility settings.  */\n-#ifndef SYMBOL_VISIBILITY_DEFINED\n-#define SYMBOL_VISIBILITY_DEFINED\n-enum symbol_visibility\n-{\n-  VISIBILITY_DEFAULT,\n-  VISIBILITY_INTERNAL,\n-  VISIBILITY_HIDDEN,\n-  VISIBILITY_PROTECTED\n-};\n-#endif\n+/* In a FUNCTION_DECL, nonzero means a built in function.  */\n+#define DECL_BUILT_IN(NODE) (DECL_BUILT_IN_CLASS (NODE) != NOT_BUILT_IN)\n \n-struct function;\n-struct tree_decl GTY(())\n-{\n-  struct tree_common common;\n-  location_t locus;\n-  unsigned int uid;\n-  tree size;\n+/* For a builtin function, identify which part of the compiler defined it.  */\n+#define DECL_BUILT_IN_CLASS(NODE) \\\n+   (FUNCTION_DECL_CHECK (NODE)->function_decl.built_in_class)\n \n-  /* 32 bits: */\n-  ENUM_BITFIELD(machine_mode) mode : 8;\n+/* In FUNCTION_DECL, a chain of ..._DECL nodes.\n+   VAR_DECL and PARM_DECL reserve the arguments slot for language-specific\n+   uses.  */\n+#define DECL_ARGUMENTS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_non_common.arguments)\n \n-  unsigned external_flag : 1;\n-  unsigned nonlocal_flag : 1;\n-  unsigned regdecl_flag : 1;\n-  unsigned inline_flag : 1;\n-  unsigned bit_field_flag : 1;\n-  unsigned virtual_flag : 1;\n-  unsigned ignored_flag : 1;\n-  unsigned abstract_flag : 1;\n+/* FUNCTION_DECL inherits from DECL_NON_COMMON because of the use of the\n+   arguments/result/saved_tree fields by front ends.   It was either inherit\n+   FUNCTION_DECL from non_common, or inherit non_common from FUNCTION_DECL,\n+   which seemed a bit strange.  */\n \n-  unsigned in_system_header_flag : 1;\n-  unsigned common_flag : 1;\n-  unsigned defer_output : 1;\n-  unsigned transparent_union : 1;\n+struct tree_function_decl GTY(())\n+{\n+  struct tree_decl_non_common common;\n+  \n   unsigned static_ctor_flag : 1;\n   unsigned static_dtor_flag : 1;\n-  unsigned artificial_flag : 1;\n-  unsigned weak_flag : 1;\n-\n-  unsigned non_addr_const_p : 1;\n-  unsigned no_instrument_function_entry_exit : 1;\n-  unsigned comdat_flag : 1;\n+  unsigned uninlinable : 1;\n+  unsigned possibly_inlined : 1;\n+  unsigned novops_flag : 1;\n+  unsigned returns_twice_flag : 1;\n   unsigned malloc_flag : 1;\n-  unsigned no_limit_stack : 1;\n-  ENUM_BITFIELD(built_in_class) built_in_class : 2;\n   unsigned pure_flag : 1;\n-\n-  /* 32 bits: */\n-  unsigned non_addressable : 1;\n-  unsigned user_align : 1;\n-  unsigned uninlinable : 1;\n-  unsigned gimple_reg_flag : 1;\n+  \n   unsigned declared_inline_flag : 1;\n-  ENUM_BITFIELD(symbol_visibility) visibility : 2;\n-  unsigned visibility_specified : 1;\n+  unsigned regdecl_flag : 1;\n+  unsigned inline_flag : 1;\n+  unsigned no_instrument_function_entry_exit : 1;\n+  unsigned no_limit_stack : 1;\n+  ENUM_BITFIELD(built_in_class) built_in_class : 2;\n \n-  unsigned lang_flag_0 : 1;\n-  unsigned lang_flag_1 : 1;\n-  unsigned lang_flag_2 : 1;\n-  unsigned lang_flag_3 : 1;\n-  unsigned lang_flag_4 : 1;\n-  unsigned lang_flag_5 : 1;\n-  unsigned lang_flag_6 : 1;\n-  unsigned lang_flag_7 : 1;\n+  struct function *f;\n+};\n \n-  unsigned possibly_inlined : 1;\n-  unsigned preserve_flag: 1;\n-  unsigned gimple_formal_temp : 1;\n-  unsigned debug_expr_is_from : 1;\n-  unsigned returns_twice_flag : 1;\n-  unsigned seen_in_bind_expr : 1;\n-  unsigned novops_flag : 1;\n-  unsigned has_value_expr : 1;\n+/* For a TYPE_DECL, holds the \"original\" type.  (TREE_TYPE has the copy.) */\n+#define DECL_ORIGINAL_TYPE(NODE) (TYPE_DECL_CHECK (NODE)->decl_non_common.result)\n \n-  ENUM_BITFIELD(tls_model) tls_model : 3;\n-  /* 5 unused bits.  */\n+/* In a TYPE_DECL nonzero means the detail info about this type is not dumped\n+   into stabs.  Instead it will generate cross reference ('x') of names.\n+   This uses the same flag as DECL_EXTERNAL.  */\n+#define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n+  (TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_2)\n \n-  union tree_decl_u1 {\n-    /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n-       DECL_FUNCTION_CODE.  */\n-    enum built_in_function f;\n-    /* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this\n-       is used by language-dependent code.  */\n-    HOST_WIDE_INT i;\n-    /* DECL_ALIGN and DECL_OFFSET_ALIGN.  (These are not used for\n-       FUNCTION_DECLs).  */\n-    struct tree_decl_u1_a {\n-      unsigned int align : 24;\n-      unsigned int off_align : 8;\n-    } a;\n-  } GTY ((skip)) u1;\n+struct tree_type_decl GTY(())\n+{\n+  struct tree_decl_non_common common;\n \n-  tree size_unit;\n-  tree name;\n-  tree context;\n-  tree arguments;\t/* Also used for DECL_FIELD_OFFSET */\n-  tree result;\t/* Also used for DECL_BIT_FIELD_TYPE */\n-  tree initial;\t/* Also used for DECL_QUALIFIER */\n-  tree abstract_origin;\n-  tree assembler_name;\n-  tree section_name;\n-  tree attributes;\n-  rtx rtl;\t/* RTL representation for object.  */\n-\n-  /* In FUNCTION_DECL, if it is inline, holds the saved insn chain.\n-     In FIELD_DECL, is DECL_FIELD_BIT_OFFSET.\n-     In PARM_DECL, holds an RTL for the stack slot\n-     of register where the data was actually passed.\n-     Used by Chill and Java in LABEL_DECL and by C++ and Java in VAR_DECL.  */\n-  union tree_decl_u2 {\n-    struct function * GTY ((tag (\"FUNCTION_DECL\"))) f;\n-    rtx GTY ((tag (\"PARM_DECL\"))) r;\n-    tree GTY ((tag (\"FIELD_DECL\"))) t;\n-    int GTY ((tag (\"VAR_DECL\"))) i;\n-  } GTY ((desc (\"TREE_CODE((tree) &(%0))\"))) u2;\n-\n-  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.\n-     In a VAR_DECL or PARM_DECL, this is DECL_VALUE_EXPR.  */\n-  tree saved_tree;\n-  tree vindex;\n-  HOST_WIDE_INT pointer_alias_set;\n-  /* Points to a structure whose details depend on the language in use.  */\n-  struct lang_decl *lang_specific;\n };\n-\n \f\n /* A STATEMENT_LIST chains statements together in GENERIC and GIMPLE.\n    To reduce overhead, the nodes containing the statements are not trees.\n@@ -2549,27 +2724,7 @@ struct tree_value_handle GTY(())\n   unsigned int id;\n };\n \f\n-enum tree_node_structure_enum {\n-  TS_COMMON,\n-  TS_INT_CST,\n-  TS_REAL_CST,\n-  TS_VECTOR,\n-  TS_STRING,\n-  TS_COMPLEX,\n-  TS_IDENTIFIER,\n-  TS_DECL,\n-  TS_TYPE,\n-  TS_LIST,\n-  TS_VEC,\n-  TS_EXP,\n-  TS_SSA_NAME,\n-  TS_PHI_NODE,\n-  TS_BLOCK,\n-  TS_BINFO,\n-  TS_STATEMENT_LIST,\n-  TS_VALUE_HANDLE,\n-  LAST_TS_ENUM\n-};\n+\n \n /* Define the overall contents of a tree node.\n    It may be any of the structures declared above\n@@ -2585,7 +2740,19 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_string GTY ((tag (\"TS_STRING\"))) string;\n   struct tree_complex GTY ((tag (\"TS_COMPLEX\"))) complex;\n   struct tree_identifier GTY ((tag (\"TS_IDENTIFIER\"))) identifier;\n-  struct tree_decl GTY ((tag (\"TS_DECL\"))) decl;\n+  struct tree_decl_minimal GTY((tag (\"TS_DECL_MINIMAL\"))) decl_minimal;\n+  struct tree_decl_common GTY ((tag (\"TS_DECL_COMMON\"))) decl_common;\n+  struct tree_decl_with_rtl GTY ((tag (\"TS_DECL_WRTL\"))) decl_with_rtl;\n+  struct tree_decl_non_common  GTY ((tag (\"TS_DECL_NON_COMMON\"))) decl_non_common;\n+  struct tree_parm_decl  GTY  ((tag (\"TS_PARM_DECL\"))) parm_decl;\n+  struct tree_decl_with_vis GTY ((tag (\"TS_DECL_WITH_VIS\"))) decl_with_vis;\n+  struct tree_var_decl GTY ((tag (\"TS_VAR_DECL\"))) var_decl;\n+  struct tree_field_decl GTY ((tag (\"TS_FIELD_DECL\"))) field_decl;\n+  struct tree_label_decl GTY ((tag (\"TS_LABEL_DECL\"))) label_decl;\n+  struct tree_result_decl GTY ((tag (\"TS_RESULT_DECL\"))) result_decl;\n+  struct tree_const_decl GTY ((tag (\"TS_CONST_DECL\"))) const_decl;\n+  struct tree_type_decl GTY ((tag (\"TS_TYPE_DECL\"))) type_decl;\n+  struct tree_function_decl GTY ((tag (\"TS_FUNCTION_DECL\"))) function_decl;\n   struct tree_type GTY ((tag (\"TS_TYPE\"))) type;\n   struct tree_list GTY ((tag (\"TS_LIST\"))) list;\n   struct tree_vec GTY ((tag (\"TS_VEC\"))) vec;\n@@ -3933,6 +4100,17 @@ extern tree get_base_address (tree t);\n /* In tree-vectorizer.c.  */\n extern void vect_set_verbosity_level (const char *);\n \n+struct tree_map GTY(())\n+{\n+  unsigned int hash;\n+  tree from;\n+  tree to;\n+};\n+\n+extern unsigned int tree_map_hash (const void *);\n+extern int tree_map_marked_p (const void *);\n+extern int tree_map_eq (const void *, const void *);\n+\n /* In tree-ssa-address.c.  */\n extern tree tree_mem_ref_addr (tree, tree);\n extern void copy_mem_ref_info (tree, tree);"}, {"sha": "43a465d4ea73c2aaaf05ef2c990bced8125c94cc", "filename": "gcc/treestruct.def", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820cc88fbd53803f1b57374bfc78e628c6879fc0/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=820cc88fbd53803f1b57374bfc78e628c6879fc0", "patch": "@@ -0,0 +1,60 @@\n+/* This file contains the definitions for the tree structure\n+   enumeration used in GCC.  \n+\n+Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* The format of this file is \n+   DEFTREESTRUCT(enumeration value, printable name).\n+   Each enumeration value should correspond with a single member of union \n+   tree_node.  \n+   These enumerator values are used in order to distinguish members of union\n+   tree_node for garbage collection purposes, as well as specifying what structures\n+   contain what other structures in the tree_contains_struct array.  */\n+\t\n+DEFTREESTRUCT(TS_COMMON, \"common\")\n+DEFTREESTRUCT(TS_INT_CST, \"integer cst\")\n+DEFTREESTRUCT(TS_REAL_CST, \"real cst\")\n+DEFTREESTRUCT(TS_VECTOR, \"vector\")\n+DEFTREESTRUCT(TS_STRING, \"string\")\n+DEFTREESTRUCT(TS_COMPLEX, \"complex\")\n+DEFTREESTRUCT(TS_IDENTIFIER, \"indentifier\")\n+DEFTREESTRUCT(TS_DECL_MINIMAL, \"decl minimal\")\n+DEFTREESTRUCT(TS_DECL_COMMON, \"decl common\")\n+DEFTREESTRUCT(TS_DECL_WRTL, \"decl with RTL\")\n+DEFTREESTRUCT(TS_DECL_NON_COMMON, \"decl non-common\")\n+DEFTREESTRUCT(TS_DECL_WITH_VIS, \"decl with visibility\")\n+DEFTREESTRUCT(TS_FIELD_DECL, \"field decl\")\n+DEFTREESTRUCT(TS_VAR_DECL, \"var decl\")\n+DEFTREESTRUCT(TS_PARM_DECL, \"parm decl\")\n+DEFTREESTRUCT(TS_LABEL_DECL, \"label decl\")\n+DEFTREESTRUCT(TS_RESULT_DECL, \"result decl\")\n+DEFTREESTRUCT(TS_CONST_DECL, \"const decl\")\n+DEFTREESTRUCT(TS_TYPE_DECL, \"label decl\")\n+DEFTREESTRUCT(TS_FUNCTION_DECL, \"function decl\")\n+DEFTREESTRUCT(TS_TYPE, \"type\")\n+DEFTREESTRUCT(TS_LIST, \"list\")\n+DEFTREESTRUCT(TS_VEC, \"vec\")\n+DEFTREESTRUCT(TS_EXP, \"exp\")\n+DEFTREESTRUCT(TS_SSA_NAME, \"ssa name\")\n+DEFTREESTRUCT(TS_PHI_NODE, \"phi node\")\n+DEFTREESTRUCT(TS_BLOCK, \"block\")\n+DEFTREESTRUCT(TS_BINFO, \"binfo\")\n+DEFTREESTRUCT(TS_STATEMENT_LIST, \"statement list\")\n+DEFTREESTRUCT(TS_VALUE_HANDLE, \"value handle\")"}]}