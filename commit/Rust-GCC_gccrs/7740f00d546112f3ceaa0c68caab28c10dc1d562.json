{"sha": "7740f00d546112f3ceaa0c68caab28c10dc1d562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc0MGYwMGQ1NDYxMTJmM2NlYWEwYzY4Y2FhYjI4YzEwZGMxZDU2Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-16T20:51:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-16T20:51:31Z"}, "message": "langhooks-def.h (LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING, [...]): Remove.\n\n        * langhooks-def.h (LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING,\n        lhd_tree_inlining_copy_res_decl_for_inlining): Remove.\n        * langhooks.c (lhd_tree_inlining_copy_res_decl_for_inlining): Remove.\n        * langhooks.h (struct lang_hooks_for_tree_inlining): Remove\n        copy_res_decl_for_inlining.\n\n        * tree-inline.c (declare_return_variable): New modify_dest argument.\n        Use it as the return value, when possible or manditory.  Handle\n        TREE_ADDRESSABLE types.\n        (expand_call_inline): Extract MODIFY_EXPR lhs for call.  Simplify\n        replacement of CALL_EXPR.\n\ncp/\n        * cp-lang.c (LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING): Die.\n        * cp-tree.h (cp_copy_res_decl_for_inlining): Remove.\n        * tree.c (cp_copy_res_decl_for_inlining): Remove.\n\nFrom-SVN: r84831", "tree": {"sha": "1fb4722f84cb260ae7dddc523251e0014eb13091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb4722f84cb260ae7dddc523251e0014eb13091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7740f00d546112f3ceaa0c68caab28c10dc1d562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7740f00d546112f3ceaa0c68caab28c10dc1d562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7740f00d546112f3ceaa0c68caab28c10dc1d562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7740f00d546112f3ceaa0c68caab28c10dc1d562/comments", "author": null, "committer": null, "parents": [{"sha": "26e79d1018d0e6bd50b96f5f3fabb0376e392dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e79d1018d0e6bd50b96f5f3fabb0376e392dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e79d1018d0e6bd50b96f5f3fabb0376e392dff"}], "stats": {"total": 269, "additions": 120, "deletions": 149}, "files": [{"sha": "054c04ab6cca3315df9eac441bddd9f89fa4aed6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -1,3 +1,17 @@\n+2004-07-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING,\n+\tlhd_tree_inlining_copy_res_decl_for_inlining): Remove.\n+\t* langhooks.c (lhd_tree_inlining_copy_res_decl_for_inlining): Remove.\n+\t* langhooks.h (struct lang_hooks_for_tree_inlining): Remove\n+\tcopy_res_decl_for_inlining.\n+\n+\t* tree-inline.c (declare_return_variable): New modify_dest argument.\n+\tUse it as the return value, when possible or manditory.  Handle\n+\tTREE_ADDRESSABLE types.\n+\t(expand_call_inline): Extract MODIFY_EXPR lhs for call.  Simplify\n+\treplacement of CALL_EXPR.\n+\n 2004-07-16  Richard Henderson  <rth@redhat.com>\n \n \t* tree-flow.h (struct var_ann_d): Remove has_hidden_use."}, {"sha": "3945ebf0f53fd954d64f51c53f325c0e5b6392a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -1,3 +1,9 @@\n+2004-07-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-lang.c (LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING): Die.\n+\t* cp-tree.h (cp_copy_res_decl_for_inlining): Remove.\n+\t* tree.c (cp_copy_res_decl_for_inlining): Remove.\n+\n 2004-07-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (finish_struct_bits): Use for loop."}, {"sha": "27c9270130f3c73e4f2ea42767d4117933f3d9c2", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -131,9 +131,6 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #undef LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P\n #define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n   cp_auto_var_in_fn_p\n-#undef LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING\n-#define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n-  cp_copy_res_decl_for_inlining\n #undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P anon_aggr_type_p\n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P"}, {"sha": "f61dc39f24b8522c819f8b9568d15f02fd77f9a6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -4206,8 +4206,6 @@ extern int cp_cannot_inline_tree_fn (tree*);\n extern tree cp_add_pending_fn_decls (void*,tree);\n extern int cp_is_overload_p (tree);\n extern int cp_auto_var_in_fn_p (tree,tree);\n-extern tree cp_copy_res_decl_for_inlining (tree, tree, tree, void*,\n-\t\t\t\t\t\t   int*, tree);\n extern void cp_update_decl_after_saving (tree, void *);\n \n /* in typeck.c */"}, {"sha": "6279eb5d9b7401b2f5e4c3ecad73fe2697ef507a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -10680,8 +10680,8 @@ cxx_push_function_context (struct function * f)\n \t  *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (fn);\n \n \t  /* We don't need the saved data anymore.  Unless this is an inline\n-\t     function; we need the named return value info for\n-\t     cp_copy_res_decl_for_inlining.  */\n+\t     function; we need the named return value info for \n+\t     declare_return_variable.  */\n \t  if (! DECL_INLINE (fn))\n \t    DECL_SAVED_FUNCTION_DATA (fn) = NULL;\n \t}"}, {"sha": "253c1e6fea6da16b51f5878f10fbc719ce1ed0be", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -2093,48 +2093,6 @@ cp_auto_var_in_fn_p (tree var, tree fn)\n \t  && nonstatic_local_decl_p (var));\n }\n \n-/* Tell whether a declaration is needed for the RESULT of a function\n-   FN being inlined into CALLER or if the top node of target_exprs is\n-   to be used.  */\n-\n-tree\n-cp_copy_res_decl_for_inlining (tree result, \n-                               tree fn, \n-                               tree caller, \n-                               void* decl_map_ ATTRIBUTE_UNUSED,\n-                               int* need_decl, \n-                               tree return_slot_addr)\n-{\n-  tree var;\n-\n-  /* If FN returns an aggregate then the caller will always pass the\n-     address of the return slot explicitly.  If we were just to\n-     create a new VAR_DECL here, then the result of this function\n-     would be copied (bitwise) into the variable initialized by the\n-     TARGET_EXPR.  That's incorrect, so we must transform any\n-     references to the RESULT into references to the target.  */\n-\n-  /* We should have an explicit return slot iff the return type is\n-     TREE_ADDRESSABLE.  See gimplify_aggr_init_expr.  */\n-  if (TREE_ADDRESSABLE (TREE_TYPE (result))\n-      != (return_slot_addr != NULL_TREE))\n-    abort ();\n-\n-  *need_decl = !return_slot_addr;\n-  if (return_slot_addr)\n-    {\n-      var = build_indirect_ref (return_slot_addr, \"\");\n-      if (! same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (var),\n-\t\t\t\t\t\t       TREE_TYPE (result)))\n-\tabort ();\n-    }\n-  /* Otherwise, make an appropriate copy.  */\n-  else\n-    var = copy_decl_for_inlining (result, fn, caller);\n-\n-  return var;\n-}\n-\n /* FN body has been duplicated.  Update language specific fields.  */\n \n void"}, {"sha": "ae8dcd2ef95f21c4e08c99866da9f22ddd8b42e1", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -78,8 +78,6 @@ extern int lhd_tree_inlining_cannot_inline_tree_fn (tree *);\n extern int lhd_tree_inlining_disregard_inline_limits (tree);\n extern tree lhd_tree_inlining_add_pending_fn_decls (void *, tree);\n extern int lhd_tree_inlining_auto_var_in_fn_p (tree, tree);\n-extern tree lhd_tree_inlining_copy_res_decl_for_inlining (tree, tree, tree,\n-\t\t\t\t\t\t\t  void *, int *, tree);\n extern int lhd_tree_inlining_anon_aggr_type_p (tree);\n extern int lhd_tree_inlining_start_inlining (tree);\n extern void lhd_tree_inlining_end_inlining (tree);\n@@ -150,8 +148,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n   lhd_tree_inlining_add_pending_fn_decls\n #define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n   lhd_tree_inlining_auto_var_in_fn_p\n-#define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n-  lhd_tree_inlining_copy_res_decl_for_inlining\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n   lhd_tree_inlining_anon_aggr_type_p\n #define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P \\\n@@ -169,7 +165,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n   LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS, \\\n   LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS, \\\n   LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P, \\\n-  LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING, \\\n   LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P, \\\n   LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P, \\\n   LANG_HOOKS_TREE_INLINING_START_INLINING, \\"}, {"sha": "aa8dc3a633ac56d584014d24e1c04573bccba301", "filename": "gcc/langhooks.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -362,28 +362,6 @@ lhd_tree_inlining_auto_var_in_fn_p (tree var, tree fn)\n \t      || TREE_CODE (var) == RESULT_DECL));\n }\n \n-/* lang_hooks.tree_inlining.copy_res_decl_for_inlining should return a\n-   declaration for the result RES of function FN to be inlined into\n-   CALLER.  NDP points to an integer that should be set in case a new\n-   declaration wasn't created (presumably because RES was of aggregate\n-   type, such that a TARGET_EXPR is used for the result).  TEXPS is a\n-   pointer to a varray with the stack of TARGET_EXPRs seen while\n-   inlining functions into caller; the top of TEXPS is supposed to\n-   match RES.  */\n-\n-tree\n-lhd_tree_inlining_copy_res_decl_for_inlining (tree res, tree fn, tree caller,\n-\t\t\t\t\t      void *dm ATTRIBUTE_UNUSED,\n-\t\t\t\t\t      int *ndp ATTRIBUTE_UNUSED,\n-\t\t\t\t\t      tree return_slot_addr ATTRIBUTE_UNUSED)\n-{\n-  if (return_slot_addr)\n-    return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (return_slot_addr)),\n-\t\t   return_slot_addr);\n-  else\n-    return copy_decl_for_inlining (res, fn, caller);\n-}\n-\n /* lang_hooks.tree_inlining.anon_aggr_type_p determines whether T is a\n    type node representing an anonymous aggregate (union, struct, etc),\n    i.e., one whose members are in the same scope as the union itself.  */"}, {"sha": "345e89c5047e10f1f7fa0e24b1ae79840bf23b12", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -40,8 +40,6 @@ struct lang_hooks_for_tree_inlining\n   int (*disregard_inline_limits) (tree);\n   tree (*add_pending_fn_decls) (void *, tree);\n   int (*auto_var_in_fn_p) (tree, tree);\n-  tree (*copy_res_decl_for_inlining) (tree, tree, tree,\n-\t\t\t\t      void *, int *, tree);\n   int (*anon_aggr_type_p) (tree);\n   bool (*var_mod_type_p) (tree, tree);\n   int (*start_inlining) (tree);"}, {"sha": "705216adb4f6e03b4063d1d57f45d588a798d1a8", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 98, "deletions": 71, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7740f00d546112f3ceaa0c68caab28c10dc1d562/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=7740f00d546112f3ceaa0c68caab28c10dc1d562", "patch": "@@ -122,7 +122,6 @@ typedef struct inline_data\n    decisions about when a function is too big to inline.  */\n #define INSNS_PER_STMT (10)\n \n-static tree declare_return_variable (inline_data *, tree, tree *);\n static tree copy_body_r (tree *, int *, void *);\n static tree copy_body (inline_data *);\n static tree expand_call_inline (tree *, int *, void *);\n@@ -851,35 +850,102 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n   return init_stmts;\n }\n \n-/* Declare a return variable to replace the RESULT_DECL for the\n-   function we are calling.  An appropriate decl is returned.\n- \n-   ??? Needs documentation of parameters. */\n+/* Declare a return variable to replace the RESULT_DECL for the function we\n+   are calling.  RETURN_SLOT_ADDR, if non-null, was a fake parameter that\n+   took the address of the result.  MODIFY_DEST, if non-null, was the LHS of\n+   the MODIFY_EXPR to which this call is the RHS.\n+\n+   The return value is a (possibly null) value that is the result of the\n+   function as seen by the callee.  *USE_P is a (possibly null) value that\n+   holds the result as seen by the caller.  */\n \n static tree\n-declare_return_variable (inline_data *id, tree return_slot_addr, tree *use_p)\n+declare_return_variable (inline_data *id, tree return_slot_addr,\n+\t\t\t tree modify_dest, tree *use_p)\n {\n-  tree fn = VARRAY_TOP_TREE (id->fns);\n-  tree result = DECL_RESULT (fn);\n-  int need_return_decl = 1;\n-  tree var;\n+  tree callee = VARRAY_TOP_TREE (id->fns);\n+  tree caller = VARRAY_TREE (id->fns, 0);\n+  tree result = DECL_RESULT (callee);\n+  tree callee_type = TREE_TYPE (result);\n+  tree caller_type = TREE_TYPE (TREE_TYPE (callee));\n+  tree var, use;\n \n   /* We don't need to do anything for functions that don't return\n      anything.  */\n-  if (!result || VOID_TYPE_P (TREE_TYPE (result)))\n+  if (!result || VOID_TYPE_P (callee_type))\n     {\n       *use_p = NULL_TREE;\n       return NULL_TREE;\n     }\n \n-  var = (lang_hooks.tree_inlining.copy_res_decl_for_inlining\n-\t (result, fn, VARRAY_TREE (id->fns, 0), id->decl_map,\n-\t  &need_return_decl, return_slot_addr));\n-  \n+  /* If there was a return slot, then the return value the the\n+     dereferenced address of that object.  */\n+  if (return_slot_addr)\n+    {\n+      /* The front end shouldn't have used both return_slot_addr and\n+\t a modify expression.  */\n+      if (modify_dest)\n+\tabort ();\n+      var = build_fold_indirect_ref (return_slot_addr);\n+      use = NULL;\n+      goto done;\n+    }\n+\n+  /* All types requiring non-trivial constructors should have been handled.  */\n+  if (TREE_ADDRESSABLE (callee_type))\n+    abort ();\n+\n+  /* Attempt to avoid creating a new temporary variable.  */\n+  if (modify_dest)\n+    {\n+      bool use_it = false;\n+\n+      /* We can't use MODIFY_DEST if there's type promotion involved.  */\n+      if (!lang_hooks.types_compatible_p (caller_type, callee_type))\n+\tuse_it = false;\n+\n+      /* ??? If we're assigning to a variable sized type, then we must\n+\t reuse the destination variable, because we've no good way to\n+\t create variable sized temporaries at this point.  */\n+      else if (TREE_CODE (TYPE_SIZE_UNIT (caller_type)) != INTEGER_CST)\n+\tuse_it = true;\n+\n+      /* If the callee cannot possibly modify MODIFY_DEST, then we can\n+\t reuse it as the result of the call directly.  Don't do this if\n+\t it would promote MODIFY_DEST to addressable.  */\n+      else if (!TREE_STATIC (modify_dest)\n+\t       && !TREE_ADDRESSABLE (modify_dest)\n+\t       && !TREE_ADDRESSABLE (result))\n+\tuse_it = true;\n+\n+      if (use_it)\n+\t{\n+\t  var = modify_dest;\n+\t  use = NULL;\n+\t  goto done;\n+\t}\n+    }\n+\n+  if (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) != INTEGER_CST)\n+    abort ();\n+\n+  var = copy_decl_for_inlining (result, callee, caller);\n+  DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n+  DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list\n+    = tree_cons (NULL_TREE, var,\n+\t\t DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list);\n+\n   /* Do not have the rest of GCC warn about this variable as it should\n      not be visible to the user.   */\n   TREE_NO_WARNING (var) = 1;\n \n+  /* Build the use expr.  If the return type of the function was\n+     promoted, convert it back to the expected type.  */\n+  use = var;\n+  if (!lang_hooks.types_compatible_p (TREE_TYPE (var), caller_type))\n+    use = fold_convert (caller_type, var);\n+\n+ done:\n   /* Register the VAR_DECL as the equivalent for the RESULT_DECL; that\n      way, when the RESULT_DECL is encountered, it will be\n      automatically replaced by the VAR_DECL.  */\n@@ -888,30 +954,8 @@ declare_return_variable (inline_data *id, tree return_slot_addr, tree *use_p)\n   /* Remember this so we can ignore it in remap_decls.  */\n   id->retvar = var;\n \n-  /* Build the use expr.  If the return type of the function was\n-     promoted, convert it back to the expected type.  */\n-  if (return_slot_addr)\n-    /* The function returns through an explicit return slot, not a normal\n-       return value.  */\n-    *use_p = NULL_TREE;\n-  else if (TREE_TYPE (var) == TREE_TYPE (TREE_TYPE (fn)))\n-    *use_p = var;\n-  else if (TREE_CODE (var) == INDIRECT_REF)\n-    *use_p = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t     TREE_OPERAND (var, 0));\n-  else if (TREE_ADDRESSABLE (TREE_TYPE (var)))\n-    abort ();\n-  else\n-    *use_p = build1 (NOP_EXPR, TREE_TYPE (TREE_TYPE (fn)), var);\n-\n-  /* Build the declaration statement if FN does not return an\n-     aggregate.  */\n-  if (need_return_decl)\n-    return var;\n-  /* If FN does return an aggregate, there's no need to declare the\n-     return variable; we're using a variable in our caller's frame.  */\n-  else\n-    return NULL_TREE;\n+  *use_p = use;\n+  return var;\n }\n \n /* Returns nonzero if a function can be inlined as a tree.  */\n@@ -1385,10 +1429,10 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   tree fn;\n   tree arg_inits;\n   tree *inlined_body;\n-  tree inline_result;\n   splay_tree st;\n   tree args;\n   tree return_slot_addr;\n+  tree modify_dest;\n   location_t saved_location;\n   struct cgraph_edge *edge;\n   const char *reason;\n@@ -1517,7 +1561,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n      statements within the function to jump to.  The type of the\n      statement expression is the return type of the function call.  */\n   stmt = NULL;\n-  expr = build (BIND_EXPR, TREE_TYPE (TREE_TYPE (fn)), NULL_TREE,\n+  expr = build (BIND_EXPR, void_type_node, NULL_TREE,\n \t\tstmt, make_node (BLOCK));\n   BLOCK_ABSTRACT_ORIGIN (BIND_EXPR_BLOCK (expr)) = fn;\n \n@@ -1586,10 +1630,16 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       || TREE_CODE (DECL_INITIAL (fn)) != BLOCK)\n     abort ();\n \n+  /* Find the lhs to which the result of this call is assigned.  */\n+  modify_dest = tsi_stmt (id->tsi);\n+  if (TREE_CODE (modify_dest) == MODIFY_EXPR)\n+    modify_dest = TREE_OPERAND (modify_dest, 0);\n+  else\n+    modify_dest = NULL;\n+\n   /* Declare the return variable for the function.  */\n-  decl = declare_return_variable (id, return_slot_addr, &use_retvar);\n-  if (decl)\n-    declare_inline_vars (expr, decl);\n+  decl = declare_return_variable (id, return_slot_addr,\n+\t\t\t\t  modify_dest, &use_retvar);\n \n   /* After we've initialized the parameters, we insert the body of the\n      function itself.  */\n@@ -1611,41 +1661,23 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       append_to_statement_list (label, &BIND_EXPR_BODY (expr));\n     }\n \n-  /* Finally, mention the returned value so that the value of the\n-     statement-expression is the returned value of the function.  */\n-  if (use_retvar)\n-    /* Set TREE_TYPE on BIND_EXPR?  */\n-    append_to_statement_list_force (use_retvar, &BIND_EXPR_BODY (expr));\n-\n   /* Clean up.  */\n   splay_tree_delete (id->decl_map);\n   id->decl_map = st;\n \n   /* The new expression has side-effects if the old one did.  */\n   TREE_SIDE_EFFECTS (expr) = TREE_SIDE_EFFECTS (t);\n \n-  /* We want to create a new variable to hold the result of the inlined\n-     body.  This new variable needs to be added to the function which we\n-     are inlining into, thus the saving and restoring of\n-     current_function_decl.  */\n-  {\n-    tree save_decl = current_function_decl;\n-    current_function_decl = id->node->decl;\n-    inline_result = voidify_wrapper_expr (expr, NULL);\n-    current_function_decl = save_decl;\n-  }\n+  tsi_link_before (&id->tsi, expr, TSI_SAME_STMT);\n \n   /* If the inlined function returns a result that we care about,\n      then we're going to need to splice in a MODIFY_EXPR.  Otherwise\n      the call was a standalone statement and we can just replace it\n      with the BIND_EXPR inline representation of the called function.  */\n-  if (TREE_CODE (tsi_stmt (id->tsi)) != CALL_EXPR)\n-    {\n-      tsi_link_before (&id->tsi, expr, TSI_SAME_STMT);\n-      *tp = inline_result;\n-    }\n+  if (!use_retvar || !modify_dest)\n+    *tsi_stmt_ptr (id->tsi) = build_empty_stmt ();\n   else\n-    *tp = expr;\n+    *tp = use_retvar;\n \n   /* When we gimplify a function call, we may clear TREE_SIDE_EFFECTS on\n      the call if it is to a \"const\" function.  Thus the copy of\n@@ -1660,11 +1692,6 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n      the toplevel expression.  */\n   recalculate_side_effects (expr);\n \n-  /* If the value of the new expression is ignored, that's OK.  We\n-     don't warn about this for CALL_EXPRs, so we shouldn't warn about\n-     the equivalent inlined version either.  */\n-  TREE_USED (*tp) = 1;\n-\n   /* Update callgraph if needed.  */\n   cgraph_remove_node (edge->callee);\n "}]}