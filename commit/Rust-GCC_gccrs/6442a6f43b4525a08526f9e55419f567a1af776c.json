{"sha": "6442a6f43b4525a08526f9e55419f567a1af776c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ0MmE2ZjQzYjQ1MjVhMDg1MjZmOWU1NTQxOWY1NjdhMWFmNzc2Yw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-06-01T14:30:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-06-01T14:30:00Z"}, "message": "re PR fortran/71156 (PURE interface/definition inconsistency: accepts invalid, rejects valid)\n\n2016-06-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/71156\n\t* decl.c (copy_prefix): Add checks that the module procedure\n\tdeclaration prefixes are compliant with the interface. Invert\n\torder of existing elemental and pure checks.\n\t* resolve.c (resolve_fl_procedure): Invert order of elemental\n\tand pure errors.\n\n2016-06-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/71156\n\t* gfortran.dg/submodule_14.f08: Add missing recursive prefix\n\tto the module procedure declaration.\n\t* gfortran.dg/submodule_16.f08: New test.\n\nFrom-SVN: r236996", "tree": {"sha": "f09700eb58e6a8b3d0e9f95544d3f416715aad97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f09700eb58e6a8b3d0e9f95544d3f416715aad97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6442a6f43b4525a08526f9e55419f567a1af776c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6442a6f43b4525a08526f9e55419f567a1af776c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6442a6f43b4525a08526f9e55419f567a1af776c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6442a6f43b4525a08526f9e55419f567a1af776c/comments", "author": null, "committer": null, "parents": [{"sha": "ab62397a1b51a925abf062999a96556241dc3478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab62397a1b51a925abf062999a96556241dc3478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab62397a1b51a925abf062999a96556241dc3478"}], "stats": {"total": 134, "additions": 121, "deletions": 13}, "files": [{"sha": "1cc998e78b586e18f25a3fd51c9289d3557ea676", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6442a6f43b4525a08526f9e55419f567a1af776c", "patch": "@@ -1,3 +1,12 @@\n+2016-06-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/71156\n+\t* decl.c (copy_prefix): Add checks that the module procedure\n+\tdeclaration prefixes are compliant with the interface. Invert\n+\torder of existing elemental and pure checks.\n+\t* resolve.c (resolve_fl_procedure): Invert order of elemental\n+\tand pure errors.\n+\n 2016-06-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* parse.c (case_decl): Move ST_OMP_* to ..."}, {"sha": "724f14f7ff12a248e509299c31b6b9937193bcbe", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=6442a6f43b4525a08526f9e55419f567a1af776c", "patch": "@@ -608,10 +608,10 @@ gfc_match_data (void)\n \n /* Like gfc_match_init_expr, but matches a 'clist' (old-style initialization\n    list). The difference here is the expression is a list of constants\n-   and is surrounded by '/'. \n+   and is surrounded by '/'.\n    The typespec ts must match the typespec of the variable which the\n    clist is initializing.\n-   The arrayspec tells whether this should match a list of constants \n+   The arrayspec tells whether this should match a list of constants\n    corresponding to array elements or a scalar (as == NULL).  */\n \n static match\n@@ -1848,7 +1848,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \n   /* If we are in a nested union/map definition, gfc_add_component will not\n      properly find repeated components because:\n-       (i) gfc_add_component does a flat search, where components of unions \n+       (i) gfc_add_component does a flat search, where components of unions\n            and maps are implicity chained so nested components may conflict.\n       (ii) Unions and maps are not linked as components of their parent\n            structures until after they are parsed.\n@@ -4978,12 +4978,51 @@ gfc_match_prefix (gfc_typespec *ts)\n static bool\n copy_prefix (symbol_attribute *dest, locus *where)\n {\n-  if (current_attr.pure && !gfc_add_pure (dest, where))\n-    return false;\n+  if (dest->module_procedure)\n+    {\n+      if (current_attr.elemental)\n+\tdest->elemental = 1;\n+\n+      if (current_attr.pure)\n+\tdest->pure = 1;\n+\n+      if (current_attr.recursive)\n+\tdest->recursive = 1;\n+\n+      /* Module procedures are unusual in that the 'dest' is copied from\n+\t the interface declaration. However, this is an oportunity to\n+\t check that the submodule declaration is compliant with the\n+\t interface.  */\n+      if (dest->elemental && !current_attr.elemental)\n+\t{\n+\t  gfc_error (\"ELEMENTAL prefix in MODULE PROCEDURE interface is \"\n+\t\t     \"missing at %L\", where);\n+\t  return false;\n+\t}\n+\n+      if (dest->pure && !current_attr.pure)\n+\t{\n+\t  gfc_error (\"PURE prefix in MODULE PROCEDURE interface is \"\n+\t\t     \"missing at %L\", where);\n+\t  return false;\n+\t}\n+\n+      if (dest->recursive && !current_attr.recursive)\n+\t{\n+\t  gfc_error (\"RECURSIVE prefix in MODULE PROCEDURE interface is \"\n+\t\t     \"missing at %L\", where);\n+\t  return false;\n+\t}\n+\n+      return true;\n+    }\n \n   if (current_attr.elemental && !gfc_add_elemental (dest, where))\n     return false;\n \n+  if (current_attr.pure && !gfc_add_pure (dest, where))\n+    return false;\n+\n   if (current_attr.recursive && !gfc_add_recursive (dest, where))\n     return false;\n \n@@ -8327,7 +8366,7 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n    does NOT have a generic symbol matching the name given by the user.\n    STRUCTUREs can share names with variables and PARAMETERs so we must allow\n    for the creation of an independent symbol.\n-   Other parameters are a message to prefix errors with, the name of the new \n+   Other parameters are a message to prefix errors with, the name of the new\n    type to be created, and the flavor to add to the resulting symbol. */\n \n static bool\n@@ -8355,7 +8394,7 @@ get_struct_decl (const char *name, sym_flavor fl, locus *decl,\n \n   if (sym->components != NULL || sym->attr.zero_comp)\n     {\n-      gfc_error (\"Type definition of '%s' at %C was already defined at %L\", \n+      gfc_error (\"Type definition of '%s' at %C was already defined at %L\",\n                  sym->name, &sym->declared_at);\n       return false;\n     }"}, {"sha": "77f8c10bf7ec45ef1871956ec8d5f52ea93e0490", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6442a6f43b4525a08526f9e55419f567a1af776c", "patch": "@@ -11965,17 +11965,17 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \tgoto check_formal;\n \n       /* Check the procedure characteristics.  */\n-      if (sym->attr.pure != iface->attr.pure)\n+      if (sym->attr.elemental != iface->attr.elemental)\n \t{\n-\t  gfc_error (\"Mismatch in PURE attribute between MODULE \"\n+\t  gfc_error (\"Mismatch in ELEMENTAL attribute between MODULE \"\n \t\t     \"PROCEDURE at %L and its interface in %s\",\n \t\t     &sym->declared_at, module_name);\n \t  return false;\n \t}\n \n-      if (sym->attr.elemental != iface->attr.elemental)\n+      if (sym->attr.pure != iface->attr.pure)\n \t{\n-\t  gfc_error (\"Mismatch in ELEMENTAL attribute between MODULE \"\n+\t  gfc_error (\"Mismatch in PURE attribute between MODULE \"\n \t\t     \"PROCEDURE at %L and its interface in %s\",\n \t\t     &sym->declared_at, module_name);\n \t  return false;"}, {"sha": "49fe8c0e9a30f57dcedaf752c2819cae663e6828", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6442a6f43b4525a08526f9e55419f567a1af776c", "patch": "@@ -1,3 +1,10 @@\n+2016-06-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/71156\n+\t* gfortran.dg/submodule_14.f08: Add missing recursive prefix\n+\tto the module procedure declaration.\n+\t* gfortran.dg/submodule_16.f08: New test.\n+\n 2016-06-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/71371\n@@ -322,7 +329,7 @@\n 2016-05-26  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/aarch64/simd/vmul_elem_1.c: Force result variables to be\n-\tkept in memory. \n+\tkept in memory.\n \n 2016-05-25  Jeff Law  <law@redhat.com>\n "}, {"sha": "cbfc3d1d4b17aa626c28d7e9f0abee59a20334c1", "filename": "gcc/testsuite/gfortran.dg/submodule_14.f08", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_14.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_14.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_14.f08?ref=6442a6f43b4525a08526f9e55419f567a1af776c", "patch": "@@ -27,7 +27,7 @@ end module test\n         Call sub1 (x)\n     End If\n   End Procedure sub1\n-  module function fcn1 (x) result(res)\n+  recursive module function fcn1 (x) result(res)\n     integer, intent (inout) :: x\n     integer :: res\n     res = x - 1"}, {"sha": "6e555b60eff0b3a6f1e82f37c921578a369cb329", "filename": "gcc/testsuite/gfortran.dg/submodule_16.f08", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_16.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6442a6f43b4525a08526f9e55419f567a1af776c/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_16.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_16.f08?ref=6442a6f43b4525a08526f9e55419f567a1af776c", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+!\n+! Tests the fix for PR71156 in which the valid code (f7, f8 and f9 below)\n+! triggered an error, while the invalid code (f1 to f6) compiled.\n+!\n+! Contributed by Damian Rousn  <damian@sourceryinstitute.org>\n+!\n+module my_interface\n+  implicit none\n+  interface\n+    module subroutine f1\n+    end subroutine\n+    module subroutine f2\n+    end subroutine\n+    module subroutine f3\n+    end subroutine\n+    elemental module subroutine f4\n+    end subroutine\n+    pure module subroutine f5\n+    end subroutine\n+    recursive module subroutine f6\n+    end subroutine\n+    elemental module subroutine f7\n+    end subroutine\n+    pure module subroutine f8\n+    end subroutine\n+    recursive module subroutine f9\n+    end subroutine\n+  end interface\n+end module\n+\n+submodule(my_interface) my_implementation\n+  implicit none\n+contains\n+    elemental module subroutine f1 ! { dg-error \"Mismatch in ELEMENTAL attribute\" }\n+    end subroutine\n+    pure module subroutine f2 ! { dg-error \"Mismatch in PURE attribute\" }\n+    end subroutine\n+    recursive module subroutine f3 ! { dg-error \"Mismatch in RECURSIVE attribute\" }\n+    end subroutine\n+    module subroutine f4 ! { dg-error \"ELEMENTAL prefix\" }\n+    end subroutine\n+    module subroutine f5 ! { dg-error \"PURE prefix\" }\n+    end subroutine\n+    module subroutine f6 ! { dg-error \"RECURSIVE prefix\" }\n+    end subroutine\n+    elemental module subroutine f7\n+    end subroutine\n+    pure module subroutine f8\n+    end subroutine\n+    recursive module subroutine f9\n+    end subroutine\n+end submodule"}]}