{"sha": "948cf550b44fc0cca1c2eb6688d37ca93e99cb68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4Y2Y1NTBiNDRmYzBjY2ExYzJlYjY2ODhkMzdjYTkzZTk5Y2I2OA==", "commit": {"author": {"name": "Igor Zamyatin", "email": "igor.zamyatin@intel.com", "date": "2014-10-20T15:22:09Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2014-10-20T15:22:09Z"}, "message": "re PR c/63307 (Cilk+ breaks -fcompare-debug bootstrap)\n\n\tPR c/63307\ngcc/c-family/\n\t* cilk.c: Include vec.h.\n\t(struct cilk_decls): New structure.\n\t(wrapper_parm_cb): Split this function to...\n\t(fill_decls_vec): ...this...\n\t(create_parm_list): ...and this.\n\t(compare_decls): New function.\n\t(for_local_cb): Remove.\n\t(wrapper_local_cb): Ditto.\n\t(build_wrapper_type): For now first traverse and fill vector of\n\tdeclarations then sort it and then deal with sorted vector.\n\t(cilk_outline): Ditto.\n\t(declare_one_free_variable): Ditto.\n\nFrom-SVN: r216483", "tree": {"sha": "f4ed6fbf0573b839728635c6d770d8f601662172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4ed6fbf0573b839728635c6d770d8f601662172"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/948cf550b44fc0cca1c2eb6688d37ca93e99cb68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948cf550b44fc0cca1c2eb6688d37ca93e99cb68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948cf550b44fc0cca1c2eb6688d37ca93e99cb68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948cf550b44fc0cca1c2eb6688d37ca93e99cb68/comments", "author": {"login": "Garra1980", "id": 25365940, "node_id": "MDQ6VXNlcjI1MzY1OTQw", "avatar_url": "https://avatars.githubusercontent.com/u/25365940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Garra1980", "html_url": "https://github.com/Garra1980", "followers_url": "https://api.github.com/users/Garra1980/followers", "following_url": "https://api.github.com/users/Garra1980/following{/other_user}", "gists_url": "https://api.github.com/users/Garra1980/gists{/gist_id}", "starred_url": "https://api.github.com/users/Garra1980/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Garra1980/subscriptions", "organizations_url": "https://api.github.com/users/Garra1980/orgs", "repos_url": "https://api.github.com/users/Garra1980/repos", "events_url": "https://api.github.com/users/Garra1980/events{/privacy}", "received_events_url": "https://api.github.com/users/Garra1980/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbb4cfef76186a547ac0c3ce1e0d895cd87685ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb4cfef76186a547ac0c3ce1e0d895cd87685ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb4cfef76186a547ac0c3ce1e0d895cd87685ec"}], "stats": {"total": 128, "additions": 87, "deletions": 41}, "files": [{"sha": "c673a743e6dd2bea7c880664da4f70373d21ee92", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948cf550b44fc0cca1c2eb6688d37ca93e99cb68/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948cf550b44fc0cca1c2eb6688d37ca93e99cb68/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=948cf550b44fc0cca1c2eb6688d37ca93e99cb68", "patch": "@@ -1,3 +1,19 @@\n+2014-10-20  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR c/63307\n+\t* cilk.c: Include vec.h.\n+\t(struct cilk_decls): New structure.\n+\t(wrapper_parm_cb): Split this function to...\n+\t(fill_decls_vec): ...this...\n+\t(create_parm_list): ...and this.\n+\t(compare_decls): New function.\n+\t(for_local_cb): Remove.\n+\t(wrapper_local_cb): Ditto.\n+\t(build_wrapper_type): For now first traverse and fill vector of\n+\tdeclarations then sort it and then deal with sorted vector.\n+\t(cilk_outline): Ditto.\n+\t(declare_one_free_variable): Ditto.\n+\n 2014-10-17  Marek Polacek  <polacek@redhat.com>\n \n \t* c-opts.c (c_common_post_options): Set warn_implicit_int."}, {"sha": "ffcf3b53bcd993386292d39f48890f5d3131ffdc", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948cf550b44fc0cca1c2eb6688d37ca93e99cb68/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948cf550b44fc0cca1c2eb6688d37ca93e99cb68/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=948cf550b44fc0cca1c2eb6688d37ca93e99cb68", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\" \n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n+#include \"vec.h\"\n #include \"cilk.h\"\n \n enum add_variable_type {\n@@ -332,17 +333,36 @@ create_cilk_helper_decl (struct wrapper_data *wd)\n   return fndecl;\n }\n \n-/* A function used by walk tree to find wrapper parms.  */\n+struct cilk_decls\n+{\n+  tree key;\n+  tree *val;\n+};\n+\n+/* A function used by traversal to fill vector of decls for further work.  */\n \n bool\n-wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n+fill_decls_vec (tree const &key0, tree *val0, auto_vec<struct cilk_decls> *v)\n+{\n+  tree t1 = key0;\n+  struct cilk_decls dp;\n+\n+  dp.key = t1;\n+  dp.val = val0;\n+  v->safe_push (dp);\n+  return true;\n+}\n+\n+/* Function that actually creates necessary parm lists.  */\n+\n+static void\n+create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n {\n-  tree arg = key0;\n   tree val = *val0;\n   tree parm;\n \n   if (val == error_mark_node || val == arg)\n-    return true;\n+    return;\n \n   if (TREE_CODE (val) == PAREN_EXPR)\n     {\n@@ -360,7 +380,7 @@ wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n \t}\n       else\n \targ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), arg);\n-\t\n+\n       val = TREE_OPERAND (val, 0);\n       *val0 = val;\n       gcc_assert (TREE_CODE (val) == INDIRECT_REF);\n@@ -371,23 +391,46 @@ wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n     parm = val;\n   TREE_CHAIN (parm) = wd->parms;\n   wd->parms = parm;\n-  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes); \n-  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist); \n-  return true;\n+  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes);\n+  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist);\n+}\n+\n+/* Sorting decls in a vector.  */\n+\n+static int\n+compare_decls (const void *a, const void *b)\n+{\n+  const struct cilk_decls* t1 = (const struct cilk_decls*) a;\n+  const struct cilk_decls* t2 = (const struct cilk_decls*) b;\n+\n+  if (DECL_UID (t1->key) > DECL_UID (t2->key))\n+    return 1;\n+  else if (DECL_UID (t1->key) < DECL_UID (t2->key))\n+    return -1;\n+  else\n+    return 0;\n }\n \n /* This function is used to build a wrapper of a certain type.  */\n \n static void\n build_wrapper_type (struct wrapper_data *wd)\n {\n+  unsigned int j;\n+  struct cilk_decls * c;\n+  auto_vec<struct cilk_decls> vd;\n   wd->arglist = NULL_TREE;\n   wd->parms = NULL_TREE;\n   wd->argtypes = void_list_node;\n \n-  wd->decl_map->traverse<wrapper_data *, wrapper_parm_cb> (wd);\n+  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n   gcc_assert (wd->type != CILK_BLOCK_FOR);\n \n+  vd.qsort (compare_decls);\n+\n+  FOR_EACH_VEC_ELT (vd, j, c)\n+   create_parm_list (wd, c->val, c->key);\n+\n   /* Now build a function.\n      Its return type is void (all side effects are via explicit parameters).\n      Its parameters are WRAPPER_PARMS with type WRAPPER_TYPES.\n@@ -448,41 +491,19 @@ copy_decl_for_cilk (tree decl, copy_body_data *id)\n     }\n }\n \n-/* Copy all local variables.  */\n-\n-bool\n-for_local_cb (tree const &k, tree *vp, copy_body_data *id)\n-{\n-  tree v = *vp;\n-\n-  if (v == error_mark_node)\n-    *vp = copy_decl_no_change (k, id);\n-  return true;\n-}\n-\n-/* Copy all local declarations from a _Cilk_spawned function's body.  */\n-\n-bool\n-wrapper_local_cb (tree const &key, tree *vp, copy_body_data *id)\n-{\n-  tree val = *vp;\n-\n-  if (val == error_mark_node)\n-    *vp = copy_decl_for_cilk (key, id);\n-\n-  return true;\n-}\n-\n /* Alter a tree STMT from OUTER_FN to form the body of INNER_FN.  */\n \n void\n cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n {\n   struct wrapper_data *wd = (struct wrapper_data *) w;\n-  const tree outer_fn = wd->context;\t      \n+  const tree outer_fn = wd->context;\n   const bool nested = (wd->type == CILK_BLOCK_FOR);\n   copy_body_data id;\n   bool throws;\n+  auto_vec<struct cilk_decls> vd;\n+  unsigned int j;\n+  struct cilk_decls * c;\n \n   DECL_STATIC_CHAIN (outer_fn) = 1;\n \n@@ -508,11 +529,13 @@ cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n \n   insert_decl_map (&id, wd->block, DECL_INITIAL (inner_fn));\n \n+  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n+  vd.qsort (compare_decls);\n   /* We don't want the private variables any more.  */\n-  if (nested)\n-    wd->decl_map->traverse<copy_body_data *, for_local_cb> (&id);\n-  else\n-    wd->decl_map->traverse<copy_body_data *, wrapper_local_cb> (&id);\n+  FOR_EACH_VEC_ELT (vd, j, c)\n+   if (*(c->val) == error_mark_node)\n+     *(c->val) = nested ? copy_decl_no_change (c->key, &id)\n+\t\t\t: copy_decl_for_cilk (c->key, &id);\n \n   walk_tree (stmt_p, copy_tree_body_r, (void *) &id, NULL);\n \n@@ -617,7 +640,7 @@ free_wd (struct wrapper_data *wd)\n */\n \n bool\n-declare_one_free_variable (tree const &var0, tree *map0, wrapper_data &)\n+declare_one_free_variable (tree var0, tree *map0)\n {\n   const_tree var = var0;\n   tree map = *map0;\n@@ -690,6 +713,9 @@ create_cilk_wrapper (tree exp, tree *args_out)\n {\n   struct wrapper_data wd;\n   tree fndecl;\n+  unsigned int j;\n+  struct cilk_decls * c;\n+  auto_vec<struct cilk_decls> vd;\n \n   init_wd (&wd, CILK_BLOCK_SPAWN);\n \n@@ -710,7 +736,11 @@ create_cilk_wrapper (tree exp, tree *args_out)\n     }\n   else\n     extract_free_variables (exp, &wd, ADD_READ);\n-  wd.decl_map->traverse<wrapper_data &, declare_one_free_variable> (wd);\n+  wd.decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n+  vd.qsort (compare_decls);\n+  FOR_EACH_VEC_ELT (vd, j, c)\n+   declare_one_free_variable (c->key, c->val);\n+\n   wd.block = TREE_BLOCK (exp);\n   if (!wd.block)\n     wd.block = DECL_INITIAL (current_function_decl);"}]}