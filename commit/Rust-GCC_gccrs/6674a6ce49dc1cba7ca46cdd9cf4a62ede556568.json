{"sha": "6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3NGE2Y2U0OWRjMWNiYTdjYTQ2Y2RkOWNmNGE2MmVkZTU1NjU2OA==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "Kenneth.Zadeck@NaturalBridge.com", "date": "2004-09-13T22:51:01Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2004-09-13T22:51:01Z"}, "message": "New code to analyze file level static variables and to determine if...\n\nNew code to analyze file level static variables and to determine if\nthey escape and also code to use this information to prune clobber\nlists.\n\nFrom-SVN: r87455", "tree": {"sha": "69297f66b1458959fbc86188df989df620a72c6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69297f66b1458959fbc86188df989df620a72c6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/comments", "author": null, "committer": null, "parents": [{"sha": "c56e3d82fc9090d1580ca8dc02a6add848629d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56e3d82fc9090d1580ca8dc02a6add848629d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56e3d82fc9090d1580ca8dc02a6add848629d0c"}], "stats": {"total": 1338, "additions": 1289, "deletions": 49}, "files": [{"sha": "5609638157f9bb36890dac7f859024c9c0ef35ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -1,3 +1,40 @@\n+2004-09-26  Kenneth Zadeck  <Kenneth.Zadeck@NaturalBridge.com>\n+\n+\n+\t* tree-ssa-operands.c (get_call_expr_operands): Added parm to\n+\tadd_call_clobber_ops and add_call_read_ops.\n+\t(add_call_clobber_ops, add_call_read_ops): Added code to reduce\n+\tthe number of vdefs and vuses inserted based on analysis of global\n+\tvariables across calls.  * tree-dfa.c (find_referenced_vars):\n+\tNeeded to reset static var maps before each function is compiled.\n+\t* cgraphunit.c:\n+\t(static_vars_to_consider_by_tree,static_vars_to_consider_by_uid,\n+\tstatic_vars_info,functions_to_static_vars_info,module_statics_escape,\n+\tall_module_statics,searchc_env,dfs_info): New fields to support\n+\tanalysis of static global variables.\n+\t(print_order, convert_UIDs_in_bitmap, new_static_vars_info,\n+\tcgraph_reset_static_var_maps, get_global_static_vars_info,\n+\tget_global_statics_not_read, get_global_statics_not_written,\n+\tsearchc, cgraph_reduced_inorder, has_proper_scope_for_analysis,\n+\tcheck_rhs_var, check_lhs_var, get_asm_expr_operands,\n+\tprocess_call_for_static_vars, scan_for_static_refs,\n+\tcgraph_characterize_statics_local, cgraph_get_static_name_by_uid,\n+\tclear_static_vars_maps, cgraph_propagate_bits,\n+\tcgraph_characterize_statics): New. Functions to support analysis\n+\tof static global variables.\n+\t(cgraph_mark_local_and_external_functions): Renamed from:\n+\t(cgraph_mark_local_functions)\n+\t(cgraph_expand_all_functions): Remove call to\n+\tcgraph_mark_local_and_external_functions.\n+\t(cgraph_optimize): Added driver to analyze static variables whose\n+\tscope is within the compilation unit.  * cgraph.h (struct\n+\tcgraph_local_info, GTY): Added statics_read, statics_written,\n+\tlocal, calls_read_all, calls_write_all, for_functions_valid.\n+\t(struct cgraph_node): Added next_cycle.  * cgraph.c\n+\t(dump_cgraph_node): Added print routines for new fields.  *\n+\tmakefile.in: macroized cgraph.h, added cgraphunit.c to the ggc\n+\tlist.\n+\n 2004-09-13  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-decl.c (grokdeclarator): Correct comments about where storage"}, {"sha": "e30d8132b14736949b0239d75902a8e4b20609e9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -702,6 +702,7 @@ INTEGRATE_H = integrate.h varray.h\n LOOP_H = loop.h varray.h bitmap.h\n CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)\n CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H)\n+CGRAPH_H = cgraph.h bitmap.h tree.h $(HASHTAB_H)\n DF_H = df.h bitmap.h sbitmap.h $(BASIC_BLOCK_H)\n DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h\n@@ -722,7 +723,7 @@ TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)\n TREE_GIMPLE_H = tree-gimple.h tree-iterator.h\n TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\tbitmap.h $(BASIC_BLOCK_H) hard-reg-set.h $(TREE_GIMPLE_H) \\\n-\t\t$(HASHTAB_H)\n+\t\t$(HASHTAB_H) $(CGRAPH_H)\n TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H)\n PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)\n@@ -1370,7 +1371,7 @@ c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) function.h output.h \\\n     $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \\\n-    opts.h $(C_PRAGMA_H) gt-c-decl.h cgraph.h $(HASHTAB_H) libfuncs.h except.h \\\n+    opts.h $(C_PRAGMA_H) gt-c-decl.h $(CGRAPH_H) $(HASHTAB_H) libfuncs.h except.h \\\n     $(LANGHOOKS_DEF_H) $(TREE_DUMP_H)\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) $(FLAGS_H) intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H) \\\n@@ -1390,7 +1391,7 @@ c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) $(EXPR_H) \\\n     $(FLAGS_H) toplev.h tree-inline.h $(DIAGNOSTIC_H) $(VARRAY_H) \\\n-    langhooks.h $(GGC_H) $(TARGET_H) cgraph.h $(C_PRETTY_PRINT_H) c-objc-common.h\n+    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(C_PRETTY_PRINT_H) c-objc-common.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(FLAGS_H) toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1551,7 +1552,7 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \tvarray.h $(HASHTAB_H) $(SPLAY_TREE_H) bitmap.h $(TREE_H) $(RTL_H) \\\n \tfunction.h insn-config.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n \tcselib.h insn-addr.h $(OPTABS_H) libfuncs.h debug.h $(GGC_H) \\\n-\tcgraph.h $(TREE_FLOW_H) reload.h $(CPP_ID_DATA_H)\n+\t$(CGRAPH_H) $(TREE_FLOW_H) reload.h $(CPP_ID_DATA_H)\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n@@ -1586,7 +1587,7 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h insn-config.h \\\n    $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n-   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h function.h \\\n+   langhooks.h $(C_COMMON_H) tree-inline.h $(CGRAPH_H) intl.h function.h \\\n    $(TREE_GIMPLE_H)\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h real.h\n@@ -1670,7 +1671,7 @@ tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_DUMP_H) diagnostic.h except.h tree-pass.h $(FLAGS_H) langhooks.h\n tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(TM_P_H) function.h tree-dump.h tree-inline.h tree-iterator.h \\\n-   tree-gimple.h cgraph.h $(EXPR_H) langhooks.h $(GGC_H) gt-tree-nested.h\n+   tree-gimple.h $(CGRAPH_H) $(EXPR_H) langhooks.h $(GGC_H) gt-tree-nested.h\n tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) flags.h $(TIMEVAR_H) varray.h $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n    cfgloop.h $(RTL_H) c-common.h tree-chrec.h tree-data-ref.h \\\n@@ -1681,9 +1682,9 @@ tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h tree-inline.h $(HASHTAB_H) $(FLAGS_H) function.h $(TIMEVAR_H) \\\n    convert.h $(TM_H) coretypes.h langhooks.h \\\n-   $(TREE_DUMP_H) tree-pass.h params.h\n+   $(TREE_DUMP_H) tree-pass.h params.h $(CGRAPH_H)\n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(GGC_H) diagnostic.h errors.h \\\n+   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(GGC_H) $(CGRAPH_H) diagnostic.h errors.h \\\n    tree-inline.h $(FLAGS_H) function.h $(TM_H) $(TIMEVAR_H) tree-pass.h\n tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_H) $(FLAGS_H) function.h except.h langhooks.h \\\n@@ -1725,15 +1726,15 @@ tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n    $(GGC_H) output.h diagnostic.h errors.h $(FLAGS_H) \\\n    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h function.h \\\n-   langhooks.h $(FLAGS_H) cgraph.h tree-inline.h tree-mudflap.h $(GGC_H) \\\n-   cgraph.h tree-pass.h\n+   langhooks.h $(FLAGS_H) $(CGRAPH_H) tree-inline.h tree-mudflap.h $(GGC_H) \\\n+   $(CGRAPH_H) tree-pass.h\n c-gimplify.o : c-gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n    $(C_TREE_H) $(C_COMMON_H) diagnostic.h $(TREE_GIMPLE_H) varray.h $(FLAGS_H) \\\n    langhooks.h toplev.h rtl.h $(TREE_FLOW_H) langhooks-def.h \\\n-   $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) cgraph.h\n+   $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H)\n gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n    diagnostic.h $(TREE_GIMPLE_H) tree-inline.h varray.h langhooks.h \\\n-   langhooks-def.h $(TREE_FLOW_H) cgraph.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   langhooks-def.h $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) output.h $(GGC_H) \\\n    gt-gimplify.h\n gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n@@ -1766,7 +1767,7 @@ tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n    $(C_TREE_H) $(C_COMMON_H) $(TREE_GIMPLE_H) diagnostic.h $(HASHTAB_H) \\\n    output.h varray.h langhooks.h tree-mudflap.h $(TM_H) coretypes.h \\\n-   $(TREE_DUMP_H) tree-pass.h cgraph.h\n+   $(TREE_DUMP_H) tree-pass.h $(CGRAPH_H)\n tree-nomudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n    $(C_TREE_H) $(C_COMMON_H) $(TREE_GIMPLE_H) diagnostic.h $(HASHTAB_H) \\\n    output.h varray.h langhooks.h tree-mudflap.h $(TM_H) coretypes.h\n@@ -1793,7 +1794,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) versio\n    graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \\\n-   hosthooks.h $(LANGHOOKS_DEF_H) cgraph.h $(COVERAGE_H) alloc-pool.h\n+   hosthooks.h $(LANGHOOKS_DEF_H) $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DTARGET_NAME=\\\"$(target_noncanonical)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)\n@@ -1805,7 +1806,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \\\n-   hosthooks.h $(LANGHOOKS_DEF_H) cgraph.h $(COVERAGE_H) alloc-pool.h \\\n+   hosthooks.h $(LANGHOOKS_DEF_H) $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h \\\n    tree-pass.h tree-dump.h\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n@@ -1842,7 +1843,7 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) except.h function.h $(EXPR_H) libfuncs.h $(INTEGRATE_H) \\\n    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n    dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H) \\\n-   gt-except.h cgraph.h\n+   gt-except.h $(CGRAPH_H)\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) \\\n    function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h $(INSN_ATTR_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n@@ -1858,7 +1859,7 @@ builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(T\n    tree-mudflap.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) \\\n    $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \\\n-   libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) cgraph.h except.h\n+   libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) $(CGRAPH_H) except.h\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) real.h \\\n    toplev.h $(TM_P_H) langhooks.h\n@@ -1882,7 +1883,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(RTL_H) dwarf2.h debug.h $(FLAGS_H) insn-config.h reload.h \\\n    output.h $(DIAGNOSTIC_H) real.h hard-reg-set.h $(REGS_H) $(EXPR_H) \\\n    libfuncs.h toplev.h dwarf2out.h varray.h $(GGC_H) except.h dwarf2asm.h \\\n-   $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) cgraph.h \\\n+   $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) \\\n    $(MD5_H) input.h\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(FLAGS_H) $(RTL_H) \\\n    $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) gt-dwarf2asm.h\n@@ -1908,11 +1909,11 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RT\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H) $(TREE_H) $(TARGET_H)\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   langhooks.h toplev.h $(FLAGS_H) $(GGC_H)  $(TARGET_H) cgraph.h gt-cgraph.h \\\n+   langhooks.h toplev.h $(FLAGS_H) $(GGC_H)  $(TARGET_H) $(CGRAPH_H) gt-cgraph.h \\\n    output.h intl.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H)  $(TARGET_H) cgraph.h intl.h \\\n-   function.h\n+   langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H)  $(TARGET_H) $(CGRAPH_H) intl.h \\\n+   function.h $(TREE_GIMPLE_H) $(TREE_FLOW_H)\n coverage.o : coverage.c gcov-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \\\n    toplev.h $(GGC_H) $(TARGET_H) langhooks.h $(COVERAGE_H) libfuncs.h \\\n@@ -2095,7 +2096,7 @@ reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) condition\n alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h $(ALIAS_H) $(EMIT_RTL_H) \\\n    $(GGC_H) function.h cselib.h $(TREE_H) $(TM_P_H) langhooks.h $(TARGET_H) \\\n-   gt-alias.h $(TIMEVAR_H) cgraph.h\n+   gt-alias.h $(TIMEVAR_H) $(CGRAPH_H)\n regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) function.h \\\n    $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n@@ -2398,6 +2399,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h $(srcdir)/reload.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n+  $(srcdir)/cgraphunit.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/dojump.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\"}, {"sha": "f8f0b7cd52a2af634c72dc6c9fda7832bfb0c8c3", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -474,6 +474,12 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \n   if (node->local.local)\n     fprintf (f, \" local\");\n+  if (node->local.external)\n+    fprintf (f, \" external\");\n+  if (node->local.calls_read_all)\n+    fprintf (f, \" calls_read_all\");\n+  if (node->local.calls_write_all)\n+    fprintf (f, \" calls_write_all\");\n   if (node->local.disregard_inline_limits)\n     fprintf (f, \" always_inline\");\n   else if (node->local.inlinable)"}, {"sha": "0af4447df35a3f532dd49087b6c8b240f1f230b8", "filename": "gcc/cgraph.h", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -22,6 +22,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n #include \"hashtab.h\"\n+#include \"bitmap.h\"\n+#include \"tree.h\"\n \n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n@@ -30,19 +32,37 @@ struct cgraph_local_info GTY(())\n {\n   /* Size of the function before inlining.  */\n   int self_insns;\n+\n   /* Set when function function is visible in current compilation unit only\n      and it's address is never taken.  */\n   bool local;\n+\n+  /* Set when function is defined in another compilation unit.  */\n+  bool external;\n+\n+  /* Set when this function calls a function external of the\n+     compilation unit.  In general, such calls are modeled as reading\n+     and writing all variables (both bits on) but sometime there are\n+     attributes on the called function so we can do better.  */\n+  bool calls_read_all;\n+  bool calls_write_all;\n+\n   /* Set once it has been finalized so we consider it to be output.  */\n   bool finalized;\n \n   /* False when there something makes inlining impossible (such as va_arg).  */\n   bool inlinable;\n+\n   /* True when function should be inlined independently on it's size.  */\n   bool disregard_inline_limits;\n+\n   /* True when the function has been originally extern inline, but it is\n      redefined now.  */\n   bool redefined_extern_inline;\n+\n+  /* True if statics_read_for_function and\n+     statics_written_for_function contain valid data.  */\n+  bool for_functions_valid;\n };\n \n /* Information about the function that needs to be computed globally\n@@ -70,6 +90,69 @@ struct cgraph_rtl_info GTY(())\n    bool pure_function;\n };\n \n+/* FIXME -- PROFILE-RESTRUCTURE: When the next round of the profiling\n+   code gets merged in, it will contain a restructing where ssa form\n+   is built for every function within the compilation unit before the\n+   rest of the compilation continues.  When this reorgination is done,\n+   it will no longer be necessary to have the _decl_uid versions of\n+   local_static_vars_info and global_static_vars_info structures.\n+   Having both structures is now requirred because the _ann_uid values\n+   for static variables are reset as each function is compiled.\n+   Currently, the analysis is done using the _decl_uid versions and\n+   converted to the _var_ann versions on demand.\n+\n+   Also, the var_anns_valid fields within these structures can also go\n+   away.\n+*/\n+\n+/* The static variables defined within the compilation unit that are\n+   loaded or stored directly by function that owns this structure.  */ \n+\n+struct local_static_vars_info_d GTY(())\n+{\n+  bitmap statics_read_by_decl_uid;\n+  bitmap statics_written_by_decl_uid;\n+};\n+\n+struct global_static_vars_info_d GTY(())\n+{\n+  bitmap statics_read_by_decl_uid;\n+  bitmap statics_written_by_decl_uid;\n+  bitmap statics_read_by_ann_uid;\n+  bitmap statics_written_by_ann_uid;\n+  bitmap statics_not_read_by_decl_uid;\n+  bitmap statics_not_written_by_decl_uid;\n+  bitmap statics_not_read_by_ann_uid;\n+  bitmap statics_not_written_by_ann_uid;\n+\n+  /* var_anns_valid is reset at the start of compilation for each\n+     function because the indexing that the \"_var_anns\" is based\n+     on is invalidated between function compilations.  This allows for\n+     lazy creation of the \"_var_ann\" variables.  */\n+  bool var_anns_valid;\n+};\n+\n+/* Statics that are read and written by some set of functions. The\n+   local ones are based on the loads and stores local to the function.\n+   The global ones are based on the local info as well as the\n+   transitive closure of the functions that are called.  The\n+   structures are separated to allow the global structures to be\n+   shared between several functions since every function within a\n+   strongly connected component will have the same information.  This\n+   sharing saves both time and space in the computation of the vectors\n+   as well as their translation from decl_uid form to ann_uid\n+   form.  */ \n+\n+typedef struct local_static_vars_info_d *local_static_vars_info_t;\n+typedef struct global_static_vars_info_d *global_static_vars_info_t;\n+\n+struct static_vars_info_d GTY(()) \n+{\n+  local_static_vars_info_t local;\n+  global_static_vars_info_t global;\n+};\n+\n+typedef struct static_vars_info_d *static_vars_info_t;\n \n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n@@ -91,11 +174,18 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   struct cgraph_node *next_needed;\n   /* Pointer to the next clone.  */\n   struct cgraph_node *next_clone;\n+  /* Pointer to next node in a recursive call graph cycle; */\n+  struct cgraph_node *next_cycle;\n   PTR GTY ((skip)) aux;\n \n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n+  \n+  /* Pointer to the structure that contains the sets of global\n+     variables modified by function calls.  */\n+  static_vars_info_t static_vars_info;\n+\n   /* Unique id of the node.  */\n   int uid;\n   /* Set when function must be output - it is externally visible\n@@ -192,6 +282,9 @@ void verify_cgraph_node (struct cgraph_node *);\n void cgraph_mark_inline_edge (struct cgraph_edge *e);\n void cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate);\n void cgraph_build_static_cdtor (char which, tree body, int priority);\n+void cgraph_reset_static_var_maps (void);\n+bitmap get_global_statics_not_read (tree fn);\n+bitmap get_global_statics_not_written(tree fn);\n void init_cgraph (void);\n \n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "73f5d6c048e5b7d1d3168793cbb20a9e9ba5786e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1065, "deletions": 16, "changes": 1081, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -164,12 +164,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \tinto account, while cgraph_decide_inlining_incrementally considers\n \tonly one function at a time and is used in non-unit-at-a-time mode.  */\n \n+\n+/* Additionally this file gathers information about how local statics\n+   are used.  This is done in cgraph_charactize_statics.  After the\n+   call graph has been built, each function is analyzed to determine\n+   which local static variables are either read or written or have\n+   their address taken.  Any local static that has its address taken\n+   is removed from consideration.  Once the local read and writes\n+   are determined, a transitive closure of this information is\n+   performed over the call graph to determine the worst case set of\n+   side effects of each call.  In a later part of the compiler, these\n+   local and global sets are examined to make the call clobbering less\n+   traumatic both with respect to aliasing and to code generation.  */\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"tree-flow.h\"\n #include \"tree-inline.h\"\n #include \"langhooks.h\"\n #include \"hashtab.h\"\n@@ -186,14 +200,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-common.h\"\n #include \"intl.h\"\n #include \"function.h\"\n+#include \"tree-gimple.h\"\n \n #define INSNS_PER_CALL 10\n \n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static tree record_call_1 (tree *, int *, void *);\n-static void cgraph_mark_local_functions (void);\n+static void cgraph_mark_local_and_external_functions (void);\n static bool cgraph_default_inline_p (struct cgraph_node *n);\n static void cgraph_analyze_function (struct cgraph_node *node);\n static void cgraph_decide_inlining_incrementally (struct cgraph_node *);\n@@ -212,6 +227,34 @@ static htab_t visited_nodes;\n \n static FILE *cgraph_dump_file;\n \n+/* These splay trees contain all of the static variables that are\n+   being considered by the compilation level alias analysis.  For\n+   module_at_a_time compilation, this is the set of static but not\n+   public variables.  Any variables that either have their address\n+   taken or participate in otherwise unsavory operations are deleted\n+   from this list.  */\n+static GTY((param1_is(tree), param2_is(tree)))\n+     splay_tree static_vars_to_consider_by_tree;\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: change comment from DECL_UID to var-ann. */    \n+/* same as above but indexed by DECL_UID */\n+static GTY((param1_is(int), param2_is(tree)))\n+     splay_tree static_vars_to_consider_by_uid;\n+\n+/* This bitmap is used to knock out the module static variables whose\n+   addresses have been taken and passed around.  This is indexed by\n+   uid.  */\n+static bitmap module_statics_escape;\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: change comment from DECL_UID to var-ann. */    \n+/* A bit is set for every module static we are considering and is\n+   indexed by DECL_UID.  This is ored into the local info when asm\n+   code is found that clobbers all memory. */\n+static GTY(()) bitmap all_module_statics;\n+\n+/* Holds the value of \"memory\".  */\n+static tree memory_identifier;\n+\n /* Determine if function DECL is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n    configury, or (if not doing unit-at-a-time) to something we havn't\n@@ -277,6 +320,189 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n+/* Debugging function for postorder and inorder code. NOTE is a string\n+   that is printed before the nodes are printed.  ORDER is an array of\n+   cgraph_nodes that has COUNT useful nodes in it.  */\n+\n+static void \n+print_order (const char * note, struct cgraph_node** order, int count) \n+{\n+  int i;\n+  fprintf (cgraph_dump_file, \"\\n\\n ordered call graph: %s\\n\", note);\n+  \n+  for (i = count - 1; i >= 0; i--)\n+    {\n+      struct cgraph_edge *edge;\n+\n+      fprintf (cgraph_dump_file, \"\\n  %s<-(\", cgraph_node_name (order[i]));\n+\n+      for (edge = order[i]->callers; edge; edge = edge->next_caller)\n+\tfprintf (cgraph_dump_file, \" %s\", cgraph_node_name (edge->caller));\n+      fprintf (cgraph_dump_file, \")\");\n+    }\n+  fprintf (cgraph_dump_file, \"\\n\");\n+}\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: Remove this function, it becomes a nop. */    \n+/* Convert IN_DECL bitmap which is indexed by DECL_UID to IN_ANN, a\n+   bitmap indexed by var_ann (VAR_DECL)->uid.  */\n+\n+static void \n+convert_UIDs_in_bitmap (bitmap in_ann, bitmap in_decl) \n+{\n+  int index;\n+  EXECUTE_IF_SET_IN_BITMAP(in_decl, 0, index,\n+      {\n+\tsplay_tree_node n = \n+\t  splay_tree_lookup (static_vars_to_consider_by_uid, index);\n+\tif (n != NULL) \n+\t  {\n+\t    tree t = (tree)n->value;\n+\t    var_ann_t va = var_ann (t);\n+\t    if (va) \n+\t      bitmap_set_bit(in_ann, va->uid);\n+\t  }\n+      });\n+}\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: Delete all stmts initing *_decl_uid\n+   variables.  Add code to create a var_ann for tree node within the\n+   cgraph_node and have it point to the newly created\n+   static_vars_info.  */\n+/* Create a new static_vars_info structure and place it into\n+   cgraph_node, NODE.  INIT_GLOBAL causes the global part of the\n+   structure to be initialized.  */\n+static static_vars_info_t\n+new_static_vars_info(struct cgraph_node* node, \n+\t\t     bool init_global)\n+{\n+  static_vars_info_t info = ggc_calloc (1, sizeof (struct static_vars_info_d));\n+  local_static_vars_info_t l\n+    = ggc_calloc (1, sizeof (struct local_static_vars_info_d));\n+\n+  /* Add the info to the tree's annotation.  */\n+  var_ann_t var_ann = get_var_ann(node->decl);\n+  node->static_vars_info = info;\n+  var_ann->static_vars_info = info;\n+\n+  info->local = l;\n+  l->statics_read_by_decl_uid = BITMAP_GGC_ALLOC ();\n+  l->statics_written_by_decl_uid = BITMAP_GGC_ALLOC ();\n+\n+  if (init_global)\n+    {\n+      global_static_vars_info_t g\n+\t= ggc_calloc (1, sizeof (struct global_static_vars_info_d));\n+      info->global = g;\n+      g->statics_read_by_decl_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_written_by_decl_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_read_by_ann_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_written_by_ann_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_not_read_by_decl_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_not_written_by_decl_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_not_read_by_ann_uid = BITMAP_GGC_ALLOC ();\n+      g->statics_not_written_by_ann_uid = BITMAP_GGC_ALLOC ();\n+    }\n+  return info;\n+}\n+\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: Remove this function, it becomes a\n+   nop. */    \n+/* The bitmaps used to represent the static global variables are\n+   indexed by DECL_UID however, this is not used inside of functions\n+   to index the ssa variables.  The denser var_ann (VAR_DECL)->uid is\n+   used there.  This function is called from\n+   tree_dfa:find_referenced_vars after the denser representation is\n+   built.  This function invalidates any cached indexes.  */ \n+\n+void\n+cgraph_reset_static_var_maps (void) \n+{\n+  struct cgraph_node *node;\n+  \n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      static_vars_info_t info = node->static_vars_info;\n+      if (info) \n+\t{\n+\t  global_static_vars_info_t g = info->global;\n+\t  if (g->var_anns_valid) \n+\t    {\n+\t      bitmap_clear (g->statics_read_by_ann_uid);\n+\t      bitmap_clear (g->statics_written_by_ann_uid);\n+\t      bitmap_clear (g->statics_not_read_by_ann_uid);\n+\t      bitmap_clear (g->statics_not_written_by_ann_uid);\n+\t      g->var_anns_valid = false;\n+\t    }\n+\t}\n+      else \n+\t/* Handle the case where a cgraph node has been inserted\n+\t   after the analysis.  We know nothing.  */\n+\tnew_static_vars_info(node, true);\n+    }\n+}\n+\n+/* Get the global static_vars_info structure for the function FN and\n+   make sure the ann_uid's bitmaps are properly converted.  */\n+ \n+static global_static_vars_info_t\n+get_global_static_vars_info (tree fn) \n+{\n+  global_static_vars_info_t g;\n+\n+  /* Was not compiled -O2 or higher.  */ \n+  static_vars_info_t info = get_var_ann(fn)->static_vars_info;\n+  if (!info)\n+    return NULL;\n+\n+  g = info->global;\n+  if (!g->var_anns_valid) \n+    {\n+      convert_UIDs_in_bitmap (g->statics_read_by_ann_uid, \n+\t\t\t      g->statics_read_by_decl_uid);\n+      convert_UIDs_in_bitmap (g->statics_written_by_ann_uid, \n+\t\t\t      g->statics_written_by_decl_uid);\n+      convert_UIDs_in_bitmap (g->statics_not_read_by_ann_uid, \n+\t\t\t      g->statics_not_read_by_decl_uid);\n+      convert_UIDs_in_bitmap (g->statics_not_written_by_ann_uid, \n+\t\t\t      g->statics_not_written_by_decl_uid);\n+      g->var_anns_valid = true;\n+    }\n+  return g;\n+}\n+\n+/* Return a bitmap indexed by var_ann (VAR_DECL)->uid for the static\n+   variables that are not read during the execution of the function\n+   FN.  Returns NULL if no data is available, such as it was not\n+   compiled with -O2 or higher.  */\n+\n+bitmap \n+get_global_statics_not_read (tree fn) \n+{\n+  global_static_vars_info_t g = get_global_static_vars_info (fn);\n+  if (g) \n+    return g->statics_not_read_by_ann_uid;\n+  else\n+    return NULL;\n+}\n+\n+/* Return a bitmap indexed by var_ann (VAR_DECL)->uid for the static\n+   variables that are not written during the execution of the function\n+   FN.  Note that variables written may or may not be read during the\n+   function call.  Returns NULL if no data is available, such as it\n+   was not compiled with -O2 or higher.  */\n+\n+bitmap \n+get_global_statics_not_written (tree fn) \n+{\n+  global_static_vars_info_t g = get_global_static_vars_info (fn);\n+  if (g) \n+    return g->statics_not_written_by_ann_uid;\n+  else\n+    return NULL;\n+}\n+\n /* When not doing unit-at-a-time, output all functions enqueued.\n    Return true when such a functions were found.  */\n \n@@ -892,6 +1118,150 @@ cgraph_postorder (struct cgraph_node **order)\n   return order_pos;\n }\n \n+struct searchc_env {\n+  struct cgraph_node **stack;\n+  int stack_size;\n+  struct cgraph_node **result;\n+  int order_pos;\n+  splay_tree nodes_marked_new;\n+  bool reduce;\n+  int count;\n+};\n+\n+struct dfs_info {\n+  int dfn_number;\n+  int low_link;\n+  bool new;\n+  bool on_stack;\n+};\n+\n+/* This is an implementation of Tarjan's strongly connected region\n+   finder as reprinted in Aho Hopcraft and Ullman's The Design and\n+   Analysis of Computer Programs (1975) pages 192-193.  This version\n+   has been customized for cgraph_nodes.  The env parameter is because\n+   it is recursive and there are no nested functions here.  This\n+   function should only be called from itself or\n+   cgraph_reduced_inorder.  ENV is a stack env and would be\n+   unnecessary if C had nested functions.  V is the node to start\n+   searching from.  */\n+\n+static void\n+searchc (struct searchc_env* env, struct cgraph_node *v) \n+{\n+  struct cgraph_edge *edge;\n+  struct dfs_info *v_info = v->aux;\n+  \n+  /* mark node as old */\n+  v_info->new = false;\n+  splay_tree_remove (env->nodes_marked_new, v->uid);\n+  \n+  v_info->dfn_number = env->count;\n+  v_info->low_link = env->count;\n+  env->count++;\n+  env->stack[(env->stack_size)++] = v;\n+  v_info->on_stack = true;\n+  \n+  for (edge = v->callers; edge; edge = edge->next_caller)\n+    {\n+      struct dfs_info * w_info;\n+      struct cgraph_node *w = edge->caller;\n+      /* skip the nodes that we are supposed to ignore */\n+      if (w->aux) \n+\t{\n+\t  w_info = w->aux;\n+\t  if (w_info->new) \n+\t    {\n+\t      searchc (env, w);\n+\t      v_info->low_link =\n+\t\t(v_info->low_link < w_info->low_link) ?\n+\t\tv_info->low_link : w_info->low_link;\n+\t    } \n+\t  else \n+\t    if ((w_info->dfn_number < v_info->dfn_number) \n+\t\t&& (w_info->on_stack)) \n+\t      v_info->low_link =\n+\t\t(w_info->dfn_number < v_info->low_link) ?\n+\t\tw_info->dfn_number : v_info->low_link;\n+\t}\n+    }\n+\n+\n+  if (v_info->low_link == v_info->dfn_number) \n+    {\n+      struct cgraph_node *last = NULL;\n+      struct cgraph_node *x;\n+      struct dfs_info *x_info;\n+      do {\n+\tx = env->stack[--(env->stack_size)];\n+\tx_info = x->aux;\n+\tx_info->on_stack = false;\n+\t\n+\tif (env->reduce) \n+\t  {\n+\t    x->next_cycle = last;\n+\t    last = x;\n+\t  } \n+\telse \n+\t  env->result[env->order_pos++] = x;\n+      } \n+      while (v != x);\n+      if (env->reduce) \n+\tenv->result[env->order_pos++] = v;\n+    }\n+}\n+\n+/* Topsort the call graph by caller relation.  Put the result in ORDER.\n+\n+   The REDUCE flag is true if you want the cycles reduced to single\n+   nodes.  Only consider nodes that have the output bit set. */\n+\n+static int\n+cgraph_reduced_inorder (struct cgraph_node **order, bool reduce)\n+{\n+  struct cgraph_node *node;\n+  struct searchc_env env;\n+  splay_tree_node result;\n+  env.stack = xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+  env.stack_size = 0;\n+  env.result = order;\n+  env.order_pos = 0;\n+  env.nodes_marked_new = splay_tree_new (splay_tree_compare_ints, 0, 0);\n+  env.count = 1;\n+  env.reduce = reduce;\n+  \n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->output) \n+      {\n+\tstruct dfs_info *info = xcalloc (1, sizeof (struct dfs_info));\n+\tinfo->new = true;\n+\tinfo->on_stack = false;\n+\tnode->aux = info;\n+\tnode->next_cycle = NULL;\n+\t\n+\tsplay_tree_insert (env.nodes_marked_new,\n+\t\t\t   node->uid, (splay_tree_value)node);\n+      } \n+    else \n+      node->aux = NULL;\n+  result = splay_tree_min (env.nodes_marked_new);\n+  while (result)\n+    {\n+      node = (struct cgraph_node *)result->value;\n+      searchc (&env, node);\n+      result = splay_tree_min (env.nodes_marked_new);\n+    }\n+  splay_tree_delete (env.nodes_marked_new);\n+  free (env.stack);\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->aux)\n+      {\n+\tfree (node->aux);\n+\tnode->aux = NULL;\n+      }\n+  return env.order_pos;\n+}\n+\n /* Perform reachability analysis and reclaim all unreachable nodes.\n    This function also remove unneeded bodies of extern inline functions\n    and thus needs to be done only after inlining decisions has been made.  */\n@@ -1640,6 +2010,664 @@ cgraph_inline_p (struct cgraph_edge *e, const char **reason)\n   return !e->inline_failed;\n }\n \n+/* FIXME this needs to be enhanced.  If we are compiling a single\n+   module this returns true if the variable is a module level static,\n+   but if we are doing whole program compilation, this could return\n+   true if TREE_PUBLIC is true. */\n+/* Return true if the variable T is the right kind of static variable to\n+   perform compilation unit scope escape analysis.  */\n+\n+static inline\n+bool has_proper_scope_for_analysis (tree t)\n+{\n+  return (TREE_STATIC(t)) && !(TREE_PUBLIC(t)) && !(TREE_THIS_VOLATILE(t));\n+}\n+\n+/* Check to see if T is a read or address of operation on a static var\n+   we are interrested in analyzing.  FN is passed in to get access to\n+   its bit vectors.  */\n+\n+static void\n+check_rhs_var (struct cgraph_node *fn, tree t)\n+{\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    {\n+      tree x = TREE_OPERAND (t, 0);\n+      if ((TREE_CODE (x) == VAR_DECL) && has_proper_scope_for_analysis (x))\n+\t{\n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \"\\nadding address:%s\",\n+\t\t     lang_hooks.decl_printable_name (x, 2));\n+\t  \n+\t  /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n+\t     DECL_UID to get the uid from the var_ann field. */    \n+\t  bitmap_set_bit (module_statics_escape, DECL_UID (x));\n+\t}\n+    }\n+  t = get_base_address (t);\n+  if (!t) return;\n+  if ((TREE_CODE (t) == VAR_DECL) && has_proper_scope_for_analysis (t))\n+    {\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"\\nadding rhs:%s\",\n+\t\t lang_hooks.decl_printable_name (t, 2));\n+      /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n+\t DECL_UID to get the uid from the var_ann field. */    \n+      bitmap_set_bit (fn->static_vars_info->local->statics_read_by_decl_uid, \n+\t\t      DECL_UID (t));\n+    }\n+}\n+\n+/* Check to see if T is an assignement to a static var we are\n+   interrested in analyzing.  FN is passed in to get access to its bit\n+   vectors.\n+*/\n+\n+static void\n+check_lhs_var (struct cgraph_node *fn, tree t)\n+{\n+  t = get_base_address (t);\n+  if (!t) return;\n+  if ((TREE_CODE (t) == VAR_DECL) && has_proper_scope_for_analysis (t))\n+    {\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"\\nadding lhs:%s\",\n+\t\t lang_hooks.decl_printable_name (t, 2));\n+      \n+      /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n+\t DECL_UID to get the uid from the var_ann field. */    \n+      bitmap_set_bit (fn->static_vars_info->local->statics_written_by_decl_uid,\n+\t\t      DECL_UID (t));\n+    }\n+}\n+\n+/* This is a scaled down version of get_asm_expr_operands from\n+   tree_ssa_operands.c.  The version there runs much later and assumes\n+   that aliasing information is already available. Here we are just\n+   trying to find if the set of inputs and outputs contain references\n+   or address of operations to local static variables.  FN is the\n+   function being analyzed and STMT is the actual asm statement.  */\n+\n+static void\n+get_asm_expr_operands (struct cgraph_node * fn, tree stmt)\n+{\n+  int noutputs = list_length (ASM_OUTPUTS (stmt));\n+  const char **oconstraints\n+    = (const char **) alloca ((noutputs) * sizeof (const char *));\n+  int i;\n+  tree link;\n+  const char *constraint;\n+  bool allows_mem, allows_reg, is_inout;\n+  \n+  for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n+    {\n+      oconstraints[i] = constraint\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+      parse_output_constraint (&constraint, i, 0, 0,\n+\t\t\t       &allows_mem, &allows_reg, &is_inout);\n+      \n+      /* Memory operands are addressable.  Note that STMT needs the\n+\t address of this operand.  */\n+      if (!allows_reg && allows_mem)\n+\t{\n+\t  check_lhs_var (fn, TREE_VALUE (link));\n+\t}\n+    }\n+\n+  for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n+    {\n+      constraint\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+      parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n+\t\t\t      oconstraints, &allows_mem, &allows_reg);\n+      \n+      /* Memory operands are addressable.  Note that STMT needs the\n+\t address of this operand.  */\n+      if (!allows_reg && allows_mem)\n+\t{\n+\t  check_rhs_var (fn, TREE_VALUE (link));\n+\t}\n+    }\n+  \n+  for (link = ASM_CLOBBERS (stmt); link; link = TREE_CHAIN (link))\n+    if (TREE_VALUE (link) == memory_identifier) \n+      {\n+\t/* Abandon all hope, ye who enter here. */\n+\tlocal_static_vars_info_t l = fn->static_vars_info->local;\n+\tbitmap_a_or_b (l->statics_read_by_decl_uid,\n+\t\t       l->statics_read_by_decl_uid,\n+\t\t       all_module_statics);\n+\tbitmap_a_or_b (l->statics_written_by_decl_uid,\n+\t\t       l->statics_written_by_decl_uid,\n+\t\t       all_module_statics);\n+\t\n+      }\n+}\n+\n+/* Check the parameters of a function call from CALLER to CALL_EXPR to\n+   see if any of them are static vars.  Also check to see if this is\n+   either an indirect call, a call outside the compilation unit, or\n+   has special attributes that effect the clobbers.  The caller\n+   parameter is the tree node for the caller and the second operand is\n+   the tree node for the entire call expression.  */\n+static void\n+process_call_for_static_vars(struct cgraph_node * caller, tree call_expr) \n+{\n+  int flags = call_expr_flags(call_expr);\n+  tree operandList = TREE_OPERAND (call_expr, 1);\n+  tree operand;\n+\n+  for (operand = operandList;\n+       operand != NULL_TREE;\n+       operand = TREE_CHAIN (operand))\n+    {\n+      tree argument = TREE_VALUE (operand);\n+      check_rhs_var (caller, argument);\n+    }\n+\n+  /* Const and pure functions have less clobber effects than other\n+     functions so we process these first.  Otherwise if it is a call\n+     outside the compilation unit or an indirect call we punt.  This\n+     leaves local calls which will be processed by following the call\n+     graph.  */  \n+  if (flags & ECF_CONST) \n+    return;\n+  else if (flags & ECF_PURE) \n+    caller->local.calls_write_all = true;\n+  else \n+    {\n+      tree callee_t = get_callee_fndecl (call_expr);\n+      if (callee_t == NULL) \n+\t{\n+\t  /* Indirect call. */\n+\t  caller->local.calls_read_all = true;\n+\t  caller->local.calls_write_all = true;\n+\t}\n+      else \n+\t{\n+ \t  struct cgraph_node* callee = cgraph_node(callee_t);\n+\n+\t  if (callee->local.external) \n+\t    {\n+\t      caller->local.calls_read_all = true;\n+\t      caller->local.calls_write_all = true;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: Change to walk by explicitly walking\n+   the basic blocks rather than calling walktree.  */    \n+\n+/* Walk tree and record all calls.  Called via walk_tree.  FIXME When\n+   this is moved into the tree-profiling-branch, and is dealing with\n+   low GIMPLE, this routine should be changed to use tree iterators\n+   rather than being a walk_tree callback.  The data is the function\n+   that is being scanned.  */\n+/* TP is the part of the tree currently under the\n+   microscope. WALK_SUBTREES is part of the walk_tree api but is\n+   unused here.  DATA is cgraph_node of the function being walked.  */\n+\n+static tree\n+scan_for_static_refs (tree *tp, \n+\t\t      int *walk_subtrees ATTRIBUTE_UNUSED, \n+\t\t      void *data)\n+{\n+  struct cgraph_node *fn = data;\n+  tree t = *tp;\n+  \n+  switch (TREE_CODE (t))  \n+    {\n+    case MODIFY_EXPR:\n+      {\n+\t/* First look on the lhs and see what variable is stored to */\n+\ttree rhs = TREE_OPERAND (t, 1);\n+\tcheck_lhs_var (fn, TREE_OPERAND (t, 0));\n+\t/* Next check the operands on the rhs to see if they are ok. */\n+\tswitch (TREE_CODE_CLASS (TREE_CODE (rhs))) {\n+\tcase '2':\n+\t  check_rhs_var (fn, TREE_OPERAND (rhs, 0));\n+\t  check_rhs_var (fn, TREE_OPERAND (rhs, 1));\n+\t  break;\n+\tcase '1':\n+\tcase 'r':\n+\t  check_rhs_var (fn, TREE_OPERAND (rhs, 0));\n+\t  break;\n+\tcase 'd':\n+\t  check_rhs_var (fn, rhs);\n+\t  break;\n+\tcase 'e':\n+\t  switch (TREE_CODE (rhs)) {\n+\t  case ADDR_EXPR:\n+\t    check_rhs_var (fn, rhs);\n+\t    break;\n+\t  case CALL_EXPR: \n+\t    process_call_for_static_vars (fn, rhs);\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      }\n+      break;\n+      \n+      \n+    case CALL_EXPR: \n+      process_call_for_static_vars (fn, t);\n+      break;\n+      \n+    case ASM_EXPR:\n+      get_asm_expr_operands (fn, t);\n+      break;\n+      \n+    default:\n+      break;\n+    }\n+  return NULL;\n+}\n+\n+\n+/* This is the main routine for finding the reference patterns for\n+   global variables within a function FN */\n+ static void\n+cgraph_characterize_statics_local (struct cgraph_node *fn)\n+{\n+  tree decl = fn->decl;\n+  static_vars_info_t info = new_static_vars_info(fn, false);\n+  local_static_vars_info_t l = info->local;\n+\n+\n+  /* The nodes we're interested in are never shared, so walk\n+     the tree ignoring duplicates.  */\n+  visited_nodes = htab_create (37, htab_hash_pointer,\n+\t\t\t       htab_eq_pointer, NULL);\n+  \n+  /* FIXME -- PROFILE-RESTRUCTURE: Remove creation of _decl_uid vars.  */\n+  l->statics_read_by_decl_uid = BITMAP_GGC_ALLOC ();\n+  l->statics_written_by_decl_uid = BITMAP_GGC_ALLOC ();\n+  \n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\n local analysis of %s\", cgraph_node_name (fn));\n+  \n+  walk_tree (&DECL_SAVED_TREE (decl), scan_for_static_refs, fn, visited_nodes);\n+  htab_delete (visited_nodes);\n+  visited_nodes = NULL;\n+}\n+\n+/* Lookup the tree node for the static variable that has UID and\n+   conver the name to a string for debugging. */\n+static const char *\n+cgraph_get_static_name_by_uid (int index)\n+{\n+  splay_tree_node stn = splay_tree_lookup (static_vars_to_consider_by_uid, index);\n+  if (stn)\n+    return lang_hooks.decl_printable_name ((tree)(stn->value), 2);\n+  return NULL;\n+}\n+\n+/* Clear out any the static variable with uid INDEX from further\n+   consideration because it escapes (i.e. has had its address\n+   taken).  */\n+static void\n+clear_static_vars_maps (int index)\n+{\n+  splay_tree_node stn = splay_tree_lookup (static_vars_to_consider_by_uid, index);\n+  if (stn) \n+    {\n+      splay_tree_remove (static_vars_to_consider_by_tree, stn->value);\n+      splay_tree_remove (static_vars_to_consider_by_uid, index);\n+    }\n+}\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: Change all *_decl_uid to *_ann_uid.  */\n+\n+/* Or in all of the bits from every callee into X, the caller's, bit\n+   vector.  There are several cases to check to avoid the sparce\n+   bitmap oring.  */\n+static void\n+cgraph_propagate_bits (struct cgraph_node *x)\n+{\n+  static_vars_info_t x_info = x->static_vars_info;\n+  global_static_vars_info_t x_global = x_info->global;\n+\n+  struct cgraph_edge *e;\n+  for (e = x->callees; e; e = e->next_callee) \n+    {\n+      struct cgraph_node *y = e->callee;\n+\n+      /* We are only going to look at edges that point to nodes that\n+\t have their output bit set.  */\n+      if (y->output)\n+\t{\n+\t  static_vars_info_t y_info; \n+\t  global_static_vars_info_t y_global;\n+\t  y_info = y->static_vars_info;\n+\t  y_global = y_info->global;\n+\n+\t  if (x_global->statics_read_by_decl_uid != all_module_statics)\n+\t    {\n+\t      if (y_global->statics_read_by_decl_uid == all_module_statics) \n+\t\tx_global->statics_read_by_decl_uid = all_module_statics;\n+\t      /* Skip bitmaps that are pointer equal to node's bitmap\n+\t\t (no reason to spin within the cycle).  */\n+\t      else if (x_global->statics_read_by_decl_uid != y_global->statics_read_by_decl_uid)\n+\t\tbitmap_a_or_b (x_global->statics_read_by_decl_uid,\n+\t\t\t       x_global->statics_read_by_decl_uid,\n+\t\t\t       y_global->statics_read_by_decl_uid);\n+\t    }\n+\n+\t  if (x_global->statics_written_by_decl_uid != all_module_statics)\n+\t    {\n+\t      if (y_global->statics_written_by_decl_uid == all_module_statics) \n+\t\tx_global->statics_written_by_decl_uid = all_module_statics;\n+\t      /* Skip bitmaps that are pointer equal to node's bitmap\n+\t\t (no reason to spin within the cycle).  */\n+\t      else if (x_global->statics_written_by_decl_uid != y_global->statics_written_by_decl_uid)\n+\t\tbitmap_a_or_b (x_global->statics_written_by_decl_uid,\n+\t\t\t       x_global->statics_written_by_decl_uid,\n+\t\t\t       y_global->statics_written_by_decl_uid);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* FIXME -- PROFILE-RESTRUCTURE: Change all *_decl_uid to *_ann_uid\n+   except where noted below.  */\n+\n+/* The main routine for analyzing global static variable usage. See\n+   comments at top for description.  */\n+\n+static void\n+cgraph_characterize_statics (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_node *w;\n+  struct cgraph_node **order =\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n+  int order_pos = 0;\n+  int i;\n+  \n+  struct cgraph_varpool_node *vnode;\n+  tree global;\n+\n+  /* get rid of the splay trees from the previous compilation unit. */\n+  \n+  static_vars_to_consider_by_tree =\n+    splay_tree_new_ggc (splay_tree_compare_pointers);\n+  static_vars_to_consider_by_uid =\n+    splay_tree_new_ggc (splay_tree_compare_ints);\n+\n+  if (module_statics_escape) \n+    {\n+      bitmap_clear (module_statics_escape);\n+      bitmap_clear (all_module_statics);\n+    } \n+  else\n+    {\n+      module_statics_escape = BITMAP_XMALLOC ();\n+      all_module_statics = BITMAP_GGC_ALLOC ();\n+    }\n+\n+  /* Find all of the global variables that we wish to analyze. */\n+  for (vnode = cgraph_varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+    {\n+      global = vnode->decl;\n+      if ((TREE_CODE (global) == VAR_DECL) &&\n+\t  has_proper_scope_for_analysis (global)) \n+\t{\n+\t  splay_tree_insert (static_vars_to_consider_by_tree,\n+\t\t\t     (splay_tree_key) global, \n+\t\t\t     (splay_tree_value) global);\n+\t  /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n+\t     DECL_UID to get the uid from the var_ann field. */    \n+\t  splay_tree_insert (static_vars_to_consider_by_uid,\n+\t\t\t     DECL_UID (global), (splay_tree_value)global);\n+\t  \n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \"\\nConsidering global:%s\",\n+\t\t     lang_hooks.decl_printable_name (global, 2));\n+\t  /* FIXME -- PROFILE-RESTRUCTURE: Change the call from\n+\t     DECL_UID to get the uid from the var_ann field. */    \n+\t  bitmap_set_bit (all_module_statics, DECL_UID (global));\n+\t}\n+    }\n+\n+  order_pos = cgraph_reduced_inorder (order, false);\n+  if (cgraph_dump_file)\n+    print_order(\"new\", order, order_pos);\n+\n+  for (i = order_pos - 1; i >= 0; i--)\n+    {\n+      node = order[i];\n+\n+      /* Scan each function to determine the variable usage\n+\t patterns.  */ \n+      cgraph_characterize_statics_local (node);\n+    }\n+\n+  /* Prune out the variables that were found to behave badly\n+     (i.e. have there address taken).  */\n+  {\n+    int index;\n+    EXECUTE_IF_SET_IN_BITMAP (module_statics_escape,\n+\t\t\t      0, index, clear_static_vars_maps (index));\n+    bitmap_operation (all_module_statics, all_module_statics,\n+\t\t      module_statics_escape, BITMAP_AND_COMPL);\n+\n+    for (i = order_pos - 1; i >= 0; i--)\n+      {\n+\tlocal_static_vars_info_t l;\n+\tnode = order[i];\n+\tl = node->static_vars_info->local;\n+\n+\tbitmap_operation (l->statics_read_by_decl_uid, \n+\t\t\t  l->statics_read_by_decl_uid,\n+\t\t\t  module_statics_escape, \n+\t\t\t  BITMAP_AND_COMPL);\n+\tbitmap_operation (l->statics_written_by_decl_uid, \n+\t\t\t  l->statics_written_by_decl_uid,\n+\t\t\t  module_statics_escape, \n+\t\t\t  BITMAP_AND_COMPL);\n+      }\n+  }\n+\n+  if (cgraph_dump_file)\n+    {\n+      for (i = order_pos - 1; i >= 0; i--)\n+\t{\n+\t  int index;\n+\t  local_static_vars_info_t l;\n+\t  node = order[i];\n+\t  l = node->static_vars_info->local;\n+\t  fprintf (cgraph_dump_file, \n+\t\t   \"\\nFunction name:%s/%i:\", \n+\t\t   cgraph_node_name (node), node->uid);\n+\t  fprintf (cgraph_dump_file, \"\\n  locals read: \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_read_by_decl_uid,\n+\t\t\t\t    0, index,\n+\t\t\t\t    fprintf (cgraph_dump_file, \"%s \",\n+\t\t\t\t\t     cgraph_get_static_name_by_uid (index)));\n+\t  fprintf (cgraph_dump_file, \"\\n  locals written: \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_written_by_decl_uid,\n+\t\t\t\t    0, index,\n+\t\t\t\t    fprintf(cgraph_dump_file, \"%s \",\n+\t\t\t\t\t   cgraph_get_static_name_by_uid (index)));\n+\t}\n+    }\n+\n+  /* Propagate the local information thru the call graph to produce\n+     the global information.  All the nodes within a cycle will have\n+     the same info so we collapse cycles first.  Then we can do the\n+     propagation in one pass from the leaves to the roots.  */\n+  order_pos = cgraph_reduced_inorder (order, true);\n+  for (i = order_pos - 1; i >= 0; i--)\n+    {\n+      static_vars_info_t node_info;\n+      global_static_vars_info_t node_g = \n+\tggc_calloc (1, sizeof (struct global_static_vars_info_d));\n+      local_static_vars_info_t node_l;\n+      \n+\n+      bool read_all;\n+      bool write_all;\n+\n+      node = order[i];\n+      node_info = node->static_vars_info;\n+      node_info->global = node_g;\n+      node_l = node_info->local;\n+\n+      read_all = node->local.calls_read_all;\n+      write_all = node->local.calls_write_all;\n+\n+      /* If any node in a cycle is calls_read_all or calls_write_all\n+\t they all are. */\n+      w = node->next_cycle;\n+      while (w)\n+\t{\n+\t  read_all |= w->local.calls_read_all;\n+\t  write_all |= w->local.calls_write_all;\n+\t  w = w->next_cycle;\n+\t}\n+\n+      /* Initialized the bitmaps for the reduced nodes */\n+      if (read_all) \n+\tnode_g->statics_read_by_decl_uid = all_module_statics;\n+      else \n+\t{\n+\t  node_g->statics_read_by_decl_uid = BITMAP_GGC_ALLOC ();\n+\t  bitmap_copy (node_g->statics_read_by_decl_uid, \n+\t\t       node_l->statics_read_by_decl_uid);\n+\t}\n+\n+      if (write_all) \n+\tnode_g->statics_written_by_decl_uid = all_module_statics;\n+      else\n+\t{\n+\t  node_g->statics_written_by_decl_uid = BITMAP_GGC_ALLOC ();\n+\t  bitmap_copy (node_g->statics_written_by_decl_uid, \n+\t\t       node_l->statics_written_by_decl_uid);\n+\t}\n+\n+      w = node->next_cycle;\n+      while (w)\n+\t{\n+\t  /* All nodes within a cycle share the same global info bitmaps.  */\n+\t  static_vars_info_t w_info = w->static_vars_info;\n+\t  local_static_vars_info_t w_l;\n+\n+\t  w_info->global = node_g;\n+\t  w_l = w_info->local;\n+\t  \n+\t  /* These global bitmaps are initialized from the local info\n+\t     of all of the nodes in the region.  However there is no\n+\t     need to do any work if the bitmaps were set to\n+\t     all_module_statics.  */\n+\t  if (!read_all)\n+\t    bitmap_a_or_b (node_g->statics_read_by_decl_uid,\n+\t\t\t   node_g->statics_read_by_decl_uid,\n+\t\t\t   w_l->statics_read_by_decl_uid);\n+\t  if (!write_all)\n+\t    bitmap_a_or_b (node_g->statics_written_by_decl_uid,\n+\t\t\t   node_g->statics_written_by_decl_uid,\n+\t\t\t   w_l->statics_written_by_decl_uid);\n+\t  w = w->next_cycle;\n+\t}\n+\n+      cgraph_propagate_bits (node);\n+\n+      w = node->next_cycle;\n+      while (w)\n+\t{\n+\t  cgraph_propagate_bits (w);\n+\t  w = w->next_cycle;\n+\t}\n+    }\n+\n+  if (cgraph_dump_file)\n+    {\n+      for (i = order_pos - 1; i >= 0; i--)\n+\t{\n+\t  static_vars_info_t node_info;\n+\t  global_static_vars_info_t node_g;\n+\t  int index;\n+\t  node = order[i];\n+\t  node_info = node->static_vars_info;\n+\t  node_g = node_info->global;\n+\t  fprintf (cgraph_dump_file, \n+\t\t   \"\\nFunction name:%s/%i:\", \n+\t\t   cgraph_node_name (node), node->uid);\n+\t  w = node->next_cycle;\n+\t  while (w) \n+\t    {\n+\t      fprintf (cgraph_dump_file, \"\\n  next cycle: %s/%i \",\n+\t\t       cgraph_node_name (w), w->uid);\n+\t      w = w->next_cycle;\n+\t    }\n+\t  fprintf (cgraph_dump_file, \"\\n  globals read: \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (node_g->statics_read_by_decl_uid,\n+\t\t\t\t    0, index,\n+\t\t\t\t    fprintf (cgraph_dump_file, \"%s \",\n+\t\t\t\t\t     cgraph_get_static_name_by_uid (index)));\n+\t  fprintf (cgraph_dump_file, \"\\n  globals written: \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (node_g->statics_written_by_decl_uid,\n+\t\t\t\t    0, index,\n+\t\t\t\t    fprintf (cgraph_dump_file, \"%s \",\n+\t\t\t\t\t     cgraph_get_static_name_by_uid (index)));\n+\t}\n+    }\n+\n+  /* Cleanup. */\n+  for (i = order_pos - 1; i >= 0; i--)\n+    {\n+      static_vars_info_t node_info;\n+      global_static_vars_info_t node_g;\n+      node = order[i];\n+      node_info = node->static_vars_info;\n+      node_g = node_info->global;\n+      \n+      node_g->var_anns_valid = false;\n+\n+      /* Create the complimentary sets.  These are more useful for\n+\t certain apis.  */\n+      node_g->statics_not_read_by_decl_uid = BITMAP_GGC_ALLOC ();\n+      node_g->statics_not_written_by_decl_uid = BITMAP_GGC_ALLOC ();\n+\n+      /* FIXME -- PROFILE-RESTRUCTURE: Delete next 4 assignments.  */\n+      node_g->statics_read_by_ann_uid = BITMAP_GGC_ALLOC ();\n+      node_g->statics_written_by_ann_uid = BITMAP_GGC_ALLOC ();\n+      node_g->statics_not_read_by_ann_uid = BITMAP_GGC_ALLOC ();\n+      node_g->statics_not_written_by_ann_uid = BITMAP_GGC_ALLOC ();\n+\n+      if (node_g->statics_read_by_decl_uid != all_module_statics) \n+\t{\n+\t  bitmap_operation (node_g->statics_not_read_by_decl_uid, \n+\t\t\t    all_module_statics,\n+\t\t\t    node_g->statics_read_by_decl_uid,\n+\t\t\t    BITMAP_AND_COMPL);\n+\t}\n+\n+      if (node_g->statics_written_by_decl_uid != all_module_statics) \n+\tbitmap_operation (node_g->statics_not_written_by_decl_uid, \n+\t\t\t  all_module_statics,\n+\t\t\t  node_g->statics_written_by_decl_uid,\n+\t\t\t  BITMAP_AND_COMPL);\n+\n+      w = node->next_cycle;\n+\n+      while (w)\n+\t{\n+\t  struct cgraph_node * last = w;\n+\t  w = w->next_cycle;\n+\t  last->next_cycle = NULL;\n+\t}\n+    }\n+\n+  free (order);\n+}\n+\n /* Expand all functions that must be output.\n \n    Attempt to topologically sort the nodes so function is output when\n@@ -1659,8 +2687,6 @@ cgraph_expand_all_functions (void)\n   int order_pos = 0, new_order_pos = 0;\n   int i;\n \n-  cgraph_mark_functions_to_output ();\n-\n   order_pos = cgraph_postorder (order);\n   gcc_assert (order_pos == cgraph_n_nodes);\n \n@@ -1683,34 +2709,46 @@ cgraph_expand_all_functions (void)\n   free (order);\n }\n \n-/* Mark all local functions.\n+/* Mark all local and external functions.\n+   \n+   A local function is one whose calls can occur only in the current\n+   compilation unit and all its calls are explicit, so we can change\n+   its calling convention.  We simply mark all static functions whose\n+   address is not taken as local.\n \n-   A local function is one whose calls can occur only in the\n-   current compilation unit and all its calls are explicit,\n-   so we can change its calling convention.\n-   We simply mark all static functions whose address is not taken\n-   as local.  */\n+   An external function is one whose body is outside the current\n+   compilation unit.  */\n \n static void\n-cgraph_mark_local_functions (void)\n+cgraph_mark_local_and_external_functions (void)\n {\n   struct cgraph_node *node;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nMarking local functions:\");\n-\n   /* Figure out functions we want to assemble.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       node->local.local = (!node->needed\n \t\t           && DECL_SAVED_TREE (node->decl)\n \t\t           && !TREE_PUBLIC (node->decl));\n-      if (cgraph_dump_file && node->local.local)\n-\tfprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+      node->local.external = (!DECL_SAVED_TREE (node->decl)\n+\t\t\t   && TREE_PUBLIC (node->decl));\n     }\n+\n   if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"\\nMarking local functions:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->local.local)\n+\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+      fprintf (cgraph_dump_file, \"\\n\\n\");\n+\n+      fprintf (cgraph_dump_file, \"\\nMarking external functions:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->local.external)\n+\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n     fprintf (cgraph_dump_file, \"\\n\\n\");\n }\n+}\n \n /* Return true when function body of DECL still needs to be kept around\n    for later re-use.  */\n@@ -1744,7 +2782,7 @@ cgraph_optimize (void)\n   if (!quiet_flag)\n     fprintf (stderr, \"Performing intraprocedural optimizations\\n\");\n \n-  cgraph_mark_local_functions ();\n+  cgraph_mark_local_and_external_functions ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Marked \");\n@@ -1767,6 +2805,15 @@ cgraph_optimize (void)\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif\n+  \n+  /* This call was moved here from cgraph_expand_all_functions so that\n+     cgraph_characterize_statics could use the output flag of the cgraph\n+     node.  */\n+  \n+  cgraph_mark_functions_to_output ();\n+  \n+  cgraph_characterize_statics ();\n+  \n   cgraph_expand_all_functions ();\n   if (cgraph_dump_file)\n     {\n@@ -1874,4 +2921,6 @@ void\n init_cgraph (void)\n {\n   cgraph_dump_file = dump_begin (TDI_cgraph, NULL);\n+  memory_identifier = get_identifier(\"memory\");\n }\n+#include \"gt-cgraphunit.h\""}, {"sha": "7f552ca928f45118b7049af1a17d856d0ea1ce4e", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-pass.h\"\n #include \"convert.h\"\n #include \"params.h\"\n+#include \"cgraph.h\"\n \n /* Build and maintain data flow information for trees.  */\n \n@@ -107,6 +108,7 @@ find_referenced_vars (void)\n   block_stmt_iterator si;\n   struct walk_state walk_state;\n \n+  cgraph_reset_static_var_maps ();\n   vars_found = htab_create (50, htab_hash_pointer, htab_eq_pointer, NULL);\n   memset (&walk_state, 0, sizeof (walk_state));\n   walk_state.vars_found = vars_found;"}, {"sha": "5f8c8d13c4ee18b23e1f5bd1d029e372d43e650d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hashtab.h\"\n #include \"tree-gimple.h\"\n #include \"tree-ssa-operands.h\"\n+#include \"cgraph.h\"\n \n /* Forward declare structures for the garbage collector GTY markers.  */\n #ifndef GCC_BASIC_BLOCK_H\n@@ -199,6 +200,11 @@ struct var_ann_d GTY(())\n      live at the same time and this can happen for each call to the\n      dominator optimizer.  */\n   tree current_def;\n+\n+  /* Pointer to the structure that contains the sets of global\n+     variables modified by function calls.  This field is only used\n+     for FUNCTION_DECLs.  */\n+  static_vars_info_t static_vars_info;\n };\n \n "}, {"sha": "83f0c369ae0e40d884daeef440e9b37cfdd1b948", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6674a6ce49dc1cba7ca46cdd9cf4a62ede556568/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6674a6ce49dc1cba7ca46cdd9cf4a62ede556568", "patch": "@@ -32,7 +32,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-pass.h\"\n #include \"ggc.h\"\n #include \"timevar.h\"\n+#include \"cgraph.h\"\n \n+#include \"langhooks.h\"\n \n /* This file contains the code required to manage the operands cache of the \n    SSA optimizer.  For every stmt, we maintain an operand cache in the stmt \n@@ -133,8 +135,8 @@ static inline void append_def (tree *);\n static inline void append_use (tree *);\n static void append_v_may_def (tree);\n static void append_v_must_def (tree);\n-static void add_call_clobber_ops (tree);\n-static void add_call_read_ops (tree);\n+static void add_call_clobber_ops (tree, tree);\n+static void add_call_read_ops (tree, tree);\n static void add_stmt_operand (tree *, tree, int);\n \n /* Return a vector of contiguous memory for NUM def operands.  */\n@@ -1380,6 +1382,7 @@ get_call_expr_operands (tree stmt, tree expr)\n {\n   tree op;\n   int call_flags = call_expr_flags (expr);\n+  tree callee = get_callee_fndecl (expr);\n \n   /* Find uses in the called function.  */\n   get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_none);\n@@ -1396,9 +1399,9 @@ get_call_expr_operands (tree stmt, tree expr)\n \t there is no point in recording that.  */ \n       if (TREE_SIDE_EFFECTS (expr)\n \t  && !(call_flags & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n-\tadd_call_clobber_ops (stmt);\n+\tadd_call_clobber_ops (stmt, callee);\n       else if (!(call_flags & ECF_CONST))\n-\tadd_call_read_ops (stmt);\n+\tadd_call_read_ops (stmt, callee);\n     }\n }\n \n@@ -1562,7 +1565,7 @@ note_addressable (tree var, stmt_ann_t s_ann)\n    clobbered variables in the function.  */\n \n static void\n-add_call_clobber_ops (tree stmt)\n+add_call_clobber_ops (tree stmt, tree callee)\n {\n   /* Functions that are not const, pure or never return may clobber\n      call-clobbered variables.  */\n@@ -1579,16 +1582,53 @@ add_call_clobber_ops (tree stmt)\n     {\n       size_t i;\n \n+      /* Get info for module level statics.  There is a bit set for\n+\t each static if the call being processed does not read or\n+\t write that variable.  */\n+\n+      bitmap not_read_b = callee \n+\t? get_global_statics_not_read (callee) : NULL; \n+      bitmap not_written_b = callee \n+\t? get_global_statics_not_written (callee) : NULL; \n+\n+\n       EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n \t{\n \t  tree var = referenced_var (i);\n \n-\t  /* If VAR is read-only, don't add a V_MAY_DEF, just a \n-\t     VUSE operand.  */\n-\t  if (!TREE_READONLY (var))\n-\t    add_stmt_operand (&var, stmt, opf_is_def);\n+\t  bool not_read = not_read_b \n+\t    ? bitmap_bit_p(not_read_b, i) : false;\n+\t  bool not_written = not_written_b\n+\t    ? bitmap_bit_p(not_written_b, i) : false;\n+\n+\n+\t  if (not_read) \n+\t    { /* The var is not read during the call.  */\n+\t      if (not_written) \n+\t\t{\n+\t\t  /* Nothing. */\n+\t\t}\n+\t      else \n+\t\tadd_stmt_operand (&var, stmt, opf_is_def);\n+\t    } \n \t  else\n-\t    add_stmt_operand (&var, stmt, opf_none);\n+\t    { /* The var is read during the call.  */\n+\t      if (not_written) \n+\t\tadd_stmt_operand (&var, stmt, opf_none);\n+\t      else \n+\t\t/* The not_read and not_written bits are only set\n+\t\t   for module static variables.  Neither is set\n+\t\t   here, so we may be dealing with a module static\n+\t\t   or we may not.  So we still must look anywhere\n+\t\t   else we can (such as the TREE_READONLY) to get\n+\t\t   better info.  */\n+\t\t/* If VAR is read-only, don't add a V_MAY_DEF, just a \n+\t\t   VUSE operand.  */\n+\t\tif (TREE_READONLY (var))\n+\t\t  add_stmt_operand (&var, stmt, opf_none);\n+\t\telse\n+\t\t  add_stmt_operand (&var, stmt, opf_is_def);\n+\t    }\t      \n \t});\n     }\n }\n@@ -1598,7 +1638,7 @@ add_call_clobber_ops (tree stmt)\n    function.  */\n \n static void\n-add_call_read_ops (tree stmt)\n+add_call_read_ops (tree stmt, tree callee)\n {\n   /* Otherwise, if the function is not pure, it may reference memory.  Add\n      a VUSE for .GLOBAL_VAR if it has been created.  Otherwise, add a VUSE\n@@ -1609,10 +1649,15 @@ add_call_read_ops (tree stmt)\n   else\n     {\n       size_t i;\n+      bitmap not_read_b = callee \n+\t? get_global_statics_not_read (callee) : NULL; \n \n       EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n \t{\n \t  tree var = referenced_var (i);\n+\t  bool not_read = not_read_b \n+\t    ? bitmap_bit_p(not_read_b, i) : false;\n+\t  if (!not_read)\n \t  add_stmt_operand (&var, stmt, opf_none);\n \t});\n     }"}]}