{"sha": "d7445152be468cc8de1ea0a3ab6555448086e951", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NDUxNTJiZTQ2OGNjOGRlMWVhMGEzYWI2NTU1NDQ4MDg2ZTk1MQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-09-23T03:52:19Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-09-23T03:52:19Z"}, "message": "re PR fortran/37498 (Incorrect array value returned - 4.3 ABI Broken)\n\n2008-09-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n\n\tPR fortran/37498\n\t* trans-io.c (gfc_build_io_library_fndecls): Bump pad size.\n\t(build_dt): Set mask bit for IOPARM_dt_f2003.\n\t* ioparm.def: Add IOPARM_dt_f2003.\n\n2008-09-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n\n\tPR libfortran/37498\n\t* file_pos (st_endfile): Clear memory only for libfortran 4.3 private\n\tarea.\n\t* list_read.c (eat_separator): Only access F2003 I/O parameters if\n\tIOPARM_DT_HAS_F2003 bit is set. (parse_real): Ditto.\n\t(read_real): Ditto.\n\t* read.c (read_a): Likewise. (read_a_char4): Likewise though not\n\tstrictly necessary. (read_f): Likewise.\n\t* io.h (unit_sign_s): New enumerator to allow duplication of\n\tst_parameter structures. (IOPARM_DT_HAS_F2003): New mask bit.\n\t(st_parameter_43): New structure copied from 4.3 version of \n\tst_paramater_dt private section. (st_parameter_44): New structure with\n\tF2003 items added. (st_parameter_dt): Modified to create union of new\n\tand old structures to allow correct memory setting for 4.3 ABI\n\tcompatibility. Bumped the pad size.\n\t* transfer.c (read_sf): Do not use F2003 I/O memory areas unless\n\tIOPARM_DT_HAS_F2003 bit has been set. (read_block_form): Ditto.\n\t(formatted_transfer_scalar): Ditto. (data_transfer_init): Ditto and\n\tadd comment, fix formatting.\n\t* write.c (write_default_char4): Likewise though not strictly necessary.\n\t(write_utf8_char4): Ditto. (write_character): Ditto.\n\t(write_real_g0): Ditto. (list_formatted_write_scalar): Ditto.\n\t(nml_write_obj): Ditto. (namelist_write): Ditto.\n\t* write_float.def (calculate_sign): Eliminate warning by including all\n\tcases in switch. (output_float): Output only decimal point of F2003 flag\n\tis not set.\n\nFrom-SVN: r140576", "tree": {"sha": "ed1e0822525cb0910a79366e0c5da38734d18377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed1e0822525cb0910a79366e0c5da38734d18377"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7445152be468cc8de1ea0a3ab6555448086e951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7445152be468cc8de1ea0a3ab6555448086e951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7445152be468cc8de1ea0a3ab6555448086e951", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7445152be468cc8de1ea0a3ab6555448086e951/comments", "author": null, "committer": null, "parents": [{"sha": "9992fbb57107aa1f2448acbd641cc16b9c61b729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9992fbb57107aa1f2448acbd641cc16b9c61b729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9992fbb57107aa1f2448acbd641cc16b9c61b729"}], "stats": {"total": 684, "additions": 446, "deletions": 238}, "files": [{"sha": "afadaeba8d17e86897e4638e56d944f710c134fa", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -1,3 +1,10 @@\n+2008-09-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n+\n+\tPR fortran/37498\n+\t* trans-io.c (gfc_build_io_library_fndecls): Bump pad size.\n+\t(build_dt): Set mask bit for IOPARM_dt_f2003.\n+\t* ioparm.def: Add IOPARM_dt_f2003.\n+\n 2008-09-22  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/37486"}, {"sha": "ee3f6b21910ad954477c44da4f640489b625bd22", "filename": "gcc/fortran/ioparm.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -93,3 +93,4 @@ IOPARM (dt,      pad,\t\t1 << 22, char1)\n IOPARM (dt,      round,\t\t1 << 23, char2)\n IOPARM (dt,      sign,\t\t1 << 24, char1)\n IOPARM (dt,      u,\t\t0,\t pad)\n+#define IOPARM_dt_f2003\t\t\t(1 << 25)"}, {"sha": "fdc517abe9796c48d641706978698cbc31bc337c", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -291,7 +291,7 @@ gfc_build_io_library_fndecls (void)\n \t\t\t    = build_pointer_type (gfc_intio_type_node);\n   types[IOPARM_type_parray] = pchar_type_node;\n   types[IOPARM_type_pchar] = pchar_type_node;\n-  pad_size = 16 * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (pchar_type_node));\n+  pad_size = 32 * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (pchar_type_node));\n   pad_size += 32 * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (integer_type_node));\n   pad_idx = build_index_type (build_int_cst (NULL_TREE, pad_size));\n   types[IOPARM_type_pad] = build_array_type (char_type_node, pad_idx);\n@@ -1641,7 +1641,7 @@ build_dt (tree function, gfc_code * code)\n   tree tmp, var;\n   gfc_expr *nmlname;\n   gfc_namelist *nml;\n-  unsigned int mask = 0;\n+  unsigned int mask = IOPARM_dt_f2003;\n \n   gfc_start_block (&block);\n   gfc_init_block (&post_block);"}, {"sha": "fff673d83f675fbc36de7aa58a5479838a99b956", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -1,3 +1,32 @@\n+2008-09-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n+\n+\tPR libfortran/37498\n+\t* file_pos (st_endfile): Clear memory only for libfortran 4.3 private\n+\tarea.\n+\t* list_read.c (eat_separator): Only access F2003 I/O parameters if\n+\tIOPARM_DT_HAS_F2003 bit is set. (parse_real): Ditto.\n+\t(read_real): Ditto.\n+\t* read.c (read_a): Likewise. (read_a_char4): Likewise though not\n+\tstrictly necessary. (read_f): Likewise.\n+\t* io.h (unit_sign_s): New enumerator to allow duplication of\n+\tst_parameter structures. (IOPARM_DT_HAS_F2003): New mask bit.\n+\t(st_parameter_43): New structure copied from 4.3 version of \n+\tst_paramater_dt private section. (st_parameter_44): New structure with\n+\tF2003 items added. (st_parameter_dt): Modified to create union of new\n+\tand old structures to allow correct memory setting for 4.3 ABI\n+\tcompatibility. Bumped the pad size.\n+\t* transfer.c (read_sf): Do not use F2003 I/O memory areas unless\n+\tIOPARM_DT_HAS_F2003 bit has been set. (read_block_form): Ditto.\n+\t(formatted_transfer_scalar): Ditto. (data_transfer_init): Ditto and\n+\tadd comment, fix formatting.\n+\t* write.c (write_default_char4): Likewise though not strictly necessary.\n+\t(write_utf8_char4): Ditto. (write_character): Ditto.\n+\t(write_real_g0): Ditto. (list_formatted_write_scalar): Ditto.\n+\t(nml_write_obj): Ditto. (namelist_write): Ditto.\n+\t* write_float.def (calculate_sign): Eliminate warning by including all\n+\tcases in switch. (output_float): Output only decimal point of F2003 flag\n+\tis not set.\n+\n 2008-09-10  Tobias Burnus  <burnus@net-b.de>\n \t    H. J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "6dafbe59028643a6887b23925da0440f03084631", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -300,7 +300,7 @@ st_endfile (st_parameter_filepos *fpp)\n \t{\n \t  st_parameter_dt dtp;\n \t  dtp.common = fpp->common;\n-\t  memset (&dtp.u.p, 0, sizeof (dtp.u.p));\n+\t  memset (&dtp.u.p.transfer, 0, sizeof (dtp.u.q));\n \t  dtp.u.p.current_unit = u;\n \t  next_record (&dtp, 1);\n \t}"}, {"sha": "1f6041db7daf1fcd300c82d4396421693f7be2db", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 180, "deletions": 93, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -233,6 +233,10 @@ typedef enum\n { ASYNC_YES, ASYNC_NO, ASYNC_UNSPECIFIED }\n unit_async;\n \n+typedef enum\n+{ SIGN_S, SIGN_SS, SIGN_SP }\n+unit_sign_s;\n+\n #define CHARACTER1(name) \\\n \t      char * name; \\\n \t      gfc_charlen_type name ## _len\n@@ -368,19 +372,92 @@ struct format_data;\n #define IOPARM_DT_HAS_PAD\t\t\t(1 << 22)\n #define IOPARM_DT_HAS_ROUND\t\t\t(1 << 23)\n #define IOPARM_DT_HAS_SIGN\t\t\t(1 << 24)\n+#define IOPARM_DT_HAS_F2003                     (1 << 25)\n /* Internal use bit.  */\n #define IOPARM_DT_IONML_SET\t\t\t(1 << 31)\n \n-typedef struct st_parameter_dt\n+\n+typedef struct st_parameter_43\n+{\n+  void (*transfer) (struct st_parameter_dt *, bt, void *, int,\n+\t\t    size_t, size_t);\n+  struct gfc_unit *current_unit;\n+  /* Item number in a formatted data transfer.  Also used in namelist\n+     read_logical as an index into line_buffer.  */\n+  int item_count;\n+  unit_mode mode;\n+  unit_blank blank_status;\n+  unit_sign sign_status;\n+  int scale_factor;\n+  int max_pos; /* Maximum righthand column written to.  */\n+  /* Number of skips + spaces to be done for T and X-editing.  */\n+  int skips;\n+  /* Number of spaces to be done for T and X-editing.  */\n+  int pending_spaces;\n+  /* Whether an EOR condition was encountered. Value is:\n+       0 if no EOR was encountered\n+       1 if an EOR was encountered due to a 1-byte marker (LF)\n+       2 if an EOR was encountered due to a 2-bytes marker (CRLF) */\n+  int sf_seen_eor;\n+  unit_advance advance_status;\n+  unsigned reversion_flag : 1; /* Format reversion has occurred.  */\n+  unsigned first_item : 1;\n+  unsigned seen_dollar : 1;\n+  unsigned eor_condition : 1;\n+  unsigned no_leading_blank : 1;\n+  unsigned char_flag : 1;\n+  unsigned input_complete : 1;\n+  unsigned at_eol : 1;\n+  unsigned comma_flag : 1;\n+  /* A namelist specific flag used in the list directed library\n+     to flag that calls are being made from namelist read (eg. to\n+     ignore comments or to treat '/' as a terminator)  */\n+  unsigned namelist_mode : 1;\n+  /* A namelist specific flag used in the list directed library\n+     to flag read errors and return, so that an attempt can be\n+     made to read a new object name.  */\n+  unsigned nml_read_error : 1;\n+  /* A sequential formatted read specific flag used to signal that a\n+     character string is being read so don't use commas to shorten a\n+     formatted field width.  */\n+  unsigned sf_read_comma : 1;\n+  /* A namelist specific flag used to enable reading input from \n+     line_buffer for logical reads.  */\n+  unsigned line_buffer_enabled : 1;\n+  /* An internal unit specific flag used to identify that the associated\n+     unit is internal.  */\n+  unsigned unit_is_internal : 1;\n+  /* An internal unit specific flag to signify an EOF condition for list\n+     directed read.  */\n+  unsigned at_eof : 1;\n+  /* 16 unused bits.  */\n+\n+  char last_char;\n+  char nml_delim;\n+\n+  int repeat_count;\n+  int saved_length;\n+  int saved_used;\n+  bt saved_type;\n+  char *saved_string;\n+  char *scratch;\n+  char *line_buffer;\n+  struct format_data *fmt;\n+  jmp_buf *eof_jump;\n+  namelist_info *ionml;\n+  /* A flag used to identify when a non-standard expanded namelist read\n+     has occurred.  */\n+  int expanded_read;\n+  /* Storage area for values except for strings.  Must be large\n+     enough to hold a complex value (two reals) of the largest\n+     kind.  */\n+  char value[32];\n+  gfc_offset size_used;\n+} st_parameter_43;\n+\n+\n+typedef struct st_parameter_44\n {\n-  st_parameter_common common;\n-  GFC_IO_INT rec;\n-  GFC_IO_INT *size, *iolength;\n-  gfc_array_char *internal_unit_desc;\n-  CHARACTER1 (format);\n-  CHARACTER2 (advance);\n-  CHARACTER1 (internal_unit);\n-  CHARACTER2 (namelist_name);\n   GFC_IO_INT *id;\n   GFC_IO_INT pos;\n   CHARACTER1 (asynchronous);\n@@ -390,95 +467,105 @@ typedef struct st_parameter_dt\n   CHARACTER1 (pad);\n   CHARACTER2 (round);\n   CHARACTER1 (sign);\n+  void (*transfer) (struct st_parameter_dt *, bt, void *, int,\n+\t\t    size_t, size_t);\n+  struct gfc_unit *current_unit;\n+  /* Item number in a formatted data transfer.  Also used in namelist\n+     read_logical as an index into line_buffer.  */\n+  int item_count;\n+  unit_mode mode;\n+  unit_blank blank_status;\n+  unit_sign sign_status;\n+  int scale_factor;\n+  int max_pos; /* Maximum righthand column written to.  */\n+  /* Number of skips + spaces to be done for T and X-editing.  */\n+  int skips;\n+  /* Number of spaces to be done for T and X-editing.  */\n+  int pending_spaces;\n+  /* Whether an EOR condition was encountered. Value is:\n+       0 if no EOR was encountered\n+       1 if an EOR was encountered due to a 1-byte marker (LF)\n+       2 if an EOR was encountered due to a 2-bytes marker (CRLF) */\n+  int sf_seen_eor;\n+  unit_advance advance_status;\n+  unsigned reversion_flag : 1; /* Format reversion has occurred.  */\n+  unsigned first_item : 1;\n+  unsigned seen_dollar : 1;\n+  unsigned eor_condition : 1;\n+  unsigned no_leading_blank : 1;\n+  unsigned char_flag : 1;\n+  unsigned input_complete : 1;\n+  unsigned at_eol : 1;\n+  unsigned comma_flag : 1;\n+  /* A namelist specific flag used in the list directed library\n+     to flag that calls are being made from namelist read (eg. to\n+     ignore comments or to treat '/' as a terminator)  */\n+  unsigned namelist_mode : 1;\n+  /* A namelist specific flag used in the list directed library\n+     to flag read errors and return, so that an attempt can be\n+     made to read a new object name.  */\n+  unsigned nml_read_error : 1;\n+  /* A sequential formatted read specific flag used to signal that a\n+     character string is being read so don't use commas to shorten a\n+     formatted field width.  */\n+  unsigned sf_read_comma : 1;\n+  /* A namelist specific flag used to enable reading input from \n+     line_buffer for logical reads.  */\n+  unsigned line_buffer_enabled : 1;\n+  /* An internal unit specific flag used to identify that the associated\n+     unit is internal.  */\n+  unsigned unit_is_internal : 1;\n+  /* An internal unit specific flag to signify an EOF condition for list\n+     directed read.  */\n+  unsigned at_eof : 1;\n+  /* 16 unused bits.  */\n+\n+  char last_char;\n+  char nml_delim;\n+\n+  int repeat_count;\n+  int saved_length;\n+  int saved_used;\n+  bt saved_type;\n+  char *saved_string;\n+  char *scratch;\n+  char *line_buffer;\n+  struct format_data *fmt;\n+  jmp_buf *eof_jump;\n+  namelist_info *ionml;\n+  /* A flag used to identify when a non-standard expanded namelist read\n+     has occurred.  */\n+  int expanded_read;\n+  /* Storage area for values except for strings.  Must be large\n+     enough to hold a complex value (two reals) of the largest\n+     kind.  */\n+  char value[32];\n+  gfc_offset size_used;\n+  unit_pad pad_status;\n+  unit_decimal decimal_status;\n+  unit_delim delim_status;\n+} st_parameter_44;\n+\n+typedef struct st_parameter_dt\n+{\n+  st_parameter_common common;\n+  GFC_IO_INT rec;\n+  GFC_IO_INT *size, *iolength;\n+  gfc_array_char *internal_unit_desc;\n+  CHARACTER1 (format);\n+  CHARACTER2 (advance);\n+  CHARACTER1 (internal_unit);\n+  CHARACTER2 (namelist_name);\n   /* Private part of the structure.  The compiler just needs\n      to reserve enough space.  */\n   union\n     {\n-      struct\n-\t{\n-\t  void (*transfer) (struct st_parameter_dt *, bt, void *, int,\n-\t\t\t    size_t, size_t);\n-\t  struct gfc_unit *current_unit;\n-\t  /* Item number in a formatted data transfer.  Also used in namelist\n-\t       read_logical as an index into line_buffer.  */\n-\t  int item_count;\n-\t  unit_mode mode;\n-\t  unit_blank blank_status;\n-          unit_pad pad_status;\n-\t  enum { SIGN_S, SIGN_SS, SIGN_SP } sign_status;\n-\t  int scale_factor;\n-\t  int max_pos; /* Maximum righthand column written to.  */\n-\t  /* Number of skips + spaces to be done for T and X-editing.  */\n-\t  int skips;\n-\t  /* Number of spaces to be done for T and X-editing.  */\n-\t  int pending_spaces;\n-\t  /* Whether an EOR condition was encountered. Value is:\n-\t       0 if no EOR was encountered\n-\t       1 if an EOR was encountered due to a 1-byte marker (LF)\n-\t       2 if an EOR was encountered due to a 2-bytes marker (CRLF) */\n-\t  int sf_seen_eor;\n-\t  unit_advance advance_status;\n-\t  unit_decimal decimal_status;\n-          unit_delim delim_status;\n-\n-\t  unsigned reversion_flag : 1; /* Format reversion has occurred.  */\n-\t  unsigned first_item : 1;\n-\t  unsigned seen_dollar : 1;\n-\t  unsigned eor_condition : 1;\n-\t  unsigned no_leading_blank : 1;\n-\t  unsigned char_flag : 1;\n-\t  unsigned input_complete : 1;\n-\t  unsigned at_eol : 1;\n-\t  unsigned comma_flag : 1;\n-\t  /* A namelist specific flag used in the list directed library\n-\t     to flag that calls are being made from namelist read (eg. to\n-\t     ignore comments or to treat '/' as a terminator)  */\n-\t  unsigned namelist_mode : 1;\n-\t  /* A namelist specific flag used in the list directed library\n-\t     to flag read errors and return, so that an attempt can be\n-\t     made to read a new object name.  */\n-\t  unsigned nml_read_error : 1;\n-\t  /* A sequential formatted read specific flag used to signal that a\n-\t     character string is being read so don't use commas to shorten a\n-\t     formatted field width.  */\n-\t  unsigned sf_read_comma : 1;\n-          /* A namelist specific flag used to enable reading input from \n-\t     line_buffer for logical reads.  */\n-\t  unsigned line_buffer_enabled : 1;\n-\t  /* An internal unit specific flag used to identify that the associated\n-\t     unit is internal.  */\n-\t  unsigned unit_is_internal : 1;\n-\t  /* An internal unit specific flag to signify an EOF condition for list\n-\t     directed read.  */\n-\t  unsigned at_eof : 1;\n-\t  /* 16 unused bits.  */\n-\n-\t  char last_char;\n-\t  char nml_delim;\n-\n-\t  int repeat_count;\n-\t  int saved_length;\n-\t  int saved_used;\n-\t  bt saved_type;\n-\t  char *saved_string;\n-\t  char *scratch;\n-\t  char *line_buffer;\n-\t  struct format_data *fmt;\n-\t  jmp_buf *eof_jump;\n-\t  namelist_info *ionml;\n-\t  /* A flag used to identify when a non-standard expanded namelist read\n-\t     has occurred.  */\n-\t  int expanded_read;\n-\t  /* Storage area for values except for strings.  Must be large\n-\t     enough to hold a complex value (two reals) of the largest\n-\t     kind.  */\n-\t  char value[32];\n-\t  gfc_offset size_used;\n-\t} p;\n+      st_parameter_43 q;\n+      st_parameter_44 p;\n       /* This pad size must be equal to the pad_size declared in\n \t trans-io.c (gfc_build_io_library_fndecls).  The above structure\n \t must be smaller or equal to this array.  */\n-      char pad[16 * sizeof (char *) + 32 * sizeof (int)];\n+      char pad[32 * sizeof (char *) + 32 * sizeof (int)];\n     } u;\n }\n st_parameter_dt;\n@@ -512,12 +599,12 @@ typedef struct\n   unit_position position;\n   unit_status status;\n   unit_pad pad;\n+  unit_convert convert;\n+  int has_recl;\n   unit_decimal decimal;\n   unit_encoding encoding;\n   unit_round round;\n   unit_sign sign;\n-  unit_convert convert;\n-  int has_recl;\n   unit_async async;\n }\n unit_flags;"}, {"sha": "47f4786b5758a69e7edd626f95075cfc63c1f5b9", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -324,7 +324,8 @@ eat_separator (st_parameter_dt *dtp)\n   switch (c)\n     {\n     case ',':\n-      if (dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t  && dtp->u.p.decimal_status == DECIMAL_COMMA)\n \t{\n \t  unget_char (dtp, c);\n \t  break;\n@@ -1116,7 +1117,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n       c = next_char (dtp);\n     }\n \n-  if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+      && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n     c = '.';\n   \n   if (!isdigit (c) && c != '.')\n@@ -1134,7 +1136,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n-      if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t  && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n \t{\n@@ -1305,9 +1308,17 @@ read_complex (st_parameter_dt *dtp, int kind, size_t size)\n   else\n     unget_char (dtp, c);\n \n-  if (next_char (dtp)\n-      !=  (dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';'))\n-    goto bad_complex;\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    {\n+      if (next_char (dtp)\n+\t  !=  (dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';'))\n+\tgoto bad_complex;\n+    }\n+  else\n+    {\n+      if (next_char (dtp) != ',')\n+\tgoto bad_complex;\n+    }\n \n eol_2:\n   eat_spaces (dtp);\n@@ -1360,7 +1371,8 @@ read_real (st_parameter_dt *dtp, int length)\n   seen_dp = 0;\n \n   c = next_char (dtp);\n-  if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+      && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n     c = '.';\n   switch (c)\n     {\n@@ -1397,7 +1409,8 @@ read_real (st_parameter_dt *dtp, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n-      if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t  && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n \t{\n@@ -1463,7 +1476,8 @@ read_real (st_parameter_dt *dtp, int length)\n       c = next_char (dtp);\n     }\n \n-  if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+      && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n     c = '.';\n \n   if (!isdigit (c) && c != '.')\n@@ -1488,7 +1502,8 @@ read_real (st_parameter_dt *dtp, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n-      if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t  && c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n \t{"}, {"sha": "e35a7b1bdc3af01452e964bf8a815df084681f2f", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -439,9 +439,10 @@ read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n     read_utf8_char1 (dtp, p, length, w);\n   else\n     read_default_char1 (dtp, p, length, w);\n-  \n-  dtp->u.p.sf_read_comma =\n-    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+\n+  dtp->u.p.sf_read_comma = 1;\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n }\n \n \n@@ -467,8 +468,9 @@ read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n   else\n     read_default_char4 (dtp, p, length, w);\n   \n-  dtp->u.p.sf_read_comma =\n-    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  dtp->u.p.sf_read_comma = 1;\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n }\n \n /* eat_leading_spaces()-- Given a character pointer and a width,\n@@ -840,8 +842,11 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n       switch (*p)\n \t{\n \tcase ',':\n-\t  if (dtp->u.p.decimal_status == DECIMAL_COMMA && *p == ',')\n-\t    *p = '.';\n+\t  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t      && (dtp->u.p.decimal_status == DECIMAL_COMMA && *p == ','))\n+\t\t*p = '.';\n+\t  else\n+\t    goto bad_float;\n \t  /* Fall through */\n \tcase '.':\n \t  if (seen_dp)\n@@ -1074,9 +1079,17 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n void\n read_x (st_parameter_dt * dtp, int n)\n {\n-  if ((dtp->u.p.pad_status == PAD_NO || is_internal_unit (dtp))\n-      && dtp->u.p.current_unit->bytes_left < n)\n-    n = dtp->u.p.current_unit->bytes_left;\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    {\n+      if ((dtp->u.p.pad_status == PAD_NO || is_internal_unit (dtp))\n+\t  && dtp->u.p.current_unit->bytes_left < n)\n+\tn = dtp->u.p.current_unit->bytes_left;\n+    }\n+  else\n+    {\n+      if (is_internal_unit (dtp) && dtp->u.p.current_unit->bytes_left < n)\n+\tn = dtp->u.p.current_unit->bytes_left;\n+    }\n \n   dtp->u.p.sf_read_comma = 0;\n   if (n > 0)"}, {"sha": "e707fbc510e41db6fec65f8a10ae42d97739e5a9", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 130, "deletions": 103, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -264,7 +264,8 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n \t     so we can just continue with a short read.  */\n-\t  if (dtp->u.p.pad_status == PAD_NO)\n+\t  if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t      && dtp->u.p.pad_status == PAD_NO)\n \t    {\n \t      if (no_error)\n \t\tbreak;\n@@ -329,10 +330,11 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t   to unit record length and proceed, otherwise error.  */\n \t  if (dtp->u.p.current_unit->unit_number == options.stdin_unit\n \t      && dtp->u.p.current_unit->recl == DEFAULT_RECL)\n-          dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+            dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t  else\n \t    {\n-\t      if (dtp->u.p.pad_status == PAD_NO)\n+\t      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t\t  && dtp->u.p.pad_status == PAD_NO)\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n@@ -379,7 +381,8 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n   if (nread != *nbytes)\n     {\t\t\t\t/* Short read, this shouldn't happen.  */\n-      if (dtp->u.p.pad_status == PAD_YES)\n+      if ((dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t  && dtp->u.p.pad_status == PAD_YES)\n \t*nbytes = nread;\n       else\n \t{\n@@ -950,7 +953,11 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   /* Set this flag so that commas in reads cause the read to complete before\n      the entire field has been read.  The next read field will start right after\n      the comma in the stream.  (Set to 0 for character reads).  */\n-  dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  dtp->u.p.sf_read_comma = 1;\n+\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+\n   dtp->u.p.line_buffer = scratch;\n \n   for (;;)\n@@ -1820,7 +1827,13 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   namelist_info *ionml;\n \n   ionml = ((cf & IOPARM_DT_IONML_SET) != 0) ? dtp->u.p.ionml : NULL;\n-  memset (&dtp->u.p, 0, sizeof (dtp->u.p));\n+\n+  /* To maintain ABI, &transfer is the start of the private memory area in\n+     in st_parameter_dt.  Memory from the beginning of the structure to this\n+     point is set by the front end and must not be touched.  The number of\n+     bytes to clear must stay within the sizeof q to avoid over-writing.  */\n+  memset (&dtp->u.p.transfer, 0, sizeof (dtp->u.q));\n+\n   dtp->u.p.ionml = ionml;\n   dtp->u.p.mode = read_flag ? READING : WRITING;\n \n@@ -1836,60 +1849,61 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n      st_parameter_open opp;\n      unit_convert conv;\n \n-     if (dtp->common.unit < 0)\n-     {\n-       close_unit (dtp->u.p.current_unit);\n-       dtp->u.p.current_unit = NULL;\n-       generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t       \"Bad unit number in OPEN statement\");\n-       return;\n-     }\n-     memset (&u_flags, '\\0', sizeof (u_flags));\n-     u_flags.access = ACCESS_SEQUENTIAL;\n-     u_flags.action = ACTION_READWRITE;\n-\n-     /* Is it unformatted?  */\n-     if (!(cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT\n-\t\t | IOPARM_DT_IONML_SET)))\n-       u_flags.form = FORM_UNFORMATTED;\n-     else\n-       u_flags.form = FORM_UNSPECIFIED;\n-\n-     u_flags.delim = DELIM_UNSPECIFIED;\n-     u_flags.blank = BLANK_UNSPECIFIED;\n-     u_flags.pad = PAD_UNSPECIFIED;\n-     u_flags.decimal = DECIMAL_UNSPECIFIED;\n-     u_flags.encoding = ENCODING_UNSPECIFIED;\n-     u_flags.async = ASYNC_UNSPECIFIED;\n-     u_flags.round = ROUND_UNSPECIFIED;\n-     u_flags.sign = SIGN_UNSPECIFIED;\n-     u_flags.status = STATUS_UNKNOWN;\n-\n-     conv = get_unformatted_convert (dtp->common.unit);\n-\n-     if (conv == GFC_CONVERT_NONE)\n-       conv = compile_options.convert;\n-\n-     /* We use big_endian, which is 0 on little-endian machines\n-\tand 1 on big-endian machines.  */\n-     switch (conv)\n-       {\n-       case GFC_CONVERT_NATIVE:\n-       case GFC_CONVERT_SWAP:\n-\t break;\n+    if (dtp->common.unit < 0)\n+      {\n+\tclose_unit (dtp->u.p.current_unit);\n+\tdtp->u.p.current_unit = NULL;\n+\tgenerate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t\"Bad unit number in OPEN statement\");\n+\treturn;\n+      }\n+    memset (&u_flags, '\\0', sizeof (u_flags));\n+    u_flags.access = ACCESS_SEQUENTIAL;\n+    u_flags.action = ACTION_READWRITE;\n+\n+    /* Is it unformatted?  */\n+    if (!(cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT\n+\t\t| IOPARM_DT_IONML_SET)))\n+      u_flags.form = FORM_UNFORMATTED;\n+    else\n+      u_flags.form = FORM_UNSPECIFIED;\n+\n+    u_flags.delim = DELIM_UNSPECIFIED;\n+    u_flags.blank = BLANK_UNSPECIFIED;\n+    u_flags.pad = PAD_UNSPECIFIED;\n+    u_flags.decimal = DECIMAL_UNSPECIFIED;\n+    u_flags.encoding = ENCODING_UNSPECIFIED;\n+    u_flags.async = ASYNC_UNSPECIFIED;\n+    u_flags.round = ROUND_UNSPECIFIED;\n+    u_flags.sign = SIGN_UNSPECIFIED;\n+\n+    u_flags.status = STATUS_UNKNOWN;\n+\n+    conv = get_unformatted_convert (dtp->common.unit);\n+\n+    if (conv == GFC_CONVERT_NONE)\n+      conv = compile_options.convert;\n+\n+    /* We use big_endian, which is 0 on little-endian machines\n+       and 1 on big-endian machines.  */\n+    switch (conv)\n+      {\n+\tcase GFC_CONVERT_NATIVE:\n+\tcase GFC_CONVERT_SWAP:\n+\t  break;\n \t \n-       case GFC_CONVERT_BIG:\n-\t conv = big_endian ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n-\t break;\n+\tcase GFC_CONVERT_BIG:\n+\t  conv = big_endian ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n+\t  break;\n       \n-       case GFC_CONVERT_LITTLE:\n-\t conv = big_endian ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n-\t break;\n+\tcase GFC_CONVERT_LITTLE:\n+\t  conv = big_endian ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n+\t  break;\n \t \n-       default:\n-\t internal_error (&opp.common, \"Illegal value for CONVERT\");\n-\t break;\n-       }\n+\tdefault:\n+\t  internal_error (&opp.common, \"Illegal value for CONVERT\");\n+\t  break;\n+      }\n \n      u_flags.convert = conv;\n \n@@ -1970,7 +1984,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       && (cf & IOPARM_DT_HAS_REC) != 0)\n     {\n       generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t      \"Record number not allowed for sequential access data transfer\");\n+\t\t      \"Record number not allowed for sequential access \"\n+\t\t      \"data transfer\");\n       return;\n     }\n \n@@ -1986,7 +2001,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"ADVANCE specification conflicts with sequential access\");\n+\t\t\t  \"ADVANCE specification conflicts with sequential \"\n+\t\t\t  \"access\");\n \t  return;\n \t}\n \n@@ -2018,10 +2034,12 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  return;\n \t}\n \n-      if ((cf & IOPARM_DT_HAS_SIZE) != 0 && dtp->u.p.advance_status != ADVANCE_NO)\n+      if ((cf & IOPARM_DT_HAS_SIZE) != 0 \n+\t  && dtp->u.p.advance_status != ADVANCE_NO)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_MISSING_OPTION,\n-\t\t\t  \"SIZE specification requires an ADVANCE specification of NO\");\n+\t\t\t  \"SIZE specification requires an ADVANCE \"\n+\t\t\t  \"specification of NO\");\n \t  return;\n \t}\n     }\n@@ -2030,74 +2048,83 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       if ((cf & IOPARM_END) != 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"END specification cannot appear in a write statement\");\n+\t\t\t  \"END specification cannot appear in a write \"\n+\t\t\t  \"statement\");\n \t  return;\n \t}\n \n       if ((cf & IOPARM_EOR) != 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"EOR specification cannot appear in a write statement\");\n+\t\t\t  \"EOR specification cannot appear in a write \"\n+\t\t\t  \"statement\");\n \t  return;\n \t}\n \n       if ((cf & IOPARM_DT_HAS_SIZE) != 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"SIZE specification cannot appear in a write statement\");\n+\t\t\t  \"SIZE specification cannot appear in a write \"\n+\t\t\t  \"statement\");\n \t  return;\n \t}\n     }\n \n   if (dtp->u.p.advance_status == ADVANCE_UNSPECIFIED)\n     dtp->u.p.advance_status = ADVANCE_YES;\n \n-  /* Check the decimal mode.  */\n-\n-  dtp->u.p.decimal_status\n-    = !(cf & IOPARM_DT_HAS_DECIMAL) ? DECIMAL_UNSPECIFIED :\n-      find_option (&dtp->common, dtp->decimal, dtp->decimal_len, decimal_opt,\n-\t\t   \"Bad DECIMAL parameter in data transfer statement\");\n+  /* To maintain ABI check these only if we have the F2003 flag set.  */\n+  if(cf & IOPARM_DT_HAS_F2003)\n+    {\n+      /* Check the decimal mode.  */\n+      dtp->u.p.decimal_status\n+\t= !(cf & IOPARM_DT_HAS_DECIMAL) ? DECIMAL_UNSPECIFIED :\n+\t  find_option (&dtp->common, dtp->u.p.decimal, dtp->u.p.decimal_len,\n+\t\t\tdecimal_opt, \"Bad DECIMAL parameter in data transfer \"\n+\t\t\t\"statement\");\n \n-  if (dtp->u.p.decimal_status == DECIMAL_UNSPECIFIED)\n-    dtp->u.p.decimal_status = dtp->u.p.current_unit->flags.decimal;\n+      if (dtp->u.p.decimal_status == DECIMAL_UNSPECIFIED)\n+\tdtp->u.p.decimal_status = dtp->u.p.current_unit->flags.decimal;\n \n-  /* Check the sign mode. */\n-  dtp->u.p.sign_status\n-    = !(cf & IOPARM_DT_HAS_SIGN) ? SIGN_UNSPECIFIED :\n-      find_option (&dtp->common, dtp->sign, dtp->sign_len, sign_opt,\n-\t\t   \"Bad SIGN parameter in data transfer statement\");\n+      /* Check the sign mode. */\n+      dtp->u.p.sign_status\n+\t= !(cf & IOPARM_DT_HAS_SIGN) ? SIGN_UNSPECIFIED :\n+\t  find_option (&dtp->common, dtp->u.p.sign, dtp->u.p.sign_len, sign_opt,\n+\t\t\t\"Bad SIGN parameter in data transfer statement\");\n   \n-  if (dtp->u.p.sign_status == SIGN_UNSPECIFIED)\n-    dtp->u.p.sign_status = dtp->u.p.current_unit->flags.sign;\n-\n-  /* Check the blank mode.  */\n-  dtp->u.p.blank_status\n-    = !(cf & IOPARM_DT_HAS_BLANK) ? BLANK_UNSPECIFIED :\n-      find_option (&dtp->common, dtp->blank, dtp->blank_len, blank_opt,\n-\t\t   \"Bad BLANK parameter in data transfer statement\");\n+      if (dtp->u.p.sign_status == SIGN_UNSPECIFIED)\n+\tdtp->u.p.sign_status = dtp->u.p.current_unit->flags.sign;\n+\n+      /* Check the blank mode.  */\n+      dtp->u.p.blank_status\n+\t= !(cf & IOPARM_DT_HAS_BLANK) ? BLANK_UNSPECIFIED :\n+\t  find_option (&dtp->common, dtp->u.p.blank, dtp->u.p.blank_len,\n+\t\t\tblank_opt,\n+\t\t\t\"Bad BLANK parameter in data transfer statement\");\n   \n-  if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n-    dtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n+      if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n+\tdtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n   \n-  /* Check the delim mode.  */\n-  dtp->u.p.delim_status\n-    = !(cf & IOPARM_DT_HAS_DELIM) ? DELIM_UNSPECIFIED :\n-      find_option (&dtp->common, dtp->delim, dtp->delim_len, delim_opt,\n-\t\t   \"Bad DELIM parameter in data transfer statement\");\n+      /* Check the delim mode.  */\n+      dtp->u.p.delim_status\n+\t= !(cf & IOPARM_DT_HAS_DELIM) ? DELIM_UNSPECIFIED :\n+\t  find_option (&dtp->common, dtp->u.p.delim, dtp->u.p.delim_len,\n+\t\t\tdelim_opt,\n+\t\t\t\"Bad DELIM parameter in data transfer statement\");\n   \n-  if (dtp->u.p.delim_status == DELIM_UNSPECIFIED)\n-    dtp->u.p.delim_status = dtp->u.p.current_unit->flags.delim;\n-\n-  /* Check the pad mode.  */\n-  dtp->u.p.pad_status\n-    = !(cf & IOPARM_DT_HAS_PAD) ? PAD_UNSPECIFIED :\n-      find_option (&dtp->common, dtp->pad, dtp->pad_len, pad_opt,\n-\t\t   \"Bad PAD parameter in data transfer statement\");\n+      if (dtp->u.p.delim_status == DELIM_UNSPECIFIED)\n+\tdtp->u.p.delim_status = dtp->u.p.current_unit->flags.delim;\n+\n+      /* Check the pad mode.  */\n+      dtp->u.p.pad_status\n+\t= !(cf & IOPARM_DT_HAS_PAD) ? PAD_UNSPECIFIED :\n+\t  find_option (&dtp->common, dtp->u.p.pad, dtp->u.p.pad_len, pad_opt,\n+\t\t\t\"Bad PAD parameter in data transfer statement\");\n   \n-  if (dtp->u.p.pad_status == PAD_UNSPECIFIED)\n-    dtp->u.p.pad_status = dtp->u.p.current_unit->flags.pad;\n- \n+      if (dtp->u.p.pad_status == PAD_UNSPECIFIED)\n+\tdtp->u.p.pad_status = dtp->u.p.current_unit->flags.pad;\n+    }\n+\n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n     {"}, {"sha": "121a9b19f2ea80e3a84650d20e071fdc5c071509", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -65,7 +65,8 @@ write_default_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n     }\n \n   /* Get ready to handle delimiters if needed.  */\n-\n+  d = ' ';\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n   switch (dtp->u.p.delim_status)\n     {\n     case DELIM_APOSTROPHE:\n@@ -128,7 +129,8 @@ write_utf8_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n     }\n \n   /* Get ready to handle delimiters if needed.  */\n-\n+  d = ' ';\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n   switch (dtp->u.p.delim_status)\n     {\n     case DELIM_APOSTROPHE:\n@@ -880,6 +882,8 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n   int i, extra;\n   char *p, d;\n \n+  d = ' ';\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n   switch (dtp->u.p.delim_status)\n     {\n     case DELIM_APOSTROPHE:\n@@ -1018,7 +1022,10 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int length, int d)\n static void\n write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)\n {\n-  char semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n+  char semi_comma = ',';\n+\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n \n   if (write_char (dtp, '('))\n     return;\n@@ -1065,9 +1072,17 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n     }\n   else\n     {\n-      if (type != BT_CHARACTER || !dtp->u.p.char_flag ||\n-\t  dtp->u.p.delim_status != DELIM_NONE)\n-\twrite_separator (dtp);\n+      if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t{\n+\t  if (type != BT_CHARACTER || !dtp->u.p.char_flag ||\n+\t      dtp->u.p.delim_status != DELIM_NONE)\n+\t    write_separator (dtp);\n+\t}\n+      else\n+\t{\n+          if (type != BT_CHARACTER || !dtp->u.p.char_flag)\n+\t    write_separator (dtp);\n+\t}\n     }\n \n   switch (type)\n@@ -1182,7 +1197,10 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   /* Set the character to be used to separate values\n      to a comma or semi-colon.  */\n \n-  char semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n+  char semi_comma = ',';\n+\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n \n   /* Write namelist variable names in upper case. If a derived type,\n      nothing is output.  If a component, base and base_name are set.  */\n@@ -1297,13 +1315,18 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n               break;\n \n \t    case GFC_DTYPE_CHARACTER:\n-\t      tmp_delim = dtp->u.p.delim_status;\n-\t      if (dtp->u.p.nml_delim == '\"')\n-\t\tdtp->u.p.delim_status = DELIM_QUOTE;\n-\t      if (dtp->u.p.nml_delim == '\\'')\n-\t\tdtp->u.p.delim_status = DELIM_APOSTROPHE;\n-\t      write_character (dtp, p, 1, obj->string_length);\n-\t      dtp->u.p.delim_status = tmp_delim;\n+\t      if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+\t\t{\n+\t\t  tmp_delim = dtp->u.p.delim_status;\n+\t\t  if (dtp->u.p.nml_delim == '\"')\n+\t\t    dtp->u.p.delim_status = DELIM_QUOTE;\n+\t\t  if (dtp->u.p.nml_delim == '\\'')\n+\t\t    dtp->u.p.delim_status = DELIM_APOSTROPHE;\n+\t\t  write_character (dtp, p, 1, obj->string_length);\n+\t\t  dtp->u.p.delim_status = tmp_delim;\n+\t\t}\n+\t      else\n+\t\twrite_character (dtp, p, 1, obj->string_length);\n               break;\n \n \t    case GFC_DTYPE_REAL:\n@@ -1438,10 +1461,11 @@ namelist_write (st_parameter_dt *dtp)\n   index_type dummy_offset = 0;\n   char c;\n   char * dummy_name = NULL;\n-  unit_delim tmp_delim;\n+  unit_delim tmp_delim = DELIM_UNSPECIFIED;\n \n   /* Set the delimiter for namelist output.  */\n-\n+if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+  {\n   tmp_delim = dtp->u.p.delim_status;\n   switch (tmp_delim)\n     {\n@@ -1460,7 +1484,7 @@ namelist_write (st_parameter_dt *dtp)\n \n   /* Temporarily disable namelist delimters.  */\n   dtp->u.p.delim_status = DELIM_NONE;\n-\n+  }\n   write_character (dtp, \"&\", 1, 1);\n \n   /* Write namelist name in upper case - f95 std.  */\n@@ -1483,7 +1507,8 @@ namelist_write (st_parameter_dt *dtp)\n   write_character (dtp, \"  /\", 1, 3);\n   namelist_write_newline (dtp);\n   /* Restore the original delimiter.  */\n-  dtp->u.p.delim_status = tmp_delim;\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    dtp->u.p.delim_status = tmp_delim;\n }\n \n #undef NML_DIGITS"}, {"sha": "d51c8ed7f525d6d9919561027b166e3c299492bb", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7445152be468cc8de1ea0a3ab6555448086e951/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=d7445152be468cc8de1ea0a3ab6555448086e951", "patch": "@@ -55,6 +55,7 @@ calculate_sign (st_parameter_dt *dtp, int negative_flag)\n \ts = S_NONE;\n \tbreak;\n       case SIGN_S:\t/* Processor defined. */\n+      case SIGN_UNSPECIFIED:\n \ts = options.optional_plus ? S_PLUS : S_NONE;\n \tbreak;\n       }\n@@ -403,7 +404,10 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       out += nbefore;\n     }\n   /* Output the decimal point.  */\n-  *(out++) = dtp->u.p.decimal_status == DECIMAL_POINT ? '.' : ',';\n+  if (dtp->common.flags & IOPARM_DT_HAS_F2003)\n+    *(out++) = dtp->u.p.decimal_status == DECIMAL_POINT ? '.' : ',';\n+  else\n+    *(out++) = '.';\n \n   /* Output leading zeros after the decimal point.  */\n   if (nzero > 0)"}]}