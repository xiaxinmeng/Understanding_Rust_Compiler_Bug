{"sha": "30ab6d9e435dd3158d971cf9353eec8009955cb3", "node_id": "C_kwDOANBUbNoAKDMwYWI2ZDllNDM1ZGQzMTU4ZDk3MWNmOTM1M2VlYzgwMDk5NTVjYjM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-03T00:21:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T09:36:09Z"}, "message": "libstdc++: Optimize std::variant traits and improve diagnostics\n\nBy defining additional partial specializations of _Nth_type we can\nreduce the number of recursive instantiations needed to get from N to 0.\nWe can also use _Nth_type in variant_alternative, to take advantage of\nthat new optimization.\n\nBy adding a static_assert to variant_alternative we get a nicer error\nthan 'invalid use of incomplete type'.\n\nBy defining partial specializations of std::variant_size_v for the\ncommon case we can avoid instantiating the std::variant_size class\ntemplate.\n\nThe __tuple_count class template and __tuple_count_v variable template\ncan be simplified to a single variable template, __count.\n\nBy adding a deleted constructor to the _Variant_union primary template\nwe can (very slightly) improve diagnostics for invalid attempts to\nconstruct a std::variant with an out-of-range index. Instead of a\nconfusing error about \"too many initializers for ...\" we get a call to a\ndeleted function.\n\nBy using _Nth_type instead of variant_alternative (for cv-unqualified\nvariant types) we avoid instantiating variant_alternative.\n\nBy adding deleted overloads of variant::emplace we get better\ndiagnostics for emplace<invalid-index> or emplace<invalid-type>. Instead\nof getting errors explaining why each of the four overloads wasn't\nvalid, we just get one error about calling a deleted function.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/variant (_Nth_type): Define partial\n\tspecializations to reduce number of instantiations.\n\t(variant_size_v): Define partial specializations to avoid\n\tinstantiations.\n\t(variant_alternative): Use _Nth_type. Add static assert.\n\t(__tuple_count, __tuple_count_v): Replace with ...\n\t(__count): New variable template.\n\t(_Variant_union): Add deleted constructor.\n\t(variant::__to_type): Use _Nth_type.\n\t(variant::emplace): Use _Nth_type. Add deleted overloads for\n\tinvalid types and indices.", "tree": {"sha": "a483e4c14e3171d5d69910e4e4941f6bcf041a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a483e4c14e3171d5d69910e4e4941f6bcf041a50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30ab6d9e435dd3158d971cf9353eec8009955cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ab6d9e435dd3158d971cf9353eec8009955cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ab6d9e435dd3158d971cf9353eec8009955cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ab6d9e435dd3158d971cf9353eec8009955cb3/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7551a9957437f20254be41d396962b9ccc46cee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551a9957437f20254be41d396962b9ccc46cee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7551a9957437f20254be41d396962b9ccc46cee6"}], "stats": {"total": 119, "additions": 78, "deletions": 41}, "files": [{"sha": "dc3d032c543a10715ea5b0782e32628ae925c8fc", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 78, "deletions": 41, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ab6d9e435dd3158d971cf9353eec8009955cb3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ab6d9e435dd3158d971cf9353eec8009955cb3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=30ab6d9e435dd3158d971cf9353eec8009955cb3", "patch": "@@ -61,13 +61,40 @@ namespace __variant\n   template<size_t _Np, typename... _Types>\n     struct _Nth_type;\n \n-  template<size_t _Np, typename _First, typename... _Rest>\n-    struct _Nth_type<_Np, _First, _Rest...>\n-    : _Nth_type<_Np-1, _Rest...> { };\n+  template<typename _Tp0, typename... _Rest>\n+    struct _Nth_type<0, _Tp0, _Rest...>\n+    { using type = _Tp0; };\n+\n+  template<typename _Tp0, typename _Tp1, typename... _Rest>\n+    struct _Nth_type<1, _Tp0, _Tp1, _Rest...>\n+    { using type = _Tp1; };\n+\n+  template<typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>\n+    struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...>\n+    { using type = _Tp2; };\n+\n+  template<size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2,\n+\t   typename... _Rest>\n+#if __cpp_concepts\n+    requires (_Np >= 3)\n+#endif\n+    struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...>\n+    : _Nth_type<_Np - 3, _Rest...>\n+    { };\n \n-  template<typename _First, typename... _Rest>\n-    struct _Nth_type<0, _First, _Rest...>\n-    { using type = _First; };\n+#if ! __cpp_concepts // Need additional specializations to avoid ambiguities.\n+  template<typename _Tp0, typename _Tp1, typename... _Rest>\n+    struct _Nth_type<0, _Tp0, _Tp1, _Rest...>\n+    { using type = _Tp0; };\n+\n+  template<typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>\n+    struct _Nth_type<0, _Tp0, _Tp1, _Tp2, _Rest...>\n+    { using type = _Tp0; };\n+\n+  template<typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>\n+    struct _Nth_type<1, _Tp0, _Tp1, _Tp2, _Rest...>\n+    { using type = _Tp1; };\n+#endif\n \n } // namespace __variant\n } // namespace __detail\n@@ -102,16 +129,25 @@ namespace __variant\n   template<typename _Variant>\n     inline constexpr size_t variant_size_v = variant_size<_Variant>::value;\n \n+  template<typename... _Types>\n+    inline constexpr size_t\n+    variant_size_v<variant<_Types...>> = sizeof...(_Types);\n+\n+  template<typename... _Types>\n+    inline constexpr size_t\n+    variant_size_v<const variant<_Types...>> = sizeof...(_Types);\n+\n   template<size_t _Np, typename _Variant>\n     struct variant_alternative;\n \n-  template<size_t _Np, typename _First, typename... _Rest>\n-    struct variant_alternative<_Np, variant<_First, _Rest...>>\n-    : variant_alternative<_Np-1, variant<_Rest...>> {};\n+  template<size_t _Np, typename... _Types>\n+    struct variant_alternative<_Np, variant<_Types...>>\n+    {\n+      static_assert(_Np < sizeof...(_Types));\n \n-  template<typename _First, typename... _Rest>\n-    struct variant_alternative<0, variant<_First, _Rest...>>\n-    { using type = _First; };\n+      using type\n+\t= typename __detail::__variant::_Nth_type<_Np, _Types...>::type;\n+    };\n \n   template<size_t _Np, typename _Variant>\n     using variant_alternative_t =\n@@ -390,7 +426,13 @@ namespace __variant\n \n   // Defines members and ctors.\n   template<typename... _Types>\n-    union _Variadic_union { };\n+    union _Variadic_union\n+    {\n+      _Variadic_union() = default;\n+\n+      template<size_t _Np, typename... _Args>\n+\t_Variadic_union(in_place_index_t<_Np>, _Args&&...) = delete;\n+    };\n \n   template<typename _First, typename... _Rest>\n     union _Variadic_union<_First, _Rest...>\n@@ -758,28 +800,21 @@ namespace __variant\n       _Variant_base& operator=(_Variant_base&&) = default;\n     };\n \n-  // For how many times does _Tp appear in _Tuple?\n-  template<typename _Tp, typename _Tuple>\n-    struct __tuple_count;\n+  // How many times does _Tp appear in _Types?\n+  template<typename _Tp, typename... _Types>\n+    inline constexpr size_t __count = 0;\n \n-  template<typename _Tp, typename _Tuple>\n-    inline constexpr size_t __tuple_count_v =\n-      __tuple_count<_Tp, _Tuple>::value;\n+  template<typename _Tp, typename _Up, typename... _Types>\n+    inline constexpr size_t __count<_Tp, _Up, _Types...>\n+      = __count<_Tp, _Types...>;\n \n   template<typename _Tp, typename... _Types>\n-    struct __tuple_count<_Tp, tuple<_Types...>>\n-    : integral_constant<size_t, 0> { };\n-\n-  template<typename _Tp, typename _First, typename... _Rest>\n-    struct __tuple_count<_Tp, tuple<_First, _Rest...>>\n-    : integral_constant<\n-\tsize_t,\n-\t__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };\n+    inline constexpr size_t __count<_Tp, _Tp, _Types...>\n+      = 1 + __count<_Tp, _Types...>;\n \n   // TODO: Reuse this in <tuple> ?\n   template<typename _Tp, typename... _Types>\n-    inline constexpr bool __exactly_once =\n-      __tuple_count_v<_Tp, tuple<_Types...>> == 1;\n+    inline constexpr bool __exactly_once = __count<_Tp, _Types...> == 1;\n \n   // Helper used to check for valid conversions that don't involve narrowing.\n   template<typename _Ti> struct _Arr { _Ti _M_x[1]; };\n@@ -1411,7 +1446,8 @@ namespace __variant\n \t  = __detail::__variant::__accepted_index<_Tp, variant>::value;\n \n       template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>\n-\tusing __to_type = variant_alternative_t<_Np, variant>;\n+\tusing __to_type\n+\t  = typename __detail::__variant::_Nth_type<_Np, _Types...>::type;\n \n       template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>\n \tusing __accepted_type = __to_type<__accepted_index<_Tp>>;\n@@ -1543,15 +1579,12 @@ namespace __variant\n \n       template<size_t _Np, typename... _Args>\n \t_GLIBCXX20_CONSTEXPR\n-\tenable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,\n-\t\t\t\t       _Args...>,\n-\t\t    variant_alternative_t<_Np, variant>&>\n+\tenable_if_t<is_constructible_v<__to_type<_Np>, _Args...>,\n+\t\t    __to_type<_Np>&>\n \templace(_Args&&... __args)\n \t{\n-\t  static_assert(_Np < sizeof...(_Types),\n-\t\t\t\"The index must be in [0, number of alternatives)\");\n-\t  using type = variant_alternative_t<_Np, variant>;\n \t  namespace __variant = std::__detail::__variant;\n+\t  using type = typename __variant::_Nth_type<_Np, _Types...>::type;\n \t  // Provide the strong exception-safety guarantee when possible,\n \t  // to avoid becoming valueless.\n \t  if constexpr (is_nothrow_constructible_v<type, _Args...>)\n@@ -1590,15 +1623,13 @@ namespace __variant\n \n       template<size_t _Np, typename _Up, typename... _Args>\n \t_GLIBCXX20_CONSTEXPR\n-\tenable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,\n+\tenable_if_t<is_constructible_v<__to_type<_Np>,\n \t\t\t\t       initializer_list<_Up>&, _Args...>,\n-\t\t    variant_alternative_t<_Np, variant>&>\n+\t\t    __to_type<_Np>&>\n \templace(initializer_list<_Up> __il, _Args&&... __args)\n \t{\n-\t  static_assert(_Np < sizeof...(_Types),\n-\t\t\t\"The index must be in [0, number of alternatives)\");\n-\t  using type = variant_alternative_t<_Np, variant>;\n \t  namespace __variant = std::__detail::__variant;\n+\t  using type = typename __variant::_Nth_type<_Np, _Types...>::type;\n \t  // Provide the strong exception-safety guarantee when possible,\n \t  // to avoid becoming valueless.\n \t  if constexpr (is_nothrow_constructible_v<type,\n@@ -1629,6 +1660,12 @@ namespace __variant\n \t  return std::get<_Np>(*this);\n \t}\n \n+      template<size_t _Np, typename... _Args>\n+\tenable_if_t<!(_Np < sizeof...(_Types))> emplace(_Args&&...) = delete;\n+\n+      template<typename _Tp, typename... _Args>\n+\tenable_if_t<!__exactly_once<_Tp>> emplace(_Args&&...) = delete;\n+\n       constexpr bool valueless_by_exception() const noexcept\n       { return !this->_M_valid(); }\n "}]}