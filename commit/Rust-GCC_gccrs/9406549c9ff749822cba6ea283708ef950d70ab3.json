{"sha": "9406549c9ff749822cba6ea283708ef950d70ab3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwNjU0OWM5ZmY3NDk4MjJjYmE2ZWEyODM3MDhlZjk1MGQ3MGFiMw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2006-11-25T16:57:25Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-11-25T16:57:25Z"}, "message": "re PR fortran/29711 ([4.2 only] error_print does not support %N$X)\n\n\tPR fortran/29711\n\t* error.c (error_print): Handle printf-style position specifiers,\n\tof the form \"%3$d\".\n\nFrom-SVN: r119203", "tree": {"sha": "04590d6c38afbb73f6710350658f83bf681c0c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04590d6c38afbb73f6710350658f83bf681c0c4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9406549c9ff749822cba6ea283708ef950d70ab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9406549c9ff749822cba6ea283708ef950d70ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9406549c9ff749822cba6ea283708ef950d70ab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9406549c9ff749822cba6ea283708ef950d70ab3/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786f159e2721fce2f240202cfbe99639e272e95e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786f159e2721fce2f240202cfbe99639e272e95e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786f159e2721fce2f240202cfbe99639e272e95e"}], "stats": {"total": 202, "additions": 145, "deletions": 57}, "files": [{"sha": "86710de22486ac4a8cff2ef7b07918f36ac07068", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9406549c9ff749822cba6ea283708ef950d70ab3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9406549c9ff749822cba6ea283708ef950d70ab3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9406549c9ff749822cba6ea283708ef950d70ab3", "patch": "@@ -1,3 +1,9 @@\n+2006-11-25  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/29711\n+\t* error.c (error_print): Handle printf-style position specifiers,\n+\tof the form \"%3$d\".\n+\n 2006-11-24  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/20880"}, {"sha": "d92fd82004b1b702cc38494e9871dbb00545f946", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 139, "deletions": 57, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9406549c9ff749822cba6ea283708ef950d70ab3/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9406549c9ff749822cba6ea283708ef950d70ab3/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=9406549c9ff749822cba6ea283708ef950d70ab3", "patch": "@@ -378,69 +378,150 @@ show_loci (locus * l1, locus * l2)\n static void ATTRIBUTE_GCC_GFC(2,0)\n error_print (const char *type, const char *format0, va_list argp)\n {\n-  char c, c_arg[MAX_ARGS], *cp_arg[MAX_ARGS];\n-  int n, have_l1, i_arg[MAX_ARGS];\n+  enum { TYPE_CURRENTLOC, TYPE_LOCUS, TYPE_INTEGER, TYPE_CHAR, TYPE_STRING,\n+\t NOTYPE };\n+  struct\n+  {\n+    int type;\n+    int pos;\n+    union\n+    {\n+      int intval;\n+      char charval;\n+      const char * stringval;\n+    } u;\n+  } arg[MAX_ARGS], spec[MAX_ARGS];\n+  /* spec is the array of specifiers, in the same order as they\n+     appear in the format string.  arg is the array of arguments,\n+     in the same order as they appear in the va_list.  */\n+\n+  char c;\n+  int i, n, have_l1, pos, maxpos;\n   locus *l1, *l2, *loc;\n   const char *format;\n \n-  l1 = l2 = loc = NULL;\n+  l1 = l2 = NULL;\n \n   have_l1 = 0;\n+  pos = -1;\n+  maxpos = -1;\n \n   n = 0;\n   format = format0;\n \n+  for (i = 0; i < MAX_ARGS; i++)\n+    {\n+      arg[i].type = NOTYPE;\n+      spec[i].pos = -1;\n+    }\n+\n+  /* First parse the format string for position specifiers.  */\n   while (*format)\n     {\n       c = *format++;\n-      if (c == '%')\n+      if (c != '%')\n+\tcontinue;\n+\n+      if (*format == '%')\n+\tcontinue;\n+\n+      if (ISDIGIT (*format))\n \t{\n-\t  c = *format++;\n+\t  /* This is a position specifier.  For example, the number\n+\t     12 in the format string \"%12$d\", which specifies the third\n+\t     argument of the va_list, formatted in %d format.\n+\t     For details, see \"man 3 printf\".  */\n+\t  pos = atoi(format) - 1;\n+\t  gcc_assert (pos >= 0);\n+\t  while (ISDIGIT(*format))\n+\t    format++;\n+\t  gcc_assert (*format++ == '$');\n+\t}\n+      else\n+\tpos++;\n \n-\t  switch (c)\n-\t    {\n-\t    case '%':\n-\t      break;\n+      c = *format++;\n+\n+      if (pos > maxpos)\n+\tmaxpos = pos;\n+\n+      switch (c)\n+\t{\n+\t  case 'C':\n+\t    arg[pos].type = TYPE_CURRENTLOC;\n+\t    break;\n+\n+\t  case 'L':\n+\t    arg[pos].type = TYPE_LOCUS;\n+\t    break;\n+\n+\t  case 'd':\n+\t  case 'i':\n+\t    arg[pos].type = TYPE_INTEGER;\n+\t    break;\n+\n+\t  case 'c':\n+\t    arg[pos].type = TYPE_CHAR;\n+\t    break;\n+\n+\t  case 's':\n+\t    arg[pos].type = TYPE_STRING;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+\n+      spec[n++].pos = pos;\n+    }\n+\n+  /* Then convert the values for each %-style argument.  */\n+  for (pos = 0; pos <= maxpos; pos++)\n+    {\n+      gcc_assert (arg[pos].type != NOTYPE);\n+      switch (arg[pos].type)\n+\t{\n+\t  case TYPE_CURRENTLOC:\n+\t    loc = &gfc_current_locus;\n+\t    /* Fall through.  */\n \n-\t    case 'L':\n+\t  case TYPE_LOCUS:\n+\t    if (arg[pos].type == TYPE_LOCUS)\n \t      loc = va_arg (argp, locus *);\n-\t      /* Fall through */\n-\n-\t    case 'C':\n-\t      if (c == 'C')\n-\t\tloc = &gfc_current_locus;\n-\n-\t      if (have_l1)\n-\t\t{\n-\t\t  l2 = loc;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  l1 = loc;\n-\t\t  have_l1 = 1;\n-\t\t}\n-\t      break;\n-\n-\t    case 'd':\n-\t    case 'i':\n-\t      i_arg[n++] = va_arg (argp, int);\n-\t      break;\n-\n-\t    case 'c':\n-\t      c_arg[n++] = va_arg (argp, int);\n-\t      break;\n-\n-\t    case 's':\n-\t      cp_arg[n++] = va_arg (argp, char *);\n-\t      break;\n-\n-\t    case '\\0':\n-\t      format--;\n-\t      break;\n-\t    }\n+\n+\t    if (have_l1)\n+\t      {\n+\t\tl2 = loc;\n+\t\targ[pos].u.stringval = \"(2)\";\n+\t      }\n+\t    else\n+\t      {\n+\t\tl1 = loc;\n+\t\thave_l1 = 1;\n+\t\targ[pos].u.stringval = \"(1)\";\n+\t      }\n+\t    break;\n+\n+\t  case TYPE_INTEGER:\n+\t    arg[pos].u.intval = va_arg (argp, int);\n+\t    break;\n+\n+\t  case TYPE_CHAR:\n+\t    arg[pos].u.charval = (char) va_arg (argp, int);\n+\t    break;\n+\n+\t  case TYPE_STRING:\n+\t    arg[pos].u.stringval = (const char *) va_arg (argp, char *);\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n \t}\n     }\n \n+  for (n = 0; spec[n].pos >= 0; n++)\n+    spec[n].u = arg[spec[n].pos].u;\n+\n   /* Show the current loci if we have to.  */\n   if (have_l1)\n     show_loci (l1, l2);\n@@ -464,33 +545,34 @@ error_print (const char *type, const char *format0, va_list argp)\n \t}\n \n       format++;\n+      if (ISDIGIT(*format))\n+\t{\n+\t  /* This is a position specifier.  See comment above.  */\n+\t  while (ISDIGIT(*format))\n+\t    \n+\t  /* Skip over the dollar sign.  */\n+\t  format++;\n+\t}\n+\t\n       switch (*format)\n \t{\n \tcase '%':\n \t  error_char ('%');\n \t  break;\n \n \tcase 'c':\n-\t  error_char (c_arg[n++]);\n+\t  error_char (spec[n++].u.charval);\n \t  break;\n \n \tcase 's':\n-\t  error_string (cp_arg[n++]);\n-\t  break;\n-\n-\tcase 'd':\n-\tcase 'i':\n-\t  error_integer (i_arg[n++]);\n-\t  break;\n-\n \tcase 'C':\t\t/* Current locus */\n \tcase 'L':\t\t/* Specified locus */\n-\t  error_string (have_l1 ? \"(2)\" : \"(1)\");\n-\t  have_l1 = 1;\n+\t  error_string (spec[n++].u.stringval);\n \t  break;\n \n-\tcase '\\0':\n-\t  format--;\n+\tcase 'd':\n+\tcase 'i':\n+\t  error_integer (spec[n++].u.intval);\n \t  break;\n \t}\n     }"}]}