{"sha": "9bdae6af0e9d0e9825c5df7b3754f9d815a657f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJkYWU2YWYwZTlkMGU5ODI1YzVkZjdiMzc1NGY5ZDgxNWE2NTdmOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-04T02:50:36Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-04T02:50:36Z"}, "message": "fold-const.c (fold_ternary): New.\n\n\t* fold-const.c (fold_ternary): New.\n\t(fold): Call fold_ternary on ternary expressions.  Remove\n\thandling of ternary expressions.\n\nFrom-SVN: r95871", "tree": {"sha": "ac36c67988b94f5127c60f965c9b9c5dc3352cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac36c67988b94f5127c60f965c9b9c5dc3352cec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9/comments", "author": null, "committer": null, "parents": [{"sha": "8d06c80914d7374d16887b0e817eadb41d898aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d06c80914d7374d16887b0e817eadb41d898aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d06c80914d7374d16887b0e817eadb41d898aa8"}], "stats": {"total": 432, "additions": 247, "deletions": 185}, "files": [{"sha": "23672a3486cd93979f089886edab1a909e924c94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bdae6af0e9d0e9825c5df7b3754f9d815a657f9", "patch": "@@ -1,3 +1,9 @@\n+2005-03-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c (fold_ternary): New.\n+\t(fold): Call fold_ternary on ternary expressions.  Remove\n+\thandling of ternary expressions.\n+\n 2005-03-03  James A. Morrison  <phython@gcc.gnu.org>\n \n \tPR tree-optimization/15784"}, {"sha": "c494d4f846091bd0e3c8aa7d6578c0b1e9b825db", "filename": "gcc/fold-const.c", "status": "modified", "additions": 241, "deletions": 185, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdae6af0e9d0e9825c5df7b3754f9d815a657f9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9bdae6af0e9d0e9825c5df7b3754f9d815a657f9", "patch": "@@ -7014,6 +7014,245 @@ fold_unary (tree expr)\n     } /* switch (code) */\n }\n \n+/* Fold a ternary expression EXPR.  Return the folded expression if\n+   folding is successful.  Otherwise, return the original\n+   expression.  */\n+\n+static tree\n+fold_ternary (tree expr)\n+{\n+  const tree t = expr;\n+  const tree type = TREE_TYPE (expr);\n+  tree tem;\n+  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n+  enum tree_code code = TREE_CODE (t);\n+  enum tree_code_class kind = TREE_CODE_CLASS (code);\n+  int i;\n+\n+  gcc_assert (IS_EXPR_CODE_CLASS (kind)\n+\t      && TREE_CODE_LENGTH (code) == 3);\n+\n+  /* For now, we iterate only twice even though we are handling\n+     ternary expressions.  This is because we haven't defined arg2\n+     yet.  */\n+  for (i = 0; i < 2; i++)\n+    {\n+      tree op = TREE_OPERAND (t, i);\n+\n+      if (op == 0)\n+\tcontinue;\t\t/* Valid for CALL_EXPR, at least.  */\n+\n+      /* Strip any conversions that don't change the mode.  This is\n+\t safe for every expression, except for a comparison expression\n+\t because its signedness is derived from its operands.  So, in\n+\t the latter case, only strip conversions that don't change the\n+\t signedness.\n+\n+\t Note that this is done as an internal manipulation within the\n+\t constant folder, in order to find the simplest representation\n+\t of the arguments so that their form can be studied.  In any\n+\t cases, the appropriate type conversions should be put back in\n+\t the tree that will get out of the constant folder.  */\n+      STRIP_NOPS (op);\n+\n+      if (i == 0)\n+\targ0 = op;\n+      else if (i == 1)\n+\targ1 = op;\n+    }\n+\n+  switch (code)\n+    {\n+    case COMPONENT_REF:\n+      if (TREE_CODE (arg0) == CONSTRUCTOR\n+\t  && ! type_contains_placeholder_p (TREE_TYPE (arg0)))\n+\t{\n+\t  tree m = purpose_member (arg1, CONSTRUCTOR_ELTS (arg0));\n+\t  if (m)\n+\t    return TREE_VALUE (m);\n+\t}\n+      return t;\n+\n+    case COND_EXPR:\n+      /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n+\t so all simple results must be passed through pedantic_non_lvalue.  */\n+      if (TREE_CODE (arg0) == INTEGER_CST)\n+\t{\n+\t  tem = TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1));\n+\t  /* Only optimize constant conditions when the selected branch\n+\t     has the same type as the COND_EXPR.  This avoids optimizing\n+\t     away \"c ? x : throw\", where the throw has a void type.  */\n+\t  if (! VOID_TYPE_P (TREE_TYPE (tem))\n+\t      || VOID_TYPE_P (type))\n+\t    return pedantic_non_lvalue (tem);\n+\t  return t;\n+\t}\n+      if (operand_equal_p (arg1, TREE_OPERAND (t, 2), 0))\n+\treturn pedantic_omit_one_operand (type, arg1, arg0);\n+\n+      /* If we have A op B ? A : C, we may be able to convert this to a\n+\t simpler expression, depending on the operation and the values\n+\t of B and C.  Signed zeros prevent all of these transformations,\n+\t for reasons given above each one.\n+\n+         Also try swapping the arguments and inverting the conditional.  */\n+      if (COMPARISON_CLASS_P (arg0)\n+\t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n+\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t{\n+\t  tem = fold_cond_expr_with_comparison (type, arg0,\n+\t\t\t\t\t\tTREE_OPERAND (t, 1),\n+\t\t\t\t\t\tTREE_OPERAND (t, 2));\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n+      if (COMPARISON_CLASS_P (arg0)\n+\t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     TREE_OPERAND (t, 2),\n+\t\t\t\t\t     TREE_OPERAND (arg0, 1))\n+\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 2)))))\n+\t{\n+\t  tem = invert_truthvalue (arg0);\n+\t  if (COMPARISON_CLASS_P (tem))\n+\t    {\n+\t      tem = fold_cond_expr_with_comparison (type, tem,\n+\t\t\t\t\t\t    TREE_OPERAND (t, 2),\n+\t\t\t\t\t\t    TREE_OPERAND (t, 1));\n+\t      if (tem)\n+\t\treturn tem;\n+\t    }\n+\t}\n+\n+      /* If the second operand is simpler than the third, swap them\n+\t since that produces better jump optimization results.  */\n+      if (tree_swap_operands_p (TREE_OPERAND (t, 1),\n+\t\t\t\tTREE_OPERAND (t, 2), false))\n+\t{\n+\t  /* See if this can be inverted.  If it can't, possibly because\n+\t     it was a floating-point inequality comparison, don't do\n+\t     anything.  */\n+\t  tem = invert_truthvalue (arg0);\n+\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    return fold (build3 (code, type, tem,\n+\t\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1)));\n+\t}\n+\n+      /* Convert A ? 1 : 0 to simply A.  */\n+      if (integer_onep (TREE_OPERAND (t, 1))\n+\t  && integer_zerop (TREE_OPERAND (t, 2))\n+\t  /* If we try to convert TREE_OPERAND (t, 0) to our type, the\n+\t     call to fold will try to move the conversion inside\n+\t     a COND, which will recurse.  In that case, the COND_EXPR\n+\t     is probably the best choice, so leave it alone.  */\n+\t  && type == TREE_TYPE (arg0))\n+\treturn pedantic_non_lvalue (arg0);\n+\n+      /* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR\n+\t over COND_EXPR in cases such as floating point comparisons.  */\n+      if (integer_zerop (TREE_OPERAND (t, 1))\n+\t  && integer_onep (TREE_OPERAND (t, 2))\n+\t  && truth_value_p (TREE_CODE (arg0)))\n+\treturn pedantic_non_lvalue (fold_convert (type,\n+\t\t\t\t\t\t  invert_truthvalue (arg0)));\n+\n+      /* A < 0 ? <sign bit of A> : 0 is simply (A & <sign bit of A>).  */\n+      if (TREE_CODE (arg0) == LT_EXPR\n+          && integer_zerop (TREE_OPERAND (arg0, 1))\n+          && integer_zerop (TREE_OPERAND (t, 2))\n+          && (tem = sign_bit_p (TREE_OPERAND (arg0, 0), arg1)))\n+        return fold_convert (type, fold (build2 (BIT_AND_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (tem), tem, arg1)));\n+\n+      /* (A >> N) & 1 ? (1 << N) : 0 is simply A & (1 << N).  A & 1 was\n+\t already handled above.  */\n+      if (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && integer_onep (TREE_OPERAND (arg0, 1))\n+\t  && integer_zerop (TREE_OPERAND (t, 2))\n+\t  && integer_pow2p (arg1))\n+\t{\n+\t  tree tem = TREE_OPERAND (arg0, 0);\n+\t  STRIP_NOPS (tem);\n+\t  if (TREE_CODE (tem) == RSHIFT_EXPR\n+              && TREE_CODE (TREE_OPERAND (tem, 1)) == INTEGER_CST\n+              && (unsigned HOST_WIDE_INT) tree_log2 (arg1) ==\n+\t         TREE_INT_CST_LOW (TREE_OPERAND (tem, 1)))\n+\t    return fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t\t TREE_OPERAND (tem, 0), arg1));\n+\t}\n+\n+      /* A & N ? N : 0 is simply A & N if N is a power of two.  This\n+\t is probably obsolete because the first operand should be a\n+\t truth value (that's why we have the two cases above), but let's\n+\t leave it in until we can confirm this for all front-ends.  */\n+      if (integer_zerop (TREE_OPERAND (t, 2))\n+\t  && TREE_CODE (arg0) == NE_EXPR\n+\t  && integer_zerop (TREE_OPERAND (arg0, 1))\n+\t  && integer_pow2p (arg1)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),\n+\t\t\t      arg1, OEP_ONLY_CONST))\n+\treturn pedantic_non_lvalue (fold_convert (type,\n+\t\t\t\t\t\t  TREE_OPERAND (arg0, 0)));\n+\n+      /* Convert A ? B : 0 into A && B if A and B are truth values.  */\n+      if (integer_zerop (TREE_OPERAND (t, 2))\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (arg1)))\n+\treturn fold (build2 (TRUTH_ANDIF_EXPR, type, arg0, arg1));\n+\n+      /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n+      if (integer_onep (TREE_OPERAND (t, 2))\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (arg1)))\n+\t{\n+\t  /* Only perform transformation if ARG0 is easily inverted.  */\n+\t  tem = invert_truthvalue (arg0);\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    return fold (build2 (TRUTH_ORIF_EXPR, type, tem, arg1));\n+\t}\n+\n+      /* Convert A ? 0 : B into !A && B if A and B are truth values.  */\n+      if (integer_zerop (arg1)\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n+\t{\n+\t  /* Only perform transformation if ARG0 is easily inverted.  */\n+\t  tem = invert_truthvalue (arg0);\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    return fold (build2 (TRUTH_ANDIF_EXPR, type, tem,\n+\t\t\t\t TREE_OPERAND (t, 2)));\n+\t}\n+\n+      /* Convert A ? 1 : B into A || B if A and B are truth values.  */\n+      if (integer_onep (arg1)\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n+\treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0,\n+\t\t\t     TREE_OPERAND (t, 2)));\n+\n+      return t;\n+\n+    case CALL_EXPR:\n+      /* Check for a built-in function.  */\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0))\n+\t      == FUNCTION_DECL)\n+\t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n+\t{\n+\t  tree tmp = fold_builtin (t, false);\n+\t  if (tmp)\n+\t    return tmp;\n+\t}\n+      return t;\n+\n+    default:\n+      return t;\n+    } /* switch (code) */\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -7052,6 +7291,8 @@ fold (tree expr)\n \t{\n \tcase 1:\n \t  return fold_unary (expr);\n+\tcase 3:\n+\t  return fold_ternary (expr);\n \tdefault:\n \t  break;\n \t}\n@@ -7195,16 +7436,6 @@ fold (tree expr)\n     case CONST_DECL:\n       return fold (DECL_INITIAL (t));\n \n-    case COMPONENT_REF:\n-      if (TREE_CODE (arg0) == CONSTRUCTOR\n-\t  && ! type_contains_placeholder_p (TREE_TYPE (arg0)))\n-\t{\n-\t  tree m = purpose_member (arg1, CONSTRUCTOR_ELTS (arg0));\n-\t  if (m)\n-\t    return TREE_VALUE (m);\n-\t}\n-      return t;\n-\n     case RANGE_EXPR:\n       if (TREE_CONSTANT (t) != wins)\n \t{\n@@ -9662,168 +9893,6 @@ fold (tree expr)\n \n       return t;\n \n-    case COND_EXPR:\n-      /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n-\t so all simple results must be passed through pedantic_non_lvalue.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST)\n-\t{\n-\t  tem = TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1));\n-\t  /* Only optimize constant conditions when the selected branch\n-\t     has the same type as the COND_EXPR.  This avoids optimizing\n-\t     away \"c ? x : throw\", where the throw has a void type.  */\n-\t  if (! VOID_TYPE_P (TREE_TYPE (tem))\n-\t      || VOID_TYPE_P (type))\n-\t    return pedantic_non_lvalue (tem);\n-\t  return t;\n-\t}\n-      if (operand_equal_p (arg1, TREE_OPERAND (t, 2), 0))\n-\treturn pedantic_omit_one_operand (type, arg1, arg0);\n-\n-      /* If we have A op B ? A : C, we may be able to convert this to a\n-\t simpler expression, depending on the operation and the values\n-\t of B and C.  Signed zeros prevent all of these transformations,\n-\t for reasons given above each one.\n-\n-         Also try swapping the arguments and inverting the conditional.  */\n-      if (COMPARISON_CLASS_P (arg0)\n-\t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t{\n-\t  tem = fold_cond_expr_with_comparison (type, arg0,\n-\t\t\t\t\t\tTREE_OPERAND (t, 1),\n-\t\t\t\t\t\tTREE_OPERAND (t, 2));\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      if (COMPARISON_CLASS_P (arg0)\n-\t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     TREE_OPERAND (t, 2),\n-\t\t\t\t\t     TREE_OPERAND (arg0, 1))\n-\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 2)))))\n-\t{\n-\t  tem = invert_truthvalue (arg0);\n-\t  if (COMPARISON_CLASS_P (tem))\n-\t    {\n-\t      tem = fold_cond_expr_with_comparison (type, tem,\n-\t\t\t\t\t\t    TREE_OPERAND (t, 2),\n-\t\t\t\t\t\t    TREE_OPERAND (t, 1));\n-\t      if (tem)\n-\t\treturn tem;\n-\t    }\n-\t}\n-\n-      /* If the second operand is simpler than the third, swap them\n-\t since that produces better jump optimization results.  */\n-      if (tree_swap_operands_p (TREE_OPERAND (t, 1),\n-\t\t\t\tTREE_OPERAND (t, 2), false))\n-\t{\n-\t  /* See if this can be inverted.  If it can't, possibly because\n-\t     it was a floating-point inequality comparison, don't do\n-\t     anything.  */\n-\t  tem = invert_truthvalue (arg0);\n-\n-\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build3 (code, type, tem,\n-\t\t\t\t TREE_OPERAND (t, 2), TREE_OPERAND (t, 1)));\n-\t}\n-\n-      /* Convert A ? 1 : 0 to simply A.  */\n-      if (integer_onep (TREE_OPERAND (t, 1))\n-\t  && integer_zerop (TREE_OPERAND (t, 2))\n-\t  /* If we try to convert TREE_OPERAND (t, 0) to our type, the\n-\t     call to fold will try to move the conversion inside\n-\t     a COND, which will recurse.  In that case, the COND_EXPR\n-\t     is probably the best choice, so leave it alone.  */\n-\t  && type == TREE_TYPE (arg0))\n-\treturn pedantic_non_lvalue (arg0);\n-\n-      /* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR\n-\t over COND_EXPR in cases such as floating point comparisons.  */\n-      if (integer_zerop (TREE_OPERAND (t, 1))\n-\t  && integer_onep (TREE_OPERAND (t, 2))\n-\t  && truth_value_p (TREE_CODE (arg0)))\n-\treturn pedantic_non_lvalue (fold_convert (type,\n-\t\t\t\t\t\t  invert_truthvalue (arg0)));\n-\n-      /* A < 0 ? <sign bit of A> : 0 is simply (A & <sign bit of A>).  */\n-      if (TREE_CODE (arg0) == LT_EXPR\n-          && integer_zerop (TREE_OPERAND (arg0, 1))\n-          && integer_zerop (TREE_OPERAND (t, 2))\n-          && (tem = sign_bit_p (TREE_OPERAND (arg0, 0), arg1)))\n-        return fold_convert (type, fold (build2 (BIT_AND_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (tem), tem, arg1)));\n-\n-      /* (A >> N) & 1 ? (1 << N) : 0 is simply A & (1 << N).  A & 1 was\n-\t already handled above.  */\n-      if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_onep (TREE_OPERAND (arg0, 1))\n-\t  && integer_zerop (TREE_OPERAND (t, 2))\n-\t  && integer_pow2p (arg1))\n-\t{\n-\t  tree tem = TREE_OPERAND (arg0, 0);\n-\t  STRIP_NOPS (tem);\n-\t  if (TREE_CODE (tem) == RSHIFT_EXPR\n-              && TREE_CODE (TREE_OPERAND (tem, 1)) == INTEGER_CST\n-              && (unsigned HOST_WIDE_INT) tree_log2 (arg1) ==\n-\t         TREE_INT_CST_LOW (TREE_OPERAND (tem, 1)))\n-\t    return fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t TREE_OPERAND (tem, 0), arg1));\n-\t}\n-\n-      /* A & N ? N : 0 is simply A & N if N is a power of two.  This\n-\t is probably obsolete because the first operand should be a\n-\t truth value (that's why we have the two cases above), but let's\n-\t leave it in until we can confirm this for all front-ends.  */\n-      if (integer_zerop (TREE_OPERAND (t, 2))\n-\t  && TREE_CODE (arg0) == NE_EXPR\n-\t  && integer_zerop (TREE_OPERAND (arg0, 1))\n-\t  && integer_pow2p (arg1)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),\n-\t\t\t      arg1, OEP_ONLY_CONST))\n-\treturn pedantic_non_lvalue (fold_convert (type,\n-\t\t\t\t\t\t  TREE_OPERAND (arg0, 0)));\n-\n-      /* Convert A ? B : 0 into A && B if A and B are truth values.  */\n-      if (integer_zerop (TREE_OPERAND (t, 2))\n-\t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (arg1)))\n-\treturn fold (build2 (TRUTH_ANDIF_EXPR, type, arg0, arg1));\n-\n-      /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n-      if (integer_onep (TREE_OPERAND (t, 2))\n-\t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (arg1)))\n-\t{\n-\t  /* Only perform transformation if ARG0 is easily inverted.  */\n-\t  tem = invert_truthvalue (arg0);\n-\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build2 (TRUTH_ORIF_EXPR, type, tem, arg1));\n-\t}\n-\n-      /* Convert A ? 0 : B into !A && B if A and B are truth values.  */\n-      if (integer_zerop (arg1)\n-\t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n-\t{\n-\t  /* Only perform transformation if ARG0 is easily inverted.  */\n-\t  tem = invert_truthvalue (arg0);\n-\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n-\t    return fold (build2 (TRUTH_ANDIF_EXPR, type, tem,\n-\t\t\t\t TREE_OPERAND (t, 2)));\n-\t}\n-\n-      /* Convert A ? 1 : B into A || B if A and B are truth values.  */\n-      if (integer_onep (arg1)\n-\t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (TREE_OPERAND (t, 2))))\n-\treturn fold (build2 (TRUTH_ORIF_EXPR, type, arg0,\n-\t\t\t     TREE_OPERAND (t, 2)));\n-\n-      return t;\n-\n     case COMPOUND_EXPR:\n       /* When pedantic, a compound expression can be neither an lvalue\n \t nor an integer constant expression.  */\n@@ -9839,19 +9908,6 @@ fold (tree expr)\n \treturn build_complex (type, arg0, arg1);\n       return t;\n \n-    case CALL_EXPR:\n-      /* Check for a built-in function.  */\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0))\n-\t      == FUNCTION_DECL)\n-\t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t{\n-\t  tree tmp = fold_builtin (t, false);\n-\t  if (tmp)\n-\t    return tmp;\n-\t}\n-      return t;\n-\n     default:\n       return t;\n     } /* switch (code) */"}]}