{"sha": "fe77e0edabfa7bc64a0ba2c60be5e682080d1085", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU3N2UwZWRhYmZhN2JjNjRhMGJhMmM2MGJlNWU2ODIwODBkMTA4NQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-11-06T17:58:52Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-11-06T17:58:52Z"}, "message": "re PR debug/54693 (VTA guality issues with loops)\n\nPR debug/54693\n* tree-ssa-threadedge.c (propagate_threaded_block_debug_into):\nUse a stack vector before allocating a pointer set.\n\nFrom-SVN: r193251", "tree": {"sha": "ef410051862cb9d64b92619b81d335b0835178ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef410051862cb9d64b92619b81d335b0835178ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe77e0edabfa7bc64a0ba2c60be5e682080d1085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe77e0edabfa7bc64a0ba2c60be5e682080d1085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe77e0edabfa7bc64a0ba2c60be5e682080d1085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe77e0edabfa7bc64a0ba2c60be5e682080d1085/comments", "author": null, "committer": null, "parents": [{"sha": "d044dd177fb67db8cf20c986c0431b42be1aa71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d044dd177fb67db8cf20c986c0431b42be1aa71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d044dd177fb67db8cf20c986c0431b42be1aa71d"}], "stats": {"total": 71, "additions": 66, "deletions": 5}, "files": [{"sha": "68acc46214d7ab140b22096b4666107c3e364947", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77e0edabfa7bc64a0ba2c60be5e682080d1085/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77e0edabfa7bc64a0ba2c60be5e682080d1085/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe77e0edabfa7bc64a0ba2c60be5e682080d1085", "patch": "@@ -1,3 +1,9 @@\n+2012-11-06  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/54693\n+\t* tree-ssa-threadedge.c (propagate_threaded_block_debug_into):\n+\tUse a stack vector before allocating a pointer set.\n+\n 2012-11-06  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.c (ipa_get_param_decl_index_1): New function."}, {"sha": "76b91b7907e8877917eb1fa188a2d9f9680445ae", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe77e0edabfa7bc64a0ba2c60be5e682080d1085/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe77e0edabfa7bc64a0ba2c60be5e682080d1085/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=fe77e0edabfa7bc64a0ba2c60be5e682080d1085", "patch": "@@ -610,6 +610,10 @@ cond_arg_set_in_bb (edge e, basic_block bb)\n   return false;\n }\n \n+DEF_VEC_O(tree);\n+DEF_VEC_ALLOC_O_STACK(tree);\n+#define VEC_tree_stack_alloc(alloc) VEC_stack_alloc (tree, alloc)\n+\n /* Copy debug stmts from DEST's chain of single predecessors up to\n    SRC, so that we don't lose the bindings as PHI nodes are introduced\n    when DEST gains new predecessors.  */\n@@ -625,10 +629,35 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n   gcc_checking_assert (dest != src);\n \n   gimple_stmt_iterator gsi = gsi_after_labels (dest);\n-  pointer_set_t *vars = pointer_set_create ();\n+  int i = 0;\n+  const int alloc_count = 16; // ?? Should this be a PARAM?\n \n+  /* Estimate the number of debug vars overridden in the beginning of\n+     DEST, to tell how many we're going to need to begin with.  */\n   for (gimple_stmt_iterator si = gsi;\n-       !gsi_end_p (si); gsi_next (&si))\n+       i * 4 <= alloc_count * 3 && !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple stmt = gsi_stmt (si);\n+      if (!is_gimple_debug (stmt))\n+\tbreak;\n+      i++;\n+    }\n+\n+  VEC(tree, stack) *fewvars = NULL;\n+  pointer_set_t *vars = NULL;\n+\n+  /* If we're already starting with 3/4 of alloc_count, go for a\n+     pointer_set, otherwise start with an unordered stack-allocated\n+     VEC.  */\n+  if (i * 4 > alloc_count * 3)\n+    vars = pointer_set_create ();\n+  else if (alloc_count)\n+    fewvars = VEC_alloc (tree, stack, alloc_count);\n+\n+  /* Now go through the initial debug stmts in DEST again, this time\n+     actually inserting in VARS or FEWVARS.  Don't bother checking for\n+     duplicates in FEWVARS.  */\n+  for (gimple_stmt_iterator si = gsi; !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple stmt = gsi_stmt (si);\n       if (!is_gimple_debug (stmt))\n@@ -643,7 +672,10 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n       else\n \tgcc_unreachable ();\n \n-      pointer_set_insert (vars, var);\n+      if (vars)\n+\tpointer_set_insert (vars, var);\n+      else\n+\tVEC_quick_push (tree, fewvars, var);\n     }\n \n   basic_block bb = dest;\n@@ -675,8 +707,28 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \t     or somesuch.  Adding `&& bb == src' to the condition\n \t     below will preserve all potentially relevant debug\n \t     notes.  */\n-\t  if (pointer_set_insert (vars, var))\n+\t  if (vars && pointer_set_insert (vars, var))\n \t    continue;\n+\t  else if (!vars)\n+\t    {\n+\t      int i = VEC_length (tree, fewvars);\n+\t      while (i--)\n+\t\tif (VEC_index (tree, fewvars, i) == var)\n+\t\t  break;\n+\t      if (i >= 0)\n+\t\tcontinue;\n+\n+\t      if (VEC_length (tree, fewvars) < alloc_count)\n+\t\tVEC_quick_push (tree, fewvars, var);\n+\t      else\n+\t\t{\n+\t\t  vars = pointer_set_create ();\n+\t\t  for (i = 0; i < alloc_count; i++)\n+\t\t    pointer_set_insert (vars, VEC_index (tree, fewvars, i));\n+\t\t  VEC_free (tree, stack, fewvars);\n+\t\t  pointer_set_insert (vars, var);\n+\t\t}\n+\t    }\n \n \t  stmt = gimple_copy (stmt);\n \t  /* ??? Should we drop the location of the copy to denote\n@@ -686,7 +738,10 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n     }\n   while (bb != src && single_pred_p (bb));\n \n-  pointer_set_destroy (vars);\n+  if (vars)\n+    pointer_set_destroy (vars);\n+  else if (fewvars)\n+    VEC_free (tree, stack, fewvars);\n }\n \n /* TAKEN_EDGE represents the an edge taken as a result of jump threading."}]}