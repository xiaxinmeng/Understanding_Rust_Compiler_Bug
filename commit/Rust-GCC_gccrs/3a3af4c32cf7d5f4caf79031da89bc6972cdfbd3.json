{"sha": "3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EzYWY0YzMyY2Y3ZDVmNGNhZjc5MDMxZGE4OWJjNjk3MmNkZmJkMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-04T09:08:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-04T09:08:50Z"}, "message": "[multiple changes]\n\n2013-01-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* sinfo.ads: Minor documentation update.\n\n2013-01-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch3.adb, einfo.adb (Analyze_Object_Declaration): Do not set Ekind\n\tbefore resolving initialization expression.\n\n2013-01-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Generate_Index_Checks): Delay the generation of\n\tthe check for an indexed component where the prefix mentions\n\tLoop_Entry until the attribute has been properly expanded.\n\t* exp_ch5.adb (Expand_Loop_Entry_Attributes): Perform minor\n\tdecoration of the constant that captures the value of Loop_Entry's\n\tprefix at the entry point into a loop.\tGenerate index checks\n\tfor an attribute reference that has been transformed into an\n\tindexed component.\n\n2013-01-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_prag.adb, exp_util.adb, exp_util.ads, freeze.adb, exp_aggr.adb,\n\tsem_ch13.adb (Exp_Aggr.Collect_Initialization_Statements): Nothing to\n\tdo if Obj is already frozen.\n\t(Exp_Util.Find_Init_Call): Rename to...\n\t(Exp_Util.Remove_Init_Call): New subprogram, renamed from\n\tFind_Init_Call.  Remove the initialization call from the enclosing\n\tlist if found, and if it is from an Initialization_Statements\n\tattribute, reset it.\n\t(Exp_Util.Append_Freeze_Action): Minor code reorganization.\n\t(Exp_Util.Append_Freeze_Actions): Ensure a freeze node has been\n\tallocated (as is already done in Append_Freeze_Action).\n\t(Freeze.Freeze_Entity): For an object with captured\n\tInitialization_Statements and non-delayed freezeing, unwrap the\n\tinitialization statements and insert and them directly in the\n\tenclosing list.\n\t(Sem_Ch13.Check_Address_Clause): For an object\n\twith Initialization_Statements and an address clause, unwrap the\n\tinitialization statements when moving them to the freeze actions.\n\nFrom-SVN: r194887", "tree": {"sha": "3266b4f490ae72a9e167f1807975fd0e4f1971e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3266b4f490ae72a9e167f1807975fd0e4f1971e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/comments", "author": null, "committer": null, "parents": [{"sha": "576f6da6398293734bac71fd55bc7aa07c521dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576f6da6398293734bac71fd55bc7aa07c521dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576f6da6398293734bac71fd55bc7aa07c521dbf"}], "stats": {"total": 414, "additions": 269, "deletions": 145}, "files": [{"sha": "06fe6a2f5ebfc8a9a81ae50ae7211e87720396c8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -1,3 +1,44 @@\n+2013-01-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sinfo.ads: Minor documentation update.\n+\n+2013-01-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch3.adb, einfo.adb (Analyze_Object_Declaration): Do not set Ekind\n+\tbefore resolving initialization expression.\n+\n+2013-01-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Generate_Index_Checks): Delay the generation of\n+\tthe check for an indexed component where the prefix mentions\n+\tLoop_Entry until the attribute has been properly expanded.\n+\t* exp_ch5.adb (Expand_Loop_Entry_Attributes): Perform minor\n+\tdecoration of the constant that captures the value of Loop_Entry's\n+\tprefix at the entry point into a loop.\tGenerate index checks\n+\tfor an attribute reference that has been transformed into an\n+\tindexed component.\n+\n+2013-01-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_prag.adb, exp_util.adb, exp_util.ads, freeze.adb, exp_aggr.adb,\n+\tsem_ch13.adb (Exp_Aggr.Collect_Initialization_Statements): Nothing to\n+\tdo if Obj is already frozen.\n+\t(Exp_Util.Find_Init_Call): Rename to...\n+\t(Exp_Util.Remove_Init_Call): New subprogram, renamed from\n+\tFind_Init_Call.  Remove the initialization call from the enclosing\n+\tlist if found, and if it is from an Initialization_Statements\n+\tattribute, reset it.\n+\t(Exp_Util.Append_Freeze_Action): Minor code reorganization.\n+\t(Exp_Util.Append_Freeze_Actions): Ensure a freeze node has been\n+\tallocated (as is already done in Append_Freeze_Action).\n+\t(Freeze.Freeze_Entity): For an object with captured\n+\tInitialization_Statements and non-delayed freezeing, unwrap the\n+\tinitialization statements and insert and them directly in the\n+\tenclosing list.\n+\t(Sem_Ch13.Check_Address_Clause): For an object\n+\twith Initialization_Statements and an address clause, unwrap the\n+\tinitialization statements when moving them to the freeze actions.\n+\n 2013-01-03  Pascal Obry  <obry@adacore.com>\n \n \t* prj-attr.adb, projects.texi, snames.ads-tmpl: Add package remote and"}, {"sha": "0c3f58978b54044186b8e1690a06a64e8127bf2f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -5522,6 +5522,23 @@ package body Checks is\n         or else Index_Checks_Suppressed (Etype (A))\n       then\n          return;\n+\n+      --  The indexed component we are dealing with contains 'Loop_Entry in its\n+      --  prefix. This case arises when analysis has determined that constructs\n+      --  such as\n+\n+      --     Prefix'Loop_Entry (Expr)\n+      --     Prefix'Loop_Entry (Expr1, Expr2, ... ExprN)\n+\n+      --  require rewriting for error detection purposes. A side effect of this\n+      --  action is the generation of index checks that mention 'Loop_Entry.\n+      --  Delay the generation of the check until 'Loop_Entry has been properly\n+      --  expanded. This is done in Expand_Loop_Entry_Attributes.\n+\n+      elsif Nkind (Prefix (N)) = N_Attribute_Reference\n+        and then Attribute_Name (Prefix (N)) = Name_Loop_Entry\n+      then\n+         return;\n       end if;\n \n       --  Generate a raise of constraint error with the appropriate reason and"}, {"sha": "59022564ad7d2560219904c072a27e6349d645c8", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -4263,7 +4263,11 @@ package body Einfo is\n \n    procedure Set_Initialization_Statements (Id : E; V : N) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n+      --  Tolerate an E_Void entity since this can be called while resolving\n+      --  an aggregate used as the initialization expression for an object\n+      --  declaration, and this occurs before the Ekind for the object is set.\n+\n+      pragma Assert (Ekind_In (Id, E_Void, E_Constant, E_Variable));\n       Set_Node28 (Id, V);\n    end Set_Initialization_Statements;\n "}, {"sha": "0b5e13fca7b521dc90c99c00b7100becaeb3e723", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -106,9 +106,10 @@ package body Exp_Aggr is\n      (Obj        : Entity_Id;\n       N          : Node_Id;\n       Node_After : Node_Id);\n-   --  Collect actions inserted after N until, but not including, Node_After,\n-   --  for initialization of Obj, and move them to an expression with actions,\n-   --  which becomes the Initialization_Statements for Obj.\n+   --  If Obj is not frozen, collect actions inserted after N until, but not\n+   --  including, Node_After, for initialization of Obj, and move them to an\n+   --  expression with actions, which becomes the Initialization_Statements for\n+   --  Obj.\n \n    ------------------------------------------------------\n    -- Local subprograms for Record Aggregate Expansion --\n@@ -2965,6 +2966,13 @@ package body Exp_Aggr is\n       EA           : Node_Id;\n       Init_Actions : constant List_Id := New_List;\n    begin\n+      --  Nothing to do if Obj is already frozen, as in this case we known we\n+      --  won't need to move the initialization statements about later on.\n+\n+      if Is_Frozen (Obj) then\n+         return;\n+      end if;\n+\n       Init_Node := N;\n \n       while Next (Init_Node) /= Node_After loop"}, {"sha": "66aeb681dac070c906bb3d15551200d19d257e5f", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -1828,11 +1828,29 @@ package body Exp_Ch5 is\n              Object_Definition   => New_Reference_To (Typ, Loc),\n              Expression          => Relocate_Node (Prefix (LE))));\n \n+         --  Perform minor decoration as this information will be needed for\n+         --  the creation of index checks (if applicable).\n+\n+         Set_Ekind (Temp, E_Constant);\n+         Set_Etype (Temp, Typ);\n+\n          --  Replace the original attribute with a reference to the constant\n \n          Rewrite (LE, New_Reference_To (Temp, Loc));\n          Set_Etype (LE, Typ);\n \n+         --  Analysis converts attribute references of the following form\n+\n+         --     Prefix'Loop_Entry (Expr)\n+         --     Prefix'Loop_Entry (Expr1, Expr2, ... ExprN)\n+\n+         --  into indexed components for error detection purposes. Generate\n+         --  index checks now that 'Loop_Entry has been properly expanded.\n+\n+         if Nkind (Parent (LE)) = N_Indexed_Component then\n+            Generate_Index_Checks (Parent (LE));\n+         end if;\n+\n          Next_Elmt (LE_Elmt);\n       end loop;\n "}, {"sha": "f2b1c853e9b8deb30a97182f99b2ba5df7c42e93", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -549,12 +549,9 @@ package body Exp_Prag is\n       Def_Id := Entity (Arg2 (N));\n       if Ekind (Def_Id) = E_Variable then\n \n-         --  Find generated initialization call for object, if any\n+         --  Find and remove generated initialization call for object, if any\n \n-         Init_Call := Find_Init_Call (Def_Id, Rep_Clause => N);\n-         if Present (Init_Call) then\n-            Remove (Init_Call);\n-         end if;\n+         Init_Call := Remove_Init_Call (Def_Id, Rep_Clause => N);\n \n          --  Any default initialization expression should be removed\n          --  (e.g., null defaults for access objects, zero initialization"}, {"sha": "50a2ba1ec56a0426536d4019830ea752571227d6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 111, "deletions": 103, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -366,29 +366,32 @@ package body Exp_Util is\n       Fnode := Freeze_Node (T);\n \n       if No (Actions (Fnode)) then\n-         Set_Actions (Fnode, New_List);\n+         Set_Actions (Fnode, New_List (N));\n+      else\n+         Append (N, Actions (Fnode));\n       end if;\n \n-      Append (N, Actions (Fnode));\n    end Append_Freeze_Action;\n \n    ---------------------------\n    -- Append_Freeze_Actions --\n    ---------------------------\n \n    procedure Append_Freeze_Actions (T : Entity_Id; L : List_Id) is\n-      Fnode : constant Node_Id := Freeze_Node (T);\n+      Fnode : Node_Id;\n \n    begin\n       if No (L) then\n          return;\n+      end if;\n+\n+      Ensure_Freeze_Node (T);\n+      Fnode := Freeze_Node (T);\n \n+      if No (Actions (Fnode)) then\n+         Set_Actions (Fnode, L);\n       else\n-         if No (Actions (Fnode)) then\n-            Set_Actions (Fnode, L);\n-         else\n-            Append_List (L, Actions (Fnode));\n-         end if;\n+         Append_List (L, Actions (Fnode));\n       end if;\n    end Append_Freeze_Actions;\n \n@@ -2160,101 +2163,6 @@ package body Exp_Util is\n       end if;\n    end Expand_Subtype_From_Expr;\n \n-   --------------------\n-   -- Find_Init_Call --\n-   --------------------\n-\n-   function Find_Init_Call\n-     (Var        : Entity_Id;\n-      Rep_Clause : Node_Id) return Node_Id\n-   is\n-      Par : constant Node_Id   := Parent (Var);\n-      Typ : constant Entity_Id := Etype (Var);\n-\n-      Init_Proc : Entity_Id;\n-      --  Initialization procedure for Typ\n-\n-      function Find_Init_Call_In_List (From : Node_Id) return Node_Id;\n-      --  Look for init call for Var starting at From and scanning the\n-      --  enclosing list until Rep_Clause or the end of the list is reached.\n-\n-      ----------------------------\n-      -- Find_Init_Call_In_List --\n-      ----------------------------\n-\n-      function Find_Init_Call_In_List (From : Node_Id) return Node_Id is\n-         Init_Call : Node_Id;\n-      begin\n-         Init_Call := From;\n-\n-         while Present (Init_Call) and then Init_Call /= Rep_Clause loop\n-            if Nkind (Init_Call) = N_Procedure_Call_Statement\n-              and then Is_Entity_Name (Name (Init_Call))\n-              and then Entity (Name (Init_Call)) = Init_Proc\n-            then\n-               return Init_Call;\n-            end if;\n-\n-            Next (Init_Call);\n-         end loop;\n-\n-         return Empty;\n-      end Find_Init_Call_In_List;\n-\n-      Init_Call : Node_Id;\n-\n-   --  Start of processing for Find_Init_Call\n-\n-   begin\n-      if Present (Initialization_Statements (Var)) then\n-         return Initialization_Statements (Var);\n-\n-      elsif not Has_Non_Null_Base_Init_Proc (Typ) then\n-\n-         --  No init proc for the type, so obviously no call to be found\n-\n-         return Empty;\n-      end if;\n-\n-      --  We might be able to handle other cases below by just properly setting\n-      --  Initialization_Statements at the point where the init proc call is\n-      --  generated???\n-\n-      Init_Proc := Base_Init_Proc (Typ);\n-\n-      --  First scan the list containing the declaration of Var\n-\n-      Init_Call := Find_Init_Call_In_List (From => Next (Par));\n-\n-      --  If not found, also look on Var's freeze actions list, if any, since\n-      --  the init call may have been moved there (case of an address clause\n-      --  applying to Var).\n-\n-      if No (Init_Call) and then Present (Freeze_Node (Var)) then\n-         Init_Call :=\n-           Find_Init_Call_In_List (First (Actions (Freeze_Node (Var))));\n-      end if;\n-\n-      --  If the initialization call has actuals that use the secondary stack,\n-      --  the call may have been wrapped into a temporary block, in which case\n-      --  the block itself has to be removed.\n-\n-      if No (Init_Call) and then Nkind (Next (Par)) = N_Block_Statement then\n-         declare\n-            Blk : constant Node_Id := Next (Par);\n-         begin\n-            if Present\n-                 (Find_Init_Call_In_List\n-                   (First (Statements (Handled_Statement_Sequence (Blk)))))\n-            then\n-               Init_Call := Blk;\n-            end if;\n-         end;\n-      end if;\n-\n-      return Init_Call;\n-   end Find_Init_Call;\n-\n    ------------------------\n    -- Find_Interface_ADT --\n    ------------------------\n@@ -6295,6 +6203,106 @@ package body Exp_Util is\n       end case;\n    end Process_Statements_For_Controlled_Objects;\n \n+   ----------------------\n+   -- Remove_Init_Call --\n+   ----------------------\n+\n+   function Remove_Init_Call\n+     (Var        : Entity_Id;\n+      Rep_Clause : Node_Id) return Node_Id\n+   is\n+      Par : constant Node_Id   := Parent (Var);\n+      Typ : constant Entity_Id := Etype (Var);\n+\n+      Init_Proc : Entity_Id;\n+      --  Initialization procedure for Typ\n+\n+      function Find_Init_Call_In_List (From : Node_Id) return Node_Id;\n+      --  Look for init call for Var starting at From and scanning the\n+      --  enclosing list until Rep_Clause or the end of the list is reached.\n+\n+      ----------------------------\n+      -- Find_Init_Call_In_List --\n+      ----------------------------\n+\n+      function Find_Init_Call_In_List (From : Node_Id) return Node_Id is\n+         Init_Call : Node_Id;\n+      begin\n+         Init_Call := From;\n+\n+         while Present (Init_Call) and then Init_Call /= Rep_Clause loop\n+            if Nkind (Init_Call) = N_Procedure_Call_Statement\n+              and then Is_Entity_Name (Name (Init_Call))\n+              and then Entity (Name (Init_Call)) = Init_Proc\n+            then\n+               return Init_Call;\n+            end if;\n+\n+            Next (Init_Call);\n+         end loop;\n+\n+         return Empty;\n+      end Find_Init_Call_In_List;\n+\n+      Init_Call : Node_Id;\n+\n+   --  Start of processing for Find_Init_Call\n+\n+   begin\n+      if Present (Initialization_Statements (Var)) then\n+         Init_Call := Initialization_Statements (Var);\n+         Set_Initialization_Statements (Var, Empty);\n+\n+      elsif not Has_Non_Null_Base_Init_Proc (Typ) then\n+\n+         --  No init proc for the type, so obviously no call to be found\n+\n+         return Empty;\n+\n+      else\n+         --  We might be able to handle other cases below by just properly\n+         --  setting Initialization_Statements at the point where the init proc\n+         --  call is generated???\n+\n+         Init_Proc := Base_Init_Proc (Typ);\n+\n+         --  First scan the list containing the declaration of Var\n+\n+         Init_Call := Find_Init_Call_In_List (From => Next (Par));\n+\n+         --  If not found, also look on Var's freeze actions list, if any,\n+         --  since the init call may have been moved there (case of an address\n+         --  clause applying to Var).\n+\n+         if No (Init_Call) and then Present (Freeze_Node (Var)) then\n+            Init_Call :=\n+              Find_Init_Call_In_List (First (Actions (Freeze_Node (Var))));\n+         end if;\n+\n+         --  If the initialization call has actuals that use the secondary\n+         --  stack, the call may have been wrapped into a temporary block, in\n+         --  which case the block itself has to be removed.\n+\n+         if No (Init_Call) and then Nkind (Next (Par)) = N_Block_Statement then\n+            declare\n+               Blk : constant Node_Id := Next (Par);\n+            begin\n+               if Present\n+                    (Find_Init_Call_In_List\n+                      (First (Statements (Handled_Statement_Sequence (Blk)))))\n+               then\n+                  Init_Call := Blk;\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+\n+      if Present (Init_Call) then\n+         Remove (Init_Call);\n+      end if;\n+      return Init_Call;\n+   end Remove_Init_Call;\n+\n    -------------------------\n    -- Remove_Side_Effects --\n    -------------------------"}, {"sha": "d87a5a4664011a2473fe0b625e13e071a911e0e1", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -379,14 +379,6 @@ package Exp_Util is\n    --  declarations and/or allocations when the type is indefinite (including\n    --  class-wide).\n \n-   function Find_Init_Call\n-     (Var        : Entity_Id;\n-      Rep_Clause : Node_Id) return Node_Id;\n-   --  Look for init_proc call for variable Var, either among declarations\n-   --  between that of Var and a subsequent Rep_Clause applying to Var, or\n-   --  in the list of freeze actions associated with Var, and if found, return\n-   --  that call node.\n-\n    function Find_Interface_ADT\n      (T     : Entity_Id;\n       Iface : Entity_Id) return Elmt_Id;\n@@ -723,6 +715,14 @@ package Exp_Util is\n    --  statements looking for declarations of controlled objects. If at least\n    --  one such object is found, wrap the statement list in a block.\n \n+   function Remove_Init_Call\n+     (Var        : Entity_Id;\n+      Rep_Clause : Node_Id) return Node_Id;\n+   --  Look for init_proc call or aggregate initialization statements for\n+   --  variable Var, either among declarations between that of Var and a\n+   --  subsequent Rep_Clause applying to Var, or in the list of freeze actions\n+   --  associated with Var, and if found, remove and return that call node.\n+\n    procedure Remove_Side_Effects\n      (Exp          : Node_Id;\n       Name_Req     : Boolean := False;"}, {"sha": "bf71111c68a91a82824c3c24eeeb90a35e67bb32", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -3344,6 +3344,31 @@ package body Freeze is\n             then\n                Layout_Object (E);\n             end if;\n+\n+            --  If initialization statements were captured in an expression\n+            --  with actions with null expression, and the object does not\n+            --  have delayed freezing, move them back now directly within the\n+            --  enclosing statement sequence.\n+\n+            if Ekind_In (E, E_Constant, E_Variable)\n+                 and then not Has_Delayed_Freeze (E)\n+            then\n+               declare\n+                  Init_Stmts : constant Node_Id :=\n+                                 Initialization_Statements (E);\n+               begin\n+                  if Present (Init_Stmts)\n+                       and then Nkind (Init_Stmts) = N_Expression_With_Actions\n+                       and then Nkind (Expression (Init_Stmts))\n+                         = N_Null_Statement\n+                  then\n+                     Insert_List_Before (Init_Stmts, Actions (Init_Stmts));\n+                     Remove (Init_Stmts);\n+                     Set_Initialization_Statements (E, Empty);\n+                  end if;\n+               end;\n+            end if;\n+\n          end if;\n \n       --  Case of a type or subtype being frozen"}, {"sha": "e02b7a085c7d0fb79c5bb63c086c18df892f5c88", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -2903,11 +2903,25 @@ package body Sem_Ch13 is\n                   --  before its definition.\n \n                   declare\n-                     Init_Call : constant Node_Id := Find_Init_Call (U_Ent, N);\n+                     Init_Call : constant Node_Id :=\n+                                   Remove_Init_Call (U_Ent, N);\n                   begin\n                      if Present (Init_Call) then\n-                        Remove (Init_Call);\n-                        Append_Freeze_Action (U_Ent, Init_Call);\n+\n+                        --  If the init call is an expression with actions with\n+                        --  null expression, just extract the actions.\n+\n+                        if Nkind (Init_Call) = N_Expression_With_Actions\n+                             and then Nkind (Expression (Init_Call))\n+                               = N_Null_Statement\n+                        then\n+                           Append_Freeze_Actions (U_Ent, Actions (Init_Call));\n+\n+                        --  General case: move Init_Call to freeze actions\n+\n+                        else\n+                           Append_Freeze_Action (U_Ent, Init_Call);\n+                        end if;\n                      end if;\n                   end;\n "}, {"sha": "ac0e0cc2fe7bdf0c3a044a770575f6db2759e07f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -3171,14 +3171,9 @@ package body Sem_Ch3 is\n             Set_Has_Completion (Id);\n          end if;\n \n-         --  Set kind (expansion of E may need it) and type now, and resolve.\n-         --  Type might be overridden later on.\n-\n-         if Constant_Present (N) then\n-            Set_Ekind (Id, E_Constant);\n-         else\n-            Set_Ekind (Id, E_Variable);\n-         end if;\n+         --  Set type and resolve (type may be overridden later on). Note:\n+         --  Ekind (Id) must still be E_Void at this point so that incorrect\n+         --  early usage within E is properly diagnosed.\n \n          Set_Etype (Id, T);\n          Resolve (E, T);\n@@ -3520,12 +3515,11 @@ package body Sem_Ch3 is\n \n       Set_Never_Set_In_Source (Id, True);\n \n-      --  Now establish the proper kind (if not already set) and type of the\n-      --  object.\n+      --  Now establish the proper kind and type of the object\n \n       if Constant_Present (N) then\n+         Set_Ekind            (Id, E_Constant);\n          Set_Is_True_Constant (Id, True);\n-         Set_Ekind (Id, E_Constant);\n \n       else\n          Set_Ekind (Id, E_Variable);"}, {"sha": "08b09d2ad048043bcef5ccfd9db97d84ba070e3c", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=3a3af4c32cf7d5f4caf79031da89bc6972cdfbd3", "patch": "@@ -7020,15 +7020,10 @@ package Sinfo is\n       --  a subexpression, whose value is the value of the Expression after\n       --  executing all the actions.\n \n-      --  Note: if the actions contain declarations, then these declarations\n-      --  may be referenced within the expression. It is thus appropriate for\n-      --  the back-end to create a scope that encompasses the construct (any\n-      --  declarations within the actions will definitely not be referenced\n-      --  once elaboration of the construct is completed).\n-\n-      --  But we rely on freeze nodes appearing in actions being elaborated in\n-      --  the enclosing scope (see Exp_Aggr.Collect_Initialization_\n-      --  Statements)???\n+      --  If the actions contain declarations, then these declarations may\n+      --  be referenced within the expression. However note that there is\n+      --  no proper scope associated with the expression-with-action, so the\n+      --  back-end will elaborate them in the context of the enclosing scope.\n \n       --  Sprint syntax:  do\n       --                    action;\n@@ -7046,7 +7041,10 @@ package Sinfo is\n       --  never have created this node if there weren't some actions.\n \n       --  Note: Expression may be a Null_Statement, in which case the\n-      --  N_Expression_With_Actions has type Standard_Void_Type.\n+      --  N_Expression_With_Actions has type Standard_Void_Type. However some\n+      --  backends do not support such expression-with-actions occurring\n+      --  outside of a proper (non-void) expression, so this should just be\n+      --  used as an intermediate representation within the front-end.\n \n       --------------------\n       -- Free Statement --\n@@ -7183,7 +7181,7 @@ package Sinfo is\n       --  the exception to be raised (i.e. it is equivalent to a raise\n       --  statement that raises the corresponding exception). This use\n       --  is distinguished by the fact that the Etype in this case is\n-      --  Standard_Void_Type, In the subexpression case, the Etype is the\n+      --  Standard_Void_Type; in the subexpression case, the Etype is the\n       --  same as the type of the subexpression which it replaces.\n \n       --  If Condition is empty, then the raise is unconditional. If the"}]}