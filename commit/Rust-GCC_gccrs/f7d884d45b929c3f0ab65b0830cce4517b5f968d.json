{"sha": "f7d884d45b929c3f0ab65b0830cce4517b5f968d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdkODg0ZDQ1YjkyOWMzZjBhYjY1YjA4MzBjY2U0NTE3YjVmOTY4ZA==", "commit": {"author": {"name": "Sudakshina Das", "email": "sudi.das@arm.com", "date": "2018-03-19T18:50:32Z"}, "committer": {"name": "Sudakshina Das", "email": "sudi@gcc.gnu.org", "date": "2018-03-19T18:50:32Z"}, "message": "[PR81647][AARCH64] Fix handling of Unordered Comparisons in aarch64-simd.md\n\nThis patch fixes the inconsistent behavior observed at -O3 for the unordered\ncomparisons. According to the online docs (https://gcc.gnu.org/onlinedocs\n/gcc-7.2.0/gccint/Unary-and-Binary-Expressions.html), all of the following\nshould not raise an FP exception:\n- UNGE_EXPR\n- UNGT_EXPR\n- UNLE_EXPR\n- UNLT_EXPR\n- UNEQ_EXPR\nAlso ORDERED_EXPR and UNORDERED_EXPR should only return zero or one.\n\nThe aarch64-simd.md handling of these were generating exception raising\ninstructions such as fcmgt. This patch changes the instructions that are\nemitted in order to not give out the exceptions. We first check each\noperand for NaNs and force any elements containing NaN to zero before using\nthem in the compare.\n\nExample: UN<cc> (a, b) -> UNORDERED (a, b)\n\t\t\t  | (cm<cc> (isnan (a) ? 0.0 : a, isnan (b) ? 0.0 : b))\n\n\nThe ORDERED_EXPR is now handled as (cmeq (a, a) & cmeq (b, b)) and\nUNORDERED_EXPR as ~ORDERED_EXPR and UNEQ as (~ORDERED_EXPR | cmeq (a,b)).\n\nChangeLog Entries:\n\n*** gcc/ChangeLog ***\n\n2018-03-19  Sudakshina Das  <sudi.das@arm.com>\n\n\tPR target/81647\n\t* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_int_equiv>): Modify\n\tinstructions for UNLT, UNLE, UNGT, UNGE, UNEQ, UNORDERED and ORDERED.\n\n*** gcc/testsuite/ChangeLog ***\n\n2018-03-19  Sudakshina Das  <sudi.das@arm.com>\n\n\tPR target/81647\n\t* gcc.target/aarch64/pr81647.c: New.\n\nFrom-SVN: r258653", "tree": {"sha": "d902629b27925595f99c85223f38fe0b948f3b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d902629b27925595f99c85223f38fe0b948f3b42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7d884d45b929c3f0ab65b0830cce4517b5f968d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d884d45b929c3f0ab65b0830cce4517b5f968d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d884d45b929c3f0ab65b0830cce4517b5f968d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d884d45b929c3f0ab65b0830cce4517b5f968d/comments", "author": {"login": "sudakshina-das-arm", "id": 28538945, "node_id": "MDQ6VXNlcjI4NTM4OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/28538945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudakshina-das-arm", "html_url": "https://github.com/sudakshina-das-arm", "followers_url": "https://api.github.com/users/sudakshina-das-arm/followers", "following_url": "https://api.github.com/users/sudakshina-das-arm/following{/other_user}", "gists_url": "https://api.github.com/users/sudakshina-das-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudakshina-das-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudakshina-das-arm/subscriptions", "organizations_url": "https://api.github.com/users/sudakshina-das-arm/orgs", "repos_url": "https://api.github.com/users/sudakshina-das-arm/repos", "events_url": "https://api.github.com/users/sudakshina-das-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/sudakshina-das-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a84677b84df4a05498f6741eea19f3042e4ee017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84677b84df4a05498f6741eea19f3042e4ee017", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a84677b84df4a05498f6741eea19f3042e4ee017"}], "stats": {"total": 158, "additions": 114, "deletions": 44}, "files": [{"sha": "713e9642833ad74859e93cb3a7bf493f72307d00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7d884d45b929c3f0ab65b0830cce4517b5f968d", "patch": "@@ -1,3 +1,9 @@\n+2018-03-19  Sudakshina Das  <sudi.das@arm.com>\n+\n+\tPR target/81647\n+\t* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_int_equiv>): Modify\n+\tinstructions for UNLT, UNLE, UNGT, UNGE, UNEQ, UNORDERED and ORDERED.\n+\n 2018-03-19  Jim Wilson  <jimw@sifive.com>\n \n \tPR bootstrap/84856"}, {"sha": "1154fc3d58deaa33413ea3050ff7feec37f092a6", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=f7d884d45b929c3f0ab65b0830cce4517b5f968d", "patch": "@@ -2730,10 +2730,10 @@\n \t  break;\n \t}\n       /* Fall through.  */\n-    case UNGE:\n+    case UNLT:\n       std::swap (operands[2], operands[3]);\n       /* Fall through.  */\n-    case UNLE:\n+    case UNGT:\n     case GT:\n       comparison = gen_aarch64_cmgt<mode>;\n       break;\n@@ -2744,10 +2744,10 @@\n \t  break;\n \t}\n       /* Fall through.  */\n-    case UNGT:\n+    case UNLE:\n       std::swap (operands[2], operands[3]);\n       /* Fall through.  */\n-    case UNLT:\n+    case UNGE:\n     case GE:\n       comparison = gen_aarch64_cmge<mode>;\n       break;\n@@ -2770,47 +2770,61 @@\n     case UNGT:\n     case UNLE:\n     case UNLT:\n-    case NE:\n-      /* FCM returns false for lanes which are unordered, so if we use\n-\t the inverse of the comparison we actually want to emit, then\n-\t invert the result, we will end up with the correct result.\n-\t Note that a NE NaN and NaN NE b are true for all a, b.\n-\n-\t Our transformations are:\n-\t a UNGE b -> !(b GT a)\n-\t a UNGT b -> !(b GE a)\n-\t a UNLE b -> !(a GT b)\n-\t a UNLT b -> !(a GE b)\n-\t a   NE b -> !(a EQ b)  */\n-      gcc_assert (comparison != NULL);\n-      emit_insn (comparison (operands[0], operands[2], operands[3]));\n-      emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n+      {\n+\t/* All of the above must not raise any FP exceptions.  Thus we first\n+\t   check each operand for NaNs and force any elements containing NaN to\n+\t   zero before using them in the compare.\n+\t   Example: UN<cc> (a, b) -> UNORDERED (a, b) |\n+\t\t\t\t     (cm<cc> (isnan (a) ? 0.0 : a,\n+\t\t\t\t\t      isnan (b) ? 0.0 : b))\n+\t   We use the following transformations for doing the comparisions:\n+\t   a UNGE b -> a GE b\n+\t   a UNGT b -> a GT b\n+\t   a UNLE b -> b GE a\n+\t   a UNLT b -> b GT a.  */\n+\n+\trtx tmp0 = gen_reg_rtx (<V_INT_EQUIV>mode);\n+\trtx tmp1 = gen_reg_rtx (<V_INT_EQUIV>mode);\n+\trtx tmp2 = gen_reg_rtx (<V_INT_EQUIV>mode);\n+\temit_insn (gen_aarch64_cmeq<mode> (tmp0, operands[2], operands[2]));\n+\temit_insn (gen_aarch64_cmeq<mode> (tmp1, operands[3], operands[3]));\n+\temit_insn (gen_and<v_int_equiv>3 (tmp2, tmp0, tmp1));\n+\temit_insn (gen_and<v_int_equiv>3 (tmp0, tmp0,\n+\t\t\t\t\t  lowpart_subreg (<V_INT_EQUIV>mode,\n+\t\t\t\t\t\t\t  operands[2],\n+\t\t\t\t\t\t\t  <MODE>mode)));\n+\temit_insn (gen_and<v_int_equiv>3 (tmp1, tmp1,\n+\t\t\t\t\t  lowpart_subreg (<V_INT_EQUIV>mode,\n+\t\t\t\t\t\t\t  operands[3],\n+\t\t\t\t\t\t\t  <MODE>mode)));\n+\tgcc_assert (comparison != NULL);\n+\temit_insn (comparison (operands[0],\n+\t\t\t       lowpart_subreg (<MODE>mode,\n+\t\t\t\t\t       tmp0, <V_INT_EQUIV>mode),\n+\t\t\t       lowpart_subreg (<MODE>mode,\n+\t\t\t\t\t       tmp1, <V_INT_EQUIV>mode)));\n+\temit_insn (gen_orn<v_int_equiv>3 (operands[0], tmp2, operands[0]));\n+      }\n       break;\n \n     case LT:\n     case LE:\n     case GT:\n     case GE:\n     case EQ:\n+    case NE:\n       /* The easy case.  Here we emit one of FCMGE, FCMGT or FCMEQ.\n \t As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:\n \t a GE b -> a GE b\n \t a GT b -> a GT b\n \t a LE b -> b GE a\n \t a LT b -> b GT a\n-\t a EQ b -> a EQ b  */\n+\t a EQ b -> a EQ b\n+\t a NE b -> ~(a EQ b)  */\n       gcc_assert (comparison != NULL);\n       emit_insn (comparison (operands[0], operands[2], operands[3]));\n-      break;\n-\n-    case UNEQ:\n-      /* We first check (a > b ||  b > a) which is !UNEQ, inverting\n-\t this result will then give us (a == b || a UNORDERED b).  */\n-      emit_insn (gen_aarch64_cmgt<mode> (operands[0],\n-\t\t\t\t\t operands[2], operands[3]));\n-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[3], operands[2]));\n-      emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n-      emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n+      if (code == NE)\n+\temit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n       break;\n \n     case LTGT:\n@@ -2822,21 +2836,22 @@\n       emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n       break;\n \n-    case UNORDERED:\n-      /* Operands are ORDERED iff (a > b || b >= a), so we can compute\n-\t UNORDERED as !ORDERED.  */\n-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));\n-      emit_insn (gen_aarch64_cmge<mode> (operands[0],\n-\t\t\t\t\t operands[3], operands[2]));\n-      emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n-      emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n-      break;\n-\n     case ORDERED:\n-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));\n-      emit_insn (gen_aarch64_cmge<mode> (operands[0],\n-\t\t\t\t\t operands[3], operands[2]));\n-      emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n+    case UNORDERED:\n+    case UNEQ:\n+      /* cmeq (a, a) & cmeq (b, b).  */\n+      emit_insn (gen_aarch64_cmeq<mode> (operands[0],\n+\t\t\t\t\t operands[2], operands[2]));\n+      emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[3], operands[3]));\n+      emit_insn (gen_and<v_int_equiv>3 (operands[0], operands[0], tmp));\n+\n+      if (code == UNORDERED)\n+\temit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n+      else if (code == UNEQ)\n+\t{\n+\t  emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[2], operands[3]));\n+\t  emit_insn (gen_orn<v_int_equiv>3 (operands[0], operands[0], tmp));\n+\t}\n       break;\n \n     default:"}, {"sha": "2202df759b92bfe094e8203154d83a16a3834b69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7d884d45b929c3f0ab65b0830cce4517b5f968d", "patch": "@@ -1,3 +1,8 @@\n+2018-03-19  Sudakshina Das  <sudi.das@arm.com>\n+\n+\tPR target/81647\n+\t* gcc.target/aarch64/pr81647.c: New.\n+\n 2018-03-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/84933"}, {"sha": "f60dfba49d538e3b2164b11392ab8dbfdba6546e", "filename": "gcc/testsuite/gcc.target/aarch64/pr81647.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr81647.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7d884d45b929c3f0ab65b0830cce4517b5f968d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr81647.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr81647.c?ref=f7d884d45b929c3f0ab65b0830cce4517b5f968d", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-tree-ssa\" } */\n+\n+#include <fenv.h>\n+\n+double x[28], y[28];\n+int res[28];\n+\n+int\n+main (void)\n+{\n+  int i;\n+  for (i = 0; i < 28; ++i)\n+    {\n+      x[i] = __builtin_nan (\"\");\n+      y[i] = i;\n+    }\n+  __asm__ volatile (\"\" ::: \"memory\");\n+  feclearexcept (FE_ALL_EXCEPT);\n+  for (i = 0; i < 4; ++i)\n+    res[i] = __builtin_isgreater (x[i], y[i]);\n+  for (i = 4; i < 8; ++i)\n+    res[i] = __builtin_isgreaterequal (x[i], y[i]);\n+  for (i = 8; i < 12; ++i)\n+    res[i] = __builtin_isless (x[i], y[i]);\n+  for (i = 12; i < 16; ++i)\n+    res[i] = __builtin_islessequal (x[i], y[i]);\n+  for (i = 16; i < 20; ++i)\n+    res[i] = __builtin_islessgreater (x[i], y[i]);\n+  for (i = 20; i < 24; ++i)\n+    res[i] = __builtin_isunordered (x[i], y[i]);\n+  for (i = 24; i < 28; ++i)\n+    res[i] = !(__builtin_isunordered (x[i], y[i]));\n+  __asm__ volatile (\"\" ::: \"memory\");\n+  return fetestexcept (FE_ALL_EXCEPT) != 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \" u> \" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump \" u>= \" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump \" u< \" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump \" u<= \" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump \" u== \" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump \" unord \" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump \" ord \" \"ssa\" } } */"}]}