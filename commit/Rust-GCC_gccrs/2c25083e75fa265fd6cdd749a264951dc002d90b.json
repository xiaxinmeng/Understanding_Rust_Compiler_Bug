{"sha": "2c25083e75fa265fd6cdd749a264951dc002d90b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyNTA4M2U3NWZhMjY1ZmQ2Y2RkNzQ5YTI2NDk1MWRjMDAyZDkwYg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2018-10-01T12:58:21Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-10-01T12:58:21Z"}, "message": "Add a hook to support telling the mid-end when to probe the stack.\n\nThis patch adds a hook to tell the mid-end about the probing requirements of the\ntarget.  On AArch64 we allow a specific range for which no probing needs to\nbe done.  This same range is also the amount that will have to be probed up when\na probe is needed after dropping the stack.\n\nDefining this probe comes with the extra requirement that the outgoing arguments\nsize of any function that uses alloca and stack clash be at the very least 8\nbytes.  With this invariant we can skip doing the zero checks for alloca and\nsave some code.\n\nA simplified version of the AArch64 stack frame is:\n\n   +-----------------------+                                              \n   |                       |                                                 \n   |                       |                                              \n   |                       |                                              \n   +-----------------------+                                              \n   |LR                     |                                              \n   +-----------------------+                                              \n   |FP                     |                                              \n   +-----------------------+                                              \n   |dynamic allocations    | -\\      probe range hook effects these       \n   +-----------------------+   --\\   and ensures that outgoing stack      \n   |padding                |      -- args is always > 8 when alloca.      \n   +-----------------------+  ---/   Which means it's always safe to probe\n   |outgoing stack args    |-/       at SP                                \n   +-----------------------+                                              \n                                                                                                           \n\nThis allows us to generate better code than without the hook without affecting\nother targets.\n\nWith this patch I am also removing the stack_clash_protection_final_dynamic_probe\nhook which was added specifically for AArch64 but that is no longer needed.\n\ngcc/\n\n\tPR target/86486\n\t* explow.c (anti_adjust_stack_and_probe_stack_clash): Support custom\n\tprobe ranges.\n\t* target.def (stack_clash_protection_alloca_probe_range): New.\n\t(stack_clash_protection_final_dynamic_probe): Remove.\n\t* targhooks.h (default_stack_clash_protection_alloca_probe_range) New.\n\t(default_stack_clash_protection_final_dynamic_probe): Remove.\n\t* targhooks.c: Likewise.\n\t* doc/tm.texi.in (TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE): New.\n\t(TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE): Remove.\n\t* doc/tm.texi: Regenerate.\n\nFrom-SVN: r264750", "tree": {"sha": "8cf97b47c2d4d4f0fe2f01f8522b89b2afe0cab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cf97b47c2d4d4f0fe2f01f8522b89b2afe0cab9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c25083e75fa265fd6cdd749a264951dc002d90b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c25083e75fa265fd6cdd749a264951dc002d90b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c25083e75fa265fd6cdd749a264951dc002d90b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c25083e75fa265fd6cdd749a264951dc002d90b/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb471ba379597d73fcd79986cca5b8351a32770a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb471ba379597d73fcd79986cca5b8351a32770a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb471ba379597d73fcd79986cca5b8351a32770a"}], "stats": {"total": 142, "additions": 93, "deletions": 49}, "files": [{"sha": "9eda3cd36d9a898725292264c904d479b20207fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -1,3 +1,17 @@\n+2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* explow.c (anti_adjust_stack_and_probe_stack_clash): Support custom\n+\tprobe ranges.\n+\t* target.def (stack_clash_protection_alloca_probe_range): New.\n+\t(stack_clash_protection_final_dynamic_probe): Remove.\n+\t* targhooks.h (default_stack_clash_protection_alloca_probe_range) New.\n+\t(default_stack_clash_protection_final_dynamic_probe): Remove.\n+\t* targhooks.c: Likewise.\n+\t* doc/tm.texi.in (TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE): New.\n+\t(TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE): Remove.\n+\t* doc/tm.texi: Regenerate.\n+\n 2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/86486"}, {"sha": "b00e4b60bc55171bec1705242798332e25d526b8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -3450,8 +3450,12 @@ GCC computed the default from the values of the above macros and you will\n normally not need to override that default.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE (rtx @var{residual})\n-Some targets make optimistic assumptions about the state of stack probing when they emit their prologues.  On such targets a probe into the end of any dynamically allocated space is likely required for safety against stack clash style attacks.  Define this variable to return nonzero if such a probe is required or zero otherwise.  You need not define this macro if it would always have the value zero.\n+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE (void)\n+Some targets have an ABI defined interval for which no probing needs to be done.\n+When a probe does need to be done this same interval is used as the probe distance up when doing stack clash protection for alloca.\n+On such targets this value can be set to override the default probing up interval.\n+Define this variable to return nonzero if such a probe range is required or zero otherwise.  Defining this hook also requires your functions which make use of alloca to have at least 8 byesof outgoing arguments.  If this is not the case the stack will be corrupted.\n+You need not define this macro if it would always have the value zero.\n @end deftypefn\n \n @need 2000"}, {"sha": "e2b6f945d2980b57ba47080e362b9b10195a0394", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -2841,7 +2841,7 @@ GCC computed the default from the values of the above macros and you will\n normally not need to override that default.\n @end defmac\n \n-@hook TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE\n+@hook TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE\n \n @need 2000\n @node Frame Registers"}, {"sha": "1dabd6ff9aa9b31bbb8fce900fcbdd87c57766bc", "filename": "gcc/explow.c", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -1958,10 +1958,21 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \n   /* We can get here with a constant size on some targets.  */\n   rtx rounded_size, last_addr, residual;\n-  HOST_WIDE_INT probe_interval;\n+  HOST_WIDE_INT probe_interval, probe_range;\n+  bool target_probe_range_p = false;\n   compute_stack_clash_protection_loop_data (&rounded_size, &last_addr,\n \t\t\t\t\t    &residual, &probe_interval, size);\n \n+  /* Get the back-end specific probe ranges.  */\n+  probe_range = targetm.stack_clash_protection_alloca_probe_range ();\n+  target_probe_range_p = probe_range != 0;\n+  gcc_assert (probe_range >= 0);\n+\n+  /* If no back-end specific range defined, default to the top of the newly\n+     allocated range.  */\n+  if (probe_range == 0)\n+    probe_range = probe_interval - GET_MODE_SIZE (word_mode);\n+\n   if (rounded_size != CONST0_RTX (Pmode))\n     {\n       if (CONST_INT_P (rounded_size)\n@@ -1972,13 +1983,12 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \t       i += probe_interval)\n \t    {\n \t      anti_adjust_stack (GEN_INT (probe_interval));\n-\n \t      /* The prologue does not probe residuals.  Thus the offset\n \t\t here to probe just beyond what the prologue had already\n \t\t allocated.  */\n \t      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t       (probe_interval\n-\t\t\t\t\t\t- GET_MODE_SIZE (word_mode))));\n+\t\t\t\t\t       probe_range));\n+\n \t      emit_insn (gen_blockage ());\n \t    }\n \t}\n@@ -1992,10 +2002,10 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \t  anti_adjust_stack (GEN_INT (probe_interval));\n \n \t  /* The prologue does not probe residuals.  Thus the offset here\n-\t     to probe just beyond what the prologue had already allocated.  */\n+\t     to probe just beyond what the prologue had already\n+\t     allocated.  */\n \t  emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t   (probe_interval\n-\t\t\t\t\t    - GET_MODE_SIZE (word_mode))));\n+\t\t\t\t\t   probe_range));\n \n \t  emit_stack_clash_protection_probe_loop_end (loop_lab, end_loop,\n \t\t\t\t\t\t      last_addr, rotate_loop);\n@@ -2010,48 +2020,55 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \t hold live data.  Furthermore, we do not want to probe into the\n \t red zone.\n \n-\t Go ahead and just guard the probe at *sp on RESIDUAL != 0 at\n-\t runtime if RESIDUAL is not a compile time constant.  */\n+\t If TARGET_PROBE_RANGE_P then the target has promised it's safe to\n+\t probe at offset 0.  In which case we no longer have to check for\n+\t RESIDUAL == 0.  However we still need to probe at the right offset\n+\t when RESIDUAL > PROBE_RANGE, in which case we probe at PROBE_RANGE.\n+\n+\t If !TARGET_PROBE_RANGE_P then go ahead and just guard the probe at *sp\n+\t on RESIDUAL != 0 at runtime if RESIDUAL is not a compile time constant.\n+\t */\n+      anti_adjust_stack (residual);\n+\n       if (!CONST_INT_P (residual))\n \t{\n \t  label = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (residual, CONST0_RTX (GET_MODE (residual)),\n-\t\t\t\t   EQ, NULL_RTX, Pmode, 1, label);\n-\t}\n+\t  rtx_code op = target_probe_range_p ? LT : EQ;\n+\t  rtx probe_cmp_value = target_probe_range_p\n+\t    ? gen_rtx_CONST_INT (GET_MODE (residual), probe_range)\n+\t    : CONST0_RTX (GET_MODE (residual));\n \n-      rtx x = force_reg (Pmode, plus_constant (Pmode, residual,\n-\t\t\t\t\t       -GET_MODE_SIZE (word_mode)));\n-      anti_adjust_stack (residual);\n-      emit_stack_probe (gen_rtx_PLUS (Pmode, stack_pointer_rtx, x));\n-      emit_insn (gen_blockage ());\n-      if (!CONST_INT_P (residual))\n-\temit_label (label);\n-    }\n+\t  if (target_probe_range_p)\n+\t    emit_stack_probe (stack_pointer_rtx);\n \n-  /* Some targets make optimistic assumptions in their prologues about\n-     how the caller may have probed the stack.  Make sure we honor\n-     those assumptions when needed.  */\n-  if (size != CONST0_RTX (Pmode)\n-      && targetm.stack_clash_protection_final_dynamic_probe (residual))\n-    {\n-      /* SIZE could be zero at runtime and in that case *sp could hold\n-\t live data.  Furthermore, we don't want to probe into the red\n-\t zone.\n+\t  emit_cmp_and_jump_insns (residual, probe_cmp_value,\n+\t\t\t\t   op, NULL_RTX, Pmode, 1, label);\n+\t}\n \n-\t Go ahead and just guard the probe at *sp on SIZE != 0 at runtime\n-\t if SIZE is not a compile time constant.  */\n-      rtx label = NULL_RTX;\n-      if (!CONST_INT_P (size))\n+      rtx x = NULL_RTX;\n+\n+      /* If RESIDUAL isn't a constant and TARGET_PROBE_RANGE_P then we probe up\n+\t by the ABI defined safe value.  */\n+      if (!CONST_INT_P (residual) && target_probe_range_p)\n+\tx = GEN_INT (probe_range);\n+      /* If RESIDUAL is a constant but smaller than the ABI defined safe value,\n+\t we still want to probe up, but the safest amount if a word.  */\n+      else if (target_probe_range_p)\n \t{\n-\t  label = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (size, CONST0_RTX (GET_MODE (size)),\n-\t\t\t\t   EQ, NULL_RTX, Pmode, 1, label);\n+\t  if (INTVAL (residual) <= probe_range)\n+\t    x = GEN_INT (GET_MODE_SIZE (word_mode));\n+\t  else\n+\t    x = GEN_INT (probe_range);\n \t}\n+      else\n+      /* If nothing else, probe at the top of the new allocation.  */\n+\tx = plus_constant (Pmode, residual, -GET_MODE_SIZE (word_mode));\n+\n+      emit_stack_probe (gen_rtx_PLUS (Pmode, stack_pointer_rtx, x));\n \n-      emit_stack_probe (stack_pointer_rtx);\n       emit_insn (gen_blockage ());\n-      if (!CONST_INT_P (size))\n-\temit_label (label);\n+      if (!CONST_INT_P (residual))\n+\t  emit_label (label);\n     }\n }\n "}, {"sha": "9733edff81391ec82b599e2dfeefaf32892a8507", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -5854,10 +5854,17 @@ these registers when the target switches are opposed to them.)\",\n  hook_void_void)\n \n DEFHOOK\n-(stack_clash_protection_final_dynamic_probe,\n- \"Some targets make optimistic assumptions about the state of stack probing when they emit their prologues.  On such targets a probe into the end of any dynamically allocated space is likely required for safety against stack clash style attacks.  Define this variable to return nonzero if such a probe is required or zero otherwise.  You need not define this macro if it would always have the value zero.\",\n- bool, (rtx residual),\n- default_stack_clash_protection_final_dynamic_probe)\n+(stack_clash_protection_alloca_probe_range,\n+ \"Some targets have an ABI defined interval for which no probing needs to be done.\\n\\\n+When a probe does need to be done this same interval is used as the probe distance \\\n+up when doing stack clash protection for alloca.\\n\\\n+On such targets this value can be set to override the default probing up interval.\\n\\\n+Define this variable to return nonzero if such a probe range is required or zero otherwise.  \\\n+Defining this hook also requires your functions which make use of alloca to have at least 8 byes\\\n+of outgoing arguments.  If this is not the case the stack will be corrupted.\\n\\\n+You need not define this macro if it would always have the value zero.\",\n+ HOST_WIDE_INT, (void),\n+ default_stack_clash_protection_alloca_probe_range)\n \n \n /* Functions specific to the C family of frontends.  */"}, {"sha": "3d8b3b9d69be8fb1c9bfb052e522ea84b1bdc341", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -2310,8 +2310,10 @@ default_excess_precision (enum excess_precision_type ATTRIBUTE_UNUSED)\n   return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;\n }\n \n-bool\n-default_stack_clash_protection_final_dynamic_probe (rtx residual ATTRIBUTE_UNUSED)\n+/* Default implementation for\n+  TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE.  */\n+HOST_WIDE_INT\n+default_stack_clash_protection_alloca_probe_range (void)\n {\n   return 0;\n }"}, {"sha": "176c64d23f534601be5b3534d416bcf3a66cb20a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c25083e75fa265fd6cdd749a264951dc002d90b/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=2c25083e75fa265fd6cdd749a264951dc002d90b", "patch": "@@ -277,7 +277,7 @@ extern unsigned int default_min_arithmetic_precision (void);\n \n extern enum flt_eval_method\n default_excess_precision (enum excess_precision_type ATTRIBUTE_UNUSED);\n-extern bool default_stack_clash_protection_final_dynamic_probe (rtx);\n+extern HOST_WIDE_INT default_stack_clash_protection_alloca_probe_range (void);\n extern void default_select_early_remat_modes (sbitmap);\n extern tree default_preferred_else_value (unsigned, tree, unsigned, tree *);\n "}]}