{"sha": "c644ee4c4351e3590f5396e94ec24ad7b828a954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY0NGVlNGM0MzUxZTM1OTBmNTM5NmU5NGVjMjRhZDdiODI4YTk1NA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-13T16:12:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-13T16:12:45Z"}, "message": "Merge #671\n\n671: Support indirection for struct and tuple field access r=philberty a=philberty\n\nThis allows for fat pointers to be used for tuple or struct field access by\r\nsupporting the GCC indirect references by binding the type to the reference.\r\n\r\nThis might get updated when we support the autoderef mechanism and if the\r\ntype supports the deref trait.\r\n\r\nAddresses #241\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "b1bcaa2f68d4fc74e4e90ff6d608613e4f11a8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1bcaa2f68d4fc74e4e90ff6d608613e4f11a8a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c644ee4c4351e3590f5396e94ec24ad7b828a954", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhP3h9CRBK7hj4Ov3rIwAAHJsIAKaycSDBYeiOOO2HLYarIpgK\nR2fdWRLPkTJCizJrDLoFLF7fA8Q1XBYZ7aWpwzySMkeGJEwr11VlDUvzwvxFx8ol\niNQSWegori4YESEtidlwZd1sOrIjljuokxKvoXHVbzaZaIiNMxMMSmw014RiB+Fu\nI0FXlAExFFmmMnHMB8+De0thk6qAu7tj3FMalYThz+J0WUpbrpkvGeKUyJdyXzHg\naYyq3o/x/qmdBgSixHWTeGj63TtCCV+uR7kzvVj/6PNthPVxG/Wi74pNFfbcDSQ3\n6NyH9qM54p5Ky8WSD0PqTOKK423jC89vqBPTAwf6VrM4DDzqlHWiYXZSo0+Ec+8=\n=rlSV\n-----END PGP SIGNATURE-----\n", "payload": "tree b1bcaa2f68d4fc74e4e90ff6d608613e4f11a8a7\nparent e3b7eb58844c446d097ddee00ecd455d5537c6b2\nparent 9464066111c715a63e632b1dc60f3230e8c48bb1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631549565 +0000\ncommitter GitHub <noreply@github.com> 1631549565 +0000\n\nMerge #671\n\n671: Support indirection for struct and tuple field access r=philberty a=philberty\n\nThis allows for fat pointers to be used for tuple or struct field access by\r\nsupporting the GCC indirect references by binding the type to the reference.\r\n\r\nThis might get updated when we support the autoderef mechanism and if the\r\ntype supports the deref trait.\r\n\r\nAddresses #241\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c644ee4c4351e3590f5396e94ec24ad7b828a954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c644ee4c4351e3590f5396e94ec24ad7b828a954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c644ee4c4351e3590f5396e94ec24ad7b828a954/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b7eb58844c446d097ddee00ecd455d5537c6b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b7eb58844c446d097ddee00ecd455d5537c6b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b7eb58844c446d097ddee00ecd455d5537c6b2"}, {"sha": "9464066111c715a63e632b1dc60f3230e8c48bb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9464066111c715a63e632b1dc60f3230e8c48bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9464066111c715a63e632b1dc60f3230e8c48bb1"}], "stats": {"total": 103, "additions": 92, "deletions": 11}, "files": [{"sha": "d0c0b748497b86ca4736ff999cffd8f87cce9e22", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=c644ee4c4351e3590f5396e94ec24ad7b828a954", "patch": "@@ -46,6 +46,26 @@ class CompileExpr : public HIRCompileBase\n     TupleIndex index = expr.get_tuple_index ();\n \n     Bexpression *receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+\n+    TyTy::BaseType *tuple_expr_ty = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (\n+      tuple_expr->get_mappings ().get_hirid (), &tuple_expr_ty);\n+    rust_assert (ok);\n+\n+    // do we need to add an indirect reference\n+    if (tuple_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+      {\n+\tTyTy::ReferenceType *r\n+\t  = static_cast<TyTy::ReferenceType *> (tuple_expr_ty);\n+\tTyTy::BaseType *tuple_type = r->get_base ();\n+\tBtype *tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n+\n+\tBexpression *indirect\n+\t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n+\t\t\t\t\t\t      true, expr.get_locus ());\n+\treceiver_ref = indirect;\n+      }\n+\n     translated\n       = ctx->get_backend ()->struct_field_expression (receiver_ref, index,\n \t\t\t\t\t\t      expr.get_locus ());\n@@ -606,6 +626,9 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::FieldAccessExpr &expr) override\n   {\n+    Bexpression *receiver_ref\n+      = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n+\n     // resolve the receiver back to ADT type\n     TyTy::BaseType *receiver = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type (\n@@ -615,17 +638,31 @@ class CompileExpr : public HIRCompileBase\n \t\t       \"unresolved type for receiver\");\n \treturn;\n       }\n-    rust_assert (receiver->get_kind () == TyTy::TypeKind::ADT);\n-    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n \n-    size_t index = 0;\n-    adt->get_field (expr.get_field_name (), &index);\n+    size_t field_index = 0;\n+    if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n+\tadt->get_field (expr.get_field_name (), &field_index);\n+      }\n+    else if (receiver->get_kind () == TyTy::TypeKind::REF)\n+      {\n+\tTyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+\tTyTy::BaseType *b = r->get_base ();\n+\trust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n \n-    Bexpression *struct_ref\n-      = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n+\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (b);\n+\tadt->get_field (expr.get_field_name (), &field_index);\n+\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n+\n+\tBexpression *indirect\n+\t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n+\t\t\t\t\t\t      true, expr.get_locus ());\n+\treceiver_ref = indirect;\n+      }\n \n     translated\n-      = ctx->get_backend ()->struct_field_expression (struct_ref, index,\n+      = ctx->get_backend ()->struct_field_expression (receiver_ref, field_index,\n \t\t\t\t\t\t      expr.get_locus ());\n   }\n "}, {"sha": "087129131d1986457dd1a62ac58b76991c0df185", "filename": "gcc/rust/lint/rust-lint-marklive.cc", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.cc?ref=c644ee4c4351e3590f5396e94ec24ad7b828a954", "patch": "@@ -214,9 +214,22 @@ MarkLive::visit (HIR::FieldAccessExpr &expr)\n       rust_error_at (expr.get_receiver_expr ()->get_locus (),\n \t\t     \"unresolved type for receiver\");\n     }\n-  bool ok = receiver->get_kind () == TyTy::TypeKind::ADT;\n-  rust_assert (ok);\n-  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n+\n+  TyTy::ADTType *adt = nullptr;\n+  if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      adt = static_cast<TyTy::ADTType *> (receiver);\n+    }\n+  else if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      TyTy::BaseType *b = r->get_base ();\n+      rust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n+\n+      adt = static_cast<TyTy::ADTType *> (b);\n+    }\n+\n+  rust_assert (adt != nullptr);\n \n   // get the field index\n   size_t index = 0;\n@@ -228,6 +241,7 @@ MarkLive::visit (HIR::FieldAccessExpr &expr)\n \t\t     adt->get_name ().c_str (), index);\n       return;\n     }\n+\n   // get the field hir id\n   HirId field_id = adt->get_field (index)->get_ref ();\n   mark_hir_id (field_id);"}, {"sha": "31c8909dee8862decd07db2d6ff0bd245a5d1854", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c644ee4c4351e3590f5396e94ec24ad7b828a954", "patch": "@@ -64,13 +64,20 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     auto resolved\n       = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get (), inside_loop);\n-    if (resolved == nullptr)\n+    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_tuple_expr ()->get_locus (),\n \t\t       \"failed to resolve TupleIndexExpr receiver\");\n \treturn;\n       }\n \n+    // FIXME does this require autoderef here?\n+    if (resolved->get_kind () == TyTy::TypeKind::REF)\n+      {\n+\tTyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (resolved);\n+\tresolved = r->get_base ();\n+      }\n+\n     bool is_valid_type = resolved->get_kind () == TyTy::TypeKind::ADT\n \t\t\t || resolved->get_kind () == TyTy::TypeKind::TUPLE;\n     if (!is_valid_type)\n@@ -902,6 +909,14 @@ class TypeCheckExpr : public TypeCheckBase\n     auto struct_base\n       = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get (), false);\n \n+    // FIXME does this require autoderef here?\n+    if (struct_base->get_kind () == TyTy::TypeKind::REF)\n+      {\n+\tTyTy::ReferenceType *r\n+\t  = static_cast<TyTy::ReferenceType *> (struct_base);\n+\tstruct_base = r->get_base ();\n+      }\n+\n     bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n     if (!is_valid_type)\n       {"}, {"sha": "0cf070f1f37e2b8f3e6dc266e862c6c4f55276c1", "filename": "gcc/testsuite/rust/compile/torture/autoderef1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fautoderef1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c644ee4c4351e3590f5396e94ec24ad7b828a954/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fautoderef1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fautoderef1.rs?ref=c644ee4c4351e3590f5396e94ec24ad7b828a954", "patch": "@@ -0,0 +1,15 @@\n+struct Foo(i32, bool);\n+struct Bar {\n+    a: i32,\n+    b: bool,\n+}\n+\n+fn main() {\n+    let a = &Foo(123, false);\n+    let _b: i32 = a.0;\n+    let _c: bool = a.1;\n+\n+    let a = &Bar { a: 456, b: false };\n+    let _b: i32 = a.a;\n+    let _c: bool = a.b;\n+}"}]}