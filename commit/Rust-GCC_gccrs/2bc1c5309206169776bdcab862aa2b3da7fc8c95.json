{"sha": "2bc1c5309206169776bdcab862aa2b3da7fc8c95", "node_id": "C_kwDOANBUbNoAKDJiYzFjNTMwOTIwNjE2OTc3NmJkY2FiODYyYWEyYjNkYTdmYzhjOTU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-10-26T08:56:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-26T08:56:37Z"}, "message": "Merge #1615\n\n1615: intrinsics: Add early implementation for atomic_store_{seqcst, relaxed, release} r=CohenArthur a=CohenArthur\n\nNeeds #1614 so ignore the first commit\r\n\r\nThis commit adds support for three `atomic_store_*` intrinsics declared\r\nin the core library. The mapping is as follows:\r\n\r\n- atomic_store_seqcst(dst, val) -> __atomic_store_n(dst, val,\r\n  __ATOMIC_SEQ_CST)\r\n- atomic_store_relaxed(dst, val) -> __atomic_store_n(dst, val,\r\n  __ATOMIC_RELAXED)\r\n- atomic_store_release(dst, val) -> __atomic_store_n(dst, val,\r\n  __ATOMIC_RELEASE)\r\n\r\nThe one remaining question is whether `atomic_store_unordered` can be\r\nabstracted as an atomic store with the __ATOMIC_RELAXED ordering.\r\n\r\nThis commit also performs the overloading \"by hand\": Replacing\r\n`atomic_store_release<i32>` with `__atomic_store_4` as I cannot get the\r\ngeneric version to work. This will be done in future improvements.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "98141c08cd9ec0404b386a491e830a0132ca2855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98141c08cd9ec0404b386a491e830a0132ca2855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bc1c5309206169776bdcab862aa2b3da7fc8c95", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjWPZFCRBK7hj4Ov3rIwAA8ycIAJo+hnQ0KoEE9TCW7+NMKDfp\nYUFKopKNhun8eVFJv/+nxpRMGFShYCirZCGcztZK4D3KZZhWVURXK6osT0UltiuY\nAi37sN7dfmBX506RaW6eaF1nhLQB9rnQi7KisPImqzZBZkF30UKMLPoWC+jPXqUW\nkUZj3n9SV+Rf8gmjU82hboPolwPhRbL3zAmGpH4Snc3GxaLtJWXhXthHr6fa1uth\nrmGHK+2rl5NpJ3WiKRYlDCuICqxkmfKgVHjN8Bw+97x7CiZPYxpep6c4Vhyr5rRf\nQuACR3ah5uX+EZK/vi4B8APbQYtd3oGBXgEXDvHCpYFDJcgN+ZGll2ruVyA5NLI=\n=cIVx\n-----END PGP SIGNATURE-----\n", "payload": "tree 98141c08cd9ec0404b386a491e830a0132ca2855\nparent 14c942c3eb060e063fd8142d390c6d09951bf544\nparent 4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1666774597 +0000\ncommitter GitHub <noreply@github.com> 1666774597 +0000\n\nMerge #1615\n\n1615: intrinsics: Add early implementation for atomic_store_{seqcst, relaxed, release} r=CohenArthur a=CohenArthur\n\nNeeds #1614 so ignore the first commit\r\n\r\nThis commit adds support for three `atomic_store_*` intrinsics declared\r\nin the core library. The mapping is as follows:\r\n\r\n- atomic_store_seqcst(dst, val) -> __atomic_store_n(dst, val,\r\n  __ATOMIC_SEQ_CST)\r\n- atomic_store_relaxed(dst, val) -> __atomic_store_n(dst, val,\r\n  __ATOMIC_RELAXED)\r\n- atomic_store_release(dst, val) -> __atomic_store_n(dst, val,\r\n  __ATOMIC_RELEASE)\r\n\r\nThe one remaining question is whether `atomic_store_unordered` can be\r\nabstracted as an atomic store with the __ATOMIC_RELAXED ordering.\r\n\r\nThis commit also performs the overloading \"by hand\": Replacing\r\n`atomic_store_release<i32>` with `__atomic_store_4` as I cannot get the\r\ngeneric version to work. This will be done in future improvements.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc1c5309206169776bdcab862aa2b3da7fc8c95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc1c5309206169776bdcab862aa2b3da7fc8c95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc1c5309206169776bdcab862aa2b3da7fc8c95/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c942c3eb060e063fd8142d390c6d09951bf544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c942c3eb060e063fd8142d390c6d09951bf544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c942c3eb060e063fd8142d390c6d09951bf544"}, {"sha": "4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d42744aa5d5778975d46ac9f5c945f9c7ec2ffa"}], "stats": {"total": 290, "additions": 268, "deletions": 22}, "files": [{"sha": "64e06e1a24094816a06dd57ccfc9675ee85ca769", "filename": "gcc/rust/backend/rust-builtins.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.cc?ref=2bc1c5309206169776bdcab862aa2b3da7fc8c95", "patch": "@@ -68,11 +68,47 @@ BuiltinsContext::setup_math_fns ()\n \t\t  math_function_type_f32, builtin_const);\n }\n \n+void\n+BuiltinsContext::setup_atomic_fns ()\n+{\n+  define_builtin (\"atomic_store\", BUILT_IN_ATOMIC_STORE, \"__atomic_store\", NULL,\n+\t\t  build_function_type_list (void_type_node, size_type_node,\n+\t\t\t\t\t    build_pointer_type (void_type_node),\n+\t\t\t\t\t    const_ptr_type_node,\n+\t\t\t\t\t    integer_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_n\", BUILT_IN_ATOMIC_STORE_N, \"__atomic_store_n\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_1\", BUILT_IN_ATOMIC_STORE_1, \"__atomic_store_1\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_2\", BUILT_IN_ATOMIC_STORE_2, \"__atomic_store_2\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_4\", BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_8\", BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\",\n+\t\t  NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+  define_builtin (\"atomic_store_16\", BUILT_IN_ATOMIC_STORE_16,\n+\t\t  \"__atomic_store_16\", NULL,\n+\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n+\t\t  0);\n+}\n+\n void\n BuiltinsContext::setup ()\n {\n   setup_math_fns ();\n   setup_overflow_fns ();\n+  setup_atomic_fns ();\n \n   define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE, \"__builtin_unreachable\",\n \t\t  NULL, build_function_type (void_type_node, void_list_node),"}, {"sha": "c2825107faff2317a40b696c3477b62139475f26", "filename": "gcc/rust/backend/rust-builtins.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=2bc1c5309206169776bdcab862aa2b3da7fc8c95", "patch": "@@ -86,8 +86,8 @@ class BuiltinsContext\n   BuiltinsContext ();\n \n   void setup_overflow_fns ();\n-\n   void setup_math_fns ();\n+  void setup_atomic_fns ();\n \n   void setup ();\n "}, {"sha": "7c592dabb38568d4202fd527c1aa5ff98067e65d", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 144, "deletions": 21, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=2bc1c5309206169776bdcab862aa2b3da7fc8c95", "patch": "@@ -93,6 +93,17 @@ prefetch_write_data (Context *ctx, TyTy::FnType *fntype)\n   return prefetch_data_handler (ctx, fntype, Prefetch::Write);\n }\n \n+static tree\n+atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering);\n+\n+static inline std::function<tree (Context *, TyTy::FnType *)>\n+atomic_store_handler (int ordering)\n+{\n+  return [ordering] (Context *ctx, TyTy::FnType *fntype) {\n+    return atomic_store_handler_inner (ctx, fntype, ordering);\n+  };\n+}\n+\n static inline tree\n sorry_handler (Context *ctx, TyTy::FnType *fntype)\n {\n@@ -105,18 +116,22 @@ sorry_handler (Context *ctx, TyTy::FnType *fntype)\n static const std::map<std::string,\n \t\t      std::function<tree (Context *, TyTy::FnType *)>>\n   generic_intrinsics = {\n-    {\"offset\", &offset_handler},\n-    {\"size_of\", &sizeof_handler},\n-    {\"transmute\", &transmute_handler},\n-    {\"rotate_left\", &rotate_left_handler},\n-    {\"rotate_right\", &rotate_right_handler},\n-    {\"wrapping_add\", &wrapping_add_handler},\n-    {\"wrapping_sub\", &wrapping_sub_handler},\n-    {\"wrapping_mul\", &wrapping_mul_handler},\n-    {\"copy_nonoverlapping\", &copy_nonoverlapping_handler},\n-    {\"prefetch_read_data\", &prefetch_read_data},\n-    {\"prefetch_write_data\", &prefetch_write_data},\n-    {\"atomic_load\", &sorry_handler},\n+    {\"offset\", offset_handler},\n+    {\"size_of\", sizeof_handler},\n+    {\"transmute\", transmute_handler},\n+    {\"rotate_left\", rotate_left_handler},\n+    {\"rotate_right\", rotate_right_handler},\n+    {\"wrapping_add\", wrapping_add_handler},\n+    {\"wrapping_sub\", wrapping_sub_handler},\n+    {\"wrapping_mul\", wrapping_mul_handler},\n+    {\"copy_nonoverlapping\", copy_nonoverlapping_handler},\n+    {\"prefetch_read_data\", prefetch_read_data},\n+    {\"prefetch_write_data\", prefetch_write_data},\n+    {\"atomic_load\", sorry_handler},\n+    {\"atomic_store_seqcst\", atomic_store_handler (__ATOMIC_SEQ_CST)},\n+    {\"atomic_store_release\", atomic_store_handler (__ATOMIC_RELEASE)},\n+    {\"atomic_store_relaxed\", atomic_store_handler (__ATOMIC_RELAXED)},\n+    {\"atomic_store_unordered\", atomic_store_handler (__ATOMIC_RELAXED)},\n };\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n@@ -551,6 +566,16 @@ copy_nonoverlapping_handler (Context *ctx, TyTy::FnType *fntype)\n   return fndecl;\n }\n \n+static tree\n+make_unsigned_long_tree (Context *ctx, unsigned long value)\n+{\n+  mpz_t mpz_value;\n+  mpz_init_set_ui (mpz_value, value);\n+\n+  return ctx->get_backend ()->integer_constant_expression (integer_type_node,\n+\t\t\t\t\t\t\t   mpz_value);\n+}\n+\n static tree\n prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n {\n@@ -576,16 +601,8 @@ prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n \n   auto addr = ctx->get_backend ()->var_expression (args[0], Location ());\n   auto locality = ctx->get_backend ()->var_expression (args[1], Location ());\n+  auto rw_flag = make_unsigned_long_tree (ctx, kind == Prefetch::Write ? 1 : 0);\n \n-  mpz_t zero;\n-  mpz_t one;\n-  mpz_init_set_ui (zero, 0);\n-  mpz_init_set_ui (one, 1);\n-\n-  auto rw_flag_value = kind == Prefetch::Write ? one : zero;\n-  auto rw_flag\n-    = ctx->get_backend ()->integer_constant_expression (integer_type_node,\n-\t\t\t\t\t\t\trw_flag_value);\n   auto prefetch_raw = NULL_TREE;\n   auto ok\n     = BuiltinsContext::get ().lookup_simple_builtin (\"prefetch\", &prefetch_raw);\n@@ -597,12 +614,118 @@ prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n     = ctx->get_backend ()->call_expression (prefetch, {addr, rw_flag, locality},\n \t\t\t\t\t    nullptr, Location ());\n \n+  TREE_READONLY (prefetch_call) = 0;\n+  TREE_SIDE_EFFECTS (prefetch_call) = 1;\n+\n   ctx->add_statement (prefetch_call);\n \n   finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;\n }\n \n+static std::string\n+build_atomic_builtin_name (Location locus, tree operand_type)\n+{\n+  static const std::map<std::string, std::string> allowed_types = {\n+    {\"i8\", \"1\"},    {\"i16\", \"2\"},   {\"i32\", \"4\"},   {\"i64\", \"8\"},\n+    {\"i128\", \"16\"}, {\"isize\", \"8\"}, {\"u8\", \"1\"},    {\"u16\", \"2\"},\n+    {\"u32\", \"4\"},   {\"u64\", \"8\"},   {\"u128\", \"16\"}, {\"usize\", \"8\"},\n+  };\n+\n+  // TODO: Can we maybe get the generic version (atomic_store_n) to work... This\n+  // would be so much better\n+\n+  std::string result = \"atomic_store_\";\n+\n+  auto type_name = std::string (TYPE_NAME_STRING (operand_type));\n+  if (type_name == \"usize\" || type_name == \"isize\")\n+    {\n+      rust_sorry_at (\n+\tlocus, \"atomics are not yet available for size types (usize, isize)\");\n+      return \"\";\n+    }\n+\n+  // FIXME: Can we have a better looking name here?\n+  // Instead of `<crate>::<module>::<type>`?\n+  // Maybe instead of giving the tree node, pass the resolved Tyty before it\n+  // gets compiled?\n+  //\n+  // Or should we perform this check somwhere else in the compiler?\n+  auto type_size_str = allowed_types.find (type_name);\n+  if (type_size_str == allowed_types.end ())\n+    {\n+      rust_error_at (locus,\n+\t\t     \"atomic intrinsics are only available for basic integer \"\n+\t\t     \"types: got type %qs\",\n+\t\t     type_name.c_str ());\n+      return \"\";\n+    }\n+\n+  result += type_size_str->second;\n+\n+  return result;\n+}\n+\n+static tree\n+atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n+{\n+  rust_assert (fntype->get_params ().size () == 2);\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // Most intrinsic functions are pure but not the atomic ones\n+  TREE_READONLY (fndecl) = 0;\n+  TREE_SIDE_EFFECTS (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  std::vector<tree> types;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars, &types);\n+\n+  auto ok = ctx->get_backend ()->function_set_parameters (fndecl, param_vars);\n+  rust_assert (ok);\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  auto dst = ctx->get_backend ()->var_expression (param_vars[0], Location ());\n+  TREE_READONLY (dst) = 0;\n+\n+  auto value = ctx->get_backend ()->var_expression (param_vars[1], Location ());\n+  auto memorder = make_unsigned_long_tree (ctx, ordering);\n+\n+  auto builtin_name\n+    = build_atomic_builtin_name (fntype->get_locus (), TREE_TYPE (types[0]));\n+  if (builtin_name.empty ())\n+    return error_mark_node;\n+\n+  tree atomic_store_raw = nullptr;\n+  BuiltinsContext::get ().lookup_simple_builtin (builtin_name,\n+\t\t\t\t\t\t &atomic_store_raw);\n+  rust_assert (atomic_store_raw);\n+\n+  auto atomic_store\n+    = build_fold_addr_expr_loc (Location ().gcc_location (), atomic_store_raw);\n+\n+  auto store_call\n+    = ctx->get_backend ()->call_expression (atomic_store,\n+\t\t\t\t\t    {dst, value, memorder}, nullptr,\n+\t\t\t\t\t    Location ());\n+\n+  TREE_READONLY (store_call) = 0;\n+  TREE_SIDE_EFFECTS (store_call) = 1;\n+\n+  ctx->add_statement (store_call);\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "243d4460089fd6276fb005c1a711c4d24186eedf", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-4.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs?ref=2bc1c5309206169776bdcab862aa2b3da7fc8c95", "patch": "@@ -0,0 +1,20 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    // pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+}\n+\n+fn main() {\n+    let mut dst = 15;\n+    let new_value = 14;\n+\n+    unsafe {\n+        atomic_store_seqcst(&mut dst, new_value);\n+        atomic_store_release(&mut dst, new_value);\n+        atomic_store_relaxed(&mut dst, new_value);\n+        // atomic_store_unordered(&mut dst, new_value);\n+    }\n+}"}, {"sha": "e0087720cc4fd25ecf59d00227be99db652ed32d", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-5.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs?ref=2bc1c5309206169776bdcab862aa2b3da7fc8c95", "patch": "@@ -0,0 +1,35 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, value: T);\n+    // { dg-error \"atomic intrinsics are only available for basic integer types: got type .intrinsics_5::VeryLargeType.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"atomic intrinsics are only available for basic integer types: got type .bool.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct VeryLargeType {\n+    a0: i128,\n+    a1: i128,\n+    a2: i128,\n+    a3: i128,\n+}\n+\n+impl VeryLargeType {\n+    pub fn new(value: i128) -> VeryLargeType {\n+        VeryLargeType {\n+            a0: value,\n+            a1: 0,\n+            a2: 0,\n+            a3: 0,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut dst = VeryLargeType::new(0);\n+    let mut b = false;\n+\n+    unsafe {\n+        atomic_store_seqcst(&mut dst, VeryLargeType::new(1));\n+        atomic_store_seqcst(&mut b, true);\n+    }\n+}"}, {"sha": "9f248b4f823f5175600da5922650d4dea266f0ee", "filename": "gcc/testsuite/rust/execute/torture/atomic_store.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc1c5309206169776bdcab862aa2b3da7fc8c95/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs?ref=2bc1c5309206169776bdcab862aa2b3da7fc8c95", "patch": "@@ -0,0 +1,32 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+}\n+\n+fn main() -> i32 {\n+    let mut dst = 15;\n+    let one;\n+    let two;\n+    let three;\n+    let four;\n+\n+    unsafe {\n+        atomic_store_seqcst(&mut dst, 1);\n+        one = dst;\n+\n+        atomic_store_release(&mut dst, 2);\n+        two = dst;\n+\n+        atomic_store_relaxed(&mut dst, 3);\n+        three = dst;\n+\n+        atomic_store_unordered(&mut dst, 4);\n+        four = dst;\n+    }\n+\n+    (four + three + two + one) - 10\n+}"}]}