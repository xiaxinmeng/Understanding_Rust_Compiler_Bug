{"sha": "873aa8f5480598231174d8781bc60614815dd71d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczYWE4ZjU0ODA1OTgyMzExNzRkODc4MWJjNjA2MTQ4MTVkZDcxZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-16T21:30:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-16T21:30:54Z"}, "message": "cgraph.h (cgraph_decide_inlining_incrementally): Kill.\n\n\t* cgraph.h (cgraph_decide_inlining_incrementally): Kill.\n\t* tree-pass.h: Reorder to make IPA passes appear toegher.\n\t(pass_early_inline, pass_inline_parameters, pass_apply_inline): Declare.\n\t* cgraphunit.c (cgraph_finalize_function): Do not compute inling\n\tparameters, do not call early inliner.\n\t* ipa-inline.c: Update comments.  Include tree-flow.h\n\t(cgraph_decide_inlining): Do not compute inlining parameters.\n\t(cgraph_decide_inlining_incrementally): Return TODOs; assume to\n\tbe called with function context set up.\n\t(pass_ipa_inline): Remove unreachable functions before pass.\n\t(cgraph_early_inlining): Simplify assuming to be called from the\n\tPM as local pass.\n\t(pass_early_inline): New pass.\n\t(cgraph_gate_ipa_early_inlining): New gate.\n\t(pass_ipa_early_inline): Turn into simple wrapper.\n\t(compute_inline_parameters): New function.\n\t(gate_inline_passes): New gate.\n\t(pass_inline_parameters): New pass.\n\t(apply_inline): Move here from tree-optimize.c\n\t(pass_apply_inline): New pass.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Verify cgraph after\n\ttransforming.\n\t* tree-inline.c (optimize_inline_calls): Return TODOs rather than\n\tdoing them by hand.\n\t(tree_function_versioning): Do not allocate dummy struct function.\n\t* tree-inline.h (optimize_inline_calls): Update prototype.\n\t* tree-optimize.c (execute_fixup_cfg): Export.\n\t(pass_fixup_cfg): Remove\n\t(tree_rest_of_compilation): Do not apply inlines.\n\t* tree-flow.h (execute_fixup_cfg): Declare.\n\t* Makefile.in (gt-passes.c): New.\n\t* passes.c: Include gt-passes.h\n\t(init_optimization_passes): New passes.\n\t(nnodes, order): New static vars.\n\t(do_per_function_toporder): New function.\n\t(execute_one_pass): Dump current pass here.\n\t(execute_ipa_pass_list): Don't dump current pass here.\n\nFrom-SVN: r120835", "tree": {"sha": "804fa8f1f32288cbe6d17f5732d75a433109a589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/804fa8f1f32288cbe6d17f5732d75a433109a589"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/873aa8f5480598231174d8781bc60614815dd71d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/873aa8f5480598231174d8781bc60614815dd71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/873aa8f5480598231174d8781bc60614815dd71d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/873aa8f5480598231174d8781bc60614815dd71d/comments", "author": null, "committer": null, "parents": [{"sha": "2797f081d474a208a74af9684d2c5c3dc0ff282d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2797f081d474a208a74af9684d2c5c3dc0ff282d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2797f081d474a208a74af9684d2c5c3dc0ff282d"}], "stats": {"total": 511, "additions": 360, "deletions": 151}, "files": [{"sha": "7d44816fc9e4b98cc57df65fda4eecbdbe8176e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -1,3 +1,43 @@\n+2007-01-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_decide_inlining_incrementally): Kill.\n+\t* tree-pass.h: Reorder to make IPA passes appear toegher.\n+\t(pass_early_inline, pass_inline_parameters, pass_apply_inline): Declare.\n+\t* cgraphunit.c (cgraph_finalize_function): Do not compute inling\n+\tparameters, do not call early inliner.\n+\t* ipa-inline.c: Update comments.  Include tree-flow.h\n+\t(cgraph_decide_inlining): Do not compute inlining parameters.\n+\t(cgraph_decide_inlining_incrementally): Return TODOs; assume to\n+\tbe called with function context set up.\n+\t(pass_ipa_inline): Remove unreachable functions before pass.\n+\t(cgraph_early_inlining): Simplify assuming to be called from the\n+\tPM as local pass.\n+\t(pass_early_inline): New pass.\n+\t(cgraph_gate_ipa_early_inlining): New gate.\n+\t(pass_ipa_early_inline): Turn into simple wrapper.\n+\t(compute_inline_parameters): New function.\n+\t(gate_inline_passes): New gate.\n+\t(pass_inline_parameters): New pass.\n+\t(apply_inline): Move here from tree-optimize.c\n+\t(pass_apply_inline): New pass.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Verify cgraph after\n+\ttransforming.\n+\t* tree-inline.c (optimize_inline_calls): Return TODOs rather than\n+\tdoing them by hand.\n+\t(tree_function_versioning): Do not allocate dummy struct function.\n+\t* tree-inline.h (optimize_inline_calls): Update prototype.\n+\t* tree-optimize.c (execute_fixup_cfg): Export.\n+\t(pass_fixup_cfg): Remove\n+\t(tree_rest_of_compilation): Do not apply inlines.\n+\t* tree-flow.h (execute_fixup_cfg): Declare.\n+\t* Makefile.in (gt-passes.c): New.\n+\t* passes.c: Include gt-passes.h\n+\t(init_optimization_passes): New passes.\n+\t(nnodes, order): New static vars.\n+\t(do_per_function_toporder): New function.\n+\t(execute_one_pass): Dump current pass here.\n+\t(execute_ipa_pass_list): Don't dump current pass here.\n+\n 2007-01-16  Janis Johnson  <janis187@us.ibm.com>\n \n \t* config/dfp-bit.c (dfp_compare_op): Return separate value for NaN."}, {"sha": "33461161d917f14b4ee8619f055c25443e319dee", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -2103,7 +2103,8 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \\\n-   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H)\n+   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n+   gt-passes.h\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n \n@@ -2819,7 +2820,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n   $(srcdir)/tree-ssa-structalias.c \\\n   $(srcdir)/c-pragma.h $(srcdir)/omp-low.c $(srcdir)/varpool.c \\\n-  $(srcdir)/targhooks.c $(out_file) \\\n+  $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c\\\n   @all_gtfiles@\n \n GTFILES_FILES_LANGS = @all_gtfiles_files_langs@\n@@ -2850,7 +2851,7 @@ gt-tree-profile.h gt-tree-ssa-address.h \\\n gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-propagate.h gt-varpool.h \\\n-gt-tree-ssa-structalias.h gt-ipa-inline.h \\\n+gt-tree-ssa-structalias.h gt-ipa-inline.h gt-passes.h \\\n gt-stringpool.h gt-targhooks.h gt-omp-low.h : s-gtype ; @true\n \n define echo_quoted_to_gtyp"}, {"sha": "3a5805e9b8138660d414ce4eab37c93e71284be9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -395,7 +395,6 @@ varpool_next_static_initializer (struct varpool_node *node)\n         (node) = varpool_next_static_initializer (node))\n \n /* In ipa-inline.c  */\n-bool cgraph_decide_inlining_incrementally (struct cgraph_node *, bool);\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);\n void cgraph_mark_inline_edge (struct cgraph_edge *, bool);\n bool cgraph_default_inline_p (struct cgraph_node *, const char **);"}, {"sha": "5a0b9a99c499db0c293cd5d7a2ef132063d9ffbb", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -455,10 +455,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   /* If not unit at a time, then we need to create the call graph\n      now, so that called functions can be queued and emitted now.  */\n   if (!flag_unit_at_a_time)\n-    {\n-      cgraph_analyze_function (node);\n-      cgraph_decide_inlining_incrementally (node, false);\n-    }\n+    cgraph_analyze_function (node);\n \n   if (decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);"}, {"sha": "d369a32dc8ed04d720e8a74bb067b09a4c6d6d51", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 214, "deletions": 57, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -61,7 +61,64 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n       cgraph_decide_inlining implements heuristics taking whole callgraph\n       into account, while cgraph_decide_inlining_incrementally considers\n-      only one function at a time and is used in non-unit-at-a-time mode.  */\n+      only one function at a time and is used in non-unit-at-a-time mode. \n+\n+   The inliner itself is split into several passes:\n+\n+   pass_inline_parameters\n+\n+     This pass computes local properties of functions that are used by inliner:\n+     estimated function body size, whether function is inlinable at all and\n+     stack frame consumption.\n+\n+     Before executing any of inliner passes, this local pass has to be applied\n+     to each function in the callgraph (ie run as subpass of some earlier\n+     IPA pass).  The results are made out of date by any optimization applied\n+     on the function body.\n+\n+   pass_early_inlining\n+\n+     Simple local inlining pass inlining callees into current function.  This\n+     pass makes no global whole compilation unit analysis and this when allowed\n+     to do inlining expanding code size it might result in unbounded growth of\n+     whole unit.\n+\n+     This is the main inlining pass in non-unit-at-a-time.\n+\n+     With unit-at-a-time the pass is run during conversion into SSA form.\n+     Only functions already converted into SSA form are inlined, so the\n+     conversion must happen in topological order on the callgraph (that is\n+     maintained by pass manager).  The functions after inlining are early\n+     optimized so the early inliner sees unoptimized function itself, but\n+     all considered callees are already optimized allowing it to unfold\n+     abstraction penalty on C++ effectivly and cheaply.\n+\n+   pass_ipa_early_inlining\n+\n+     With profiling, the early inlining is also neccesary to reduce\n+     instrumentation costs on program with high abstraction penalty (doing\n+     many redundant calls).  This can't happen in parallel with early\n+     optimization and profile instrumentation, because we would end up\n+     re-instrumenting already instrumented function bodies we brought in via\n+     inlining.\n+\n+     To avoid this, this pass is executed as IPA pass before profiling.  It is\n+     simple wrapper to pass_early_inlining and ensures first inlining.\n+\n+   pass_ipa_inline\n+\n+     This is the main pass implementing simple greedy algorithm to do inlining\n+     of small functions that results in overall growth of compilation unit and\n+     inlining of functions called once.  The pass compute just so called inline\n+     plan (representation of inlining to be done in callgraph) and unlike early\n+     inlining it is not performing the inlining itself.\n+\n+   pass_apply_inline\n+\n+     This pass performs actual inlining according to pass_ipa_inline on given\n+     function.  Possible the function body before inlining is saved when it is\n+     needed for further inlining later.\n+ */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -81,6 +138,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"hashtab.h\"\n #include \"coverage.h\"\n #include \"ggc.h\"\n+#include \"tree-flow.h\"\n \n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n@@ -931,13 +989,6 @@ cgraph_decide_inlining (void)\n       {\n \tstruct cgraph_edge *e;\n \n-\t/* At the moment, no IPA passes change function bodies before inlining.\n-\t   Save some time by not recomputing function body sizes if early inlining\n-\t   already did so.  */\n-\tif (!flag_early_inlining)\n-\t  node->local.self_insns = node->global.insns\n-\t     = estimate_num_insns (node->decl);\n-\n \tinitial_insns += node->local.self_insns;\n \tgcc_assert (node->local.self_insns == node->global.insns);\n \tfor (e = node->callees; e; e = e->next_callee)\n@@ -1088,17 +1139,24 @@ cgraph_decide_inlining (void)\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  */\n \n-bool\n+static unsigned int\n cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n {\n   struct cgraph_edge *e;\n   bool inlined = false;\n   const char *failed_reason;\n+  unsigned int todo = 0;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph_node (node);\n+#endif\n \n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n     if (e->callee->local.disregard_inline_limits\n \t&& e->inline_failed\n+\t&& (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t    == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n         && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n \t/* ??? It is possible that renaming variable removed the function body\n \t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n@@ -1111,6 +1169,13 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t    fprintf (dump_file, \" into %s\\n\", cgraph_node_name (node));\n \t  }\n \tcgraph_mark_inline (e);\n+\t/* In order to fully inline alway_inline functions at -O0, we need to\n+\t   recurse here, since the inlined functions might not be processed by\n+\t   incremental inlining at all yet.  */\n+\t\n+\tif (!flag_unit_at_a_time)\n+          cgraph_decide_inlining_incrementally (e->callee, early);\n+\t\n \tinlined = true;\n       }\n \n@@ -1121,6 +1186,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t  && e->inline_failed\n \t  && !e->callee->local.disregard_inline_limits\n \t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n+\t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t      == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n \t  && (!early\n \t      || (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n \t          <= e->caller->global.insns))\n@@ -1142,19 +1209,13 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t  else if (!early)\n \t    e->inline_failed = failed_reason;\n \t}\n-  if (early && inlined)\n+  if (early && inlined && !node->global.inlined_to)\n     {\n       timevar_push (TV_INTEGRATION);\n-      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-      tree_register_cfg_hooks ();\n-      current_function_decl = node->decl;\n-      optimize_inline_calls (current_function_decl);\n-      node->local.self_insns = node->global.insns;\n-      current_function_decl = NULL;\n-      pop_cfun ();\n+      todo = optimize_inline_calls (current_function_decl);\n       timevar_pop (TV_INTEGRATION);\n     }\n-  return inlined;\n+  return todo;\n }\n \n /* When inlining shall be performed.  */\n@@ -1176,7 +1237,7 @@ struct tree_opt_pass pass_ipa_inline =\n   0,\t                                /* properties_required */\n   PROP_cfg,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_remove_functions,\t\t/* todo_flags_finish */\n   TODO_dump_cgraph | TODO_dump_func\n   | TODO_remove_functions,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n@@ -1194,44 +1255,11 @@ static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n static unsigned int\n cgraph_early_inlining (void)\n {\n-  struct cgraph_node *node;\n-  int i;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n \n   if (sorrycount || errorcount)\n     return 0;\n-#ifdef ENABLE_CHECKING\n-  for (node = cgraph_nodes; node; node = node->next)\n-    gcc_assert (!node->aux);\n-#endif\n-\n-  order = ggc_alloc (sizeof (*order) * cgraph_n_nodes);\n-  nnodes = cgraph_postorder (order);\n-  for (i = nnodes - 1; i >= 0; i--)\n-    {\n-      node = order[i];\n-      if (node->analyzed && (node->needed || node->reachable))\n-        node->local.self_insns = node->global.insns\n-\t  = estimate_num_insns (node->decl);\n-    }\n-  for (i = nnodes - 1; i >= 0; i--)\n-    {\n-      node = order[i];\n-      if (node->analyzed && node->local.inlinable\n-\t  && (node->needed || node->reachable)\n-\t  && node->callers)\n-\t{\n-\t  if (cgraph_decide_inlining_incrementally (node, true))\n-\t    ggc_collect ();\n-\t}\n-    }\n-#ifdef ENABLE_CHECKING\n-  for (node = cgraph_nodes; node; node = node->next)\n-    gcc_assert (!node->global.inlined_to);\n-#endif\n-  ggc_free (order);\n-  order = NULL;\n-  nnodes = 0;\n-  return 0;\n+  return cgraph_decide_inlining_incrementally (node, flag_unit_at_a_time);\n }\n \n /* When inlining shall be performed.  */\n@@ -1241,7 +1269,7 @@ cgraph_gate_early_inlining (void)\n   return flag_inline_trees && flag_early_inlining;\n }\n \n-struct tree_opt_pass pass_early_ipa_inline = \n+struct tree_opt_pass pass_early_inline = \n {\n   \"einline\",\t \t\t\t/* name */\n   cgraph_gate_early_inlining,\t\t/* gate */\n@@ -1254,8 +1282,137 @@ struct tree_opt_pass pass_early_ipa_inline =\n   PROP_cfg,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_cgraph | TODO_dump_func\n-  | TODO_remove_functions,\t\t/* todo_flags_finish */\n+  TODO_dump_func,    \t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* When inlining shall be performed.  */\n+static bool\n+cgraph_gate_ipa_early_inlining (void)\n+{\n+  return (flag_inline_trees && flag_early_inlining\n+\t  && (flag_branch_probabilities || flag_test_coverage\n+\t      || profile_arc_flag));\n+}\n+\n+/* IPA pass wrapper for early inlining pass.  We need to run early inlining\n+   before tree profiling so we have stand alone IPA pass for doing so.  */\n+struct tree_opt_pass pass_ipa_early_inline = \n+{\n+  \"einline_ipa\",\t\t\t/* name */\n+  cgraph_gate_ipa_early_inlining,\t/* gate */\n+  NULL,\t\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  PROP_cfg,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_cgraph, \t\t        /* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* Compute parameters of functions used by inliner.  */\n+static unsigned int\n+compute_inline_parameters (void)\n+{\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+\n+  gcc_assert (!node->global.inlined_to);\n+  node->local.estimated_self_stack_size = estimated_stack_frame_size ();\n+  node->global.estimated_stack_size = node->local.estimated_self_stack_size;\n+  node->global.stack_frame_offset = 0;\n+  node->local.inlinable = tree_inlinable_function_p (current_function_decl);\n+  node->local.self_insns = estimate_num_insns (current_function_decl);\n+  if (node->local.inlinable)\n+    node->local.disregard_inline_limits\n+      = lang_hooks.tree_inlining.disregard_inline_limits (current_function_decl);\n+  if (flag_really_no_inline && !node->local.disregard_inline_limits)\n+    node->local.inlinable = 0;\n+  /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n+  node->global.insns = node->local.self_insns;\n+  return 0;\n+}\n+\n+/* When inlining shall be performed.  */\n+static bool\n+gate_inline_passes (void)\n+{\n+  return flag_inline_trees;\n+}\n+\n+struct tree_opt_pass pass_inline_parameters = \n+{\n+  NULL,\t \t\t\t\t/* name */\n+  gate_inline_passes,\t\t\t/* gate */\n+  compute_inline_parameters,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  PROP_cfg,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* Apply inline plan to the function.  */\n+static unsigned int\n+apply_inline (void)\n+{\n+  unsigned int todo = 0;\n+  struct cgraph_edge *e;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+\n+  /* Even when not optimizing, ensure that always_inline functions get inlined.\n+   */\n+  if (!optimize)\n+   cgraph_decide_inlining_incrementally (node, false);\n+\n+  /* We might need the body of this function so that we can expand\n+     it inline somewhere else.  */\n+  if (cgraph_preserve_function_body_p (current_function_decl))\n+    save_inline_function_body (node);\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (!e->inline_failed || warn_inline)\n+      break;\n+  if (e)\n+    {\n+      timevar_push (TV_INTEGRATION);\n+      todo = optimize_inline_calls (current_function_decl);\n+      timevar_pop (TV_INTEGRATION);\n+    }\n+  /* In non-unit-at-a-time we must mark all referenced functions as needed.  */\n+  if (!flag_unit_at_a_time)\n+    {\n+      struct cgraph_edge *e;\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (e->callee->analyzed)\n+          cgraph_mark_needed_node (e->callee);\n+    }\n+  return todo | execute_fixup_cfg ();\n+}\n+\n+struct tree_opt_pass pass_apply_inline = \n+{\n+  \"apply_inline\",\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  apply_inline,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  PROP_cfg,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_flow\n+  | TODO_verify_stmts,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "9997f6cb79f8b5c38998e7ca0b194e972ed5f8ee", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -206,6 +206,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     node->aux = NULL;\n   if (file)\n     fprintf (file, \"\\nReclaimed %i insns\", insns);\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n   return changed;\n }\n "}, {"sha": "9cb2c5284e44951ee33765326dfc93dc95dd7064", "filename": "gcc/passes.c", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -437,10 +437,11 @@ init_optimization_passes (void)\n   struct tree_opt_pass **p;\n \n #define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n+\n   /* Interprocedural optimization passes.  */\n   p = &all_ipa_passes;\n   NEXT_PASS (pass_ipa_function_and_variable_visibility);\n-  NEXT_PASS (pass_early_ipa_inline);\n+  NEXT_PASS (pass_ipa_early_inline);\n   NEXT_PASS (pass_early_local_passes);\n   NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_cp);\n@@ -451,6 +452,12 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_ipa_pta);\n   *p = NULL;\n \n+  p = &pass_ipa_early_inline.sub;\n+  NEXT_PASS (pass_early_inline);\n+  NEXT_PASS (pass_inline_parameters);\n+  NEXT_PASS (pass_rebuild_cgraph_edges);\n+  *p = NULL;\n+\n   /* All passes needed to lower the function into shape optimizers can\n      operate on.  */\n   p = &all_lowering_passes;\n@@ -464,6 +471,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_warn_function_return);\n   NEXT_PASS (pass_build_cgraph_edges);\n+  NEXT_PASS (pass_inline_parameters);\n   *p = NULL;\n \n   p = &pass_early_local_passes.sub;\n@@ -473,13 +481,16 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_expand_omp);\n   NEXT_PASS (pass_all_early_optimizations);\n   NEXT_PASS (pass_rebuild_cgraph_edges);\n+  NEXT_PASS (pass_inline_parameters);\n   *p = NULL;\n \n   p = &pass_all_early_optimizations.sub;\n   NEXT_PASS (pass_referenced_vars);\n   NEXT_PASS (pass_reset_cc_flags);\n   NEXT_PASS (pass_build_ssa);\n   NEXT_PASS (pass_early_warn_uninitialized);\n+  NEXT_PASS (pass_rebuild_cgraph_edges);\n+  NEXT_PASS (pass_early_inline);\n   NEXT_PASS (pass_cleanup_cfg);\n   NEXT_PASS (pass_rename_ssa_copies);\n   NEXT_PASS (pass_ccp);\n@@ -494,7 +505,7 @@ init_optimization_passes (void)\n   *p = NULL;\n \n   p = &all_passes;\n-  NEXT_PASS (pass_fixup_cfg);\n+  NEXT_PASS (pass_apply_inline);\n   NEXT_PASS (pass_all_optimizations);\n   NEXT_PASS (pass_warn_function_noreturn);\n   NEXT_PASS (pass_free_datastructures);\n@@ -749,6 +760,52 @@ do_per_function (void (*callback) (void *data), void *data)\n     }\n }\n \n+/* Because inlining might remove no-longer reachable nodes, we need to\n+   keep the array visible to garbage collector to avoid reading collected\n+   out nodes.  */\n+static int nnodes;\n+static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n+\n+/* If we are in IPA mode (i.e., current_function_decl is NULL), call\n+   function CALLBACK for every function in the call graph.  Otherwise,\n+   call CALLBACK on the current function.  */ \n+\n+static void\n+do_per_function_toporder (void (*callback) (void *data), void *data)\n+{\n+  int i;\n+\n+  if (current_function_decl)\n+    callback (data);\n+  else\n+    {\n+      gcc_assert (!order);\n+      order = ggc_alloc (sizeof (*order) * cgraph_n_nodes);\n+      nnodes = cgraph_postorder (order);\n+      for (i = nnodes - 1; i >= 0; i--)\n+\t{\n+\t  struct cgraph_node *node = order[i];\n+\n+\t  /* Allow possibly removed nodes to be garbage collected.  */\n+\t  order[i] = NULL;\n+\t  if (node->analyzed && (node->needed || node->reachable))\n+\t    {\n+\t      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\t      current_function_decl = node->decl;\n+\t      callback (data);\n+\t      free_dominance_info (CDI_DOMINATORS);\n+\t      free_dominance_info (CDI_POST_DOMINATORS);\n+\t      current_function_decl = NULL;\n+\t      pop_cfun ();\n+\t      ggc_collect ();\n+\t    }\n+\t}\n+    }\n+  ggc_free (order);\n+  order = NULL;\n+  nnodes = 0;\n+}\n+\n /* Perform all TODO actions that ought to be done on each function.  */\n \n static void\n@@ -903,6 +960,9 @@ execute_one_pass (struct tree_opt_pass *pass)\n   if (pass->gate && !pass->gate ())\n     return false;\n \n+  if (!quiet_flag && !cfun)\n+    fprintf (stderr, \" <%s>\", pass->name ? pass->name : \"\");\n+\n   if (pass->todo_flags_start & TODO_set_props)\n     cfun->curr_properties = pass->properties_required;\n \n@@ -1012,16 +1072,13 @@ execute_ipa_pass_list (struct tree_opt_pass *pass)\n     {\n       gcc_assert (!current_function_decl);\n       gcc_assert (!cfun);\n-      if (!quiet_flag)\n-\t{\n-          fprintf (stderr, \" <%s>\", pass->name ? pass->name : \"\");\n-\t  fflush (stderr);\n-\t}\n       if (execute_one_pass (pass) && pass->sub)\n-\tdo_per_function ((void (*)(void *))execute_pass_list, pass->sub);\n+\tdo_per_function_toporder ((void (*)(void *))execute_pass_list,\n+\t\t\t\t  pass->sub);\n       if (!current_function_decl)\n \tcgraph_process_new_functions ();\n       pass = pass->next;\n     }\n   while (pass);\n }\n+#include \"gt-passes.h\""}, {"sha": "7ebe52f4afe7a40257e83831cae3cdf863199948", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -1058,6 +1058,7 @@ void sort_fieldstack (VEC(fieldoff_s,heap) *);\n \n void init_alias_heapvars (void);\n void delete_alias_heapvars (void);\n+unsigned int execute_fixup_cfg (void);\n \n #include \"tree-flow-inline.h\"\n "}, {"sha": "813f18db307dd76d976c82b0dcfa7be08b88c1e8", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -2613,7 +2613,7 @@ fold_marked_statements (int first, struct pointer_set_t *statements)\n \n /* Expand calls to inline functions in the body of FN.  */\n \n-void\n+unsigned int\n optimize_inline_calls (tree fn)\n {\n   copy_body_data id;\n@@ -2624,7 +2624,7 @@ optimize_inline_calls (tree fn)\n      occurred -- and we might crash if we try to inline invalid\n      code.  */\n   if (errorcount || sorrycount)\n-    return;\n+    return 0;\n \n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n@@ -2679,25 +2679,22 @@ optimize_inline_calls (tree fn)\n   if (ENTRY_BLOCK_PTR->count)\n     counts_to_freqs ();\n \n+  /* We are not going to maintain the cgraph edges up to date.\n+     Kill it so it won't confuse us.  */\n+  cgraph_node_remove_callees (id.dst_node);\n+\n   fold_marked_statements (last, id.statements_to_fold);\n   pointer_set_destroy (id.statements_to_fold);\n-  if (gimple_in_ssa_p (cfun))\n-    {\n-      /* We make no attempts to keep dominance info up-to-date.  */\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      delete_unreachable_blocks ();\n-      update_ssa (TODO_update_ssa);\n-      fold_cond_expr_cond ();\n-      if (need_ssa_update_p ())\n-        update_ssa (TODO_update_ssa);\n-    }\n-  else\n-    fold_cond_expr_cond ();\n+  fold_cond_expr_cond ();\n+  /* We make no attempts to keep dominance info up-to-date.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n   /* It would be nice to check SSA/CFG/statement consistency here, but it is\n      not possible yet - the IPA passes might make various functions to not\n      throw and they don't care to proactively update local EH info.  This is\n      done later in fixup_cfg pass that also execute the verification.  */\n+  return (TODO_update_ssa | TODO_cleanup_cfg\n+\t  | (gimple_in_ssa_p (cfun) ? TODO_remove_unused_locals : 0));\n }\n \n /* FN is a function that has a complete body, and CLONE is a function whose\n@@ -3194,6 +3191,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   struct ipa_replace_map *replace_info;\n   basic_block old_entry_block;\n   tree t_step;\n+  tree old_current_function_decl = current_function_decl;\n \n   gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL\n \t      && TREE_CODE (new_decl) == FUNCTION_DECL);\n@@ -3202,10 +3200,6 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   old_version_node = cgraph_node (old_decl);\n   new_version_node = cgraph_node (new_decl);\n \n-  allocate_struct_function (new_decl);\n-  /* Cfun points to the new allocated function struct at this point.  */\n-  cfun->function_end_locus = DECL_SOURCE_LOCATION (new_decl);\n-\n   DECL_ARTIFICIAL (new_decl) = 1;\n   DECL_ABSTRACT_ORIGIN (new_decl) = DECL_ORIGIN (old_decl);\n \n@@ -3322,7 +3316,9 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   pop_cfun ();\n-  current_function_decl = NULL;\n+  current_function_decl = old_current_function_decl;\n+  gcc_assert (!current_function_decl\n+\t      || DECL_STRUCT_FUNCTION (current_function_decl) == cfun);\n   return;\n }\n "}, {"sha": "102d590a4d3f68fdb06094aab018d0f270351b24", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -98,7 +98,7 @@ typedef struct copy_body_data\n extern tree copy_body_r (tree *, int *, void *);\n extern void insert_decl_map (copy_body_data *, tree, tree);\n \n-void optimize_inline_calls (tree);\n+unsigned int optimize_inline_calls (tree);\n bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n void clone_body (tree, tree, void *);"}, {"sha": "1299a856ffd2198074b9548cddb47071a08e9265", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 10, "deletions": 55, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -285,9 +285,12 @@ has_abnormal_outgoing_edge_p (basic_block bb)\n /* Pass: fixup_cfg.  IPA passes, compilation of earlier functions or inlining\n    might have changed some properties, such as marked functions nothrow or\n    added calls that can potentially go to non-local labels.  Remove redundant\n-   edges and basic blocks, and create new ones if necessary.  */\n+   edges and basic blocks, and create new ones if necessary.\n \n-static unsigned int\n+   This pass can't be executed as stand alone pass from pass manager, because\n+   in between inlining and this fixup the verify_flow_info would fail.  */\n+\n+unsigned int\n execute_fixup_cfg (void)\n {\n   basic_block bb;\n@@ -310,7 +313,7 @@ execute_fixup_cfg (void)\n \t      {\n \t\tif (gimple_in_ssa_p (cfun))\n \t\t  {\n-\t\t    todo |= TODO_update_ssa;\n+\t\t    todo |= TODO_update_ssa | TODO_cleanup_cfg;\n \t            update_stmt (stmt);\n \t\t  }\n \t        TREE_SIDE_EFFECTS (call) = 0;\n@@ -320,7 +323,8 @@ execute_fixup_cfg (void)\n \t    if (!tree_could_throw_p (stmt) && lookup_stmt_eh_region (stmt))\n \t      remove_stmt_from_eh_region (stmt);\n \t  }\n-\ttree_purge_dead_eh_edges (bb);\n+\tif (tree_purge_dead_eh_edges (bb))\n+          todo |= TODO_cleanup_cfg;\n       }\n \n   if (current_function_has_nonlocal_label)\n@@ -358,7 +362,7 @@ execute_fixup_cfg (void)\n \n \t\t      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t\t\t{\n-\t\t          todo |= TODO_update_ssa;\n+\t\t          todo |= TODO_update_ssa | TODO_cleanup_cfg;\n \t\t\t  gcc_assert (SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n \t\t\t\t      (PHI_RESULT (phi)));\n \t\t\t  mark_sym_for_renaming\n@@ -377,24 +381,6 @@ execute_fixup_cfg (void)\n   return todo;\n }\n \n-struct tree_opt_pass pass_fixup_cfg =\n-{\n-  \"fixupcfg\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_fixup_cfg,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  0,\t\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg | TODO_ggc_collect\n-  | TODO_dump_func | TODO_verify_flow\n-  | TODO_verify_stmts,/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */ };\n-\n /* Do the actions required to initialize internal data structures used\n    in tree-ssa optimization passes.  */\n \n@@ -487,13 +473,9 @@ tree_rest_of_compilation (tree fndecl)\n   /* Initialize the default bitmap obstack.  */\n   bitmap_obstack_initialize (NULL);\n \n-  /* We might need the body of this function so that we can expand\n-     it inline somewhere else.  */\n-  if (cgraph_preserve_function_body_p (fndecl))\n-    save_inline_function_body (node);\n-\n   /* Initialize the RTL code for the function.  */\n   current_function_decl = fndecl;\n+  cfun = DECL_STRUCT_FUNCTION (fndecl);\n   saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n   init_function_start (fndecl);\n@@ -506,33 +488,6 @@ tree_rest_of_compilation (tree fndecl)\n   \n   tree_register_cfg_hooks ();\n \n-  if (flag_inline_trees)\n-    {\n-      struct cgraph_edge *e;\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (!e->inline_failed || warn_inline)\n-\t  break;\n-      if (e)\n-\t{\n-\t  timevar_push (TV_INTEGRATION);\n-\t  optimize_inline_calls (fndecl);\n-\t  timevar_pop (TV_INTEGRATION);\n-\t}\n-    }\n-  /* In non-unit-at-a-time we must mark all referenced functions as needed.\n-     */\n-  if (!flag_unit_at_a_time)\n-    {\n-      struct cgraph_edge *e;\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (e->callee->analyzed)\n-          cgraph_mark_needed_node (e->callee);\n-    }\n-\n-  /* We are not going to maintain the cgraph edges up to date.\n-     Kill it so it won't confuse us.  */\n-  cgraph_node_remove_callees (node);\n-\n   bitmap_obstack_initialize (&reg_obstack); /* FIXME, only at RTL generation*/\n   /* Perform all tree transforms and optimizations.  */\n   execute_pass_list (all_passes);"}, {"sha": "b904e10d62425691dcec051dd62d94aabe33ea37", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873aa8f5480598231174d8781bc60614815dd71d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=873aa8f5480598231174d8781bc60614815dd71d", "patch": "@@ -310,13 +310,12 @@ extern struct tree_opt_pass pass_reset_cc_flags;\n /* IPA Passes */\n extern struct tree_opt_pass pass_ipa_cp;\n extern struct tree_opt_pass pass_ipa_inline;\n-extern struct tree_opt_pass pass_early_ipa_inline;\n+extern struct tree_opt_pass pass_ipa_early_inline;\n extern struct tree_opt_pass pass_ipa_reference;\n extern struct tree_opt_pass pass_ipa_pure_const;\n extern struct tree_opt_pass pass_ipa_type_escape;\n extern struct tree_opt_pass pass_ipa_pta;\n extern struct tree_opt_pass pass_early_local_passes;\n-extern struct tree_opt_pass pass_all_early_optimizations;\n extern struct tree_opt_pass pass_ipa_increase_alignment;\n extern struct tree_opt_pass pass_ipa_function_and_variable_visibility;\n \n@@ -399,6 +398,10 @@ extern struct tree_opt_pass pass_set_nothrow_function_flags;\n extern struct tree_opt_pass pass_final;\n extern struct tree_opt_pass pass_rtl_seqabstr;\n extern struct tree_opt_pass pass_release_ssa_names;\n+extern struct tree_opt_pass pass_early_inline;\n+extern struct tree_opt_pass pass_inline_parameters;\n+extern struct tree_opt_pass pass_apply_inline;\n+extern struct tree_opt_pass pass_all_early_optimizations;\n \n /* The root of the compilation pass tree, once constructed.  */\n extern struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;"}]}