{"sha": "6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEwMTg0OTU1YzBiNjJmNzhjMTNlZDIzNGIxYmMxYzczZDM3MDNiOQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-07-29T21:07:34Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-07-29T21:07:34Z"}, "message": "re PR fortran/45087 (-fwhole-program: Miscompiled due to wrong decls)\n\n2010-07-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45087\n        PR fortran/45125\n        * trans-decl.c (gfc_get_extern_function_decl): Correctly handle\n        external procedure declarations in modules.\n        (gfc_get_symbol_decl): Modify assert.\n\n2010-07-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45087\n        PR fortran/45125\n        * gfortran.dg/whole_file_25.f90: New.\n        * gfortran.dg/whole_file_26.f90: New.\n        * gfortran.dg/whole_file_27.f90: New.\n\nFrom-SVN: r162696", "tree": {"sha": "3cf1174370b9769958d2982a1e60504afc5542cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cf1174370b9769958d2982a1e60504afc5542cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a68e29dc51525dc6bb8e6e7cb4df6cfa060383c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a68e29dc51525dc6bb8e6e7cb4df6cfa060383c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a68e29dc51525dc6bb8e6e7cb4df6cfa060383c"}], "stats": {"total": 292, "additions": 286, "deletions": 6}, "files": [{"sha": "b5b2923bcacaa1d98ca276cbf5b8be04366a3675", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "patch": "@@ -1,3 +1,11 @@\n+2010-07-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45087\n+\tPR fortran/45125\n+\t* trans-decl.c (gfc_get_extern_function_decl): Correctly handle\n+\texternal procedure declarations in modules.\n+\t(gfc_get_symbol_decl): Modify assert.\n+\n 2010-07-29  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44962"}, {"sha": "b544fa89b61cc16b906d3f55ecc2a7db669af6d1", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "patch": "@@ -1045,7 +1045,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \n   gcc_assert (sym->attr.referenced\n \t\t|| sym->attr.use_assoc\n-\t\t|| sym->ns->proc_name->attr.if_source == IFSRC_IFBODY);\n+\t\t|| sym->ns->proc_name->attr.if_source == IFSRC_IFBODY\n+\t\t|| (sym->module && sym->attr.if_source != IFSRC_DECL\n+\t\t    && sym->backend_decl));\n \n   if (sym->ns && sym->ns->proc_name && sym->ns->proc_name->attr.function)\n     byref = gfc_return_by_reference (sym->ns->proc_name);\n@@ -1409,7 +1411,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->name);\n \n   if (gfc_option.flag_whole_file\n-\t&& !sym->attr.use_assoc\n+\t&& (!sym->attr.use_assoc || sym->attr.if_source != IFSRC_DECL)\n \t&& !sym->backend_decl\n \t&& gsym && gsym->ns\n \t&& ((gsym->type == GSYM_SUBROUTINE) || (gsym->type == GSYM_FUNCTION))\n@@ -1450,12 +1452,17 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n \t    }\n \t}\n       else\n-\t{\n-\t  sym->backend_decl = gsym->ns->proc_name->backend_decl;\n-\t}\n+\tsym->backend_decl = gsym->ns->proc_name->backend_decl;\n \n       if (sym->backend_decl)\n-\treturn sym->backend_decl;\n+\t{\n+\t  /* Avoid problems of double deallocation of the backend declaration\n+\t     later in gfc_trans_use_stmts; cf. PR 45087.  */\n+\t  if (sym->attr.if_source != IFSRC_DECL && sym->attr.use_assoc)\n+\t    sym->attr.use_assoc = 0;\n+\n+\t  return sym->backend_decl;\n+\t}\n     }\n \n   /* See if this is a module procedure from the same file.  If so,"}, {"sha": "4dd9b5ecae7a40d550d93053ff0ad5cedbd4258b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "patch": "@@ -1,3 +1,11 @@\n+2010-07-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45087\n+\tPR fortran/45125\n+\t* gfortran.dg/whole_file_25.f90: New.\n+\t* gfortran.dg/whole_file_26.f90: New.\n+\t* gfortran.dg/whole_file_27.f90: New.\n+\n 2010-07-29  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44962"}, {"sha": "d2cbd36ae1d6366630b686d6e621655179001fd7", "filename": "gcc/testsuite/gfortran.dg/whole_file_25.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_25.f90?ref=6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-program\" }\n+!\n+! PR fortran/45087\n+!\n+\n+module ints\n+   INTERFACE\n+      SUBROUTINE NOZZLE()\n+      END SUBROUTINE NOZZLE\n+   END INTERFACE\n+end module ints\n+\n+      SUBROUTINE NOZZLE()\n+      END SUBROUTINE NOZZLE\n+      program CORTESA \n+      USE INTS\n+      CALL NOZZLE ()\n+      END program CORTESA\n+\n+! { dg-final { cleanup-modules \"ints\" } }"}, {"sha": "8ce45107086b1cf5e3148d622e483bb819705c84", "filename": "gcc/testsuite/gfortran.dg/whole_file_26.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_26.f90?ref=6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-program  --param ggc-min-expand=0 --param ggc-min-heapsize=0\" }\n+!\n+! PR fortran/45087\n+!\n+\n+module INTS\n+  interface\n+    subroutine NEXT\n+    end subroutine NEXT\n+    subroutine VALUE()\n+    end subroutine VALUE\n+  end interface\n+end module INTS\n+\n+subroutine NEXT\n+end subroutine NEXT\n+\n+subroutine VALUE()\n+  use INTS, only: NEXT\n+  CALL NEXT\n+end subroutine VALUE\n+\n+end\n+\n+! { dg-final { cleanup-modules \"ints\" } }"}, {"sha": "4129547273168988a67a082b1766b012256bcc8c", "filename": "gcc/testsuite/gfortran.dg/whole_file_27.f90", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_27.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0184955c0b62f78c13ed234b1bc1c73d3703b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_27.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_27.f90?ref=6a0184955c0b62f78c13ed234b1bc1c73d3703b9", "patch": "@@ -0,0 +1,210 @@\n+! { dg-do compile }\n+!\n+! PR fortran/45125\n+!\n+! Contributed by Salvatore Filippone and Dominique d'Humieres.\n+!\n+\n+module const_mod\n+  ! This is the default integer\n+  integer, parameter  :: ndig=8\n+  integer, parameter  :: int_k_ = selected_int_kind(ndig)\n+  ! This is an 8-byte  integer, and normally different from default integer. \n+  integer, parameter  :: longndig=12\n+  integer, parameter  :: long_int_k_ = selected_int_kind(longndig)\n+  !\n+  ! These must be the kind parameter corresponding to MPI_DOUBLE_PRECISION\n+  ! and MPI_REAL\n+  !\n+  integer, parameter  :: dpk_ = kind(1.d0)\n+  integer, parameter  :: spk_ = kind(1.e0)\n+  integer, save       :: sizeof_dp, sizeof_sp\n+  integer, save       :: sizeof_int, sizeof_long_int\n+  integer, save       :: mpi_integer\n+\n+  integer, parameter :: invalid_ = -1 \n+  integer, parameter :: spmat_null_=0, spmat_bld_=1\n+  integer, parameter :: spmat_asb_=2, spmat_upd_=4\n+\n+  !\n+  ! \n+  !     Error constants\n+  integer, parameter, public :: success_=0\n+  integer, parameter, public :: err_iarg_neg_=10\n+end module const_mod\n+module base_mat_mod\n+  \n+  use const_mod \n+\n+\n+  type  :: base_sparse_mat\n+    integer, private     :: m, n\n+    integer, private     :: state, duplicate \n+    logical, private     :: triangle, unitd, upper, sorted\n+  contains \n+\n+    procedure, pass(a) :: get_fmt => base_get_fmt\n+    procedure, pass(a) :: set_null => base_set_null\n+    procedure, pass(a) :: allocate_mnnz => base_allocate_mnnz\n+    generic,   public  :: allocate => allocate_mnnz\n+  end type base_sparse_mat\n+\n+  interface \n+    subroutine  base_allocate_mnnz(m,n,a,nz) \n+      import base_sparse_mat, long_int_k_\n+      integer, intent(in) :: m,n\n+      class(base_sparse_mat), intent(inout) :: a\n+      integer, intent(in), optional  :: nz\n+    end subroutine base_allocate_mnnz\n+  end interface\n+\n+contains\n+\n+  function base_get_fmt(a) result(res)\n+    implicit none \n+    class(base_sparse_mat), intent(in) :: a\n+    character(len=5) :: res\n+    res = 'NULL'\n+  end function base_get_fmt\n+\n+  subroutine  base_set_null(a) \n+    implicit none \n+    class(base_sparse_mat), intent(inout) :: a\n+\n+    a%state = spmat_null_\n+  end subroutine base_set_null\n+\n+\n+end module base_mat_mod\n+\n+module d_base_mat_mod\n+  \n+  use base_mat_mod\n+\n+  type, extends(base_sparse_mat) :: d_base_sparse_mat\n+  contains\n+  end type d_base_sparse_mat\n+  \n+  \n+  \n+  type, extends(d_base_sparse_mat) :: d_coo_sparse_mat\n+    \n+    integer              :: nnz\n+    integer, allocatable :: ia(:), ja(:)\n+    real(dpk_), allocatable :: val(:)\n+    \n+  contains\n+    \n+    procedure, pass(a) :: get_fmt      => d_coo_get_fmt\n+    procedure, pass(a) :: allocate_mnnz => d_coo_allocate_mnnz\n+    \n+  end type d_coo_sparse_mat\n+  \n+  \n+  interface\n+    subroutine  d_coo_allocate_mnnz(m,n,a,nz) \n+      import d_coo_sparse_mat\n+      integer, intent(in) :: m,n\n+      class(d_coo_sparse_mat), intent(inout) :: a\n+      integer, intent(in), optional :: nz\n+    end subroutine d_coo_allocate_mnnz\n+  end interface\n+  \n+contains \n+  \n+  function d_coo_get_fmt(a) result(res)\n+    implicit none \n+    class(d_coo_sparse_mat), intent(in) :: a\n+    character(len=5) :: res\n+    res = 'COO'\n+  end function d_coo_get_fmt\n+  \n+end module d_base_mat_mod\n+\n+subroutine  base_allocate_mnnz(m,n,a,nz) \n+  use base_mat_mod, protect_name => base_allocate_mnnz\n+  implicit none \n+  integer, intent(in) :: m,n\n+  class(base_sparse_mat), intent(inout) :: a\n+  integer, intent(in), optional  :: nz\n+  Integer :: err_act\n+  character(len=20)  :: name='allocate_mnz', errfmt\n+  logical, parameter :: debug=.false.\n+\n+  ! This is the base version. If we get here\n+  ! it means the derived class is incomplete,\n+  ! so we throw an error.\n+  errfmt=a%get_fmt()\n+  write(0,*) 'Error: Missing ovverriding impl for allocate in class ',errfmt\n+\n+  return\n+\n+end subroutine base_allocate_mnnz\n+\n+subroutine  d_coo_allocate_mnnz(m,n,a,nz) \n+  use d_base_mat_mod, protect_name => d_coo_allocate_mnnz\n+  implicit none \n+  integer, intent(in) :: m,n\n+  class(d_coo_sparse_mat), intent(inout) :: a\n+  integer, intent(in), optional :: nz\n+  Integer :: err_act, info, nz_\n+  character(len=20)  :: name='allocate_mnz'\n+  logical, parameter :: debug=.false.\n+\n+  info = success_\n+  if (m < 0) then \n+    info = err_iarg_neg_\n+  endif\n+  if (n < 0) then \n+    info = err_iarg_neg_\n+  endif\n+  if (present(nz)) then \n+    nz_ = nz\n+  else\n+    nz_ = max(7*m,7*n,1)\n+  end if\n+  if (nz_ < 0) then \n+    info = err_iarg_neg_\n+  endif\n+! !$  if (info == success_) call realloc(nz_,a%ia,info)\n+! !$  if (info == success_) call realloc(nz_,a%ja,info)\n+! !$  if (info == success_) call realloc(nz_,a%val,info)\n+  if (info == success_) then \n+! !$    call a%set_nrows(m)\n+! !$    call a%set_ncols(n)\n+! !$    call a%set_nzeros(0)\n+! !$    call a%set_bld()\n+! !$    call a%set_triangle(.false.)\n+! !$    call a%set_unit(.false.)\n+! !$    call a%set_dupl(dupl_def_)\n+    write(0,*) 'Allocated COO succesfully, should now set components'\n+  else \n+    write(0,*) 'COO allocation failed somehow. Go figure'\n+  end if\n+  return\n+\n+end subroutine d_coo_allocate_mnnz\n+\n+\n+program d_coo_err\n+  use d_base_mat_mod\n+  implicit none\n+\n+  integer            :: ictxt, iam, np\n+\n+  ! solver parameters\n+  type(d_coo_sparse_mat) :: acoo\n+  \n+  ! other variables\n+  integer nnz, n\n+\n+  n   = 32\n+  nnz = n*9\n+  \n+  call acoo%set_null()\n+  call acoo%allocate(n,n,nz=nnz)\n+\n+  stop\n+end program d_coo_err\n+\n+! { dg-final { cleanup-modules \"base_mat_mod const_mod d_base_mat_mod\" } }"}]}