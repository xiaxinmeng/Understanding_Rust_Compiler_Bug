{"sha": "6aec53ee4f75a64cc9c35577e8d785ba2b692270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFlYzUzZWU0Zjc1YTY0Y2M5YzM1NTc3ZThkNzg1YmEyYjY5MjI3MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-08-05T10:04:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-08-05T11:59:07Z"}, "message": "refactor LIM a bit\n\nThis refactors LIM to eschew alloc_aux_for_edges and re-uses the RPO\norder of the move_computations walk for invariantness computation as well.\nIt also removes one unnecessary sorting (but retaining it as checking\ncode because we bsearch the vector) and moves edge insert commit code\nto the place where it doesn't have to scan all the functions edges.\n\nThis was all done when investigating whether LIM can be refactored\nto work on a specific loop for on-demand processing (but we're not\nthere yet).\n\n2020-08-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (invariantness_dom_walker): Remove.\n\t(invariantness_dom_walker::before_dom_children): Move to ...\n\t(compute_invariantness): ... this function.\n\t(move_computations): Inline ...\n\t(tree_ssa_lim): ... here, share RPO order and avoid some\n\tcfun references.\n\t(analyze_memory_references): Remove sorting of location\n\tlists, instead assert they are sorted already when checking.\n\t(prev_flag_edges): Remove.\n\t(execute_sm_if_changed): Pass down and adjust prev edge state.\n\t(execute_sm_exit): Likewise.\n\t(hoist_memory_references): Likewise.  Commit edge insertions\n\tof each processed exit.\n\t(store_motion_loop): Do not commit edge insertions on all\n\tedges in the function.\n\t(tree_ssa_lim_initialize): Do not call alloc_aux_for_edges.\n\t(tree_ssa_lim_finalize): Do not call free_aux_for_edges.", "tree": {"sha": "59dc5dd2484cbbf2e0eaedacc1167d03e2304e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59dc5dd2484cbbf2e0eaedacc1167d03e2304e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6aec53ee4f75a64cc9c35577e8d785ba2b692270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aec53ee4f75a64cc9c35577e8d785ba2b692270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aec53ee4f75a64cc9c35577e8d785ba2b692270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aec53ee4f75a64cc9c35577e8d785ba2b692270/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0699540f37e2550974f9049778a42a634062c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0699540f37e2550974f9049778a42a634062c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0699540f37e2550974f9049778a42a634062c0b"}], "stats": {"total": 153, "additions": 58, "deletions": 95}, "files": [{"sha": "35da1fb26a67f2a53b6a1e4a28153fe58295d5cd", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 58, "deletions": 95, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aec53ee4f75a64cc9c35577e8d785ba2b692270/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aec53ee4f75a64cc9c35577e8d785ba2b692270/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=6aec53ee4f75a64cc9c35577e8d785ba2b692270", "patch": "@@ -37,7 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop.h\"\n #include \"tree-into-ssa.h\"\n #include \"cfgloop.h\"\n-#include \"domwalk.h\"\n #include \"tree-affine.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"trans-mem.h\"\n@@ -970,25 +969,12 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n   return stmt;\n }\n \n-/* For each statement determines the outermost loop in that it is invariant,\n-   -   statements on whose motion it depends and the cost of the computation.\n-   -   This information is stored to the LIM_DATA structure associated with\n-   -   each statement.  */\n-class invariantness_dom_walker : public dom_walker\n-{\n-public:\n-  invariantness_dom_walker (cdi_direction direction)\n-    : dom_walker (direction) {}\n-\n-  virtual edge before_dom_children (basic_block);\n-};\n-\n /* Determine the outermost loops in that statements in basic block BB are\n-   invariant, and record them to the LIM_DATA associated with the statements.\n-   Callback for dom_walker.  */\n+   invariant, and record them to the LIM_DATA associated with the\n+   statements.  */\n \n-edge\n-invariantness_dom_walker::before_dom_children (basic_block bb)\n+static void\n+compute_invariantness (basic_block bb)\n {\n   enum move_pos pos;\n   gimple_stmt_iterator bsi;\n@@ -998,7 +984,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n   struct lim_aux_data *lim_data;\n \n   if (!loop_outer (bb->loop_father))\n-    return NULL;\n+    return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Basic block %d (loop %d -- depth %d):\\n\\n\",\n@@ -1122,7 +1108,6 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n       if (lim_data->cost >= LIM_EXPENSIVE)\n \tset_profitable_level (stmt);\n     }\n-  return NULL;\n }\n \n /* Hoist the statements in basic block BB out of the loops prescribed by\n@@ -1289,28 +1274,6 @@ move_computations_worker (basic_block bb)\n   return todo;\n }\n \n-/* Hoist the statements out of the loops prescribed by data stored in\n-   LIM_DATA structures associated with each statement.*/\n-\n-static unsigned int\n-move_computations (void)\n-{\n-  int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  int n = pre_and_rev_post_order_compute_fn (cfun, NULL, rpo, false);\n-  unsigned todo = 0;\n-\n-  for (int i = 0; i < n; ++i)\n-    todo |= move_computations_worker (BASIC_BLOCK_FOR_FN (cfun, rpo[i]));\n-\n-  free (rpo);\n-\n-  gsi_commit_edge_inserts ();\n-  if (need_ssa_update_p (cfun))\n-    rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-\n-  return todo;\n-}\n-\n /* Checks whether the statement defining variable *INDEX can be hoisted\n    out of the loop passed in DATA.  Callback for for_each_index.  */\n \n@@ -1678,20 +1641,27 @@ analyze_memory_references (void)\n \t      bb_loop_postorder);\n \n   /* Visit blocks in loop postorder and assign mem-ref IDs in that order.\n-     That results in better locality for all the bitmaps.  */\n+     That results in better locality for all the bitmaps.  It also\n+     automatically sorts the location list of gathered memory references\n+     after their loop postorder number allowing to binary-search it.  */\n   for (i = 0; i < n; ++i)\n     {\n       basic_block bb = bbs[i];\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n         gather_mem_refs_stmt (bb->loop_father, gsi_stmt (bsi));\n     }\n \n-  /* Sort the location list of gathered memory references after their\n+  /* Verify the list of gathered memory references is sorted after their\n      loop postorder number.  */\n-  im_mem_ref *ref;\n-  FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n-    ref->accesses_in_loop.sort (sort_locs_in_loop_postorder_cmp,\n-\t\t\t\tbb_loop_postorder);\n+  if (flag_checking)\n+    {\n+      im_mem_ref *ref;\n+      FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n+\tfor (unsigned j = 1; j < ref->accesses_in_loop.length (); ++j)\n+\t  gcc_assert (sort_locs_in_loop_postorder_cmp\n+\t\t\t(&ref->accesses_in_loop[j-1], &ref->accesses_in_loop[j],\n+\t\t\t bb_loop_postorder) <= 0);\n+    }\n \n   free (bbs);\n \n@@ -1865,14 +1835,6 @@ first_mem_ref_loc (class loop *loop, im_mem_ref *ref)\n   return locp;\n }\n \n-struct prev_flag_edges {\n-  /* Edge to insert new flag comparison code.  */\n-  edge append_cond_position;\n-\n-  /* Edge for fall through from previous flag comparison.  */\n-  edge last_cond_fallthru;\n-};\n-\n /* Helper function for execute_sm.  Emit code to store TMP_VAR into\n    MEM along edge EX.\n \n@@ -1920,14 +1882,14 @@ struct prev_flag_edges {\n \n static void\n execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n-\t\t       edge preheader, hash_set <basic_block> *flag_bbs)\n+\t\t       edge preheader, hash_set <basic_block> *flag_bbs,\n+\t\t       edge &append_cond_position, edge &last_cond_fallthru)\n {\n   basic_block new_bb, then_bb, old_dest;\n   bool loop_has_only_one_exit;\n-  edge then_old_edge, orig_ex = ex;\n+  edge then_old_edge;\n   gimple_stmt_iterator gsi;\n   gimple *stmt;\n-  struct prev_flag_edges *prev_edges = (struct prev_flag_edges *) ex->aux;\n   bool irr = ex->flags & EDGE_IRREDUCIBLE_LOOP;\n \n   profile_count count_sum = profile_count::zero ();\n@@ -1975,8 +1937,8 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \n   /* ?? Insert store after previous store if applicable.  See note\n      below.  */\n-  if (prev_edges)\n-    ex = prev_edges->append_cond_position;\n+  if (append_cond_position)\n+    ex = append_cond_position;\n \n   loop_has_only_one_exit = single_pred_p (ex->dest);\n \n@@ -2033,10 +1995,10 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \n   set_immediate_dominator (CDI_DOMINATORS, then_bb, new_bb);\n \n-  if (prev_edges)\n+  if (append_cond_position)\n     {\n-      basic_block prevbb = prev_edges->last_cond_fallthru->src;\n-      redirect_edge_succ (prev_edges->last_cond_fallthru, new_bb);\n+      basic_block prevbb = last_cond_fallthru->src;\n+      redirect_edge_succ (last_cond_fallthru, new_bb);\n       set_immediate_dominator (CDI_DOMINATORS, new_bb, prevbb);\n       set_immediate_dominator (CDI_DOMINATORS, old_dest,\n \t\t\t       recompute_dominator (CDI_DOMINATORS, old_dest));\n@@ -2046,17 +2008,8 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n      sequence they originally happened.  Save the position right after\n      the (_lsm) store we just created so we can continue appending after\n      it and maintain the original order.  */\n-  {\n-    struct prev_flag_edges *p;\n-\n-    if (orig_ex->aux)\n-      orig_ex->aux = NULL;\n-    alloc_aux_for_edge (orig_ex, sizeof (struct prev_flag_edges));\n-    p = (struct prev_flag_edges *) orig_ex->aux;\n-    p->append_cond_position = then_old_edge;\n-    p->last_cond_fallthru = find_edge (new_bb, old_dest);\n-    orig_ex->aux = (void *) p;\n-  }\n+  append_cond_position = then_old_edge;\n+  last_cond_fallthru = find_edge (new_bb, old_dest);\n \n   if (!loop_has_only_one_exit)\n     for (gphi_iterator gpi = gsi_start_phis (old_dest);\n@@ -2222,7 +2175,8 @@ struct seq_entry\n \n static void\n execute_sm_exit (class loop *loop, edge ex, vec<seq_entry> &seq,\n-\t\t hash_map<im_mem_ref *, sm_aux *> &aux_map, sm_kind kind)\n+\t\t hash_map<im_mem_ref *, sm_aux *> &aux_map, sm_kind kind,\n+\t\t edge &append_cond_position, edge &last_cond_fallthru)\n {\n   /* Sink the stores to exit from the loop.  */\n   for (unsigned i = seq.length (); i > 0; --i)\n@@ -2255,7 +2209,8 @@ execute_sm_exit (class loop *loop, edge ex, vec<seq_entry> &seq,\n \t  else\n \t    execute_sm_if_changed (ex, ref->mem.ref, aux->tmp_var,\n \t\t\t\t   aux->store_flag,\n-\t\t\t\t   loop_preheader_edge (loop), &aux->flag_bbs);\n+\t\t\t\t   loop_preheader_edge (loop), &aux->flag_bbs,\n+\t\t\t\t   append_cond_position, last_cond_fallthru);\n \t}\n     }\n }\n@@ -2647,14 +2602,21 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n   /* Materialize ordered store sequences on exits.  */\n   FOR_EACH_VEC_ELT (exits, i, e)\n     {\n+      edge append_cond_position = NULL;\n+      edge last_cond_fallthru = NULL;\n       if (i < sms.length ())\n \t{\n \t  gcc_assert (sms[i].first == e);\n-\t  execute_sm_exit (loop, e, sms[i].second, aux_map, sm_ord);\n+\t  execute_sm_exit (loop, e, sms[i].second, aux_map, sm_ord,\n+\t\t\t   append_cond_position, last_cond_fallthru);\n \t  sms[i].second.release ();\n \t}\n       if (!unord_refs.is_empty ())\n-\texecute_sm_exit (loop, e, unord_refs, aux_map, sm_unord);\n+\texecute_sm_exit (loop, e, unord_refs, aux_map, sm_unord,\n+\t\t\t append_cond_position, last_cond_fallthru);\n+      /* Commit edge inserts here to preserve the order of stores\n+\t when an exit exits multiple loops.  */\n+      gsi_commit_one_edge_insert (e, NULL);\n     }\n \n   for (hash_map<im_mem_ref *, sm_aux *>::iterator iter = aux_map.begin ();\n@@ -2912,12 +2874,7 @@ store_motion_loop (class loop *loop, bitmap sm_executed)\n     {\n       find_refs_for_sm (loop, sm_executed, sm_in_loop);\n       if (!bitmap_empty_p (sm_in_loop))\n-\t{\n-\t  hoist_memory_references (loop, sm_in_loop, exits);\n-\t  /* Commit edge inserts here to preserve the order of stores\n-\t     when an exit exits multiple loops.  */\n-\t  gsi_commit_edge_inserts ();\n-\t}\n+\thoist_memory_references (loop, sm_in_loop, exits);\n     }\n   exits.release ();\n \n@@ -3064,8 +3021,6 @@ tree_ssa_lim_initialize (void)\n   if (flag_tm)\n     compute_transaction_bits ();\n \n-  alloc_aux_for_edges (0);\n-\n   memory_accesses.refs = new hash_table<mem_ref_hasher> (100);\n   memory_accesses.refs_list.create (100);\n   /* Allocate a special, unanalyzable mem-ref with ID zero.  */\n@@ -3108,8 +3063,6 @@ tree_ssa_lim_finalize (void)\n   unsigned i;\n   im_mem_ref *ref;\n \n-  free_aux_for_edges ();\n-\n   FOR_EACH_BB_FN (bb, cfun)\n     SET_ALWAYS_EXECUTED_IN (bb, NULL);\n \n@@ -3138,9 +3091,9 @@ tree_ssa_lim_finalize (void)\n    i.e. those that are likely to be win regardless of the register pressure.  */\n \n static unsigned int\n-tree_ssa_lim (void)\n+tree_ssa_lim (function *fun)\n {\n-  unsigned int todo;\n+  unsigned int todo = 0;\n \n   tree_ssa_lim_initialize ();\n \n@@ -3150,17 +3103,27 @@ tree_ssa_lim (void)\n   /* Fills ALWAYS_EXECUTED_IN information for basic blocks.  */\n   fill_always_executed_in ();\n \n+  int *rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n+  int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n+\n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n-  invariantness_dom_walker (CDI_DOMINATORS)\n-    .walk (cfun->cfg->x_entry_block_ptr);\n+  for (int i = 0; i < n; ++i)\n+    compute_invariantness (BASIC_BLOCK_FOR_FN (fun, rpo[i]));\n \n   /* Execute store motion.  Force the necessary invariants to be moved\n      out of the loops as well.  */\n   do_store_motion ();\n \n   /* Move the expressions that are expensive enough.  */\n-  todo = move_computations ();\n+  for (int i = 0; i < n; ++i)\n+    todo |= move_computations_worker (BASIC_BLOCK_FOR_FN (fun, rpo[i]));\n+\n+  free (rpo);\n+\n+  gsi_commit_edge_inserts ();\n+  if (need_ssa_update_p (fun))\n+    rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n \n   tree_ssa_lim_finalize ();\n \n@@ -3207,7 +3170,7 @@ pass_lim::execute (function *fun)\n \n   if (number_of_loops (fun) <= 1)\n     return 0;\n-  unsigned int todo = tree_ssa_lim ();\n+  unsigned int todo = tree_ssa_lim (fun);\n \n   if (!in_loop_pipeline)\n     loop_optimizer_finalize ();"}]}