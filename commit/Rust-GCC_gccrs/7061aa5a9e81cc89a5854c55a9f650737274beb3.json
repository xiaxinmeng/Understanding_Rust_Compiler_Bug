{"sha": "7061aa5a9e81cc89a5854c55a9f650737274beb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA2MWFhNWE5ZTgxY2M4OWE1ODU0YzU1YTlmNjUwNzM3Mjc0YmViMw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1998-12-15T11:09:16Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-12-15T11:09:16Z"}, "message": "cpphash.h (union hash_value): Remove `keydef' member, add a `struct hashnode *aschain' member for #assert.\n\n1998-12-15  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n\t* cpphash.h (union hash_value): Remove `keydef' member, add a\n          `struct hashnode *aschain' member for #assert.\n\t  * cpplib.c (struct tokenlist_list, struct\n          assertion_hashnode): Delete structure definitions.\n          (assertion_install, assertion_lookup, delete_assertion,\n          check_assertion, compare_token_lists, reverse_token_list,\n          read_token_list, free_token_list): Delete functions.\n          (parse_assertion): New function.\n\t  (cpp_cleanup): Don't destroy the assertion_hashtable.\n          (do_assert): Gut and rewrite.  #assert foo (bar) places\n          entries for `#foo' and `#foo(bar)' in the macro hash table,\n          type T_ASSERT.  The value union's `aschain' member is used\n          to chain all answers for a given predicate together.\n          (do_unassert): Also rewritten.  Take an un-asserted\n          answer off the chain from its predicate and call\n          delete_macro on the hashnode, or walk a predicate chain\n          calling delete_macro on all the entries.\n          (cpp_read_check_assertion): Simply call parse_assertion to\n          get the canonical assertion name, and look that up in the\n          hash table.\n\t* cpplib.h (ASSERTION_HASHNODE,ASSERTION_HASHSIZE,assertion_hashtab):\n \tRemoved.\n\t* cpphash.c (install): Use bcopy instead of an explicit loop\n          to copy the macro name.\n\t* cppexp.c (cpp_lex): Convert the result of\n          cpp_read_check_assertion to a `struct operation' directly;\n          don't go through parse_number.\n\nFrom-SVN: r24325", "tree": {"sha": "8508da5ca527221e1e8d149486ecce4965c7bc0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8508da5ca527221e1e8d149486ecce4965c7bc0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7061aa5a9e81cc89a5854c55a9f650737274beb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7061aa5a9e81cc89a5854c55a9f650737274beb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7061aa5a9e81cc89a5854c55a9f650737274beb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7061aa5a9e81cc89a5854c55a9f650737274beb3/comments", "author": null, "committer": null, "parents": [{"sha": "4b259e3fd8a2459f2c5d36fcc573884b725ada14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b259e3fd8a2459f2c5d36fcc573884b725ada14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b259e3fd8a2459f2c5d36fcc573884b725ada14"}], "stats": {"total": 662, "additions": 215, "deletions": 447}, "files": [{"sha": "de83a4eab8702767619bca11a6d4e0d0ebb0be6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7061aa5a9e81cc89a5854c55a9f650737274beb3", "patch": "@@ -1,3 +1,38 @@\n+1998-12-15  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t* cpphash.h (union hash_value): Remove `keydef' member, add a\n+          `struct hashnode *aschain' member for #assert.  \n+\n+\t  * cpplib.c (struct tokenlist_list, struct\n+          assertion_hashnode): Delete structure definitions.\n+          (assertion_install, assertion_lookup, delete_assertion,\n+          check_assertion, compare_token_lists, reverse_token_list,\n+          read_token_list, free_token_list): Delete functions.\n+          (parse_assertion): New function.  \n+\t  (cpp_cleanup): Don't destroy the assertion_hashtable.\n+\n+          (do_assert): Gut and rewrite.  #assert foo (bar) places\n+          entries for `#foo' and `#foo(bar)' in the macro hash table,\n+          type T_ASSERT.  The value union's `aschain' member is used\n+          to chain all answers for a given predicate together.\n+          (do_unassert): Also rewritten.  Take an un-asserted\n+          answer off the chain from its predicate and call\n+          delete_macro on the hashnode, or walk a predicate chain\n+          calling delete_macro on all the entries.\n+          (cpp_read_check_assertion): Simply call parse_assertion to\n+          get the canonical assertion name, and look that up in the\n+          hash table.\n+\n+\t* cpplib.h (ASSERTION_HASHNODE,ASSERTION_HASHSIZE,assertion_hashtab):\n+ \tRemoved.\n+\n+\t* cpphash.c (install): Use bcopy instead of an explicit loop\n+          to copy the macro name.\n+\n+\t* cppexp.c (cpp_lex): Convert the result of\n+          cpp_read_check_assertion to a `struct operation' directly;\n+          don't go through parse_number.\n+\n Tue Dec 15 18:27:39 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.h (struct induction): Delete times_used member."}, {"sha": "f8da2223a6c59989aa93488e7391790c74a8f600", "filename": "gcc/cppexp.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=7061aa5a9e81cc89a5854c55a9f650737274beb3", "patch": "@@ -274,8 +274,11 @@ cpp_lex (pfile, skip_evaluation)\n   cpp_skip_hspace (pfile);\n   c = CPP_BUF_PEEK (CPP_BUFFER (pfile));\n   if (c == '#')\n-    return parse_number (pfile,\n-\t\t\t cpp_read_check_assertion (pfile) ? \"1\" : \"0\", 1);\n+    {\n+      op.op = INT;\n+      op.value = cpp_read_check_assertion (pfile);\n+      return op;\n+    }\n \n   if (c == '\\n')\n     {"}, {"sha": "73ac3b4deb323d146434508d24be16b5703ff5f1", "filename": "gcc/cpphash.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=7061aa5a9e81cc89a5854c55a9f650737274beb3", "patch": "@@ -154,7 +154,7 @@ install (name, len, type, ivalue, value, hash)\n {\n   register HASHNODE *hp;\n   register int i, bucket;\n-  register U_CHAR *p, *q;\n+  register U_CHAR *p;\n \n   if (len < 0) {\n     p = name;\n@@ -182,10 +182,7 @@ install (name, len, type, ivalue, value, hash)\n   else\n     hp->value.cpval = value;\n   hp->name = ((U_CHAR *) hp) + sizeof (HASHNODE);\n-  p = hp->name;\n-  q = name;\n-  for (i = 0; i < len; i++)\n-    *p++ = *q++;\n+  bcopy (name, hp->name, len);\n   hp->name[len] = 0;\n   return hp;\n }"}, {"sha": "ee600dd1b55c034d985684ef0096949e06be3812", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=7061aa5a9e81cc89a5854c55a9f650737274beb3", "patch": "@@ -4,9 +4,7 @@ union hashval {\n   int ival;\n   char *cpval;\n   DEFINITION *defn;\n-#if 0\n-  KEYDEF *keydef;\n-#endif\n+  struct hashnode *aschain; /* for #assert */\n };\n \n struct hashnode {"}, {"sha": "919e9ac6235bbfea042bef41f1c058d903f8726c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 172, "deletions": 432, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=7061aa5a9e81cc89a5854c55a9f650737274beb3", "patch": "@@ -106,29 +106,6 @@ static char *predefs = \"\";\n #define REGISTER_PREFIX \"\"\n #endif\n \f\n-/* In the definition of a #assert name, this structure forms\n-   a list of the individual values asserted.\n-   Each value is itself a list of \"tokens\".\n-   These are strings that are compared by name.  */\n-\n-struct tokenlist_list {\n-  struct tokenlist_list *next;\n-  struct arglist *tokens;\n-};\n-\n-struct assertion_hashnode {\n-  struct assertion_hashnode *next;\t/* double links for easy deletion */\n-  struct assertion_hashnode *prev;\n-  /* also, a back pointer to this node's hash\n-     chain is kept, in case the node is the head\n-     of the chain and gets deleted.  */\n-  struct assertion_hashnode **bucket_hdr;\n-  int length;\t\t\t/* length of token, for quick comparison */\n-  U_CHAR *name;\t\t\t/* the actual name */\n-  /* List of token-sequences.  */\n-  struct tokenlist_list *value;\n-};\n-\f\n #define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n #define SKIP_ALL_WHITE_SPACE(p) do { while (is_space[*p]) p++; } while (0)\n \n@@ -182,12 +159,8 @@ extern void fancy_abort ();\n static int check_macro_name\t\tPROTO ((cpp_reader *, U_CHAR *, char *));\n static int compare_defs\t\t\tPROTO ((cpp_reader *,\n \t\t\t\t\t\tDEFINITION *, DEFINITION *));\n-static int compare_token_lists\t\tPROTO ((struct arglist *,\n-\t\t\t\t\t\tstruct arglist *));\n static HOST_WIDE_INT eval_if_expression\tPROTO ((cpp_reader *, U_CHAR *, int));\n static int change_newlines\t\tPROTO ((U_CHAR *, int));\n-static struct arglist *read_token_list\tPROTO ((cpp_reader *, int *));\n-static void free_token_list\t\tPROTO ((struct arglist *));\n static void push_macro_expansion PARAMS ((cpp_reader *,\n \t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending *));\n@@ -3121,100 +3094,6 @@ do_include (pfile, keyword, unused1, unused2)\n   return 0;\n }\n \n-/*\n- * Install a name in the assertion hash table.\n- *\n- * If LEN is >= 0, it is the length of the name.\n- * Otherwise, compute the length by scanning the entire name.\n- *\n- * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n- */\n-\n-static ASSERTION_HASHNODE *\n-assertion_install (pfile, name, len, hash)\n-     cpp_reader *pfile;\n-     U_CHAR *name;\n-     int len;\n-     int hash;\n-{\n-  register ASSERTION_HASHNODE *hp;\n-  register int i, bucket;\n-  register U_CHAR *p, *q;\n-\n-  i = sizeof (ASSERTION_HASHNODE) + len + 1;\n-  hp = (ASSERTION_HASHNODE *) xmalloc (i);\n-  bucket = hash;\n-  hp->bucket_hdr = &pfile->assertion_hashtab[bucket];\n-  hp->next = pfile->assertion_hashtab[bucket];\n-  pfile->assertion_hashtab[bucket] = hp;\n-  hp->prev = NULL;\n-  if (hp->next != NULL)\n-    hp->next->prev = hp;\n-  hp->length = len;\n-  hp->value = 0;\n-  hp->name = ((U_CHAR *) hp) + sizeof (ASSERTION_HASHNODE);\n-  p = hp->name;\n-  q = name;\n-  for (i = 0; i < len; i++)\n-    *p++ = *q++;\n-  hp->name[len] = 0;\n-  return hp;\n-}\n-/*\n- * find the most recent hash node for name \"name\" (ending with first\n- * non-identifier char) installed by install\n- *\n- * If LEN is >= 0, it is the length of the name.\n- * Otherwise, compute the length by scanning the entire name.\n- *\n- * If HASH is >= 0, it is the precomputed hash code.\n- * Otherwise, compute the hash code.\n- */\n-\n-static ASSERTION_HASHNODE *\n-assertion_lookup (pfile, name, len, hash)\n-     cpp_reader *pfile;\n-     U_CHAR *name;\n-     int len;\n-     int hash;\n-{\n-  register ASSERTION_HASHNODE *bucket;\n-\n-  bucket = pfile->assertion_hashtab[hash];\n-  while (bucket) {\n-    if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n-      return bucket;\n-    bucket = bucket->next;\n-  }\n-  return NULL;\n-}\n-\n-static void\n-delete_assertion (hp)\n-     ASSERTION_HASHNODE *hp;\n-{\n-  struct tokenlist_list *tail;\n-  if (hp->prev != NULL)\n-    hp->prev->next = hp->next;\n-  if (hp->next != NULL)\n-    hp->next->prev = hp->prev;\n-\n-  for (tail = hp->value; tail; )\n-    {\n-      struct tokenlist_list *next = tail->next;\n-      free_token_list (tail->tokens);\n-      free (tail);\n-      tail = next;\n-    }\n-\n-  /* Make sure that the bucket chain header that\n-     the deleted guy was on points to the right thing afterwards.  */\n-  if (hp == *hp->bucket_hdr)\n-    *hp->bucket_hdr = hp->next;\n-\n-  free (hp);\n-}\n \f\n /* Convert a character string literal into a nul-terminated string.\n    The input string is [IN ... LIMIT).\n@@ -6049,351 +5928,240 @@ cpp_cleanup (pfile)\n       pfile->all_include_files[i] = 0;\n     }\n \n-  for (i = ASSERTION_HASHSIZE; --i >= 0; )\n+  cpp_hash_cleanup (pfile);\n+}\n+\f\n+/* Read an assertion into the token buffer, converting to\n+   canonical form: `#predicate(a n swe r)'  The next non-whitespace\n+   character to read should be the first letter of the predicate.\n+   Returns 0 for syntax error, 1 for bare predicate, 2 for predicate\n+   with answer (see callers for why). In case of 0, an error has been\n+   printed. */\n+static int\n+parse_assertion (pfile)\n+     cpp_reader *pfile;\n+{\n+  int c, dropwhite;\n+  cpp_skip_hspace (pfile);\n+  c = PEEKC();\n+  if (! is_idstart[c])\n     {\n-      while (pfile->assertion_hashtab[i])\n-\tdelete_assertion (pfile->assertion_hashtab[i]);\n+      cpp_error (pfile, \"assertion predicate is not an identifier\");\n+      return 0;\n     }\n+  CPP_PUTC(pfile, '#');\n+  FORWARD(1);\n+  parse_name(pfile, c);\n \n-  cpp_hash_cleanup (pfile);\n+  c = PEEKC();\n+  if (c != '(')\n+    {\n+      if (is_hor_space[c])\n+\tcpp_skip_hspace (pfile);\n+      c = PEEKC();\n+    }\n+  if (c != '(')\n+    return 1;\n+\n+  CPP_PUTC(pfile, '(');\n+  FORWARD(1);\n+  dropwhite = 1;\n+  while ((c = GETC()) != ')')\n+    {\n+      if (is_hor_space[c])\n+\t{\n+\t  if (! dropwhite)\n+\t    {\n+\t      CPP_PUTC(pfile, ' ');\n+\t      dropwhite = 1;\n+\t    }\n+\t}\n+      else if (c == '\\\\' && PEEKC() == '\\n')\n+\tFORWARD(1);\n+      else if (c == '\\n' || c == EOF)\n+\t{\n+\t  if (c == '\\n') FORWARD(-1);\n+\t  cpp_error (pfile, \"un-terminated assertion answer\");\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  CPP_PUTC(pfile, c);\n+\t  dropwhite = 0;\n+\t}\n+    }\n+\n+  if (pfile->limit[-1] == ' ')\n+    pfile->limit[-1] = ')';\n+  else if (pfile->limit[-1] == '(')\n+    {\n+      cpp_error (pfile, \"empty token sequence in assertion\");\n+      return 0;\n+    }\n+  else\n+    CPP_PUTC(pfile, ')');\n+\n+  CPP_NUL_TERMINATE(pfile);\n+  return 2;\n }\n-\f\n+\n static int\n do_assert (pfile, keyword, buf, limit)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n      U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n-  long symstart;\t\t/* remember where symbol name starts */\n-  int c;\n-  int sym_length;\t\t/* and how long it is */\n-  struct arglist *tokens = NULL;\n+  char *sym;\n+  int ret, c;\n+  HASHNODE *base, *this;\n+  int baselen, thislen;\n \n   if (CPP_PEDANTIC (pfile) && CPP_OPTIONS (pfile)->done_initializing\n       && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#assert'\");\n \n   cpp_skip_hspace (pfile);\n-  symstart = CPP_WRITTEN (pfile);\t/* remember where it starts */\n-  parse_name (pfile, GETC());\n-  sym_length = check_macro_name (pfile, pfile->token_buffer + symstart,\n-\t\t\t\t \"assertion\");\n-\n-  cpp_skip_hspace (pfile);\n-  if (PEEKC() != '(') {\n-    cpp_error (pfile, \"missing token-sequence in `#assert'\");\n+  sym = CPP_PWRITTEN (pfile);\t/* remember where it starts */\n+  ret = parse_assertion (pfile);\n+  if (ret == 0)\n     goto error;\n-  }\n-\n-  {\n-    int error_flag = 0;\n-    tokens = read_token_list (pfile, &error_flag);\n-    if (error_flag)\n-      goto error;\n-    if (tokens == 0) {\n-      cpp_error (pfile, \"empty token-sequence in `#assert'\");\n+  else if (ret == 1)\n+    {\n+      cpp_error (pfile, \"missing token-sequence in `#assert'\");\n       goto error;\n     }\n+\n   cpp_skip_hspace (pfile);\n-  c = PEEKC ();\n+  c = PEEKC();\n   if (c != EOF && c != '\\n')\n-      cpp_pedwarn (pfile, \"junk at end of `#assert'\");\n-  skip_rest_of_line (pfile);\n-  }\n-\n-  /* If this name isn't already an assertion name, make it one.\n-     Error if it was already in use in some other way.  */\n+    {\n+      cpp_error (pfile, \"junk at end of `#assert'\");\n+      goto error;\n+    }\n \n-  {\n-    ASSERTION_HASHNODE *hp;\n-    U_CHAR *symname = pfile->token_buffer + symstart;\n-    int hashcode = hashf (symname, sym_length, ASSERTION_HASHSIZE);\n-    struct tokenlist_list *value\n-      = (struct tokenlist_list *) xmalloc (sizeof (struct tokenlist_list));\n-\n-    hp = assertion_lookup (pfile, symname, sym_length, hashcode);\n-    if (hp == NULL) {\n-      if (sym_length == 7 && ! strncmp (symname, \"defined\", sym_length))\n-\tcpp_error (pfile, \"`defined' redefined as assertion\");\n-      hp = assertion_install (pfile, symname, sym_length, hashcode);\n+  thislen = strlen (sym);\n+  baselen = index (sym, '(') - sym;\n+  this = cpp_lookup (pfile, sym, thislen, -1);\n+  if (this)\n+    {\n+      cpp_warning (pfile, \"`%s' re-asserted\", sym);\n+      goto error;\n     }\n \n-    /* Add the spec'd token-sequence to the list of such.  */\n-    value->tokens = tokens;\n-    value->next = hp->value;\n-    hp->value = value;\n+  base = cpp_lookup (pfile, sym, baselen, -1);\n+  if (! base)\n+    base = install (sym, baselen, T_ASSERT, 0, 0, -1);\n+  else if (base->type != T_ASSERT)\n+  {\n+    /* Token clash - but with what?! */\n+    cpp_fatal (pfile,\n+\t       \"cpp internal error: base->type != T_ASSERT in do_assert\");\n+    goto error;\n   }\n-  CPP_SET_WRITTEN (pfile, symstart); /* Pop */\n+\n+  this = install (sym, thislen, T_ASSERT, 0,\n+\t\t  (char *)base->value.aschain, -1);\n+  base->value.aschain = this;\n+  \n+  pfile->limit = sym; /* Pop */\n   return 0;\n+\n  error:\n-  CPP_SET_WRITTEN (pfile, symstart); /* Pop */\n+  pfile->limit = sym; /* Pop */\n   skip_rest_of_line (pfile);\n   return 1;\n }\n-\f\n+\n static int\n do_unassert (pfile, keyword, buf, limit)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n      U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n-  long symstart;\t\t/* remember where symbol name starts */\n-  int sym_length;\t/* and how long it is */\n-  int c;\n-\n-  struct arglist *tokens = NULL;\n-  int tokens_specified = 0;\n-\n+  int c, ret;\n+  char *sym;\n+  long baselen, thislen;\n+  HASHNODE *base, *this, *next;\n+  \n   if (CPP_PEDANTIC (pfile) && CPP_OPTIONS (pfile)->done_initializing\n       && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#unassert'\");\n \n   cpp_skip_hspace (pfile);\n \n-  symstart = CPP_WRITTEN (pfile);\t/* remember where it starts */\n-  parse_name (pfile, GETC());\n-  sym_length = check_macro_name (pfile, pfile->token_buffer + symstart,\n-\t\t\t\t \"assertion\");\n-\n-  cpp_skip_hspace (pfile);\n-  if (PEEKC() == '(') {\n-    int error_flag = 0;\n-\n-    tokens = read_token_list (pfile, &error_flag);\n-    if (error_flag)\n-      goto error;\n-    if (tokens == 0) {\n-      cpp_error (pfile, \"empty token list in `#unassert'\");\n-      goto error;\n-    }\n-\n-    tokens_specified = 1;\n-  }\n-\n+  sym = CPP_PWRITTEN (pfile);\t/* remember where it starts */\n+  ret = parse_assertion (pfile);\n+  if (ret == 0)\n+    goto error;\n+  \n   cpp_skip_hspace (pfile);\n   c = PEEKC ();\n   if (c != EOF && c != '\\n')\n       cpp_error (pfile, \"junk at end of `#unassert'\");\n-  skip_rest_of_line (pfile);\n \n-  {\n-    ASSERTION_HASHNODE *hp;\n-    U_CHAR *symname = pfile->token_buffer + symstart;\n-    int hashcode = hashf (symname, sym_length, ASSERTION_HASHSIZE);\n-    struct tokenlist_list *tail, *prev;\n-\n-    hp = assertion_lookup (pfile, symname, sym_length, hashcode);\n-    if (hp == NULL)\n-      return 1;\n-\n-    /* If no token list was specified, then eliminate this assertion\n-       entirely.  */\n-    if (! tokens_specified)\n-      delete_assertion (hp);\n-    else {\n-      /* If a list of tokens was given, then delete any matching list.  */\n-\n-      tail = hp->value;\n-      prev = 0;\n-      while (tail) {\n-\tstruct tokenlist_list *next = tail->next;\n-\tif (compare_token_lists (tail->tokens, tokens)) {\n-\t  if (prev)\n-\t    prev->next = next;\n-\t  else\n-\t    hp->value = tail->next;\n-\t  free_token_list (tail->tokens);\n-\t  free (tail);\n-\t} else {\n-\t  prev = tail;\n+  thislen = strlen (sym);\n+  if (ret == 1)\n+    {\n+      base = cpp_lookup (pfile, sym, thislen, -1);\n+      if (! base)\n+\tgoto error;  /* It isn't an error to #undef what isn't #defined,\n+\t\t\tso it isn't an error to #unassert what isn't\n+\t\t\t#asserted either. */\n+      \n+      for (this = base->value.aschain; this; this = next)\n+        {\n+\t  next = this->value.aschain;\n+\t  delete_macro (this);\n \t}\n-\ttail = next;\n-      }\n+      delete_macro (base);\n     }\n-  }\n+  else\n+    {\n+      baselen = index (sym, '(') - sym;\n+      base = cpp_lookup (pfile, sym, baselen, -1);\n+      if (! base) goto error;\n+      this = cpp_lookup (pfile, sym, thislen, -1);\n+      if (! this) goto error;\n+\n+      next = base;\n+      while (next->value.aschain != this)\n+\tnext = next->value.aschain;\n \n-  CPP_SET_WRITTEN (pfile, symstart); /* Pop */\n+      next->value.aschain = this->value.aschain;\n+      delete_macro (this);\n+\n+      if (base->value.aschain == NULL)\n+\tdelete_macro (base);  /* Last answer for this predicate deleted. */\n+    }\n+  \n+  pfile->limit = sym; /* Pop */\n   return 0;\n  error:\n-  CPP_SET_WRITTEN (pfile, symstart); /* Pop */\n+  pfile->limit = sym; /* Pop */\n   skip_rest_of_line (pfile);\n   return 1;\n }\n-\f\n-/* Test whether there is an assertion named NAME\n-   and optionally whether it has an asserted token list TOKENS.\n-   NAME is not null terminated; its length is SYM_LENGTH.\n-   If TOKENS_SPECIFIED is 0, then don't check for any token list.  */\n \n int\n-check_assertion (pfile, name, sym_length, tokens_specified, tokens)\n-     cpp_reader *pfile;\n-     U_CHAR *name;\n-     int sym_length;\n-     int tokens_specified;\n-     struct arglist *tokens;\n-{\n-  ASSERTION_HASHNODE *hp;\n-  int hashcode = hashf (name, sym_length, ASSERTION_HASHSIZE);\n-\n-  if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n-    cpp_pedwarn (pfile, \"ANSI C does not allow testing assertions\");\n-\n-  hp = assertion_lookup (pfile, name, sym_length, hashcode);\n-  if (hp == NULL)\n-    /* It is not an assertion; just return false.  */\n-    return 0;\n-\n-  /* If no token list was specified, then value is 1.  */\n-  if (! tokens_specified)\n-    return 1;\n-\n-  {\n-    struct tokenlist_list *tail;\n-\n-    tail = hp->value;\n-\n-    /* If a list of tokens was given,\n-       then succeed if the assertion records a matching list.  */\n-\n-    while (tail) {\n-      if (compare_token_lists (tail->tokens, tokens))\n-\treturn 1;\n-      tail = tail->next;\n-    }\n-\n-    /* Fail if the assertion has no matching list.  */\n-    return 0;\n-  }\n-}\n-\n-/* Compare two lists of tokens for equality including order of tokens.  */\n-\n-static int\n-compare_token_lists (l1, l2)\n-     struct arglist *l1, *l2;\n-{\n-  while (l1 && l2) {\n-    if (l1->length != l2->length)\n-      return 0;\n-    if (strncmp (l1->name, l2->name, l1->length))\n-      return 0;\n-    l1 = l1->next;\n-    l2 = l2->next;\n-  }\n-\n-  /* Succeed if both lists end at the same time.  */\n-  return l1 == l2;\n-}\n-\f\n-struct arglist *\n-reverse_token_list (tokens)\n-     struct arglist *tokens;\n-{\n-  register struct arglist *prev = 0, *this, *next;\n-  for (this = tokens; this; this = next)\n-    {\n-      next = this->next;\n-      this->next = prev;\n-      prev = this;\n-    }\n-  return prev;\n-}\n-\n-/* Read a space-separated list of tokens ending in a close parenthesis.\n-   Return a list of strings, in the order they were written.\n-   (In case of error, return 0 and store -1 in *ERROR_FLAG.) */\n-\n-static struct arglist *\n-read_token_list (pfile, error_flag)\n+cpp_read_check_assertion (pfile)\n      cpp_reader *pfile;\n-     int *error_flag;\n {\n-  struct arglist *token_ptrs = 0;\n-  int depth = 1;\n-  int length;\n-\n-  *error_flag = 0;\n-  FORWARD (1);  /* Skip '(' */\n-\n-  /* Loop over the assertion value tokens.  */\n-  while (depth > 0)\n+  char *name = CPP_PWRITTEN (pfile);\n+  int result;\n+  HASHNODE *hp;\n+  \n+  FORWARD (1);  /* Skip '#' */\n+  cpp_skip_hspace (pfile);\n+  if (! parse_assertion (pfile))\n+    result = 0;\n+  else\n     {\n-      struct arglist *temp;\n-      long name_written = CPP_WRITTEN (pfile);\n-      int c;\n-\n-      cpp_skip_hspace (pfile);\n-\n-      c = GETC ();\n-\t  \n-      /* Find the end of the token.  */\n-      if (c == '(')\n-        {\n-\t  CPP_PUTC (pfile, c);\n-\t  depth++;\n-        }\n-      else if (c == ')')\n-        {\n-\t  depth--;\n-\t  if (depth == 0)\n-\t    break;\n-\t  CPP_PUTC (pfile, c);\n-        }\n-      else if (c == '\"' || c == '\\'')\n-        {\n-\t  FORWARD(-1);\n-\t  cpp_get_token (pfile);\n-        }\n-      else if (c == '\\n')\n-\tbreak;\n-      else\n-        {\n-\t  while (c != EOF && ! is_space[c] && c != '(' && c != ')'\n-\t\t && c != '\"' && c != '\\'')\n-\t    {\n-\t      CPP_PUTC (pfile, c);\n-\t      c = GETC();\n-\t    }\n-\t  if (c != EOF)  FORWARD(-1);\n-        }\n-\n-      length = CPP_WRITTEN (pfile) - name_written;\n-      temp = (struct arglist *)\n-\t  xmalloc (sizeof (struct arglist) + length + 1);\n-      temp->name = (U_CHAR *) (temp + 1);\n-      bcopy ((char *) (pfile->token_buffer + name_written),\n-\t     (char *) temp->name, length);\n-      temp->name[length] = 0;\n-      temp->next = token_ptrs;\n-      token_ptrs = temp;\n-      temp->length = length;\n-\n-      CPP_ADJUST_WRITTEN (pfile, -length); /* pop */\n-\n-      if (c == EOF || c == '\\n')\n-        { /* FIXME */\n-\t  cpp_error (pfile,\n-\t\t     \"unterminated token sequence following  `#' operator\");\n-\t  return 0;\n-\t}\n+      hp = cpp_lookup (pfile, name, (char *)CPP_PWRITTEN (pfile) - name, -1);\n+      result = (hp != 0);\n     }\n \n-  /* We accumulated the names in reverse order.\n-     Now reverse them to get the proper order.  */\n-  return reverse_token_list (token_ptrs);\n-}\n-\n-static void\n-free_token_list (tokens)\n-     struct arglist *tokens;\n-{\n-  while (tokens) {\n-    struct arglist *next = tokens->next;\n-    free (tokens->name);\n-    free (tokens);\n-    tokens = next;\n-  }\n+  pfile->limit = name;\n+  return result;\n }\n \n /* FIXME: savestring() should be renamed strdup() and should\n@@ -6465,34 +6233,6 @@ parse_move_mark (pmark, pfile)\n   pmark->position = pbuf->cur - pbuf->buf;\n }\n \n-int\n-cpp_read_check_assertion (pfile)\n-     cpp_reader *pfile;\n-{\n-  int name_start = CPP_WRITTEN (pfile);\n-  int name_length, name_written;\n-  int result;\n-  FORWARD (1);  /* Skip '#' */\n-  cpp_skip_hspace (pfile);\n-  parse_name (pfile, GETC ());\n-  name_written = CPP_WRITTEN (pfile);\n-  name_length = name_written - name_start;\n-  cpp_skip_hspace (pfile);\n-  if (CPP_BUF_PEEK (CPP_BUFFER (pfile)) == '(')\n-    {\n-      int error_flag;\n-      struct arglist *token_ptrs = read_token_list (pfile, &error_flag);\n-      result = check_assertion (pfile,\n-\t\t\t\tpfile->token_buffer + name_start, name_length,\n-\t\t\t\t1, token_ptrs);\n-    }\n-  else\n-    result = check_assertion (pfile,\n-\t\t\t      pfile->token_buffer + name_start, name_length,\n-\t\t\t      0, NULL_PTR);\n-  CPP_ADJUST_WRITTEN (pfile, - name_length);  /* pop */\n-  return result;\n-}\n \f\n void\n cpp_print_file_and_line (pfile)"}, {"sha": "7e9aa7d3fdb0d024f046fc91380400391f1c9233", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7061aa5a9e81cc89a5854c55a9f650737274beb3/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=7061aa5a9e81cc89a5854c55a9f650737274beb3", "patch": "@@ -144,9 +144,6 @@ struct cpp_buffer {\n struct cpp_pending;  /* Forward declaration - for C++. */\n struct file_name_map_list;\n \n-typedef struct assertion_hashnode ASSERTION_HASHNODE;\n-#define ASSERTION_HASHSIZE 37\n-\n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n@@ -230,8 +227,6 @@ struct cpp_reader\n \n   struct tm *timebuf;\n \n-  ASSERTION_HASHNODE *assertion_hashtab[ASSERTION_HASHSIZE];\n-\n   /* Buffer of -M output.  */\n   char *deps_buffer;\n "}]}