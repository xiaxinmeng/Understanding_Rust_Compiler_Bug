{"sha": "c5c7673583c6310e7f8e45704fdc4aadff33e393", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjNzY3MzU4M2M2MzEwZTdmOGU0NTcwNGZkYzRhYWRmZjMzZTM5Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-07T05:49:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-07T05:49:18Z"}, "message": "Merge in gcc2-ss-010999\n\nFrom-SVN: r29150", "tree": {"sha": "f1a67b6ea75a7f0da3f06e0a1c60b213f4403168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1a67b6ea75a7f0da3f06e0a1c60b213f4403168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5c7673583c6310e7f8e45704fdc4aadff33e393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c7673583c6310e7f8e45704fdc4aadff33e393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5c7673583c6310e7f8e45704fdc4aadff33e393", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c7673583c6310e7f8e45704fdc4aadff33e393/comments", "author": null, "committer": null, "parents": [{"sha": "ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b"}], "stats": {"total": 10825, "additions": 5892, "deletions": 4933}, "files": [{"sha": "c7300cd85ed5eb3b548d06295e3419dafc8df3e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,3 +1,8 @@\n+Mon Sep  6 22:44:47 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Merge from gcc2 snapshot Jan 9, 1999.  See FSFChangeLog for\n+\tdetails.\n+\n Mon Sep  6 22:31:28 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-aux-info.c (concat): Don't define.\n@@ -126,6 +131,7 @@ Mon Sep  6 14:30:13 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(ix86_mark_machine_status): New function.\n \t(override_options): Set mark_machine_status.\n \n+>>>>>>> 1.4290\n Mon Sep  6 15:26:23 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* tree.c (copy_node): Copy node contents also if doing GC.\n@@ -136,6 +142,7 @@ Mon Sep  6 08:42:06 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n Mon Sep  6 02:42:36 1999  Jeffrey A Law  (law@cygnus.com)\n \n+>>>>>>> 1.4287\n \t* collect2.c (scan_libraries): Fix thinko.\n \n \t* cse.c (delete_trivially_dead_insns): Do not skip the last"}, {"sha": "d8cdf7bd564863f5528dc1001cc8edec02811599", "filename": "gcc/FSFChangeLog", "status": "modified", "additions": 750, "deletions": 199, "changes": 949, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2FFSFChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2FFSFChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FFSFChangeLog?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,9 +1,646 @@\n+Sat Jan  9 08:19:14 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* toplev.c (rest_of_compilation): Set cse_not_expected earlier.\n+\n+\t* optabs.c (emit_conditional_move): Undo canonicalization previously\n+\tdone by get_condition.\n+\n+\t* jump.c (jump_optimize): Move simple optimizations in front\n+\tof complex ones.\n+\tReset NEXT whenever deleting an insn in case NEXT was deleted.\n+\tDisable some conditional move optimizations if have \n+\tconditional arithmetic or if CSE not run yet.\n+\tAdd new optimization to conditionalize code if have conditional\n+\tarithmetic.\n+\t(can_reverse_comparison_p): Check REVERSIBLE_CC_MODE.\n+\t(condjump{,_in_parallel}_p): Simplify.\n+\n+Thu Jan  7 09:25:51 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* jump.c (delete_computation): Don't trust location of REG_DEAD\n+\tnote within a basic block.\n+\n+Sat Dec 26 06:31:43 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cse.c (cse_insn): Always make SET a nop if dest is hard regster and\n+\tsrc is equivalent.\n+\n+\t* flow.c (print_rtl_with_bb): Write insns in epilogue delay list.\n+\n+\t* combine.c (simplify_set): Update SET_SRC after force_to_mode call.\n+\tIf HAVE_conditional_arithmetic, make conditional if comparison\n+\toperator is arg of arithmetic.\n+\n+\t* genconfig.c (have_cond_arith_flag): New variable.\n+\t(walk_insn_part, case IF_THEN_ELSE): Set it.\n+\t(main): Define HAVE_conditional_arithmetic if have_cond_arith_flag.\n+\n+\t* reorg.c (optimize_skip): Count insns in delay slots for epilogue\n+\tas being after a conditional return.\n+\n+Wed Dec 23 07:30:22 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* mips.md (movdf [mips4]): Remove '=' in constraint when not output.\n+\n+\t* toplev.c (fatal_function): New static variable.\n+\t(set_fatal_function): New function.\n+\t(vfatal): If fatal_function nonzero, call it.\n+\n+Thu Dec 10 07:21:44 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (move_by_pieces_1): Give inner arg types of function passed\n+\tas first operand.\n+\n+\t* aclocal.m4 (GCC_HEADER_INTTYPES, GCC_CHECK_STRINGIFY): New macros.\n+\t* configure.in: Use them instead of inline text.\n+\t(malloc.h): Check for presence.\n+\t(free, malloc, calloc, realloc): Include malloc.h to see if need decl.\n+\t* system.h (malloc.h): Conditionally include.\n+\t(free, malloc, calloc, realloc): Conditionally declare.\n+\t* xm-mn10200.h (free, malloc, realloc, calloc): Remove redundant decls.\n+\t* xm-mn10300.h, rs6000/xm-sysv4.h, xm-v850.h: Likewise.\n+\t* xm-alpha.h: Likewise.\n+\t(string.h): Remove reundant #include.\n+\t* rtl.h (free): Remove declaration.\n+\t* tree.h (free): Likewise.\n+\n+\t* gcov.c (fatal): New function.\n+\n+Wed Dec  9 06:25:12 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* protoize.c: Remove extraneous #endif.\n+\tRemove redundant declarations and includes.\n+\t(fatal): New function, from gen*.c.\n+\n+Wed Dec  9 06:16:26 1998  Craig Burley  (burley@gnu.ai.mit.edu)\n+\n+\t* fold-const.c (multiple_of_p): New function.\n+\t(fold): Turn some cases of *_DIV_EXPR into EXACT_DIV_EXPR.\n+\n+Wed Dec  9 04:42:23 1998  H.J. Lu  (hjl@gnu.ai.mit.edu)\n+\n+\t* expr.h, real.h: Add more prototypes.\n+\n+Tue Dec  8 06:04:19 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* c-typeck.c (c_expand_asm_operands): Fix text of error message\n+\tand handle conversion as lvalue.\n+\n+Mon Dec  7 21:35:31 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* dwarf2out.c (dyn-string.h): Fix patching error.\n+\t* toplev.c (<sys/times.h>): Include if HAVE_SYS_TIMES_H is defined.\n+\n+Sun Dec  6 01:14:46 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* collect2.c (mktemp): Remove unused decl.\n+\n+Sat Dec  5 21:02:13 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* cccp.c (fwrite): New VMS macro.\n+\t(VMS_fwrite): New VMS function.\n+\t(strerror): Declare only if NEED_DECLARATION_STRERROR.\n+\t(warn_white_space): New var.\n+\t(do_warning): Remove.\n+\t(directive_table): Use do_error to print warnings.\n+\t(eprint_string): Remove.  All callers now use fwrite instead.\n+\t(check_white_space): New function.\n+\t(fatal): Now extern.\n+\t(main): Add new option --White-space, implied by -Wall.\n+\tIf DEPENDENCIES_OUTPUT has the form `FILE TARGET', have TARGET depend\n+\ton source file as well as files it includes.\n+\t(newline_fix, name_newline_fix): Assume that *BP == '\\\\',\n+\tbut don't assume that BP[1] == '\\n'; all callers changed.\n+\t(rescan): Warn about white space at end of line in string.\n+\tFix bug with counting newlines in strings as result of macro-expanding.\n+\t(expand_to_temp_buffer): Do not stomp on the output buffer length;\n+\tall callers changed.\n+\t(handle_directive): No need to check bp < limit if *bp == '\\n'.\n+\tAllocate a larger directive buffer; expand newline to\n+\tbackslash-'n' in string literals.\n+\t(timestamp): Don't assume that localtime succeeds.\n+\t(finclude): Add call to check_white_space in included file.\n+\t(collect_expansion): No need to check for p < limit at backslash.\n+\t(do_line): Allow nulls in file name.\n+\t(do_error): Also do warnings.\n+\t(do_pragma): Handle escapes in strings correctly.\n+\t(skip_quoted_string): Don't say ``Unterminated string or character''\n+\tif it's known to be a character.\n+\tWarn about white space at end of line in string.\n+\t(struct argdata): New member expand_size.\n+\tRename member stringified_length to stringified_length_bound.\n+\tAll uses changed.\n+\t(macroexpand): Record expand_size separately from expand_length.\n+\tGenerate nothing for backslash-newline in a string.\n+\tEscape newlines in strings.\n+\t(macarg): Have macarg1 count newlines.  Escape newlines in strings.\n+\t(macarg1): Skip backslash-newline in strings.\n+\t(change_newlines): Now takes struct argdata * (not U_CHAR * and int)\n+\treturns void, not int.  Modify the arg in-place.\n+\t(change_newlines, make_definition): In strings, replace\n+\tbackslash-newline with nothing, and non-backslashed newline\n+\twith backslash-'n'.\n+\n+\t* cexp.y (fatal): New decl (exported by cccp.c).\n+\t(yylex): Allow multiple-char constants like 'abcde' that are longer\n+\tthan long; draft C9x requires this.  Don't treat (char)-1 like EOF.\n+\t(parse_escape): Return -2 if backslash-newline is seen.\n+\tParse backslash-newline in numeric escapes.\n+\tParse \\x using unsigned, not signed, for proper overflow detection.\n+\n+Fri Dec  4 16:24:36 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Defer some __builtin_constant_p elaborations until after cse;\n+\toriginal idea from rth@cygnus.com\n+\t* rtl.def (CONSTANT_P_RTX): New RTL code.\n+\t* expr.c (expand_builtin, case BUILT_IN_CONSTANT_P): Rework to\n+\tconsider constant CONSTRUCTOR constant and to defer some cases to cse.\n+\t* cse.c (fold_rtx, case CONST): Add handling for CONSTANT_P_RTX.\n+\t* regclass.c (reg_scan_mark_refs, case CONST): Likewise.\n+\t\n+Tue Dec  1 09:35:45 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (C_AND_OBJC_OBJS): Add mbchar.o.\n+\t(c-lex.o, cexp.o, cccp.o): Depend on mbchar.h.\n+\t(mbchar.o): New rule.\n+\t(CCCP_OBJS, CPPMAIN_OBJS): Include mbchar.o.\n+\t* po/POTFILES.in (mbchar.[ch]): Add.\n+\n+Tue Dec  1 09:32:27 1998  Dave Brolley  <brolley@cygnus.com>\n+\n+\t* mbchar.[ch]: New files for multibyte character handling.\n+\t* configure.in (enable_c_mbchar): New configure option.\n+\t* cexp.y (mbchar.h): #include it.\n+\t(yylex): Handle Multibyte characters in character literals.\n+\t* cccp.c (mbchar.h): #include it.\n+\t(main): Set character set based on LANG environment variable.\n+\t(rescan): Handle multibyte characters in comments.\n+\t(skip_if_group, validate_else, skip_to_end_of_comment): Likewise.\n+\t(macarg1, discard_comments): Likewise.\n+\t(rescan): Handle multibyte characters in string and character literals.\n+\t(collect_expansion, skip_quoted_string, macroexpand): Likewise.\n+\t(macarg1, discard_comments, change_newlines): Likewise.\n+\t* c-lex.c (mbchar.h): #include it.\n+\t(GET_ENVIRONMENT): New macro.\n+\t(init_lex): Set character set based on LANG environment variable.\n+\t(yylex): Handle multibyte characters in character and string literals.\n+\n+Mon Nov 30 08:25:35 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* dyn-string.h: New file.\n+\t* dyn-string.c: Likewise.\n+\t* Makefile.in (OBJS): Add dyn-string.o.\n+\t(dwarf2out.o): Add dyn-string.h dependency.\n+\t(dyn-string.o): New rule.\n+\t* dwarf2out.c (dyn-string.h): Include.\n+\t(ASM_NAME_TO_STRING): Use dyn_string_append, rather than strcpy.\n+\t(addr_const_to_string): Take a dyn_string_t, not a char * as a\n+\tprototype.  Use dyn_string_append rather than strcat, throughout.\n+\t(addr_to_string): Use dyn_string_t.\n+\n+Mon Nov 30 06:57:49 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* po/POTFILES.in (dyn-string.[ch]): New files.\n+\n+\t* sched.c (swap_sort): Fix typo in last change.\n+\n+Sun Nov 29 21:02:34 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* po/POTFILES.in: Add gengenrtl.c, system.h.\n+\n+Sun Nov 29 16:36:59 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expmed.c (emit_store_flag): Don't try to negate STORE_FLAG_VALUE.\n+\n+\t* configure.in: Remove inadvertently added duplicate tests.\n+\n+\t* reload1.c (emit_reload_insns): Fix typos in preserve death note code.\n+\n+\t* Makefile.in (c-lex.o): Depends on $(RTL_H).\n+\n+\t* genattr.c (fatal): No longer static.\n+\t* genattrtab.c, gencodes.c, genconfig.c, genemit.c: Likewise.\n+\t* genextract.c, genflags.c, gengenrtl.c, genopinit.c: Likewise.\n+\t* genoutput.c, genpeep.c, genrecog.c: Likewise.\n+\n+\t* 1750a.c: Use gen_rtx_FOO and GEN_INT, not gen_rtx; include system.h.\n+\t* a29k.c, alpha.c, arc.c, arm.c, clipper.c, convex.c: Likewise.\n+\t* dsp16xx.c, fx80.c, gmicro.c, h8300.c, i386.c, i860.c: Likewise.\n+\t* i960.c, m32r.c, m68k.c, m88k.c, mips.c, mn10200.c: Likewise.\n+\t* mn10300.c, ns32k.c, pa.c, pdp11.c, pyr.c, romp.c: Likewise.\n+\t* rs6000.c, sh.c, sparc.c, spur.c, tahoe.c, v850.c: Likewise.\n+\t* vax.c, we32k.c: Likewise.\n+\t* elxsi.c, i370.c: Include system.h\n+\t* gofast.h: Use gen_rtx_FOO and GEN_INT instead of gen_rtx.\n+\t* 1750a.{md,h}, a29k{md,h}, alpha.{md,h}, alpha/vms.h: Likewise.\n+\t* arc.{md,h}, arm.{md,h}, clipper.{md,h}, convex.{md,h}: Likewise.\n+\t* dsp16xx.{md,h}, elxsi.h, fx80.{md,h}, gmicro.{md,h}: Likewise.\n+\t* h8300.h, i370.{md,h}, i386.{md,h}, i386/cygwin32.h: Likewise.\n+\t* i386/osfrose.h, i386/win-nt.h, i860.{md,h}, i960.{md,h}: Likewise.\n+\t* m32r.{md,h}, m68k.{md,h}, m68k/a-ux.h, m68k/crds.h: Likewise.\n+\t* m68k/isi.h, m68k/linux.h, m68k/lynx.h, m68k/m68kemb.h: Likewise.\n+\t* m68k/m68kv4.h, m68k/mot3300.h, m68k/news.h, m68k/sun3.h: Likewise.\n+\t* m88k.{md,h}, mips.{md,h}, mips/abi64.h, mn10200.{md,h}: Likewise.\n+\t* mn10300.{md,h}, ns32k.{md,h}, pa.{md,h}, pyr.{md,h}: Likewise.\n+\t* romp.{md,h}, rs6000.{md,h}, sh.{md,h}, sparc.{md.h}: Likewise.\n+\t* spur{md,h}, tahoe.{md,h}, v850.{md,h}, vax.{md,h}: Likewise.\n+\t* we32k.{md,h}: Likewise.\n+\n+Sat Nov 28 19:32:33 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* rtl.def (INLINE_HEADER): Fix type error found by gen_rtx_FOO changes.\n+\n+        * configure.in: If host != build, run autoconf to generate auto\n+\tbuild.h for the build machine and include it in build_xm_files.\n+\t\n+Sat Nov 28 19:20:06 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* bc-emit.c, caller-save.c, calls.c, combine.c: Call gen_rtx_FOO.\n+\t* cse.c, dwarf2out.c, emit-rtl.c, except.c, explow.c: Likewise.\n+\t* expmed.c expr.c, final.c, function.c, genpeep.c, halfpic.c: Likewise.\n+\t* integrate.c, jump.c, local-alloc.c, loop.c, optabs.c: Likewise.\n+\t* profile.c, recog.c, reg-stack.c, regclass.c, regmove.c: Likewise.\n+\t* reload.c, reload1.c, reorg.c, sched.c, stmt.c, stupid.c: Likewise.\n+\t* unroll.c, varasm.c: Likewise.\n+\n+\t* Makefile.in (*.o): Depend on system.h.\n+\t* system.h (ANSI_PROTOTYPES): Add definition.\n+\t* *.c, c-parse.in, cexp.y: Include system.h and delete any\n+\tnon-redundant includes, macro definitions, or declarations.\n+\t* gen*.c, bc-emit.c, calls.c, cccp.c, combine.c, emit-rtl.c:\n+\tUse ANSI_PROTOTYPES, not __STDC__ to select varargs vs. stdargs.\n+\t* gcc.c, mips-tfile.c, prefix.c, toplev.c, tree.c: Likewise.\n+\t* gen*.c (fatal): Fix error in varargs case.\n+\t* genattrtab.c (fatal): Make same as other gen programs.\n+\t* genattrtab.c: Write #include for system.h in output.\n+\t* genemit.c, genextract.c, genoutput.c, genpeep.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\n+Sat Nov 28 06:01:525 1998  John F. Carr  <jfc@mit.edu>\n+\n+\t* emit-rtl.c (const_int_rtx): Now array of rtx_def, not rtx.\n+\n+Sat Nov 28 05:53:45 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* rtl.h (obstack_alloc_rtx): New declaration.\n+\t* rtl.c (rtx_alloc): Try to clear as integer or HOST_WIDE_INT indirect.\n+\t(obstack_alloc_rtx): New function.\n+\n+Sat Nov 28 05:46:41 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* gengenrtl.c: New file.\n+\t* Makefile.in (OBJS): Add genrtl.c.\n+\t(GEN): Add gengenrtl.\n+\t(STAGESTUFF): Add s-genrtl and gengenrtl$(exeext);\n+\t(RTL_BASE_H): New, from RTL_H.\n+\t(RTL_H): Contains RTL_BASE_H and genrtl.h\n+\t(genrtl.o, genrtl.c, s-genrtl, gengenrtl): New rules.\n+\t* emit-rtl.c (gen_rtx_{CONST_INT,REG,MEM}): New functions.\n+\t(gen_rtx): Call them.\n+\t* genemit.c (gen_exp, gen_insn): Call gen_rtx_FOO for constant FOO.\n+\t* rtl.h (genrtl.h): Include ifndef NO_GENRTL_H.\n+\t(gen_rtx_{CONST_INT,REG,MEM}): New declarations.\n+\t(GEN_INT): Call gen_rtx_CONST_INT.\n+\n+Fri Nov 27 20:16:12 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* configure.in (AC_CHECK_FUNCS): Check for strchr and strrchr.\n+\n+Fri Nov 27 20:13:36 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* system.h: New file.\n+\n+\t* configure.in (AC_CHECK_FUNCS): Remove check for vprintf.\n+\tAdd check for isascii and strsignal.\n+\tCollapse multiple calls.\n+\t(GCC_NEED_DECLARATIONS): Likewise, from GCC_NEED_DECLARATION.\n+\tCheck for bcopy, bcmp, bzero, strerror, atof, getcwd,\n+\tstrsignal and getwd.\n+\tAdd checks for getrlimit and setrlimit; search in sys/resource.h.\n+\t(GCC_FUNC_PRINTF_PTR, GCC_C_VOLATILE, GCC_FUNC_VFPRINTF_DOPRNT): Call.\n+\t(GCC_HEADER_STRING, AC_FUNC_VFORK, AC_HEADER_SYS_WAIT): Likewise.\n+\n+\t* acconfig.h (NEED_DECLARATION_{STRERROR,GETCWD,GETWD,BZERO}: Add.\n+\t(NEED_DECLARATION_{{G,S}ETRLIMIT,STRSIGNAL,BCOPY,BCMP}): Likewise.\n+\t(STRING_WITH_STRINGS, HAVE_VOLATILE, HOST_PTR_PRINTF): Likewise.\n+\n+\t* aclocal.m4 (GCC_NEED_DECLARATION): Accept optional second arg.\n+\tTest STRING_WITH_STRINGS when deciding which headers to search for\n+\tfunction declarations.\n+\t(GCC_NEED_DECLARATIONS, GCC_HEADER_STRING): New autoconf test.\n+\t(GCC_FUNC_{VFPRINTF_DOPRNT,PRINTF_PTR}, GCC_C_VOLATILE): Likewise.\n+\n+Fri Nov 27 20:10:42 1998  Richard Henderson  <rth@cygnus.com>\n+\n+        * configure.in: Add cpp stringify test.\n+\t(AC_CHECK_FUNCS): Check for sbrk.\n+\t* acconfig.h (HAVE_CPP_STRINGIFY): New tag.\n+\n+Fri Nov 27 20:09:27 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n+\n+\t* configure.in (AC_CHECK_FUNCS): Check for getrlimit and setrlimit.\n+\n+Fri Nov 27 19:48:27 1998  Jeffrey A Law  <law@cygnus.com>\n+\n+\t* configure.in (AC_CHECK_FUNCS): Add gettimeofday, atoq, atoll,\n+\tstrerror, stroul, abort and bsearch.\n+\t* acconfig.h (NEED_DECLARATION_{ATOL,ABORT}): New tags.\n+\n+Fri Nov 27 19:46:09 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* acconfig.h (HAVE_INTTYPES_H): New tag.\n+\t* configure.in (inttypes.h): Check for conflicts between sys/types.h\n+\tand inttypes.h and verify that intmax_t is defined.\n+\t\n+Fri Nov 27 08:07:53 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alpha.c (sext_add_operand): Use reg_not_elim_operand.\n+\t(reg_not_elim_or_8bit_operand): New function.\n+\t* alpha.h (PREDICATE_CODE): Add new entry and alphabetize.\n+\t* alpha.md (mult patterns): Ensure eliminable reg not any input.\n+\n+\t* Makefile.in (STAGESTUFF): Remove s-ver.\n+\t(s-ver): Remove rule and revert back to version.c as target.\n+\n+Fri Nov 27 02:39:36 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* cccp.c (main): Make `-I -' equivalent to `-I-'.\n+\n+Fri Nov 27 02:39:36 1998  Sam Kendall  <kendall@init.com>\n+\n+\t* cccp.c (main): Avoid `++i' and `i' in same expression.\n+\n+Thu Nov 26 19:42:02 1998  Stephen L Moshier  <moshier@mediaone.net>\n+\n+\t* real.c (ereal_atof): New function for hexadecimal floating constants.\n+\t* real.h (REAL_VALUE_HTOF): New macro for hex float conversion.\n+\t* c-lex.c (yylex): Use it and check syntax of hex floats.\n+\t* fold-const.c (real_hex_to_f): New function reads hex float\n+\tif no REAL_ARITHMETIC.\n+\n+Thu Nov 26 18:51:51 1998  Richard Henderson <rth@cygnus.com>\n+\n+\t* alpha.c (reg_not_elim_operand): New function.\n+\t* alpha.h (PREDICATE_CODES): Add it.\n+\t* alpha.md: Remove reload-only patterns for (plus (plus (mult ...))).\n+\t(s[48]{add,sub}q): Use new function as predicate for multiplicand.\n+\n+Thu Nov 26 09:13:35 1998  Hans Cappelle  <cappelle@imec.be>\n+\n+\t* reorg.c (fill_simple_delay_slots): Fix typo in sets_cc0_p call.\n+\n+Thu Nov 26 06:15:46 1998  Paul Edwards  <avon@matra.com.au>\n+ \n+\t* genattr.c (fatal): Use vprintf if available.\n+\t* genattrtab.c, gencodes.c, genconfig.c, genemit.c: Likewise.\n+\t* genextract.c, genflags.c, genopinit.c, genoutput.c: Likewise.\n+\t* genpeep.c: Likewise.\n+\n+Wed Nov 25 08:02:23 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* Makefile.in (version.c): Truncate tmp-version.c when writing to\n+\tit, instead of appending.  Use timestamp file s-ver to prevent\n+\trepeated rebuilding of file with unchanged contents.\n+\t(STAGESTUFF): Add s-ver.\n+\n+Wed Nov 25 07:53:24 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload.h (form_sum): Add new parm, DIFF_P.\n+\t* reload.c (form_sum): Likewise.\n+\t(subst_indexed_address): Call it with new parm.\n+\t* reload1.c (eliminate_regs, case MINUS): Make common with PLUS.\n+\t(eliminate_regs_in_insn): Re-recognize if was MINUS.\n+\t* alpha.md: Add patterns for (plus (minus (mult ..) ...) ...).\n+\n+\t* libgcc2.c (__bb_init_prg): Avoid use of bzero.\n+\n+\t* combine.c (make_extraction): Make extraction even if may\n+\tspan if INNER is not MEM.\n+\n+Wed Nov 25 07:30:28 1998  David Addison <addy@quadrics.com>\n+\n+\t* sparc.h (SPARC_INCOMING_INT_ARG_FIRST): Respect TARGET_FLAT.\n+\n+Mon Nov 23 07:00:57 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* function.c (purge_addressof_1): If validate_change fails, try\n+\tvalidate_replace_rtx.\n+\n+\t* expr.c (expand_expr, case ADDR_EXPR): Non-constant can be ADDRESSOF.\n+\n+\t* expr.c (store_constructor_{,field}): New parameter ALIGN and\n+\tuse it when making recursive calls and clearing memory.\n+\t(expand_expr, case CONSTRUCTOR): Call with new parameter.\n+\n+\t* mips/abi64.h (FUNCTION_ARG_PASS_BY_REFERENCE): Remove ABI_EABI test.\n+\t* mips.c (function_arg_pass_by_reference): Return 1 if would\n+\totherwise pass both in registers and on stack.\n+\n+Fri Nov 13 06:56:24 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alpha/vms.h (struct avms_arg_info): Use int for num_args.\n+\n+Mon Nov  2 07:35:26 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* sched.c ({true,anti,output}_dependence): Volatile conflicts with\n+\tanything where MEM_IN_STRUCT_P doesn't match.\n+\n+Fri Oct 30 14:05:32 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (struct move_by_pieces): New fields {to,from}_readonly.\n+\t(move_by_pieces): Initialize them.\n+\t(move_by_pieces_1): Use them.\n+\n+\n+Sun Oct 25 06:12:33 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* optabs.c (emit_no_conflict_block): Allow insn of just USE or SET.\n+\n+\t* explow.c (allocate_dynamic_stack_space): If operand 1 has VOIDmode,\n+\tuse Pmode.\n+\n+\t* configure.in (AC_CHECK_HEADERS): Fix typo with sys/stat.h.\n+\n+\t* Makefile.in (config.status): Use $(srcdir) for configure.\n+\n+\t* sparc.md (*sethi_di_medium_pic): Add CLOBBER of register 1.\n+\n+\t* x-alpha (CLIB): Add -lexc.\n+\n+\t* i386/mingw32.h (OUTPUT_QUOTED_STRING): Don't use Cygwin format\n+\tfor drive letter.\n+\n+\t* cccp.c (handle_directive): Complete support for #undef when -dM.\n+\n+\t* configure.in (alpha*-*-vxworks*): Set MASK_SUPPORT_ARCH from host.\n+\n+\t* m68k.md (adddi3, subdi3, anddi3, iordi3, xordi3): Use split_double.\n+\n+Sat Oct 24 13:41:06 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* local-alloc.c (alloc_qty_for_scratch, requires_inout): Allow\n+\tmatching up to operand number 9.\n+\t* recog.c (constrain_operands): Likewise.\n+\t* reg-stack.c (constrain_asm_operands): Likewise.\n+\t* regclass.c (record_reg_classes): Likewise.\n+\t* regmove.c (find_matches): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* reload1.c (reload_cse_simplify_operands): Likewise.\n+\n+Sat Oct 24 09:27:30 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* regclass.c (record_reg_classes): Skip modifiers when looking\n+\tfor constraint that just matches a previous operand.\n+\tInitialize classes[i] before handling matching operand.\n+\n+Fri Oct 23 07:05:52 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (fold_range_test, fold): Use global_bindings_p,\n+\tnot checking current_function_decl, to see if in function.\n+\n+Mon Oct 12 06:21:08 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* function.c (gen_mem_addressof): Copy REG_USERVAR_P to new reg.\n+\n+Sun Oct 11 14:40:24 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* calls.c (store_one_arg): Use ARGS_SIZE_RTX to get size of argument\n+\twhen emitting chkr_set_right_libfunc call.\n+\n+Mon Oct  5 18:28:33 1998  Hans-Peter Nilsson  <hp@axis.se>\n+\n+\t* Makefile.in (version.c): Apply basename when using VERSION_DEP.\n+\n+Mon Oct  5 18:08:31 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* rs6000.c (rs6000_stack_info): Remove extra paren.\n+\t(print_operand): Cast -1 to HOST_WIDE_INT before shifting it.\n+\t* optabs.c (init_optabs): Create Checker symbols in Pmode.\n+\n+Mon Oct  5 06:23:27 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* function.c (purge_addressof_1): Add new parm IN_DEST.\n+\tIf have different modes and IN_DEST, try making STRICT_LOW_PART.\n+\n+\t* regmove.c (regmove_profitable_p): Put obfree at right place.\n+\n+Sun Oct  4 08:37:36 1998  Paul Edwards  <avon@matra.com.au>\n+\n+\t* configure.in (AC_CHECK_HEADERS): Add sys/types.h and sys/stat.h.\n+\t* gcc.c (sys/types.h, sys/stat.h): Only include if exist.\n+\t* cccp.c, toplev.c: Likewise.\n+\n+Sun Oct  4 07:11:34 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.eu>\n+\n+\t* calls.c (expand_call): Don't call emit_group_store if target\n+\tis the same as VALREG.\n+\n+\t* loop.c (strength_reduce): Track maybe_multiple on giv scan.\n+\t(find_mem_givs, record_giv): New argument maybe_multiple.\n+\n+\t* reorg.c (fill_{simple,eager}_delay_slots): If insn no longer needs\n+\tdelay slots, just skip instead of aborting.\n+\n+Sat Oct  3 08:04:28 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* tree.h (DECL_NO_CHECK_MEMORY_USAGE): New macro.\n+\t(struct tree_decl): New field no_check_memory_usage.\n+\t* c-common.c (enum attrs): Add A_NO_CHECK_MEMORY_USAGE.\n+\t(init_attributes): Register it as a new attribute.\n+\t(decl_attributes): Set flags on functions given that attribute.\n+\t* c-decl.c (duplicate_decls): Merge new attribute.\n+\t* expr.h (current_function_check_memory_usage): Declare.\n+\t* calls.c, expr.c, function.c, stmt.c: Replace uses of\n+\tflag_check_memory_usage with current_function_check_memory_usage.\n+\t* alpha.c, clipper.c, m88k.c, pa.c, sparc.c: Likewise.\n+\t* function.h (struct function): New field check_memory_usage.\n+\t* function.c (current_function_check_memory_usage): Define it.\n+\t(push_function_context_to, pop_function_context_from): Save and\n+\trestore it.\n+\t(expand_function_start): Set it, based on global flag and function\n+\tattribute.\n+\n+\t* expr.c (expand_expr, case VAR_DECL): In memory-checking code, do\n+\tcheck non-automatic variables.\n+\n+Sat Oct  3 07:20:28 1998  Stephen L Moshier  <moshier@world.std.com>\n+\n+\t* emit-rtl.c (gen_lowpart_common): Disable optimization of\n+\tinitialized float-int union if the value is a NaN.\n+\n+Sat Oct  3 06:58:53 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* rs6000.h (ASM_OUTPUT_ADDR_DIFF_ELT): Remove extraneous parameter.\n+\n+Sat Oct  3 06:53:43 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* regmove.c (regmove_profitable_p): Free allocated mem if we return 1.\n+\n+\t* rs6000.h (CPP_PREDEFINES): Add -D_LONG_LONG.\n+\n+Fri Oct  2 11:02:41 1998  Klaus Espenlaub <kespenla@student.informatik.uni-ulm.de>\n+\n+\t* Makefile.in (stmp-fixinc, stmp-fixproto, install-multilib):\n+\tFix directory permissions.\n+\t* objc/Makefile.in (copy-headers): Likewise.\n+\n+Fri Oct  2 10:39:08 1998  Hans-Peter Nilsson  <hp@axis.se>\n+\n+\t* expr.c (expand_expr, case CONSTRUCTOR): Change \">\" to \">=\"\n+\tmaking MOVE_RATIO use consistent.\n+\n+Fri Oct  2 08:22:01 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* h8300.c (get_shift_alg): Fix typo in asm string; \"n\" should be \"\\n\".\n+\n+Wed Sep 30 15:53:17 1998  Klaus Espenlaub  <kespenla@student.informatik.uni-ulm.de>\n+\n+\t* rs6000.h (ASM_OUTPUT_CONSTRUCTOR, ASM_OUTPUT_DESTRUCTOR): Delete.\n+\n Wed Sep 30 14:27:49 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n \n \t* function.c (assign_parms): Undo change of June 9.\n \n+Wed Sep 30 14:21:39 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* c-typeck.c (c_expand_asm_operands): Give error if non-lvalue for\n+\toutput operand.\n+\n+\t* libgcc2.c (__bb_init_prg): Properly zero bb_hashbuckets.\n+\n+Wed Sep 30 11:31:23 1998  Walter Gadeyne  <gadeynew@sebb.bel.alcatel.be>\n+\n+\t* combine.c (num_sign_bit_copies, case UDIV): Return 1.\n+\n+Wed Sep 30 10:44:15 1998  Tristan Gingold  <gingold@gavroche.enst.fr>\n+\n+\t* c-decl.c (finish_decl): Set the assembler name to the current\n+\tdecl if it was specified.\n+\t(finish_function): Use assembler name for constructor and\n+\tdestructor name.\n+\t(duplicate_decls): Copy the assembler name.\n+\n+Wed Sep 30 10:42:49 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* regmove.c (struct match): Change char to int.\n+\n Tue Sep 29 09:57:26 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* regmove.c (regmove_profitable_p): For shift, use 1 as third arg.\n+\n+\t* function.c (find_fixup_replacement): Consider equivalent if\n+\trtx_equal_p, not just same rtx.\n+\n+\t* reload.h (last_output_reload_regno): New declaration.\n+\t* reload.c (find_reloads): No longer make it static and get last value.\n+\t* reload1.c (last_output_reload_regno): New definition.\n+\t(reload): Initialize it before each scan.\n+\t(reload_as_needed): Likewise, and also when insn has no reloads.\n+\t\n+\t* combine.c (simplify_comparison, case AND): Properly check for\n+\tSUBREG of a low part and exclude paradoxcal SUBREG, not low part,\n+\tfor non-WORD_REGISTER_OPERATIONS machines.\n+\n \t* expr.c (get_inner_reference): Fix typo in last change.\n \n Mon Sep 27 21:34:00 1998  Paul Eggert  <eggert@twinsun.com>\n@@ -62,19 +699,12 @@ Mon Aug 17 00:12:42 1998  Paul Eggert  <eggert@twinsun.com>\n Sun Aug  2 01:10:15 1998  Paul Eggert  <eggert@twinsun.com>\n \n \tAdd Native Language Support.\n-\n-\t* intl/, ABOUT-NLS, mkinstalldirs, po/Makefile.in.in: New\n-\tsubdirectory and files.  They should be kept identical to the\n-\tcorresponding items from the GNU gettext distribution.\n-\n-\t* ABOUT-GCC-NLS, exgettext, intl.c, intl.h, po/POTFILES.in,\n-\tpo/en_UK.po: New files.\n-\n-\t* Makefile.in (AWK, datadir, localedir, top_builddir, USE_NLS,\n-\tINTLLIBS, POSUB, INTL_SUBDIRS, HOST_INTLLIBS,\n-\tPREPEND_DOTDOT_TO_RELATIVE_PATHS, SUBDIR_FLAGS_TO_PASS, GCC_OBJS,\n-\tCOLLECT2_OBJS, CCCP_OBJS, CPPMAIN_OBJS, PROTO_OBJS, GCOV_OBJS,\n-\tINTL_DISTCLEAN, GEN_PROTOS_OBJS): New vars.\n+\t* intl/*, mkinstalldirs, po/*, exgettext, intl.c, intl.h: New files.\n+\t* Makefile.in (AWK, datadir, localedir, top_builddir): New variables.\n+\t(USE_NLS, INTLLIBS, POSUB, INTL_SUBDIRS, HOST_INTLLIBS): Likewise.\n+\t(PREPEND_DOTDOT_TO_RELATIVE_PATHS, SUBDIR_FLAGS_TO_PASS): Likewise.\n+\t(GCC_OBJS, COLLECT2_OBJS, CCCP_OBJS, CPPMAIN_OBJS): Likewise.\n+\t(PROTO_OBJS, GCOV_OBJS, INTL_DISTCLEAN, GEN_PROTOS_OBJS): Likewise.\n \t(LIBDEPS, LIBS): Add $(INTLLIBS).\n \t(HOST_LIBDEPS, HOST_LIBS): Add $(HOST_INTLLIBS).\n \t(LIBS): Add @LIBS@.\n@@ -85,25 +715,22 @@ Sun Aug  2 01:10:15 1998  Paul Eggert  <eggert@twinsun.com>\n \t(GEN): Add gencheck.\n \t(STAGESTUFF): Add tree-check.h, gencheck$(exeext).\n \t(native): Depend on intl.all.\n-\t(xgcc, collect2, cccp, cppmain, protoize, unprotoize, gcov): Link\n-\tintl.o.\n-\t(c-typeck.o, c-lex.o, collect2.o, gcc.o, toplev.o, integrate.o,\n-\tfinal.o, cccp.o, cppmain.o, cpplib.o, cpperror.o, s-proto,\n-\tgcov.o): Depend on intl.h.\n-\t(gencheck): Depend on $(HOST_LIBDEPS) instead of tree.h and\n-\ttree.def.\n-\t(gencheck.o, intl.o, $(top_builddir)/intl/libintl.a,\n-\t$(srcdir)/cp/parse.c, intl.all, intl.install, intl.uninstall,\n-\tintl.distdir, intl.mostlyclean, intl.clean, intl.distclean,\n-\tintl.maintainer-clean, intl.distdir-fixup, distdir-check): New\n-\trules.\n+\t(xgcc, collect2, cccp, cppmain, {,un}protoize, gcov): Link intl.o.\n+\t(c-typeck.o, c-lex.o, collect2.o, gcc.o, toplev.o): Depend on intl.h.\n+\t(integrate.o, final.o, cccp.o, cppmain.o, cpplib.o): Likewise.\n+\t(cpperror.o, s-proto, gcov.o): Likewise.\n+\t(gencheck): Depend on $(HOST_LIBDEPS) instead of tree.h and tree.def.\n+\t(gencheck.o, intl.o, $(top_builddir)/intl/libintl.a): New rules.\n+\t($(srcdir)/cp/parse.c, intl.all, intl.install): Likewise.\n+\t(intl.uninstall, intl.distdir, intl.mostlyclean, intl.clean): Likewise.\n+\t(intl.distclean, intl.maintainer-clean, intl.distdir-fixup): Likewise.\n+\t(distdir-check): Likewise.\n \t(gen-protos): Link cpperror.o, cppexp.o, cpphash.o, cpplib.o,\n \tprefix.o, version.o; needed for `cpp_notice'.\n \t(mostlyclean): Depend on intl.mostlyclean.\n \t(clean): Depend on intl.clean.\n \t(distclean): Depend on intl.disclean, unless the invoker defines\n-\tINTL_DISTCLEAN to be empty.  Remove intl/libintl.h and libintl.h\n-\t(created by configure).\n+\tINTL_DISTCLEAN to be empty.  Remove intl/libintl.h and libintl.h.\n \t(maintainer-clean): Make intl.maintainer-clean, but define\n \tINTL_DISTCLEAN to be empty.\n \t(install-normal): Depend on intl.install.\n@@ -112,34 +739,26 @@ Sun Aug  2 01:10:15 1998  Paul Eggert  <eggert@twinsun.com>\n \tUse $(AWK), not awk.  Make tmp/intl and tmp/po directories.\n \t(distdir-finish): Make distdir-check at the end.\n \t(distdir): Depend on intl.distdir, intl.distdir-fixup.\n-\t(compare, compare3, gnucompare, gnucompare3, stage1-start,\n-\tstage2-start, stage3-start, stage4-start): Handle intl\n-\tsubdirectory.\n-\n-\t* acconfig.h (ENABLE_NLS, HAVE_CATGETS, HAVE_GETTEXT,\n-\tHAVE_LC_MESSAGES, HAVE_STPCPY, PACKAGE, VERSION): New macros.\n+\t(compare, compare3, gnucompare, gnucompare3): Handle intl subdirectory.\n+\t(stage1-start, stage2-start, stage3-start, stage4-start): Likewise.\n \n-\t* aclocal.m4 (AC_ISC_POSIX, AM_WITH_NLS, AM_GNU_GETTEXT,\n-\tAM_LC_MESSAGES, AM_PATH_PROG_WITH_TEST): New functions; taken from\n-\tgettext distribution.\n+\t* acconfig.h (ENABLE_NLS, HAVE_CATGETS, HAVE_GETTEXT): New macros.\n+\t(HAVE_LC_MESSAGES, HAVE_STPCPY, PACKAGE, VERSION): Likewise.\n+\t* aclocal.m4 (AC_ISC_POSIX, AM_WITH_NLS): New functions.\n+\t(AM_GNU_GETTEXT, AM_LC_MESSAGES, AM_PATH_PROG_WITH_TEST): Likewise.\n \n \t* bi-arity.c, bi-opcode.c, bi-opname.c: Include config file first.\n-\n \t* c-common.c: Don't include <ctype.h>.\n \t(tfaff): Now a function, not a string.  All users changed.\n \t(check_format_info): Use is_C_digit, not isdigit.\n \tReword messages to ease localization.\n-\n-\t* c-decl.c (redeclaration_error_message): Now returns int, not\n-\tmessage.\n+\t* c-decl.c (redeclaration_error_message): Now returns int, not message.\n \t(poplevel, duplicate_decls, pushdecl): Revamp to pass explicit\n \tstrings to diagnostic generators.\n \t(duplicate_decls, parmlist_tags_warning, finish_struct): Reword\n \tmessages to ease localization.\n-\n \t* c-iterate.c (prdecl): Reword messages so that they do not require\n \tlocalization.\n-\n \t* c-lex.c: Include limits.h if available.\n \tInclude intl.h.\n \tInclude ctype.h only if MAP_CHARACTER is defined.\n@@ -148,245 +767,177 @@ Sun Aug  2 01:10:15 1998  Paul Eggert  <eggert@twinsun.com>\n \t(init_lex): Initialize it.\n \t(yyerror): Localize msgid arg.\n \t(yylex): Use is_C_alnum and is_C_digit, not isalnum and isdigit.\n-\n \t* c-lex.h (C_alnum_array): New decl.\n \t(is_C_alnum, is_C_digit): New macros.\n-\n \t* c-typeck.c: Include intl.h.\n \t(warning_init): Now takes just one arg.\n-\t(incomplete_type_error, build_unary_op, lvalue_or_else,\n-\treadonly_warning, build_modify_expr): Reword messages to ease\n-\tlocalization.\n+\t(incomplete_type_error): Reword messages to ease localization.\n+\t(build_unary_op, lvalue_or_else, readonly_warning): Likewise.\n+\t(build_modify_expr): Likewise.\n \t(build_unary_op, readonly_warning): Revamp to pass explicit\n \tstrings to diagnostic generators.\n \t(build_modify_expr, warn_for_assignment, c_expand_return):\n \tTranslate strings passed to functions expecting translated\n \tstrings.\n \t(get_spelling): Remove; it was a no-op.  All callers changed.\n-\t(error_init, pedwarn_init): Now takes just one arg.  All callers\n-\tand decls changed.  This makes it easier to localize.\n-\n+\t(error_init, pedwarn_init): Now takes one arg.  All callers changed.\n+\t* c-tree.h (error_init, pedwarn_init): Likewise.\n \t* cccp.c: Include intl.h.\n \t(char_name): Remove.\n-\t(check_macro_name): Now takes int 2nd arg, not char *.  All\n-\tcallers changed.\n+\t(check_macro_name): 2nd arg now int, not char *.  All callers changed.\n \t(macarg): Now returns int, not char *.  All callers changed.\n \t(notice, vnotice, pedwarn_strange_white_space): New functions.\n \t(verror): Now extern; used by cexp.y.\n-\t(main): Set message locale, and defer memory allocation until\n-\tafter.\n+\t(main): Set message locale, and defer memory allocation until after.\n \t(main, do_include, print_containing_files): Invoke `notice' to\n \tlocalize notices.\n \t(handle_directive): Invoke pedwarn_strange_white_space instead of\n \tusing char_name.\n-\t(do_include, check_macro_name): Reword messages to ease\n-\tlocalization.\n-\t(my_strerror): Reword message so that it does not require\n-\tlocalization.\n-\t(verror, vwarning, verror_with_line, vwarning_with_line,\n-\tpedwarn_with_file_and_line, fatal): Invoke vnotice to localize\n-\tmsgid.\n+\t(do_include, check_macro_name): Reword messages to ease localization.\n+\t(my_strerror): Likewise.\n+\t(verror, vwarning): Invoke vnotice to localize msgid.\n+\t(verror_with_line, vwarning_with_line): Likewise.\n+\t(pedwarn_with_file_and_line, fatal): Likewise.\n \t(initialize_char_syntax): No need to initialize char_name.\n-\n \t* cexp.y (yyerror): Now takes msgid format and args, not just string.\n \t(verror): New decl.\n-\t(parse_number, yylex): Reword messages to ease\n-\tlocalization.\n+\t(parse_number, yylex): Reword messages to ease localization.\n \t(verror): New test function.\n \t(pedwarn, warning): Translate msgid arg.\n-\n \t* collect2.c: Include intl.h.\n-\t(my_strerror, main, collect_execute, scan_prog_file,\n-\tscan_libraries, read_file, end_file): Reword messages so that they\n-\tdo not require localization.\n-\t(notice): Nwe function.\n-\t(fatal, error, main, collect_execute, maybe_unlink,\n-\twrite_c_file_stat, locatelib, scan_libraries, scan_prog_file,\n-\tadd_func_table): Use it to translate msgid strings.\n-\t(main): Set message locale, and defer memory allocation until\n-\tafter.\n+\t(my_strerror): Reword messages so they do not require localization.\n+\t(main, collect_execute, scan_prog_file, scan_libraries): Likewise.\n+\t(read_file, end_file): Likewise.\n+\t(notice): New function.\n+\t(fatal, error, main): Use it to translate msgid strings.\n+\t(collect_execute, maybe_unlink, write_c_file_stat): Likewise.\n+\t(locatelib, scan_libraries, scan_prog_file, add_func_table): Likewise.\n+\t(main): Set message locale, and defer memory allocation until after.\n \t(collect_wait): Reword messages to ease localization.\n-\t(bad_header): Revamp to pass explicit strings to diagnostic\n-\tgenerators.\n-\n+\t(bad_header): Revamp to pass explicit strings to diagnostic generators.\n \t* combine.c (dump_combine_stats, dump_combine_total_stats):\n \tUse fnotice to translate diagnostic messages.\n-\n-\t* config/1750a/1750a.c (memop_valid): Don't use `valid' as an\n-\tidentifier; it runs afoul of SunOS 4.1.4 <locale.h>.\n-\n-\t* config/arc/initfini.c (__do_global_dtors): Put backslash before\n-\tnewline in strings, to pacify xgettext.\n-\n-\t* config/dsp16xx/dsp16xx.c, config/dsp16xx/dsp16xx.h\n-\t(dsp16xx_invalid_register_for_compare): New function.\n-\t* config/dsp16xx/dsp16xx.md: Use it to report invalid registers.\n-\n-\t* config/i370/i370.h: Include <ctype.h>.\n-\n-\t* config/i386/i386.c: Include config.h first.\n-\n-\t* config/m32r/initfini.c  (__do_global_dtors): Put backslash before\n-\tnewline in strings, to pacify xgettext.\n-\t* config/m88k/dguxbcs.h (CPP_SPEC): Likewise.\n-\n-\t* config/rs6000/rs6000.c: Include config.h first.\n-\t* config/rs6000/rs6000.c, config/rs6000/rs6000.h\n-\t(rs6000_fatal_bad_address): New function.\n-\t* config/rs6000/rs6000.md: Use it to report bad addresses.\n-\n-\t* config/v850/v850.c: Include config.h first.\n-\n-\t* configure.in: When generating config.h and mentioning a file\n-\ttaken from the config directory, surround it with #ifdef IN_GCC,\n-\tso that programs compiled without IN_GCC -- notably in the intl\n-\tsubdirectory -- don't need to be compiled with -Iconfig.\n-\t(PACKAGE, VERSION, ALL_LINGUAS): New vars.\n-\t(AC_ARG_ENABLE): Add --enable-nls.\n-\t(AM_GNU_GETTEXT): Add.  Override XGETTEXT so that we use exgettext\n-\tinstead of xgettext to extract strings.\n-\t(all_outputs): Add intl/Makefile, po/Makefile.in.\n-\tDo not use the shell variable 'l'; it runs afoul of gettext's\n-\taclocal mechanism!\n-\tIf libintl.h is created, echo '#include \"intl/libintl.h\"'\n-\t>libintl.h so that we don't have to futz with our include paths.\n-\n-\t* cp/Make-lang.in (g++.o): Depend on gansidecl.h, intl.h, Makefile;\n-\tdo not depend on config.status.\n-\t(GXX_OBJS): New var.\n-\t(g++$(exeext)): Link intl.o.\n-\n-\t* cp/Makefile.in (top_builddir, INTLLIBS): New vars.\n-\t(LIBS): Add $(INTLLIBS).\n-\n \t* cppalloc.c (memory_full): Use `cpp_notice' to print diagnostic.\n-\n \t* cpperror.c: Include intl.h.\n \t(cpp_print_containing_files): Use cpp_notice to translate messages.\n \t(cpp_message): is_error is -1 for notices.  Translate \"warning:\".\n \t(cpp_fatal): Translate msgid arg.\n-\n-\t* cppexp.c (cpp_lex): Revamp to pass explicit strings to\n-\tdiagnostic generators.\n+\t* cppexp.c (cpp_lex): Pass explicit strings to diagnostic generators.\n \t(cpp_parse_expr): Use cpp_error, not fprintf, to report\n \tunimplemented operators.\n-\n \t* cpplib.c: Include intl.h.\n-\t(check_macro_name): Now takes int 2nd arg, not char *.  All\n-\tcallers changed.\n-\t(check_macro_name, do_define): Reword messages to ease\n-\tlocalization.\n-\t(do_define): Revamp to pass explicit strings to diagnostic\n-\tgenerators.\n+\t(check_macro_name): 2nd arg now int, not char *.  All callers changed.\n+\t(check_macro_name, do_define): Reword messages to ease localization.\n+\t(do_define): Pass explicit strings to diagnostic generators.\n \t(do_define, cpp_start_read, cpp_handle_options): Use cpp_notice to\n \ttranslate messages.\n-\t(cpp_error, cpp_warning, cpp_warning_with_line,\n-\tcpp_pedwarn_with_file_and_line): Translate msgid arg.\n+\t(cpp_error, cpp_warning, cpp_warning_with_line): Translate msgid arg.\n+\t(cpp_pedwarn_with_file_and_line): Likewise.\n \t(cpp_notice): New function.\n-\t(my_strerror): Reword message so that it does not require\n-\tlocalization.\n-\n+\t(my_strerror): Reword message so it does not require localization.\n \t* cpplib.h (cpp_notice): New decl.\n-\n \t* cppmain.c: Include intl.h.\n \t(main): Set message locale.\n-\n \t* cse.c (cse_main): Use fnotice to print diagnostic.\n-\n \t* final.c: Include intl.h; do not include ctype.h.\n \t(output_operand_lossage): Translate msgid arg.\n-\n \t* fold-const.c (optimize_bit_field_compare, fold_truthop): Reword\n \tmessages to ease localization.\n-\n \t* gcc.c: Include intl.h.\n-\t(my_strerror, snapshot_warning): Reword messages so that they do\n-\tnot require localization.\n-\t(init_spec, set_spec, read_specs, execute, do_spec_1, main,\n-\tsnapshot_warning): Invoke `notice' to localize notices.\n-\t(struct switchstr): Don't use `valid' as an identifier; it runs\n-\tafoul of SunOS 4.1.4 <locale.h>.  All uses changed.\n+\t(my_strerror, snapshot_warning): Reword messages so they do not\n+\trequire localization.\n+\t(init_spec, set_spec): Invoke `notice' to localize notices.\n+\t(read_specs, execute, do_spec_1, main, snapshot_warning): Likewise.\n+\t(struct switchstr): Don't use `valid' as identifier.\n \t(do_spec_1): Treat %e string as msgid format, which needs\n \ttranslation.\n \t(main): Set message locale.\n-\t(pfatal_with_name): Invoke perror_with_name, not fatal, so that we\n-\tdon't have to translate \"%s: %s\".\n-\t(perror_with_name): Invoke printf, not error, so that we don't\n-\thave to translate \"%s: %s\".\n-\t(pfatal_pexecute): Invoke pfatal_with_name, not fatal, so that we\n-\tdon't have to translate \"%s: %s\".\n+\t(pfatal_with_name): Invoke perror_with_name, not fatal.\n+\t(perror_with_name): Invoke printf, not error.\n+\t(pfatal_pexecute): Invoke pfatal_with_name, not fatal.\n \t(fatal, error): Translate msgid arg.\n \t(notice): New function.\n-\n \t* gcov.c: Include intl.h; include stdarg.h if __STDC__ is defined.\n \t(main): Set message locale.\n \t(fnotice): New function.\n-\t(xmalloc, fancy_abort, print_usage, open_files, read_files,\n-\tfunction_summary, output_data): Use it to to print diagnostics.\n-\n-\t* install.texi: Explain new configure options --enable-nls,\n-\t--with-included-gettext, --with-catgets.\n-\n+\t(xmalloc, fancy_abort, print_usage): Use it to to print diagnostics.\n+\t(open_files, read_files, function_summary, output_data): Likewise.\n \t* integrate.c: Include intl.h.\n \t(function_cannot_inline_p): Mark msgids with N_.\n-\n-\t* invoke.texi: Describe environment variables affecting locale.\n-\n \t* pexecute.c: Include libintl.h if ENABLE_NLS, otherwise define\n \tgettext to be a noop.\n \t(_, N_): New macros.\n \t(install_error_msg): Wrap inside N_.\n \t(pexecute): Translate diagnostics.\n-\n \t* protoize.c: Include intl.h.\n \t(__attribute__): New macro.\n \t(notice): New function.\n-\t(my_strerror): Reword message so that it does not require\n-\tlocalization.\n-\t(xmalloc, xrealloc, fancy_abort, safe_write, usage,\n-\tfile_normally_convertible, abspath, find_file, aux_info_corrupted,\n-\tsave_def_or_dec, gen_aux_info_file, process_aux_info_file,\n-\trename_c_file, find_extern_def, find_static_definition,\n-\tdeclare_source_confusing, edit_fn_declaration, edit_formals_lists,\n-\tadd_local_decl, add_global_decls, edit_fn_definition,\n-\tscan_for_missed_items, edit_file, main): Use `notice' to print\n-\tdiagnostic.\n+\t(my_strerror): Reword message so it does not require localization.\n+\t(xmalloc, xrealloc, fancy_abort): Use `notice' to print diagnostic.\n+\t(safe_write, usage, file_normally_convertible, abspath): Likewise.\n+\t(find_file, aux_info_corrupted, save_def_or_dec): Likewise.\n+\t(gen_aux_info_file, process_aux_info_file, rename_c_file): Likewise.\n+\t(find_extern_def, find_static_definition): Likewise.\n+\t(declare_source_confusing, edit_fn_declaration): Likewise.\n+\t(edit_formals_lists, add_local_decl, add_global_decls): Likewise.\n+\t(edit_fn_definition, scan_for_missed_items, edit_file, main): Likewise.\n \t(main): Set message locale.\n-\n \t* real.c (NMSGS, ermsg): Remove.\n-\t(mtherr): Revamp to pass explicit strings to diagnostic\n-\tgenerators.  Abort on invalid operations.\n-\n+\t(mtherr): Pass explicit strings to diagnostic generators.\n+\tAbort on invalid operations.\n \t* regclass.c (fix_register): Reword messages to ease localization.\n-\n \t* toplev.c: Include intl.h; do not include ctype.h.\n \t(v_really_sorry, really_sorry): Remove unused functions.\n \t(count_error, fatal_io_error): Translate strings.\n-\t(default_print_error_function, report_error_function, main,\n-\tprint_version): Reword messages to ease localization.  Use\n-\t`notice' to translate diagnostics.\n+\t(default_print_error_function): Reword messages to ease localization.\n+\tUse `notice' to translate diagnostics.\n+\t(report_error_function, main, print_version): Likewise.\n \t(vnotice, notice, fnotice): New functions.\n \t(vmessage): Remove.\n-\t(v_message_with_file_and_line, vsorry): Translate msgid with\n-\tvnotice.\n+\t(v_message_with_file_and_line, vsorry): Translate msgid with vnotice.\n \t(v_message_with_file_and_line, v_message_with_decl): Use\n \treport_file_and_line.  Now takes int warning flag, not prefix;\n \tthis is easier to localize.  All callers changed.\n \t(v_message_with_decl): Abort if first format spec is neither %%\n \tnor %s.  Translate \"((anonymous))\".\n \t(main): Set message locale.\n-\t(set_target_switch): Don't use `valid' as an identifier; it runs\n-\tafoul of SunOS 4.1.4 <locale.h>.\n-\t(__VERSION__): Reword message so that it does not require\n-\tlocalization.\n-\t(print_switch_values): Translate \"options passed\" and \"options\n-\tenabled\".\n-\n-\t* tree.c (valid_machine_attribute): Don't use `valid' as an\n-\tidentifier; it runs afoul of SunOS 4.1.4 <locale.h>.\n-\n+\t(set_target_switch): Don't use `valid' as an identifier.\n+\t(__VERSION__): Reword message so it does not require localization.\n+\t(print_switch_values): Translate \"options passed\" and \"enabled\".\n+\t* tree.c (valid_machine_attribute): Don't use `valid' as identifier.\n \t* xcoffout.c (xcoff_output_standard_types): Use `error' to\n \toutput diagnostic, so that it gets translated.\n+\t* 1750a.c (memop_valid): Don't use `valid' as an identifier.\n+\t* arc/initfini.c (__do_global_dtors): Put backslash before\n+\tnewline in strings, to pacify xgettext.\n+\t* dsp16xx.c (dsp16xx_invalid_register_for_compare): New function.\n+\t* dsp16xx.h: Declare it.\n+\t* dsp16xx.md: Use it to report invalid registers.\n+\t* i370.h: Include <ctype.h>.\n+\t* i386.c: Include config.h first.\n+\t* m32r/initfini.c  (__do_global_dtors): Put backslash before\n+\tnewline in strings, to pacify xgettext.\n+\t* m88k/dguxbcs.h (CPP_SPEC): Likewise.\n+\t* rs6000.c: Include config.h first.\n+\t(rs6000_fatal_bad_address): New function.\n+\t* rs6000.h: Declare it.\n+\t* rs6000.md: Use it to report bad addresses.\n+\t* v850.c: Include config.h first.\n+\n+\t* configure.in: When generating config.h and mentioning file from\n+\tthe config directory, surround it with #ifdef IN_GCC.\n+\t(AC_ARG_ENABLE): Add --enable-nls.\n+\t(AM_GNU_GETTEXT): Add.  Override XGETTEXT so that we use exgettext\n+\tinstead of xgettext to extract strings.\n+\t(all_outputs): Add intl/Makefile, po/Makefile.in.\n+\tDo not use the shell variable 'l'.\n+\tIf libintl.h is created, echo '#include \"intl/libintl.h\"' >libintl.h.\n+\t* cp/Make-lang.in (g++.o): Depend on gansidecl.h, intl.h, Makefile;\n+\tdo not depend on config.status.\n+\t(GXX_OBJS): New var.\n+\t(g++$(exeext)): Link intl.o.\n+\t* cp/Makefile.in (top_builddir, INTLLIBS): New vars.\n+\t(LIBS): Add $(INTLLIBS).\n \n \t* patch-apollo-includes: Remove; this is part of README.APOLLO.\n "}, {"sha": "ce56466ff01270a545a28dd4d679086dc2c7071c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -689,7 +689,7 @@ CCCP=@cpp_main@\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c tree-check.h \\\n- s-flags s-config s-codes s-mlib s-under\\\n+ s-flags s-config s-codes s-mlib s-unders s-genrtl \\\n  s-output s-recog s-emit s-extract s-peep s-check \\\n  s-attr s-attrtab s-opinit s-crt s-crtS s-crt0 \\\n  genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \\\n@@ -786,6 +786,16 @@ REGS_H = regs.h varray.h machmode.h machmode.def\n .SUFFIXES:\n .SUFFIXES: .c .o\n \n+$(srcdir)/version.c: $(VERSION_DEP)\n+\t(cd $(srcdir); cvs log -h `basename $?`) >tmp-ver\n+\ttag=`sed '1,/^sym/d;s/\t*gcc-//;s/:.*$$//;q' tmp-ver`; \\\n+\tver=`echo $${tag} | sed 's/-.*//' | sed 's/_/./g'`; \\\n+\tdate=`echo $${tag} | sed 's/.*-//'`; \\\n+\tif [ $${date} != RELEASE ]; then ver=\"testgcc-$${ver} $${date} experimental\"; fi; \\\n+\techo \"char *version_string = \\\"$${ver}\\\";\" >tmp-version.c\n+\trm -f tmp-ver\n+\t$(srcdir)/move-if-change tmp-version.c $(srcdir)/version.c\n+\n Makefile: $(srcdir)/Makefile.in config.status $(srcdir)/version.c \\\n    $(xmake_file) $(tmake_file) $(LANG_MAKEFILES)\n \t$(SHELL) $(srcdir)/configure.frag $(srcdir) \"$(SUBDIRS)\" \\\n@@ -818,7 +828,7 @@ cstamp-h: config.in config.status\n # Really, really stupid make features, such as SUN's KEEP_STATE, may force\n # a target to build even if it is up-to-date.  So we must verify that\n # config.status does not exist before failing.\n-config.status: configure version.c\n+config.status: $(srcdir)/configure version.c\n \t@if [ ! -f config.status ] ; then \\\n \t  echo You must configure gcc.  Look at the INSTALL file for details.; \\\n \t  false; \\\n@@ -1449,7 +1459,7 @@ prefix.o: prefix.c $(CONFIG_H) system.h Makefile prefix.h\n \t-DPREFIX=\\\"$(prefix)\\\" \\\n \t  -c `echo $(srcdir)/prefix.c | sed 's,^\\./,,'`\n \n-convert.o: convert.c $(CONFIG_H) $(TREE_H) flags.h convert.h toplev.h\n+convert.o: convert.c $(CONFIG_H) system.h $(TREE_H) flags.h convert.h toplev.h\n \n tree.o : tree.c $(CONFIG_H) system.h $(TREE_H) flags.h function.h toplev.h \\\n    ggc.h\n@@ -1521,11 +1531,9 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(REGS_H) insn-config.h $(RECOG_H) real.h ggc.h \\\n    $(EXPR_H) $(srcdir)/../include/obstack.h hard-reg-set.h bitmap.h toplev.h\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n-\n integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    integrate.h insn-flags.h insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n    intl.h function.h output.h $(RECOG_H) except.h toplev.h\n-\n jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h insn-attr.h\n@@ -1567,7 +1575,6 @@ bitmap.o : bitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h reload.h function.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h toplev.h\n varray.o : varray.c $(CONFIG_H) system.h varray.h $(RTL_H) $(TREE_H) bitmap.h\n-\n reload.o : reload.c $(CONFIG_H) system.h $(RTL_H) flags.h output.h $(EXPR_H) \\\n    reload.h $(RECOG_H) hard-reg-set.h insn-config.h insn-codes.h $(REGS_H) \\\n    function.h real.h toplev.h\n@@ -1757,11 +1764,11 @@ genrtl.c genrtl.h : s-genrtl\n \t@true\t# force gnu make to recheck modification times.\n \n s-genrtl: gengenrtl $(srcdir)/move-if-change $(RTL_BASE_H)\n-\t./gengenrtl tmp-genrtl.h tmp-genrtl.c\n+\t./gengenrtl -h >tmp-genrtl.h\n \t$(srcdir)/move-if-change tmp-genrtl.h genrtl.h\n+\t./gengenrtl >tmp-genrtl.c\n \t$(srcdir)/move-if-change tmp-genrtl.c genrtl.c\n \ttouch s-genrtl\n-\n #\f\n # Compile the programs that generate insn-* from the machine description.\n # They are compiled with $(HOST_CC), and associated libraries,\n@@ -1862,7 +1869,6 @@ gengenrtl : gengenrtl.o $(HOST_LIBDEPS)\n \n gengenrtl.o : gengenrtl.c $(RTL_BASE_H) system.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gengenrtl.c\n-\n #\f\n # Compile the libraries to be used by gen*.\n # If we are not cross-building, gen* use the same .o's that cc1 will use,\n@@ -1970,7 +1976,7 @@ cpp$(exeext): $(CCCP)$(exeext)\n CCCP_OBJS = cccp.o cexp.o intl.o prefix.o version.o @extra_cpp_objs@ mbchar.o \n cccp$(exeext): $(CCCP_OBJS) $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(CCCP_OBJS) $(LIBS)\n-cexp.o: $(srcdir)/cexp.c $(CONFIG_H) system.h\n+cexp.o: $(srcdir)/cexp.c $(CONFIG_H) system.h mbchar.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $(srcdir)/cexp.c\n $(srcdir)/cexp.c: $(srcdir)/cexp.y\n \tcd $(srcdir); $(BISON) -o cexp.c cexp.y\n@@ -2162,6 +2168,7 @@ fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \\\n # Build fixed copies of system files.\n stmp-fixinc: fixinc.sh gsyslimits.h\n \trm -rf include; mkdir include\n+\t-chmod a+rx include\n \tTARGET_MACHINE=$(target); srcdir=`cd $(srcdir); pwd`; \\\n \tINSTALL_ASSERT_H=$(INSTALL_ASSERT_H); SHELL=$(SHELL) ;\\\n \texport TARGET_MACHINE srcdir INSTALL_ASSERT_H SHELL ; \\\n@@ -2251,7 +2258,7 @@ fixhdr.ready: fix-header\n # if it has already been run on the files in `include'.\n stmp-fixproto: fixhdr.ready fixproto stmp-headers\n \t@echo \"Various warnings and error messages from fixproto are normal\"\n-\t-if [ -d include ] ; then true; else mkdir include; fi\n+\t-if [ -d include ] ; then true; else mkdir include; chmod a+rx include; fi\n \t-if [ -f include/fixed ] ; then true; \\\n \telse \\\n \t  : This line works around a 'make' bug in BSDI 1.1.; \\\n@@ -2621,7 +2628,7 @@ install-libgcc: libgcc.a installdirs\n install-multilib: stmp-multilib installdirs\n \tfor i in `$(GCC_FOR_TARGET) --print-multi-lib`; do \\\n \t  dir=`echo $$i | sed -e 's/;.*$$//'`; \\\n-\t  if [ -d $(libsubdir)/$${dir} ]; then true; else mkdir $(libsubdir)/$${dir}; fi; \\\n+\t  if [ -d $(libsubdir)/$${dir} ]; then true; else mkdir $(libsubdir)/$${dir}; chmod a+rx $(libsubdir)/$${dir}; fi; \\\n \t  for f in libgcc.a $(EXTRA_MULTILIB_PARTS); do \\\n \t    rm -f $(libsubdir)/$${dir}/$${f}; \\\n \t    $(INSTALL_DATA) $${dir}/$${f} $(libsubdir)/$${dir}/$${f}; \\"}, {"sha": "b6d1dbf2f67ea5858b2b52782074c7cc1d121a48", "filename": "gcc/bitmap.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -29,7 +29,6 @@ Boston, MA 02111-1307, USA.  */\n /* Obstack to allocate bitmap elements from.  */\n static struct obstack bitmap_obstack;\n static int bitmap_obstack_init = FALSE;\n-\n \f\n #ifndef INLINE\n #ifndef __GNUC__"}, {"sha": "7bde098e0e19916f73d8c55b6a9d591df2ab7aaa", "filename": "gcc/c-convert.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n    but what kind of conversions it does will depend on the language.  */\n \n #include \"config.h\"\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"convert.h\""}, {"sha": "c2d04c1a6804e366d9f89af601e0ff90e0ec41f8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1925,6 +1925,10 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n       if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n \tDECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n \n+      /* Copy the assembler name.\n+\t Currently, it can only be defined in the prototype.  */\n+      DECL_ASSEMBLER_NAME (newdecl) = DECL_ASSEMBLER_NAME (olddecl);\n+\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n \t  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n@@ -3740,6 +3744,7 @@ finish_decl (decl, init, asmspec_tree)\n       {\n \tDECL_BUILT_IN (decl) = 0;\n \tDECL_RTL (decl) = 0;\n+\tDECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n       }\n \n   /* Output the assembler code and/or RTL code for variables and functions,\n@@ -7005,7 +7010,8 @@ finish_function (nested)\n \tstatic_ctors = perm_tree_cons (NULL_TREE, fndecl, static_ctors);\n       else\n #endif\n-      assemble_constructor (IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+\tassemble_constructor (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl))); \n+\n     }\n   if (DECL_STATIC_DESTRUCTOR (fndecl))\n     {\n@@ -7014,7 +7020,7 @@ finish_function (nested)\n \tstatic_dtors = perm_tree_cons (NULL_TREE, fndecl, static_dtors);\n       else\n #endif\n-      assemble_destructor (IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+\tassemble_destructor (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)));\n     }\n \n   if (! nested)"}, {"sha": "c554b759d236effd357521800b87ca237b5dda13", "filename": "gcc/c-gperf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-gperf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-gperf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gperf.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n-/* C code produced by gperf version 2.7 */\n-/* Command-line: gperf -L C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ ../../../egcs/gcc/c-parse.gperf  */\n+/* C code produced by gperf version 2.7.1 (19981006 egcs) */\n+/* Command-line: gperf -L C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ /home/law/egcs/egcs/gcc/c-parse.gperf  */\n /* Command-line: gperf -L KR-C -F ', 0, 0' -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n struct resword { const char *name; short token; enum rid rid; };\n "}, {"sha": "c8acc4b81e313f51a8041ffb009ba5e2a84a8889", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 88, 89, 92, 93, 96, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "ccb113f1671fa4111fcad207c89a9ccac0972fab", "filename": "gcc/c-lex.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -45,6 +45,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"mbchar.h\"\n #include <locale.h>\n #endif /* MULTIBYTE_CHARS */\n+#ifndef GET_ENVIRONMENT\n+#define GET_ENVIRONMENT(ENV_VALUE,ENV_NAME) ((ENV_VALUE) = getenv (ENV_NAME))\n+#endif\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -279,7 +282,7 @@ init_lex ()\n #ifdef MULTIBYTE_CHARS\n   /* Change to the native locale for multibyte conversions.  */\n   setlocale (LC_CTYPE, \"\");\n-  literal_codeset = getenv (\"LANG\");\n+  GET_ENVIRONMENT (literal_codeset, \"LANG\");\n #endif\n \n   maxtoken = 40;\n@@ -1529,7 +1532,7 @@ yylex ()\n #define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n \tunsigned int parts[TOTAL_PARTS];\n \n-\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS, AFTER_EXPON }\n+\tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS, AFTER_EXPON}\n \t  floatflag = NOT_FLOAT;\n \n \tfor (count = 0; count < TOTAL_PARTS; count++)\n@@ -1970,7 +1973,7 @@ yylex ()\n \tint max_chars;\n #ifdef MULTIBYTE_CHARS\n \tint longest_char = local_mb_cur_max ();\n-\tlocal_mbtowc (NULL_PTR, NULL_PTR, 0);\n+\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n \n \tmax_chars = TYPE_PRECISION (integer_type_node) / width;\n@@ -2091,7 +2094,7 @@ yylex ()\n \t  }\n \n \tif (c != '\\'')\n-\t  error (\"malformatted character constant\");\n+\t  error (\"malformed character constant\");\n \telse if (chars_seen == 0)\n \t  error (\"empty character constant\");\n \telse if (num_chars > max_chars)\n@@ -2139,9 +2142,8 @@ yylex ()\n \t                           : TYPE_PRECISION (char_type_node);\n #ifdef MULTIBYTE_CHARS\n \tint longest_char = local_mb_cur_max ();\n-\tlocal_mbtowc (NULL_PTR, NULL_PTR, 0);\n+\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n-\n \tc = token_getch ();\n \tp = token_buffer + 1;\n "}, {"sha": "9c98db28d83237bd087729a9eac05f555a272d37", "filename": "gcc/c-parse.c", "status": "modified", "additions": 110, "deletions": 179, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,71 +1,71 @@\n \n /*  A Bison parser, made from c-parse.y\n- by  GNU Bison version 1.27\n+ by  GNU Bison version 1.25\n   */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n-#define\tIDENTIFIER\t257\n-#define\tTYPENAME\t258\n-#define\tSCSPEC\t259\n-#define\tTYPESPEC\t260\n-#define\tTYPE_QUAL\t261\n-#define\tCONSTANT\t262\n-#define\tSTRING\t263\n-#define\tELLIPSIS\t264\n-#define\tSIZEOF\t265\n-#define\tENUM\t266\n-#define\tSTRUCT\t267\n-#define\tUNION\t268\n-#define\tIF\t269\n-#define\tELSE\t270\n-#define\tWHILE\t271\n-#define\tDO\t272\n-#define\tFOR\t273\n-#define\tSWITCH\t274\n-#define\tCASE\t275\n-#define\tDEFAULT\t276\n-#define\tBREAK\t277\n-#define\tCONTINUE\t278\n-#define\tRETURN\t279\n-#define\tGOTO\t280\n-#define\tASM_KEYWORD\t281\n-#define\tTYPEOF\t282\n-#define\tALIGNOF\t283\n-#define\tATTRIBUTE\t284\n-#define\tEXTENSION\t285\n-#define\tLABEL\t286\n-#define\tREALPART\t287\n-#define\tIMAGPART\t288\n-#define\tVA_ARG\t289\n-#define\tEND_OF_LINE\t290\n-#define\tASSIGN\t291\n-#define\tOROR\t292\n-#define\tANDAND\t293\n-#define\tEQCOMPARE\t294\n-#define\tARITHCOMPARE\t295\n-#define\tLSHIFT\t296\n-#define\tRSHIFT\t297\n-#define\tUNARY\t298\n-#define\tPLUSPLUS\t299\n-#define\tMINUSMINUS\t300\n-#define\tHYPERUNARY\t301\n-#define\tPOINTSAT\t302\n-#define\tINTERFACE\t303\n-#define\tIMPLEMENTATION\t304\n-#define\tEND\t305\n-#define\tSELECTOR\t306\n-#define\tDEFS\t307\n-#define\tENCODE\t308\n-#define\tCLASSNAME\t309\n-#define\tPUBLIC\t310\n-#define\tPRIVATE\t311\n-#define\tPROTECTED\t312\n-#define\tPROTOCOL\t313\n-#define\tOBJECTNAME\t314\n-#define\tCLASS\t315\n-#define\tALIAS\t316\n-#define\tOBJC_STRING\t317\n+#define\tIDENTIFIER\t258\n+#define\tTYPENAME\t259\n+#define\tSCSPEC\t260\n+#define\tTYPESPEC\t261\n+#define\tTYPE_QUAL\t262\n+#define\tCONSTANT\t263\n+#define\tSTRING\t264\n+#define\tELLIPSIS\t265\n+#define\tSIZEOF\t266\n+#define\tENUM\t267\n+#define\tSTRUCT\t268\n+#define\tUNION\t269\n+#define\tIF\t270\n+#define\tELSE\t271\n+#define\tWHILE\t272\n+#define\tDO\t273\n+#define\tFOR\t274\n+#define\tSWITCH\t275\n+#define\tCASE\t276\n+#define\tDEFAULT\t277\n+#define\tBREAK\t278\n+#define\tCONTINUE\t279\n+#define\tRETURN\t280\n+#define\tGOTO\t281\n+#define\tASM_KEYWORD\t282\n+#define\tTYPEOF\t283\n+#define\tALIGNOF\t284\n+#define\tATTRIBUTE\t285\n+#define\tEXTENSION\t286\n+#define\tLABEL\t287\n+#define\tREALPART\t288\n+#define\tIMAGPART\t289\n+#define\tVA_ARG\t290\n+#define\tEND_OF_LINE\t291\n+#define\tASSIGN\t292\n+#define\tOROR\t293\n+#define\tANDAND\t294\n+#define\tEQCOMPARE\t295\n+#define\tARITHCOMPARE\t296\n+#define\tLSHIFT\t297\n+#define\tRSHIFT\t298\n+#define\tUNARY\t299\n+#define\tPLUSPLUS\t300\n+#define\tMINUSMINUS\t301\n+#define\tHYPERUNARY\t302\n+#define\tPOINTSAT\t303\n+#define\tINTERFACE\t304\n+#define\tIMPLEMENTATION\t305\n+#define\tEND\t306\n+#define\tSELECTOR\t307\n+#define\tDEFS\t308\n+#define\tENCODE\t309\n+#define\tCLASSNAME\t310\n+#define\tPUBLIC\t311\n+#define\tPRIVATE\t312\n+#define\tPROTECTED\t313\n+#define\tPROTOCOL\t314\n+#define\tOBJECTNAME\t315\n+#define\tCLASS\t316\n+#define\tALIAS\t317\n+#define\tOBJC_STRING\t318\n \n #line 33 \"c-parse.y\"\n \n@@ -151,7 +151,7 @@ c_parse_init ()\n #define\tYYFLAG\t\t-32768\n #define\tYYNTBASE\t86\n \n-#define YYTRANSLATE(x) ((unsigned)(x) <= 317 ? yytranslate[x] : 244)\n+#define YYTRANSLATE(x) ((unsigned)(x) <= 318 ? yytranslate[x] : 244)\n \n static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n@@ -179,13 +179,13 @@ static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,\n-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,\n-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,\n-    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n-    37,    41,    42,    46,    47,    48,    49,    55,    56,    57,\n-    58,    59,    63,    64,    65,    66,    67,    68,    69,    70,\n-    71,    72,    73,    74,    75,    76,    77\n+     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,\n+     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,\n+    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,\n+    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,\n+    36,    37,    41,    42,    46,    47,    48,    49,    55,    56,\n+    57,    58,    59,    63,    64,    65,    66,    67,    68,    69,\n+    70,    71,    72,    73,    74,    75,    76,    77\n };\n \n #if YYDEBUG != 0\n@@ -1256,8 +1256,7 @@ static const short yycheck[] = {    38,\n     53,    54\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/lib/bison.simple\"\n-/* This file comes from bison-1.27.  */\n+#line 3 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1274,66 +1273,46 @@ static const short yycheck[] = {    38,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n    This special exception was added by the Free Software Foundation\n    in version 1.24 of Bison.  */\n \n-/* This is the parser code that is written into each bison parser\n-  when the %semantic_parser declaration is not specified in the grammar.\n-  It was written by Richard Stallman by simplifying the hairy parser\n-  used when %semantic_parser is specified.  */\n-\n-#ifndef YYSTACK_USE_ALLOCA\n-#ifdef alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* alloca not defined */\n+#ifndef alloca\n #ifdef __GNUC__\n-#define YYSTACK_USE_ALLOCA\n #define alloca __builtin_alloca\n #else /* not GNU C.  */\n-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))\n-#define YYSTACK_USE_ALLOCA\n+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)\n #include <alloca.h>\n #else /* not sparc */\n-/* We think this test detects Watcom and Microsoft C.  */\n-/* This used to test MSDOS, but that is a bad idea\n-   since that symbol is in the user namespace.  */\n-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)\n-#if 0 /* No need for malloc.h, which pollutes the namespace;\n-\t instead, just don't use alloca.  */\n+#if defined (MSDOS) && !defined (__TURBOC__)\n #include <malloc.h>\n-#endif\n #else /* not MSDOS, or __TURBOC__ */\n #if defined(_AIX)\n-/* I don't know what this was needed for, but it pollutes the namespace.\n-   So I turned it off.   rms, 2 May 1997.  */\n-/* #include <malloc.h>  */\n+#include <malloc.h>\n  #pragma alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* not MSDOS, or __TURBOC__, or _AIX */\n-#if 0\n-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,\n-\t\t and on HPUX 10.  Eventually we can turn this on.  */\n-#define YYSTACK_USE_ALLOCA\n-#define alloca __builtin_alloca\n+#else /* not MSDOS, __TURBOC__, or _AIX */\n+#ifdef __hpux\n+#ifdef __cplusplus\n+extern \"C\" {\n+void *alloca (unsigned int);\n+};\n+#else /* not __cplusplus */\n+void *alloca ();\n+#endif /* not __cplusplus */\n #endif /* __hpux */\n-#endif\n #endif /* not _AIX */\n #endif /* not MSDOS, or __TURBOC__ */\n-#endif /* not sparc */\n-#endif /* not GNU C */\n-#endif /* alloca not defined */\n-#endif /* YYSTACK_USE_ALLOCA not defined */\n+#endif /* not sparc.  */\n+#endif /* not GNU C.  */\n+#endif /* alloca not defined.  */\n \n-#ifdef YYSTACK_USE_ALLOCA\n-#define YYSTACK_ALLOC alloca\n-#else\n-#define YYSTACK_ALLOC malloc\n-#endif\n+/* This is the parser code that is written into each bison parser\n+  when the %semantic_parser declaration is not specified in the grammar.\n+  It was written by Richard Stallman by simplifying the hairy parser\n+  used when %semantic_parser is specified.  */\n \n /* Note: there must be only one dollar sign in this file.\n    It is replaced by the list of actions, each action\n@@ -1343,8 +1322,8 @@ static const short yycheck[] = {    38,\n #define yyclearin\t(yychar = YYEMPTY)\n #define YYEMPTY\t\t-2\n #define YYEOF\t\t0\n-#define YYACCEPT\tgoto yyacceptlab\n-#define YYABORT \tgoto yyabortlab\n+#define YYACCEPT\treturn(0)\n+#define YYABORT \treturn(1)\n #define YYERROR\t\tgoto yyerrlab1\n /* Like YYERROR except do call yyerror.\n    This remains here temporarily to ease the\n@@ -1425,12 +1404,12 @@ int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n #ifndef YYMAXDEPTH\n #define YYMAXDEPTH 10000\n #endif\n-\f\n-/* Define __yy_memcpy.  Note that the size argument\n-   should be passed with type unsigned int, because that is what the non-GCC\n-   definitions require.  With GCC, __builtin_memcpy takes an arg\n-   of type size_t, but it can handle unsigned int.  */\n \n+/* Prevent warning if -Wstrict-prototypes.  */\n+#ifdef __GNUC__\n+int yyparse (void);\n+#endif\n+\f\n #if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n #define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n #else\t\t\t\t/* not GNU C or C++ */\n@@ -1442,7 +1421,7 @@ static void\n __yy_memcpy (to, from, count)\n      char *to;\n      char *from;\n-     unsigned int count;\n+     int count;\n {\n   register char *f = from;\n   register char *t = to;\n@@ -1457,10 +1436,10 @@ __yy_memcpy (to, from, count)\n /* This is the most reliable way to avoid incompatibilities\n    in available built-in functions on various systems.  */\n static void\n-__yy_memcpy (char *to, char *from, unsigned int count)\n+__yy_memcpy (char *to, char *from, int count)\n {\n-  register char *t = to;\n   register char *f = from;\n+  register char *t = to;\n   register int i = count;\n \n   while (i-- > 0)\n@@ -1470,7 +1449,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 216 \"/usr/lib/bison.simple\"\n+#line 196 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -1491,15 +1470,6 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #define YYPARSE_PARAM_DECL\n #endif /* not YYPARSE_PARAM */\n \n-/* Prevent warning if -Wstrict-prototypes.  */\n-#ifdef __GNUC__\n-#ifdef YYPARSE_PARAM\n-int yyparse (void *);\n-#else\n-int yyparse (void);\n-#endif\n-#endif\n-\n int\n yyparse(YYPARSE_PARAM_ARG)\n      YYPARSE_PARAM_DECL\n@@ -1528,7 +1498,6 @@ yyparse(YYPARSE_PARAM_ARG)\n #endif\n \n   int yystacksize = YYINITDEPTH;\n-  int yyfree_stacks = 0;\n \n #ifdef YYPURE\n   int yychar;\n@@ -1613,32 +1582,18 @@ yyparse(YYPARSE_PARAM_ARG)\n       if (yystacksize >= YYMAXDEPTH)\n \t{\n \t  yyerror(\"parser stack overflow\");\n-\t  if (yyfree_stacks)\n-\t    {\n-\t      free (yyss);\n-\t      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-\t      free (yyls);\n-#endif\n-\t    }\n \t  return 2;\n \t}\n       yystacksize *= 2;\n       if (yystacksize > YYMAXDEPTH)\n \tyystacksize = YYMAXDEPTH;\n-#ifndef YYSTACK_USE_ALLOCA\n-      yyfree_stacks = 1;\n-#endif\n-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));\n-      __yy_memcpy ((char *)yyss, (char *)yyss1,\n-\t\t   size * (unsigned int) sizeof (*yyssp));\n-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));\n-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,\n-\t\t   size * (unsigned int) sizeof (*yyvsp));\n+      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));\n+      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));\n+      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));\n+      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));\n #ifdef YYLSP_NEEDED\n-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));\n-      __yy_memcpy ((char *)yyls, (char *)yyls1,\n-\t\t   size * (unsigned int) sizeof (*yylsp));\n+      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));\n+      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));\n #endif\n #endif /* no yyoverflow */\n \n@@ -3868,7 +3823,7 @@ case 407:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 542 \"/usr/lib/bison.simple\"\n+#line 498 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -4063,30 +4018,6 @@ case 407:\n \n   yystate = yyn;\n   goto yynewstate;\n-\n- yyacceptlab:\n-  /* YYACCEPT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 0;\n-\n- yyabortlab:\n-  /* YYABORT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 1;\n }\n #line 2254 \"c-parse.y\"\n "}, {"sha": "5c9abe09ac1d8bccd4652b7f061bc89da62c2143", "filename": "gcc/c-parse.h", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,66 +1,66 @@\n typedef union {long itype; tree ttype; enum tree_code code;\n \tchar *filename; int lineno; int ends_in_label; } YYSTYPE;\n-#define\tIDENTIFIER\t257\n-#define\tTYPENAME\t258\n-#define\tSCSPEC\t259\n-#define\tTYPESPEC\t260\n-#define\tTYPE_QUAL\t261\n-#define\tCONSTANT\t262\n-#define\tSTRING\t263\n-#define\tELLIPSIS\t264\n-#define\tSIZEOF\t265\n-#define\tENUM\t266\n-#define\tSTRUCT\t267\n-#define\tUNION\t268\n-#define\tIF\t269\n-#define\tELSE\t270\n-#define\tWHILE\t271\n-#define\tDO\t272\n-#define\tFOR\t273\n-#define\tSWITCH\t274\n-#define\tCASE\t275\n-#define\tDEFAULT\t276\n-#define\tBREAK\t277\n-#define\tCONTINUE\t278\n-#define\tRETURN\t279\n-#define\tGOTO\t280\n-#define\tASM_KEYWORD\t281\n-#define\tTYPEOF\t282\n-#define\tALIGNOF\t283\n-#define\tATTRIBUTE\t284\n-#define\tEXTENSION\t285\n-#define\tLABEL\t286\n-#define\tREALPART\t287\n-#define\tIMAGPART\t288\n-#define\tVA_ARG\t289\n-#define\tEND_OF_LINE\t290\n-#define\tASSIGN\t291\n-#define\tOROR\t292\n-#define\tANDAND\t293\n-#define\tEQCOMPARE\t294\n-#define\tARITHCOMPARE\t295\n-#define\tLSHIFT\t296\n-#define\tRSHIFT\t297\n-#define\tUNARY\t298\n-#define\tPLUSPLUS\t299\n-#define\tMINUSMINUS\t300\n-#define\tHYPERUNARY\t301\n-#define\tPOINTSAT\t302\n-#define\tINTERFACE\t303\n-#define\tIMPLEMENTATION\t304\n-#define\tEND\t305\n-#define\tSELECTOR\t306\n-#define\tDEFS\t307\n-#define\tENCODE\t308\n-#define\tCLASSNAME\t309\n-#define\tPUBLIC\t310\n-#define\tPRIVATE\t311\n-#define\tPROTECTED\t312\n-#define\tPROTOCOL\t313\n-#define\tOBJECTNAME\t314\n-#define\tCLASS\t315\n-#define\tALIAS\t316\n-#define\tOBJC_STRING\t317\n+#define\tIDENTIFIER\t258\n+#define\tTYPENAME\t259\n+#define\tSCSPEC\t260\n+#define\tTYPESPEC\t261\n+#define\tTYPE_QUAL\t262\n+#define\tCONSTANT\t263\n+#define\tSTRING\t264\n+#define\tELLIPSIS\t265\n+#define\tSIZEOF\t266\n+#define\tENUM\t267\n+#define\tSTRUCT\t268\n+#define\tUNION\t269\n+#define\tIF\t270\n+#define\tELSE\t271\n+#define\tWHILE\t272\n+#define\tDO\t273\n+#define\tFOR\t274\n+#define\tSWITCH\t275\n+#define\tCASE\t276\n+#define\tDEFAULT\t277\n+#define\tBREAK\t278\n+#define\tCONTINUE\t279\n+#define\tRETURN\t280\n+#define\tGOTO\t281\n+#define\tASM_KEYWORD\t282\n+#define\tTYPEOF\t283\n+#define\tALIGNOF\t284\n+#define\tATTRIBUTE\t285\n+#define\tEXTENSION\t286\n+#define\tLABEL\t287\n+#define\tREALPART\t288\n+#define\tIMAGPART\t289\n+#define\tVA_ARG\t290\n+#define\tEND_OF_LINE\t291\n+#define\tASSIGN\t292\n+#define\tOROR\t293\n+#define\tANDAND\t294\n+#define\tEQCOMPARE\t295\n+#define\tARITHCOMPARE\t296\n+#define\tLSHIFT\t297\n+#define\tRSHIFT\t298\n+#define\tUNARY\t299\n+#define\tPLUSPLUS\t300\n+#define\tMINUSMINUS\t301\n+#define\tHYPERUNARY\t302\n+#define\tPOINTSAT\t303\n+#define\tINTERFACE\t304\n+#define\tIMPLEMENTATION\t305\n+#define\tEND\t306\n+#define\tSELECTOR\t307\n+#define\tDEFS\t308\n+#define\tENCODE\t309\n+#define\tCLASSNAME\t310\n+#define\tPUBLIC\t311\n+#define\tPRIVATE\t312\n+#define\tPROTECTED\t313\n+#define\tPROTOCOL\t314\n+#define\tOBJECTNAME\t315\n+#define\tCLASS\t316\n+#define\tALIAS\t317\n+#define\tOBJC_STRING\t318\n \n \n extern YYSTYPE yylval;"}, {"sha": "d9bfcf26ac5650803d799729e5f17d653eb8b05f", "filename": "gcc/c-parse.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -38,7 +38,6 @@ end ifc\n #include \"config.h\"\n #include \"system.h\"\n #include <setjmp.h>\n-\n #include \"tree.h\"\n #include \"input.h\"\n #include \"c-lex.h\""}, {"sha": "72885ebdeb49a43c5cd401320715ee1ccfa0da3c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -3155,8 +3155,10 @@ lvalue_or_else (ref, msgid)\n      const char *msgid;\n {\n   int win = lvalue_p (ref);\n+\n   if (! win)\n     error (msgid);\n+\n   return win;\n }\n \n@@ -3802,8 +3804,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       /* Handle (a, b) used as an \"lvalue\".  */\n     case COMPOUND_EXPR:\n       pedantic_lvalue_warning (COMPOUND_EXPR);\n-      newrhs = build_modify_expr (TREE_OPERAND (lhs, 1),\n-\t\t\t\t  modifycode, rhs);\n+      newrhs = build_modify_expr (TREE_OPERAND (lhs, 1), modifycode, rhs);\n       if (TREE_CODE (newrhs) == ERROR_MARK)\n \treturn error_mark_node;\n       return build (COMPOUND_EXPR, lhstype,\n@@ -6560,7 +6561,26 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   /* Record the contents of OUTPUTS before it is modified.  */\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    o[i] = TREE_VALUE (tail);\n+    {\n+      tree output = TREE_VALUE (tail);\n+\n+      /* We can remove conversions that just change the type, not the mode.  */\n+      STRIP_NOPS (output);\n+      o[i] = output;\n+\n+      /* Allow conversions as LHS here.  build_modify_expr as called below\n+\t will do the right thing with them.  */\n+      while (TREE_CODE (output) == NOP_EXPR\n+\t     || TREE_CODE (output) == CONVERT_EXPR\n+\t     || TREE_CODE (output) == FLOAT_EXPR\n+\t     || TREE_CODE (output) == FIX_TRUNC_EXPR\n+\t     || TREE_CODE (output) == FIX_FLOOR_EXPR\n+\t     || TREE_CODE (output) == FIX_ROUND_EXPR\n+\t     || TREE_CODE (output) == FIX_CEIL_EXPR)\n+\toutput = TREE_OPERAND (output, 1);\n+\n+      lvalue_or_else (o[i], \"invalid lvalue in asm statement\");\n+    }\n \n   /* Perform default conversions on array and function inputs.  */\n   /* Don't do this for other types--"}, {"sha": "c322f6017daa75919e5cd517c5eb9b4f70ef9d68", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Save and restore call-clobbered registers which are live across a call.\n-   Copyright (C) 1989, 1992, 94-95, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92, 94, 95, 97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "bc1e2a7b89525c8f8039994091fb24111acb6d1e", "filename": "gcc/calls.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2433,8 +2433,9 @@ expand_call (exp, target, ignore)\n \t  preserve_temp_slots (target);\n \t}\n \n-      emit_group_store (target, valreg, bytes,\n-\t\t\tTYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n+      if (! rtx_equal_p (target, valreg))\n+        emit_group_store (target, valreg, bytes,\n+\t\t\t  TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n     }\n   else if (target && GET_MODE (target) == TYPE_MODE (TREE_TYPE (exp))\n \t   && GET_MODE (target) == GET_MODE (valreg))\n@@ -2901,9 +2902,13 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n \t      rtx stack_area\n-\t\t= gen_rtx_MEM (save_mode,\n-\t\t\t       memory_address (save_mode,\n-\t\t\t\t\t       plus_constant (argblock, argvec[argnum].offset.constant)));\n+\t\t= gen_rtx_MEM\n+\t\t  (save_mode,\n+\t\t   memory_address\n+\t\t   (save_mode,\n+\t\t    plus_constant (argblock,\n+\t\t\t\t   argvec[argnum].offset.constant)));\n+\n \t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n \t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n@@ -3024,8 +3029,10 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n \trtx stack_area\n \t  = gen_rtx_MEM (save_mode,\n-\t\t\t memory_address (save_mode,\n-\t\t\t\t\t plus_constant (argblock, argvec[count].offset.constant)));\n+\t\t\t memory_address\n+\t\t\t (save_mode,\n+\t\t\t  plus_constant (argblock,\n+\t\t\t\t\t argvec[count].offset.constant)));\n \n \temit_move_insn (stack_area, argvec[count].save_area);\n       }\n@@ -3464,11 +3471,14 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n \t      rtx stack_area\n-\t\t= gen_rtx_MEM (save_mode,\n-\t\t\t       memory_address (save_mode,\n-\t\t\t\t\t       plus_constant (argblock,\n-\t\t\t\t\t\t\t      argvec[argnum].offset.constant)));\n+\t\t= gen_rtx_MEM\n+\t\t  (save_mode,\n+\t\t   memory_address\n+\t\t   (save_mode,\n+\t\t    plus_constant (argblock,\n+\t\t\t\t   argvec[argnum].offset.constant)));\n \t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n+\n \t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n #endif\n@@ -3613,8 +3623,10 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n \trtx stack_area\n \t  = gen_rtx_MEM (save_mode,\n-\t\t     memory_address (save_mode, plus_constant (argblock,\n-\t\t\t\t     argvec[count].offset.constant)));\n+\t\t\t memory_address\n+\t\t\t (save_mode,\n+\t\t\t  plus_constant (argblock,\n+\t\t\t\t\t argvec[count].offset.constant)));\n \n \temit_move_insn (stack_area, argvec[count].save_area);\n       }\n@@ -3840,8 +3852,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \n   if (arg->value == arg->stack)\n     {\n-      /* If the value is already in the stack slot, we are done moving\n-\t data.  */\n+      /* If the value is already in the stack slot, we are done.  */\n       if (current_function_check_memory_usage && GET_CODE (arg->stack) == MEM)\n \t{\n \t  emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,"}, {"sha": "23a5077d628e4724b9377d40e0d871d14522aa02", "filename": "gcc/cccp.c", "status": "modified", "additions": 292, "deletions": 213, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -72,11 +72,13 @@ typedef unsigned char U_CHAR;\n #define fopen(fname,mode)\tVMS_fopen (fname,mode)\n #define freopen(fname,mode,ofile) VMS_freopen (fname,mode,ofile)\n #define fstat(fd,stbuf)\t\tVMS_fstat (fd,stbuf)\n+#define fwrite(ptr,size,nitems,stream) VMS_fwrite (ptr,size,nitems,stream)\n static int VMS_fstat (), VMS_stat ();\n static int VMS_open ();\n static FILE *VMS_fopen ();\n static FILE *VMS_freopen ();\n-static int hack_vms_include_specification ();\n+static size_t VMS_fwrite ();\n+static void hack_vms_include_specification ();\n #define INO_T_EQ(a, b) (!bcmp((char *) &(a), (char *) &(b), sizeof (a)))\n #define INO_T_HASH(a) 0\n #define INCLUDE_LEN_FUDGE 12\t/* leave room for VMS syntax conversion */\n@@ -243,6 +245,10 @@ static int warn_trigraphs;\n \n static int warn_undef;\n \n+/* Nonzero means warn if we find white space where it doesn't belong.  */\n+\n+static int warn_white_space;\n+\n /* Nonzero means warn if #import is used.  */\n \n static int warn_import = 1;\n@@ -783,7 +789,6 @@ static int do_sccs DO_PROTO;\n #endif\n static int do_unassert DO_PROTO;\n static int do_undef DO_PROTO;\n-static int do_warning DO_PROTO;\n static int do_xifdef DO_PROTO;\n \n /* Here is the actual list of #-directives, most-often-used first.  */\n@@ -802,7 +807,7 @@ static struct directive directive_table[] = {\n   {  6, do_include, \"import\", T_IMPORT},\n   {  5, do_undef, \"undef\", T_UNDEF},\n   {  5, do_error, \"error\", T_ERROR},\n-  {  7, do_warning, \"warning\", T_WARNING},\n+  {  7, do_error, \"warning\", T_WARNING},\n #ifdef SCCS_DIRECTIVE\n   {  4, do_sccs, \"sccs\", T_SCCS},\n #endif\n@@ -874,7 +879,6 @@ static int ignore_srcdir;\n \f\n static int safe_read PROTO((int, char *, int));\n static void safe_write PROTO((int, char *, int));\n-static void eprint_string PROTO((const char *, size_t));\n \n int main PROTO((int, char **));\n \n@@ -883,6 +887,7 @@ static void path_include PROTO((char *));\n static U_CHAR *index0 PROTO((U_CHAR *, int, size_t));\n \n static void trigraph_pcp PROTO((FILE_BUF *));\n+static void check_white_space PROTO((FILE_BUF *));\n \n static void newline_fix PROTO((U_CHAR *));\n static void name_newline_fix PROTO((U_CHAR *));\n@@ -962,7 +967,7 @@ static U_CHAR *macarg1 PROTO((U_CHAR *, U_CHAR *, struct hashnode *, int *, int\n \n static int discard_comments PROTO((U_CHAR *, int, int));\n \n-static int change_newlines PROTO((U_CHAR *, int));\n+static void change_newlines PROTO((struct argdata *));\n \n static void notice PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n static void vnotice PROTO((const char *, va_list));\n@@ -1088,33 +1093,6 @@ safe_write (desc, ptr, len)\n   }\n }\n \n-/* Print a string to stderr, with extra handling in case it contains\n-   embedded NUL characters.  Any present are written as is.\n-\n-   Using fwrite for this purpose produces undesireable results on VMS\n-   when stderr happens to be a record oriented file, such as a batch log\n-   file, rather than a stream oriented one.  */\n-\n-static void\n-eprint_string (string, length)\n-     const char *string;\n-     size_t length;\n-{\n-  size_t segment_length;\n-\n-  do {\n-    fprintf(stderr, \"%s\", string);\n-    length -= (segment_length = strlen(string));\n-    if (length > 0)\n-      {\n-\tfputc('\\0', stderr);\n-\tlength -= 1;\n-\t/* Advance past the portion which has already been printed.  */\n-\tstring += segment_length + 1;\n-      }\n-  } while (length > 0);\n-}\n-\n \f\n static void\n print_help ()\n@@ -1320,20 +1298,20 @@ main (argc, argv)\n \n       case 'i':\n \tif (!strcmp (argv[i], \"-include\")) {\n-\t  int temp = i;\n-\n \t  if (i + 1 == argc)\n \t    fatal (\"Filename missing after `-include' option\");\n-\t  else\n-\t    simplify_filename (pend_includes[temp] = argv[++i]);\n+\t  else {\n+\t    simplify_filename (pend_includes[i] = argv[i]);\n+\t    i++;\n+\t  }\n \t}\n \tif (!strcmp (argv[i], \"-imacros\")) {\n-\t  int temp = i;\n-\n \t  if (i + 1 == argc)\n \t    fatal (\"Filename missing after `-imacros' option\");\n-\t  else\n-\t    simplify_filename (pend_files[temp] = argv[++i]);\n+\t  else {\n+\t    simplify_filename (pend_files[i] = argv[i]);\n+\t    i++;\n+\t  }\n \t}\n \tif (!strcmp (argv[i], \"-iprefix\")) {\n \t  if (i + 1 == argc)\n@@ -1511,6 +1489,10 @@ main (argc, argv)\n \t  warn_stringify = 1;\n \telse if (!strcmp (argv[i], \"-Wno-traditional\"))\n \t  warn_stringify = 0;\n+\telse if (!strcmp (argv[i], \"-Wwhite-space\"))\n+\t  warn_white_space = 1;\n+\telse if (!strcmp (argv[i], \"-Wno-white-space\"))\n+\t  warn_white_space = 0;\n \telse if (!strcmp (argv[i], \"-Wundef\"))\n \t  warn_undef = 1;\n \telse if (!strcmp (argv[i], \"-Wno-undef\"))\n@@ -1527,6 +1509,7 @@ main (argc, argv)\n \t  {\n \t    warn_trigraphs = 1;\n \t    warn_comments = 1;\n+\t    warn_white_space = 1;\n \t  }\n \tbreak;\n \n@@ -1691,15 +1674,15 @@ main (argc, argv)\n       case 'I':\t\t\t/* Add directory to path for includes.  */\n \t{\n \t  struct file_name_list *dirtmp;\n+\t  char *dir = argv[i][2] ? argv[i] + 2 : argv[++i];\n \n-\t  if (! ignore_srcdir && !strcmp (argv[i] + 2, \"-\")) {\n+\t  if (! ignore_srcdir && !strcmp (dir, \"-\")) {\n \t    ignore_srcdir = 1;\n \t    /* Don't use any preceding -I directories for #include <...>.  */\n \t    first_bracket_include = 0;\n \t  }\n \t  else {\n-\t    dirtmp = new_include_prefix (last_include, NULL_PTR, \"\",\n-\t\t\t\t\t argv[i][2] ? argv[i] + 2 : argv[++i]);\n+\t    dirtmp = new_include_prefix (last_include, NULL_PTR, \"\", dir);\n \t    append_include_chain (dirtmp, dirtmp);\n \t  }\n \t}\n@@ -1958,17 +1941,14 @@ main (argc, argv)\n     else\n       print_deps = 1;\n \n-    s = spec;\n     /* Find the space before the DEPS_TARGET, if there is one.  */\n-    /* This should use index.  (mrs) */\n-    while (*s != 0 && *s != ' ') s++;\n-    if (*s != 0) {\n+    s = index (spec, ' ');\n+    if (s) {\n       deps_target = s + 1;\n       output_file = xmalloc (s - spec + 1);\n       bcopy (spec, output_file, s - spec);\n       output_file[s - spec] = 0;\n-    }\n-    else {\n+    } else {\n       deps_target = 0;\n       output_file = spec;\n     }\n@@ -2029,8 +2009,9 @@ main (argc, argv)\n       strcpy (q, OBJECT_SUFFIX);\n \n       deps_output (p, ':');\n-      deps_output (in_fname, ' ');\n     }\n+\n+    deps_output (in_fname, ' ');\n   }\n \n   /* Scan the -imacros files before the main input.\n@@ -2118,6 +2099,9 @@ main (argc, argv)\n   if (!no_trigraphs)\n     trigraph_pcp (fp);\n \n+  if (warn_white_space)\n+    check_white_space (fp);\n+\n   /* Now that we know the input file is valid, open the output.  */\n \n   if (!out_fname || !strcmp (out_fname, \"\"))\n@@ -2328,13 +2312,43 @@ trigraph_pcp (buf)\n     warning_with_line (0, \"%lu trigraph(s) encountered\",\n \t\t       (unsigned long) (fptr - bptr) / 2);\n }\n+\n+/* Warn about white space between backslash and end of line.  */\n+\n+static void\n+check_white_space (buf)\n+     FILE_BUF *buf;\n+{\n+  register U_CHAR *sptr = buf->buf;\n+  register U_CHAR *lptr = sptr + buf->length;\n+  register U_CHAR *nptr;\n+  int line = 0;\n+\n+  nptr = sptr = buf->buf;\n+  lptr = sptr + buf->length;\n+  for (nptr = sptr;\n+       (nptr = index0 (nptr, '\\n', (size_t) (lptr - nptr))) != NULL;\n+       nptr ++) {\n+    register U_CHAR *p = nptr;\n+    line++;\n+    for (p = nptr; sptr < p; p--) {\n+      if (! is_hor_space[p[-1]]) {\n+\tif (p[-1] == '\\\\' && p != nptr)\n+\t  warning_with_line (line, \n+\t\t\t     \"`\\\\' followed by white space at end of line\");\n+\tbreak;\n+      }\n+    }\n+  }\n+}\n \f\n /* Move all backslash-newline pairs out of embarrassing places.\n    Exchange all such pairs following BP\n    with any potentially-embarrassing characters that follow them.\n    Potentially-embarrassing characters are / and *\n    (because a backslash-newline inside a comment delimiter\n-   would cause it not to be recognized).  */\n+   would cause it not to be recognized).\n+   We assume that *BP == '\\\\'.  */\n \n static void\n newline_fix (bp)\n@@ -2343,21 +2357,24 @@ newline_fix (bp)\n   register U_CHAR *p = bp;\n \n   /* First count the backslash-newline pairs here.  */\n-\n-  while (p[0] == '\\\\' && p[1] == '\\n')\n+  do {\n+    if (p[1] != '\\n')\n+      break;\n     p += 2;\n+  } while (*p == '\\\\');\n \n   /* What follows the backslash-newlines is not embarrassing.  */\n \n   if (*p != '/' && *p != '*')\n+    /* What follows the backslash-newlines is not embarrassing.  */\n     return;\n \n   /* Copy all potentially embarrassing characters\n      that follow the backslash-newline pairs\n      down to where the pairs originally started.  */\n-\n-  while (*p == '*' || *p == '/')\n+  do\n     *bp++ = *p++;\n+  while (*p == '*' || *p == '/');\n \n   /* Now write the same number of pairs after the embarrassing chars.  */\n   while (bp < p) {\n@@ -2376,20 +2393,24 @@ name_newline_fix (bp)\n   register U_CHAR *p = bp;\n \n   /* First count the backslash-newline pairs here.  */\n-  while (p[0] == '\\\\' && p[1] == '\\n')\n+  do {\n+    if (p[1] != '\\n')\n+      break;\n     p += 2;\n+  } while (*p == '\\\\');\n \n   /* What follows the backslash-newlines is not embarrassing.  */\n \n   if (!is_idchar[*p])\n+    /* What follows the backslash-newlines is not embarrassing.  */\n     return;\n \n   /* Copy all potentially embarrassing characters\n      that follow the backslash-newline pairs\n      down to where the pairs originally started.  */\n-\n-  while (is_idchar[*p])\n+  do\n     *bp++ = *p++;\n+  while (is_idchar[*p]);\n \n   /* Now write the same number of pairs after the embarrassing chars.  */\n   while (bp < p) {\n@@ -2467,7 +2488,7 @@ get_lintcmd (ibp, limit, argstart, arglen, cmdlen)\n  * If OUTPUT_MARKS is nonzero, keep Newline markers found in the input\n  * and insert them when appropriate.  This is set while scanning macro\n  * arguments before substitution.  It is zero when scanning for final output.\n- *   There are three types of Newline markers:\n+ *   There are two types of Newline markers:\n  *   * Newline -  follows a macro name that was not expanded\n  *     because it appeared inside an expansion of the same macro.\n  *     This marker prevents future expansion of that identifier.\n@@ -2791,6 +2812,8 @@ do { ip = &instack[indepth];\t\t\\\n \t*obp++ = *ibp;\n \tswitch (*ibp++) {\n \tcase '\\n':\n+\t  if (warn_white_space && ip->fname && is_hor_space[ibp[-2]])\n+\t    warning (\"white space at end of line in string\");\n \t  ++ip->lineno;\n \t  ++op->lineno;\n \t  /* Traditionally, end of line ends a string constant with no error.\n@@ -2818,9 +2841,10 @@ do { ip = &instack[indepth];\t\t\\\n \t       keep the line counts correct.  But if we are reading\n \t       from a macro, keep the backslash newline, since backslash\n \t       newlines have already been processed.  */\n-\t    if (ip->macro)\n+\t    if (ip->macro) {\n \t      *obp++ = '\\n';\n-\t    else\n+\t      ++op->lineno;\n+\t    } else\n \t      --obp;\n \t    ++ibp;\n \t    ++ip->lineno;\n@@ -2829,8 +2853,10 @@ do { ip = &instack[indepth];\t\t\\\n \t       is *not* prevented from combining with a newline.  */\n \t    if (!ip->macro) {\n \t      while (*ibp == '\\\\' && ibp[1] == '\\n') {\n-\t\tibp += 2;\n+\t\t*obp++ = *ibp++;\n+\t\t*obp++ = *ibp++;\n \t\t++ip->lineno;\n+\t\t++op->lineno;\n \t      }\n \t    }\n \t    *obp++ = *ibp++;\n@@ -2868,7 +2894,7 @@ do { ip = &instack[indepth];\t\t\\\n     case '/':\n       if (ip->macro != 0)\n \tgoto randomchar;\n-      if (*ibp == '\\\\' && ibp[1] == '\\n')\n+      if (*ibp == '\\\\')\n \tnewline_fix (ibp);\n       if (*ibp != '*'\n \t  && !(cplusplus_comments && *ibp == '/'))\n@@ -2986,7 +3012,7 @@ do { ip = &instack[indepth];\t\t\\\n \t  case '*':\n \t    if (ibp[-2] == '/' && warn_comments)\n \t      warning (\"`/*' within comment\");\n-\t    if (*ibp == '\\\\' && ibp[1] == '\\n')\n+\t    if (*ibp == '\\\\')\n \t      newline_fix (ibp);\n \t    if (*ibp == '/')\n \t      goto comment_end;\n@@ -3357,7 +3383,7 @@ do { ip = &instack[indepth];\t\t\\\n \t\t      break;\n \t\t    else if (*ibp == '/') {\n \t\t      /* If a comment, copy it unchanged or discard it.  */\n-\t\t      if (ibp[1] == '\\\\' && ibp[2] == '\\n')\n+\t\t      if (ibp[1] == '\\\\')\n \t\t\tnewline_fix (ibp + 1);\n \t\t      if (ibp[1] == '*') {\n \t\t\tif (put_out_comments) {\n@@ -3370,7 +3396,7 @@ do { ip = &instack[indepth];\t\t\\\n \t\t\t  /* We need not worry about newline-marks,\n \t\t\t     since they are never found in comments.  */\n \t\t\t  if (ibp[0] == '*') {\n-\t\t\t    if (ibp[1] == '\\\\' && ibp[2] == '\\n')\n+\t\t\t    if (ibp[1] == '\\\\')\n \t\t\t      newline_fix (ibp + 1);\n \t\t\t    if (ibp[1] == '/') {\n \t\t\t      ibp += 2;\n@@ -3627,9 +3653,6 @@ expand_to_temp_buffer (buf, limit, output_marks, assertions)\n   if (indepth != odepth)\n     abort ();\n \n-  /* Record the output.  */\n-  obuf.length = obuf.bufp - obuf.buf;\n-\n   assertions_flag = save_assertions_flag;\n   return obuf;\n }\n@@ -3677,7 +3700,7 @@ handle_directive (ip, op)\n \tpedwarn_strange_white_space (*bp);\n       bp++;\n     } else if (*bp == '/') {\n-      if (bp[1] == '\\\\' && bp[2] == '\\n')\n+      if (bp[1] == '\\\\')\n \tnewline_fix (bp + 1);\n       if (! (bp[1] == '*' || (cplusplus_comments && bp[1] == '/')))\n \tbreak;\n@@ -3698,7 +3721,7 @@ handle_directive (ip, op)\n     if (is_idchar[*cp])\n       cp++;\n     else {\n-      if (*cp == '\\\\' && cp[1] == '\\n')\n+      if (*cp == '\\\\')\n \tname_newline_fix (cp);\n       if (is_idchar[*cp])\n \tcp++;\n@@ -3789,14 +3812,12 @@ handle_directive (ip, op)\n \tregister U_CHAR c = *bp++;\n \tswitch (c) {\n \tcase '\\\\':\n-\t  if (bp < limit) {\n-\t    if (*bp == '\\n') {\n-\t      ip->lineno++;\n-\t      copy_directive = 1;\n-\t      bp++;\n-\t    } else if (traditional)\n-\t      bp++;\n-\t  }\n+\t  if (*bp == '\\n') {\n+\t    ip->lineno++;\n+\t    copy_directive = 1;\n+\t    bp++;\n+\t  } else if (traditional && bp < limit)\n+\t    bp++;\n \t  break;\n \n \tcase '\"':\n@@ -3848,7 +3869,7 @@ handle_directive (ip, op)\n \t  break;\n \n \tcase '/':\n-\t  if (*bp == '\\\\' && bp[1] == '\\n')\n+\t  if (*bp == '\\\\')\n \t    newline_fix (bp);\n \t  if (*bp == '*'\n \t      || (cplusplus_comments && *bp == '/')) {\n@@ -3931,12 +3952,13 @@ handle_directive (ip, op)\n \tregister U_CHAR *xp = buf;\n \t/* Need to copy entire directive into temp buffer before dispatching */\n \n-\tcp = (U_CHAR *) alloca (bp - buf + 5); /* room for directive plus\n-\t\t\t\t\t\t  some slop */\n+\t/* room for directive plus some slop */\n+\tcp = (U_CHAR *) alloca (2 * (bp - buf) + 5);\n \tbuf = cp;\n \n \t/* Copy to the new buffer, deleting comments\n-\t   and backslash-newlines (and whitespace surrounding the latter).  */\n+\t   and backslash-newlines (and whitespace surrounding the latter\n+\t   if outside of char and string constants).  */\n \n \twhile (xp < bp) {\n \t  register U_CHAR c = *xp++;\n@@ -4043,7 +4065,8 @@ handle_directive (ip, op)\n \t directives through.  */\n \n       if (!no_output && already_output == 0\n-\t  && (kt->type == T_DEFINE ? (int) dump_names <= (int) dump_macros\n+\t  && ((kt->type == T_DEFINE || kt->type == T_UNDEF)\n+\t      ? (int) dump_names <= (int) dump_macros\n \t      : IS_INCLUDE_DIRECTIVE_TYPE (kt->type) ? dump_includes\n \t      : kt->type == T_PRAGMA)) {\n         int len;\n@@ -4072,7 +4095,7 @@ handle_directive (ip, op)\n \t  bcopy (buf, (char *) op->bufp, len);\n \t}\n \top->bufp += len;\n-      }\t\t\t\t/* Don't we need a newline or #line? */\n+      }\n \n       /* Call the appropriate directive handler.  buf now points to\n \t either the appropriate place in the input buffer, or to\n@@ -4094,12 +4117,19 @@ handle_directive (ip, op)\n static struct tm *\n timestamp ()\n {\n-  static struct tm *timebuf;\n-  if (!timebuf) {\n+  static struct tm tmbuf;\n+  if (! tmbuf.tm_mday) {\n     time_t t = time ((time_t *) 0);\n-    timebuf = localtime (&t);\n+    struct tm *tm = localtime (&t);\n+    if (tm)\n+      tmbuf = *tm;\n+    else {\n+      /* Use 0000-01-01 00:00:00 if local time is not available.  */\n+      tmbuf.tm_year = -1900;\n+      tmbuf.tm_mday = 1;\n+    }\n   }\n-  return timebuf;\n+  return &tmbuf;\n }\n \n static char *monthnames[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n@@ -5284,6 +5314,9 @@ finclude (f, inc, op, system_header_p, dirptr)\n   if (!no_trigraphs)\n     trigraph_pcp (fp);\n \n+  if (warn_white_space)\n+    check_white_space (fp);\n+\n   output_line_directive (fp, op, 0, enter_file);\n   rescan (op, 0);\n \n@@ -5497,7 +5530,7 @@ pcfinclude (buf, name, op)\n     tmpbuf = expand_to_temp_buffer (string_start, cp++, 0, 0);\n     /* Lineno is already set in the precompiled file */\n     str->contents = tmpbuf.buf;\n-    str->len = tmpbuf.length;\n+    str->len = tmpbuf.bufp - tmpbuf.buf;\n     str->writeflag = 0;\n     str->filename = name;\n     str->output_mark = outbuf.bufp - outbuf.buf;\n@@ -5521,6 +5554,7 @@ pcfinclude (buf, name, op)\n       for (; nkeys--; free (tmpbuf.buf), cp = endofthiskey + 1) {\n \tKEYDEF *kp = (KEYDEF *) (GENERIC_PTR) cp;\n \tHASHNODE *hp;\n+\tU_CHAR *bp;\n \t\n \t/* It starts with a KEYDEF structure */\n \tcp += sizeof (KEYDEF);\n@@ -5532,20 +5566,19 @@ pcfinclude (buf, name, op)\n \t\n \t/* Expand the key, and enter it into the hash table.  */\n \ttmpbuf = expand_to_temp_buffer (cp, endofthiskey, 0, 0);\n-\ttmpbuf.bufp = tmpbuf.buf;\n+\tbp = tmpbuf.buf;\n \t\n-\twhile (is_hor_space[*tmpbuf.bufp])\n-\t  tmpbuf.bufp++;\n-\tif (!is_idstart[*tmpbuf.bufp]\n-\t    || tmpbuf.bufp == tmpbuf.buf + tmpbuf.length) {\n+\twhile (is_hor_space[*bp])\n+\t  bp++;\n+\tif (!is_idstart[*bp] || bp == tmpbuf.bufp) {\n \t  str->writeflag = 1;\n \t  continue;\n \t}\n \t    \n-\thp = lookup (tmpbuf.bufp, -1, -1);\n+\thp = lookup (bp, -1, -1);\n \tif (hp == NULL) {\n \t  kp->chain = 0;\n-\t  install (tmpbuf.bufp, -1, T_PCSTRING, (char *) kp, -1);\n+\t  install (bp, -1, T_PCSTRING, (char *) kp, -1);\n \t}\n \telse if (hp->type == T_PCSTRING) {\n \t  kp->chain = hp->value.keydef;\n@@ -6136,7 +6169,7 @@ collect_expansion (buf, end, nargs, arglist)\n \tbreak;\n \n       case '\\\\':\n-\tif (p < limit && expected_delimiter) {\n+\tif (expected_delimiter) {\n \t  /* In a string, backslash goes through\n \t     and makes next char ordinary.  */\n \t  *exp_p++ = *p++;\n@@ -6804,6 +6837,7 @@ do_line (buf, limit, op, keyword)\n \n   /* Point to macroexpanded line, which is null-terminated now.  */\n   bp = tem.buf;\n+  limit = tem.bufp;\n   SKIP_WHITE_SPACE (bp);\n \n   if (!ISDIGIT (*bp)) {\n@@ -6846,10 +6880,6 @@ do_line (buf, limit, op, keyword)\n     p = bp;\n     for (;;)\n       switch ((*p++ = *bp++)) {\n-      case '\\0':\n-\terror (\"invalid format `#line' directive\");\n-\treturn 0;\n-\n       case '\\\\':\n \tif (! ignore_escape_flag)\n \t  {\n@@ -6974,50 +7004,39 @@ do_undef (buf, limit, op, keyword)\n   return 0;\n }\n \f\n+\n /* Report an error detected by the program we are processing.\n-   Use the text of the line in the error message.\n-   (We use error because it prints the filename & line#.)  */\n+   Use the text of the line in the error message.  */\n \n static int\n do_error (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n+     struct directive *keyword;\n {\n   int length = limit - buf;\n   U_CHAR *copy = (U_CHAR *) alloca (length + 1);\n   bcopy ((char *) buf, (char *) copy, length);\n   copy[length] = 0;\n   SKIP_WHITE_SPACE (copy);\n-  error (\"#error %s\", copy);\n-  return 0;\n-}\n \n-/* Report a warning detected by the program we are processing.\n-   Use the text of the line in the warning message, then continue.\n-   (We use error because it prints the filename & line#.)  */\n+  switch (keyword->type) {\n+  case T_ERROR:\n+    error (\"#error %s\", copy);\n+    break;\n \n-static int\n-do_warning (buf, limit, op, keyword)\n-     U_CHAR *buf, *limit;\n-     FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n-{\n-  int length = limit - buf;\n-  U_CHAR *copy = (U_CHAR *) alloca (length + 1);\n-  bcopy ((char *) buf, (char *) copy, length);\n-  copy[length] = 0;\n-  SKIP_WHITE_SPACE (copy);\n+  case T_WARNING:\n+    if (pedantic && !instack[indepth].system_header_p)\n+      pedwarn (\"ANSI C does not allow `#warning'\");\n+    warning (\"#warning %s\", copy);\n+    break;\n \n-  if (pedantic && !instack[indepth].system_header_p)\n-    pedwarn (\"ANSI C does not allow `#warning'\");\n+  default:\n+    abort ();\n+  }\n \n-  /* Use `pedwarn' not `warning', because #warning isn't in the C Standard;\n-     if -pedantic-errors is given, #warning should cause an error.  */\n-  pedwarn (\"#warning %s\", copy);\n   return 0;\n }\n-\n /* Remember the name of the current file being read from so that we can\n    avoid ever including it again.  */\n \n@@ -7092,8 +7111,9 @@ do_pragma (buf, limit, op, keyword)\n       return 0;\n \n     fname = p + 1;\n-    if ((p = (U_CHAR *) index ((char *) fname, '\\\"')))\n-      *p = '\\0';\n+    p = skip_quoted_string (p, limit, 0, NULL_PTR, NULL_PTR, NULL_PTR);\n+    if (p[-1] == '\"')\n+      *--p = '\\0';\n     \n     for (h = 0; h < INCLUDE_HASHSIZE; h++) {\n       struct include_file *inc;\n@@ -7198,7 +7218,8 @@ do_elif (buf, limit, op, keyword)\n \t     && !bcmp (if_stack->fname, ip->nominal_fname,\n \t\t       if_stack->fname_len))) {\n \tfprintf (stderr, \", file \");\n-\teprint_string (if_stack->fname, if_stack->fname_len);\n+\tfwrite (if_stack->fname, sizeof if_stack->fname[0],\n+\t\tif_stack->fname_len, stderr);\n       }\n       fprintf (stderr, \")\\n\");\n     }\n@@ -7238,7 +7259,7 @@ eval_if_expression (buf, length)\n   pcp_inside_if = 0;\n   delete_macro (save_defined);\t/* clean up special symbol */\n \n-  temp_obuf.buf[temp_obuf.length] = '\\n';\n+  *temp_obuf.bufp = '\\n';\n   value = parse_c_expression ((char *) temp_obuf.buf,\n \t\t\t      warn_undef && !instack[indepth].system_header_p);\n \n@@ -7417,7 +7438,7 @@ skip_if_group (ip, any, op)\n   while (bp < endb) {\n     switch (*bp++) {\n     case '/':\t\t\t/* possible comment */\n-      if (*bp == '\\\\' && bp[1] == '\\n')\n+      if (*bp == '\\\\')\n \tnewline_fix (bp);\n       if (*bp == '*'\n \t  || (cplusplus_comments && *bp == '/')) {\n@@ -7547,7 +7568,7 @@ skip_if_group (ip, any, op)\n \telse if (*bp == '\\\\' && bp[1] == '\\n')\n \t  bp += 2;\n \telse if (*bp == '/') {\n-\t  if (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t  if (bp[1] == '\\\\')\n \t    newline_fix (bp + 1);\n \t  if (bp[1] == '*') {\n \t    for (bp += 2; ; bp++) {\n@@ -7556,7 +7577,7 @@ skip_if_group (ip, any, op)\n \t      else if (*bp == '*') {\n \t\tif (bp[-1] == '/' && warn_comments)\n \t\t  warning (\"`/*' within comment\");\n-\t\tif (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t\tif (bp[1] == '\\\\')\n \t\t  newline_fix (bp + 1);\n \t\tif (bp[1] == '/')\n \t\t  break;\n@@ -7609,7 +7630,7 @@ skip_if_group (ip, any, op)\n \tif (is_idchar[*bp])\n \t  bp++;\n \telse {\n-\t  if (*bp == '\\\\' && bp[1] == '\\n')\n+\t  if (*bp == '\\\\')\n \t    name_newline_fix (bp);\n \t  if (is_idchar[*bp])\n \t    bp++;\n@@ -7778,7 +7799,8 @@ do_else (buf, limit, op, keyword)\n \t     && !bcmp (if_stack->fname, ip->nominal_fname,\n \t\t       if_stack->fname_len))) {\n \tfprintf (stderr, \", file \");\n-\teprint_string (if_stack->fname, if_stack->fname_len);\n+\tfwrite (if_stack->fname, sizeof if_stack->fname[0],\n+\t\tif_stack->fname_len, stderr);\n       }\n       fprintf (stderr, \")\\n\");\n     }\n@@ -7998,7 +8020,7 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n     case '*':\n       if (bp[-2] == '/' && !nowarn && warn_comments)\n \twarning (\"`/*' within comment\");\n-      if (*bp == '\\\\' && bp[1] == '\\n')\n+      if (*bp == '\\\\')\n \tnewline_fix (bp);\n       if (*bp == '/') {\n         if (op)\n@@ -8041,7 +8063,8 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n    The input stack state is not changed.\n \n    If COUNT_NEWLINES is nonzero, it points to an int to increment\n-   for each newline passed.\n+   for each newline passed; also, warn about any white space\n+   just before line end.\n \n    If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it\n    if we pass a backslash-newline.\n@@ -8097,15 +8120,18 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n       }\n       if (match == '\\'') {\n \terror_with_line (line_for_error (start_line),\n-\t\t\t \"unterminated string or character constant\");\n+\t\t\t \"unterminated character constant\");\n \tbp--;\n \tif (eofp)\n \t  *eofp = 1;\n \tbreak;\n       }\n       /* If not traditional, then allow newlines inside strings.  */\n-      if (count_newlines)\n+      if (count_newlines) {\n+\tif (warn_white_space && is_hor_space[bp[-2]])\n+\t  warning (\"white space at end of line in string\");\n \t++*count_newlines;\n+      }\n       if (multiline_string_line == 0) {\n \tif (pedantic)\n \t  pedwarn_with_line (line_for_error (start_line),\n@@ -8295,9 +8321,9 @@ output_line_directive (ip, op, conditional, file_change)\n /* This structure represents one parsed argument in a macro call.\n    `raw' points to the argument text as written (`raw_length' is its length).\n    `expanded' points to the argument's macro-expansion\n-   (its length is `expand_length').\n-   `stringified_length' is the length the argument would have\n-   if stringified.\n+   (its length is `expand_length', and its allocated size is `expand_size').\n+   `stringified_length_bound' is an upper bound on the length\n+   the argument would have if stringified.\n    `use_count' is the number of times this macro arg is substituted\n    into the macro.  If the actual use count exceeds 10, \n    the value stored is 10.\n@@ -8306,8 +8332,8 @@ output_line_directive (ip, op, conditional, file_change)\n \n struct argdata {\n   U_CHAR *raw, *expanded;\n-  int raw_length, expand_length;\n-  int stringified_length;\n+  int raw_length, expand_length, expand_size;\n+  int stringified_length_bound;\n   U_CHAR *free1, *free2;\n   char newlines;\n   char use_count;\n@@ -8358,8 +8384,8 @@ macroexpand (hp, op)\n     for (i = 0; i < nargs; i++) {\n       args[i].raw = (U_CHAR *) \"\";\n       args[i].expanded = 0;\n-      args[i].raw_length = args[i].expand_length\n-\t= args[i].stringified_length = 0;\n+      args[i].raw_length = args[i].expand_length = args[i].expand_size\n+\t= args[i].stringified_length_bound = 0;\n       args[i].free1 = args[i].free2 = 0;\n       args[i].use_count = 0;\n     }\n@@ -8453,7 +8479,7 @@ macroexpand (hp, op)\n       xbuf_len = defn->length;\n       for (ap = defn->pattern; ap != NULL; ap = ap->next) {\n \tif (ap->stringify)\n-\t  xbuf_len += args[ap->argno].stringified_length;\n+\t  xbuf_len += args[ap->argno].stringified_length_bound;\n \telse if (ap->raw_before != 0 || ap->raw_after != 0 || traditional)\n \t  /* Add 4 for two newline-space markers to prevent\n \t     token concatenation.  */\n@@ -8468,13 +8494,20 @@ macroexpand (hp, op)\n \t\t\t\t\t  1, 0);\n \n \t    args[ap->argno].expanded = obuf.buf;\n-\t    args[ap->argno].expand_length = obuf.length;\n+\t    args[ap->argno].expand_length = obuf.bufp - obuf.buf;\n+\t    args[ap->argno].expand_size = obuf.length;\n \t    args[ap->argno].free2 = obuf.buf;\n-\t  }\n \n+\t    xbuf_len += args[ap->argno].expand_length;\n+\t  } else {\n+\t    /* If the arg appears more than once, its later occurrences\n+\t       may have newline turned into backslash-'n', which is a\n+\t       factor of 2 expansion.  */\n+\t    xbuf_len += 2 * args[ap->argno].expand_length;\n+\t  }\n \t  /* Add 4 for two newline-space markers to prevent\n \t     token concatenation.  */\n-\t  xbuf_len += args[ap->argno].expand_length + 4;\n+\t  xbuf_len += 4;\n \t}\n \tif (args[ap->argno].use_count < 10)\n \t  args[ap->argno].use_count++;\n@@ -8531,27 +8564,28 @@ macroexpand (hp, op)\n \t  for (; i < arglen; i++) {\n \t    c = arg->raw[i];\n \n-\t    if (! in_string) {\n-\t      /* Special markers Newline Space\n+\t    if (in_string) {\n+\t      /* Generate nothing for backslash-newline in a string.  */\n+\t      if (c == '\\\\' && arg->raw[i + 1] == '\\n') {\n+\t\ti++;\n+\t\tcontinue;\n+\t      }\n+\t    } else {\n+\t      /* Special markers\n \t\t generate nothing for a stringified argument.  */\n-\t      if (c == '\\n' && arg->raw[i+1] != '\\n') {\n+\t      if (c == '\\n') {\n \t\ti++;\n \t\tcontinue;\n \t      }\n \n \t      /* Internal sequences of whitespace are replaced by one space\n-\t\t except within an string or char token.  */\n-\t      if (c == '\\n' ? arg->raw[i+1] == '\\n' : is_space[c]) {\n-\t\twhile (1) {\n-\t\t  /* Note that Newline Space does occur within whitespace\n-\t\t     sequences; consider it part of the sequence.  */\n-\t\t  if (c == '\\n' && is_space[arg->raw[i+1]])\n-\t\t    i += 2;\n-\t\t  else if (c != '\\n' && is_space[c])\n-\t\t    i++;\n-\t\t  else break;\n-\t\t  c = arg->raw[i];\n-\t\t}\n+\t\t except within a string or char token.  */\n+\t      if (is_space[c]) {\n+\t\ti++;\n+\t\twhile (is_space[(c = arg->raw[i])])\n+\t\t  /* Newline markers can occur within a whitespace sequence;\n+\t\t     consider them part of the sequence.  */\n+\t\t  i += (c == '\\n') + 1;\n \t\ti--;\n \t\tc = ' ';\n \t      }\n@@ -8583,8 +8617,15 @@ macroexpand (hp, op)\n \t\tin_string = c;\n \t    }\n \n-\t    /* Escape these chars */\n-\t    if (c == '\\\"' || (in_string && c == '\\\\'))\n+\t    /* Escape double-quote, and backslashes in strings.\n+\t       Newlines in strings are best escaped as \\n, since\n+\t       otherwise backslash-backslash-newline-newline is\n+\t       mishandled.  The C Standard doesn't allow newlines in\n+\t       strings, so we can escape newlines as we please.  */\n+\t    if (c == '\\\"'\n+\t\t|| (in_string\n+\t\t    && (c == '\\\\'\n+\t\t\t|| (c == '\\n' ? (c = 'n', 1) : 0))))\n \t      xbuf[totlen++] = '\\\\';\n \t    /* We used to output e.g. \\008 for control characters here,\n \t       but this doesn't conform to the C Standard.\n@@ -8660,8 +8701,7 @@ macroexpand (hp, op)\n \t    /* Don't bother doing change_newlines for subsequent\n \t       uses of arg.  */\n \t    arg->use_count = 1;\n-\t    arg->expand_length\n-\t      = change_newlines (arg->expanded, arg->expand_length);\n+\t    change_newlines (arg);\n \t  }\n \t}\n \n@@ -8738,23 +8778,23 @@ macarg (argptr, rest_args)\n {\n   FILE_BUF *ip = &instack[indepth];\n   int paren = 0;\n-  int newlines = 0;\n+  int lineno0 = ip->lineno;\n   int comments = 0;\n   int result = 0;\n \n   /* Try to parse as much of the argument as exists at this\n      input stack level.  */\n   U_CHAR *bp = macarg1 (ip->bufp, ip->buf + ip->length, ip->macro,\n-\t\t\t&paren, &newlines, &comments, rest_args);\n+\t\t\t&paren, &ip->lineno, &comments, rest_args);\n \n   /* If we find the end of the argument at this level,\n      set up *ARGPTR to point at it in the input stack.  */\n-  if (!(ip->fname != 0 && (newlines != 0 || comments != 0))\n+  if (!(ip->fname != 0 && (ip->lineno != lineno0 || comments != 0))\n       && bp != ip->buf + ip->length) {\n     if (argptr != 0) {\n       argptr->raw = ip->bufp;\n       argptr->raw_length = bp - ip->bufp;\n-      argptr->newlines = newlines;\n+      argptr->newlines = ip->lineno - lineno0;\n     }\n     ip->bufp = bp;\n   } else {\n@@ -8763,13 +8803,12 @@ macarg (argptr, rest_args)\n        Therefore, we must allocate a temporary buffer and copy\n        the macro argument into it.  */\n     int bufsize = bp - ip->bufp;\n-    int extra = newlines;\n+    int extra = ip->lineno - lineno0;\n     U_CHAR *buffer = (U_CHAR *) xmalloc (bufsize + extra + 1);\n     int final_start = 0;\n \n     bcopy ((char *) ip->bufp, (char *) buffer, bufsize);\n     ip->bufp = bp;\n-    ip->lineno += newlines;\n \n     while (bp == ip->buf + ip->length) {\n       if (instack[indepth].macro == 0) {\n@@ -8780,18 +8819,17 @@ macarg (argptr, rest_args)\n       if (ip->free_ptr)\n \tfree (ip->free_ptr);\n       ip = &instack[--indepth];\n-      newlines = 0;\n+      lineno0 = ip->lineno;\n       comments = 0;\n       bp = macarg1 (ip->bufp, ip->buf + ip->length, ip->macro, &paren,\n-\t\t    &newlines, &comments, rest_args);\n+\t\t    &ip->lineno, &comments, rest_args);\n       final_start = bufsize;\n       bufsize += bp - ip->bufp;\n-      extra += newlines;\n+      extra += ip->lineno - lineno0;\n       buffer = (U_CHAR *) xrealloc (buffer, bufsize + extra + 1);\n       bcopy ((char *) ip->bufp, (char *) (buffer + bufsize - (bp - ip->bufp)),\n \t     bp - ip->bufp);\n       ip->bufp = bp;\n-      ip->lineno += newlines;\n     }\n \n     /* Now, if arg is actually wanted, record its raw form,\n@@ -8803,13 +8841,13 @@ macarg (argptr, rest_args)\n       argptr->raw = buffer;\n       argptr->raw_length = bufsize;\n       argptr->free1 = buffer;\n-      argptr->newlines = newlines;\n-      if ((newlines || comments) && ip->fname != 0)\n+      argptr->newlines = ip->lineno - lineno0;\n+      if ((argptr->newlines || comments) && ip->fname != 0)\n \targptr->raw_length\n \t  = final_start +\n \t    discard_comments (argptr->raw + final_start,\n \t\t\t      argptr->raw_length - final_start,\n-\t\t\t      newlines);\n+\t\t\t      argptr->newlines);\n       argptr->raw[argptr->raw_length] = 0;\n       if (argptr->raw_length > bufsize + extra)\n \tabort ();\n@@ -8843,10 +8881,10 @@ macarg (argptr, rest_args)\n \tSKIP_ALL_WHITE_SPACE (buf);\n       else\n #endif\n-      if (c == '\\\"' || c == '\\\\') /* escape these chars */\n+      if (c == '\\\"' || c == '\\\\' || c == '\\n') /* escape these chars */\n \ttotlen++;\n     }\n-    argptr->stringified_length = totlen;\n+    argptr->stringified_length_bound = totlen;\n   }\n   return result;\n }\n@@ -8895,7 +8933,7 @@ macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n     case '/':\n       if (macro)\n \tbreak;\n-      if (bp[1] == '\\\\' && bp[2] == '\\n')\n+      if (bp[1] == '\\\\')\n \tnewline_fix (bp + 1);\n       if (bp[1] == '*') {\n \t*comments = 1;\n@@ -8905,7 +8943,7 @@ macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n \t  else if (*bp == '*') {\n \t    if (bp[-1] == '/' && warn_comments)\n \t      warning (\"`/*' within comment\");\n-\t    if (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t    if (bp[1] == '\\\\')\n \t      newline_fix (bp + 1);\n \t    if (bp[1] == '/') {\n \t      bp++;\n@@ -8952,18 +8990,18 @@ macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n     case '\\\"':\n       {\n \tint quotec;\n-\tfor (quotec = *bp++; bp + 1 < limit && *bp != quotec; bp++) {\n+\tfor (quotec = *bp++; bp < limit && *bp != quotec; bp++) {\n \t  if (*bp == '\\\\') {\n \t    bp++;\n \t    if (*bp == '\\n')\n \t      ++*newlines;\n-\t    if (!macro) {\n-\t      while (*bp == '\\\\' && bp[1] == '\\n') {\n-\t\tbp += 2;\n-\t\t++*newlines;\n-\t      }\n+\t    while (*bp == '\\\\' && bp[1] == '\\n') {\n+\t      bp += 2;\n+\t      ++*newlines;\n \t    }\n \t  } else if (*bp == '\\n') {\n+\t    if (warn_white_space && is_hor_space[bp[-1]] && ! macro)\n+\t      warning (\"white space at end of line in string\");\n \t    ++*newlines;\n \t    if (quotec == '\\'')\n \t      break;\n@@ -9047,7 +9085,7 @@ discard_comments (start, length, newlines)\n       break;\n \n     case '/':\n-      if (*ibp == '\\\\' && ibp[1] == '\\n')\n+      if (*ibp == '\\\\')\n \tnewline_fix (ibp);\n       /* Delete any comment.  */\n       if (cplusplus_comments && ibp[0] == '/') {\n@@ -9082,7 +9120,7 @@ discard_comments (start, length, newlines)\n \tobp[-1] = ' ';\n       while (++ibp < limit) {\n \tif (ibp[0] == '*') {\n-\t  if (ibp[1] == '\\\\' && ibp[2] == '\\n')\n+\t  if (ibp[1] == '\\\\')\n \t    newline_fix (ibp + 1);\n \t  if (ibp[1] == '/') {\n \t    ibp += 2;\n@@ -9153,15 +9191,16 @@ discard_comments (start, length, newlines)\n   return obp - start;\n }\n \f\n-/* Turn newlines to spaces in the string of length LENGTH at START,\n-   except inside of string constants.\n-   The string is copied into itself with its beginning staying fixed.  */\n+/* Turn newlines to spaces in the macro argument ARG.\n+   Remove backslash-newline from string constants,\n+   and turn other newlines in string constants to backslash-'n'.  */\n \n-static int\n-change_newlines (start, length)\n-     U_CHAR *start;\n-     int length;\n+static void\n+change_newlines (arg)\n+     struct argdata *arg;\n {\n+  U_CHAR *start = arg->expanded;\n+  int length = arg->expand_length;\n   register U_CHAR *ibp;\n   register U_CHAR *obp;\n   register U_CHAR *limit;\n@@ -9225,7 +9264,10 @@ change_newlines (start, length)\n     }\n   }\n \n-  return obp - start;\n+  arg->expand_length = obp - arg->expanded;\n+\n+  if (start != arg->expanded)\n+    free (start);\n }\n \f\n /* notice - output message to stderr */\n@@ -9293,7 +9335,8 @@ verror (msgid, args)\n     }\n \n   if (ip != NULL) {\n-    eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n     fprintf (stderr, \":%d: \", ip->lineno);\n   }\n   vnotice (msgid, args);\n@@ -9320,7 +9363,8 @@ error_from_errno (name)\n     }\n \n   if (ip != NULL) {\n-    eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n     fprintf (stderr, \":%d: \", ip->lineno);\n   }\n \n@@ -9372,7 +9416,8 @@ vwarning (msgid, args)\n     }\n \n   if (ip != NULL) {\n-    eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n     fprintf (stderr, \":%d: \", ip->lineno);\n   }\n   notice (\"warning: \");\n@@ -9419,7 +9464,8 @@ verror_with_line (line, msgid, args)\n     }\n \n   if (ip != NULL) {\n-    eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n     fprintf (stderr, \":%d: \", line);\n   }\n   vnotice (msgid, args);\n@@ -9471,7 +9517,8 @@ vwarning_with_line (line, msgid, args)\n     }\n \n   if (ip != NULL) {\n-    eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n+    fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t    ip->nominal_fname_len, stderr);\n     fprintf (stderr, line ? \":%d: \" : \": \", line);\n   }\n   notice (\"warning: \");\n@@ -9553,7 +9600,7 @@ pedwarn_with_file_and_line VPROTO ((const char *file, size_t file_len, int line,\n #endif\n  \n   if (file) {\n-    eprint_string (file, file_len);\n+    fwrite (file, sizeof file[0], file_len, stderr);\n     fprintf (stderr, \":%d: \", line);\n   }\n   if (pedantic_errors)\n@@ -9614,7 +9661,8 @@ print_containing_files ()\n \tnotice (\",\\n                 from \");\n       }\n \n-      eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n+      fwrite (ip->nominal_fname, sizeof ip->nominal_fname[0],\n+\t      ip->nominal_fname_len, stderr);\n       fprintf (stderr, \":%d\", ip->lineno);\n     }\n   if (! first)\n@@ -10207,8 +10255,18 @@ make_definition (str)\n \t\t\t\t\t NULL_PTR, NULL_PTR, &unterminated);\n \tif (unterminated)\n \t  return;\n-\twhile (p != p1)\n-\t  *q++ = *p++;\n+\twhile (p != p1) {\n+\t  if (*p == '\\\\' && p[1] == '\\n')\n+\t    p += 2;\n+\t  else if (*p == '\\n')\n+\t    {\n+\t      *q++ = '\\\\';\n+\t      *q++ = 'n';\n+\t      p++;\n+\t    }\n+\t  else\n+\t    *q++ = *p++;\n+\t}\n       } else if (*p == '\\\\' && p[1] == '\\n')\n \tp += 2;\n       /* Change newline chars into newline-markers.  */\n@@ -11048,4 +11106,25 @@ VMS_stat (name, statbuf)\n \n   return result;\n }\n+\n+static size_t\n+VMS_fwrite (ptr, size, nitems, stream)\n+     void const *ptr;\n+     size_t size;\n+     size_t nitems;\n+     FILE *stream;\n+{\n+  /* VMS fwrite has undesirable results\n+     if STREAM happens to be a record oriented file.\n+     Work around this problem by writing each character individually.  */\n+  char const *p = ptr;\n+  size_t bytes = size * nitems;\n+  char *lim = p + bytes;\n+\n+  while (p < lim)\n+    if (putc (*p++, stream) == EOF)\n+      return 0;\n+\n+  return bytes;\n+}\n #endif /* VMS */"}, {"sha": "9379a3dac1a329856dc6cc68b42fdf18aea9f121", "filename": "gcc/cexp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -336,7 +336,7 @@ static const short yycheck[] = {     4,\n     26,    27,    23,    24,    25,    26,    27,     0,     9\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/tmp/sky/share/bison.simple\"\n+#line 3 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -529,7 +529,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/tmp/sky/share/bison.simple\"\n+#line 196 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -1110,7 +1110,7 @@ case 40:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/tmp/sky/share/bison.simple\"\n+#line 498 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "97e1375ebb35e2df243994489239689d2d4d66bf", "filename": "gcc/combine.c", "status": "modified", "additions": 127, "deletions": 54, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -76,7 +76,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"rtl.h\" /* stdio.h must precede rtl.h for FFS.  */\n+#include \"rtl.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -1812,17 +1812,17 @@ try_combine (i3, i2, i1)\n \t    ? gen_rtx_SET (VOIDmode, i1dest, i1src) : PATTERN (i1));\n \n      if (added_sets_2)\n-\t{\n-\t  /* If there is no I1, use I2's body as is.  We used to also not do\n-\t     the subst call below if I2 was substituted into I3,\n-\t     but that could lose a simplification.  */\n-\t  if (i1 == 0)\n-\t    XVECEXP (newpat, 0, --total_sets) = i2pat;\n-\t  else\n-\t    /* See comment where i2pat is assigned.  */\n-\t    XVECEXP (newpat, 0, --total_sets)\n-\t      = subst (i2pat, i1dest, i1src, 0, 0);\n-\t}\n+       {\n+\t /* If there is no I1, use I2's body as is.  We used to also not do\n+\t    the subst call below if I2 was substituted into I3,\n+\t    but that could lose a simplification.  */\n+\t if (i1 == 0)\n+\t   XVECEXP (newpat, 0, --total_sets) = i2pat;\n+\t else\n+\t   /* See comment where i2pat is assigned.  */\n+\t   XVECEXP (newpat, 0, --total_sets)\n+\t     = subst (i2pat, i1dest, i1src, 0, 0);\n+       }\n     }\n \n   /* We come here when we are replacing a destination in I2 with the\n@@ -1906,14 +1906,14 @@ try_combine (i3, i2, i1)\n \t\t  || (REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n \t\t      && ! REG_USERVAR_P (i2dest))))\n \t    ni2dest = gen_rtx_REG (GET_MODE (SET_DEST (newpat)),\n-\t\t\t       REGNO (i2dest));\n-\n-\t  m_split = split_insns\n-\t    (gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t       gen_rtvec (2, newpat,\n-\t\t\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t\t   ni2dest))),\n-\t     i3);\n+\t\t\t\t   REGNO (i2dest));\n+\n+\t  m_split = split_insns (gen_rtx_PARALLEL\n+\t\t\t\t (VOIDmode,\n+\t\t\t\t  gen_rtvec (2, newpat,\n+\t\t\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t\t      ni2dest))),\n+\t\t\t\t i3);\n \t}\n \n       if (m_split && GET_CODE (m_split) == SEQUENCE\n@@ -4604,7 +4604,10 @@ simplify_set (x)\n      low-order bits.  */\n \n   if (GET_MODE_CLASS (mode) == MODE_INT)\n-    src = force_to_mode (src, mode, GET_MODE_MASK (mode), NULL_RTX, 0);\n+    {\n+      src = force_to_mode (src, mode, GET_MODE_MASK (mode), NULL_RTX, 0);\n+      SUBST (SET_SRC (x), src);\n+    }\n \n   /* If we are setting CC0 or if the source is a COMPARE, look for the use of\n      the comparison result and try to simplify it unless we already have used\n@@ -4852,6 +4855,68 @@ simplify_set (x)\n       src = SET_SRC (x);\n     }\n \n+#ifdef HAVE_conditional_arithmetic\n+  /* If we have conditional arithmetic and the operand of a SET is\n+     a conditional expression, replace this with an IF_THEN_ELSE.\n+     We can either have a conditional expression or a MULT of that expression\n+     with a constant.  */\n+  if ((GET_RTX_CLASS (GET_CODE (src)) == '1'\n+       || GET_RTX_CLASS (GET_CODE (src)) == '2'\n+       || GET_RTX_CLASS (GET_CODE (src)) == 'c')\n+      && (GET_RTX_CLASS (GET_CODE (XEXP (src, 0))) == '<'\n+\t  || (GET_CODE (XEXP (src, 0)) == MULT\n+\t      && GET_RTX_CLASS (GET_CODE (XEXP (XEXP (src, 0), 0))) == '<'\n+\t      && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT)))\n+    {\n+      rtx cond = XEXP (src, 0);\n+      rtx true_val = const1_rtx;\n+      rtx false_arm, true_arm;\n+\n+      if (GET_CODE (cond) == MULT)\n+\t{\n+\t  true_val = XEXP (cond, 1);\n+\t  cond = XEXP (cond, 0);\n+\t}\n+\n+      if (GET_RTX_CLASS (GET_CODE (src)) == '1')\n+\t{\n+\t  true_arm = gen_unary (GET_CODE (src), GET_MODE (src),\n+\t\t\t\tGET_MODE (XEXP (src, 0)), true_val);\n+\t  false_arm = gen_unary (GET_CODE (src), GET_MODE (src),\n+\t\t\t\t GET_MODE (XEXP (src, 0)), const0_rtx);\n+\t}\n+      else\n+\t{\n+\t  true_arm = gen_binary (GET_CODE (src), GET_MODE (src),\n+\t\t\t\t true_val, XEXP (src, 1));\n+\t  false_arm = gen_binary (GET_CODE (src), GET_MODE (src),\n+\t\t\t\t  const0_rtx, XEXP (src, 1));\n+\t}\n+\n+      /* Canonicalize if true_arm is the simpler one.  */\n+      if (GET_RTX_CLASS (GET_CODE (true_arm)) == 'o'\n+\t  && GET_RTX_CLASS (GET_CODE (false_arm)) != 'o'\n+\t  && reversible_comparison_p (cond))\n+\t{\n+\t  rtx temp = true_arm;\n+\n+\t  true_arm = false_arm;\n+\t  false_arm = temp;\n+\n+\t  cond = gen_rtx_combine (reverse_condition (GET_CODE (cond)),\n+\t\t\t\t  GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t\t  XEXP (cond, 1));\n+\t}\n+\n+      src = gen_rtx_combine (IF_THEN_ELSE, GET_MODE (src),\n+\t\t\t     gen_rtx_combine (GET_CODE (cond), VOIDmode,\n+\t\t\t\t\t      XEXP (cond, 0),\n+\t\t\t\t\t      XEXP (cond, 1)),\n+\t\t\t     true_arm, false_arm);\n+      SUBST (SET_SRC (x), src);\n+    }\n+#endif\n+\n   /* If either SRC or DEST is a CLOBBER of (const_int 0), make this\n      whole thing fail.  */\n   if (GET_CODE (src) == CLOBBER && XEXP (src, 0) == const0_rtx)\n@@ -5419,8 +5484,9 @@ expand_field_assignment (x)\n \t\t\t+ (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n \t{\n \t  x = gen_rtx_SET (VOIDmode, SUBREG_REG (SET_DEST (x)),\n-\t\t\t   gen_lowpart_for_combine (GET_MODE (SUBREG_REG (SET_DEST (x))),\n-\t\t\t\t\t\t    SET_SRC (x)));\n+\t\t\t   gen_lowpart_for_combine\n+\t\t\t   (GET_MODE (SUBREG_REG (SET_DEST (x))),\n+\t\t\t    SET_SRC (x)));\n \t  continue;\n \t}\n       else\n@@ -5458,22 +5524,22 @@ expand_field_assignment (x)\n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      x = gen_rtx_SET (VOIDmode, copy_rtx (inner),\n-\t\t       gen_binary (IOR, compute_mode,\n-\t\t\t\t   gen_binary (AND, compute_mode,\n-\t\t\t\t\t       gen_unary (NOT, compute_mode,\n-\t\t\t\t\t\t\t  compute_mode,\n-\t\t\t\t\t\t\t  gen_binary (ASHIFT,\n-\t\t\t\t\t\t\t\t      compute_mode,\n-\t\t\t\t\t\t\t\t      mask, pos)),\n-\t\t\t\t\t       inner),\n-\t\t\t\t   gen_binary (ASHIFT, compute_mode,\n-\t\t\t\t\t       gen_binary (AND, compute_mode,\n-\t\t\t\t\t\t\t   gen_lowpart_for_combine\n-\t\t\t\t\t\t\t   (compute_mode,\n-\t\t\t\t\t\t\t    SET_SRC (x)),\n-\t\t\t\t\t\t\t   mask),\n-\t\t\t\t\t       pos)));\n+      x = gen_rtx_SET\n+\t(VOIDmode, copy_rtx (inner),\n+\t gen_binary (IOR, compute_mode,\n+\t\t     gen_binary (AND, compute_mode,\n+\t\t\t\t gen_unary (NOT, compute_mode,\n+\t\t\t\t\t    compute_mode,\n+\t\t\t\t\t    gen_binary (ASHIFT,\n+\t\t\t\t\t\t\tcompute_mode,\n+\t\t\t\t\t\t\tmask, pos)),\n+\t\t\t\t inner),\n+\t\t     gen_binary (ASHIFT, compute_mode,\n+\t\t\t\t gen_binary (AND, compute_mode,\n+\t\t\t\t\t     gen_lowpart_for_combine\n+\t\t\t\t\t     (compute_mode, SET_SRC (x)),\n+\t\t\t\t\t     mask),\n+\t\t\t\t pos)));\n     }\n \n   return x;\n@@ -5614,7 +5680,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  if (tmode != inner_mode)\n \t    new = gen_rtx_SUBREG (tmode, inner,\n \t\t\t\t  (WORDS_BIG_ENDIAN\n-\t\t\t\t   && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD\n+\t\t\t\t   && (GET_MODE_SIZE (inner_mode)\n+\t\t\t\t       > UNITS_PER_WORD)\n \t\t\t\t   ? (((GET_MODE_SIZE (inner_mode)\n \t\t\t\t\t- GET_MODE_SIZE (tmode))\n \t\t\t\t       / UNITS_PER_WORD)\n@@ -5654,12 +5721,12 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       && ! in_compare && ! spans_byte && unsignedp)\n     return 0;\n \n-  /* Unless we are allowed to span bytes, reject this if we would be\n-     spanning bytes or if the position is not a constant and the length\n-     is not 1.  In all other cases, we would only be going outside\n-     out object in cases when an original shift would have been\n+  /* Unless we are allowed to span bytes or INNER is not MEM, reject this if\n+     we would be spanning bytes or if the position is not a constant and the\n+     length is not 1.  In all other cases, we would only be going outside\n+     our object in cases when an original shift would have been\n      undefined.  */\n-  if (! spans_byte\n+  if (! spans_byte && GET_CODE (inner) == MEM\n       && ((pos_rtx == 0 && pos + len > GET_MODE_BITSIZE (is_mode))\n \t  || (pos_rtx != 0 && len != 1)))\n     return 0;\n@@ -9129,7 +9196,8 @@ recog_for_combine (pnewpat, insn, pnotes)\n     {\n       rtx newpat = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t     gen_rtvec (GET_CODE (pat) == PARALLEL\n-\t\t\t\t\t\t? XVECLEN (pat, 0) + num_clobbers_to_add\n+\t\t\t\t\t\t? (XVECLEN (pat, 0)\n+\t\t\t\t\t\t   + num_clobbers_to_add)\n \t\t\t\t\t\t: num_clobbers_to_add + 1));\n \n       if (GET_CODE (pat) == PARALLEL)\n@@ -9230,6 +9298,7 @@ gen_lowpart_for_combine (mode, x)\n       if (WORDS_BIG_ENDIAN)\n \toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n \t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+\n       if (BYTES_BIG_ENDIAN)\n \t{\n \t  /* Adjust the address so that the address-after-the-data is\n@@ -10208,12 +10277,17 @@ simplify_comparison (code, pop0, pop1)\n \t     represents the low part, permute the SUBREG and the AND and\n \t     try again.  */\n \t  if (GET_CODE (XEXP (op0, 0)) == SUBREG\n-\t      && ((mode_width\n-\t\t   >= GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0)))))\n+\t      && (0\n #ifdef WORD_REGISTER_OPERATIONS\n-\t\t  || subreg_lowpart_p (XEXP (op0, 0))\n+\t\t  || ((mode_width\n+\t\t       > (GET_MODE_BITSIZE\n+\t\t\t   (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n+\t\t      && mode_width <= BITS_PER_WORD)\n #endif\n-\t\t  )\n+\t\t  || ((mode_width\n+\t\t       <= (GET_MODE_BITSIZE\n+\t\t\t   (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n+\t\t      && subreg_lowpart_p (XEXP (op0, 0))))\n #ifndef WORD_REGISTER_OPERATIONS\n \t      /* It is unsafe to commute the AND into the SUBREG if the SUBREG\n \t\t is paradoxical and WORD_REGISTER_OPERATIONS is not defined.\n@@ -11700,8 +11774,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t  if (! find_regno_note (tem, REG_UNUSED,\n \t\t\t\t\t\t REGNO (XEXP (note, 0))))\n \t\t\t    REG_NOTES (tem)\n-\t\t\t      = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t\t\t\t   XEXP (note, 0),\n+\t\t\t      = gen_rtx_EXPR_LIST (REG_UNUSED, XEXP (note, 0),\n \t\t\t\t\t\t   REG_NOTES (tem));\n \t\t\t}\n \t\t      else\n@@ -11863,8 +11936,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t      && ! reg_bitfield_target_p (piece,\n \t\t\t\t\t\t\t  PATTERN (place)))\n \t\t\t    REG_NOTES (place)\n-\t\t\t      = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t   piece, REG_NOTES (place));\n+\t\t\t      = gen_rtx_EXPR_LIST (REG_DEAD, piece,\n+\t\t\t\t\t\t   REG_NOTES (place));\n \t\t\t}\n \n \t\t      place = 0;"}, {"sha": "631d8df8e1da98c47812257bdca1b55bec582620", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -21,8 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define __datalbl\n #include \"config.h\"\n-#include <stdio.h>\n-#include <string.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"function.h\"\n@@ -118,7 +117,7 @@ function_arg (cum, mode, type, named)\n   else\n     size = GET_MODE_SIZE (mode);\n   if (cum + size < 12)\n-    return gen_rtx (REG, mode, cum);\n+    return gen_rtx_REG (mode, cum);\n   else\n     return (rtx) 0;\n }"}, {"sha": "1c61ab5d69db50117d669a5795e8d00547f7077a", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -474,14 +474,14 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    otherwise, FUNC is 0. */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx(REG,TYPE_MODE(VALTYPE),0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE. */\n /* 1750 note: no libcalls yet */\n \n #define LIBCALL_VALUE(MODE)  printf(\"LIBCALL_VALUE called!\\n\"), \\\n-  gen_rtx(REG,MODE,0)\n+  gen_rtx_REG (MODE, 0)\n \n /* 1 if N is a possible register number for a function value. */\n \n@@ -696,8 +696,8 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  printf(\"INITIALIZE_TRAMPO called\\n\")\n /* {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, QImode, plus_constant (TRAMP, 1)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, QImode, plus_constant (TRAMP, 6)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (QImode, plus_constant (TRAMP, 1)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (QImode, plus_constant (TRAMP, 6)), FNADDR); \\\n } */\n \n "}, {"sha": "3bea692edbd6e9d6760e0c3bf5e8e63b43017cd8", "filename": "gcc/config/1750a/1750a.md", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for GNU compiler\n ;;- MIL-STD-1750A version.\n-;; Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n ;; Contributed by O.M.Kellogg, DASA (oliver.kellogg@space.otn.dasa.de).\n \n ;; This file is part of GNU CC.\n@@ -767,9 +767,9 @@\n         (neg:TQF (match_operand:TQF 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"\n-   emit_insn(gen_rtx(SET,VOIDmode,operands[0],CONST0_RTX(TQFmode)));\n-   emit_insn(gen_rtx(SET,VOIDmode,operands[0],\n-             gen_rtx(MINUS,TQFmode,operands[0],operands[1])));\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[0], CONST0_RTX (TQFmode)));\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t   gen_rtx_MINUS (TQFmode, operands[0], operands[1])));\n    DONE;\n   \")\n \n@@ -954,7 +954,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -981,7 +981,7 @@\n   \"\n   {\n     if (GET_CODE (operands[2]) != CONST_INT)\n-      operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n   }\")\n \n (define_insn \"\"\n@@ -1012,7 +1012,7 @@\n   \"\n   {\n     if (GET_CODE (operands[2]) != CONST_INT)\n-      operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n   }\")\n \n (define_insn \"\"\n@@ -1038,7 +1038,7 @@\n   \"\n   {\n     if (GET_CODE (operands[2]) != CONST_INT)\n-      operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n   }\")\n \n (define_insn \"\"\n@@ -1375,17 +1375,6 @@\n   \"\"\n   \"ANYCALL %0\")\n \n-\n-; (define_insn \"return\"\n-;   [(return)]\n-;   \"\"\n-;   \"*\n-;    { \n-;         rtx oprnd = GEN_INT (get_frame_size());\n-;         output_asm_insn(\\\"ret.m  %0\\\",&oprnd);\n-;         return \\\"\\;\\\";\n-;    } \")\n-\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:QI 0 \"address_operand\" \"p\"))]\n   \"\""}, {"sha": "d930363f12db60376447e97dd4e659ee7b3f47bb", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on AMD Am29000.\n-   Copyright (C) 1987, 88, 90-94, 1995, 1997, 1999 Free Software\n+   Copyright (C) 1987, 88, 90-95, 1997, 1998, 1999 Free Software\n    Foundation, Inc. \n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n@@ -21,7 +21,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -854,9 +854,10 @@ a29k_clobbers_to (insn, op)\n \n   for (i = R_LR (2); i < high_regno; i++)\n     CALL_INSN_FUNCTION_USAGE (insn)\n-      = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, i)),\n-\t\t CALL_INSN_FUNCTION_USAGE (insn));\n+      = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t    gen_rtx (REG, SImode, i)),\n+\t\t\t   CALL_INSN_FUNCTION_USAGE (insn));\n }\n \f\n /* These routines are used in finding insns to fill delay slots in the"}, {"sha": "4ea977c5fbe069b5ebd37ba0a85b620098bfad51", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -746,12 +746,12 @@ extern struct rtx_def *a29k_get_reloaded_address ();\n    On 29k the value is found in gr96.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), R_GR (96))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), R_GR (96))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, R_GR (96))\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, R_GR (96))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.\n@@ -846,7 +846,7 @@ extern struct rtx_def *a29k_get_reloaded_address ();\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n ((CUM) < 16 && (NAMED) && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n- ? gen_rtx(REG, (MODE), R_LR (2) + (CUM)) : 0)\n+ ? gen_rtx_REG ((MODE), R_LR (2) + (CUM)) : 0)\n \n /* Define where a function finds its arguments.\n    This is different from FUNCTION_ARG because of register windows.\n@@ -856,8 +856,8 @@ extern struct rtx_def *a29k_get_reloaded_address ();\n \n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n ((CUM) < 16 && (NAMED) && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\t\\\n- ? gen_rtx (REG, MODE,\t\t\t\t\t\t\t\\\n-\t    incoming_reg (CUM, A29K_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n+ ? gen_rtx_REG (MODE,\t\t\t\t\t\t\t\\\n+\t\tincoming_reg (CUM, A29K_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n  : 0)\n \n /* This indicates that an argument is to be passed with an invisible reference\n@@ -911,7 +911,7 @@ extern struct rtx_def *a29k_get_reloaded_address ();\n       if (! (NO_RTL) && first_reg_offset != 16)\t\t\t\t\\\n \tmove_block_from_reg\t\t\t\t\t\t\\\n \t  (R_AR (0) + first_reg_offset,\t\t\t\t\t\\\n-\t   gen_rtx (MEM, BLKmode, virtual_incoming_args_rtx),\t\t\\\n+\t   gen_rtx_MEM (BLKmode, virtual_incoming_args_rtx),\t\t\\\n \t   16 - first_reg_offset, (16 - first_reg_offset) * UNITS_PER_WORD); \\\n       PRETEND_SIZE = (16 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -1043,25 +1043,25 @@ extern char *a29k_function_name;\n   rtx _val = force_reg (SImode, VALUE);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   _addr = memory_address (QImode, plus_constant (TRAMP, (CONST) + 3));\t\\\n-  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n \t\t  gen_lowpart (QImode, _val));\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\t\\\n \t\t       build_int_2 (8, 0), 0, 1);\t\t\t\\\n   _addr = memory_address (QImode, plus_constant (TRAMP, (CONST) + 1));\t\\\n-  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n \t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   _temp = expand_shift (RSHIFT_EXPR, SImode, _temp,\t\t\t\\\n \t\t       build_int_2 (8, 0), _temp, 1);\t\t\t\\\n   _addr = memory_address (QImode, plus_constant (TRAMP, (CONSTH) + 3));\t\\\n-  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n \t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   _temp = expand_shift (RSHIFT_EXPR, SImode, _temp,\t\t\t\\\n \t\t       build_int_2 (8, 0), _temp, 1);\t\t\t\\\n   _addr = memory_address (QImode, plus_constant (TRAMP, (CONSTH) + 1));\t\\\n-  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (QImode, _addr),\t\t\t\t\\\n \t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n }\n \f"}, {"sha": "aa82c6c5ca79856477c2b38b4460f240560aaa13", "filename": "gcc/config/a29k/a29k.md", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for AMD Am29000 for GNU C compiler\n-;;   Copyright (C) 1991, 1992, 1994 Free Software Foundation, Inc.\n+;;   Copyright (C) 1991, 1992, 1994, 1998, 1999 Free Software Foundation, Inc.\n ;;   Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -145,8 +145,8 @@\n      later be inlined into another function.  */\n   if (! TARGET_SMALL_MEMORY\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n-    operands[0] = gen_rtx (MEM, SImode,\n-\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+    operands[0] = gen_rtx_MEM (SImode,\n+\t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n }\")\n  \n (define_expand \"call_value\"\n@@ -178,9 +178,8 @@\n      later be inlined into another function.  */\n   if (! TARGET_SMALL_MEMORY\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-    operands[1] = gen_rtx (MEM, SImode,\n-\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n-\n+    operands[1] = gen_rtx_MEM (SImode,\n+\t\t\t       force_reg (Pmode, XEXP (operands[1], 0)));\n }\")\n  \n (define_insn \"\"\n@@ -644,9 +643,9 @@\n   if (size != 8 || (pos != 8 && pos != 16))\n     FAIL;\n \n-  operands[3] = gen_rtx (ASHIFT, PSImode,\n-\t\t\t force_reg (PSImode, GEN_INT (pos / 8)),\n-\t\t\t GEN_INT (3));\n+  operands[3] = gen_rtx_ASHIFT (PSImode,\n+\t\t\t\tforce_reg (PSImode, GEN_INT (pos / 8)),\n+\t\t\t\tGEN_INT (3));\n \n }\")\n \n@@ -967,9 +966,9 @@\n   if ((size != 8 && size != 16) || pos % size != 0)\n     FAIL;\n \n-  operands[2] = gen_rtx (ASHIFT, PSImode,\n-\t\t\t force_reg (PSImode, GEN_INT (pos / 8)),\n-\t\t\t GEN_INT (3));\n+  operands[2] = gen_rtx_ASHIFT (PSImode,\n+\t\t\t\tforce_reg (PSImode, GEN_INT (pos / 8)),\n+\t\t\t\tGEN_INT (3));\n }\")\n \f\n ;; LOAD (also used by move insn).\n@@ -1056,20 +1055,20 @@\n   /* CR gets set to the number of registers minus one.  */\n   operands[2] = GEN_INT(count - 1);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 2));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 2));\n   from = memory_address (SImode, XEXP (operands[1], 0));\n-  XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t gen_rtx (REG, SImode, regno),\n-\t\t\t\t\t gen_rtx (MEM, SImode, from));\n+  XVECEXP (operands[3], 0, 0) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t     gen_rtx_REG (SImode, regno),\n+\t\t\t\t\t     gen_rtx_MEM (SImode, from));\n   operands[4] = gen_reg_rtx (PSImode);\n \n-  XVECEXP (operands[3], 0, 1) = gen_rtx (USE, VOIDmode, operands[4]);\n-  XVECEXP (operands[3], 0, 2) = gen_rtx (CLOBBER, VOIDmode, operands[4]);\n+  XVECEXP (operands[3], 0, 1) = gen_rtx_USE (VOIDmode, operands[4]);\n+  XVECEXP (operands[3], 0, 2) = gen_rtx_CLOBBER (VOIDmode, operands[4]);\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 2)\n-      = gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, regno + i),\n-\t\t gen_rtx (MEM, SImode, plus_constant (from, i * 4)));\n+      = gen_rtx_SET (VOIDmode, gen_rtx (REG, SImode, regno + i),\n+\t\t gen_rtx_MEM (SImode, plus_constant (from, i * 4)));\n }\")\n \n ;; Indicate that CR is used and is then clobbered.\n@@ -1378,20 +1377,20 @@\n   /* CR gets set to the number of registers minus one.  */\n   operands[2] = GEN_INT(count - 1);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 2));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 2));\n   from = memory_address (SImode, XEXP (operands[0], 0));\n-  XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t gen_rtx (MEM, SImode, from),\n-\t\t\t\t\t gen_rtx (REG, SImode, regno));\n+  XVECEXP (operands[3], 0, 0) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t     gen_rtx_MEM (SImode, from),\n+\t\t\t\t\t     gen_rtx_REG (SImode, regno));\n   operands[4] = gen_reg_rtx (PSImode);\n-  XVECEXP (operands[3], 0, 1) = gen_rtx (USE, VOIDmode, operands[4]);\n-  XVECEXP (operands[3], 0, 2) = gen_rtx (CLOBBER, VOIDmode, operands[4]);\n+  XVECEXP (operands[3], 0, 1) = gen_rtx_USE (VOIDmode, operands[4]);\n+  XVECEXP (operands[3], 0, 2) = gen_rtx_CLOBBER (VOIDmode, operands[4]);\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 2)\n-      = gen_rtx (SET, VOIDmode,\n-\t\t gen_rtx (MEM, SImode, plus_constant (from, i * 4)),\n-\t\t gen_rtx (REG, SImode, regno + i));\n+      = gen_rtx_SET (VOIDmode,\n+\t\t     gen_rtx_MEM (SImode, plus_constant (from, i * 4)),\n+\t\t     gen_rtx_REG (SImode, regno + i));\n }\")\n \n (define_expand \"store_multiple_bug\"\n@@ -1417,19 +1416,19 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[1]);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count + 1));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n   from = memory_address (SImode, XEXP (operands[0], 0));\n-  XVECEXP (operands[3], 0, 0) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t gen_rtx (MEM, SImode, from),\n-\t\t\t\t\t gen_rtx (REG, SImode, regno));\n+  XVECEXP (operands[3], 0, 0) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t     gen_rtx_MEM (SImode, from),\n+\t\t\t\t\t     gen_rtx_REG (SImode, regno));\n   XVECEXP (operands[3], 0, 1)\n-    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, PSImode));\n+    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (PSImode));\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 1)\n-      = gen_rtx (SET, VOIDmode,\n-\t\t gen_rtx (MEM, SImode, plus_constant (from, i * 4)),\n-\t\t gen_rtx (REG, SImode, regno + i));\n+      = gen_rtx_SET (VOIDmode,\n+\t\t     gen_rtx_MEM (SImode, plus_constant (from, i * 4)),\n+\t\t     gen_rtx_REG (SImode, regno + i));\n }\")\n \n (define_insn \"\"\n@@ -1811,7 +1810,7 @@\n   \"\n { rtx seq = gen_loadhi (gen_lowpart (SImode, operands[0]),\n \t\t\ta29k_get_reloaded_address (operands[1]),\n-\t\t\tgen_rtx (REG, SImode, R_TAV),\n+\t\t\tgen_rtx_REG (SImode, R_TAV),\n \t\t\toperands[2]);\n \n   a29k_set_memflags (seq, operands[1]);\n@@ -1828,7 +1827,7 @@\n { rtx (*fcn) () = TARGET_BYTE_WRITES ? gen_storehihww : gen_storehinhww;\n   rtx seq = (*fcn) (a29k_get_reloaded_address (operands[0]),\n \t\t    gen_lowpart (SImode, operands[1]),\n-\t\t    gen_rtx (REG, SImode, R_TAV), operands[2]);\n+\t\t    gen_rtx_REG (SImode, R_TAV), operands[2]);\n \n   a29k_set_memflags (seq, operands[0]);\n   emit_insn (seq);\n@@ -1941,7 +1940,7 @@\n   \"\n { rtx seq = gen_loadqi (gen_lowpart (SImode, operands[0]),\n \t\t\ta29k_get_reloaded_address (operands[1]),\n-\t\t\tgen_rtx (REG, SImode, R_TAV),\n+\t\t\tgen_rtx_REG (SImode, R_TAV),\n \t\t\toperands[2]);\n \n   a29k_set_memflags (seq, operands[1]);\n@@ -1958,7 +1957,7 @@\n { rtx (*fcn) () = TARGET_BYTE_WRITES ? gen_storeqihww : gen_storeqinhww;\n   rtx seq = (*fcn) (a29k_get_reloaded_address (operands[0]),\n \t\t    gen_lowpart (SImode, operands[1]),\n-\t\t    gen_rtx (REG, SImode, R_TAV), operands[2]);\n+\t\t    gen_rtx_REG (SImode, R_TAV), operands[2]);\n \n   a29k_set_memflags (seq, operands[0]);\n   emit_insn (seq);\n@@ -2173,25 +2172,25 @@\n   if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n       && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n     {\n-      operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n-      operands[4] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3);\n-      operands[5] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n-      operands[6] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n-      operands[7] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-      operands[8] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-      operands[9] = gen_rtx (REG, SImode, REGNO (operands[0]));\n-      operands[10] = gen_rtx (REG, SImode, REGNO (operands[1]));\n+      operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]) + 3);\n+      operands[4] = gen_rtx_REG (SImode, REGNO (operands[1]) + 3);\n+      operands[5] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n+      operands[6] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n+      operands[7] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+      operands[8] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n+      operands[9] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+      operands[10] = gen_rtx_REG (SImode, REGNO (operands[1]));\n     }\n   else\n     {\n-      operands[3] = gen_rtx (REG, SImode, REGNO (operands[0]));\n-      operands[4] = gen_rtx (REG, SImode, REGNO (operands[1]));\n-      operands[5] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-      operands[6] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-      operands[7] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n-      operands[8] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n-      operands[9] = gen_rtx (REG, SImode, REGNO (operands[0]) + 3);\n-      operands[10] = gen_rtx (REG, SImode, REGNO (operands[1]) + 3); \n+      operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+      operands[4] = gen_rtx_REG (SImode, REGNO (operands[1]));\n+      operands[5] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+      operands[6] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n+      operands[7] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n+      operands[8] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n+      operands[9] = gen_rtx_REG (SImode, REGNO (operands[0]) + 3);\n+      operands[10] = gen_rtx_REG (SImode, REGNO (operands[1]) + 3); \n     }\n }\")\n \n@@ -2553,9 +2552,9 @@\n {\n   operands[1] = gen_reg_rtx (SImode);\n   if (a29k_compare_fp_p)\n-    operands[2] = gen_rtx (GT, SImode, a29k_compare_op1, a29k_compare_op0);\n+    operands[2] = gen_rtx_GT (SImode, a29k_compare_op1, a29k_compare_op0);\n   else\n-    operands[2] = gen_rtx (LT, SImode, a29k_compare_op0, a29k_compare_op1);\n+    operands[2] = gen_rtx_LT (SImode, a29k_compare_op0, a29k_compare_op1);\n }\")\n \n ;; Similarly for \"le\".\n@@ -2570,9 +2569,9 @@\n {\n   operands[1] = gen_reg_rtx (SImode);\n   if (a29k_compare_fp_p)\n-    operands[2] = gen_rtx (GE, SImode, a29k_compare_op1, a29k_compare_op0);\n+    operands[2] = gen_rtx_GE (SImode, a29k_compare_op1, a29k_compare_op0);\n   else\n-    operands[2] = gen_rtx (LE, SImode, a29k_compare_op0, a29k_compare_op1);\n+    operands[2] = gen_rtx_LE (SImode, a29k_compare_op0, a29k_compare_op1);\n }\")\n \n (define_expand \"bltu\"\n@@ -2708,9 +2707,9 @@\n   \"\n {\n   if (a29k_compare_fp_p)\n-    operands[1] = gen_rtx (GT, SImode, a29k_compare_op1, a29k_compare_op0);\n+    operands[1] = gen_rtx_GT (SImode, a29k_compare_op1, a29k_compare_op0);\n   else\n-    operands[1] = gen_rtx (LT, SImode, a29k_compare_op0, a29k_compare_op1);\n+    operands[1] = gen_rtx_LT (SImode, a29k_compare_op0, a29k_compare_op1);\n }\")\n \n ;; Similarly for \"le\"\n@@ -2721,9 +2720,9 @@\n   \"\n {\n   if (a29k_compare_fp_p)\n-    operands[1] = gen_rtx (GE, SImode, a29k_compare_op1, a29k_compare_op0);\n+    operands[1] = gen_rtx_GE (SImode, a29k_compare_op1, a29k_compare_op0);\n   else\n-    operands[1] = gen_rtx (LE, SImode, a29k_compare_op0, a29k_compare_op1);\n+    operands[1] = gen_rtx_LE (SImode, a29k_compare_op0, a29k_compare_op1);\n }\")\n \n (define_expand \"sltu\""}, {"sha": "e9da5dbbe2573bb936df3ec1f37c9f503f348f0f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -412,7 +412,7 @@ sext_add_operand (op, mode)\n     return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n \t    || CONST_OK_FOR_LETTER_P (INTVAL (op), 'O'));\n \n-  return register_operand (op, mode);\n+  return reg_not_elim_operand (op, mode);\n }\n \n /* Return 1 if OP is the constant 4 or 8.  */\n@@ -3052,9 +3052,9 @@ alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n \n   /* Store function address and CXT.  */\n   addr = memory_address (mode, plus_constant (tramp, fnofs));\n-  emit_move_insn (gen_rtx (MEM, mode, addr), fnaddr);\n+  emit_move_insn (gen_rtx_MEM (mode, addr), fnaddr);\n   addr = memory_address (mode, plus_constant (tramp, cxtofs));\n-  emit_move_insn (gen_rtx (MEM, mode, addr), cxt);\n+  emit_move_insn (gen_rtx_MEM (mode, addr), cxt);\n \n   /* This has been disabled since the hint only has a 32k range, and in\n      no existing OS is the stack within 32k of the text segment. */\n@@ -3070,15 +3070,15 @@ alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n \n       /* Merge in the hint.  */\n       addr = memory_address (SImode, plus_constant (tramp, jmpofs));\n-      temp1 = force_reg (SImode, gen_rtx (MEM, SImode, addr));\n+      temp1 = force_reg (SImode, gen_rtx_MEM (SImode, addr));\n       temp1 = expand_and (temp1, GEN_INT (0xffffc000), NULL_RTX);\n       temp1 = expand_binop (SImode, ior_optab, temp1, temp, temp1, 1,\n \t\t\t    OPTAB_WIDEN);\n-      emit_move_insn (gen_rtx (MEM, SImode, addr), temp1);\n+      emit_move_insn (gen_rtx_MEM (SImode, addr), temp1);\n     }\n \n #ifdef TRANSFER_FROM_TRAMPOLINE\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__enable_execute_stack\"),\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n \t\t     0, VOIDmode, 1, addr, Pmode);\n #endif\n "}, {"sha": "233dae9a3fd230b0c5eb573930324aab7edb702c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1009,25 +1009,25 @@ extern int alpha_memory_latency;\n    On Alpha the value is found in $0 for integer functions and\n    $f0 for floating-point functions.  */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n   gen_rtx_REG (((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n-\t         && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n-\t        || POINTER_TYPE_P (VALTYPE))\t\t\t\\\n+\t\t && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n+\t\t|| POINTER_TYPE_P (VALTYPE))\t\t\t\\\n \t       ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n \t       ((TARGET_FPREGS\t\t\t\t\t\\\n-\t         && (TREE_CODE (VALTYPE) == REAL_TYPE\t\t\\\n+\t\t && (TREE_CODE (VALTYPE) == REAL_TYPE\t\t\\\n \t\t     || TREE_CODE (VALTYPE) == COMPLEX_TYPE))\t\\\n-\t        ? 32 : 0))\n+\t\t? 32 : 0))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\\\n+#define LIBCALL_VALUE(MODE)\t\\\n    gen_rtx_REG (MODE,\t\t\t\t\t\t\\\n-\t        (TARGET_FPREGS\t\t\t\t\t\\\n-\t         && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+\t\t(TARGET_FPREGS\t\t\t\t\t\\\n+\t\t && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n \t\t     || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n-\t         ? 32 : 0))\n+\t\t ? 32 : 0))\n \n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.\n@@ -1105,11 +1105,12 @@ extern int alpha_memory_latency;\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n ((CUM) < 6 && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n- ? gen_rtx(REG, (MODE),\t\t\t\t\\\n-\t   (CUM) + 16 + ((TARGET_FPREGS\t\t\\\n-\t\t\t  && (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT  \\\n-\t\t\t      || GET_MODE_CLASS (MODE) == MODE_FLOAT)) \\\n-\t\t\t * 32))\t\t\t\\\n+ ? gen_rtx_REG ((MODE),\t\t\t\t\\\n+\t\t(CUM) + 16\t\t\t\\\n+\t\t+ ((TARGET_FPREGS\t\t\\\n+\t\t    && (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT  \\\n+\t\t\t|| GET_MODE_CLASS (MODE) == MODE_FLOAT)) \\\n+\t\t   * 32))\t\t\t\\\n  : 0)\n \n /* Specify the padding direction of arguments."}, {"sha": "6407b6c1d098c411b67e8e9312ace11c4627d40e", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 2, "deletions": 91, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -491,7 +491,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(sign_extend:DI\n-\t (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t (plus:SI (match_operand:SI 1 \"reg_not_elim_operand\" \"\")\n \t\t  (match_operand:SI 2 \"const_int_operand\" \"\"))))\n    (clobber (match_operand:SI 3 \"reg_not_elim_operand\" \"\"))]\n   \"! sext_add_operand (operands[2], SImode) && INTVAL (operands[2]) > 0\n@@ -626,7 +626,7 @@\n \t\t\t\t\t      [(match_operand 2 \"\" \"\")\n \t\t\t\t\t       (match_operand 3 \"\" \"\")])\n \t\t\t   (match_operand:SI 4 \"const48_operand\" \"\"))\n-\t\t  (match_operand:SI 5 \"add_operand\" \"\"))))\n+\t\t  (match_operand:SI 5 \"sext_add_operand\" \"\"))))\n    (clobber (match_operand:DI 6 \"reg_not_elim_operand\" \"\"))]\n   \"\"\n   [(set (match_dup 6) (match_dup 7))\n@@ -650,95 +650,6 @@\n    s%2addq %1,%3,%0\n    s%2subq %1,%n3,%0\")\n \n-;; These variants of the above insns can occur if the third operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize them while reloading.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"some_operand\" \"=&r\")\n-\t(plus:DI (plus:DI (match_operand:DI 1 \"some_operand\" \"r\")\n-\t\t\t  (match_operand:DI 2 \"some_operand\" \"r\"))\n-\t\t (match_operand:DI 3 \"some_operand\" \"rIOKL\")))]\n-  \"reload_in_progress\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(plus:DI (plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t  (match_operand:DI 2 \"register_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"add_operand\" \"\")))]\n-  \"reload_completed\"\n-  [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n-  \"\")\n-\t\t\t\t\t   \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"some_operand\" \"=&r\")\n-\t(plus:SI (plus:SI (mult:SI (match_operand:SI 1 \"some_operand\" \"rJ\")\n-\t\t\t\t   (match_operand:SI 2 \"const48_operand\" \"I\"))\n-\t\t\t  (match_operand:SI 3 \"some_operand\" \"r\"))\n-\t\t (match_operand:SI 4 \"some_operand\" \"rIOKL\")))]\n-  \"reload_in_progress\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n-\t(plus:SI (plus:SI (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n-\t\t\t\t   (match_operand:SI 2 \"const48_operand\" \"\"))\n-\t\t\t  (match_operand:SI 3 \"register_operand\" \"\"))\n-\t\t (match_operand:SI 4 \"add_operand\" \"rIOKL\")))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:SI (mult:SI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"some_operand\" \"=&r\")\n-\t(sign_extend:DI\n-\t (plus:SI (plus:SI\n-\t\t   (mult:SI (match_operand:SI 1 \"some_operand\" \"rJ\")\n-\t\t\t    (match_operand:SI 2 \"const48_operand\" \"I\"))\n-\t\t   (match_operand:SI 3 \"some_operand\" \"r\"))\n-\t\t  (match_operand:SI 4 \"some_operand\" \"rIOKL\"))))]\n-  \"reload_in_progress\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(sign_extend:DI\n-\t (plus:SI (plus:SI\n-\t\t   (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const48_operand\" \"\"))\n-\t\t   (match_operand:SI 3 \"register_operand\" \"\"))\n-\t\t  (match_operand:SI 4 \"add_operand\" \"\"))))]\n-  \"reload_completed\"\n-  [(set (match_dup 5)\n-\t(plus:SI (mult:SI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 0) (sign_extend:DI (plus:SI (match_dup 5) (match_dup 4))))]\n-  \"operands[5] = gen_lowpart (SImode, operands[0]);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"some_operand\" \"=&r\")\n-\t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"some_operand\" \"rJ\")\n-\t\t\t\t   (match_operand:DI 2 \"const48_operand\" \"I\"))\n-\t\t\t  (match_operand:DI 3 \"some_operand\" \"r\"))\n-\t\t (match_operand:DI 4 \"some_operand\" \"rIOKL\")))]\n-  \"reload_in_progress\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"=\")\n-\t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n-\t\t\t\t   (match_operand:DI 2 \"const48_operand\" \"\"))\n-\t\t\t  (match_operand:DI 3 \"register_operand\" \"\"))\n-\t\t (match_operand:DI 4 \"add_operand\" \"\")))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:DI (mult:DI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n-  \"\")\n-\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"reg_or_8bit_operand\" \"rI\")))]"}, {"sha": "4d9bb1bd194458fcf59f3988f71759de80a13d67", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -143,7 +143,7 @@ Boston, MA 02111-1307, USA.  */\n    Thus 6 or more means all following args should go on the stack.  */\n \n enum avms_arg_type {I64, FF, FD, FG, FS, FT};\n-typedef struct {char num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n+typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n \n #undef CUMULATIVE_ARGS\n #define CUMULATIVE_ARGS avms_arg_info\n@@ -185,12 +185,12 @@ extern struct rtx_def *alpha_arg_info_reg_val ();\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n ((MODE) == VOIDmode ? alpha_arg_info_reg_val (CUM)\t\t\\\n  : ((CUM.num_args) < 6 && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n-    ? gen_rtx(REG, (MODE),\t\t\t\t\t\\\n-\t      ((CUM).num_args + 16\t\t\t\t\\\n-\t       + ((TARGET_FPREGS\t\t\t\t\\\n-\t\t   && (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n-\t\t       || GET_MODE_CLASS (MODE) == MODE_FLOAT)) \\\n-\t\t  * 32)))\t\t\t\\\n+    ? gen_rtx_REG ((MODE),\t\t\t\t\t\\\n+\t\t   ((CUM).num_args + 16\t\t\t\t\\\n+\t\t    + ((TARGET_FPREGS\t\t\t\t\\\n+\t\t\t&& (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n+\t\t\t    || GET_MODE_CLASS (MODE) == MODE_FLOAT)) \\\n+\t\t       * 32)))\t\t\t\\\n     : 0))\n \n #undef FUNCTION_ARG_ADVANCE\n@@ -242,7 +242,7 @@ extern struct rtx_def *alpha_arg_info_reg_val ();\n     {\t\t\t\t\t\t\t\\\n       if (! (NO_RTL))\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\\\n-\t  emit_move_insn (gen_rtx (REG, DImode, 1),\t\\\n+\t  emit_move_insn (gen_rtx_REG (DImode, 1),\t\\\n \t\t\t  virtual_incoming_args_rtx);\t\\\n \t  emit_insn (gen_arg_home ());\t\t\t\\\n \t}\t\t\t\t\t\t\\"}, {"sha": "61ed8b0950d23ad28f6cea5fc5c5266a5716e1dc", "filename": "gcc/config/alpha/x-alpha", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Fx-alpha", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Fx-alpha", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fx-alpha?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,2 +1,2 @@\n-CLIB=-lmld\n+CLIB=-lmld -lexc\n EXTRA_HEADERS = $(srcdir)/config/alpha/va_list.h"}, {"sha": "91e2edee9ad927e531fc7cc73791a56a779819f1", "filename": "gcc/config/alpha/xm-alpha.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Fxm-alpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Falpha%2Fxm-alpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fxm-alpha.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for GNU C-compiler for DEC Alpha.\n-   Copyright (C) 1990, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 92, 93, 94, 95, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu).\n \n This file is part of GNU CC.\n@@ -61,16 +61,6 @@ extern void *alloca ();\n #define ONLY_INT_FIELDS\n #endif\n \n-/* Declare some functions needed for this machine.  We don't want to\n-   include these in the sources since other machines might define them\n-   differently.  */\n-\n-extern void *malloc (), *realloc (), *calloc ();\n-\n-#ifndef inhibit_libc\n-#include \"string.h\"\n-#endif\n-\n /* OSF/1 is POSIX.1 compliant.  */\n \n #define POSIX"}, {"sha": "c5638f1f75385db11d05421e25d17574e64ff555", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on the Argonaut ARC cpu.\n-   Copyright (C) 1994, 1995, 1997, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -20,8 +20,8 @@ Boston, MA 02111-1307, USA.  */\n \n /* ??? This is an old port, and is undoubtedly suffering from bit rot.  */\n \n-#include <stdio.h>\n #include \"config.h\"\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -707,10 +707,10 @@ gen_compare_reg (code, x, y)\n   enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg;\n \n-  cc_reg = gen_rtx (REG, mode, 61);\n+  cc_reg = gen_rtx_REG (mode, 61);\n \n-  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n-\t\t      gen_rtx (COMPARE, mode, x, y)));\n+  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n+\t\t\t  gen_rtx_COMPARE (mode, x, y)));\n \n   return cc_reg;\n }\n@@ -786,12 +786,11 @@ arc_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       int align_slop = size & 1;\n       rtx regblock;\n \n-      regblock = gen_rtx (MEM, BLKmode,\n-\t\t\t  plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t FIRST_PARM_OFFSET (0)\n-\t\t\t\t\t + align_slop * UNITS_PER_WORD));\n+      regblock = gen_rtx_MEM (BLKmode,\n+\t\t\t      plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t     FIRST_PARM_OFFSET (0)\n+\t\t\t\t\t     + align_slop * UNITS_PER_WORD));\n       MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();\n-\n       move_block_from_reg (first_reg_offset, regblock,\n \t\t\t   MAX_ARC_PARM_REGS - first_reg_offset,\n \t\t\t   ((MAX_ARC_PARM_REGS - first_reg_offset)"}, {"sha": "8135198e312f1808496268141c30734d9990b19a", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -601,10 +601,12 @@ extern enum reg_class arc_regno_reg_class[];\n    farther back is at [%fp,4].  */\n #if 0 /* The default value should work.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME) \\\n-(((COUNT) == -1)\t\t\t\t\\\n- ? gen_rtx (REG, Pmode, 31)\t\t\t\\\n- : copy_to_reg (gen_rtx (MEM, Pmode,\t\t\\\n-\t\t\t memory_address (Pmode, plus_constant ((FRAME), UNITS_PER_WORD)))))\n+(((COUNT) == -1)\t\t\t\t\t\t\t\\\n+ ? gen_rtx_REG (Pmode, 31)\t\t\t\t\t\t\\\n+ : copy_to_reg (gen_rtx_MEM (Pmode,\t\t\t\t\t\\\n+\t\t\t     memory_address (Pmode,\t\t\t\\\n+\t\t\t\t\t     plus_constant ((FRAME),\t\\\n+\t\t\t\t\t\t\t    UNITS_PER_WORD)))))\n #endif\n \n /* Register to use for pushing function arguments.  */\n@@ -722,7 +724,7 @@ extern enum reg_class arc_regno_reg_class[];\n    and the rest are pushed.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n (PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED))\t\t\t\t\\\n- ? gen_rtx (REG, (MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+ ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n  : 0)\n \n /* A C expression for the number of words, at the beginning of an\n@@ -812,11 +814,11 @@ arc_setup_incoming_varargs(&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, 0)\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -909,9 +911,9 @@ do { \\\n    CXT is an RTX for the static chain value for the function.  */\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n do { \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)), FNADDR); \\\n-  emit_insn (gen_flush_icache (validize_mem (gen_rtx (MEM, SImode, TRAMP)))); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), FNADDR); \\\n+  emit_insn (gen_flush_icache (validize_mem (gen_rtx_MEM (SImode, TRAMP)))); \\\n } while (0)\n \f\n /* Library calls.  */"}, {"sha": "89ebc8ed9bea65f7df05313d7bcfa1d174d0aad4", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description of the Argonaut ARC cpu for GNU C compiler\n-;; Copyright (C) 1994, 1997, 1999 Free Software Foundation, Inc.\n+;; Copyright (C) 1994, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -304,7 +304,7 @@\n ;{\n ;  /* Flow doesn't understand that this is effectively a DFmode move.\n ;     It doesn't know that all of `operands[0]' is set.  */\n-;  emit_insn (gen_rtx (CLOBBER, VOIDmode, operands[0]));\n+;  emit_insn (gen_rtx_CLOBBER (VOIDmode, operands[0]));\n ;\n ;  /* Emit insns that movsi_insn can handle.  */\n ;  emit_insn (gen_movsi (operand_subword (operands[0], 0, 0, DImode),\n@@ -407,7 +407,7 @@\n ;{\n ;  /* Flow doesn't understand that this is effectively a DFmode move.\n ;     It doesn't know that all of `operands[0]' is set.  */\n-;  emit_insn (gen_rtx (CLOBBER, VOIDmode, operands[0]));\n+;  emit_insn (gen_rtx_CLOBBER (VOIDmode, operands[0]));\n ;\n ;  /* Emit insns that movsi_insn can handle.  */\n ;  emit_insn (gen_movsi (operand_subword (operands[0], 0, 0, DFmode),\n@@ -586,9 +586,9 @@\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx ccreg = gen_rtx (REG,\n-\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-\t\t       61);\n+  rtx ccreg\n+    = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+\t\t   61);\n \n   operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n }\")\n@@ -602,14 +602,14 @@\n ;  \"\n ;{\n ;  enum rtx_code code = GET_CODE (operands[1]);\n-;  rtx ccreg = gen_rtx (REG,\n-;\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-;\t\t       61);\n+;  rtx ccreg\n+;   = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+;\t\t   61);\n ;\n ;  operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n-;}\")\n-\n+}\")\n (define_expand \"movsfcc\"\n+\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n \t\t      (match_operand:SF 2 \"nonmemory_operand\" \"\")\n@@ -618,9 +618,9 @@\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx ccreg = gen_rtx (REG,\n-\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-\t\t       61);\n+  rtx ccreg\n+    = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+\t\t   61);\n \n   operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n }\")\n@@ -633,13 +633,13 @@\n ;  \"0 /* ??? can generate less efficient code if constants involved */\"\n ;  \"\n ;{\n-;  enum rtx_code code = GET_CODE (operands[1]);\n-;  rtx ccreg = gen_rtx (REG,\n-;\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n-;\t\t       61);\n+; enum rtx_code code = GET_CODE (operands[1]);\n+; rtx ccreg\n+;   = gen_rtx_REG (SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+;\t\t   61);\n ;\n ;  operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n-;}\")\n+}\")\n \n (define_insn \"*movsicc_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1060,12 +1060,14 @@\n {\n   if (! TARGET_SHIFTER)\n     {\n-      emit_insn (gen_rtx\n-\t\t (PARALLEL, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL\n+\t\t (VOIDmode,\n \t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\t      gen_rtx (ASHIFT, SImode, operands[1], operands[2])),\n-\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)))));\n+\t\t\t     gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t\t  gen_rtx_ASHIFT (SImode, operands[1],\n+\t\t\t\t\t\t\t  operands[2])),\n+\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t      gen_rtx_SCRATCH (SImode)))));\n       DONE;\n     }\n }\")\n@@ -1079,12 +1081,15 @@\n {\n   if (! TARGET_SHIFTER)\n     {\n-      emit_insn (gen_rtx\n-\t\t (PARALLEL, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL\n+\t\t (VOIDmode,\n \t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\t      gen_rtx (ASHIFTRT, SImode, operands[1], operands[2])),\n-\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)))));\n+\t\t\t     gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t\t  gen_rtx_ASHIFTRT (SImode,\n+\t\t\t\t\t\t\t    operands[1],\n+\t\t\t\t\t\t\t    operands[2])),\n+\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t      gen_rtx_SCRATCH (SImode)))));\n       DONE;\n     }\n }\")\n@@ -1098,12 +1103,15 @@\n {\n   if (! TARGET_SHIFTER)\n     {\n-      emit_insn (gen_rtx\n-\t\t (PARALLEL, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL\n+\t\t (VOIDmode,\n \t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\t      gen_rtx (LSHIFTRT, SImode, operands[1], operands[2])),\n-\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)))));\n+\t\t\t     gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t\t  gen_rtx_LSHIFTRT (SImode,\n+\t\t\t\t\t\t\t    operands[1],\n+\t\t\t\t\t\t\t    operands[2])),\n+\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t      gen_rtx_SCRATCH (SImode)))));\n       DONE;\n     }\n }\")"}, {"sha": "c76570e2e13e8099670dea87e91b64c8d87c8ba0", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Clipper\n-   Copyright (C) 1987, 1988, 1991, 1997, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 97, 98, 1999 Free Software Foundation, Inc.\n    Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n \n This file is part of GNU CC.\n@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -43,16 +43,14 @@ extern int frame_pointer_needed;\n \n static int frame_size;\n \n-/*\n- * compute size of a clipper stack frame where 'lsize' is the required\n- * space for local variables.\n- */\n+/* Compute size of a clipper stack frame where 'lsize' is the required\n+   space for local variables.  */\n \n int\n clipper_frame_size (lsize)\n      int lsize;\n {\n-  int i,size;\t\t\t\t/* total size of frame */\n+  int i, size;\t\t\t\t/* total size of frame */\n   int save_size;\n   save_size = 0;\t\t\t/* compute size for reg saves */\n \n@@ -70,17 +68,15 @@ clipper_frame_size (lsize)\n   return size;\n }\n \n-/*\n- * prologue and epilogue output\n- * function is entered with pc pushed, i.e. stack is 32 bit aligned\n- *\n- * current_function_args_size == 0 means that the current function's args\n- * are passed totally in registers i.e fp is not used as ap.\n- * If frame_size is also 0 the current function does not push anything and\n- * can run with misaligned stack -> subq $4,sp / add $4,sp on entry and exit\n- * can be omitted.\n- *\n- */\n+/* Prologue and epilogue output\n+   Function is entered with pc pushed, i.e. stack is 32 bit aligned\n+\n+   current_function_args_size == 0 means that the current function's args\n+   are passed totally in registers i.e fp is not used as ap.\n+   If frame_size is also 0 the current function does not push anything and\n+   can run with misaligned stack -> subq $4,sp / add $4,sp on entry and exit\n+   can be omitted.  */\n+\n void\n output_function_prologue (file, lsize)\n      FILE *file;"}, {"sha": "e73ebfcc586aae86a3d45cfd5f76102d5e744ae3", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Clipper version.\n-   Copyright (C) 1987, 88, 91, 93-96, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 93-96, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n \n This file is part of GNU CC.\n@@ -393,15 +393,15 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS, LIM_REG_CLASSES};\n    otherwise, FUNC is 0.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n-\t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n-\t\t\t\t        16 : 0))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n+\t\t\t\t      TYPE_MODE (VALTYPE) == DFmode) ? \\\n+\t\t\t\t     16 : 0))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE)  \\\n-  gen_rtx (REG, (MODE), ((MODE) == SFmode || (MODE) == DFmode ? 16 : 0))\n+  gen_rtx_REG ((MODE), ((MODE) == SFmode || (MODE) == DFmode ? 16 : 0))\n \n \n /* 1 if N is a possible register number for a function value\n@@ -527,8 +527,9 @@ do\t\t\t\t\t\t\t\t\t      \\\n     && (GET_MODE_SIZE (MODE) <= 8)\t\t\t\t\t     \\\n     && ((TYPE) == NULL || !AGGREGATE_TYPE_P(TYPE))\t\t\t     \\\n     && ((MODE) != DImode || (CUM).num == 0))\t\t\t\t     \\\n-   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t     \\\n-\t      GET_MODE_CLASS(MODE) == MODE_FLOAT ? (CUM).num+16 : (CUM).num) \\\n+   ? gen_rtx_REG ((MODE),\t\t\t\t\t\t     \\\n+\t\t  GET_MODE_CLASS(MODE) == MODE_FLOAT\t\t\t     \\\n+\t\t  ? (CUM).num+16 : (CUM).num)\t\t\t\t     \\\n    : 0)\n \n /* If defined, a C expression that gives the alignment boundary, in bits,\n@@ -633,8 +634,8 @@ do\t\t\t\t\t\t\t\t\t      \\\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 24)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 28)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 24)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 28)), FNADDR); \\\n }\n \f\n /* Addressing modes, and classification of registers for them.  */"}, {"sha": "efe26a995f325dedd5ccaf6c0956b4f0201cec4f", "filename": "gcc/config/clipper/clipper.md", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fclipper%2Fclipper.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fclipper%2Fclipper.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,6 @@\n ;;- Machine description for GNU compiler, Clipper Version\n-;;   Copyright (C) 1987, 88, 91, 93, 94, 1997 Free Software Foundation, Inc.\n+;;  Copyright (C) 1987, 88, 91, 93, 94, 97, 98, 1999\n+;;  Free Software Foundation, Inc.\n ;; Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n \n ;; This file is part of GNU CC.\n@@ -178,7 +179,7 @@\n     {\n       rtx xops[4];\n       xops[0] = operands[0];\n-      xops[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      xops[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n       xops[2] = operands[1];\n       xops[3] = adj_offsettable_operand (operands[1], 4);\n       output_asm_insn (\\\"loadw  %2,%0\\;loadw  %3,%1\\\", xops);\n@@ -189,9 +190,9 @@\n     {\n       rtx xops[4];\n       xops[0] = operands[0];\n-      xops[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      xops[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n       xops[2] = operands[1];\n-      xops[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      xops[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n       output_asm_insn (\\\"movw   %2,%0\\;movw   %3,%1\\\", xops);\n       return \\\"\\\";\n     }\n@@ -215,7 +216,7 @@\n   xops[0] = operands[0];\t\t/* r -> o */\n   xops[1] = adj_offsettable_operand (operands[0], 4);\n   xops[2] = operands[1];\n-  xops[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  xops[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   output_asm_insn (\\\"storw  %2,%0\\;storw  %3,%1\\\", xops);\n   return \\\"\\\";\n }\"\n@@ -317,12 +318,12 @@\n {\n   rtx xoperands[2],yoperands[2];\n \n-  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \n   if (which_alternative == 0)\t\t/* r -> r */\n     {\n       output_asm_insn (\\\"movw   %1,%0\\\", operands);\n-      xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n       output_asm_insn (\\\"movw   %1,%0\\\", xoperands);\n       return \\\"\\\";\n     }\n@@ -366,7 +367,7 @@\n   xops[0] = operands[0];\n   xops[1] = adj_offsettable_operand (operands[0], 4);\n   xops[2] = operands[1];\n-  xops[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  xops[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   output_asm_insn (\\\"storw  %2,%0\\;storw  %3,%1\\\", xops);\n   return \\\"\\\";\n }\"\n@@ -696,9 +697,9 @@\n   rtx xoperands[4];\n \n   xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   xoperands[2] = operands[2];\n-  xoperands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  xoperands[3] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   output_asm_insn (\\\"addw   %2,%0\\;addwc  %3,%1\\\", xoperands);\n   return \\\"\\\";\n }\"\n@@ -767,9 +768,9 @@\n   rtx xoperands[4];\n \n   xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   xoperands[2] = operands[2];\n-  xoperands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  xoperands[3] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   output_asm_insn (\\\"subw   %2,%0\\;subwc  %3,%1\\\", xoperands);\n   return \\\"\\\";\n }\"\n@@ -991,7 +992,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1018,7 +1019,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1088,7 +1089,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1115,7 +1116,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1146,7 +1147,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1173,7 +1174,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\""}, {"sha": "63de08cc8eab8003ac72a01e4ff7b220e54d76f9", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Convex.\n-   Copyright (C) 1988, 1993, 1994, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 93, 94, 97, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -360,8 +360,8 @@ expand_movstr (operands)\n \tdest = change_address (dest, mode, 0);\n \n       /* Make load and store patterns for this piece */\n-      load = gen_rtx (SET, VOIDmode, reg, src);\n-      store = gen_rtx (SET, VOIDmode, dest, reg);\n+      load = gen_rtx_SET (VOIDmode, reg, src);\n+      store = gen_rtx_SET (VOIDmode, dest, reg);\n \n       /* Emit the load and the store from last time. \n \t When we emit a store, we can reuse its temp reg. */\n@@ -398,7 +398,7 @@ static void\n expand_movstr_call (operands)\n      rtx *operands;\n {\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n \t\t     VOIDmode, 3,\n \t\t     XEXP (operands[0], 0), Pmode,\n \t\t     XEXP (operands[1], 0), Pmode,"}, {"sha": "fc6ce66be23e8c9bde93021504b121c01fc0b0f2", "filename": "gcc/config/convex/convex.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fconvex%2Fconvex.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fconvex%2Fconvex.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler, Convex Version\n-;;  Copyright (C) 1988, 1994, 1995 Free Software Foundation, Inc.\n+;;  Copyright (C) 1988, 1994, 1995, 1998, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1518,7 +1518,7 @@\n     }\n   else\n     {\n-      output_cmp (gen_rtx (REG, SImode, 7), constm1_rtx, 'W');\n+      output_cmp (gen_rtx_REG (SImode, 7), constm1_rtx, 'W');\n       return \\\"psh.w s7\\;ld.w %0,s7\\;add.w #-1,s7\\;st.w s7,%0\\;pop.w s7\\\";\n     }\n }\")\n@@ -1540,7 +1540,7 @@\n     }\n   else\n     {\n-      output_cmp (gen_rtx (REG, SImode, 7), const0_rtx, 'W');\n+      output_cmp (gen_rtx_REG (SImode, 7), const0_rtx, 'W');\n       return \\\"psh.w s7\\;ld.w %0,s7\\;add.w #-1,s7\\;st.w s7,%0\\;pop.w s7\\\";\n     }\n }\")\n@@ -1561,7 +1561,7 @@\n     }\n   else\n     {\n-      output_cmp (gen_rtx (REG, HImode, 7), constm1_rtx, 'H');\n+      output_cmp (gen_rtx_REG (HImode, 7), constm1_rtx, 'H');\n       return \\\"psh.w s7\\;ld.h %0,s7\\;add.h #-1,s7\\;st.h s7,%0\\;pop.w s7\\\";\n     }\n }\")\n@@ -1583,7 +1583,7 @@\n     }\n   else\n     {\n-      output_cmp (gen_rtx (REG, HImode, 7), const0_rtx, 'H');\n+      output_cmp (gen_rtx_REG (HImode, 7), const0_rtx, 'H');\n       return \\\"psh.w s7\\;ld.h %0,s7\\;add.h #-1,s7\\;st.h s7,%0\\;pop.w s7\\\";\n     }\n }\")"}, {"sha": "cac77af42943d95b1759263b21a9bf51d2e5c0c3", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 68, "deletions": 54, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -21,7 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Some output-actions in dsp1600.md need these.  */\n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -1795,43 +1795,47 @@ enum machine_mode mode;\n \t  quotient = shift_amount/16;\n \t  shift_amount = shift_amount - (quotient * 16);\n \t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\tgen_rtx (shift_op, mode, \n-\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n-\t\t\t\t\t GEN_INT (16))));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t    gen_rtx (shift_op, mode, \n+\t\t\t\t\t     first_shift_emitted\n+\t\t\t\t\t     ? operands[0] : operands[1],\n+\t\t\t\t\t     GEN_INT (16))));\n \t  first_shift_emitted = 1;\n \t}\n       else if (shift_amount/8)\n \t{\n \t  quotient = shift_amount/8;\n \t  shift_amount = shift_amount - (quotient * 8);\n \t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\tgen_rtx (shift_op, mode, \n-\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n-\t\t\t\t\t GEN_INT (8))));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t    gen_rtx (shift_op, mode, \n+\t\t\t\t\t     first_shift_emitted\n+\t\t\t\t\t     ? operands[0] : operands[1],\n+\t\t\t\t\t     GEN_INT (8))));\n \t  first_shift_emitted = 1;\n \t}\n       else if (shift_amount/4)\n \t{\n \t  quotient = shift_amount/4;\n \t  shift_amount = shift_amount - (quotient * 4);\n \t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\tgen_rtx (shift_op, mode, \n-\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n-\t\t\t\t\t GEN_INT (4))));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t    gen_rtx (shift_op, mode, \n+\t\t\t\t\t     first_shift_emitted\n+\t\t\t\t\t     ? operands[0] : operands[1],\n+\t\t\t\t\t     GEN_INT (4))));\n \t  first_shift_emitted = 1;\n \t}\n       else if (shift_amount/1)\n \t{\n \t  quotient = shift_amount/1;\n \t  shift_amount = shift_amount - (quotient * 1);\n \t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\tgen_rtx (shift_op, mode, \n-\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n-\t\t\t\t\t GEN_INT (1))));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t    gen_rtx (shift_op, mode, \n+\t\t\t\t\t     first_shift_emitted\n+\t\t\t\t\t     ? operands[0] : operands[1],\n+\t\t\t\t\t     GEN_INT (1))));\n \t  first_shift_emitted = 1;\n \t}\n     }\n@@ -2085,7 +2089,7 @@ dsp16xx_function_arg (args_so_far, mode, type, named)\n \targs_so_far++;\n \n       if (named && args_so_far < 4 && !MUST_PASS_IN_STACK (mode,type))\n-\treturn gen_rtx (REG, mode, args_so_far + FIRST_REG_FOR_FUNCTION_ARG);\n+\treturn gen_rtx_REG (mode, args_so_far + FIRST_REG_FOR_FUNCTION_ARG);\n       else\n \treturn (struct rtx_def *) 0;\n     }\n@@ -2135,14 +2139,14 @@ gen_tst_reg (x)\n \n   if (mode == QImode)\n     {\n-\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\tgen_rtvec (2,\n-\t\t\t\t   gen_rtx (SET, VOIDmode, cc0_rtx, x),\n-\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)))));\n+\t  emit_insn (gen_rtx_PARALLEL\n+\t\t     (VOIDmode,\n+\t\t      gen_rtvec (2, gen_rtx_SET (VOIDmode, cc0_rtx, x),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n \t}\n   else if (mode == HImode)\n-    emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, x));\n+    emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, x));\n   else\n     fatal (\"Invalid mode for gen_tst_reg\");\n \n@@ -2165,54 +2169,64 @@ gen_compare_reg (code, x, y)\n \n   if (mode == QImode)\n     {\n-      if (code == GTU || code == GEU ||\n-\t  code == LTU || code == LEU)\n+      if (code == GTU || code == GEU\n+\t  || code == LTU || code == LEU)\n \t{\n-\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\tgen_rtvec (3,\n-\t\t\t\t   gen_rtx (SET, VOIDmode, cc0_rtx,\n-\t\t\t\t\t    gen_rtx (COMPARE, mode, x, y)),\n-\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)),\n-\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)))));\n+\t  emit_insn (gen_rtx_PARALLEL\n+\t\t     (VOIDmode,\n+\t\t      gen_rtvec (3,\n+\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx,\n+\t\t\t\t\t      gen_rtx_COMPARE (mode, x, y)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n \t}\n       else\n \t{\n-\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\tgen_rtvec (3,\n-\t\t\t\t   gen_rtx (SET, VOIDmode, cc0_rtx,\n-\t\t\t\t\t    gen_rtx (COMPARE, mode, x, y)),\n-\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)),\n-\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)))));\n+\t  emit_insn (gen_rtx_PARALLEL\n+\t\t     (VOIDmode,\n+\t\t      gen_rtvec (3, gen_rtx_SET (VOIDmode, cc0_rtx,\n+\t\t\t\t\t\t gen_rtx_COMPARE (mode, x, y)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n \t}\n     }\n   else if (mode == HImode)\n     {\n-      if (code == GTU || code == GEU ||\n-\t  code == LTU || code == LEU)\n+      if (code == GTU || code == GEU\n+\t  || code == LTU || code == LEU)\n \t{\n #if 1\n-\t  emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (5,\n-\t\t\t     gen_rtx (SET, VOIDmode, cc0_rtx, gen_rtx (COMPARE, VOIDmode, x, y)),\n-\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)),\n-\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)),\n-\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)),\n-\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)))));\n+\t  emit_insn (gen_rtx_PARALLEL\n+\t\t     (VOIDmode,\n+\t\t      gen_rtvec (5,\n+\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx,\n+\t\t\t\t\t      gen_rtx_COMPARE (VOIDmode,\n+\t\t\t\t\t\t\t       x, y)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n+\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n #else\n \t  if (!dsp16xx_ucmphi2_libcall)\n-\t    dsp16xx_ucmphi2_libcall = gen_rtx (SYMBOL_REF, Pmode, UCMPHI2_LIBCALL);\n+\t    dsp16xx_ucmphi2_libcall = gen_rtx_SYMBOL_REF (Pmode, UCMPHI2_LIBCALL);\n \t  emit_library_call (dsp16xx_ucmphi2_libcall, 1, HImode, 2,\n \t\t\t     x, HImode, y, HImode);\n \t  emit_insn (gen_tsthi_1 (copy_to_reg(hard_libcall_value (HImode))));\n #endif\n \t}\n       else\n-\temit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,\n-\t\t\t    gen_rtx (COMPARE, VOIDmode, force_reg(HImode, x), \n-\t\t\t\t     force_reg(HImode,y))));\n+\temit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n+\t\t\t\tgen_rtx_COMPARE (VOIDmode,\n+\t\t\t\t\t\t force_reg (HImode, x), \n+\t\t\t\t\t\t force_reg (HImode,y))));\n     }\n   else\n     fatal (\"Invalid mode for integer comparison in gen_compare_reg\");"}, {"sha": "5ded3bb956afe6ff78f45bb43fd7dd73095e901f", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -195,8 +195,8 @@\n \n   if (GET_CODE(operands[1]) == REG)\n     {\n-      if (REGNO (operands[1]) == REG_Y ||\n-\t  REGNO (operands[1]) == REG_PROD)\n+      if (REGNO (operands[1]) == REG_Y\n+\t  || REGNO (operands[1]) == REG_PROD)\n \t{\n \t  output_asm_insn (\\\"a1=%1\\\", operands);\n \t}\n@@ -1049,11 +1049,13 @@\n   emit_move_insn (operands[0], addr_reg);\n \n   /* Then generate the add insn */\n-  emit_insn (gen_rtx (PARALLEL, VOIDmode, \n-\t\t      gen_rtvec (2,\n-\t\t\t\t gen_rtx (SET, VOIDmode, operands[0], \n-\t\t\t\t\t  gen_rtx (PLUS, QImode, operands[0], offset)),\n-\t\t\t\t gen_rtx (CLOBBER, VOIDmode, operands[2]))));\n+  emit_insn (gen_rtx_PARALLEL\n+\t     (VOIDmode, \n+\t      gen_rtvec (2,\n+\t\t\t gen_rtx_SET (VOIDmode, operands[0], \n+\t\t\t\t      gen_rtx_PLUS (QImode, operands[0],\n+\t\t\t\t\t\t    offset)),\n+\t\t\t gen_rtx_CLOBBER (VOIDmode, operands[2]))));\n   DONE;\n }\")\n \n@@ -1251,7 +1253,7 @@\n   \"\n {\n \toperands[2] = gen_reg_rtx (HImode);\n-\toperands[3] = gen_rtx (SUBREG, QImode, operands[2], 1);\n+\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], 1);\n }\")\n \n ;;(define_insn \"extendqihi2\"\n@@ -1301,7 +1303,7 @@\n   \"\n {\n \toperands[2] = gen_reg_rtx (HImode);\n-\toperands[3] = gen_rtx (SUBREG, QImode, operands[2], 1);\n+\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], 1);\n }\")\n \n \n@@ -1357,8 +1359,8 @@\n       emit_jump_insn (gen_bge (label1));\n \n       emit_insn (gen_fix_trunchfhi2 (operands[0], operands[1]));\n-      emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx (LABEL_REF, VOIDmode, label2)));\n+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, label2)));\n       emit_barrier ();\n \n       emit_label (label1);\n@@ -1372,7 +1374,7 @@\n \n       /* allow REG_NOTES to be set on last insn (labels don't have enough\n \t fields, and can't be used for REG_NOTES anyway).  */\n-      emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n       DONE;\n     }\n }\")\n@@ -1438,7 +1440,8 @@\n \n #if 0\n \tif (!dsp16xx_ashrhi3_libcall)\n-\t  dsp16xx_ashrhi3_libcall = gen_rtx_SYMBOL_REF (Pmode, ASHRHI3_LIBCALL);\n+\t  dsp16xx_ashrhi3_libcall\n+\t    = gen_rtx_SYMBOL_REF (Pmode, ASHRHI3_LIBCALL);\n \n \t  emit_library_call (dsp16xx_ashrhi3_libcall, 1, HImode, 2,\n \t\t\t     operands[1], HImode,\n@@ -1562,7 +1565,8 @@\n \t  rtx label2 = gen_label_rtx ();\n #if 0\n \t  if (!dsp16xx_lshrhi3_libcall)\n-\t    dsp16xx_lshrhi3_libcall = gen_rtx_SYMBOL_REF (Pmode, LSHRHI3_LIBCALL);\n+\t    dsp16xx_lshrhi3_libcall\n+\t      = gen_rtx_SYMBOL_REF (Pmode, LSHRHI3_LIBCALL);\n \t  \n \t  emit_library_call (dsp16xx_lshrhi3_libcall, 1, HImode, 2,\n \t\t\t     operands[1], HImode,\n@@ -1704,11 +1708,11 @@\n \trtx label2 = gen_label_rtx ();\n #if 0\n \tif (!dsp16xx_ashlhi3_libcall)\n-\t  dsp16xx_ashlhi3_libcall = gen_rtx_SYMBOL_REF (Pmode, ASHLHI3_LIBCALL);\n+\t  dsp16xx_ashlhi3_libcall\n+\t    = gen_rtx_SYMBOL_REF (Pmode, ASHLHI3_LIBCALL);\n \n \t  emit_library_call (dsp16xx_ashlhi3_libcall, 1, HImode, 2,\n-\t\t\t     operands[1], HImode,\n-\t\t\t     operands[2], QImode);\n+\t\t\t     operands[1], HImode, operands[2], QImode);\n \t  emit_move_insn (operands[0], hard_libcall_value(HImode));\n \t  DONE;\n #else\n@@ -2028,8 +2032,8 @@\n {\n   if (GET_CODE (operands[0]) == MEM\n       && ! call_address_operand (XEXP (operands[0], 0), QImode))\n-    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n-\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+    operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),\n+\t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n }\")\n \n (define_insn \"\"\n@@ -2059,8 +2063,8 @@\n {\n   if (GET_CODE (operands[1]) == MEM\n       && ! call_address_operand (XEXP (operands[1], 0), QImode))\n-    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n+    operands[1] = gen_rtx_MEM (GET_MODE (operands[1]),\n+\t\t\t       force_reg (Pmode, XEXP (operands[1], 0)));\n }\")\n \n (define_insn \"\""}, {"sha": "8362e48b76316f4615deabc2163623a4619998b9", "filename": "gcc/config/elxsi/elxsi.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Felxsi%2Felxsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Felxsi%2Felxsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for GNU compiler.  Elxsi version.\n-   Copyright (C) 1987, 1992, 1997 Free Software Foundation, Inc\n-   This port, done by Mike Stump <mrs@cygnus.com> in 1988, and is the first\n+   Copyright (C) 1987, 1992, 1998, 1999 Free Software Foundation, Inc\n+   Contributrd by Mike Stump <mrs@cygnus.com> in 1988 and is the first\n    64 bit port of GNU CC.\n    Based upon the VAX port.\n \n@@ -22,7 +22,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"function.h\"\n "}, {"sha": "06e83f89f5840de3e538033c8812299ab0c26f8b", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  Elxsi version.\n-   Copyright (C) 1987, 1988, 1992, 1995, 1996 Free Software Foundation, Inc.\n-   This port, contributed by Mike Stump <mrs@cygnus.com> in 1988, is the first\n+   Copyright (C) 1987, 88, 92, 95, 96, 1998, 1999 Free Software Foundation, Inc.\n+   Contributed by Mike Stump <mrs@cygnus.com> in 1988.  This is the first\n    64 bit port of GNU CC.\n    Based upon the VAX port.\n \n@@ -319,14 +319,14 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* On the Vax the return value is in R0 regardless.  */   \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n /* On the Vax the return value is in R0 regardless.  */   \n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n /* Define this if PCC uses the nonreentrant convention for returning\n    structure and union values.  */\n@@ -481,11 +481,11 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n   else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx) \\\n     { rtx other_reg = XEXP (ADDR, 1);\t\t\t\t\t\\\n       offset = 0;\t\t\t\t\t\t\t\\\n-      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n   else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 1) == frame_pointer_rtx) \\\n     { rtx other_reg = XEXP (ADDR, 0);\t\t\t\t\t\\\n       offset = 0;\t\t\t\t\t\t\t\\\n-      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n   if (offset >= 0)\t\t\t\t\t\t\t\\\n     { int regno;\t\t\t\t\t\t\t\\\n       extern char call_used_regs[];\t\t\t\t\t\\"}, {"sha": "81d637e18f69eafa16c18f29fb73c37e61d2cecb", "filename": "gcc/config/fx80/fx80.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ffx80%2Ffx80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ffx80%2Ffx80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Alliant FX computers.\n-   Copyright (C) 1989, 1991, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -21,7 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Some output-actions in alliant.md need these.  */\n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -153,14 +153,14 @@ output_move_double (operands)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       output_asm_insn (\"subq%.l %#8,%0\", operands);\n-      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      operands[0] = gen_rtx_MEM (DImode, operands[0]);\n       optype0 = OFFSOP;\n     }\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n       output_asm_insn (\"subq%.l %#8,%1\", operands);\n-      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      operands[1] = gen_rtx_MEM (DImode, operands[1]);\n       optype1 = OFFSOP;\n     }\n \n@@ -183,14 +183,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)"}, {"sha": "c416d5c87657bfd03fd4ac3069de5fdb13feec6c", "filename": "gcc/config/fx80/fx80.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ffx80%2Ffx80.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ffx80%2Ffx80.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Alliant FX version.\n-   Copyright (C) 1989, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 94, 95, 96, 1998, 1999 Free Software Foundation, Inc.\n    Adapted from m68k.h by Paul Petersen (petersen@uicsrd.csrd.uiuc.edu)\n    and Joe Weening (weening@gang-of-four.stanford.edu).\n \n@@ -453,8 +453,8 @@ extern enum reg_class regno_reg_class[];\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   (TREE_CODE (VALTYPE) == REAL_TYPE \\\n-   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16) \\\n-   : gen_rtx (REG, TYPE_MODE (VALTYPE), 0))\n+   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16) \\\n+   : gen_rtx_REG (TYPE_MODE (VALTYPE), 0))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n@@ -467,8 +467,8 @@ extern enum reg_class regno_reg_class[];\n \n #define LIBCALL_VALUE(MODE)  \\\n   (((MODE) == DFmode || (MODE) == SFmode) \\\n-   ? gen_rtx (REG, MODE, 16) \\\n-   : gen_rtx (REG, MODE, 0))\n+   ? gen_rtx_REG (MODE, 16) \\\n+   : gen_rtx_REG (MODE, 0))\n \n /* 1 if N is a possible register number for a function value.\n    On the Alliant, D0 and FP0 are the only registers thus used."}, {"sha": "6fffb163c39cf0f9bd03c99605efb2dc488db1e2", "filename": "gcc/config/fx80/fx80.md", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ffx80%2Ffx80.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ffx80%2Ffx80.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU C compiler for Alliant FX systems\n-;;  Copyright (C) 1989, 1994, 1996 Free Software Foundation, Inc.\n+;;  Copyright (C) 1989, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.\n ;;  Adapted from m68k.md by Paul Petersen (petersen@uicsrd.csrd.uiuc.edu)\n ;;  and Joe Weening (weening@gang-of-four.stanford.edu).\n \n@@ -415,8 +415,7 @@\n     {\n       xoperands[1] = operands[1];\n       xoperands[2]\n-        = gen_rtx (MEM, QImode,\n-\t\t   gen_rtx (PLUS, VOIDmode, stack_pointer_rtx, const1_rtx));\n+        = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 1));\n       xoperands[3] = stack_pointer_rtx;\n       /* Just pushing a byte puts it in the high byte of the halfword.  */\n       /* We must put it in the low half, the second byte.  */\n@@ -428,8 +427,7 @@\n       xoperands[0] = operands[0];\n       xoperands[1] = operands[1];\n       xoperands[2]\n-        = gen_rtx (MEM, QImode,\n-\t\t   gen_rtx (PLUS, VOIDmode, stack_pointer_rtx, const1_rtx));\n+        = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 1));\n       xoperands[3] = stack_pointer_rtx;\n       output_asm_insn (\\\"mov%.w %1,%-\\;mov%.b %2,%0\\;addq%.w %#2,%3\\\", xoperands);\n       return \\\"\\\";\n@@ -537,7 +535,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"mov%.l %1,%-\\\", xoperands);\n \t  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n \t  return \\\"fmove%.d %+,%0\\\";\n@@ -549,7 +547,7 @@\n       if (REG_P (operands[0]))\n \t{\n \t  output_asm_insn (\\\"fmove%.d %1,%-\\;mov%.l %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  return \\\"mov%.l %+,%0\\\";\n \t}\n       return \\\"fmove%.d %1,%0\\\";\n@@ -570,7 +568,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"mov%.l %1,%-\\\", xoperands);\n \t  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n \t  return \\\"fmove%.d %+,%0\\\";\n@@ -582,7 +580,7 @@\n       if (REG_P (operands[0]))\n \t{\n \t  output_asm_insn (\\\"fmove%.d %1,%-\\;mov%.l %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  return \\\"mov%.l %+,%0\\\";\n \t}\n       return \\\"fmove%.d %1,%0\\\";\n@@ -1395,7 +1393,8 @@\n \toperands[1] = GEN_INT (logval);\n       else\n         {\n-\t  operands[0] = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n+\t  operands[0]\n+\t    = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n \t  operands[1] = GEN_INT (logval % 8);\n \t}\n       return \\\"bset %1,%0\\\";\n@@ -1896,10 +1895,8 @@\n       && GET_CODE (operands[2]) == CONST_INT)\n     {    \n       int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n-      return output_btst (operands,\n-\t\t\t  GEN_INT (width - INTVAL (operands[2])),\n-\t\t\t  operands[0],\n-\t\t\t  insn, 1000);\n+      return output_btst (operands, GEN_INT (width - INTVAL (operands[2])),\n+\t\t\t  operands[0], insn, 1000);\n       /* Pass 1000 as SIGNPOS argument so that btst will\n          not think we are testing the sign bit for an `and'\n \t and assume that nonzero implies a negative result.  */\n@@ -1922,10 +1919,8 @@\n       && GET_CODE (operands[2]) == CONST_INT)\n     {    \n       int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n-      return output_btst (operands,\n-\t\t\t  GEN_INT (width - INTVAL (operands[2])),\n-\t\t\t  operands[0],\n-\t\t\t  insn, 1000);\n+      return output_btst (operands, GEN_INT (width - INTVAL (operands[2])),\n+\t\t\t  operands[0], insn, 1000);\n       /* Pass 1000 as SIGNPOS argument so that btst will\n          not think we are testing the sign bit for an `and'\n \t and assume that nonzero implies a negative result.  */\n@@ -2292,10 +2287,9 @@\n   table_elt_addr\n     = memory_address_noforce\n         (HImode,\n-\t gen_rtx (PLUS, Pmode,\n-\t\t  gen_rtx (MULT, Pmode, index_diff,\n-\t\t\t   GEN_INT (2)),\n-\t\t  gen_rtx (LABEL_REF, VOIDmode, operands[3])));\n+\t gen_rtx_PLUS (Pmode,\n+\t\t       gen_rtx_MULT (Pmode, index_diff, GEN_INT (2)),\n+\t\t       gen_rtx_LABEL_REF (Pmode, operands[3])));\n   /* Emit the last few insns.  */\n   emit_insn (gen_casesi_2 (gen_reg_rtx (HImode), table_elt_addr, operands[3]));\n   DONE;\n@@ -2508,7 +2502,7 @@\n ;  \"*\n ;{\n ;  rtx xoperands[2];\n-;  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+;  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n ;  output_asm_insn (\\\"mov%.l %1,%@\\\", xoperands);\n ;  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n ;  return \\\"fmove%.d %+,%0\\\";"}, {"sha": "306431cd118f4e95b7e77500826888186b27a17b", "filename": "gcc/config/gmicro/gmicro.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgmicro%2Fgmicro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgmicro%2Fgmicro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,9 +1,8 @@\n /* Subroutines for insn-output.c for the Gmicro.\n-   Ported by Masanobu Yuhara, Fujitsu Laboratories LTD.\n+   Copyright (C) 1990, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Contributed by Masanobu Yuhara, Fujitsu Laboratories LTD.\n    (yuhara@flab.fujitsu.co.jp)\n \n-   Copyright (C) 1990, 1991, 1997 Free Software Foundation, Inc.\n-\n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -24,9 +23,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -498,14 +496,14 @@ output_move_double (operands)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       output_asm_insn (\"sub.w %#8,%0\", operands);\n-      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      operands[0] = gen_rtx_MEM (DImode, operands[0]);\n       optype0 = OFFSOP;\n     }\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n       output_asm_insn (\"sub.w %#8,%1\", operands);\n-      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      operands[1] = gen_rtx_MEM (DImode, operands[1]);\n       optype1 = OFFSOP;\n     }\n \n@@ -528,14 +526,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n@@ -633,16 +631,14 @@ output_move_const_double (operands)\n   else if (GREG_P (operands[0])) \n     {\n       rtx xoperands[2];\n-      xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n       xoperands[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n       output_asm_insn (\"mov.w %1,%0\", xoperands);\n       operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n       return \"mov.w %1,%0\";\n     }\n   else \n-    {\n-      return output_move_double (operands); /* ?????? */\n-    }\n+    return output_move_double (operands); /* ?????? */\n }\n \n char *"}, {"sha": "529d3cc8fdf5d816968d96ec09eeed1e5ef8aba4", "filename": "gcc/config/gmicro/gmicro.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Gmicro (TRON) version.\n-   Copyright (C) 1987, 88, 89, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 95-98, 1999 Free Software Foundation, Inc.\n    Contributed by Masanobu Yuhara, Fujitsu Laboratories LTD.\n    (yuhara@flab.fujitsu.co.jp)\n \n@@ -477,9 +477,10 @@ extern enum reg_class regno_reg_class[];\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)\t\\\n-  (gen_rtx (REG, (MODE),\t\t\\\n-    ((TARGET_FPU && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0)))\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+  (gen_rtx_REG ((MODE),\t\t\t\t\t\t\t\\\n+\t\t((TARGET_FPU && ((MODE) == SFmode || (MODE) == DFmode))\t\\\n+\t\t ? 16 : 0)))\n \n \n /* 1 if N is a possible register number for a function value.\n@@ -546,7 +547,7 @@ extern enum reg_class regno_reg_class[];\n    It exists only to test register calling conventions.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+((TARGET_REGPARM && (CUM) < 8) ? gen_rtx_REG ((MODE), (CUM) / 4) : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -830,25 +831,25 @@ extern enum reg_class regno_reg_class[];\n   else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx) \\\n     { rtx other_reg = XEXP (ADDR, 1);\t\t\t\t\t\\\n       offset = 0;\t\t\t\t\t\t\t\\\n-      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n   else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 1) == frame_pointer_rtx) \\\n     { rtx other_reg = XEXP (ADDR, 0);\t\t\t\t\t\\\n       offset = 0;\t\t\t\t\t\t\t\\\n-      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n   else if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n \t   && GET_CODE (XEXP (ADDR, 0)) == PLUS\t\t\t\t\\\n \t   && XEXP (XEXP (ADDR, 0), 0) == frame_pointer_rtx\t\t\\\n \t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n     { rtx other_reg = XEXP (XEXP (ADDR, 0), 1);\t\t\t\t\\\n       offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n-      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n   else if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n \t   && GET_CODE (XEXP (ADDR, 0)) == PLUS\t\t\t\t\\\n \t   && XEXP (XEXP (ADDR, 0), 1) == frame_pointer_rtx\t\t\\\n \t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n     { rtx other_reg = XEXP (XEXP (ADDR, 0), 0);\t\t\t\t\\\n       offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n-      regs = gen_rtx (PLUS, Pmode, stack_pointer_rtx, other_reg); }\t\\\n+      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n   if (offset >= 0)\t\t\t\t\t\t\t\\\n     { int regno;\t\t\t\t\t\t\t\\\n       extern char call_used_regs[];\t\t\t\t\t\\"}, {"sha": "631b4b52ebe7e33b4d126c4fcff37c8205a29e99", "filename": "gcc/config/gmicro/gmicro.md", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler, Fujitsu Gmicro Version\n-;;  Copyright (C) 1990, 1994, 1996 Free Software Foundation, Inc.\n+;;  Copyright (C) 1990, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.\n ;;  Contributed by M.Yuhara, Fujitsu Laboratories LTD.\n \n ;; This file is part of GNU CC.\n@@ -581,7 +581,7 @@\n       if (FPU_REG_P (operands[0]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"mov.w %1,%-\\\", xoperands);\n \t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n \t  return \\\"fmov.d %+,%0\\\";\n@@ -590,7 +590,7 @@\n \t{\n \t  output_asm_insn (\\\"fmov.d %f1,%-\\\", operands);\n \t  output_asm_insn (\\\"mov.w %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  return \\\"mov.w %+,%0\\\";\n \t}\n     }\n@@ -616,7 +616,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"mov.w %1,%-\\\", xoperands);\n \t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n \t  return \\\"fmov.d %+,%0\\\";\n@@ -630,7 +630,7 @@\n       if (REG_P (operands[0]))\n \t{\n \t  output_asm_insn (\\\"fmov.d %f1,%-\\;mov.w %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  return \\\"mov.w %+,%0\\\";\n \t}\n       else\n@@ -1601,7 +1601,8 @@\n \t}\n       else\n         {\n-\t  operands[0] = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n+\t  operands[0]\n+\t    = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n \t  operands[1] = GEN_INT (7 - (logval % 8));\n \t}\n       return \\\"bset.b %1,%0\\\";\n@@ -1864,7 +1865,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1889,7 +1890,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, HImode, negate_rtx (HImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (HImode, negate_rtx (HImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1914,7 +1915,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -2270,7 +2271,7 @@\n     output_asm_insn (\\\"mov.w %1,%0\\\", operands);\n   if (INTVAL (operands[3]) != 0)\n     output_asm_insn (\\\"shl.w %3,%0\\\", operands);\n-  operands[2] = GEN_INT (-(32 - INTVAL (operands[2])));\n+  operands[2] = GEN_INT (- (32 - INTVAL (operands[2])));\n   return \\\"shl.w %3,%0\\\";\n }\")\n \n@@ -2730,7 +2731,7 @@\n   \"*\n {\n   rtx xoperands[2];\n-  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   output_asm_insn (\\\"mov.w %1,@sp\\\", xoperands);\n   output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n   return \\\"fmov.d %+,%0\\\";"}, {"sha": "26d2327e356b9f70286802768e42ed3cc3e5dbc4", "filename": "gcc/config/gofast.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgofast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fgofast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgofast.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* US Software GOFAST floating point library support.\n-   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -44,33 +44,33 @@ Boston, MA 02111-1307, USA.  */\n   } while (0)\n \n #define GOFAST_RENAME_LIBCALLS \\\n-  add_optab->handlers[(int) SFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpadd\"); \\\n-  add_optab->handlers[(int) DFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpadd\"); \\\n-  sub_optab->handlers[(int) SFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpsub\"); \\\n-  sub_optab->handlers[(int) DFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpsub\"); \\\n-  smul_optab->handlers[(int) SFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpmul\"); \\\n-  smul_optab->handlers[(int) DFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpmul\"); \\\n-  flodiv_optab->handlers[(int) SFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpdiv\"); \\\n-  flodiv_optab->handlers[(int) DFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpdiv\"); \\\n-  cmp_optab->handlers[(int) SFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n-  cmp_optab->handlers[(int) DFmode].libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n+  add_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpadd\"); \\\n+  add_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpadd\"); \\\n+  sub_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpsub\"); \\\n+  sub_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpsub\"); \\\n+  smul_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpmul\"); \\\n+  smul_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpmul\"); \\\n+  flodiv_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpdiv\"); \\\n+  flodiv_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpdiv\"); \\\n+  cmp_optab->handlers[(int) SFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  cmp_optab->handlers[(int) DFmode].libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n \\\n-  extendsfdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fptodp\"); \\\n-  truncdfsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dptofp\"); \\\n+  extendsfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fptodp\"); \\\n+  truncdfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dptofp\"); \\\n \\\n-  eqsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n-  nesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n-  gtsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n-  gesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n-  ltsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n-  lesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"fpcmp\"); \\\n+  eqsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  nesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  gtsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  gesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  ltsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n+  lesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"fpcmp\"); \\\n \\\n-  eqdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n-  nedf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n-  gtdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n-  gedf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n-  ltdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n-  ledf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"dpcmp\"); \\\n+  eqdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  nedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  gtdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  gedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  ltdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n+  ledf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"dpcmp\"); \\\n \\\n   eqxf2_libfunc = NULL_RTX; \\\n   nexf2_libfunc = NULL_RTX; \\"}, {"sha": "aa58157284cd96701dde97b22f765f2facb7f246", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -22,7 +22,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"regs.h\"\n@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Forward declarations.  */\n void print_operand_address ();\n-char *index ();\n \n static int h8300_interrupt_function_p PROTO ((tree));\n static int h8300_monitor_function_p PROTO ((tree));\n@@ -954,16 +953,16 @@ function_arg (cum, mode, type, named)\n \t  switch (cum->nbytes / UNITS_PER_WORD)\n \t    {\n \t    case 0:\n-\t      result = gen_rtx (REG, mode, 0);\n+\t      result = gen_rtx_REG (mode, 0);\n \t      break;\n \t    case 1:\n-\t      result = gen_rtx (REG, mode, 1);\n+\t      result = gen_rtx_REG (mode, 1);\n \t      break;\n \t    case 2:\n-\t      result = gen_rtx (REG, mode, 2);\n+\t      result = gen_rtx_REG (mode, 2);\n \t      break;\n \t    case 3:\n-\t      result = gen_rtx (REG, mode, 3);\n+\t      result = gen_rtx_REG (mode, 3);\n \t      break;\n \t    default:\n \t      result = 0;\n@@ -1858,12 +1857,14 @@ expand_a_shift (mode, code, operands)\n   /* need a loop to get all the bits we want  - we generate the\n      code at emit time, but need to allocate a scratch reg now  */\n \n-  emit_insn (gen_rtx\n-\t     (PARALLEL, VOIDmode,\n+  emit_insn (gen_rtx_PARALLEL\n+\t     (VOIDmode,\n \t      gen_rtvec (2,\n-\t\t\t gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\t  gen_rtx (code, mode, operands[0], operands[2])),\n-\t\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)))));\n+\t\t\t gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t      gen_rtx (code, mode, operands[0],\n+\t\t\t\t\t       operands[2])),\n+\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n \n   return 1;\n }\n@@ -2791,19 +2792,19 @@ fix_bit_operand (operands, what, type)\n \t  /* Ok to have a memory dest.  */\n \t  if (GET_CODE (operands[0]) == MEM && !EXTRA_CONSTRAINT (operands[0], 'U'))\n \t    {\n-\t      rtx mem;\n-\t      mem = gen_rtx (MEM, GET_MODE (operands[0]),\n-\t\t\t   copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+\t      rtx mem = gen_rtx_MEM (GET_MODE (operands[0]),\n+\t\t\t\t     copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t       XEXP (operands[0], 0)));\n \t      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[0]);\n \t      MEM_COPY_ATTRIBUTES (mem, operands[0]);\n \t      operands[0] = mem;\n \t    }\n \n \t  if (GET_CODE (operands[1]) == MEM && !EXTRA_CONSTRAINT (operands[1], 'U'))\n \t    {\n-\t      rtx mem;\n-\t      mem = gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t\t   copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+\t      rtx mem = gen_rtx_MEM (GET_MODE (operands[1]),\n+\t\t\t\t     copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t       XEXP (operands[1], 0)));\n \t      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[1]);\n \t      MEM_COPY_ATTRIBUTES (mem, operands[0]);\n \t      operands[1] = mem;\n@@ -2817,8 +2818,9 @@ fix_bit_operand (operands, what, type)\n   operands[1] = force_reg (QImode, operands[1]);\n   {\n     rtx res = gen_reg_rtx (QImode);\n-    emit_insn (gen_rtx (SET, VOIDmode, res, gen_rtx (type, QImode, operands[1], operands[2])));\n-    emit_insn (gen_rtx (SET, VOIDmode, operands[0], res));\n+    emit_insn (gen_rtx_SET (VOIDmode, res,\n+\t\t\t    gen_rtx (type, QImode, operands[1], operands[2])));\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], res));\n   }\n   return 1;\n }"}, {"sha": "9e8b68232f23e1e33ac30afef8c7cfbf7c0e19d0", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -526,15 +526,15 @@ enum reg_class {\n    On the H8 the return value is in R0/R1.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n /* On the h8 the return value is in R0/R1 */\n \n #define LIBCALL_VALUE(MODE) \\\n-  gen_rtx (REG, MODE, 0)\n+  gen_rtx_REG (MODE, 0)\n \n /* 1 if N is a possible register number for a function value.\n    On the H8, R0 is the only register thus used.  */\n@@ -713,10 +713,11 @@ struct rtx_def *function_arg();\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\t\\\n   enum machine_mode mode = TARGET_H8300H || TARGET_H8300S? SImode : HImode; \\\n-  emit_move_insn (gen_rtx (MEM, mode, plus_constant ((TRAMP), 2)), CXT);    \\\n-  emit_move_insn (gen_rtx (MEM, mode, plus_constant ((TRAMP), 6)), FNADDR); \\\n-  if (TARGET_H8300H || TARGET_H8300S)\t\t\t\t\t    \\\n-    emit_move_insn (gen_rtx (MEM, QImode, plus_constant ((TRAMP), 6)), GEN_INT (0x5A)); \\\n+  emit_move_insn (gen_rtx_MEM (mode, plus_constant ((TRAMP), 2)), CXT);    \\\n+  emit_move_insn (gen_rtx_MEM (mode, plus_constant ((TRAMP), 6)), FNADDR); \\\n+  if (TARGET_H8300H || TARGET_H8300S)\t\t\t\t\t   \\\n+    emit_move_insn (gen_rtx_MEM (QImode, plus_constant ((TRAMP), 6)),\t   \\\n+\t\t    GEN_INT (0x5A)); \t\t\t\t\t   \\\n }\n \f\n /* Addressing modes, and classification of registers for them.  */\n@@ -1387,15 +1388,15 @@ extern int handle_pragma ();\n #define INIT_TARGET_OPTABS \\\n   do { \\\n     smul_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, MULHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, MULHI3_LIBCALL);\t\\\n     sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, DIVHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, DIVHI3_LIBCALL);\t\\\n     udiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, UDIVHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, UDIVHI3_LIBCALL);\t\\\n     smod_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, MODHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, MODHI3_LIBCALL);\t\\\n     umod_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, UMODHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, UMODHI3_LIBCALL);\t\\\n   } while (0)\n \n #define MOVE_RATIO 3"}, {"sha": "d9954e3137efcede5204e2f6cf134e1e666240bc", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for System/370.\n-   Copyright (C) 1989, 1993, 1995, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 95, 97, 98, 1999 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n    Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n@@ -22,12 +22,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n-#include <string.h>\n-#include <ctype.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>  \n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"regs.h\"\n@@ -41,7 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"flags.h\"\n #include \"recog.h\"\n-#include <time.h>\n \n extern FILE *asm_out_file;\n "}, {"sha": "1e32e0102e48a0e37b9ae2afc5e8ced1ff2dc529", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 95, 96, 97, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n    Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n@@ -545,15 +545,15 @@ enum reg_class\n     (((MODE) == DCmode || (MODE) == SCmode || (MODE) == TFmode || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n-  gen_rtx(REG, TYPE_MODE (VALTYPE), RET_REG(TYPE_MODE(VALTYPE)))  \n+  gen_rtx_REG (TYPE_MODE (VALTYPE), RET_REG (TYPE_MODE (VALTYPE)))\n \n #define RETURN_IN_MEMORY(VALTYPE)  \\\n   ((DImode == TYPE_MODE (VALTYPE)) || (BLKmode == TYPE_MODE (VALTYPE)))\n \n /* Define how to find the value returned by a library function assuming\n    the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx(REG, MODE, RET_REG(MODE))\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, RET_REG (MODE))\n \n /* 1 if N is a possible register number for a function value.\n    On the 370 under C/370, R15 and R16 are thus used.  */\n@@ -585,13 +585,12 @@ enum reg_class\n \n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x05E0));\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x5800 | \t\\\n-\t\t\t   STATIC_CHAIN_REGNUM << 4));\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xE00A));\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x58F0)); \t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xE00E));\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x07FF));\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x05E0));\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0xE00A));\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x58F0)); \t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0xE00E));\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x07FF));\t\t\t\t\\\n   ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n   ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n   ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n@@ -606,8 +605,8 @@ enum reg_class\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n }\n \n /* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n@@ -792,17 +791,17 @@ enum reg_class\n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n   if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), 0));\t\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\t\\\n   if (memory_address_p (MODE, X))\t\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n }"}, {"sha": "f08812bbc3bffb8b827ec986228961d5cd7a4f7f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1441,11 +1441,11 @@ static rtx\n gen_push (arg)\n      rtx arg;\n {\n-  return gen_rtx (SET, VOIDmode,\n-\t\t  gen_rtx_MEM (SImode,\n-\t\t\t       gen_rtx (PRE_DEC, SImode,\n-\t\t\t\t\tstack_pointer_rtx)),\n-\t\t  arg);\n+  return gen_rtx_SET (VOIDmode,\n+\t\t      gen_rtx_MEM (SImode,\n+\t\t\t\t   gen_rtx_PRE_DEC (SImode,\n+\t\t\t\t\t\t    stack_pointer_rtx)),\n+\t\t      arg);\n }\n \n /* Compute the size of local storage taking into consideration the\n@@ -2239,19 +2239,19 @@ legitimize_address (x, oldx, mode)\n \t  && (log = (unsigned)exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)))) < 4)\n \t{\n \t  changed = 1;\n-\t  XEXP (x, 0) = gen_rtx (MULT, Pmode,\n-\t\t\t\t force_reg (Pmode, XEXP (XEXP (x, 0), 0)),\n-\t\t\t\t GEN_INT (1 << log));\n+\t  XEXP (x, 0) = gen_rtx_MULT (Pmode,\n+\t\t\t\t      force_reg (Pmode, XEXP (XEXP (x, 0), 0)),\n+\t\t\t\t      GEN_INT (1 << log));\n \t}\n \n       if (GET_CODE (XEXP (x, 1)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n \t  && (log = (unsigned)exact_log2 (INTVAL (XEXP (XEXP (x, 1), 1)))) < 4)\n \t{\n \t  changed = 1;\n-\t  XEXP (x, 1) = gen_rtx (MULT, Pmode,\n-\t\t\t\t force_reg (Pmode, XEXP (XEXP (x, 1), 0)),\n-\t\t\t\t GEN_INT (1 << log));\n+\t  XEXP (x, 1) = gen_rtx_MULT (Pmode,\n+\t\t\t\t      force_reg (Pmode, XEXP (XEXP (x, 1), 0)),\n+\t\t\t\t      GEN_INT (1 << log));\n \t}\n \n       /* Put multiply first if it isn't already. */\n@@ -2270,10 +2270,10 @@ legitimize_address (x, oldx, mode)\n       if (GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == PLUS)\n \t{\n \t  changed = 1;\n-\t  x = gen_rtx (PLUS, Pmode,\n-\t\t       gen_rtx (PLUS, Pmode, XEXP (x, 0),\n-\t\t\t\tXEXP (XEXP (x, 1), 0)),\n-\t\t       XEXP (XEXP (x, 1), 1));\n+\t  x = gen_rtx_PLUS (Pmode,\n+\t\t\t    gen_rtx_PLUS (Pmode, XEXP (x, 0),\n+\t\t\t\t\t  XEXP (XEXP (x, 1), 0)),\n+\t\t\t    XEXP (XEXP (x, 1), 1));\n \t}\n \n       /* Canonicalize\n@@ -2303,10 +2303,10 @@ legitimize_address (x, oldx, mode)\n \t  if (constant)\n \t    {\n \t      changed = 1;\n-\t      x = gen_rtx (PLUS, Pmode,\n-\t\t\t   gen_rtx (PLUS, Pmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 1), 0)),\n-\t\t\t   plus_constant (other, INTVAL (constant)));\n+\t      x = gen_rtx_PLUS (Pmode,\n+\t\t\t\tgen_rtx_PLUS (Pmode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t      XEXP (XEXP (XEXP (x, 0), 1), 0)),\n+\t\t\t\tplus_constant (other, INTVAL (constant)));\n \t    }\n \t}\n "}, {"sha": "eebd336d80bfc73244f42977a320b74d3836f926", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1103,7 +1103,7 @@ enum reg_class\n    otherwise, FUNC is 0.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n    gen_rtx_REG (TYPE_MODE (VALTYPE), \\\n-\t    VALUE_REGNO (TYPE_MODE (VALTYPE)))\n+\t\tVALUE_REGNO (TYPE_MODE (VALTYPE)))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n@@ -2168,12 +2168,12 @@ number as al, and ax.\n /* Before the prologue, RA is at 0(%esp).  */\n #define INCOMING_RETURN_ADDR_RTX \\\n   gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n-\n+ \n /* After the prologue, RA is at -4(AP) in the current frame.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n   ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, arg_pointer_rtx, GEN_INT(-4)))\\\n-   : gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, (FRAME), GEN_INT(4))))\n+   ? gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -4))\\\n+   : gen_rtx_MEM (Pmode, plus_constant (FRAME, 4)))\n \n /* PC is dbx register 8; let's use that column for RA. */\n #define DWARF_FRAME_RETURN_COLUMN \t8"}, {"sha": "5ec2448593c6a7b89a25df1fca7f8be88994cdbb", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -70,14 +70,6 @@ do {\t\t\t\t\t\t\\\n   char c;\t\t\t\t\t\\\n \t\t\t\t\t\t\\\n   putc ('\\\"', asm_file);\t\t\t\\\n-  if (STRING[1] == ':'\t\t\t\t\\\n-      && (STRING[2] == '/' || STRING[2] == '\\\\')) \\\n-    {\t\t\t\t\t\t\\\n-      putc ('/', asm_file);\t\t\t\\\n-      putc ('/', asm_file);\t\t\t\\\n-      putc (*string, asm_file);\t\t\t\\\n-      string += 2;\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n \t\t\t\t\t\t\\\n   while ((c = *string++) != 0)\t\t\t\\\n     {\t\t\t\t\t\t\\"}, {"sha": "f75fe1f46c038d46908f1f2ccdf51eb4f17f488a", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    Intel 386 (OSF/1 with OSF/rose) version.\n-   Copyright (C) 1991, 1992, 1993, 1996, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 92, 93, 96, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -217,8 +217,8 @@ do\t\t\t\t\t\t\t\t\t\\\n \t    rtx symref;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t    HALF_PIC_EXTERNAL (\"_mcount_ptr\");\t\t\t\t\\\n-\t    symref = HALF_PIC_PTR (gen_rtx (SYMBOL_REF, Pmode,\t\t\\\n-\t\t\t\t\t    \"_mcount_ptr\"));\t\t\\\n+\t    symref = HALF_PIC_PTR (gen_rtx_SYMBOL_REF (Pmode,\t\t\\\n+\t\t\t\t\t\t       \"_mcount_ptr\"));\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n \t    fprintf (FILE, \"\\tmovl %s%s,%%eax\\n\", prefix,\t\t\\\n@@ -290,7 +290,7 @@ do\t\t\t\t\t\t\t\t\t\\\n \t    rtx symdef;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t    HALF_PIC_EXTERNAL (\"mcount\");\t\t\t\t\\\n-\t    symdef = HALF_PIC_PTR (gen_rtx (SYMBOL_REF, Pmode, \"mcount\")); \\\n+\t    symdef = HALF_PIC_PTR (gen_rtx_SYMBOL_REF (Pmode, \"mcount\")); \\\n \t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n \t    fprintf (FILE, \"\\tcall *%s%s\\n\", prefix, XSTR (symdef, 0));\t\\\n \t  }\t\t\t\t\t\t\t\t\\"}, {"sha": "262c3afee275ed4def6f674043df19e447f059f1", "filename": "gcc/config/i386/win-nt.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi386%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwin-nt.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Operating system specific defines to be used when targeting GCC for\n    Windows NT 3.x on an i386.\n-   Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (drupp@cs.washington.edu).\n \n This file is part of GNU CC.\n@@ -118,7 +118,7 @@ do\t\t\t\t\t\t\t\t\t\\\n       if (lookup_attribute (\"stdcall\",\t\t\t\t\t\\\n \t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (DECL))))\t\\\n         XEXP (DECL_RTL (DECL), 0) = \t\t\t\t\t\\\n-          gen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (DECL)); \t\\\n+          gen_rtx_SYMBOL_REF (Pmode, gen_stdcall_suffix (DECL)); \t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n #endif"}, {"sha": "d55e912f2e0dbea4df63bff086c6c50013604d8e", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -26,7 +26,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n@@ -522,7 +522,7 @@ singlemove_string (operands)\n \t  rtx xoperands[2];\n \n \t  cc_status.flags &= ~CC_F0_IS_0;\n-\t  xoperands[0] = gen_rtx (REG, SFmode, 32);\n+\t  xoperands[0] = gen_rtx_REG (SFmode, 32);\n \t  xoperands[1] = operands[1];\n \t  output_asm_insn (singlemove_string (xoperands), xoperands);\n \t  xoperands[1] = xoperands[0];\n@@ -627,14 +627,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n@@ -693,7 +693,7 @@ output_move_double (operands)\n \t  xops[0] = latehalf[0];\n \t  xops[1] = operands[0];\n \t  output_asm_insn (\"adds %1,%0,%1\", xops);\n-\t  operands[1] = gen_rtx (MEM, DImode, operands[0]);\n+\t  operands[1] = gen_rtx_MEM (DImode, operands[0]);\n \t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n \t  addreg1 = 0;\n \t  highest_first = 1;\n@@ -747,7 +747,7 @@ output_fp_move_double (operands)\n   /* If the source operand is any sort of zero, use f0 instead.  */\n \n   if (operands[1] == CONST0_RTX (GET_MODE (operands[1])))\n-    operands[1] = gen_rtx (REG, DFmode, F0_REGNUM);\n+    operands[1] = gen_rtx_REG (DFmode, F0_REGNUM);\n \n   if (FP_REG_P (operands[0]))\n     {\n@@ -756,8 +756,8 @@ output_fp_move_double (operands)\n       if (GET_CODE (operands[1]) == REG)\n \t{\n \t  output_asm_insn (\"ixfr %1,%0\", operands);\n-\t  operands[0] = gen_rtx (REG, VOIDmode, REGNO (operands[0]) + 1);\n-\t  operands[1] = gen_rtx (REG, VOIDmode, REGNO (operands[1]) + 1);\n+\t  operands[0] = gen_rtx_REG (VOIDmode, REGNO (operands[0]) + 1);\n+\t  operands[1] = gen_rtx_REG (VOIDmode, REGNO (operands[1]) + 1);\n \t  return \"ixfr %1,%0\";\n \t}\n       if (operands[1] == CONST0_RTX (DFmode))\n@@ -782,8 +782,8 @@ output_fp_move_double (operands)\n       if (GET_CODE (operands[0]) == REG)\n \t{\n \t  output_asm_insn (\"fxfr %1,%0\", operands);\n-\t  operands[0] = gen_rtx (REG, VOIDmode, REGNO (operands[0]) + 1);\n-\t  operands[1] = gen_rtx (REG, VOIDmode, REGNO (operands[1]) + 1);\n+\t  operands[0] = gen_rtx_REG (VOIDmode, REGNO (operands[0]) + 1);\n+\t  operands[1] = gen_rtx_REG (VOIDmode, REGNO (operands[1]) + 1);\n \t  return \"fxfr %1,%0\";\n \t}\n       if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n@@ -1116,8 +1116,7 @@ output_size_for_block_move (size, reg, align)\n     output_asm_insn (\"sub %2,%1,%0\", xoperands);\n   else\n     {\n-      xoperands[1]\n-\t= GEN_INT (INTVAL (size) - INTVAL (align));\n+      xoperands[1] = GEN_INT (INTVAL (size) - INTVAL (align));\n       cc_status.flags &= ~ CC_KNOW_HI_R31;\n       output_asm_insn (\"mov %1,%0\", xoperands);\n     }\n@@ -1432,8 +1431,8 @@ output_delayed_branch (template, operands, insn)\n   else\n     {\n       int insn_code_number;\n-      rtx pat = gen_rtx (SET, VOIDmode, dest, src);\n-      rtx delay_insn = gen_rtx (INSN, VOIDmode, 0, 0, 0, pat, -1, 0, 0);\n+      rtx pat = gen_rtx_SET (VOIDmode, dest, src);\n+      rtx delay_insn = gen_rtx_INSN (VOIDmode, 0, 0, 0, pat, -1, 0, 0);\n       int i;\n \n       /* Output the branch instruction first.  */"}, {"sha": "107849d63cd0d89ffc6a281389c7a5f04f6032e8", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Intel 860.\n-   Copyright (C) 1989, 91, 93, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 91, 93, 95-98, 1999 Free Software Foundation, Inc.\n    Hacked substantially by Ron Guilmette (rfg@monkeys.com) to cater to\n    the whims of the System V Release 4 assembler.\n \n@@ -428,17 +428,17 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* On the i860, the value register depends on the mode.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE),\t\t\t\t\\\n-\t   (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT\t\\\n-\t    ? 40 : 16))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\\\n+\t       (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT\t\\\n+\t\t? 40 : 16))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE)\t\t\t\t\\\n-  gen_rtx (REG, MODE,\t\t\t\t\t\\\n-\t   (GET_MODE_CLASS ((MODE)) == MODE_FLOAT\t\\\n-\t    ? 40 : 16))\n+  gen_rtx_REG (MODE,\t\t\t\t\t\\\n+\t       (GET_MODE_CLASS ((MODE)) == MODE_FLOAT\t\\\n+\t\t? 40 : 16))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -523,17 +523,17 @@ struct cumulative_args { int ints, floats; };\n   ? 0\t\t\t\t\t\t\t\\\n   : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n   ? (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE))) < 32\t\\\n-     ? gen_rtx (REG, (MODE),\t\t\t\t\\\n-\t\t40+(ROUNDUP ((CUM).floats,\t\t\\\n-\t\t\t     GET_MODE_SIZE ((MODE)))\t\\\n-\t\t    / 4))\t\t\t\t\\\n+     ? gen_rtx_REG ((MODE),\t\t\t\t\\\n+\t\t    40 + (ROUNDUP ((CUM).floats,\t\\\n+\t\t\t\t   GET_MODE_SIZE ((MODE)))\t\\\n+\t\t\t  / 4))\t\t\t\t\\\n      : 0)\t\t\t\t\t\t\\\n   : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\\\n   ? (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) < 48\t\\\n-     ? gen_rtx (REG, (MODE),\t\t\t\t\\\n-\t\t16+(ROUNDUP ((CUM).ints,\t\t\\\n-\t\t\t     GET_MODE_SIZE ((MODE)))\t\\\n-\t\t    / 4))\t\t\t\t\\\n+     ? gen_rtx_REG ((MODE),\t\t\t\t\\\n+\t\t    16 + (ROUNDUP ((CUM).ints,\t\t\\\n+\t\t\t\t   GET_MODE_SIZE ((MODE)))\t\\\n+\t\t\t  / 4))\t\t\t\t\\\n      : 0)\t\t\t\t\t\t\\\n   : 0)\n \n@@ -660,13 +660,13 @@ struct cumulative_args { int ints, floats; };\n \t\t\t     size_int (16), 0, 0);\t\t\t\\\n   rtx hi_fn = expand_shift (RSHIFT_EXPR, SImode, fn,\t\t\t\\\n \t\t\t    size_int (16), 0, 0);\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 16)),\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 16)),\t\\\n \t\t  gen_lowpart (HImode, cxt));\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 4)),\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 4)),\t\\\n \t\t  gen_lowpart (HImode, fn));\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 8)),\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 8)),\t\\\n \t\t  gen_lowpart (HImode, hi_cxt));\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 0)),\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 0)),\t\\\n \t\t  gen_lowpart (HImode, hi_fn));\t\t\t\t\\\n }\n \f\n@@ -819,25 +819,25 @@ struct cumulative_args { int ints, floats; };\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n { if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) != REG\t\\\n       && GET_CODE (XEXP (X, 0)) != CONST_INT)\t\t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) != REG\t\\\n       && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n   if (GET_CODE (x) == SYMBOL_REF)\t\t\t\t\\\n     (X) = copy_to_reg (X);\t\t\t\t\t\\\n   if (GET_CODE (x) == CONST)\t\t\t\t\t\\"}, {"sha": "59b0b6d144e482f436e4114298d7920a2f2fea35", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for Intel 860 chip for GNU C compiler\n-;;   Copyright (C) 1989, 1990, 1997 Free Software Foundation, Inc.\n+;;  Copyright (C) 1989, 1990, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1527,7 +1527,7 @@\n   \"*\n {\n   CC_STATUS_PARTIAL_INIT;\n-  operands[2] = GEN_INT ((INTVAL (operands[2]) << INTVAL (operands[1])));\n+  operands[2] = GEN_INT (INTVAL (operands[2]) << INTVAL (operands[1]));\n   return \\\"and %2,%0,%?r0\\\";\n }\")\n \n@@ -1542,7 +1542,7 @@\n   \"*\n {\n   CC_STATUS_PARTIAL_INIT;\n-  operands[2] = GEN_INT ((INTVAL (operands[2]) << INTVAL (operands[1])));\n+  operands[2] = GEN_INT (INTVAL (operands[2]) << INTVAL (operands[1]));\n   return \\\"and %2,%0,%?r0\\\";\n }\")\n \f\n@@ -1766,14 +1766,15 @@\n     return \\\"and %2,%1,%0\\\";\n   if ((INTVAL (operands[2]) & 0xffff) == 0)\n     {\n-      operands[2] = GEN_INT ((unsigned) INTVAL (operands[2]) >> 16);\n+      operands[2]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n       return \\\"andh %2,%1,%0\\\";\n     }\n   xop[0] = operands[0];\n   xop[1] = operands[1];\n   xop[2] = GEN_INT (~INTVAL (operands[2]) & 0xffff);\n   output_asm_insn (\\\"andnot %2,%1,%0\\\", xop);\n-  operands[2] = GEN_INT (~(unsigned) INTVAL (operands[2]) >> 16);\n+  operands[2] = GEN_INT (~(unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n   return \\\"andnoth %2,%0,%0\\\";\n }\")\n \n@@ -1791,14 +1792,15 @@\n     return \\\"andnot %1,%2,%0\\\";\n   if ((INTVAL (operands[1]) & 0xffff) == 0)\n     {\n-      operands[1] = GEN_INT ((unsigned) INTVAL (operands[1]) >> 16);\n+      operands[1]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[1]) >> 16);\n       return \\\"andnoth %1,%2,%0\\\";\n     }\n   xop[0] = operands[0];\n-  xop[1] = GEN_INT ((INTVAL (operands[1]) & 0xffff));\n+  xop[1] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n   xop[2] = operands[2];\n   output_asm_insn (\\\"andnot %1,%2,%0\\\", xop);\n-  operands[1] = GEN_INT ((unsigned) INTVAL (operands[1]) >> 16);\n+  operands[1] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[1]) >> 16);\n   return \\\"andnoth %1,%0,%0\\\";\n }\")\n \n@@ -1816,14 +1818,15 @@\n     return \\\"or %2,%1,%0\\\";\n   if ((INTVAL (operands[2]) & 0xffff) == 0)\n     {\n-      operands[2] = GEN_INT ((unsigned) INTVAL (operands[2]) >> 16);\n+      operands[2]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n       return \\\"orh %2,%1,%0\\\";\n     }\n   xop[0] = operands[0];\n   xop[1] = operands[1];\n-  xop[2] = GEN_INT ((INTVAL (operands[2]) & 0xffff));\n+  xop[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n   output_asm_insn (\\\"or %2,%1,%0\\\", xop);\n-  operands[2] = GEN_INT ((unsigned) INTVAL (operands[2]) >> 16);\n+  operands[2] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n   return \\\"orh %2,%0,%0\\\";\n }\")\n \n@@ -1841,14 +1844,15 @@\n     return \\\"xor %2,%1,%0\\\";\n   if ((INTVAL (operands[2]) & 0xffff) == 0)\n     {\n-      operands[2] = GEN_INT ((unsigned) INTVAL (operands[2]) >> 16);\n+      operands[2]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n       return \\\"xorh %2,%1,%0\\\";\n     }\n   xop[0] = operands[0];\n   xop[1] = operands[1];\n-  xop[2] = GEN_INT ((INTVAL (operands[2]) & 0xffff));\n+  xop[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n   output_asm_insn (\\\"xor %2,%1,%0\\\", xop);\n-  operands[2] = GEN_INT ((unsigned) INTVAL (operands[2]) >> 16);\n+  operands[2] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n   return \\\"xorh %2,%0,%0\\\";\n }\")\n \n@@ -2121,7 +2125,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   if (INTVAL (operands[1]) > 0)\n     {\n       emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n-      emit_insn (gen_rtx (USE, VOIDmode, arg_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, arg_pointer_rtx));\n     }\n }\")\n \n@@ -2189,7 +2193,7 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   if (INTVAL (operands[2]) > 0)\n     {\n       emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n-      emit_insn (gen_rtx (USE, VOIDmode, arg_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, arg_pointer_rtx));\n     }\n }\")\n "}, {"sha": "fa98ad4c4d04ab6c2fbb4ce576332a164bface1c", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -23,7 +23,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -507,9 +507,9 @@ gen_compare_reg (code, x, y)\n \ty = force_reg (SImode, y);\n     }\n \n-  cc_reg = gen_rtx (REG, ccmode, 36);\n-  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n-\t\t      gen_rtx (COMPARE, ccmode, x, y)));\n+  cc_reg = gen_rtx_REG (ccmode, 36);\n+  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n+\t\t\t  gen_rtx_COMPARE (ccmode, x, y)));\n \n   return cc_reg;\n }\n@@ -608,12 +608,12 @@ emit_move_sequence (operands, mode)\n       && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n       && ! HARD_REGNO_MODE_OK (REGNO (operands[1]), mode))\n     {\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t  gen_rtvec (2,\n-\t\t\t\t     gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t      operands[0], operands[1]),\n-\t\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t      gen_rtx (SCRATCH, Pmode)))));\n+      emit_insn (gen_rtx_PARALLEL\n+\t\t (VOIDmode,\n+\t\t  gen_rtvec (2,\n+\t\t\t     gen_rtx_SET (VOIDmode, operands[0], operands[1]),\n+\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t      gen_rtx_SCRATCH (Pmode)))));\n       return 1;\n     }\n \n@@ -664,8 +664,8 @@ i960_output_move_double (dst, src)\n \t     edge conditions.  */\n \t  operands[0] = dst;\n \t  operands[1] = src;\n-\t  operands[2] = gen_rtx (REG, Pmode, REGNO (dst) + 1);\n-\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+\t  operands[2] = gen_rtx_REG (Pmode, REGNO (dst) + 1);\n+\t  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n \t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n \t  output_asm_insn (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\", operands);\n \t  return \"\";\n@@ -754,8 +754,8 @@ i960_output_move_quad (dst, src)\n \t     edge conditions.  */\n \t  operands[0] = dst;\n \t  operands[1] = src;\n-\t  operands[2] = gen_rtx (REG, Pmode, REGNO (dst) + 3);\n-\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+\t  operands[2] = gen_rtx_REG (Pmode, REGNO (dst) + 3);\n+\t  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n \t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n \t  operands[5] = adj_offsettable_operand (operands[4], UNITS_PER_WORD);\n \t  operands[6] = adj_offsettable_operand (operands[5], UNITS_PER_WORD);\n@@ -844,7 +844,7 @@ i960_output_ldconst (dst, src)\n \n       for (i = 0; i < 3; i++)\n \t{\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (dst) + i);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (dst) + i);\n \t  operands[1] = GEN_INT (value_long[i]);\n \t  output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n \t\t\t   operands);\n@@ -863,11 +863,11 @@ i960_output_ldconst (dst, src)\n \n       output_asm_insn (\"# ldconst\t%1,%0\",operands);\n \n-      operands[0] = gen_rtx (REG, SImode, REGNO (dst));\n+      operands[0] = gen_rtx_REG (SImode, REGNO (dst));\n       operands[1] = first;\n       output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n \t\t      operands);\n-      operands[0] = gen_rtx (REG, SImode, REGNO (dst) + 1);\n+      operands[0] = gen_rtx_REG (SImode, REGNO (dst) + 1);\n       operands[1] = second;\n       output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n \t\t      operands);\n@@ -882,7 +882,7 @@ i960_output_ldconst (dst, src)\n       REAL_VALUE_TO_TARGET_SINGLE (d, value);\n \n       output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-      operands[0] = gen_rtx (REG, SImode, REGNO (dst));\n+      operands[0] = gen_rtx_REG (SImode, REGNO (dst));\n       operands[1] = GEN_INT (value);\n       output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n \t\t      operands);\n@@ -918,7 +918,7 @@ i960_output_ldconst (dst, src)\n \treturn \"movl\t%1,%0\";\n \n       /* Output the upper half with a recursive call.  */\n-      xoperands[0] = gen_rtx (REG, SImode, REGNO (dst) + 1);\n+      xoperands[0] = gen_rtx_REG (SImode, REGNO (dst) + 1);\n       xoperands[1] = upperhalf;\n       output_asm_insn (i960_output_ldconst (xoperands[0], xoperands[1]),\n \t\t       xoperands);\n@@ -2144,9 +2144,9 @@ legitimize_address (x, oldx, mode)\n      similar optimizations.  */\n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (x, 1)) == PLUS)\n-    x = gen_rtx (PLUS, Pmode,\n-\t\t gen_rtx (PLUS, Pmode, XEXP (x, 0), XEXP (XEXP (x, 1), 0)),\n-\t\t XEXP (XEXP (x, 1), 1));\n+    x = gen_rtx_PLUS (Pmode,\n+\t\t      gen_rtx_PLUS (Pmode, XEXP (x, 0), XEXP (XEXP (x, 1), 0)),\n+\t\t      XEXP (XEXP (x, 1), 1));\n \n   /* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const)\n      into (plus (plus (mult (reg) (const)) (reg)) (const)).  */\n@@ -2171,10 +2171,10 @@ legitimize_address (x, oldx, mode)\n \tconstant = 0;\n \n       if (constant)\n-\tx = gen_rtx (PLUS, Pmode,\n-\t\t     gen_rtx (PLUS, Pmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t      XEXP (XEXP (XEXP (x, 0), 1), 0)),\n-\t\t     plus_constant (other, INTVAL (constant)));\n+\tx = gen_rtx_PLUS (Pmode,\n+\t\t\t  gen_rtx_PLUS (Pmode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\tXEXP (XEXP (XEXP (x, 0), 1), 0)),\n+\t\t\t  plus_constant (other, INTVAL (constant)));\n     }\n \n   return x;\n@@ -2483,7 +2483,7 @@ i960_function_arg (cum, mode, type, named)\n   else\n     {\n       cum->ca_nregparms = ROUND_PARM (cum->ca_nregparms, align);\n-      ret = gen_rtx (REG, mode, cum->ca_nregparms);\n+      ret = gen_rtx_REG (mode, cum->ca_nregparms);\n     }\n \n   return ret;\n@@ -2615,17 +2615,17 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t va_start assumes it.  */\n       emit_insn (gen_cmpsi (arg_pointer_rtx, const0_rtx));\n       emit_jump_insn (gen_bne (label));\n-      emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n-\t\t\t  stack_pointer_rtx));\n-      emit_insn (gen_rtx (SET, VOIDmode, stack_pointer_rtx,\n-\t\t\t  memory_address (SImode,\n-\t\t\t\t\t  plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t 48))));\n+      emit_insn (gen_rtx_SET (VOIDmode, arg_pointer_rtx,\n+\t\t\t      stack_pointer_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      memory_address (SImode,\n+\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t     48))));\n       emit_label (label);\n \n       /* ??? Note that we unnecessarily store one extra register for stdarg\n-\t fns.  We could optimize this, but it's kept as-is for now.  */\n-      regblock = gen_rtx (MEM, BLKmode,\n+\t fns.  We could optimize this, but it's kept as for now.  */\n+      regblock = gen_rtx_MEM (BLKmode,\n \t\t\t  plus_constant (arg_pointer_rtx,\n \t\t\t\t\t first_reg * 4));\n       MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();"}, {"sha": "63be254fda63e05a2e56e423e9c105f8081449dc", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -831,7 +831,7 @@ enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE) gen_rtx ((REG), (MODE), 0)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG ((MODE), 0)\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.\n@@ -947,7 +947,7 @@ extern struct rtx_def *i960_function_arg ();\n    otherwise, FUNC is 0.  */\n \n #define FUNCTION_VALUE(TYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (TYPE), 0)\n+  gen_rtx_REG (TYPE_MODE (TYPE), 0)\n \n /* Force aggregates and objects larger than 16 bytes to be returned in memory,\n    since we only have 4 registers available for return values.  */\n@@ -1583,10 +1583,8 @@ extern struct rtx_def *gen_compare_reg ();\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)),\t\\\n-\t\t  FNADDR);\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)),\t\\\n-\t\t  CXT);\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n }\n \n /* Generate RTL to flush the register windows so as to make arbitrary frames"}, {"sha": "616e97939bd3e929d8dce3b58bb3f26b721e63f3", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -875,7 +875,7 @@\n   if (which_alternative == 0)\n     return i960_output_move_double (operands[0], operands[1]);\n     \n-  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n   operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n   return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\\";\n }\"\n@@ -954,7 +954,7 @@\n   if (which_alternative == 0)\n     return i960_output_move_quad (operands[0], operands[1]);\n \n-  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n   operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n   operands[5] = adj_offsettable_operand (operands[4], UNITS_PER_WORD);\n   operands[6] = adj_offsettable_operand (operands[5], UNITS_PER_WORD);\n@@ -1266,7 +1266,7 @@\n \t  operand0 = SUBREG_REG (operand0);\n \t}\n       if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx (SUBREG, SImode, operand0, op0_subreg_word);\n+\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_word);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n       emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n@@ -1387,7 +1387,7 @@\n \t  operand0 = SUBREG_REG (operand0);\n \t}\n       if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx (SUBREG, SImode, operand0, op0_subreg_word);\n+\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_word);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n       emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n@@ -1470,11 +1470,12 @@\n   \"\n {\n   rtx temp = gen_reg_rtx (DImode);\n-  emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t      gen_rtx (UNSIGNED_FIX, DImode,\n-\t\t\t       gen_rtx (FIX, DFmode, operands[1]))));\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t      gen_rtx (SUBREG, SImode, temp, 0)));\n+  emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t  gen_rtx_UNSIGNED_FIX (DImode,\n+\t\t\t\t\t\tgen_rtx_FIX (DFmode,\n+\t\t\t\t\t\t\t     operands[1]))));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_SUBREG (SImode, temp, 0)));\n   DONE;\n }\")\n \n@@ -1492,11 +1493,12 @@\n   \"\n {\n   rtx temp = gen_reg_rtx (DImode);\n-  emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t      gen_rtx (UNSIGNED_FIX, DImode,\n-\t\t\t       gen_rtx (FIX, SFmode, operands[1]))));\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t      gen_rtx (SUBREG, SImode, temp, 0)));\n+  emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t  gen_rtx_UNSIGNED_FIX (DImode,\n+\t\t\t\t\t\tgen_rtx_FIX (SFmode,\n+\t\t\t\t\t\t\t     operands[1]))));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_SUBREG (SImode, temp, 0)));\n   DONE;\n }\")\n \f"}, {"sha": "8bc569863efad5ca552ae369f7701c3bbdc5552d", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on the Mitsubishi M32R cpu.\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -938,18 +938,15 @@ m32r_select_cc_mode (op, x, y)\n    than being susummed into the following branch instruction. */\n \n rtx\n-gen_compare (int_code, x, y, need_compare)\n-     int\t   int_code;\n-     rtx           x;\n-     rtx           y;\n-     int           need_compare;\n+gen_compare (code, x, y, need_compare)\n+     enum rtx_code code;\n+     rtx x, y;\n+     int need_compare;\n {\n-  enum rtx_code     code = (enum rtx_code)int_code;\n-  enum rtx_code     compare_code;\n-  enum rtx_code     branch_code;\n-  enum machine_mode mode      = SELECT_CC_MODE (code, x, y);\n-  rtx               cc_reg    = gen_rtx (REG, mode, CARRY_REGNUM);\n-  int               must_swap = 0;\n+  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  enum rtx_code compare_code, branch_code;\n+  rtx cc_reg = gen_rtx_REG (mode, CARRY_REGNUM);\n+  int swap_p = 0;\n \n   switch (code)\n     {\n@@ -1336,9 +1333,9 @@ m32r_setup_incoming_varargs (cum, int_mode, type, pretend_size, no_rtl)\n       int size = M32R_MAX_PARM_REGS - first_reg_offset;\n       rtx regblock;\n \n-      regblock = gen_rtx (MEM, BLKmode,\n-\t\t\t  plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t FIRST_PARM_OFFSET (0)));\n+      regblock = gen_rtx_MEM (BLKmode,\n+\t\t\t      plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t     FIRST_PARM_OFFSET (0)));\n       MEM_ALIAS_SET (regblock) = get_varargs_alias_set ();\n       move_block_from_reg (first_reg_offset, regblock,\n \t\t\t   size, size * UNITS_PER_WORD);"}, {"sha": "7cad6c0f71b852b0e5571e0e47d9dfef7e3b8eea", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, Mitsubishi M32R cpu.\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -706,10 +706,12 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n /* The current return address is in r14.  */\n #if 0 /* The default value should work.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME) \\\n-(((COUNT) == -1)\t\t\t\t\\\n- ? gen_rtx (REG, Pmode, 14)\t\t\t\\\n- : copy_to_reg (gen_rtx (MEM, Pmode,\t\t\\\n-\t\t\t memory_address (Pmode, plus_constant ((FRAME), UNITS_PER_WORD)))))\n+(((COUNT) == -1)\t\t\t\t\t\t\t\\\n+ ? gen_rtx_REG (Pmode, 14)\t\t\t\t\t\t\\\n+ : copy_to_reg (gen_rtx_MEM (Pmode,\t\t\t\t\t\\\n+\t\t\t     memory_address (Pmode,\t\t\t\\\n+\t\t\t\t\t     plus_constant ((FRAME),\t\\\n+\t\t\t\t\t\t\t    UNITS_PER_WORD)))))\n #endif\n \n /* Register to use for pushing function arguments.  */\n@@ -918,14 +920,14 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    and the rest are pushed.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n (PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED))\t\t\t\t\\\n- ? gen_rtx (REG, (MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+ ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n  : 0)\n \n /* ??? Quick hack to try to get varargs working the normal way.  */\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n (((! current_function_varargs || (NAMED))\t\t\t\t\\\n   && PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED)))\t\t\t\\\n- ? gen_rtx (REG, (MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+ ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n  : 0)\n \n /* A C expression for the number of words, at the beginning of an\n@@ -1011,11 +1013,11 @@ m32r_setup_incoming_varargs (&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, 0)\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -1095,13 +1097,13 @@ m32r_output_function_epilogue (FILE, SIZE)\n    CXT is an RTX for the static chain value for the function.  */\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n do { \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 0)), \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 0)), \\\n \t\t  plus_constant ((CXT), 0xe7000000)); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), \\\n \t\t  plus_constant ((FNADDR), 0xe6000000)); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 8)), \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 8)), \\\n \t\t  GEN_INT (0x1fc67000)); \\\n-  emit_insn (gen_flush_icache (validize_mem (gen_rtx (MEM, SImode, TRAMP)))); \\\n+  emit_insn (gen_flush_icache (validize_mem (gen_rtx_MEM (SImode, TRAMP)))); \\\n } while (0)\n \f\n /* Library calls.  */"}, {"sha": "85ab2530e1f3d8fc86f3355a5b04a9a374820948", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description of the Mitsubishi M32R cpu for GNU C compiler\n-;; Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+;; Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -684,11 +684,11 @@\n       op0_subword = SUBREG_WORD (operand0);\n       operand0 = XEXP (operand0, 0);\n     }\n-  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n-\t\t\t\t\t op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n+\t\t\t\t\t\top1_subword),\n \t\t\t  shift_24));\n   if (GET_MODE (operand0) != SImode)\n-    operand0 = gen_rtx (SUBREG, SImode, operand0, op0_subword);\n+    operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subword);\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n   DONE;\n }\")\n@@ -717,8 +717,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n-\t\t\t\t\t op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n \t\t\t  shift_24));\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n   DONE;\n@@ -748,8 +747,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n-\t\t\t\t\t op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n \t\t\t  shift_16));\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n   DONE;"}, {"sha": "1b85ce4404668d782364ae71592bd910c7ce5469", "filename": "gcc/config/m68k/a-ux.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fa-ux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fa-ux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fa-ux.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for Motorola 680x0 running A/UX\n-   Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -116,14 +116,14 @@ crt2.o%s \"\n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE, FUNC)                                  \\\n   (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881                    \\\n-   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)                            \\\n+   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)                            \\\n    : (POINTER_TYPE_P (VALTYPE)\t\t                               \\\n-      ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)                           \\\n-      : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n+      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)                           \\\n+      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n                     \n #undef LIBCALL_VALUE\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  gen_rtx (REG, (MODE), ((TARGET_68881 &&\t\t\t\t\\\n+  gen_rtx_REG ((MODE), ((TARGET_68881 &&\t\t\t\t\\\n \t\t\t ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0))\n \n /* 1 if N is a possible register number for a function value.\n@@ -166,9 +166,9 @@ crt2.o%s \"\n \n #undef FINALIZE_TRAMPOLINE\n #define FINALIZE_TRAMPOLINE(TRAMP)\t\t\t\t\t\\\n-  emit_library_call(gen_rtx(SYMBOL_REF, Pmode, \"__clear_cache\"),\t\\\n-\t\t    0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\\n-\t\t    plus_constant(TRAMP, TRAMPOLINE_SIZE), Pmode);\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n+\t\t     0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\\n+\t\t     plus_constant (TRAMP, TRAMPOLINE_SIZE), Pmode);\n \n /* Clear the instruction cache from `beg' to `end'.  This makes an \n    inline system call to SYS_sysm68k.  The arguments are as follows:"}, {"sha": "89bf07ac1d4c75dae18f945bcb2dd4a41fe00844", "filename": "gcc/config/m68k/crds.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fcrds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fcrds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcrds.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler;\n    Charles River Data Systems UNiverse/32.\n-   Copyright (C) 1987, 1993, 1994, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93, 94, 96, 97, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Gary E. Miller (Gary_Edmunds_Miller@cup.portal.com)\n \n This file is part of GNU CC.\n@@ -79,7 +79,7 @@ Boston, MA 02111-1307, USA.  */\n \n #if 0\n #define HAVE_probe 1\n-#define gen_probe()  gen_rtx(ASM_INPUT, VOIDmode, \"tstb -2048(sp)\\t;probe\\n\")\n+#define gen_probe()  gen_rtx_ASM_INPUT (VOIDmode, \"tstb -2048(sp)\\t;probe\\n\")\n #else\n #undef NEED_PROBE\n #define NEED_PROBE (-2048)\n@@ -109,7 +109,7 @@ Boston, MA 02111-1307, USA.  */\n /* unos uses \".comm c.sac\" returns &c.sac in d0 */\n /* make pointer to c.sac ?\n #undef STRUCT_VALUE_REGNUM\n-#define STRUCT_VALUE gen_rtx(MEM, Pmode, gen_rtx( , , ) )\n+#define STRUCT_VALUE gen_rtx_MEM (Pmode, gen_rtx( , , ) )\n */\n \n #define BSS_SECTION_ASM_OP \".bss\""}, {"sha": "32d2706aab04c424982e02d251dc32b50487a2af", "filename": "gcc/config/m68k/isi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fisi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fisi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fisi.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  ISI 68000/68020 version.\n    Intended only for use with GAS, and not ISI's assembler, which is buggy\n-   Copyright (C) 1988, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1996, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -74,7 +74,7 @@ Boston, MA 02111-1307, USA.  */\n #define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n \n #define LIBCALL_VALUE(MODE) \\\n- gen_rtx (REG, (MODE), ((TARGET_68881 && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0))\n+ gen_rtx_REG ((MODE), ((TARGET_68881 && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0))\n \n /* 1 if N is a possible register number for a function value.\n    D0 may be used, and F0 as well if -m68881 is specified.  */"}, {"sha": "a7707dd800f5c338b23d04ccb850489f93b35f7a", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for Motorola 68k running Linux-based GNU systems with\n    ELF format.\n-   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -298,8 +298,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n   ((((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)\t\t\\\n     && TARGET_68881)\t\t\t\t\t\t\t\\\n-   ? gen_rtx_REG (MODE, 16)\t\t\t\t\t\t\\\n-   : gen_rtx_REG (MODE, 0))\n+   ? gen_rtx_REG ((MODE), 16)\t\t\t\t\t\t\\\n+   : gen_rtx_REG ((MODE), 0))\n \n /* In m68k svr4, a symbol_ref rtx can be a valid PIC operand if it is\n    an operand of a function call. */"}, {"sha": "b0b7206634c311d9427e3c7a1cbd79e661f4e5e1", "filename": "gcc/config/m68k/lynx.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Flynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Flynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flynx.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for Motorola 680x0 running LynxOS.\n-   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 94, 95, 96, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -62,9 +62,10 @@ Boston, MA 02111-1307, USA.  */\n \n #undef LIBCALL_VALUE\n #define LIBCALL_VALUE(MODE)                                                \\\n- gen_rtx (REG, (MODE),                                                     \\\n-          ((TARGET_68881                                                   \\\n-            && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)) \\\n+ gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t      ((TARGET_68881\t\t\t\t\t\\\n+\t\t&& ((MODE) == SFmode || (MODE) == DFmode\t\\\n+\t\t    || (MODE) == XFmode))\t\t\t\\\n            ? 16 : 0))\n \n #undef FUNCTION_VALUE_REGNO_P"}, {"sha": "2db8626b01e327f1e2a1d1b0a06deb2740e2ee61", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -18,8 +18,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n-/* Some output-actions in m68k.md need these.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n@@ -2147,7 +2145,7 @@ output_addsi3 (operands)\n       if (INTVAL (operands[2]) < 0\n \t  && INTVAL (operands[2]) >= -8)\n         {\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  operands[2] = GEN_INT (- INTVAL (operands[2]));\n \t  return \"subq%.l %2,%0\";\n \t}\n       /* On the CPU32 it is faster to use two addql instructions to\n@@ -2164,7 +2162,7 @@ output_addsi3 (operands)\n \t  if (INTVAL (operands[2]) < -8\n \t      && INTVAL (operands[2]) >= -16)\n \t    {\n-\t      operands[2] = GEN_INT (-INTVAL (operands[2]) - 8);\n+\t      operands[2] = GEN_INT (- INTVAL (operands[2]) - 8);\n \t      return \"subq%.l %#8,%0\\n\\tsubq%.l %2,%0\";\n \t    }\n \t}"}, {"sha": "37e5ea32c17a96fef24cf9d293fa9598973c905b", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 62, "deletions": 94, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1504,7 +1504,7 @@\n   \"*\n {\n   CC_STATUS_INIT;\n-  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   return \\\"moveq %#0,%0\\;moveq %#0,%2\\;move%.b %1,%2\\\";\n }\")\n \n@@ -1515,7 +1515,7 @@\n   \"*\n {\n   CC_STATUS_INIT;\n-  operands[2] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   return \\\"moveq %#0,%0\\;moveq %#0,%2\\;move%.w %1,%2\\\";\n }\")\n \n@@ -2197,32 +2197,33 @@\n \treturn \\\"add%.l %R2,%R0\\;addx%.l %2,%0\\\";\n       else if (GET_CODE (operands[2]) == MEM\n \t  && GET_CODE (XEXP (operands[2], 0)) == POST_INC)\n-\t{\n-\t  return \\\"move%.l %2,%3\\;add%.l %2,%R0\\;addx%.l %3,%0\\\";\n-\t}\n+\treturn \\\"move%.l %2,%3\\;add%.l %2,%R0\\;addx%.l %3,%0\\\";\n       else\n \t{\n+\t  rtx high, low;\n \t  rtx xoperands[2];\n+\n \t  if (GET_CODE (operands[2]) == REG)\n-\t    operands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-\t  else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n \t    {\n-\t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-\t      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t      low = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n+\t      high = operands[2];\n \t    }\n-\t  else if (GET_CODE (operands[2]) == CONST_INT)\n+\t  else if (CONSTANT_P (operands[2]))\n+\t    split_double (operands[2], &high, &low);\n+\t  else\n \t    {\n-\t      operands[1] = operands[2];\n-\t      operands[2] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n+\t      low = adj_offsettable_operand (operands[2], 4);\n+\t      high = operands[2];\n \t    }\n-\t  else\n-\t    operands[1] = adj_offsettable_operand (operands[2], 4);\n+\n+\t  operands[1] = low, operands[2] = high;\n \t  xoperands[0] = operands[3];\n \t  if (GET_CODE (operands[1]) == CONST_INT\n \t      && INTVAL (operands[1]) >= -8 && INTVAL (operands[1]) < 0)\n \t    xoperands[1] = GEN_INT (-INTVAL (operands[2]) - 1);\n \t  else\n \t    xoperands[1] = operands[2];\n+\n \t  output_asm_insn (output_move_simode (xoperands), xoperands);\n \t  if (GET_CODE (operands[1]) == CONST_INT)\n \t    {\n@@ -2255,10 +2256,8 @@\n       CC_STATUS_INIT;\n       if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n \t{\n-\t  operands[1]\n-\t    = gen_rtx_MEM (SImode,\n-\t\t\t   gen_rtx_PLUS (VOIDmode, XEXP(operands[0], 0),\n-\t\t\t\t\t GEN_INT (-8)));\n+\t  operands[1] = gen_rtx_MEM (SImode,\n+\t\t\t\t     plus_constant (XEXP(operands[0], 0), -8));\n \t  return \\\"move%.l %0,%3\\;add%.l %R2,%0\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n \t}\n       else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n@@ -2368,7 +2367,7 @@\n       if (INTVAL (operands[2]) < 0\n \t  && INTVAL (operands[2]) >= -8)\n \t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  operands[2] = GEN_INT (- INTVAL (operands[2]));\n \t  return \\\"subq%.w %2,%0\\\";\n \t}\n       /* On the CPU32 it is faster to use two addqw instructions to\n@@ -2385,7 +2384,7 @@\n \t  if (INTVAL (operands[2]) < -8\n \t      && INTVAL (operands[2]) >= -16)\n \t    {\n-\t      operands[2] = GEN_INT (-INTVAL (operands[2]) - 8);\n+\t      operands[2] = GEN_INT (- INTVAL (operands[2]) - 8);\n \t      return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n \t    }\n \t}\n@@ -2430,7 +2429,7 @@\n       if (INTVAL (operands[1]) < 0\n \t  && INTVAL (operands[1]) >= -8)\n \t{\n-\t  operands[1] = GEN_INT (-INTVAL (operands[1]));\n+\t  operands[1] = GEN_INT (- INTVAL (operands[1]));\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n       /* On the CPU32 it is faster to use two addqw instructions to\n@@ -2447,7 +2446,7 @@\n \t  if (INTVAL (operands[1]) < -8\n \t      && INTVAL (operands[1]) >= -16)\n \t    {\n-\t      operands[1] = GEN_INT (-INTVAL (operands[1]) - 8);\n+\t      operands[1] = GEN_INT (- INTVAL (operands[1]) - 8);\n \t      return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n \t    }\n \t}\n@@ -2486,7 +2485,7 @@\n       if (INTVAL (operands[1]) < 0\n \t  && INTVAL (operands[1]) >= -8)\n \t{\n-\t  operands[1] = GEN_INT (-INTVAL (operands[1]));\n+\t  operands[1] = GEN_INT (- INTVAL (operands[1]));\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n       /* On the CPU32 it is faster to use two addqw instructions to\n@@ -2503,7 +2502,7 @@\n \t  if (INTVAL (operands[1]) < -8\n \t      && INTVAL (operands[1]) >= -16)\n \t    {\n-\t      operands[1] = GEN_INT (-INTVAL (operands[1]) - 8);\n+\t      operands[1] = GEN_INT (- INTVAL (operands[1]) - 8);\n \t      return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n \t    }\n \t}\n@@ -2536,7 +2535,7 @@\n \treturn \\\"addq%.b %2,%0\\\";\n       if (INTVAL (operands[2]) < 0 && INTVAL (operands[2]) >= -8)\n        {\n-\t operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t operands[2] = GEN_INT (- INTVAL (operands[2]));\n \t return \\\"subq%.b %2,%0\\\";\n        }\n     }\n@@ -2562,7 +2561,7 @@\n \treturn \\\"addq%.b %1,%0\\\";\n       if (INTVAL (operands[1]) < 0 && INTVAL (operands[1]) >= -8)\n        {\n-\t operands[1] = GEN_INT (-INTVAL (operands[1]));\n+\t operands[1] = GEN_INT (- INTVAL (operands[1]));\n \t return \\\"subq%.b %1,%0\\\";\n        }\n     }\n@@ -2588,7 +2587,7 @@\n \treturn \\\"addq%.b %1,%0\\\";\n       if (INTVAL (operands[1]) < 0 && INTVAL (operands[1]) >= -8)\n        {\n-\t operands[1] = GEN_INT (-INTVAL (operands[1]));\n+\t operands[1] = GEN_INT (- INTVAL (operands[1]));\n \t return \\\"subq%.b %1,%0\\\";\n        }\n     }\n@@ -2763,27 +2762,30 @@\n \t}\n       else\n \t{\n+\t  rtx high, low;\n \t  rtx xoperands[2];\n+\n \t  if (GET_CODE (operands[2]) == REG)\n-\t    operands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-\t  else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n \t    {\n-\t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-\t      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t      low = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n+\t      high = operands[2];\n \t    }\n-\t  else if (GET_CODE (operands[2]) == CONST_INT)\n+\t  else if (CONSTANT_P (operands[2]))\n+\t    split_double (operands[2], &high, &low);\n+\t  else\n \t    {\n-\t      operands[1] = operands[2];\n-\t      operands[2] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n+\t      low = adj_offsettable_operand (operands[2], 4);\n+\t      high = operands[2];\n \t    }\n-\t  else\n-\t    operands[1] = adj_offsettable_operand (operands[2], 4);\n+\n+\t  operands[1] = low, operands[2] = high;\n \t  xoperands[0] = operands[3];\n \t  if (GET_CODE (operands[1]) == CONST_INT\n \t      && INTVAL (operands[1]) >= -8 && INTVAL (operands[1]) < 0)\n \t    xoperands[1] = GEN_INT (-INTVAL (operands[2]) - 1);\n \t  else\n \t    xoperands[1] = operands[2];\n+\n \t  output_asm_insn (output_move_simode (xoperands), xoperands);\n \t  if (GET_CODE (operands[1]) == CONST_INT)\n \t    {\n@@ -2817,9 +2819,7 @@\n       if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n \t{\n \t  operands[1]\n-\t    = gen_rtx_MEM (SImode,\n-\t\t\t   gen_rtx_PLUS (VOIDmode, XEXP(operands[0], 0),\n-\t\t\t\t\t GEN_INT (-8)));\n+\t    = gen_rtx_MEM (SImode, plus_constant (XEXP (operands[0], 0), -8));\n \t  return \\\"move%.l %0,%3\\;sub%.l %R2,%0\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n \t}\n       else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n@@ -3641,21 +3641,12 @@\n {\n   CC_STATUS_INIT;\n   /* We can get CONST_DOUBLE, but also const1_rtx etc. */\n-  if (GET_CODE (operands[2]) == CONST_DOUBLE\n-     || GET_CODE (operands[2]) == CONST_INT)\n+  if (CONSTANT_P (operands[2]))\n     {\n       rtx hi, lo;\n \n-      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-\t{\n-\t  hi = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-\t  lo = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-\t}\n-      else\n-\t{\n-\t  lo = operands[2];\n-\t  hi = INTVAL (lo) < 0 ? constm1_rtx : const0_rtx;\n-\t}\n+      split_double (operands[2], &hi, &lo);\n+\n       switch (INTVAL (hi))\n \t{\n \t  case 0 :\n@@ -3790,7 +3781,7 @@\n \n   CC_STATUS_INIT;\n   if (GET_CODE (operands[0]) == REG)\n-    operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else\n     operands[0] = adj_offsettable_operand (operands[0], 4);\n   if (GET_MODE (operands[1]) == SImode)\n@@ -3814,21 +3805,12 @@\n {\n   CC_STATUS_INIT;\n   /* We can get CONST_DOUBLE, but also const1_rtx etc. */\n-  if (GET_CODE (operands[2]) == CONST_DOUBLE\n-     || GET_CODE (operands[2]) == CONST_INT)\n+  if (CONSTANT_P (operands[2]))\n     {\n       rtx hi, lo;\n \n-      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-\t{\n-\t  hi = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-\t  lo = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-\t}\n-      else\n-\t{\n-\t  lo = operands[2];\n-\t  hi = INTVAL (lo) < 0 ? constm1_rtx : const0_rtx;\n-\t}\n+      split_double (operands[2], &hi, &lo);\n+\n       switch (INTVAL (hi))\n \t{\n \t  case 0 :\n@@ -4001,21 +3983,13 @@\n {\n   CC_STATUS_INIT;\n   /* We can get CONST_DOUBLE, but also const1_rtx etc. */\n-  if (GET_CODE (operands[2]) == CONST_DOUBLE\n-     || GET_CODE (operands[2]) == CONST_INT)\n+\n+  if (CONSTANT_P (operands[2]))\n     {\n       rtx hi, lo;\n \n-      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-\t{\n-\t  hi = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-\t  lo = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-\t}\n-      else\n-\t{\n-\t  lo = operands[2];\n-\t  hi = INTVAL (lo) < 0 ? constm1_rtx : const0_rtx;\n-\t}\n+      split_double (operands[2], &hi, &lo);\n+\n       switch (INTVAL (hi))\n \t{\n \t  case 0 :\n@@ -4248,7 +4222,7 @@\n       target = operand_subword_force (operands[0], 0, SFmode);\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, SFmode),\n-\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -4299,7 +4273,7 @@\n       target = operand_subword (operands[0], 0, 1, DFmode);\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, DFmode),\n-\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -4382,7 +4356,7 @@\n       target = operand_subword_force (operands[0], 0, SFmode);\n       result = expand_binop (SImode, and_optab,\n \t\t\t     operand_subword_force (operands[1], 0, SFmode),\n-\t\t\t     GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -4428,7 +4402,7 @@\n       target = operand_subword (operands[0], 0, 1, DFmode);\n       result = expand_binop (SImode, and_optab,\n \t\t\t     operand_subword_force (operands[1], 0, DFmode),\n-\t\t\t     GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -5645,8 +5619,7 @@\n       int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n       return output_btst (operands,\n \t\t\t  GEN_INT (width - INTVAL (operands[2])),\n-\t\t\t  operands[0],\n-\t\t\t  insn, 1000);\n+\t\t\t  operands[0], insn, 1000);\n       /* Pass 1000 as SIGNPOS argument so that btst will\n          not think we are testing the sign bit for an `and'\n \t and assume that nonzero implies a negative result.  */\n@@ -5670,10 +5643,8 @@\n       && GET_CODE (operands[2]) == CONST_INT)\n     {\n       int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n-      return output_btst (operands,\n-\t\t\t  GEN_INT (width - INTVAL (operands[2])),\n-\t\t\t  operands[0],\n-\t\t\t  insn, 1000);\n+      return output_btst (operands, GEN_INT (width - INTVAL (operands[2])),\n+\t\t\t  operands[0], insn, 1000);\n       /* Pass 1000 as SIGNPOS argument so that btst will\n          not think we are testing the sign bit for an `and'\n \t and assume that nonzero implies a negative result.  */\n@@ -7003,8 +6974,7 @@\n  \"NEED_PROBE\"\n  \"*\n {\n-  operands[0] = gen_rtx_PLUS (SImode, stack_pointer_rtx,\n-\t\t\t      GEN_INT (NEED_PROBE));\n+  operands[0] = plus_constant (stack_pointer_rtx, NEED_PROBE);\n   return \\\"tstl %a0\\\";\n }\")\n \n@@ -7207,9 +7177,7 @@\n \n   xoperands[1] = operands[1];\n   xoperands[2]\n-    = gen_rtx_MEM (QImode,\n-\t\t   gen_rtx_PLUS (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t GEN_INT (3)));\n+    = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 3));\n   xoperands[3] = stack_pointer_rtx;\n   if (!TARGET_5200)\n     output_asm_insn (\\\"subq%.w %#4,%3\\;move%.b %1,%2\\\", xoperands);\n@@ -7552,7 +7520,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"move%.l %1,%-\\\", xoperands);\n \t  output_asm_insn (\\\"move%.l %1,%-\\\", operands);\n \t  return \\\"f%&move%.d %+,%0\\\";\n@@ -7784,7 +7752,7 @@\n       target = operand_subword (operands[0], 0, 1, XFmode);\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, XFmode),\n-\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -7833,7 +7801,7 @@\n       target = operand_subword (operands[0], 0, 1, XFmode);\n       result = expand_binop (SImode, and_optab,\n \t\t\t     operand_subword_force (operands[1], 0, XFmode),\n-\t\t\t     GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n "}, {"sha": "379bf3afe0a6e75e4448e24d86ada2fceb3d3f02", "filename": "gcc/config/m68k/m68kemb.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68kemb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68kemb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kemb.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  \"embedded\" 68XXX.\n    This is meant to be included after m68k.h.\n-   Copyright (C) 1994, 1995 Free Software Foundation, Inc.  */\n+   Copyright (C) 1994, 1995, 1998, 1999 Free Software Foundation, Inc.  */\n \n #define PTRDIFF_TYPE \"long int\"\n #define SIZE_TYPE \"long unsigned int\"\n@@ -26,10 +26,11 @@\n #define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n \n #undef LIBCALL_VALUE\n-#define LIBCALL_VALUE(MODE)                                                \\\n- gen_rtx (REG, (MODE),                                                     \\\n-          ((TARGET_68881                                                   \\\n-            && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)) \\\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\\\n+ gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t      ((TARGET_68881\t\t\t\t\t\\\n+\t\t&& ((MODE) == SFmode || (MODE) == DFmode\t\\\n+\t\t    || (MODE) == XFmode))\t\t\t\\\n            ? 16 : 0))\n \n #undef FUNCTION_VALUE_REGNO_P"}, {"sha": "dd2b3c1d6fde167a4131ce026504b6713edc6ac1", "filename": "gcc/config/m68k/m68kv4.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Target definitions for GNU compiler for mc680x0 running System V.4\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93, 94, 95, 96, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@monkeys.com) and\n    Fred Fish (fnf@cygnus.com).\n \n@@ -167,10 +167,10 @@ while (0)\n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n   (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881\t\t\t\\\n-   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)\t\t\t\t\\\n+   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)\t\t\t\t\\\n    : (POINTER_TYPE_P (VALTYPE)\t\t\t\t\t\t\\\n-      ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)\t\t\t\t\\\n-      : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n+      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)\t\t\t\t\\\n+      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n \n /* For compatibility with the large body of existing code which does not\n    always properly declare external functions returning pointer types, the\n@@ -195,8 +195,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n   ((((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)\t\t\\\n     && TARGET_68881)\t\t\t\t\t\t\t\\\n-   ? gen_rtx (REG, (MODE), 16)\t\t\t\t\t\t\\\n-   : gen_rtx (REG, (MODE), 0))\n+   ? gen_rtx_REG ((MODE), 16)\t\t\t\t\t\t\\\n+   : gen_rtx_REG ((MODE), 0))\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.\n    The m68k/SVR4 convention is to keep the stack pointer longword aligned. */\n@@ -321,13 +321,13 @@ int switch_table_difference_label_flag;\n #undef TRAMPOLINE_TEMPLATE\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x227a));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (8));\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x2f3a));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (8));\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x4e75));\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x227a));\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (8));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x2f3a));\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (8));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x4e75));\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\\\n }\n \n /* Redefine since we are using a different trampoline */\n@@ -341,6 +341,6 @@ int switch_table_difference_label_flag;\n #undef INITIALIZE_TRAMPOLINE\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)                       \\\n {                                                                       \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 10)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 14)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 10)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 14)), FNADDR); \\\n }"}, {"sha": "8074e5b4d2efda2586c998005153be2804d554e6", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    SysV68 Motorola 3300 Delta Series.\n-   Copyright (C) 1987, 93, 94, 95, 96, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93-98, 1999 Free Software Foundation, Inc.\n    Contributed by Abramo and Roberto Bagnara (bagnara@dipisa.di.unipi.it)\n    based on Alex Crain's 3B1 definitions.\n    Maintained by Philippe De Muyter (phdm@info.ucl.ac.be).\n@@ -298,20 +298,21 @@ dtors_section ()\t\t\t\t\t\t\t\\\n /* sysV68 (brain damaged) cc convention support. */\n #define FUNCTION_VALUE(VALTYPE,FUNC) \\\n   (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881 \t\\\n-   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)\t\t\\\n+   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)\t\t\\\n    : (POINTER_TYPE_P (VALTYPE)\t\t\t\t\\\n-      ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)\t\t\\\n-      : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n+      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)\t\t\\\n+      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n \n /* If TARGET_68881, SF and DF values are returned in fp0 instead of d0.  */\n \n /* Is LIBCALL_VALUE never called with a pointer ? */\n #undef LIBCALL_VALUE\n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t   \\\n- gen_rtx (REG, (MODE),\t\t\t\t\t\t\t   \\\n-\t  ((TARGET_68881\t\t\t\t\t\t   \\\n-\t    && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)) \\\n-\t   ? 16 : 0))\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\\\n+ gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t      ((TARGET_68881\t\t\t\t\t\\\n+\t\t&& ((MODE) == SFmode || (MODE) == DFmode\t\\\n+\t\t    || (MODE) == XFmode))\t\t\t\\\n+\t       ? 16 : 0))\n \n /* 1 if N is a possible register number for a function value.\n    d0 may be used, and fp0 as well if -msoft-float is not specified.  */\n@@ -772,8 +773,8 @@ do {(CUM).offset = 0;\\\n \n #undef FUNCTION_ARG\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-(((CUM).libcall && (CUM).offset == 0) ? gen_rtx(REG, (MODE), 0)\\\n-: (TARGET_REGPARM && (CUM).offset < 8) ? gen_rtx (REG, (MODE), (CUM).offset / 4) : 0)\n+(((CUM).libcall && (CUM).offset == 0) ? gen_rtx_REG ((MODE), 0)\\\n+: (TARGET_REGPARM && (CUM).offset < 8) ? gen_rtx_REG ((MODE), (CUM).offset / 4) : 0)\n \n #undef FUNCTION_ARG_PARTIAL_NREGS\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n@@ -815,5 +816,5 @@ do {(CUM).offset = 0;\\\n   if (!TARGET_68040)\t\t\t\\\n     ;\t\t\t\t\t\\\n   else\t\t\t\t\t\\\n-    emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__clear_insn_cache\"), \\\n+    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_insn_cache\"), \\\n \t\t       0, VOIDmode, 0)"}, {"sha": "246f5e77e855ff5fee89108885e0e10b809a02b8", "filename": "gcc/config/m68k/news.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fnews.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fnews.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnews.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  SONY NEWS-OS 4 version.\n-   Copyright (C) 1987, 89, 93, 94, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 93, 94, 96-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -126,11 +126,12 @@ Boston, MA 02111-1307, USA.  */\n \n #define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n \n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t   \\\n- gen_rtx (REG, (MODE),\t\t\t\t\t\t\t   \\\n-\t  ((TARGET_68881\t\t\t\t\t\t   \\\n-\t    && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)) \\\n-\t   ? 16 : 0))\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\\\n+ gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t      ((TARGET_68881\t\t\t\t\t\\\n+\t\t&& ((MODE) == SFmode || (MODE) == DFmode\t\\\n+\t\t    || (MODE) == XFmode))\t\t\t\\\n+\t       ? 16 : 0))\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n   fprintf (FILE, \"\\t.align %d\\n\", (LOG))"}, {"sha": "9320a1fccacd2c1dbfb202f6ceb0b4df0cab321d", "filename": "gcc/config/m68k/next.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fnext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fnext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnext.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Target definitions for GNU compiler for mc680x0 running NeXTSTEP\n-   Copyright (C) 1989, 90-94, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 90-94, 96, 97, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -186,8 +186,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef FINALIZE_TRAMPOLINE\n #define FINALIZE_TRAMPOLINE(TRAMP) \\\n-  emit_library_call(gen_rtx(SYMBOL_REF, Pmode, \"__enable_execute_stack\"), \\\n-\t\t    0, VOIDmode, 1, memory_address(SImode, (TRAMP)), Pmode)\n+  emit_library_call(gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"), \\\n+\t\t    0, VOIDmode, 1, memory_address (SImode, (TRAMP)), Pmode)\n \n /* A C expression used to clear the instruction cache from \n    address BEG to address END.   On NeXTSTEP this i a system trap. */"}, {"sha": "4e277636c3dcb082fa333e64caa316c55f81da01", "filename": "gcc/config/m68k/sun3.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n-   Copyright (C) 1987, 1988, 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 93, 95, 96, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -171,11 +171,12 @@ Boston, MA 02111-1307, USA.  */\n /* This is not a good idea.  It prevents interoperation between\n    files compiled with -m68881 and those compiled with -msoft-float.  */\n #if 0\n-#define FUNCTION_VALUEX(MODE)\t\t\t\t\t\t    \\\n-  gen_rtx (REG, (MODE),\t\t\t\t\t\t\t    \\\n-\t   ((TARGET_68881\t\t\t\t\t\t    \\\n-\t     && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)) \\\n-\t    ? 16 : 0))\n+#define FUNCTION_VALUEX(MODE)\t\t\t\t\t\\\n+  gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t       ((TARGET_68881\t\t\t\t\t\\\n+\t\t && ((MODE) == SFmode || (MODE) == DFmode\t\\\n+\t\t     || (MODE) == XFmode))\t\t\t\\\n+\t\t? 16 : 0))\n \n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE,FUNC) FUNCTION_VALUEX (TYPE_MODE (VALTYPE))"}, {"sha": "ddc80506b1b3788508bb0ec59a9436b7e76187f5", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 81, "deletions": 83, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Motorola 88000.\n-   Copyright (C) 1988, 92, 93, 94, 95, 16, 1997, 1999 Free Software\n+   Copyright (C) 1988, 92, 93, 94, 95, 96, 1997, 1998, 1999 Free Software\n    Foundation, Inc. \n    Contributed by Michael Tiemann (tiemann@mcc.com)\n    Currently maintained by (gcc@dg-rtp.dg.com)\n@@ -22,12 +22,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-\n-#include <stdio.h>\n-#include <sys/types.h>\n-#include <time.h>\n-#include <ctype.h>\n-\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -44,8 +39,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n \n extern char *version_string;\n-extern time_t time ();\n-extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n@@ -237,7 +230,7 @@ emit_move_sequence (operands, mode, scratch)\n \t  || GET_CODE (operand1) == MEM)\n \t{\n \t  /* Run this case quickly.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n     }\n@@ -247,7 +240,7 @@ emit_move_sequence (operands, mode, scratch)\n \t  || (operand1 == const0_rtx && GET_MODE_SIZE (mode) <= UNITS_PER_WORD))\n \t{\n \t  /* Run this case quickly.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n       if (! reload_in_progress && ! reload_completed)\n@@ -269,7 +262,7 @@ emit_move_sequence (operands, mode, scratch)\n \t\t\t\t\t    && symbolic_address_p (operand1),\n \t\t\t\t\t    operand1, temp, scratch);\n \t  if (mode != SImode)\n-\t    operands[1] = gen_rtx (SUBREG, mode, operands[1], 0);\n+\t    operands[1] = gen_rtx_SUBREG (mode, operands[1], 0);\n \t}\n     }\n \n@@ -316,28 +309,33 @@ legitimize_address (pic, orig, reg, scratch)\n \t      temp = ((reload_in_progress || reload_completed)\n \t\t      ? reg : gen_reg_rtx (Pmode));\n \n-\t      emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t\t\t  gen_rtx (HIGH, SImode,\n-\t\t\t\t\t   gen_rtx (UNSPEC, SImode,\n-\t\t\t\t\t\t    gen_rtvec (1, addr),\n-\t\t\t\t\t\t    0))));\n-\t      emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t\t\t  gen_rtx (LO_SUM, SImode, temp,\n-\t\t\t\t\t   gen_rtx (UNSPEC, SImode,\n-\t\t\t\t\t\t    gen_rtvec (1, addr),\n-\t\t\t\t\t\t    0))));\n+\t      emit_insn (gen_rtx_SET\n+\t\t\t (VOIDmode, temp,\n+\t\t\t  gen_rtx_HIGH (SImode,\n+\t\t\t\t\tgen_rtx_UNSPEC (SImode,\n+\t\t\t\t\t\t\tgen_rtvec (1, addr),\n+\t\t\t\t\t\t\t0))));\n+\n+\t      emit_insn (gen_rtx_SET\n+\t\t\t (VOIDmode, temp,\n+\t\t\t  gen_rtx_LO_SUM (SImode, temp,\n+\t\t\t\t\t  gen_rtx_UNSPEC (SImode,\n+\t\t\t\t\t\t\t  gen_rtvec (1, addr),\n+\t\t\t\t\t\t\t  0))));\n \t      addr = temp;\n \t    }\n-\t  new = gen_rtx (MEM, Pmode,\n-\t\t\t gen_rtx (PLUS, SImode,\n-\t\t\t\t  pic_offset_table_rtx, addr));\n+\n+\t  new = gen_rtx_MEM (Pmode,\n+\t\t\t     gen_rtx_PLUS (SImode,\n+\t\t\t\t\t   pic_offset_table_rtx, addr));\n+\n \t  current_function_uses_pic_offset_table = 1;\n \t  RTX_UNCHANGING_P (new) = 1;\n \t  insn = emit_move_insn (reg, new);\n \t  /* Put a REG_EQUAL note on this insn, so that it can be optimized\n \t     by loop.  */\n-\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n-\t\t\t\t      REG_NOTES (insn));\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig,\n+\t\t\t\t\t\tREG_NOTES (insn));\n \t  new = reg;\n \t}\n       else if (GET_CODE (addr) == CONST)\n@@ -381,7 +379,7 @@ legitimize_address (pic, orig, reg, scratch)\n \t\t   for this address.  */\n \t\tabort ();\n \t    }\n-\t  new = gen_rtx (PLUS, SImode, base, addr);\n+\t  new = gen_rtx_PLUS (SImode, base, addr);\n \t  /* Should we set special REG_NOTEs here?  */\n \t}\n     }\n@@ -395,15 +393,15 @@ legitimize_address (pic, orig, reg, scratch)\n \t    reg = gen_reg_rtx (Pmode);\n \t}\n \n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  reg, gen_rtx (HIGH, SImode, addr)));\n-      new = gen_rtx (LO_SUM, SImode, reg, addr);\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      reg, gen_rtx_HIGH (SImode, addr)));\n+      new = gen_rtx_LO_SUM (SImode, reg, addr);\n     }\n \n   if (new != orig\n       && GET_CODE (orig) == MEM)\n     {\n-      new = gen_rtx (MEM, GET_MODE (orig), new);\n+      new = gen_rtx_MEM (GET_MODE (orig), new);\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (orig);\n       MEM_COPY_ATTRIBUTES (new, orig);\n     }\n@@ -527,15 +525,15 @@ expand_block_move (dest_mem, src_mem, operands)\n   else\n     {\n #ifdef TARGET_MEM_FUNCTIONS\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n \t\t\t VOIDmode, 3,\n \t\t\t operands[0], Pmode,\n \t\t\t operands[1], Pmode,\n \t\t\t convert_to_mode (TYPE_MODE (sizetype), operands[2],\n \t\t\t\t\t  TREE_UNSIGNED (sizetype)),\n \t\t\t TYPE_MODE (sizetype));\n #else\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"bcopy\"), 0,\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"bcopy\"), 0,\n \t\t\t VOIDmode, 3,\n \t\t\t operands[1], Pmode,\n \t\t\t operands[0], Pmode,\n@@ -596,22 +594,22 @@ block_move_loop (dest, dest_mem, src, src_mem, size, align)\n \n   offset_rtx = GEN_INT (MOVSTR_LOOP + (1 - units) * align);\n \n-  value_rtx = gen_rtx (MEM, MEM_IN_STRUCT_P (src_mem) ? mode : BLKmode,\n-\t\t       gen_rtx (PLUS, Pmode,\n-\t\t\t\tgen_rtx (REG, Pmode, 3),\n-\t\t\t\toffset_rtx));\n+  value_rtx = gen_rtx_MEM (MEM_IN_STRUCT_P (src_mem) ? mode : BLKmode,\n+\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t gen_rtx_REG (Pmode, 3),\n+\t\t\t\t\t offset_rtx));\n   RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n   MEM_COPY_ATTRIBUTES (value_rtx, src_mem);\n \n   emit_insn (gen_call_movstrsi_loop\n-\t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n+\t     (gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (entry_name)),\n \t      dest, src, offset_rtx, value_rtx,\n-\t      gen_rtx (REG, mode, ((units & 1) ? 4 : 5)),\n+\t      gen_rtx_REG (mode, ((units & 1) ? 4 : 5)),\n \t      GEN_INT (count)));\n \n   if (remainder)\n-    block_move_sequence (gen_rtx (REG, Pmode, 2), dest_mem,\n-\t\t\t gen_rtx (REG, Pmode, 3), src_mem,\n+    block_move_sequence (gen_rtx_REG (Pmode, 2), dest_mem,\n+\t\t\t gen_rtx_REG (Pmode, 3), src_mem,\n \t\t\t remainder, align, MOVSTR_LOOP + align);\n }\n \n@@ -652,24 +650,25 @@ block_move_no_loop (dest, dest_mem, src, src_mem, size, align)\n \n   offset_rtx = GEN_INT (most - (size - remainder));\n \n-  value_rtx = gen_rtx (MEM, MEM_IN_STRUCT_P (src_mem) ? mode : BLKmode,\n-\t\t       gen_rtx (PLUS, Pmode,\n-\t\t\t\tgen_rtx (REG, Pmode, 3),\n-\t\t\t\toffset_rtx));\n+  value_rtx = gen_rtx_MEM (MEM_IN_STRUCT_P (src_mem) ? mode : BLKmode,\n+\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t gen_rtx_REG (Pmode, 3),\n+\t\t\t\t\t offset_rtx));\n+\n   RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n   MEM_COPY_ATTRIBUTES (value_rtx, src_mem);\n \n   value_reg = ((((most - (size - remainder)) / align) & 1) == 0\n \t       ? (align == 8 ? 6 : 5) : 4);\n \n   emit_insn (gen_call_block_move\n-\t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n+\t     (gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (entry_name)),\n \t      dest, src, offset_rtx, value_rtx,\n-\t      gen_rtx (REG, mode, value_reg)));\n+\t      gen_rtx_REG (mode, value_reg)));\n \n   if (remainder)\n-    block_move_sequence (gen_rtx (REG, Pmode, 2), dest_mem,\n-\t\t\t gen_rtx (REG, Pmode, 3), src_mem,\n+    block_move_sequence (gen_rtx_REG (Pmode, 2), dest_mem,\n+\t\t\t gen_rtx_REG (Pmode, 3), src_mem,\n \t\t\t remainder, align, most);\n }\n \n@@ -724,27 +723,26 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \t      temp[next] = gen_reg_rtx (mode[next]);\n \t    }\n \t  size -= amount[next];\n-\t  srcp = gen_rtx (MEM,\n-\t\t\t  MEM_IN_STRUCT_P (src_mem) ? mode[next] : BLKmode,\n-\t\t\t  gen_rtx (PLUS, Pmode, src,\n-\t\t\t\t   GEN_INT (offset_ld)));\n+\t  srcp = gen_rtx_MEM (MEM_IN_STRUCT_P (src_mem) ? mode[next] : BLKmode,\n+\t\t\t      plus_constant (src, offset_ld));\n+\n \t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n \t  MEM_COPY_ATTRIBUTES (srcp, src_mem);\n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp[next], srcp));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp[next], srcp));\n \t  offset_ld += amount[next];\n \t  active[next] = TRUE;\n \t}\n \n       if (active[phase])\n \t{\n \t  active[phase] = FALSE;\n-\t  dstp = gen_rtx (MEM,\n-\t\t\t  MEM_IN_STRUCT_P (dest_mem) ? mode[phase] : BLKmode,\n-\t\t\t  gen_rtx (PLUS, Pmode, dest,\n-\t\t\t\t   GEN_INT (offset_st)));\n+\t  dstp\n+\t    = gen_rtx_MEM (MEM_IN_STRUCT_P (dest_mem) ? mode[phase] : BLKmode,\n+\t\t\t   plus_constant (dest, offset_st));\n+\n \t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dest_mem);\n \t  MEM_COPY_ATTRIBUTES (dstp, dest_mem);\n-\t  emit_insn (gen_rtx (SET, VOIDmode, dstp, temp[phase]));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dstp, temp[phase]));\n \t  offset_st += amount[phase];\n \t}\n     }\n@@ -927,9 +925,9 @@ output_call (operands, addr)\n \t    }\n \n \t  /* Record the values to be computed later as \"def name,high-low\".  */\n-\t  sb_name = gen_rtx (EXPR_LIST, VOIDmode, operands[0], sb_name);\n-\t  sb_high = gen_rtx (EXPR_LIST, VOIDmode, high, sb_high);\n-\t  sb_low = gen_rtx (EXPR_LIST, VOIDmode, low, sb_low);\n+\t  sb_name = gen_rtx_EXPR_LIST (VOIDmode, operands[0], sb_name);\n+\t  sb_high = gen_rtx_EXPR_LIST (VOIDmode, high, sb_high);\n+\t  sb_low = gen_rtx_EXPR_LIST (VOIDmode, low, sb_low);\n #endif /* Don't USE_GAS */\n \n \t  return last;\n@@ -1160,7 +1158,7 @@ legitimize_operand (op, mode)\n \t  && (u.s.exponent1 == 0x8 || u.s.exponent1 == 0x7) /* Exponent fits */\n \t  && (temp = simplify_unary_operation (FLOAT_TRUNCATE, SFmode,\n \t\t\t\t\t       op, mode)) != 0)\n-\treturn gen_rtx (FLOAT_EXTEND, mode, force_reg (SFmode, temp));\n+\treturn gen_rtx_FLOAT_EXTEND (mode, force_reg (SFmode, temp));\n     }\n   else if (register_operand (op, mode))\n     return op;\n@@ -1982,13 +1980,13 @@ m88k_expand_prologue ()\n \n   if (flag_pic && save_regs[PIC_OFFSET_TABLE_REGNUM])\n     {\n-      rtx return_reg = gen_rtx (REG, SImode, 1);\n+      rtx return_reg = gen_rtx_REG (SImode, 1);\n       rtx label = gen_label_rtx ();\n       rtx temp_reg;\n \n       if (! save_regs[1])\n \t{\n-\t  temp_reg = gen_rtx (REG, SImode, TEMP_REGNUM);\n+\t  temp_reg = gen_rtx_REG (SImode, TEMP_REGNUM);\n \t  emit_move_insn (temp_reg, return_reg);\n \t}\n       emit_insn (gen_locate1 (pic_offset_table_rtx, label));\n@@ -2092,9 +2090,10 @@ emit_add (dstreg, srcreg, amount)\n      int amount;\n {\n   rtx incr = GEN_INT (abs (amount));\n+\n   if (! ADD_INTVAL (amount))\n     {\n-      rtx temp = gen_rtx (REG, SImode, TEMP_REGNUM);\n+      rtx temp = gen_rtx_REG (SImode, TEMP_REGNUM);\n       emit_move_insn (temp, incr);\n       incr = temp;\n     }\n@@ -2207,22 +2206,23 @@ emit_ldst (store_p, regno, mode, offset)\n      enum machine_mode mode;\n      int offset;\n {\n-  rtx reg = gen_rtx (REG, mode, regno);\n+  rtx reg = gen_rtx_REG (mode, regno);\n   rtx mem;\n \n   if (SMALL_INTVAL (offset))\n     {\n-      mem = gen_rtx (MEM, mode, plus_constant (stack_pointer_rtx, offset));\n+      mem = gen_rtx_MEM (mode, plus_constant (stack_pointer_rtx, offset));\n     }\n   else\n     {\n       /* offset is too large for immediate index must use register */\n \n       rtx disp = GEN_INT (offset);\n-      rtx temp = gen_rtx (REG, SImode, TEMP_REGNUM);\n-      rtx regi = gen_rtx (PLUS, SImode, stack_pointer_rtx, temp);\n+      rtx temp = gen_rtx_REG (SImode, TEMP_REGNUM);\n+      rtx regi = gen_rtx_PLUS (SImode, stack_pointer_rtx, temp);\n+\n       emit_move_insn (temp, disp);\n-      mem = gen_rtx (MEM, mode, regi);\n+      mem = gen_rtx_MEM (mode, regi);\n     }\n \n   if (store_p)\n@@ -2561,9 +2561,8 @@ m88k_function_arg (args_so_far, mode, type, named)\n \t       || bytes != UNITS_PER_WORD))\n     return (rtx) 0;\n \n-  return gen_rtx (REG,\n-\t\t  ((mode == BLKmode) ? TYPE_MODE (type) : mode),\n-\t\t  2 + args_so_far);\n+  return gen_rtx_REG (((mode == BLKmode) ? TYPE_MODE (type) : mode),\n+\t\t      2 + args_so_far);\n }\n \f\n /* Do what is necessary for `va_start'.  We look at the current function\n@@ -2788,15 +2787,14 @@ emit_bcnd (op, label)\n      rtx label;\n {\n   if (m88k_compare_op1 == const0_rtx)\n-    emit_jump_insn( gen_bcnd (\n-\t\t\tgen_rtx (op, VOIDmode,m88k_compare_op0, const0_rtx),\n-\t\t\tlabel));\n+    emit_jump_insn (gen_bcnd\n+\t\t    (gen_rtx (op, VOIDmode,m88k_compare_op0, const0_rtx),\n+\t\t     label));\n   else if (m88k_compare_op0 == const0_rtx)\n-    emit_jump_insn( gen_bcnd(\n-\t\t      gen_rtx(\n-\t\t\tswap_condition (op),\n-\t\t\tVOIDmode, m88k_compare_op1, const0_rtx),\n-\t\t      label));\n+    emit_jump_insn (gen_bcnd\n+\t\t    (gen_rtx (swap_condition (op),\n+\t\t\t      VOIDmode, m88k_compare_op1, const0_rtx),\n+\t\t     label));\n   else if (op != EQ && op != NE)\n     emit_jump_insn (gen_bxx (emit_test (op, VOIDmode), label));\n   else"}, {"sha": "707bd3cebdddd70c84a76d690a5afd34a2c836f0", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -975,9 +975,8 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, \\\n-\t   TYPE_MODE (VALTYPE) == BLKmode ? SImode : TYPE_MODE (VALTYPE), \\\n-\t   2)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE) == BLKmode ? SImode : TYPE_MODE (VALTYPE), \\\n+\t       2)\n \n /* Define this if it differs from FUNCTION_VALUE.  */\n /* #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC) ... */\n@@ -997,7 +996,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 2)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 2)\n \n /* True if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -1239,8 +1238,8 @@ extern struct rtx_def *m88k_va_arg ();\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 36)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 36)), CXT); \\\n }\n \n /*** Library Subroutine Names ***/\n@@ -1416,23 +1415,23 @@ extern struct rtx_def *m88k_va_arg ();\n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n   if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n-    (X) = gen_rtx (PLUS, Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n-\t\t   XEXP (X, 1));\t\t\t\t\\\n+    (X) = gen_rtx_PLUS (Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n+\t\t\tXEXP (X, 1));\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n-    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), NULL_RTX));\t\\\n+    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), NULL_RTX));\t\\\n   if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n \t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n     (X) = legitimize_address (flag_pic, X, 0, 0);\t\t\\"}, {"sha": "a82a528c420cf3b1f9d02fa3533ff3eea4b5b1f3", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for the Motorola 88000 for GNU C compiler\n-;;;  Copyright (C) 1988, 92-96, 1999 Free Software Foundation, Inc.\n+;;;  Copyright (C) 1988, 92-96, 1998, 1999 Free Software Foundation, Inc.\n ;;  Contributed by Michael Tiemann (tiemann@mcc.com)\n ;;  Currently maintained by (gcc@dg-rtp.dg.com)\n \n@@ -432,24 +432,25 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(neg:SI (match_op_dup 1 [(match_dup 5) (const_int 0)])))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    if (GET_CODE (operands[1]) == GET_CODE (operands[3]))\n      ; /* The conditions match.  */\n    else if (GET_CODE (operands[1])\n \t    == reverse_condition (GET_CODE (operands[3])))\n      /* Reverse the condition by complimenting the compare word.  */\n-     operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+     operands[4] = gen_rtx_NOT (CCmode, operands[4]);\n    else\n      {\n        /* Make the condition pairs line up by rotating the compare word.  */\n        int cv1 = condition_value (operands[1]);\n        int cv2 = condition_value (operands[3]);\n \n-       operands[4] = gen_rtx (ROTATE, CCmode, operands[4],\n-\t\t\t      GEN_INT (((cv2 & ~1) - (cv1 & ~1)) & 0x1f));\n+       operands[4] = gen_rtx_ROTATE (CCmode, operands[4],\n+\t\t\t\t     GEN_INT (((cv2 & ~1) - (cv1 & ~1))\n+\t\t\t\t\t      & 0x1f));\n        /* Reverse the condition if needed.  */\n        if ((cv1 & 1) != (cv2 & 1))\n-\t operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+\t operands[4] = gen_rtx_NOT (CCmode, operands[4]);\n      }\")\n \n (define_split\n@@ -469,7 +470,7 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(neg:SI (match_op_dup 1 [(match_dup 5) (const_int 0)])))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    if (GET_CODE (operands[1]) == GET_CODE (operands[3]))\n      ; /* The conditions match.  */\n    else\n@@ -478,8 +479,8 @@\n        int cv1 = condition_value (operands[1]);\n        int cv2 = condition_value (operands[3]);\n \n-       operands[4] = gen_rtx (ROTATE, CCmode, operands[4],\n-\t\t\t      GEN_INT ((cv2 - cv1) & 0x1f));\n+       operands[4] = gen_rtx_ROTATE (CCmode, operands[4],\n+\t\t\t\t     GEN_INT ((cv2 - cv1) & 0x1f));\n      }\")\n \n (define_split\n@@ -499,7 +500,7 @@\n \t\t(match_dup 4)))\n    (set (match_dup 0)\n \t(neg:SI (match_op_dup 3 [(match_dup 5) (const_int 0)])))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n   if (GET_CODE (operands[1])\n \t    == reverse_condition (GET_CODE (operands[3])))\n      ; \n@@ -509,8 +510,9 @@\n        int cv1 = condition_value (operands[1]);\n        int cv2 = condition_value (operands[3]);\n \n-       operands[2] = gen_rtx (ROTATE, CCmode, operands[2],\n-\t\t\t      GEN_INT (((cv1 & ~1) - (cv2 & ~1)) & 0x1f));\n+       operands[2] = gen_rtx_ROTATE (CCmode, operands[2],\n+\t\t\t\t     GEN_INT (((cv1 & ~1) - (cv2 & ~1))\n+\t\t\t\t\t      & 0x1f));\n      }\")\n \n (define_split\n@@ -529,10 +531,10 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    /* Reverse the condition by  complimenting the compare word.  */\n    if (GET_CODE (operands[1]) != GET_CODE (operands[3]))\n-      operands[4] = gen_rtx (NOT, CCmode, operands[4]);\")\n+      operands[4] = gen_rtx_NOT (CCmode, operands[4]);\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -549,7 +551,7 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\")\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -566,7 +568,7 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\")\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -585,23 +587,24 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(neg:SI (match_op_dup 1 [(match_dup 5) (const_int 0)])))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    if (GET_CODE (operands[1]) == GET_CODE (operands[3]))\n      ; /* The conditions match.  */\n    else if (GET_CODE (operands[1])\n \t    == reverse_condition (GET_CODE (operands[3])))\n      /* Reverse the condition by complimenting the compare word.  */\n-     operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+     operands[4] = gen_rtx_NOT (CCmode, operands[4]);\n    else\n      {\n        /* Make the condition pairs line up by rotating the compare word.  */\n        int cv1 = condition_value (operands[1]);\n        int cv2 = condition_value (operands[3]);\n-       operands[4] = gen_rtx (ROTATE, CCmode, operands[4],\n-\t\t\t      GEN_INT (((cv2 & ~1) - (cv1 & ~1)) & 0x1f));\n+       operands[4] = gen_rtx_ROTATE (CCmode, operands[4],\n+\t\t\t\t     GEN_INT (((cv2 & ~1) - (cv1 & ~1))\n+\t\t\t\t\t      & 0x1f));\n        /* Reverse the condition if needed.  */\n        if ((cv1 & 1) != (cv2 & 1))\n-\t operands[4] = gen_rtx (NOT, CCmode, operands[4]);\n+\t operands[4] = gen_rtx_NOT (CCmode, operands[4]);\n      }\")\n \n (define_split\n@@ -621,16 +624,16 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(neg:SI (match_op_dup 1 [(match_dup 5) (const_int 0)])))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    if (GET_CODE (operands[1]) == GET_CODE (operands[3]))\n      ; /* The conditions match.  */\n    else\n      {\n        /* Make the condition pairs line up by rotating the compare word.  */\n        int cv1 = condition_value (operands[1]);\n        int cv2 = condition_value (operands[3]);\n-       operands[4] = gen_rtx (ROTATE, CCmode, operands[4],\n-\t\t\t      GEN_INT ((cv2 - cv1) & 0x1f));\n+       operands[4] = gen_rtx_ROTATE (CCmode, operands[4],\n+\t\t\t\t     GEN_INT ((cv2 - cv1) & 0x1f));\n      }\")\n \n (define_split\n@@ -650,7 +653,7 @@\n \t\t(match_dup 4)))\n    (set (match_dup 0)\n \t(neg:SI (match_op_dup 3 [(match_dup 5) (const_int 0)])))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    if (GET_CODE (operands[1])\n \t    == reverse_condition (GET_CODE (operands[3])))\n \t;\n@@ -659,8 +662,9 @@\n        /* Make the condition pairs line up by rotating the compare word.  */\n        int cv1 = condition_value (operands[1]);\n        int cv2 = condition_value (operands[3]);\n-       operands[2] = gen_rtx (ROTATE, CCmode, operands[2],\n-\t\t\t      GEN_INT (((cv1 & ~1) - (cv2 & ~1)) & 0x1f));\n+       operands[2] = gen_rtx_ROTATE (CCmode, operands[2],\n+\t\t\t\t     GEN_INT (((cv1 & ~1) - (cv2 & ~1))\n+\t\t\t\t\t      & 0x1f));\n      }\")\n \n (define_split\n@@ -679,10 +683,10 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\n    /* Reverse the condition by  complimenting the compare word.  */\n    if (GET_CODE (operands[1]) != GET_CODE (operands[3]))\n-      operands[4] = gen_rtx (NOT, CCmode, operands[4]);\")\n+      operands[4] = gen_rtx_NOT (CCmode, operands[4]);\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -699,7 +703,7 @@\n \t\t(match_dup 2)))\n    (set (match_dup 0)\n \t(match_op_dup 1 [(match_dup 5) (const_int 0)]))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\")\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -716,7 +720,7 @@\n \t\t(match_dup 4)))\n    (set (match_dup 0)\n \t(match_op_dup 3 [(match_dup 5) (const_int 0)]))]\n-  \"operands[5] = gen_rtx(SUBREG, CCEVENmode, operands[5], 0);\")\n+  \"operands[5] = gen_rtx_SUBREG (CCEVENmode, operands[5], 0);\")\n \n \f\n ;; Logical operations on compare words.\n@@ -1786,7 +1790,7 @@\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \n@@ -2279,8 +2283,8 @@\n     {\n       operands[1]\n \t= legitimize_address (flag_pic, operands[1], 0, 0);\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t  gen_rtx (ZERO_EXTEND, SImode, operands[1])));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t      gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n       DONE;\n     }\n }\")\n@@ -2852,7 +2856,7 @@\n \n   if (TARGET_USE_DIV)\n     {\n-      emit_move_insn (op0, gen_rtx (DIV, SImode, op1, op2));\n+      emit_move_insn (op0, gen_rtx_DIV (SImode, op1, op2));\n       if (TARGET_CHECK_ZERO_DIV && GET_CODE (op2) != CONST_INT)\n \t{\n \t  rtx label = gen_label_rtx ();\n@@ -2881,7 +2885,7 @@\n       emit_insn (gen_cmpsi (op2, const0_rtx));\n       emit_jump_insn (gen_bgt (label1));\n \t\t\t\t\t\t/* constant / 0-or-negative */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, neg_op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, op1, neg_op2));\n       if (!neg)\n \temit_insn (gen_negsi2 (op0, op0));\n \n@@ -2891,7 +2895,7 @@\n       emit_barrier ();\n \n       emit_label (label1);\t\t\t/* constant / positive */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, op1, op2));\n       if (neg)\n \temit_insn (gen_negsi2 (op0, op0));\n     }\n@@ -2914,15 +2918,15 @@\n       emit_insn (gen_cmpsi (op1, const0_rtx));\n       emit_jump_insn (gen_bge (label1));\n \t\t\t\t\t\t/* 0-or-negative / constant */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, neg_op1, op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, neg_op1, op2));\n       if (!neg)\n \temit_insn (gen_negsi2 (op0, op0));\n \n       emit_jump_insn (gen_jump (join_label));\n       emit_barrier ();\n \n       emit_label (label1);\t\t\t/* positive / constant */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, op1, op2));\n       if (neg)\n \temit_insn (gen_negsi2 (op0, op0));\n     }\n@@ -2944,7 +2948,7 @@\n       emit_insn (gen_cmpsi (op1, const0_rtx));\n       emit_jump_insn (gen_bge (label2));\n \t\t\t\t\t\t/* negative / negative-or-0 */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, neg_op1, neg_op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, neg_op1, neg_op2));\n \n       if (TARGET_CHECK_ZERO_DIV)\n \t{\n@@ -2958,7 +2962,7 @@\n       emit_barrier ();\n \n       emit_label (label2);\t\t\t/* pos.-or-0 / neg.-or-0 */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, neg_op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, op1, neg_op2));\n \n       if (TARGET_CHECK_ZERO_DIV)\n \t{\n@@ -2975,13 +2979,13 @@\n       emit_insn (gen_cmpsi (op1, const0_rtx));\n       emit_jump_insn (gen_bge (label3));\n \t\t\t\t\t\t/* negative / positive */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, neg_op1, op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, neg_op1, op2));\n       emit_insn (gen_negsi2 (op0, op0));\n       emit_jump_insn (gen_jump (join_label));\n       emit_barrier ();\n \n       emit_label (label3);\t\t\t/* positive-or-0 / positive */\n-      emit_move_insn (op0, gen_rtx (UDIV, SImode, op1, op2));\n+      emit_move_insn (op0, gen_rtx_UDIV (SImode, op1, op2));\n     }\n \n   emit_label (join_label);\n@@ -3016,8 +3020,8 @@\n   else if (GET_CODE (op2) != CONST_INT && TARGET_CHECK_ZERO_DIV)\n     {\n       rtx label = gen_label_rtx ();\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t  gen_rtx (UDIV, SImode, operands[1], op2)));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t      gen_rtx_UDIV (SImode, operands[1], op2)));\n       emit_insn (gen_tcnd_divide_by_zero (op2, label));\n       emit_label (label);\n       emit_insn (gen_dummy (operands[0]));\n@@ -3801,7 +3805,7 @@\n {\n   register rtx index_diff = gen_reg_rtx (SImode);\n   register rtx low = GEN_INT (-INTVAL (operands[1]));\n-  register rtx label = gen_rtx (LABEL_REF, VOIDmode, operands[3]);\n+  register rtx label = gen_rtx_LABEL_REF (Pmode, operands[3]);\n   register rtx base;\n \n   if (! CASE_VECTOR_INSNS)\n@@ -3879,8 +3883,8 @@\n {\n   if (GET_CODE (operands[0]) == MEM\n       && ! call_address_operand (XEXP (operands[0], 0), SImode))\n-    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n-\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+    operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),\n+\t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n }\")\n \n (define_insn \"\"\n@@ -3901,8 +3905,8 @@\n {\n   if (GET_CODE (operands[1]) == MEM\n       && ! call_address_operand (XEXP (operands[1], 0), SImode))\n-    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n+    operands[1] = gen_rtx_MEM (GET_MODE (operands[1]),\n+\t\t\t       force_reg (Pmode, XEXP (operands[1], 0)));\n }\")\n \n (define_insn \"\""}, {"sha": "11df8850ff0409ab821c6ea6d1eeaffc511ac4e3", "filename": "gcc/config/m88k/sysv3.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fsysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fm88k%2Fsysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fsysv3.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    Motorola m88100 running the AT&T/Unisoft/Motorola V.3 reference port.\n-   Copyright (C) 1990, 1991, 1997, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Ray Essick (ressick@mot.com)\n    Enhanced by Tom Wood (Tom_Wood@NeXT.com)\n \n@@ -145,10 +145,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef INITIALIZE_TRAMPOLINE \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 36)), CXT); \\\n-  emit_call_insn (gen_call (gen_rtx (MEM, SImode,\t\t\t\\\n-\t\t\t\t     gen_rtx (SYMBOL_REF, Pmode,\t\\\n-\t\t\t\t\t     \"__enable_execute_stack\")), \\\n-\t\t\t   const0_rtx));\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 36)), CXT); \\\n+  emit_call_insn (gen_call\t\t\t\t\t\t\\\n+\t\t  (gen_rtx_MEM\t\t\t\t\t\t\\\n+\t\t   (SImode,\t\t\t\t\t\t\\\n+\t\t    gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\")), \\\n+\t\t   const0_rtx));\t\t\t\t\t\\\n }"}, {"sha": "3e4447e5bdd40fc4f12868500632ac40db8e80fa", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -134,7 +134,7 @@ extern struct rtx_def *mips_function_value ();\n \t\tptr = plus_constant (virtual_incoming_args_rtx,\t\t\\\n \t\t\t\t     - (mips_save_gp_regs\t\t\\\n \t\t\t\t\t* UNITS_PER_WORD));\t\t\\\n-\t      mem = gen_rtx (MEM, BLKmode, ptr);\t\t\t\\\n+\t      mem = gen_rtx_MEM (BLKmode, ptr);\t\t\t\\\n \t      /* va_arg is an array access in this case, which causes\t\\\n \t\t it to get MEM_IN_STRUCT_P set.  We must set it here\t\\\n \t\t so that the insn scheduler won't assume that these\t\\\n@@ -167,15 +167,15 @@ extern struct rtx_def *mips_function_value ();\n \t      for (i = 0; i < mips_save_fp_regs; i++)\t\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n \t\t  rtx tem =\t\t\t\t\t\t\\\n-\t\t    gen_rtx (MEM, mode,\t\t\t\t\t\\\n-\t\t\t     plus_constant (virtual_incoming_args_rtx,\t\\\n-\t\t\t\t\t    off));\t\t\t\\\n+\t\t    gen_rtx_MEM (mode,\t\t\t\t\t\\\n+\t\t\t\t plus_constant (virtual_incoming_args_rtx, \\\n+\t\t\t\t\t\toff));\t\t\t\\\n \t\t  emit_move_insn (tem,\t\t\t\t\t\\\n-\t\t\t\t  gen_rtx (REG, mode,\t\t\t\\\n-\t\t\t\t\t   ((CUM).fp_arg_words\t\t\\\n-\t\t\t\t\t    + FP_ARG_FIRST\t\t\\\n-\t\t\t\t\t    + i\t\t\t\t\\\n-\t\t\t\t\t    + mips_fp_off)));\t\t\\\n+\t\t\t\t  gen_rtx_REG (mode,\t\t\t\\\n+\t\t\t\t\t       ((CUM).fp_arg_words\t\\\n+\t\t\t\t\t\t+ FP_ARG_FIRST\t\t\\\n+\t\t\t\t\t\t+ i\t\t\t\\\n+\t\t\t\t\t\t+ mips_fp_off)));\t\\\n \t\t  off += size;\t\t\t\t\t\t\\\n \t\t  if (! TARGET_FLOAT64 || TARGET_SINGLE_FLOAT)\t\t\\\n \t\t    ++i;\t\t\t\t\t\t\\\n@@ -193,8 +193,7 @@ extern struct rtx_def *mips_function_value ();\n    argument itself.  The pointer is passed in whatever way is appropriate\n    for passing a pointer to that type.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (mips_abi == ABI_EABI\t\t\t\t\t\t\t\\\n-   && function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED))\n+  function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED)\n \n /* A C expression that indicates when it is the called function's\n    responsibility to make a copy of arguments passed by invisible"}, {"sha": "e65e4be7a8d7dccb4b7c8c2e9a209149bea65b86", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 95, "deletions": 77, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -29,7 +29,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include <signal.h>\n-\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -41,6 +40,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-codes.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"output.h\"\n+\n #include \"tree.h\"\n #include \"function.h\"\n #include \"expr.h\"\n@@ -1478,14 +1479,14 @@ mips_fill_delay_slot (ret, type, operands, cur_insn)\n   mips_load_reg = set_reg;\n   if (GET_MODE_SIZE (mode)\n       > (FP_REG_P (REGNO (set_reg)) ? UNITS_PER_FPREG : UNITS_PER_WORD))\n-    mips_load_reg2 = gen_rtx (REG, SImode, REGNO (set_reg) + 1);\n+    mips_load_reg2 = gen_rtx_REG (SImode, REGNO (set_reg) + 1);\n   else\n     mips_load_reg2 = 0;\n \n   if (type == DELAY_HILO)\n     {\n-      mips_load_reg3 = gen_rtx (REG, SImode, MD_REG_FIRST);\n-      mips_load_reg4 = gen_rtx (REG, SImode, MD_REG_FIRST+1);\n+      mips_load_reg3 = gen_rtx_REG (SImode, MD_REG_FIRST);\n+      mips_load_reg4 = gen_rtx_REG (SImode, MD_REG_FIRST+1);\n     }\n   else\n     {\n@@ -1646,9 +1647,10 @@ embedded_pic_offset (x)\n       pop_topmost_sequence ();\n     }\n \n-  return gen_rtx (CONST, Pmode,\n-\t\t  gen_rtx (MINUS, Pmode, x,\n-\t\t\t   XEXP (DECL_RTL (current_function_decl), 0)));\n+  return\n+    gen_rtx_CONST (Pmode,\n+\t\t   gen_rtx_MINUS (Pmode, x,\n+\t\t\t\t  XEXP (DECL_RTL (current_function_decl), 0)));\n }\n \n /* Return the appropriate instructions to move one operand to another.  */\n@@ -2790,7 +2792,7 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n   else if (test == ITEST_EQ)\n     {\n       reg2 = invert ? gen_reg_rtx (mode) : result;\n-      convert_move (reg2, gen_rtx (LTU, mode, reg, const1_rtx), 0);\n+      convert_move (reg2, gen_rtx_LTU (mode, reg, const1_rtx), 0);\n       reg = reg2;\n     }\n \n@@ -2857,18 +2859,18 @@ gen_conditional_branch (operands, test_code)\n     case CMP_SF:\n     case CMP_DF:\n       if (mips_isa < 4)\n-\treg = gen_rtx (REG, CCmode, FPSW_REGNUM);\n+\treg = gen_rtx_REG (CCmode, FPSW_REGNUM);\n       else\n \treg = gen_reg_rtx (CCmode);\n \n       /* For cmp0 != cmp1, build cmp0 == cmp1, and test for result ==\n          0 in the instruction built below.  The MIPS FPU handles\n          inequality testing by testing for equality and looking for a\n          false result.  */\n-      emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t  gen_rtx (test_code == NE ? EQ : test_code,\n-\t\t\t\t   CCmode, cmp0, cmp1)));\n-\n+      emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t      gen_rtx (test_code == NE ? EQ : test_code,\n+\t\t\t\t       CCmode, cmp0, cmp1)));\n+      \n       test_code = test_code == NE ? EQ : NE;\n       mode = CCmode;\n       cmp0 = reg;\n@@ -2882,7 +2884,7 @@ gen_conditional_branch (operands, test_code)\n \n   /* Generate the branch.  */\n \n-  label1 = gen_rtx (LABEL_REF, VOIDmode, operands[0]);\n+  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n   label2 = pc_rtx;\n \n   if (invert)\n@@ -2891,10 +2893,11 @@ gen_conditional_branch (operands, test_code)\n       label1 = pc_rtx;\n     }\n \n-  emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n-\t\t\t\t    gen_rtx (test_code, mode, cmp0, cmp1),\n-\t\t\t\t    label1, label2)));\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t\t     gen_rtx (test_code, mode,\n+\t\t\t\t\t\t\t      cmp0, cmp1),\n+\t\t\t\t\t\t     label1, label2)));\n }\n \n /* Emit the common code for conditional moves.  OPERANDS is the array\n@@ -2973,14 +2976,15 @@ gen_conditional_move (operands)\n     abort ();\n \n   cmp_reg = gen_reg_rtx (cmp_mode);\n-  emit_insn (gen_rtx (SET, cmp_mode, cmp_reg,\n-\t\t      gen_rtx (cmp_code, cmp_mode, op0, op1)));\n-\n-  emit_insn (gen_rtx (SET, op_mode, operands[0],\n-\t\t      gen_rtx (IF_THEN_ELSE, op_mode,\n-\t\t\t       gen_rtx (move_code, VOIDmode,\n-\t\t\t\t\tcmp_reg, CONST0_RTX (SImode)),\n-\t\t\t       operands[2], operands[3])));\n+  emit_insn (gen_rtx_SET (cmp_mode, cmp_reg,\n+\t\t\t  gen_rtx (cmp_code, cmp_mode, op0, op1)));\n+\n+  emit_insn (gen_rtx_SET (op_mode, operands[0],\n+\t\t\t  gen_rtx_IF_THEN_ELSE (op_mode,\n+\t\t\t\t\t\tgen_rtx (move_code, VOIDmode,\n+\t\t\t\t\t\t\t cmp_reg,\n+\t\t\t\t\t\t\t CONST0_RTX (SImode)),\n+\t\t\t\t\t\toperands[2], operands[3])));\n }\n \f\n /* Write a loop to move a constant number of bytes.\n@@ -3097,13 +3101,13 @@ block_move_call (dest_reg, src_reg, bytes_rtx)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n \n #ifdef TARGET_MEM_FUNCTIONS\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n \t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n \t\t\t\t      TREE_UNSIGNED (sizetype)),\n \t\t     TYPE_MODE (sizetype));\n #else\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"bcopy\"), 0,\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"bcopy\"), 0,\n \t\t     VOIDmode, 3, src_reg, Pmode, dest_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (integer_type_node), bytes_rtx,\n \t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n@@ -3502,23 +3506,23 @@ output_block_move (insn, operands, num_regs, move_type)\n \t\t    abort ();\n \n \t\t  if (GET_MODE (operands[i + 4]) != load_store[i].mode)\n-\t\t    operands[i + 4] = gen_rtx (REG, load_store[i].mode,\n-\t\t\t\t\t       REGNO (operands[i + 4]));\n+\t\t    operands[i + 4] = gen_rtx_REG (load_store[i].mode,\n+\t\t\t\t\t\t   REGNO (operands[i + 4]));\n \n \t\t  offset = load_store[i].offset;\n \t\t  xoperands[0] = operands[i + 4];\n-\t\t  xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t\t  plus_constant (src_reg, offset));\n+\t\t  xoperands[1] = gen_rtx_MEM (load_store[i].mode,\n+\t\t\t\t\t      plus_constant (src_reg, offset));\n \n \t\t  if (use_lwl_lwr)\n \t\t    {\n \t\t      int extra_offset\n \t\t\t= GET_MODE_SIZE (load_store[i].mode) - 1;\n \n-\t\t      xoperands[2] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t\t      plus_constant (src_reg,\n-\t\t\t\t\t\t\t     extra_offset\n-\t\t\t\t\t\t\t     + offset));\n+\t\t      xoperands[2] = gen_rtx_MEM (load_store[i].mode,\n+\t\t\t\t\t\t  plus_constant (src_reg,\n+\t\t\t\t\t\t\t\t extra_offset\n+\t\t\t\t\t\t\t\t + offset));\n \t\t    }\n \n \t\t  output_asm_insn (load_store[i].load, xoperands);\n@@ -3531,17 +3535,17 @@ output_block_move (insn, operands, num_regs, move_type)\n \t      int offset = load_store[i].offset;\n \n \t      xoperands[0] = operands[i + 4];\n-\t      xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t      plus_constant (dest_reg, offset));\n+\t      xoperands[1] = gen_rtx_MEM (load_store[i].mode,\n+\t\t\t\t\t  plus_constant (dest_reg, offset));\n \n \n \t      if (use_lwl_lwr)\n \t\t{\n \t\t  int extra_offset = GET_MODE_SIZE (load_store[i].mode) - 1;\n-\t\t  xoperands[2] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t\t  plus_constant (dest_reg,\n-\t\t\t\t\t\t\t extra_offset\n-\t\t\t\t\t\t\t + offset));\n+\t\t  xoperands[2] = gen_rtx_MEM (load_store[i].mode,\n+\t\t\t\t\t      plus_constant (dest_reg,\n+\t\t\t\t\t\t\t     extra_offset\n+\t\t\t\t\t\t\t     + offset));\n \t\t}\n \n \t      if (move_type == BLOCK_MOVE_NORMAL)\n@@ -3814,7 +3818,7 @@ function_arg (cum, mode, type, named)\n \n       if (! type || TREE_CODE (type) != RECORD_TYPE || mips_abi == ABI_32\n \t  || mips_abi == ABI_EABI || mips_abi == ABI_O64 || ! named)\n-\tret = gen_rtx (REG, mode, regbase + *arg_words + bias);\n+\tret = gen_rtx_REG (mode, regbase + *arg_words + bias);\n       else\n \t{\n \t  /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n@@ -3834,7 +3838,7 @@ function_arg (cum, mode, type, named)\n \t  /* If the whole struct fits a DFmode register,\n \t     we don't need the PARALLEL.  */\n \t  if (! field || mode == DFmode)\n-\t    ret = gen_rtx (REG, mode, regbase + *arg_words + bias);\n+\t    ret = gen_rtx_REG (mode, regbase + *arg_words + bias);\n \t  else\n \t    {\n \t      /* Now handle the special case by returning a PARALLEL\n@@ -3853,7 +3857,7 @@ function_arg (cum, mode, type, named)\n \n \t      /* assign_parms checks the mode of ENTRY_PARM, so we must\n \t\t use the actual mode here.  */\n-\t      ret = gen_rtx (PARALLEL, mode, rtvec_alloc (chunks));\n+\t      ret = gen_rtx_PARALLEL (mode, rtvec_alloc (chunks));\n \n \t      bitpos = 0;\n \t      regno = regbase + *arg_words + bias;\n@@ -3872,14 +3876,14 @@ function_arg (cum, mode, type, named)\n \t\t      && TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)) == bitpos\n \t\t      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t\t      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n-\t\t    reg = gen_rtx (REG, DFmode,\n-\t\t\t\t   regno + FP_ARG_FIRST - GP_ARG_FIRST);\n+\t\t    reg = gen_rtx_REG (DFmode,\n+\t\t\t\t       regno + FP_ARG_FIRST - GP_ARG_FIRST);\n \t\t  else\n-\t\t    reg = gen_rtx (REG, word_mode, regno);\n-\n+\t\t    reg = gen_rtx_REG (word_mode, regno);\n+\t\t  \n \t\t  XVECEXP (ret, 0, i) \n-\t\t    = gen_rtx (EXPR_LIST, VOIDmode, reg,\n-\t\t\t       GEN_INT (bitpos / BITS_PER_UNIT));\n+\t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg,\n+\t\t\t\t\t GEN_INT (bitpos / BITS_PER_UNIT));\n \n \t\t  bitpos += 64;\n \t\t  regno++;\n@@ -3915,7 +3919,7 @@ function_arg (cum, mode, type, named)\n \t{\n \t  rtx amount = GEN_INT (BITS_PER_WORD\n \t\t\t\t- int_size_in_bytes (type) * BITS_PER_UNIT);\n-\t  rtx reg = gen_rtx (REG, word_mode, regbase + *arg_words + bias);\n+\t  rtx reg = gen_rtx_REG (word_mode, regbase + *arg_words + bias);\n \n \t  if (TARGET_64BIT)\n \t    cum->adjust[cum->num_adjusts++] = gen_ashldi3 (reg, reg, amount);\n@@ -5773,7 +5777,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t       && (unsigned HOST_WIDE_INT) (large_offset - gp_offset) < 32768\n \t       && (unsigned HOST_WIDE_INT) (large_offset - end_offset) < 32768)\n \t{\n-\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = large_offset;\n \t  if (file == 0)\n \t    {\n@@ -5796,7 +5800,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n       else\n \t{\n-\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = gp_offset;\n \t  if (file == 0)\n \t    {\n@@ -5990,7 +5994,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t       && (unsigned HOST_WIDE_INT) (large_offset - fp_offset) < 32768\n \t       && (unsigned HOST_WIDE_INT) (large_offset - end_offset) < 32768)\n \t{\n-\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = large_offset;\n \t  if (file == 0)\n \t    {\n@@ -6014,7 +6018,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n       else\n \t{\n-\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = fp_offset;\n \t  if (file == 0)\n \t    {\n@@ -6665,7 +6669,7 @@ mips_expand_prologue ()\n \n       if (TARGET_ABICALLS && (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0),\n-\t\t\t       gen_rtx (REG, DImode, 25)));\n+\t\t\t       gen_rtx_REG (DImode, 25)));\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -6794,7 +6798,7 @@ mips_expand_epilogue ()\n \n   if (tsize > 32767 && ! TARGET_MIPS16)\n     {\n-      tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n+      tmp_rtx = gen_rtx_REG (Pmode, MIPS_TEMP1_REGNUM);\n       emit_move_insn (tmp_rtx, tsize_rtx);\n       tsize_rtx = tmp_rtx;\n     }\n@@ -7111,12 +7115,13 @@ mips_function_value (valtype, func)\n \t\t strictly necessary.  */\n \t      enum machine_mode field_mode = TYPE_MODE (TREE_TYPE (fields[0]));\n \n-\t      return gen_rtx (PARALLEL, mode,\n-\t\t\t      gen_rtvec (1,\n-\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\t  gen_rtx (REG, field_mode,\n-\t\t\t\t\t\t\t   FP_RETURN),\n-\t\t\t\t\t\t  const0_rtx)));\n+\t      return gen_rtx_PARALLEL\n+\t\t(mode,\n+\t\t gen_rtvec (1,\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (field_mode,\n+\t\t\t\t\t\t\t    FP_RETURN),\n+\t\t\t\t\t       const0_rtx)));\n \t    }\n \n \t  else if (i == 2)\n@@ -7130,23 +7135,24 @@ mips_function_value (valtype, func)\n \t      int second_offset\n \t\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (fields[1]));\n \n-\t      return gen_rtx (PARALLEL, mode,\n-\t\t\t      gen_rtvec (2,\n-\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\t  gen_rtx (REG, first_mode,\n-\t\t\t\t\t\t\t   FP_RETURN),\n-\t\t\t\t\t\t  GEN_INT (first_offset\n-\t\t\t\t\t\t\t   / BITS_PER_UNIT)),\n-\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\t  gen_rtx (REG, second_mode,\n-\t\t\t\t\t\t\t   FP_RETURN + 2),\n-\t\t\t\t\t\t  GEN_INT (second_offset\n-\t\t\t\t\t\t\t   / BITS_PER_UNIT))));\n+\t      return gen_rtx_PARALLEL\n+\t\t(mode,\n+\t\t gen_rtvec (2,\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (first_mode,\n+\t\t\t\t\t\t\t    FP_RETURN),\n+\t\t\t\t\t       GEN_INT (first_offset\n+\t\t\t\t\t\t\t/ BITS_PER_UNIT)),\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (second_mode,\n+\t\t\t\t\t\t\t    FP_RETURN + 2),\n+\t\t\t\t\t       GEN_INT (second_offset\n+\t\t\t\t\t\t\t/ BITS_PER_UNIT))));\n \t    }\n \t}\n     }\n \n-  return gen_rtx (REG, mode, reg);\n+  return gen_rtx_REG (mode, reg);\n }\n \n /* The implementation of FUNCTION_ARG_PASS_BY_REFERENCE.  Return\n@@ -7161,6 +7167,18 @@ function_arg_pass_by_reference (cum, mode, type, named)\n {\n   int size;\n \n+  /* We must pass by reference if we would be both passing in registers\n+     and the stack.  This is because any subsequent partial arg would be\n+     handled incorrectly in this case.\n+\n+     ??? This is really a kludge.  We should either fix GCC so that such\n+     a situation causes an abort and then do something in the MIPS port\n+     to prevent it, or add code to function.c to properly handle the case.  */\n+  if (FUNCTION_ARG (*cum, mode, type, named) != 0\n+      && MUST_PASS_IN_STACK (mode, type))\n+    return 1;\n+\n+  /* Otherwise, we only do this if EABI is selected.  */\n   if (mips_abi != ABI_EABI)\n     return 0;\n "}, {"sha": "084f5d2a9257dcf0a7bd9e4f5120e94eb5ef8f1b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1131,7 +1131,7 @@ while (0)\n #define DWARF_FRAME_RETURN_COLUMN (FP_REG_LAST + 1)\n \n /* Before the prologue, RA lives in r31.  */\n-#define INCOMING_RETURN_ADDR_RTX  gen_rtx (REG, VOIDmode, GP_REG_FIRST + 31)\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, GP_REG_FIRST + 31)\n \n /* Overrides for the COFF debug format.  */\n #define PUT_SDB_SCL(a)\t\t\t\t\t\\\n@@ -2164,7 +2164,7 @@ extern enum reg_class\tmips_secondary_reload_class ();\n \n #define RETURN_ADDR_RTX(count, frame)\t\t\t\\\n   ((count == 0)\t\t\t\t\t\t\\\n-   ? gen_rtx (MEM, Pmode, gen_rtx (REG, Pmode, RETURN_ADDRESS_POINTER_REGNUM))\\\n+   ? gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM))\\\n    : (rtx) 0)\n \n /* Structure to be filled in by compute_frame_size with register\n@@ -2706,19 +2706,19 @@ typedef struct mips_args {\n   rtx addr = ADDR;\t\t\t\t\t\t\t    \\\n   if (Pmode == DImode)\t\t\t\t\t\t\t    \\\n     {\t\t\t\t\t\t\t\t\t    \\\n-      emit_move_insn (gen_rtx (MEM, DImode, plus_constant (addr, 32)), FUNC); \\\n-      emit_move_insn (gen_rtx (MEM, DImode, plus_constant (addr, 40)), CHAIN);\\\n+      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (addr, 32)), FUNC); \\\n+      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (addr, 40)), CHAIN);\\\n     }\t\t\t\t\t\t\t\t\t    \\\n   else\t\t\t\t\t\t\t\t\t    \\\n     {\t\t\t\t\t\t\t\t\t    \\\n-      emit_move_insn (gen_rtx (MEM, SImode, plus_constant (addr, 32)), FUNC); \\\n-      emit_move_insn (gen_rtx (MEM, SImode, plus_constant (addr, 36)), CHAIN);\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 32)), FUNC); \\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 36)), CHAIN);\\\n     }\t\t\t\t\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n   /* Flush both caches.  We need to flush the data cache in case\t    \\\n      the system has a write-back cache.  */\t\t\t\t    \\\n   /* ??? Should check the return value for errors.  */\t\t\t    \\\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, CACHE_FLUSH_FUNC),\t    \\\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, CACHE_FLUSH_FUNC),\t    \\\n \t\t     0, VOIDmode, 3, addr, Pmode,\t\t\t    \\\n \t\t     GEN_INT (TRAMPOLINE_SIZE), TYPE_MODE (integer_type_node),\\\n \t\t     GEN_INT (3), TYPE_MODE (integer_type_node));\t    \\\n@@ -3050,8 +3050,10 @@ typedef struct mips_args {\n   if (mips_split_addresses && mips_check_split (X, MODE))\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /* ??? Is this ever executed?  */\t\t\t\t\t\\\n-      X = gen_rtx (LO_SUM, Pmode,\t\t\t\t\t\\\n-\t\t   copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode, X)), X); \\\n+      X = gen_rtx_LO_SUM (Pmode,\t\t\t\t\t\\\n+\t\t\t  copy_to_mode_reg (Pmode,\t\t\t\\\n+\t\t\t\t\t    gen_rtx (HIGH, Pmode, X)),\t\\\n+\t\t\t  X);\t\t\t\t\t\t\\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -3067,7 +3069,7 @@ typedef struct mips_args {\n \t\t\t\t\t\t\t\t\t\\\n       emit_move_insn (ptr_reg, XEXP (XEXP (xinsn, 0), 0));\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      X = gen_rtx (PLUS, Pmode, ptr_reg, constant);\t\t\t\\\n+      X = gen_rtx_PLUS (Pmode, ptr_reg, constant);\t\t\t\\\n       if (SMALL_INT (constant))\t\t\t\t\t\t\\\n \tgoto WIN;\t\t\t\t\t\t\t\\\n       /* Otherwise we fall through so the code below will fix the\t\\\n@@ -3099,12 +3101,12 @@ typedef struct mips_args {\n \t  emit_move_insn (int_reg,\t\t\t\t\t\\\n \t\t\t  GEN_INT (INTVAL (xplus1) & ~ 0x7fff));\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\t  emit_insn (gen_rtx (SET, VOIDmode,\t\t\t\t\\\n-\t\t\t      ptr_reg,\t\t\t\t\t\\\n-\t\t\t      gen_rtx (PLUS, Pmode, xplus0, int_reg)));\t\\\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\t\t\t\t\\\n+\t\t\t\t  ptr_reg,\t\t\t\t\\\n+\t\t\t\t  gen_rtx_PLUS (Pmode, xplus0, int_reg))); \\\n \t\t\t\t\t\t\t\t\t\\\n-\t  X = gen_rtx (PLUS, Pmode, ptr_reg,\t\t\t\t\\\n-\t\t       GEN_INT (INTVAL (xplus1) & 0x7fff));\t\t\\\n+\t  X = gen_rtx_PLUS (Pmode, ptr_reg,\t\t\t\t\\\n+\t\t\t    GEN_INT (INTVAL (xplus1) & 0x7fff));\t\\\n \t  goto WIN;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "ff03d01e1d527c35f02398c7bcc00e1683f0b0d6", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 84, "deletions": 83, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,9 +1,9 @@\n ;;  Mips.md\t     Machine Description for MIPS based processors\n+;;  Copyright (C) 1989, 90-98, 1999 Free Software Foundation, Inc.\n ;;  Contributed by   A. Lichnewsky, lich@inria.inria.fr\n ;;  Changes by       Michael Meissner, meissner@osf.org\n ;;  64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n ;;  Brendan Eich, brendan@microunity.com.\n-;;  Copyright (C) 1989, 90-98, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1701,7 +1701,7 @@\n   rtx xoperands[10];\n \n   xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx (REG, SImode, LO_REGNUM);\n+  xoperands[1] = gen_rtx_REG (SImode, LO_REGNUM);\n \n   output_asm_insn (\\\"mult\\\\t%1,%2\\\", operands);\n   output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n@@ -1829,13 +1829,13 @@\n     output_asm_insn (\\\"dmult\\\\t%0,%1,%2\\\", operands);\n   else \n     {\n-    rtx xoperands[10];\n+      rtx xoperands[10];\n \n-    xoperands[0] = operands[0];\n-    xoperands[1] = gen_rtx (REG, DImode, LO_REGNUM);\n+      xoperands[0] = operands[0];\n+      xoperands[1] = gen_rtx_REG (DImode, LO_REGNUM);\n \n-    output_asm_insn (\\\"dmult\\\\t%1,%2\\\", operands);\n-    output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n+      output_asm_insn (\\\"dmult\\\\t%1,%2\\\", operands);\n+      output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n     }\n   return \\\"\\\";\n }\"\n@@ -4265,12 +4265,12 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_jump_insn (gen_bge (label1));\n \n       emit_insn (gen_fix_truncdfsi2 (operands[0], operands[1]));\n-      emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx (LABEL_REF, VOIDmode, label2)));\n+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, label2)));\n       emit_barrier ();\n \n       emit_label (label1);\n-      emit_move_insn (reg2, gen_rtx (MINUS, DFmode, operands[1], reg1));\n+      emit_move_insn (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));\n       emit_move_insn (reg3, GEN_INT (0x80000000));\n \n       emit_insn (gen_fix_truncdfsi2 (operands[0], reg2));\n@@ -4280,7 +4280,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n       /* allow REG_NOTES to be set on last insn (labels don't have enough\n \t fields, and can't be used for REG_NOTES anyway).  */\n-      emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n       DONE;\n     }\n }\")\n@@ -4308,12 +4308,12 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_jump_insn (gen_bge (label1));\n \n       emit_insn (gen_fix_truncdfdi2 (operands[0], operands[1]));\n-      emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx (LABEL_REF, VOIDmode, label2)));\n+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, label2)));\n       emit_barrier ();\n \n       emit_label (label1);\n-      emit_move_insn (reg2, gen_rtx (MINUS, DFmode, operands[1], reg1));\n+      emit_move_insn (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));\n       emit_move_insn (reg3, GEN_INT (0x80000000));\n       emit_insn (gen_ashldi3 (reg3, reg3, GEN_INT (32)));\n \n@@ -4324,7 +4324,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n       /* allow REG_NOTES to be set on last insn (labels don't have enough\n \t fields, and can't be used for REG_NOTES anyway).  */\n-      emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n       DONE;\n     }\n }\")\n@@ -4352,12 +4352,12 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_jump_insn (gen_bge (label1));\n \n       emit_insn (gen_fix_truncsfsi2 (operands[0], operands[1]));\n-      emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx (LABEL_REF, VOIDmode, label2)));\n+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, label2)));\n       emit_barrier ();\n \n       emit_label (label1);\n-      emit_move_insn (reg2, gen_rtx (MINUS, SFmode, operands[1], reg1));\n+      emit_move_insn (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));\n       emit_move_insn (reg3, GEN_INT (0x80000000));\n \n       emit_insn (gen_fix_truncsfsi2 (operands[0], reg2));\n@@ -4367,7 +4367,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n       /* allow REG_NOTES to be set on last insn (labels don't have enough\n \t fields, and can't be used for REG_NOTES anyway).  */\n-      emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n       DONE;\n     }\n }\")\n@@ -4395,12 +4395,12 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_jump_insn (gen_bge (label1));\n \n       emit_insn (gen_fix_truncsfdi2 (operands[0], operands[1]));\n-      emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx (LABEL_REF, VOIDmode, label2)));\n+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t\t   gen_rtx_LABEL_REF (VOIDmode, label2)));\n       emit_barrier ();\n \n       emit_label (label1);\n-      emit_move_insn (reg2, gen_rtx (MINUS, SFmode, operands[1], reg1));\n+      emit_move_insn (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));\n       emit_move_insn (reg3, GEN_INT (0x80000000));\n       emit_insn (gen_ashldi3 (reg3, reg3, GEN_INT (32)));\n \n@@ -4411,7 +4411,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n       /* allow REG_NOTES to be set on last insn (labels don't have enough\n \t fields, and can't be used for REG_NOTES anyway).  */\n-      emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n       DONE;\n     }\n }\")\n@@ -4729,10 +4729,10 @@ move\\\\t%0,%z4\\\\n\\\\\n       rtx tem = ((reload_in_progress | reload_completed)\n \t\t ? operands[0] : gen_reg_rtx (mode));\n \n-      emit_insn (gen_rtx (SET, VOIDmode, tem,\n-\t\t\t  gen_rtx (HIGH, mode, operands[1])));\n+      emit_insn (gen_rtx_SET (VOIDmode, tem,\n+\t\t\t      gen_rtx_HIGH (mode, operands[1])));\n \n-      operands[1] = gen_rtx (LO_SUM, mode, tem, operands[1]);\n+      operands[1] = gen_rtx_LO_SUM (mode, tem, operands[1]);\n     }\n \n   /* If we are generating embedded PIC code, and we are referring to a\n@@ -4746,8 +4746,8 @@ move\\\\t%0,%z4\\\\n\\\\\n       rtx temp;\n \n       temp = embedded_pic_offset (operands[1]);\n-      temp = gen_rtx (PLUS, Pmode, embedded_pic_fnaddr_rtx,\n-\t\t      force_reg (DImode, temp));\n+      temp = gen_rtx_PLUS (Pmode, embedded_pic_fnaddr_rtx,\n+\t\t\t   force_reg (DImode, temp));\n       emit_move_insn (operands[0], force_reg (DImode, temp));\n       DONE;\n     }\n@@ -4762,7 +4762,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       if (! SMALL_INT (temp2))\n \ttemp2 = force_reg (DImode, temp2);\n \n-      emit_move_insn (operands[0], gen_rtx (PLUS, DImode, temp, temp2));\n+      emit_move_insn (operands[0], gen_rtx_PLUS (DImode, temp, temp2));\n       DONE;\n     }\n \n@@ -4972,10 +4972,10 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_64BIT\"\n   \"\n {\n-  rtx scratch = gen_rtx (REG, DImode,\n-\t\t\t (REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t  ? REGNO (operands[2]) + 1\n-\t\t\t  : REGNO (operands[2])));\n+  rtx scratch = gen_rtx_REG (DImode,\n+\t\t\t     (REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t      ? REGNO (operands[2]) + 1\n+\t\t\t      : REGNO (operands[2])));\n \n   if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n     {\n@@ -4985,7 +4985,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  rtx addr = find_replacement (&XEXP (operands[1], 0));\n \t  rtx op1 = change_address (operands[1], VOIDmode, addr);\n \n-\t  scratch = gen_rtx (REG, SImode, REGNO (scratch));\n+\t  scratch = gen_rtx_REG (SImode, REGNO (scratch));\n \t  memword = change_address (op1, SImode, NULL_RTX);\n \t  offword = change_address (adj_offsettable_operand (op1, 4),\n \t\t\t\t    SImode, NULL_RTX);\n@@ -5000,15 +5000,15 @@ move\\\\t%0,%z4\\\\n\\\\\n \t      loword = memword;\n \t    }\n \t  emit_move_insn (scratch, hiword);\n-\t  emit_move_insn (gen_rtx (REG, SImode, 64), scratch);\n+\t  emit_move_insn (gen_rtx_REG (SImode, 64), scratch);\n \t  emit_move_insn (scratch, loword);\n \t  emit_move_insn (gen_rtx (REG, SImode, 65), scratch);\n           emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n \t}\n       else\n \t{\n \t  emit_insn (gen_ashrdi3 (scratch, operands[1], GEN_INT (32)));\n-\t  emit_insn (gen_movdi (gen_rtx (REG, DImode, 64), scratch));\n+\t  emit_insn (gen_movdi (gen_rtx_REG (DImode, 64), scratch));\n \t  emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n \t  emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n \t  emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n@@ -5018,10 +5018,10 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n   if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n     {\n-      emit_insn (gen_movdi (scratch, gen_rtx (REG, DImode, 65)));\n+      emit_insn (gen_movdi (scratch, gen_rtx_REG (DImode, 65)));\n       emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n       emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n-      emit_insn (gen_movdi (operands[0], gen_rtx (REG, DImode, 64)));\n+      emit_insn (gen_movdi (operands[0], gen_rtx_REG (DImode, 64)));\n       emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n       emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n       emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n@@ -5065,7 +5065,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  rtx addr = find_replacement (&XEXP (operands[0], 0));\n \t  rtx op0 = change_address (operands[0], VOIDmode, addr);\n \n-\t  scratch = gen_rtx (REG, SImode, REGNO (operands[2]));\n+\t  scratch = gen_rtx_REG (SImode, REGNO (operands[2]));\n \t  memword = change_address (op0, SImode, NULL_RTX);\n \t  offword = change_address (adj_offsettable_operand (op0, 4),\n \t\t\t\t    SImode, NULL_RTX);\n@@ -5079,9 +5079,9 @@ move\\\\t%0,%z4\\\\n\\\\\n \t      hiword = offword;\n \t      loword = memword;\n \t    }\n-\t  emit_move_insn (scratch, gen_rtx (REG, SImode, 64));\n+\t  emit_move_insn (scratch, gen_rtx_REG (SImode, 64));\n \t  emit_move_insn (hiword, scratch);\n-\t  emit_move_insn (scratch, gen_rtx (REG, SImode, 65));\n+\t  emit_move_insn (scratch, gen_rtx_REG (SImode, 65));\n \t  emit_move_insn (loword, scratch);\n \t  emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n \t}\n@@ -5151,10 +5151,10 @@ move\\\\t%0,%z4\\\\n\\\\\n       rtx tem = ((reload_in_progress | reload_completed)\n \t\t ? operands[0] : gen_reg_rtx (mode));\n \n-      emit_insn (gen_rtx (SET, VOIDmode, tem,\n-\t\t\t  gen_rtx (HIGH, mode, operands[1])));\n+      emit_insn (gen_rtx_SET (VOIDmode, tem,\n+\t\t\t      gen_rtx_HIGH (mode, operands[1])));\n \n-      operands[1] = gen_rtx (LO_SUM, mode, tem, operands[1]);\n+      operands[1] = gen_rtx_LO_SUM (mode, tem, operands[1]);\n     }\n \n   /* If we are generating embedded PIC code, and we are referring to a\n@@ -5168,8 +5168,8 @@ move\\\\t%0,%z4\\\\n\\\\\n       rtx temp;\n \n       temp = embedded_pic_offset (operands[1]);\n-      temp = gen_rtx (PLUS, Pmode, embedded_pic_fnaddr_rtx,\n-\t\t      force_reg (SImode, temp));\n+      temp = gen_rtx_PLUS (Pmode, embedded_pic_fnaddr_rtx,\n+\t\t\t   force_reg (SImode, temp));\n       emit_move_insn (operands[0], force_reg (SImode, temp));\n       DONE;\n     }\n@@ -5184,7 +5184,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       if (! SMALL_INT (temp2))\n \ttemp2 = force_reg (SImode, temp2);\n \n-      emit_move_insn (operands[0], gen_rtx (PLUS, SImode, temp, temp2));\n+      emit_move_insn (operands[0], gen_rtx_PLUS (SImode, temp, temp2));\n       DONE;\n     }\n \n@@ -5429,7 +5429,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   if (TARGET_64BIT\n       && GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n     {\n-      emit_insn (gen_movsi (gen_rtx (REG, SImode, 65), operands[1]));\n+      emit_insn (gen_movsi (gen_rtx_REG (SImode, 65), operands[1]));\n       emit_insn (gen_ashrsi3 (operands[2], operands[1], GEN_INT (31)));\n       emit_insn (gen_movsi (gen_rtx (REG, SImode, 64), operands[2]));\n       emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n@@ -5596,17 +5596,17 @@ move\\\\t%0,%z4\\\\n\\\\\n   if (GET_CODE (operands[1]) == MEM)\n     source = change_address (operands[1], SFmode, NULL_RTX);\n   else if (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG)\n-    source = gen_rtx (REG, SFmode, true_regnum (operands[1]));\n+    source = gen_rtx_REG (SFmode, true_regnum (operands[1]));\n   else\n     source = operands[1];\n \n-  fp1 = gen_rtx (REG, SFmode, REGNO (operands[2]));\n-  fp2 = gen_rtx (REG, SFmode, REGNO (operands[2]) + 1);\n+  fp1 = gen_rtx_REG (SFmode, REGNO (operands[2]));\n+  fp2 = gen_rtx_REG (SFmode, REGNO (operands[2]) + 1);\n \n   emit_insn (gen_move_insn (fp1, source));\n-  emit_insn (gen_move_insn (fp2, gen_rtx (REG, SFmode, 0)));\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t      gen_rtx (LT, CCmode, fp2, fp1)));\n+  emit_insn (gen_move_insn (fp2, gen_rtx_REG (SFmode, 0)));\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_LT (CCmode, fp2, fp1)));\n \n   DONE;\n }\")\n@@ -5692,7 +5692,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t(match_operand:SF 0 \"register_operand\" \"=f\"))]\n+\t(match_operand:SF 0 \"register_operand\" \"f\"))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n   \"swxc1\\\\t%0,%1(%2)\"\n   [(set_attr \"type\"\t\"store\")\n@@ -5701,7 +5701,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (mem:SF (plus:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n \t\t\t (match_operand:DI 2 \"se_register_operand\" \"d\")))\n-\t(match_operand:SF 0 \"register_operand\" \"=f\"))]\n+\t(match_operand:SF 0 \"register_operand\" \"f\"))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n   \"swxc1\\\\t%0,%1(%2)\"\n   [(set_attr \"type\"\t\"store\")\n@@ -5710,7 +5710,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t(match_operand:DF 0 \"register_operand\" \"=f\"))]\n+\t(match_operand:DF 0 \"register_operand\" \"f\"))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"sdxc1\\\\t%0,%1(%2)\"\n   [(set_attr \"type\"\t\"store\")\n@@ -5719,7 +5719,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (mem:DF (plus:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n \t\t\t (match_operand:DI 2 \"se_register_operand\" \"d\")))\n-\t(match_operand:DF 0 \"register_operand\" \"=f\"))]\n+\t(match_operand:DF 0 \"register_operand\" \"f\"))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"sdxc1\\\\t%0,%1(%2)\"\n   [(set_attr \"type\"\t\"store\")\n@@ -6551,9 +6551,9 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   int amount = INTVAL (operands[2]);\n \n-  operands[2] = GEN_INT ((amount & 31));\n+  operands[2] = GEN_INT (amount & 31);\n   operands[4] = const0_rtx;\n-  operands[5] = GEN_INT (((-amount) & 31));\n+  operands[5] = GEN_INT ((-amount) & 31);\n \n   return \\\"sll\\\\t%M0,%M1,%2\\;srl\\\\t%3,%L1,%5\\;or\\\\t%M0,%M0,%3\\;sll\\\\t%L0,%L1,%2\\\";\n }\"\n@@ -6592,8 +6592,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\n {\n   int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n }\")\n \n \n@@ -6627,8 +6627,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\n {\n   int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n }\")\n \n \n@@ -6905,8 +6905,8 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   int amount = INTVAL (operands[2]);\n \n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n \n   return \\\"srl\\\\t%L0,%L1,%2\\;sll\\\\t%3,%M1,%4\\;or\\\\t%L0,%L0,%3\\;sra\\\\t%M0,%M1,%2\\\";\n }\"\n@@ -6945,8 +6945,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\n {\n   int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n }\")\n \n \n@@ -6980,8 +6980,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\n {\n   int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n }\")\n \n \n@@ -7290,8 +7290,8 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   int amount = INTVAL (operands[2]);\n \n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n \n   return \\\"srl\\\\t%L0,%L1,%2\\;sll\\\\t%3,%M1,%4\\;or\\\\t%L0,%L0,%3\\;srl\\\\t%M0,%M1,%2\\\";\n }\"\n@@ -7330,8 +7330,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\n {\n   int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n }\")\n \n \n@@ -7365,8 +7365,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\n {\n   int amount = INTVAL (operands[2]);\n-  operands[2] = GEN_INT ((amount & 31));\n-  operands[4] = GEN_INT (((-amount) & 31));\n+  operands[2] = GEN_INT (amount & 31);\n+  operands[4] = GEN_INT ((-amount) & 31);\n }\")\n \n \n@@ -8775,7 +8775,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n   \"*\n {\n-  operands[2] = GEN_INT (INTVAL (operands[2])+1);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \\\"sltu\\\\t%0,%1,%2\\\";\n }\"\n   [(set_attr \"type\"\t\"arith\")\n@@ -8804,7 +8804,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_64BIT && !TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n   \"*\n {\n-  operands[2] = GEN_INT (INTVAL (operands[2])+1);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \\\"sltu\\\\t%0,%1,%2\\\";\n }\"\n   [(set_attr \"type\"\t\"arith\")\n@@ -9514,8 +9514,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \t}\n \n       emit_call_insn (gen_call_internal0 (operands[0], operands[1],\n-\t\t\t\t\t  gen_rtx (REG, SImode, GP_REG_FIRST + 31)));\n-\n+\t\t\t\t\t  gen_rtx_REG (SImode,\n+\t\t\t\t\t\t       GP_REG_FIRST + 31)));\n       DONE;\n     }\n }\")\n@@ -9694,7 +9694,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t\t  (XEXP (XVECEXP (operands[0], 0, 0), 0),\n \t\t\t   operands[1], operands[2],\n \t\t\t   XEXP (XVECEXP (operands[0], 0, 1), 0),\n-\t\t\t   gen_rtx (REG, SImode, GP_REG_FIRST + 31)));\n+\t\t\t   gen_rtx_REG (SImode, GP_REG_FIRST + 31)));\n \t  DONE;\n \t}\n \n@@ -9704,7 +9704,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \toperands[0] = XEXP (XVECEXP (operands[0], 0, 0), 0);\n \n       emit_call_insn (gen_call_value_internal0 (operands[0], operands[1], operands[2],\n-\t\t\t\t\t        gen_rtx (REG, SImode, GP_REG_FIRST + 31)));\n+\t\t\t\t\t        gen_rtx_REG (SImode,\n+\t\t\t\t\t\t\t     GP_REG_FIRST + 31)));\n \n       DONE;\n     }\n@@ -9945,7 +9946,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;   \"\n ;; {\n ;;   operands[0] = gen_reg_rtx (SImode);\n-;;   operands[1] = gen_rtx (MEM, SImode, stack_pointer_rtx);\n+;;   operands[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);\n ;;   MEM_VOLATILE_P (operands[1]) = TRUE;\n ;; \n ;;   /* fall through and generate default code */"}, {"sha": "cda180a567536531ff44798042f1938d8fe427cd", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Matsushita MN10200 series\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"regs.h\"\n@@ -276,7 +276,7 @@ print_operand (file, x, code)\n \tif (GET_CODE (x) != MEM)\n \t  abort ();\n \tif (GET_CODE (XEXP (x, 0)) == REG)\n-\t  x = gen_rtx (PLUS, PSImode, XEXP (x, 0), GEN_INT (0));\n+\t  x = gen_rtx_PLUS (PSImode, XEXP (x, 0), GEN_INT (0));\n \telse\n \t  x = XEXP (x, 0);\n \tfputc ('(', file);\n@@ -595,12 +595,12 @@ expand_prologue ()\n \t      if (!regs_ever_live[2])\n \t\t{\n \t\t  regs_ever_live[2] = 1;\n-\t\t  zero_dreg = gen_rtx (REG, HImode, 2);\n+\t\t  zero_dreg = gen_rtx_REG (HImode, 2);\n \t\t}\n \t      if (!regs_ever_live[3])\n \t\t{\n \t\t  regs_ever_live[3] = 1;\n-\t\t  zero_dreg = gen_rtx (REG, HImode, 3);\n+\t\t  zero_dreg = gen_rtx_REG (HImode, 3);\n \t\t}\n \t    }\n \n@@ -612,12 +612,12 @@ expand_prologue ()\n \t      if (!regs_ever_live[5])\n \t\t{\n \t\t  regs_ever_live[5] = 1;\n-\t\t  zero_areg = gen_rtx (REG, HImode, 5);\n+\t\t  zero_areg = gen_rtx_REG (HImode, 5);\n \t\t}\n \t      if (!regs_ever_live[6])\n \t\t{\n \t\t  regs_ever_live[6] = 1;\n-\t\t  zero_areg = gen_rtx (REG, HImode, 6);\n+\t\t  zero_areg = gen_rtx_REG (HImode, 6);\n \t\t}\n \t    }\n \n@@ -639,14 +639,14 @@ expand_prologue ()\n     {\n       emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t      GEN_INT (-4)));\n-      emit_move_insn (gen_rtx (MEM, PSImode, stack_pointer_rtx),\n-\t\t      gen_rtx (REG, PSImode, STATIC_CHAIN_REGNUM));\n+      emit_move_insn (gen_rtx_MEM (PSImode, stack_pointer_rtx),\n+\t\t      gen_rtx_REG (PSImode, STATIC_CHAIN_REGNUM));\n     }\n \n   if (frame_pointer_needed)\n     {\n       /* Store a2 into a0 temporarily.  */\n-      emit_move_insn (gen_rtx (REG, PSImode, 4), frame_pointer_rtx);\n+      emit_move_insn (gen_rtx_REG (PSImode, 4), frame_pointer_rtx);\n \n       /* Set up the frame pointer.  */\n       emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n@@ -671,11 +671,10 @@ expand_prologue ()\n \t     register 4 (a0).  */\n \t  regno = (i == FRAME_POINTER_REGNUM && frame_pointer_needed) ? 4 : i;\n \t\n-\t  emit_move_insn (gen_rtx (MEM, PSImode,\n-\t\t\t\t   gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t    GEN_INT (offset))),\n-\t\t\t  gen_rtx (REG, PSImode, regno));\n+\t  emit_move_insn (gen_rtx_MEM (PSImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      offset)),\n+\t\t\t  gen_rtx_REG (PSImode, regno));\n \t  offset += 4;\n \t}\n     }\n@@ -684,10 +683,10 @@ expand_prologue ()\n      expects to find it.  */\n   if (current_function_needs_context)\n     {\n-      emit_move_insn (gen_rtx (REG, PSImode, STATIC_CHAIN_REGNUM),\n+      emit_move_insn (gen_rtx_REG (PSImode, STATIC_CHAIN_REGNUM),\n \t\t      gen_rtx (MEM, PSImode,\n-\t\t\t       gen_rtx (PLUS, PSImode, stack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (size))));\n+\t\t\t       gen_rtx_PLUS (PSImode, stack_pointer_rtx,\n+\t\t\t\t\t     GEN_INT (size))));\n     }\n }\n \n@@ -765,11 +764,9 @@ expand_epilogue ()\n \t  regno = ((i == FRAME_POINTER_REGNUM && frame_pointer_needed)\n \t\t   ? temp_regno : i);\n \t\n-\t  emit_move_insn (gen_rtx (REG, PSImode, regno),\n-\t\t\t  gen_rtx (MEM, PSImode,\n-\t\t\t\t   gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t    basereg,\n-\t\t\t\t\t    GEN_INT (offset))));\n+\t  emit_move_insn (gen_rtx_REG (PSImode, regno),\n+\t\t\t  gen_rtx_MEM (PSImode,\n+\t\t\t\t       plus_constant (basereg, offset)));\n \t  offset += 4;\n \t}\n     }\n@@ -779,7 +776,7 @@ expand_epilogue ()\n       /* Deallocate this frame's stack.  */\n       emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n       /* Restore the old frame pointer.  */\n-      emit_move_insn (frame_pointer_rtx, gen_rtx (REG, PSImode, temp_regno));\n+      emit_move_insn (frame_pointer_rtx, gen_rtx_REG (PSImode, temp_regno));\n     }\n   else if (size)\n     {\n@@ -973,14 +970,14 @@ expand_a_shift (mode, code, operands)\n   /* need a loop to get all the bits we want  - we generate the\n      code at emit time, but need to allocate a scratch reg now  */\n \n-  emit_insn (gen_rtx\n-\t     (PARALLEL, VOIDmode,\n+  emit_insn (gen_rtx_PARALLEL\n+\t     (VOIDmode,\n \t      gen_rtvec (2,\n-\t\t\t gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t\t  gen_rtx (code, mode,\n-\t\t\t\t\t   operands[0], operands[2])),\n-\t\t\t gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t  gen_rtx (SCRATCH, HImode, 0)))));\n+\t\t\t gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t      gen_rtx (code, mode,\n+\t\t\t\t\t       operands[0], operands[2])),\n+\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t  gen_rtx_SCRATCH (HImode)))));\n \n   return 1;\n }\n@@ -1375,10 +1372,10 @@ function_arg (cum, mode, type, named)\n   switch (cum->nbytes / UNITS_PER_WORD)\n     {\n     case 0:\n-      result = gen_rtx (REG, mode, 0);\n+      result = gen_rtx_REG (mode, 0);\n       break;\n     case 1:\n-      result = gen_rtx (REG, mode, 1);\n+      result = gen_rtx_REG (mode, 1);\n       break;\n     default:\n       result = 0;"}, {"sha": "ce44d826da77c7f994b15f9f3eabf18a7e04c53e", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler. Matsushita MN10200 series\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -528,12 +528,12 @@ extern struct rtx_def *mn10200_va_arg();\n    otherwise, FUNC is 0.   */\n    \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), TYPE_MODE (VALTYPE) == PSImode ? 4 : 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), TYPE_MODE (VALTYPE) == PSImode ? 4 : 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, (MODE) == PSImode ? 4 : 0)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, (MODE) == PSImode ? 4 : 0)\n \n /* 1 if N is a possible register number for a function value.  */\n \n@@ -594,9 +594,9 @@ extern struct rtx_def *mn10200_va_arg();\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, PSImode, plus_constant ((TRAMP), 20)),  \\\n+  emit_move_insn (gen_rtx_MEM (PSImode, plus_constant ((TRAMP), 20)),\t\\\n \t\t  (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, PSImode, plus_constant ((TRAMP), 24)),  \\\n+  emit_move_insn (gen_rtx_MEM (PSImode, plus_constant ((TRAMP), 24)),\t\\\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n }\n \n@@ -605,7 +605,7 @@ extern struct rtx_def *mn10200_va_arg();\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)   \\\n   ((COUNT == 0)                         \\\n-   ? gen_rtx (MEM, Pmode, frame_pointer_rtx) \\\n+   ? gen_rtx_MEM (Pmode, frame_pointer_rtx) \\\n    : (rtx) 0)\n \n \n@@ -1051,9 +1051,9 @@ do { char dstr[30];\t\t\t\t\t\\\n #define INIT_TARGET_OPTABS \\\n   do { \\\n     sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, DIVHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, DIVHI3_LIBCALL);\t\\\n     smod_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, MODHI3_LIBCALL);\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, MODHI3_LIBCALL);\t\\\n   } while (0)\n \n /* The assembler op to get a word.  */"}, {"sha": "e9bbd02fdadf6d15398db238eb46f0c06463ef31", "filename": "gcc/config/mn10200/mn10200.md", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,5 @@\n ;; GCC machine description for Matsushita MN10200\n-;; Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n-\n+;; Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n ;; Contributed by Jeff Law (law@cygnus.com).\n \n ;; This file is part of GNU CC.\n@@ -401,13 +400,13 @@\n       rtx ret, insns;\n \n       start_sequence ();\n-      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__addsi3\\\"),\n+      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__addsi3\\\"),\n \t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n \t\t\t\t     SImode, operands[2], SImode);\n       insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx (PLUS, SImode, operands[1], operands[2]));\n+\t\t\t  gen_rtx_PLUS (SImode, operands[1], operands[2]));\n       DONE;\n     }\n   else\n@@ -478,13 +477,13 @@\n       rtx ret, insns;\n \n       start_sequence ();\n-      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__subsi3\\\"),\n+      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__subsi3\\\"),\n \t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n \t\t\t\t     SImode, operands[2], SImode);\n       insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx (MINUS, SImode, operands[1], operands[2]));\n+\t\t\t  gen_rtx_MINUS (SImode, operands[1], operands[2]));\n       DONE;\n     }\n   else\n@@ -1275,9 +1274,9 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, HImode, operands[0],\n-\t\t\t      gen_rtx (ASHIFT, HImode,\n-\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (HImode, operands[0],\n+\t\t\t\t  gen_rtx_ASHIFT (HImode,\n+\t\t\t\t\t\t  operands[0], GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1314,9 +1313,10 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, HImode, operands[0],\n-\t\t\t      gen_rtx (LSHIFTRT, HImode,\n-\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (HImode, operands[0],\n+\t\t\t\t   gen_rtx_LSHIFTRT (HImode,\n+\t\t\t\t\t\t     operands[0],\n+\t\t\t\t\t\t     GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1353,9 +1353,9 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, HImode, operands[0],\n-\t\t\t      gen_rtx (ASHIFTRT, HImode,\n-\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (HImode, operands[0],\n+\t\t\t\t  gen_rtx_ASHIFTRT (HImode, operands[0],\n+\t\t\t\t\t\t    GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1407,9 +1407,9 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, PSImode, operands[0],\n-\t\t\t      gen_rtx (ASHIFT, PSImode,\n-\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (PSImode, operands[0],\n+\t\t\t\t  gen_rtx_ASHIFT (PSImode,\n+\t\t\t\t\t\t  operands[0], GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1484,9 +1484,9 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n-\t\t\t\t   gen_rtx (ASHIFT, SImode,\n-\t\t\t\t\t    operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n+\t\t\t\t  gen_rtx_ASHIFT (SImode,\n+\t\t\t\t\t\t  operands[0], GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1498,13 +1498,13 @@\n       rtx ret, insns;\n \n       start_sequence ();\n-      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__ashlsi3\\\"),\n+      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__ashlsi3\\\"),\n \t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n \t\t\t\t     SImode, operands[2], HImode);\n       insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx (ASHIFT, SImode, operands[1], operands[2]));\n+\t\t\t  gen_rtx_ASHIFT (SImode, operands[1], operands[2]));\n       DONE;\n     }\n   else\n@@ -1542,9 +1542,9 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n-\t\t\t\t   gen_rtx (LSHIFTRT, SImode,\n-\t\t\t\t\t    operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n+\t\t\t\t  gen_rtx_LSHIFTRT (SImode, operands[0],\n+\t\t\t\t\t\t    GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1556,13 +1556,13 @@\n       rtx ret, insns;\n \n       start_sequence ();\n-      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__lshrsi3\\\"),\n+      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__lshrsi3\\\"),\n \t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n \t\t\t\t     SImode, operands[2], HImode);\n       insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx (LSHIFTRT, SImode, operands[1], operands[2]));\n+\t\t\t  gen_rtx_LSHIFTRT (SImode, operands[1], operands[2]));\n       DONE;\n     }\n   else\n@@ -1600,9 +1600,9 @@\n       emit_move_insn (operands[0], operands[1]);\n       while (count > 0)\n \t{\n-\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n-\t\t\t\t   gen_rtx (ASHIFTRT, SImode,\n-\t\t\t\t\t    operands[0], GEN_INT (1))));\n+\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n+\t\t\t\t  gen_rtx_ASHIFTRT (SImode, operands[0],\n+\t\t\t\t\t\t    GEN_INT (1))));\n \t  count--;\n \t}\n       DONE;\n@@ -1614,13 +1614,13 @@\n       rtx ret, insns;\n \n       start_sequence ();\n-      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__ashrsi3\\\"),\n+      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__ashrsi3\\\"),\n \t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n \t\t\t\t     SImode, operands[2], HImode);\n       insns = get_insns ();\n       end_sequence ();\n       emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx (ASHIFTRT, SImode, operands[1], operands[2]));\n+\t\t\t  gen_rtx_ASHIFTRT (SImode, operands[1], operands[2]));\n       DONE;\n     }\n   else"}, {"sha": "5e291d0991aaf413d3facbb2b4aebf554a4fa51b", "filename": "gcc/config/mn10200/xm-mn10200.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fxm-mn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10200%2Fxm-mn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fxm-mn10200.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for Matsushita MN10200. \n-   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Cygnus Support.\n \n This file is part of GNU CC.\n@@ -38,10 +38,3 @@ Boston, MA 02111-1307, USA.  */\n    tm.h is a symbolic link to the actual target specific file.   */\n \n #include \"tm.h\"\n-\n-#ifndef __STDC__\n-extern char *malloc (), *realloc (), *calloc ();\n-#else\n-extern void *malloc (), *realloc (), *calloc ();\n-#endif\n-extern void free ();"}, {"sha": "d85f9d2dc00d3950bf24373fda8a0977cf21f64b", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Matsushita MN10300 series\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"regs.h\"\n@@ -233,7 +233,7 @@ print_operand (file, x, code)\n       case 'A':\n \tfputc ('(', file);\n \tif (GET_CODE (XEXP (x, 0)) == REG)\n-\t  output_address (gen_rtx (PLUS, SImode, XEXP (x, 0), GEN_INT (0)));\n+\t  output_address (gen_rtx_PLUS (SImode, XEXP (x, 0), GEN_INT (0)));\n \telse\n \t  output_address (XEXP (x, 0));\n \tfputc (')', file);\n@@ -314,9 +314,9 @@ print_operand_address (file, addr)\n     {\n     case REG:\n       if (addr == stack_pointer_rtx)\n-\tprint_operand_address (file, gen_rtx (PLUS, SImode,\n-\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      GEN_INT (0)));\n+\tprint_operand_address (file, gen_rtx_PLUS (SImode,\n+\t\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t\t   GEN_INT (0)));\n       else\n \tprint_operand (file, addr, 0);\n       break;\n@@ -376,14 +376,12 @@ expand_prologue ()\n      need to be flushed back to the stack.  */\n   if (current_function_varargs)\n     {\n-      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (PLUS, Pmode, stack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (4))),\n-\t\t      gen_rtx (REG, SImode, 0));\n-      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (PLUS, Pmode, stack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (8))),\n-\t\t      gen_rtx (REG, SImode, 1));\n+      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t   plus_constant (stack_pointer_rtx, 4)),\n+\t\t      gen_rtx_REG (SImode, 0));\n+      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t   plus_constant (stack_pointer_rtx, 8)),\n+\t\t      gen_rtx_REG (SImode, 1));\n     }\n \n   /* And now store all the registers onto the stack with a\n@@ -747,10 +745,10 @@ function_arg (cum, mode, type, named)\n   switch (cum->nbytes / UNITS_PER_WORD)\n     {\n     case 0:\n-      result = gen_rtx (REG, mode, 0);\n+      result = gen_rtx_REG (mode, 0);\n       break;\n     case 1:\n-      result = gen_rtx (REG, mode, 1);\n+      result = gen_rtx_REG (mode, 1);\n       break;\n     default:\n       result = 0;\n@@ -995,7 +993,7 @@ legitimize_address (x, oldx, mode)\n \t  regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n \t  regx1 = force_reg (Pmode,\n \t\t\t     gen_rtx (GET_CODE (y), Pmode, regx1, regy2));\n-\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regy1));\n+\t  return force_reg (Pmode, gen_rtx_PLUS (Pmode, regx1, regy1));\n \t}\n     }\n   return x;"}, {"sha": "a7686ca81cb98a4c6d46d908610e3ff8dd7cf431", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler. Matsushita MN10300 series\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -485,12 +485,12 @@ extern struct rtx_def *function_arg ();\n    otherwise, FUNC is 0.   */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), POINTER_TYPE_P (VALTYPE) ? 4 : 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), POINTER_TYPE_P (VALTYPE) ? 4 : 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, 0)\n \n /* 1 if N is a possible register number for a function value.  */\n \n@@ -544,9 +544,9 @@ extern struct rtx_def *function_arg ();\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x14)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 0x14)),\t\\\n  \t\t (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x18)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 0x18)),\t\\\n \t\t (FNADDR));\t\t\t\t\t\t\\\n }\n /* A C expression whose value is RTL representing the value of the return\n@@ -560,7 +560,7 @@ extern struct rtx_def *function_arg ();\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)   \\\n   ((COUNT == 0)                         \\\n-   ? gen_rtx (MEM, Pmode, arg_pointer_rtx) \\\n+   ? gen_rtx_MEM (Pmode, arg_pointer_rtx) \\\n    : (rtx) 0)\n \n /* Emit code for a call to builtin_saveregs.  We must emit USE insns which"}, {"sha": "59acf5ac3978b4a31ea50171c16e6c2f8039a672", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,7 +1,6 @@\n ;; GCC machine description for Matsushita MN10300\n-;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n-\n-;;   Contributed by Jeff Law (law@cygnus.com).\n+;; Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+;; Contributed by Jeff Law (law@cygnus.com).\n \n ;; This file is part of GNU CC.\n \n@@ -159,8 +158,9 @@\n \t  && (GET_MODE_SIZE (GET_MODE (XEXP (operands[1], 1)))\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (operands[1], 1))))))\n \temit_move_insn (operands[2],\n-\t\t\tgen_rtx (ZERO_EXTEND, GET_MODE (XEXP (operands[1], 1)),\n-\t\t\t\t SUBREG_REG (XEXP (operands[1], 1))));\n+\t\t\tgen_rtx_ZERO_EXTEND\n+\t\t\t(GET_MODE (XEXP (operands[1], 1)),\n+\t\t\t SUBREG_REG (XEXP (operands[1], 1))));\n       else\n \temit_move_insn (operands[2], XEXP (operands[1], 1));\n       emit_move_insn (operands[0], XEXP (operands[1], 0));\n@@ -171,8 +171,9 @@\n \t  && (GET_MODE_SIZE (GET_MODE (XEXP (operands[1], 0)))\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (operands[1], 0))))))\n \temit_move_insn (operands[2],\n-\t\t\tgen_rtx (ZERO_EXTEND, GET_MODE (XEXP (operands[1], 0)),\n-\t\t\t\t SUBREG_REG (XEXP (operands[1], 0))));\n+\t\t\tgen_rtx_ZERO_EXTEND\n+\t\t\t(GET_MODE (XEXP (operands[1], 0)),\n+\t\t\t SUBREG_REG (XEXP (operands[1], 0))));\n       else\n \temit_move_insn (operands[2], XEXP (operands[1], 0));\n       emit_move_insn (operands[0], XEXP (operands[1], 1));\n@@ -344,7 +345,7 @@\n \t    if (GET_CODE (temp) != REG)\n \t      abort ();\n \n-\t    if (reg_overlap_mentioned_p (gen_rtx (REG, SImode, REGNO (temp)),\n+\t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n \t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n \t    else\n@@ -476,7 +477,7 @@\n \t    if (GET_CODE (temp) != REG)\n \t      abort ();\n \n-\t    if (reg_overlap_mentioned_p (gen_rtx (REG, SImode, REGNO (temp)),\n+\t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n \t\t\t\t\t XEXP (operands[1], 0)))\n \t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n \t    else\n@@ -586,7 +587,7 @@\n       && GET_CODE (operands[2]) != CONST_INT)\n    {\n      rtx temp = gen_reg_rtx (SImode);\n-     emit_move_insn (temp, gen_rtx (PLUS, SImode, operands[1], operands[2]));\n+     emit_move_insn (temp, gen_rtx_PLUS (SImode, operands[1], operands[2]));\n      emit_move_insn (operands[0], temp);\n      DONE;\n    }"}, {"sha": "84f888be48853c0073cb3252c86199c5fdbbbf6c", "filename": "gcc/config/mn10300/xm-mn10300.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fxm-mn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fmn10300%2Fxm-mn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fxm-mn10300.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for Matsushita MN10300. \n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Cygnus Support.\n \n This file is part of GNU CC.\n@@ -38,10 +38,3 @@ Boston, MA 02111-1307, USA.  */\n    tm.h is a symbolic link to the actual target specific file.   */\n \n #include \"tm.h\"\n-\n-#ifndef __STDC__\n-extern char *malloc (), *realloc (), *calloc ();\n-#else\n-extern void *malloc (), *realloc (), *calloc ();\n-#endif\n-extern void free ();"}, {"sha": "ab7535c1dec8ab472993976b3538b615d192d849", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the NS32000.\n-   Copyright (C) 1988, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,7 +18,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Some output-actions in ns32k.md need these.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n@@ -208,10 +207,10 @@ gen_indexed_expr (base, index, scale)\n   /* This generates an invalid addressing mode, if BASE is\n      fp or sp.  This is handled by PRINT_OPERAND_ADDRESS.  */\n   if (GET_CODE (base) != REG && GET_CODE (base) != CONST_INT)\n-    base = gen_rtx (MEM, SImode, base);\n-  addr = gen_rtx (MULT, SImode, index,\n-\t\t  GEN_INT (1 << INTVAL (scale)));\n-  addr = gen_rtx (PLUS, SImode, base, addr);\n+    base = gen_rtx_MEM (SImode, base);\n+  addr = gen_rtx_MULT (SImode, index,\n+\t\t       GEN_INT (1 << INTVAL (scale)));\n+  addr = gen_rtx_PLUS (SImode, base, addr);\n   return addr;\n }\n \n@@ -246,8 +245,8 @@ split_di (operands, num, lo_half, hi_half)\n     {\n       if (GET_CODE (operands[num]) == REG)\n \t{\n-\t  lo_half[num] = gen_rtx (REG, SImode, REGNO (operands[num]));\n-\t  hi_half[num] = gen_rtx (REG, SImode, REGNO (operands[num]) + 1);\n+\t  lo_half[num] = gen_rtx_REG (SImode, REGNO (operands[num]));\n+\t  hi_half[num] = gen_rtx_REG (SImode, REGNO (operands[num]) + 1);\n \t}\n       else if (CONSTANT_P (operands[num]))\n \t{\n@@ -324,14 +323,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n@@ -382,7 +381,7 @@ output_move_double (operands)\n \t  xops[0] = XEXP (operands[1], 0);\n \t  xops[1] = operands[0];\n \t  output_asm_insn (\"addr %a0,%1\", xops);\n-\t  operands[1] = gen_rtx (MEM, DImode, operands[0]);\n+\t  operands[1] = gen_rtx_MEM (DImode, operands[0]);\n \t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n \t  /* The first half has the overlap, Do the late half first.  */\n \t  output_asm_insn (singlemove_string (latehalf), latehalf);\n@@ -968,7 +967,7 @@ print_operand_address (file, addr)\n \tcase CONST_INT:\n \tcase LABEL_REF:\n \t  if (offset)\n-\t    offset = gen_rtx (PLUS, SImode, tmp, offset);\n+\t    offset = gen_rtx_PLUS (SImode, tmp, offset);\n \t  else\n \t    offset = tmp;\n \t  break;\n@@ -1063,7 +1062,7 @@ print_operand_address (file, addr)\n \t      case SYMBOL_REF:\n \t      case LABEL_REF:\n \t\tif (offset)\n-\t\t  offset = gen_rtx (PLUS, SImode, tmp, offset);\n+\t\t  offset = gen_rtx_PLUS (SImode, tmp, offset);\n \t\telse\n \t\t  offset = tmp;\n \t\tbreak;"}, {"sha": "71df54afda42e9726c57f5dfca1dbad00d909490", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  NS32000 version.\n-   Copyright (C) 1988, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 93, 94-98, 1999 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -587,8 +587,8 @@ enum reg_class\n    or perhaps F0 is there is fp support.  */\n \n #define LIBCALL_VALUE(MODE)  \\\n-  gen_rtx (REG, MODE,\t\t\t\t  \\\n-\t   FLOAT_MODE_P(MODE) && TARGET_32081 ? F0_REGNUM: R0_REGNUM)\n+  gen_rtx_REG (MODE,\t\t\t\t  \\\n+\t       FLOAT_MODE_P(MODE) && TARGET_32081 ? F0_REGNUM: R0_REGNUM)\n \n /* Define this if PCC uses the nonreentrant convention for returning\n    structure and union values.  */\n@@ -653,7 +653,7 @@ enum reg_class\n    It exists only to test register calling conventions.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+((TARGET_REGPARM && (CUM) < 8) ? gen_rtx_REG ((MODE), (CUM) / 4) : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -941,8 +941,8 @@ operands on the 32k are stored).  */\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t     \\\n {\t\t\t\t\t\t\t\t\t     \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)), CXT);    \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT);    \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n }\n \n /* This is the library routine that is used"}, {"sha": "dfe6629021625976a1f47619909066553350377c", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler, ns32000 Version\n-;;  Copyright (C) 1988, 1994, 1996, 1999 Free Software Foundation, Inc.\n+;;  Copyright (C) 1988, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.\n ;;  Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n ;; This file is part of GNU CC.\n@@ -221,7 +221,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"movd %1,tos\\\", xoperands);\n \t  output_asm_insn (\\\"movd %1,tos\\\", operands);\n \t  return \\\"movl tos,%0\\\";\n@@ -233,7 +233,7 @@\n       if (REG_P (operands[0]))\n \t{\n \t  output_asm_insn (\\\"movl %1,tos\\;movd tos,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  return \\\"movd tos,%0\\\";\n \t}\n       else\n@@ -277,7 +277,7 @@\n       convrt.i[1] = CONST_DOUBLE_HIGH (operands[1]);\n       convrt.f = convrt.d;\n \n-      /* Is there a better machine-independent way to do this?  */\n+      /* Is there a better machine-independent way to to this?  */\n       operands[1] = GEN_INT (convrt.i[0]);\n       return \\\"movd %1,%0\\\";\n     }\n@@ -304,7 +304,7 @@\n       if (REG_P (operands[1]))\n \t{\n \t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn (\\\"movd %1,tos\\\", xoperands);\n \t  output_asm_insn (\\\"movd %1,tos\\\", operands);\n \t  return \\\"movl tos,%0\\\";\n@@ -316,7 +316,7 @@\n       if (REG_P (operands[0]))\n \t{\n \t  output_asm_insn (\\\"movl %1,tos\\;movd tos,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  return \\\"movd tos,%0\\\";\n \t}\n       else\n@@ -357,8 +357,7 @@\n       && REGNO (operands[0]) == FRAME_POINTER_REGNUM)\n     return \\\"lprd fp,%1\\\";\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1]\n-      = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n+    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       int i = INTVAL (operands[1]);\n@@ -437,8 +436,7 @@\n       if (i <= 7 && i >= -8)\n \t{\n \t  if (INTVAL (operands[1]) > 7)\n-\t    operands[1] =\n-\t      GEN_INT (i);\n+\t    operands[1] = GEN_INT (i);\n \t  return \\\"movqw %1,%0\\\";\n \t}\n \treturn \\\"movw %1,%0\\\";\n@@ -483,8 +481,7 @@\n       if (char_val <= 7 && char_val >= -8)\n \t{\n \t  if (INTVAL (operands[1]) > 7)\n-\t    operands[1] =\n-\t      GEN_INT (char_val);\n+\t    operands[1] = GEN_INT (char_val);\n \t  return \\\"movqb %1,%0\\\";\n \t}\n \treturn \\\"movb %1,%0\\\";\n@@ -1784,7 +1781,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1809,7 +1806,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1834,7 +1831,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1862,7 +1859,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1887,7 +1884,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1912,7 +1909,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1962,7 +1959,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1987,7 +1984,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -2012,7 +2009,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n }\")\n \n (define_insn \"\""}, {"sha": "4bb427efe0a6cca38e7b1b3e5c4d3ffce9764046", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -21,7 +21,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -662,8 +661,9 @@ legitimize_pic_address (orig, mode, reg)\n \t}\n       else\n \tpic_ref = gen_rtx_MEM (Pmode,\n-\t\t\t       gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t     pic_offset_table_rtx, orig));\n+\t\t\t       gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t\t     orig));\n+\n       current_function_uses_pic_offset_table = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n       emit_move_insn (reg, pic_ref);\n@@ -803,16 +803,14 @@ hppa_legitimize_address (x, oldx, mode)\n       if (! VAL_14_BITS_P (newoffset)\n \t  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n-\t  rtx const_part\n-\t    = gen_rtx_CONST (VOIDmode, gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t     XEXP (x, 0),\n-\t\t\t\t\t\t     GEN_INT (newoffset)));\n+\t  rtx const_part = plus_constant (XEXP (x, 0), newoffset);\n \t  rtx tmp_reg\n \t    = force_reg (Pmode,\n \t\t\t gen_rtx_HIGH (Pmode, const_part));\n \t  ptr_reg\n \t    = force_reg (Pmode,\n-\t\t\t gen_rtx_LO_SUM (Pmode, tmp_reg, const_part));\n+\t\t\t gen_rtx_LO_SUM (Pmode,\n+\t\t\t\t\t tmp_reg, const_part));\n \t}\n       else\n \t{\n@@ -850,8 +848,9 @@ hppa_legitimize_address (x, oldx, mode)\n         reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n       return force_reg (Pmode, gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t     gen_rtx_MULT (Pmode, reg2,\n-\t\t\t\t\t\t           GEN_INT (val)),\n+\t\t\t\t\t     gen_rtx_MULT (Pmode,\n+\t\t\t\t\t\t\t   reg2,\n+\t\t\t\t\t\t\t   GEN_INT (val)),\n \t\t\t\t\t     reg1));\n     }\n \n@@ -926,11 +925,12 @@ hppa_legitimize_address (x, oldx, mode)\n \t  reg1 = force_reg (Pmode, gen_rtx_PLUS (Pmode, reg1, GEN_INT (val)));\n \n \t  /* We can now generate a simple scaled indexed address.  */\n-\t  return force_reg (Pmode,\n-\t\t\t    gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t  gen_rtx_MULT (Pmode, reg1,\n-\t\t\t\t\t\t        XEXP (XEXP (idx, 0), 1)),\n-\t\t\t\t\t  base));\n+\t  return\n+\t    force_reg\n+\t      (Pmode, gen_rtx_PLUS (Pmode,\n+\t\t\t\t    gen_rtx_MULT (Pmode, reg1,\n+\t\t\t\t\t\t  XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t    base));\n \t}\n \n       /* If B + C is still a valid base register, then add them.  */\n@@ -948,7 +948,8 @@ hppa_legitimize_address (x, oldx, mode)\n \t    reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n \t  return force_reg (Pmode, gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t         gen_rtx_MULT (Pmode, reg2,\n+\t\t\t\t\t\t gen_rtx_MULT (Pmode,\n+\t\t\t\t\t\t\t       reg2,\n \t\t\t\t\t\t\t       GEN_INT (val)),\n \t\t\t\t\t\t reg1));\n \t}\n@@ -1034,9 +1035,10 @@ hppa_legitimize_address (x, oldx, mode)\n \n \t      return force_reg (Pmode,\n \t\t\t\tgen_rtx_PLUS (Pmode,\n-\t\t\t\t\t      gen_rtx_MULT (Pmode, reg2,\n+\t\t\t\t\t      gen_rtx_MULT (Pmode,\n+\t\t\t\t\t\t\t    reg2,\n \t\t\t\t\t\t\t    GEN_INT (val)),\n-\t\t\t\t\t\treg1));\n+\t\t\t\t\t      reg1));\n \t    }\n \t  else if ((mode == DFmode || mode == SFmode)\n \t\t   && GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n@@ -1054,12 +1056,12 @@ hppa_legitimize_address (x, oldx, mode)\n \t\tregx2 = force_reg (Pmode, force_operand (regx2, 0));\n \t      regx2 = force_reg (Pmode, gen_rtx_fmt_ee (GET_CODE (y), Pmode,\n \t\t\t\t\t\t\tregx2, regx1));\n-\t      return force_reg (Pmode,\n-\t\t\t\tgen_rtx_PLUS (Pmode,\n-\t\t\t\t\t      gen_rtx_MULT (Pmode, regx2,\n-\t\t\t\t\t\t            XEXP (XEXP (x, 0),\n-\t\t\t\t\t\t\t    1)),\n-\t\t\t\t\t      force_reg (Pmode, XEXP (y, 0))));\n+\t      return\n+\t\tforce_reg (Pmode,\n+\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t gen_rtx_MULT (Pmode, regx2,\n+\t\t\t\t\t\t       XEXP (XEXP (x, 0), 1)),\n+\t\t\t\t\t force_reg (Pmode, XEXP (y, 0))));\n \t    }\n \t  else if (GET_CODE (XEXP (y, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (y, 1)) >= -4096\n@@ -1201,8 +1203,8 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t}\n       else\n \temit_move_insn (scratch_reg, XEXP (operand1, 0));\n-      emit_insn (gen_rtx_SET (VOIDmode, operand0, gen_rtx_MEM (mode,\n-\t\t\t\t\t\t\t       scratch_reg)));\n+      emit_insn (gen_rtx_SET (VOIDmode, operand0,\n+\t\t\t      gen_rtx_MEM (mode, scratch_reg)));\n       return 1;\n     }\n   else if (fp_reg_operand (operand1, mode)\n@@ -1266,7 +1268,8 @@ emit_move_sequence (operands, mode, scratch_reg)\n       emit_move_sequence (xoperands, Pmode, 0);\n \n       /* Now load the destination register.  */\n-      emit_insn (gen_rtx_SET (mode, operand0, gen_rtx_MEM (mode, scratch_reg)));\n+      emit_insn (gen_rtx_SET (mode, operand0,\n+\t\t\t      gen_rtx_MEM (mode, scratch_reg)));\n       return 1;\n     }\n   /* Handle secondary reloads for SAR.  These occur when trying to load\n@@ -1495,7 +1498,8 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      if (ishighonly)\n \t\tset = gen_rtx_SET (mode, operand0, temp);\n \t      else\n-\t\tset = gen_rtx_SET (VOIDmode, operand0,\n+\t\tset = gen_rtx_SET (VOIDmode,\n+\t\t\t\t   operand0,\n \t\t\t\t   gen_rtx_LO_SUM (mode, temp, operand1));\n \n \t      emit_insn (gen_rtx_SET (VOIDmode,\n@@ -2515,18 +2519,16 @@ remove_useless_addtr_insns (insns, check_notes)\n \n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+\n static void\n store_reg (reg, disp, base)\n      int reg, disp, base;\n {\n   if (VAL_14_BITS_P (disp))\n-    {\n-      emit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t\t   gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t gen_rtx_REG (Pmode, base),\n-\t\t\t\t\t\t GEN_INT (disp))),\n-\t\t\t\t   gen_rtx_REG (word_mode, reg));\n-    }\n+    emit_move_insn (gen_rtx_MEM (word_mode,\n+\t\t\t\t plus_constant (gen_rtx_REG (Pmode, base),\n+\t\t\t\t\t\tdisp)),\n+\t\t    gen_rtx_REG (word_mode, reg));\n   else\n     {\n       emit_move_insn (gen_rtx_REG (Pmode, 1),\n@@ -2545,18 +2547,16 @@ store_reg (reg, disp, base)\n \n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+\n static void\n load_reg (reg, disp, base)\n      int reg, disp, base;\n {\n   if (VAL_14_BITS_P (disp))\n-    {\n-      emit_move_insn (gen_rtx_REG (word_mode, reg),\n-\t\t      gen_rtx_MEM (word_mode,\n-\t\t\t\t   gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t gen_rtx_REG (Pmode, base),\n-\t\t\t\t            GEN_INT (disp))));\n-    }\n+    emit_move_insn (gen_rtx_REG (word_mode, reg),\n+\t\t    gen_rtx_MEM (word_mode,\n+\t\t\t\t plus_constant (gen_rtx_REG (Pmode, base),\n+\t\t\t\t\t\tdisp)));\n   else\n     {\n       emit_move_insn (gen_rtx_REG (Pmode, 1),\n@@ -2575,17 +2575,14 @@ load_reg (reg, disp, base)\n \n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+\n static void\n-set_reg_plus_d(reg, base, disp)\n+set_reg_plus_d (reg, base, disp)\n      int reg, base, disp;\n {\n   if (VAL_14_BITS_P (disp))\n-    {\n-      emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t      gen_rtx_PLUS (Pmode,\n-\t\t\t\t    gen_rtx_REG (Pmode, base),\n-\t\t\t\t    GEN_INT (disp)));\n-    }\n+    emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t    plus_constant (gen_rtx_REG (Pmode, base), disp));\n   else\n     {\n       emit_move_insn (gen_rtx_REG (Pmode, 1),\n@@ -2839,7 +2836,8 @@ hppa_expand_prologue()\n \t place to get the expected results.   sprintf here is just to\n \t put something in the name.  */\n       sprintf(hp_profile_label_name, \"LP$%04d\", -1);\n-      hp_profile_label_rtx = gen_rtx_SYMBOL_REF (Pmode, hp_profile_label_name);\n+      hp_profile_label_rtx = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t hp_profile_label_name);\n       if (current_function_returns_struct)\n \tstore_reg (STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n       if (current_function_needs_context)\n@@ -6392,11 +6390,12 @@ pa_combine_instructions (insns)\n \t\t  || anchor_attr == PA_COMBINE_TYPE_FMPY))\n \t    {\n \t      /* Emit the new instruction and delete the old anchor.  */\n-\t      emit_insn_before (gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t\t\t  gen_rtvec (2,\n-\t\t\t\t\t\t\t     PATTERN (anchor),\n-\t\t\t\t\t\t\t     PATTERN (floater))),\n-\t\t\t\t\t\t  anchor);\n+\t      emit_insn_before (gen_rtx_PARALLEL\n+\t\t\t\t(VOIDmode,\n+\t\t\t\t gen_rtvec (2, PATTERN (anchor),\n+\t\t\t\t\t    PATTERN (floater))),\n+\t\t\t\tanchor);\n+\n \t      PUT_CODE (anchor, NOTE);\n \t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;\n \t      NOTE_SOURCE_FILE (anchor) = 0;\n@@ -6413,10 +6412,13 @@ pa_combine_instructions (insns)\n \t    {\n \t      rtx temp;\n \t      /* Emit the new_jump instruction and delete the old anchor.  */\n-\t      temp = emit_jump_insn_before (gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t\t      gen_rtvec (2, PATTERN (anchor),\n-\t\t\t\t\t\t\t PATTERN (floater))),\n-\t\t\t\tanchor);\n+\t      temp\n+\t\t= emit_jump_insn_before (gen_rtx_PARALLEL\n+\t\t\t\t\t (VOIDmode,\n+\t\t\t\t\t  gen_rtvec (2, PATTERN (anchor),\n+\t\t\t\t\t\t     PATTERN (floater))),\n+\t\t\t\t\t anchor);\n+\n \t      JUMP_LABEL (temp) = JUMP_LABEL (anchor);\n \t      PUT_CODE (anchor, NOTE);\n \t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;"}, {"sha": "5e60940c55a3d2ca5ca7c9ed372aa9996ef08b77", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -880,7 +880,7 @@ int zdepi_cint_p ();\n #define LIBCALL_VALUE(MODE)\t\\\n   gen_rtx_REG (MODE,\t\t\t\t\t\t\t\\\n \t       (! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t        && ((MODE) == SFmode || (MODE) == DFmode) ? 32 : 28))\n+\t\t&& ((MODE) == SFmode || (MODE) == DFmode) ? 32 : 28))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -1007,41 +1007,42 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n       || !FLOAT_MODE_P (MODE) || TARGET_SOFT_FLOAT\t\t\t\\\n       || (CUM).nargs_prototype > 0)\t\t\t\t\t\\\n       ? gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n-\t\t  ? (((!(CUM).indirect \t\t\t\t\t\\\n-\t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n-\t\t      && (MODE) == DFmode\t\t\t\t\\\n-\t\t      && ! TARGET_SOFT_FLOAT)\t\t\t\t\\\n-\t\t     ? ((CUM).words ? 38 : 34)\t\t\t\t\\\n-\t\t     : ((CUM).words ? 23 : 25))\t\t\t\t\\\n-\t\t  : (((!(CUM).indirect\t\t\t\t\t\\\n-\t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n-\t\t      && (MODE) == SFmode\t\t\t\t\\\n-\t\t      && ! TARGET_SOFT_FLOAT)\t\t\t\t\\\n-\t\t     ? (32 + 2 * (CUM).words)\t\t\t\t\\\n-\t\t     : (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\t\\\n-\t\t\t\t\t\t\t      (TYPE))))))\\\n+\t\t     (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n+\t\t      ? (((!(CUM).indirect \t\t\t\t\\\n+\t\t\t   || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n+\t\t\t  && (MODE) == DFmode\t\t\t\t\\\n+\t\t\t  && ! TARGET_SOFT_FLOAT)\t\t\t\\\n+\t\t\t ? ((CUM).words ? 38 : 34)\t\t\t\\\n+\t\t\t : ((CUM).words ? 23 : 25))\t\t\t\\\n+\t\t      : (((!(CUM).indirect\t\t\t\t\\\n+\t\t\t   || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n+\t\t\t  && (MODE) == SFmode\t\t\t\t\\\n+\t\t\t  && ! TARGET_SOFT_FLOAT)\t\t\t\\\n+\t\t\t ? (32 + 2 * (CUM).words)\t\t\t\\\n+\t\t\t : (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\\\n+\t\t\t\t\t\t\t\t  (TYPE))))))\\\n    /* We are calling a non-prototyped function with floating point\t\\\n       arguments using the portable conventions.  */\t\t\t\\\n-   : gen_rtx_PARALLEL ((MODE),\t\t\t\t\t\t\\\n-\t      gen_rtvec\t\t\t\t\t\t\t\\\n-\t      (2,\t\t\t\t\t\t\t\\\n-\t       gen_rtx_EXPR_LIST (VOIDmode,\t\t\t\t\\\n-\t\t\tgen_rtx_REG ((MODE),\t\t\t\t\\\n-\t\t\t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1 \\\n-\t\t\t\t  ? ((CUM).words ? 38 : 34)\t\t\\\n-\t\t\t\t  : (32 + 2 * (CUM).words))),\t\t\\\n-\t\t\tconst0_rtx),\t\t\t\t\t\\\n-\t       gen_rtx_EXPR_LIST (VOIDmode,\t\t\t\t\\\n-\t\t\tgen_rtx_REG ((MODE),\t\t\t\t\\\n-\t\t\t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1 \\\n-\t\t\t\t  ? ((CUM).words ? 23 : 25)\t\t\\\n-\t\t\t\t  : (27 - (CUM).words -\t\t\t\\\n-\t\t\t\t     FUNCTION_ARG_SIZE ((MODE),\t\t\\\n-\t\t\t\t\t\t\t(TYPE))))),\t\\\n-\t\t\tconst0_rtx)))\t\t\t\t\t\\\n-  /* Pass this parameter in the stack.  */\t\t\t\t\\\n-  : 0)\n+   : (gen_rtx_PARALLEL\t\t\t\t\t\t\t\\\n+      ((MODE),\t\t\t\t\t\t\t\t\\\n+       gen_rtvec\t\t\t\t\t\t\t\\\n+       (2,\t\t\t\t\t\t\t\t\\\n+\tgen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n+\t(VOIDmode,\t\t\t\t\t\t\t\\\n+\t gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t\t      (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1 \t\t\\\n+\t\t       ? ((CUM).words ? 38 : 34) : (32 + 2 * (CUM).words))), \\\n+\t const0_rtx),\t\t\t\t\t\t\t\\\n+\tgen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n+\t(VOIDmode,\t\t\t\t\t\t\t\\\n+\t gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t\t      (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n+\t\t       ? ((CUM).words ? 23 : 25)\t\t\t\\\n+\t\t       : (27 - (CUM).words -\t\t\t\t\\\n+\t\t\t  FUNCTION_ARG_SIZE ((MODE), (TYPE))))),\t\\\n+\t const0_rtx))))\t\t\t\t\t\t\t\\\n+      /* Pass this parameter in the stack.  */\t\t\t\t\\\n+      : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used."}, {"sha": "eff818b37db13c3174fea1c3737e82d4e8058189", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -3107,8 +3107,7 @@\n       operands[1] = force_reg (SImode, operands[1]);\n       operands[2] = force_reg (SImode, operands[2]);\n       emit_insn (gen_umulsidi3 (scratch, operands[1], operands[2]));\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      operands[0],\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t      gen_rtx_SUBREG (SImode, scratch, 1)));\n       DONE;\n     }\n@@ -5410,7 +5409,8 @@\n \n   /* Else call $$sh_func_adrs to extract the function's real add24.  */\n   return output_millicode_call (insn,\n-\t\t\t\tgen_rtx_SYMBOL_REF (SImode, \\\"$$sh_func_adrs\\\"));\n+\t\t\t\tgen_rtx_SYMBOL_REF (SImode,\n+\t\t\t\t\t \\\"$$sh_func_adrs\\\"));\n }\"\n   [(set_attr \"type\" \"multi\")\n    (set (attr \"length\")\n@@ -5456,8 +5456,9 @@\n   /* Load the PIC register from the stack slot (in our caller's\n      frame).  */\n   emit_move_insn (pic_offset_table_rtx,\n-\t\t  gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, -32)));\n-  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+\t\t  gen_rtx_MEM (SImode,\n+\t\t\t       plus_constant (stack_pointer_rtx, -32)));\n+  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n   emit_insn (gen_blockage ());\n   DONE;\n }\")"}, {"sha": "f65e27f34fc1ee33174a2b1fcb2c01515804effe", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for gcc2 for pdp11.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 95-98, 1999 Free Software Foundation, Inc.\n    Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n \n This file is part of GNU CC.\n@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -364,14 +364,14 @@ output_move_double (operands)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       output_asm_insn (\"sub $4,%0\", operands);\n-      operands[0] = gen_rtx (MEM, SImode, operands[0]);\n+      operands[0] = gen_rtx_MEM (SImode, operands[0]);\n       optype0 = OFFSOP;\n     }\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n       output_asm_insn (\"sub $4,%1\", operands);\n-      operands[1] = gen_rtx (MEM, SImode, operands[1]);\n+      operands[1] = gen_rtx_MEM (SImode, operands[1]);\n       optype1 = OFFSOP;\n     }\n \n@@ -394,14 +394,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, HImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 2);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, HImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 2);\n   else if (optype1 == CNSTOP)\n@@ -411,8 +411,8 @@ output_move_double (operands)\n \t    /* now the mess begins, high word is in lower word??? \n \n \t       that's what ashc makes me think, but I don't remember :-( */\n-\t    latehalf[1] = GEN_INT (INTVAL(operands[1])>>16);\n-\t    operands[1] = GEN_INT (INTVAL(operands[1])&0xff);\n+\t    latehalf[1] = GEN_INT (INTVAL(operands[1]) >> 16);\n+\t    operands[1] = GEN_INT (INTVAL(operands[1]) & 0xff);\n \t}\n       else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \t{\n@@ -576,14 +576,14 @@ output_move_quad (operands)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       output_asm_insn (\"sub $8,%0\", operands);\n-      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      operands[0] = gen_rtx_MEM (DImode, operands[0]);\n       optype0 = OFFSOP;\n     }\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n       output_asm_insn (\"sub $8,%1\", operands);\n-      operands[1] = gen_rtx (MEM, SImode, operands[1]);\n+      operands[1] = gen_rtx_MEM (SImode, operands[1]);\n       optype1 = OFFSOP;\n     }\n \n@@ -606,14 +606,14 @@ output_move_quad (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n@@ -631,19 +631,18 @@ output_move_quad (operands)\n \t    \n #ifndef HOST_WORDS_BIG_ENDIAN\n \t  latehalf[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n+\t  operands[1] = GEN_INT\t(CONST_DOUBLE_HIGH (operands[1]));\n #else /* HOST_WORDS_BIG_ENDIAN */\n \t  latehalf[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n \t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n #endif /* HOST_WORDS_BIG_ENDIAN */\n \t}\n       else if (GET_CODE(operands[1]) == CONST_INT)\n-      {\n+\t{\n \t  latehalf[1] = GEN_INT (0);\n-      }\n+\t}\n       else\n-\t  abort();\n-      \n+\tabort();\n     }\n   else\n     latehalf[1] = operands[1];"}, {"sha": "804e0d2747832f7d150a7287c7a7576b73cc7cd4", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -569,18 +569,18 @@ extern int current_first_parm_offset;\n not without FPU!!!! ) */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))\n \n /* and the called function leaves it in the first register.\n    Difference only on machines with register windows.  */\n \n #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, BASE_RETURN_VALUE_REG(MODE))\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, BASE_RETURN_VALUE_REG(MODE))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.\n@@ -1300,8 +1300,8 @@ JMP\tFUNCTION\t0x0058  0x0000 <- FUNCTION\n   if (TARGET_SPLIT)\t\t\t\\\n     abort();\t\t\t\t\\\n \t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 2)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant (TRAMP, 6)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 2)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 6)), FNADDR); \\\n }\n \n "}, {"sha": "217e314f1eb980429c46a8a5cfc32872750b7493", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for the pdp11 for GNU C compiler\n-;; Copyright (C) 1994, 1995, 1997, 1999 Free Software Foundation, Inc.\n+;; Copyright (C) 1994, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.\n ;; Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n \n ;; This file is part of GNU CC.\n@@ -732,7 +732,7 @@\n      {\n        output_asm_insn(\\\"{stcdf|movfo} %1, -(sp)\\\", operands);\n        output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n-       operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+       operands[0] = gen_rtx_REG (HImode, REGNO (operands[0])+1);\n        output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n        return \\\"\\\";\n      }\n@@ -805,8 +805,8 @@\n \n   /* make register pair available */\n   latehalf[0] = operands[0];\n-  operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n-    \n+  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0])+ 1);\n+\n   output_asm_insn(\\\"movb %1, %0\\\", operands);\n   output_asm_insn(\\\"sxt %0\\\", latehalf);\n     \n@@ -857,7 +857,7 @@\n \n       /* make register pair available */\n       latehalf[0] = operands[0];\n-      operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+      operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n \n       output_asm_insn(\\\"mov %1, %0\\\", operands);\n       output_asm_insn(\\\"sxt %0\\\", latehalf);\n@@ -883,7 +883,7 @@\n   rtx lateoperands[2];\n \n   lateoperands[0] = operands[0];\n-  operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n \n   output_asm_insn(\\\"tst %0\\\", operands);\n   sprintf(buf, \\\"bge extendhisi%d\\\", count);\n@@ -918,7 +918,7 @@\n        rtx latehalf[2];\n \n        latehalf[0] = NULL; \n-       latehalf[1] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+       latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n        output_asm_insn(\\\"mov %1, -(sp)\\\", latehalf);\n        output_asm_insn(\\\"mov %1, -(sp)\\\", operands);\n        \n@@ -952,7 +952,7 @@\n        output_asm_insn(\\\"{stcdl|movfi} %1, -(sp)\\\", operands);\n        output_asm_insn(\\\"seti\\\", operands);\n        output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n-       operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+       operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n        output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n        return \\\"\\\";\n      }\n@@ -998,7 +998,7 @@\n   lateoperands[0] = operands[0];\n \n   if (REG_P (operands[0]))\n-    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+    operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n   else\n     operands[0] = adj_offsettable_operand (operands[0], 2);\n   \n@@ -1007,7 +1007,7 @@\n     lateoperands[2] = operands[2];\n \n     if (REG_P (operands[2]))\n-      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+      operands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n     else\n       operands[2] = adj_offsettable_operand(operands[2], 2);\n \n@@ -1017,8 +1017,8 @@\n     return \\\"\\\";\n   }\n \n-  lateoperands[2] = GEN_INT ((INTVAL(operands[2]) >> 16) & 0xffff);\n-  operands[2] = GEN_INT (INTVAL(operands[2]) & 0xffff);\n+  lateoperands[2] = GEN_INT (INTVAL (operands[2]) >> 16) & 0xffff);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n   \n   if (INTVAL(operands[2]))\n   { \n@@ -1101,14 +1101,14 @@\n   lateoperands[0] = operands[0];\n \n   if (REG_P (operands[0]))\n-    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+    operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n   else\n     operands[0] = adj_offsettable_operand (operands[0], 2);\n   \n   lateoperands[2] = operands[2];\n \n   if (REG_P (operands[2]))\n-    operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+    operands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n   else\n     operands[2] = adj_offsettable_operand(operands[2], 2);\n \n@@ -1209,7 +1209,7 @@\n   lateoperands[0] = operands[0];\n \n   if (REG_P (operands[0]))\n-    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+    operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n   else\n     operands[0] = adj_offsettable_operand (operands[0], 2);\n   \n@@ -1218,7 +1218,7 @@\n     lateoperands[2] = operands[2];\n \n     if (REG_P (operands[2]))\n-      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+      operands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n     else\n       operands[2] = adj_offsettable_operand(operands[2], 2);\n \n@@ -1227,8 +1227,8 @@\n     return \\\"\\\";\n   }\n \n-  lateoperands[2] = GEN_INT ((INTVAL(operands[2]) >> 16) & 0xffff);\n-  operands[2] = GEN_INT (INTVAL(operands[2]) & 0xffff);\n+  lateoperands[2] = GEN_INT ((INTVAL (operands[2]) >> 16) & 0xffff);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n   \n   /* these have different lengths, so we should have \n      different constraints! */\n@@ -1275,26 +1275,26 @@\n   lateoperands[0] = operands[0];\n \n   if (REG_P (operands[0]))\n-    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+    operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n   else\n     operands[0] = adj_offsettable_operand (operands[0], 2);\n   \n   if (! CONSTANT_P(operands[2]))\n-  {\n-    lateoperands[2] = operands[2];\n+    {\n+      lateoperands[2] = operands[2];\n \n-    if (REG_P (operands[2]))\n-      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n-    else\n-      operands[2] = adj_offsettable_operand(operands[2], 2);\n+      if (REG_P (operands[2]))\n+\toperands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n+      else\n+\toperands[2] = adj_offsettable_operand (operands[2], 2);\n \n-    output_asm_insn (\\\"bis %2, %0\\\", operands);\n-    output_asm_insn (\\\"bis %2, %0\\\", lateoperands);\n-    return \\\"\\\";\n-  }\n+      output_asm_insn (\\\"bis %2, %0\\\", operands);\n+      output_asm_insn (\\\"bis %2, %0\\\", lateoperands);\n+      return \\\"\\\";\n+    }\n \n-  lateoperands[2] = GEN_INT ((INTVAL(operands[2]) >> 16) & 0xffff);\n-  operands[2] = GEN_INT (INTVAL(operands[2]) & 0xffff);\n+  lateoperands[2] = GEN_INT ((INTVAL (operands[2]) >> 16) & 0xffff);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n   \n   /* these have different lengths, so we should have \n      different constraints! */\n@@ -1336,26 +1336,26 @@\n   rtx lateoperands[3];\n \n   lateoperands[0] = operands[0];\n-  operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n \n   if (REG_P(operands[2]))\n-  {\n-    lateoperands[2] = operands[2];\n-    operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n-    \n-    output_asm_insn (\\\"xor %2, %0\\\", operands);\n-    output_asm_insn (\\\"xor %2, %0\\\", lateoperands);\n+    {\n+      lateoperands[2] = operands[2];\n+      operands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n \n-    return \\\"\\\";\n-  }\n+      output_asm_insn (\\\"xor %2, %0\\\", operands);\n+      output_asm_insn (\\\"xor %2, %0\\\", lateoperands);\n \n-  lateoperands[2] = GEN_INT ((INTVAL(operands[2]) >> 16) & 0xffff);\n+      return \\\"\\\";\n+    }\n+\n+  lateoperands[2] = GEN_INT ((INTVAL (operands[2]) >> 16) & 0xffff);\n   operands[2] = GEN_INT (INTVAL(operands[2]) & 0xffff);\n   \n-  if (INTVAL(operands[2]))\n+  if (INTVAL (operands[2]))\n     output_asm_insn (\\\"xor %2, %0\\\", operands);\n \n-  if (INTVAL(lateoperands[2]))\n+  if (INTVAL (lateoperands[2]))\n     output_asm_insn (\\\"xor %2, %0\\\", lateoperands);\n \n   return \\\"\\\";\n@@ -1614,7 +1614,7 @@\n ;\n ;  /* allow REG_NOTES to be set on last insn (labels don't have enough\n ;     fields, and can't be used for REG_NOTES anyway).  */\n-;  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+;  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n ;  DONE;\n ;}\")\n "}, {"sha": "9c39e3f77e9381838872efdfa28853fc4c260438", "filename": "gcc/config/pyr/pyr.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpyr%2Fpyr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpyr%2Fpyr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Pyramid 90x, 9000, and MIServer Series.\n-   Copyright (C) 1989, 1991, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -20,7 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Some output-actions in pyr.md need these.  */\n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -258,6 +258,7 @@ extend_const (x, extop, from_mode, to_mode)\n     val = val & ~((-1) << (GET_MODE_BITSIZE (from_mode)));\n   if (GET_MODE_BITSIZE (to_mode) == HOST_BITS_PER_INT)\n     return GEN_INT (val);\n+\n   return GEN_INT (val & ~((-1) << (GET_MODE_BITSIZE (to_mode))));\n }\n \n@@ -296,7 +297,7 @@ extend_and_branch (extop)\n   if (op1 == 0)\n     {\n       op0 = ensure_extended (op0, extop, test_mode);\n-      emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, op0));\n+      emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, op0));\n     }\n   else\n     {\n@@ -338,8 +339,8 @@ extend_and_branch (extop)\n \t    op0 = force_reg (test_mode, op0);\n \t}\n \n-      emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,\n-\t\t\t  gen_rtx (COMPARE, VOIDmode, op0, op1)));\n+      emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n+\t\t\t      gen_rtx_COMPARE (VOIDmode, op0, op1)));\n     }\n }\n \n@@ -630,7 +631,7 @@ output_move_double (operands)\n \t    }\n \t  operands[1] = GEN_INT (CONST_DOUBLE_HIGH (const_op));\n \t  output_asm_insn (\"movw %1,%0\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (const_op));\n \t  return \"movw %1,%0\";\n \t}\n@@ -648,7 +649,7 @@ output_move_double (operands)\n \t    }\n \t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (const_op));\n \t  output_asm_insn (\"movw %1,%0\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  operands[1] = GEN_INT (CONST_DOUBLE_HIGH (const_op));\n \t  return \"movw %1,%0\";\n \t}"}, {"sha": "e5167791665a6203c3619c1a2679fb7d1ab8579e", "filename": "gcc/config/pyr/pyr.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine parameters for GNU compiler,\n    for Pyramid 90x, 9000, and MIServer Series.\n-   Copyright (C) 1989, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 95-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -511,19 +511,19 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    --> its type.   */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), PYR_TREG(0))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), PYR_TREG(0))\n \n /* --> but the callee has to leave it in PR0(/PR1) */\n \n #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)\t\\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), PYR_PREG(0))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), PYR_PREG(0))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n /* --> On Pyramid the return value is in TR0/TR1 regardless.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, PYR_TREG(0))\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, PYR_TREG(0))\n \n /* Define this if PCC uses the nonreentrant convention for returning\n    structure and union values.  */\n@@ -652,7 +652,7 @@ extern int inner_param_safe_helper();\n \t\t   + ((MODE) == BLKmode\t\t\t\t\\\n \t\t      ? (int_size_in_bytes (TYPE) + 3) / 4\t\\\n \t\t      : (GET_MODE_SIZE (MODE) + 3) / 4))\t\\\n-    ? gen_rtx (REG, (MODE), PYR_TREG(CUM))\t\t\t\\\n+    ? gen_rtx_REG ((MODE), PYR_TREG(CUM))\t\t\t\\\n     : 0)\t\t\t\t\t\t\t\\\n  : 0)\n #ifdef __GNUC__\n@@ -673,7 +673,7 @@ extern void* pyr_function_arg ();\n \t   + ((MODE) == BLKmode\t\t\t\t\\\n \t      ? (int_size_in_bytes (TYPE) + 3) / 4\t\\\n \t      : (GET_MODE_SIZE (MODE) + 3) / 4))\t\\\n-    ? gen_rtx (REG, (MODE), PYR_PREG(CUM))\t\t\\\n+    ? gen_rtx_REG ((MODE), PYR_PREG(CUM))\t\t\\\n     : 0)\t\t\t\t\t\t\\\n  : 0)\n \n@@ -749,12 +749,13 @@ extern void* pyr_function_arg ();\n    CXT is an RTX for the static chain value for the function.  */\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-{ emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 4)), CXT);\t\\\n+{ emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (TRAMP, 4)), CXT);\t\\\n   emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 12)), FNADDR); \\\n-  emit_call_insn (gen_call (gen_rtx (MEM, QImode,\t\t\t\\\n-\t\t\t\t     gen_rtx (SYMBOL_REF, Pmode,\t\\\n-\t\t\t\t\t      \"__enable_execute_stack\")), \\\n-\t\t\t    const0_rtx));\t\t\t\t\\\n+  emit_call_insn (gen_call\t\t\t\t\t\t\\\n+\t\t  (gen_rtx_MEM\t\t\t\t\t\t\\\n+\t\t   (QImode,\t\t\t\t\t\t\\\n+\t\t    gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\")), \\\n+\t\t   const0_rtx));\t\t\t\t\\\n }\n \n /* Output assembler code to FILE to increment profiler label # LABELNO"}, {"sha": "efd7bce5a1a75d7351de29299f5c6de99b4c0f94", "filename": "gcc/config/pyr/pyr.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpyr%2Fpyr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fpyr%2Fpyr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;; GNU C machine description for Pyramid 90x, 9000, MIServer Series\n-;; Copyright (C) 1989, 1990, 1995, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1989, 90, 95, 97, 98, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1257,9 +1257,9 @@\n {\n   rtx xoperands[2];\n   CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     {\n       xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n@@ -1278,9 +1278,9 @@\n {\n   rtx xoperands[2];\n   CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     {\n       xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n@@ -1299,9 +1299,9 @@\n {\n   rtx xoperands[2];\n   CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     {\n       xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n@@ -1320,9 +1320,9 @@\n {\n   rtx xoperands[2];\n   CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     {\n       xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n@@ -1341,9 +1341,9 @@\n {\n   rtx xoperands[2];\n   CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     {\n       xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));"}, {"sha": "b5096c2f9c2f75a0d0c831652834a09d70ee8512", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on ROMP.\n-   Copyright (C) 1990, 1991, 1992, 1993, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 91, 92, 93, 97, 98, 1999 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n This file is part of GNU CC.\n@@ -21,7 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -825,8 +825,8 @@ print_operand (file, x, code)\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n       else if (GET_CODE (x) == MEM)\n-\tprint_operand (file, gen_rtx (MEM, GET_MODE (x),\n-\t\t\t\t      plus_constant (XEXP (x, 0), 4)), 0);\n+\tprint_operand (file, gen_rtx_MEM (GET_MODE (x),\n+\t\t\t\t\t  plus_constant (XEXP (x, 0), 4)), 0);\n       else\n \tabort ();\n       break;\n@@ -1222,8 +1222,7 @@ output_epilog (file, size)\n   /* Restore floating-point registers.  */\n   if (write_code)\n     output_loadsave_fpregs (file, CLOBBER,\n-\t\t\t    gen_rtx (PLUS, Pmode, gen_rtx (REG, Pmode, 1),\n-\t\t\t\t     GEN_INT (fp_save)));\n+\t\t\t    plus_constant (gen_rtx_REG (Pmode, 1), fp_save));\n \n   /* If we push the stack and do not have size > 32K, adjust the register\n      save location to the current position of sp.  Otherwise, if long frame,\n@@ -1349,9 +1348,9 @@ get_symref (name)\n       end_temporary_allocation ();\n       p = *last_p = (struct symref_hashent *)\n \t\t\tpermalloc (sizeof (struct symref_hashent));\n-      p->symref = gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t   obstack_copy0 (&permanent_obstack,\n-\t\t\t\t\t  name, strlen (name)));\n+      p->symref = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t      obstack_copy0 (&permanent_obstack,\n+\t\t\t\t\t\t     name, strlen (name)));\n       p->next = 0;\n       resume_temporary_allocation ();\n     }\n@@ -1740,8 +1739,7 @@ output_loadsave_fpregs (file, code, addr)\n \n   if (mask)\n     fprintf (file, \"\\t%s\\n\",\n-\t     output_fpop (code, GEN_INT (mask),\n-\t\t\t\tgen_rtx (MEM, Pmode, addr),\n+\t     output_fpop (code, GEN_INT (mask), gen_rtx_MEM (Pmode, addr),\n \t\t\t\t0, const0_rtx));\n \n }"}, {"sha": "521a78c2b13d85c0c485e3fe43f5a60ba0d8e162", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for ROMP chip.\n-   Copyright (C) 1989, 1991, 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 91, 93, 95, 96, 98, 1999 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n This file is part of GNU CC.\n@@ -271,13 +271,11 @@ extern int target_flags;\n \n /* Place to put static chain when calling a function that requires it.  */\n #define STATIC_CHAIN\t\t\t\t\t\t\t\\\n-  gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\t\\\n-\t\t\t\tGEN_INT (-36)))\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, -36))\n \n /* Place where static chain is found upon entry to routine.  */\n #define STATIC_CHAIN_INCOMING\t\t\t\t\t\t\\\n-  gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode, arg_pointer_rtx,\t\t\\\n-\t\t\t\tGEN_INT (-20)))\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -20))\n \n /* Place that structure value return address is placed.\n \n@@ -520,15 +518,16 @@ enum reg_class { NO_REGS, R0_REGS, R15_REGS, BASE_REGS, GENERAL_REGS,\n    On ROMP the value is found in r2, unless the machine specific option\n    fp-arg-in-fpregs is selected, in which case FP return values are in fr1 */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE),\t\\\n-\t   (TARGET_FP_REGS &&\t\t\\\n-\t    GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT) ? 18 : 2)\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\t\\\n+\t       (TARGET_FP_REG\t\t\t\t\t\t\\\n+\t\t&& GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT)\t\\\n+\t       ? 18 : 2)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 2)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 2)\n \n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.\n@@ -628,8 +627,8 @@ struct rt_cargs {int gregs, fregs; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n   (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n    : ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST) ? 0\t\\\n-   : USE_FP_REG(MODE,CUM) ? gen_rtx(REG, (MODE),(CUM.fregs) + 17)\t\\\n-   : (CUM).gregs < 4 ? gen_rtx(REG, (MODE), 2 + (CUM).gregs) : 0)\n+   : USE_FP_REG(MODE,CUM) ? gen_rtx_REG ((MODE), (CUM.fregs) + 17)\t\\\n+   : (CUM).gregs < 4 ? gen_rtx_REG ((MODE), 2 + (CUM).gregs) : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -672,9 +671,9 @@ struct rt_cargs {int gregs, fregs; };\n       if (! NO_RTL && first_reg_offset != 4)\t\t\t\t\\\n \tmove_block_from_reg\t\t\t\t\t\t\\\n \t  (2 + first_reg_offset,\t\t\t\t\t\\\n-\t   gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n-\t\t    plus_constant (virtual_incoming_args_rtx,\t\t\\\n-\t\t\t\t   first_reg_offset * 4)), \t\t\\\n+\t   gen_rtx_MEM (BLKmode,\t\t\t\t\t\\\n+\t\t\tplus_constant (virtual_incoming_args_rtx,\t\\\n+\t\t\t\t       first_reg_offset * 4)), \t\t\\\n \t   4 - first_reg_offset, (4 - first_reg_offset) * UNITS_PER_WORD); \\\n       PRETEND_SIZE = (4 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -814,27 +813,27 @@ struct rt_cargs {int gregs, fregs; };\n   _temp = expand_binop (SImode, add_optab, ADDR,\t\t\\\n \t\t\tGEN_INT (4),\t\t\t\t\\\n \t\t\t0, 1, OPTAB_LIB_WIDEN);\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n-\t\t\t   memory_address (SImode, ADDR)), _temp); \\\n+  emit_move_insn (gen_rtx_MEM (SImode,\t\t\t\t\\\n+\t\t\t       memory_address (SImode, ADDR)), _temp); \\\n \t\t\t\t\t\t\t\t\\\n   _val = force_reg (SImode, CXT);\t\t\t\t\\\n   _addr = memory_address (HImode, plus_constant (ADDR, 10));\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, _addr),\t\t\t\\\n \t\t  gen_lowpart (HImode, _val));\t\t\t\\\n   _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\\\n \t\t\tbuild_int_2 (16, 0), 0, 1);\t\t\\\n   _addr = memory_address (HImode, plus_constant (ADDR, 6));\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, _addr),\t\t\t\\\n \t\t  gen_lowpart (HImode, _temp));\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n   _val = force_reg (SImode, FNADDR);\t\t\t\t\\\n   _addr = memory_address (HImode, plus_constant (ADDR, 24));\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, _addr),\t\t\t\\\n \t\t  gen_lowpart (HImode, _val));\t\t\t\\\n   _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\\\n \t\t\tbuild_int_2 (16, 0), 0, 1);\t\t\\\n   _addr = memory_address (HImode, plus_constant (ADDR, 20));\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, _addr),\t\t\t\\\n \t\t  gen_lowpart (HImode, _temp));\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n }\n@@ -1074,11 +1073,10 @@ struct rt_cargs {int gregs, fregs; };\n       low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\\\n       if (low_int & 0x8000)\t\t\t\t\t\\\n \thigh_int += 1, low_int |= 0xffff0000;\t\t\t\\\n-      (X) = gen_rtx (PLUS, SImode,\t\t\t\t\\\n-\t\t     force_operand\t\t\t\t\\\n-\t\t     \t(gen_rtx (PLUS, SImode, XEXP (X, 0), \\\n-\t\t\t\t  GEN_INT (high_int << 16)), 0),\\\n-\t\t     GEN_INT (low_int));\t\t\t\\\n+      (X) = gen_rtx_PLUS (SImode,\t\t\t\t\\\n+\t\t\t  force_operand (plus_constant (XEXP (X, 0),  \\\n+\t\t\t\t\t\t\thigh_int << 16)),  \\\n+\t\t\t  GEN_INT (low_int));\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n@@ -1129,7 +1127,7 @@ struct rt_cargs {int gregs, fregs; };\n \t\t&& GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2))\t\\\n \t\t&& REGNO (op0) == REGNO (op2))\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n-\t\ttem = gen_rtx (REG, GET_MODE (op0), 17);\t\t\\\n+\t\ttem = gen_rtx_REG (GET_MODE (op0), 17);\t\t\\\n \t\temit_insn_after (gen_move_insn (op0, tem), INSN);\t\\\n \t\tSET_DEST (XVECEXP (PATTERN (INSN), 0, 0)) = tem; \t\\\n \t\tOPERANDS[0] = tem;\t\t\t\t\t\\\n@@ -1584,8 +1582,8 @@ extern int romp_debugger_arg_correction();\n   else if (GET_CODE (addr) == SYMBOL_REF\t\t\t\\\n \t   && CONSTANT_POOL_ADDRESS_P (addr))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      offset = GEN_INT (get_pool_offset (addr) + 12);  \\\n-      base = gen_rtx (REG, SImode, 14);\t\t\t\t\\\n+      offset = GEN_INT (get_pool_offset (addr) + 12);  \t\t\\\n+      base = gen_rtx_REG (SImode, 14);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (addr) == CONST\t\t\t\t\\\n \t   && GET_CODE (XEXP (addr, 0)) == PLUS\t\t\t\\\n@@ -1596,7 +1594,7 @@ extern int romp_debugger_arg_correction();\n       offset = plus_constant (XEXP (XEXP (addr, 0), 1),\t\t\\\n \t\t\t      (get_pool_offset (XEXP (XEXP (addr, 0), 0)) \\\n \t\t\t       + 12));\t\t\t\t\\\n-      base = gen_rtx (REG, SImode, 14);\t\t\t\t\\\n+      base = gen_rtx_REG (SImode, 14);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   output_addr_const (FILE, offset);\t\t\t\t\\\n   if (base)\t\t\t\t\t\t\t\\"}, {"sha": "82290c49780451e4804d3fba60831be8c0d6f09b", "filename": "gcc/config/romp/romp.md", "status": "modified", "additions": 52, "deletions": 63, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fromp%2Fromp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fromp%2Fromp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for ROMP chip for GNU C compiler\n-;;   Copyright (C) 1988, 91, 93, 94, 95, 1999 Free Software Foundation, Inc.\n+;;   Copyright (C) 1988, 91, 93, 94, 95, 98, 1999 Free Software Foundation, Inc.\n ;;   Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -180,8 +180,7 @@\n \t       || (unsigned) ((- const_val) + 0x8000) < 0x10000)\n \t{\n \t  /* Can do this by loading the negative constant and then negating. */\n-\t  emit_move_insn (operands[0],\n-\t\t\t  GEN_INT (- const_val));\n+\t  emit_move_insn (operands[0], GEN_INT (- const_val));\n \t  emit_insn (gen_negsi2 (operands[0], operands[0]));\n \t  DONE;\n \t}\n@@ -195,8 +194,7 @@\n \t  if (low_part >= 0x10 && exact_log2 (low_part) >= 0)\n \t    i = high_part, high_part = low_part, low_part = i;\n \n-\t  emit_move_insn (operands[0],\n-\t\t\t  GEN_INT (low_part));\n+\t  emit_move_insn (operands[0], GEN_INT (low_part));\n \t  emit_insn (gen_iorsi3 (operands[0], operands[0],\n \t\t\t\t GEN_INT (high_part)));\n \t  DONE;\n@@ -482,11 +480,9 @@\n { operands[2] = operand_subword (operands[0], 1, 0, DImode);\n   operands[3] = XEXP (operands[1], 0);\n   operands[4] = operand_subword (operands[0], 0, 0, DImode);\n-  operands[5] = gen_rtx (MEM, SImode, operands[2]);\n+  operands[5] = gen_rtx_MEM (SImode, operands[2]);\n   operands[6] = operands[2];\n-  operands[7] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, SImode, operands[2],\n-\t\t\t\t  GEN_INT (4)));\n+  operands[7] = gen_rtx_MEM (SImode, plus_constant (operands[2], 4));\n \n   if (operands[2] == 0 || operands[4] == 0)\n     FAIL;\n@@ -503,11 +499,9 @@\n    (set (match_dup 6) (match_dup 7))]\n   \"\n { operands[3] = XEXP (operands[0], 0);\n-  operands[4] = gen_rtx (MEM, SImode, operands[2]);\n+  operands[4] = gen_rtx_MEM (SImode, operands[2]);\n   operands[5] = operand_subword (operands[1], 0, 0, DImode);\n-  operands[6] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, SImode, operands[2],\n-\t\t\t\t  GEN_INT (4)));\n+  operands[6] = gen_rtx_MEM (SImode, plus_constant (operands[4], 4));\n   operands[7] = operand_subword (operands[1], 1, 0, DImode);\n \n   if (operands[5] == 0 || operands[7] == 0)\n@@ -607,8 +601,8 @@\n     operands[7] = operands[8] = operands[6];\n   else\n     {\n-      operands[7] = gen_rtx (SCRATCH, SImode);\n-      operands[8] = gen_rtx (SCRATCH, SImode);\n+      operands[7] = gen_rtx_SCRATCH (SImode);\n+      operands[8] = gen_rtx_SCRATCH (SImode);\n     }\n }\")\n \n@@ -631,7 +625,7 @@\n \n   if (op0 == op1)\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode, op0, op1));\n+      emit_insn (gen_rtx_SET (VOIDmode, op0, op1));\n       DONE;\n     }\n \n@@ -686,7 +680,7 @@\n   \n   if (op0 == op1)\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode, op0, op1));\n+      emit_insn (gen_rtx_SET (VOIDmode, op0, op1));\n       DONE;\n     }\n \n@@ -706,7 +700,7 @@\n       last = emit_move_insn (operand_subword (op0, 0, 1, SFmode),\n \t\t\t     operand_subword_force (op1, 0, SFmode));\n \n-      REG_NOTES (last) = gen_rtx (EXPR_LIST, REG_EQUAL, op1, REG_NOTES (last));\n+      REG_NOTES (last) = gen_rtx_EXPR_LIST (REG_EQUAL, op1, REG_NOTES (last));\n       DONE;\n     }\n }\")\n@@ -812,11 +806,10 @@\n   \"\n { operands[2] = XEXP (operands[1], 0);\n   operands[3] = operand_subword (operands[0], 0, 0, DFmode);\n-  operands[4] = gen_rtx (MEM, SImode, gen_rtx (REG, SImode, 15));\n+  operands[4] = gen_rtx_MEM (SImode, gen_rtx (REG, SImode, 15));\n   operands[5] = operand_subword (operands[0], 1, 0, DFmode);\n-  operands[6] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, SImode, gen_rtx (REG, SImode, 15),\n-\t\t\t\t  GEN_INT (4)));\n+  operands[6] = gen_rtx_MEM (SImode,\n+\t\t\t     plus_constant (gen_rtx (REG, SImode, 15), 4));\n \n   if (operands[3] == 0 || operands[5] == 0)\n     FAIL;\n@@ -833,11 +826,10 @@\n    (set (match_dup 5) (match_dup 6))]\n   \"\n { operands[2] = XEXP (operands[0], 0);\n-  operands[3] = gen_rtx (MEM, SImode, gen_rtx (REG, SImode, 15));\n+  operands[3] = gen_rtx_MEM (SImode, gen_rtx (REG, SImode, 15));\n   operands[4] = operand_subword (operands[1], 0, 0, DFmode);\n-  operands[5] = gen_rtx (MEM, SImode,\n-\t\t\t gen_rtx (PLUS, SImode, gen_rtx (REG, SImode, 15),\n-\t\t\t\t  GEN_INT (4)));\n+  operands[5] = gen_rtx_MEM (SImode,\n+\t\t\t     plus_constant (gen_rtx_REG (SImode, 15), 4));\n   operands[6] = operand_subword (operands[1], 1, 0, DFmode);\n \n   if (operands[4] == 0 || operands[6] == 0)\n@@ -870,11 +862,11 @@\n     FAIL;\n \n   if (reload_completed)\n-    operands[6] = operands[7] = gen_rtx (REG, SImode, 15);\n+    operands[6] = operands[7] = gen_rtx_REG (SImode, 15);\n   else\n     {\n-      operands[6] = gen_rtx (SCRATCH, SImode);\n-      operands[7] = gen_rtx (SCRATCH, SImode);\n+      operands[6] = gen_rtx_SCRATCH (SImode);\n+      operands[7] = gen_rtx_SCRATCH (SImode);\n     }\n }\")\n \n@@ -1208,8 +1200,7 @@\n       if (low & 0x8000)\n \thigh++, low |= 0xffff0000;\n \n-      emit_insn (gen_addsi3 (operands[0], operands[1],\n-\t\t\t     GEN_INT (high << 16)));\n+      emit_insn (gen_addsi3 (operands[0], operands[1], GEN_INT (high << 16)));\n       operands[1] = operands[0];\n       operands[2] = GEN_INT (low);\n     }\n@@ -1366,16 +1357,16 @@\n   rtx insn;\n \n   emit_insn (gen_divmodsi4_doit (operands[1], operands[2]));\n-  insn = emit_move_insn (operands[0], gen_rtx (REG, SImode, 2));\n-  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t      gen_rtx (DIV, SImode, operands[1],\n-\t\t\t\t       operands[2]),\n-\t\t\t      REG_NOTES (insn));\n-  insn = emit_move_insn (operands[3], gen_rtx (REG, SImode, 3));\n-  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t      gen_rtx (MOD, SImode, operands[1],\n-\t\t\t\t       operands[2]),\n-\t\t\t      REG_NOTES (insn));\n+  insn = emit_move_insn (operands[0], gen_rtx_REG (SImode, 2));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\tgen_rtx_DIV (SImode, operands[1],\n+\t\t\t\t\t\t     operands[2]),\n+\t\t\t\t\tREG_NOTES (insn));\n+  insn = emit_move_insn (operands[3], gen_rtx_REG (SImode, 3));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\tgen_rtx_MOD (SImode, operands[1],\n+\t\t\t\t\t\t     operands[2]),\n+\t\t\t\t\tREG_NOTES (insn));\n   DONE;\n }\")\n \n@@ -1416,16 +1407,16 @@\n   rtx insn;\n \n   emit_insn (gen_udivmodsi4_doit (operands[1], operands[2]));\n-  insn = emit_move_insn (operands[0], gen_rtx (REG, SImode, 2));\n-  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t      gen_rtx (UDIV, SImode, operands[1],\n-\t\t\t\t       operands[2]),\n-\t\t\t      REG_NOTES (insn));\n-  insn = emit_move_insn (operands[3], gen_rtx (REG, SImode, 3));\n-  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t      gen_rtx (UMOD, SImode, operands[1],\n-\t\t\t\t       operands[2]),\n-\t\t\t      REG_NOTES (insn));\n+  insn = emit_move_insn (operands[0], gen_rtx_REG (SImode, 2));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\tgen_rtx_UDIV (SImode, operands[1],\n+\t\t\t\t\t\t      operands[2]),\n+\t\t\t\t\tREG_NOTES (insn));\n+  insn = emit_move_insn (operands[3], gen_rtx_REG (SImode, 3));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\tgen_rtx_UMOD (SImode, operands[1],\n+\t\t\t\t\t\t      operands[2]),\n+\t\t\t\t\tREG_NOTES (insn));\n   DONE;\n }\")\n \n@@ -1550,7 +1541,7 @@\n       if (top != 0 && bottom != 0)\n \t{\n \t  emit_insn (gen_iorsi3 (operands[0], operands[1],\n-\t\t\t\t GEN_INT ((top << 16))));\n+\t\t\t\t GEN_INT (top << 16))));\n \t  operands[1] = operands[0];\n \t  operands[2] = GEN_INT (bottom);\n \t}\n@@ -1590,7 +1581,7 @@\n       else if (top != 0 && bottom != 0)\n \t{\n \t  emit_insn (gen_xorsi3 (operands[0], operands[1],\n-\t\t\t\t GEN_INT ((top << 16))));\n+\t\t\t\t GEN_INT (top << 16)));\n \t  operands[1] = operands[0];\n \t  operands[2] = GEN_INT (bottom);\n \t}\n@@ -1664,7 +1655,7 @@\n   \"\"\n   \"\n {\n-  rtx reg0 = gen_rtx (REG, SImode, 0);\n+  rtx reg0 = gen_rtx_REG (SImode, 0);\n   rtx call_insn;\n \n   if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != CONST_INT)\n@@ -1674,8 +1665,8 @@\n   if (GET_CODE (operands[0]) == SYMBOL_REF)\n     {\n       extern rtx get_symref ();\n-      char *real_fcnname =\n-\t\t(char *) alloca (strlen (XSTR (operands[0], 0)) + 2);\n+      char *real_fcnname\n+\t= (char *) alloca (strlen (XSTR (operands[0], 0)) + 2);\n \n       /* Copy the data area address to r0.  */\n       emit_move_insn (reg0, force_reg (SImode, operands[0]));\n@@ -1688,7 +1679,7 @@\n       rtx data_access;\n \n       emit_move_insn (reg0, force_reg (SImode, operands[0]));\n-      data_access = gen_rtx (MEM, SImode, operands[0]);\n+      data_access = gen_rtx_MEM (SImode, operands[0]);\n       RTX_UNCHANGING_P (data_access) = 1;\n       operands[0] = copy_to_reg (data_access);\n     }\n@@ -1723,7 +1714,7 @@\n   \"\"\n   \"\n {\n-  rtx reg0 = gen_rtx (REG, SImode, 0);\n+  rtx reg0 = gen_rtx_REG (SImode, 0);\n   rtx call_insn;\n \n   if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != CONST_INT)\n@@ -1747,7 +1738,7 @@\n       rtx data_access;\n \n       emit_move_insn (reg0,force_reg (SImode, operands[1]));\n-      data_access = gen_rtx (MEM, SImode, operands[1]);\n+      data_access = gen_rtx_MEM (SImode, operands[1]);\n       RTX_UNCHANGING_P (data_access) = 1;\n       operands[1] = copy_to_reg (data_access);\n     }\n@@ -1977,8 +1968,7 @@\n \n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, SFmode),\n-\t\t\t     GEN_INT (0x80000000),\n-\t\t\t     target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n \n@@ -2011,8 +2001,7 @@\n       start_sequence ();\n       result = expand_binop (SImode, xor_optab,\n \t\t\t     operand_subword_force (operands[1], 0, DFmode),\n-\t\t\t     GEN_INT (0x80000000),\n-\t\t\t     target, 0, OPTAB_WIDEN);\n+\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n       if (result == 0)\n \tabort ();\n "}, {"sha": "2594863de85c68c6f71a8b67512d41973c5f35d5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2199,8 +2199,8 @@ expand_block_move (operands)\n \t    }\n \t  else\n \t    {\n-\t      src_addr  = gen_rtx_PLUS (Pmode, src_reg,  GEN_INT (offset));\n-\t      dest_addr = gen_rtx_PLUS (Pmode, dest_reg, GEN_INT (offset));\n+\t      src_addr = plus_constant (src_reg, offset);\n+\t      dest_addr = plus_constant (dest_reg, offset);\n \t    }\n \n \t  /* Generate the appropriate load and store, saving the stores for later */\n@@ -3675,7 +3675,8 @@ rs6000_stack_info ()\n   if (TARGET_EABI)\n #endif\n     {\n-      if (strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)), \"main\") == 0\n+      if (0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n+\t\t       \"main\")\n \t  && DECL_CONTEXT (current_function_decl) == NULL_TREE)\n \t{\n \t  info_ptr->main_p = 1;\n@@ -5594,7 +5595,8 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n \n /* Macros to shorten the code expansions below.  */\n #define MEM_DEREF(addr) gen_rtx_MEM (pmode, memory_address (pmode, addr))\n-#define MEM_PLUS(addr,offset) gen_rtx_MEM (pmode, memory_address (pmode, plus_constant (addr, offset)))\n+#define MEM_PLUS(addr,offset) \\\n+  gen_rtx_MEM (pmode, memory_address (pmode, plus_constant (addr, offset)))\n \n     /* Under AIX, just build the 3 word function descriptor */\n     case ABI_AIX:"}, {"sha": "db1108417f0eed9e382cc789cd78474038d152dc", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1368,8 +1368,8 @@ extern int rs6000_sysv_varargs_p;\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE)\t\t\\\n-  gen_rtx_REG (MODE,\t\t\t\\\n-\t       GET_MODE_CLASS (MODE) == MODE_FLOAT && TARGET_HARD_FLOAT ? 33 : 3)\n+  gen_rtx_REG (MODE, (GET_MODE_CLASS (MODE) == MODE_FLOAT\t \\\n+\t\t      && TARGET_HARD_FLOAT ? 33 : 3))\n \n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.\n@@ -1718,10 +1718,13 @@ typedef struct rs6000_args\n   ((count == -1)\t\t\t\t\t\\\n    ? gen_rtx_REG (Pmode, 65)\t\t\t\t\\\n    : gen_rtx_MEM (Pmode,\t\t\t\t\\\n-\t      memory_address (Pmode, \t\t\t\\\n-\t\t\t      plus_constant (copy_to_reg (gen_rtx_MEM (Pmode, \\\n-\t\t\t\t\t\t\t\t   memory_address (Pmode, frame))), \\\n-\t\t\t\t\t     RETURN_ADDRESS_OFFSET))))\n+\t\t  memory_address\t\t\t\\\n+\t\t  (Pmode, \t\t\t\t\\\n+\t\t   plus_constant (copy_to_reg\t\t\\\n+\t\t\t\t  (gen_rtx_MEM (Pmode,\t\\\n+\t\t\t\t\t\tmemory_address (Pmode, \\\n+\t\t\t\t\t\t\t\tframe))), \\\n+\t\t\t\t  RETURN_ADDRESS_OFFSET))))\n \f\n /* Definitions for register eliminations.\n \n@@ -1998,7 +2001,7 @@ typedef struct rs6000_args\n       if (low_int & 0x8000)\t\t\t\t\t\t\\\n \thigh_int += 0x10000, low_int |= ((HOST_WIDE_INT) -1) << 16;\t\\\n       sum = force_operand (gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\\\n-\t\t\t\t    GEN_INT (high_int)), 0);\t\t\\\n+\t\t\t\t\t GEN_INT (high_int)), 0);\t\\\n       (X) = gen_rtx_PLUS (Pmode, sum, GEN_INT (low_int));\t\t\\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2009,7 +2012,7 @@ typedef struct rs6000_args\n \t   && (MODE) != TImode)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\t\\\n-\t\t     force_reg (Pmode, force_operand (XEXP (X, 1), 0))); \\\n+\t\t\t  force_reg (Pmode, force_operand (XEXP (X, 1), 0))); \\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (TARGET_ELF && TARGET_32BIT && TARGET_NO_TOC\t\t\t\\\n@@ -3107,7 +3110,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n   do { char buf[100];\t\t\t\t\t\\\n        fputs (TARGET_32BIT ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\"}, {"sha": "54e62060d2bc52cc9d8941dca250240c75917fcd", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -4318,11 +4318,12 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t  indx,\n-\t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff) ^ 0x8000) - 0x8000)\n-\t\t\t\t\t   + ((WORDS_BIG_ENDIAN != 0) * 4))));\n+  operands[2]\n+    = gen_rtx_MEM (SImode,\n+\t\t   plus_constant (indx,\n+\t\t\t\t  (((rs6000_fpmem_offset & 0xffff) ^ 0x8000)\n+\t\t\t\t   - 0x8000)\n+\t\t\t\t  + ((WORDS_BIG_ENDIAN != 0) * 4)));\n \n   return \\\"{st|stw} %0,%2\\\";\n }\"\n@@ -4345,11 +4346,12 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t  indx,\n-\t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff) ^ 0x8000) - 0x8000)\n-\t\t\t\t\t   + ((WORDS_BIG_ENDIAN == 0) * 4))));\n+  operands[2]\n+    = gen_rtx_MEM (SImode,\n+\t\t   plus_constant (indx,\n+\t\t\t\t  (((rs6000_fpmem_offset & 0xffff) ^ 0x8000)\n+\t\t\t\t   - 0x8000)\n+\t\t\t\t  + ((WORDS_BIG_ENDIAN == 0) * 4)));\n \n   return \\\"{st|stw} %0,%2\\\";\n }\"\n@@ -4375,8 +4377,7 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t gen_rtx_PLUS (Pmode, indx, GEN_INT (offset)));\n+  operands[2] = gen_rtx_MEM (SImode, plus_constant (indx, offset));\n \n   return \\\"lfd %0,%2\\\";\n }\"\n@@ -4449,10 +4450,9 @@\n     indx = stack_pointer_rtx;\n \n   operands[2] = gen_rtx_MEM (DFmode,\n-\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t  indx,\n-\t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff)\n-\t\t\t\t\t     ^ 0x8000) - 0x8000))));\n+\t\t\t     plus_constant (indx,\n+\t\t\t\t\t    (((rs6000_fpmem_offset & 0xffff)\n+\t\t\t\t\t      ^ 0x8000) - 0x8000)));\n \n   return \\\"stfd %0,%2\\\";\n }\"\n@@ -4474,11 +4474,12 @@\n   else\n     indx = stack_pointer_rtx;\n \n-  operands[2] = gen_rtx_MEM (DFmode,\n-\t\t\t gen_rtx_PLUS (Pmode,\n-\t\t\t\t  indx,\n-\t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff) ^ 0x8000) - 0x8000)\n-\t\t\t\t\t   + ((WORDS_BIG_ENDIAN) ? 4 : 0))));\n+  operands[2]\n+    = gen_rtx_MEM (DFmode,\n+\t\t   plus_constant (indx,\n+\t\t\t\t  (((rs6000_fpmem_offset & 0xffff) ^ 0x8000)\n+\t\t\t\t   - 0x8000)\n+\t\t\t\t  + ((WORDS_BIG_ENDIAN) ? 4 : 0)));\n \n   return \\\"{l|lwz} %0,%2\\\";\n }\"\n@@ -4507,7 +4508,7 @@\n   rtx last = XVECEXP (insns, 0, XVECLEN (insns, 0) - 1);\n \n   REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n-\t\t\t       REG_NOTES (first));\n+\t\t\t\t\t REG_NOTES (first));\n   REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n \n   emit_insn (insns);\n@@ -6015,7 +6016,8 @@\n \t  while (*name == '.')\n \t    name++;\n \t  new_ref = gen_rtx_SYMBOL_REF (Pmode, name);\n-\t  CONSTANT_POOL_ADDRESS_P (new_ref) = CONSTANT_POOL_ADDRESS_P (operands[1]);\n+\t  CONSTANT_POOL_ADDRESS_P (new_ref)\n+\t    = CONSTANT_POOL_ADDRESS_P (operands[1]);\n \t  SYMBOL_REF_FLAG (new_ref) = SYMBOL_REF_FLAG (operands[1]);\n \t  SYMBOL_REF_USED (new_ref) = SYMBOL_REF_USED (operands[1]);\n \t  operands[1] = new_ref;\n@@ -7198,8 +7200,8 @@\n   for (i = 0; i < count; i++)\n     XVECEXP (operands[3], 0, i)\n       = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno + i),\n-\t\t change_address (operands[1], SImode,\n-\t\t\t\t plus_constant (from, i * 4)));\n+\t\t     change_address (operands[1], SImode,\n+\t\t\t\t     plus_constant (from, i * 4)));\n }\")\n \n (define_insn \"\"\n@@ -7293,16 +7295,16 @@\n \n   XVECEXP (operands[3], 0, 0)\n     = gen_rtx_SET (VOIDmode, change_address (operands[0], SImode, to),\n-\t       operands[1]);\n+\t\t   operands[1]);\n   XVECEXP (operands[3], 0, 1) = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (SImode));\n+\t\t\t\t\t\t gen_rtx_SCRATCH (SImode));\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 1)\n       = gen_rtx_SET (VOIDmode,\n-\t\t change_address (operands[0], SImode,\n-\t\t\t\t plus_constant (to, i * 4)),\n-\t\t gen_rtx_REG (SImode, regno + i));\n+\t\t     change_address (operands[0], SImode,\n+\t\t\t\t     plus_constant (to, i * 4)),\n+\t\t     gen_rtx_REG (SImode, regno + i));\n }\")\n \n (define_insn \"\"\n@@ -7874,7 +7876,8 @@\n       && (GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) > 4096))\n     {\n       rtx tmp = gen_reg_rtx (Pmode);\n-      emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__allocate_stack\\\"),\n+      emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\\\"__allocate_stack\\\"),\n \t\t\t       tmp, 0, Pmode, 1, operands[1], Pmode);\n       emit_insn (gen_set_sp (tmp));\n       emit_move_insn (operands[0], tmp);\n@@ -7962,7 +7965,8 @@\n \n   /* Copy the backchain to the first word, sp to the second.  */\n   emit_move_insn (temp, gen_rtx_MEM (Pmode, operands[1]));\n-  emit_move_insn (operand_subword (operands[0], 0, 0, (TARGET_32BIT ? DImode : TImode)),\n+  emit_move_insn (operand_subword (operands[0], 0, 0,\n+\t\t\t\t   (TARGET_32BIT ? DImode : TImode)),\n \t\t  temp);\n   emit_move_insn (operand_subword (operands[0], 1, 0, (TARGET_32BIT ? DImode : TImode)),\n \t\t  operands[1]);\n@@ -7981,7 +7985,8 @@\n   emit_move_insn (temp,\n \t\t  operand_subword (operands[1], 0, 0, (TARGET_32BIT ? DImode : TImode)));\n   emit_move_insn (operands[0],\n-\t\t  operand_subword (operands[1], 1, 0, (TARGET_32BIT ? DImode : TImode)));\n+\t\t  operand_subword (operands[1], 1, 0,\n+\t\t\t\t   (TARGET_32BIT ? DImode : TImode)));\n   emit_move_insn (gen_rtx_MEM (Pmode, operands[0]), temp);\n   DONE;\n }\")\n@@ -8201,7 +8206,8 @@\n \n \t  if (DEFAULT_ABI == ABI_AIX)\n \t    {\n-\t      /* AIX function pointers are really pointers to a three word area */\n+\t      /* AIX function pointers are really pointers to a three word\n+\t\t area.  */\n \t      rtx static_chain = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n \t      emit_call_insn (TARGET_32BIT\n \t\t\t      ? gen_call_indirect_aix32 (force_reg (Pmode, operands[0]),\n@@ -8263,7 +8269,8 @@\n \n \t  if (DEFAULT_ABI == ABI_AIX)\n \t    {\n-\t      /* AIX function pointers are really pointers to a three word area */\n+\t      /* AIX function pointers are really pointers to a three word\n+\t\t area.  */\n \t      rtx static_chain = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n \t      emit_call_insn (TARGET_32BIT\n \t\t\t      ? gen_call_value_indirect_aix32 (operands[0],\n@@ -8655,7 +8662,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8670,7 +8677,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8685,7 +8692,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8700,7 +8707,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8715,7 +8722,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8730,7 +8737,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8744,7 +8751,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8758,7 +8765,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8772,7 +8779,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8786,7 +8793,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8803,7 +8810,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8817,7 +8824,7 @@\n     FAIL;\n \n   operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCFPmode);\n }\")\n \n@@ -8834,7 +8841,7 @@\n     FAIL;\n \n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8851,7 +8858,7 @@\n     FAIL;\n \n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8863,7 +8870,7 @@\n   \"\n { enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8880,7 +8887,7 @@\n     FAIL;\n \n   operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (mode);\n }\")\n \n@@ -8891,7 +8898,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8902,7 +8909,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8913,7 +8920,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n@@ -8924,7 +8931,7 @@\n   \"\"\n   \"\n { operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \f\n@@ -10368,7 +10375,7 @@\n   \"TARGET_32BIT\"\n   \"\n { operands[0] = force_reg (SImode, operands[0]);\n-  operands[2] = force_reg (SImode, gen_rtx_LABEL_REF (VOIDmode, operands[1]));\n+  operands[2] = force_reg (SImode, gen_rtx_LABEL_REF (SImode, operands[1]));\n   operands[3] = gen_reg_rtx (SImode);\n }\")\n \n@@ -10381,7 +10388,7 @@\n   \"TARGET_64BIT\"\n   \"\n { operands[0] = force_reg (DImode, operands[0]);\n-  operands[2] = force_reg (DImode, gen_rtx_LABEL_REF (VOIDmode, operands[1]));\n+  operands[2] = force_reg (DImode, gen_rtx_LABEL_REF (SImode, operands[1]));\n   operands[3] = gen_reg_rtx (DImode);\n }\")\n "}, {"sha": "46d1ddd8e5449945f2794ef04a28de0a8243caca", "filename": "gcc/config/rs6000/xm-sysv4.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Fxm-sysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Frs6000%2Fxm-sysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxm-sysv4.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,5 @@\n /* Configuration for GNU C-compiler for PowerPC running System V.4.\n-   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n-\n+   Copyright (C) 1995, 1998, 1999 Free Software Foundation, Inc.\n    Cloned from sparc/xm-sysv4.h by Michael Meissner (meissner@cygnus.com).\n \n This file is part of GNU CC.\n@@ -59,12 +58,3 @@ extern char *alloca ();\n #undef ONLY_INT_FIELDS\n #define ONLY_INT_FIELDS\n #endif\n-\n-#ifdef __PPC__\n-#ifndef __STDC__\n-extern char *malloc (), *realloc (), *calloc ();\n-#else\n-extern void *malloc (), *realloc (), *calloc ();\n-#endif\n-extern void free ();\n-#endif"}, {"sha": "c6c28cdb687e17f37dd45788b138fb3f20faab0e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,7 @@\n /* Output routines for GCC for Hitachi Super-H.\n-   Copyright (C) 1993-1998 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1998, 1999 Free Software Foundation, Inc.\n+   Contributed by Steve Chamberlain (sac@cygnus.com).\n+   Improved by Jim Wilson (wilson@cygnus.com). \n \n This file is part of GNU CC.\n \n@@ -18,13 +20,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Contributed by Steve Chamberlain (sac@cygnus.com).\n-   Improved by Jim Wilson (wilson@cygnus.com).  */\n-\n #include \"config.h\"\n-\n-#include <stdio.h>\n-\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -392,16 +389,16 @@ expand_block_move (operands)\n       char entry[30];\n       tree entry_name;\n       rtx func_addr_rtx;\n-      rtx r4 = gen_rtx (REG, SImode, 4);\n-      rtx r5 = gen_rtx (REG, SImode, 5);\n+      rtx r4 = gen_rtx_REG (SImode, 4);\n+      rtx r5 = gen_rtx_REG (SImode, 5);\n \n       sprintf (entry, \"__movstrSI%d\", bytes);\n       entry_name = get_identifier (entry);\n \n       func_addr_rtx\n \t= copy_to_mode_reg (Pmode,\n-\t\t\t    gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t\t     IDENTIFIER_POINTER (entry_name)));\n+\t\t\t    gen_rtx_SYMBOL_REF\n+\t\t\t    (Pmode, IDENTIFIER_POINTER (entry_name)));\n       force_into (XEXP (operands[0], 0), r4);\n       force_into (XEXP (operands[1], 0), r5);\n       emit_insn (gen_block_move_real (func_addr_rtx));\n@@ -415,15 +412,15 @@ expand_block_move (operands)\n       tree entry_name;\n       rtx func_addr_rtx;\n       int final_switch, while_loop;\n-      rtx r4 = gen_rtx (REG, SImode, 4);\n-      rtx r5 = gen_rtx (REG, SImode, 5);\n-      rtx r6 = gen_rtx (REG, SImode, 6);\n+      rtx r4 = gen_rtx_REG (SImode, 4);\n+      rtx r5 = gen_rtx_REG (SImode, 5);\n+      rtx r6 = gen_rtx_REG (SImode, 6);\n \n       entry_name = get_identifier (\"__movstr\");\n       func_addr_rtx\n \t= copy_to_mode_reg (Pmode,\n-\t\t\t    gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t\t     IDENTIFIER_POINTER (entry_name)));\n+\t\t\t    gen_rtx_SYMBOL_REF\n+\t\t\t    (Pmode, IDENTIFIER_POINTER (entry_name)));\n       force_into (XEXP (operands[0], 0), r4);\n       force_into (XEXP (operands[1], 0), r5);\n \n@@ -478,7 +475,7 @@ rtx\n prepare_scc_operands (code)\n      enum rtx_code code;\n {\n-  rtx t_reg = gen_rtx (REG, SImode, T_REG);\n+  rtx t_reg = gen_rtx_REG (SImode, T_REG);\n   enum rtx_code oldcode = code;\n   enum machine_mode mode;\n \n@@ -562,9 +559,10 @@ from_compare (operands, code)\n       insn = gen_ieee_ccmpeqsf_t (sh_compare_op0, sh_compare_op1);\n     }\n   else\n-    insn = gen_rtx (SET, VOIDmode,\n-\t\t    gen_rtx (REG, SImode, 18),\n-\t\t    gen_rtx (code, SImode, sh_compare_op0, sh_compare_op1));\n+    insn = gen_rtx_SET (VOIDmode,\n+\t\t\tgen_rtx_REG (SImode, 18),\n+\t\t\tgen_rtx (code, SImode, sh_compare_op0,\n+\t\t\t\t sh_compare_op1));\n   if (TARGET_SH4 && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n       insn = gen_rtx (PARALLEL, VOIDmode,\n@@ -711,7 +709,7 @@ output_far_jump (insn, op)\n       if (dbr_sequence_length ())\n \tprint_slot (final_sequence);\n \n-      this.reg = gen_rtx (REG, SImode, 13);\n+      this.reg = gen_rtx_REG (SImode, 13);\n       output_asm_insn (\"mov.l\tr13,@-r15\", 0);\n       output_asm_insn (jump, &this.lab);\n       output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n@@ -1218,13 +1216,13 @@ expand_ashiftrt (operands)\n   wrk = gen_reg_rtx (Pmode);\n \n   /* Load the value into an arg reg and call a helper.  */\n-  emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n+  emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n   sprintf (func, \"__ashiftrt_r4_%d\", value);\n   func_name = get_identifier (func);\n-  emit_move_insn (wrk, gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t\tIDENTIFIER_POINTER (func_name)));\n+  emit_move_insn (wrk, gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t   IDENTIFIER_POINTER (func_name)));\n   emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk));\n-  emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n+  emit_move_insn (operands[0], gen_rtx_REG (SImode, 4));\n   return 1;\n }\n \n@@ -2559,7 +2557,7 @@ gen_block_redirect (jump, addr, need_block)\n \n   if (dead)\n     {\n-      rtx reg = gen_rtx (REG, SImode, exact_log2 (dead & -dead));\n+      rtx reg = gen_rtx_REG (SImode, exact_log2 (dead & -dead));\n \n       /* It would be nice if we could convert the jump into an indirect\n \t jump / far branch right now, and thus exposing all constituent\n@@ -2767,8 +2765,8 @@ machine_dependent_reorg (first)\n {\n   rtx insn, mova;\n   int num_mova;\n-  rtx r0_rtx = gen_rtx (REG, Pmode, 0);\n-  rtx r0_inc_rtx = gen_rtx (POST_INC, Pmode, r0_rtx);\n+  rtx r0_rtx = gen_rtx_REG (Pmode, 0);\n+  rtx r0_inc_rtx = gen_rtx_POST_INC (Pmode, r0_rtx);\n \n   /* If relaxing, generate pseudo-ops to associate function calls with\n      the symbols they call.  It does no harm to not generate these\n@@ -2973,10 +2971,10 @@ machine_dependent_reorg (first)\n              or pseudo-op.  */\n \n \t  label = gen_label_rtx ();\n-\t  REG_NOTES (link) = gen_rtx (EXPR_LIST, REG_LABEL, label,\n-\t\t\t\t      REG_NOTES (link));\n-\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, label,\n-\t\t\t\t      REG_NOTES (insn));\n+\t  REG_NOTES (link) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\t\t\t\t\tREG_NOTES (link));\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\t\t\t\t\tREG_NOTES (insn));\n \t  if (rescan)\n \t    {\n \t      scan = link;\n@@ -2990,8 +2988,8 @@ machine_dependent_reorg (first)\n \t\t\t   && reg_mentioned_p (reg, scan))\n \t\t\t  || ((reg2 = sfunc_uses_reg (scan))\n \t\t\t      && REGNO (reg2) == REGNO (reg))))\n-\t\t    REG_NOTES (scan) = gen_rtx (EXPR_LIST, REG_LABEL,\n-\t\t\t\t\t\tlabel, REG_NOTES (scan));\n+\t\t    REG_NOTES (scan)\n+\t\t      = gen_rtx_EXPR_LIST (REG_LABEL, label, REG_NOTES (scan));\n \t\t}\n \t      while (scan != dies);\n \t    }\n@@ -3091,7 +3089,7 @@ machine_dependent_reorg (first)\n \t\t\t  offset += SUBREG_WORD (dst);\n \t\t\t  dst = SUBREG_REG (dst);\n \t\t\t}\n-\t\t      dst = gen_rtx (REG, HImode, REGNO (dst) + offset);\n+\t\t      dst = gen_rtx_REG (HImode, REGNO (dst) + offset);\n \t\t    }\n \n \t\t  if (GET_CODE (dst) == REG\n@@ -3145,11 +3143,11 @@ machine_dependent_reorg (first)\n \t\t  else\n \t\t    {\n \t\t      lab = add_constant (src, mode, 0);\n-\t\t      newsrc = gen_rtx (MEM, mode,\n-\t\t\t\t\tgen_rtx (LABEL_REF, VOIDmode, lab));\n+\t\t      newsrc = gen_rtx_MEM (mode,\n+\t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab));\n \t\t    }\n \t\t  RTX_UNCHANGING_P (newsrc) = 1;\n-\t\t  *patp = gen_rtx (SET, VOIDmode, dst, newsrc);\n+\t\t  *patp = gen_rtx_SET (VOIDmode, dst, newsrc);\n \t\t  INSN_CODE (scan) = -1;\n \t\t}\n \t    }\n@@ -3564,7 +3562,7 @@ output_stack_adjust (size, reg, temp)\n \t     to handle this case, so just abort when we see it.  */\n \t  if (temp < 0)\n \t    abort ();\n-\t  const_reg = gen_rtx (REG, SImode, temp);\n+\t  const_reg = gen_rtx_REG (SImode, temp);\n \n \t  /* If SIZE is negative, subtract the positive value.\n \t     This sometimes allows a constant pool entry to be shared\n@@ -3597,16 +3595,17 @@ push (rn)\n     {\n       if ((rn - FIRST_FP_REG) & 1 && rn <= LAST_FP_REG)\n \treturn;\n-      x = gen_push_4 (gen_rtx (REG, DFmode, rn));\n+      x = gen_push_4 (gen_rtx_REG (DFmode, rn));\n     }\n   else if (TARGET_SH3E && rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n-    x = gen_push_e (gen_rtx (REG, SFmode, rn));\n+    x = gen_push_e (gen_rtx_REG (SFmode, rn));\n   else\n-    x = gen_push (gen_rtx (REG, SImode, rn));\n+    x = gen_push (gen_rtx_REG (SImode, rn));\n \n   x = emit_insn (x);\n-  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n-\t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n+  REG_NOTES (x)\n+    = gen_rtx_EXPR_LIST (REG_INC,\n+\t\t\t gen_rtx_REG (SImode, STACK_POINTER_REGNUM), 0);\n }\n \n /* Output RTL to pop register RN from the stack.  */\n@@ -3623,16 +3622,17 @@ pop (rn)\n     {\n       if ((rn - FIRST_FP_REG) & 1 && rn <= LAST_FP_REG)\n \treturn;\n-      x = gen_pop_4 (gen_rtx (REG, DFmode, rn));\n+      x = gen_pop_4 (gen_rtx_REG (DFmode, rn));\n     }\n   else if (TARGET_SH3E && rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n-    x = gen_pop_e (gen_rtx (REG, SFmode, rn));\n+    x = gen_pop_e (gen_rtx_REG (SFmode, rn));\n   else\n-    x = gen_pop (gen_rtx (REG, SImode, rn));\n+    x = gen_pop (gen_rtx_REG (SImode, rn));\n     \n   x = emit_insn (x);\n-  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n-\t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n+  REG_NOTES (x)\n+    = gen_rtx_EXPR_LIST (REG_INC,\n+\t\t\t gen_rtx_REG (SImode, STACK_POINTER_REGNUM), 0);\n }\n \n /* Generate code to push the regs specified in the mask.  */\n@@ -3904,9 +3904,10 @@ sh_builtin_saveregs ()\n      named args need not be saved.  */\n   if (n_intregs > 0)\n     move_block_from_reg (BASE_ARG_REG (SImode) + first_intreg,\n-\t\t\t gen_rtx (MEM, BLKmode, \n-\t\t\t \tplus_constant (XEXP (regbuf, 0),\n-\t\t\t\t\tn_floatregs * UNITS_PER_WORD)), \n+\t\t\t gen_rtx_MEM (BLKmode, \n+\t\t\t\t      plus_constant (XEXP (regbuf, 0),\n+\t\t\t\t\t\t     (n_floatregs\n+\t\t\t\t\t\t      * UNITS_PER_WORD))),\n \t\t\t n_intregs, n_intregs * UNITS_PER_WORD);\n \n   /* Save float args.\n@@ -3943,8 +3944,8 @@ sh_builtin_saveregs ()\n     for (regno = NPARM_REGS (SFmode) - 1; regno >= first_floatreg; regno--)\n       {\n \temit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n-\temit_move_insn (gen_rtx (MEM, SFmode, fpregs),\n-\t\t\tgen_rtx (REG, SFmode, BASE_ARG_REG (SFmode) + regno));\n+\temit_move_insn (gen_rtx_MEM (SFmode, fpregs),\n+\t\t\tgen_rtx_REG (SFmode, BASE_ARG_REG (SFmode) + regno));\n       }\n \n   /* Return the address of the regbuf.  */\n@@ -4085,8 +4086,8 @@ sh_valid_machine_decl_attribute (decl, attributes, attr, args)\n       if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n \treturn 0;\n \n-      sp_switch = gen_rtx (SYMBOL_REF, VOIDmode,\n-\t\t\t   TREE_STRING_POINTER (TREE_VALUE (args)));\n+      sp_switch = gen_rtx_SYMBOL_REF (VOIDmode,\n+\t\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args)));\n       return 1;\n     }\n "}, {"sha": "dd802ab6f79379cd3959c7a35edee9c04d05a285", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for Hitachi Super-H.\n-   Copyright (C) 1993-1998 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1998, 1999 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -923,7 +923,7 @@ extern enum reg_class reg_class_from_letter[];\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE) \\\n-  gen_rtx (REG, (MODE), BASE_RETURN_VALUE_REG (MODE))\n+  gen_rtx_REG ((MODE), BASE_RETURN_VALUE_REG (MODE));\n \n /* 1 if N is a possible register number for a function value. */\n #define FUNCTION_VALUE_REGNO_P(REGNO) \\\n@@ -1043,10 +1043,10 @@ struct sh_args {\n   ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n     && ((NAMED)\t\t\t\t\t\t\t\t\\\n \t|| (! TARGET_HITACHI && (TARGET_SH3E || ! current_function_varargs)))) \\\n-   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t      ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \t\\\n-\t       ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n-\t\t  && TARGET_LITTLE_ENDIAN != 0)))\t\t\t\\\n+   ? gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+\t\t  ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \t\\\n+\t\t   ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n+\t\t      && TARGET_LITTLE_ENDIAN != 0)))\t\t\t\\\n    : 0)\n \n #define PRETEND_OUTGOING_VARARGS_NAMED (! TARGET_HITACHI)\n@@ -1129,13 +1129,13 @@ extern int current_function_anonymous_args;\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, (TRAMP)),\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, (TRAMP)),\t\t\t\\\n \t\t  GEN_INT (TARGET_LITTLE_ENDIAN ? 0xd301dd02 : 0xdd02d301));\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 4)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 4)),\t\\\n \t\t  GEN_INT (TARGET_LITTLE_ENDIAN ? 0x00094d2b : 0x4d2b0009));\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 8)),\t\\\n \t\t  (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 12)),\t\\\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n   if (TARGET_HARVARD)\t\t\t\t\t\t\t\\\n     emit_insn (gen_ic_invalidate_line (TRAMP));\t\t\t\t\\\n@@ -1148,7 +1148,7 @@ extern int current_function_anonymous_args;\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n   (((COUNT) == 0)\t\t\t\t\\\n-   ? gen_rtx (MEM, Pmode, gen_rtx (REG, Pmode, RETURN_ADDRESS_POINTER_REGNUM)) \\\n+   ? gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM)) \\\n    : (rtx) 0)\n \f\n /* Generate necessary RTL for __builtin_saveregs().  */\n@@ -1393,7 +1393,7 @@ extern struct rtx_def *sh_builtin_saveregs ();\n \t\t\t      GEN_INT (offset_base), NULL_RTX, 0, \\\n \t\t\t      OPTAB_LIB_WIDEN);\t\t\t\\\n                                                                 \\\n-\t  (X) = gen_rtx (PLUS, Pmode, sum, GEN_INT (offset - offset_base)); \\\n+\t  (X) = gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base)); \\\n \t  goto WIN;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\"}, {"sha": "ac3d3b0a6f4371c4104289d43adcfbc8d4b564d3", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -706,10 +706,12 @@\n   \"\n {\n   rtx high0, high2, low0 = gen_lowpart (SImode, operands[0]);\n-  high0 = gen_rtx (REG, SImode,\n-\t\t   true_regnum (operands[0]) + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n-  high2 = gen_rtx (REG, SImode,\n-\t\t   true_regnum (operands[2]) + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n+  high0 = gen_rtx_REG (SImode,\n+\t\t       true_regnum (operands[0])\n+\t\t       + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n+  high2 = gen_rtx_REG (SImode,\n+\t\t       true_regnum (operands[2])\n+\t\t       + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n   emit_insn (gen_clrt ());\n   emit_insn (gen_addc (low0, low0, gen_lowpart (SImode, operands[2])));\n   emit_insn (gen_addc1 (high0, high0, high2));\n@@ -770,10 +772,12 @@\n   \"\n {\n   rtx high0, high2, low0 = gen_lowpart (SImode, operands[0]);\n-  high0 = gen_rtx (REG, SImode,\n-\t\t   true_regnum (operands[0]) + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n-  high2 = gen_rtx (REG, SImode,\n-\t\t   true_regnum (operands[2]) + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n+  high0 = gen_rtx_REG (SImode,\n+\t\t       true_regnum (operands[0])\n+\t\t       + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n+  high2 = gen_rtx_REG (SImode,\n+\t\t       true_regnum (operands[2])\n+\t\t       + (TARGET_LITTLE_ENDIAN ? 1 : 0));\n   emit_insn (gen_clrt ());\n   emit_insn (gen_subc (low0, low0, gen_lowpart (SImode, operands[2])));\n   emit_insn (gen_subc1 (high0, high0, high2));\n@@ -1152,9 +1156,9 @@\n \n       emit_insn (gen_mulsidi3_i (operands[1], operands[2]));\n \n-      emit_insn (gen_rtx (CLOBBER, VOIDmode, operands[0]));\n-      emit_move_insn (low_dst, gen_rtx (REG, SImode, 21));\n-      emit_move_insn (high_dst, gen_rtx (REG, SImode, 20));\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, operands[0]));\n+      emit_move_insn (low_dst, gen_rtx_REG (SImode, 21));\n+      emit_move_insn (high_dst, gen_rtx_REG (SImode, 20));\n       DONE;\n     }\n }\")\n@@ -1185,9 +1189,9 @@\n \n       emit_insn (gen_umulsidi3_i (operands[1], operands[2]));\n \n-      emit_insn (gen_rtx (CLOBBER, VOIDmode, operands[0]));\n-      emit_move_insn (low_dst, gen_rtx (REG, SImode, 21));\n-      emit_move_insn (high_dst, gen_rtx (REG, SImode, 20));\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, operands[0]));\n+      emit_move_insn (low_dst, gen_rtx_REG (SImode, 21));\n+      emit_move_insn (high_dst, gen_rtx_REG (SImode, 20));\n       DONE;\n     }\n }\")\n@@ -2755,7 +2759,7 @@\n   emit_move_insn (operands[2], const_int);\n   emit_move_insn (operands[0],\n \t\t  change_address (operands[1], VOIDmode,\n-\t\t\t\t  gen_rtx (PLUS, SImode, reg, operands[2])));\n+\t\t\t\t  gen_rtx_PLUS (SImode, reg, operands[2])));\n   DONE;\n }\")\n \n@@ -2780,7 +2784,7 @@\n     FAIL;\n   emit_move_insn (operands[2], const_int);\n   emit_move_insn (change_address (operands[1], VOIDmode,\n-\t\t\t\t  gen_rtx (PLUS, SImode, reg, operands[2])),\n+\t\t\t\t  gen_rtx_PLUS (SImode, reg, operands[2])),\n \t\t  operands[0]);\n   DONE;\n }\")\n@@ -3463,7 +3467,7 @@\n     {\n       if (TARGET_IEEE)\n \t{\n-\t  rtx t_reg = gen_rtx (REG, SImode, T_REG);\n+\t  rtx t_reg = gen_rtx_REG (SImode, T_REG);\n \t  rtx lab = gen_label_rtx ();\n \t  prepare_scc_operands (EQ);\n \t  emit_jump_insn (gen_branch_true (lab));\n@@ -4394,14 +4398,14 @@\n   addr_target = copy_addr_to_reg (plus_constant (orig_address, size - 1));\n \n   operands[0] = change_address (operands[0], QImode, addr_target);\n-  emit_insn (gen_movqi (operands[0], gen_rtx (SUBREG, QImode, shift_reg, 0)));\n+  emit_insn (gen_movqi (operands[0], gen_rtx_SUBREG (QImode, shift_reg, 0)));\n \n   while (size -= 1)\n     {\n       emit_insn (gen_lshrsi3_k (shift_reg, shift_reg, GEN_INT (8)));\n       emit_insn (gen_addsi3 (addr_target, addr_target, GEN_INT (-1)));\n       emit_insn (gen_movqi (operands[0],\n-\t\t\t    gen_rtx (SUBREG, QImode, shift_reg, 0)));\n+\t\t\t    gen_rtx_SUBREG (QImode, shift_reg, 0)));\n     }\n \n   DONE;"}, {"sha": "43583b738e6a8be9da15bcb38dcbe9a73508dc37", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1195,15 +1195,14 @@ extern int sparc_mode_class[];\n #define STRUCT_VALUE \\\n   (TARGET_ARCH64\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\\\n-   : gen_rtx_MEM (Pmode,\t\t\t\t\\\n-\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx, \\\n-\t\t       GEN_INT (STRUCT_VALUE_OFFSET))))\n+   : gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, \\\n+\t\t\t\t\tSTRUCT_VALUE_OFFSET)))\n+\n #define STRUCT_VALUE_INCOMING \\\n-  (TARGET_ARCH64\t\t\t\t\t\\\n-   ? 0\t\t\t\t\t\t\t\\\n-   : gen_rtx_MEM (Pmode,\t\t\t\t\\\n-\t\t  gen_rtx_PLUS (Pmode, frame_pointer_rtx, \\\n-\t\t       GEN_INT (STRUCT_VALUE_OFFSET))))\n+  (TARGET_ARCH64\t\t\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\t\\\n+   : gen_rtx_MEM (Pmode, plus_constant (frame_pointer_rtx,\t\\\n+\t\t\t\t\tSTRUCT_VALUE_OFFSET)))\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -1497,8 +1496,8 @@ extern char leaf_reg_remap[];\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n   (get_frame_size () == 0\t\t\t\t\t\t\\\n    ? assign_stack_local (MODE, GET_MODE_SIZE (MODE), 0)\t\t\t\\\n-   : gen_rtx_MEM (MODE, gen_rtx_PLUS (Pmode, frame_pointer_rtx,\t\\\n-\t\t\t\t  GEN_INT (STARTING_FRAME_OFFSET))))\n+   : gen_rtx_MEM (MODE, plus_constant (frame_pointer_rtx,\t\t\\\n+\t\t\t\t       STARTING_FRAME_OFFSET)))\n \n /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9\n    because the movsi and movsf patterns don't handle r/f moves.\n@@ -2076,8 +2075,7 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    return an rtx for the address of the word in the frame\n    that holds the dynamic chain--the previous frame's address.\n    ??? -mflat support? */\n-#define DYNAMIC_CHAIN_ADDRESS(frame) \\\n-  gen_rtx_PLUS (Pmode, frame, GEN_INT (14 * UNITS_PER_WORD))\n+#define DYNAMIC_CHAIN_ADDRESS(frame) plus_constant (frame, 14 * UNITS_PER_WORD)\n \n /* The return address isn't on the stack, it is in a register, so we can't\n    access it from the current frame pointer.  We can access it from the\n@@ -2098,14 +2096,15 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n   ((count == -1)\t\t\t\t\\\n    ? gen_rtx_REG (Pmode, 31)\t\t\t\\\n    : gen_rtx_MEM (Pmode,\t\t\t\\\n-\t      memory_address (Pmode, plus_constant (frame, 15 * UNITS_PER_WORD))))\n+\t\t  memory_address (Pmode, plus_constant (frame, \\\n+\t\t\t\t\t\t\t15 * UNITS_PER_WORD))))\n \n /* Before the prologue, the return address is %o7 + 8.  OK, sometimes it's\n    +12, but always using +8 is close enough for frame unwind purposes.\n    Actually, just using %o7 is close enough for unwinding, but %o7+8\n    is something you can return to.  */\n #define INCOMING_RETURN_ADDR_RTX \\\n-  gen_rtx_PLUS (word_mode, gen_rtx_REG (word_mode, 15), GEN_INT (8))\n+  plus_constant (gen_rtx_REG (word_mode, 15), 8)\n \n /* The offset from the incoming value of %sp to the top of the stack frame\n    for the current function.  On sparc64, we have to account for the stack\n@@ -2389,25 +2388,25 @@ extern struct rtx_def *legitimize_pic_address ();\n { rtx sparc_x = (X);\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n     (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), NULL_RTX));\t\\\n+\t\t\tforce_operand (XEXP (X, 0), NULL_RTX));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n     (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), NULL_RTX));\t\\\n+\t\t\tforce_operand (XEXP (X, 1), NULL_RTX));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n     (X) = gen_rtx_PLUS (Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n-\t\t   XEXP (X, 1));\t\t\t\t\\\n+\t\t\tXEXP (X, 1));\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n     (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), NULL_RTX));\t\\\n+\t\t\tforce_operand (XEXP (X, 1), NULL_RTX));\t\\\n   if (sparc_x != (X) && memory_address_p (MODE, X))\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\\\n   if (flag_pic) (X) = legitimize_pic_address (X, MODE, 0);\t\\\n   else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n     (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t   copy_to_mode_reg (Pmode, XEXP (X, 1)));\t\\\n+\t\t\tcopy_to_mode_reg (Pmode, XEXP (X, 1)));\t\\\n   else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n     (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),\t\t\t\\\n-\t\t   copy_to_mode_reg (Pmode, XEXP (X, 0)));\t\\\n+\t\t\tcopy_to_mode_reg (Pmode, XEXP (X, 0)));\t\\\n   else if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n \t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n     (X) = copy_to_suggested_reg (X, NULL_RTX, Pmode); \t\t\\"}, {"sha": "c51e25cac2f4a669d6d6ab8315a481bbabb84e45", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2421,7 +2421,9 @@\n \n (define_insn \"*sethi_di_medlow_embmedany_pic\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (high:DI (match_operand:DI 1 \"sp64_medium_pic_operand\" \"\")))]\n+        (high:DI (match_operand:DI 1 \"sp64_medium_pic_operand\" \"\")))\n+  ;; The clobber is here because emit_move_sequence assumes the worst case.\n+   (clobber (reg:DI 1))]\n   \"(TARGET_CM_MEDLOW || TARGET_CM_EMBMEDANY) && check_pic (1)\"\n   \"sethi\\\\t%%hi(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n@@ -2430,6 +2432,8 @@\n (define_insn \"*sethi_di_medlow\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (match_operand:DI 1 \"symbolic_operand\" \"\")))]\n+  ;; The clobber is here because emit_move_sequence assumes the worst case.\n+   (clobber (reg:DI 1))]\n   \"TARGET_CM_MEDLOW && check_pic (1)\"\n   \"sethi\\\\t%%hi(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n@@ -3954,8 +3958,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n-\t\t\t\t\t op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n \t\t\t  shift_16));\n   emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n   DONE;\n@@ -4033,8 +4036,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1,\n-\t\t\t\t\t\top1_subword),\n+  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subword),\n \t\t\t  shift_48));\n   emit_insn (gen_lshrdi3 (operand0, temp, shift_48));\n   DONE;\n@@ -4214,8 +4216,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n-\t\t\t\t\t\top1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n \t\t\t  shift_16));\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n   DONE;\n@@ -4250,8 +4251,7 @@\n       op0_subword = SUBREG_WORD (operand0);\n       operand0 = XEXP (operand0, 0);\n     }\n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n-\t\t\t\t\t\top1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n \t\t\t  shift_24));\n   if (GET_MODE (operand0) != SImode)\n     operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subword);\n@@ -4283,8 +4283,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n-\t\t\t\t\t\top1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n \t\t\t  shift_24));\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n   DONE;\n@@ -4314,8 +4313,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1,\n-\t\t\t\t\t\top1_subword),\n+  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subword),\n \t\t\t  shift_56));\n   emit_insn (gen_ashrdi3 (operand0, temp, shift_56));\n   DONE;\n@@ -4345,8 +4343,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1,\n-\t\t\t\t\t\top1_subword),\n+  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subword),\n \t\t\t  shift_48));\n   emit_insn (gen_ashrdi3 (operand0, temp, shift_48));\n   DONE;\n@@ -6280,11 +6277,14 @@\n {\n   if (! TARGET_ARCH64)\n     {\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n-\t\t\t  gen_rtx_SET (VOIDmode, operand0,\n-\t\t\t\t   gen_rtx_NEG (DImode, operand1)),\n-\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_REG (CCmode, SPARC_ICC_REG)))));\n+      emit_insn (gen_rtx_PARALLEL\n+\t\t (VOIDmode,\n+\t\t  gen_rtvec (2,\n+\t\t\t     gen_rtx_SET (VOIDmode, operand0,\n+\t\t\t\t\t  gen_rtx_NEG (DImode, operand1)),\n+\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (CCmode,\n+\t\t\t\t\t\t\t   SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -7407,21 +7407,19 @@\n \n       if (! TARGET_ARCH64 && INTVAL (operands[3]) != 0)\n \temit_jump_insn\n-\t  (gen_rtx_PARALLEL (VOIDmode,\n-\t\t    gen_rtvec (3,\n-\t\t\t       gen_rtx_SET (VOIDmode, pc_rtx,\n-\t\t\t\t\tXEXP (operands[0], 0)),\n-\t\t\t       GEN_INT (INTVAL (operands[3]) & 0xfff),\n-\t\t\t       gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\tgen_rtx_REG (Pmode, 15)))));\n+\t  (gen_rtx_PARALLEL\n+\t   (VOIDmode,\n+\t    gen_rtvec (3,\n+\t\t       gen_rtx_SET (VOIDmode, pc_rtx, XEXP (operands[0], 0)),\n+\t\t       GEN_INT (INTVAL (operands[3]) & 0xfff),\n+\t\t       gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))));\n       else\n \temit_jump_insn\n-\t  (gen_rtx_PARALLEL (VOIDmode,\n-\t\t    gen_rtvec (2,\n-\t\t\t       gen_rtx_SET (VOIDmode, pc_rtx,\n-\t\t\t\t\tXEXP (operands[0], 0)),\n-\t\t\t       gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\tgen_rtx_REG (Pmode, 15)))));\n+\t  (gen_rtx_PARALLEL\n+\t   (VOIDmode,\n+\t    gen_rtvec (2,\n+\t\t       gen_rtx_SET (VOIDmode, pc_rtx, XEXP (operands[0], 0)),\n+\t\t       gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))));\n       goto finish_call;\n     }\n \n@@ -7441,17 +7439,17 @@\n \n   if (! TARGET_ARCH64 && INTVAL (operands[3]) != 0)\n     emit_call_insn\n-      (gen_rtx_PARALLEL (VOIDmode,\n-\t\tgen_rtvec (3, gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx),\n-\t\t\t   GEN_INT (INTVAL (operands[3]) & 0xfff),\n-\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t    gen_rtx_REG (Pmode, 15)))));\n+      (gen_rtx_PARALLEL\n+       (VOIDmode,\n+\tgen_rtvec (3, gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx),\n+\t\t   GEN_INT (INTVAL (operands[3]) & 0xfff),\n+\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))));\n   else\n     emit_call_insn\n-      (gen_rtx_PARALLEL (VOIDmode,\n-\t\tgen_rtvec (2, gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx),\n-\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t    gen_rtx_REG (Pmode, 15)))));\n+      (gen_rtx_PARALLEL\n+       (VOIDmode,\n+\tgen_rtvec (2, gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx),\n+\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))));\n \n  finish_call:\n #if 0\n@@ -7583,7 +7581,7 @@\n \n   vec = gen_rtvec (2,\n \t\t   gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx)),\n+\t\t\t\tgen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx)),\n \t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)));\n \n   emit_call_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n@@ -7935,6 +7933,7 @@\n ;  [(set_attr \"type\" \"multi\")\n ;   (set_attr \"length\" \"4\")])\n \n+\n \f\n ;; Peepholes go at the end.\n "}, {"sha": "5c4024379e863799faa45c68a43e37a6096dcf25", "filename": "gcc/config/spur/spur.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fspur%2Fspur.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fspur%2Fspur.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for SPUR.  Adapted from routines for\n    the Motorola 68000 family.\n-   Copyright (C) 1988, 1991, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -140,14 +140,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (operands[0], 4);\n   else\n     latehalf[0] = operands[0];\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n@@ -224,7 +224,7 @@ output_fp_move_double (operands)\n \t{\n \t  rtx xoperands[2];\n \t  int offset = - get_frame_size () - 8;\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n \t  xoperands[0] = GEN_INT (offset + 4);\n \t  output_asm_insn (\"st_32 %1,r25,%0\", xoperands);\n \t  xoperands[1] = operands[1];\n@@ -247,7 +247,7 @@ output_fp_move_double (operands)\n \t  output_asm_insn (\"st_dbl %1,r25,%0\", xoperands);\n \t  xoperands[1] = operands[0];\n \t  output_asm_insn (\"ld_32 %1,r25,%0\\n\\tnop\", xoperands);\n-\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n \t  xoperands[0] = GEN_INT (offset + 4);\n \t  output_asm_insn (\"ld_32 %1,r25,%0\\n\\tnop\", xoperands);\n \t  return \"\";"}, {"sha": "3c893d494669e22bee22b3595a81b825c5d1d2ff", "filename": "gcc/config/spur/spur.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fspur%2Fspur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fspur%2Fspur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for SPUR chip.\n-   Copyright (C) 1988, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1995, 1996, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -355,17 +355,17 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* On SPUR the value is found in the second \"output\" register.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 27)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 27)\n \n /* But the called function leaves it in the second \"input\" register.  */\n \n #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 11)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 11)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 27)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 27)\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.\n@@ -449,7 +449,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n        + ((MODE) == BLKmode\t\t\t\t\\\n \t  ? (int_size_in_bytes (TYPE) + 3) / 4\t\t\\\n \t  : (GET_MODE_SIZE (MODE) + 3) / 4))\t\t\\\n- ? gen_rtx (REG, (MODE), 27 + (CUM))\t\t\t\\\n+ ? gen_rtx_REG ((MODE), 27 + (CUM))\t\t\t\\\n  : 0)\n \n /* Define where a function finds its arguments.\n@@ -460,7 +460,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n        + ((MODE) == BLKmode\t\t\t\t\\\n \t  ? (int_size_in_bytes (TYPE) + 3) / 4\t\t\\\n \t  : (GET_MODE_SIZE (MODE) + 3) / 4))\t\t\\\n- ? gen_rtx (REG, (MODE), 11 + (CUM))\t\t\t\\\n+ ? gen_rtx_REG ((MODE), 11 + (CUM))\t\t\t\\\n  : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n@@ -708,17 +708,17 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n { if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n   if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n-\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN; }\n "}, {"sha": "100cc0b5a924292a0a2d72963da4ff10e386fcbb", "filename": "gcc/config/spur/spur.md", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fspur%2Fspur.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fspur%2Fspur.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for SPUR chip for GNU C compiler\n-;;   Copyright (C) 1988 Free Software Foundation, Inc.\n+;;  Copyright (C) 1988, 1998, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -288,44 +288,44 @@\n       rtx addr = force_reg (SImode, XEXP (operands[1], 0));\n       rtx subreg;\n \n-      emit_move_insn (tem, gen_rtx (MEM, SImode, addr));\n+      emit_move_insn (tem, gen_rtx_MEM (SImode, addr));\n       if (GET_CODE (operands[0]) == SUBREG)\n-\tsubreg = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[0]),\n-\t\t\t  SUBREG_WORD (operands[0]));\n+\tsubreg = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[0]),\n+\t\t\t\t SUBREG_WORD (operands[0]));\n       else\n-\tsubreg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\tsubreg = gen_rtx_SUBREG (SImode, operands[0], 0);\n \n-      emit_insn (gen_rtx (SET, VOIDmode, subreg,\n-\t\t\t  gen_rtx (ZERO_EXTRACT, SImode, tem,\n-\t\t\t\t   GEN_INT (8),\n-\t\t\t\t   addr)));\n+      emit_insn (gen_rtx_SET (VOIDmode, subreg,\n+\t\t\t      gen_rtx_ZERO_EXTRACT (SImode, tem,\n+\t\t\t\t\t\t    GEN_INT (8),\n+\t\t\t\t\t\t    addr)));\n     }\n   else if (GET_CODE (operands[0]) == MEM)\n     {\n       rtx tem = gen_reg_rtx (SImode);\n       rtx addr = force_reg (SImode, XEXP (operands[0], 0));\n       rtx subreg;\n \n-      emit_move_insn (tem, gen_rtx (MEM, SImode, addr));\n+      emit_move_insn (tem, gen_rtx_MEM (SImode, addr));\n       if (! CONSTANT_ADDRESS_P (operands[1]))\n \t{\n \t  if (GET_CODE (operands[1]) == SUBREG)\n-\t    subreg = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n-\t\t\t      SUBREG_WORD (operands[1]));\n+\t    subreg = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n+\t\t\t\t     SUBREG_WORD (operands[1]));\n \t  else\n-\t    subreg = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\t    subreg = gen_rtx_SUBREG (SImode, operands[1], 0);\n \t}\n \n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (ZERO_EXTRACT, SImode, tem,\n-\t\t\t\t   GEN_INT (8),\n-\t\t\t\t   addr),\n-\t\t\t  subreg));\n-      emit_move_insn (gen_rtx (MEM, SImode, addr), tem);\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      gen_rtx_ZERO_EXTRACT (SImode, tem,\n+\t\t\t\t\t\t    GEN_INT (8),\n+\t\t\t\t\t\t    addr),\n+\t\t\t      subreg));\n+      emit_move_insn (gen_rtx_MEM (SImode, addr), tem);\n     }\n   else\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n     }\n   DONE;\n }\")\n@@ -443,10 +443,10 @@\n   \"\n {\n   if (GET_CODE (operands[1]) == SUBREG)\n-    operands[5] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_WORD (operands[1]));\n+    operands[5] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n+\t\t\t\t  SUBREG_WORD (operands[1]));\n   else\n-    operands[5] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+    operands[5] = gen_rtx_SUBREG (SImode, operands[1], 0);\n }\")\n \n ;; Like storehi but operands[1] is a CONST_INT.\n@@ -468,7 +468,7 @@\n \t(match_dup 2))]\n   \"\"\n   \" operands[5] = GEN_INT (INTVAL (operands[1]) & 255);\n-    operands[6] = GEN_INT ((INTVAL (operands[1]) >> 8) & 255);\n+    operands[6] = GEN_INT (INTVAL (operands[1]) >> 8) & 255);\n \")\n \f\n ;; Main entry for generating insns to move halfwords.\n@@ -490,8 +490,8 @@\n \t\t\t       gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n \t\t\t       gen_reg_rtx (QImode)));\n       /* Tell cse what value the loadhi produces, so it detect duplicates.  */\n-      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, operands[1],\n-\t\t\t\t\t     REG_NOTES (insn));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\t    REG_NOTES (insn));\n     }\n   else if (GET_CODE (operands[0]) == MEM)\n     {\n@@ -511,7 +511,7 @@\n \t}\n     }\n   else\n-    emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   DONE;\n }\")\n \f\n@@ -579,7 +579,7 @@\n     return output_fp_move_double (operands);\n   if (operands[1] == CONST0_RTX (DFmode) && GET_CODE (operands[0]) == REG)\n     {\n-      operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n       return \\\"add_nt %0,r0,$0\\;add_nt %1,r0,$0\\\";\n     }\n   if (operands[1] == CONST0_RTX (DFmode) && GET_CODE (operands[0]) == MEM)\n@@ -699,10 +699,10 @@\n   \"\n {\n   if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_WORD (operands[1]));\n+    operands[1] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n+\t\t\t\t  SUBREG_WORD (operands[1]));\n   else\n-    operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+    operands[1] = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n   operands[2] = force_reg (SImode, GEN_INT (65535));\n }\")\n@@ -736,10 +736,10 @@\n   \"\n {\n   if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_WORD (operands[1]));\n+    operands[1] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n+\t\t\t\t  SUBREG_WORD (operands[1]));\n   else\n-    operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+    operands[1] = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n   operands[2] = gen_reg_rtx (SImode);\n   operands[3] = gen_reg_rtx (SImode);\n@@ -759,10 +759,10 @@\n   \"\n {\n   if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx (SUBREG, HImode, SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_WORD (operands[1]));\n+    operands[1] = gen_rtx_SUBREG (HImode, SUBREG_REG (operands[1]),\n+\t\t\t\t  SUBREG_WORD (operands[1]));\n   else\n-    operands[1] = gen_rtx (SUBREG, HImode, operands[1], 0);\n+    operands[1] = gen_rtx_SUBREG (HImode, operands[1], 0);\n \n   operands[2] = gen_reg_rtx (HImode);\n   operands[3] = gen_reg_rtx (HImode);\n@@ -779,10 +779,10 @@\n   \"\n {\n   if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n-\t\t\t   SUBREG_WORD (operands[1]));\n+    operands[1] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n+\t\t\t\t  SUBREG_WORD (operands[1]));\n   else\n-    operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+    operands[1] = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n   operands[2] = gen_reg_rtx (SImode);\n   operands[3] = gen_reg_rtx (SImode);"}, {"sha": "89cdc3d8f84d25540036ccd5e72ff65064ee0ec1", "filename": "gcc/config/tahoe/tahoe.c", "status": "modified", "additions": 299, "deletions": 303, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,10 @@\n /* Subroutines for insn-output.c for Tahoe.\n-   Copyright (C) 1989, 1991, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Contributed by the University of Buffalo (Devon Bowen, Dale Wiles\n+   and Kevin Zachmann.\n+   Changes for HCX by Piet van Oostrum, University of Utrecht,\n+   The Netherlands (piet@cs.ruu.nl)\n+   Speed tweaks by Michael Tiemann (tiemann@lurch.stanford.edu).\n \n This file is part of GNU CC.\n \n@@ -18,9 +23,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -32,21 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n \n-/*\n- * File: output-tahoe.c\n- *\n- * Original port made at the University of Buffalo by Devon Bowen,\n- * Dale Wiles and Kevin Zachmann.\n- *\n- * Changes for HCX by Piet van Oostrum,\n- * University of Utrecht, The Netherlands (piet@cs.ruu.nl)\n- *\n- * Speed tweaks by Michael Tiemann (tiemann@lurch.stanford.edu).\n- *\n- * Mail bugs reports or fixes to:\tgcc@cs.buffalo.edu\n- */\n-\n-\n /* On tahoe, you have to go to memory to convert a register\n    from sub-word to word.  */\n \n@@ -61,13 +50,15 @@ extensible_operand (op, mode)\n        || (GET_CODE (op) == SUBREG\n \t   && GET_CODE (SUBREG_REG (op)) == REG))\n       && tahoe_reg_conversion_loc == 0)\n-    tahoe_reg_conversion_loc = assign_stack_local (SImode, GET_MODE_SIZE (SImode));\n+    tahoe_reg_conversion_loc\n+      = assign_stack_local (SImode, GET_MODE_SIZE (SImode));\n+\n   return general_operand (op, mode);\n }\n \n-/* most of the print_operand_address function was taken from the vax\t*/\n-/* since the modes are basically the same. I had to add a special case,\t*/\n-/* though, for symbol references with offsets.\t\t\t\t*/\n+/* Most of the print_operand_address function was taken from the VAX since\n+   the modes are basically the same. I had to add a special case, though, for\n+   symbol references with offsets.  */\n \n print_operand_address (file, addr)\n      FILE *file;\n@@ -98,8 +89,8 @@ print_operand_address (file, addr)\n       break;\n \n     case PLUS:\n-      reg1 = 0;\treg2 = 0;\n-      ireg = 0;\tbreg = 0;\n+      reg1 = 0,\treg2 = 0;\n+      ireg = 0,\tbreg = 0;\n       offset = 0;\n \n       if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n@@ -112,38 +103,22 @@ print_operand_address (file, addr)\n \n       if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n \t  || GET_CODE (XEXP (addr, 0)) == MEM)\n-\t{\n-\t  offset = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n+\toffset = XEXP (addr, 0), addr = XEXP (addr, 1);\n       else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n \t       || GET_CODE (XEXP (addr, 1)) == MEM)\n-\t{\n-\t  offset = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n+\toffset = XEXP (addr, 1), addr = XEXP (addr, 0);\n+\n       if (GET_CODE (addr) != PLUS)\n \t;\n       else if (GET_CODE (XEXP (addr, 0)) == MULT)\n-\t{\n-\t  reg1 = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n+\treg1 = XEXP (addr, 0), addr = XEXP (addr, 1);\n       else if (GET_CODE (XEXP (addr, 1)) == MULT)\n-\t{\n-\t  reg1 = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n+\treg1 = XEXP (addr, 1), addr = XEXP (addr, 0);\n       else if (GET_CODE (XEXP (addr, 0)) == REG)\n-\t{\n-\t  reg1 = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n+\treg1 = XEXP (addr, 0), addr = XEXP (addr, 1);\n       else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t{\n-\t  reg1 = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n+\treg1 = XEXP (addr, 1), addr = XEXP (addr, 0);\n+\n       if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\n \t{\n \t  if (reg1 == 0)\n@@ -152,39 +127,34 @@ print_operand_address (file, addr)\n \t    reg2 = addr;\n \t  addr = 0;\n \t}\n+\n       if (offset != 0)\n \t{\n-\t  if (addr != 0) abort ();\n+\t  if (addr != 0)\n+\t    abort ();\n+\n \t  addr = offset;\n \t}\n+\n       if (reg1 != 0 && GET_CODE (reg1) == MULT)\n-\t{\n-\t  breg = reg2;\n-\t  ireg = reg1;\n-\t}\n+\tbreg = reg2, ireg = reg1;\n       else if (reg2 != 0 && GET_CODE (reg2) == MULT)\n-\t{\n-\t  breg = reg1;\n-\t  ireg = reg2;\n-\t}\n+\tbreg = reg1, ireg = reg2;\n       else if (reg2 != 0 || GET_CODE (addr) == MEM)\n-\t{\n-\t  breg = reg2;\n-\t  ireg = reg1;\n-\t}\n+\tbreg = reg2, ireg = reg1;\n       else\n-\t{\n-\t  breg = reg1;\n-\t  ireg = reg2;\n-\t}\n+\tbreg = reg1, ireg = reg2;\n+\n       if (addr != 0)\n \toutput_address (offset);\n+\n       if (breg != 0)\n \t{\n \t  if (GET_CODE (breg) != REG)\n \t    abort ();\n \t  fprintf (file, \"(%s)\", reg_name[REGNO (breg)]);\n \t}\n+\n       if (ireg != 0)\n \t{\n \t  if (GET_CODE (ireg) == MULT)\n@@ -200,74 +170,78 @@ print_operand_address (file, addr)\n     }\n }\n \n-/* Do a quick check and find out what the best way to do the */\n-/* mini-move is. Could be a push or a move.....\t\t     */\n+/* Do a quick check and find out what the best way to do the mini-move is.\n+   Could be a push or a move.....  */\n \n static char *\n singlemove_string (operands)\n      rtx *operands;\n {\n   if (operands[1] == const0_rtx)\n       return \"clrl %0\";\n+\n   if (push_operand (operands[0], SImode))\n     return \"pushl %1\";\n+\n   return \"movl %1,%0\";\n }\n \n-/* given the rtx for an address, return true if the given */\n-/* register number is used in the address somewhere.\t  */\n+/* Given the rtx for an address, return true if the given register number is\n+   used in the address somewhere.  */\n \n-regisused(addr,regnum)\n-rtx addr;\n-int regnum;\n+int\n+regisused (addr, regnum)\n+     rtx addr;\n+     int regnum;\n {\n-\tif (GET_CODE(addr) == REG)\n-\t\tif (REGNO(addr) == regnum)\n-\t\t\treturn (1);\n-\t\telse\n-\t\t\treturn (0);\n+  if (GET_CODE (addr) == REG)\n+    return REGNO (addr) == regnum;\n \n-\tif (GET_CODE(addr) == MEM)\n-\t\treturn regisused(XEXP(addr,0),regnum);\n+  else if (GET_CODE (addr) == MEM)\n+    return regisused (XEXP (addr, 0), regnum);\n \n-\tif ((GET_CODE(addr) == MULT) || (GET_CODE(addr) == PLUS))\n-\t\treturn ((regisused(XEXP(addr,0),regnum)) ||\n-\t\t\t\t\t(regisused(XEXP(addr,1),regnum)));\n+  else if (GET_CODE (addr) == MULT || GET_CODE (addr) == PLUS)\n+    return (regisused (XEXP (addr, 0), regnum)\n+\t    || regisused (XEXP (addr, 1), regnum));\n \n-\treturn 0;\n+  return 0;\n }\n \n \n-/* Given some rtx, traverse it and return the register used in a */\n-/* index. If no index is found, return 0.\t\t\t */\n+/* Given some rtx, traverse it and return the register used in a index. If no\n+   index is found, return 0.  */\n \n rtx\n-index_reg(addr)\n-rtx addr;\n+index_reg (addr)\n+     rtx addr;\n {\n-\trtx temp;\n+  rtx temp;\n \n-\tif (GET_CODE(addr) == MEM)\n-\t\treturn index_reg(XEXP(addr,0));\n+  if (GET_CODE (addr) == MEM)\n+    return index_reg (XEXP (addr, 0));\n \n-\tif (GET_CODE(addr) == MULT)\n-\t\tif (GET_CODE(XEXP(addr,0)) == REG)\n-\t\t\treturn XEXP(addr,0);\n-\t\telse\n-\t\t\treturn XEXP(addr,1);\n+  else if (GET_CODE (addr) == MULT)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\treturn XEXP (addr, 0);\n+      else\n+\treturn XEXP (addr, 1);\n+    }\n \n-\tif (GET_CODE(addr) == PLUS)\n-\t\tif (temp = index_reg(XEXP(addr,0)))\n-\t\t\treturn temp;\n-\t\telse\n-\t\t\treturn index_reg(XEXP(addr,1));\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      if ((temp = index_reg (XEXP (addr, 0))) != 0)\n+\treturn temp;\n+      else\n+\treturn index_reg (XEXP (addr, 1));\n+    }\n \n-\treturn 0;\n+  return 0;\n }\n \n \n-/* simulate the move double by generating two movl's. You have */\n-/* to be careful about mixing modes here.\t\t       */\n+/* Simulate the move double by generating two movl's. We need to be careful\n+   about mixing modes here.  */\n \n char *\n output_move_double (operands)\n@@ -285,21 +259,25 @@ output_move_double (operands)\n \n   if (REG_P (operands[0]))\n     optype0 = REGOP;\n-  else if ((GET_CODE(operands[0])==MEM) && (shftreg0=index_reg(operands[0])))\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && (shftreg0 = index_reg (operands[0])) != 0)\n     optype0 = INDOP;\n   else if (offsettable_memref_p (operands[0]))\n     optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC) {\n-    optype0 = PUSHOP;\n-    dohighfirst++;\n-  } else if (GET_CODE (operands[0]) == MEM)\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    {\n+      optype0 = PUSHOP;\n+      dohighfirst++;\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n     optype0 = MEMOP;\n   else\n     optype0 = RNDOP;\n \n   if (REG_P (operands[1]))\n     optype1 = REGOP;\n-  else if ((GET_CODE(operands[1])==MEM) && (shftreg1=index_reg(operands[1])))\n+  else if (GET_CODE (operands[1]) == MEM\n+\t   && (shftreg1 = index_reg (operands[1])) !+ 0)\n     optype1 = INDOP;\n   else if (offsettable_memref_p (operands[1]))\n     optype1 = OFFSOP;\n@@ -312,214 +290,233 @@ output_move_double (operands)\n   else\n     optype1 = RNDOP;\n \n-  /* set up for the high byte move for operand zero */\n+  /* Set up for the high byte move for operand zero */\n \n-  switch (optype0) {\n-\n-\t/* if it's a register, just use the next highest in the */\n-\t/* high address move.\t\t\t\t\t*/\n-\n-\tcase REGOP  : latehalf[0] = gen_rtx (REG,SImode,REGNO(operands[0])+1);\n-\t\t      break;\n-\n-\t/* for an offsettable address, use the gcc function to  */\n-\t/* modify the operand to get an offset of 4 higher for  */\n-\t/* the second move.\t\t\t\t\t*/\n-\n-\tcase OFFSOP : latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-\t\t      break;\n-\n-\t/* if the operand is MEMOP type, it must be a pointer\t*/\n-\t/* to a pointer. So just remember to increase the mem\t*/\n-\t/* location and use the same operand.\t\t\t*/\n-\n-\tcase MEMOP  : latehalf[0] = operands[0];\n-\t\t      addreg0 = XEXP(operands[0],0);\n-\t\t      break;\n+  switch (optype0)\n+    {\n+      /* If it's a register, just use the next highest in the high address\n+\t move. */\n+    case REGOP:\n+      latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+      break;\n \n-\t/* if we're dealing with a push instruction, just leave */\n-\t/* the operand alone since it auto-increments.\t\t*/\n+      /* For an offsettable address, use the GCC function to modify the\n+\t operand to get an offset of 4 higher for the second move.  */\n+    case OFFSOP:\n+      latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+      break;\n \n-\tcase PUSHOP : latehalf[0] = operands[0];\n-\t\t      break;\n+      /* If the operand is MEMOP type, it must be a pointer to a pointer.\n+\t So just remember to increase the mem location and use the same\n+\t operand.  */\n+    case MEMOP:\n+      latehalf[0] = operands[0];\n+      addreg0 = XEXP(operands[0],0);\n+      break;\n \n-\t/* YUCK! Indexed addressing!! If the address is considered   */\n-\t/* offsettable, go use the offset in the high part. Otherwise */\n-\t/* find what exactly is being added to the multiplication. If */\n-\t/* it's a mem reference, increment that with the high part   */\n-\t/* being unchanged to cause the shift. If it's a reg, do the */\n-\t/* same. If you can't identify it, abort. Remember that the  */\n-\t/* shift register was already set during identification.     */\n+      /* If we're dealing with a push instruction, just leave the operand\n+\t alone since it auto-increments. */\n+    case PUSHOP:\n+      latehalf[0] = operands[0];\n+      break;\n \n-\tcase INDOP  : if (offsettable_memref_p(operands[0])) {\n-\t\t\t   latehalf[0] = adj_offsettable_operand(operands[0],4);\n-\t\t\t   break;\n-\t\t      }\n+      /* Indexed addressing. If the address is considered offsettable, use\n+\t the offset in the high part. Otherwise find what exactly is being\n+\t added to the multiplication. If it's a mem reference, increment that\n+\t with the high part being unchanged to cause the shift. If it's a\n+\t reg, do the same. If we can't identify it, abort. Remember that the\n+\t shift register was already set during identification.  */\n \n-\t\t      latehalf[0] = operands[0];\n+    case INDOP:\n+      if (offsettable_memref_p (operands[0]))\n+\t{\n+\t  latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+\t  break;\n+\t}\n \n-\t\t      temp0 = XEXP(XEXP(operands[0],0),0);\n-                      if (GET_CODE(temp0) == MULT) {\n-\t\t\t   temp1 = temp0;\n-\t\t\t   temp0 = XEXP(XEXP(operands[0],0),1);\n-\t\t      } else {\n-\t\t\t   temp1 = XEXP(XEXP(operands[0],0),1);\n-\t\t\t   if (GET_CODE(temp1) != MULT)\n-\t\t\t\tabort();\n-\t\t      }\n+      latehalf[0] = operands[0];\n \n-\t\t      if (GET_CODE(temp0) == MEM)\n-\t\t\t   addreg0 = temp0;\n-\t\t      else if (GET_CODE(temp0) == REG)\n-\t\t\t   addreg0 = temp0;\n-\t\t      else\n-\t\t\t   abort();\n+      temp0 = XEXP (XEXP (operands[0], 0), 0);\n+      if (GET_CODE(temp0) == MULT)\n+\t{\n+\t  temp1 = temp0;\n+\t  temp0 = XEXP (XEXP (operands[0], 0), 1);\n+\t}\n+      else\n+\t{\n+\t  temp1 = XEXP (XEXP (operands[0], 0), 1);\n+\t  if (GET_CODE (temp1) != MULT)\n+\t    abort();\n+\t}\n \n-\t\t      break;\n+      if (GET_CODE (temp0) == MEM)\n+\taddreg0 = temp0;\n+      else if (GET_CODE (temp0) == REG)\n+\taddreg0 = temp0;\n+      else\n+\tabort();\n \n-\t/* if we don't know the operand type, print a friendly  */\n-\t/* little error message...   8-)\t\t\t*/\n+      break;\n \n-\tcase RNDOP  :\n-\tdefault     : abort();\n+    case RNDOP:\n+    default:\n+      abort();\n   }\n \n-  /* do the same setup for operand one */\n+  /* Do the same setup for operand one.  */\n \n-  switch (optype1) {\n+  switch (optype1)\n+    {\n+    case REGOP:\n+      latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n+      break;\n \n-\tcase REGOP  : latehalf[1] = gen_rtx(REG,SImode,REGNO(operands[1])+1);\n-\t\t      break;\n+    case OFFSOP:\n+      latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+      break;\n \n-\tcase OFFSOP : latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-\t\t      break;\n+    case MEMOP:\n+      latehalf[1] = operands[1];\n+      addreg1 = XEXP (operands[1], 0);\n+      break;\n \n-\tcase MEMOP  : latehalf[1] = operands[1];\n-\t\t      addreg1 = XEXP(operands[1],0);\n-\t\t      break;\n+    case POPOP:\n+      latehalf[1] = operands[1];\n+      break;\n \n-\tcase POPOP  : latehalf[1] = operands[1];\n-\t\t      break;\n+    case INDOP:\n+      if (offsettable_memref_p (operands[1]))\n+\t{\n+\t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+\t  break;\n+\t}\n \n-\tcase INDOP  : if (offsettable_memref_p(operands[1])) {\n-\t\t\t   latehalf[1] = adj_offsettable_operand(operands[1],4);\n-\t\t\t   break;\n-\t\t      }\n+      latehalf[1] = operands[1];\n \n-\t\t      latehalf[1] = operands[1];\n+      temp0 = XEXP (XEXP (operands[1], 0), 0);\n+      if (GET_CODE (temp0) == MULT)\n+\t{\n+\t  temp1 = temp0;\n+\t  temp0 = XEXP (XEXP (operands[1], 0), 1);\n+\t}\n+      else\n+\t{\n+\t  temp1 = XEXP (XEXP (operands[1], 0), 1);\n+\t  if (GET_CODE (temp1) != MULT)\n+\t    abort();\n+\t}\n \n-\t\t      temp0 = XEXP(XEXP(operands[1],0),0);\n-                      if (GET_CODE(temp0) == MULT) {\n-\t\t\t   temp1 = temp0;\n-\t\t\t   temp0 = XEXP(XEXP(operands[1],0),1);\n-\t\t      } else {\n-\t\t\t   temp1 = XEXP(XEXP(operands[1],0),1);\n-\t\t\t   if (GET_CODE(temp1) != MULT)\n-\t\t\t\tabort();\n-\t\t      }\n+      if (GET_CODE (temp0) == MEM)\n+\taddreg1 = temp0;\n+      else if (GET_CODE (temp0) == REG)\n+\taddreg1 = temp0;\n+      else\n+\tabort();\n+      break;\n \n-\t\t      if (GET_CODE(temp0) == MEM)\n-\t\t\t   addreg1 = temp0;\n-\t\t      else if (GET_CODE(temp0) == REG)\n-\t\t\t   addreg1 = temp0;\n-\t\t      else\n-\t\t\t   abort();\n+    case CNSTOP:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else if (CONSTANT_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+      else\n+\tabort ();\n+      break;\n \n-\t\t      break;\n+    case RNDOP:\n+    default:\n+      abort ();\n+  }\n \n-\tcase CNSTOP :\n-\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t    split_double (operands[1], &operands[1], &latehalf[1]);\n-\t  else if (CONSTANT_P (operands[1]))\n-\t    latehalf[1] = const0_rtx;\n-\t  else abort ();\n-\t  break;\n \n-\tcase RNDOP  :\n-\tdefault     : abort();\n-  }\n+  /* Double the register used for shifting in both of the operands but make\n+     sure the same register isn't doubled twice!  */\n \n+  if (shftreg0 != 0 && shftreg1 != 0 && rtx_equal_p (shftreg0, shftreg1))\n+    output_asm_insn (\"addl2 %0,%0\", &shftreg0);\n+  else\n+    {\n+      if (shftreg0 != 0)\n+\toutput_asm_insn (\"addl2 %0,%0\", &shftreg0);\n+      if (shftreg1!= 0)\n+\toutput_asm_insn (\"addl2 %0,%0\", &shftreg1);\n+    }\n \n-  /* double the register used for shifting in both of the operands */\n-  /* but make sure the same register isn't doubled twice!\t   */\n+  /* If the destination is a register and that register is needed in the\n+     source addressing mode, swap the order of the moves since we don't want\n+     this destroyed til last. If both regs are used, not much we can do, so\n+     abort. If these becomes a problem, maybe we can do it on the stack?  */\n \n-  if (shftreg0 && shftreg1 && (rtx_equal_p(shftreg0,shftreg1)))\n-\toutput_asm_insn(\"addl2 %0,%0\", &shftreg0);\n-  else {\n-\tif (shftreg0)\n-\t\toutput_asm_insn(\"addl2 %0,%0\", &shftreg0);\n-\tif (shftreg1)\n-\t\toutput_asm_insn(\"addl2 %0,%0\", &shftreg1);\n-  }\n+  if (GET_CODE (operands[0]) == REG\n+      && regisused (operands[1], REGNO (operands[0])))\n+    {\n+      if (regisused (latehalf[1], REGNO(latehalf[0])))\n+\t;\n+      else\n+\tdohighfirst++;\n+    }\n+\n+  /* If we're pushing, do the high address part first. */\n \n-  /* if the destination is a register and that register is needed in  */\n-  /* the source addressing mode, swap the order of the moves since we */\n-  /* don't want this destroyed til last. If both regs are used, not   */\n-  /* much we can do, so abort. If these becomes a problem, maybe we   */\n-  /* can do it on the stack?\t\t\t\t\t      */\n-\n-  if (GET_CODE(operands[0])==REG && regisused(operands[1],REGNO(operands[0])))\n-\tif (regisused(latehalf[1],REGNO(latehalf[0])))\n-\t\t8;\n-\telse\n-\t\tdohighfirst++;\n-\n-  /* if we're pushing, do the high address part first. */\n-\n-  if (dohighfirst) {\n-\n-\tif (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n-\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n-\telse {\n-\t\tif (addreg0)\n-\t\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n-\t\tif (addreg1)\n-\t\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg1);\n+  if (dohighfirst)\n+    {\n+      if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p (addreg0, addreg1))\n+\toutput_asm_insn (\"addl2 $4,%0\", &addreg0);\n+      else\n+\t{\n+\t  if (addreg0 != 0)\n+\t    output_asm_insn (\"addl2 $4,%0\", &addreg0);\n+\t  if (addreg1 != 0)\n+\t    output_asm_insn (\"addl2 $4,%0\", &addreg1);\n \t}\n \n-\toutput_asm_insn(singlemove_string(latehalf), latehalf);\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n \n-\tif (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n-\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n-\telse {\n-\t\tif (addreg0)\n-\t\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n-\t\tif (addreg1)\n-\t\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg1);\n+      if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p (addreg0, addreg1))\n+\toutput_asm_insn (\"subl2 $4,%0\", &addreg0);\n+      else\n+\t{\n+\t  if (addreg0 != 0)\n+\t    output_asm_insn (\"subl2 $4,%0\", &addreg0);\n+\t  if (addreg1 != 0)\n+\t    output_asm_insn (\"subl2 $4,%0\", &addreg1);\n \t}\n \n-\treturn singlemove_string(operands);\n-  }\n+      return singlemove_string (operands);\n+    }\n \n-  output_asm_insn(singlemove_string(operands), operands);\n+  output_asm_insn (singlemove_string(operands), operands);\n \n-  if (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n-\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n-  else {\n-\tif (addreg0)\n-\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg0);\n-\tif (addreg1)\n-\t\toutput_asm_insn(\"addl2 $4,%0\", &addreg1);\n-  }\n+  if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p (addreg0, addreg1))\n+    output_asm_insn (\"addl2 $4,%0\", &addreg0);\n+  else\n+    {\n+      if (addreg0 != 0)\n+\toutput_asm_insn (\"addl2 $4,%0\", &addreg0);\n+      if (addreg1 != 0)\n+\toutput_asm_insn (\"addl2 $4,%0\", &addreg1);\n+    }\n \n-  output_asm_insn(singlemove_string(latehalf), latehalf);\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n \n-  if (addreg0 && addreg1 && (rtx_equal_p(addreg0,addreg1)))\n-\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n-  else {\n-\tif (addreg0)\n-\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg0);\n-\tif (addreg1)\n-\t\toutput_asm_insn(\"subl2 $4,%0\", &addreg1);\n-  }\n+  if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p(addreg0, addreg1))\n+    output_asm_insn (\"subl2 $4,%0\", &addreg0);\n+  else\n+    {\n+      if (addreg0 != 0)\n+\toutput_asm_insn (\"subl2 $4,%0\", &addreg0);\n+      if (addreg1 != 0)\n+\toutput_asm_insn (\"subl2 $4,%0\", &addreg1);\n+    }\n \n-  if (shftreg0 && shftreg1 && (rtx_equal_p(shftreg0,shftreg1)))\n-\toutput_asm_insn(\"shar $1,%0,%0\", &shftreg0);\n-  else {\n-\tif (shftreg0)\n-\t\toutput_asm_insn(\"shar $1,%0,%0\", &shftreg0);\n-\tif (shftreg1)\n-\t\toutput_asm_insn(\"shar $1,%0,%0\", &shftreg1);\n+  if (shftreg0 != 0 && shftreg1 != 0 && rtx_equal_p (shftreg0, shftreg1))\n+    output_asm_insn (\"shar $1,%0,%0\", &shftreg0);\n+  else\n+    {\n+      if (shftreg0 != 0)\n+\toutput_asm_insn (\"shar $1,%0,%0\", &shftreg0);\n+      if (shftreg1 != 0)\n+\toutput_asm_insn (\"shar $1,%0,%0\", &shftreg1);\n   }\n \n   return \"\";\n@@ -533,33 +530,32 @@ output_move_double (operands)\n \n int\n tahoe_cmp_check (insn, op, max)\n-rtx insn, op; int max;\n+     rtx insn, op;\n+     int max;\n {\n+  register rtx next = NEXT_INSN (insn);\n+\n     if (GET_CODE (op) == CONST_INT\n-\t&& ( INTVAL (op) < 0 || INTVAL (op) > max ))\n-\treturn 0;\n+\t&& (INTVAL (op) < 0 || INTVAL (op) > max))\n+      return 0;\n+\n+  if (GET_RTX_CLASS (GET_CODE (next)) == 'i')\n     {\n-\tregister rtx next = NEXT_INSN (insn);\n-\n-\tif ((GET_CODE (next) == JUMP_INSN\n-\t   || GET_CODE (next) == INSN\n-\t   || GET_CODE (next) == CALL_INSN))\n-\t    {\n-\t\tnext = PATTERN (next);\n-\t\tif (GET_CODE (next) == SET\n-\t\t    && SET_DEST (next) == pc_rtx\n-\t\t    && GET_CODE (SET_SRC (next)) == IF_THEN_ELSE)\n-\t\t    switch (GET_CODE (XEXP (SET_SRC (next), 0)))\n-\t\t\t{\n-\t\t\tcase EQ:\n-\t\t\tcase NE:\n-\t\t\tcase LTU:\n-\t\t\tcase GTU:\n-\t\t\tcase LEU:\n-\t\t\tcase GEU:\n-\t\t\t    return 1;\n-\t\t\t}\n-\t    }\n+      next = PATTERN (next);\n+      if (GET_CODE (next) == SET\n+\t  && SET_DEST (next) == pc_rtx\n+\t  && GET_CODE (SET_SRC (next)) == IF_THEN_ELSE)\n+\tswitch (GET_CODE (XEXP (SET_SRC (next), 0)))\n+\t  {\n+\t  case EQ:\n+\t  case NE:\n+\t  case LTU:\n+\t  case GTU:\n+\t  case LEU:\n+\t  case GEU:\n+\t    return 1;\n+\t  }\n     }\n-    return 0;\n+  \n+  return 0;\n }"}, {"sha": "b18e8ab59f0605425baed5331838a2eaf16e73ca", "filename": "gcc/config/tahoe/tahoe.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Tahoe version.\n-   Copyright (C) 1989, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 94, 95, 96, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -331,11 +331,11 @@ enum reg_class {NO_REGS,GENERAL_REGS,FPP_REG,ALL_REGS,LIM_REG_CLASSES};\n /* function values for all types are returned in register 0 */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* library routines also return things in reg 0 */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n /* Tahoe doesn't return structures in a reentrant way */\n "}, {"sha": "8ed06497dea52a62b0f2356a8ee3e5db3bd36673", "filename": "gcc/config/tahoe/tahoe.md", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ftahoe%2Ftahoe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Ftahoe%2Ftahoe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description for GNU compiler, Tahoe version\n-;; Copyright (C) 1989, 1994, 1996, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1989, 1994, 96-98, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1591,7 +1591,7 @@\n   \"\"\n   \"*\n {\n-  operands[1] = GEN_INT ((INTVAL (operands[1]) + 4));\n+  operands[1] = GEN_INT (INTVAL (operands[1]) + 4);\n   if (GET_CODE(operands[0]) == MEM\n       && CONSTANT_ADDRESS_P (XEXP(operands[0], 0))\n       && INTVAL (operands[1]) < 64)\n@@ -1609,7 +1609,7 @@\n   \"\"\n   \"*\n {\n-  operands[2] = GEN_INT ((INTVAL (operands[2]) + 4));\n+  operands[2] = GEN_INT (INTVAL (operands[2]) + 4));\n   if (GET_CODE(operands[1]) == MEM\n       && CONSTANT_ADDRESS_P (XEXP(operands[1], 0))\n       && INTVAL (operands[2]) < 64)\n@@ -2056,8 +2056,7 @@\n ;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n ;  \"*\n ;{\n-;  operands[1]\n-;    = GEN_INT (exact_log2 (INTVAL (operands[1])));\n+;  operands[1] = GEN_INT (exact_log2 (INTVAL (operands[1])));\n ;  return \\\"bbs %1,%0,%l2\\\";\n ;}\")\n ;\n@@ -2073,8 +2072,7 @@\n ;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n ;  \"*\n ;{\n-;  operands[1]\n-;    = GEN_INT (exact_log2 (INTVAL (operands[1])));\n+;  operands[1] = GEN_INT (exact_log2 (INTVAL (operands[1])));\n ;  return \\\"bbc %1,%0,%l2\\\";\n ;}\")\n ;\n@@ -2090,8 +2088,7 @@\n ;   && exact_log2 (INTVAL (operands[1])) >= 0\"\n ;  \"*\n ;{\n-;  operands[1]\n-;    = GEN_INT (exact_log2 (INTVAL (operands[1])));\n+;  operands[1] = GEN_INT (exact_log2 (INTVAL (operands[1])));\n ;  return \\\"bbc %1,%0,%l2\\\";\n ;}\")\n ;"}, {"sha": "a085b518d636123da4d35c6651f08ffc8416394c", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 69, "deletions": 68, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -20,8 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n-#include <ctype.h>\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -200,16 +199,16 @@ function_arg (cum, mode, type, named)\n   switch (cum->nbytes / UNITS_PER_WORD)\n     {\n     case 0:\n-      result = gen_rtx (REG, mode, 6);\n+      result = gen_rtx_REG (mode, 6);\n       break;\n     case 1:\n-      result = gen_rtx (REG, mode, 7);\n+      result = gen_rtx_REG (mode, 7);\n       break;\n     case 2:\n-      result = gen_rtx (REG, mode, 8);\n+      result = gen_rtx_REG (mode, 8);\n       break;\n     case 3:\n-      result = gen_rtx (REG, mode, 9);\n+      result = gen_rtx_REG (mode, 9);\n       break;\n     default:\n       result = 0;\n@@ -563,9 +562,8 @@ print_operand (file, x, code)\n \t{\n \tcase MEM:\n \t  if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n-\t    output_address (gen_rtx (PLUS, SImode,\n-\t\t\t\t     gen_rtx (REG, SImode, 0),\n-\t\t\t\t     XEXP (x, 0)));\n+\t    output_address (gen_rtx_PLUS (SImode, gen_rtx (REG, SImode, 0),\n+\t\t\t\t\t  XEXP (x, 0)));\n \t  else\n \t    output_address (XEXP (x, 0));\n \t  break;\n@@ -792,7 +790,7 @@ output_move_single (operands)\n \treturn \"%S0st%W0 %.,%0\";\n     }\n \n-  fatal_insn (\"output_move_single:\", gen_rtx (SET, VOIDmode, dst, src));\n+  fatal_insn (\"output_move_single:\", gen_rtx_SET (VOIDmode, dst, src));\n   return \"\";\n }\n \n@@ -839,7 +837,7 @@ output_move_double (operands)\n \n       for (i = 0; i < 2; i++)\n \t{\n-\t  xop[0] = gen_rtx (REG, SImode, REGNO (dst)+i);\n+\t  xop[0] = gen_rtx_REG (SImode, REGNO (dst)+i);\n \t  xop[1] = GEN_INT (high_low[i]);\n \t  output_asm_insn (output_move_single (xop), xop);\n \t}\n@@ -1093,14 +1091,14 @@ substitute_ep_register (first_insn, last_insn, uses, regno, p_r1, p_ep)\n      rtx *p_r1;\n      rtx *p_ep;\n {\n-  rtx reg = gen_rtx (REG, Pmode, regno);\n+  rtx reg = gen_rtx_REG (Pmode, regno);\n   rtx insn;\n \n   if (!*p_r1)\n     {\n       regs_ever_live[1] = 1;\n-      *p_r1 = gen_rtx (REG, Pmode, 1);\n-      *p_ep = gen_rtx (REG, Pmode, 30);\n+      *p_r1 = gen_rtx_REG (Pmode, 1);\n+      *p_ep = gen_rtx_REG (Pmode, 30);\n     }\n \n   if (TARGET_DEBUG)\n@@ -1156,8 +1154,9 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n \t\t\t\t\t\t   unsignedp))\n \t\t\t   && ((INTVAL (XEXP (addr, 1))) >= 0))\n \t\t    *p_mem = change_address (*p_mem, VOIDmode,\n-\t\t\t\t\t     gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t\t      *p_ep, XEXP (addr, 1)));\n+\t\t\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t   *p_ep,\n+\t\t\t\t\t\t\t   XEXP (addr, 1)));\n \t\t}\n \t    }\n \t}\n@@ -1171,10 +1170,10 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n       && SET_SRC (PATTERN (insn)) == *p_r1)\n     delete_insn (insn);\n   else\n-    emit_insn_before (gen_rtx (SET, Pmode, *p_r1, *p_ep), first_insn);\n+    emit_insn_before (gen_rtx_SET (Pmode, *p_r1, *p_ep), first_insn);\n \n-  emit_insn_before (gen_rtx (SET, Pmode, *p_ep, reg), first_insn);\n-  emit_insn_before (gen_rtx (SET, Pmode, *p_ep, *p_r1), last_insn);\n+  emit_insn_before (gen_rtx_SET (Pmode, *p_ep, reg), first_insn);\n+  emit_insn_before (gen_rtx_SET (Pmode, *p_ep, *p_r1), last_insn);\n }\n \n \f\n@@ -1558,10 +1557,10 @@ expand_prologue ()\n \t  offset = 0;\n \t  for (i = 6; i < 10; i++)\n \t    {\n-\t      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)),\n-\t\t\t      gen_rtx (REG, SImode, i));\n+\t      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t  offset)),\n+\t\t\t      gen_rtx_REG (SImode, i));\n \t      offset += 4;\n \t    }\n \t}\n@@ -1573,14 +1572,14 @@ expand_prologue ()\n   for (i = 1; i < 31; i++)\n     {\n       if (((1L << i) & reg_saved) != 0)\n-\tsave_regs[num_save++] = gen_rtx (REG, Pmode, i);\n+\tsave_regs[num_save++] = gen_rtx_REG (Pmode, i);\n     }\n \n   /* If the return pointer is saved, the helper functions also allocate\n      16 bytes of stack for arguments to be saved in.  */\n   if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n     {\n-      save_regs[num_save++] = gen_rtx (REG, Pmode, LINK_POINTER_REGNUM);\n+      save_regs[num_save++] = gen_rtx_REG (Pmode, LINK_POINTER_REGNUM);\n       default_stack = 16;\n     }\n \n@@ -1610,28 +1609,30 @@ expand_prologue ()\n \t stack space is allocated.  */\n       if (save_func_len < save_normal_len)\n \t{\n-\t  save_all = gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t      rtvec_alloc (num_save + (TARGET_V850 ? 2 : 1)));\n-\t  XVECEXP (save_all, 0, 0) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t\t\t       GEN_INT (-alloc_stack)));\n+\t  save_all = gen_rtx_PARALLEL\n+\t    (VOIDmode,\n+\t     rtvec_alloc (num_save + (TARGET_V850 ? 2 : 1)));\n+\n+\t  XVECEXP (save_all, 0, 0)\n+\t    = gen_rtx_SET (VOIDmode,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   plus_constant (stack_pointer_rtx, -alloc_stack));\n \n \t  if (TARGET_V850)\n \t    {\n-\t      XVECEXP (save_all, 0, num_save + 1)\n-\t\t= gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 10));\n+\t      XVECEXP (save_all, 0, num_save+1)\n+\t\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 10));\n \t    }\n \n \t  offset = - default_stack;\n \t  for (i = 0; i < num_save; i++)\n \t    {\n-\t      XVECEXP (save_all, 0, i + 1)\n-\t\t= gen_rtx (SET, VOIDmode,\n-\t\t\t   gen_rtx (MEM, Pmode,\n-\t\t\t\t    plus_constant (stack_pointer_rtx, offset)),\n-\t\t\t\t    save_regs[i]);\n+\t      XVECEXP (save_all, 0, i+1)\n+\t\t= gen_rtx_SET (VOIDmode,\n+\t\t\t       gen_rtx_MEM (Pmode,\n+\t\t\t\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t   offset)),\n+\t\t\t       save_regs[i]);\n \t      offset -= 4;\n \t    }\n \n@@ -1684,18 +1685,18 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n \t  /* Save the return pointer first.  */\n \t  if (num_save > 0 && REGNO (save_regs[num_save-1]) == LINK_POINTER_REGNUM)\n \t    {\n-\t      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)),\n+\t      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t  offset)),\n \t\t\t      save_regs[--num_save]);\n \t      offset -= 4;\n \t    }\n \t  \n \t  for (i = 0; i < num_save; i++)\n \t    {\n-\t      emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)),\n+\t      emit_move_insn (gen_rtx_MEM (SImode,\n+\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t  offset)),\n \t\t\t      save_regs[i]);\n \t      offset -= 4;\n \t    }\n@@ -1714,7 +1715,7 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n \t\t\t       GEN_INT (-diff)));\n       else\n \t{\n-\t  rtx reg = gen_rtx (REG, Pmode, 12);\n+\t  rtx reg = gen_rtx_REG (Pmode, 12);\n \t  emit_move_insn (reg, GEN_INT (-diff));\n \t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n \t}\n@@ -1760,14 +1761,14 @@ expand_epilogue ()\n   for (i = 1; i < 31; i++)\n     {\n       if (((1L << i) & reg_saved) != 0)\n-\trestore_regs[num_restore++] = gen_rtx (REG, Pmode, i);\n+\trestore_regs[num_restore++] = gen_rtx_REG (Pmode, i);\n     }\n \n   /* If the return pointer is saved, the helper functions also allocate\n      16 bytes of stack for arguments to be saved in.  */\n   if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n     {\n-      restore_regs[num_restore++] = gen_rtx (REG, Pmode, LINK_POINTER_REGNUM);\n+      restore_regs[num_restore++] = gen_rtx_REG (Pmode, LINK_POINTER_REGNUM);\n       default_stack = 16;\n     }\n \n@@ -1797,24 +1798,24 @@ expand_epilogue ()\n       /* Don't bother checking if we don't actually save any space.  */\n       if (restore_func_len < restore_normal_len)\n \t{\n-\t  restore_all = gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t\t rtvec_alloc (num_restore + 2));\n-\t  XVECEXP (restore_all, 0, 0) = gen_rtx (RETURN, VOIDmode);\n+\t  restore_all = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t  rtvec_alloc (num_restore + 2));\n+\t  XVECEXP (restore_all, 0, 0) = gen_rtx_RETURN (VOIDmode);\n \t  XVECEXP (restore_all, 0, 1)\n-\t    = gen_rtx (SET, VOIDmode, stack_pointer_rtx,\n-\t\t       gen_rtx (PLUS, Pmode,\n-\t\t\t\tstack_pointer_rtx,\n-\t\t\t\tGEN_INT (alloc_stack)));\n+\t    = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t  GEN_INT (alloc_stack)));\n \n \t  offset = alloc_stack - 4;\n \t  for (i = 0; i < num_restore; i++)\n \t    {\n \t      XVECEXP (restore_all, 0, i+2)\n-\t\t= gen_rtx (SET, VOIDmode,\n-\t\t\t   restore_regs[i],\n-\t\t\t   gen_rtx (MEM, Pmode,\n-\t\t\t\t    plus_constant\n-\t\t\t\t    (stack_pointer_rtx, offset)));\n+\t\t= gen_rtx_SET (VOIDmode,\n+\t\t\t       restore_regs[i],\n+\t\t\t       gen_rtx_MEM (Pmode,\n+\t\t\t\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t   offset)));\n \t      offset -= 4;\n \t    }\n \n@@ -1832,7 +1833,7 @@ expand_epilogue ()\n \t\t\t\t\t   GEN_INT (actual_fsize)));\n \t\t  else\n \t\t    {\n-\t\t      rtx reg = gen_rtx (REG, Pmode, 12);\n+\t\t      rtx reg = gen_rtx_REG (Pmode, 12);\n \t\t      emit_move_insn (reg, GEN_INT (actual_fsize));\n \t\t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t\t     stack_pointer_rtx,\n@@ -1880,7 +1881,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t\t\t\t   GEN_INT (diff)));\n \t  else\n \t    {\n-\t      rtx reg = gen_rtx (REG, Pmode, 12);\n+\t      rtx reg = gen_rtx_REG (Pmode, 12);\n \t      emit_move_insn (reg, GEN_INT (diff));\n \t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t     stack_pointer_rtx,\n@@ -1904,18 +1905,18 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t      && REGNO (restore_regs [num_restore - 1]) == LINK_POINTER_REGNUM)\n \t    {\n \t      emit_move_insn (restore_regs[--num_restore],\n-\t\t\t      gen_rtx (MEM, SImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)));\n+\t\t\t      gen_rtx_MEM (SImode,\n+\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t  offset)));\n \t      offset -= 4;\n \t    }\n \n \t  for (i = 0; i < num_restore; i++)\n \t    {\n \t      emit_move_insn (restore_regs[i],\n-\t\t\t      gen_rtx (MEM, SImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)));\n+\t\t\t      gen_rtx_MEM (SImode,\n+\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t  offset)));\n \n \t      offset -= 4;\n \t    }"}, {"sha": "22289c393674fd6158d2061a928c81ced1e4c814", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -755,13 +755,13 @@ extern int current_function_anonymous_args;\n    otherwise, FUNC is 0.   */\n    \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 10)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 10)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE) \\\n-  gen_rtx (REG, MODE, 10)\n+  gen_rtx_REG (MODE, 10)\n \n /* 1 if N is a possible register number for a function value.  */\n \n@@ -811,9 +811,9 @@ extern int current_function_anonymous_args;\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 16)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 16)),\t\\\n  \t\t (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 20)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 20)),\t\\\n \t\t (FNADDR));\t\t\t\t\t\t\\\n }\n "}, {"sha": "5214d1663c535d21941cfae80cade6470a321766", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,7 +1,6 @@\n ;; GCC machine description for NEC V850\n-;; Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.\n-\n-;;   Contributed by Jeff Law (law@cygnus.com).\n+;; Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+;; Contributed by Jeff Law (law@cygnus.com).\n \n ;; This file is part of GNU CC.\n \n@@ -168,10 +167,10 @@\n       else\n \ttemp = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_rtx (SET, SImode, temp,\n-                          gen_rtx (HIGH, SImode, operand1)));\n-      emit_insn (gen_rtx (SET, SImode, operand0,\n-                          gen_rtx (LO_SUM, SImode, temp, operand1)));\n+      emit_insn (gen_rtx_SET (SImode, temp,\n+\t\t\t      gen_rtx_HIGH (SImode, operand1)));\n+      emit_insn (gen_rtx_SET (SImode, operand0,\n+\t\t\t      gen_rtx_LO_SUM (SImode, temp, operand1)));\n       DONE;\n     }\n }\")\n@@ -412,8 +411,8 @@\n   int log2 = exact_log2 (~INTVAL (operands[1]) & 0xffff);\n \n   rtx xoperands[2];\n-  xoperands[0] = gen_rtx (MEM, QImode,\n-\t\t\t  plus_constant (XEXP (operands[0], 0), log2 / 8));\n+  xoperands[0] = gen_rtx_MEM (QImode,\n+\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n   xoperands[1] = GEN_INT (log2 % 8);\n   output_asm_insn (\\\"clr1 %1,%0\\\", xoperands);\n   return \\\"\\\";\n@@ -431,8 +430,8 @@\n   int log2 = exact_log2 (~INTVAL (operands[1]) & 0xffffffff);\n \n   rtx xoperands[2];\n-  xoperands[0] = gen_rtx (MEM, QImode,\n-\t\t\t  plus_constant (XEXP (operands[0], 0), log2 / 8));\n+  xoperands[0] = gen_rtx_MEM (QImode,\n+\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n   xoperands[1] = GEN_INT (log2 % 8);\n   output_asm_insn (\\\"clr1 %1,%0\\\", xoperands);\n   return \\\"\\\";\n@@ -479,8 +478,9 @@\n   else\n     {\n       rtx xoperands[2];\n-      xoperands[0] = gen_rtx (MEM, QImode,\n-\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[0] = gen_rtx_MEM (QImode,\n+\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\\\"set1 %1,%0\\\", xoperands);\n     }\n@@ -503,8 +503,9 @@\n   else\n     {\n       rtx xoperands[2];\n-      xoperands[0] = gen_rtx (MEM, QImode,\n-\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[0] = gen_rtx_MEM (QImode,\n+\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\\\"set1 %1,%0\\\", xoperands);\n     }\n@@ -552,8 +553,9 @@\n   else\n     {\n       rtx xoperands[2];\n-      xoperands[0] = gen_rtx (MEM, QImode,\n-\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[0] = gen_rtx_MEM (QImode,\n+\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\\\"not1 %1,%0\\\", xoperands);\n     }\n@@ -576,8 +578,9 @@\n   else\n     {\n       rtx xoperands[2];\n-      xoperands[0] = gen_rtx (MEM, QImode,\n-\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+      xoperands[0] = gen_rtx_MEM (QImode,\n+\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\\\"not1 %1,%0\\\", xoperands);\n     }\n@@ -942,11 +945,11 @@\n   emit_insn (gen_ashlsi3 (reg, reg, GEN_INT (TARGET_BIG_SWITCH ? 2 : 1)));\n   /* Load the table address into a pseudo.  */\n   emit_insn (gen_movsi (tableaddress,\n-\t\t\tgen_rtx (LABEL_REF, VOIDmode, operands[3])));\n+\t\t\tgen_rtx_LABEL_REF (VOIDmode, operands[3])));\n   /* Add the table address to the index.  */\n   emit_insn (gen_addsi3 (reg, reg, tableaddress));\n   /* Load the table entry.  */\n-  mem = gen_rtx (MEM, CASE_VECTOR_MODE, reg);\n+  mem = gen_rtx_MEM (CASE_VECTOR_MODE, reg);\n   RTX_UNCHANGING_P (mem);\n   if (! TARGET_BIG_SWITCH)\n     {"}, {"sha": "7e2da6749a3a5d55d070a3a900be3430a86c0815", "filename": "gcc/config/v850/xm-v850.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fxm-v850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fv850%2Fxm-v850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fxm-v850.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for NEC V850. \n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Cygnus Support.\n \n This file is part of GNU CC.\n@@ -34,15 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #define SUCCESS_EXIT_CODE 0\n #define FATAL_EXIT_CODE 33\n \n-#ifdef __v850\n-#ifndef __STDC__\n-extern char *malloc (), *realloc (), *calloc ();\n-#else\n-extern void *malloc (), *realloc (), *calloc ();\n-#endif\n-extern void free ();\n-#endif\n-\n /* target machine dependencies.\n    tm.h is a symbolic link to the actual target specific file.   */\n "}, {"sha": "9eab182b80eca4330ae7ce1be7a9715aff75e145", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Vax.\n-   Copyright (C) 1987, 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 94, 95, 97, 98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -53,11 +53,11 @@ split_quadword_operands (operands, low, n)\n \t       && (GET_CODE (XEXP (operands[i], 0)) == POST_INC))\n \t{\n \t  rtx addr = XEXP (operands[i], 0);\n-\t  operands[i] = low[i] = gen_rtx (MEM, SImode, addr);\n+\t  operands[i] = low[i] = gen_rtx_MEM (SImode, addr);\n \t  if (which_alternative == 0 && i == 0)\n \t    {\n \t      addr = XEXP (operands[i], 0);\n-\t      operands[i+1] = low[i+1] = gen_rtx (MEM, SImode, addr);\n+\t      operands[i+1] = low[i+1] = gen_rtx_MEM (SImode, addr);\n \t    }\n \t}\n       else"}, {"sha": "35f3fbdc0e733ec034e2eb33c8753e9899e2c070", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Vax version.\n-   Copyright (C) 1987, 88, 91, 93-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 93-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -347,8 +347,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Given an rtx for the address of a frame,\n    return an rtx for the address of the word in the frame\n    that holds the dynamic chain--the previous frame's address.  */\n-#define DYNAMIC_CHAIN_ADDRESS(frame) \\\n-gen_rtx (PLUS, Pmode, frame, GEN_INT (12))\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant ((FRAME), 12)\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -377,14 +376,14 @@ gen_rtx (PLUS, Pmode, frame, GEN_INT (12))\n /* On the Vax the return value is in R0 regardless.  */   \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n /* On the Vax the return value is in R0 regardless.  */   \n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n /* Define this if PCC uses the nonreentrant convention for returning\n    structure and union values.  */\n@@ -530,14 +529,14 @@ gen_rtx (PLUS, Pmode, frame, GEN_INT (12))\n      movl $STATIC,r0   (store the functions static chain)\n      jmp  *$FUNCTION   (jump to function code at address FUNCTION)  */\n \n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x8fd0));\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_BYTE  (FILE, 0x50+STATIC_CHAIN_REGNUM);\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x9f17));\t\\\n-  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x8fd0));\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_BYTE  (FILE, 0x50 + STATIC_CHAIN_REGNUM);\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x9f17));\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -552,12 +551,12 @@ gen_rtx (PLUS, Pmode, frame, GEN_INT (12))\n    to the start of the trampoline.  */\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_insn (gen_rtx (ASM_INPUT, VOIDmode,\t\t\t\t\\\n-\t\t      \"movpsl -(sp)\\n\\tpushal 1(pc)\\n\\trei\"));\t\t\\\n-  emit_move_insn (gen_rtx (MEM, HImode, TRAMP),\t\t\t\t\\\n-\t\t  gen_rtx (MEM, HImode, FNADDR));\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), CXT);\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 11)),\t\\\n+  emit_insn (gen_rtx_ASM_INPUT (VOIDmode,\t\t\t\t\\\n+\t\t\t\t\"movpsl -(sp)\\n\\tpushal 1(pc)\\n\\trei\")); \\\n+  emit_move_insn (gen_rtx_MEM (HImode, TRAMP),\t\t\t\t\\\n+\t\t  gen_rtx_MEM (HImode, FNADDR));\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), CXT);\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 11)),\t\\\n \t\t  plus_constant (FNADDR, 2));\t\t\t\t\\\n }\n \n@@ -573,7 +572,7 @@ gen_rtx (PLUS, Pmode, frame, GEN_INT (12))\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n   ((COUNT == 0)\t\t\t\t\\\n-   ? gen_rtx (MEM, Pmode, plus_constant (FRAME, RETURN_ADDRESS_OFFSET)) \\\n+   ? gen_rtx_MEM (Pmode, plus_constant (FRAME, RETURN_ADDRESS_OFFSET)) \\\n    : (rtx) 0)\n \n \f"}, {"sha": "ead66070ae5d9001df6cd874f7d7b8ca314b84ab", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n-;;- Machine description for GNU compiler, Vax Version\n-;;   Copyright (C) 1987, 88, 91, 94-96, 1998 Free Software Foundation, Inc.\n+;; Machine description for GNU compiler, Vax Version\n+;; Copyright (C) 1987, 88, 91, 94-96, 1998, 1999 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -1189,7 +1189,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"\"\n@@ -1237,7 +1237,7 @@\n   \"\"\n   \"\n {\n-  operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+  operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"ashldi3\"\n@@ -1283,7 +1283,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+    operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"rotlsi3\"\n@@ -2131,6 +2131,7 @@\n   \"\"\n   \"*\n {\n-  operands[3] = GEN_INT (INTVAL (operands[3]) & ~((1 << INTVAL (operands[2])) - 1));\n+  operands[3]\n+    = GEN_INT (INTVAL (operands[3]) & ~((1 << INTVAL (operands[2])) - 1));\n   return \\\"rotl %2,%1,%0\\;bicl2 %N3,%0\\\";\n }\")"}, {"sha": "ef03232cb5de85b68219102000694ac43985362c", "filename": "gcc/config/we32k/we32k.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for AT&T we32000 Family.\n+   Copyright (C) 1991, 1992, 1997, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by John Wehle (john@feith1.uucp)\n-   Copyright (C) 1991, 1992, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -21,12 +21,11 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"function.h\"\n #include \"real.h\"\n \n-\n void\n output_move_double (operands)\n      rtx *operands;\n@@ -37,7 +36,7 @@ output_move_double (operands)\n \n   if (GET_CODE (operands[0]) == REG) \n     {\n-      lsw_operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      lsw_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n       msw_dreg = operands[0];\n     }\n   else if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n@@ -47,7 +46,7 @@ output_move_double (operands)\n \n   if (GET_CODE (operands[1]) == REG) \n     {\n-      lsw_operands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      lsw_operands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n       lsw_sreg = lsw_operands[1];\n     }\n   else if (GET_CODE (operands[1]) == MEM && offsettable_memref_p (operands[1])) \n@@ -116,12 +115,12 @@ output_push_double (operands)\n   rtx lsw_operands[1];\n \n   if (GET_CODE (operands[0]) == REG)\n-    lsw_operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+    lsw_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n     lsw_operands[0] = adj_offsettable_operand (operands[0], 4);\n   else if (GET_CODE (operands[0]) == CONST_DOUBLE)\n     {\n-      lsw_operands[0] = GEN_INT (CONST_DOUBLE_HIGH (operands[0]));\n+      lsw_operands[0] = GEN_INT CONST_DOUBLE_HIGH (operands[0]));\n       operands[0] = GEN_INT (CONST_DOUBLE_LOW (operands[0]));\n     }\n   else if (GET_CODE (operands[0]) == CONST_INT)"}, {"sha": "7a66c734083dd371ffcb83d0b160f48f45e87269", "filename": "gcc/config/we32k/we32k.h", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,6 @@\n /* Definitions of target machine for GNU compiler.  AT&T we32000 version.\n-   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 92, 93, 94, 95, 96, 98, 1999\n+   Free Software Foundation, Inc.\n    Contributed by John Wehle (john@feith1.uucp)\n \n This file is part of GNU CC.\n@@ -319,14 +320,14 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n /* On the we32000 the return value is in r0 regardless.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n /* On the we32000 the return value is in r0 regardless.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n \n /* 1 if N is a possible register number for a function value.\n    On the we32000, r0 is the only register thus used.  */\n@@ -478,15 +479,15 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n      mov #STATIC,%r8\n      jmp #FUNCTION */\n \n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x844f));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, GEN_INT (0x48));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x247f));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+{\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x844f));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n+  ASM_OUTPUT_CHAR  (FILE, GEN_INT (0x48));\t\\\n+  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x247f));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -499,8 +500,8 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 2)), CXT); \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 9)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 2)), CXT); \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 9)), FNADDR); \\\n }\n \f\n /* Generate calls to memcpy() and memset() rather"}, {"sha": "afabb9200cd3a047257eb92cf3f6c543289450db", "filename": "gcc/config/we32k/we32k.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fwe32k%2Fwe32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfig%2Fwe32k%2Fwe32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.md?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description for GNU compiler, AT&T we32000 Version\n-;; Copyright (C) 1991, 1992, 1994 Free Software Foundation, Inc.\n+;; Copyright (C) 1991, 1992, 1994, 1998, 1999 Free Software Foundation, Inc.\n ;; Contributed by John Wehle (john@feith1.uucp)\n \n ;; This file is part of GNU CC.\n@@ -125,15 +125,15 @@\n   rtx lsw_operands[3];\n \n   if (GET_CODE (operands[0]) == REG)\n-    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+    lsw_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else\n     if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n       lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n     else\n       abort();\n \n   if (GET_CODE (operands[2]) == REG)\n-    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+    lsw_operands[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n       lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n@@ -175,15 +175,15 @@\n   rtx lsw_operands[3];\n \n   if (GET_CODE (operands[0]) == REG)\n-    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+    lsw_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else\n     if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n       lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n     else\n       abort();\n \n   if (GET_CODE (operands[1]) == REG)\n-    lsw_operands[1] = gen_rtx(REG, SImode, REGNO (operands[1]) + 1);\n+    lsw_operands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else\n     if (GET_CODE (operands[1]) == MEM && offsettable_memref_p (operands[1]))\n       lsw_operands[1] = adj_offsettable_operand(operands[1], 4);\n@@ -203,7 +203,7 @@\n           abort();\n \n   if (GET_CODE (operands[2]) == REG)\n-    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+    lsw_operands[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n       lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n@@ -289,15 +289,15 @@\n   rtx lsw_operands[3];\n \n   if (GET_CODE (operands[0]) == REG)\n-    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+    lsw_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else\n     if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n       lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n     else\n       abort();\n \n   if (GET_CODE (operands[2]) == REG)\n-    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+    lsw_operands[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n       lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n@@ -339,15 +339,15 @@\n   rtx lsw_operands[3];\n \n   if (GET_CODE (operands[0]) == REG)\n-    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+    lsw_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   else\n     if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n       lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n     else\n       abort();\n \n   if (GET_CODE (operands[1]) == REG)\n-    lsw_operands[1] = gen_rtx(REG, SImode, REGNO (operands[1]) + 1);\n+    lsw_operands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n   else\n     if (GET_CODE (operands[1]) == MEM && offsettable_memref_p (operands[1]))\n       lsw_operands[1] = adj_offsettable_operand(operands[1], 4);\n@@ -367,7 +367,7 @@\n           abort();\n \n   if (GET_CODE (operands[2]) == REG)\n-    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+    lsw_operands[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n   else\n     if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n       lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n@@ -758,7 +758,7 @@\n \n   if (GET_CODE (operands[1]) == CONST_INT &&\n     ((unsigned long)INTVAL (operands[1]) & 0x8000L))\n-    operands[1] = GEN_INT (INTVAL(operands[1]) | 0xffff0000L);\n+    operands[1] = GEN_INT (INTVAL (operands[1]) | 0xffff0000L);\n \n   output_asm_insn(\\\"CMPH %1, %0\\\",operands);\n \n@@ -913,7 +913,7 @@\n   \"*\n   {\n \n-  operands[2] = GEN_INT (INTVAL(operands[2]) - 1);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\n   output_asm_insn(\\\"EXTFH %2, %3, {uhalf}%1, {uword}%0\\\",operands);\n \n   return \\\"\\\";\n@@ -928,7 +928,7 @@\n   \"*\n   {\n \n-  operands[2] = GEN_INT (INTVAL(operands[2]) - 1);\n+  operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\n   output_asm_insn(\\\"EXTFB %2, %3, {ubyte}%1, {uword}%0\\\",operands);\n \n   return \\\"\\\";\n@@ -943,7 +943,7 @@\n   \"*\n   {\n \n-  operands[1] = GEN_INT (INTVAL(operands[1]) - 1);\n+  operands[1] = GEN_INT (INTVAL (operands[1]) - 1);\n   output_asm_insn(\\\"INSFW %1, %2, %3, %0\\\",operands);\n \n   return \\\"\\\";"}, {"sha": "25979971c2aa682076f5de86fb82bbd7c893c0f5", "filename": "gcc/configure", "status": "modified", "additions": 188, "deletions": 118, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -41,12 +41,12 @@ ac_help=\"$ac_help\n ac_help=\"$ac_help\n   --enable-c-cpplib       link cpplib directly into C and C++ compilers\n                           (EXPERIMENTAL) (implies --enable-cpplib).\"\n-ac_help=\"$ac_help\n-  --enable-c-mbchar       enable multibyte characters for C and C++.\"\n ac_help=\"$ac_help\n   --disable-fast-fixincludes\n                          Disable the new fast fixincludes.\n                          Run the old fixincludes script unconditionally\"\n+ac_help=\"$ac_help\n+  --enable-c-mbchar       Enable multibyte characters for C and C++.\"\n ac_help=\"$ac_help\n   --enable-threads        enable thread usage for target GCC.\n   --enable-threads=LIB    use LIB thread package for target GCC.\"\n@@ -831,16 +831,6 @@ fi\n fi\n \n \n-# Enable Multibyte Characters for C/C++\n-# Check whether --enable-c-mbchar or --disable-c-mbchar was given.\n-if test \"${enable_c_mbchar+set}\" = set; then\n-  enableval=\"$enable_c_mbchar\"\n-  if test x$enable_c_mbchar != xno; then\n-  extra_c_flags=-DMULTIBYTE_CHARS=1\n-fi\n-fi\n-\n-\n # Disable fast fixincludes\n # Check whether --enable-fast-fixincludes or --disable-fast-fixincludes was given.\n if test \"${enable_fast_fixincludes+set}\" = set; then\n@@ -851,6 +841,16 @@ fi\n fi\n \n \n+# Enable Multibyte Characters for C/C++\n+# Check whether --enable-c-mbchar or --disable-c-mbchar was given.\n+if test \"${enable_c_mbchar+set}\" = set; then\n+  enableval=\"$enable_c_mbchar\"\n+  if [ x$enable_c_mbchar != xno ]; then\n+  extra_c_flags=-DMULTIBYTE_CHARS=1\n+fi\n+fi\n+\n+  \n # Enable threads\n # Pass with no value to take the default\n # Pass with a value to specify a thread package\n@@ -1935,7 +1935,7 @@ EOF\n \n fi\n \n-for ac_hdr in limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unistd.h stab.h sys/file.h sys/time.h sys/resource.h sys/param.h sys/times.h sys/stat.h direct.h\n+for ac_hdr in limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unistd.h stab.h sys/file.h sys/time.h sys/resource.h sys/param.h sys/times.h sys/stat.h direct.h malloc.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n@@ -2626,7 +2626,7 @@ EOF\n fi\n \n \n-for ac_func in malloc realloc calloc free bcopy bzero bcmp \\\n+for ac_func in bcopy bzero bcmp \\\n \tindex rindex getenv atol sbrk abort atof strerror getcwd getwd \\\n \tstrsignal putc_unlocked fputs_unlocked strstr\n do\n@@ -2695,7 +2695,7 @@ fi\n done\n \n \n-for ac_func in getrlimit setrlimit\n+for ac_func in malloc realloc calloc free\n do\n echo $ac_n \"checking whether $ac_func must be declared\"\"... $ac_c\" 1>&6\n echo \"configure:2702: checking whether $ac_func must be declared\" >&5\n@@ -2706,6 +2706,76 @@ else\n #line 2707 \"configure\"\n #include \"confdefs.h\"\n \n+#include <stdio.h>\n+#ifdef STRING_WITH_STRINGS\n+# include <string.h>\n+# include <strings.h>\n+#else\n+# ifdef HAVE_STRING_H\n+#  include <string.h>\n+# else\n+#  ifdef HAVE_STRINGS_H\n+#   include <strings.h>\n+#  endif\n+# endif\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifndef HAVE_RINDEX\n+#define rindex strrchr\n+#endif\n+#ifndef HAVE_INDEX\n+#define index strchr\n+#endif\n+#ifdef HAVE_MALLOC_H\n+#include <malloc.h>\n+#endif\n+\n+int main() {\n+char *(*pfn) = (char *(*)) $ac_func\n+; return 0; }\n+EOF\n+if { (eval echo configure:2743: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  rm -rf conftest*\n+  eval \"gcc_cv_decl_needed_$ac_func=no\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"gcc_cv_decl_needed_$ac_func=yes\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$gcc_cv_decl_needed_'$ac_func`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  gcc_tr_decl=NEED_DECLARATION_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`\n+  cat >> confdefs.h <<EOF\n+#define $gcc_tr_decl 1\n+EOF\n+\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+done\n+\n+\n+for ac_func in getrlimit setrlimit\n+do\n+echo $ac_n \"checking whether $ac_func must be declared\"\"... $ac_c\" 1>&6\n+echo \"configure:2772: checking whether $ac_func must be declared\" >&5\n+if eval \"test \\\"`echo '$''{'gcc_cv_decl_needed_$ac_func'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2777 \"configure\"\n+#include \"confdefs.h\"\n+\n #include <stdio.h>\n #ifdef STRING_WITH_STRINGS\n # include <string.h>\n@@ -2740,7 +2810,7 @@ int main() {\n char *(*pfn) = (char *(*)) $ac_func\n ; return 0; }\n EOF\n-if { (eval echo configure:2744: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2814: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   eval \"gcc_cv_decl_needed_$ac_func=no\"\n else\n@@ -2767,12 +2837,12 @@ done\n \n \n echo $ac_n \"checking for sys_siglist declaration in signal.h or unistd.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2771: checking for sys_siglist declaration in signal.h or unistd.h\" >&5\n+echo \"configure:2841: checking for sys_siglist declaration in signal.h or unistd.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2776 \"configure\"\n+#line 2846 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <signal.h>\n@@ -2784,7 +2854,7 @@ int main() {\n char *msg = *(sys_siglist + 1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2788: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2858: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_decl_sys_siglist=yes\n else\n@@ -2807,12 +2877,12 @@ fi\n \n # mkdir takes a single argument on some systems. \n echo $ac_n \"checking if mkdir takes one argument\"\"... $ac_c\" 1>&6\n-echo \"configure:2811: checking if mkdir takes one argument\" >&5\n+echo \"configure:2881: checking if mkdir takes one argument\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_mkdir_takes_one_arg'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2816 \"configure\"\n+#line 2886 \"configure\"\n #include \"confdefs.h\"\n \n #include <sys/types.h>\n@@ -2829,7 +2899,7 @@ int main() {\n mkdir (\"foo\", 0);\n ; return 0; }\n EOF\n-if { (eval echo configure:2833: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2903: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   gcc_cv_mkdir_takes_one_arg=no\n else\n@@ -6179,15 +6249,15 @@ fi\n \n \n         echo $ac_n \"checking for strerror in -lcposix\"\"... $ac_c\" 1>&6\n-echo \"configure:6183: checking for strerror in -lcposix\" >&5\n+echo \"configure:6253: checking for strerror in -lcposix\" >&5\n ac_lib_var=`echo cposix'_'strerror | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lcposix  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 6191 \"configure\"\n+#line 6261 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -6198,7 +6268,7 @@ int main() {\n strerror()\n ; return 0; }\n EOF\n-if { (eval echo configure:6202: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6272: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -6221,12 +6291,12 @@ fi\n   \n \n echo $ac_n \"checking for working const\"\"... $ac_c\" 1>&6\n-echo \"configure:6225: checking for working const\" >&5\n+echo \"configure:6295: checking for working const\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_const'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6230 \"configure\"\n+#line 6300 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -6275,7 +6345,7 @@ ccp = (char const *const *) p;\n \n ; return 0; }\n EOF\n-if { (eval echo configure:6279: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:6349: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_const=yes\n else\n@@ -6296,21 +6366,21 @@ EOF\n fi\n \n echo $ac_n \"checking for inline\"\"... $ac_c\" 1>&6\n-echo \"configure:6300: checking for inline\" >&5\n+echo \"configure:6370: checking for inline\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_inline'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_inline=no\n for ac_kw in inline __inline__ __inline; do\n   cat > conftest.$ac_ext <<EOF\n-#line 6307 \"configure\"\n+#line 6377 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n } $ac_kw foo() {\n ; return 0; }\n EOF\n-if { (eval echo configure:6314: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:6384: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_inline=$ac_kw; break\n else\n@@ -6336,12 +6406,12 @@ EOF\n esac\n \n echo $ac_n \"checking for off_t\"\"... $ac_c\" 1>&6\n-echo \"configure:6340: checking for off_t\" >&5\n+echo \"configure:6410: checking for off_t\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_type_off_t'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6345 \"configure\"\n+#line 6415 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #if STDC_HEADERS\n@@ -6369,12 +6439,12 @@ EOF\n fi\n \n echo $ac_n \"checking for size_t\"\"... $ac_c\" 1>&6\n-echo \"configure:6373: checking for size_t\" >&5\n+echo \"configure:6443: checking for size_t\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_type_size_t'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6378 \"configure\"\n+#line 6448 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #if STDC_HEADERS\n@@ -6404,19 +6474,19 @@ fi\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:6408: checking for working alloca.h\" >&5\n+echo \"configure:6478: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6413 \"configure\"\n+#line 6483 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:6420: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6490: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -6437,12 +6507,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:6441: checking for alloca\" >&5\n+echo \"configure:6511: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6446 \"configure\"\n+#line 6516 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -6470,7 +6540,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:6474: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6544: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -6502,12 +6572,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:6506: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:6576: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6511 \"configure\"\n+#line 6581 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -6532,12 +6602,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:6536: checking for $ac_func\" >&5\n+echo \"configure:6606: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6541 \"configure\"\n+#line 6611 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -6560,7 +6630,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:6564: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6634: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -6587,15 +6657,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:6591: checking stack direction for C alloca\" >&5\n+echo \"configure:6661: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6599 \"configure\"\n+#line 6669 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -6614,7 +6684,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:6618: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:6688: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -6639,17 +6709,17 @@ for ac_hdr in unistd.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:6643: checking for $ac_hdr\" >&5\n+echo \"configure:6713: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6648 \"configure\"\n+#line 6718 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:6653: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:6723: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -6678,12 +6748,12 @@ done\n for ac_func in getpagesize\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:6682: checking for $ac_func\" >&5\n+echo \"configure:6752: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6687 \"configure\"\n+#line 6757 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -6706,7 +6776,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:6710: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6780: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -6731,15 +6801,15 @@ fi\n done\n \n echo $ac_n \"checking for working mmap\"\"... $ac_c\" 1>&6\n-echo \"configure:6735: checking for working mmap\" >&5\n+echo \"configure:6805: checking for working mmap\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_mmap_fixed_mapped'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_func_mmap_fixed_mapped=no\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6743 \"configure\"\n+#line 6813 \"configure\"\n #include \"confdefs.h\"\n \n /* Thanks to Mike Haertel and Jim Avera for this test.\n@@ -6879,7 +6949,7 @@ main()\n }\n \n EOF\n-if { (eval echo configure:6883: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:6953: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_func_mmap_fixed_mapped=yes\n else\n@@ -6907,17 +6977,17 @@ unistd.h sys/param.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:6911: checking for $ac_hdr\" >&5\n+echo \"configure:6981: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6916 \"configure\"\n+#line 6986 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:6921: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:6991: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -6947,12 +7017,12 @@ done\n strdup __argz_count __argz_stringify __argz_next\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:6951: checking for $ac_func\" >&5\n+echo \"configure:7021: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6956 \"configure\"\n+#line 7026 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -6975,7 +7045,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:6979: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7049: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7004,12 +7074,12 @@ done\n      for ac_func in stpcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:7008: checking for $ac_func\" >&5\n+echo \"configure:7078: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7013 \"configure\"\n+#line 7083 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -7032,7 +7102,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7036: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7106: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7066,19 +7136,19 @@ EOF\n \n    if test $ac_cv_header_locale_h = yes; then\n     echo $ac_n \"checking for LC_MESSAGES\"\"... $ac_c\" 1>&6\n-echo \"configure:7070: checking for LC_MESSAGES\" >&5\n+echo \"configure:7140: checking for LC_MESSAGES\" >&5\n if eval \"test \\\"`echo '$''{'am_cv_val_LC_MESSAGES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7075 \"configure\"\n+#line 7145 \"configure\"\n #include \"confdefs.h\"\n #include <locale.h>\n int main() {\n return LC_MESSAGES\n ; return 0; }\n EOF\n-if { (eval echo configure:7082: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7152: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   am_cv_val_LC_MESSAGES=yes\n else\n@@ -7099,7 +7169,7 @@ EOF\n     fi\n   fi\n    echo $ac_n \"checking whether NLS is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:7103: checking whether NLS is requested\" >&5\n+echo \"configure:7173: checking whether NLS is requested\" >&5\n         # Check whether --enable-nls or --disable-nls was given.\n if test \"${enable_nls+set}\" = set; then\n   enableval=\"$enable_nls\"\n@@ -7119,7 +7189,7 @@ fi\n EOF\n \n       echo $ac_n \"checking whether included gettext is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:7123: checking whether included gettext is requested\" >&5\n+echo \"configure:7193: checking whether included gettext is requested\" >&5\n       # Check whether --with-included-gettext or --without-included-gettext was given.\n if test \"${with_included_gettext+set}\" = set; then\n   withval=\"$with_included_gettext\"\n@@ -7138,17 +7208,17 @@ fi\n \n \tac_safe=`echo \"libintl.h\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for libintl.h\"\"... $ac_c\" 1>&6\n-echo \"configure:7142: checking for libintl.h\" >&5\n+echo \"configure:7212: checking for libintl.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7147 \"configure\"\n+#line 7217 \"configure\"\n #include \"confdefs.h\"\n #include <libintl.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:7152: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:7222: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -7165,19 +7235,19 @@ fi\n if eval \"test \\\"`echo '$ac_cv_header_'$ac_safe`\\\" = yes\"; then\n   echo \"$ac_t\"\"yes\" 1>&6\n   echo $ac_n \"checking for gettext in libc\"\"... $ac_c\" 1>&6\n-echo \"configure:7169: checking for gettext in libc\" >&5\n+echo \"configure:7239: checking for gettext in libc\" >&5\n if eval \"test \\\"`echo '$''{'gt_cv_func_gettext_libc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7174 \"configure\"\n+#line 7244 \"configure\"\n #include \"confdefs.h\"\n #include <libintl.h>\n int main() {\n return (int) gettext (\"\")\n ; return 0; }\n EOF\n-if { (eval echo configure:7181: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7251: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   gt_cv_func_gettext_libc=yes\n else\n@@ -7193,15 +7263,15 @@ echo \"$ac_t\"\"$gt_cv_func_gettext_libc\" 1>&6\n \n \t   if test \"$gt_cv_func_gettext_libc\" != \"yes\"; then\n \t     echo $ac_n \"checking for bindtextdomain in -lintl\"\"... $ac_c\" 1>&6\n-echo \"configure:7197: checking for bindtextdomain in -lintl\" >&5\n+echo \"configure:7267: checking for bindtextdomain in -lintl\" >&5\n ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lintl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 7205 \"configure\"\n+#line 7275 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -7212,7 +7282,7 @@ int main() {\n bindtextdomain()\n ; return 0; }\n EOF\n-if { (eval echo configure:7216: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7286: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -7228,20 +7298,20 @@ fi\n if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n   echo \"$ac_t\"\"yes\" 1>&6\n   echo $ac_n \"checking for gettext in libintl\"\"... $ac_c\" 1>&6\n-echo \"configure:7232: checking for gettext in libintl\" >&5\n+echo \"configure:7302: checking for gettext in libintl\" >&5\n if eval \"test \\\"`echo '$''{'gt_cv_func_gettext_libintl'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   echo $ac_n \"checking for gettext in -lintl\"\"... $ac_c\" 1>&6\n-echo \"configure:7237: checking for gettext in -lintl\" >&5\n+echo \"configure:7307: checking for gettext in -lintl\" >&5\n ac_lib_var=`echo intl'_'gettext | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lintl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 7245 \"configure\"\n+#line 7315 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -7252,7 +7322,7 @@ int main() {\n gettext()\n ; return 0; }\n EOF\n-if { (eval echo configure:7256: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7326: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -7291,7 +7361,7 @@ EOF\n \t      # Extract the first word of \"msgfmt\", so it can be a program name with args.\n set dummy msgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7295: checking for $ac_word\" >&5\n+echo \"configure:7365: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7325,12 +7395,12 @@ fi\n \t\tfor ac_func in dcgettext\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:7329: checking for $ac_func\" >&5\n+echo \"configure:7399: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7334 \"configure\"\n+#line 7404 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -7353,7 +7423,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7357: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7427: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7380,7 +7450,7 @@ done\n \t\t# Extract the first word of \"gmsgfmt\", so it can be a program name with args.\n set dummy gmsgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7384: checking for $ac_word\" >&5\n+echo \"configure:7454: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7416,7 +7486,7 @@ fi\n \t\t# Extract the first word of \"xgettext\", so it can be a program name with args.\n set dummy xgettext; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7420: checking for $ac_word\" >&5\n+echo \"configure:7490: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7448,15 +7518,15 @@ else\n fi\n \n \t\tcat > conftest.$ac_ext <<EOF\n-#line 7452 \"configure\"\n+#line 7522 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n extern int _nl_msg_cat_cntr;\n \t\t\t       return _nl_msg_cat_cntr\n ; return 0; }\n EOF\n-if { (eval echo configure:7460: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7530: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   CATOBJEXT=.gmo\n \t\t   DATADIRNAME=share\n@@ -7479,7 +7549,7 @@ fi\n \n         if test \"$CATOBJEXT\" = \"NONE\"; then\n \t  echo $ac_n \"checking whether catgets can be used\"\"... $ac_c\" 1>&6\n-echo \"configure:7483: checking whether catgets can be used\" >&5\n+echo \"configure:7553: checking whether catgets can be used\" >&5\n \t  # Check whether --with-catgets or --without-catgets was given.\n if test \"${with_catgets+set}\" = set; then\n   withval=\"$with_catgets\"\n@@ -7492,22 +7562,22 @@ fi\n \n \t  if test \"$nls_cv_use_catgets\" = \"yes\"; then\n \t    \t    echo $ac_n \"checking for main in -li\"\"... $ac_c\" 1>&6\n-echo \"configure:7496: checking for main in -li\" >&5\n+echo \"configure:7566: checking for main in -li\" >&5\n ac_lib_var=`echo i'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-li  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 7504 \"configure\"\n+#line 7574 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:7511: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7581: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -7535,12 +7605,12 @@ else\n fi\n \n \t    echo $ac_n \"checking for catgets\"\"... $ac_c\" 1>&6\n-echo \"configure:7539: checking for catgets\" >&5\n+echo \"configure:7609: checking for catgets\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_catgets'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7544 \"configure\"\n+#line 7614 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char catgets(); below.  */\n@@ -7563,7 +7633,7 @@ catgets();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7567: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7637: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_catgets=yes\"\n else\n@@ -7585,7 +7655,7 @@ EOF\n \t       # Extract the first word of \"gencat\", so it can be a program name with args.\n set dummy gencat; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7589: checking for $ac_word\" >&5\n+echo \"configure:7659: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GENCAT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7621,7 +7691,7 @@ fi\n \t\t # Extract the first word of \"gmsgfmt\", so it can be a program name with args.\n set dummy gmsgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7625: checking for $ac_word\" >&5\n+echo \"configure:7695: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7658,7 +7728,7 @@ fi\n \t\t   # Extract the first word of \"msgfmt\", so it can be a program name with args.\n set dummy msgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7662: checking for $ac_word\" >&5\n+echo \"configure:7732: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7693,7 +7763,7 @@ fi\n \t\t # Extract the first word of \"xgettext\", so it can be a program name with args.\n set dummy xgettext; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7697: checking for $ac_word\" >&5\n+echo \"configure:7767: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7751,7 +7821,7 @@ fi\n         # Extract the first word of \"msgfmt\", so it can be a program name with args.\n set dummy msgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7755: checking for $ac_word\" >&5\n+echo \"configure:7825: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7785,7 +7855,7 @@ fi\n         # Extract the first word of \"gmsgfmt\", so it can be a program name with args.\n set dummy gmsgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7789: checking for $ac_word\" >&5\n+echo \"configure:7859: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7821,7 +7891,7 @@ fi\n         # Extract the first word of \"xgettext\", so it can be a program name with args.\n set dummy xgettext; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7825: checking for $ac_word\" >&5\n+echo \"configure:7895: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7914,7 +7984,7 @@ fi\n        LINGUAS=\n      else\n        echo $ac_n \"checking for catalogs to be installed\"\"... $ac_c\" 1>&6\n-echo \"configure:7918: checking for catalogs to be installed\" >&5\n+echo \"configure:7988: checking for catalogs to be installed\" >&5\n        NEW_LINGUAS=\n        for lang in ${LINGUAS=$ALL_LINGUAS}; do\n          case \"$ALL_LINGUAS\" in\n@@ -7942,17 +8012,17 @@ echo \"configure:7918: checking for catalogs to be installed\" >&5\n    if test \"$CATOBJEXT\" = \".cat\"; then\n      ac_safe=`echo \"linux/version.h\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for linux/version.h\"\"... $ac_c\" 1>&6\n-echo \"configure:7946: checking for linux/version.h\" >&5\n+echo \"configure:8016: checking for linux/version.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7951 \"configure\"\n+#line 8021 \"configure\"\n #include \"confdefs.h\"\n #include <linux/version.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:7956: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:8026: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -8027,7 +8097,7 @@ fi\n \n \n echo $ac_n \"checking whether windows registry support is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:8031: checking whether windows registry support is requested\" >&5\n+echo \"configure:8101: checking whether windows registry support is requested\" >&5\n if test x$enable_win32_registry != xno; then\n   cat >> confdefs.h <<\\EOF\n #define ENABLE_WIN32_REGISTRY 1\n@@ -8056,7 +8126,7 @@ esac\n \n if test x$enable_win32_registry != xno; then\n   echo $ac_n \"checking registry key on windows hosts\"\"... $ac_c\" 1>&6\n-echo \"configure:8060: checking registry key on windows hosts\" >&5\n+echo \"configure:8130: checking registry key on windows hosts\" >&5\n   cat >> confdefs.h <<EOF\n #define WIN32_REGISTRY_KEY \"$gcc_cv_win32_registry_key\"\n EOF\n@@ -8232,7 +8302,7 @@ fi\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n-echo \"configure:8236: checking assembler alignment features\" >&5\n+echo \"configure:8306: checking assembler alignment features\" >&5\n gcc_cv_as=\n gcc_cv_as_alignment_features=\n gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/gas\n@@ -8353,7 +8423,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_alignment_features\" 1>&6\n \n echo $ac_n \"checking assembler subsection support\"\"... $ac_c\" 1>&6\n-echo \"configure:8357: checking assembler subsection support\" >&5\n+echo \"configure:8427: checking assembler subsection support\" >&5\n gcc_cv_as_subsections=\n if test x$gcc_cv_as != x; then\n \t# Check if we have .subsection\n@@ -8395,7 +8465,7 @@ echo \"$ac_t\"\"$gcc_cv_as_subsections\" 1>&6\n case \"$target\" in \n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:8399: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:8469: checking assembler .register pseudo-op support\" >&5\n     gcc_cv_as_register_pseudo_op=\n     if test x$gcc_cv_as != x; then\n \t# Check if we have .register\n@@ -8412,7 +8482,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_register_pseudo_op\" 1>&6\n \n     echo $ac_n \"checking assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:8416: checking assembler offsetable %lo() support\" >&5\n+echo \"configure:8486: checking assembler offsetable %lo() support\" >&5\n     gcc_cv_as_offsetable_lo10=\n     if test x$gcc_cv_as != x; then\n \t# Check if assembler has offsetable %lo()\n@@ -8449,7 +8519,7 @@ EOF\n \n   i[34567]86-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:8453: checking assembler instructions\" >&5\n+echo \"configure:8523: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_as != x; then\n \tset \"filds fists\" \"filds mem; fists mem\""}, {"sha": "fca71493789639122cbf19d69ceb5a8ae0d3b753", "filename": "gcc/configure.in", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -216,13 +216,6 @@ if test x$enable_c_cpplib != xno; then\n   cpp_main=cppmain\n fi)\n \n-# Enable Multibyte Characters for C/C++\n-AC_ARG_ENABLE(c-mbchar,\n-[  --enable-c-mbchar       enable multibyte characters for C and C++.],\n-if test x$enable_c_mbchar != xno; then\n-  extra_c_flags=-DMULTIBYTE_CHARS=1\n-fi)\n-\n # Disable fast fixincludes\n AC_ARG_ENABLE(fast-fixincludes,\n [  --disable-fast-fixincludes\n@@ -232,6 +225,13 @@ if test x$enable_fast_fixincludes = xno ; then\n   cp $srcdir/fixincludes ./fixinc.sh\n fi)\n \n+# Enable Multibyte Characters for C/C++\n+AC_ARG_ENABLE(c-mbchar,\n+[  --enable-c-mbchar       Enable multibyte characters for C and C++.],\n+if [[[ x$enable_c_mbchar != xno ]]]; then\n+  extra_c_flags=-DMULTIBYTE_CHARS=1\n+fi)\n+  \n # Enable threads\n # Pass with no value to take the default\n # Pass with a value to specify a thread package\n@@ -333,7 +333,7 @@ AC_HEADER_STDC\n AC_HEADER_TIME\n GCC_HEADER_STRING\n AC_HEADER_SYS_WAIT\n-AC_CHECK_HEADERS(limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unistd.h stab.h sys/file.h sys/time.h sys/resource.h sys/param.h sys/times.h sys/stat.h direct.h)\n+AC_CHECK_HEADERS(limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unistd.h stab.h sys/file.h sys/time.h sys/resource.h sys/param.h sys/times.h sys/stat.h direct.h malloc.h)\n \n # Check for thread headers.\n AC_CHECK_HEADER(thread.h, [have_thread_h=yes], [have_thread_h=])\n@@ -391,10 +391,16 @@ case \"${host}\" in\n esac\n AC_FUNC_VFORK\n \n-GCC_NEED_DECLARATIONS(malloc realloc calloc free bcopy bzero bcmp \\\n+GCC_NEED_DECLARATIONS(bcopy bzero bcmp \\\n \tindex rindex getenv atol sbrk abort atof strerror getcwd getwd \\\n \tstrsignal putc_unlocked fputs_unlocked strstr)\n \n+GCC_NEED_DECLARATIONS(malloc realloc calloc free, [\n+#ifdef HAVE_MALLOC_H\n+#include <malloc.h>\n+#endif\n+])\n+\n GCC_NEED_DECLARATIONS(getrlimit setrlimit, [\n #include <sys/types.h>\n #ifdef HAVE_SYS_RESOURCE_H"}, {"sha": "31ebb56ff3098aecb7a1c2c6798a9f959cb3a5d9", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n    intended to be called by the language-specific convert () functions.  */\n \n #include \"config.h\"\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"convert.h\""}, {"sha": "a1928efbb6f81c6ea1e59c497346f2060285e2fa", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2207,7 +2207,7 @@ break_out_target_exprs (t)\n tree\n build_min_nt VPROTO((enum tree_code code, ...))\n {\n-#ifndef __STDC__\n+#ifndef ANSI_PROTOTYPES\n   enum tree_code code;\n #endif\n   register struct obstack *ambient_obstack = expression_obstack;\n@@ -2218,7 +2218,7 @@ build_min_nt VPROTO((enum tree_code code, ...))\n \n   VA_START (p, code);\n \n-#ifndef __STDC__\n+#ifndef ANSI_PROTOTYPES\n   code = va_arg (p, enum tree_code);\n #endif\n \n@@ -2245,7 +2245,7 @@ build_min_nt VPROTO((enum tree_code code, ...))\n tree\n build_min VPROTO((enum tree_code code, tree tt, ...))\n {\n-#ifndef __STDC__\n+#ifndef ANSI_PROTOTYPES\n   enum tree_code code;\n   tree tt;\n #endif\n@@ -2257,7 +2257,7 @@ build_min VPROTO((enum tree_code code, tree tt, ...))\n \n   VA_START (p, tt);\n \n-#ifndef __STDC__\n+#ifndef ANSI_PROTOTYPES\n   code = va_arg (p, enum tree_code);\n   tt = va_arg (p, tree);\n #endif"}, {"sha": "e9a9095c7b21c8cc3491c108037db9780b6ae690", "filename": "gcc/cpp.texi", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2741,12 +2741,6 @@ as when text other than a comment follows @samp{#else} or @samp{#endif}.\n Like @samp{-pedantic}, except that errors are produced rather than\n warnings.\n \n-@item -Wtrigraphs\n-@findex -Wtrigraphs\n-Warn if any trigraphs are encountered.  Currently this only works if you\n-have turned trigraphs on with @samp{-trigraphs} or @samp{-ansi}; in the\n-future this restriction will be removed.\n-\n @item -Wcomment\n @findex -Wcomment\n @ignore\n@@ -2759,10 +2753,19 @@ future this restriction will be removed.\n Warn whenever a comment-start sequence @samp{/*} appears in a @samp{/*}\n comment, or whenever a Backslash-Newline appears in a @samp{//} comment.\n \n+@item -Wtrigraphs\n+@findex -Wtrigraphs\n+Warn if any trigraphs are encountered (assuming they are enabled).\n+\n+@item -Wwhite-space\n+@findex -Wwhite-space\n+Warn about possible white space confusion, e.g. white space between a\n+backslash and a newline.\n+\n @item -Wall\n @findex -Wall\n-Requests both @samp{-Wtrigraphs} and @samp{-Wcomment} (but not\n-@samp{-Wtraditional} or @samp{-Wundef}). \n+Requests @samp{-Wcomment}, @samp{-Wtrigraphs}, and @samp{-Wwhite-space}\n+(but not @samp{-Wtraditional} or @samp{-Wundef}).\n \n @item -Wtraditional\n @findex -Wtraditional"}, {"sha": "b42e523d8a5bf615176a93e07af16f7d85a5a399", "filename": "gcc/cppalloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcppalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcppalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppalloc.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Part of CPP library.  (memory allocation - xmalloc etc)\n-   Copyright (C) 1986, 87, 89, 92, 93, 94, 1995, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92-95, 1998 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987"}, {"sha": "66fa3589707e13f0d78a5ac1690a44493d6f07bc", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* Part of CPP library.  (Macro handling.)\n-   Copyright (C) 1986, 87, 89, 92-95, 1996, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92-96, 98, 1999 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987"}, {"sha": "2065833e20966e39f323b7110da268450ff139b8", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -4025,9 +4025,11 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  if (GET_CODE (op1) == AND)\n \t    {\n \t     if (rtx_equal_p (op0, XEXP (op1, 0)))\n-\t       return cse_gen_binary (AND, mode, op0, gen_rtx_NOT (mode, XEXP (op1, 1)));\n+\t       return cse_gen_binary (AND, mode, op0,\n+\t\t\t\t      gen_rtx_NOT (mode, XEXP (op1, 1)));\n \t     if (rtx_equal_p (op0, XEXP (op1, 1)))\n-\t       return cse_gen_binary (AND, mode, op0, gen_rtx_NOT (mode, XEXP (op1, 0)));\n+\t       return cse_gen_binary (AND, mode, op0,\n+\t\t\t\t      gen_rtx_NOT (mode, XEXP (op1, 0)));\n \t   }\n \t  break;\n \n@@ -4172,8 +4174,9 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\t  return gen_rtx_MULT (mode, op0, \n \t\t\t\t       CONST_DOUBLE_FROM_REAL_VALUE (d, mode));\n #else\n-\t\t  return gen_rtx_MULT (mode, op0, \n-\t\t\t\t       CONST_DOUBLE_FROM_REAL_VALUE (1./d, mode));\n+\t\t  return\n+\t\t    gen_rtx_MULT (mode, op0, \n+\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (1./d, mode));\n #endif\n \t\t}\n \t    }\n@@ -7212,9 +7215,10 @@ cse_insn (insn, libcall_insn)\n \t  && qty_first_reg[REG_QTY (REGNO (dest))] != REGNO (dest)\n \t  && GET_CODE (src) == REG && REGNO (src) == REGNO (dest)\n \t  /* Don't do this if the original insn had a hard reg as\n-\t     SET_SRC.  */\n+\t     SET_SRC or SET_DEST.  */\n \t  && (GET_CODE (sets[i].src) != REG\n-\t      || REGNO (sets[i].src) >= FIRST_PSEUDO_REGISTER))\n+\t      || REGNO (sets[i].src) >= FIRST_PSEUDO_REGISTER)\n+\t  && (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER))\n \t/* We can't call canon_reg here because it won't do anything if\n \t   SRC is a hard register.  */\n \t{\n@@ -7307,9 +7311,9 @@ cse_insn (insn, libcall_insn)\n \t\t  if (note)\n \t\t    XEXP (note, 0) = const_insn;\n \t\t  else\n-\t\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_WAS_0,\n-\t\t\t\t\t\t\t  const_insn,\n-\t\t\t\t\t\t\t  REG_NOTES (insn));\n+\t\t    REG_NOTES (insn)\n+\t\t      = gen_rtx_INSN_LIST (REG_WAS_0, const_insn,\n+\t\t\t\t\t   REG_NOTES (insn));\n \t\t}\n \t    }\n \t}\n@@ -8820,7 +8824,8 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n   qty_first_reg = (int *) alloca ((max_qty - max_reg) * sizeof (int));\n   qty_last_reg = (int *) alloca ((max_qty - max_reg) * sizeof (int));\n-  qty_mode= (enum machine_mode *) alloca ((max_qty - max_reg) * sizeof (enum machine_mode));\n+  qty_mode = (enum machine_mode *) alloca ((max_qty - max_reg)\n+\t\t\t\t\t   * sizeof (enum machine_mode));\n   qty_const = (rtx *) alloca ((max_qty - max_reg) * sizeof (rtx));\n   qty_const_insn = (rtx *) alloca ((max_qty - max_reg) * sizeof (rtx));\n   qty_comparison_code"}, {"sha": "91bef90b1ef7f8bb806823838f4d9c1bdaa1436b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -427,20 +427,20 @@ static void dwarf2out_frame_debug_expr\tPROTO((rtx, char *));\n \n #define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n   assemble_integer (gen_rtx_MINUS (HImode,\t\t\t      \t\\\n-\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL1),   \t\\\n-\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL1),  \\\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    2, 1)\n   \n #define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n   assemble_integer (gen_rtx_MINUS (SImode,\t\t\t      \t\\\n-\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL1),   \t\\\n-\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL1),  \\\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    4, 1)\n \n #define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n   assemble_integer (gen_rtx_MINUS (Pmode,\t\t\t\t\\\n-\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL1),\t\\\n-\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL1),\t\\\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    PTR_SIZE, 1)\n \n #define ASM_OUTPUT_DWARF_DELTA(FILE,LABEL1,LABEL2) \\\n@@ -7390,7 +7390,7 @@ add_bound_info (subrange_die, bound_attr, bound)\n \t      rtx new_addr = fix_lexical_addr (XEXP (loc, 0), bound);\n \n \t      if (XEXP (loc, 0) != new_addr)\n-\t\tloc = gen_rtx (MEM, GET_MODE (loc), new_addr);\n+\t\tloc = gen_rtx_MEM (GET_MODE (loc), new_addr);\n \t    }\n \n \t  add_AT_flag (decl_die, DW_AT_artificial, 1);"}, {"sha": "704629d253b1fc7ab52bdc38fa06730f0c05792b", "filename": "gcc/dyn-string.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -4,42 +4,42 @@\n \n This file is part of GNU CC.\n    \n-GNU CC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"dyn-string.h\"\n \n-/* Create a new dynamic string capable of holding at least SPACE\n-   characters, including the terminating NUL.  If SPACE is 0, it\n-   will be silently increased to 1.  */\n+/* Create a new dynamic string capable of holding at least SPACE characters,\n+   including the terminating NUL.  If SPACE is 0, it will be silently\n+   increased to 1.  */\n \n dyn_string_t \n dyn_string_new (space)\n      int space;\n {\n   dyn_string_t result = (dyn_string_t) xmalloc (sizeof (struct dyn_string));\n  \n+  /* We need at least one byte in which to store the terminating NUL.  */\n   if (space == 0)\n-    /* We need at least one byte in which to store the terminating\n-       NUL.  */\n     space = 1;\n \n   result->allocated = space;\n-  result->s = (char*) xmalloc (space);\n+  result->s = (char *) xmalloc (space);\n   result->length = 0;\n   result->s[0] = '\\0';\n \n@@ -56,25 +56,27 @@ dyn_string_delete (ds)\n   free (ds);\n }\n \n-/* Append the NUL-terminated string S to DS, resizing DS if\n-   necessary.  */\n+/* Append the NUL-terminated string S to DS, resizing DS if necessary.  */\n \n dyn_string_t \n dyn_string_append (ds, s)\n      dyn_string_t ds;\n      const char *s;\n {\n   int len = strlen (s);\n-  dyn_string_resize (ds, ds->length + len + 1 /* '\\0' */);\n+\n+  /* The new length is the old length plus the size of our string, plus\n+     one for the null at the end.  */\n+  dyn_string_resize (ds, ds->length + len + 1);\n   strcpy (ds->s + ds->length, s);\n   ds->length += len;\n \n   return ds;\n }\n \n-/* Increase the capacity of DS so that it can hold at least SPACE\n-   characters, including the terminating NUL.  This function will not\n-   (at present) reduce the capacity of DS.  */\n+/* Increase the capacity of DS so it can hold at least SPACE characters,\n+   including the terminating NUL.  This function will not (at present)\n+   reduce the capacity of DS.  */\n \n dyn_string_t \n dyn_string_resize (ds, space)\n@@ -90,7 +92,7 @@ dyn_string_resize (ds, space)\n     {\n       /* We actually need more space.  */\n       ds->allocated = new_allocated;\n-      ds->s = (char*) xrealloc (ds->s, ds->allocated);\n+      ds->s = (char *) xrealloc (ds->s, ds->allocated);\n     }\n \n   return ds;"}, {"sha": "50e00e70031d1a1cb517d2642b4fee4a231fc54d", "filename": "gcc/dyn-string.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -4,26 +4,27 @@\n \n This file is part of GNU CC.\n    \n-GNU CC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+\n typedef struct dyn_string\n {\n-  int allocated; /* The amount of space allocated for the string.  */\n-  int length; /* The actual length of the string.  */\n-  char *s; /* The string itself, NUL-terminated.  */\n+  int allocated;\t/* The amount of space allocated for the string.  */\n+  int length;\t\t/* The actual length of the string.  */\n+  char *s;\t\t/* The string itself, NUL-terminated.  */\n }* dyn_string_t;\n \n extern dyn_string_t dyn_string_new      PROTO((int));"}, {"sha": "5a4b5f2f02ae3b8ebea36ad6afb26523f6c5d323", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -187,6 +187,10 @@ static rtx make_call_insn_raw\t\tPROTO((rtx));\n static rtx find_line_note\t\tPROTO((rtx));\n static void mark_sequence_stack         PROTO((struct sequence_stack *));\n \f\n+/* There are some RTL codes that require special attention; the generation\n+   functions do the raw handling.  If you add to this list, modify\n+   special_rtx in gengenrtl.c as well.  */\n+\n rtx\n gen_rtx_CONST_INT (mode, arg)\n      enum machine_mode mode;\n@@ -247,21 +251,22 @@ gen_rtx_REG (mode, regno)\n \n   if (mode == Pmode && !reload_in_progress)\n     {\n-      if (regno == FRAME_POINTER_REGNUM)\n+      if (frame_pointer_rtx != 0 && regno == FRAME_POINTER_REGNUM)\n \treturn frame_pointer_rtx;\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      if (regno == HARD_FRAME_POINTER_REGNUM)\n+      if (hard_frame_pointer_rtx != 0 && regno == HARD_FRAME_POINTER_REGNUM)\n \treturn hard_frame_pointer_rtx;\n #endif\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM && HARD_FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-      if (regno == ARG_POINTER_REGNUM)\n+      if (arg_pointer_rtx != 0 && regno == ARG_POINTER_REGNUM)\n \treturn arg_pointer_rtx;\n #endif\n #ifdef RETURN_ADDRESS_POINTER_REGNUM\n-      if (regno == RETURN_ADDRESS_POINTER_REGNUM)\n+      if (return_address_pointer_rtx != 0\n+\t  && regno == RETURN_ADDRESS_POINTER_REGNUM)\n \treturn return_address_pointer_rtx;\n #endif\n-      if (regno == STACK_POINTER_REGNUM)\n+      if (stack_pointer_rtx != 0 && regno == STACK_POINTER_REGNUM)\n \treturn stack_pointer_rtx;\n     }\n \n@@ -281,7 +286,7 @@ gen_rtx_MEM (mode, addr)\n \n   return rt;\n }\n-\n+\f\n /* rtx gen_rtx (code, mode, [element1, ..., elementn])\n **\n **\t    This routine generates an RTX of the size specified by\n@@ -747,6 +752,9 @@ gen_lowpart_common (mode, x)\n \n       i = INTVAL (x);\n       r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n+      /* Avoid changing the bit pattern of a NaN.  */\n+      if (REAL_VALUE_ISNAN (r))\n+\treturn 0;\n       return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n     }\n #else\n@@ -785,6 +793,8 @@ gen_lowpart_common (mode, x)\n \ti[0] = low, i[1] = high;\n \n       r = REAL_VALUE_FROM_TARGET_DOUBLE (i);\n+      if (REAL_VALUE_ISNAN (r))\n+\treturn 0;\n       return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n     }\n #else\n@@ -1478,7 +1488,8 @@ reverse_comparison (insn)\n     }\n   else\n     {\n-      rtx new = gen_rtx_COMPARE (VOIDmode, CONST0_RTX (GET_MODE (comp)), comp);\n+      rtx new = gen_rtx_COMPARE (VOIDmode,\n+\t\t\t\t CONST0_RTX (GET_MODE (comp)), comp);\n       if (GET_CODE (body) == SET)\n \tSET_SRC (body) = new;\n       else\n@@ -2105,7 +2116,8 @@ link_cc0_insns (insn)\n   if (GET_CODE (user) == INSN && GET_CODE (PATTERN (user)) == SEQUENCE)\n     user = XVECEXP (PATTERN (user), 0, 0);\n \n-  REG_NOTES (user) = gen_rtx_INSN_LIST (REG_CC_SETTER, insn, REG_NOTES (user));\n+  REG_NOTES (user) = gen_rtx_INSN_LIST (REG_CC_SETTER, insn,\n+\t\t\t\t\tREG_NOTES (user));\n   REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_CC_USER, user, REG_NOTES (insn));\n }\n \n@@ -3541,6 +3553,8 @@ init_emit_once (line_numbers)\n \n   /* Create the unique rtx's for certain rtx codes and operand values.  */\n \n+  /* Don't use gen_rtx here since gen_rtx in this case\n+     tries to use these variables.  */\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n     {\n       PUT_CODE (&const_int_rtx[i + MAX_SAVED_CONST_INT], CONST_INT);\n@@ -3648,7 +3662,8 @@ init_emit_once (line_numbers)\n \n #ifdef STATIC_CHAIN_INCOMING_REGNUM\n   if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n-    static_chain_incoming_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n+    static_chain_incoming_rtx\n+      = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n   else\n #endif\n     static_chain_incoming_rtx = static_chain_rtx;"}, {"sha": "3af4c2c06a88fbb7f36ef33dcc8bc9d9eb30b771", "filename": "gcc/explow.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -215,7 +215,7 @@ plus_constant_for_output_wide (x, c)\n \n   if (GET_CODE (x) == LO_SUM)\n     return gen_rtx_LO_SUM (mode, XEXP (x, 0),\n-\t\t    plus_constant_for_output (XEXP (x, 1), c));\n+\t\t\t   plus_constant_for_output (XEXP (x, 1), c));\n \n   else\n     return plus_constant (x, c);\n@@ -1314,6 +1314,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n #else\n \ttarget = copy_to_mode_reg (Pmode, target);\n #endif\n+\n+      if (mode == VOIDmode)\n+\tmode = Pmode;\n+\n       size = convert_modes (mode, ptr_mode, size, 1);\n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][1]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][1])\n@@ -1420,10 +1424,10 @@ probe_stack_range (first, size)\n \n       if (insn_operand_predicate[(int) CODE_FOR_check_stack][0]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_check_stack][0])\n-\t\t(last_address, Pmode)))\n-\tlast_address = copy_to_mode_reg (Pmode, last_address);\n+\t\t(last_addr, Pmode)))\n+\tlast_addr = copy_to_mode_reg (Pmode, last_addr);\n \n-      emit_insn (gen_check_stack (last_address));\n+      emit_insn (gen_check_stack (last_addr));\n       return;\n     }\n #endif"}, {"sha": "2138ad189af5f3b0dc2a40212b96b37fbcdf925c", "filename": "gcc/expmed.c", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -66,8 +66,8 @@ static int sdiv_pow2_cheap, smod_pow2_cheap;\n #define MAX_BITS_PER_WORD BITS_PER_WORD\n #endif\n \n-/* Cost of various pieces of RTL.  Note that some of these are indexed by shift count,\n-   and some by mode.  */\n+/* Cost of various pieces of RTL.  Note that some of these are indexed by\n+   shift count and some by mode.  */\n static int add_cost, negate_cost, zero_cost;\n static int shift_cost[MAX_BITS_PER_WORD];\n static int shiftadd_cost[MAX_BITS_PER_WORD];\n@@ -96,7 +96,7 @@ init_expmed ()\n      makes.  */\n   free_point = (char *) oballoc (0);\n \n-  reg = gen_rtx (REG, word_mode, 10000);\n+  reg = gen_rtx_REG (word_mode, 10000);\n \n   zero_cost = rtx_cost (const0_rtx, 0);\n   add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n@@ -170,12 +170,13 @@ init_expmed ()\n \t  mul_highpart_cost[(int) mode]\n \t    = rtx_cost (gen_rtx_TRUNCATE\n \t\t\t(mode,\n-\t\t\t gen_rtx_LSHIFTRT\n-\t\t\t (wider_mode,\n-\t\t\t  gen_rtx_MULT (wider_mode,\n-\t\t\t\t\tgen_rtx_ZERO_EXTEND (wider_mode, reg),\n-\t\t\t\t\tgen_rtx_ZERO_EXTEND (wider_mode, reg)),\n-\t\t\t  GEN_INT (GET_MODE_BITSIZE (mode)))),\n+\t\t\t gen_rtx_LSHIFTRT (wider_mode,\n+\t\t\t\t\t   gen_rtx_MULT (wider_mode,\n+\t\t\t\t\t\t\t gen_rtx_ZERO_EXTEND\n+\t\t\t\t\t\t\t (wider_mode, reg),\n+\t\t\t\t\t\t\t gen_rtx_ZERO_EXTEND\n+\t\t\t\t\t\t\t (wider_mode, reg)),\n+\t\t\t\t\t   GEN_INT (GET_MODE_BITSIZE (mode)))),\n \t\t\tSET);\n \t}\n     }\n@@ -365,7 +366,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t    }\n \n \t  emit_insn (GEN_FCN (icode)\n-\t\t   (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n+\t\t     (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n \t}\n       return value;\n     }\n@@ -2419,15 +2420,17 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n \t\t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n-\t\t\t\t\t add_target ? add_target : accum_target);\n+\t\t\t\t\t add_target\n+\t\t\t\t\t ? add_target : accum_target);\n \t\t  val_so_far += (HOST_WIDE_INT) 1 << log;\n \t\t  break;\n \n \t\tcase alg_sub_t_m2:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n \t\t  accum = force_operand (gen_rtx_MINUS (mode, accum, tem),\n-\t\t\t\t\t add_target ? add_target : accum_target);\n+\t\t\t\t\t add_target\n+\t\t\t\t\t ? add_target : accum_target);\n \t\t  val_so_far -= (HOST_WIDE_INT) 1 << log;\n \t\t  break;\n \n@@ -2436,7 +2439,8 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t\t\t\tbuild_int_2 (log, 0), shift_subtarget,\n \t\t\t\t\t0);\n \t\t  accum = force_operand (gen_rtx_PLUS (mode, accum, op0),\n-\t\t\t\t\t add_target ? add_target : accum_target);\n+\t\t\t\t\t add_target\n+\t\t\t\t\t ? add_target : accum_target);\n \t\t  val_so_far = (val_so_far << log) + 1;\n \t\t  break;\n \n@@ -2445,15 +2449,17 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t\t\t\tbuild_int_2 (log, 0), shift_subtarget,\n \t\t\t\t\t0);\n \t\t  accum = force_operand (gen_rtx_MINUS (mode, accum, op0),\n-\t\t\t\t\t add_target ? add_target : accum_target);\n+\t\t\t\t\t add_target\n+\t\t\t\t\t ? add_target : accum_target);\n \t\t  val_so_far = (val_so_far << log) - 1;\n \t\t  break;\n \n \t\tcase alg_add_factor:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n \t\t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n-\t\t\t\t\t add_target ? add_target : accum_target);\n+\t\t\t\t\t add_target\n+\t\t\t\t\t ? add_target : accum_target);\n \t\t  val_so_far += val_so_far << log;\n \t\t  break;\n \n@@ -3279,11 +3285,15 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n \t\t\tif (d < 0)\n-\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t3, t2),\n-\t\t\t\t\t\t    tquotient);\n+\t\t\t  quotient\n+\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n+\t\t\t\t\t\t\t    t3, t2),\n+\t\t\t\t\t     tquotient);\n \t\t\telse\n-\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t2, t3),\n-\t\t\t\t\t\t    tquotient);\n+\t\t\t  quotient\n+\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n+\t\t\t\t\t\t\t    t2, t3),\n+\t\t\t\t\t     tquotient);\n \t\t      }\n \t\t    else\n \t\t      {\n@@ -3297,18 +3307,25 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n-\t\t\tt2 = force_operand (gen_rtx_PLUS (compute_mode, t1, op0),\n+\t\t\tt2 = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t\t  t1, op0),\n \t\t\t\t\t    NULL_RTX);\n \t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t   build_int_2 (post_shift, 0), NULL_RTX, 0);\n+\t\t\t\t\t   build_int_2 (post_shift, 0),\n+\t\t\t\t\t   NULL_RTX, 0);\n \t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\t\t\t\t   build_int_2 (size - 1, 0),\n+\t\t\t\t\t   NULL_RTX, 0);\n \t\t\tif (d < 0)\n-\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t4, t3),\n-\t\t\t\t\t\t    tquotient);\n+\t\t\t  quotient\n+\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n+\t\t\t\t\t\t\t    t4, t3),\n+\t\t\t\t\t     tquotient);\n \t\t\telse\n-\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t3, t4),\n-\t\t\t\t\t\t    tquotient);\n+\t\t\t  quotient\n+\t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n+\t\t\t\t\t\t\t    t3, t4),\n+\t\t\t\t\t     tquotient);\n \t\t      }\n \t\t  }\n \t\telse\t\t/* Too wide mode to use tricky code */\n@@ -4261,7 +4278,9 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \t     we don't have to do anything.  */\n \t  if (normalizep == 0 || normalizep == STORE_FLAG_VALUE)\n \t    ;\n-\t  else if (normalizep == - STORE_FLAG_VALUE)\n+\t  /* STORE_FLAG_VALUE might be the most negative number, so write\n+\t     the comparison this way to avoid a compiler-time warning.  */\n+\t  else if (- normalizep == STORE_FLAG_VALUE)\n \t    op0 = expand_unop (compare_mode, neg_optab, op0, subtarget, 0);\n \n \t  /* We don't want to use STORE_FLAG_VALUE < 0 below since this"}, {"sha": "2f014d345e1a4a9f6434b8afd64be7a8a8be5c15", "filename": "gcc/expr.c", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -98,11 +98,13 @@ struct move_by_pieces\n   int autinc_to;\n   int explicit_inc_to;\n   int to_struct;\n+  int to_readonly;\n   rtx from;\n   rtx from_addr;\n   int autinc_from;\n   int explicit_inc_from;\n   int from_struct;\n+  int from_readonly;\n   int len;\n   int offset;\n   int reverse;\n@@ -132,13 +134,14 @@ static int move_by_pieces_ninsns PROTO((unsigned int, int));\n static void move_by_pieces_1\tPROTO((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t       struct move_by_pieces *));\n static void clear_by_pieces\tPROTO((rtx, int, int));\n-static void clear_by_pieces_1\tPROTO((rtx (*) (rtx, ...), enum machine_mode,\n+static void clear_by_pieces_1\tPROTO((rtx (*) (rtx, ...),\n+\t\t\t\t       enum machine_mode,\n \t\t\t\t       struct clear_by_pieces *));\n static int is_zeros_p\t\tPROTO((tree));\n static int mostly_zeros_p\tPROTO((tree));\n static void store_constructor_field PROTO((rtx, int, int, enum machine_mode,\n-\t\t\t\t\t   tree, tree, int));\n-static void store_constructor\tPROTO((tree, rtx, int));\n+\t\t\t\t\t   tree, tree, int, int));\n+static void store_constructor\tPROTO((tree, rtx, int, int));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int,\n \t\t\t\t       int, int));\n@@ -309,9 +312,8 @@ static rtx\n enqueue_insn (var, body)\n      rtx var, body;\n {\n-  pending_chain = gen_rtx_QUEUED (GET_MODE (var),\n-\t\t\t\t  var, NULL_RTX, NULL_RTX, body,\n-\t\t\t\t  pending_chain);\n+  pending_chain = gen_rtx_QUEUED (GET_MODE (var), var, NULL_RTX, NULL_RTX,\n+\t\t\t\t  body, pending_chain);\n   return pending_chain;\n }\n \n@@ -1365,6 +1367,8 @@ move_by_pieces (to, from, len, align)\n \n   data.to_struct = MEM_IN_STRUCT_P (to);\n   data.from_struct = MEM_IN_STRUCT_P (from);\n+  data.to_readonly = RTX_UNCHANGING_P (to);\n+  data.from_readonly = RTX_UNCHANGING_P (from);\n \n   /* If copying requires more than two move insns,\n      copy addresses to registers (to make displacements shorter)\n@@ -1502,6 +1506,7 @@ move_by_pieces_1 (genfun, mode, data)\n \t\t\t\t\t plus_constant (data->to_addr,\n \t\t\t\t\t\t\tdata->offset))));\n       MEM_IN_STRUCT_P (to1) = data->to_struct;\n+      RTX_UNCHANGING_P (to1) = data->to_readonly;\n \n       from1\n \t= (data->autinc_from\n@@ -1510,6 +1515,7 @@ move_by_pieces_1 (genfun, mode, data)\n \t\t\t\t       plus_constant (data->from_addr,\n \t\t\t\t\t\t      data->offset))));\n       MEM_IN_STRUCT_P (from1) = data->from_struct;\n+      RTX_UNCHANGING_P (from1) = data->from_readonly;\n \n       if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n@@ -2731,7 +2737,7 @@ push_block (size, extra, below)\n \t\t    negate_rtx (Pmode, plus_constant (size, extra)));\n   else\n     temp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n-\t\t    negate_rtx (Pmode, size));\n+\t\t\t negate_rtx (Pmode, size));\n #endif\n \n   return memory_address (GET_CLASS_NARROWEST_MODE (MODE_INT), temp);\n@@ -3194,7 +3200,7 @@ rtx\n expand_assignment (to, from, want_value, suggest_reg)\n      tree to, from;\n      int want_value;\n-     int suggest_reg;\n+     int suggest_reg ATTRIBUTE_UNUSED;\n {\n   register rtx to_rtx = 0;\n   rtx result;\n@@ -3277,8 +3283,10 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n \t  to_rtx = change_address (to_rtx, VOIDmode,\n \t\t\t\t   gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n-\t\t\t\t\t\t force_reg (ptr_mode, offset_rtx)));\n+\t\t\t\t\t\t force_reg (ptr_mode,\n+\t\t\t\t\t\t\t    offset_rtx)));\n \t}\n+\n       if (volatilep)\n \t{\n \t  if (GET_CODE (to_rtx) == MEM)\n@@ -3925,7 +3933,7 @@ mostly_zeros_p (exp)\n /* Helper function for store_constructor.\n    TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.\n    TYPE is the type of the CONSTRUCTOR, not the element type.\n-   CLEARED is as for store_constructor.\n+   ALIGN and CLEARED are as for store_constructor.\n \n    This provides a recursive shortcut back to store_constructor when it isn't\n    necessary to go through store_field.  This is so that we can pass through\n@@ -3934,11 +3942,12 @@ mostly_zeros_p (exp)\n \n static void\n store_constructor_field (target, bitsize, bitpos,\n-\t\t\t mode, exp, type, cleared)\n+\t\t\t mode, exp, type, align, cleared)\n      rtx target;\n      int bitsize, bitpos;\n      enum machine_mode mode;\n      tree exp, type;\n+     int align;\n      int cleared;\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR\n@@ -3952,22 +3961,24 @@ store_constructor_field (target, bitsize, bitpos,\n \ttarget = change_address (target, VOIDmode,\n \t\t\t\t plus_constant (XEXP (target, 0),\n \t\t\t\t\t\tbitpos / BITS_PER_UNIT));\n-      store_constructor (exp, target, cleared);\n+      store_constructor (exp, target, align, cleared);\n     }\n   else\n-    store_field (target, bitsize, bitpos, mode, exp,\n-\t\t VOIDmode, 0, TYPE_ALIGN (type) / BITS_PER_UNIT,\n-\t\t int_size_in_bytes (type), 0);\n+    store_field (target, bitsize, bitpos, mode, exp, VOIDmode, 0, \n+\t\t (align + BITS_PER_UNIT - 1) / BITS_PER_UNIT,\n+\t\t int_size_in_bytes (type), cleared);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n    TARGET is either a REG or a MEM.\n+   ALIGN is the maximum known alignment for TARGET, in bits.\n    CLEARED is true if TARGET is known to have been zero'd.  */\n \n static void\n-store_constructor (exp, target, cleared)\n+store_constructor (exp, target, align, cleared)\n      tree exp;\n      rtx target;\n+     int align;\n      int cleared;\n {\n   tree type = TREE_TYPE (exp);\n@@ -4021,7 +4032,7 @@ store_constructor (exp, target, cleared)\n \t{\n \t  if (! cleared)\n \t    clear_storage (target, expr_size (exp),\n-\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\t\t\t   (align + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n \n \t  cleared = 1;\n \t}\n@@ -4035,7 +4046,9 @@ store_constructor (exp, target, cleared)\n       for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n \t{\n \t  register tree field = TREE_PURPOSE (elt);\n+#ifdef WORD_REGISTER_OPERATIONS\n \t  tree value = TREE_VALUE (elt);\n+#endif\n \t  register enum machine_mode mode;\n \t  int bitsize;\n \t  int bitpos = 0;\n@@ -4097,8 +4110,10 @@ store_constructor (exp, target, cleared)\n \t      to_rtx\n \t\t= change_address (to_rtx, VOIDmode,\n \t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n-\t\t\t\t\t   force_reg (ptr_mode, offset_rtx)));\n+\t\t\t\t\t\tforce_reg (ptr_mode,\n+\t\t\t\t\t\t\t   offset_rtx)));\n \t    }\n+\n \t  if (TREE_READONLY (field))\n \t    {\n \t      if (GET_CODE (to_rtx) == MEM)\n@@ -4135,8 +4150,11 @@ store_constructor (exp, target, cleared)\n \t      mode = word_mode;\n \t    }\n #endif\n-\t  store_constructor_field (to_rtx, bitsize, bitpos,\n-\t\t\t\t   mode, value, type, cleared);\n+\t  store_constructor_field (to_rtx, bitsize, bitpos, mode,\n+\t\t\t\t   TREE_VALUE (elt), type, \n+\t\t\t\t   MIN (align,\n+\t\t\t\t\tDECL_ALIGN (TREE_PURPOSE (elt))),\n+\t\t\t\t   cleared);\n \t}\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -4196,7 +4214,7 @@ store_constructor (exp, target, cleared)\n \t{\n \t  if (! cleared)\n \t    clear_storage (target, expr_size (exp),\n-\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\t\t\t   (align + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n \t  cleared = 1;\n \t}\n       else\n@@ -4215,6 +4233,7 @@ store_constructor (exp, target, cleared)\n \t  int bitpos;\n \t  int unsignedp;\n \t  tree value = TREE_VALUE (elt);\n+\t  int align = TYPE_ALIGN (TREE_TYPE (value));\n \t  tree index = TREE_PURPOSE (elt);\n \t  rtx xtarget = target;\n \n@@ -4250,8 +4269,8 @@ store_constructor (exp, target, cleared)\n \t\t  for (; lo <= hi; lo++)\n \t\t    {\n \t\t      bitpos = lo * TREE_INT_CST_LOW (TYPE_SIZE (elttype));\n-\t\t      store_constructor_field (target, bitsize, bitpos,\n-\t\t\t\t\t       mode, value, type, cleared);\n+\t\t      store_constructor_field (target, bitsize, bitpos, mode,\n+\t\t\t\t\t       value, type, align, cleared);\n \t\t    }\n \t\t}\n \t      else\n@@ -4290,7 +4309,7 @@ store_constructor (exp, target, cleared)\n \t\t  addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n \t\t  xtarget = change_address (target, mode, addr);\n \t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n-\t\t    store_constructor (value, xtarget, cleared);\n+\t\t    store_constructor (value, xtarget, align, cleared);\n \t\t  else\n \t\t    store_expr (value, xtarget, 0);\n \n@@ -4337,8 +4356,8 @@ store_constructor (exp, target, cleared)\n \t\t\t  * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n \t      else\n \t\tbitpos = (i * TREE_INT_CST_LOW (TYPE_SIZE (elttype)));\n-\t      store_constructor_field (target, bitsize, bitpos,\n-\t\t\t\t       mode, value, type, cleared);\n+\t      store_constructor_field (target, bitsize, bitpos, mode, value,\n+\t\t\t\t       type, align, cleared);\n \t    }\n \t}\n     }\n@@ -5641,6 +5660,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t\t label_rtx (exp),\n \t\t\t\t\t\t forced_labels);\n \t  }\n+\n \ttemp = gen_rtx_MEM (FUNCTION_MODE,\n \t\t\t    gen_rtx_LABEL_REF (Pmode, label_rtx (exp)));\n \tif (function != current_function_decl\n@@ -6171,7 +6191,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      RTX_UNCHANGING_P (target) = 1;\n \t    }\n \n-\t  store_constructor (exp, target, 0);\n+\t  store_constructor (exp, target, TYPE_ALIGN (TREE_TYPE (exp)), 0);\n \t  return target;\n \t}\n \n@@ -6475,7 +6495,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \t    op0 = change_address (op0, VOIDmode,\n \t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (op0, 0),\n-\t\t\t\t\t\tforce_reg (ptr_mode, offset_rtx)));\n+\t\t\t\t\t\tforce_reg (ptr_mode,\n+\t\t\t\t\t\t\t   offset_rtx)));\n \t  }\n \n \t/* Don't forget about volatility even if this is a bitfield.  */\n@@ -6486,8 +6507,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \t/* Check the access.  */\n-\tif (current_function && current_function_check_memory_usage\n-\t    && GET_CODE (op0) == MEM)\n+\tif (current_function_check_memory_usage && GET_CODE (op0) == MEM)\n           {\n \t    enum memory_use_mode memory_usage;\n \t    memory_usage = get_memory_usage_from_modifier (modifier);\n@@ -7092,19 +7112,23 @@ expand_expr (exp, target, tmode, modifier)\n \t  /* Apply distributive law if OP0 is x+c.  */\n \t  if (GET_CODE (op0) == PLUS\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n-\t    return gen_rtx_PLUS (mode,\n-\t\t\t\t gen_rtx_MULT (mode, XEXP (op0, 0),\n-\t\t\t\t\t       GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n-\t\t\t    GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n-\t\t\t\t     * INTVAL (XEXP (op0, 1))));\n+\t    return\n+\t      gen_rtx_PLUS\n+\t\t(mode,\n+\t\t gen_rtx_MULT\n+\t\t (mode, XEXP (op0, 0),\n+\t\t  GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n+\t\t GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n+\t\t\t  * INTVAL (XEXP (op0, 1))));\n \n \t  if (GET_CODE (op0) != REG)\n \t    op0 = force_operand (op0, NULL_RTX);\n \t  if (GET_CODE (op0) != REG)\n \t    op0 = copy_to_mode_reg (mode, op0);\n \n-\t  return gen_rtx_MULT (mode, op0,\n-\t\t\t       GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n+\t  return\n+\t    gen_rtx_MULT (mode, op0,\n+\t\t\t  GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n \t}\n \n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n@@ -7974,10 +7998,9 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  op0 = protect_from_queue (op0, 0);\n \n-\t  /* We would like the object in memory.  If it is a constant,\n-\t     we can have it be statically allocated into memory.  For\n-\t     a non-constant (REG, SUBREG or CONCAT), we need to allocate some\n-\t     memory and store the value into it.  */\n+\t  /* We would like the object in memory.  If it is a constant, we can\n+\t     have it be statically allocated into memory.  For a non-constant,\n+\t     we need to allocate some memory and store the value into it.  */\n \n \t  if (CONSTANT_P (op0))\n \t    op0 = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),"}, {"sha": "cea80725e3add3b79c607e69b8e15434d89225c3", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -945,7 +945,7 @@ extern rtx clear_storage PROTO((rtx, rtx, int));\n extern rtx emit_move_insn PROTO((rtx, rtx));\n \n /* Emit insns to set X from Y, with no frills.  */\n-extern rtx emit_move_insn_1 PROTO ((rtx, rtx));\n+extern rtx emit_move_insn_1 PROTO((rtx, rtx));\n \n /* Push a block of length SIZE (perhaps variable)\n    and return an rtx to address the beginning of the block.  */"}, {"sha": "8a3a7e725c94f7c1529466c74cd85a218aea9eb3", "filename": "gcc/extend.texi", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988,89,92,93,94,96,99 Free Software Foundation, Inc.\n+@c Copyright (C) 1988,89,92,93,94,96,98, 99 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -114,6 +114,7 @@ C++ Language}, for extensions that apply @emph{only} to C++.\n \t\t\t function.\n * Return Address::      Getting the return or frame address of a function.\n * Deprecated Features:: Things might disappear from g++.\n+* Other Builtins::      Other built-in functions.\n @end menu\n @end ifclear\n \n@@ -811,7 +812,8 @@ them as a single variable with a complex type.\n @node Hex Floats\n @section Hex Floats\n @cindex hex floats\n-GNU CC recognizes floating-point numbers written not only in the usual\n+\n+GNU CC recognizes floating-point numbers writen not only in the usual\n decimal notation, such as @code{1.55e1}, but also numbers such as\n @code{0x1.fp3} written in hexadecimal format.  In that format the\n @code{0x} hex introducer and the @code{p} or @code{P} exponent field are\n@@ -1555,16 +1557,19 @@ Not all target machines support this attribute.\n \n @item no_check_memory_usage\n @cindex @code{no_check_memory_usage} function attribute\n-If @samp{-fcheck-memory-usage} is given, calls to support routines will\n-be generated before most memory accesses, to permit support code to\n-record usage and detect uses of uninitialized or unallocated storage.\n-Since the compiler cannot handle them properly, @code{asm} statements\n-are not allowed.  Declaring a function with this attribute disables the\n+The @code{no_check_memory_usage} attribute causes GNU CC to omit checks\n+of memory references when it generates code for that function.  Normally\n+if you specify @samp{-fcheck-memory-usage} (see @pxref{Code Gen\n+Options}), GNU CC generates calls to support routines before most memory\n+accesses to permit support code to record usage and detect uses of\n+uninitialized or unallocated storage.  Since GNU CC cannot handle\n+@code{asm} statements properly they are not allowed in such functions.\n+If you declare a function with this attribute, GNU CC will not generate\n memory checking code for that function, permitting the use of @code{asm}\n-statements without requiring separate compilation with different\n-options, and allowing you to write support routines of your own if you\n-wish, without getting infinite recursion if they get compiled with this\n-option.\n+statements without having to compile that function with different\n+options.  This also allows you to write support routines of your own if\n+you wish, without getting infinite recursion if they get compiled with\n+@code{-fcheck-memory-usage}.\n \n @item regparm (@var{number})\n @cindex functions that are passed arguments in registers on the 386\n@@ -2445,13 +2450,15 @@ asm volatile (\"movc3 %0,%1,%2\"\n               : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\");\n @end example\n \n-It is an error for a clobber description to overlap an input or output\n-operand (for example, an operand describing a register class with one\n-member, mentioned in the clobber list).  Most notably, it is invalid to\n-describe that an input operand is modified, but unused as output.  It has\n-to be specified as an input and output operand anyway.  Note that if there\n-are only unused output operands, you will then also need to specify\n-@code{volatile} for the @code{asm} construct, as described below.\n+You may not write a clobber description in a way that overlaps with an\n+input or output operand.  For example, you may not have an operand\n+describing a register class with one member if you mention that register\n+in the clobber list.  There is no way for you to specify that an input\n+operand is modified without also specifying it as an output\n+operand.  Note that if all the output operands you specify are for this\n+purpose (and hence unused), you will then also need to specify\n+@code{volatile} for the @code{asm} construct, as described below, to\n+prevent GNU CC from deleting the @code{asm} statement as unused.\n \n If you refer to a particular hardware register from the assembler code,\n you will probably have to list the register after the third colon to"}, {"sha": "706a308fa21c241c2de8c3814d3afb04e35a71e4", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -425,9 +425,11 @@ end_final (filename)\n       if (write_symbols != NO_DEBUG && profile_block_flag)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 5);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes, 1);\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n+\t\t\t    pointer_bytes, 1);\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 6);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes, 1);\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n+\t\t\t    pointer_bytes, 1);\n \t}\n       else\n \t{"}, {"sha": "9ee464022a3b0c372dec792c628baee51dd4ba1d", "filename": "gcc/flow.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -134,6 +134,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n \n #include \"obstack.h\"\n+\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -4450,6 +4451,14 @@ print_rtl_with_bb (outf, rtx_first)\n \t    putc ('\\n', outf);\n \t}\n     }\n+\n+  if (current_function_epilogue_delay_list != 0)\n+    {\n+      fprintf (outf, \"\\n;; Insns in epilogue delay list:\\n\\n\");\n+      for (tmp_rtx = current_function_epilogue_delay_list; tmp_rtx != 0;\n+\t   tmp_rtx = XEXP (tmp_rtx, 1))\n+\tprint_rtl_single (outf, XEXP (tmp_rtx, 0));\n+    }\n }\n \n \f"}, {"sha": "d3a7696413d37d7ac86ca99287cef756c9717766", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -3603,7 +3603,7 @@ fold_range_test (exp)\n \t\t      TREE_TYPE (exp), TREE_OPERAND (exp, 0),\n \t\t      TREE_OPERAND (exp, 1));\n \n-      else if (current_function_decl != 0\n+      else if (global_bindings_p () == 0\n \t       && ! contains_placeholder_p (lhs))\n \t{\n \t  tree common = save_expr (lhs);\n@@ -4352,7 +4352,7 @@ fold (expr)\n \t       && (TREE_CODE (arg0) != COND_EXPR\n \t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg0)\n-\t\t   || (current_function_decl != 0\n+\t\t   || (global_bindings_p () == 0\n \t\t       && ! contains_placeholder_p (arg0))))\n \t{\n \t  tree test, true_value, false_value;\n@@ -4387,7 +4387,7 @@ fold (expr)\n \t     in that case.  */\n \n \t  if (TREE_CODE (arg0) != SAVE_EXPR && ! TREE_CONSTANT (arg0)\n-\t      && current_function_decl != 0\n+\t      && global_bindings_p () == 0\n \t      && ((TREE_CODE (arg0) != VAR_DECL\n \t\t   && TREE_CODE (arg0) != PARM_DECL)\n \t\t  || TREE_SIDE_EFFECTS (arg0)))\n@@ -4427,7 +4427,7 @@ fold (expr)\n \t       && (TREE_CODE (arg1) != COND_EXPR\n \t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg1)\n-\t\t   || (current_function_decl != 0\n+\t\t   || (global_bindings_p () == 0\n \t\t       && ! contains_placeholder_p (arg1))))\n \t{\n \t  tree test, true_value, false_value;\n@@ -4448,7 +4448,7 @@ fold (expr)\n \t    }\n \n \t  if (TREE_CODE (arg1) != SAVE_EXPR && ! TREE_CONSTANT (arg0)\n-\t      && current_function_decl != 0\n+\t      && global_bindings_p () == 0\n \t      && ((TREE_CODE (arg1) != VAR_DECL\n \t\t   && TREE_CODE (arg1) != PARM_DECL)\n \t\t  || TREE_SIDE_EFFECTS (arg1)))\n@@ -5072,7 +5072,7 @@ fold (expr)\n \t  if (real_onep (arg1))\n \t    return non_lvalue (convert (type, arg0));\n \t  /* x*2 is x+x */\n-\t  if (! wins && real_twop (arg1) && current_function_decl != 0\n+\t  if (! wins && real_twop (arg1) && global_bindings_p () == 0\n \t      && ! contains_placeholder_p (arg0))\n \t    {\n \t      tree arg = save_expr (arg0);\n@@ -6582,54 +6582,40 @@ fold (expr)\n     } /* switch (code) */\n }\n \n-/* Determine if first argument is a multiple of second argument.\n-   Return 0 if it is not, or is not easily determined to so be.\n+/* Determine if first argument is a multiple of second argument.  Return 0 if\n+   it is not, or we cannot easily determined it to be.\n \n-   An example of the sort of thing we care about (at this point --\n-   this routine could surely be made more general, and expanded\n-   to do what the *_DIV_EXPR's fold() cases do now) is discovering\n-   that\n+   An example of the sort of thing we care about (at this point; this routine\n+   could surely be made more general, and expanded to do what the *_DIV_EXPR's\n+   fold cases do now) is discovering that\n \n      SAVE_EXPR (I) * SAVE_EXPR (J * 8)\n \n    is a multiple of\n \n      SAVE_EXPR (J * 8)\n \n-   when we know that the two `SAVE_EXPR (J * 8)' nodes are the\n-   same node (which means they will have the same value at run\n-   time, even though we don't know when they'll be assigned).\n+   when we know that the two SAVE_EXPR (J * 8) nodes are the same node.\n \n    This code also handles discovering that\n \n      SAVE_EXPR (I) * SAVE_EXPR (J * 8)\n \n-   is a multiple of\n-\n-     8\n-\n-   (of course) so we don't have to worry about dealing with a\n+   is a multiple of 8 so we don't have to worry about dealing with a\n    possible remainder.\n \n-   Note that we _look_ inside a SAVE_EXPR only to determine\n-   how it was calculated; it is not safe for fold() to do much\n-   of anything else with the internals of a SAVE_EXPR, since\n-   fold() cannot know when it will be evaluated at run time.\n-   For example, the latter example above _cannot_ be implemented\n-   as\n-\n-     SAVE_EXPR (I) * J\n-\n-   or any variant thereof, since the value of J at evaluation time\n-   of the original SAVE_EXPR is not necessarily the same at the time\n-   the new expression is evaluated.  The only optimization of this\n+   Note that we *look* inside a SAVE_EXPR only to determine how it was\n+   calculated; it is not safe for fold to do much of anything else with the\n+   internals of a SAVE_EXPR, since it cannot know when it will be evaluated\n+   at run time.  For example, the latter example above *cannot* be implemented\n+   as SAVE_EXPR (I) * J or any variant thereof, since the value of J at\n+   evaluation time of the original SAVE_EXPR is not necessarily the same at\n+   the time the new expression is evaluated.  The only optimization of this\n    sort that would be valid is changing\n \n      SAVE_EXPR (I) * SAVE_EXPR (SAVE_EXPR (J) * 8)\n-   divided by\n-     8\n \n-   to\n+   divided by 8 to\n \n      SAVE_EXPR (I) * SAVE_EXPR (J)\n \n@@ -6660,12 +6646,14 @@ multiple_of_p (type, top, bottom)\n \t      && multiple_of_p (type, TREE_OPERAND (top, 1), bottom));\n \n     case NOP_EXPR:\n-      /* Punt if conversion from non-integral or wider integral type.  */\n+      /* Can't handle conversions from non-integral or wider integral type.  */\n       if ((TREE_CODE (TREE_TYPE (TREE_OPERAND (top, 0))) != INTEGER_TYPE)\n \t  || (TYPE_PRECISION (type)\n \t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (top, 0)))))\n \treturn 0;\n-      /* Fall through. */\n+\n+      /* .. fall through ... */\n+\n     case SAVE_EXPR:\n       return multiple_of_p (type, TREE_OPERAND (top, 0), bottom);\n \n@@ -6681,4 +6669,3 @@ multiple_of_p (type, top, bottom)\n       return 0;\n     }\n }\n-\f"}, {"sha": "320c0944176247752db5bbaec0e4a0029dd584d3", "filename": "gcc/function.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1419,7 +1419,7 @@ find_fixup_replacement (replacements, x)\n   struct fixup_replacement *p;\n \n   /* See if we have already replaced this.  */\n-  for (p = *replacements; p && p->old != x; p = p->next)\n+  for (p = *replacements; p != 0 && ! rtx_equal_p (p->old, x); p = p->next)\n     ;\n \n   if (p == 0)\n@@ -2045,7 +2045,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t    pos %= GET_MODE_BITSIZE (wanted_mode);\n \n \t\t    newmem = gen_rtx_MEM (wanted_mode,\n-\t\t\t\t\t  plus_constant (XEXP (tem, 0), offset));\n+\t\t\t\t\t  plus_constant (XEXP (tem, 0),\n+\t\t\t\t\t\t\t offset));\n \t\t    RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (tem);\n \t\t    MEM_COPY_ATTRIBUTES (newmem, tem);\n \n@@ -2693,12 +2694,22 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \n   code = GET_CODE (x);\n \n-  if (code == ADDRESSOF && GET_CODE (XEXP (x, 0)) == MEM)\n+  /* If we don't return in any of the cases below, we will recurse inside\n+     the RTX, which will normally result in any ADDRESSOF being forced into\n+     memory.  */\n+  if (code == SET)\n+    {\n+      purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);\n+      purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);\n+      return;\n+    }\n+\n+  else if (code == ADDRESSOF && GET_CODE (XEXP (x, 0)) == MEM)\n     {\n-      rtx insns;\n       /* We must create a copy of the rtx because it was created by\n \t overwriting a REG rtx which is always shared.  */\n       rtx sub = copy_rtx (XEXP (XEXP (x, 0), 0));\n+      rtx insns;\n \n       if (validate_change (insn, loc, sub, 0)\n \t  || validate_replace_rtx (x, sub, insn))\n@@ -2715,6 +2726,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n       emit_insn_before (insns, insn);\n       return;\n     }\n+\n   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)\n     {\n       rtx sub = XEXP (XEXP (x, 0), 0);\n@@ -2727,13 +2739,9 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t  RTX_UNCHANGING_P (sub2) = RTX_UNCHANGING_P (sub);\n \t  sub = sub2;\n \t}\n-\n-      if (GET_CODE (sub) == REG\n-\t  && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n-\t{\n-\t  put_addressof_into_stack (XEXP (x, 0), ht);\n-\t  return;\n-\t}\n+      else if (GET_CODE (sub) == REG\n+\t       && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n+\t;\n       else if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n \t{\n \t  int size_x, size_sub;\n@@ -2890,6 +2898,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t      return;\n \t    }\n \t}\n+\n       else if (validate_change (insn, loc, sub, 0))\n \t{\n \t  /* Remember the replacement so that the same one can be done\n@@ -2917,6 +2926,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n     give_up:;\n       /* else give up and put it into the stack */\n     }\n+\n   else if (code == ADDRESSOF)\n     {\n       put_addressof_into_stack (x, ht);\n@@ -5925,7 +5935,8 @@ expand_function_start (subr, parms_have_cleanups)\n \t  last_ptr = plus_constant (last_ptr, - GET_MODE_SIZE (Pmode));\n #endif\n \t  last_ptr = copy_to_reg (gen_rtx_MEM (Pmode,\n-\t\t\t\t\t       memory_address (Pmode, last_ptr)));\n+\t\t\t\t\t       memory_address (Pmode,\n+\t\t\t\t\t\t\t       last_ptr)));\n \n \t  /* If we are not optimizing, ensure that we know that this\n \t     piece of context is live over the entire function.  */"}, {"sha": "0923eb1b7f104eea7b115e6ce39fd1ad6d727b70", "filename": "gcc/gansidecl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgansidecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgansidecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgansidecl.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -76,6 +76,10 @@ Boston, MA 02111-1307, USA.  */\n #define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)\n #endif /* ATTRIBUTE_PRINTF */\n \n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n #define GENERIC_PTR PTR\n \n #ifndef NULL_PTR"}, {"sha": "1b7638f4ff13550eeabaeb8d9c65515d874161c6", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -30,11 +30,11 @@ and deleting the temporary files at the end.\n CC recognizes how to compile each input file by suffixes in the file names.\n Once it knows which kind of compilation to perform, the procedure for\n compilation is specified by a string called a \"spec\".  */\n-\f\n+\n+\n #include \"config.h\"\n #include \"system.h\"\n #include <signal.h>\n-\n #include \"obstack.h\"\n #include \"intl.h\"\n #include \"prefix.h\""}, {"sha": "fcec762d06ca15e2c782661f81495587e60c642f", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* gen-protos.c - massages a list of prototypes, for use by fixproto.\n-   Copyright (C) 1993, 94-96, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 94-96, 1998, 1999 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the"}, {"sha": "23d06787d9c792cde768c2791fc5a33ec3992096", "filename": "gcc/gencodes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,4 @@\n /* Generate from machine description:\n-\n    - some macros CODE_FOR_... giving the insn_code_number value\n    for each of the defined standard insn names.\n    Copyright (C) 1987, 1991, 1995, 1998, 1999 Free Software Foundation, Inc."}, {"sha": "a40b6b3f05a0f8687b1f69267b3c73586af3e551", "filename": "gcc/genconfig.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -42,6 +42,7 @@ static int max_clobbers_per_insn;\n static int register_constraint_flag;\n static int have_cc0_flag;\n static int have_cmove_flag;\n+static int have_cond_arith_flag;\n static int have_lo_sum_flag;\n static int have_peephole_flag;\n static int have_peephole2_flag;\n@@ -135,12 +136,21 @@ walk_insn_part (part, recog_p, non_pc_set_src)\n \t two arms of the IF_THEN_ELSE are both MATCH_OPERAND.  Otherwise,\n \t we have some specific IF_THEN_ELSE construct (like the doz\n \t instruction on the RS/6000) that can't be used in the general\n-\t context we want it for.  */\n+\t context we want it for.  If the first operand is an arithmetic\n+\t operation and the second is a MATCH_OPERNAND, show we have\n+\t conditional arithmetic.  */\n \n       if (recog_p && non_pc_set_src\n \t  && GET_CODE (XEXP (part, 1)) == MATCH_OPERAND\n \t  && GET_CODE (XEXP (part, 2)) == MATCH_OPERAND)\n \thave_cmove_flag = 1;\n+      else if (recog_p && non_pc_set_src\n+\t       && (GET_RTX_CLASS (GET_CODE (XEXP (part, 1))) == '1'\n+\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (part, 1))) == '2'\n+\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (part, 1))) == 'c')\n+\t       && GET_CODE (XEXP (XEXP (part, 1), 0)) == MATCH_OPERAND\n+\t       && GET_CODE (XEXP (part, 2)) == MATCH_OPERAND)\n+\thave_cond_arith_flag = 1;\n       break;\n \n     case REG: case CONST_INT: case SYMBOL_REF:\n@@ -345,6 +355,9 @@ from the machine description file `md'.  */\\n\\n\");\n   if (have_cmove_flag)\n     printf (\"#define HAVE_conditional_move\\n\");\n \n+  if (have_cond_arith_flag)\n+    printf (\"#define HAVE_conditional_arithmetic\\n\");\n+\n   if (have_lo_sum_flag)\n     printf (\"#define HAVE_lo_sum\\n\");\n "}, {"sha": "4bdb1513b90375e3651ae9350fc8e758b314f7df", "filename": "gcc/genemit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -401,7 +401,9 @@ gen_insn (insn)\n     }\n   else\n     {\n-      printf (\"  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (%d\", XVECLEN (insn, 1));\n+      printf (\"  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (%d\",\n+\t      XVECLEN (insn, 1));\n+\n       for (i = 0; i < XVECLEN (insn, 1); i++)\n \t{\n \t  printf (\",\\n\\t\\t\");"}, {"sha": "d8dbf8791ed9bc9f14d94f5d869f201f39ff6e6c", "filename": "gcc/genflags.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,4 @@\n /* Generate from machine description:\n-\n    - some flags HAVE_... saying which simple standard instructions are\n    available for this machine.\n    Copyright (C) 1987, 1991, 1995, 1998, 1999 Free Software Foundation, Inc."}, {"sha": "e6d932cbd46a84c67f7028d887f788118db198f7", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 143, "deletions": 131, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -62,18 +62,18 @@ struct rtx_definition defs[] =\n \n const char *formats[NUM_RTX_CODE];\n \n-static const char *type_from_format PROTO((int));\n-static const char *accessor_from_format PROTO((int));\n-static int special_format PROTO((const char *));\n-static int special_rtx PROTO((int));\n-static void find_formats PROTO((void));\n-static void gendecl PROTO((FILE *, const char *));\n-static void genmacro PROTO((FILE *, int));\n-static void gendef PROTO((FILE *, const char *));\n-static void genlegend PROTO((FILE *));\n-static void genheader PROTO((FILE *));\n-static void gencode PROTO((FILE *));\n-\n+static const char *type_from_format\tPROTO((int));\n+static const char *accessor_from_format\tPROTO((int));\n+static int special_format\t\tPROTO((const char *));\n+static int special_rtx\t\t\tPROTO((int));\n+static void find_formats\t\tPROTO((void));\n+static void gendecl\t\t\tPROTO((const char *));\n+static void genmacro\t\t\tPROTO((int));\n+static void gendef\t\t\tPROTO((const char *));\n+static void genlegend\t\t\tPROTO((void));\n+static void genheader\t\t\tPROTO((void));\n+static void gencode\t\t\tPROTO((void));\n+\f\n /* Decode a format letter into a C type string.  */\n \n static const char *\n@@ -83,16 +83,19 @@ type_from_format (c)\n   switch (c)\n     {\n     case 'i':\n-      return \"int\";\n+      return \"int \";\n+\n     case 'w':\n-      return \"HOST_WIDE_INT\";\n+      return \"HOST_WIDE_INT \";\n+\n     case 's':\n       return \"char *\";\n-    case 'e':\n-    case 'u':\n-      return \"rtx\";\n+\n+    case 'e':  case 'u':\n+      return \"rtx \";\n+\n     case 'E':\n-      return \"rtvec\";\n+      return \"rtvec \";\n     case 'b':\n       return \"struct bitmap_head_def *\";  /* bitmap - typedef not available */\n     case 't':\n@@ -112,25 +115,32 @@ accessor_from_format (c)\n     {\n     case 'i':\n       return \"XINT\";\n+\n     case 'w':\n       return \"XWINT\";\n+\n     case 's':\n       return \"XSTR\";\n-    case 'e':\n-    case 'u':\n+\n+    case 'e':  case 'u':\n       return \"XEXP\";\n+\n     case 'E':\n       return \"XVEC\";\n+\n     case 'b':\n       return \"XBITMAP\";\n+\n     case 't':\n       return \"XTREE\";\n+\n     default:\n       abort ();\n     }\n }\n \n-/* Return true if a format character doesn't need normal processing.  */\n+/* Return nonzero if we should ignore FMT, an RTL format, when making\n+   the list of formats we write routines to create.  */\n \n static int\n special_format (fmt)\n@@ -142,7 +152,9 @@ special_format (fmt)\n \t  || strchr (fmt, 'n') != 0);\n }\n \n-/* Return true if an rtx requires special processing.  */\n+/* Return nonzero if the RTL code given by index IDX is one that we should not\n+   generate a gen_RTX_FOO function foo (because that function is present\n+   elsewhere in the compiler.  */\n \n static int\n special_rtx (idx)\n@@ -154,170 +166,182 @@ special_rtx (idx)\n \t  || strcmp (defs[idx].enumname, \"MEM\") == 0);\n }\n \n-/* Fill `formats' with all unique format strings.  */\n+/* Place a list of all format specifiers we use into the array FORMAT. */\n \n static void\n find_formats ()\n {\n   int i;\n \n-  for (i = 0; i < NUM_RTX_CODE; ++i)\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n     {\n       const char **f;\n \n       if (special_format (defs[i].format))\n \tcontinue;\n \n-      for (f = formats; *f ; ++f)\n+      for (f = formats; *f; f++)\n \tif (! strcmp (*f, defs[i].format))\n \t  break;\n \n-      if (!*f)\n+      if (*f == 0)\n \t*f = defs[i].format;\n     }\n }\n \n-/* Emit a prototype for the rtx generator for a format.  */\n+/* Write the declarations for the routine to allocate RTL with FORMAT.  */\n \n static void\n-gendecl (f, format)\n-     FILE *f;\n+gendecl (format)\n      const char *format;\n {\n   const char *p;\n-  int i;\n+  int i, pos;\n   \n-  fprintf (f, \"extern rtx gen_rtx_fmt_%s PROTO((RTX_CODE, enum machine_mode mode\",\n-\t   format);\n-  for (p = format, i = 0; *p ; ++p)\n+  printf (\"extern rtx gen_rtx_fmt_%s\\tPROTO((RTX_CODE, \", format);\n+  printf (\"enum machine_mode mode\");\n+\n+  /* Write each parameter that is needed and start a new line when the line\n+     would overflow.  */\n+  for (p = format, i = 0, pos = 75; *p != 0; p++)\n     if (*p != '0')\n-      fprintf (f, \", %s arg%d\", type_from_format (*p), i++);\n-  fprintf (f, \"));\\n\");\n+      {\n+\tint ourlen = strlen (type_from_format (*p)) + 6 + (i > 9);\n+\n+\tprintf (\",\");\n+\tif (pos + ourlen > 76)\n+\t  printf (\"\\n\\t\\t\\t\\t      \"), pos = 39;\n+\n+\tprintf (\" %sarg%d\", type_from_format (*p), i++);\n+\tpos += ourlen;\n+      }\n+\n+  printf (\"));\\n\");\n }\n \n-/* Emit a define mapping an rtx code to the generator for its format.  */\n+/* Generate macros to generate RTL of code IDX using the functions we\n+   write.  */\n \n static void \n-genmacro (f, idx)\n-     FILE *f;\n+genmacro (idx)\n      int idx;\n {\n   const char *p;\n   int i;\n \n-  fprintf (f, \"#define gen_rtx_%s%s(mode\",\n-\t   (special_rtx (idx) ? \"raw_\" : \"\"), defs[idx].enumname);\n+  /* We write a macro that defines gen_rtx_RTLCODE to be an equivalent to\n+     gen_rtx_fmt_FORMAT where FORMAT is the RTX_FORMAT of RTLCODE.  */\n \n-  for (p = defs[idx].format, i = 0; *p ; ++p)\n+  printf (\"#define gen_rtx_%s%s(MODE\",\n+\t   special_rtx (idx) ? \"raw_\" : \"\", defs[idx].enumname);\n+\n+  for (p = defs[idx].format, i = 0; *p != 0; p++)\n     if (*p != '0')\n-      fprintf (f, \", arg%d\", i++);\n-  fprintf (f, \")   \");\n+      printf (\", ARG%d\", i++);\n+\n+  printf (\") \\\\\\n  gen_rtx_fmt_%s (%s, (MODE)\",\n+\t  defs[idx].format, defs[idx].enumname);\n \n-  fprintf (f, \"gen_rtx_fmt_%s(%s,(mode)\", defs[idx].format, defs[idx].enumname);\n-  for (p = defs[idx].format, i = 0; *p ; ++p)\n+  for (p = defs[idx].format, i = 0; *p != 0; p++)\n     if (*p != '0')\n-      fprintf (f, \",(arg%d)\", i++);\n-  fprintf (f, \")\\n\");\n+      printf (\", (ARG%d)\", i++);\n+\n+  printf (\")\\n\");\n }\n \n-/* Emit the implementation for the rtx generator for a format.  */\n+/* Generate the code for the function to generate RTL whose\n+   format is FORMAT.  */\n \n static void\n-gendef (f, format)\n-     FILE *f;\n+gendef (format)\n      const char *format;\n {\n   const char *p;\n   int i, j;\n   \n-  fprintf (f, \"rtx\\ngen_rtx_fmt_%s (code, mode\", format);\n-  for (p = format, i = 0; *p ; ++p)\n-    if (*p != '0')\n-      fprintf (f, \", arg%d\", i++);\n+  /* Start by writing the definition of the function name and the types\n+     of the arguments.  */\n \n-  fprintf (f, \")\\n     RTX_CODE code;\\n     enum machine_mode mode;\\n\");\n-  for (p = format, i = 0; *p ; ++p)\n+  printf (\"rtx\\ngen_rtx_fmt_%s (code, mode\", format);\n+  for (p = format, i = 0; *p != 0; p++)\n     if (*p != '0')\n-      fprintf (f, \"     %s arg%d;\\n\", type_from_format (*p), i++);\n+      printf (\", arg%d\", i++);\n \n-  /* See rtx_alloc in rtl.c for comments.  */\n-  fprintf (f, \"{\\n\");\n-  fprintf (f, \"  rtx rt;\\n\");\n-  fprintf (f, \"  if (ggc_p)\\n\");\n-  fprintf (f, \"    rt = ggc_alloc_rtx (%d);\\n\", \n+  printf (\")\\n     RTX_CODE code;\\n     enum machine_mode mode;\\n\");\n+  for (p = format, i = 0; *p != 0; p++)\n+    if (*p != '0')\n+      printf (\"     %sarg%d;\\n\", type_from_format (*p), i++);\n+\n+  /* Now write out the body of the function itself, which allocates\n+     the memory and initializes it.  */\n+  printf (\"{\\n\");\n+  printf (\"  rtx rt;\\n\");\n+  printf (\"  if (ggc_p)\\n\");\n+  printf (\"    rt = ggc_alloc_rtx (%d);\\n\", \n \t   (int) strlen (format));\n-  fprintf (f, \"  else\\n\");\n-  fprintf (f, \"    rt = obstack_alloc_rtx (sizeof (struct rtx_def) + %d * sizeof (rtunion));\\n\",\n+  printf (\"  else\\n\");\n+  printf (\"    rt = obstack_alloc_rtx (sizeof (struct rtx_def) + %d * sizeof (rtunion));\\n\",\n \t   (int) strlen (format) - 1);\n \n-  fprintf (f, \"  PUT_CODE (rt, code);\\n\");\n-  fprintf (f, \"  PUT_MODE (rt, mode);\\n\");\n+  printf (\"  PUT_CODE (rt, code);\\n\");\n+  printf (\"  PUT_MODE (rt, mode);\\n\");\n \n   for (p = format, i = j = 0; *p ; ++p, ++i)\n     if (*p != '0')\n-      {\n-\tfprintf (f, \"  %s (rt, %d) = arg%d;\\n\",\n-\t\t accessor_from_format (*p), i, j++);\n-      }\n+      printf (\"  %s (rt, %d) = arg%d;\\n\", accessor_from_format (*p), i, j++);\n \n-  fprintf (f, \"\\n  return rt;\\n}\\n\\n\");\n+  printf (\"\\n  return rt;\\n}\\n\\n\");\n }\n \n-/* Emit the `do not edit' banner.  */\n+/* Generate the documentation header for files we write.  */\n \n static void\n-genlegend (f)\n-     FILE *f;\n+genlegend ()\n {\n-  fputs (\"/* Generated automaticaly by the program `gengenrtl'\\n\", f);\n-  fputs (\"   from the RTL description file `rtl.def' */\\n\\n\", f);\n+  printf (\"/* Generated automaticaly by the program `gengenrtl'\\n\");\n+  printf (\"   from the RTL description file `rtl.def' */\\n\\n\");\n }\n \n-/* Emit \"genrtl.h\".  */\n+/* Generate the text of the header file we make, genrtl.h.  */\n \n static void\n-genheader (f)\n-     FILE *f;\n+genheader ()\n {\n   int i;\n   const char **fmt;\n-\n+  \n   for (fmt = formats; *fmt; ++fmt)\n-    gendecl (f, *fmt);\n+    gendecl (*fmt);\n \n-  fprintf (f, \"\\n\");\n+  printf (\"\\n\");\n \n   for (i = 0; i < NUM_RTX_CODE; i++)\n-    {\n-      if (special_format (defs[i].format))\n-\tcontinue;\n-      genmacro (f, i);\n-    }\n+    if (! special_format (defs[i].format))\n+      genmacro (i);\n }\n \n-/* Emit \"genrtl.c\".  */\n+/* Generate the text of the code file we write, genrtl.c.  */\n \n static void\n-gencode (f)\n-     FILE *f;\n+gencode ()\n {\n   const char **fmt;\n \n-  fputs (\"#include \\\"config.h\\\"\\n\", f);\n-  fputs (\"#include \\\"system.h\\\"\\n\", f);\n-  fputs (\"#include \\\"obstack.h\\\"\\n\", f);\n-  fputs (\"#include \\\"rtl.h\\\"\\n\", f);\n-  fputs (\"#include \\\"ggc.h\\\"\\n\\n\", f);\n-  fputs (\"extern struct obstack *rtl_obstack;\\n\\n\", f);\n-  fputs (\"static rtx obstack_alloc_rtx PROTO((int length));\\n\", f);\n-  fputs (\"static rtx obstack_alloc_rtx (length)\\n\", f);\n-  fputs (\"     register int length;\\n{\\n\", f);\n-  fputs (\"  rtx rt = (rtx) obstack_alloc (rtl_obstack, length);\\n\\n\", f);\n-  fputs (\"  memset(rt, 0, sizeof(struct rtx_def) - sizeof(rtunion));\\n\\n\", f);\n-  fputs (\"  return rt;\\n}\\n\\n\", f);\n-\n-  for (fmt = formats; *fmt; ++fmt)\n-    gendef (f, *fmt);\n+  puts (\"#include \\\"config.h\\\"\\n\");\n+  puts (\"#include \\\"system.h\\\"\\n\");\n+  puts (\"#include \\\"obstack.h\\\"\\n\");\n+  puts (\"#include \\\"rtl.h\\\"\\n\");\n+  puts (\"#include \\\"ggc.h\\\"\\n\\n\");\n+  puts (\"extern struct obstack *rtl_obstack;\\n\\n\");\n+  puts (\"static rtx obstack_alloc_rtx PROTO((int length));\\n\");\n+  puts (\"static rtx obstack_alloc_rtx (length)\\n\");\n+  puts (\"     register int length;\\n{\\n\");\n+  puts (\"  rtx rt = (rtx) obstack_alloc (rtl_obstack, length);\\n\\n\");\n+  puts (\"  memset(rt, 0, sizeof(struct rtx_def) - sizeof(rtunion));\\n\\n\");\n+  puts (\"  return rt;\\n}\\n\\n\");\n+\n+  for (fmt = formats; *fmt != 0; fmt++)\n+    gendef (*fmt);\n }\n \n #if defined(USE_C_ALLOCA)\n@@ -338,37 +362,25 @@ xmalloc (nbytes)\n }\n #endif /* USE_C_ALLOCA */\n \n+/* This is the main program.  We accept only one argument, \"-h\", which\n+   says we are writing the genrtl.h file.  Otherwise we are writing the\n+   genrtl.c file.  */\n+\n int\n-main(argc, argv)\n+main (argc, argv)\n      int argc;\n      char **argv;\n {\n-  FILE *f;\n-\n-  if (argc != 3)\n-    exit (1);\n-\n   find_formats ();\n+  genlegend ();\n \n-  f = fopen (argv[1], \"w\");\n-  if (f == NULL)\n-    {\n-      perror (argv[1]);\n-      exit (1);\n-    }\n-  genlegend (f);\n-  genheader (f);\n-  fclose (f);\n-\n-  f = fopen (argv[2], \"w\");\n-  if (f == NULL)\n-    {\n-      perror (argv[2]);\n-      exit (1);\n-    }\n-  genlegend (f);\n-  gencode (f);\n-  fclose (f);\n+  if (argc == 2 && argv[1][0] == '-' && argv[1][1] == 'h')\n+    genheader ();\n+  else\n+    gencode ();\n \n-  exit (0);\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n }"}, {"sha": "fabc73b00464884567b762822f69187745bb447f", "filename": "gcc/halfpic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,5 @@\n /* OSF/rose half-pic support functions.\n-   Copyright (C) 1992, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "d5699565a862652a6c7b0c3f8a8f10477a7e54a7", "filename": "gcc/integrate.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1647,10 +1647,12 @@ copy_rtx_and_substitute (orig, map)\n       return get_label_from_map (map, CODE_LABEL_NUMBER (orig));\n \n     case LABEL_REF:\n-      copy = gen_rtx_LABEL_REF (mode,\n-\t\t\t\tLABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n-\t\t\t\t: get_label_from_map (map, \n-\t\t\t\t\t\t      CODE_LABEL_NUMBER (XEXP (orig, 0))));\n+      copy\n+\t= gen_rtx_LABEL_REF\n+\t  (mode,\n+\t   LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n+\t   : get_label_from_map (map, CODE_LABEL_NUMBER (XEXP (orig, 0))));\n+\n       LABEL_OUTSIDE_LOOP_P (copy) = LABEL_OUTSIDE_LOOP_P (orig);\n \n       /* The fact that this label was previously nonlocal does not mean\n@@ -1777,10 +1779,13 @@ copy_rtx_and_substitute (orig, map)\n #ifndef NO_FUNCTION_CSE\n       if (! (optimize && ! flag_no_function_cse))\n #endif\n-\treturn gen_rtx_CALL (GET_MODE (orig),\n-\t\t\t     gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n-\t\t\t\t\t  copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0), map)),\n-\t\t\tcopy_rtx_and_substitute (XEXP (orig, 1), map));\n+\treturn\n+\t  gen_rtx_CALL\n+\t    (GET_MODE (orig),\n+\t     gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n+\t\t\t  copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0),\n+\t\t\t\t\t\t   map)),\n+\t     copy_rtx_and_substitute (XEXP (orig, 1), map));\n       break;\n \n #if 0\n@@ -1807,6 +1812,7 @@ copy_rtx_and_substitute (orig, map)\n \t  equiv_loc = VARRAY_CONST_EQUIV (map->const_equiv_varray, REGNO (equiv_reg)).rtx;\n \t  loc_offset\n \t    = GET_CODE (equiv_loc) == REG ? 0 : INTVAL (XEXP (equiv_loc, 1));\n+\t      \n \t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n \t\t\t      force_operand\n \t\t\t      (plus_constant"}, {"sha": "9f87ca9f2504a8ba19a7f524e1020d8ca2f9a8e3", "filename": "gcc/invoke.texi", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1477,7 +1477,8 @@ unused variables, parameters and labels, use the @samp{unused} attribute\n (@pxref{Variable Attributes}).\n \n @item -Wuninitialized\n-An automatic variable is used without first being initialized.\n+Warn if an automatic variable is used without first being initialized or\n+if a variable may be clobbered by a @code{setjmp} call.\n \n These warnings are possible only in optimizing compilation,\n because they require data flow information that is computed only\n@@ -1534,7 +1535,8 @@ This has no bug because @code{save_y} is used only if it is set.\n \n @cindex @code{longjmp} warnings\n This option also warns when a nonvolatile automatic variable might be\n-changed by a call to @code{longjmp}.\n+changed by a call to @code{longjmp}.  These warnings as well are possible\n+only in optimizing compilation.\n \n The compiler sees only the calls to @code{setjmp}.  It cannot know\n where @code{longjmp} will be called; in fact, a signal handler could\n@@ -1546,6 +1548,12 @@ Some spurious warnings can be avoided if you declare all the functions\n you use that never return as @code{noreturn}.  @xref{Function\n Attributes}.\n \n+@item -Wreorder (C++ only)\n+@cindex reordering, warning\n+@cindex warning for reordering of member initializers\n+Warn when the order of member initializers given in the code does not\n+match the order in which they must be executed.  For instance:\n+\n @item -Wunknown-pragmas\n @cindex warning for unknown pragmas\n @cindex unknown pragmas, warning\n@@ -1786,8 +1794,7 @@ because the program does work.  Another common use of unreachable\n code is to provide behaviour which is selectable at compile-time.\n \n @item -Winline\n-Warn if a function can not be inlined, and either it was declared as inline,\n-or else the @samp{-finline-functions} option was given.\n+Warn if a function can not be inlined and it was declared as inline.\n \n @item -Wlong-long\n Warn if @samp{long long} type is used.  This is default.  To inhibit\n@@ -6636,16 +6643,16 @@ it.\n @table @code\n @item -fexceptions\n Enable exception handling. Generates extra code needed to propagate\n-exceptions.  For some targets, this implies generation of frame unwind \n-information for all functions. This can produce significant data size \n-overhead, although it does not affect execution.\n-If you do not specify this option, it is enabled by\n-default for languages like C++ which normally require exception handling,\n-and disabled for languages like C that do not normally require it.\n-However, when compiling C code that needs to interoperate properly with\n-exception handlers written in C++, you may need to enable this option.\n-You may also wish to disable this option is you are compiling older C++\n-programs that don't use exception handling.\n+exceptions.  For some targets, this implies GNU CC will generate frame\n+unwind information for all functions, which can produce significant data\n+size overhead, although it does not affect execution.  If you do not\n+specify this option, GNU CC will enable it by default for languages like\n+C++ which normally require exception handling, and disable itfor\n+languages like C that do not normally require it.  However, you may need\n+to enable this option when compiling C code that needs to interoperate\n+properly with exception handlers written in C++.  You may also wish to\n+disable this option if you are compiling older C++ programs that don't\n+use exception handling.\n \n @item -fpcc-struct-return\n Return ``short'' @code{struct} and @code{union} values in memory like\n@@ -6687,7 +6694,7 @@ shared between processes running the same program, while private data\n exists in one copy per process.\n \n @item -fno-common\n-Allocate even uninitialized global variables in the bss section of the\n+Allocate even uninitialized global variables in the data section of the\n object file, rather than generating them as common blocks.  This has the\n effect that if the same variable is declared (without @code{extern}) in\n two different compilations, you will get an error when you link them.\n@@ -6833,23 +6840,21 @@ stubs for every function you call, you might have to specify\n @samp{-fcheck-memory-usage} without @samp{-fprefix-function-name}.\n \n If you specify this option, you can not use the @code{asm} or\n-@code{__asm__} keywords in functions with memory checking enabled.  The\n-compiler cannot understand what the @code{asm} statement will do, and\n-therefore cannot generate the appropriate code, so it is rejected.\n-However, the function attribute @code{no_check_memory_usage} will\n-disable memory checking within a function, and @code{asm} statements can\n-be put inside such functions.  Inline expansion of a non-checked\n-function within a checked function is permitted; the inline function's\n-memory accesses won't be checked, but the rest will.\n-\n-If you move your @code{asm} statements to non-checked inline functions,\n-but they do access memory, you can add calls to the support code in your\n+@code{__asm__} keywords in functions with memory checking enabled.  GNU\n+CC cannot understand what the @code{asm} statement may do, and therefore\n+cannot generate the appropriate code, so it will reject it.  However, if\n+you specify the function attribute @code{no_check_memory_usage} (see\n+@pxref{Function Attributes}, GNU CC will disable memory checking within a\n+function; you may use @code{asm} statements inside such functions.  You\n+may have an inline expansion of a non-checked function within a checked\n+function; in that case GNU CC will not generate checks for the inlined\n+function's memory accesses.\n+\n+If you move your @code{asm} statements to non-checked inline functions\n+and they do access memory, you can add calls to the support code in your\n inline function, to indicate any reads, writes, or copies being done.\n These calls would be similar to those done in the stubs described above.\n \n-@c FIXME: The support-routine interface is defined by the compiler and\n-@c        should be documented!\n-\n @item -fprefix-function-name\n Request GCC to add a prefix to the symbols generated for function names.\n GCC adds a prefix to the names of functions defined as well as"}, {"sha": "7090771ae1120626278526cfb7a2f814405639fb", "filename": "gcc/java/parse-scan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fjava%2Fparse-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fjava%2Fparse-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1378,7 +1378,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/local/gnu/share/bison.simple\"\n+#line 3 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1571,7 +1571,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/local/gnu/share/bison.simple\"\n+#line 196 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2159,7 +2159,7 @@ case 337:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/local/gnu/share/bison.simple\"\n+#line 498 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "4e57df5c02c1eada9cb563f7a7d31c4b971e57a7", "filename": "gcc/jump.c", "status": "modified", "additions": 272, "deletions": 151, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -230,7 +230,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n   last_insn = delete_unreferenced_labels (f);\n \n-  if (!optimize)\n+  if (optimize == 0)\n     {\n       /* CAN_REACH_END is persistent for each function.  Once set it should\n \t not be cleared.  This is especially true for the case where we\n@@ -314,20 +314,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t  int this_is_simplejump, this_is_condjump, reversep = 0;\n \t  int this_is_condjump_in_parallel;\n \n-#if 0\n-\t  /* If NOT the first iteration, if this is the last jump pass\n-\t     (just before final), do the special peephole optimizations.\n-\t     Avoiding the first iteration gives ordinary jump opts\n-\t     a chance to work before peephole opts.  */\n-\n-\t  if (reload_completed && !first && !flag_no_peephole)\n-\t    if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n-\t      peephole (insn);\n-#endif\n-\n-\t  /* That could have deleted some insns after INSN, so check now\n-\t     what the following insn is.  */\n-\n \t  next = NEXT_INSN (insn);\n \n \t  /* See if this is a NOTE_INSN_LOOP_BEG followed by an unconditional\n@@ -362,6 +348,11 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t  if (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n \t    changed |= tension_vector_labels (PATTERN (insn), 1);\n \n+\t  /* See if this jump goes to another jump and redirect if so.  */\n+\t  nlabel = follow_jumps (JUMP_LABEL (insn));\n+\t  if (nlabel != JUMP_LABEL (insn))\n+\t    changed |= redirect_jump (insn, nlabel);\n+\n \t  /* If a dispatch table always goes to the same place,\n \t     get rid of it and replace the insn that uses it.  */\n \n@@ -394,47 +385,123 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t}\n \t    }\n \n-\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n-\n \t  /* If a jump references the end of the function, try to turn\n \t     it into a RETURN insn, possibly a conditional one.  */\n-\t  if (JUMP_LABEL (insn)\n+\t  if (JUMP_LABEL (insn) != 0\n \t      && (next_active_insn (JUMP_LABEL (insn)) == 0\n \t\t  || GET_CODE (PATTERN (next_active_insn (JUMP_LABEL (insn))))\n \t\t      == RETURN))\n \t    changed |= redirect_jump (insn, NULL_RTX);\n \n+\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n+\n \t  /* Detect jump to following insn.  */\n-\t  if (reallabelprev == insn && condjump_p (insn))\n+\t  if (reallabelprev == insn && this_is_condjump)\n \t    {\n \t      next = next_real_insn (JUMP_LABEL (insn));\n \t      delete_jump (insn);\n \t      changed = 1;\n \t      continue;\n \t    }\n \n+\t  /* Detect a conditional jump going to the same place\n+\t     as an immediately following unconditional jump.  */\n+\t  else if (this_is_condjump\n+\t\t   && (temp = next_active_insn (insn)) != 0\n+\t\t   && simplejump_p (temp)\n+\t\t   && (next_active_insn (JUMP_LABEL (insn))\n+\t\t       == next_active_insn (JUMP_LABEL (temp))))\n+\t    {\n+\t      /* Don't mess up test coverage analysis.  */\n+\t      temp2 = temp;\n+\t      if (flag_test_coverage && !reload_completed)\n+\t\tfor (temp2 = insn; temp2 != temp; temp2 = NEXT_INSN (temp2))\n+\t\t  if (GET_CODE (temp2) == NOTE && NOTE_LINE_NUMBER (temp2) > 0)\n+\t\t    break;\n+\t\t  \n+\t      if (temp2 == temp)\n+\t\t{\n+\t\t  delete_jump (insn);\n+\t\t  changed = 1;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  /* Detect a conditional jump jumping over an unconditional jump.  */\n+\n+\t  else if ((this_is_condjump || this_is_condjump_in_parallel)\n+\t\t   && ! this_is_simplejump\n+\t\t   && reallabelprev != 0\n+\t\t   && GET_CODE (reallabelprev) == JUMP_INSN\n+\t\t   && prev_active_insn (reallabelprev) == insn\n+\t\t   && no_labels_between_p (insn, reallabelprev)\n+\t\t   && simplejump_p (reallabelprev))\n+\t    {\n+\t      /* When we invert the unconditional jump, we will be\n+\t\t decrementing the usage count of its old label.\n+\t\t Make sure that we don't delete it now because that\n+\t\t might cause the following code to be deleted.  */\n+\t      rtx prev_uses = prev_nonnote_insn (reallabelprev);\n+\t      rtx prev_label = JUMP_LABEL (insn);\n+\n+\t      if (prev_label)\n+\t\t++LABEL_NUSES (prev_label);\n+\n+\t      if (invert_jump (insn, JUMP_LABEL (reallabelprev)))\n+\t\t{\n+\t\t  /* It is very likely that if there are USE insns before\n+\t\t     this jump, they hold REG_DEAD notes.  These REG_DEAD\n+\t\t     notes are no longer valid due to this optimization,\n+\t\t     and will cause the life-analysis that following passes\n+\t\t     (notably delayed-branch scheduling) to think that\n+\t\t     these registers are dead when they are not.\n+\n+\t\t     To prevent this trouble, we just remove the USE insns\n+\t\t     from the insn chain.  */\n+\n+\t\t  while (prev_uses && GET_CODE (prev_uses) == INSN\n+\t\t\t && GET_CODE (PATTERN (prev_uses)) == USE)\n+\t\t    {\n+\t\t      rtx useless = prev_uses;\n+\t\t      prev_uses = prev_nonnote_insn (prev_uses);\n+\t\t      delete_insn (useless);\n+\t\t    }\n+\n+\t\t  delete_insn (reallabelprev);\n+\t\t  changed = 1;\n+\t\t}\n+\n+\t      /* We can now safely delete the label if it is unreferenced\n+\t\t since the delete_insn above has deleted the BARRIER.  */\n+\t      if (prev_label && --LABEL_NUSES (prev_label) == 0)\n+\t\tdelete_insn (prev_label);\n+\n+\t      next = NEXT_INSN (insn);\n+\t    }\n+\n \t  /* If we have an unconditional jump preceded by a USE, try to put\n \t     the USE before the target and jump there.  This simplifies many\n \t     of the optimizations below since we don't have to worry about\n \t     dealing with these USE insns.  We only do this if the label\n \t     being branch to already has the identical USE or if code\n \t     never falls through to that label.  */\n \n-\t  if (this_is_simplejump\n-\t      && (temp = prev_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (temp) == INSN && GET_CODE (PATTERN (temp)) == USE\n-\t      && (temp1 = prev_nonnote_insn (JUMP_LABEL (insn))) != 0\n-\t      && (GET_CODE (temp1) == BARRIER\n-\t\t  || (GET_CODE (temp1) == INSN\n-\t\t      && rtx_equal_p (PATTERN (temp), PATTERN (temp1))))\n-\t      /* Don't do this optimization if we have a loop containing only\n-\t\t the USE instruction, and the loop start label has a usage\n-\t\t count of 1.  This is because we will redo this optimization\n-\t\t everytime through the outer loop, and jump opt will never\n-\t\t exit.  */\n-\t      && ! ((temp2 = prev_nonnote_insn (temp)) != 0\n-\t\t    && temp2 == JUMP_LABEL (insn)\n-\t\t    && LABEL_NUSES (temp2) == 1))\n+\t  else if (this_is_simplejump\n+\t\t   && (temp = prev_nonnote_insn (insn)) != 0\n+\t\t   && GET_CODE (temp) == INSN\n+\t\t   && GET_CODE (PATTERN (temp)) == USE\n+\t\t   && (temp1 = prev_nonnote_insn (JUMP_LABEL (insn))) != 0\n+\t\t   && (GET_CODE (temp1) == BARRIER\n+\t\t       || (GET_CODE (temp1) == INSN\n+\t\t\t   && rtx_equal_p (PATTERN (temp), PATTERN (temp1))))\n+\t\t   /* Don't do this optimization if we have a loop containing\n+\t\t      only the USE instruction, and the loop start label has\n+\t\t      a usage count of 1.  This is because we will redo this\n+\t\t      optimization everytime through the outer loop, and jump\n+\t\t      opt will never exit.  */\n+\t\t   && ! ((temp2 = prev_nonnote_insn (temp)) != 0\n+\t\t\t && temp2 == JUMP_LABEL (insn)\n+\t\t\t && LABEL_NUSES (temp2) == 1))\n \t    {\n \t      if (GET_CODE (temp1) == BARRIER)\n \t\t{\n@@ -446,6 +513,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t      redirect_jump (insn, get_label_before (temp1));\n \t      reallabelprev = prev_real_insn (temp1);\n \t      changed = 1;\n+\t      next = NEXT_INSN (insn);\n \t    }\n \n \t  /* Simplify   if (...) x = a; else x = b; by converting it\n@@ -587,6 +655,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t      redirect_jump (p, target);\n \n \t\t  changed = 1;\n+\t\t  next = NEXT_INSN (insn);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -683,7 +752,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\tcontinue;\n \t    }\n \n-#ifndef HAVE_cc0\n+#if !defined(HAVE_cc0) && !defined(HAVE_conditional_arithmetic)\n+\n \t  /* If we have if (...) x = exp;  and branches are expensive,\n \t     EXP is a single insn, does not have any side effects, cannot\n \t     trap, and is not too costly, convert this to\n@@ -694,6 +764,10 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t     the potential for conflicts.  We also can't do this when we have\n \t     notes on the insn for the same reason as above.\n \n+\t     If we have conditional arithmetic, this will make this\n+\t     harder to optimize later and isn't needed, so don't do it\n+\t     in that case either.\n+\n \t     We set:\n \n \t     TEMP to the \"x = exp;\" insn.\n@@ -865,8 +939,127 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t    }\n #endif /* HAVE_cc0 */\n \n+#ifdef HAVE_conditional_arithmetic\n+\t  /* See if this is a conditional jump around a small number of\n+\t     instructions that we can conditionalize.  Don't do this before\n+\t     the initial CSE pass or after reload.\n+\n+\t     We reject any insns that have side effects or may trap.\n+\t     Strictly speaking, this is not needed since the machine may\n+\t     support conditionalizing these too, but we won't deal with that\n+\t     now.  Specifically, this means that we can't conditionalize a \n+\t     CALL_INSN, which some machines, such as the ARC, can do, but\n+\t     this is a very minor optimization.  */\n+\t  if (this_is_condjump && ! this_is_simplejump\n+\t      && cse_not_expected && optimize > 0 && ! reload_completed\n+\t      && BRANCH_COST > 2\n+\t      && can_reverse_comparison_p (XEXP (SET_SRC (PATTERN (insn)), 0),\n+\t\t\t\t\t   insn))\n+\t    {\n+\t      rtx ourcond = XEXP (SET_SRC (PATTERN (insn)), 0);\n+\t      int num_insns = 0;\n+\t      char *storage = (char *) oballoc (0);\n+\t      int last_insn = 0, failed = 0;\n+\t      rtx changed_jump = 0;\n+\n+\t      ourcond = gen_rtx (reverse_condition (GET_CODE (ourcond)),\n+\t\t\t\t VOIDmode, XEXP (ourcond, 0),\n+\t\t\t\t XEXP (ourcond, 1));\n+\n+\t      /* Scan forward BRANCH_COST real insns looking for the JUMP_LABEL\n+\t\t of this insn.  We see if we think we can conditionalize the\n+\t\t insns we pass.  For now, we only deal with insns that have\n+\t\t one SET.  We stop after an insn that modifies anything in\n+\t\t OURCOND, if we have too many insns, or if we have an insn\n+\t\t with a side effect or that may trip.  Note that we will\n+\t\t be modifying any unconditional jumps we encounter to be\n+\t\t conditional; this will have the effect of also doing this\n+\t\t optimization on the \"else\" the next time around.  */\n+\t      for (temp1 = NEXT_INSN (insn);\n+\t\t   num_insns <= BRANCH_COST && ! failed && temp1 != 0\n+\t\t   && GET_CODE (temp1) != CODE_LABEL;\n+\t\t   temp1 = NEXT_INSN (temp1))\n+\t\t{\n+\t\t  /* Ignore everything but an active insn.  */\n+\t\t  if (GET_RTX_CLASS (GET_CODE (temp1)) != 'i'\n+\t\t      || GET_CODE (PATTERN (temp1)) == USE\n+\t\t      || GET_CODE (PATTERN (temp1)) == CLOBBER)\n+\t\t    continue;\n+\n+\t\t  /* If this was an unconditional jump, record it since we'll\n+\t\t     need to remove the BARRIER if we succeed.  We can only\n+\t\t     have one such jump since there must be a label after\n+\t\t     the BARRIER and it's either ours, in which case it's the\n+\t\t     only one or some other, in which case we'd fail.  */\n+\n+\t\t  if (simplejump_p (temp1))\n+\t\t    changed_jump = temp1;\n+\n+\t\t  /* See if we are allowed another insn and if this insn\n+\t\t     if one we think we may be able to handle.  */\n+\t\t  if (++num_insns > BRANCH_COST\n+\t\t      || last_insn\n+\t\t      || (temp2 = single_set (temp1)) == 0\n+\t\t      || side_effects_p (SET_SRC (temp2))\n+\t\t      || may_trap_p (SET_SRC (temp2)))\n+\t\t    failed = 1;\n+\t\t  else\n+\t\t    validate_change (temp1, &SET_SRC (temp2),\n+\t\t\t\t     gen_rtx_IF_THEN_ELSE\n+\t\t\t\t     (GET_MODE (SET_DEST (temp2)),\n+\t\t\t\t      copy_rtx (ourcond),\n+\t\t\t\t      SET_SRC (temp2), SET_DEST (temp2)),\n+\t\t\t\t     1);\n+\n+\t\t  if (modified_in_p (ourcond, temp1))\n+\t\t    last_insn = 1;\n+\t\t}\n+\n+\t      /* If we've reached our jump label, haven't failed, and all\n+\t\t the changes above are valid, we can delete this jump\n+\t\t insn.  Also remove a BARRIER after any jump that used\n+\t\t to be unconditional and remove any REG_EQUAL or REG_EQUIV\n+\t\t that might have previously been present on insns we\n+\t\t made conditional.  */\n+\t      if (temp1 == JUMP_LABEL (insn) && ! failed\n+\t\t  && apply_change_group ())\n+\t\t{\n+\t\t  for (temp1 = NEXT_INSN (insn); temp1 != JUMP_LABEL (insn);\n+\t\t       temp1 = NEXT_INSN (temp1))\n+\t\t    if (GET_RTX_CLASS (GET_CODE (temp1)) == 'i')\n+\t\t      for (temp2 = REG_NOTES (temp1); temp2 != 0;\n+\t\t\t   temp2 = XEXP (temp2, 1))\n+\t\t\tif (REG_NOTE_KIND (temp2) == REG_EQUAL\n+\t\t\t    || REG_NOTE_KIND (temp2) == REG_EQUIV)\n+\t\t\t  remove_note (temp1, temp2);\n+\n+\t\t  if (changed_jump != 0)\n+\t\t    {\n+\t\t      if (GET_CODE (NEXT_INSN (changed_jump)) != BARRIER)\n+\t\t\tabort ();\n+\n+\t\t      delete_insn (NEXT_INSN (changed_jump));\n+\t\t    }\n+\n+\t\t  delete_insn (insn);\n+\t\t  changed = 1;\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  cancel_changes (0);\n+\t\t  obfree (storage);\n+\t\t}\n+\t    }\n+#endif\n+\n \t  /* Try to use a conditional move (if the target has them), or a\n-\t     store-flag insn.  The general case is:\n+\t     store-flag insn.  If the target has conditional arithmetic as\n+\t     well as conditional move, the above code will have done something.\n+\t     Note that we prefer the above code since it is more general: the\n+\t     code below can make changes that require work to undo.\n+\n+\t     The general case here is:\n \n \t     1) x = a; if (...) x = b; and\n \t     2) if (...) x = b;\n@@ -889,6 +1082,11 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n \t  if (/* We can't do this after reload has completed.  */\n \t      ! reload_completed\n+#ifdef HAVE_conditional_arithmetic\n+\t      /* Defer this until after CSE so the above code gets the\n+\t\t first crack at it.  */\n+\t      && cse_not_expected\n+#endif\n \t      && this_is_condjump && ! this_is_simplejump\n \t      /* Set TEMP to the \"x = b;\" insn.  */\n \t      && (temp = next_nonnote_insn (insn)) != 0\n@@ -1668,30 +1866,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t}\n \t    }\n #endif\n-\t  /* Detect a conditional jump going to the same place\n-\t     as an immediately following unconditional jump.  */\n-\t  else if (this_is_condjump\n-\t\t   && (temp = next_active_insn (insn)) != 0\n-\t\t   && simplejump_p (temp)\n-\t\t   && (next_active_insn (JUMP_LABEL (insn))\n-\t\t       == next_active_insn (JUMP_LABEL (temp))))\n-\t    {\n-\t      rtx tem = temp;\n-\n-\t      /* ??? Optional.  Disables some optimizations, but makes\n-\t\t gcov output more accurate with -O.  */\n-\t      if (flag_test_coverage && !reload_completed)\n-\t\tfor (tem = insn; tem != temp; tem = NEXT_INSN (tem))\n-\t\t  if (GET_CODE (tem) == NOTE && NOTE_LINE_NUMBER (tem) > 0)\n-\t\t    break;\n-\n-\t      if (tem == temp)\n-\t\t{\n-\t\t  delete_jump (insn);\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t    }\n #ifdef HAVE_trap\n \t  /* Detect a conditional jump jumping over an unconditional trap.  */\n \t  else if (HAVE_trap\n@@ -1765,70 +1939,10 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t}\n \t    }\n #endif\n-\n-\t  /* Detect a conditional jump jumping over an unconditional jump.  */\n-\n-\t  else if ((this_is_condjump || this_is_condjump_in_parallel)\n-\t\t   && ! this_is_simplejump\n-\t\t   && reallabelprev != 0\n-\t\t   && GET_CODE (reallabelprev) == JUMP_INSN\n-\t\t   && prev_active_insn (reallabelprev) == insn\n-\t\t   && no_labels_between_p (insn, reallabelprev)\n-\t\t   && simplejump_p (reallabelprev))\n-\t    {\n-\t      /* When we invert the unconditional jump, we will be\n-\t\t decrementing the usage count of its old label.\n-\t\t Make sure that we don't delete it now because that\n-\t\t might cause the following code to be deleted.  */\n-\t      rtx prev_uses = prev_nonnote_insn (reallabelprev);\n-\t      rtx prev_label = JUMP_LABEL (insn);\n-\n-\t      if (prev_label)\n-\t\t++LABEL_NUSES (prev_label);\n-\n-\t      if (invert_jump (insn, JUMP_LABEL (reallabelprev)))\n-\t\t{\n-\t\t  /* It is very likely that if there are USE insns before\n-\t\t     this jump, they hold REG_DEAD notes.  These REG_DEAD\n-\t\t     notes are no longer valid due to this optimization,\n-\t\t     and will cause the life-analysis that following passes\n-\t\t     (notably delayed-branch scheduling) to think that\n-\t\t     these registers are dead when they are not.\n-\n-\t\t     To prevent this trouble, we just remove the USE insns\n-\t\t     from the insn chain.  */\n-\n-\t\t  while (prev_uses && GET_CODE (prev_uses) == INSN\n-\t\t\t && GET_CODE (PATTERN (prev_uses)) == USE)\n-\t\t    {\n-\t\t      rtx useless = prev_uses;\n-\t\t      prev_uses = prev_nonnote_insn (prev_uses);\n-\t\t      delete_insn (useless);\n-\t\t    }\n-\n-\t\t  delete_insn (reallabelprev);\n-\t\t  next = insn;\n-\t\t  changed = 1;\n-\t\t}\n-\n-\t      /* We can now safely delete the label if it is unreferenced\n-\t\t since the delete_insn above has deleted the BARRIER.  */\n-\t      if (prev_label && --LABEL_NUSES (prev_label) == 0)\n-\t\tdelete_insn (prev_label);\n-\t      continue;\n-\t    }\n \t  else\n \t    {\n \t      /* Detect a jump to a jump.  */\n \n-\t      nlabel = follow_jumps (JUMP_LABEL (insn));\n-\t      if (nlabel != JUMP_LABEL (insn)\n-\t\t  && redirect_jump (insn, nlabel))\n-\t\t{\n-\t\t  changed = 1;\n-\t\t  next = insn;\n-\t\t}\n-\n \t      /* Look for   if (foo) bar; else break;  */\n \t      /* The insns look like this:\n \t\t insn = condjump label1;\n@@ -3227,22 +3341,29 @@ can_reverse_comparison_p (comparison, insn)\n       rtx prev = prev_nonnote_insn (insn);\n       rtx set;\n \n-      /* If the comparison itself was a loop invariant, it could have been\n-\t hoisted out of the loop.  If we proceed to unroll such a loop, then\n-\t we may not be able to find the comparison when copying the loop.\n-\n-\t Returning zero in that case is the safe thing to do.  */\n-      if (prev == 0)\n-\treturn 0;\n-\n-      set = single_set (prev);\n-      if (set == 0 || SET_DEST (set) != arg0)\n-\treturn 0;\n-\n-      arg0 = SET_SRC (set);\n+      /* First see if the condition code mode alone if enough to say we can\n+\t reverse the condition.  If not, then search backwards for a set of\n+\t ARG0. We do not need to check for an insn clobbering it since valid\n+\t code will contain set a set with no intervening clobber.  But\n+\t stop when we reach a label.  */\n+#ifdef REVERSIBLE_CC_MODE\n+      if (GET_MODE_CLASS (GET_MODE (arg0)) == MODE_CC\n+\t  && REVERSIBLE_CC_MODE (GET_MODE (arg0)))\n+\treturn 1;\n+#endif\n+\t\n+      for (prev = prev_nonnote_insn (insn);\n+\t   prev != 0 && GET_CODE (prev) != CODE_LABEL;\n+\t   prev = prev_nonnote_insn (prev))\n+\tif ((set = single_set (prev)) != 0\n+\t    && rtx_equal_p (SET_DEST (set), arg0))\n+\t  {\n+\t    arg0 = SET_SRC (set);\n \n-      if (GET_CODE (arg0) == COMPARE)\n-\targ0 = XEXP (arg0, 0);\n+\t    if (GET_CODE (arg0) == COMPARE)\n+\t      arg0 = XEXP (arg0, 0);\n+\t    break;\n+\t  }\n     }\n \n   /* We can reverse this if ARG0 is a CONST_INT or if its mode is\n@@ -3477,27 +3598,27 @@ condjump_p (insn)\n      rtx insn;\n {\n   register rtx x = PATTERN (insn);\n-  if (GET_CODE (x) != SET)\n-    return 0;\n-  if (GET_CODE (SET_DEST (x)) != PC)\n-    return 0;\n-  if (GET_CODE (SET_SRC (x)) == LABEL_REF)\n-    return 1;\n-  if (GET_CODE (SET_SRC (x)) != IF_THEN_ELSE)\n+\n+  if (GET_CODE (x) != SET\n+      || GET_CODE (SET_DEST (x)) != PC)\n     return 0;\n-  if (XEXP (SET_SRC (x), 2) == pc_rtx\n-      && (GET_CODE (XEXP (SET_SRC (x), 1)) == LABEL_REF\n-\t  || GET_CODE (XEXP (SET_SRC (x), 1)) == RETURN))\n-    return 1;\n-  if (XEXP (SET_SRC (x), 1) == pc_rtx\n-      && (GET_CODE (XEXP (SET_SRC (x), 2)) == LABEL_REF\n-\t  || GET_CODE (XEXP (SET_SRC (x), 2)) == RETURN))\n+\n+  x = SET_SRC (x);\n+  if (GET_CODE (x) == LABEL_REF)\n     return 1;\n+  else return (GET_CODE (x) == IF_THEN_ELSE\n+\t       && ((GET_CODE (XEXP (x, 2)) == PC\n+\t\t    && (GET_CODE (XEXP (x, 1)) == LABEL_REF\n+\t\t\t|| GET_CODE (XEXP (x, 1)) == RETURN))\n+\t\t   || (GET_CODE (XEXP (x, 1)) == PC\n+\t\t       && (GET_CODE (XEXP (x, 2)) == LABEL_REF\n+\t\t\t   || GET_CODE (XEXP (x, 2)) == RETURN))));\n+\n   return 0;\n }\n \n-/* Return nonzero if INSN is a (possibly) conditional jump\n-   and nothing more.  */\n+/* Return nonzero if INSN is a (possibly) conditional jump inside a\n+   PARALLEL.  */\n \n int\n condjump_in_parallel_p (insn)"}, {"sha": "6ac41438ecbaf88c23782b24300866445380d298", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2077,12 +2077,12 @@ found:        ;\n static void\n __bb_init_prg ()\n {\n-\n   FILE *file;\n   char buf[BBINBUFSIZE];\n   const char *p;\n   const char *pos;\n   enum bb_func_mode m;\n+  int i;\n \n #ifdef ON_EXIT\n   /* Initialize destructor.  */\n@@ -2164,7 +2164,10 @@ __bb_init_prg ()\n       bb_hashbuckets = (struct bb_edge **) \n                    malloc (BB_BUCKETS * sizeof (struct bb_edge *));\n       if (bb_hashbuckets)\n-        memset (bb_hashbuckets, 0, BB_BUCKETS * sizeof (struct bb_edge *));\n+\t/* Use a loop here rather than calling bzero to avoid having to\n+\t   conditionalize its existance.  */\n+\tfor (i = 0; i < BB_BUCKETS; i++)\n+\t  bb_hashbuckets[i] = 0;\n     }\n \n   if (bb_mode & 12)"}, {"sha": "870f7473a19b07c1941b0bfe434de3edf6089ba5", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -2219,7 +2219,8 @@ requires_inout (p)\n       case '=':  case '+':  case '?':\n       case '#':  case '&':  case '!':\n       case '*':  case '%':\n-      case '1':  case '2':  case '3':  case '4':\n+      case '1':  case '2':  case '3':  case '4': case '5':\n+      case '6':  case '7':  case '8':  case '9':\n       case 'm':  case '<':  case '>':  case 'V':  case 'o':\n       case 'E':  case 'F':  case 'G':  case 'H':\n       case 's':  case 'i':  case 'n':"}, {"sha": "97265faf4a28fcdd070b7a249e7bf1ef54aa4d91", "filename": "gcc/loop.c", "status": "modified", "additions": 105, "deletions": 46, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -301,11 +301,11 @@ static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx,\n \t\t\t\t   struct loop_info *, rtx, int, int));\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n-static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n+static void find_mem_givs PROTO((rtx, rtx, int, int, rtx, rtx));\n static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int));\n static void check_final_value PROTO((struct induction *, rtx, rtx, \n \t\t\t\t     unsigned HOST_WIDE_INT));\n-static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, rtx *, rtx, rtx));\n+static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, int, rtx *, rtx, rtx));\n static void update_giv_derive PROTO((rtx));\n static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *, rtx **));\n static rtx simplify_giv_expr PROTO((rtx, int *));\n@@ -2356,21 +2356,24 @@ constant_high_bytes (p, loop_start)\n   /* Try to change (SET (REG ...) (ZERO_EXTEND (..:B ...)))\n      to (SET (STRICT_LOW_PART (SUBREG:B (REG...))) ...).  */\n \n-  new = gen_rtx_SET (VOIDmode,\n-\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n-\t\t\t\t\t      gen_rtx_SUBREG (GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)),\n-\t\t\t\t   SET_DEST (PATTERN (p)),\n-\t\t\t\t   0)),\n-\t\t XEXP (SET_SRC (PATTERN (p)), 0));\n+  new\n+    = gen_rtx_SET\n+      (VOIDmode,\n+       gen_rtx_STRICT_LOW_PART\n+       (VOIDmode,\n+\tgen_rtx_SUBREG (GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)),\n+\t\t\tSET_DEST (PATTERN (p)), 0)),\n+       XEXP (SET_SRC (PATTERN (p)), 0));\n+\n   insn_code_number = recog (new, p);\n \n   if (insn_code_number)\n     {\n       register int i;\n \n       /* Clear destination register before the loop.  */\n-      emit_insn_before (gen_rtx_SET (VOIDmode, SET_DEST (PATTERN (p)),\n-\t\t\t\t     const0_rtx),\n+      emit_insn_before (gen_rtx_SET (VOIDmode,\n+\t\t\t\t     SET_DEST (PATTERN (p)), const0_rtx),\n \t\t\tloop_start);\n \n       /* Inside the loop, just load the low part.  */\n@@ -4377,6 +4380,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n   not_every_iteration = 0;\n   loop_depth = 0;\n+  maybe_multiple = 0;\n   p = scan_start;\n   while (1)\n     {\n@@ -4445,8 +4449,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\tp = last_consec_insn;\n \n \t      record_giv (v, p, src_reg, dest_reg, mult_val, add_val, benefit,\n-\t\t\t  DEST_REG, not_every_iteration, NULL_PTR, loop_start,\n-\t\t\t  loop_end);\n+\t\t\t  DEST_REG, not_every_iteration, maybe_multiple,\n+\t\t\t  NULL_PTR, loop_start, loop_end);\n \n \t    }\n \t}\n@@ -4456,8 +4460,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       /* This resulted in worse code on a VAX 8600.  I wonder if it\n \t still does.  */\n       if (GET_CODE (p) == INSN)\n-\tfind_mem_givs (PATTERN (p), p, not_every_iteration, loop_start,\n-\t\t       loop_end);\n+\tfind_mem_givs (PATTERN (p), p, not_every_iteration, maybe_multiple,\n+\t\t       loop_start, loop_end);\n #endif\n \n       /* Update the status of whether giv can derive other givs.  This can\n@@ -4466,6 +4470,49 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t|| GET_CODE (p) == CODE_LABEL)\n \tupdate_giv_derive (p);\n \n+      /* Past CODE_LABEL, we get to insns that may be executed multiple\n+\t times.  The only way we can be sure that they can't is if every\n+\t every jump insn between here and the end of the loop either\n+\t returns, exits the loop, is a forward jump, or is a jump\n+\t to the loop start.  */\n+\n+      if (GET_CODE (p) == CODE_LABEL)\n+\t{\n+\t  rtx insn = p;\n+\n+\t  maybe_multiple = 0;\n+\n+\t  while (1)\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      if (insn == scan_start)\n+\t\tbreak;\n+\t      if (insn == end)\n+\t\t{\n+\t\t  if (loop_top != 0)\n+\t\t    insn = loop_top;\n+\t\t  else\n+\t\t    break;\n+\t\t  if (insn == scan_start)\n+\t\t    break;\n+\t\t}\n+\n+\t      if (GET_CODE (insn) == JUMP_INSN\n+\t\t  && GET_CODE (PATTERN (insn)) != RETURN\n+\t\t  && (! condjump_p (insn)\n+\t\t      || (JUMP_LABEL (insn) != 0\n+\t\t\t  && JUMP_LABEL (insn) != scan_start\n+\t\t\t  && (INSN_UID (JUMP_LABEL (insn)) >= max_uid_for_loop\n+\t\t\t      || INSN_UID (insn) >= max_uid_for_loop\n+\t\t\t      || (INSN_LUID (JUMP_LABEL (insn))\n+\t\t\t\t  < INSN_LUID (insn))))))\n+\t\t{\n+\t\t  maybe_multiple = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n       /* Past a jump, we get to insns for which we can't count\n \t on whether they will be executed during each iteration.  */\n       /* This code appears twice in strength_reduce.  There is also similar\n@@ -5224,13 +5271,15 @@ valid_initial_value_p (x, insn, call_seen, loop_start)\n /* Scan X for memory refs and check each memory address\n    as a possible giv.  INSN is the insn whose pattern X comes from.\n    NOT_EVERY_ITERATION is 1 if the insn might not be executed during\n-   every loop iteration.  */\n+   every loop iteration.  MAYBE_MULTIPLE is 1 if the insn might be executed\n+   more thanonce in each loop iteration.  */\n \n static void\n-find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)\n+find_mem_givs (x, insn, not_every_iteration, maybe_multiple, loop_start,\n+\t       loop_end)\n      rtx x;\n      rtx insn;\n-     int not_every_iteration;\n+     int not_every_iteration, maybe_multiple;\n      rtx loop_start, loop_end;\n {\n   register int i, j;\n@@ -5278,7 +5327,7 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)\n \n \t    record_giv (v, insn, src_reg, addr_placeholder, mult_val,\n \t\t\tadd_val, benefit, DEST_ADDR, not_every_iteration,\n-\t\t\t&XEXP (x, 0), loop_start, loop_end);\n+\t\t\tmaybe_multiple, &XEXP (x, 0), loop_start, loop_end);\n \n \t    v->mem_mode = GET_MODE (x);\n \t  }\n@@ -5294,12 +5343,12 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      find_mem_givs (XEXP (x, i), insn, not_every_iteration, loop_start,\n-\t\t     loop_end);\n+      find_mem_givs (XEXP (x, i), insn, not_every_iteration, maybe_multiple,\n+\t\t     loop_start, loop_end);\n     else if (fmt[i] == 'E')\n       for (j = 0; j < XVECLEN (x, i); j++)\n \tfind_mem_givs (XVECEXP (x, i, j), insn, not_every_iteration,\n-\t\t       loop_start, loop_end);\n+\t\t       maybe_multiple, loop_start, loop_end);\n }\n \f\n /* Fill in the data about one biv update.\n@@ -5421,15 +5470,16 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n \n static void\n record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n-\t    type, not_every_iteration, location, loop_start, loop_end)\n+\t    type, not_every_iteration, maybe_multiple, location, loop_start,\n+\t    loop_end)\n      struct induction *v;\n      rtx insn;\n      rtx src_reg;\n      rtx dest_reg;\n      rtx mult_val, add_val;\n      int benefit;\n      enum g_types type;\n-     int not_every_iteration;\n+     int not_every_iteration, maybe_multiple;\n      rtx *location;\n      rtx loop_start, loop_end;\n {\n@@ -5447,7 +5497,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->location = location;\n   v->cant_derive = 0;\n   v->combined_with = 0;\n-  v->maybe_multiple = 0;\n+  v->maybe_multiple = maybe_multiple;\n   v->maybe_dead = 0;\n   v->derive_adjustment = 0;\n   v->same = 0;\n@@ -5882,9 +5932,10 @@ update_giv_derive (p)\n \t\t\t\t\t     &dummy);\n \n \t\t  if (tem && giv->derive_adjustment)\n-\t\t    tem = simplify_giv_expr (gen_rtx_PLUS (giv->mode, tem,\n-\t\t\t\t\t\t\t   giv->derive_adjustment),\n-\t\t\t\t\t     &dummy);\n+\t\t    tem = simplify_giv_expr\n+\t\t      (gen_rtx_PLUS (giv->mode, tem, giv->derive_adjustment),\n+\t\t       &dummy);\n+\n \t\t  if (tem)\n \t\t    giv->derive_adjustment = tem;\n \t\t  else\n@@ -6274,10 +6325,13 @@ simplify_giv_expr (x, benefit)\n \n \t  case PLUS:\n \t    /* (a + invar_1) + invar_2.  Associate.  */\n-\t    return simplify_giv_expr (\n-\t\tgen_rtx_PLUS (mode, XEXP (arg0, 0),\n-\t\t\t      gen_rtx_PLUS (mode, XEXP (arg0, 1), arg1)),\n-\t\tbenefit);\n+\t    return\n+\t      simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t\t\t\t\t       XEXP (arg0, 0),\n+\t\t\t\t\t       gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t\t     XEXP (arg0, 1),\n+\t\t\t\t\t\t\t     arg1)),\n+\t\t\t\t benefit);\n \n \t  default:\n \t    abort ();\n@@ -6297,11 +6351,12 @@ simplify_giv_expr (x, benefit)\n \ttem = arg0, arg0 = arg1, arg1 = tem;\n \n       if (GET_CODE (arg1) == PLUS)\n-\t  return simplify_giv_expr (gen_rtx_PLUS (mode,\n-\t\t\t\t\t\t  gen_rtx_PLUS (mode, arg0,\n-\t\t\t\t\t\t\t\tXEXP (arg1, 0)),\n-\t\t\t\t\t\t  XEXP (arg1, 1)),\n-\t\t\t\t    benefit);\n+\t  return\n+\t    simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t\t\t\t\t     gen_rtx_PLUS (mode, arg0,\n+\t\t\t\t\t\t\t   XEXP (arg1, 0)),\n+\t\t\t\t\t     XEXP (arg1, 1)),\n+\t\t\t       benefit);\n \n       /* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */\n       if (GET_CODE (arg0) != MULT || GET_CODE (arg1) != MULT)\n@@ -6321,7 +6376,8 @@ simplify_giv_expr (x, benefit)\n       /* Handle \"a - b\" as \"a + b * (-1)\".  */\n       return simplify_giv_expr (gen_rtx_PLUS (mode,\n \t\t\t\t\t      XEXP (x, 0),\n-\t\t\t\t\t      gen_rtx_MULT (mode, XEXP (x, 1),\n+\t\t\t\t\t      gen_rtx_MULT (mode,\n+\t\t\t\t\t\t\t    XEXP (x, 1),\n \t\t\t\t\t\t\t    constm1_rtx)),\n \t\t\t\tbenefit);\n \n@@ -6380,7 +6436,8 @@ simplify_giv_expr (x, benefit)\n \n \tcase MULT:\n \t  /* (a * invar_1) * invar_2.  Associate.  */\n-\t  return simplify_giv_expr (gen_rtx_MULT (mode, XEXP (arg0, 0),\n+\t  return simplify_giv_expr (gen_rtx_MULT (mode,\n+\t\t\t\t\t\t  XEXP (arg0, 0),\n \t\t\t\t\t\t  gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t\tXEXP (arg0, 1),\n \t\t\t\t\t\t\t\targ1)),\n@@ -6406,11 +6463,12 @@ simplify_giv_expr (x, benefit)\n       if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \treturn 0;\n \n-      return simplify_giv_expr (gen_rtx_MULT (mode,\n-\t\t\t\t\t      XEXP (x, 0),\n-\t\t\t\t\t      GEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t\t       << INTVAL (XEXP (x, 1)))),\n-\t\t\t\tbenefit);\n+      return\n+\tsimplify_giv_expr (gen_rtx_MULT (mode,\n+\t\t\t\t\t XEXP (x, 0),\n+\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t\t  << INTVAL (XEXP (x, 1)))),\n+\t\t\t   benefit);\n \n     case NEG:\n       /* \"-a\" is \"a * (-1)\" */\n@@ -6448,9 +6506,10 @@ simplify_giv_expr (x, benefit)\n \t    if (v->cant_derive)\n \t      return 0;\n \n-\t    tem = gen_rtx_PLUS (mode, gen_rtx_MULT (mode, v->src_reg,\n-\t\t\t\t\t\t    v->mult_val),\n-\t\t\t   v->add_val);\n+\t    tem = gen_rtx_PLUS (mode, gen_rtx_MULT (mode,\n+\t\t\t\t\t\t    v->src_reg, v->mult_val),\n+\t\t\t\tv->add_val);\n+\n \t    if (v->derive_adjustment)\n \t      tem = gen_rtx_MINUS (mode, tem, v->derive_adjustment);\n \t    return simplify_giv_expr (tem, benefit);"}, {"sha": "0f1794a03441d09cc16a35471b3de65d0a453fbe", "filename": "gcc/mbchar.c", "status": "modified", "additions": 101, "deletions": 59, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmbchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmbchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -18,11 +18,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* These functions are used to manipulate multibyte characters.  */\n-\n /* Note regarding cross compilation:\n \n-   In general translation of multibyte characters to wide characters can\n+   In general, translation of multibyte characters to wide characters can\n    only work in a native compiler since the translation function (mbtowc)\n    needs to know about both the source and target character encoding.  However,\n    this particular implementation for JIS, SJIS and EUCJP source characters\n@@ -37,31 +35,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"mbchar.h\"\n #include <locale.h>\n \n-typedef enum\n-{\n-  ESCAPE, DOLLAR, BRACKET, AT, B, J, NUL, JIS_CHAR, OTHER, JIS_C_NUM\n-} JIS_CHAR_TYPE;\n+typedef enum {ESCAPE, DOLLAR, BRACKET, AT, B, J, NUL, JIS_CHAR, OTHER,\n+\t      JIS_C_NUM} JIS_CHAR_TYPE;\n \n-typedef enum\n-{\n-  ASCII, A_ESC, A_ESC_DL, JIS, JIS_1, JIS_2, J_ESC, J_ESC_BR,\n-  J2_ESC, J2_ESC_BR, INV, JIS_S_NUM\n-} JIS_STATE; \n+typedef enum {ASCII, A_ESC, A_ESC_DL, JIS, JIS_1, JIS_2, J_ESC, J_ESC_BR,\n+\t     J2_ESC, J2_ESC_BR, INV, JIS_S_NUM} JIS_STATE; \n+\n+typedef enum {COPYA, COPYJ, COPYJ2, MAKE_A, MAKE_J, NOOP,\n+\t      EMPTY, ERROR} JIS_ACTION;\n+\n+/* State/action tables for processing JIS encoding:\n+\n+   Where possible, switches to JIS are grouped with proceding JIS characters\n+   and switches to ASCII are grouped with preceding JIS characters.\n+   Thus, maximum returned length is:\n+     2 (switch to JIS) + 2 (JIS characters) + 2 (switch back to ASCII) = 6.  */\n \n-typedef enum\n-{\n-  COPYA, COPYJ, COPYJ2, MAKE_A, MAKE_J, NOOP, EMPTY, ERROR\n-} JIS_ACTION;\n-\n-/*****************************************************************************\n- * state/action tables for processing JIS encoding\n- * Where possible, switches to JIS are grouped with proceding JIS characters\n- * and switches to ASCII are grouped with preceding JIS characters.\n- * Thus, maximum returned length is:\n- *   2 (switch to JIS) + 2 (JIS characters) + 2 (switch back to ASCII) = 6.\n- *****************************************************************************/\n static JIS_STATE JIS_state_table[JIS_S_NUM][JIS_C_NUM] = {\n-/*            ESCAPE DOLLAR   BRACKET   AT     B      J     NUL JIS_CHAR OTHER*/\n+/*            ESCAPE DOLLAR   BRACKET   AT     B      J     NUL JIS_CHAR OTH*/\n /*ASCII*/   { A_ESC, ASCII,   ASCII,    ASCII, ASCII, ASCII, ASCII,ASCII,ASCII},\n /*A_ESC*/   { ASCII, A_ESC_DL,ASCII,    ASCII, ASCII, ASCII, ASCII,ASCII,ASCII},\n /*A_ESC_DL*/{ ASCII, ASCII,   ASCII,    JIS,   JIS,   ASCII, ASCII,ASCII,ASCII},\n@@ -75,87 +66,112 @@ static JIS_STATE JIS_state_table[JIS_S_NUM][JIS_C_NUM] = {\n };\n \n static JIS_ACTION JIS_action_table[JIS_S_NUM][JIS_C_NUM] = {\n-/*            ESCAPE DOLLAR BRACKET AT     B       J      NUL  JIS_CHAR OTHER */\n+/*            ESCAPE DOLLAR BRACKET AT     B       J      NUL  JIS_CHAR OTH */\n /*ASCII */   {NOOP,  COPYA, COPYA, COPYA,  COPYA,  COPYA, EMPTY, COPYA, COPYA},\n /*A_ESC */   {COPYA, NOOP,  COPYA, COPYA,  COPYA,  COPYA, COPYA, COPYA, COPYA},\n /*A_ESC_DL */{COPYA, COPYA, COPYA, MAKE_J, MAKE_J, COPYA, COPYA, COPYA, COPYA},\n-/*JIS */     {NOOP,  NOOP,  NOOP,  NOOP,   NOOP,   NOOP,  ERROR, NOOP,  ERROR },\n-/*JIS_1 */   {ERROR, NOOP,  NOOP,  NOOP,   NOOP,   NOOP,  ERROR, NOOP,  ERROR },\n+/*JIS */     {NOOP,  NOOP,  NOOP,  NOOP,   NOOP,   NOOP,  ERROR, NOOP,  ERROR},\n+/*JIS_1 */   {ERROR, NOOP,  NOOP,  NOOP,   NOOP,   NOOP,  ERROR, NOOP,  ERROR},\n /*JIS_2 */   {NOOP,  COPYJ2,COPYJ2,COPYJ2, COPYJ2, COPYJ2,ERROR, COPYJ2,COPYJ2},\n-/*J_ESC */   {ERROR, ERROR, NOOP,  ERROR,  ERROR,  ERROR, ERROR, ERROR, ERROR },\n-/*J_ESC_BR */{ERROR, ERROR, ERROR, ERROR,  NOOP,   NOOP,  ERROR, ERROR, ERROR },\n-/*J2_ESC */  {ERROR, ERROR, NOOP,  ERROR,  ERROR,  ERROR, ERROR, ERROR, ERROR },\n-/*J2_ESC_BR*/{ERROR, ERROR, ERROR, ERROR,  COPYJ,  COPYJ, ERROR, ERROR, ERROR },\n+/*J_ESC */   {ERROR, ERROR, NOOP,  ERROR,  ERROR,  ERROR, ERROR, ERROR, ERROR},\n+/*J_ESC_BR */{ERROR, ERROR, ERROR, ERROR,  NOOP,   NOOP,  ERROR, ERROR, ERROR},\n+/*J2_ESC */  {ERROR, ERROR, NOOP,  ERROR,  ERROR,  ERROR, ERROR, ERROR, ERROR},\n+/*J2_ESC_BR*/{ERROR, ERROR, ERROR, ERROR,  COPYJ,  COPYJ, ERROR, ERROR, ERROR},\n };\n \n \n char *literal_codeset = NULL;\n \n+/* Store into *PWC (if PWC is not null) the wide character\n+   corresponding to the multibyte character at the start of the\n+   buffer S of size N.  Return the number of bytes in the multibyte\n+   character.  Return -1 if the bytes do not form a valid character,\n+   or 0 if S is null or points to a null byte.\n+\n+   This function behaves like the Standard C function mbtowc, except\n+   it treats locale names of the form \"C-...\" specially.  */\n+\n int\n local_mbtowc (pwc, s, n)\n-     wchar_t       *pwc;\n-     const char    *s;\n-     size_t         n;\n+     wchar_t *pwc;\n+     char *s;\n+     size_t n;\n {\n   static JIS_STATE save_state = ASCII;\n   JIS_STATE curr_state = save_state;\n-  unsigned char *t = (unsigned char *)s;\n+  unsigned char *t = (unsigned char *) s;\n \n   if (s != NULL && n == 0)\n     return -1;\n \n   if (literal_codeset == NULL || strlen (literal_codeset) <= 1)\n-    {\n-      /* This must be the \"C\" locale or unknown locale -- fall thru */\n-    }\n+    /* This must be the \"C\" locale or unknown locale -- fall thru */\n+    ;\n   else if (! strcmp (literal_codeset, \"C-SJIS\"))\n     {\n       int char1;\n       if (s == NULL)\n-        return 0;  /* not state-dependent */\n+\t/* Not state-dependent.  */\n+        return 0;\n+\n       char1 = *t;\n       if (ISSJIS1 (char1))\n         {\n           int char2 = t[1];\n+\n           if (n <= 1)\n             return -1;\n+\n           if (ISSJIS2 (char2))\n             {\n \t      if (pwc != NULL)\n-\t\t*pwc = (((wchar_t)*t) << 8) + (wchar_t)(*(t+1));\n+\t\t*pwc = (((wchar_t) *t) << 8) + (wchar_t) (*(t + 1));\n               return 2;\n             }\n+\n \t  return -1;\n         }\n+\n       if (pwc != NULL)\n-\t*pwc = (wchar_t)*t;\n+\t*pwc = (wchar_t) *t;\n+\n       if (*t == '\\0')\n \treturn 0;\n+\n       return 1;\n     }\n   else if (! strcmp (literal_codeset, \"C-EUCJP\"))\n     {\n       int char1;\n+\n       if (s == NULL)\n-        return 0;  /* not state-dependent */\n+\t/* Not state-dependent.  */\n+        return 0;\n+\n       char1 = *t;\n       if (ISEUCJP (char1))\n         {\n           int char2 = t[1];     \n+\n           if (n <= 1)\n             return -1;\n+\n           if (ISEUCJP (char2))\n             {\n \t      if (pwc != NULL)\n-\t\t*pwc = (((wchar_t)*t) << 8) + (wchar_t)(*(t+1));\n+\t\t*pwc = (((wchar_t) *t) << 8) + (wchar_t) (*(t + 1));\n               return 2;\n             }\n+\n \t  return -1;\n         }\n+\n       if (pwc != NULL)\n-\t*pwc = (wchar_t)*t;\n+\t*pwc = (wchar_t) *t;\n+\n       if (*t == '\\0')\n \treturn 0;\n+\n       return 1;\n     }\n   else if (! strcmp (literal_codeset, \"C-JIS\"))\n@@ -168,12 +184,13 @@ local_mbtowc (pwc, s, n)\n       if (s == NULL)\n \t{\n \t  save_state = ASCII;\n-\t  return 1;  /* state-dependent */\n+\t  /* State-dependent. */\n+\t  return 1;\n \t}\n \n       ptr = t;\n \n-      for (i = 0; i < n; ++i)\n+      for (i = 0; i < n; i++)\n         {\n           curr_ch = t[i];\n           switch (curr_ch)\n@@ -213,59 +230,84 @@ local_mbtowc (pwc, s, n)\n             {\n             case NOOP:\n               break;\n+\n             case EMPTY:\n \t      if (pwc != NULL)\n-\t\t*pwc = (wchar_t)0;\n+\t\t*pwc = (wchar_t) 0;\n+\n \t      save_state = curr_state;\n               return i;\n+\n             case COPYA:\n \t      if (pwc != NULL)\n-\t\t*pwc = (wchar_t)*ptr;\n+\t\t*pwc = (wchar_t) *ptr;\n \t      save_state = curr_state;\n-              return (i + 1);\n+              return i + 1;\n+\n             case COPYJ:\n \t      if (pwc != NULL)\n-\t\t*pwc = (((wchar_t)*ptr) << 8) + (wchar_t)(*(ptr+1));\n+\t\t*pwc = (((wchar_t) *ptr) << 8) + (wchar_t) (*(ptr + 1));\n+\n \t      save_state = curr_state;\n-              return (i + 1);\n+              return i + 1;\n+\n             case COPYJ2:\n \t      if (pwc != NULL)\n-\t\t*pwc = (((wchar_t)*ptr) << 8) + (wchar_t)(*(ptr+1));\n+\t\t*pwc = (((wchar_t) *ptr) << 8) + (wchar_t) (*(ptr + 1));\n+\n \t      save_state = curr_state;\n-              return (ptr - t) + 2;\n+              return ptr - t + 2;\n+\n             case MAKE_A:\n             case MAKE_J:\n-              ptr = (char *)(t + i + 1);\n+              ptr = (char *) (t + i + 1);\n               break;\n+\n             case ERROR:\n             default:\n               return -1;\n             }\n         }\n \n-      return -1;  /* n < bytes needed */\n+      /* More than n bytes needed.  */\n+      return -1;  \n     }\n                \n #ifdef CROSS_COMPILE\n   if (s == NULL)\n-    return 0;  /* not state-dependent */\n+    /* Not state-dependent.  */\n+    return 0;\n+\n   if (pwc != NULL)\n     *pwc = *s;\n   return 1;\n #else\n+\n   /* This must be the \"C\" locale or unknown locale. */\n   return mbtowc (pwc, s, n);\n #endif\n }\n \n+/* Return the number of bytes in the multibyte character at the start\n+   of the buffer S of size N.  Return -1 if the bytes do not form a\n+   valid character, or 0 if S is null or points to a null byte.\n+\n+   This function behaves like the Standard C function mblen, except\n+   it treats locale names of the form \"C-...\" specially.  */\n+\n int\n local_mblen (s, n)\n-     const char    *s;\n-     size_t         n;\n+     char *s;\n+     size_t n;\n {\n   return local_mbtowc (NULL, s, n);\n }\n \n+/* Return the maximum mumber of bytes in a multibyte character.\n+\n+   This function returns the same value as the Standard C macro MB_CUR_MAX,\n+   except it treats locale names of the form \"C-...\" specially.  */\n+\n int\n local_mb_cur_max ()\n {"}, {"sha": "a4c019bf64f4d6bca7f6b783b8f23918d2b6c8e3", "filename": "gcc/mbchar.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmbchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmbchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,4 +1,4 @@\n-/* mbchar.h - Various declarations for functions found in mbchar.c\n+/* Various declarations for functions found in mbchar.c\n    Copyright (C) 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -22,20 +22,19 @@ Boston, MA 02111-1307, USA.  */\n #define __GCC_MBCHAR_H__\n \n #ifdef MULTIBYTE_CHARS\n-/* escape character used for JIS encoding */\n+\n+/* Escape character used for JIS encoding */\n #define JIS_ESC_CHAR 0x1b\n \n #define ISSJIS1(c)   ((c) >= 0x81 && (c) <= 0x9f || (c) >= 0xe0 && (c) <= 0xef)\n #define ISSJIS2(c)   ((c) >= 0x40 && (c) <= 0x7e || (c) >= 0x80 && (c) <= 0xfc)\n #define ISEUCJP(c)   ((c) >= 0xa1 && (c) <= 0xfe)\n #define ISJIS(c)     ((c) >= 0x21 && (c) <= 0x7e)\n \n-int local_mbtowc     PROTO ((wchar_t *, const char *, size_t));\n-int local_mblen      PROTO ((const char *, size_t));\n-int local_mb_cur_max PROTO ((void));\n+extern int local_mbtowc     PROTO ((wchar_t *, char *, size_t));\n+extern int local_mblen      PROTO ((char *, size_t));\n+extern int local_mb_cur_max PROTO ((void));\n \n /* The locale being used for multibyte characters in string/char literals.  */\n extern char *literal_codeset;\n #endif /* MULTIBYTE_CHARS */\n-\n-#endif /* __GCC_MBCHAR_H__ */"}, {"sha": "d1df107cbbfa3d9a6d6bd62403d4a7fe5a3067fa", "filename": "gcc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1137,6 +1137,9 @@ which are outputs from it.  @samp{=} identifies an output; @samp{+}\n identifies an operand that is both input and output; all other operands\n are assumed to be input only.\n \n+If you specify @samp{=} or @samp{+} in a constraint, you put it in the\n+first character of the constraint string.\n+\n @cindex @samp{&} in constraint\n @cindex earlyclobber operand\n @item &"}, {"sha": "fd70e51d88ec3c11e79f4368d376136022eb2847", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393", "patch": "@@ -1,5 +1,6 @@\n /* Read and manage MIPS symbol tables from object modules.\n-   Copyright (C) 1991, 1994, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1994, 1995, 1997, 1998, 1999 \n+   Free Software Foundation, Inc.\n    Contributed by hartzell@boulder.colorado.edu,\n    Rewritten by meissner@osf.org.\n \n@@ -22,7 +23,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-\n #ifdef index\n #undef index\n #undef rindex"}, {"sha": "0644cd708dc6a26f9bb4b200793137bad7eddb1e", "filename": "gcc/objc/objc-parse.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "7812b9b2ba3dc25e37f46a13b53e4cfd0a953d39", "filename": "gcc/objc/objc-parse.y", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "312dfce8455f0d37f7bace4221071db008728a2d", "filename": "gcc/optabs.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "a633625403a86022f931486258ff4877c1daf7a0", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "03c4c41bcb21787f2c7006cd7d26caf3dc13444d", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "e2b54fbef16b11986fd52715b4c7e29c8506e0f1", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "83b02954fee34531d0fa51b659c92c781a30dd01", "filename": "gcc/real.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "506a6dd7391b5d8bdac1fe29d37590e753e4480f", "filename": "gcc/real.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "31ca8cbee1b158d71a0123ddaa1952a99b6af6de", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "e0f1b277a77c8d86a332680c4c6fceff0fca9f80", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "424e3b11dfc91e089704adbe138cf64ab1948a91", "filename": "gcc/regmove.c", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "93ca1430582dbbcc2c6baa1583470cb0445077d3", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "39421fa64dd8558b83d0f2d2288cae52ab487db5", "filename": "gcc/reload1.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "433306196035721de6cce77a1842b3edb5841400", "filename": "gcc/reorg.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "1c5bf6db4cb41545dd81ea6923690625c4ec196a", "filename": "gcc/rtl.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "257ab07faf8ddbc9695e72751f2943a1946f731d", "filename": "gcc/rtl.def", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "6d90fe70cb5723a5d26f29e638dbad6675ca3e68", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "92050e9730576aa2eda48ccf8227d793c0abab62", "filename": "gcc/stmt.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "42b57106d6df567a5543758db03d5f9f6f4b298e", "filename": "gcc/stupid.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "7538071e7c3c9d62ce90bbb2f9e7d766589b2696", "filename": "gcc/system.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "4ca7bb3aa0d258a7805aba82f037702034f73212", "filename": "gcc/texinfo.tex", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftexinfo.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftexinfo.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftexinfo.tex?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "746c491824896b5d22bbccbd2a645432b841fafc", "filename": "gcc/tm.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "fda94dbf3c72fe4456fe1e0083709081d8eb2b70", "filename": "gcc/toplev.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "6251fa6d8aeb54f1e6766a03576e373b935dbd00", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "3d18899ebd2c07497e33b68f9ff111d6e64e9917", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}, {"sha": "14d70c1e21c226d0d77228361b58c56b766a7323", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c7673583c6310e7f8e45704fdc4aadff33e393/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c7673583c6310e7f8e45704fdc4aadff33e393/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=c5c7673583c6310e7f8e45704fdc4aadff33e393"}]}