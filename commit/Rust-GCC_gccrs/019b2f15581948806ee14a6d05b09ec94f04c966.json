{"sha": "019b2f15581948806ee14a6d05b09ec94f04c966", "node_id": "C_kwDOANBUbNoAKDAxOWIyZjE1NTgxOTQ4ODA2ZWUxNGE2ZDA1YjA5ZWM5NGYwNGM5NjY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T12:27:56Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:07Z"}, "message": "gccrs: Add HIR to GCC GENERIC lowering for all nodes\n\nThis patch implements the lowering mentioned in the previous patch for all HIR nodes.\n\n\tgcc/rust/\n\t* backend/rust-compile-block.cc: New.\n\t* backend/rust-compile-block.h: New.\n\t* backend/rust-compile-expr.cc: New.\n\t* backend/rust-compile-expr.h: New.\n\t* backend/rust-compile-extern.h: New.\n\t* backend/rust-compile-fnparam.cc: New.\n\t* backend/rust-compile-fnparam.h: New.\n\t* backend/rust-compile-implitem.cc: New.\n\t* backend/rust-compile-implitem.h: New.\n\t* backend/rust-compile-intrinsic.cc: New.\n\t* backend/rust-compile-intrinsic.h: New.\n\t* backend/rust-compile-item.cc: New.\n\t* backend/rust-compile-item.h: New.\n\t* backend/rust-compile-pattern.cc: New.\n\t* backend/rust-compile-pattern.h: New.\n\t* backend/rust-compile-resolve-path.cc: New.\n\t* backend/rust-compile-resolve-path.h: New.\n\t* backend/rust-compile-stmt.cc: New.\n\t* backend/rust-compile-stmt.h: New.\n\t* backend/rust-compile-struct-field-expr.cc: New.\n\t* backend/rust-compile-struct-field-expr.h: New.\n\t* backend/rust-compile-type.cc: New.\n\t* backend/rust-compile-type.h: New.\n\t* backend/rust-compile-var-decl.h: New.\n\nCo-authored-by: David Faust <david.faust@oracle.com>", "tree": {"sha": "33a737ec45d313c8797fe297a72126a65b52e265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33a737ec45d313c8797fe297a72126a65b52e265"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/019b2f15581948806ee14a6d05b09ec94f04c966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019b2f15581948806ee14a6d05b09ec94f04c966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019b2f15581948806ee14a6d05b09ec94f04c966", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019b2f15581948806ee14a6d05b09ec94f04c966/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15f04af347e3b65f436808077cbac4fa566019f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f04af347e3b65f436808077cbac4fa566019f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f04af347e3b65f436808077cbac4fa566019f9"}], "stats": {"total": 6690, "additions": 6690, "deletions": 0}, "files": [{"sha": "99674e2d1e7691ee967c702afab9bbb69dbceff3", "filename": "gcc/rust/backend/rust-compile-block.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-block.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-block.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,158 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-block.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileBlock::CompileBlock (Context *ctx, Bvariable *result)\n+  : HIRCompileBase (ctx), translated (nullptr), result (result)\n+{}\n+\n+tree\n+CompileBlock::compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n+{\n+  CompileBlock compiler (ctx, result);\n+  compiler.visit (*expr);\n+  return compiler.translated;\n+}\n+\n+void\n+CompileBlock::visit (HIR::BlockExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  Location start_location = expr.get_locus ();\n+  Location end_location = expr.get_end_locus ();\n+  auto body_mappings = expr.get_mappings ();\n+\n+  Resolver::Rib *rib = nullptr;\n+  if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to setup locals per block\");\n+      return;\n+    }\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t       start_location, end_location);\n+  ctx->push_block (new_block);\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  tree s = convert_to_void (compiled_expr, ICV_STATEMENT);\n+\t  ctx->add_statement (s);\n+\t}\n+    }\n+\n+  if (expr.has_expr ())\n+    {\n+      // the previous passes will ensure this is a valid return or\n+      // a valid trailing expression\n+      tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (result == nullptr)\n+\t    {\n+\t      ctx->add_statement (compiled_expr);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree result_reference = ctx->get_backend ()->var_expression (\n+\t\tresult, expr.get_final_expr ()->get_locus ());\n+\n+\t      tree assignment\n+\t\t= ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t\t     compiled_expr,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+\t      ctx->add_statement (assignment);\n+\t    }\n+\t}\n+    }\n+\n+  ctx->pop_block ();\n+  translated = new_block;\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t NULL, expr.get_locus ());\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree else_block = CompileBlock::compile (expr.get_else_block (), ctx, result);\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t else_block, expr.get_locus ());\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+\n+  // else block\n+  std::vector<Bvariable *> locals;\n+  Location start_location = expr.get_conseq_if_expr ()->get_locus ();\n+  Location end_location = expr.get_conseq_if_expr ()->get_locus (); // FIXME\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree else_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (else_block);\n+\n+  tree else_stmt_decl\n+    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n+\t\t\t\t\t result);\n+  ctx->add_statement (else_stmt_decl);\n+\n+  ctx->pop_block ();\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t else_block, expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "cdd17f19ca2089a90f222da665a16ce1baa5e8aa", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,211 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_BLOCK\n+#define RUST_COMPILE_BLOCK\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileBlock : private HIRCompileBase\n+{\n+public:\n+  static tree compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result);\n+\n+protected:\n+  void visit (HIR::BlockExpr &expr);\n+\n+private:\n+  CompileBlock (Context *ctx, Bvariable *result);\n+\n+  tree translated;\n+  Bvariable *result;\n+};\n+\n+class CompileConditionalBlocks : public HIRCompileBase,\n+\t\t\t\t public HIR::HIRExpressionVisitor\n+{\n+public:\n+  static tree compile (HIR::IfExpr *expr, Context *ctx, Bvariable *result)\n+  {\n+    CompileConditionalBlocks resolver (ctx, result);\n+    expr->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  void visit (HIR::IfExpr &expr) override;\n+  void visit (HIR::IfExprConseqElse &expr) override;\n+  void visit (HIR::IfExprConseqIf &expr) override;\n+\n+  // Empty visit for unused Expression HIR nodes.\n+  void visit (HIR::PathInExpression &) override {}\n+  void visit (HIR::QualifiedPathInExpression &) override {}\n+  void visit (HIR::ClosureExprInner &) override {}\n+  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::StructExprFieldIdentifier &) override {}\n+  void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+  void visit (HIR::StructExprFieldIndexValue &) override {}\n+  void visit (HIR::StructExprStruct &) override {}\n+  void visit (HIR::StructExprStructFields &) override {}\n+  void visit (HIR::LiteralExpr &) override {}\n+  void visit (HIR::BorrowExpr &) override {}\n+  void visit (HIR::DereferenceExpr &) override {}\n+  void visit (HIR::ErrorPropagationExpr &) override {}\n+  void visit (HIR::NegationExpr &) override {}\n+  void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  void visit (HIR::ComparisonExpr &) override {}\n+  void visit (HIR::LazyBooleanExpr &) override {}\n+  void visit (HIR::TypeCastExpr &) override {}\n+  void visit (HIR::AssignmentExpr &) override {}\n+  void visit (HIR::CompoundAssignmentExpr &) override {}\n+  void visit (HIR::GroupedExpr &) override {}\n+  void visit (HIR::ArrayExpr &) override {}\n+  void visit (HIR::ArrayIndexExpr &) override {}\n+  void visit (HIR::TupleExpr &) override {}\n+  void visit (HIR::TupleIndexExpr &) override {}\n+  void visit (HIR::CallExpr &) override {}\n+  void visit (HIR::MethodCallExpr &) override {}\n+  void visit (HIR::FieldAccessExpr &) override {}\n+  void visit (HIR::BlockExpr &) override {}\n+  void visit (HIR::ContinueExpr &) override {}\n+  void visit (HIR::BreakExpr &) override {}\n+  void visit (HIR::RangeFromToExpr &) override {}\n+  void visit (HIR::RangeFromExpr &) override {}\n+  void visit (HIR::RangeToExpr &) override {}\n+  void visit (HIR::RangeFullExpr &) override {}\n+  void visit (HIR::RangeFromToInclExpr &) override {}\n+  void visit (HIR::RangeToInclExpr &) override {}\n+  void visit (HIR::ReturnExpr &) override {}\n+  void visit (HIR::UnsafeBlockExpr &) override {}\n+  void visit (HIR::LoopExpr &) override {}\n+  void visit (HIR::WhileLoopExpr &) override {}\n+  void visit (HIR::WhileLetLoopExpr &) override {}\n+  void visit (HIR::ForLoopExpr &) override {}\n+  void visit (HIR::IfExprConseqIfLet &) override {}\n+  void visit (HIR::IfLetExpr &) override {}\n+  void visit (HIR::IfLetExprConseqElse &) override {}\n+  void visit (HIR::IfLetExprConseqIf &) override {}\n+  void visit (HIR::IfLetExprConseqIfLet &) override {}\n+  void visit (HIR::MatchExpr &) override {}\n+  void visit (HIR::AwaitExpr &) override {}\n+  void visit (HIR::AsyncBlockExpr &) override {}\n+\n+private:\n+  CompileConditionalBlocks (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n+  {}\n+\n+  tree translated;\n+  Bvariable *result;\n+};\n+\n+class CompileExprWithBlock : public HIRCompileBase,\n+\t\t\t     public HIR::HIRExpressionVisitor\n+{\n+public:\n+  static tree compile (HIR::ExprWithBlock *expr, Context *ctx,\n+\t\t       Bvariable *result)\n+  {\n+    CompileExprWithBlock resolver (ctx, result);\n+    expr->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  void visit (HIR::IfExpr &expr) override\n+  {\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n+  }\n+\n+  void visit (HIR::IfExprConseqElse &expr) override\n+  {\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n+  }\n+\n+  void visit (HIR::IfExprConseqIf &expr) override\n+  {\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n+  }\n+\n+  // Empty visit for unused Expression HIR nodes.\n+  void visit (HIR::PathInExpression &) override {}\n+  void visit (HIR::QualifiedPathInExpression &) override {}\n+  void visit (HIR::ClosureExprInner &) override {}\n+  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::StructExprFieldIdentifier &) override {}\n+  void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+  void visit (HIR::StructExprFieldIndexValue &) override {}\n+  void visit (HIR::StructExprStruct &) override {}\n+  void visit (HIR::StructExprStructFields &) override {}\n+  void visit (HIR::LiteralExpr &) override {}\n+  void visit (HIR::BorrowExpr &) override {}\n+  void visit (HIR::DereferenceExpr &) override {}\n+  void visit (HIR::ErrorPropagationExpr &) override {}\n+  void visit (HIR::NegationExpr &) override {}\n+  void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  void visit (HIR::ComparisonExpr &) override {}\n+  void visit (HIR::LazyBooleanExpr &) override {}\n+  void visit (HIR::TypeCastExpr &) override {}\n+  void visit (HIR::AssignmentExpr &) override {}\n+  void visit (HIR::CompoundAssignmentExpr &) override {}\n+  void visit (HIR::GroupedExpr &) override {}\n+  void visit (HIR::ArrayExpr &) override {}\n+  void visit (HIR::ArrayIndexExpr &) override {}\n+  void visit (HIR::TupleExpr &) override {}\n+  void visit (HIR::TupleIndexExpr &) override {}\n+  void visit (HIR::CallExpr &) override {}\n+  void visit (HIR::MethodCallExpr &) override {}\n+  void visit (HIR::FieldAccessExpr &) override {}\n+  void visit (HIR::BlockExpr &) override {}\n+  void visit (HIR::ContinueExpr &) override {}\n+  void visit (HIR::BreakExpr &) override {}\n+  void visit (HIR::RangeFromToExpr &) override {}\n+  void visit (HIR::RangeFromExpr &) override {}\n+  void visit (HIR::RangeToExpr &) override {}\n+  void visit (HIR::RangeFullExpr &) override {}\n+  void visit (HIR::RangeFromToInclExpr &) override {}\n+  void visit (HIR::RangeToInclExpr &) override {}\n+  void visit (HIR::ReturnExpr &) override {}\n+  void visit (HIR::UnsafeBlockExpr &) override {}\n+  void visit (HIR::LoopExpr &) override {}\n+  void visit (HIR::WhileLoopExpr &) override {}\n+  void visit (HIR::WhileLetLoopExpr &) override {}\n+  void visit (HIR::ForLoopExpr &) override {}\n+  void visit (HIR::IfExprConseqIfLet &) override {}\n+  void visit (HIR::IfLetExpr &) override {}\n+  void visit (HIR::IfLetExprConseqElse &) override {}\n+  void visit (HIR::IfLetExprConseqIf &) override {}\n+  void visit (HIR::IfLetExprConseqIfLet &) override {}\n+  void visit (HIR::MatchExpr &) override {}\n+  void visit (HIR::AwaitExpr &) override {}\n+  void visit (HIR::AsyncBlockExpr &) override {}\n+\n+private:\n+  CompileExprWithBlock (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n+  {}\n+\n+  tree translated;\n+  Bvariable *result;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_BLOCK"}, {"sha": "8d239e92f450d39cfc1fc11135cf89a9c97d1921", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "added", "additions": 2769, "deletions": 0, "changes": 2769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,2769 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-compile-pattern.h\"\n+#include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-block.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-constexpr.h\"\n+\n+#include \"fold-const.h\"\n+#include \"realmpfr.h\"\n+#include \"convert.h\"\n+#include \"print-tree.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileExpr::CompileExpr (Context *ctx)\n+  : HIRCompileBase (ctx), translated (error_mark_node)\n+{}\n+\n+tree\n+CompileExpr::Compile (HIR::Expr *expr, Context *ctx)\n+{\n+  CompileExpr compiler (ctx);\n+  expr->accept_vis (compiler);\n+  return compiler.translated;\n+}\n+\n+void\n+CompileExpr::visit (HIR::TupleIndexExpr &expr)\n+{\n+  HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n+  TupleIndex index = expr.get_tuple_index ();\n+\n+  tree receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+\n+  TyTy::BaseType *tuple_expr_ty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (tuple_expr->get_mappings ().get_hirid (),\n+\t\t\t\t      &tuple_expr_ty);\n+  rust_assert (ok);\n+\n+  // do we need to add an indirect reference\n+  if (tuple_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      tree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n+      receiver_ref = indirect;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, index,\n+\t\t\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    {\n+      translated = ctx->get_backend ()->unit_expression ();\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this TupleExpr\");\n+      return;\n+    }\n+\n+  tree tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n+  rust_assert (tuple_type != nullptr);\n+\n+  // this assumes all fields are in order from type resolution\n+  std::vector<tree> vals;\n+  for (auto &elem : expr.get_tuple_elems ())\n+    {\n+      auto e = CompileExpr::Compile (elem.get (), ctx);\n+      vals.push_back (e);\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->constructor_expression (tuple_type, false, vals, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::ReturnExpr &expr)\n+{\n+  auto fncontext = ctx->peek_fn ();\n+\n+  std::vector<tree> retstmts;\n+  if (expr.has_return_expr ())\n+    {\n+      tree compiled_expr = CompileExpr::Compile (expr.return_expr.get (), ctx);\n+      rust_assert (compiled_expr != nullptr);\n+\n+      retstmts.push_back (compiled_expr);\n+    }\n+\n+  auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n+\t\t\t\t\t\t  expr.get_locus ());\n+  ctx->add_statement (s);\n+}\n+\n+void\n+CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+      translated = resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t\t      expr.get_lhs (), expr.get_rhs ());\n+      return;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_left_expr ().get (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_right_expr ().get (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\t  expr.get_expr_type ());\n+      auto compound_assignment\n+\t= resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t     expr.get_left_expr ().get (),\n+\t\t\t\t     expr.get_right_expr ().get ());\n+      ctx->add_statement (compound_assignment);\n+\n+      return;\n+    }\n+\n+  auto operator_expr\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+  tree assignment\n+    = ctx->get_backend ()->assignment_statement (lhs, operator_expr,\n+\t\t\t\t\t\t expr.get_locus ());\n+  ctx->add_statement (assignment);\n+}\n+\n+void\n+CompileExpr::visit (HIR::NegationExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto negated_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::NegationOperatorToLangItem (op);\n+      translated\n+\t= resolve_operator_overload (lang_item_type, expr, negated_expr,\n+\t\t\t\t     nullptr, expr.get_expr ().get (), nullptr);\n+      return;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n+}\n+\n+void\n+CompileExpr::visit (HIR::ComparisonExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  translated\n+    = ctx->get_backend ()->comparison_expression (op, lhs, rhs, location);\n+}\n+\n+void\n+CompileExpr::visit (HIR::LazyBooleanExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  translated\n+    = ctx->get_backend ()->lazy_boolean_expression (op, lhs, rhs, location);\n+}\n+\n+void\n+CompileExpr::visit (HIR::TypeCastExpr &expr)\n+{\n+  TyTy::BaseType *type_to_cast_to_ty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &type_to_cast_to_ty))\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *casted_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_casted_expr ()->get_mappings ().get_hirid (), &casted_tyty))\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  auto type_to_cast_to = TyTyResolveCompile::compile (ctx, type_to_cast_to_ty);\n+  auto casted_expr = CompileExpr::Compile (expr.get_casted_expr ().get (), ctx);\n+\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_cast_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  if (ok)\n+    {\n+      casted_expr\n+\t= resolve_adjustements (*adjustments, casted_expr, expr.get_locus ());\n+    }\n+\n+  translated\n+    = type_cast_expression (type_to_cast_to, casted_expr, expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::IfExpr &expr)\n+{\n+  auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n+  ctx->add_statement (stmt);\n+}\n+\n+void\n+CompileExpr::visit (HIR::IfExprConseqElse &expr)\n+{\n+  TyTy::BaseType *if_type = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &if_type))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type of IfExprConseqElse\");\n+      return;\n+    }\n+\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !if_type->is_unit ();\n+  if (needs_temp)\n+    {\n+      fncontext fnctx = ctx->peek_fn ();\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n+  ctx->add_statement (stmt);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::IfExprConseqIf &expr)\n+{\n+  TyTy::BaseType *if_type = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &if_type))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type of IfExprConseqElse\");\n+      return;\n+    }\n+\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !if_type->is_unit ();\n+  if (needs_temp)\n+    {\n+      fncontext fnctx = ctx->peek_fn ();\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n+  ctx->add_statement (stmt);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::BlockExpr &expr)\n+{\n+  TyTy::BaseType *block_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &block_tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+      return;\n+    }\n+\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !block_tyty->is_unit ();\n+  if (needs_temp)\n+    {\n+      fncontext fnctx = ctx->peek_fn ();\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  auto block_stmt = CompileBlock::compile (&expr, ctx, tmp);\n+  rust_assert (TREE_CODE (block_stmt) == BIND_EXPR);\n+  ctx->add_statement (block_stmt);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+CompileExpr::visit (HIR::StructExprStruct &struct_expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (struct_expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_error_at (struct_expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  rust_assert (tyty->is_unit ());\n+  translated = ctx->get_backend ()->unit_expression ();\n+}\n+\n+void\n+CompileExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (struct_expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_error_at (struct_expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  // it must be an ADT\n+  rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+\n+  // what variant is it?\n+  int union_disriminator = struct_expr.union_index;\n+  TyTy::VariantDef *variant = nullptr;\n+  if (!adt->is_enum ())\n+    {\n+      rust_assert (adt->number_of_variants () == 1);\n+      variant = adt->get_variants ().at (0);\n+    }\n+  else\n+    {\n+      HirId variant_id;\n+      bool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\tstruct_expr.get_struct_name ().get_mappings ().get_hirid (),\n+\t&variant_id);\n+      rust_assert (ok);\n+\n+      ok\n+\t= adt->lookup_variant_by_id (variant_id, &variant, &union_disriminator);\n+      rust_assert (ok);\n+    }\n+\n+  // compile it\n+  tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  std::vector<tree> arguments;\n+  if (adt->is_union ())\n+    {\n+      rust_assert (struct_expr.get_fields ().size () == 1);\n+\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary\n+      auto respective_field = variant->get_field_at_index (union_disriminator);\n+      auto expected = respective_field->get_field_type ();\n+\n+      // process arguments\n+      auto &argument = struct_expr.get_fields ().at (0);\n+      auto lvalue_locus\n+\t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+      auto rvalue_locus = argument->get_locus ();\n+      auto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+      TyTy::BaseType *actual = nullptr;\n+      bool ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+\n+      if (ok)\n+\t{\n+\t  rvalue\n+\t    = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t     actual, expected, lvalue_locus, rvalue_locus);\n+\t}\n+\n+      // add it to the list\n+      arguments.push_back (rvalue);\n+    }\n+  else\n+    {\n+      // this assumes all fields are in order from type resolution and if a\n+      // base struct was specified those fields are filed via accesors\n+      for (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n+\t{\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = variant->get_field_at_index (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  // process arguments\n+\t  auto &argument = struct_expr.get_fields ().at (i);\n+\t  auto lvalue_locus\n+\t    = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\t  auto rvalue_locus = argument->get_locus ();\n+\t  auto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\n+\t  // coerce it if required/possible see\n+\t  // compile/torture/struct_base_init_1.rs\n+\t  if (ok)\n+\t    {\n+\t      rvalue\n+\t\t= coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t\t actual, expected, lvalue_locus, rvalue_locus);\n+\t    }\n+\n+\t  // add it to the list\n+\t  arguments.push_back (rvalue);\n+\t}\n+    }\n+\n+  // the constructor depends on whether this is actually an enum or not if\n+  // its an enum we need to setup the discriminator\n+  std::vector<tree> ctor_arguments;\n+  if (adt->is_enum ())\n+    {\n+      HIR::Expr *discrim_expr = variant->get_discriminant ();\n+      tree discrim_expr_node = CompileExpr::Compile (discrim_expr, ctx);\n+      tree folded_discrim_expr = fold_expr (discrim_expr_node);\n+      tree qualifier = folded_discrim_expr;\n+\n+      ctor_arguments.push_back (qualifier);\n+    }\n+  for (auto &arg : arguments)\n+    ctor_arguments.push_back (arg);\n+\n+  translated = ctx->get_backend ()->constructor_expression (\n+    compiled_adt_type, adt->is_enum (), ctor_arguments, union_disriminator,\n+    struct_expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::GroupedExpr &expr)\n+{\n+  translated = CompileExpr::Compile (expr.get_expr_in_parens ().get (), ctx);\n+}\n+\n+void\n+CompileExpr::visit (HIR::FieldAccessExpr &expr)\n+{\n+  HIR::Expr *receiver_expr = expr.get_receiver_expr ().get ();\n+  tree receiver_ref = CompileExpr::Compile (receiver_expr, ctx);\n+\n+  // resolve the receiver back to ADT type\n+  TyTy::BaseType *receiver = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_receiver_expr ()->get_mappings ().get_hirid (), &receiver))\n+    {\n+      rust_error_at (expr.get_receiver_expr ()->get_locus (),\n+\t\t     \"unresolved type for receiver\");\n+      return;\n+    }\n+\n+  size_t field_index = 0;\n+  if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+\n+      TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+      bool ok\n+\t= variant->lookup_field (expr.get_field_name (), nullptr, &field_index);\n+      rust_assert (ok);\n+    }\n+  else if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      TyTy::BaseType *b = r->get_base ();\n+      rust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n+\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (b);\n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+\n+      TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+      bool ok\n+\t= variant->lookup_field (expr.get_field_name (), nullptr, &field_index);\n+      rust_assert (ok);\n+\n+      tree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n+      receiver_ref = indirect;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, field_index,\n+\t\t\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  translated = ResolvePathRef::Compile (expr, ctx);\n+}\n+\n+void\n+CompileExpr::visit (HIR::PathInExpression &expr)\n+{\n+  translated = ResolvePathRef::Compile (expr, ctx);\n+}\n+\n+void\n+CompileExpr::visit (HIR::LoopExpr &expr)\n+{\n+  TyTy::BaseType *block_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &block_tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+      return;\n+    }\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+  bool is_address_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n+  Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+    fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+    expr.get_locus (), &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+  ctx->push_loop_context (tmp);\n+\n+  if (expr.has_loop_label ())\n+    {\n+      HIR::LoopLabel &loop_label = expr.get_loop_label ();\n+      tree label\n+\t= ctx->get_backend ()->label (fnctx.fndecl,\n+\t\t\t\t      loop_label.get_lifetime ().get_name (),\n+\t\t\t\t      loop_label.get_locus ());\n+      tree label_decl = ctx->get_backend ()->label_definition_statement (label);\n+      ctx->add_statement (label_decl);\n+      ctx->insert_label_decl (\n+\tloop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n+    }\n+\n+  tree loop_begin_label\n+    = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n+  tree loop_begin_label_decl\n+    = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n+  ctx->add_statement (loop_begin_label_decl);\n+  ctx->push_loop_begin_label (loop_begin_label);\n+\n+  tree code_block\n+    = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n+  tree loop_expr\n+    = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n+  ctx->add_statement (loop_expr);\n+\n+  ctx->pop_loop_context ();\n+  translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+\n+  ctx->pop_loop_begin_label ();\n+}\n+\n+void\n+CompileExpr::visit (HIR::WhileLoopExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  if (expr.has_loop_label ())\n+    {\n+      HIR::LoopLabel &loop_label = expr.get_loop_label ();\n+      tree label\n+\t= ctx->get_backend ()->label (fnctx.fndecl,\n+\t\t\t\t      loop_label.get_lifetime ().get_name (),\n+\t\t\t\t      loop_label.get_locus ());\n+      tree label_decl = ctx->get_backend ()->label_definition_statement (label);\n+      ctx->add_statement (label_decl);\n+      ctx->insert_label_decl (\n+\tloop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n+    }\n+\n+  std::vector<Bvariable *> locals;\n+  Location start_location = expr.get_loop_block ()->get_locus ();\n+  Location end_location = expr.get_loop_block ()->get_locus (); // FIXME\n+\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree loop_block\n+    = ctx->get_backend ()->block (fnctx.fndecl, enclosing_scope, locals,\n+\t\t\t\t  start_location, end_location);\n+  ctx->push_block (loop_block);\n+\n+  tree loop_begin_label\n+    = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n+  tree loop_begin_label_decl\n+    = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n+  ctx->add_statement (loop_begin_label_decl);\n+  ctx->push_loop_begin_label (loop_begin_label);\n+\n+  tree condition\n+    = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n+  tree exit_expr\n+    = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n+  ctx->add_statement (exit_expr);\n+\n+  tree code_block_stmt\n+    = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n+  rust_assert (TREE_CODE (code_block_stmt) == BIND_EXPR);\n+  ctx->add_statement (code_block_stmt);\n+\n+  ctx->pop_loop_begin_label ();\n+  ctx->pop_block ();\n+\n+  tree loop_expr\n+    = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n+  ctx->add_statement (loop_expr);\n+}\n+\n+void\n+CompileExpr::visit (HIR::BreakExpr &expr)\n+{\n+  if (expr.has_break_expr ())\n+    {\n+      tree compiled_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+\n+      Bvariable *loop_result_holder = ctx->peek_loop_context ();\n+      tree result_reference\n+\t= ctx->get_backend ()->var_expression (loop_result_holder,\n+\t\t\t\t\t       expr.get_expr ()->get_locus ());\n+\n+      tree assignment\n+\t= ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t     compiled_expr,\n+\t\t\t\t\t\t     expr.get_locus ());\n+      ctx->add_statement (assignment);\n+    }\n+\n+  if (expr.has_label ())\n+    {\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      if (!ctx->get_resolver ()->lookup_resolved_label (\n+\t    expr.get_label ().get_mappings ().get_nodeid (), &resolved_node_id))\n+\t{\n+\t  rust_error_at (\n+\t    expr.get_label ().get_locus (),\n+\t    \"failed to resolve compiled label for label %s\",\n+\t    expr.get_label ().get_mappings ().as_string ().c_str ());\n+\t  return;\n+\t}\n+\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"reverse lookup label failure\");\n+\t  return;\n+\t}\n+\n+      tree label = NULL_TREE;\n+      if (!ctx->lookup_label_decl (ref, &label))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to lookup compiled label\");\n+\t  return;\n+\t}\n+\n+      tree goto_label\n+\t= ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n+      ctx->add_statement (goto_label);\n+    }\n+  else\n+    {\n+      tree exit_expr = ctx->get_backend ()->exit_expression (\n+\tctx->get_backend ()->boolean_constant_expression (true),\n+\texpr.get_locus ());\n+      ctx->add_statement (exit_expr);\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::ContinueExpr &expr)\n+{\n+  tree label = ctx->peek_loop_begin_label ();\n+  if (expr.has_label ())\n+    {\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      if (!ctx->get_resolver ()->lookup_resolved_label (\n+\t    expr.get_label ().get_mappings ().get_nodeid (), &resolved_node_id))\n+\t{\n+\t  rust_error_at (\n+\t    expr.get_label ().get_locus (),\n+\t    \"failed to resolve compiled label for label %s\",\n+\t    expr.get_label ().get_mappings ().as_string ().c_str ());\n+\t  return;\n+\t}\n+\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"reverse lookup label failure\");\n+\t  return;\n+\t}\n+\n+      if (!ctx->lookup_label_decl (ref, &label))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to lookup compiled label\");\n+\t  return;\n+\t}\n+    }\n+\n+  translated = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::BorrowExpr &expr)\n+{\n+  tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+  if (SLICE_TYPE_P (TREE_TYPE (main_expr)))\n+    {\n+      translated = main_expr;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    return;\n+\n+  translated = address_expression (main_expr, expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::DereferenceExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this TupleExpr\");\n+      return;\n+    }\n+\n+  tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n+      tree operator_overload_call\n+\t= resolve_operator_overload (lang_item_type, expr, main_expr, nullptr,\n+\t\t\t\t     expr.get_expr ().get (), nullptr);\n+\n+      // rust deref always returns a reference from this overload then we can\n+      // actually do the indirection\n+      main_expr = operator_overload_call;\n+    }\n+\n+  tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+  if (SLICE_TYPE_P (TREE_TYPE (main_expr)) && SLICE_TYPE_P (expected_type))\n+    {\n+      translated = main_expr;\n+      return;\n+    }\n+\n+  translated = indirect_expression (main_expr, expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::LiteralExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    return;\n+\n+  switch (expr.get_lit_type ())\n+    {\n+    case HIR::Literal::BOOL:\n+      translated = compile_bool_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::INT:\n+      translated = compile_integer_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::FLOAT:\n+      translated = compile_float_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::CHAR:\n+      translated = compile_char_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::BYTE:\n+      translated = compile_byte_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::STRING:\n+      translated = compile_string_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::BYTE_STRING:\n+      translated = compile_byte_string_literal (expr, tyty);\n+      return;\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::AssignmentExpr &expr)\n+{\n+  auto lvalue = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rvalue = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+  // assignments are coercion sites so lets convert the rvalue if necessary\n+  TyTy::BaseType *expected = nullptr;\n+  TyTy::BaseType *actual = nullptr;\n+\n+  bool ok;\n+  ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_lhs ()->get_mappings ().get_hirid (), &expected);\n+  rust_assert (ok);\n+\n+  ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n+  rust_assert (ok);\n+\n+  rvalue = coercion_site (expr.get_mappings ().get_hirid (), rvalue, actual,\n+\t\t\t  expected, expr.get_lhs ()->get_locus (),\n+\t\t\t  expr.get_rhs ()->get_locus ());\n+\n+  tree assignment\n+    = ctx->get_backend ()->assignment_statement (lvalue, rvalue,\n+\t\t\t\t\t\t expr.get_locus ());\n+\n+  ctx->add_statement (assignment);\n+}\n+\n+// Helper for sort_tuple_patterns.\n+// Determine whether Patterns a and b are really the same pattern.\n+// FIXME: This is a nasty hack to avoid properly implementing a comparison\n+//        for Patterns, which we really probably do want at some point.\n+static bool\n+patterns_mergeable (HIR::Pattern *a, HIR::Pattern *b)\n+{\n+  if (!a || !b)\n+    return false;\n+\n+  HIR::Pattern::PatternType pat_type = a->get_pattern_type ();\n+  if (b->get_pattern_type () != pat_type)\n+    return false;\n+\n+  switch (pat_type)\n+    {\n+      case HIR::Pattern::PatternType::PATH: {\n+\t// FIXME: this is far too naive\n+\tHIR::PathPattern &aref = *static_cast<HIR::PathPattern *> (a);\n+\tHIR::PathPattern &bref = *static_cast<HIR::PathPattern *> (b);\n+\tif (aref.get_num_segments () != bref.get_num_segments ())\n+\t  return false;\n+\n+\tconst auto &asegs = aref.get_segments ();\n+\tconst auto &bsegs = bref.get_segments ();\n+\tfor (size_t i = 0; i < asegs.size (); i++)\n+\t  {\n+\t    if (asegs[i].as_string () != bsegs[i].as_string ())\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+      break;\n+      case HIR::Pattern::PatternType::LITERAL: {\n+\tHIR::LiteralPattern &aref = *static_cast<HIR::LiteralPattern *> (a);\n+\tHIR::LiteralPattern &bref = *static_cast<HIR::LiteralPattern *> (b);\n+\treturn aref.get_literal ().is_equal (bref.get_literal ());\n+      }\n+      break;\n+      case HIR::Pattern::PatternType::IDENTIFIER: {\n+\t// TODO\n+      }\n+      break;\n+    case HIR::Pattern::PatternType::WILDCARD:\n+      return true;\n+      break;\n+\n+      // TODO\n+\n+    default:;\n+    }\n+  return false;\n+}\n+\n+// A little container for rearranging the patterns and cases in a match\n+// expression while simplifying.\n+struct PatternMerge\n+{\n+  std::unique_ptr<HIR::MatchCase> wildcard;\n+  std::vector<std::unique_ptr<HIR::Pattern>> heads;\n+  std::vector<std::vector<HIR::MatchCase>> cases;\n+};\n+\n+// Helper for simplify_tuple_match.\n+// For each tuple pattern in a given match, pull out the first elt of the\n+// tuple and construct a new MatchCase with the remaining tuple elts as the\n+// pattern. Return a mapping from each _unique_ first tuple element to a\n+// vec of cases for a new match.\n+//\n+// FIXME: This used to be a std::map<Pattern, Vec<MatchCase>>, but it doesn't\n+// actually work like we want - the Pattern includes an HIR ID, which is unique\n+// per Pattern object. This means we don't have a good means for comparing\n+// Patterns. It would probably be best to actually implement a means of\n+// properly comparing patterns, and then use an actual map.\n+//\n+static struct PatternMerge\n+sort_tuple_patterns (HIR::MatchExpr &expr)\n+{\n+  rust_assert (expr.get_scrutinee_expr ()->get_expression_type ()\n+\t       == HIR::Expr::ExprType::Tuple);\n+\n+  struct PatternMerge result;\n+  result.wildcard = nullptr;\n+  result.heads = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+  result.cases = std::vector<std::vector<HIR::MatchCase>> ();\n+\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      HIR::MatchArm &case_arm = match_case.get_arm ();\n+\n+      // FIXME: Note we are only dealing with the first pattern in the arm.\n+      // The patterns vector in the arm might hold many patterns, which are the\n+      // patterns separated by the '|' token. Rustc abstracts these as \"Or\"\n+      // patterns, and part of its simplification process is to get rid of them.\n+      // We should get rid of the ORs too, maybe here or earlier than here?\n+      auto pat = case_arm.get_patterns ()[0]->clone_pattern ();\n+\n+      // Record wildcards so we can add them in inner matches.\n+      if (pat->get_pattern_type () == HIR::Pattern::PatternType::WILDCARD)\n+\t{\n+\t  // The *whole* pattern is a wild card (_).\n+\t  result.wildcard\n+\t    = std::unique_ptr<HIR::MatchCase> (new HIR::MatchCase (match_case));\n+\t  continue;\n+\t}\n+\n+      rust_assert (pat->get_pattern_type ()\n+\t\t   == HIR::Pattern::PatternType::TUPLE);\n+\n+      auto ref = *static_cast<HIR::TuplePattern *> (pat.get ());\n+\n+      rust_assert (ref.has_tuple_pattern_items ());\n+\n+      auto items\n+\t= HIR::TuplePattern (ref).get_items ()->clone_tuple_pattern_items ();\n+      if (items->get_pattern_type ()\n+\t  == HIR::TuplePatternItems::TuplePatternItemType::MULTIPLE)\n+\t{\n+\t  auto items_ref\n+\t    = *static_cast<HIR::TuplePatternItemsMultiple *> (items.get ());\n+\n+\t  // Pop the first pattern out\n+\t  auto patterns = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+\t  auto first = items_ref.get_patterns ()[0]->clone_pattern ();\n+\t  for (auto p = items_ref.get_patterns ().begin () + 1;\n+\t       p != items_ref.get_patterns ().end (); p++)\n+\t    {\n+\t      patterns.push_back ((*p)->clone_pattern ());\n+\t    }\n+\n+\t  // if there is only one pattern left, don't make a tuple out of it\n+\t  std::unique_ptr<HIR::Pattern> result_pattern;\n+\t  if (patterns.size () == 1)\n+\t    {\n+\t      result_pattern = std::move (patterns[0]);\n+\t    }\n+\t  else\n+\t    {\n+\t      auto new_items = std::unique_ptr<HIR::TuplePatternItems> (\n+\t\tnew HIR::TuplePatternItemsMultiple (std::move (patterns)));\n+\n+\t      // Construct a TuplePattern from the rest of the patterns\n+\t      result_pattern = std::unique_ptr<HIR::Pattern> (\n+\t\tnew HIR::TuplePattern (ref.get_pattern_mappings (),\n+\t\t\t\t       std::move (new_items),\n+\t\t\t\t       ref.get_locus ()));\n+\t    }\n+\n+\t  // I don't know why we need to make foo separately here but\n+\t  // using the { new_tuple } syntax in new_arm constructor does not\n+\t  // compile.\n+\t  auto foo = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+\t  foo.emplace_back (std::move (result_pattern));\n+\t  HIR::MatchArm new_arm (std::move (foo), Location (), nullptr,\n+\t\t\t\t AST::AttrVec ());\n+\n+\t  HIR::MatchCase new_case (match_case.get_mappings (), new_arm,\n+\t\t\t\t   match_case.get_expr ()->clone_expr ());\n+\n+\t  bool pushed = false;\n+\t  for (size_t i = 0; i < result.heads.size (); i++)\n+\t    {\n+\t      if (patterns_mergeable (result.heads[i].get (), first.get ()))\n+\t\t{\n+\t\t  result.cases[i].push_back (new_case);\n+\t\t  pushed = true;\n+\t\t}\n+\t    }\n+\n+\t  if (!pushed)\n+\t    {\n+\t      result.heads.push_back (std::move (first));\n+\t      result.cases.push_back ({new_case});\n+\t    }\n+\t}\n+      else /* TuplePatternItemType::RANGED */\n+\t{\n+\t  // FIXME\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+// Helper for CompileExpr::visit (HIR::MatchExpr).\n+// Given a MatchExpr where the scrutinee is some kind of tuple, build an\n+// equivalent match where only one element of the tuple is examined at a time.\n+// This resulting match can then be lowered to a SWITCH_EXPR tree directly.\n+//\n+// The approach is as follows:\n+// 1. Split the scrutinee and each pattern into the first (head) and the\n+//    rest (tail).\n+// 2. Build a mapping of unique pattern heads to the cases (tail and expr)\n+//    that shared that pattern head in the original match.\n+//    (This is the job of sort_tuple_patterns ()).\n+// 3. For each unique pattern head, build a new MatchCase where the pattern\n+//    is the unique head, and the expression is a new match where:\n+//    - The scrutinee is the tail of the original scrutinee\n+//    - The cases are are those built by the mapping in step 2, i.e. the\n+//      tails of the patterns and the corresponing expressions from the\n+//      original match expression.\n+// 4. Do this recursively for each inner match, until there is nothing more\n+//    to simplify.\n+// 5. Build the resulting match which scrutinizes the head of the original\n+//    scrutinee, using the cases built in step 3.\n+static HIR::MatchExpr\n+simplify_tuple_match (HIR::MatchExpr &expr)\n+{\n+  if (expr.get_scrutinee_expr ()->get_expression_type ()\n+      != HIR::Expr::ExprType::Tuple)\n+    return expr;\n+\n+  auto ref = *static_cast<HIR::TupleExpr *> (expr.get_scrutinee_expr ().get ());\n+\n+  auto &tail = ref.get_tuple_elems ();\n+  rust_assert (tail.size () > 1);\n+\n+  auto head = std::move (tail[0]);\n+  tail.erase (tail.begin (), tail.begin () + 1);\n+\n+  // e.g.\n+  // match (tupA, tupB, tupC) {\n+  //   (a1, b1, c1) => { blk1 },\n+  //   (a2, b2, c2) => { blk2 },\n+  //   (a1, b3, c3) => { blk3 },\n+  // }\n+  // tail = (tupB, tupC)\n+  // head = tupA\n+\n+  // Make sure the tail is only a tuple if it consists of at least 2 elements.\n+  std::unique_ptr<HIR::Expr> remaining;\n+  if (tail.size () == 1)\n+    remaining = std::move (tail[0]);\n+  else\n+    remaining = std::unique_ptr<HIR::Expr> (\n+      new HIR::TupleExpr (ref.get_mappings (), std::move (tail),\n+\t\t\t  AST::AttrVec (), ref.get_outer_attrs (),\n+\t\t\t  ref.get_locus ()));\n+\n+  // e.g.\n+  // a1 -> [(b1, c1) => { blk1 },\n+  //        (b3, c3) => { blk3 }]\n+  // a2 -> [(b2, c2) => { blk2 }]\n+  struct PatternMerge map = sort_tuple_patterns (expr);\n+\n+  std::vector<HIR::MatchCase> cases;\n+  // Construct the inner match for each unique first elt of the tuple\n+  // patterns\n+  for (size_t i = 0; i < map.heads.size (); i++)\n+    {\n+      auto inner_match_cases = map.cases[i];\n+\n+      // If there is a wildcard at the outer match level, then need to\n+      // propegate the wildcard case into *every* inner match.\n+      // FIXME: It is probably not correct to add this unconditionally, what if\n+      // we have a pattern like (a, _, c)? Then there is already a wildcard in\n+      // the inner matches, and having two will cause two 'default:' blocks\n+      // which is an error.\n+      if (map.wildcard != nullptr)\n+\t{\n+\t  inner_match_cases.push_back (*(map.wildcard.get ()));\n+\t}\n+\n+      // match (tupB, tupC) {\n+      //   (b1, c1) => { blk1 },\n+      //   (b3, c3) => { blk3 }\n+      // }\n+      HIR::MatchExpr inner_match (expr.get_mappings (),\n+\t\t\t\t  remaining->clone_expr (), inner_match_cases,\n+\t\t\t\t  AST::AttrVec (), expr.get_outer_attrs (),\n+\t\t\t\t  expr.get_locus ());\n+\n+      inner_match = simplify_tuple_match (inner_match);\n+\n+      auto outer_arm_pat = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+      outer_arm_pat.emplace_back (map.heads[i]->clone_pattern ());\n+\n+      HIR::MatchArm outer_arm (std::move (outer_arm_pat), expr.get_locus ());\n+\n+      // Need to move the inner match to the heap and put it in a unique_ptr to\n+      // build the actual match case of the outer expression\n+      // auto inner_expr = std::unique_ptr<HIR::Expr> (new HIR::MatchExpr\n+      // (inner_match));\n+      auto inner_expr = inner_match.clone_expr ();\n+\n+      // a1 => match (tupB, tupC) { ... }\n+      HIR::MatchCase outer_case (expr.get_mappings (), outer_arm,\n+\t\t\t\t std::move (inner_expr));\n+\n+      cases.push_back (outer_case);\n+    }\n+\n+  // If there was a wildcard, make sure to include it at the outer match level\n+  // too.\n+  if (map.wildcard != nullptr)\n+    {\n+      cases.push_back (*(map.wildcard.get ()));\n+    }\n+\n+  // match tupA {\n+  //   a1 => match (tupB, tupC) {\n+  //     (b1, c1) => { blk1 },\n+  //     (b3, c3) => { blk3 }\n+  //   }\n+  //   a2 => match (tupB, tupC) {\n+  //     (b2, c2) => { blk2 }\n+  //   }\n+  // }\n+  HIR::MatchExpr outer_match (expr.get_mappings (), std::move (head), cases,\n+\t\t\t      AST::AttrVec (), expr.get_outer_attrs (),\n+\t\t\t      expr.get_locus ());\n+\n+  return outer_match;\n+}\n+\n+// Helper for CompileExpr::visit (HIR::MatchExpr).\n+// Check that the scrutinee of EXPR is a valid kind of expression to match on.\n+// Return the TypeKind of the scrutinee if it is valid, or TyTy::TypeKind::ERROR\n+// if not.\n+static TyTy::TypeKind\n+check_match_scrutinee (HIR::MatchExpr &expr, Context *ctx)\n+{\n+  TyTy::BaseType *scrutinee_expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_scrutinee_expr ()->get_mappings ().get_hirid (),\n+\t&scrutinee_expr_tyty))\n+    {\n+      return TyTy::TypeKind::ERROR;\n+    }\n+\n+  TyTy::TypeKind scrutinee_kind = scrutinee_expr_tyty->get_kind ();\n+  rust_assert ((TyTy::is_primitive_type_kind (scrutinee_kind)\n+\t\t&& scrutinee_kind != TyTy::TypeKind::NEVER)\n+\t       || scrutinee_kind == TyTy::TypeKind::ADT\n+\t       || scrutinee_kind == TyTy::TypeKind::TUPLE);\n+\n+  if (scrutinee_kind == TyTy::TypeKind::ADT)\n+    {\n+      // this will need to change but for now the first pass implementation,\n+      // lets assert this is the case\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (scrutinee_expr_tyty);\n+      rust_assert (adt->is_enum ());\n+      rust_assert (adt->number_of_variants () > 0);\n+    }\n+  else if (scrutinee_kind == TyTy::TypeKind::FLOAT)\n+    {\n+      // FIXME: CASE_LABEL_EXPR does not support floating point types.\n+      // Find another way to compile these.\n+      rust_sorry_at (expr.get_locus (),\n+\t\t     \"match on floating-point types is not yet supported\");\n+    }\n+\n+  TyTy::BaseType *expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &expr_tyty))\n+    {\n+      return TyTy::TypeKind::ERROR;\n+    }\n+\n+  return scrutinee_kind;\n+}\n+\n+void\n+CompileExpr::visit (HIR::MatchExpr &expr)\n+{\n+  // https://gcc.gnu.org/onlinedocs/gccint/Basic-Statements.html#Basic-Statements\n+  // TODO\n+  // SWITCH_ALL_CASES_P is true if the switch includes a default label or the\n+  // case label ranges cover all possible values of the condition expression\n+\n+  /* Switch expression.\n+\n+     TREE_TYPE is the original type of the condition, before any\n+     language required type conversions.  It may be NULL, in which case\n+     the original type and final types are assumed to be the same.\n+\n+     Operand 0 is the expression used to perform the branch,\n+     Operand 1 is the body of the switch, which probably contains\n+       CASE_LABEL_EXPRs.  It may also be NULL, in which case operand 2\n+       must not be NULL.  */\n+  // DEFTREECODE (SWITCH_EXPR, \"switch_expr\", tcc_statement, 2)\n+\n+  /* Used to represent a case label.\n+\n+     Operand 0 is CASE_LOW.  It may be NULL_TREE, in which case the label\n+       is a 'default' label.\n+     Operand 1 is CASE_HIGH.  If it is NULL_TREE, the label is a simple\n+       (one-value) case label.  If it is non-NULL_TREE, the case is a range.\n+     Operand 2 is CASE_LABEL, which has the corresponding LABEL_DECL.\n+     Operand 3 is CASE_CHAIN.  This operand is only used in tree-cfg.cc to\n+       speed up the lookup of case labels which use a particular edge in\n+       the control flow graph.  */\n+  // DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", tcc_statement, 4)\n+\n+  TyTy::TypeKind scrutinee_kind = check_match_scrutinee (expr, ctx);\n+  if (scrutinee_kind == TyTy::TypeKind::ERROR)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &expr_tyty))\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !expr_tyty->is_unit ();\n+  if (needs_temp)\n+    {\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, expr_tyty);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  // lets compile the scrutinee expression\n+  tree match_scrutinee_expr\n+    = CompileExpr::Compile (expr.get_scrutinee_expr ().get (), ctx);\n+\n+  tree match_scrutinee_expr_qualifier_expr;\n+  if (TyTy::is_primitive_type_kind (scrutinee_kind))\n+    {\n+      match_scrutinee_expr_qualifier_expr = match_scrutinee_expr;\n+    }\n+  else if (scrutinee_kind == TyTy::TypeKind::ADT)\n+    {\n+      // need to access qualifier the field, if we use QUAL_UNION_TYPE this\n+      // would be DECL_QUALIFIER i think. For now this will just access the\n+      // first record field and its respective qualifier because it will always\n+      // be set because this is all a big special union\n+      tree scrutinee_first_record_expr\n+\t= ctx->get_backend ()->struct_field_expression (\n+\t  match_scrutinee_expr, 0, expr.get_scrutinee_expr ()->get_locus ());\n+      match_scrutinee_expr_qualifier_expr\n+\t= ctx->get_backend ()->struct_field_expression (\n+\t  scrutinee_first_record_expr, 0,\n+\t  expr.get_scrutinee_expr ()->get_locus ());\n+    }\n+  else if (scrutinee_kind == TyTy::TypeKind::TUPLE)\n+    {\n+      // match on tuple becomes a series of nested switches, with one level\n+      // for each element of the tuple from left to right.\n+      auto exprtype = expr.get_scrutinee_expr ()->get_expression_type ();\n+      switch (exprtype)\n+\t{\n+\t  case HIR::Expr::ExprType::Tuple: {\n+\t    // Build an equivalent expression which is nicer to lower.\n+\t    HIR::MatchExpr outer_match = simplify_tuple_match (expr);\n+\n+\t    // We've rearranged the match into something that lowers better\n+\t    // to GENERIC trees.\n+\t    // For actually doing the lowering we need to compile the match\n+\t    // we've just made. But we're half-way through compiling the\n+\t    // original one.\n+\t    // ...\n+\t    // For now, let's just replace the original with the rearranged one\n+\t    // we just made, and compile that instead. What could go wrong? :)\n+\t    //\n+\t    // FIXME: What about when we decide a temporary is needed above?\n+\t    //        We might have already pushed a statement for it that\n+\t    //        we no longer need. Probably need to rearrange the order\n+\t    //        of these steps.\n+\t    expr = outer_match;\n+\n+\t    scrutinee_kind = check_match_scrutinee (expr, ctx);\n+\t    if (scrutinee_kind == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\ttranslated = error_mark_node;\n+\t\treturn;\n+\t      }\n+\n+\t    // Now compile the scrutinee of the simplified match.\n+\t    // FIXME: this part is duplicated from above.\n+\t    match_scrutinee_expr\n+\t      = CompileExpr::Compile (expr.get_scrutinee_expr ().get (), ctx);\n+\n+\t    if (TyTy::is_primitive_type_kind (scrutinee_kind))\n+\t      {\n+\t\tmatch_scrutinee_expr_qualifier_expr = match_scrutinee_expr;\n+\t      }\n+\t    else if (scrutinee_kind == TyTy::TypeKind::ADT)\n+\t      {\n+\t\t// need to access qualifier the field, if we use QUAL_UNION_TYPE\n+\t\t// this would be DECL_QUALIFIER i think. For now this will just\n+\t\t// access the first record field and its respective qualifier\n+\t\t// because it will always be set because this is all a big\n+\t\t// special union\n+\t\ttree scrutinee_first_record_expr\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    match_scrutinee_expr, 0,\n+\t\t    expr.get_scrutinee_expr ()->get_locus ());\n+\t\tmatch_scrutinee_expr_qualifier_expr\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    scrutinee_first_record_expr, 0,\n+\t\t    expr.get_scrutinee_expr ()->get_locus ());\n+\t      }\n+\t    else\n+\t      {\n+\t\t// FIXME: There are other cases, but it better not be a Tuple\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\t  case HIR::Expr::ExprType::Path: {\n+\t    // FIXME\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    {\n+      // FIXME: match on other types of expressions not yet implemented.\n+      gcc_unreachable ();\n+    }\n+\n+  // setup the end label so the cases can exit properly\n+  tree fndecl = fnctx.fndecl;\n+  Location end_label_locus = expr.get_locus (); // FIXME\n+  tree end_label\n+    = ctx->get_backend ()->label (fndecl,\n+\t\t\t\t  \"\" /* empty creates an artificial label */,\n+\t\t\t\t  end_label_locus);\n+  tree end_label_decl_statement\n+    = ctx->get_backend ()->label_definition_statement (end_label);\n+\n+  // setup the switch-body-block\n+  Location start_location; // FIXME\n+  Location end_location;   // FIXME\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree switch_body_block\n+    = ctx->get_backend ()->block (fndecl, enclosing_scope, {}, start_location,\n+\t\t\t\t  end_location);\n+  ctx->push_block (switch_body_block);\n+\n+  for (auto &kase : expr.get_match_cases ())\n+    {\n+      // for now lets just get single pattern's working\n+      HIR::MatchArm &kase_arm = kase.get_arm ();\n+      rust_assert (kase_arm.get_patterns ().size () > 0);\n+\n+      // generate implicit label\n+      Location arm_locus = kase_arm.get_locus ();\n+      tree case_label = ctx->get_backend ()->label (\n+\tfndecl, \"\" /* empty creates an artificial label */, arm_locus);\n+\n+      // setup the bindings for the block\n+      for (auto &kase_pattern : kase_arm.get_patterns ())\n+\t{\n+\t  tree switch_kase_expr\n+\t    = CompilePatternCaseLabelExpr::Compile (kase_pattern.get (),\n+\t\t\t\t\t\t    case_label, ctx);\n+\t  ctx->add_statement (switch_kase_expr);\n+\n+\t  CompilePatternBindings::Compile (kase_pattern.get (),\n+\t\t\t\t\t   match_scrutinee_expr, ctx);\n+\t}\n+\n+      // compile the expr and setup the assignment if required when tmp != NULL\n+      tree kase_expr_tree = CompileExpr::Compile (kase.get_expr ().get (), ctx);\n+      if (tmp != NULL)\n+\t{\n+\t  tree result_reference\n+\t    = ctx->get_backend ()->var_expression (tmp, arm_locus);\n+\t  tree assignment\n+\t    = ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t\t kase_expr_tree,\n+\t\t\t\t\t\t\t arm_locus);\n+\t  ctx->add_statement (assignment);\n+\t}\n+\n+      // go to end label\n+      tree goto_end_label = build1_loc (arm_locus.gcc_location (), GOTO_EXPR,\n+\t\t\t\t\tvoid_type_node, end_label);\n+      ctx->add_statement (goto_end_label);\n+    }\n+\n+  // setup the switch expression\n+  tree match_body = ctx->pop_block ();\n+  tree match_expr_stmt\n+    = build2_loc (expr.get_locus ().gcc_location (), SWITCH_EXPR,\n+\t\t  TREE_TYPE (match_scrutinee_expr_qualifier_expr),\n+\t\t  match_scrutinee_expr_qualifier_expr, match_body);\n+  ctx->add_statement (match_expr_stmt);\n+  ctx->add_statement (end_label_decl_statement);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::CallExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_fnexpr ()->get_mappings ().get_hirid (), &tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  // must be a tuple constructor\n+  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  bool is_adt_ctor = !is_fn;\n+  if (is_adt_ctor)\n+    {\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+      // what variant is it?\n+      int union_disriminator = -1;\n+      TyTy::VariantDef *variant = nullptr;\n+      if (!adt->is_enum ())\n+\t{\n+\t  rust_assert (adt->number_of_variants () == 1);\n+\t  variant = adt->get_variants ().at (0);\n+\t}\n+      else\n+\t{\n+\t  HirId variant_id;\n+\t  bool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\t    expr.get_fnexpr ()->get_mappings ().get_hirid (), &variant_id);\n+\t  rust_assert (ok);\n+\n+\t  ok = adt->lookup_variant_by_id (variant_id, &variant,\n+\t\t\t\t\t  &union_disriminator);\n+\t  rust_assert (ok);\n+\t}\n+\n+      // this assumes all fields are in order from type resolution and if a\n+      // base struct was specified those fields are filed via accesors\n+      std::vector<tree> arguments;\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = variant->get_field_at_index (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  Location lvalue_locus\n+\t    = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\t  Location rvalue_locus = argument->get_locus ();\n+\t  rvalue\n+\t    = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t     actual, expected, lvalue_locus, rvalue_locus);\n+\n+\t  // add it to the list\n+\t  arguments.push_back (rvalue);\n+\t}\n+\n+      // the constructor depends on whether this is actually an enum or not if\n+      // its an enum we need to setup the discriminator\n+      std::vector<tree> ctor_arguments;\n+      if (adt->is_enum ())\n+\t{\n+\t  HIR::Expr *discrim_expr = variant->get_discriminant ();\n+\t  tree discrim_expr_node = CompileExpr::Compile (discrim_expr, ctx);\n+\t  tree folded_discrim_expr = fold_expr (discrim_expr_node);\n+\t  tree qualifier = folded_discrim_expr;\n+\n+\t  ctor_arguments.push_back (qualifier);\n+\t}\n+      for (auto &arg : arguments)\n+\tctor_arguments.push_back (arg);\n+\n+      translated = ctx->get_backend ()->constructor_expression (\n+\tcompiled_adt_type, adt->is_enum (), ctor_arguments, union_disriminator,\n+\texpr.get_locus ());\n+\n+      return;\n+    }\n+\n+  auto get_parameter_tyty_at_index\n+    = [] (const TyTy::BaseType *base, size_t index,\n+\t  TyTy::BaseType **result) -> bool {\n+    bool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t || base->get_kind () == TyTy::TypeKind::FNPTR;\n+    rust_assert (is_fn);\n+\n+    if (base->get_kind () == TyTy::TypeKind::FNPTR)\n+      {\n+\tconst TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n+\t*result = fn->param_at (index);\n+\n+\treturn true;\n+      }\n+\n+    const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n+    auto param = fn->param_at (index);\n+    *result = param.second;\n+\n+    return true;\n+  };\n+\n+  bool is_varadic = false;\n+  if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+      is_varadic = fn->is_varadic ();\n+    }\n+\n+  size_t required_num_args;\n+  if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+      required_num_args = fn->num_params ();\n+    }\n+  else\n+    {\n+      const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n+      required_num_args = fn->num_params ();\n+    }\n+\n+  std::vector<tree> args;\n+  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+    {\n+      auto &argument = expr.get_arguments ().at (i);\n+      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+      if (is_varadic && i >= required_num_args)\n+\t{\n+\t  args.push_back (rvalue);\n+\t  continue;\n+\t}\n+\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary\n+      bool ok;\n+      TyTy::BaseType *expected = nullptr;\n+      ok = get_parameter_tyty_at_index (tyty, i, &expected);\n+      rust_assert (ok);\n+\n+      TyTy::BaseType *actual = nullptr;\n+      ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+      rust_assert (ok);\n+\n+      // coerce it if required\n+      Location lvalue_locus\n+\t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+      Location rvalue_locus = argument->get_locus ();\n+      rvalue = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t      actual, expected, lvalue_locus, rvalue_locus);\n+\n+      // add it to the list\n+      args.push_back (rvalue);\n+    }\n+\n+  // must be a call to a function\n+  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+  translated = ctx->get_backend ()->call_expression (fn_address, args, nullptr,\n+\t\t\t\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  // method receiver\n+  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // lookup the expected function type\n+  TyTy::BaseType *lookup_fntype = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_method_name ().get_mappings ().get_hirid (), &lookup_fntype);\n+  rust_assert (ok);\n+  rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  tree fn_expr = error_mark_node;\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      for (auto &arg : expr.get_arguments ())\n+\targuments.push_back (arg.get ());\n+\n+      fn_expr\n+\t= get_fn_addr_from_dyn (dyn, receiver, fntype, self, expr.get_locus ());\n+      self = get_receiver_from_dyn (dyn, receiver, fntype, self,\n+\t\t\t\t    expr.get_locus ());\n+    }\n+  else\n+    {\n+      // lookup compiled functions since it may have already been compiled\n+      HIR::PathExprSegment method_name = expr.get_method_name ();\n+      HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+      fn_expr\n+\t= resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t\t  expr.get_mappings (), expr.get_locus ());\n+    }\n+\n+  // lookup the autoderef mappings\n+  HirId autoderef_mappings_id\n+    = expr.get_receiver ()->get_mappings ().get_hirid ();\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t\t\t     &adjustments);\n+  rust_assert (ok);\n+\n+  // apply adjustments for the fn call\n+  self = resolve_adjustements (*adjustments, self,\n+\t\t\t       expr.get_receiver ()->get_locus ());\n+\n+  std::vector<tree> args;\n+  args.push_back (self); // adjusted self\n+\n+  // normal args\n+  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+    {\n+      auto &argument = expr.get_arguments ().at (i);\n+      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary, offset from the already adjusted implicit self\n+      bool ok;\n+      TyTy::BaseType *expected = fntype->param_at (i + 1).second;\n+\n+      TyTy::BaseType *actual = nullptr;\n+      ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+      rust_assert (ok);\n+\n+      // coerce it if required\n+      Location lvalue_locus\n+\t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+      Location rvalue_locus = argument->get_locus ();\n+      rvalue = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t      actual, expected, lvalue_locus, rvalue_locus);\n+\n+      // add it to the list\n+      args.push_back (rvalue);\n+    }\n+\n+  translated = ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+\t\t\t\t\t\t     expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t   TyTy::BaseType *receiver,\n+\t\t\t\t   TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t   Location expr_locus)\n+{\n+  size_t offs = 0;\n+  const Resolver::TraitItemReference *ref = nullptr;\n+  for (auto &bound : dyn->get_object_items ())\n+    {\n+      const Resolver::TraitItemReference *item = bound.first;\n+      auto t = item->get_tyty ();\n+      rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n+      auto ft = static_cast<TyTy::FnType *> (t);\n+\n+      if (ft->get_id () == fntype->get_id ())\n+\t{\n+\t  ref = item;\n+\t  break;\n+\t}\n+      offs++;\n+    }\n+\n+  if (ref == nullptr)\n+    return error_mark_node;\n+\n+  // get any indirection sorted out\n+  if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      tree indirect = indirect_expression (receiver_ref, expr_locus);\n+      receiver_ref = indirect;\n+    }\n+\n+  // cast it to the correct fntype\n+  tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  tree idx = build_int_cst (size_type_node, offs);\n+\n+  tree vtable_ptr\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, 1,\n+\t\t\t\t\t\t    expr_locus);\n+  tree vtable_array_access = build4_loc (expr_locus.gcc_location (), ARRAY_REF,\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (vtable_ptr)),\n+\t\t\t\t\t vtable_ptr, idx, NULL_TREE, NULL_TREE);\n+\n+  tree vcall\n+    = build3_loc (expr_locus.gcc_location (), OBJ_TYPE_REF, expected_fntype,\n+\t\t  vtable_array_access, receiver_ref, idx);\n+\n+  return vcall;\n+}\n+\n+tree\n+CompileExpr::get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t    TyTy::BaseType *receiver,\n+\t\t\t\t    TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t    Location expr_locus)\n+{\n+  // get any indirection sorted out\n+  if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      tree indirect = indirect_expression (receiver_ref, expr_locus);\n+      receiver_ref = indirect;\n+    }\n+\n+  // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+  return ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t       expr_locus);\n+}\n+\n+tree\n+CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t\t     TyTy::BaseType *receiver,\n+\t\t\t\t     HIR::PathIdentSegment &segment,\n+\t\t\t\t     Analysis::NodeMapping expr_mappings,\n+\t\t\t\t     Location expr_locus)\n+{\n+  // lookup compiled functions since it may have already been compiled\n+  tree fn = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+    {\n+      return address_expression (fn, expr_locus);\n+    }\n+\n+  // Now we can try and resolve the address since this might be a forward\n+  // declared function, generic function which has not be compiled yet or\n+  // its an not yet trait bound function\n+  HIR::ImplItem *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_implitem (ref, nullptr);\n+  if (resolved_item != nullptr)\n+    {\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (resolved_item, ctx);\n+\n+      return CompileInherentImplItem::Compile (resolved_item, ctx, fntype);\n+    }\n+\n+  // it might be resolved to a trait item\n+  HIR::TraitItem *trait_item\n+    = ctx->get_mappings ()->lookup_hir_trait_item (ref);\n+  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+    trait_item->get_mappings ().get_hirid ());\n+\n+  Resolver::TraitReference *trait_ref\n+    = &Resolver::TraitReference::error_node ();\n+  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+    trait->get_mappings ().get_defid (), &trait_ref);\n+  rust_assert (ok);\n+\n+  // the type resolver can only resolve type bounds to their trait\n+  // item so its up to us to figure out if this path should resolve\n+  // to an trait-impl-block-item or if it can be defaulted to the\n+  // trait-impl-item's definition\n+\n+  auto root = receiver->get_root ();\n+  std::vector<Resolver::PathProbeCandidate> candidates\n+    = Resolver::PathProbeType::Probe (root, segment, true /* probe_impls */,\n+\t\t\t\t      false /* probe_bounds */,\n+\t\t\t\t      true /* ignore_mandatory_trait_items */);\n+  if (candidates.size () == 0)\n+    {\n+      // this means we are defaulting back to the trait_item if\n+      // possible\n+      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+      bool ok = trait_ref->lookup_hir_trait_item (*trait_item, &trait_item_ref);\n+      rust_assert (ok);\t\t\t\t    // found\n+      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+      // FIXME Optional means it has a definition and an associated\n+      // block which can be a default implementation, if it does not\n+      // contain an implementation we should actually return\n+      // error_mark_node\n+\n+      return CompileTraitItem::Compile (trait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\tctx, fntype, true, expr_locus);\n+    }\n+  else\n+    {\n+      // FIXME this will be a case to return error_mark_node, there is\n+      // an error scenario where a Trait Foo has a method Bar, but this\n+      // receiver does not implement this trait or has an incompatible\n+      // implementation and we should just return error_mark_node\n+\n+      rust_assert (candidates.size () == 1);\n+      auto &candidate = candidates.at (0);\n+      rust_assert (candidate.is_impl_candidate ());\n+      rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);\n+\n+      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+      if (!candidate_call->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (impl_item, ctx);\n+\n+      TyTy::BaseType *monomorphized = candidate_call;\n+      if (candidate_call->needs_generic_substitutions ())\n+\t{\n+\t  TyTy::BaseType *infer_impl_call\n+\t    = candidate_call->infer_substitions (expr_locus);\n+\t  monomorphized = infer_impl_call->unify (fntype);\n+\t}\n+\n+      return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n+    }\n+}\n+\n+tree\n+CompileExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n+  tree lhs, tree rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n+{\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  rust_assert (is_op_overload);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  bool ok = ctx->get_resolver ()->lookup_resolved_name (\n+    expr.get_mappings ().get_nodeid (), &resolved_node_id);\n+  rust_assert (ok);\n+\n+  // reverse lookup\n+  HirId ref;\n+  ok = ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref);\n+  rust_assert (ok);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathIdentSegment segment_name (\n+    Analysis::RustLangItem::ToString (lang_item_type));\n+  tree fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_lvalue_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  // apply adjustments for the fn call\n+  tree self = resolve_adjustements (*adjustments, lhs, lhs_expr->get_locus ());\n+\n+  std::vector<tree> args;\n+  args.push_back (self); // adjusted self\n+  if (rhs != nullptr)\t // can be null for negation_expr (unary ones)\n+    args.push_back (rhs);\n+\n+  return ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+\t\t\t\t\t       expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::compile_bool_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t   const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::BOOL);\n+\n+  const auto literal_value = expr.get_literal ();\n+  bool bval = literal_value.as_string ().compare (\"true\") == 0;\n+  return ctx->get_backend ()->boolean_constant_expression (bval);\n+}\n+\n+tree\n+CompileExpr::compile_integer_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t      const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::INT);\n+  const auto literal_value = expr.get_literal ();\n+\n+  tree type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  mpz_t ival;\n+  if (mpz_init_set_str (ival, literal_value.as_string ().c_str (), 10) != 0)\n+    {\n+      rust_error_at (expr.get_locus (), \"bad number in literal\");\n+      return error_mark_node;\n+    }\n+\n+  mpz_t type_min;\n+  mpz_t type_max;\n+  mpz_init (type_min);\n+  mpz_init (type_max);\n+  get_type_static_bounds (type, type_min, type_max);\n+\n+  if (mpz_cmp (ival, type_min) < 0 || mpz_cmp (ival, type_max) > 0)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"integer overflows the respective type %<%s%>\",\n+\t\t     tyty->get_name ().c_str ());\n+      return error_mark_node;\n+    }\n+\n+  tree result = wide_int_to_tree (type, wi::from_mpz (type, ival, true));\n+\n+  mpz_clear (type_min);\n+  mpz_clear (type_max);\n+  mpz_clear (ival);\n+\n+  return result;\n+}\n+\n+tree\n+CompileExpr::compile_float_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t    const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::FLOAT);\n+  const auto literal_value = expr.get_literal ();\n+\n+  mpfr_t fval;\n+  if (mpfr_init_set_str (fval, literal_value.as_string ().c_str (), 10,\n+\t\t\t MPFR_RNDN)\n+      != 0)\n+    {\n+      rust_error_at (expr.get_locus (), \"bad number in literal\");\n+      return error_mark_node;\n+    }\n+\n+  tree type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // taken from:\n+  // see go/gofrontend/expressions.cc:check_float_type\n+  mpfr_exp_t exp = mpfr_get_exp (fval);\n+  bool real_value_overflow = exp > TYPE_PRECISION (type);\n+\n+  REAL_VALUE_TYPE r1;\n+  real_from_mpfr (&r1, fval, type, GMP_RNDN);\n+  REAL_VALUE_TYPE r2;\n+  real_convert (&r2, TYPE_MODE (type), &r1);\n+\n+  tree real_value = build_real (type, r2);\n+  if (TREE_OVERFLOW (real_value) || real_value_overflow)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"decimal overflows the respective type %<%s%>\",\n+\t\t     tyty->get_name ().c_str ());\n+      return error_mark_node;\n+    }\n+\n+  return real_value;\n+}\n+\n+tree\n+CompileExpr::compile_char_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t   const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::CHAR);\n+  const auto literal_value = expr.get_literal ();\n+\n+  // FIXME needs wchar_t\n+  char c = literal_value.as_string ().c_str ()[0];\n+  return ctx->get_backend ()->wchar_constant_expression (c);\n+}\n+\n+tree\n+CompileExpr::compile_byte_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t   const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::BYTE);\n+  const auto literal_value = expr.get_literal ();\n+\n+  tree type = TyTyResolveCompile::compile (ctx, tyty);\n+  char c = literal_value.as_string ().c_str ()[0];\n+  return build_int_cst (type, c);\n+}\n+\n+tree\n+CompileExpr::compile_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t     const TyTy::BaseType *tyty)\n+{\n+  tree fat_pointer = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  rust_assert (expr.get_lit_type () == HIR::Literal::STRING);\n+  const auto literal_value = expr.get_literal ();\n+\n+  auto base = ctx->get_backend ()->string_constant_expression (\n+    literal_value.as_string ());\n+  tree data = address_expression (base, expr.get_locus ());\n+\n+  TyTy::BaseType *usize = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n+  rust_assert (ok);\n+  tree type = TyTyResolveCompile::compile (ctx, usize);\n+\n+  tree size = build_int_cstu (type, literal_value.as_string ().size ());\n+\n+  return ctx->get_backend ()->constructor_expression (fat_pointer, false,\n+\t\t\t\t\t\t      {data, size}, -1,\n+\t\t\t\t\t\t      expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::compile_byte_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t\t  const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::BYTE_STRING);\n+\n+  // the type here is &[ty; capacity]\n+  rust_assert (tyty->get_kind () == TyTy::TypeKind::REF);\n+  const auto ref_tyty = static_cast<const TyTy::ReferenceType *> (tyty);\n+  auto base_tyty = ref_tyty->get_base ();\n+  rust_assert (base_tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n+\n+  std::string value_str = expr.get_literal ().as_string ();\n+  std::vector<tree> vals;\n+  std::vector<unsigned long> indexes;\n+  for (size_t i = 0; i < value_str.size (); i++)\n+    {\n+      char b = value_str.at (i);\n+      tree bb = ctx->get_backend ()->char_constant_expression (b);\n+      vals.push_back (bb);\n+      indexes.push_back (i);\n+    }\n+\n+  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+  tree constructed\n+    = ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n+\t\t\t\t\t\t\t vals,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+\n+  return address_expression (constructed, expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::type_cast_expression (tree type_to_cast_to, tree expr_tree,\n+\t\t\t\t   Location location)\n+{\n+  if (type_to_cast_to == error_mark_node || expr_tree == error_mark_node\n+      || TREE_TYPE (expr_tree) == error_mark_node)\n+    return error_mark_node;\n+\n+  if (ctx->get_backend ()->type_size (type_to_cast_to) == 0\n+      || TREE_TYPE (expr_tree) == void_type_node)\n+    {\n+      // Do not convert zero-sized types.\n+      return expr_tree;\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == INTEGER_TYPE)\n+    {\n+      tree cast = convert_to_integer (type_to_cast_to, expr_tree);\n+      // FIXME check for TREE_OVERFLOW?\n+      return cast;\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == REAL_TYPE)\n+    {\n+      tree cast = convert_to_real (type_to_cast_to, expr_tree);\n+      // FIXME\n+      // We might need to check that the tree is MAX val and thusly saturate it\n+      // to inf. we can get the bounds and check the value if its >= or <= to\n+      // the min and max bounds\n+      //\n+      // https://github.com/Rust-GCC/gccrs/issues/635\n+      return cast;\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == COMPLEX_TYPE)\n+    {\n+      return convert_to_complex (type_to_cast_to, expr_tree);\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (expr_tree)) == INTEGER_TYPE)\n+    {\n+      return convert_to_pointer (type_to_cast_to, expr_tree);\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == RECORD_TYPE\n+\t   || TREE_CODE (type_to_cast_to) == ARRAY_TYPE)\n+    {\n+      return fold_build1_loc (location.gcc_location (), VIEW_CONVERT_EXPR,\n+\t\t\t      type_to_cast_to, expr_tree);\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == POINTER_TYPE\n+\t   && SLICE_TYPE_P (TREE_TYPE (expr_tree)))\n+    {\n+      // returning a raw cast using NOP_EXPR seems to resut in an ICE:\n+      //\n+      // Analyzing compilation unit\n+      // Performing interprocedural optimizations\n+      //  <*free_lang_data> {heap 2644k} <visibility> {heap 2644k}\n+      //  <build_ssa_passes> {heap 2644k} <opt_local_passes> {heap 2644k}during\n+      //  GIMPLE pass: cddce\n+      // In function \u2018*T::as_ptr<i32>\u2019:\n+      // rust1: internal compiler error: in propagate_necessity, at\n+      // tree-ssa-dce.cc:984 0x1d5b43e propagate_necessity\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:984\n+      // 0x1d5e180 perform_tree_ssa_dce\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:1876\n+      // 0x1d5e2c8 tree_ssa_cd_dce\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:1920\n+      // 0x1d5e49a execute\n+      //         ../../gccrs/gcc/tree-ssa-dce.cc:1992\n+\n+      // this is returning the direct raw pointer of the slice an assumes a very\n+      // specific layout\n+      return ctx->get_backend ()->struct_field_expression (expr_tree, 0,\n+\t\t\t\t\t\t\t   location);\n+    }\n+\n+  return fold_convert_loc (location.gcc_location (), type_to_cast_to,\n+\t\t\t   expr_tree);\n+}\n+\n+void\n+CompileExpr::visit (HIR::ArrayExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this array expr\");\n+      return;\n+    }\n+\n+  tree array_type = TyTyResolveCompile::compile (ctx, tyty);\n+  if (TREE_CODE (array_type) != ARRAY_TYPE)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  rust_assert (tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+  const TyTy::ArrayType &array_tyty\n+    = static_cast<const TyTy::ArrayType &> (*tyty);\n+\n+  HIR::ArrayElems &elements = *expr.get_internal_elements ();\n+  switch (elements.get_array_expr_type ())\n+    {\n+      case HIR::ArrayElems::ArrayExprType::VALUES: {\n+\tHIR::ArrayElemsValues &elems\n+\t  = static_cast<HIR::ArrayElemsValues &> (elements);\n+\ttranslated\n+\t  = array_value_expr (expr.get_locus (), array_tyty, array_type, elems);\n+      }\n+      return;\n+\n+    case HIR::ArrayElems::ArrayExprType::COPIED:\n+      HIR::ArrayElemsCopied &elems\n+\t= static_cast<HIR::ArrayElemsCopied &> (elements);\n+      translated\n+\t= array_copied_expr (expr.get_locus (), array_tyty, array_type, elems);\n+    }\n+}\n+\n+tree\n+CompileExpr::array_value_expr (Location expr_locus,\n+\t\t\t       const TyTy::ArrayType &array_tyty,\n+\t\t\t       tree array_type, HIR::ArrayElemsValues &elems)\n+{\n+  std::vector<unsigned long> indexes;\n+  std::vector<tree> constructor;\n+  size_t i = 0;\n+  for (auto &elem : elems.get_values ())\n+    {\n+      tree translated_expr = CompileExpr::Compile (elem.get (), ctx);\n+      constructor.push_back (translated_expr);\n+      indexes.push_back (i++);\n+    }\n+\n+  return ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n+\t\t\t\t\t\t\t    constructor,\n+\t\t\t\t\t\t\t    expr_locus);\n+}\n+\n+tree\n+CompileExpr::array_copied_expr (Location expr_locus,\n+\t\t\t\tconst TyTy::ArrayType &array_tyty,\n+\t\t\t\ttree array_type, HIR::ArrayElemsCopied &elems)\n+{\n+  //  see gcc/cp/typeck2.cc:1369-1401\n+  gcc_assert (TREE_CODE (array_type) == ARRAY_TYPE);\n+  tree domain = TYPE_DOMAIN (array_type);\n+  if (!domain)\n+    return error_mark_node;\n+\n+  if (!TREE_CONSTANT (TYPE_MAX_VALUE (domain)))\n+    {\n+      rust_error_at (expr_locus, \"non const capacity domain %qT\", array_type);\n+      return error_mark_node;\n+    }\n+\n+  tree capacity_expr = CompileExpr::Compile (elems.get_num_copies_expr (), ctx);\n+  if (!TREE_CONSTANT (capacity_expr))\n+    {\n+      rust_error_at (expr_locus, \"non const num copies %qT\", array_type);\n+      return error_mark_node;\n+    }\n+\n+  // get the compiled value\n+  tree translated_expr = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n+\n+  tree max_domain = TYPE_MAX_VALUE (domain);\n+  tree min_domain = TYPE_MIN_VALUE (domain);\n+\n+  auto max = wi::to_offset (max_domain);\n+  auto min = wi::to_offset (min_domain);\n+  auto precision = TYPE_PRECISION (TREE_TYPE (domain));\n+  auto sign = TYPE_SIGN (TREE_TYPE (domain));\n+  unsigned HOST_WIDE_INT len\n+    = wi::ext (max - min + 1, precision, sign).to_uhwi ();\n+\n+  // In a const context we must initialize the entire array, which entails\n+  // allocating for each element. If the user wants a huge array, we will OOM\n+  // and die horribly.\n+  if (ctx->const_context_p ())\n+    {\n+      size_t idx = 0;\n+      std::vector<unsigned long> indexes;\n+      std::vector<tree> constructor;\n+      for (unsigned HOST_WIDE_INT i = 0; i < len; i++)\n+\t{\n+\t  constructor.push_back (translated_expr);\n+\t  indexes.push_back (idx++);\n+\t}\n+\n+      return ctx->get_backend ()->array_constructor_expression (array_type,\n+\t\t\t\t\t\t\t\tindexes,\n+\t\t\t\t\t\t\t\tconstructor,\n+\t\t\t\t\t\t\t\texpr_locus);\n+    }\n+\n+  else\n+    {\n+      // Create a new block scope in which to initialize the array\n+      tree fndecl = NULL_TREE;\n+      if (ctx->in_fn ())\n+\tfndecl = ctx->peek_fn ().fndecl;\n+\n+      std::vector<Bvariable *> locals;\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree init_block\n+\t= ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t      expr_locus, expr_locus);\n+      ctx->push_block (init_block);\n+\n+      tree tmp;\n+      tree stmts\n+\t= ctx->get_backend ()->array_initializer (fndecl, init_block,\n+\t\t\t\t\t\t  array_type, capacity_expr,\n+\t\t\t\t\t\t  translated_expr, &tmp,\n+\t\t\t\t\t\t  expr_locus);\n+      ctx->add_statement (stmts);\n+\n+      tree block = ctx->pop_block ();\n+\n+      // The result is a compound expression which creates a temporary array,\n+      // initializes all the elements in a loop, and then yeilds the array.\n+      return ctx->get_backend ()->compound_expression (block, tmp, expr_locus);\n+    }\n+}\n+\n+tree\n+HIRCompileBase::resolve_adjustements (\n+  std::vector<Resolver::Adjustment> &adjustments, tree expression,\n+  Location locus)\n+{\n+  tree e = expression;\n+  for (auto &adjustment : adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::ERROR:\n+\t  return error_mark_node;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\t  case Resolver::Adjustment::AdjustmentType::MUT_REF: {\n+\t    if (!SLICE_TYPE_P (TREE_TYPE (e)))\n+\t      {\n+\t\te = address_expression (e, locus);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF:\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_MUT:\n+\t  e = resolve_deref_adjustment (adjustment, e, locus);\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::INDIRECTION:\n+\t  e = resolve_indirection_adjustment (adjustment, e, locus);\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::UNSIZE:\n+\t  e = resolve_unsized_adjustment (adjustment, e, locus);\n+\t  break;\n+\t}\n+    }\n+\n+  return e;\n+}\n+\n+tree\n+HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t\t  tree expression, Location locus)\n+{\n+  rust_assert (adjustment.is_deref_adjustment ()\n+\t       || adjustment.is_deref_mut_adjustment ());\n+  rust_assert (adjustment.has_operator_overload ());\n+\n+  TyTy::FnType *lookup = adjustment.get_deref_operator_fn ();\n+  HIR::ImplItem *resolved_item = adjustment.get_deref_hir_item ();\n+\n+  tree fn_address = error_mark_node;\n+  if (!lookup->has_subsititions_defined ())\n+    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, nullptr,\n+\t\t\t\t\t\t   true, locus);\n+  else\n+    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, lookup,\n+\t\t\t\t\t\t   true, locus);\n+\n+  // does it need a reference to call\n+  tree adjusted_argument = expression;\n+  bool needs_borrow = adjustment.get_deref_adjustment_type ()\n+\t\t      != Resolver::Adjustment::AdjustmentType::ERROR;\n+  if (needs_borrow)\n+    {\n+      adjusted_argument = address_expression (expression, locus);\n+    }\n+\n+  // make the call\n+  return ctx->get_backend ()->call_expression (fn_address, {adjusted_argument},\n+\t\t\t\t\t       nullptr, locus);\n+}\n+\n+tree\n+HIRCompileBase::resolve_indirection_adjustment (\n+  Resolver::Adjustment &adjustment, tree expression, Location locus)\n+{\n+  return indirect_expression (expression, locus);\n+}\n+\n+tree\n+HIRCompileBase::resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t\t    tree expression, Location locus)\n+{\n+  bool expect_slice\n+    = adjustment.get_expected ()->get_kind () == TyTy::TypeKind::SLICE;\n+  bool expect_dyn\n+    = adjustment.get_expected ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+  // assumes this is an array\n+  tree expr_type = TREE_TYPE (expression);\n+  if (expect_slice)\n+    {\n+      rust_assert (TREE_CODE (expr_type) == ARRAY_TYPE);\n+      return resolve_unsized_slice_adjustment (adjustment, expression, locus);\n+    }\n+\n+  rust_assert (expect_dyn);\n+  return resolve_unsized_dyn_adjustment (adjustment, expression, locus);\n+}\n+\n+tree\n+HIRCompileBase::resolve_unsized_slice_adjustment (\n+  Resolver::Adjustment &adjustment, tree expression, Location locus)\n+{\n+  // assumes this is an array\n+  tree expr_type = TREE_TYPE (expression);\n+  rust_assert (TREE_CODE (expr_type) == ARRAY_TYPE);\n+\n+  // takes an array and returns a fat-pointer so this becomes a constructor\n+  // expression\n+  rust_assert (adjustment.get_expected ()->get_kind ()\n+\t       == TyTy::TypeKind::SLICE);\n+  tree fat_pointer\n+    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\n+  // make a constructor for this\n+  tree data = address_expression (expression, locus);\n+\n+  // fetch the size from the domain\n+  tree domain = TYPE_DOMAIN (expr_type);\n+  unsigned HOST_WIDE_INT array_size\n+    = wi::ext (wi::to_offset (TYPE_MAX_VALUE (domain))\n+\t\t - wi::to_offset (TYPE_MIN_VALUE (domain)) + 1,\n+\t       TYPE_PRECISION (TREE_TYPE (domain)),\n+\t       TYPE_SIGN (TREE_TYPE (domain)))\n+\t.to_uhwi ();\n+  tree size = build_int_cstu (size_type_node, array_size);\n+\n+  return ctx->get_backend ()->constructor_expression (fat_pointer, false,\n+\t\t\t\t\t\t      {data, size}, -1, locus);\n+}\n+\n+tree\n+HIRCompileBase::resolve_unsized_dyn_adjustment (\n+  Resolver::Adjustment &adjustment, tree expression, Location locus)\n+{\n+  tree rvalue = expression;\n+  Location rvalue_locus = locus;\n+\n+  const TyTy::BaseType *actual = adjustment.get_actual ();\n+  const TyTy::BaseType *expected = adjustment.get_expected ();\n+\n+  const TyTy::DynamicObjectType *dyn\n+    = static_cast<const TyTy::DynamicObjectType *> (expected);\n+\n+  rust_debug (\"resolve_unsized_dyn_adjustment actual={%s} dyn={%s}\",\n+\t      actual->debug_str ().c_str (), dyn->debug_str ().c_str ());\n+\n+  return coerce_to_dyn_object (rvalue, actual, dyn, rvalue_locus);\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFromToExpr &expr)\n+{\n+  tree from = CompileExpr::Compile (expr.get_from_expr ().get (), ctx);\n+  tree to = CompileExpr::Compile (expr.get_to_expr ().get (), ctx);\n+  if (from == error_mark_node || to == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {from, to}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFromExpr &expr)\n+{\n+  tree from = CompileExpr::Compile (expr.get_from_expr ().get (), ctx);\n+  if (from == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {from}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeToExpr &expr)\n+{\n+  tree to = CompileExpr::Compile (expr.get_to_expr ().get (), ctx);\n+  if (to == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {to}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFullExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+  translated = ctx->get_backend ()->constructor_expression (adt, false, {}, -1,\n+\t\t\t\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::RangeFromToInclExpr &expr)\n+{\n+  tree from = CompileExpr::Compile (expr.get_from_expr ().get (), ctx);\n+  tree to = CompileExpr::Compile (expr.get_to_expr ().get (), ctx);\n+  if (from == error_mark_node || to == error_mark_node)\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (), &tyty);\n+  rust_assert (ok);\n+\n+  tree adt = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // make the constructor\n+  translated\n+    = ctx->get_backend ()->constructor_expression (adt, false, {from, to}, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n+{\n+  tree array_reference = CompileExpr::Compile (expr.get_array_expr (), ctx);\n+  tree index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n+\n+  // this might be an core::ops::index lang item situation\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type = Analysis::RustLangItem::ItemType::INDEX;\n+      tree operator_overload_call\n+\t= resolve_operator_overload (lang_item_type, expr, array_reference,\n+\t\t\t\t     index, expr.get_array_expr (),\n+\t\t\t\t     expr.get_index_expr ());\n+\n+      tree actual_type = TREE_TYPE (operator_overload_call);\n+      bool can_indirect = TYPE_PTR_P (actual_type) || TYPE_REF_P (actual_type);\n+      if (!can_indirect)\n+\t{\n+\t  // nothing to do\n+\t  translated = operator_overload_call;\n+\t  return;\n+\t}\n+\n+      // rust deref always returns a reference from this overload then we can\n+      // actually do the indirection\n+      translated\n+\t= indirect_expression (operator_overload_call, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lets check if the array is a reference type then we can add an\n+  // indirection if required\n+  TyTy::BaseType *array_expr_ty = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_array_expr ()->get_mappings ().get_hirid (), &array_expr_ty);\n+  rust_assert (ok);\n+\n+  // do we need to add an indirect reference\n+  if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      array_reference\n+\t= indirect_expression (array_reference, expr.get_locus ());\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->array_index_expression (array_reference, index,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "4c1f95ade29d589182e136985b3dcd6f05ecc40c", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,148 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_EXPR\n+#define RUST_COMPILE_EXPR\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n+{\n+public:\n+  static tree Compile (HIR::Expr *expr, Context *ctx);\n+\n+  void visit (HIR::TupleIndexExpr &expr) override;\n+  void visit (HIR::TupleExpr &expr) override;\n+  void visit (HIR::ReturnExpr &expr) override;\n+  void visit (HIR::CallExpr &expr) override;\n+  void visit (HIR::MethodCallExpr &expr) override;\n+  void visit (HIR::LiteralExpr &expr) override;\n+  void visit (HIR::AssignmentExpr &expr) override;\n+  void visit (HIR::CompoundAssignmentExpr &expr) override;\n+  void visit (HIR::ArrayIndexExpr &expr) override;\n+  void visit (HIR::ArrayExpr &expr) override;\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n+  void visit (HIR::ComparisonExpr &expr) override;\n+  void visit (HIR::LazyBooleanExpr &expr) override;\n+  void visit (HIR::NegationExpr &expr) override;\n+  void visit (HIR::TypeCastExpr &expr) override;\n+  void visit (HIR::IfExpr &expr) override;\n+  void visit (HIR::IfExprConseqIf &expr) override;\n+  void visit (HIR::IfExprConseqElse &expr) override;\n+  void visit (HIR::BlockExpr &expr) override;\n+  void visit (HIR::UnsafeBlockExpr &expr) override;\n+  void visit (HIR::StructExprStruct &struct_expr) override;\n+  void visit (HIR::StructExprStructFields &struct_expr) override;\n+  void visit (HIR::GroupedExpr &expr) override;\n+  void visit (HIR::FieldAccessExpr &expr) override;\n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n+  void visit (HIR::PathInExpression &expr) override;\n+  void visit (HIR::LoopExpr &expr) override;\n+  void visit (HIR::WhileLoopExpr &expr) override;\n+  void visit (HIR::BreakExpr &expr) override;\n+  void visit (HIR::ContinueExpr &expr) override;\n+  void visit (HIR::BorrowExpr &expr) override;\n+  void visit (HIR::DereferenceExpr &expr) override;\n+  void visit (HIR::MatchExpr &expr) override;\n+  void visit (HIR::RangeFromToExpr &expr) override;\n+  void visit (HIR::RangeFromExpr &expr) override;\n+  void visit (HIR::RangeToExpr &expr) override;\n+  void visit (HIR::RangeFullExpr &expr) override;\n+  void visit (HIR::RangeFromToInclExpr &expr) override;\n+\n+  // Empty visit for unused Expression HIR nodes.\n+  void visit (HIR::ClosureExprInner &) override {}\n+  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::StructExprFieldIdentifier &) override {}\n+  void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+  void visit (HIR::StructExprFieldIndexValue &) override {}\n+  void visit (HIR::ErrorPropagationExpr &) override {}\n+  void visit (HIR::RangeToInclExpr &) override {}\n+  void visit (HIR::WhileLetLoopExpr &) override {}\n+  void visit (HIR::ForLoopExpr &) override {}\n+  void visit (HIR::IfExprConseqIfLet &) override {}\n+  void visit (HIR::IfLetExpr &) override {}\n+  void visit (HIR::IfLetExprConseqElse &) override {}\n+  void visit (HIR::IfLetExprConseqIf &) override {}\n+  void visit (HIR::IfLetExprConseqIfLet &) override {}\n+  void visit (HIR::AwaitExpr &) override {}\n+  void visit (HIR::AsyncBlockExpr &) override {}\n+\n+protected:\n+  tree get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t     TyTy::BaseType *receiver, TyTy::FnType *fntype,\n+\t\t\t     tree receiver_ref, Location expr_locus);\n+\n+  tree get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n+\t\t\t      TyTy::BaseType *receiver, TyTy::FnType *fntype,\n+\t\t\t      tree receiver_ref, Location expr_locus);\n+\n+  tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t       HIR::PathIdentSegment &segment,\n+\t\t\t       Analysis::NodeMapping expr_mappings,\n+\t\t\t       Location expr_locus);\n+\n+  tree\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExprMeta expr, tree lhs, tree rhs,\n+\t\t\t     HIR::Expr *lhs_expr, HIR::Expr *rhs_expr);\n+\n+  tree compile_bool_literal (const HIR::LiteralExpr &expr,\n+\t\t\t     const TyTy::BaseType *tyty);\n+\n+  tree compile_integer_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\tconst TyTy::BaseType *tyty);\n+\n+  tree compile_float_literal (const HIR::LiteralExpr &expr,\n+\t\t\t      const TyTy::BaseType *tyty);\n+\n+  tree compile_char_literal (const HIR::LiteralExpr &expr,\n+\t\t\t     const TyTy::BaseType *tyty);\n+\n+  tree compile_byte_literal (const HIR::LiteralExpr &expr,\n+\t\t\t     const TyTy::BaseType *tyty);\n+\n+  tree compile_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t       const TyTy::BaseType *tyty);\n+\n+  tree compile_byte_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t    const TyTy::BaseType *tyty);\n+\n+  tree type_cast_expression (tree type_to_cast_to, tree expr, Location locus);\n+\n+  tree array_value_expr (Location expr_locus, const TyTy::ArrayType &array_tyty,\n+\t\t\t tree array_type, HIR::ArrayElemsValues &elems);\n+\n+  tree array_copied_expr (Location expr_locus,\n+\t\t\t  const TyTy::ArrayType &array_tyty, tree array_type,\n+\t\t\t  HIR::ArrayElemsCopied &elems);\n+\n+private:\n+  CompileExpr (Context *ctx);\n+\n+  tree translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_EXPR"}, {"sha": "45a507e03be654e848b3b5639d86b99aa6613982", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,172 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_EXTERN_ITEM\n+#define RUST_COMPILE_EXTERN_ITEM\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-intrinsic.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileExternItem : public HIRCompileBase,\n+\t\t\t  public HIR::HIRExternalItemVisitor\n+{\n+public:\n+  static tree compile (HIR::ExternalItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n+  {\n+    CompileExternItem compiler (ctx, concrete, ref_locus);\n+    item->accept_vis (compiler);\n+\n+    if (is_query_mode && compiler.reference == error_mark_node)\n+      rust_internal_error_at (ref_locus, \"failed to compile extern item: %s\",\n+\t\t\t      item->as_string ().c_str ());\n+\n+    return compiler.reference;\n+  }\n+\n+  void visit (HIR::ExternalStaticItem &item) override\n+  {\n+    // check if its already been compiled\n+    Bvariable *lookup = ctx->get_backend ()->error_variable ();\n+    if (ctx->lookup_var_decl (item.get_mappings ().get_hirid (), &lookup))\n+      {\n+\treference = ctx->get_backend ()->var_expression (lookup, ref_locus);\n+\treturn;\n+      }\n+\n+    TyTy::BaseType *resolved_type = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (item.get_mappings ().get_hirid (),\n+\t\t\t\t\t      &resolved_type);\n+    rust_assert (ok);\n+\n+    std::string name = item.get_item_name ();\n+    // FIXME this is assuming C ABI\n+    std::string asm_name = name;\n+\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    bool is_external = true;\n+    bool is_hidden = false;\n+    bool in_unique_section = false;\n+\n+    Bvariable *static_global\n+      = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n+\t\t\t\t\t      is_hidden, in_unique_section,\n+\t\t\t\t\t      item.get_locus ());\n+    ctx->insert_var_decl (item.get_mappings ().get_hirid (), static_global);\n+    ctx->push_var (static_global);\n+\n+    reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n+  }\n+\n+  void visit (HIR::ExternalFunctionItem &function) override\n+  {\n+    TyTy::BaseType *fntype_tyty;\n+    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t\t &fntype_tyty))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n+\tif (concrete == nullptr)\n+\t  return;\n+\telse\n+\t  {\n+\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+\t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n+\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    tree lookup = NULL_TREE;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t   fntype->get_id (), fntype))\n+      {\n+\treference = address_expression (lookup, ref_locus);\n+\treturn;\n+      }\n+\n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n+    if (fntype->get_abi () == ABI::INTRINSIC)\n+      {\n+\tIntrinsics compile (ctx);\n+\ttree fndecl = compile.compile (fntype);\n+\tctx->insert_function_decl (fntype, fndecl);\n+\treturn;\n+      }\n+\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    std::string ir_symbol_name = function.get_item_name ();\n+    std::string asm_name = function.get_item_name ();\n+    if (fntype->get_abi () == ABI::RUST)\n+      {\n+\t// then we need to get the canonical path of it and mangle it\n+\tconst Resolver::CanonicalPath *canonical_path = nullptr;\n+\tbool ok = ctx->get_mappings ()->lookup_canonical_path (\n+\t  function.get_mappings ().get_nodeid (), &canonical_path);\n+\trust_assert (ok);\n+\n+\tir_symbol_name = canonical_path->get () + fntype->subst_as_string ();\n+\tasm_name = ctx->mangle_item (fntype, *canonical_path);\n+      }\n+\n+    const unsigned int flags = Backend::function_is_declaration;\n+    tree fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n+\t\t\t\t       asm_name, flags, function.get_locus ());\n+    TREE_PUBLIC (fndecl) = 1;\n+    setup_abi_options (fndecl, fntype->get_abi ());\n+\n+    ctx->insert_function_decl (fntype, fndecl);\n+\n+    reference = address_expression (fndecl, ref_locus);\n+  }\n+\n+private:\n+  CompileExternItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete), reference (error_mark_node),\n+      ref_locus (ref_locus)\n+  {}\n+\n+  TyTy::BaseType *concrete;\n+  tree reference;\n+  Location ref_locus;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_EXTERN_ITEM"}, {"sha": "3f0ec82b625336cd650ab26c1a38b6efabbd081d", "filename": "gcc/rust/backend/rust-compile-fnparam.cc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,121 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-compile-pattern.h\"\n+\n+#include \"gimple-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileFnParam::CompileFnParam (Context *ctx, tree fndecl, tree decl_type,\n+\t\t\t\tLocation locus)\n+  : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type), locus (locus),\n+    compiled_param (ctx->get_backend ()->error_variable ())\n+{}\n+\n+Bvariable *\n+CompileFnParam::compile (Context *ctx, tree fndecl, HIR::FunctionParam *param,\n+\t\t\t tree decl_type, Location locus)\n+{\n+  CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+  param->get_param_name ()->accept_vis (compiler);\n+  return compiler.compiled_param;\n+}\n+\n+Bvariable *\n+CompileFnParam::compile (Context *ctx, tree fndecl, HIR::Pattern *param,\n+\t\t\t tree decl_type, Location locus)\n+{\n+  CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+  param->accept_vis (compiler);\n+  return compiler.compiled_param;\n+}\n+\n+void\n+CompileFnParam::visit (HIR::IdentifierPattern &pattern)\n+{\n+  if (!pattern.is_mut ())\n+    decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+  compiled_param\n+    = ctx->get_backend ()->parameter_variable (fndecl,\n+\t\t\t\t\t       pattern.get_identifier (),\n+\t\t\t\t\t       decl_type, locus);\n+}\n+\n+void\n+CompileFnParam::visit (HIR::WildcardPattern &pattern)\n+{\n+  decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+  compiled_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"_\", decl_type, locus);\n+}\n+\n+void\n+CompileFnParam::visit (HIR::StructPattern &pattern)\n+{\n+  // generate the anon param\n+  tree tmp_ident = create_tmp_var_name (\"RSTPRM\");\n+  std::string cpp_str_identifier = std::string (IDENTIFIER_POINTER (tmp_ident));\n+\n+  decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+  compiled_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, cpp_str_identifier,\n+\t\t\t\t\t       decl_type, locus);\n+\n+  // setup the pattern bindings\n+  tree anon_param = ctx->get_backend ()->var_expression (compiled_param, locus);\n+  CompilePatternBindings::Compile (&pattern, anon_param, ctx);\n+}\n+\n+void\n+CompileFnParam::visit (HIR::TupleStructPattern &pattern)\n+{\n+  // generate the anon param\n+  tree tmp_ident = create_tmp_var_name (\"RSTPRM\");\n+  std::string cpp_str_identifier = std::string (IDENTIFIER_POINTER (tmp_ident));\n+\n+  decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+  compiled_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, cpp_str_identifier,\n+\t\t\t\t\t       decl_type, locus);\n+\n+  // setup the pattern bindings\n+  tree anon_param = ctx->get_backend ()->var_expression (compiled_param, locus);\n+  CompilePatternBindings::Compile (&pattern, anon_param, ctx);\n+}\n+\n+Bvariable *\n+CompileSelfParam::compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n+\t\t\t   tree decl_type, Location locus)\n+{\n+  bool is_immutable\n+    = self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM\n+      || self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM_REF;\n+  if (is_immutable)\n+    decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+  return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n+\t\t\t\t\t\t  locus);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "0dbbd99ef08d66f1b74045bc2f0afa127c00f7d2", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_FNPARAM\n+#define RUST_COMPILE_FNPARAM\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileFnParam : private HIRCompileBase, protected HIR::HIRPatternVisitor\n+{\n+public:\n+  static Bvariable *compile (Context *ctx, tree fndecl,\n+\t\t\t     HIR::FunctionParam *param, tree decl_type,\n+\t\t\t     Location locus);\n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::Pattern *param,\n+\t\t\t     tree decl_type, Location locus);\n+\n+  void visit (HIR::IdentifierPattern &pattern) override;\n+  void visit (HIR::WildcardPattern &pattern) override;\n+  void visit (HIR::StructPattern &) override;\n+  void visit (HIR::TupleStructPattern &) override;\n+\n+  // Empty visit for unused Pattern HIR nodes.\n+  void visit (HIR::GroupedPattern &) override {}\n+  void visit (HIR::LiteralPattern &) override {}\n+  void visit (HIR::PathInExpression &) override {}\n+  void visit (HIR::QualifiedPathInExpression &) override {}\n+  void visit (HIR::RangePattern &) override {}\n+  void visit (HIR::ReferencePattern &) override {}\n+  void visit (HIR::SlicePattern &) override {}\n+  void visit (HIR::TuplePattern &) override {}\n+\n+private:\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus);\n+\n+  tree fndecl;\n+  tree decl_type;\n+  Location locus;\n+  Bvariable *compiled_param;\n+};\n+\n+class CompileSelfParam : private HIRCompileBase\n+{\n+public:\n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n+\t\t\t     tree decl_type, Location locus);\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_FNPARAM"}, {"sha": "d0f70a702282dbf03cec1ba312166e5e1521a5d5", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,101 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileTraitItem::visit (HIR::TraitItemConst &constant)\n+{\n+  rust_assert (concrete != nullptr);\n+  TyTy::BaseType *resolved_type = concrete;\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    constant.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  HIR::Expr *const_value_expr = constant.get_expr ().get ();\n+  tree const_expr\n+    = compile_constant_item (ctx, resolved_type, canonical_path,\n+\t\t\t     const_value_expr, constant.get_locus ());\n+  ctx->push_const (const_expr);\n+  ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+  reference = const_expr;\n+}\n+\n+void\n+CompileTraitItem::visit (HIR::TraitItemFunc &func)\n+{\n+  rust_assert (func.has_block_defined ());\n+\n+  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+  fntype->monomorphize ();\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\n+\t  reference = address_expression (lookup, ref_locus);\n+\t  return;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    func.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  // FIXME: How do we get the proper visibility here?\n+  auto vis = HIR::Visibility (HIR::Visibility::VisType::PUBLIC);\n+  HIR::TraitFunctionDecl &function = func.get_decl ();\n+  tree fndecl\n+    = compile_function (ctx, function.get_function_name (),\n+\t\t\tfunction.get_self (), function.get_function_params (),\n+\t\t\tfunction.get_qualifiers (), vis,\n+\t\t\tfunc.get_outer_attrs (), func.get_locus (),\n+\t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n+\t\t\tfunction.has_return_type ());\n+  reference = address_expression (fndecl, ref_locus);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "ac9478af150b3aa6571ea6060e9b38c050104d23", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_IMPLITEM_H\n+#define RUST_COMPILE_IMPLITEM_H\n+\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+// this is a proxy for HIR::ImplItem's back to use the normel HIR::Item path\n+class CompileInherentImplItem : public CompileItem\n+{\n+public:\n+  static tree Compile (HIR::ImplItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n+  {\n+    CompileInherentImplItem compiler (ctx, concrete, ref_locus);\n+    item->accept_vis (compiler);\n+\n+    if (is_query_mode && compiler.reference == error_mark_node)\n+      rust_internal_error_at (ref_locus, \"failed to compile impl item: %s\",\n+\t\t\t      item->as_string ().c_str ());\n+\n+    return compiler.reference;\n+  }\n+\n+private:\n+  CompileInherentImplItem (Context *ctx, TyTy::BaseType *concrete,\n+\t\t\t   Location ref_locus)\n+    : CompileItem (ctx, concrete, ref_locus)\n+  {}\n+};\n+\n+class CompileTraitItem : public HIRCompileBase, public HIR::HIRTraitItemVisitor\n+{\n+public:\n+  static tree Compile (HIR::TraitItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete, bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n+  {\n+    CompileTraitItem compiler (ctx, concrete, ref_locus);\n+    item->accept_vis (compiler);\n+\n+    if (is_query_mode && compiler.reference == error_mark_node)\n+      rust_internal_error_at (ref_locus, \"failed to compile trait item: %s\",\n+\t\t\t      item->as_string ().c_str ());\n+\n+    return compiler.reference;\n+  }\n+\n+  void visit (HIR::TraitItemConst &constant) override;\n+  void visit (HIR::TraitItemFunc &func) override;\n+\n+  void visit (HIR::TraitItemType &typ) override {}\n+\n+private:\n+  CompileTraitItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete), reference (error_mark_node),\n+      ref_locus (ref_locus)\n+  {}\n+\n+  TyTy::BaseType *concrete;\n+  tree reference;\n+  Location ref_locus;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_IMPLITEM_H"}, {"sha": "61084b90f333fea0000c1afc963114eea328e007", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,515 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-intrinsic.h\"\n+#include \"fold-const.h\"\n+#include \"langhooks.h\"\n+#include \"rust-compile-context.h\"\n+#include \"rust-compile-type.h\"\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-builtins.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-location.h\"\n+#include \"rust-tree.h\"\n+#include \"tree-core.h\"\n+#include \"print-tree.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+static tree\n+offset_handler (Context *ctx, TyTy::FnType *fntype);\n+static tree\n+sizeof_handler (Context *ctx, TyTy::FnType *fntype);\n+static tree\n+transmute_handler (Context *ctx, TyTy::FnType *fntype);\n+static tree\n+rotate_handler (Context *ctx, TyTy::FnType *fntype, tree_code op);\n+static tree\n+wrapping_op_handler (Context *ctx, TyTy::FnType *fntype, tree_code op);\n+static tree\n+copy_nonoverlapping_handler (Context *ctx, TyTy::FnType *fntype);\n+\n+static inline tree\n+rotate_left_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  return rotate_handler (ctx, fntype, LROTATE_EXPR);\n+}\n+static inline tree\n+rotate_right_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  return rotate_handler (ctx, fntype, RROTATE_EXPR);\n+}\n+\n+static inline tree\n+wrapping_add_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  return wrapping_op_handler (ctx, fntype, PLUS_EXPR);\n+}\n+static inline tree\n+wrapping_sub_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  return wrapping_op_handler (ctx, fntype, MINUS_EXPR);\n+}\n+static inline tree\n+wrapping_mul_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  return wrapping_op_handler (ctx, fntype, MULT_EXPR);\n+}\n+\n+static const std::map<std::string,\n+\t\t      std::function<tree (Context *, TyTy::FnType *)>>\n+  generic_intrinsics = {{\"offset\", &offset_handler},\n+\t\t\t{\"size_of\", &sizeof_handler},\n+\t\t\t{\"transmute\", &transmute_handler},\n+\t\t\t{\"rotate_left\", &rotate_left_handler},\n+\t\t\t{\"rotate_right\", &rotate_right_handler},\n+\t\t\t{\"wrapping_add\", &wrapping_add_handler},\n+\t\t\t{\"wrapping_sub\", &wrapping_sub_handler},\n+\t\t\t{\"wrapping_mul\", &wrapping_mul_handler},\n+\t\t\t{\"copy_nonoverlapping\", &copy_nonoverlapping_handler}};\n+\n+Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n+\n+tree\n+Intrinsics::compile (TyTy::FnType *fntype)\n+{\n+  rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n+\n+  tree builtin = error_mark_node;\n+  BuiltinsContext &builtin_ctx = BuiltinsContext::get ();\n+  if (builtin_ctx.lookup_simple_builtin (fntype->get_identifier (), &builtin))\n+    return builtin;\n+\n+  // is it an generic builtin?\n+  auto it = generic_intrinsics.find (fntype->get_identifier ());\n+  if (it != generic_intrinsics.end ())\n+    return it->second (ctx, fntype);\n+\n+  Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n+  rust_error_at (locus, \"unknown builtin intrinsic: %s\",\n+\t\t fntype->get_identifier ().c_str ());\n+\n+  return error_mark_node;\n+}\n+\n+/**\n+ * Items can be forward compiled which means we may not need to invoke this\n+ * code. We might also have already compiled this generic function as well.\n+ */\n+static bool\n+check_for_cached_intrinsic (Context *ctx, TyTy::FnType *fntype, tree *lookup)\n+{\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // Has this been added to the list? Then it must be finished\n+      if (ctx->function_completed (*lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    ctx->insert_function_decl (fntype, *lookup);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/**\n+ * Maybe override the Hir Lookups for the substituions in this context\n+ */\n+static void\n+maybe_override_ctx (TyTy::FnType *fntype)\n+{\n+  if (fntype->has_subsititions_defined ())\n+    fntype->override_context ();\n+}\n+\n+/**\n+ * Compile and setup a function's parameters\n+ */\n+static void\n+compile_fn_params (Context *ctx, TyTy::FnType *fntype, tree fndecl,\n+\t\t   std::vector<Bvariable *> *compiled_param_variables,\n+\t\t   std::vector<tree_node *> *compiled_param_types = nullptr)\n+{\n+  for (auto &parm : fntype->get_params ())\n+    {\n+      auto &referenced_param = parm.first;\n+      auto &param_tyty = parm.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param->get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      compiled_param_variables->push_back (compiled_param_var);\n+      if (compiled_param_types)\n+\tcompiled_param_types->push_back (compiled_param_type);\n+    }\n+}\n+\n+static tree\n+compile_intrinsic_function (Context *ctx, TyTy::FnType *fntype)\n+{\n+  maybe_override_ctx (fntype);\n+\n+  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path.get () + fntype->subst_as_string ();\n+  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, fntype->get_ident ().locus);\n+\n+  TREE_PUBLIC (fndecl) = 0;\n+  TREE_READONLY (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 1;\n+  DECL_EXTERNAL (fndecl) = 0;\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+  return fndecl;\n+}\n+\n+static void\n+enter_intrinsic_block (Context *ctx, tree fndecl)\n+{\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = Location ();\n+  Location end_location = Location ();\n+\n+  auto block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t   start_location, end_location);\n+\n+  ctx->push_block (block);\n+}\n+\n+static void\n+finalize_intrinsic_block (Context *ctx, tree fndecl)\n+{\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->push_function (fndecl);\n+}\n+\n+static tree\n+offset_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  // offset intrinsic has two params dst pointer and offset isize\n+  rust_assert (fntype->get_params ().size () == 2);\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  std::vector<Bvariable *> param_vars;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n+\n+  auto &dst_param = param_vars.at (0);\n+  auto &size_param = param_vars.at (1);\n+  rust_assert (param_vars.size () == 2);\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN offset FN BODY BEGIN\n+  tree dst = ctx->get_backend ()->var_expression (dst_param, Location ());\n+  tree size = ctx->get_backend ()->var_expression (size_param, Location ());\n+  tree pointer_offset_expr\n+    = pointer_offset_expression (dst, size, BUILTINS_LOCATION);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {pointer_offset_expr},\n+\t\t\t\t\t     Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN offset FN BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n+static tree\n+sizeof_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  // size_of has _zero_ parameters its parameter is the generic one\n+  rust_assert (fntype->get_params ().size () == 0);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // get the template parameter type tree fn size_of<T>();\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+  auto &param_mapping = fntype->get_substs ().at (0);\n+  const TyTy::ParamType *param_tyty = param_mapping.get_param_ty ();\n+  TyTy::BaseType *resolved_tyty = param_tyty->resolve ();\n+  tree template_parameter_type\n+    = TyTyResolveCompile::compile (ctx, resolved_tyty);\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN size_of FN BODY BEGIN\n+  tree size_expr = TYPE_SIZE_UNIT (template_parameter_type);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {size_expr}, Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN size_of FN BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n+static tree\n+transmute_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  // transmute intrinsic has one parameter\n+  rust_assert (fntype->get_params ().size () == 1);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  std::vector<Bvariable *> param_vars;\n+  std::vector<tree_node *> compiled_types;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars, &compiled_types);\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // param to convert\n+  Bvariable *convert_me_param = param_vars.at (0);\n+  tree convert_me_expr\n+    = ctx->get_backend ()->var_expression (convert_me_param, Location ());\n+\n+  // check for transmute pre-conditions\n+  tree target_type_expr = TREE_TYPE (DECL_RESULT (fndecl));\n+  tree source_type_expr = compiled_types.at (0);\n+  tree target_size_expr = TYPE_SIZE (target_type_expr);\n+  tree source_size_expr = TYPE_SIZE (source_type_expr);\n+  // for some reason, unit types and other zero-sized types return NULL for the\n+  // size expressions\n+  unsigned HOST_WIDE_INT target_size\n+    = target_size_expr ? TREE_INT_CST_LOW (target_size_expr) : 0;\n+  unsigned HOST_WIDE_INT source_size\n+    = source_size_expr ? TREE_INT_CST_LOW (source_size_expr) : 0;\n+\n+  // size check for concrete types\n+  // TODO(liushuyu): check alignment for pointers; check for dependently-sized\n+  // types\n+  if (target_size != source_size)\n+    {\n+      rust_error_at (fntype->get_locus (),\n+\t\t     \"cannot transmute between types of different sizes, or \"\n+\t\t     \"dependently-sized types\");\n+      rust_inform (fntype->get_ident ().locus, \"source type: %qs (%lu bits)\",\n+\t\t   fntype->get_params ().at (0).second->as_string ().c_str (),\n+\t\t   (unsigned long) source_size);\n+      rust_inform (fntype->get_ident ().locus, \"target type: %qs (%lu bits)\",\n+\t\t   fntype->get_return_type ()->as_string ().c_str (),\n+\t\t   (unsigned long) target_size);\n+    }\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN transmute FN BODY BEGIN\n+\n+  // Return *((orig_type*)&decl)  */\n+\n+  tree t\n+    = build_fold_addr_expr_loc (Location ().gcc_location (), convert_me_expr);\n+  t = fold_build1_loc (Location ().gcc_location (), NOP_EXPR,\n+\t\t       build_pointer_type (target_type_expr), t);\n+  tree result_expr\n+    = build_fold_indirect_ref_loc (Location ().gcc_location (), t);\n+\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {result_expr},\n+\t\t\t\t\t     Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN transmute FN BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n+static tree\n+rotate_handler (Context *ctx, TyTy::FnType *fntype, tree_code op)\n+{\n+  // rotate intrinsic has two parameter\n+  rust_assert (fntype->get_params ().size () == 2);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n+\n+  auto &x_param = param_vars.at (0);\n+  auto &y_param = param_vars.at (1);\n+  rust_assert (param_vars.size () == 2);\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN rotate FN BODY BEGIN\n+  tree x = ctx->get_backend ()->var_expression (x_param, Location ());\n+  tree y = ctx->get_backend ()->var_expression (y_param, Location ());\n+  tree rotate_expr\n+    = fold_build2_loc (BUILTINS_LOCATION, op, TREE_TYPE (x), x, y);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {rotate_expr},\n+\t\t\t\t\t     Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN rotate FN BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n+/**\n+ * pub fn wrapping_{add, sub, mul}<T>(lhs: T, rhs: T) -> T;\n+ */\n+static tree\n+wrapping_op_handler (Context *ctx, TyTy::FnType *fntype, tree_code op)\n+{\n+  // wrapping_<op> intrinsics have two parameter\n+  rust_assert (fntype->get_params ().size () == 2);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n+\n+  auto &lhs_param = param_vars.at (0);\n+  auto &rhs_param = param_vars.at (1);\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN wrapping_<op> FN BODY BEGIN\n+  auto lhs = ctx->get_backend ()->var_expression (lhs_param, Location ());\n+  auto rhs = ctx->get_backend ()->var_expression (rhs_param, Location ());\n+\n+  // Operations are always wrapping in Rust, as we have -fwrapv enabled by\n+  // default. The difference between a wrapping_{add, sub, mul} and a regular\n+  // arithmetic operation is that these intrinsics do not panic - they always\n+  // carry over.\n+  auto wrap_expr = build2 (op, TREE_TYPE (lhs), lhs, rhs);\n+\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {wrap_expr}, Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN wrapping_<op> FN BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n+/**\n+ * fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+ */\n+static tree\n+copy_nonoverlapping_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  rust_assert (fntype->get_params ().size () == 3);\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // Most intrinsic functions are pure - not `copy_nonoverlapping`\n+  TREE_READONLY (fndecl) = 0;\n+  TREE_SIDE_EFFECTS (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN copy_nonoverlapping BODY BEGIN\n+\n+  auto src = ctx->get_backend ()->var_expression (param_vars[0], Location ());\n+  auto dst = ctx->get_backend ()->var_expression (param_vars[1], Location ());\n+  auto count = ctx->get_backend ()->var_expression (param_vars[2], Location ());\n+\n+  // We want to create the following statement\n+  // memcpy(dst, src, size_of::<T>());\n+  // so\n+  // memcpy(dst, src, size_expr);\n+\n+  auto *resolved_ty = fntype->get_substs ().at (0).get_param_ty ()->resolve ();\n+  auto param_type = TyTyResolveCompile::compile (ctx, resolved_ty);\n+\n+  tree size_expr\n+    = build2 (MULT_EXPR, size_type_node, TYPE_SIZE_UNIT (param_type), count);\n+\n+  tree memcpy_raw = nullptr;\n+  BuiltinsContext::get ().lookup_simple_builtin (\"memcpy\", &memcpy_raw);\n+  rust_assert (memcpy_raw);\n+  auto memcpy\n+    = build_fold_addr_expr_loc (Location ().gcc_location (), memcpy_raw);\n+\n+  auto copy_call\n+    = ctx->get_backend ()->call_expression (memcpy, {dst, src, size_expr},\n+\t\t\t\t\t    nullptr, Location ());\n+\n+  ctx->add_statement (copy_call);\n+\n+  // BUILTIN copy_nonoverlapping BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "dceb0864fd490c7f377e3ae3b39201e4850ce8a1", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,40 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_INTRINSIC\n+#define RUST_COMPILE_INTRINSIC\n+\n+#include \"rust-compile-context.h\"\n+#include \"langhooks.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class Intrinsics\n+{\n+public:\n+  Intrinsics (Context *ctx);\n+\n+  tree compile (TyTy::FnType *fntype);\n+\n+private:\n+  Context *ctx;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_INTRINSIC"}, {"sha": "ceba51c2d27f5bd3a57b3a7acd9b1621cae88354", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,206 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-extern.h\"\n+#include \"rust-constexpr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileItem::visit (HIR::StaticItem &var)\n+{\n+  // have we already compiled this?\n+  Bvariable *static_decl_ref = nullptr;\n+  if (ctx->lookup_var_decl (var.get_mappings ().get_hirid (), &static_decl_ref))\n+    {\n+      reference\n+\t= ctx->get_backend ()->var_expression (static_decl_ref, ref_locus);\n+      return;\n+    }\n+\n+  TyTy::BaseType *resolved_type = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n+\t\t\t\t\t    &resolved_type);\n+  rust_assert (ok);\n+\n+  tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+  tree value = CompileExpr::Compile (var.get_expr (), ctx);\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  ok = ctx->get_mappings ()->lookup_canonical_path (\n+    var.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  std::string name = canonical_path->get ();\n+  std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n+\n+  bool is_external = false;\n+  bool is_hidden = false;\n+  bool in_unique_section = true;\n+\n+  Bvariable *static_global\n+    = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n+\t\t\t\t\t    is_hidden, in_unique_section,\n+\t\t\t\t\t    var.get_locus ());\n+  ctx->get_backend ()->global_variable_set_init (static_global, value);\n+\n+  ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n+  ctx->push_var (static_global);\n+\n+  reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n+}\n+\n+void\n+CompileItem::visit (HIR::ConstantItem &constant)\n+{\n+  if (ctx->lookup_const_decl (constant.get_mappings ().get_hirid (),\n+\t\t\t      &reference))\n+    return;\n+\n+  // resolve the type\n+  TyTy::BaseType *resolved_type = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n+\t\t\t\t      &resolved_type);\n+  rust_assert (ok);\n+\n+  // canonical path\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  ok = ctx->get_mappings ()->lookup_canonical_path (\n+    constant.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  HIR::Expr *const_value_expr = constant.get_expr ();\n+  ctx->push_const_context ();\n+  tree const_expr\n+    = compile_constant_item (ctx, resolved_type, canonical_path,\n+\t\t\t     const_value_expr, constant.get_locus ());\n+  ctx->pop_const_context ();\n+\n+  ctx->push_const (const_expr);\n+  ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+  reference = const_expr;\n+}\n+\n+void\n+CompileItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *fntype_tyty;\n+  if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t       &fntype_tyty))\n+    {\n+      rust_fatal_error (function.get_locus (),\n+\t\t\t\"failed to lookup function type\");\n+      return;\n+    }\n+\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // we cant do anything for this only when it is used and a concrete type\n+      // is given\n+      if (concrete == nullptr)\n+\treturn;\n+      else\n+\t{\n+\t  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  fntype->monomorphize ();\n+\t}\n+    }\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\n+\t  reference = address_expression (lookup, ref_locus);\n+\t  return;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    function.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  tree fndecl\n+    = compile_function (ctx, function.get_function_name (),\n+\t\t\tfunction.get_self_param (),\n+\t\t\tfunction.get_function_params (),\n+\t\t\tfunction.get_qualifiers (), function.get_visibility (),\n+\t\t\tfunction.get_outer_attrs (), function.get_locus (),\n+\t\t\tfunction.get_definition ().get (), canonical_path,\n+\t\t\tfntype, function.has_function_return_type ());\n+  reference = address_expression (fndecl, ref_locus);\n+}\n+\n+void\n+CompileItem::visit (HIR::ImplBlock &impl_block)\n+{\n+  TyTy::BaseType *self_lookup = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\timpl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n+    {\n+      rust_error_at (impl_block.get_locus (), \"failed to resolve type of impl\");\n+      return;\n+    }\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    CompileInherentImplItem::Compile (impl_item.get (), ctx);\n+}\n+\n+void\n+CompileItem::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      CompileExternItem::compile (item.get (), ctx, concrete);\n+    }\n+}\n+\n+void\n+CompileItem::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    CompileItem::compile (item.get (), ctx);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "3c12f1040fcb2150de4d1e3e844d378300cc94d8", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_ITEM\n+#define RUST_COMPILE_ITEM\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileItem : private HIRCompileBase, protected HIR::HIRStmtVisitor\n+{\n+protected:\n+public:\n+  static tree compile (HIR::Item *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n+  {\n+    CompileItem compiler (ctx, concrete, ref_locus);\n+    item->accept_vis (compiler);\n+\n+    if (is_query_mode && compiler.reference == error_mark_node)\n+      rust_internal_error_at (ref_locus, \"failed to compile item: %s\",\n+\t\t\t      item->as_string ().c_str ());\n+\n+    return compiler.reference;\n+  }\n+\n+  void visit (HIR::StaticItem &var) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::ImplBlock &impl_block) override;\n+  void visit (HIR::ExternBlock &extern_block) override;\n+  void visit (HIR::Module &module) override;\n+\n+  // Empty visit for unused Stmt HIR nodes.\n+  void visit (HIR::TupleStruct &) override {}\n+  void visit (HIR::EnumItem &) override {}\n+  void visit (HIR::EnumItemTuple &) override {}\n+  void visit (HIR::EnumItemStruct &) override {}\n+  void visit (HIR::EnumItemDiscriminant &) override {}\n+  void visit (HIR::TypePathSegmentFunction &) override {}\n+  void visit (HIR::TypePath &) override {}\n+  void visit (HIR::QualifiedPathInType &) override {}\n+  void visit (HIR::ExternCrate &) override {}\n+  void visit (HIR::UseDeclaration &) override {}\n+  void visit (HIR::TypeAlias &) override {}\n+  void visit (HIR::StructStruct &) override {}\n+  void visit (HIR::Enum &) override {}\n+  void visit (HIR::Union &) override {}\n+  void visit (HIR::Trait &) override {}\n+  void visit (HIR::EmptyStmt &) override {}\n+  void visit (HIR::LetStmt &) override {}\n+  void visit (HIR::ExprStmtWithoutBlock &) override {}\n+  void visit (HIR::ExprStmtWithBlock &) override {}\n+\n+protected:\n+  CompileItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete), reference (error_mark_node),\n+      ref_locus (ref_locus)\n+  {}\n+\n+  TyTy::BaseType *concrete;\n+  tree reference;\n+  Location ref_locus;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_ITEM"}, {"sha": "1d8eda1a5774786cfea005b154503c8330c334a0", "filename": "gcc/rust/backend/rust-compile-pattern.cc", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,333 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-pattern.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-resolve-path.h\"\n+#include \"rust-constexpr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::PathInExpression &pattern)\n+{\n+  // lookup the type\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (pattern.get_mappings ().get_hirid (),\n+\t\t\t\t      &lookup);\n+  rust_assert (ok);\n+\n+  // this must be an enum\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+  rust_assert (adt->is_enum ());\n+\n+  // lookup the variant\n+  HirId variant_id;\n+  ok = ctx->get_tyctx ()->lookup_variant_definition (\n+    pattern.get_mappings ().get_hirid (), &variant_id);\n+  rust_assert (ok);\n+\n+  TyTy::VariantDef *variant = nullptr;\n+  ok = adt->lookup_variant_by_id (variant_id, &variant);\n+  rust_assert (ok);\n+\n+  HIR::Expr *discrim_expr = variant->get_discriminant ();\n+  tree discrim_expr_node = CompileExpr::Compile (discrim_expr, ctx);\n+  tree folded_discrim_expr = fold_expr (discrim_expr_node);\n+  tree case_low = folded_discrim_expr;\n+\n+  case_label_expr\n+    = build_case_label (case_low, NULL_TREE, associated_case_label);\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::StructPattern &pattern)\n+{\n+  CompilePatternCaseLabelExpr::visit (pattern.get_path ());\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::TupleStructPattern &pattern)\n+{\n+  CompilePatternCaseLabelExpr::visit (pattern.get_path ());\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::WildcardPattern &pattern)\n+{\n+  // operand 0 being NULL_TREE signifies this is the default case label see:\n+  // tree.def for documentation for CASE_LABEL_EXPR\n+  case_label_expr\n+    = build_case_label (NULL_TREE, NULL_TREE, associated_case_label);\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::LiteralPattern &pattern)\n+{\n+  // Compile the literal\n+  HIR::LiteralExpr *litexpr\n+    = new HIR::LiteralExpr (pattern.get_pattern_mappings (),\n+\t\t\t    pattern.get_literal (), pattern.get_locus (),\n+\t\t\t    std::vector<AST::Attribute> ());\n+\n+  // Note: Floating point literals are currently accepted but will likely be\n+  // forbidden in LiteralPatterns in a future version of Rust.\n+  // See: https://github.com/rust-lang/rust/issues/41620\n+  // For now, we cannot compile them anyway as CASE_LABEL_EXPR does not support\n+  // floating point types.\n+  if (pattern.get_literal ().get_lit_type () == HIR::Literal::LitType::FLOAT)\n+    {\n+      rust_sorry_at (pattern.get_locus (), \"floating-point literal in pattern\");\n+    }\n+\n+  tree lit = CompileExpr::Compile (litexpr, ctx);\n+\n+  case_label_expr = build_case_label (lit, NULL_TREE, associated_case_label);\n+}\n+\n+static tree\n+compile_range_pattern_bound (HIR::RangePatternBound *bound,\n+\t\t\t     Analysis::NodeMapping mappings, Location locus,\n+\t\t\t     Context *ctx)\n+{\n+  tree result = NULL_TREE;\n+  switch (bound->get_bound_type ())\n+    {\n+      case HIR::RangePatternBound::RangePatternBoundType::LITERAL: {\n+\tHIR::RangePatternBoundLiteral &ref\n+\t  = *static_cast<HIR::RangePatternBoundLiteral *> (bound);\n+\n+\tHIR::LiteralExpr *litexpr\n+\t  = new HIR::LiteralExpr (mappings, ref.get_literal (), locus,\n+\t\t\t\t  std::vector<AST::Attribute> ());\n+\n+\tresult = CompileExpr::Compile (litexpr, ctx);\n+      }\n+      break;\n+\n+      case HIR::RangePatternBound::RangePatternBoundType::PATH: {\n+\tHIR::RangePatternBoundPath &ref\n+\t  = *static_cast<HIR::RangePatternBoundPath *> (bound);\n+\n+\tresult = ResolvePathRef::Compile (ref.get_path (), ctx);\n+\n+\t// If the path resolves to a const expression, fold it.\n+\tresult = fold_expr (result);\n+      }\n+      break;\n+\n+      case HIR::RangePatternBound::RangePatternBoundType::QUALPATH: {\n+\tHIR::RangePatternBoundQualPath &ref\n+\t  = *static_cast<HIR::RangePatternBoundQualPath *> (bound);\n+\n+\tresult = ResolvePathRef::Compile (ref.get_qualified_path (), ctx);\n+\n+\t// If the path resolves to a const expression, fold it.\n+\tresult = fold_expr (result);\n+      }\n+    }\n+\n+  return result;\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::RangePattern &pattern)\n+{\n+  tree upper = compile_range_pattern_bound (pattern.get_upper_bound ().get (),\n+\t\t\t\t\t    pattern.get_pattern_mappings (),\n+\t\t\t\t\t    pattern.get_locus (), ctx);\n+  tree lower = compile_range_pattern_bound (pattern.get_lower_bound ().get (),\n+\t\t\t\t\t    pattern.get_pattern_mappings (),\n+\t\t\t\t\t    pattern.get_locus (), ctx);\n+\n+  case_label_expr = build_case_label (lower, upper, associated_case_label);\n+}\n+\n+// setup the bindings\n+\n+void\n+CompilePatternBindings::visit (HIR::TupleStructPattern &pattern)\n+{\n+  // lookup the type\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    pattern.get_path ().get_mappings ().get_hirid (), &lookup);\n+  rust_assert (ok);\n+\n+  // this must be an enum\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+  rust_assert (adt->number_of_variants () > 0);\n+\n+  int variant_index = 0;\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+  if (adt->is_enum ())\n+    {\n+      HirId variant_id = UNKNOWN_HIRID;\n+      bool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\tpattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+      rust_assert (ok);\n+\n+      ok = adt->lookup_variant_by_id (variant_id, &variant, &variant_index);\n+      rust_assert (ok);\n+    }\n+\n+  rust_assert (variant->get_variant_type ()\n+\t       == TyTy::VariantDef::VariantType::TUPLE);\n+\n+  std::unique_ptr<HIR::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case HIR::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case HIR::TupleStructItems::NO_RANGE: {\n+\tHIR::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<HIR::TupleStructItemsNoRange &> (*items.get ());\n+\n+\trust_assert (items_no_range.get_patterns ().size ()\n+\t\t     == variant->num_fields ());\n+\n+\tif (adt->is_enum ())\n+\t  {\n+\t    // we are offsetting by + 1 here since the first field in the record\n+\t    // is always the discriminator\n+\t    size_t tuple_field_index = 1;\n+\t    for (auto &pattern : items_no_range.get_patterns ())\n+\t      {\n+\t\ttree variant_accessor\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    match_scrutinee_expr, variant_index, pattern->get_locus ());\n+\n+\t\ttree binding = ctx->get_backend ()->struct_field_expression (\n+\t\t  variant_accessor, tuple_field_index++, pattern->get_locus ());\n+\n+\t\tctx->insert_pattern_binding (\n+\t\t  pattern->get_pattern_mappings ().get_hirid (), binding);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    size_t tuple_field_index = 0;\n+\t    for (auto &pattern : items_no_range.get_patterns ())\n+\t      {\n+\t\ttree variant_accessor = match_scrutinee_expr;\n+\n+\t\ttree binding = ctx->get_backend ()->struct_field_expression (\n+\t\t  variant_accessor, tuple_field_index++, pattern->get_locus ());\n+\n+\t\tctx->insert_pattern_binding (\n+\t\t  pattern->get_pattern_mappings ().get_hirid (), binding);\n+\t      }\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+CompilePatternBindings::visit (HIR::StructPattern &pattern)\n+{\n+  // lookup the type\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    pattern.get_path ().get_mappings ().get_hirid (), &lookup);\n+  rust_assert (ok);\n+\n+  // this must be an enum\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+  rust_assert (adt->number_of_variants () > 0);\n+\n+  int variant_index = 0;\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+  if (adt->is_enum ())\n+    {\n+      HirId variant_id = UNKNOWN_HIRID;\n+      bool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\tpattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+      rust_assert (ok);\n+\n+      ok = adt->lookup_variant_by_id (variant_id, &variant, &variant_index);\n+      rust_assert (ok);\n+    }\n+\n+  rust_assert (variant->get_variant_type ()\n+\t       == TyTy::VariantDef::VariantType::STRUCT);\n+\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case HIR::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT: {\n+\t    HIR::StructPatternFieldIdent &ident\n+\t      = static_cast<HIR::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    size_t offs = 0;\n+\t    ok\n+\t      = variant->lookup_field (ident.get_identifier (), nullptr, &offs);\n+\t    rust_assert (ok);\n+\n+\t    tree binding = error_mark_node;\n+\t    if (adt->is_enum ())\n+\t      {\n+\t\ttree variant_accessor\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    match_scrutinee_expr, variant_index, ident.get_locus ());\n+\n+\t\t// we are offsetting by + 1 here since the first field in the\n+\t\t// record is always the discriminator\n+\t\tbinding = ctx->get_backend ()->struct_field_expression (\n+\t\t  variant_accessor, offs + 1, ident.get_locus ());\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree variant_accessor = match_scrutinee_expr;\n+\t\tbinding = ctx->get_backend ()->struct_field_expression (\n+\t\t  variant_accessor, offs, ident.get_locus ());\n+\t      }\n+\n+\t    ctx->insert_pattern_binding (ident.get_mappings ().get_hirid (),\n+\t\t\t\t\t binding);\n+\t  }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "0eb5d61249b2cf06a0f2dbf5bbbe3fb591adfe3c", "filename": "gcc/rust/backend/rust-compile-pattern.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompilePatternCaseLabelExpr : public HIRCompileBase,\n+\t\t\t\t    public HIR::HIRPatternVisitor\n+{\n+public:\n+  static tree Compile (HIR::Pattern *pattern, tree associated_case_label,\n+\t\t       Context *ctx)\n+  {\n+    CompilePatternCaseLabelExpr compiler (ctx, associated_case_label);\n+    pattern->accept_vis (compiler);\n+    return compiler.case_label_expr;\n+  }\n+\n+  void visit (HIR::PathInExpression &pattern) override;\n+  void visit (HIR::StructPattern &pattern) override;\n+  void visit (HIR::TupleStructPattern &pattern) override;\n+  void visit (HIR::WildcardPattern &pattern) override;\n+  void visit (HIR::RangePattern &pattern) override;\n+\n+  // Empty visit for unused Pattern HIR nodes.\n+  void visit (HIR::GroupedPattern &) override {}\n+  void visit (HIR::IdentifierPattern &) override {}\n+  void visit (HIR::LiteralPattern &) override;\n+  void visit (HIR::QualifiedPathInExpression &) override {}\n+  void visit (HIR::ReferencePattern &) override {}\n+  void visit (HIR::SlicePattern &) override {}\n+  void visit (HIR::TuplePattern &) override {}\n+\n+  CompilePatternCaseLabelExpr (Context *ctx, tree associated_case_label)\n+    : HIRCompileBase (ctx), case_label_expr (error_mark_node),\n+      associated_case_label (associated_case_label)\n+  {}\n+\n+  tree case_label_expr;\n+  tree associated_case_label;\n+};\n+\n+class CompilePatternBindings : public HIRCompileBase,\n+\t\t\t       public HIR::HIRPatternVisitor\n+{\n+public:\n+  static void Compile (HIR::Pattern *pattern, tree match_scrutinee_expr,\n+\t\t       Context *ctx)\n+  {\n+    CompilePatternBindings compiler (ctx, match_scrutinee_expr);\n+    pattern->accept_vis (compiler);\n+  }\n+\n+  void visit (HIR::StructPattern &pattern) override;\n+  void visit (HIR::TupleStructPattern &pattern) override;\n+\n+  // Empty visit for unused Pattern HIR nodes.\n+  void visit (HIR::GroupedPattern &) override {}\n+  void visit (HIR::IdentifierPattern &) override {}\n+  void visit (HIR::LiteralPattern &) override {}\n+  void visit (HIR::PathInExpression &) override {}\n+  void visit (HIR::QualifiedPathInExpression &) override {}\n+  void visit (HIR::RangePattern &) override {}\n+  void visit (HIR::ReferencePattern &) override {}\n+  void visit (HIR::SlicePattern &) override {}\n+  void visit (HIR::TuplePattern &) override {}\n+  void visit (HIR::WildcardPattern &) override {}\n+\n+protected:\n+  CompilePatternBindings (Context *ctx, tree match_scrutinee_expr)\n+    : HIRCompileBase (ctx), match_scrutinee_expr (match_scrutinee_expr)\n+  {}\n+\n+  tree match_scrutinee_expr;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "4fb3d540257ef55894863d5167ceb0c2d7bb4342", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,301 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-intrinsic.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-compile-extern.h\"\n+#include \"rust-constexpr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+ResolvePathRef::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  resolved = resolve (expr.get_final_segment ().get_segment (),\n+\t\t      expr.get_mappings (), expr.get_locus (), true);\n+}\n+\n+void\n+ResolvePathRef::visit (HIR::PathInExpression &expr)\n+{\n+  resolved = resolve (expr.get_final_segment ().get_segment (),\n+\t\t      expr.get_mappings (), expr.get_locus (), false);\n+}\n+\n+tree\n+ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n+\t\t\t const Analysis::NodeMapping &mappings,\n+\t\t\t Location expr_locus, bool is_qualified_path)\n+{\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n+  rust_assert (ok);\n+\n+  // need to look up the reference for this identifier\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (mappings.get_nodeid (),\n+\t\t\t\t\t\t   &ref_node_id))\n+    {\n+      // this can fail because it might be a Constructor for something\n+      // in that case the caller should attempt ResolvePathType::Compile\n+\n+      // it might be an enum data-less enum variant\n+      if (lookup->get_kind () != TyTy::TypeKind::ADT)\n+\treturn error_mark_node;\n+\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+\n+      // it might be a unit-struct\n+      if (adt->is_unit ())\n+\t{\n+\t  return ctx->get_backend ()->unit_expression ();\n+\t}\n+\n+      if (!adt->is_enum ())\n+\treturn error_mark_node;\n+\n+      HirId variant_id;\n+      if (!ctx->get_tyctx ()->lookup_variant_definition (mappings.get_hirid (),\n+\t\t\t\t\t\t\t &variant_id))\n+\treturn error_mark_node;\n+\n+      int union_disriminator = -1;\n+      TyTy::VariantDef *variant = nullptr;\n+      if (!adt->lookup_variant_by_id (variant_id, &variant,\n+\t\t\t\t      &union_disriminator))\n+\treturn error_mark_node;\n+\n+      // this can only be for discriminant variants the others are built up\n+      // using call-expr or struct-init\n+      rust_assert (variant->get_variant_type ()\n+\t\t   == TyTy::VariantDef::VariantType::NUM);\n+\n+      // we need the actual gcc type\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, adt);\n+\n+      // make the ctor for the union\n+      HIR::Expr *discrim_expr = variant->get_discriminant ();\n+      tree discrim_expr_node = CompileExpr::Compile (discrim_expr, ctx);\n+      tree folded_discrim_expr = fold_expr (discrim_expr_node);\n+      tree qualifier = folded_discrim_expr;\n+\n+      return ctx->get_backend ()->constructor_expression (compiled_adt_type,\n+\t\t\t\t\t\t\t  true, {qualifier},\n+\t\t\t\t\t\t\t  union_disriminator,\n+\t\t\t\t\t\t\t  expr_locus);\n+    }\n+\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (ref_node_id, &ref))\n+    {\n+      rust_error_at (expr_locus, \"reverse call path lookup failure\");\n+      return error_mark_node;\n+    }\n+\n+  // might be a constant\n+  tree constant_expr;\n+  if (ctx->lookup_const_decl (ref, &constant_expr))\n+    {\n+      TREE_USED (constant_expr) = 1;\n+      return constant_expr;\n+    }\n+\n+  // this might be a variable reference or a function reference\n+  Bvariable *var = nullptr;\n+  if (ctx->lookup_var_decl (ref, &var))\n+    {\n+      // TREE_USED is setup in the gcc abstraction here\n+      return ctx->get_backend ()->var_expression (var, expr_locus);\n+    }\n+\n+  // might be a match pattern binding\n+  tree binding = error_mark_node;\n+  if (ctx->lookup_pattern_binding (ref, &binding))\n+    {\n+      TREE_USED (binding) = 1;\n+      return binding;\n+    }\n+\n+  // it might be a function call\n+  if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+      tree fn = NULL_TREE;\n+      if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t{\n+\t  TREE_USED (fn) = 1;\n+\t  return address_expression (fn, expr_locus);\n+\t}\n+      else if (fntype->get_abi () == ABI::INTRINSIC)\n+\t{\n+\t  Intrinsics compile (ctx);\n+\t  fn = compile.compile (fntype);\n+\t  TREE_USED (fn) = 1;\n+\t  return address_expression (fn, expr_locus);\n+\t}\n+    }\n+\n+  // let the query system figure it out\n+  tree resolved_item = query_compile (ref, lookup, final_segment, mappings,\n+\t\t\t\t      expr_locus, is_qualified_path);\n+  if (resolved_item != error_mark_node)\n+    {\n+      TREE_USED (resolved_item) = 1;\n+    }\n+  return resolved_item;\n+}\n+\n+tree\n+HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t\t       const HIR::PathIdentSegment &final_segment,\n+\t\t\t       const Analysis::NodeMapping &mappings,\n+\t\t\t       Location expr_locus, bool is_qualified_path)\n+{\n+  HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (ref);\n+  HirId parent_block;\n+  HIR::ExternalItem *resolved_extern_item\n+    = ctx->get_mappings ()->lookup_hir_extern_item (ref, &parent_block);\n+  bool is_hir_item = resolved_item != nullptr;\n+  bool is_hir_extern_item = resolved_extern_item != nullptr;\n+  if (is_hir_item)\n+    {\n+      if (!lookup->has_subsititions_defined ())\n+\treturn CompileItem::compile (resolved_item, ctx, nullptr, true,\n+\t\t\t\t     expr_locus);\n+      else\n+\treturn CompileItem::compile (resolved_item, ctx, lookup, true,\n+\t\t\t\t     expr_locus);\n+    }\n+  else if (is_hir_extern_item)\n+    {\n+      if (!lookup->has_subsititions_defined ())\n+\treturn CompileExternItem::compile (resolved_extern_item, ctx, nullptr,\n+\t\t\t\t\t   true, expr_locus);\n+      else\n+\treturn CompileExternItem::compile (resolved_extern_item, ctx, lookup,\n+\t\t\t\t\t   true, expr_locus);\n+    }\n+  else\n+    {\n+      HirId parent_impl_id = UNKNOWN_HIRID;\n+      HIR::ImplItem *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_implitem (ref, &parent_impl_id);\n+      bool is_impl_item = resolved_item != nullptr;\n+      if (is_impl_item)\n+\t{\n+\t  rust_assert (parent_impl_id != UNKNOWN_HIRID);\n+\t  HIR::Item *impl_ref\n+\t    = ctx->get_mappings ()->lookup_hir_item (parent_impl_id);\n+\t  rust_assert (impl_ref != nullptr);\n+\t  HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n+\n+\t  TyTy::BaseType *self = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n+\t  rust_assert (ok);\n+\n+\t  if (!lookup->has_subsititions_defined ())\n+\t    return CompileInherentImplItem::Compile (resolved_item, ctx,\n+\t\t\t\t\t\t     nullptr, true, expr_locus);\n+\t  else\n+\t    return CompileInherentImplItem::Compile (resolved_item, ctx, lookup,\n+\t\t\t\t\t\t     true, expr_locus);\n+\t}\n+      else\n+\t{\n+\t  // it might be resolved to a trait item\n+\t  HIR::TraitItem *trait_item\n+\t    = ctx->get_mappings ()->lookup_hir_trait_item (ref);\n+\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t    trait_item->get_mappings ().get_hirid ());\n+\n+\t  Resolver::TraitReference *trait_ref\n+\t    = &Resolver::TraitReference::error_node ();\n+\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t    trait->get_mappings ().get_defid (), &trait_ref);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *receiver = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n+\t\t\t\t\t\t   &receiver);\n+\t  rust_assert (ok);\n+\n+\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n+\t    {\n+\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+\t      receiver = p->resolve ();\n+\t    }\n+\n+\t  // the type resolver can only resolve type bounds to their trait\n+\t  // item so its up to us to figure out if this path should resolve\n+\t  // to an trait-impl-block-item or if it can be defaulted to the\n+\t  // trait-impl-item's definition\n+\t  std::vector<Resolver::PathProbeCandidate> candidates\n+\t    = Resolver::PathProbeImplTrait::Probe (receiver, final_segment,\n+\t\t\t\t\t\t   trait_ref);\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      // this means we are defaulting back to the trait_item if\n+\t      // possible\n+\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t  &trait_item_ref);\n+\t      rust_assert (ok);\t\t\t\t    // found\n+\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+\t      return CompileTraitItem::Compile (\n+\t\ttrait_item_ref->get_hir_trait_item (), ctx, lookup, true,\n+\t\texpr_locus);\n+\t    }\n+\t  else\n+\t    {\n+\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t      rust_assert (candidate.is_impl_candidate ());\n+\n+\t      HIR::ImplBlock *impl = candidate.item.impl.parent;\n+\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\n+\t      TyTy::BaseType *self = nullptr;\n+\t      bool ok = ctx->get_tyctx ()->lookup_type (\n+\t\timpl->get_type ()->get_mappings ().get_hirid (), &self);\n+\t      rust_assert (ok);\n+\n+\t      if (!lookup->has_subsititions_defined ())\n+\t\treturn CompileInherentImplItem::Compile (impl_item, ctx,\n+\t\t\t\t\t\t\t nullptr, true,\n+\t\t\t\t\t\t\t expr_locus);\n+\t      else\n+\t\treturn CompileInherentImplItem::Compile (impl_item, ctx, lookup,\n+\t\t\t\t\t\t\t true, expr_locus);\n+\n+\t      lookup->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n+\t    }\n+\t}\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "f0360bdc7394f3fb9932badafd5cc73be7cdcc21", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_RESOLVE_PATH\n+#define RUST_COMPILE_RESOLVE_PATH\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class ResolvePathRef : public HIRCompileBase, public HIR::HIRPatternVisitor\n+{\n+public:\n+  static tree Compile (HIR::QualifiedPathInExpression &expr, Context *ctx)\n+  {\n+    ResolvePathRef resolver (ctx);\n+    expr.accept_vis (resolver);\n+    return resolver.resolved;\n+  }\n+\n+  static tree Compile (HIR::PathInExpression &expr, Context *ctx)\n+  {\n+    ResolvePathRef resolver (ctx);\n+    expr.accept_vis (resolver);\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::PathInExpression &expr) override;\n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n+\n+  // Empty visit for unused Pattern HIR nodes.\n+  void visit (HIR::GroupedPattern &) override {}\n+  void visit (HIR::IdentifierPattern &) override {}\n+  void visit (HIR::LiteralPattern &) override {}\n+  void visit (HIR::RangePattern &) override {}\n+  void visit (HIR::ReferencePattern &) override {}\n+  void visit (HIR::SlicePattern &) override {}\n+  void visit (HIR::StructPattern &) override {}\n+  void visit (HIR::TuplePattern &) override {}\n+  void visit (HIR::TupleStructPattern &) override {}\n+  void visit (HIR::WildcardPattern &) override {}\n+\n+  ResolvePathRef (Context *ctx)\n+    : HIRCompileBase (ctx), resolved (error_mark_node)\n+  {}\n+\n+  tree resolve (const HIR::PathIdentSegment &final_segment,\n+\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\tbool is_qualified_path);\n+\n+  tree resolved;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_RESOLVE_PATH"}, {"sha": "bfb25f12980ef18d9658a28cdfb1bb34db5afdb0", "filename": "gcc/rust/backend/rust-compile-stmt.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileStmt::CompileStmt (Context *ctx)\n+  : HIRCompileBase (ctx), translated (nullptr)\n+{}\n+\n+tree\n+CompileStmt::Compile (HIR::Stmt *stmt, Context *ctx)\n+{\n+  CompileStmt compiler (ctx);\n+  stmt->accept_vis (compiler);\n+  return compiler.translated;\n+}\n+\n+void\n+CompileStmt::visit (HIR::ExprStmtWithBlock &stmt)\n+{\n+  translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+}\n+\n+void\n+CompileStmt::visit (HIR::ExprStmtWithoutBlock &stmt)\n+{\n+  translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+}\n+\n+void\n+CompileStmt::visit (HIR::LetStmt &stmt)\n+{\n+  // nothing to do\n+  if (!stmt.has_init_expr ())\n+    return;\n+\n+  const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n+  HirId stmt_id = stmt_pattern.get_pattern_mappings ().get_hirid ();\n+\n+  TyTy::BaseType *ty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (stmt_id, &ty))\n+    {\n+      // FIXME this should be an assertion instead\n+      rust_fatal_error (stmt.get_locus (),\n+\t\t\t\"failed to lookup variable declaration type\");\n+      return;\n+    }\n+\n+  Bvariable *var = nullptr;\n+  if (!ctx->lookup_var_decl (stmt_id, &var))\n+    {\n+      // FIXME this should be an assertion instead and use error mark node\n+      rust_fatal_error (stmt.get_locus (),\n+\t\t\t\"failed to lookup compiled variable declaration\");\n+      return;\n+    }\n+\n+  tree init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+  // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n+  // on failure and make this an assertion\n+  if (init == nullptr)\n+    return;\n+\n+  TyTy::BaseType *actual = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    stmt.get_init_expr ()->get_mappings ().get_hirid (), &actual);\n+  rust_assert (ok);\n+  tree stmt_type = TyTyResolveCompile::compile (ctx, ty);\n+\n+  Location lvalue_locus = stmt.get_pattern ()->get_locus ();\n+  Location rvalue_locus = stmt.get_init_expr ()->get_locus ();\n+  TyTy::BaseType *expected = ty;\n+  init = coercion_site (stmt.get_mappings ().get_hirid (), init, actual,\n+\t\t\texpected, lvalue_locus, rvalue_locus);\n+\n+  auto fnctx = ctx->peek_fn ();\n+  if (ty->is_unit ())\n+    {\n+      ctx->add_statement (init);\n+\n+      auto unit_type_init_expr\n+\t= ctx->get_backend ()->constructor_expression (stmt_type, false, {}, -1,\n+\t\t\t\t\t\t       rvalue_locus);\n+      auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var,\n+\t\t\t\t\t\t    unit_type_init_expr);\n+      ctx->add_statement (s);\n+    }\n+  else\n+    {\n+      auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n+      ctx->add_statement (s);\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "a0ec8b26667b8af8956265faef200f88a6ea044a", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_STMT\n+#define RUST_COMPILE_STMT\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileStmt : private HIRCompileBase, protected HIR::HIRStmtVisitor\n+{\n+public:\n+  static tree Compile (HIR::Stmt *stmt, Context *ctx);\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt) override;\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override;\n+  void visit (HIR::LetStmt &stmt) override;\n+\n+  // Empty visit for unused Stmt HIR nodes.\n+  void visit (HIR::TupleStruct &) override {}\n+  void visit (HIR::EnumItem &) override {}\n+  void visit (HIR::EnumItemTuple &) override {}\n+  void visit (HIR::EnumItemStruct &) override {}\n+  void visit (HIR::EnumItemDiscriminant &) override {}\n+  void visit (HIR::TypePathSegmentFunction &) override {}\n+  void visit (HIR::TypePath &) override {}\n+  void visit (HIR::QualifiedPathInType &) override {}\n+  void visit (HIR::Module &) override {}\n+  void visit (HIR::ExternCrate &) override {}\n+  void visit (HIR::UseDeclaration &) override {}\n+  void visit (HIR::Function &) override {}\n+  void visit (HIR::TypeAlias &) override {}\n+  void visit (HIR::StructStruct &) override {}\n+  void visit (HIR::Enum &) override {}\n+  void visit (HIR::Union &) override {}\n+  void visit (HIR::ConstantItem &) override {}\n+  void visit (HIR::StaticItem &) override {}\n+  void visit (HIR::Trait &) override {}\n+  void visit (HIR::ImplBlock &) override {}\n+  void visit (HIR::ExternBlock &) override {}\n+  void visit (HIR::EmptyStmt &) override {}\n+\n+private:\n+  CompileStmt (Context *ctx);\n+\n+  tree translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_STMT"}, {"sha": "c9a2811f61195c63762fda1d8d294fc44746343d", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileStructExprField::CompileStructExprField (Context *ctx)\n+  : HIRCompileBase (ctx), translated (error_mark_node)\n+{}\n+\n+tree\n+CompileStructExprField::Compile (HIR::StructExprField *field, Context *ctx)\n+{\n+  CompileStructExprField compiler (ctx);\n+  switch (field->get_kind ())\n+    {\n+    case HIR::StructExprField::StructExprFieldKind::IDENTIFIER:\n+      compiler.visit (static_cast<HIR::StructExprFieldIdentifier &> (*field));\n+      break;\n+\n+    case HIR::StructExprField::StructExprFieldKind::IDENTIFIER_VALUE:\n+      compiler.visit (\n+\tstatic_cast<HIR::StructExprFieldIdentifierValue &> (*field));\n+      break;\n+\n+    case HIR::StructExprField::StructExprFieldKind::INDEX_VALUE:\n+      compiler.visit (static_cast<HIR::StructExprFieldIndexValue &> (*field));\n+      break;\n+    }\n+  return compiler.translated;\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  // we can make the field look like a path expr to take advantage of existing\n+  // code\n+\n+  Analysis::NodeMapping mappings_copy1 = field.get_mappings ();\n+  Analysis::NodeMapping mappings_copy2 = field.get_mappings ();\n+\n+  HIR::PathIdentSegment ident_seg (field.get_field_name ());\n+  HIR::PathExprSegment seg (mappings_copy1, ident_seg, field.get_locus (),\n+\t\t\t    HIR::GenericArgs::create_empty ());\n+  HIR::PathInExpression expr (mappings_copy2, {seg}, field.get_locus (), false,\n+\t\t\t      {});\n+  translated = CompileExpr::Compile (&expr, ctx);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "bc5da080dfef0c7c67ab1f4ade3891f04fee3ee5", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_STRUCT_FIELD_EXPR\n+#define RUST_COMPILE_STRUCT_FIELD_EXPR\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileStructExprField : private HIRCompileBase\n+{\n+public:\n+  static tree Compile (HIR::StructExprField *field, Context *ctx);\n+\n+protected:\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+  void visit (HIR::StructExprFieldIndexValue &field);\n+  void visit (HIR::StructExprFieldIdentifier &field);\n+\n+private:\n+  CompileStructExprField (Context *ctx);\n+\n+  tree translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_STRUCT_FIELD_EXPR"}, {"sha": "eced909673e76b1ff4a048e7c0c26cb5bb364a45", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "added", "additions": 713, "deletions": 0, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,713 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-type.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-constexpr.h\"\n+\n+#include \"tree.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+static const std::string RUST_ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\";\n+\n+TyTyResolveCompile::TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n+  : ctx (ctx), trait_object_mode (trait_object_mode),\n+    translated (error_mark_node), recurisve_ops (0)\n+{}\n+\n+tree\n+TyTyResolveCompile::compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t\t     bool trait_object_mode)\n+{\n+  TyTyResolveCompile compiler (ctx, trait_object_mode);\n+  ty->accept_vis (compiler);\n+\n+  if (compiler.translated != error_mark_node\n+      && TYPE_NAME (compiler.translated) != NULL)\n+    {\n+      // canonicalize the type\n+      compiler.translated = ctx->insert_compiled_type (compiler.translated);\n+    }\n+\n+  return compiler.translated;\n+}\n+\n+// see: gcc/c/c-decl.cc:8230-8241\n+// https://github.com/Rust-GCC/gccrs/blob/0024bc2f028369b871a65ceb11b2fddfb0f9c3aa/gcc/c/c-decl.c#L8229-L8241\n+tree\n+TyTyResolveCompile::get_implicit_enumeral_node_type (Context *ctx)\n+{\n+  // static tree enum_node = NULL_TREE;\n+  // if (enum_node == NULL_TREE)\n+  //   {\n+  //     enum_node = make_node (ENUMERAL_TYPE);\n+  //     SET_TYPE_MODE (enum_node, TYPE_MODE (unsigned_type_node));\n+  //     SET_TYPE_ALIGN (enum_node, TYPE_ALIGN (unsigned_type_node));\n+  //     TYPE_USER_ALIGN (enum_node) = 0;\n+  //     TYPE_UNSIGNED (enum_node) = 1;\n+  //     TYPE_PRECISION (enum_node) = TYPE_PRECISION (unsigned_type_node);\n+  //     TYPE_MIN_VALUE (enum_node) = TYPE_MIN_VALUE (unsigned_type_node);\n+  //     TYPE_MAX_VALUE (enum_node) = TYPE_MAX_VALUE (unsigned_type_node);\n+\n+  //     // tree identifier = ctx->get_backend ()->get_identifier_node\n+  //     // (\"enumeral\"); tree enum_decl\n+  //     //   = build_decl (BUILTINS_LOCATION, TYPE_DECL, identifier,\n+  //     enum_node);\n+  //     // TYPE_NAME (enum_node) = enum_decl;\n+  //   }\n+  // return enum_node;\n+\n+  static tree enum_node = NULL_TREE;\n+  if (enum_node == NULL_TREE)\n+    {\n+      enum_node = ctx->get_backend ()->named_type (\n+\t\"enumeral\", ctx->get_backend ()->integer_type (false, 64),\n+\tLinemap::predeclared_location ());\n+    }\n+  return enum_node;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ErrorType &)\n+{\n+  translated = error_mark_node;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::InferType &)\n+{\n+  translated = error_mark_node;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ClosureType &)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ProjectionType &type)\n+{\n+  type.get ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::PlaceholderType &type)\n+{\n+  type.resolve ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ParamType &param)\n+{\n+  if (recurisve_ops++ >= rust_max_recursion_depth)\n+    {\n+      rust_error_at (Location (),\n+\t\t     \"%<recursion depth%> count exceeds limit of %i (use \"\n+\t\t     \"%<frust-max-recursion-depth=%> to increase the limit)\",\n+\t\t     rust_max_recursion_depth);\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  param.resolve ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FnType &type)\n+{\n+  Backend::typed_identifier receiver;\n+  std::vector<Backend::typed_identifier> parameters;\n+  std::vector<Backend::typed_identifier> results;\n+\n+  if (!type.get_return_type ()->is_unit ())\n+    {\n+      auto hir_type = type.get_return_type ();\n+      auto ret = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n+      results.push_back (Backend::typed_identifier (\n+\t\"_\", ret,\n+\tctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n+    }\n+\n+  for (auto &param_pair : type.get_params ())\n+    {\n+      auto param_tyty = param_pair.second;\n+      auto compiled_param_type\n+\t= TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n+\n+      auto compiled_param = Backend::typed_identifier (\n+\tparam_pair.first->as_string (), compiled_param_type,\n+\tctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n+\n+      parameters.push_back (compiled_param);\n+    }\n+\n+  if (!type.is_varadic ())\n+    translated\n+      = ctx->get_backend ()->function_type (receiver, parameters, results, NULL,\n+\t\t\t\t\t    type.get_ident ().locus);\n+  else\n+    translated\n+      = ctx->get_backend ()->function_type_varadic (receiver, parameters,\n+\t\t\t\t\t\t    results, NULL,\n+\t\t\t\t\t\t    type.get_ident ().locus);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FnPtr &type)\n+{\n+  tree result_type = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n+\n+  std::vector<tree> parameters;\n+\n+  auto &params = type.get_params ();\n+  for (auto &p : params)\n+    {\n+      tree pty = TyTyResolveCompile::compile (ctx, p.get_tyty ());\n+      parameters.push_back (pty);\n+    }\n+\n+  translated = ctx->get_backend ()->function_ptr_type (result_type, parameters,\n+\t\t\t\t\t\t       type.get_ident ().locus);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ADTType &type)\n+{\n+  tree type_record = error_mark_node;\n+  if (!type.is_enum ())\n+    {\n+      rust_assert (type.number_of_variants () == 1);\n+\n+      TyTy::VariantDef &variant = *type.get_variants ().at (0);\n+      std::vector<Backend::typed_identifier> fields;\n+      for (size_t i = 0; i < variant.num_fields (); i++)\n+\t{\n+\t  const TyTy::StructFieldType *field = variant.get_field_at_index (i);\n+\t  tree compiled_field_ty\n+\t    = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+\n+\t  Backend::typed_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\t  fields.push_back (std::move (f));\n+\t}\n+\n+      type_record = type.is_union ()\n+\t\t      ? ctx->get_backend ()->union_type (fields)\n+\t\t      : ctx->get_backend ()->struct_type (fields);\n+    }\n+  else\n+    {\n+      // see:\n+      // https://github.com/bminor/binutils-gdb/blob/527b8861cd472385fa9160a91dd6d65a25c41987/gdb/dwarf2/read.c#L9010-L9241\n+      //\n+      // enums are actually a big union so for example the rust enum:\n+      //\n+      // enum AnEnum {\n+      //   A,\n+      //   B,\n+      //   C (char),\n+      //   D { x: i64, y: i64 },\n+      // }\n+      //\n+      // we actually turn this into\n+      //\n+      // union {\n+      //   struct A { int RUST$ENUM$DISR; }; <- this is a data-less variant\n+      //   struct B { int RUST$ENUM$DISR; }; <- this is a data-less variant\n+      //   struct C { int RUST$ENUM$DISR; char __0; };\n+      //   struct D { int RUST$ENUM$DISR; i64 x; i64 y; };\n+      // }\n+      //\n+      // Ada, qual_union_types might still work for this but I am not 100% sure.\n+      // I ran into some issues lets reuse our normal union and ask Ada people\n+      // about it.\n+\n+      std::vector<tree> variant_records;\n+      for (auto &variant : type.get_variants ())\n+\t{\n+\t  std::vector<Backend::typed_identifier> fields;\n+\n+\t  // add in the qualifier field for the variant\n+\t  tree enumeral_type\n+\t    = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+\t  Backend::typed_identifier f (RUST_ENUM_DISR_FIELD_NAME, enumeral_type,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t variant->get_id ()));\n+\t  fields.push_back (std::move (f));\n+\n+\t  // compile the rest of the fields\n+\t  for (size_t i = 0; i < variant->num_fields (); i++)\n+\t    {\n+\t      const TyTy::StructFieldType *field\n+\t\t= variant->get_field_at_index (i);\n+\t      tree compiled_field_ty\n+\t\t= TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+\n+\t      std::string field_name = field->get_name ();\n+\t      if (variant->get_variant_type ()\n+\t\t  == TyTy::VariantDef::VariantType::TUPLE)\n+\t\tfield_name = \"__\" + field->get_name ();\n+\n+\t      Backend::typed_identifier f (\n+\t\tfield_name, compiled_field_ty,\n+\t\tctx->get_mappings ()->lookup_location (type.get_ty_ref ()));\n+\t      fields.push_back (std::move (f));\n+\t    }\n+\n+\t  tree variant_record = ctx->get_backend ()->struct_type (fields);\n+\t  tree named_variant_record = ctx->get_backend ()->named_type (\n+\t    variant->get_ident ().path.get (), variant_record,\n+\t    variant->get_ident ().locus);\n+\n+\t  // set the qualifier to be a builtin\n+\t  DECL_ARTIFICIAL (TYPE_FIELDS (variant_record)) = 1;\n+\n+\t  // add them to the list\n+\t  variant_records.push_back (named_variant_record);\n+\t}\n+\n+      // now we need to make the actual union, but first we need to make\n+      // named_type TYPE_DECL's out of the variants\n+\n+      size_t i = 0;\n+      std::vector<Backend::typed_identifier> enum_fields;\n+      for (auto &variant_record : variant_records)\n+\t{\n+\t  TyTy::VariantDef *variant = type.get_variants ().at (i++);\n+\t  std::string implicit_variant_name = variant->get_identifier ();\n+\n+\t  Backend::typed_identifier f (implicit_variant_name, variant_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\t  enum_fields.push_back (std::move (f));\n+\t}\n+\n+      // finally make the union or the enum\n+      type_record = ctx->get_backend ()->union_type (enum_fields);\n+    }\n+\n+  // Handle repr options\n+  // TODO: \"packed\" should only narrow type alignment and \"align\" should only\n+  // widen it. Do we need to check and enforce this here, or is it taken care of\n+  // later on in the gcc middle-end?\n+  TyTy::ADTType::ReprOptions repr = type.get_repr_options ();\n+  if (repr.pack)\n+    {\n+      TYPE_PACKED (type_record) = 1;\n+      if (repr.pack > 1)\n+\t{\n+\t  SET_TYPE_ALIGN (type_record, repr.pack * 8);\n+\t  TYPE_USER_ALIGN (type_record) = 1;\n+\t}\n+    }\n+  else if (repr.align)\n+    {\n+      SET_TYPE_ALIGN (type_record, repr.align * 8);\n+      TYPE_USER_ALIGN (type_record) = 1;\n+    }\n+\n+  std::string named_struct_str\n+    = type.get_ident ().path.get () + type.subst_as_string ();\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::TupleType &type)\n+{\n+  if (type.num_fields () == 0)\n+    {\n+      translated = ctx->get_backend ()->unit_type ();\n+      return;\n+    }\n+\n+  // create implicit struct\n+  std::vector<Backend::typed_identifier> fields;\n+  for (size_t i = 0; i < type.num_fields (); i++)\n+    {\n+      TyTy::BaseType *field = type.get_field (i);\n+      tree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n+\n+      // rustc uses the convention __N, where N is an integer, to\n+      // name the fields of a tuple.  We follow this as well,\n+      // because this is used by GDB.  One further reason to prefer\n+      // this, rather than simply emitting the integer, is that this\n+      // approach makes it simpler to use a C-only debugger, or\n+      // GDB's C mode, when debugging Rust.\n+      Backend::typed_identifier f (\"__\" + std::to_string (i), compiled_field_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n+  translated\n+    = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n+\t\t\t\t       type.get_ident ().locus);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n+{\n+  tree element_type\n+    = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+  tree capacity_expr = CompileExpr::Compile (&type.get_capacity_expr (), ctx);\n+  tree folded_capacity_expr = fold_expr (capacity_expr);\n+\n+  translated\n+    = ctx->get_backend ()->array_type (element_type, folded_capacity_expr);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::SliceType &type)\n+{\n+  tree type_record = create_slice_type_record (type);\n+\n+  std::string named_struct_str\n+    = std::string (\"[\") + type.get_element_type ()->get_name () + \"]\";\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::BoolType &type)\n+{\n+  translated\n+    = ctx->get_backend ()->named_type (\"bool\",\n+\t\t\t\t       ctx->get_backend ()->bool_type (),\n+\t\t\t\t       Linemap::predeclared_location ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::IntType &type)\n+{\n+  switch (type.get_int_kind ())\n+    {\n+    case TyTy::IntType::I8:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i8\", ctx->get_backend ()->integer_type (false, 8),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I16:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i16\", ctx->get_backend ()->integer_type (false, 16),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I32:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i32\", ctx->get_backend ()->integer_type (false, 32),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I64:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i64\", ctx->get_backend ()->integer_type (false, 64),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I128:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i128\", ctx->get_backend ()->integer_type (false, 128),\n+\tLinemap::predeclared_location ());\n+      return;\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::UintType &type)\n+{\n+  switch (type.get_uint_kind ())\n+    {\n+    case TyTy::UintType::U8:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u8\", ctx->get_backend ()->integer_type (true, 8),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U16:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u16\", ctx->get_backend ()->integer_type (true, 16),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U32:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u32\", ctx->get_backend ()->integer_type (true, 32),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U64:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u64\", ctx->get_backend ()->integer_type (true, 64),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U128:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u128\", ctx->get_backend ()->integer_type (true, 128),\n+\tLinemap::predeclared_location ());\n+      return;\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FloatType &type)\n+{\n+  switch (type.get_float_kind ())\n+    {\n+    case TyTy::FloatType::F32:\n+      translated\n+\t= ctx->get_backend ()->named_type (\"f32\",\n+\t\t\t\t\t   ctx->get_backend ()->float_type (32),\n+\t\t\t\t\t   Linemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::FloatType::F64:\n+      translated\n+\t= ctx->get_backend ()->named_type (\"f64\",\n+\t\t\t\t\t   ctx->get_backend ()->float_type (64),\n+\t\t\t\t\t   Linemap::predeclared_location ());\n+      return;\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::USizeType &type)\n+{\n+  translated = ctx->get_backend ()->named_type (\n+    \"usize\",\n+    ctx->get_backend ()->integer_type (\n+      true, ctx->get_backend ()->get_pointer_size ()),\n+    Linemap::predeclared_location ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ISizeType &type)\n+{\n+  translated = ctx->get_backend ()->named_type (\n+    \"isize\",\n+    ctx->get_backend ()->integer_type (\n+      false, ctx->get_backend ()->get_pointer_size ()),\n+    Linemap::predeclared_location ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::CharType &type)\n+{\n+  translated\n+    = ctx->get_backend ()->named_type (\"char\",\n+\t\t\t\t       ctx->get_backend ()->wchar_type (),\n+\t\t\t\t       Linemap::predeclared_location ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n+{\n+  const TyTy::SliceType *slice = nullptr;\n+  const TyTy::StrType *str = nullptr;\n+  if (type.is_dyn_slice_type (&slice))\n+    {\n+      tree type_record = create_slice_type_record (*slice);\n+      std::string dyn_slice_type_str\n+\t= std::string (type.is_mutable () ? \"&mut \" : \"&\") + \"[\"\n+\t  + slice->get_element_type ()->get_name () + \"]\";\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_slice_type_str, type_record,\n+\t\t\t\t\t   slice->get_locus ());\n+\n+      return;\n+    }\n+  else if (type.is_dyn_str_type (&str))\n+    {\n+      tree type_record = create_str_type_record (*str);\n+      std::string dyn_str_type_str\n+\t= std::string (type.is_mutable () ? \"&mut \" : \"&\") + \"str\";\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_str_type_str, type_record,\n+\t\t\t\t\t   str->get_locus ());\n+\n+      return;\n+    }\n+\n+  tree base_compiled_type\n+    = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n+  if (type.is_mutable ())\n+    {\n+      translated = ctx->get_backend ()->reference_type (base_compiled_type);\n+    }\n+  else\n+    {\n+      auto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n+      translated = ctx->get_backend ()->reference_type (base);\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::PointerType &type)\n+{\n+  const TyTy::SliceType *slice = nullptr;\n+  const TyTy::StrType *str = nullptr;\n+  if (type.is_dyn_slice_type (&slice))\n+    {\n+      tree type_record = create_slice_type_record (*slice);\n+      std::string dyn_slice_type_str\n+\t= std::string (type.is_mutable () ? \"*mut \" : \"*const \") + \"[\"\n+\t  + slice->get_element_type ()->get_name () + \"]\";\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_slice_type_str, type_record,\n+\t\t\t\t\t   slice->get_locus ());\n+\n+      return;\n+    }\n+  else if (type.is_dyn_str_type (&str))\n+    {\n+      tree type_record = create_str_type_record (*str);\n+      std::string dyn_str_type_str\n+\t= std::string (type.is_mutable () ? \"*mut \" : \"*const \") + \"str\";\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_str_type_str, type_record,\n+\t\t\t\t\t   str->get_locus ());\n+\n+      return;\n+    }\n+\n+  tree base_compiled_type\n+    = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n+  if (type.is_mutable ())\n+    {\n+      translated = ctx->get_backend ()->pointer_type (base_compiled_type);\n+    }\n+  else\n+    {\n+      auto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n+      translated = ctx->get_backend ()->pointer_type (base);\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::StrType &type)\n+{\n+  tree raw_str = create_str_type_record (type);\n+  translated\n+    = ctx->get_backend ()->named_type (\"str\", raw_str,\n+\t\t\t\t       Linemap::predeclared_location ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::NeverType &)\n+{\n+  translated = ctx->get_backend ()->unit_type ();\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n+{\n+  if (trait_object_mode)\n+    {\n+      translated = ctx->get_backend ()->integer_type (\n+\ttrue, ctx->get_backend ()->get_pointer_size ());\n+      return;\n+    }\n+\n+  // create implicit struct\n+  auto items = type.get_object_items ();\n+  std::vector<Backend::typed_identifier> fields;\n+\n+  tree uint = ctx->get_backend ()->integer_type (\n+    true, ctx->get_backend ()->get_pointer_size ());\n+  tree uintptr_ty = build_pointer_type (uint);\n+\n+  Backend::typed_identifier f (\"pointer\", uintptr_ty,\n+\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t type.get_ty_ref ()));\n+  fields.push_back (std::move (f));\n+\n+  tree vtable_size = build_int_cst (size_type_node, items.size ());\n+  tree vtable_type = ctx->get_backend ()->array_type (uintptr_ty, vtable_size);\n+  Backend::typed_identifier vtf (\"vtable\", vtable_type,\n+\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t   type.get_ty_ref ()));\n+  fields.push_back (std::move (vtf));\n+\n+  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  translated = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n+}\n+\n+tree\n+TyTyResolveCompile::create_slice_type_record (const TyTy::SliceType &type)\n+{\n+  // lookup usize\n+  TyTy::BaseType *usize = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n+  rust_assert (ok);\n+\n+  tree element_type\n+    = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+  tree data_field_ty = build_pointer_type (element_type);\n+  Backend::typed_identifier data_field (\"data\", data_field_ty,\n+\t\t\t\t\ttype.get_locus ());\n+\n+  tree len_field_ty = TyTyResolveCompile::compile (ctx, usize);\n+  Backend::typed_identifier len_field (\"len\", len_field_ty, type.get_locus ());\n+\n+  tree record = ctx->get_backend ()->struct_type ({data_field, len_field});\n+  SLICE_FLAG (record) = 1;\n+  TYPE_MAIN_VARIANT (record) = ctx->insert_main_variant (record);\n+\n+  return record;\n+}\n+\n+tree\n+TyTyResolveCompile::create_str_type_record (const TyTy::StrType &type)\n+{\n+  // lookup usize\n+  TyTy::BaseType *usize = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n+  rust_assert (ok);\n+\n+  tree char_ptr = build_pointer_type (char_type_node);\n+  tree const_char_type = build_qualified_type (char_ptr, TYPE_QUAL_CONST);\n+\n+  tree element_type = const_char_type;\n+  tree data_field_ty = build_pointer_type (element_type);\n+  Backend::typed_identifier data_field (\"data\", data_field_ty,\n+\t\t\t\t\ttype.get_locus ());\n+\n+  tree len_field_ty = TyTyResolveCompile::compile (ctx, usize);\n+  Backend::typed_identifier len_field (\"len\", len_field_ty, type.get_locus ());\n+\n+  tree record = ctx->get_backend ()->struct_type ({data_field, len_field});\n+  SLICE_FLAG (record) = 1;\n+  TYPE_MAIN_VARIANT (record) = ctx->insert_main_variant (record);\n+\n+  return record;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "b52fd71bf6b75aaa2154fb56b00665f8a386be27", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_TYPE\n+#define RUST_COMPILE_TYPE\n+\n+#include \"rust-compile-context.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class TyTyResolveCompile : protected TyTy::TyConstVisitor\n+{\n+public:\n+  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t       bool trait_object_mode = false);\n+\n+  static tree get_implicit_enumeral_node_type (Context *ctx);\n+\n+  void visit (const TyTy::InferType &) override;\n+  void visit (const TyTy::ADTType &) override;\n+  void visit (const TyTy::TupleType &) override;\n+  void visit (const TyTy::FnType &) override;\n+  void visit (const TyTy::FnPtr &) override;\n+  void visit (const TyTy::ArrayType &) override;\n+  void visit (const TyTy::SliceType &) override;\n+  void visit (const TyTy::BoolType &) override;\n+  void visit (const TyTy::IntType &) override;\n+  void visit (const TyTy::UintType &) override;\n+  void visit (const TyTy::FloatType &) override;\n+  void visit (const TyTy::USizeType &) override;\n+  void visit (const TyTy::ISizeType &) override;\n+  void visit (const TyTy::ErrorType &) override;\n+  void visit (const TyTy::CharType &) override;\n+  void visit (const TyTy::ReferenceType &) override;\n+  void visit (const TyTy::PointerType &) override;\n+  void visit (const TyTy::ParamType &) override;\n+  void visit (const TyTy::StrType &) override;\n+  void visit (const TyTy::NeverType &) override;\n+  void visit (const TyTy::PlaceholderType &) override;\n+  void visit (const TyTy::ProjectionType &) override;\n+  void visit (const TyTy::DynamicObjectType &) override;\n+  void visit (const TyTy::ClosureType &) override;\n+\n+public:\n+  static hashval_t type_hasher (tree type);\n+\n+protected:\n+  tree create_slice_type_record (const TyTy::SliceType &type);\n+  tree create_str_type_record (const TyTy::StrType &type);\n+\n+private:\n+  TyTyResolveCompile (Context *ctx, bool trait_object_mode);\n+\n+  Context *ctx;\n+  bool trait_object_mode;\n+  tree translated;\n+  int recurisve_ops;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_TYPE"}, {"sha": "e2ee05b81631844f39c83af61ba349428e6885c7", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019b2f15581948806ee14a6d05b09ec94f04c966/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=019b2f15581948806ee14a6d05b09ec94f04c966", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_VAR_DECL\n+#define RUST_COMPILE_VAR_DECL\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-hir-visitor.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileVarDecl : public HIRCompileBase, public HIR::HIRPatternVisitor\n+{\n+  using HIR::HIRPatternVisitor::visit;\n+\n+public:\n+  static ::Bvariable *compile (tree fndecl, tree translated_type,\n+\t\t\t       HIR::Pattern *pattern, Context *ctx)\n+  {\n+    CompileVarDecl compiler (ctx, fndecl, translated_type);\n+    pattern->accept_vis (compiler);\n+    return compiler.compiled_variable;\n+  }\n+\n+  void visit (HIR::IdentifierPattern &pattern) override\n+  {\n+    if (!pattern.is_mut ())\n+      translated_type = ctx->get_backend ()->immutable_type (translated_type);\n+\n+    compiled_variable\n+      = ctx->get_backend ()->local_variable (fndecl, pattern.get_identifier (),\n+\t\t\t\t\t     translated_type, NULL /*decl_var*/,\n+\t\t\t\t\t     pattern.get_locus ());\n+\n+    HirId stmt_id = pattern.get_pattern_mappings ().get_hirid ();\n+    ctx->insert_var_decl (stmt_id, compiled_variable);\n+  }\n+\n+  void visit (HIR::WildcardPattern &pattern) override\n+  {\n+    translated_type = ctx->get_backend ()->immutable_type (translated_type);\n+\n+    compiled_variable\n+      = ctx->get_backend ()->local_variable (fndecl, \"_\", translated_type,\n+\t\t\t\t\t     NULL /*decl_var*/,\n+\t\t\t\t\t     pattern.get_locus ());\n+\n+    HirId stmt_id = pattern.get_pattern_mappings ().get_hirid ();\n+    ctx->insert_var_decl (stmt_id, compiled_variable);\n+  }\n+\n+  // Empty visit for unused Pattern HIR nodes.\n+  void visit (HIR::GroupedPattern &) override {}\n+  void visit (HIR::LiteralPattern &) override {}\n+  void visit (HIR::PathInExpression &) override {}\n+  void visit (HIR::QualifiedPathInExpression &) override {}\n+  void visit (HIR::RangePattern &) override {}\n+  void visit (HIR::ReferencePattern &) override {}\n+  void visit (HIR::SlicePattern &) override {}\n+  void visit (HIR::StructPattern &) override {}\n+  void visit (HIR::TuplePattern &) override {}\n+  void visit (HIR::TupleStructPattern &) override {}\n+\n+private:\n+  CompileVarDecl (Context *ctx, tree fndecl, tree translated_type)\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (translated_type),\n+      compiled_variable (ctx->get_backend ()->error_variable ())\n+  {}\n+\n+  tree fndecl;\n+  tree translated_type;\n+\n+  Bvariable *compiled_variable;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_VAR_DECL"}]}