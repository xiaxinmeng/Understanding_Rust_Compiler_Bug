{"sha": "5362b0866b3e17b4e0db2c427da4839dbad6ca03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM2MmIwODY2YjNlMTdiNGUwZGIyYzQyN2RhNDgzOWRiYWQ2Y2EwMw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2000-11-09T23:15:27Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2000-11-09T23:15:27Z"}, "message": "decl.c (init_decl_processing): Change definition of __wchar_t to wchar_t.\n\n2000-11-07  Eric Christopher  <echristo@redhat.com>\n\n        * decl.c (init_decl_processing): Change definition of\n        __wchar_t to wchar_t.  Remove artificial declaration of\n        wchar_t.\n        * lex.c: Change instances of __wchar_t to wchar_t.\n\nFrom-SVN: r37348", "tree": {"sha": "044e6065a180d0c384f61b86d57ff9326e31b1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/044e6065a180d0c384f61b86d57ff9326e31b1df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5362b0866b3e17b4e0db2c427da4839dbad6ca03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5362b0866b3e17b4e0db2c427da4839dbad6ca03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5362b0866b3e17b4e0db2c427da4839dbad6ca03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5362b0866b3e17b4e0db2c427da4839dbad6ca03/comments", "author": null, "committer": null, "parents": [{"sha": "7ca0e6d96e806cb6fd026dfda2e58449af177969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca0e6d96e806cb6fd026dfda2e58449af177969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca0e6d96e806cb6fd026dfda2e58449af177969"}], "stats": {"total": 176, "additions": 89, "deletions": 87}, "files": [{"sha": "384d8c2145795d4f03e385e9f653d276bd8406ef", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5362b0866b3e17b4e0db2c427da4839dbad6ca03/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5362b0866b3e17b4e0db2c427da4839dbad6ca03/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5362b0866b3e17b4e0db2c427da4839dbad6ca03", "patch": "@@ -1,3 +1,10 @@\n+2000-11-07  Eric Christopher  <echristo@redhat.com>\n+\n+        * decl.c (init_decl_processing): Change definition of\n+        __wchar_t to wchar_t.  Remove artificial declaration of\n+        wchar_t.\n+        * lex.c: Change instances of __wchar_t to wchar_t.\n+\n 2000-11-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* lex.c (do_identifier): Don't lookup_name for operators.\n@@ -115,7 +122,7 @@\n \t* error.c (dump_function_decl): Print no space between\n \t`ptr-operator' the `type-specifier' of the return type.\n \t(dump_type_prefix): Make sure we put space at the appropriate\n-\tplace. \n+\tplace.\n \n 2000-10-23  Jason Merrill  <jason@redhat.com>\n \n@@ -134,7 +141,7 @@\n \n \t* optimize.c (copy_body_r): Don't treat CALL_EXPRs specially.\n \n-\t* typeck.c (c_sizeof): Return an expression of `size_t' type, \n+\t* typeck.c (c_sizeof): Return an expression of `size_t' type,\n \tnot one with TYPE_IS_SIZETYPE set.\n \t(dubious_conversion_warnings): Remove special-case code.\n \n@@ -147,7 +154,7 @@\n \t* tree.c (walk_tree): Handle VECTOR_TYPE.\n \n \t* decl.c (init_decl_processing): Call MD_INIT_BUILTINS.\n-\t\n+\n 2000-10-21  Jason Merrill  <jason@redhat.com>\n \n \t* parse.y (operator): Set got_object from got_scope.\n@@ -195,7 +202,7 @@ Fri Oct 20 13:54:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(splay_tree_compare_integer_csts): New function.\n \t(layout_class_type): Use a splay_tree, rather than a varray, to\n \trepresent the offsets of empty bases.\n-\t\n+\n \t* cp-tree.h (DECL_ANTICIPATED): Don't require a FUNCTION_DECL.\n \t* decl.c (select_decl): Don't return declarations that are\n \tDECL_ANTICIPATED.\n@@ -227,7 +234,7 @@ Fri Oct 20 13:54:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* except.c (init_exception_processing): Use std_identifier.\n \t* init.c (build_member_call): Use fake_std_node.\n \t* rtti.c (init_rtti_processing): Use std_identifier.\n-\t \n+\n 2000-10-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (back_end_hook): Remove declaration.\n@@ -295,7 +302,7 @@ Tue Oct 17 20:19:06 2000  Brad Lucier <lucier@math.purdue.edu>\n \t(init_repo): Initialize it.\n \t* search.c (current_obstack): Remove.\n \t* typeck2.c (add_exception_specifier): Don't call build_decl_list.\n-\t\n+\n 2000-10-09  Richard Henderson  <rth@cygnus.com>\n \n \t* Make-lang.in (CXX_EXTRA_HEADERS): Remove.\n@@ -331,7 +338,7 @@ Tue Oct 17 20:19:06 2000  Brad Lucier <lucier@math.purdue.edu>\n \n \t* pt.c (lookup_template_class): Set current access for enum.\n \t(tsubst_enum): Set file & line for enum decl.\n-\t\n+\n \t* spew.c (yylex): Remove unused variable.\n \n 2000-10-05  Richard Henderson  <rth@cygnus.com>\n@@ -354,7 +361,7 @@ Tue Oct 17 20:19:06 2000  Brad Lucier <lucier@math.purdue.edu>\n 2000-10-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* pt.c (tsubst_expr, DECL_STMT case): Don't process if\n-\ttsubsting fails.\t\n+\ttsubsting fails.\n \n 2000-10-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -366,7 +373,7 @@ Tue Oct 17 20:19:06 2000  Brad Lucier <lucier@math.purdue.edu>\n \n \t* decl.c (lang_mark_false_label_stack): Remove.\n \t* lex.c (cp_mang_lang_type): Use ggc_alloc_cleared.\n-\t\n+\n 2000-09-30  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gxxint.texi: Use @email for formatting email addresses."}, {"sha": "ce19601760b360466d6d121c4f72d642e2f5ec91", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5362b0866b3e17b4e0db2c427da4839dbad6ca03/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5362b0866b3e17b4e0db2c427da4839dbad6ca03/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5362b0866b3e17b4e0db2c427da4839dbad6ca03", "patch": "@@ -188,7 +188,7 @@ static tree start_cleanup_fn PARAMS ((void));\n static void end_cleanup_fn PARAMS ((void));\n static tree cp_make_fname_decl PARAMS ((tree, const char *, int));\n static void initialize_predefined_identifiers PARAMS ((void));\n-static tree check_special_function_return_type \n+static tree check_special_function_return_type\n   PARAMS ((special_function_kind, tree, tree, tree));\n static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n@@ -491,7 +491,7 @@ struct binding_level\n        replaced with a TEMPLATE_DECL.  */\n     unsigned template_parms_p : 1;\n \n-    /* Nonzero if this scope corresponds to the `<>' in a \n+    /* Nonzero if this scope corresponds to the `<>' in a\n        `template <>' clause.  Whenever this flag is set,\n        TEMPLATE_PARMS_P will be set as well.  */\n     unsigned template_spec_p : 1;\n@@ -2860,12 +2860,12 @@ pushtag (name, type, globalize)\n \t     all function definitions in a translation unit in a convenient\n \t     way.  (It's otherwise tricky to find a member function definition\n \t     it's only pointed to from within a local class.)  */\n-\t  if (TYPE_CONTEXT (type) \n+\t  if (TYPE_CONTEXT (type)\n \t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL\n \t      && !processing_template_decl)\n \t    VARRAY_PUSH_TREE (local_classes, type);\n \n-\t  if (!uses_template_parms (type)) \n+\t  if (!uses_template_parms (type))\n \t    {\n \t      if (flag_new_abi)\n \t\tDECL_ASSEMBLER_NAME (d) = mangle_type (type);\n@@ -4049,7 +4049,7 @@ pushdecl (x)\n \t     warn if we later see static one.  */\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n-\t  \n+\n \t  /* Bind the mangled name for the entity.  In the future, we\n \t     should not need to do this; mangled names are an\n \t     implementation detail of which the front-end should not\n@@ -4745,7 +4745,7 @@ redeclaration_error_message (newdecl, olddecl)\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n       if ((TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n-\t   && (DECL_TEMPLATE_RESULT (newdecl) \n+\t   && (DECL_TEMPLATE_RESULT (newdecl)\n \t       != DECL_TEMPLATE_RESULT (olddecl))\n \t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (newdecl))\n \t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)))\n@@ -5152,7 +5152,7 @@ struct cp_switch\n    mark the stack for garbage collection because it is only active\n    during the processing of the body of a function, and we never\n    collect at that point.  */\n-   \n+\n static struct cp_switch *switch_stack;\n \n /* Called right after a switch-statement condition is parsed.\n@@ -5175,7 +5175,7 @@ void\n pop_switch ()\n {\n   struct cp_switch *cs;\n-  \n+\n   cs = switch_stack;\n   splay_tree_delete (cs->cases);\n   switch_stack = switch_stack->next;\n@@ -5197,7 +5197,7 @@ finish_case_label (low_value, high_value)\n       if (high_value)\n \terror (\"case label not within a switch statement\");\n       else if (low_value)\n-\tcp_error (\"case label `%E' not within a switch statement\", \n+\tcp_error (\"case label `%E' not within a switch statement\",\n \t\t  low_value);\n       else\n \terror (\"`default' label not within a switch statement\");\n@@ -5698,8 +5698,8 @@ select_decl (binding, flags)\n   /* When we implicitly declare some builtin entity, we mark it\n      DECL_ANTICIPATED, so that we know to ignore it until it is\n      really declared.  */\n-  if (val && DECL_P (val) \n-      && DECL_LANG_SPECIFIC (val) \n+  if (val && DECL_P (val)\n+      && DECL_LANG_SPECIFIC (val)\n       && DECL_ANTICIPATED (val))\n     return NULL_TREE;\n \n@@ -6267,7 +6267,7 @@ typedef struct predefined_identifier\n /* Create all the predefined identifiers.  */\n \n static void\n-initialize_predefined_identifiers () \n+initialize_predefined_identifiers ()\n {\n   struct predefined_identifier *pid;\n \n@@ -6385,7 +6385,7 @@ init_decl_processing ()\n \t\t\t\t  void_type_node);\n       pushdecl (fake_std_node);\n     }\n-  \n+\n   /* Define `int' and `char' first so that dbx will output them first.  */\n   record_builtin_type (RID_INT, NULL_PTR, integer_type_node);\n   record_builtin_type (RID_CHAR, \"char\", char_type_node);\n@@ -6405,7 +6405,7 @@ init_decl_processing ()\n \t\t       long_long_unsigned_type_node);\n   record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n   record_builtin_type (RID_MAX, \"short unsigned int\",\n-\t\t       short_unsigned_type_node); \n+\t\t       short_unsigned_type_node);\n   record_builtin_type (RID_MAX, \"unsigned short\",\n \t\t       short_unsigned_type_node);\n \n@@ -6576,12 +6576,7 @@ init_decl_processing ()\n     wchar_type_node = make_signed_type (wchar_type_size);\n   else\n     wchar_type_node = make_unsigned_type (wchar_type_size);\n-  record_builtin_type (RID_WCHAR, \"__wchar_t\", wchar_type_node);\n-\n-  /* Artificial declaration of wchar_t -- can be bashed */\n-  wchar_decl_node = build_decl (TYPE_DECL, get_identifier (\"wchar_t\"),\n-\t\t\t\twchar_type_node);\n-  pushdecl (wchar_decl_node);\n+  record_builtin_type (RID_WCHAR, \"wchar_t\", wchar_type_node);\n \n   /* This is for wide string constants.  */\n   wchar_array_type_node\n@@ -6760,7 +6755,7 @@ cp_make_fname_decl (id, name, type_dep)\n   tree decl, type, init;\n   size_t length = strlen (name);\n   tree domain = NULL_TREE;\n-  \n+\n   if (!processing_template_decl)\n     type_dep = 0;\n   if (!type_dep)\n@@ -6791,7 +6786,7 @@ cp_make_fname_decl (id, name, type_dep)\n     }\n   DECL_INITIAL (decl) = init;\n   cp_finish_decl (decl, init, NULL_TREE, LOOKUP_ONLYCONVERTING);\n-  \n+\n   /* We will have to make sure we only emit this, if it is actually used. */\n   return decl;\n }\n@@ -6823,7 +6818,7 @@ builtin_function (name, type, code, class, libname)\n \n   /* All builtins that don't begin with an `_' should go in the `std'\n      namespace.  */\n-  if (flag_honor_std && name[0] != '_') \n+  if (flag_honor_std && name[0] != '_')\n     {\n       push_namespace (std_identifier);\n       DECL_CONTEXT (decl) = std_node;\n@@ -6937,7 +6932,7 @@ push_cp_library_fn (operator_code, type)\n      enum tree_code operator_code;\n      tree type;\n {\n-  tree fn = build_cp_library_fn (ansi_opname (operator_code), \n+  tree fn = build_cp_library_fn (ansi_opname (operator_code),\n \t\t\t\t operator_code,\n \t\t\t\t type);\n   pushdecl (fn);\n@@ -7399,7 +7394,7 @@ start_decl_1 (decl)\n       && TREE_CODE (decl) != TYPE_DECL\n       && TREE_CODE (decl) != TEMPLATE_DECL\n       && type != error_mark_node\n-      && IS_AGGR_TYPE (type) \n+      && IS_AGGR_TYPE (type)\n       && ! DECL_EXTERNAL (decl))\n     {\n       if ((! processing_template_decl || ! uses_template_parms (type))\n@@ -7922,7 +7917,7 @@ maybe_inject_for_scope_var (decl)\n {\n   if (!DECL_NAME (decl))\n     return;\n-  \n+\n   if (current_binding_level->is_for_scope)\n     {\n       struct binding_level *outer\n@@ -8000,7 +7995,7 @@ initialize_local_var (decl, init, flags)\n \t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = \n+\t  current_stmt_tree ()->stmts_are_full_exprs_p =\n \t    saved_stmts_are_full_exprs_p;\n \t}\n \n@@ -8114,9 +8109,9 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \n   if (type == error_mark_node)\n     return;\n-  \n+\n   /* Add this declaration to the statement-tree.  */\n-  if (building_stmt_tree () \n+  if (building_stmt_tree ()\n       && at_function_scope_p ()\n       && TREE_CODE (decl) != RESULT_DECL)\n     add_decl_stmt (decl);\n@@ -9140,12 +9135,12 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \tset_decl_namespace (decl, context, 0);\n \n       context = DECL_CONTEXT (decl);\n-      if (declarator && context && current_lang_name != lang_name_c) \n+      if (declarator && context && current_lang_name != lang_name_c)\n \t{\n \t  if (flag_new_abi)\n \t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n \t  else\n-\t    DECL_ASSEMBLER_NAME (decl) \n+\t    DECL_ASSEMBLER_NAME (decl)\n \t      = build_static_name (context, declarator);\n \t}\n     }\n@@ -9550,7 +9545,7 @@ check_special_function_return_type (sfk, type, ctype, optype)\n     case sfk_constructor:\n       if (type)\n \tcp_error (\"return type specification for constructor invalid\");\n-\t\n+\n       /* In the old ABI, we return `this'; in the new ABI we don't\n \t bother.  */\n       type = flag_new_abi ? void_type_node : build_pointer_type\t(ctype);\n@@ -9871,7 +9866,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tctor_return_type = TREE_TYPE (dname);\n \t\tsfk = sfk_conversion;\n \t\tif (IDENTIFIER_GLOBAL_VALUE (dname)\n-\t\t    && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (dname)) \n+\t\t    && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (dname))\n \t\t\t== TYPE_DECL))\n \t\t  name = IDENTIFIER_POINTER (dname);\n \t\telse\n@@ -10442,7 +10437,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  if (IDENTIFIER_TYPENAME_P (tmp))\n \t\t    {\n \t\t      if (IDENTIFIER_GLOBAL_VALUE (tmp)\n-\t\t\t  && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (tmp)) \n+\t\t\t  && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (tmp))\n \t\t\t      == TYPE_DECL))\n \t\t\tname = IDENTIFIER_POINTER (tmp);\n \t\t      else\n@@ -10585,7 +10580,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    type = create_array_type_for_decl (dname, type, size);\n \n \t    /* VLAs never work as fields. */\n-\t    if (decl_context == FIELD && !processing_template_decl \n+\t    if (decl_context == FIELD && !processing_template_decl\n \t\t&& TREE_CODE (type) == ARRAY_TYPE\n \t\t&& TYPE_DOMAIN (type) != NULL_TREE\n \t\t&& !TREE_CONSTANT (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n@@ -10948,7 +10943,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    t = ctype;\n \t    while (t != NULL_TREE && CLASS_TYPE_P (t))\n \t      {\n-\t\t/* You're supposed to have one `template <...>' \n+\t\t/* You're supposed to have one `template <...>'\n \t\t   for every template class, but you don't need one\n \t\t   for a full specialization.  For example:\n \n@@ -11191,7 +11186,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))\n \t      = TYPE_IDENTIFIER (type);\n \n-\t  if (flag_new_abi) \n+\t  if (flag_new_abi)\n \t    DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n \t  else\n \t    {\n@@ -11203,7 +11198,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tDECL_CONTEXT (decl) = current_class_type;\n \t      else\n \t\tDECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n-\t      \n+\n \t      DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n \t      DECL_ASSEMBLER_NAME (decl)\n \t\t= get_identifier (build_overload_name (type, 1, 1));\n@@ -11984,7 +11979,7 @@ check_default_argument (decl, arg)\n \n      The keyword `this' shall not be used in a default argument of a\n      member function.  */\n-  var = walk_tree_without_duplicates (&arg, local_variable_p_walkfn, \n+  var = walk_tree_without_duplicates (&arg, local_variable_p_walkfn,\n \t\t\t\t      NULL);\n   if (var)\n     {\n@@ -12409,7 +12404,7 @@ grok_op_properties (decl, virtualp, friendp)\n \tcase CALL_EXPR:\n \t  TYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n \t  break;\n-\t  \n+\n \tcase ARRAY_REF:\n \t  TYPE_OVERLOADS_ARRAY_REF (current_class_type) = 1;\n \t  break;\n@@ -12418,19 +12413,19 @@ grok_op_properties (decl, virtualp, friendp)\n \tcase MEMBER_REF:\n \t  TYPE_OVERLOADS_ARROW (current_class_type) = 1;\n \t  break;\n-\t  \n+\n \tcase NEW_EXPR:\n \t  TYPE_HAS_NEW_OPERATOR (current_class_type) = 1;\n \t  break;\n-\t  \n+\n \tcase DELETE_EXPR:\n \t  TYPE_GETS_DELETE (current_class_type) |= 1;\n \t  break;\n-\t  \n+\n \tcase VEC_NEW_EXPR:\n \t  TYPE_HAS_ARRAY_NEW_OPERATOR (current_class_type) = 1;\n \t  break;\n-\t  \n+\n \tcase VEC_DELETE_EXPR:\n \t  TYPE_GETS_DELETE (current_class_type) |= 2;\n \t  break;\n@@ -12508,7 +12503,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    {\n \t      int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n \t      const char *what = 0;\n-\t      \n+\n \t      if (ref)\n \t\tt = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n \n@@ -12528,7 +12523,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \t}\n \n-      if (DECL_ASSIGNMENT_OPERATOR_P (decl) \n+      if (DECL_ASSIGNMENT_OPERATOR_P (decl)\n \t  && operator_code == NOP_EXPR)\n \t{\n \t  tree parmtype;\n@@ -13128,9 +13123,9 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n \t  if (CLASS_TYPE_P (basetype))\n \t    {\n-\t      TYPE_HAS_NEW_OPERATOR (ref) \n+\t      TYPE_HAS_NEW_OPERATOR (ref)\n \t\t|= TYPE_HAS_NEW_OPERATOR (basetype);\n-\t      TYPE_HAS_ARRAY_NEW_OPERATOR (ref) \n+\t      TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n \t\t|= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n \t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n \t      /* If the base-class uses multiple inheritance, so do we.  */\n@@ -13760,7 +13755,7 @@ start_function (declspecs, declarator, attrs, flags)\n \n   /* If we are (erroneously) defining a function that we have already\n      defined before, wipe out what we knew before.  */\n-  if (!DECL_PENDING_INLINE_P (decl1) \n+  if (!DECL_PENDING_INLINE_P (decl1)\n       && DECL_SAVED_FUNCTION_DATA (decl1))\n     {\n       free (DECL_SAVED_FUNCTION_DATA (decl1));\n@@ -13960,7 +13955,7 @@ store_parm_decls (current_function_parms)\n \t      else\n \t\tcp_error (\"parameter `%D' declared void\", parm);\n \n-\t      cleanup = (processing_template_decl \n+\t      cleanup = (processing_template_decl\n \t\t\t ? NULL_TREE\n \t\t\t : maybe_build_cleanup (parm));\n \n@@ -14726,7 +14721,7 @@ lang_mark_tree (t)\n \t{\n \t  ggc_mark (ld);\n \t  c_mark_lang_decl (&ld->decl_flags.base);\n-\t  if (!DECL_GLOBAL_CTOR_P (t) \n+\t  if (!DECL_GLOBAL_CTOR_P (t)\n \t      && !DECL_GLOBAL_DTOR_P (t)\n \t      && !DECL_THUNK_P (t))\n \t    ggc_mark_tree (ld->decl_flags.u2.access);"}, {"sha": "e7c1e550de150ae99e191ba0d28a7e3583b03b22", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5362b0866b3e17b4e0db2c427da4839dbad6ca03/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5362b0866b3e17b4e0db2c427da4839dbad6ca03/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5362b0866b3e17b4e0db2c427da4839dbad6ca03", "patch": "@@ -170,7 +170,7 @@ make_pointer_declarator (cv_qualifiers, target)\n \n    We return an ADDR_EXPR whose \"contents\" are TARGET\n    and whose type is the modifier list.  */\n-   \n+\n tree\n make_reference_declarator (cv_qualifiers, target)\n      tree cv_qualifiers, target;\n@@ -199,7 +199,7 @@ tree\n make_call_declarator (target, parms, cv_qualifiers, exception_specification)\n      tree target, parms, cv_qualifiers, exception_specification;\n {\n-  target = build_parse_node (CALL_EXPR, target, \n+  target = build_parse_node (CALL_EXPR, target,\n \t\t\t     tree_cons (parms, cv_qualifiers, NULL_TREE),\n \t\t\t     /* The third operand is really RTL.  We\n \t\t\t\tshouldn't put anything there.  */\n@@ -323,7 +323,7 @@ init_cpp_parse ()\n operator_name_info_t operator_name_info[(int) LAST_CPLUS_TREE_CODE];\n /* Similar, but for assignment operators.  */\n operator_name_info_t assignment_operator_name_info[(int) LAST_CPLUS_TREE_CODE];\n-  \n+\n /* Initialize data structures that keep track of operator names.  */\n \n #define DEF_OPERATOR(NAME, C, NM, OM, AR, AP) \\\n@@ -337,7 +337,7 @@ init_operators ()\n   tree identifier;\n   char buffer[256];\n   struct operator_name_info_t *oni;\n-  \n+\n #define DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, ASSN_P) \\\n   sprintf (buffer, ISALPHA (NAME[0]) ? \"operator %s\" : \"operator%s\", NAME); \\\n   identifier = get_identifier (buffer);\t\t\t\t\t    \\\n@@ -353,16 +353,16 @@ init_operators ()\n #include \"operators.def\"\n #undef DEF_OPERATOR\n \n-  operator_name_info[(int) ERROR_MARK].identifier \n+  operator_name_info[(int) ERROR_MARK].identifier\n     = get_identifier (\"<invalid operator>\");\n \n   /* Handle some special cases.  These operators are not defined in\n      the language, but can be produced internally.  We may need them\n      for error-reporting.  (Eventually, we should ensure that this\n      does not happen.  Error messages involving these operators will\n      be confusing to users.)  */\n-  \n-  operator_name_info [(int) INIT_EXPR].name \n+\n+  operator_name_info [(int) INIT_EXPR].name\n     = operator_name_info [(int) MODIFY_EXPR].name;\n   operator_name_info [(int) EXACT_DIV_EXPR].name = \"(ceiling /)\";\n   operator_name_info [(int) CEIL_DIV_EXPR].name = \"(ceiling /)\";\n@@ -380,19 +380,19 @@ init_operators ()\n   operator_name_info [(int) RANGE_EXPR].name = \"...\";\n   operator_name_info [(int) CONVERT_EXPR].name = \"+\";\n \n-  assignment_operator_name_info [(int) EXACT_DIV_EXPR].name \n+  assignment_operator_name_info [(int) EXACT_DIV_EXPR].name\n     = \"(exact /=)\";\n-  assignment_operator_name_info [(int) CEIL_DIV_EXPR].name \n+  assignment_operator_name_info [(int) CEIL_DIV_EXPR].name\n     = \"(ceiling /=)\";\n-  assignment_operator_name_info [(int) FLOOR_DIV_EXPR].name \n+  assignment_operator_name_info [(int) FLOOR_DIV_EXPR].name\n     = \"(floor /=)\";\n-  assignment_operator_name_info [(int) ROUND_DIV_EXPR].name \n+  assignment_operator_name_info [(int) ROUND_DIV_EXPR].name\n     = \"(round /=)\";\n-  assignment_operator_name_info [(int) CEIL_MOD_EXPR].name \n+  assignment_operator_name_info [(int) CEIL_MOD_EXPR].name\n     = \"(ceiling %=)\";\n-  assignment_operator_name_info [(int) FLOOR_MOD_EXPR].name \n+  assignment_operator_name_info [(int) FLOOR_MOD_EXPR].name\n     = \"(floor %=)\";\n-  assignment_operator_name_info [(int) ROUND_MOD_EXPR].name \n+  assignment_operator_name_info [(int) ROUND_MOD_EXPR].name\n     = \"(round %=)\";\n }\n \n@@ -443,7 +443,6 @@ static const struct resword reswords[] =\n   { \"__typeof__\",\tRID_TYPEOF,\t0 },\n   { \"__volatile\",\tRID_VOLATILE,\t0 },\n   { \"__volatile__\",\tRID_VOLATILE,\t0 },\n-  { \"__wchar_t\",\tRID_WCHAR,\t0 },\n   { \"asm\",\t\tRID_ASM,\tD_ASM },\n   { \"and\",\t\tRID_AND,\tD_OPNAME },\n   { \"and_eq\",\t\tRID_AND_EQ,\tD_OPNAME },\n@@ -515,6 +514,7 @@ static const struct resword reswords[] =\n   { \"virtual\",\t\tRID_VIRTUAL,\t0 },\n   { \"void\",\t\tRID_VOID,\t0 },\n   { \"volatile\",\t\tRID_VOLATILE,\t0 },\n+  { \"wchar_t\",          RID_WCHAR,\t0 },\n   { \"while\",\t\tRID_WHILE,\t0 },\n   { \"xor\",\t\tRID_XOR,\tD_OPNAME },\n   { \"xor_eq\",\t\tRID_XOR_EQ,\tD_OPNAME },\n@@ -560,7 +560,7 @@ const short rid_to_yy[RID_MAX] =\n   /* RID_BYCOPY */\t0,\n   /* RID_BYREF */\t0,\n   /* RID_ONEWAY */\t0,\n-  \n+\n   /* C */\n   /* RID_INT */\t\tTYPESPEC,\n   /* RID_CHAR */\tTYPESPEC,\n@@ -708,7 +708,7 @@ init_parse (filename)\n   set_identifier_size (sizeof (struct lang_identifier));\n   decl_printable_name = lang_printable_name;\n \n-  internal_filename = ggc_alloc_string (INTERNAL_FILENAME, \n+  internal_filename = ggc_alloc_string (INTERNAL_FILENAME,\n \t\t\t\t\tsizeof (INTERNAL_FILENAME));\n   input_filename = internal_filename;\n \n@@ -896,7 +896,7 @@ print_parse_statistics ()\n   int i;\n   int maxlen = REDUCE_LENGTH;\n   unsigned *sorted;\n-  \n+\n   if (reduce_count[-1] == 0)\n     return;\n \n@@ -981,7 +981,7 @@ extract_interface_info ()\n   if (flag_alt_external_templates)\n     {\n       tree til = tinst_for_decl ();\n-  \n+\n       if (til)\n \tfinfo = get_fileinfo (TINST_FILE (til));\n     }\n@@ -1117,7 +1117,7 @@ parse_strconst_pragma (name, opt)\n   error (\"invalid #pragma %s\", name);\n   return (tree)-1;\n }\n-      \n+\n static void\n handle_pragma_vtable (dfile)\n      cpp_reader *dfile ATTRIBUTE_UNUSED;\n@@ -1392,15 +1392,15 @@ do_identifier (token, parsing, args)\n      like local variables, rather than creating TEMPLATE_DECLs for the\n      local variables and then finding matching instantiations.  */\n   if (current_template_parms\n-      && (is_overloaded_fn (id) \n-\t  || (TREE_CODE (id) == VAR_DECL \n+      && (is_overloaded_fn (id)\n+\t  || (TREE_CODE (id) == VAR_DECL\n \t      && CP_DECL_CONTEXT (id)\n \t      && TREE_CODE (CP_DECL_CONTEXT (id)) == FUNCTION_DECL)\n \t  || TREE_CODE (id) == PARM_DECL\n \t  || TREE_CODE (id) == RESULT_DECL\n \t  || TREE_CODE (id) == USING_DECL))\n     id = build_min_nt (LOOKUP_EXPR, token);\n-      \n+\n   return id;\n }\n \n@@ -1418,7 +1418,7 @@ do_scoped_id (token, parsing)\n \tid = NULL_TREE;\n       else\n \tid = BINDING_VALUE (id);\n-    } \n+    }\n   else\n     id = IDENTIFIER_GLOBAL_VALUE (token);\n   if (parsing && yychar == YYEMPTY)\n@@ -1616,7 +1616,7 @@ cp_make_lang_type (code)\n     {\n       struct lang_type *pi;\n \n-      pi = ((struct lang_type *) \n+      pi = ((struct lang_type *)\n \t    ggc_alloc_cleared (sizeof (struct lang_type)));\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n@@ -1669,9 +1669,9 @@ compiler_error VPARAMS ((const char *msg, ...))\n #endif\n   char buf[1024];\n   va_list ap;\n-  \n+\n   VA_START (ap, msg);\n-  \n+\n #ifndef ANSI_PROTOTYPES\n   msg = va_arg (ap, const char *);\n #endif"}]}