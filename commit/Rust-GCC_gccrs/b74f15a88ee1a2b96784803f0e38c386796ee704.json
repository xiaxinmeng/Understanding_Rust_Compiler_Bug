{"sha": "b74f15a88ee1a2b96784803f0e38c386796ee704", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0ZjE1YTg4ZWUxYTJiOTY3ODQ4MDNmMGUzOGMzODY3OTZlZTcwNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-08-01T23:45:36Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-08-01T23:45:36Z"}, "message": "PR c++/90947 - Simple lookup table of array of strings is miscompiled\n\ngcc/cp/ChangeLog:\n\n\tPR c++/90947\n\t* decl.c (reshape_init_array_1): Avoid truncating initializer\n\tlists containing string literals.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/90947\n\t* c-c++-common/array-1.c: New test.\n\t* g++.dg/abi/mangle73.C: New test.\n\t* g++.dg/cpp2a/nontype-class23.C: New test.\n\t* g++.dg/init/array53.C: New test.\n\ngcc/ChangeLog:\n\n\tPR c++/90947\n\t* tree.c (type_initializer_zero_p): Define.\n\t* tree.h (type_initializer_zero_p): New function.\n\nFrom-SVN: r273989", "tree": {"sha": "7c4a96774ea3cef422ba9596824ceb090bf0ff21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c4a96774ea3cef422ba9596824ceb090bf0ff21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b74f15a88ee1a2b96784803f0e38c386796ee704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74f15a88ee1a2b96784803f0e38c386796ee704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b74f15a88ee1a2b96784803f0e38c386796ee704", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74f15a88ee1a2b96784803f0e38c386796ee704/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3b4eae6c3ac560f28f2d1d209ae5e0e030f95fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b4eae6c3ac560f28f2d1d209ae5e0e030f95fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3b4eae6c3ac560f28f2d1d209ae5e0e030f95fe"}], "stats": {"total": 576, "additions": 574, "deletions": 2}, "files": [{"sha": "e5c3a59cbb5820ea0785559f5971531a11dfe751", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -1,3 +1,9 @@\n+2019-08-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/90947\n+\t* tree.c (type_initializer_zero_p): Define.\n+\t* tree.h (type_initializer_zero_p): New function.\n+\n 2019-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cfgrtl.c (relink_block_chain): Add line returns in dump file."}, {"sha": "02992ae9b470112bfc87a1e733aba9cd1421210b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -1,3 +1,9 @@\n+2019-08-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/90947\n+\t* decl.c (reshape_init_array_1): Avoid truncating initializer\n+\tlists containing string literals.\n+\n 2019-08-01  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/90805 - detect narrowing in case values."}, {"sha": "a1ab5ca81933118622f5dccfcd737ed22369b297", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -5899,8 +5899,9 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n       /* Pointers initialized to strings must be treated as non-zero\n \t even if the string is empty.  */\n       tree init_type = TREE_TYPE (elt_init);\n-      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type))\n-\t  || !initializer_zerop (elt_init))\n+      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)))\n+\tlast_nonzero = index;\n+      else if (!type_initializer_zero_p (elt_type, elt_init))\n \tlast_nonzero = index;\n \n       /* This can happen with an invalid initializer (c++/54501).  */"}, {"sha": "028f978e8b12783b6ec3ac50ea84f54ebd877e73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -1,3 +1,11 @@\n+2019-08-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/90947\n+\t* c-c++-common/array-1.c: New test.\n+\t* g++.dg/abi/mangle73.C: New test.\n+\t* g++.dg/cpp2a/nontype-class23.C: New test.\n+\t* g++.dg/init/array53.C: New test.\n+\n 2019-08-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/85693"}, {"sha": "5de9ade4d4339efdbd1c7d2921a8bf67f0f81701", "filename": "gcc/testsuite/c-c++-common/array-1.c", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Farray-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Farray-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Farray-1.c?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -0,0 +1,247 @@\n+// PR c++/90947 - Simple lookup table of array of strings is miscompiled\n+// { dg-do compile }\n+// { dg-options \"-O1 -fdump-tree-optimized\" }\n+\n+#define assert(expr) ((expr) ? (void)0 : __builtin_abort ())\n+\n+void pr90947 (void)\n+{\n+  int vecsize = 4;\n+  int index = 0;\n+  static const char *a[4][4] =\n+    {\n+     { \".x\", \".y\", \".z\", \".w\" },\n+     { \".xy\", \".yz\", \".zw\", 0 },\n+     { \".xyz\", \".yzw\", 0, 0 },\n+     { \"\", 0, 0, 0 },\n+    };\n+\n+  assert (vecsize >= 1 && vecsize <= 4);\n+  assert (index >= 0 && index < 4);\n+  assert (a[vecsize - 1][index]);\n+}\n+\n+void f_a1_1 (void)\n+{\n+  {\n+    const char* a[1][1] = { { 0 } };\n+    assert (0 == a[0][0]);\n+  }\n+  {\n+    const char* a[1][1] = { { \"\" } };\n+    assert ('\\0' == *a[0][0]);\n+  }\n+}\n+\n+void f_a2_1 (void)\n+{\n+  {\n+    const char* a[2][1] = { { \"\" }, { \"\" } };\n+    assert ('\\0' == *a[0][0] && '\\0' == *a[1][0]);\n+  }\n+  {\n+    const char* a[2][1] = { { 0 }, { \"\" } };\n+    assert (0 == a[0][0] && '\\0' == *a[1][0]);\n+  }\n+  {\n+    const char* a[2][1] = { { }, { \"\" } };\n+    assert (0 == a[0][0] && '\\0' == *a[1][0]);\n+  }\n+}\n+\n+void f_a2_2 (void)\n+{\n+  {\n+    const char* a[2][2] = { { \"\", \"\" }, { \"\", \"\" } };\n+    assert ('\\0' == *a[0][0] && '\\0' == *a[0][1]);\n+    assert ('\\0' == *a[1][0] && '\\0' == *a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { \"\", \"\" }, { \"\", 0 } };\n+    assert ('\\0' == *a[0][0] && '\\0' == *a[0][1]);\n+    assert ('\\0' == *a[1][0] && 0 == a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { \"\", \"\" }, { \"\" } };\n+    assert ('\\0' == *a[0][0] && '\\0' == *a[0][1]);\n+    assert ('\\0' == *a[1][0] && 0 == a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { \"\", \"\" }, { 0, \"\" } };\n+    assert ('\\0' == *a[0][0] && '\\0' == *a[0][1]);\n+    assert (0 == a[1][0] && '\\0' == *a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { \"\", 0 }, { 0, \"\" } };\n+    assert ('\\0' == *a[0][0] && 0 == a[0][1]);\n+    assert (0 == a[1][0] && '\\0' == *a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { 0, 0 }, { 0, \"\" } };\n+    assert (0 == a[0][0] && 0 == a[0][1]);\n+    assert (0 == a[1][0] && '\\0' == *a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { 0 }, { 0, \"\" } };\n+    assert (0 == a[0][0] && 0 == a[0][1]);\n+    assert (0 == a[1][0] && '\\0' == *a[1][1]);\n+  }\n+  {\n+    const char* a[2][2] = { { }, { 0, \"\" } };\n+    assert (0 == a[0][0] && 0 == a[0][1]);\n+    assert (0 == a[1][0] && '\\0' == *a[1][1]);\n+  }\n+}\n+\n+void f_a2_2_2 (void)\n+{\n+  {\n+    const char* a[2][2][2] =\n+      { { { \"\", \"\" }, { \"\", \"\" } }, { { \"\", \"\" }, { \"\", \"\" } } };\n+\n+    assert ('\\0' == *a[0][0][0] && '\\0' == *a[0][0][1]);\n+    assert ('\\0' == *a[0][1][0] && '\\0' == *a[0][1][1]);\n+    assert ('\\0' == *a[1][0][0] && '\\0' == *a[1][0][1]);\n+    assert ('\\0' == *a[1][1][0] && '\\0' == *a[1][1][1]);\n+  }\n+\n+  {\n+    const char* a[2][2][2] =\n+      { { { \"\", \"\" }, { \"\", \"\" } }, { { \"\", \"\" }, { 0, \"\" } } };\n+\n+    assert ('\\0' == *a[0][0][0] && '\\0' == *a[0][0][1]);\n+    assert ('\\0' == *a[0][1][0] && '\\0' == *a[0][1][1]);\n+    assert ('\\0' == *a[1][0][0] && '\\0' == *a[1][0][1]);\n+    assert (0 == a[1][1][0] && '\\0' == *a[1][1][1]);\n+  }\n+\n+  {\n+    const char* a[2][2][2] =\n+      { { { \"\", \"\" }, { \"\", \"\" } }, { { 0, 0 }, { 0, \"\" } } };\n+\n+    assert ('\\0' == *a[0][0][0] && '\\0' == *a[0][0][1]);\n+    assert ('\\0' == *a[0][1][0] && '\\0' == *a[0][1][1]);\n+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);\n+    assert (0 == a[1][1][0] && '\\0' == *a[1][1][1]);\n+  }\n+\n+  {\n+    const char* a[2][2][2] =\n+      { { { \"\", \"\" }, { 0, 0 } }, { { 0, 0 }, { 0, \"\" } } };\n+\n+    assert ('\\0' == *a[0][0][0] && '\\0' == *a[0][0][1]);\n+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);\n+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);\n+    assert (0 == a[1][1][0] && '\\0' == *a[1][1][1]);\n+  }\n+\n+  {\n+    const char* a[2][2][2] =\n+      { { { 0, 0 }, { 0, 0 } }, { { 0, 0 }, { 0, \"\" } } };\n+\n+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);\n+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);\n+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);\n+    assert (0 == a[1][1][0] && '\\0' == *a[1][1][1]);\n+  }\n+\n+  {\n+    const char* a[2][2][2] =\n+      { { { }, { } }, { { }, { 0, \"\" } } };\n+\n+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);\n+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);\n+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);\n+    assert (0 == a[1][1][0] && '\\0' == *a[1][1][1]);\n+  }\n+}\n+\n+void f_sa2_2_2 (void)\n+{\n+  struct S { const char a[2], *s, c; };\n+\n+  {\n+    const struct S a[2][2][2] = {\n+      { },\n+      {\n+        { { }, { \"\", \"\" } },\n+        { }\n+      }\n+    };\n+\n+    assert ('\\0' == *a[0][0][0].a && 0 == a[0][0][0].s && 0 == a[0][0][0].c);\n+    assert ('\\0' == *a[0][0][1].a && 0 == a[0][0][1].s && 0 == a[0][0][1].c);\n+    assert ('\\0' == *a[0][1][0].a && 0 == a[0][1][0].s && 0 == a[0][1][0].c);\n+    assert ('\\0' == *a[0][1][1].a && 0 == a[0][1][1].s && 0 == a[0][1][1].c);\n+\n+    assert ('\\0' == *a[1][0][0].a && 0 == a[1][0][0].s && 0 == a[1][0][0].c);\n+    assert ('\\0' == *a[1][0][1].a && '\\0' == *a[1][0][1].s && 0 == a[1][0][1].c);\n+    assert ('\\0' == *a[1][1][0].a && 0 == a[1][1][0].s && 0 == a[1][1][0].c);\n+    assert ('\\0' == *a[1][1][1].a && 0 == a[1][1][1].s && 0 == a[1][1][1].c);\n+  }\n+\n+  {\n+    const struct S a[2][2][2] = {\n+      { },\n+      {\n+        { { } },\n+        { { \"\", \"\" } }\n+      }\n+    };\n+\n+    assert ('\\0' == *a[0][0][0].a && 0 == a[0][0][0].s);\n+    assert ('\\0' == *a[0][0][1].a && 0 == a[0][0][1].s);\n+    assert ('\\0' == *a[0][1][0].a && 0 == a[0][1][0].s);\n+    assert ('\\0' == *a[0][1][1].a && 0 == a[0][1][1].s);\n+\n+    assert ('\\0' == *a[1][0][0].a && 0 == a[1][0][0].s);\n+    assert ('\\0' == *a[1][0][1].a && 0 == a[1][0][1].s);\n+    assert ('\\0' == *a[1][1][0].a && '\\0' == *a[1][1][0].s);\n+    assert ('\\0' == *a[1][1][1].a && 0 == a[1][1][1].s);\n+  }\n+\n+  {\n+    const struct S a[2][2][2] = {\n+      { },\n+      {\n+        { { }, { } },\n+        { { }, { \"\", \"\", 0 } }\n+      }\n+    };\n+\n+    assert ('\\0' == *a[0][0][0].a && 0 == a[0][0][0].s);\n+    assert ('\\0' == *a[0][0][1].a && 0 == a[0][0][1].s);\n+    assert ('\\0' == *a[0][1][0].a && 0 == a[0][1][0].s);\n+    assert ('\\0' == *a[0][1][1].a && 0 == a[0][1][1].s);\n+\n+    assert ('\\0' == *a[1][0][0].a && 0 == a[1][0][0].s);\n+    assert ('\\0' == *a[1][0][1].a && 0 == a[1][0][1].s);\n+    assert ('\\0' == *a[1][1][0].a && 0 == a[1][1][0].s);\n+    assert ('\\0' == *a[1][1][1].a && '\\0' == *a[1][1][1].s);\n+  }\n+\n+  {\n+    const struct S a[2][2][2] = {\n+      {\n+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },\n+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },\n+      },\n+      {\n+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },\n+       { { }, { \"\", \"\", 0 } }\n+      }\n+    };\n+\n+    assert ('\\0' == *a[0][0][0].a && 0 == a[0][0][0].s);\n+    assert ('\\0' == *a[0][0][1].a && 0 == a[0][0][1].s);\n+    assert ('\\0' == *a[0][1][0].a && 0 == a[0][1][0].s);\n+    assert ('\\0' == *a[0][1][1].a && 0 == a[0][1][1].s);\n+\n+    assert ('\\0' == *a[1][0][0].a && 0 == a[1][0][0].s);\n+    assert ('\\0' == *a[1][0][1].a && 0 == a[1][0][1].s);\n+    assert ('\\0' == *a[1][1][0].a && 0 == a[1][1][0].s);\n+    assert ('\\0' == *a[1][1][1].a && '\\0' == *a[1][1][1].s);\n+  }\n+}\n+\n+// { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } }"}, {"sha": "2a5322a37c37211aec671391378faaf7b4a7b0dd", "filename": "gcc/testsuite/g++.dg/abi/mangle73.C", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle73.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle73.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle73.C?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -0,0 +1,96 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A\n+{\n+  char a[2][2];\n+};\n+\n+template <A> struct B { };\n+\n+typedef B<A{ { { 0, 0 }, { 0, 0 } } }> AZZZZ;\n+typedef B<A{ { { 0, 0 }, { 0 } } }>    AZZZ_;\n+typedef B<A{ { { 0, 0 } } }>           AZZ__;\n+typedef B<A{ { { 0 } } }>              AZ___;\n+typedef B<A{ { { } } }>                A____;\n+\n+typedef B<A{ { { \"\" }, { \"\" } } }>     AS_S_;\n+typedef B<A{ { { \"\" }, { 0, 0 } } }>   AS_ZZ;\n+typedef B<A{ { { \"\" }, { 0 } } }>      AS_Z_;\n+typedef B<A{ { { \"\" } } }>             AS___;\n+\n+\n+// Verify that the types mangle the same.\n+void a_zzzz (AZZZZ) { }\n+// { dg-final { scan-assembler \"_Z6a_zzzz1BIXtl1AEEE\" } }\n+\n+void a_zzz_ (AZZZ_) { }\n+// { dg-final { scan-assembler \"_Z6a_zzz_1BIXtl1AEEE\" } }\n+\n+void a_zz__ (AZZ__) { }\n+// { dg-final { scan-assembler \"_Z6a_zz__1BIXtl1AEEE\" } }\n+\n+void a_z___ (AZ___) { }\n+// { dg-final { scan-assembler \"_Z6a_z___1BIXtl1AEEE\" } }\n+\n+void a_____ (A____) { }\n+// { dg-final { scan-assembler \"_Z6a_____1BIXtl1AEEE\" } }\n+\n+void a_s_s_ (AS_S_) { }\n+// { dg-final { scan-assembler \"_Z6a_s_s_1BIXtl1AEEE\" } }\n+\n+void a_s_zz (AS_ZZ) { }\n+// { dg-final { scan-assembler \"_Z6a_s_zz1BIXtl1AEEE\" } }\n+\n+void a_s_z_ (AS_Z_) { }\n+// { dg-final { scan-assembler \"_Z6a_s_z_1BIXtl1AEEE\" } }\n+\n+void a_s___ (AS___) { }\n+// { dg-final { scan-assembler \"_Z6a_s___1BIXtl1AEEE\" } }\n+\n+\n+struct C\n+{\n+  struct { const char a[2][2], *p; } a[2];\n+};\n+\n+template <C> struct D { };\n+\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}, 0 }}}> DZZZZZZZZZZ;\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}}}}> DZZZZZZZZZ_;\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0 }}}}}>    DZZZZZZZZ__;\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 } }}}}>          DZZZZZZZ___;\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0 } }}}}>             DZZZZZZ____;\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }}}>                         DZZZZZ_____;\n+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}}}}>                             DZZZZ______;\n+typedef D<C{{{{{ 0, 0 }, { 0 }}}}}>                                DZZZ_______;\n+typedef D<C{{{{{ 0, 0 }}}}}>                                       DZZ________;\n+typedef D<C{{{{{ 0 }}}}}>                                          DZ_________;\n+typedef D<C{ }>                                                    D__________;\n+\n+typedef D<C{{{{{ \"\" }, { \"\" }}, 0 }, {{{ \"\" }, { \"\" }}, 0 }}}>     DS_S_ZS_S_Z;\n+\n+void d_zzzzzzzzzz (DZZZZZZZZZZ) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzzzzzzzz1DIXtl1CEEE\" } }\n+void d_zzzzzzzzz_ (DZZZZZZZZZ_) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzzzzzzz_1DIXtl1CEEE\" } }\n+void d_zzzzzzzz__ (DZZZZZZZZ__) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzzzzzz__1DIXtl1CEEE\" } }\n+void d_zzzzzzz___ (DZZZZZZZ___) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzzzzz___1DIXtl1CEEE\" } }\n+void d_zzzzzz____ (DZZZZZZ____) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzzzz____1DIXtl1CEEE\" } }\n+void d_zzzzz_____ (DZZZZZ_____) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzzz_____1DIXtl1CEEE\" } }\n+void d_zzzz______ (DZZZZ______) { }\n+// { dg-final { scan-assembler \"_Z12d_zzzz______1DIXtl1CEEE\" } }\n+void d_zzz_______ (DZZZ_______) { }\n+// { dg-final { scan-assembler \"_Z12d_zzz_______1DIXtl1CEEE\" } }\n+void d_zz________ (DZZ________) { }\n+// { dg-final { scan-assembler \"_Z12d_zz________1DIXtl1CEEE\" } }\n+void d_z_________ (DZ_________) { }\n+// { dg-final { scan-assembler \"_Z12d_z_________1DIXtl1CEEE\" } }\n+void d___________ (D__________) { }\n+// { dg-final { scan-assembler \"_Z12d___________1DIXtl1CEEE\" } }\n+\n+void d_s_s_zs_s_z (DS_S_ZS_S_Z) { }\n+// { dg-final { scan-assembler \"_Z12d_s_s_zs_s_z1DIXtl1CEEE\" } }"}, {"sha": "ab9e80fd335d97fdd4bc7eeb2cbf1e76dc2f13a0", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class23.C", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class23.C?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -0,0 +1,102 @@\n+// PR c++/90947 - Simple lookup table of array of strings is miscompiled\n+// Test to verify that the same specializations on non-type template\n+// parameters of class types are in fact treated as the same.  Unlike\n+// nontype-class15.C which involves only one-dimensional arrays this\n+// test involves arrays of arrays and arrays of structs.\n+// { dg-do compile { target c++2a } }\n+\n+struct AA3\n+{\n+  const char a[2][2][2];\n+};\n+\n+template <AA3> struct BAA3 { };\n+\n+// Redeclare the same variable using different initialization forms\n+// of the same constant to verify that they are in fact all recognized\n+// as the same.\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", \"\" }}}>       baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", { 0, 0 } }}}> baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", { 0 } }}}>    baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", {} }}}>       baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\" }}}>           baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { { 0, 0 } }}}>     baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { { 0 } }}}>        baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { {} }}}>           baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }, { }}}>              baa3;\n+extern BAA3<AA3{{{ \"\", \"\" }}}>                   baa3;\n+extern BAA3<AA3{{{ \"\", { 0, 0 } }}}>             baa3;\n+extern BAA3<AA3{{{ \"\", { 0 } }}}>                baa3;\n+extern BAA3<AA3{{{ \"\", {} }}}>                   baa3;\n+extern BAA3<AA3{{{ \"\" }}}>                       baa3;\n+extern BAA3<AA3{{{ { 0, 0 } }}}>                 baa3;\n+extern BAA3<AA3{{{ { 0 } }}}>                    baa3;\n+extern BAA3<AA3{{{ {} }}}>                       baa3;\n+extern BAA3<AA3{{{ }}}>                          baa3;\n+extern BAA3<AA3{{ }}>                            baa3;\n+extern BAA3<AA3{ }>                              baa3;\n+\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", \"1\" }}}>        baa3_1;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", { '1', 0 } }}}> baa3_1;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"\", { '1' } }}}>    baa3_1;\n+\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"1\", {} }}}>        baa3_2;\n+extern BAA3<AA3{{{ \"\", \"\" }, { \"1\" }}}>            baa3_2;\n+extern BAA3<AA3{{{ \"\", \"\" }, { { '1', 0 } }}}>     baa3_2;\n+extern BAA3<AA3{{{ \"\", \"\" }, { { '1' } }}}>        baa3_2;\n+\n+extern BAA3<AA3{{{ \"\", \"1\" }}}>                    baa3_3;\n+extern BAA3<AA3{{{ \"\", { '1', 0 } }}}>             baa3_3;\n+extern BAA3<AA3{{{ \"\", { '1' } }}}>                baa3_3;\n+\n+extern BAA3<AA3{{{ \"1\" }}}>                        baa3_4;\n+extern BAA3<AA3{{{ { '1', 0 } }}}>                 baa3_4;\n+extern BAA3<AA3{{{ { '1' } }}}>                    baa3_4;\n+\n+struct AS2\n+{\n+  struct S { const char a[2], *p; } a[2];\n+};\n+\n+template <AS2> struct BAS2 { };\n+\n+extern BAS2<AS2{{{ \"\", 0 }, { \"\", 0 }}}> bas2;\n+extern BAS2<AS2{{{ \"\", 0 }, { {}, 0 }}}> bas2;\n+extern BAS2<AS2{{{ \"\", 0 }, { \"\" }}}>    bas2;\n+extern BAS2<AS2{{{ \"\", 0 }, { {} }}}>    bas2;\n+extern BAS2<AS2{{{ \"\", 0 }, { }}}>       bas2;\n+extern BAS2<AS2{{{ \"\", 0 }}}>            bas2;\n+extern BAS2<AS2{{{ {}, 0 }}}>            bas2;\n+extern BAS2<AS2{{{ \"\" }}}>               bas2;\n+extern BAS2<AS2{{{ {} }}}>               bas2;\n+extern BAS2<AS2{{{ }}}>                  bas2;\n+extern BAS2<AS2{{ }}>                    bas2;\n+extern BAS2<AS2{ }>                      bas2;\n+\n+struct AS2_2\n+{\n+  struct S { const char a[2], *p; } a[2][2];\n+};\n+\n+template <AS2_2> struct BAS2_2 { };\n+\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { \"\", 0 }, { \"\", 0 }}}}> b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { \"\", 0 }, { \"\" }}}}>    b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { \"\", 0 }, { {} }}}}>    b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { \"\", 0 }, { }}}}>       b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { \"\", 0 } }}}>           b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { \"\" } }}}>              b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { {} } }}}>              b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { { }}}}>                  b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 } }, { }}}>                     b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\", 0 }}}}>                           b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { \"\" }}}}>                              b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { {} }}}}>                              b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }, { }}}}>                                 b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\", 0 }}}}>                                      b2_2;\n+extern BAS2_2<AS2_2{{{{ \"\" }}}}>                                         b2_2;\n+extern BAS2_2<AS2_2{{{{ {} }}}}>                                         b2_2;\n+extern BAS2_2<AS2_2{{{{ }}}}>                                            b2_2;\n+extern BAS2_2<AS2_2{{{ }}}>                                              b2_2;\n+extern BAS2_2<AS2_2{{ }}>                                                b2_2;\n+extern BAS2_2<AS2_2{ }>                                                  b2_2;"}, {"sha": "2bf480561fe02665d2451c7b8c31db2cc8558afa", "filename": "gcc/testsuite/g++.dg/init/array53.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray53.C?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/90947 - Simple lookup table of array of strings is miscompiled\n+// Verify that initializers for arrays of elements of a class type with\n+// \"unusual\" data members are correctly recognized as non-zero.\n+// { dg-do compile }\n+// { dg-options \"-O1 -fdump-tree-optimized\" }\n+\n+struct S\n+{\n+  const char *p;\n+  static int i;\n+  enum { e };\n+  typedef int X;\n+  int: 1, b:1;\n+  union {\n+    int c;\n+  };\n+  const char *q;\n+};\n+\n+void f (void)\n+{\n+  const struct S a[2] =\n+    {\n+     { /* .p = */ \"\", /* .b = */ 0, /* .c = */ 0, /* .q = */ \"\" },\n+     { /* .p = */ \"\", /* .b = */ 0, /* .c = */ 0, /* .q = */ \"\" }\n+    };\n+\n+  if (!a[0].p || *a[0].p || !a[0].q || *a[0].q\n+      || !a[1].p || *a[1].p || !a[1].q || *a[1].q)\n+    __builtin_abort ();\n+}\n+\n+// { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } }"}, {"sha": "efa49e99d659a23ffc55fb31c67a793003e0bdde", "filename": "gcc/tree.c", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -11376,6 +11376,73 @@ initializer_each_zero_or_onep (const_tree expr)\n     }\n }\n \n+/* Given an initializer INIT for a TYPE, return true if INIT is zero\n+   so that it can be replaced by value initialization.  This function\n+   distinguishes betwen empty strings as initializers for arrays and\n+   for pointers (which make it return false).  */\n+\n+bool\n+type_initializer_zero_p (tree type, tree init)\n+{\n+  if (type  == error_mark_node || init == error_mark_node)\n+    return false;\n+\n+  STRIP_NOPS (init);\n+\n+  if (POINTER_TYPE_P (type))\n+    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);\n+\n+  if (TREE_CODE (init) != CONSTRUCTOR)\n+    return initializer_zerop (init);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      tree elt_type = TREE_TYPE (type);\n+      elt_type = TYPE_MAIN_VARIANT (elt_type);\n+      if (elt_type == char_type_node)\n+\treturn initializer_zerop (init);\n+\n+      tree elt_init;\n+      unsigned HOST_WIDE_INT i;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)\n+\tif (!type_initializer_zero_p (elt_type, elt_init))\n+\t  return false;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return initializer_zerop (init);\n+\n+  tree fld = TYPE_FIELDS (type);\n+\n+  tree fld_init;\n+  unsigned HOST_WIDE_INT i;\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)\n+    {\n+      /* Advance to the next member, skipping over everything that\n+\t canot be initialized (including unnamed bit-fields).  */\n+      while (TREE_CODE (fld) != FIELD_DECL\n+\t     || DECL_ARTIFICIAL (fld)\n+\t     || (DECL_BIT_FIELD (fld) && !DECL_NAME (fld)))\n+\t{\n+\t  fld = DECL_CHAIN (fld);\n+\t  if (!fld)\n+\t    return true;\n+\t  continue;\n+\t}\n+\n+      tree fldtype = TREE_TYPE (fld);\n+      if (!type_initializer_zero_p (fldtype, fld_init))\n+\treturn false;\n+\n+      fld = DECL_CHAIN (fld);\n+      if (!fld)\n+\tbreak;\n+    }\n+\n+  return true;\n+}\n+\n /* Check if vector VEC consists of all the equal elements and\n    that the number of elements corresponds to the type of VEC.\n    The function returns first element of the vector"}, {"sha": "d5fb3b2bd59aa89ba75ba9b82e365b9b23230520", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74f15a88ee1a2b96784803f0e38c386796ee704/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b74f15a88ee1a2b96784803f0e38c386796ee704", "patch": "@@ -4623,6 +4623,12 @@ extern tree first_field (const_tree);\n extern bool initializer_zerop (const_tree, bool * = NULL);\n extern bool initializer_each_zero_or_onep (const_tree);\n \n+/* Analogous to initializer_zerop but also examines the type for\n+   which the initializer is being used.  Unlike initializer_zerop,\n+   considers empty strings to be zero initializers for arrays and\n+   non-zero for pointers.  */\n+extern bool type_initializer_zero_p (tree, tree);\n+\n extern wide_int vector_cst_int_elt (const_tree, unsigned int);\n extern tree vector_cst_elt (const_tree, unsigned int);\n "}]}