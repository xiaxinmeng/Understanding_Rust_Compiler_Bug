{"sha": "9e931c2a2819523ce7847b622eaf8ae5f740744e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5MzFjMmEyODE5NTIzY2U3ODQ3YjYyMmVhZjhhZTVmNzQwNzQ0ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-08-23T21:09:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-08-23T21:09:03Z"}, "message": "cp-tree.h (lookup_field_1, [...]): Move declatations to ...\n\n\t* cp-tree.h (lookup_field_1, lookup_fnfields_slot,\n\tlookup_fnfields_slot_nolazy, lookup_all_conversions): Move\n\tdeclatations to ...\n\t* name-lookup.h (lookup_field_1, lookup_fnfields_slot,\n\tlookup_fnfields_slot_nolazy, lookup_all_conversions): ... here.\n\t* search.c (lookup_conversion_operator,\n\tlookup_fnfields_slot_nolazy, lookup_field_1, lookup_fnfields_slot,\n\tlookup_all_conversions): Move to ...\n\t* name-lookup.c (lookup_conversion_operator,\n\tlookup_fnfields_slot_nolazy, lookup_field_1, lookup_fnfields_slot,\n\tlookup_all_conversions): ... here.\n\nFrom-SVN: r251319", "tree": {"sha": "89f161d64525e43337bc7415374d67c0898b8dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89f161d64525e43337bc7415374d67c0898b8dd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e931c2a2819523ce7847b622eaf8ae5f740744e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e931c2a2819523ce7847b622eaf8ae5f740744e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e931c2a2819523ce7847b622eaf8ae5f740744e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e931c2a2819523ce7847b622eaf8ae5f740744e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3928bd5fc16719d56d6f99514148d4b05fcb9cc0"}], "stats": {"total": 526, "additions": 269, "deletions": 257}, "files": [{"sha": "5d2a3c6ebf6668ce81012bad6ae45fcf1b98cade", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e931c2a2819523ce7847b622eaf8ae5f740744e", "patch": "@@ -1,5 +1,17 @@\n 2017-08-23  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (lookup_field_1, lookup_fnfields_slot,\n+\tlookup_fnfields_slot_nolazy, lookup_all_conversions): Move\n+\tdeclatations to ...\n+\t* name-lookup.h (lookup_field_1, lookup_fnfields_slot,\n+\tlookup_fnfields_slot_nolazy, lookup_all_conversions): ... here.\n+\t* search.c (lookup_conversion_operator,\n+\tlookup_fnfields_slot_nolazy, lookup_field_1, lookup_fnfields_slot,\n+\tlookup_all_conversions): Move to ...\n+\t* name-lookup.c (lookup_conversion_operator,\n+\tlookup_fnfields_slot_nolazy, lookup_field_1, lookup_fnfields_slot,\n+\tlookup_all_conversions): ... here.\n+\n \t* semantics.c (finish_member_declaration): Move USING_DECL check\n \tearlier.  Always set C++ linkage.  Commonize TYPE_FIELD and\n \ttemplate decl list insertion."}, {"sha": "b915bd9603fb92ac94ba9c82ef465c56a5d85ceb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9e931c2a2819523ce7847b622eaf8ae5f740744e", "patch": "@@ -6563,11 +6563,7 @@ extern tree lookup_base                         (tree, tree, base_access,\n extern tree dcast_base_hint\t\t\t(tree, tree);\n extern int accessible_p\t\t\t\t(tree, tree, bool);\n extern int accessible_in_template_p\t\t(tree, tree);\n-extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n-extern tree lookup_fnfields_slot\t\t(tree, tree);\n-extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n-extern tree lookup_all_conversions\t\t(tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool,\n \t\t\t\t\t\t tsubst_flags_t,"}, {"sha": "12c507ec12412628d0d5b725eaad90387ab3c023", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 253, "deletions": 1, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9e931c2a2819523ce7847b622eaf8ae5f740744e", "patch": "@@ -1089,6 +1089,258 @@ lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args)\n   return fns;\n }\n \n+/* Return the conversion operators in CLASS_TYPE corresponding to\n+   \"operator TYPE ()\".  Only CLASS_TYPE itself is searched; this\n+   routine does not scan the base classes of CLASS_TYPE.  */\n+\n+static tree\n+lookup_conversion_operator (tree class_type, tree type)\n+{\n+  tree tpls = NULL_TREE;\n+\n+  if (TYPE_HAS_CONVERSION (class_type))\n+    {\n+      tree fns;\n+      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_type);\n+\n+      for (int i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t   vec_safe_iterate (methods, i, &fns); ++i)\n+\t{\n+\t  /* All the conversion operators come near the beginning of\n+\t     the class.  Therefore, if FN is not a conversion\n+\t     operator, there is no matching conversion operator in\n+\t     CLASS_TYPE.  */\n+\t  tree fn = OVL_FIRST (fns);\n+\t  if (!DECL_CONV_FN_P (fn))\n+\t    break;\n+\n+\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t    /* All the templated conversion functions are on the same\n+\t       slot, so remember it.  */\n+\t    tpls = fns;\n+\t  else if (same_type_p (DECL_CONV_FN_TYPE (fn), type))\n+\t    return fns;\n+\t}\n+    }\n+\n+  return tpls;\n+}\n+\n+/* TYPE is a class type. Return the member functions in the method\n+   vector with name NAME.  Does not lazily declare implicitly-declared\n+   member functions.  */\n+\n+tree\n+lookup_fnfields_slot_nolazy (tree type, tree name)\n+{\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n+  if (!method_vec)\n+    return NULL_TREE;\n+\n+  if (IDENTIFIER_CONV_OP_P (name))\n+    return lookup_conversion_operator (type, TREE_TYPE (name));\n+\n+  /* Skip the conversion operators.  */\n+  int i;\n+  tree fns;\n+  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+       vec_safe_iterate (method_vec, i, &fns);\n+       ++i)\n+    if (!DECL_CONV_FN_P (OVL_FIRST (fns)))\n+      break;\n+\n+  /* If the type is complete, use binary search.  */\n+  if (COMPLETE_TYPE_P (type))\n+    {\n+      int lo;\n+      int hi;\n+\n+      lo = i;\n+      hi = method_vec->length ();\n+      while (lo < hi)\n+\t{\n+\t  i = (lo + hi) / 2;\n+\n+\t  fns = (*method_vec)[i];\n+\t  tree fn_name = OVL_NAME (fns);\n+\t  if (fn_name > name)\n+\t    hi = i;\n+\t  else if (fn_name < name)\n+\t    lo = i + 1;\n+\t  else\n+\t    return fns;\n+\t}\n+    }\n+  else\n+    for (; vec_safe_iterate (method_vec, i, &fns); ++i)\n+      {\n+\tif (OVL_NAME (fns) == name)\n+\t  return fns;\n+      }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Do a 1-level search for NAME as a member of TYPE.  The caller must\n+   figure out whether it can access this field.  (Since it is only one\n+   level, this is reasonable.)  */\n+\n+tree\n+lookup_field_1 (tree type, tree name, bool want_type)\n+{\n+  tree field;\n+\n+  gcc_assert (identifier_p (name) && RECORD_OR_UNION_TYPE_P (type));\n+\n+  if (CLASSTYPE_SORTED_FIELDS (type))\n+    {\n+      tree *fields = &CLASSTYPE_SORTED_FIELDS (type)->elts[0];\n+      int lo = 0, hi = CLASSTYPE_SORTED_FIELDS (type)->len;\n+      int i;\n+\n+      while (lo < hi)\n+\t{\n+\t  i = (lo + hi) / 2;\n+\n+\t  if (DECL_NAME (fields[i]) > name)\n+\t    hi = i;\n+\t  else if (DECL_NAME (fields[i]) < name)\n+\t    lo = i + 1;\n+\t  else\n+\t    {\n+\t      field = NULL_TREE;\n+\n+\t      /* We might have a nested class and a field with the\n+\t\t same name; we sorted them appropriately via\n+\t\t field_decl_cmp, so just look for the first or last\n+\t\t field with this name.  */\n+\t      if (want_type)\n+\t\t{\n+\t\t  do\n+\t\t    field = fields[i--];\n+\t\t  while (i >= lo && DECL_NAME (fields[i]) == name);\n+\t\t  if (!DECL_DECLARES_TYPE_P (field))\n+\t\t    field = NULL_TREE;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  do\n+\t\t    field = fields[i++];\n+\t\t  while (i < hi && DECL_NAME (fields[i]) == name);\n+\t\t}\n+\n+\t      if (field)\n+\t      \t{\n+\t      \t  field = strip_using_decl (field);\n+\t      \t  if (is_overloaded_fn (field))\n+\t      \t    field = NULL_TREE;\n+\t      \t}\n+\n+\t      return field;\n+\t    }\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  field = TYPE_FIELDS (type);\n+\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      tree decl = field;\n+\n+      if (DECL_DECLARES_FUNCTION_P (decl))\n+\t/* Functions are kep separately, at the moment.  */\n+\tcontinue;\n+\n+      gcc_assert (DECL_P (field));\n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+\t{\n+\t  tree temp = lookup_field_1 (TREE_TYPE (field), name, want_type);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n+\n+      if (TREE_CODE (decl) == USING_DECL\n+\t  && DECL_NAME (decl) == name)\n+\t{\n+\t  decl = strip_using_decl (decl);\n+\t  if (is_overloaded_fn (decl))\n+\t    continue;\n+\t}\n+\n+      if (DECL_NAME (decl) == name\n+\t  && (!want_type || DECL_DECLARES_TYPE_P (decl)))\n+\treturn decl;\n+    }\n+\n+  /* We used to special-case vptr_identifier.  Make sure it's not\n+     special any more.  */\n+  gcc_assert (name != vptr_identifier || !TYPE_VFIELD (type));\n+\n+  return NULL_TREE;\n+}\n+\n+/* TYPE is a class type. Return the overloads in\n+   the method vector with name NAME.  Lazily create ctors etc.  */\n+\n+tree\n+lookup_fnfields_slot (tree type, tree name)\n+{\n+  type = complete_type (type);\n+\n+  if (COMPLETE_TYPE_P (type))\n+    {\n+      if (IDENTIFIER_CTOR_P (name))\n+\t{\n+\t  if (CLASSTYPE_LAZY_DEFAULT_CTOR (type))\n+\t    lazily_declare_fn (sfk_constructor, type);\n+\t  if (CLASSTYPE_LAZY_COPY_CTOR (type))\n+\t    lazily_declare_fn (sfk_copy_constructor, type);\n+\t  if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n+\t    lazily_declare_fn (sfk_move_constructor, type);\n+\t}\n+      else if (name == cp_assignment_operator_id (NOP_EXPR))\n+\t{\n+\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (type))\n+\t    lazily_declare_fn (sfk_copy_assignment, type);\n+\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (type))\n+\t    lazily_declare_fn (sfk_move_assignment, type);\n+\t}\n+      else if (IDENTIFIER_DTOR_P (name))\n+\t{\n+\t  if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n+\t    lazily_declare_fn (sfk_destructor, type);\n+\t}\n+    }\n+\n+  return lookup_fnfields_slot_nolazy (type, name);\n+}\n+\n+/* Collect all the conversion operators of KLASS.  */\n+\n+tree\n+lookup_all_conversions (tree klass)\n+{\n+  tree lkp = NULL_TREE;\n+\n+  if (vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (klass))\n+    {\n+      tree ovl;\n+      for (int idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t   methods->iterate (idx, &ovl); ++idx)\n+\t{\n+\t  if (!DECL_CONV_FN_P (OVL_FIRST (ovl)))\n+\t    /* There are no more conversion functions.  */\n+\t    break;\n+\n+\t  lkp = lookup_add (ovl, lkp);\n+\t}\n+    }\n+\n+  return lkp;\n+}\n+\n /* Compute the chain index of a binding_entry given the HASH value of its\n    name and the total COUNT of chains.  COUNT is assumed to be a power\n    of 2.  */\n@@ -3319,7 +3571,7 @@ do_pushdecl_with_scope (tree x, cp_binding_level *level, bool is_friend)\n   current_function_decl = function_decl;\n   return x;\n }\n- \n+\n /* Inject X into the local scope just before the function parms.  */\n \n tree"}, {"sha": "1f671479fecc2e490f165b66e714a6c9acd626a1", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=9e931c2a2819523ce7847b622eaf8ae5f740744e", "patch": "@@ -319,6 +319,10 @@ extern void pop_decl_namespace (void);\n extern void do_namespace_alias (tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n+extern tree lookup_field_1\t\t\t(tree, tree, bool);\n+extern tree lookup_fnfields_slot\t\t(tree, tree);\n+extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n+extern tree lookup_all_conversions\t\t(tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n extern void cp_emit_debug_info_for_using (tree, tree);"}, {"sha": "9e15b02cae6c9ccd7f478899fe68cfa879adaae1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e931c2a2819523ce7847b622eaf8ae5f740744e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9e931c2a2819523ce7847b622eaf8ae5f740744e", "patch": "@@ -353,106 +353,6 @@ dcast_base_hint (tree subtype, tree target)\n    Otherwise, return a DECL with the indicated name.  If WANT_TYPE is\n    true, type declarations are preferred.  */\n \n-/* Do a 1-level search for NAME as a member of TYPE.  The caller must\n-   figure out whether it can access this field.  (Since it is only one\n-   level, this is reasonable.)  */\n-\n-tree\n-lookup_field_1 (tree type, tree name, bool want_type)\n-{\n-  tree field;\n-\n-  gcc_assert (identifier_p (name) && RECORD_OR_UNION_TYPE_P (type));\n-\n-  if (CLASSTYPE_SORTED_FIELDS (type))\n-    {\n-      tree *fields = &CLASSTYPE_SORTED_FIELDS (type)->elts[0];\n-      int lo = 0, hi = CLASSTYPE_SORTED_FIELDS (type)->len;\n-      int i;\n-\n-      while (lo < hi)\n-\t{\n-\t  i = (lo + hi) / 2;\n-\n-\t  if (DECL_NAME (fields[i]) > name)\n-\t    hi = i;\n-\t  else if (DECL_NAME (fields[i]) < name)\n-\t    lo = i + 1;\n-\t  else\n-\t    {\n-\t      field = NULL_TREE;\n-\n-\t      /* We might have a nested class and a field with the\n-\t\t same name; we sorted them appropriately via\n-\t\t field_decl_cmp, so just look for the first or last\n-\t\t field with this name.  */\n-\t      if (want_type)\n-\t\t{\n-\t\t  do\n-\t\t    field = fields[i--];\n-\t\t  while (i >= lo && DECL_NAME (fields[i]) == name);\n-\t\t  if (!DECL_DECLARES_TYPE_P (field))\n-\t\t    field = NULL_TREE;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  do\n-\t\t    field = fields[i++];\n-\t\t  while (i < hi && DECL_NAME (fields[i]) == name);\n-\t\t}\n-\n-\t      if (field)\n-\t      \t{\n-\t      \t  field = strip_using_decl (field);\n-\t      \t  if (is_overloaded_fn (field))\n-\t      \t    field = NULL_TREE;\n-\t      \t}\n-\n-\t      return field;\n-\t    }\n-\t}\n-      return NULL_TREE;\n-    }\n-\n-  field = TYPE_FIELDS (type);\n-\n-  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-    {\n-      tree decl = field;\n-\n-      if (DECL_DECLARES_FUNCTION_P (decl))\n-\t/* Functions are kep separately, at the moment.  */\n-\tcontinue;\n-\n-      gcc_assert (DECL_P (field));\n-      if (DECL_NAME (field) == NULL_TREE\n-\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\t{\n-\t  tree temp = lookup_field_1 (TREE_TYPE (field), name, want_type);\n-\t  if (temp)\n-\t    return temp;\n-\t}\n-\n-      if (TREE_CODE (decl) == USING_DECL\n-\t  && DECL_NAME (decl) == name)\n-\t{\n-\t  decl = strip_using_decl (decl);\n-\t  if (is_overloaded_fn (decl))\n-\t    continue;\n-\t}\n-\n-      if (DECL_NAME (decl) == name\n-\t  && (!want_type || DECL_DECLARES_TYPE_P (decl)))\n-\treturn decl;\n-    }\n-\n-  /* We used to special-case vptr_identifier.  Make sure it's not\n-     special any more.  */\n-  gcc_assert (name != vptr_identifier || !TYPE_VFIELD (type));\n-\n-  return NULL_TREE;\n-}\n-\n /* Return the FUNCTION_DECL, RECORD_TYPE, UNION_TYPE, or\n    NAMESPACE_DECL corresponding to the innermost non-block scope.  */\n \n@@ -1454,158 +1354,6 @@ lookup_fnfields (tree xbasetype, tree name, int protect)\n   return rval;\n }\n \n-/* Return the conversion operators in CLASS_TYPE corresponding to\n-   \"operator TYPE ()\".  Only CLASS_TYPE itself is searched; this\n-   routine does not scan the base classes of CLASS_TYPE.  */\n-\n-static tree\n-lookup_conversion_operator (tree class_type, tree type)\n-{\n-  tree tpls = NULL_TREE;\n-\n-  if (TYPE_HAS_CONVERSION (class_type))\n-    {\n-      tree fns;\n-      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_type);\n-\n-      for (int i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   vec_safe_iterate (methods, i, &fns); ++i)\n-\t{\n-\t  /* All the conversion operators come near the beginning of\n-\t     the class.  Therefore, if FN is not a conversion\n-\t     operator, there is no matching conversion operator in\n-\t     CLASS_TYPE.  */\n-\t  tree fn = OVL_FIRST (fns);\n-\t  if (!DECL_CONV_FN_P (fn))\n-\t    break;\n-\n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    /* All the templated conversion functions are on the same\n-\t       slot, so remember it.  */\n-\t    tpls = fns;\n-\t  else if (same_type_p (DECL_CONV_FN_TYPE (fn), type))\n-\t    return fns;\n-\t}\n-    }\n-\n-  return tpls;\n-}\n-\n-/* TYPE is a class type. Return the member functions in the method\n-   vector with name NAME.  Does not lazily declare implicitly-declared\n-   member functions.  */\n-\n-tree\n-lookup_fnfields_slot_nolazy (tree type, tree name)\n-{\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n-  if (!method_vec)\n-    return NULL_TREE;\n-\n-  if (IDENTIFIER_CONV_OP_P (name))\n-    return lookup_conversion_operator (type, TREE_TYPE (name));\n-\n-  /* Skip the conversion operators.  */\n-  int i;\n-  tree fns;\n-  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       vec_safe_iterate (method_vec, i, &fns);\n-       ++i)\n-    if (!DECL_CONV_FN_P (OVL_FIRST (fns)))\n-      break;\n-\n-  /* If the type is complete, use binary search.  */\n-  if (COMPLETE_TYPE_P (type))\n-    {\n-      int lo;\n-      int hi;\n-\n-      lo = i;\n-      hi = method_vec->length ();\n-      while (lo < hi)\n-\t{\n-\t  i = (lo + hi) / 2;\n-\n-\t  fns = (*method_vec)[i];\n-\t  tree fn_name = OVL_NAME (fns);\n-\t  if (fn_name > name)\n-\t    hi = i;\n-\t  else if (fn_name < name)\n-\t    lo = i + 1;\n-\t  else\n-\t    return fns;\n-\t}\n-    }\n-  else\n-    for (; vec_safe_iterate (method_vec, i, &fns); ++i)\n-      {\n-\tif (OVL_NAME (fns) == name)\n-\t  return fns;\n-      }\n-\n-  return NULL_TREE;\n-}\n-\n-/* TYPE is a class type. Return the overloads in\n-   the method vector with name NAME.  Lazily create ctors etc.  */\n-\n-tree\n-lookup_fnfields_slot (tree type, tree name)\n-{\n-  type = complete_type (type);\n-\n-  if (COMPLETE_TYPE_P (type))\n-    {\n-      if (IDENTIFIER_CTOR_P (name))\n-\t{\n-\t  if (CLASSTYPE_LAZY_DEFAULT_CTOR (type))\n-\t    lazily_declare_fn (sfk_constructor, type);\n-\t  if (CLASSTYPE_LAZY_COPY_CTOR (type))\n-\t    lazily_declare_fn (sfk_copy_constructor, type);\n-\t  if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n-\t    lazily_declare_fn (sfk_move_constructor, type);\n-\t}\n-      else if (name == cp_assignment_operator_id (NOP_EXPR))\n-\t{\n-\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (type))\n-\t    lazily_declare_fn (sfk_copy_assignment, type);\n-\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (type))\n-\t    lazily_declare_fn (sfk_move_assignment, type);\n-\t}\n-      else if (IDENTIFIER_DTOR_P (name))\n-\t{\n-\t  if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n-\t    lazily_declare_fn (sfk_destructor, type);\n-\t}\n-    }\n-\n-  return lookup_fnfields_slot_nolazy (type, name);\n-}\n-\n-/* Collect all the conversion operators of KLASS.  */\n-\n-tree\n-lookup_all_conversions (tree klass)\n-{\n-  tree lkp = NULL_TREE;\n-\n-  if (vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (klass))\n-    {\n-      tree ovl;\n-      for (int idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   methods->iterate (idx, &ovl); ++idx)\n-\t{\n-\t  if (!DECL_CONV_FN_P (OVL_FIRST (ovl)))\n-\t    /* There are no more conversion functions.  */\n-\t    break;\n-\n-\t  lkp = lookup_add (ovl, lkp);\n-\t}\n-    }\n-\n-  return lkp;\n-}\n-\n /* DECL is the result of a qualified name lookup.  QUALIFYING_SCOPE is\n    the class or namespace used to qualify the name.  CONTEXT_CLASS is\n    the class corresponding to the object in which DECL will be used."}]}