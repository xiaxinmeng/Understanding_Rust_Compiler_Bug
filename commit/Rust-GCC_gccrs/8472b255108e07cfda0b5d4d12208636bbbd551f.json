{"sha": "8472b255108e07cfda0b5d4d12208636bbbd551f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ3MmIyNTUxMDhlMDdjZmRhMGI1ZDRkMTIyMDg2MzZiYmJkNTUxZg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-09-08T14:52:02Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-09-08T14:52:02Z"}, "message": "bfin.c (np_check_regno, [...]): New static variables.\n\n\t* config/bfin/bfin.c (np_check_regno, np_after_branch): New static\n\tvariables.\n\t(note_np_check_stores): New function.\n\t(harmless_null_pointer_p): New function.\n\t(trapping_loads_p): New args NP_REG and AFTER_NP_BRANCH.  Callers\n\tchanged.  Take into account whether we're in the shadow of a condjump\n\tthat tested NP_REG for NULL.\n\tLose all code that tested for SEQUENCEs.\n\t(workaround_speculation): Avoid inserting NOPs for loads that are\n\teither always executed or a NULL pointer.\n\nFrom-SVN: r151513", "tree": {"sha": "4d0132035833db1fad0d5ed4831939855a26f228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d0132035833db1fad0d5ed4831939855a26f228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8472b255108e07cfda0b5d4d12208636bbbd551f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8472b255108e07cfda0b5d4d12208636bbbd551f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8472b255108e07cfda0b5d4d12208636bbbd551f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8472b255108e07cfda0b5d4d12208636bbbd551f/comments", "author": null, "committer": null, "parents": [{"sha": "ac875c2ec22e23ad511d48988c4f015d4109348e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac875c2ec22e23ad511d48988c4f015d4109348e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac875c2ec22e23ad511d48988c4f015d4109348e"}], "stats": {"total": 138, "additions": 116, "deletions": 22}, "files": [{"sha": "5c12d75d7b9e647ab97070f654a0561b9e668c8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8472b255108e07cfda0b5d4d12208636bbbd551f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8472b255108e07cfda0b5d4d12208636bbbd551f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8472b255108e07cfda0b5d4d12208636bbbd551f", "patch": "@@ -1,3 +1,16 @@\n+2009-09-08  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (np_check_regno, np_after_branch): New static\n+\tvariables.\n+\t(note_np_check_stores): New function.\n+\t(harmless_null_pointer_p): New function.\n+\t(trapping_loads_p): New args NP_REG and AFTER_NP_BRANCH.  Callers\n+\tchanged.  Take into account whether we're in the shadow of a condjump\n+\tthat tested NP_REG for NULL.\n+\tLose all code that tested for SEQUENCEs.\n+\t(workaround_speculation): Avoid inserting NOPs for loads that are\n+\teither always executed or a NULL pointer.\n+\n 2009-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* doc/invoke.texi (early-inlining-insns): Reduce from 12 to 8."}, {"sha": "28406150eeaae2e55fee64b6509b39de821832d7", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 103, "deletions": 22, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8472b255108e07cfda0b5d4d12208636bbbd551f/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8472b255108e07cfda0b5d4d12208636bbbd551f/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=8472b255108e07cfda0b5d4d12208636bbbd551f", "patch": "@@ -5039,28 +5039,38 @@ type_for_anomaly (rtx insn)\n     return get_attr_type (insn);\n }\n \n-/* Return nonzero if INSN contains any loads that may trap.  It handles\n-   SEQUENCEs correctly.  */\n-\n+/* Return true iff the address found in MEM is based on the register\n+   NP_REG and optionally has a positive offset.  */\n static bool\n-trapping_loads_p (rtx insn)\n+harmless_null_pointer_p (rtx mem, int np_reg)\n {\n-  rtx pat = PATTERN (insn);\n-  if (GET_CODE (pat) == SEQUENCE)\n+  mem = XEXP (mem, 0);\n+  if (GET_CODE (mem) == POST_INC || GET_CODE (mem) == POST_DEC)\n+    mem = XEXP (mem, 0);\n+  if (REG_P (mem) && REGNO (mem) == np_reg)\n+    return true;\n+  if (GET_CODE (mem) == PLUS\n+      && REG_P (XEXP (mem, 0)) && REGNO (XEXP (mem, 0)) == np_reg)\n     {\n-      enum attr_type t;\n-      t = get_attr_type (XVECEXP (pat, 0, 1));\n-      if (t == TYPE_MCLD\n-\t  && may_trap_p (SET_SRC (PATTERN (XVECEXP (pat, 0, 1)))))\n+      mem = XEXP (mem, 1);\n+      if (GET_CODE (mem) == CONST_INT && INTVAL (mem) > 0)\n \treturn true;\n-      t = get_attr_type (XVECEXP (pat, 0, 2));\n-      if (t == TYPE_MCLD\n-\t  && may_trap_p (SET_SRC (PATTERN (XVECEXP (pat, 0, 2)))))\n-\treturn true;\n-      return false;\n     }\n-  else\n-    return may_trap_p (SET_SRC (single_set (insn)));\n+  return false;\n+}\n+\n+/* Return nonzero if INSN contains any loads that may trap.  */\n+\n+static bool\n+trapping_loads_p (rtx insn, int np_reg, bool after_np_branch)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx mem = SET_SRC (single_set (insn));\n+\n+  if (!after_np_branch)\n+    np_reg = -1;\n+  return ((np_reg == -1 || !harmless_null_pointer_p (mem, np_reg))\n+\t  && may_trap_p (mem));\n }\n \n /* Return INSN if it is of TYPE_MCLD.  Alternatively, if INSN is the start of\n@@ -5098,6 +5108,24 @@ indirect_call_p (rtx pat)\n   return REG_P (pat);\n }\n \n+/* During workaround_speculation, track whether we're in the shadow of a\n+   conditional branch that tests a P register for NULL.  If so, we can omit\n+   emitting NOPs if we see a load from that P register, since a speculative\n+   access at address 0 isn't a problem, and the load is executed in all other\n+   cases anyway.\n+   Global for communication with note_np_check_stores through note_stores.\n+   */\n+int np_check_regno = -1;\n+bool np_after_branch = false;\n+\n+/* Subroutine of workaround_speculation, called through note_stores.  */\n+static void\n+note_np_check_stores (rtx x, const_rtx pat, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (REG_P (x) && (REGNO (x) == REG_CC || REGNO (x) == np_check_regno))\n+    np_check_regno = -1;\n+}\n+\n static void\n workaround_speculation (void)\n {\n@@ -5119,17 +5147,38 @@ workaround_speculation (void)\n \n       next = find_next_insn_start (insn);\n       \n-      if (NOTE_P (insn) || BARRIER_P (insn) || LABEL_P (insn))\n+      if (NOTE_P (insn) || BARRIER_P (insn))\n \tcontinue;\n \n+      if (LABEL_P (insn))\n+\t{\n+\t  np_check_regno = -1;\n+\t  continue;\n+\t}\n+\n       pat = PATTERN (insn);\n       if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t  || GET_CODE (pat) == ASM_INPUT || GET_CODE (pat) == ADDR_VEC\n-\t  || GET_CODE (pat) == ADDR_DIFF_VEC || asm_noperands (pat) >= 0)\n+\t  || GET_CODE (pat) == ADDR_VEC || GET_CODE (pat) == ADDR_DIFF_VEC)\n \tcontinue;\n+      \n+      if (GET_CODE (pat) == ASM_INPUT || asm_noperands (pat) >= 0)\n+\t{\n+\t  np_check_regno = -1;\n+\t  continue;\n+\t}\n \n       if (JUMP_P (insn))\n \t{\n+\t  /* Is this a condjump based on a null pointer comparison we saw\n+\t     earlier?  */\n+\t  if (np_check_regno != -1\n+\t      && recog_memoized (insn) == CODE_FOR_cbranchbi4)\n+\t    {\n+\t      rtx op = XEXP (SET_SRC (PATTERN (insn)), 0);\n+\t      gcc_assert (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+\t      if (GET_CODE (op) == NE)\n+\t\tnp_after_branch = true;\n+\t    }\n \t  if (any_condjump_p (insn)\n \t      && ! cbranch_predicted_taken_p (insn))\n \t    {\n@@ -5142,6 +5191,7 @@ workaround_speculation (void)\n \t}\n       else if (CALL_P (insn))\n \t{\n+\t  np_check_regno = -1;\n \t  if (cycles_since_jump < INT_MAX)\n \t    cycles_since_jump++;\n \t  if (indirect_call_p (pat) && ENABLE_WA_INDIRECT_CALLS)\n@@ -5157,13 +5207,44 @@ workaround_speculation (void)\n \t  if (cycles_since_jump < INT_MAX)\n \t    cycles_since_jump++;\n \n+\t  /* Detect a comparison of a P register with zero.  If we later\n+\t     see a condjump based on it, we have found a null pointer\n+\t     check.  */\n+\t  if (recog_memoized (insn) == CODE_FOR_compare_eq)\n+\t    {\n+\t      rtx src = SET_SRC (PATTERN (insn));\n+\t      if (REG_P (XEXP (src, 0))\n+\t\t  && P_REGNO_P (REGNO (XEXP (src, 0)))\n+\t\t  && XEXP (src, 1) == const0_rtx)\n+\t\t{\n+\t\t  np_check_regno = REGNO (XEXP (src, 0));\n+\t\t  np_after_branch = false;\n+\t\t}\n+\t      else\n+\t\tnp_check_regno = -1;\n+\t    }\n+\n \t  if (load_insn && ENABLE_WA_SPECULATIVE_LOADS)\n \t    {\n-\t      if (trapping_loads_p (load_insn))\n+\t      if (trapping_loads_p (load_insn, np_check_regno,\n+\t\t\t\t    np_after_branch))\n \t\tdelay_needed = 4;\n \t    }\n \t  else if (type == TYPE_SYNC && ENABLE_WA_SPECULATIVE_SYNCS)\n \t    delay_needed = 3;\n+\n+\t  /* See if we need to forget about a null pointer comparison\n+\t     we found earlier.  */\n+\t  if (recog_memoized (insn) != CODE_FOR_compare_eq)\n+\t    {\n+\t      note_stores (PATTERN (insn), note_np_check_stores, NULL);\n+\t      if (np_check_regno != -1)\n+\t\t{\n+\t\t  if (find_regno_note (insn, REG_INC, np_check_regno))\n+\t\t    np_check_regno = -1;\n+\t\t}\n+\t    }\n+\n \t}\n \n       if (delay_needed > cycles_since_jump\n@@ -5241,7 +5322,7 @@ workaround_speculation (void)\n \n \t\t  if (load_insn && ENABLE_WA_SPECULATIVE_LOADS)\n \t\t    {\n-\t\t      if (trapping_loads_p (load_insn))\n+\t\t      if (trapping_loads_p (load_insn, -1, false))\n \t\t\tdelay_needed = 2;\n \t\t    }\n \t\t  else if (type == TYPE_SYNC && ENABLE_WA_SPECULATIVE_SYNCS)"}]}