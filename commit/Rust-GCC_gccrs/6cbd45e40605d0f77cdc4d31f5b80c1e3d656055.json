{"sha": "6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiZDQ1ZTQwNjA1ZDBmNzdjZGM0ZDMxZjViODBjMWUzZDY1NjA1NQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-05T11:58:13Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-05T11:58:13Z"}, "message": "[multiple changes]\n\n2017-12-05  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): Use the SLOC of the\n\titeration scheme throughout, except for the new loop statement(s).\n\n2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Gen_Assign): Do not analyze the expressionn of the\n\tassignment if it is part of an Iterated_Component_Association: the\n\tanalysis needs to take place once the loop structure is analyzed and\n\tthe loop parameter made visible, because references to it typically\n\tappear in the corresponding expression.  This is necessary if the\n\texpression is an aggregate, because previous pre-analysis of the\n\texpression does not handle nested aggregates properly.\n\n2017-12-05  Bob Duff  <duff@adacore.com>\n\n\t* sem_res.adb (Resolve_Allocator): Avoid coextension processing for an\n\tallocator that is the expansion of a build-in-place function call.\n\n2017-12-05  Olivier Hainque  <hainque@adacore.com>\n\nlibgnat/\n\t* s-trasym__dwarf.adb (spec of Module_Name.Get): Instead of\n\tpossibly adjusting the lookup address by a load address, expect\n\ta extra argument through which the load address can be conveyed\n\tseparately.\n\t(Multi_Module_Symbolic_Traceback): Adjust accordingly. Pass the\n\tretrieved load address to Init_Module.\n\t* s-tsmona__linux.adb (Get): Honor the new interface.\n\t* s-tsmona__mingw.adb (Get): Likewise.\n\t* s-dwalin.ads: Adjust comments to be explicit about which\n\taddresses are from module info and which are run-time addresses,\n\toffsetted by the module load address.\n\t* s-dwalin.adb (Set_Load_Address): Simply set C.Load_Slide.\n\tDo not alter the module Low and High (relative) addresses.\n\t(Is_Inside): Improve documentation regarding the kinds of addresses\n\tat hand and correct the test.\n\t(Symbolic_Traceback): Use separate variables with explicit names\n\tfor the address in traceback (run-time value) and the address to\n\tlookup within the shared object (module-relative). Adjust the\n\tcomputation of address passed to Symbolic_Address for symbolization.\n\nFrom-SVN: r255411", "tree": {"sha": "89cd500cfbe44b2b886476d955874f5a0821e398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89cd500cfbe44b2b886476d955874f5a0821e398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/comments", "author": null, "committer": null, "parents": [{"sha": "f4ac86dd5c3569dac8b395e823296ed89a2030e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ac86dd5c3569dac8b395e823296ed89a2030e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ac86dd5c3569dac8b395e823296ed89a2030e9"}], "stats": {"total": 264, "additions": 172, "deletions": 92}, "files": [{"sha": "36170ec4081dbc3b6a174aa5486bef4e8cce20f9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -1,3 +1,46 @@\n+2017-12-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): Use the SLOC of the\n+\titeration scheme throughout, except for the new loop statement(s).\n+\n+2017-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Gen_Assign): Do not analyze the expressionn of the\n+\tassignment if it is part of an Iterated_Component_Association: the\n+\tanalysis needs to take place once the loop structure is analyzed and\n+\tthe loop parameter made visible, because references to it typically\n+\tappear in the corresponding expression.  This is necessary if the\n+\texpression is an aggregate, because previous pre-analysis of the\n+\texpression does not handle nested aggregates properly.\n+\n+2017-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Allocator): Avoid coextension processing for an\n+\tallocator that is the expansion of a build-in-place function call.\n+\n+2017-12-05  Olivier Hainque  <hainque@adacore.com>\n+\n+libgnat/\n+\t* s-trasym__dwarf.adb (spec of Module_Name.Get): Instead of\n+\tpossibly adjusting the lookup address by a load address, expect\n+\ta extra argument through which the load address can be conveyed\n+\tseparately.\n+\t(Multi_Module_Symbolic_Traceback): Adjust accordingly. Pass the\n+\tretrieved load address to Init_Module.\n+\t* s-tsmona__linux.adb (Get): Honor the new interface.\n+\t* s-tsmona__mingw.adb (Get): Likewise.\n+\t* s-dwalin.ads: Adjust comments to be explicit about which\n+\taddresses are from module info and which are run-time addresses,\n+\toffsetted by the module load address.\n+\t* s-dwalin.adb (Set_Load_Address): Simply set C.Load_Slide.\n+\tDo not alter the module Low and High (relative) addresses.\n+\t(Is_Inside): Improve documentation regarding the kinds of addresses\n+\tat hand and correct the test.\n+\t(Symbolic_Traceback): Use separate variables with explicit names\n+\tfor the address in traceback (run-time value) and the address to\n+\tlookup within the shared object (module-relative). Adjust the\n+\tcomputation of address passed to Symbolic_Address for symbolization.\n+\n 2017-12-05  Arnaud Charlet  <charlet@adacore.com>\n \n \t* opt.ads (Expand_Nonbinary_Modular_Ops): New flag."}, {"sha": "581e31cfb929a486f57410116d55183673d2d1a8", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -1533,7 +1533,14 @@ package body Exp_Aggr is\n             --  the analysis of non-array aggregates now in order to get the\n             --  value of Expansion_Delayed flag for the inner aggregate ???\n \n-            if Present (Comp_Typ) and then not Is_Array_Type (Comp_Typ) then\n+            --  In the case of an iterated component association, the analysis\n+            --  of the generated loop will analyze the expression in the\n+            --  proper context, in which the loop parameter is visible.\n+\n+            if Present (Comp_Typ) and then not Is_Array_Type (Comp_Typ)\n+              and then\n+                Nkind (Parent (Expr_Q)) /= N_Iterated_Component_Association\n+            then\n                Analyze_And_Resolve (Expr_Q, Comp_Typ);\n             end if;\n \n@@ -5366,6 +5373,10 @@ package body Exp_Aggr is\n             Expr : Node_Id;\n \n          begin\n+            if Nkind (Parent (Aggr)) = N_Iterated_Component_Association then\n+               return False;\n+            end if;\n+\n             if Present (Expressions (Aggr)) then\n                Expr := First (Expressions (Aggr));\n                while Present (Expr) loop"}, {"sha": "5779d2362cf6517cd2d2eb6c5039c0d6dbce5165", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -3673,7 +3673,7 @@ package body Exp_Ch5 is\n       Array_Typ  : constant Entity_Id  := Base_Type (Etype (Array_Node));\n       Array_Dim  : constant Pos        := Number_Dimensions (Array_Typ);\n       Id         : constant Entity_Id  := Defining_Identifier (I_Spec);\n-      Loc        : constant Source_Ptr := Sloc (N);\n+      Loc        : constant Source_Ptr := Sloc (Isc);\n       Stats      : constant List_Id    := Statements (N);\n       Core_Loop  : Node_Id;\n       Dim1       : Int;\n@@ -3734,7 +3734,7 @@ package body Exp_Ch5 is\n       end if;\n \n       Core_Loop :=\n-        Make_Loop_Statement (Loc,\n+        Make_Loop_Statement (Sloc (N),\n           Iteration_Scheme =>\n             Make_Iteration_Scheme (Loc,\n               Loop_Parameter_Specification =>\n@@ -3771,7 +3771,7 @@ package body Exp_Ch5 is\n             --    end loop;\n \n             Core_Loop :=\n-              Make_Loop_Statement (Loc,\n+              Make_Loop_Statement (Sloc (N),\n                 Iteration_Scheme =>\n                   Make_Iteration_Scheme (Loc,\n                     Loop_Parameter_Specification =>"}, {"sha": "af11740235c11feddcfa21174a4f5ac11b784473", "filename": "gcc/ada/libgnat/s-dwalin.adb", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-dwalin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-dwalin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dwalin.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -372,7 +372,8 @@ package body System.Dwarf_Lines is\n \n    function Is_Inside (C : Dwarf_Context; Addr : Address) return Boolean is\n    begin\n-      return Addr >= C.Low and Addr <= C.High;\n+      return (Addr >= To_Address (To_Integer (C.Low) + C.Load_Slide)\n+                and Addr <= To_Address (To_Integer (C.High) + C.Load_Slide));\n    end Is_Inside;\n \n    ---------\n@@ -771,15 +772,7 @@ package body System.Dwarf_Lines is\n \n    procedure Set_Load_Address (C : in out Dwarf_Context; Addr : Address) is\n    begin\n-      if Addr = Null_Address then\n-         return;\n-      else\n-         C.Load_Slide :=\n-           To_Integer (Addr) - Integer_Address (Get_Load_Address (C.Obj.all));\n-\n-         C.Low  := To_Address (To_Integer (C.Low) + C.Load_Slide);\n-         C.High := To_Address (To_Integer (C.High) + C.Load_Slide);\n-      end if;\n+      C.Load_Slide := To_Integer (Addr);\n    end Set_Load_Address;\n \n    ------------------\n@@ -1523,8 +1516,10 @@ package body System.Dwarf_Lines is\n       Res          : in out System.Bounded_Strings.Bounded_String)\n    is\n       use Ada.Characters.Handling;\n-      C    : Dwarf_Context := Cin;\n-      Addr : Address;\n+      C : Dwarf_Context := Cin;\n+\n+      Addr_In_Traceback : Address;\n+      Addr_To_Lookup    : Address;\n \n       Dir_Name    : Str_Access;\n       File_Name   : Str_Access;\n@@ -1543,10 +1538,14 @@ package body System.Dwarf_Lines is\n          --  If the buffer is full, no need to do any useless work\n          exit when Is_Full (Res);\n \n-         Addr := PC_For (Traceback (J));\n+         Addr_In_Traceback := PC_For (Traceback (J));\n+\n+         Addr_To_Lookup := To_Address\n+           (To_Integer (Addr_In_Traceback) - C.Load_Slide);\n+\n          Symbolic_Address\n            (C,\n-            To_Address (To_Integer (Addr) + C.Load_Slide),\n+            Addr_To_Lookup,\n             Dir_Name,\n             File_Name,\n             Subprg_Name,\n@@ -1608,7 +1607,7 @@ package body System.Dwarf_Lines is\n             if Suppress_Hex then\n                Append (Res, \"...\");\n             else\n-               Append_Address (Res, Addr);\n+               Append_Address (Res, Addr_In_Traceback);\n             end if;\n \n             if Subprg_Name.Len > 0 then"}, {"sha": "982b30fda3277647302d2e65b24f633eefa0ae69", "filename": "gcc/ada/libgnat/s-dwalin.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-dwalin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-dwalin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dwalin.ads?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -73,11 +73,11 @@ package System.Dwarf_Lines is\n \n    function Is_Inside (C : Dwarf_Context; Addr : Address) return Boolean;\n    pragma Inline (Is_Inside);\n-   --  Return true iff Addr is within the module\n+   --  Return true iff a run-time address Addr is within the module\n \n    function Low (C : Dwarf_Context) return Address;\n    pragma Inline (Low);\n-   --  Return the lowest address of C\n+   --  Return the lowest address of C, from the module object file\n \n    procedure Dump (C : in out Dwarf_Context);\n    --  Dump each row found in the object's .debug_lines section to standard out\n@@ -165,7 +165,7 @@ private\n    type Dwarf_Context (In_Exception : Boolean := False) is record\n       Load_Slide : System.Storage_Elements.Integer_Address := 0;\n       Low, High  : Address;\n-      --  Bounds of the module\n+      --  Bounds of the module, per the module object file\n \n       Obj : SOR.Object_File_Access;\n       --  The object file containing dwarf sections"}, {"sha": "b1fb480c691013226aa675c6d663ce742229b7c1", "filename": "gcc/ada/libgnat/s-trasym__dwarf.adb", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-trasym__dwarf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-trasym__dwarf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-trasym__dwarf.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -132,10 +132,12 @@ package body System.Traceback.Symbolic is\n       procedure Build_Cache_For_All_Modules;\n       --  Create the cache for all current modules\n \n-      function Get (Addr : access System.Address) return String;\n-      --  Returns the module name for the given address, Addr may be updated\n-      --  to be set relative to a shared library. This depends on the platform.\n-      --  Returns an empty string for the main executable.\n+      function Get (Addr : System.Address;\n+                    Load_Addr : access System.Address) return String;\n+      --  Returns the module name for the given address Addr, or an empty\n+      --  string for the main executable.  Load_Addr is set to the shared\n+      --  library load address if this information is available, or to\n+      --  System.Null_Address otherwise.\n \n       function Is_Supported return Boolean;\n       pragma Inline (Is_Supported);\n@@ -499,12 +501,14 @@ package body System.Traceback.Symbolic is\n \n          --  Otherwise, try a shared library\n          declare\n-            Addr    : aliased System.Address := Traceback (F);\n-            M_Name  : constant String        := Module_Name.Get (Addr'Access);\n+            Load_Addr : aliased System.Address;\n+            M_Name  : constant String :=\n+              Module_Name.Get (Addr => Traceback (F),\n+                               Load_Addr => Load_Addr'Access);\n             Module  : Module_Cache;\n             Success : Boolean;\n          begin\n-            Init_Module (Module, Success, M_Name, System.Null_Address);\n+            Init_Module (Module, Success, M_Name, Load_Addr);\n             if Success then\n                Multi_Module_Symbolic_Traceback\n                  (Traceback,"}, {"sha": "c361afa898241077e4e7e0c73a0634af6a4ca743", "filename": "gcc/ada/libgnat/s-tsmona__linux.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-tsmona__linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-tsmona__linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-tsmona__linux.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -32,8 +32,6 @@\n --  This is the GNU/Linux specific version of this package\n with Interfaces.C;              use Interfaces.C;\n \n-with System.Address_Operations; use System.Address_Operations;\n-\n separate (System.Traceback.Symbolic)\n \n package body Module_Name is\n@@ -134,7 +132,10 @@ package body Module_Name is\n    -- Get --\n    ---------\n \n-   function Get (Addr : access System.Address) return String is\n+   function Get (Addr : System.Address;\n+                 Load_Addr : access System.Address)\n+     return String\n+   is\n \n       --  Dl_info record for Linux, used to get sym reloc offset\n \n@@ -154,13 +155,15 @@ package body Module_Name is\n       info : aliased Dl_info;\n \n    begin\n-      if dladdr (Addr.all, info'Access) /= 0 then\n+      Load_Addr.all := System.Null_Address;\n+\n+      if dladdr (Addr, info'Access) /= 0 then\n \n          --  If we have a shared library we need to adjust the address to\n          --  be relative to the base address of the library.\n \n          if Is_Shared_Lib (info.dli_fbase) then\n-            Addr.all := SubA (Addr.all, info.dli_fbase);\n+            Load_Addr.all := info.dli_fbase;\n          end if;\n \n          return Value (info.dli_fname);"}, {"sha": "d2f260f56661bc2b87c3a8180e88bd2077074f1b", "filename": "gcc/ada/libgnat/s-tsmona__mingw.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-tsmona__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Flibgnat%2Fs-tsmona__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-tsmona__mingw.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -50,15 +50,20 @@ package body Module_Name is\n    -- Get --\n    ---------\n \n-   function Get (Addr : access System.Address) return String is\n+   function Get (Addr : System.Address;\n+                 Load_Addr : access System.Address)\n+     return String\n+   is\n       Res     : DWORD;\n       hModule : aliased HANDLE;\n       Path    : String (1 .. 1_024);\n \n    begin\n+      Load_Addr.all := System.Null_Address;\n+\n       if GetModuleHandleEx\n            (GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-            Addr.all,\n+            Addr,\n             hModule'Access) = Win32.TRUE\n       then\n          Res := GetModuleFileName (hModule, Path'Address, Path'Length);"}, {"sha": "5884eaaae46f8d99bdb4099d1b283eb4327f959f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 71, "deletions": 56, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd45e40605d0f77cdc4d31f5b80c1e3d656055/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6cbd45e40605d0f77cdc4d31f5b80c1e3d656055", "patch": "@@ -5116,76 +5116,91 @@ package body Sem_Res is\n       --  statement.\n \n       if Nkind (N) = N_Allocator then\n+         --  Avoid coextension processing for an allocator that is the\n+         --  expansion of a build-in-place function call.\n+\n+         if Nkind (Original_Node (N)) = N_Allocator\n+           and then Nkind (Expression (Original_Node (N))) =\n+                      N_Qualified_Expression\n+           and then Nkind (Expression (Expression (Original_Node (N)))) =\n+                      N_Function_Call\n+           and then Is_Expanded_Build_In_Place_Call\n+                      (Expression (Expression (Original_Node (N))))\n+         then\n+            null; -- b-i-p function call case\n \n-         --  An anonymous access discriminant is the definition of a\n-         --  coextension.\n+         else\n+            --  An anonymous access discriminant is the definition of a\n+            --  coextension.\n \n-         if Ekind (Typ) = E_Anonymous_Access_Type\n-           and then Nkind (Associated_Node_For_Itype (Typ)) =\n-                      N_Discriminant_Specification\n-         then\n-            declare\n-               Discr : constant Entity_Id :=\n-                         Defining_Identifier (Associated_Node_For_Itype (Typ));\n+            if Ekind (Typ) = E_Anonymous_Access_Type\n+              and then Nkind (Associated_Node_For_Itype (Typ)) =\n+                         N_Discriminant_Specification\n+            then\n+               declare\n+                  Discr : constant Entity_Id :=\n+                    Defining_Identifier (Associated_Node_For_Itype (Typ));\n \n-            begin\n-               Check_Restriction (No_Coextensions, N);\n+               begin\n+                  Check_Restriction (No_Coextensions, N);\n \n-               --  Ada 2012 AI05-0052: If the designated type of the allocator\n-               --  is limited, then the allocator shall not be used to define\n-               --  the value of an access discriminant unless the discriminated\n-               --  type is immutably limited.\n+                  --  Ada 2012 AI05-0052: If the designated type of the\n+                  --  allocator is limited, then the allocator shall not\n+                  --  be used to define the value of an access discriminant\n+                  --  unless the discriminated type is immutably limited.\n \n-               if Ada_Version >= Ada_2012\n-                 and then Is_Limited_Type (Desig_T)\n-                 and then not Is_Limited_View (Scope (Discr))\n-               then\n-                  Error_Msg_N\n-                    (\"only immutably limited types can have anonymous \"\n-                     & \"access discriminants designating a limited type\", N);\n-               end if;\n-            end;\n+                  if Ada_Version >= Ada_2012\n+                    and then Is_Limited_Type (Desig_T)\n+                    and then not Is_Limited_View (Scope (Discr))\n+                  then\n+                     Error_Msg_N\n+                       (\"only immutably limited types can have anonymous \"\n+                        & \"access discriminants designating a limited type\",\n+                        N);\n+                  end if;\n+               end;\n \n-            --  Avoid marking an allocator as a dynamic coextension if it is\n-            --  within a static construct.\n+               --  Avoid marking an allocator as a dynamic coextension if it is\n+               --  within a static construct.\n \n-            if not Is_Static_Coextension (N) then\n-               Set_Is_Dynamic_Coextension (N);\n+               if not Is_Static_Coextension (N) then\n+                  Set_Is_Dynamic_Coextension (N);\n \n-               --  ??? We currently do not handle finalization and deallocation\n-               --  of coextensions properly so let's at least warn the user\n-               --  about it.\n+                  --  ??? We currently do not handle finalization and\n+                  --  deallocation of coextensions properly so let's at\n+                  --  least warn the user about it.\n \n-               if Is_Controlled (Desig_T) then\n-                  Error_Msg_N\n-                    (\"??coextension will not be finalized when its \"\n-                     & \"associated owner is deallocated or finalized\", N);\n-               else\n-                  Error_Msg_N\n-                    (\"??coextension will not be deallocated when its \"\n-                     & \"associated owner is deallocated\", N);\n+                  if Is_Controlled (Desig_T) then\n+                     Error_Msg_N\n+                       (\"??coextension will not be finalized when its \"\n+                        & \"associated owner is deallocated or finalized\", N);\n+                  else\n+                     Error_Msg_N\n+                       (\"??coextension will not be deallocated when its \"\n+                        & \"associated owner is deallocated\", N);\n+                  end if;\n                end if;\n-            end if;\n \n-         --  Cleanup for potential static coextensions\n+            --  Cleanup for potential static coextensions\n \n-         else\n-            Set_Is_Dynamic_Coextension (N, False);\n-            Set_Is_Static_Coextension  (N, False);\n+            else\n+               Set_Is_Dynamic_Coextension (N, False);\n+               Set_Is_Static_Coextension  (N, False);\n \n-            --  ??? It seems we also do not properly finalize anonymous\n-            --  access-to-controlled objects within their declared scope and\n-            --  instead finalize them with their associated unit. Warn the\n-            --  user about it here.\n+               --  ??? It seems we also do not properly finalize anonymous\n+               --  access-to-controlled objects within their declared scope and\n+               --  instead finalize them with their associated unit. Warn the\n+               --  user about it here.\n \n-            if Ekind (Typ) = E_Anonymous_Access_Type\n-              and then Is_Controlled_Active (Desig_T)\n-            then\n-               Error_Msg_N\n-                 (\"??object designated by anonymous access object might not \"\n-                  & \"be finalized until its enclosing library unit goes out \"\n-                  & \"of scope\", N);\n-               Error_Msg_N (\"\\use named access type instead\", N);\n+               if Ekind (Typ) = E_Anonymous_Access_Type\n+                 and then Is_Controlled_Active (Desig_T)\n+               then\n+                  Error_Msg_N\n+                    (\"??object designated by anonymous access object might \"\n+                     & \"not be finalized until its enclosing library unit \"\n+                     & \"goes out of scope\", N);\n+                  Error_Msg_N (\"\\use named access type instead\", N);\n+               end if;\n             end if;\n          end if;\n       end if;"}]}