{"sha": "16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY0NjVjZWIwNmNjMWY2NWNmY2EzYzBlYjJjMWVlMjdhYjAzYmRmZA==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-06-01T01:00:57Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-06-07T02:25:03Z"}, "message": "CALL_INSN may not be a real function call.\n\nUse \"used\" flag for CALL_INSN to indicate it's a fake call. If it's a\nfake call, it won't have its own function stack.\n\ngcc/ChangeLog\n\n\tPR target/82735\n\t* df-scan.c (df_get_call_refs): When call_insn is a fake call,\n\tit won't use stack pointer reg.\n\t* final.c (leaf_function_p): When call_insn is a fake call, it\n\twon't affect caller as a leaf function.\n\t* reg-stack.c (callee_clobbers_any_stack_reg): New.\n\t(subst_stack_regs): When call_insn doesn't clobber any stack\n\treg, don't clear the arguments.\n\t* rtl.c (shallow_copy_rtx): Don't clear flag used when orig is\n\ta insn.\n\t* shrink-wrap.c (requires_stack_frame_p): No need for stack\n\tframe for a fake call.\n\t* rtl.h (FAKE_CALL_P): New macro.", "tree": {"sha": "7afa0001810636d4623eff17ba18d988d79b4ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7afa0001810636d4623eff17ba18d988d79b4ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d6987e90d1181de8dc51f9ba2313052faea080e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6987e90d1181de8dc51f9ba2313052faea080e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d6987e90d1181de8dc51f9ba2313052faea080e"}], "stats": {"total": 37, "additions": 31, "deletions": 6}, "files": [{"sha": "1268536b3f0a85fd005eba40ca05e75714a8459a", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "patch": "@@ -3090,7 +3090,8 @@ df_get_call_refs (class df_collection_rec *collection_rec,\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      if (i == STACK_POINTER_REGNUM)\n+      if (i == STACK_POINTER_REGNUM\n+\t  && !FAKE_CALL_P (insn_info->insn))\n \t/* The stack ptr is used (honorarily) by a CALL insn.  */\n \tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n \t\t       NULL, bb, insn_info, DF_REF_REG_USE,"}, {"sha": "dba0b0abeb7314bdc2e656e17aeff0684a1ec8e5", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "patch": "@@ -4106,7 +4106,8 @@ leaf_function_p (void)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (CALL_P (insn)\n-\t  && ! SIBLING_CALL_P (insn))\n+\t  && ! SIBLING_CALL_P (insn)\n+\t  && ! FAKE_CALL_P (insn))\n \treturn 0;\n       if (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE"}, {"sha": "1d9ea035cf44f77a09d8bedc2001240e0d646b64", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "patch": "@@ -174,6 +174,7 @@\n #include \"reload.h\"\n #include \"tree-pass.h\"\n #include \"rtl-iter.h\"\n+#include \"function-abi.h\"\n \n #ifdef STACK_REGS\n \n@@ -2368,6 +2369,18 @@ subst_asm_stack_regs (rtx_insn *insn, stack_ptr regstack)\n \t    }\n       }\n }\n+\n+/* Return true if a function call is allowed to alter some or all bits\n+   of any stack reg.  */\n+static bool\n+callee_clobbers_any_stack_reg (const function_abi & callee_abi)\n+{\n+  for (unsigned regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n+    if (callee_abi.clobbers_at_least_part_of_reg_p (regno))\n+      return true;\n+  return false;\n+}\n+\n \f\n /* Substitute stack hard reg numbers for stack virtual registers in\n    INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n@@ -2382,7 +2395,10 @@ subst_stack_regs (rtx_insn *insn, stack_ptr regstack)\n   bool control_flow_insn_deleted = false;\n   int i;\n \n-  if (CALL_P (insn))\n+  /* If the target of the call doesn't clobber any stack registers,\n+     Don't clear the arguments.  */\n+  if (CALL_P (insn)\n+      && callee_clobbers_any_stack_reg (insn_callee_abi (insn)))\n     {\n       int top = regstack->top;\n "}, {"sha": "aaee882f5ca3e37b59c9829e41d0864070c170eb", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "patch": "@@ -395,8 +395,10 @@ shallow_copy_rtx (const_rtx orig MEM_STAT_DECL)\n     case SCRATCH:\n       break;\n     default:\n-      /* For all other RTXes clear the used flag on the copy.  */\n-      RTX_FLAG (copy, used) = 0;\n+      /* For all other RTXes clear the used flag on the copy.\n+\t CALL_INSN use \"used\" flag to indicate it's a fake call.  */\n+      if (!INSN_P (orig))\n+\tRTX_FLAG (copy, used) = 0;\n       break;\n     }\n   return copy;"}, {"sha": "5ed0d6dd6fa6356f283f1ca9c3b029b8d22aa4f7", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "patch": "@@ -839,6 +839,11 @@ struct GTY(()) rtvec_def {\n /* Predicate yielding nonzero iff X is a call insn.  */\n #define CALL_P(X) (GET_CODE (X) == CALL_INSN)\n \n+/* 1 if RTX is a call_insn for a fake call.\n+   CALL_INSN use \"used\" flag to indicate it's a fake call.  */\n+#define FAKE_CALL_P(RTX)                                        \\\n+  (RTL_FLAG_CHECK1 (\"FAKE_CALL_P\", (RTX), CALL_INSN)->used)\n+\n /* Predicate yielding nonzero iff X is an insn that cannot jump.  */\n #define NONJUMP_INSN_P(X) (GET_CODE (X) == INSN)\n "}, {"sha": "5e60f34f74927d8c99e5abbe6723e2c618e2bb04", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=16465ceb06cc1f65cfca3c0eb2c1ee27ab03bdfd", "patch": "@@ -57,7 +57,7 @@ requires_stack_frame_p (rtx_insn *insn, HARD_REG_SET prologue_used,\n   HARD_REG_SET hardregs;\n   unsigned regno;\n \n-  if (CALL_P (insn))\n+  if (CALL_P (insn) && !FAKE_CALL_P (insn))\n     return !SIBLING_CALL_P (insn);\n \n   /* We need a frame to get the unique CFA expected by the unwinder.  */"}]}