{"sha": "32a11c08863764dfd6a3be749c0729fee6cd298c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhMTFjMDg4NjM3NjRkZmQ2YTNiZTc0OWMwNzI5ZmVlNmNkMjk4Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-07-06T01:23:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-07-06T01:23:54Z"}, "message": "re PR c++/32245 (wrong POD type initialization with pointer to member)\n\n\tPR c++/32245\n\t* init.c (build_zero_init): Always build an initializer for\n\tnon-static storage.\n\t* typeck2.c (build_functional_cast): Use build_zero_init.\n\n\tPR c++/32251\n\t* init.c (build_new_1): Always pass the allocation function to\n\tbuild_op_delete_call.\n\t* call.c (build_op_delete_call): Handle operator delete with a\n\tvariable-argument list.  Do not issue an error when no matching\n\tdeallocation function is available for a new operator.\n\n\tPR c++/31992\n\t* cp-tree.h (any_value_dependent_elements_p): Declare it.\n\t* decl.c (value_dependent_init_p): New function.\n\t(cp_finish_decl): Use it.\n\t* pt.c (value_dependent_expression_p): Use\n\tany_value_dependent_elements_p.\n\t* parser.c (cp_parser_primary_expression): Add comment about\n\ttreating dependent qualified names as integral\n\tconstant-expressions.\n\n\tPR c++/32245\n\t* g++.dg/init/ptrmem4.C: New test.\n\n\tPR c++/32251\n\t* g++.dg/init/new21.C: Likewise.\n\n\tPR c++/31992\n\t* g++.dg/template/static30.C: Likewise.\n\nFrom-SVN: r126399", "tree": {"sha": "17dc867104325855fe255d6858ff0978e0b8936c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17dc867104325855fe255d6858ff0978e0b8936c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32a11c08863764dfd6a3be749c0729fee6cd298c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a11c08863764dfd6a3be749c0729fee6cd298c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32a11c08863764dfd6a3be749c0729fee6cd298c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a11c08863764dfd6a3be749c0729fee6cd298c/comments", "author": null, "committer": null, "parents": [{"sha": "22761ec3b9b4688e515019b6b97025fda5be6a44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22761ec3b9b4688e515019b6b97025fda5be6a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22761ec3b9b4688e515019b6b97025fda5be6a44"}], "stats": {"total": 196, "additions": 165, "deletions": 31}, "files": [{"sha": "3aac996e4b34c6061d8b89ccafe6182821f96f5a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -1,3 +1,27 @@\n+2007-07-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/32245\n+\t* init.c (build_zero_init): Always build an initializer for\n+\tnon-static storage.\n+\t* typeck2.c (build_functional_cast): Use build_zero_init.\n+\n+\tPR c++/32251\n+\t* init.c (build_new_1): Always pass the allocation function to\n+\tbuild_op_delete_call.\n+\t* call.c (build_op_delete_call): Handle operator delete with a\n+\tvariable-argument list.  Do not issue an error when no matching\n+\tdeallocation function is available for a new operator.\n+\n+\tPR c++/31992\n+\t* cp-tree.h (any_value_dependent_elements_p): Declare it.\n+\t* decl.c (value_dependent_init_p): New function.\n+\t(cp_finish_decl): Use it.\n+\t* pt.c (value_dependent_expression_p): Use\n+\tany_value_dependent_elements_p.\n+\t* parser.c (cp_parser_primary_expression): Add comment about\n+\ttreating dependent qualified names as integral\n+\tconstant-expressions.\n+\n 2007-07-04  Douglas Gregor  <doug.gregor@gmail.com>\n \n \t* decl.c (build_ptrmemfunc_type): Always use structural equality"}, {"sha": "82f8666c42e256454b426633b9236b22e0f7cc50", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -4062,8 +4062,12 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n    GLOBAL_P is true if the delete-expression should not consider\n    class-specific delete operators.\n    PLACEMENT is the corresponding placement new call, or NULL_TREE.\n-   If PLACEMENT is non-NULL, then ALLOC_FN is the allocation function\n-   called to perform the placement new.  */\n+\n+   If this call to \"operator delete\" is being generated as part to\n+   deallocate memory allocated via a new-expression (as per [expr.new]\n+   which requires that if the initialization throws an exception then\n+   we call a deallocation function), then ALLOC_FN is the allocation\n+   function.  */\n \n tree\n build_op_delete_call (enum tree_code code, tree addr, tree size,\n@@ -4151,9 +4155,13 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t      if (!a && !t)\n \t\tbreak;\n \t    }\n-\t  /* On the second pass, the second argument must be\n-\t     \"size_t\".  */\n+\t  /* On the second pass, look for a function with exactly two\n+\t     arguments: \"void *\" and \"size_t\".  */\n \t  else if (pass == 1\n+\t\t   /* For \"operator delete(void *, ...)\" there will be\n+\t\t      no second argument, but we will not get an exact\n+\t\t      match above.  */\n+\t\t   && t\n \t\t   && same_type_p (TREE_VALUE (t), size_type_node)\n \t\t   && TREE_CHAIN (t) == void_list_node)\n \t    break;\n@@ -4201,10 +4209,18 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t}\n     }\n \n-  /* If we are doing placement delete we do nothing if we don't find a\n-     matching op delete.  */\n-  if (placement)\n-    return NULL_TREE;\n+  /* [expr.new]\n+\n+     If no unambiguous matching deallocation function can be found,\n+     propagating the exception does not cause the object's memory to\n+     be freed.  */\n+  if (alloc_fn)\n+    {\n+      if (!placement)\n+\twarning (0, \"no corresponding deallocation function for `%D'\", \n+\t\t alloc_fn);\n+      return NULL_TREE;\n+    }\n \n   error (\"no suitable %<operator %s%> for %qT\",\n \t operator_name_info[(int)code].name, type);"}, {"sha": "68aeace6e441969db26d77a9508074ba83b1392c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -4444,6 +4444,7 @@ extern bool dependent_template_id_p\t\t(tree, tree);\n extern bool type_dependent_expression_p\t\t(tree);\n extern bool any_type_dependent_arguments_p      (tree);\n extern bool value_dependent_expression_p\t(tree);\n+extern bool any_value_dependent_elements_p      (tree);\n extern tree resolve_typename_type\t\t(tree, bool);\n extern tree template_for_substitution\t\t(tree);\n extern tree build_non_dependent_expr\t\t(tree);"}, {"sha": "bed426bb9c4b210d514442d38500065a98fa10db", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -5099,6 +5099,36 @@ initialize_artificial_var (tree decl, tree init)\n   make_rtl_for_nonlocal_decl (decl, init, /*asmspec=*/NULL);\n }\n \n+/* INIT is the initializer for a variable, as represented by the\n+   parser.  Returns true iff INIT is value-dependent.  */\n+\n+static bool\n+value_dependent_init_p (tree init)\n+{\n+  if (TREE_CODE (init) == TREE_LIST)\n+    /* A parenthesized initializer, e.g.: int i (3, 2); ? */\n+    return any_value_dependent_elements_p (init);\n+  else if (TREE_CODE (init) == CONSTRUCTOR)\n+  /* A brace-enclosed initializer, e.g.: int i = { 3 }; ? */\n+    {\n+      VEC(constructor_elt, gc) *elts;\n+      size_t nelts;\n+      size_t i;\n+\n+      elts = CONSTRUCTOR_ELTS (init);\n+      nelts = VEC_length (constructor_elt, elts);\n+      for (i = 0; i < nelts; ++i)\n+\tif (value_dependent_init_p (VEC_index (constructor_elt,\n+\t\t\t\t\t       elts, i)->value))\n+\t  return true;\n+    }\n+  else\n+    /* It must be a simple expression, e.g., int i = 3;  */\n+    return value_dependent_expression_p (init);\n+  \n+  return false;\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -5171,18 +5201,16 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    TREE_CONSTANT (decl) = 1;\n \t}\n \n-      if (!init\n-\t  || !DECL_CLASS_SCOPE_P (decl)\n-\t  || !DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n-\t  || type_dependent_p\n-\t  || value_dependent_expression_p (init)\n-\t     /* Check also if initializer is a value dependent\n-\t\t{ integral_constant_expression }.  */\n-\t  || (TREE_CODE (init) == CONSTRUCTOR\n-\t      && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)) == 1\n-\t      && value_dependent_expression_p\n-\t\t   (VEC_index (constructor_elt,\n-\t\t\t       CONSTRUCTOR_ELTS (init), 0)->value)))\n+      /* Generally, initializers in templates are expanded when the\n+\t template is instantiated.  But, if DECL is an integral\n+\t constant static data member, then it can be used in future\n+\t integral constant expressions, and its value must be\n+\t available. */\n+      if (!(init\n+\t    && DECL_CLASS_SCOPE_P (decl)\n+\t    && DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n+\t    && !type_dependent_p\n+\t    && !value_dependent_init_p (init)))\n \t{\n \t  if (init)\n \t    DECL_INITIAL (decl) = init;"}, {"sha": "288d0faff3599c00469130bc9bc8ca7af9f3b4dd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -196,7 +196,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t     corresponding to base classes as well.  Thus, iterating\n \t     over TYPE_FIELDs will result in correct initialization of\n \t     all of the subobjects.  */\n-\t  if (static_storage_p && !zero_init_p (TREE_TYPE (field)))\n+\t  if (!static_storage_p || !zero_init_p (TREE_TYPE (field)))\n \t    {\n \t      tree value = build_zero_init (TREE_TYPE (field),\n \t\t\t\t\t    /*nelts=*/NULL_TREE,\n@@ -2038,8 +2038,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t\t\t\t\t  globally_qualified_p,\n \t\t\t\t\t  (placement_allocation_fn_p\n \t\t\t\t\t   ? alloc_call : NULL_TREE),\n-\t\t\t\t\t  (placement_allocation_fn_p\n-\t\t\t\t\t   ? alloc_fn : NULL_TREE));\n+\t\t\t\t\t  alloc_fn);\n \n \t  if (!cleanup)\n \t    /* We're done.  */;"}, {"sha": "0bd33d692a19b700d013311bff433396ebfc401b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -3368,7 +3368,19 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* If name lookup gives us a SCOPE_REF, then the\n \t       qualifying scope was dependent.  */\n \t    if (TREE_CODE (decl) == SCOPE_REF)\n-\t      return decl;\n+\t      {\n+\t\t/* At this point, we do not know if DECL is a valid\n+\t\t   integral constant expression.  We assume that it is\n+\t\t   in fact such an expression, so that code like:\n+\n+\t\t      template <int N> struct A {\n+\t\t\tint a[B<N>::i];\n+\t\t      };\n+\t\t     \n+\t\t   is accepted.  At template-instantiation time, we\n+\t\t   will check that B<N>::i is actually a constant.  */\n+\t\treturn decl;\n+\t      }\n \t    /* Check to see if DECL is a local variable in a context\n \t       where that is forbidden.  */\n \t    if (parser->local_variables_forbidden_p"}, {"sha": "b822d95146356a8c71c3d8026688d64e3df1b86b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -15074,12 +15074,7 @@ value_dependent_expression_p (tree expression)\n \t  }\n \n \tif (TREE_CODE (expression) == TREE_LIST)\n-\t  {\n-\t    for (; expression; expression = TREE_CHAIN (expression))\n-\t      if (value_dependent_expression_p (TREE_VALUE (expression)))\n-\t\treturn true;\n-\t    return false;\n-\t  }\n+\t  return any_value_dependent_elements_p (expression);\n \n \treturn value_dependent_expression_p (expression);\n       }\n@@ -15308,6 +15303,19 @@ any_type_dependent_arguments_p (tree args)\n   return false;\n }\n \n+/* Returns TRUE if LIST (a TREE_LIST whose TREE_VALUEs are\n+   expressions) contains any value-dependent expressions.  */\n+\n+bool\n+any_value_dependent_elements_p (tree list)\n+{\n+  for (; list; list = TREE_CHAIN (list))\n+    if (value_dependent_expression_p (TREE_VALUE (list)))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Returns TRUE if the ARG (a template argument) is dependent.  */\n \n bool"}, {"sha": "4ef082d30ab12d2e3e57e7e4ebad55683814b28f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -1340,7 +1340,9 @@ build_functional_cast (tree exp, tree parms)\n       && !CLASSTYPE_NON_POD_P (type)\n       && TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n     {\n-      exp = build_constructor (type, NULL);\n+      exp = build_zero_init (type, \n+\t\t\t     /*nelts=*/NULL_TREE,\n+\t\t\t     /*static_storage_p=*/false);\n       return get_target_expr (exp);\n     }\n "}, {"sha": "266cc595ba6199d6b75a42b597c4d83d546643cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -1,3 +1,14 @@\n+2007-07-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/32245\n+\t* g++.dg/init/ptrmem4.C: New test.\n+\n+\tPR c++/32251\n+\t* g++.dg/init/new21.C: Likewise.\n+\n+\tPR c++/31992\n+\t* g++.dg/template/static30.C: Likewise.\n+\n 2007-07-05  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect/costmodel/ppc: New directory."}, {"sha": "5797ea981c0797578e8e09e728725e67f8b22e06", "filename": "gcc/testsuite/g++.dg/init/new21.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew21.C?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/32251\n+\n+struct A {\n+  A();\n+  void operator delete(void *, ...);\n+};\n+\n+void foo () {\n+  new A; // { dg-warning \"deallocation\" }\n+}"}, {"sha": "44ab8cf652916ced72a9e1b6fdbb993455c8f318", "filename": "gcc/testsuite/g++.dg/init/ptrmem4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fptrmem4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fptrmem4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fptrmem4.C?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/32245\n+// { dg-do run } \n+\n+struct foo {\n+  int mem1;\n+  int foo::* mem2;\n+};\n+\n+int main () {\n+  foo x = { 0 } ;\n+  if (x.mem2 != foo().mem2)\n+    return 1;\n+}"}, {"sha": "01fa5dc1e0ee544b39f7d42344d5616f4db7148a", "filename": "gcc/testsuite/g++.dg/template/static30.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a11c08863764dfd6a3be749c0729fee6cd298c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic30.C?ref=32a11c08863764dfd6a3be749c0729fee6cd298c", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/31992\n+\n+template <int> struct A \n+{\n+  static const int i1;\n+  static const int i2;\n+};\n+\n+template <int N> const int A<N>::i1(A<N>::i);\n+template <int N> const int A<N>::i2(3, A<N>::i);"}]}