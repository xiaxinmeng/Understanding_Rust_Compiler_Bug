{"sha": "9ccf6541557f9492c75dddd298edbeb74d90eecb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNjZjY1NDE1NTdmOTQ5MmM3NWRkZGQyOThlZGJlYjc0ZDkwZWVjYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-28T20:41:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-28T20:41:27Z"}, "message": "cp-tree.h (CLEAR_BINFO_NEW_VTABLE_MARKED): Remove.\n\n\t* cp-tree.h (CLEAR_BINFO_NEW_VTABLE_MARKED): Remove.\n\t* class.c (update_vtable_entry_for_fn): Correct logic for deciding\n\twhere to emit thunks.\n\t(build_vtt): Adjust call to build_vtt_inits.\n\t(build_vtt_inits): Add parameter to indicate whether or not\n\tsub-VTTs for virtual bases should be included.  Adjust handling of\n\tconstruction vtables.\n\t(get_matching_base): New function.\n\t(dfs_build_vtt_inits): Rename to ...\n\t(dfs_build_secondary_vptr_vtt_inits): Adjust handling of\n\tconstruction vtables.\n\t(dfs_fixup_binfo_vtbls): Likewise.\n\t(build_ctor_vtbl_groups): Build construction vtables for virtual\n\tbases, too.\n\t(accumulate_vtbl_inits): Tweak logic for deciding whether or not\n\tto build construction vtbls.\n\t(dfs_accumulate_vtbl_inits): Adjust handling of\n\tconstruction vtables.\n\n\t* pt.c (tsubst, case TEMPLATE_TEMPLATE_PARM): Handle cv-qualified\n\ttypes correctly.\n\nFrom-SVN: r34765", "tree": {"sha": "dcfde40786edc1f7e053127993fe997bdbd802b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcfde40786edc1f7e053127993fe997bdbd802b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ccf6541557f9492c75dddd298edbeb74d90eecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccf6541557f9492c75dddd298edbeb74d90eecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccf6541557f9492c75dddd298edbeb74d90eecb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccf6541557f9492c75dddd298edbeb74d90eecb/comments", "author": null, "committer": null, "parents": [{"sha": "6883b3aecacf6dd0dfe604f0b774ae583b5d7ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6883b3aecacf6dd0dfe604f0b774ae583b5d7ef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6883b3aecacf6dd0dfe604f0b774ae583b5d7ef5"}], "stats": {"total": 210, "additions": 145, "deletions": 65}, "files": [{"sha": "390bc1cca6c48a4e3f96c4b333de580db060b4e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9ccf6541557f9492c75dddd298edbeb74d90eecb", "patch": "@@ -1,3 +1,27 @@\n+2000-06-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CLEAR_BINFO_NEW_VTABLE_MARKED): Remove.\n+\t* class.c (update_vtable_entry_for_fn): Correct logic for deciding\n+\twhere to emit thunks.\n+\t(build_vtt): Adjust call to build_vtt_inits.\n+\t(build_vtt_inits): Add parameter to indicate whether or not\n+\tsub-VTTs for virtual bases should be included.  Adjust handling of\n+\tconstruction vtables.\n+\t(get_matching_base): New function.\n+\t(dfs_build_vtt_inits): Rename to ...\n+\t(dfs_build_secondary_vptr_vtt_inits): Adjust handling of\n+\tconstruction vtables.\n+\t(dfs_fixup_binfo_vtbls): Likewise.\n+\t(build_ctor_vtbl_groups): Build construction vtables for virtual\n+\tbases, too.\n+\t(accumulate_vtbl_inits): Tweak logic for deciding whether or not\n+\tto build construction vtbls.\n+\t(dfs_accumulate_vtbl_inits): Adjust handling of\n+\tconstruction vtables.\n+\n+\t* pt.c (tsubst, case TEMPLATE_TEMPLATE_PARM): Handle cv-qualified\n+\ttypes correctly.\n+\t\n 2000-06-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (grokfndecl): Set DECL_CONTEXT for static functions too."}, {"sha": "108e7d74b4a542e01ff9db194f02af3b7e6ac82e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 95, "deletions": 46, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9ccf6541557f9492c75dddd298edbeb74d90eecb", "patch": "@@ -190,10 +190,11 @@ static void update_vtable_entry_for_fn PARAMS ((tree, tree, tree, tree *));\n static tree copy_virtuals PARAMS ((tree));\n static void build_ctor_vtbl_group PARAMS ((tree, tree));\n static void build_vtt PARAMS ((tree));\n-static tree *build_vtt_inits PARAMS ((tree, tree, tree *, tree *));\n-static tree dfs_build_vtt_inits PARAMS ((tree, void *));\n+static tree *build_vtt_inits PARAMS ((tree, tree, int, tree *, tree *));\n+static tree dfs_build_secondary_vptr_vtt_inits PARAMS ((tree, void *));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n static int indirect_primary_base_p PARAMS ((tree, tree));\n+static tree get_matching_base PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -2643,7 +2644,7 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \n   /* Assume that we will produce a thunk that convert all the way to\n      the final overrider, and not to an intermediate virtual base.  */\n-  virtual_base  = NULL_TREE;\n+  virtual_base = NULL_TREE;\n \n   /* Assume that we will always generate thunks with the vtables that\n      reference them.  */\n@@ -2659,7 +2660,8 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t  /* If we find BINFO, then the final overrider is in a class\n \t     derived from BINFO, so the thunks can be generated with\n \t     the final overrider.  */\n-\t  if (same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n+\t  if (!virtual_base\n+\t      && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n \t    generate_thunk_with_vtable_p = 0;\n \n \t  /* If we find the final overrider, then we can stop\n@@ -6627,7 +6629,8 @@ build_vtt (t)\n   /* Build up the initializers for the VTT.  */\n   inits = NULL_TREE;\n   index = size_zero_node;\n-  build_vtt_inits (TYPE_BINFO (t), t, &inits, &index);\n+  build_vtt_inits (TYPE_BINFO (t), t, /*virtual_vtts_p=*/1, \n+\t\t   &inits, &index);\n \n   /* If we didn't need a VTT, we're done.  */\n   if (!inits)\n@@ -6643,15 +6646,45 @@ build_vtt (t)\n   initialize_array (vtt, inits);\n }\n \n+/* The type corresponding to BINFO is a base class of T, but BINFO is\n+   in the base class hierarchy of a class derived from T.  Return the\n+   base, in T's hierarchy, that corresponds to BINFO.  */\n+\n+static tree\n+get_matching_base (binfo, t)\n+     tree binfo;\n+     tree t;\n+{\n+  tree derived;\n+  int i;\n+\n+  if (same_type_p (BINFO_TYPE (binfo), t))\n+    return binfo;\n+\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    return binfo_for_vbase (BINFO_TYPE (binfo), t);\n+\n+  derived = get_matching_base (BINFO_INHERITANCE_CHAIN (binfo), t);\n+  for (i = 0; i < BINFO_N_BASETYPES (derived); ++i)\n+    if (same_type_p (BINFO_TYPE (BINFO_BASETYPE (derived, i)),\n+\t\t     BINFO_TYPE (binfo)))\n+      return BINFO_BASETYPE (derived, i);\n+\n+  my_friendly_abort (20000628);\n+  return NULL_TREE;\n+}\n+\n /* Recursively build the VTT-initializer for BINFO (which is in the\n-   hierarchy dominated by T).  INITS points to the end of the\n-   initializer list to date.  INDEX is the VTT index where the next\n-   element will be placed.  */\n+   hierarchy dominated by T).  If VIRTUAL_VTTS_P is non-zero, then\n+   sub-VTTs for virtual bases are included.  INITS points to the end\n+   of the initializer list to date.  INDEX is the VTT index where the\n+   next element will be placed.  */\n \n static tree *\n-build_vtt_inits (binfo, t, inits, index)\n+build_vtt_inits (binfo, t, virtual_vtts_p, inits, index)\n      tree binfo;\n      tree t;\n+     int virtual_vtts_p;\n      tree *inits;\n      tree *index;\n {\n@@ -6679,7 +6712,7 @@ build_vtt_inits (binfo, t, inits, index)\n   /* Add the address of the primary vtable for the complete object.  */\n   init = BINFO_VTABLE (binfo);\n   if (TREE_CODE (init) == TREE_LIST)\n-    init = TREE_PURPOSE (init);\n+    init = TREE_VALUE (init);\n   *inits = build_tree_list (NULL_TREE, init);\n   inits = &TREE_CHAIN (*inits);\n   BINFO_VPTR_INDEX (binfo) = *index;\n@@ -6690,23 +6723,23 @@ build_vtt_inits (binfo, t, inits, index)\n     {\n       b = BINFO_BASETYPE (binfo, i);\n       if (!TREE_VIA_VIRTUAL (b))\n-\tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, inits,\n-\t\t\t\t index);\n+\tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, \n+\t\t\t\t /*virtuals_vtts_p=*/0,\n+\t\t\t\t inits, index);\n     }\n       \n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or virtual functions overridden along a\n      virtual path between the declaration and D, except subobjects\n      that are non-virtual primary bases.  */\n-  secondary_vptrs = build_tree_list (BINFO_TYPE (binfo), NULL_TREE);\n+  secondary_vptrs = tree_cons (t, NULL_TREE, BINFO_TYPE (binfo));\n   TREE_TYPE (secondary_vptrs) = *index;\n   dfs_walk_real (binfo,\n-\t\t dfs_build_vtt_inits,\n+\t\t dfs_build_secondary_vptr_vtt_inits,\n \t\t NULL,\n \t\t dfs_unmarked_real_bases_queue_p,\n \t\t secondary_vptrs);\n-  dfs_walk (binfo, dfs_fixup_binfo_vtbls, dfs_marked_real_bases_queue_p,\n-\t    BINFO_TYPE (binfo));\n+  dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n   *index = TREE_TYPE (secondary_vptrs);\n \n   /* The secondary vptrs come back in reverse order.  After we reverse\n@@ -6721,24 +6754,30 @@ build_vtt_inits (binfo, t, inits, index)\n     }\n \n   /* Add the secondary VTTs for virtual bases.  */\n-  for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n-    {\n-      tree vbase;\n-\n-      if (!TREE_VIA_VIRTUAL (b))\n-\tcontinue;\n+  if (virtual_vtts_p)\n+    for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n+      {\n+\ttree vbase;\n+\t\n+\tif (!TREE_VIA_VIRTUAL (b))\n+\t  continue;\n+\t\n+\tvbase = binfo_for_vbase (BINFO_TYPE (b), t);\n+\tinits = build_vtt_inits (vbase, t, /*virtual_vtts_p=*/0, \n+\t\t\t\t inits, index);\n+      }\n \n-      vbase = binfo_for_vbase (BINFO_TYPE (b), t);\n-      inits = build_vtt_inits (vbase, t, inits, index);\n-    }\n+  dfs_walk (binfo, dfs_fixup_binfo_vtbls,\n+\t    dfs_unmarked_real_bases_queue_p,\n+\t    build_tree_list (t, binfo));\n \n   return inits;\n }\n \n /* Called from build_vtt_inits via dfs_walk.  */\n \n static tree\n-dfs_build_vtt_inits (binfo, data)\n+dfs_build_secondary_vptr_vtt_inits (binfo, data)\n      tree binfo;\n      void *data;\n {\n@@ -6748,7 +6787,7 @@ dfs_build_vtt_inits (binfo, data)\n   tree index;\n \n   l = (tree) data;\n-  t = TREE_PURPOSE (l);\n+  t = TREE_CHAIN (l);\n \n   SET_BINFO_MARKED (binfo);\n \n@@ -6769,15 +6808,15 @@ dfs_build_vtt_inits (binfo, data)\n      virtual path.  The point is that given:\n \n        struct V { virtual void f(); int i; };\n-       struct C : public V { void f (); };\n+       struct C : public virtual V { void f (); };\n \n      when we constrct C we need a secondary vptr for V-in-C because we\n      don't know what the vcall offset for `f' should be.  If `V' ends\n      up in a different place in the complete object, then we'll need a\n      different vcall offset than that present in the normal V-in-C\n      vtable.  */\n   if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo))\n-      && !BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P (binfo))\n+      && !BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P (get_matching_base (binfo, t)))\n     return NULL_TREE;\n \n   /* Record the index where this secondary vptr can be found.  */\n@@ -6789,7 +6828,7 @@ dfs_build_vtt_inits (binfo, data)\n   /* Add the initializer for the secondary vptr itself.  */\n   init = BINFO_VTABLE (binfo);\n   if (TREE_CODE (init) == TREE_LIST)\n-    init = TREE_PURPOSE (init);\n+    init = TREE_VALUE (init);\n   TREE_VALUE (l) = tree_cons (NULL_TREE, init, TREE_VALUE (l));\n \n   return NULL_TREE;\n@@ -6800,7 +6839,7 @@ dfs_build_vtt_inits (binfo, data)\n static tree\n dfs_fixup_binfo_vtbls (binfo, data)\n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n   CLEAR_BINFO_MARKED (binfo);\n \n@@ -6810,8 +6849,10 @@ dfs_fixup_binfo_vtbls (binfo, data)\n \n   /* If we scribbled the construction vtable vptr into BINFO, clear it\n      out now.  */\n-  if (TREE_CODE (BINFO_VTABLE (binfo)) == TREE_LIST)\n-    BINFO_VTABLE (binfo) = TREE_VALUE (BINFO_VTABLE (binfo));\n+  if (TREE_CODE (BINFO_VTABLE (binfo)) == TREE_LIST\n+      && (TREE_PURPOSE (BINFO_VTABLE (binfo)) \n+\t  == TREE_VALUE ((tree) data)))\n+    BINFO_VTABLE (binfo) = TREE_CHAIN (BINFO_VTABLE (binfo));\n \n   return NULL_TREE;\n }\n@@ -6829,6 +6870,7 @@ build_ctor_vtbl_group (binfo, t)\n   tree vtbl;\n   tree inits;\n   tree id;\n+  tree vbase;\n \n   /* See if we've already create this construction vtable group.  */\n   if (flag_new_abi)\n@@ -6845,6 +6887,19 @@ build_ctor_vtbl_group (binfo, t)\n   list = build_tree_list (vtbl, NULL_TREE);\n   accumulate_vtbl_inits (binfo, TYPE_BINFO (TREE_TYPE (binfo)),\n \t\t\t binfo, t, list);\n+  for (vbase = TYPE_BINFO (TREE_TYPE (binfo)); \n+       vbase; \n+       vbase = TREE_CHAIN (vbase))\n+    {\n+      tree b;\n+\n+      if (!TREE_VIA_VIRTUAL (vbase))\n+\tcontinue;\n+\n+      b = binfo_for_vbase (BINFO_TYPE (vbase), t);\n+      accumulate_vtbl_inits (b, vbase, binfo, t, list);\n+    }\n+\n   inits = TREE_VALUE (list);\n \n   /* Figure out the type of the construction vtable.  */\n@@ -6886,7 +6941,9 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n   /* If we're building a construction vtable, we're not interested in\n      subobjects that don't require construction vtables.  */\n   if (ctor_vtbl_p \n-      && !TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n+      && !TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo))\n+      && !(BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P \n+\t   (get_matching_base (binfo, BINFO_TYPE (rtti_binfo)))))\n     return;\n \n   /* Build the initializers for the BINFO-in-T vtable.  */\n@@ -6929,16 +6986,8 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n      tree l;\n {\n   tree inits = NULL_TREE;\n-  int ctor_vtbl_p;\n-\n-  /* This is a construction vtable if the RTTI type is not the most\n-     derived type in the hierarchy.  */\n-  ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n-  if (BINFO_NEW_VTABLE_MARKED (binfo, t)\n-      /* We need a new vtable, even for a primary base, when we're\n-\t building a construction vtable.  */\n-      || (ctor_vtbl_p && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))))\n+  if (BINFO_NEW_VTABLE_MARKED (orig_binfo, t))\n     {\n       tree vtbl;\n       tree index;\n@@ -6963,14 +7012,14 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n       TREE_CONSTANT (vtbl) = 1;\n \n       /* For an ordinary vtable, set BINFO_VTABLE.  */\n-      if (!ctor_vtbl_p)\n+      if (same_type_p (BINFO_TYPE (rtti_binfo), t))\n \tBINFO_VTABLE (binfo) = vtbl;\n       /* For a construction vtable, we can't overwrite BINFO_VTABLE.\n \t So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will\n \t straighten this out.  */\n       else\n-\tBINFO_VTABLE (binfo) = build_tree_list (vtbl,\n-\t\t\t\t\t\tBINFO_VTABLE (binfo));\n+\tBINFO_VTABLE (binfo) = \n+\t  tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n     }\n \n   return inits;"}, {"sha": "9f8ba200415fcd2684110a9d351ba9a47708ecb3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9ccf6541557f9492c75dddd298edbeb74d90eecb", "patch": "@@ -1781,8 +1781,6 @@ struct lang_type\n    my_friendly_assert (!BINFO_PRIMARY_MARKED_P (B), 20000517),\t\t \\\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n \t\t       20000517))\n-#define CLEAR_BINFO_NEW_VTABLE_MARKED(B, C) \\\n-  (BINFO_NEW_VTABLE_MARKED (B, C) = 0)\n \n /* Nonzero means this class has done dfs_pushdecls.  */\n #define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)"}, {"sha": "e36d51b92367f1564758e4e5d441c4870a090dca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccf6541557f9492c75dddd298edbeb74d90eecb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9ccf6541557f9492c75dddd298edbeb74d90eecb", "patch": "@@ -6361,25 +6361,34 @@ tsubst (t, args, complain, in_decl)\n \t  {\n \t  case TEMPLATE_TYPE_PARM:\n \t  case TEMPLATE_TEMPLATE_PARM:\n-\t    r = copy_node (t);\n-\t    TEMPLATE_TYPE_PARM_INDEX (r)\n-\t      = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n-\t\t\t\t\t    r, levels);\n-\t    TYPE_STUB_DECL (r) = TYPE_NAME (r) = TEMPLATE_TYPE_DECL (r);\n-\t    TYPE_MAIN_VARIANT (r) = r;\n-\t    TYPE_POINTER_TO (r) = NULL_TREE;\n-\t    TYPE_REFERENCE_TO (r) = NULL_TREE;\n-\n-\t    if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n-\t\t&& TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n+\t    if (CP_TYPE_QUALS (t))\n \t      {\n-\t\ttree argvec = tsubst (TYPE_TI_ARGS (t), args,\n-\t\t\t\t      complain, in_decl); \n-\t\tif (argvec == error_mark_node)\n-\t\t  return error_mark_node;\n+\t\tr = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);\n+\t\tr = cp_build_qualified_type_real (r, CP_TYPE_QUALS (t),\n+\t\t\t\t\t\t  complain);\n+\t      }\n+\t    else\n+\t      {\n+\t\tr = copy_node (t);\n+\t\tTEMPLATE_TYPE_PARM_INDEX (r)\n+\t\t  = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n+\t\t\t\t\t\tr, levels);\n+\t\tTYPE_STUB_DECL (r) = TYPE_NAME (r) = TEMPLATE_TYPE_DECL (r);\n+\t\tTYPE_MAIN_VARIANT (r) = r;\n+\t\tTYPE_POINTER_TO (r) = NULL_TREE;\n+\t\tTYPE_REFERENCE_TO (r) = NULL_TREE;\n+\n+\t\tif (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n+\t\t    && TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n+\t\t  {\n+\t\t    tree argvec = tsubst (TYPE_TI_ARGS (t), args,\n+\t\t\t\t\t  complain, in_decl); \n+\t\t    if (argvec == error_mark_node)\n+\t\t      return error_mark_node;\n \n-\t\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n-\t\t  = tree_cons (TYPE_TI_TEMPLATE (t), argvec, NULL_TREE);\n+\t\t    TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n+\t\t      = tree_cons (TYPE_TI_TEMPLATE (t), argvec, NULL_TREE);\n+\t\t  }\n \t      }\n \t    break;\n "}]}