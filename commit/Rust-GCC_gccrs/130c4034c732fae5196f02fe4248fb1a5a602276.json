{"sha": "130c4034c732fae5196f02fe4248fb1a5a602276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMwYzQwMzRjNzMyZmFlNTE5NmYwMmZlNDI0OGZiMWE1YTYwMjI3Ng==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-09-16T14:22:50Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-09-16T14:22:50Z"}, "message": "Rewrite first part of or_comparisons_1 into match.pd.\n\n2019-09-16  Martin Liska  <mliska@suse.cz>\n\n\t* gimple-fold.c (or_comparisons_1): Remove rules\n\tmoved to ...\n\t* match.pd: ... here.\n\nFrom-SVN: r275751", "tree": {"sha": "088f417550125e1cdfb40c14a47ae2d9cd696f73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/088f417550125e1cdfb40c14a47ae2d9cd696f73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/130c4034c732fae5196f02fe4248fb1a5a602276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130c4034c732fae5196f02fe4248fb1a5a602276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/130c4034c732fae5196f02fe4248fb1a5a602276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130c4034c732fae5196f02fe4248fb1a5a602276/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae9c3507829ca139749ac3f9cf4a78707a036d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9c3507829ca139749ac3f9cf4a78707a036d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9c3507829ca139749ac3f9cf4a78707a036d3b"}], "stats": {"total": 121, "additions": 35, "deletions": 86}, "files": [{"sha": "e70e09070c9f67bce1e3246abd2ccb4155524e5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/130c4034c732fae5196f02fe4248fb1a5a602276/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/130c4034c732fae5196f02fe4248fb1a5a602276/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=130c4034c732fae5196f02fe4248fb1a5a602276", "patch": "@@ -1,3 +1,9 @@\n+2019-09-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* gimple-fold.c (or_comparisons_1): Remove rules\n+\tmoved to ...\n+\t* match.pd: ... here.\n+\n 2019-09-16  Martin Liska  <mliska@suse.cz>\n \n \t* genmatch.c (dt_node::append_simplify): Do not print"}, {"sha": "694d2eeaae6113a5082f1a8812a16ae4d51ca076", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/130c4034c732fae5196f02fe4248fb1a5a602276/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/130c4034c732fae5196f02fe4248fb1a5a602276/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=130c4034c732fae5196f02fe4248fb1a5a602276", "patch": "@@ -6050,93 +6050,8 @@ or_comparisons_1 (tree type, enum tree_code code1, tree op1a, tree op1b,\n     {\n       int cmp = tree_int_cst_compare (op1b, op2b);\n \n-      /* If we have (op1a != op1b), we should either be able to\n-\t return that or TRUE, depending on whether the constant op1b\n-\t also satisfies the other comparison against op2b.  */\n-      if (code1 == NE_EXPR)\n-\t{\n-\t  bool done = true;\n-\t  bool val;\n-\t  switch (code2)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp < 0); break;\n-\t    case GT_EXPR: val = (cmp > 0); break;\n-\t    case LE_EXPR: val = (cmp <= 0); break;\n-\t    case GE_EXPR: val = (cmp >= 0); break;\n-\t    default: done = false;\n-\t    }\n-\t  if (done)\n-\t    {\n-\t      if (val)\n-\t\treturn boolean_true_node;\n-\t      else\n-\t\treturn fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t    }\n-\t}\n-      /* Likewise if the second comparison is a != comparison.  */\n-      else if (code2 == NE_EXPR)\n-\t{\n-\t  bool done = true;\n-\t  bool val;\n-\t  switch (code1)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp > 0); break;\n-\t    case GT_EXPR: val = (cmp < 0); break;\n-\t    case LE_EXPR: val = (cmp >= 0); break;\n-\t    case GE_EXPR: val = (cmp <= 0); break;\n-\t    default: done = false;\n-\t    }\n-\t  if (done)\n-\t    {\n-\t      if (val)\n-\t\treturn boolean_true_node;\n-\t      else\n-\t\treturn fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t    }\n-\t}\n-\n-      /* See if an equality test is redundant with the other comparison.  */\n-      else if (code1 == EQ_EXPR)\n-\t{\n-\t  bool val;\n-\t  switch (code2)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp < 0); break;\n-\t    case GT_EXPR: val = (cmp > 0); break;\n-\t    case LE_EXPR: val = (cmp <= 0); break;\n-\t    case GE_EXPR: val = (cmp >= 0); break;\n-\t    default:\n-\t      val = false;\n-\t    }\n-\t  if (val)\n-\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t}\n-      else if (code2 == EQ_EXPR)\n-\t{\n-\t  bool val;\n-\t  switch (code1)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp > 0); break;\n-\t    case GT_EXPR: val = (cmp < 0); break;\n-\t    case LE_EXPR: val = (cmp >= 0); break;\n-\t    case GE_EXPR: val = (cmp <= 0); break;\n-\t    default:\n-\t      val = false;\n-\t    }\n-\t  if (val)\n-\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t}\n-\n       /* Chose the less restrictive of two < or <= comparisons.  */\n-      else if ((code1 == LT_EXPR || code1 == LE_EXPR)\n+      if ((code1 == LT_EXPR || code1 == LE_EXPR)\n \t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n \t{\n \t  if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))"}, {"sha": "c465eabbb8991b1c1a29d8c8dc0e1ecce33e23f3", "filename": "gcc/match.pd", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/130c4034c732fae5196f02fe4248fb1a5a602276/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/130c4034c732fae5196f02fe4248fb1a5a602276/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=130c4034c732fae5196f02fe4248fb1a5a602276", "patch": "@@ -2024,6 +2024,34 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       { constant_boolean_node (false, type); })\n      )))))\n \n+/* Convert (X == CST1) || (X OP2 CST2) to a known value\n+   based on CST1 OP2 CST2.  Similarly for (X != CST1).  */\n+\n+(for code1 (eq ne)\n+ (for code2 (eq ne lt gt le ge)\n+  (simplify\n+   (bit_ior:c (code1@3 @0 INTEGER_CST@1) (code2@4 @0 INTEGER_CST@2))\n+    (with\n+     {\n+      int cmp = tree_int_cst_compare (@1, @2);\n+      bool val;\n+      switch (code2)\n+\t{\n+\tcase EQ_EXPR: val = (cmp == 0); break;\n+\tcase NE_EXPR: val = (cmp != 0); break;\n+\tcase LT_EXPR: val = (cmp < 0); break;\n+\tcase GT_EXPR: val = (cmp > 0); break;\n+\tcase LE_EXPR: val = (cmp <= 0); break;\n+\tcase GE_EXPR: val = (cmp >= 0); break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+     }\n+     (switch\n+      (if (code1 == EQ_EXPR && val) @4)\n+      (if (code1 == NE_EXPR && val) { constant_boolean_node (true, type); })\n+      (if (code1 == NE_EXPR && !val) @3))))))\n+\n+\n /* We can't reassociate at all for saturating types.  */\n (if (!TYPE_SATURATING (type))\n "}]}