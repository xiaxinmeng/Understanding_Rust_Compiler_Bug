{"sha": "6cf538daaead38a5bc09a79bfb26c34c83fec91e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmNTM4ZGFhZWFkMzhhNWJjMDlhNzliZmIyNmMzNGM4M2ZlYzkxZQ==", "commit": {"author": {"name": "Robert Suchanek", "email": "robert.suchanek@imgtec.com", "date": "2016-05-09T12:04:09Z"}, "committer": {"name": "Robert Suchanek", "email": "rts@gcc.gnu.org", "date": "2016-05-09T12:04:09Z"}, "message": "Add support for MIPS SIMD Architecture (MSA).\n\ngcc/\n\t* config.gcc: Add MSA header file for mips*-*-* target.\n\t* config/mips/constraints.md (YI, YC, YZ, Unv5, Uuv5, Usv5, Uuv6)\n\t(Ubv8i, Urv8):\tNew constraints.\n\t* config/mips/mips-ftypes.def: Add function types for MSA\n\tbuiltins.\n\t* config/mips/mips-modes.def (V16QI, V8HI, V4SI, V2DI, V4SF)\n\t(V2DF, V32QI, V16HI, V8SI, V4DI, V8SF, V4DF): New modes.\n\t* config/mips/mips-msa.md: New file.\n\t* config/mips/mips-protos.h\n\t(mips_split_128bit_const_insns): New prototype.\n\t(mips_msa_idiv_insns): Likewise.\n\t(mips_split_128bit_move): Likewise.\n\t(mips_split_128bit_move_p): Likewise.\n\t(mips_split_msa_copy_d): Likewise.\n\t(mips_split_msa_insert_d): Likewise.\n\t(mips_split_msa_fill_d): Likewise.\n\t(mips_expand_msa_branch): Likewise.\n\t(mips_const_vector_same_val_p): Likewise.\n\t(mips_const_vector_same_bytes_p): Likewise.\n\t(mips_const_vector_same_int_p): Likewise.\n\t(mips_const_vector_shuffle_set_p): Likewise.\n\t(mips_const_vector_bitimm_set_p): Likewise.\n\t(mips_const_vector_bitimm_clr_p): Likewise.\n\t(mips_msa_vec_parallel_const_half): Likewise.\n\t(mips_msa_output_division): Likewise.\n\t(mips_ldst_scaled_shift): Likewise.\n\t(mips_expand_vec_cond_expr): Likewise.\n\t* config/mips/mips.c (enum mips_builtin_type): Add\n\tMIPS_BUILTIN_MSA_TEST_BRANCH.\n\t(mips_gen_const_int_vector_shuffle): New prototype.\n\t(mips_const_vector_bitimm_set_p): New function.\n\t(mips_const_vector_bitimm_clr_p): Likewise.\n\t(mips_const_vector_same_val_p): Likewise.\n\t(mips_const_vector_same_bytes_p): Likewise.\n\t(mips_const_vector_same_int_p): Likewise.\n\t(mips_const_vector_shuffle_set_p): Likewise.\n\t(mips_symbol_insns): Forbid loading symbols via immediate for\n\tMSA.\n\t(mips_valid_offset_p): Limit offset to 10-bit for MSA loads and\n\tstores.\n\t(mips_valid_lo_sum_p): Forbid loadings symbols via %lo(base) for\n\tMSA.\n\t(mips_lx_address_p): Add support load indexed address for MSA.\n\t(mips_address_insns): Add calculation of instructions needed for\n\tstores and loads for MSA.\n\t(mips_const_insns): Move CONST_DOUBLE below CONST_VECTOR.  Handle\n\tCONST_VECTOR for MSA and let it fall through.\n\t(mips_ldst_scaled_shift): New function.\n\t(mips_subword_at_byte): Likewise.\n\t(mips_msa_idiv_insns): Likewise.\n\t(mips_legitimize_move): Validate MSA moves.\n\t(mips_rtx_costs): Add UNGE, UNGT, UNLE, UNLT cases.  Add\n\tcalculation of costs for MSA division.\n\t(mips_split_move_p): Check if MSA moves need splitting.\n\t(mips_split_move): Split MSA moves if necessary.\n\t(mips_split_128bit_move_p): New function.\n\t(mips_split_128bit_move): Likewise.\n\t(mips_split_msa_copy_d): Likewise.\n\t(mips_split_msa_insert_d): Likewise.\n\t(mips_split_msa_fill_d): Likewise.\n\t(mips_output_move): Handle MSA moves.\n\t(mips_expand_msa_branch): New function.\n\t(mips_print_operand): Add 'E', 'B', 'w', 'v' and 'V' modifiers.\n\tReinstate 'y' modifier.\n\t(mips_file_start): Add MSA .gnu_attribute.\n\t(mips_hard_regno_mode_ok_p): Allow TImode and 128-bit vectors in\n\tFPRs.\n\t(mips_hard_regno_nregs): Always return 1 for MSA supported mode.\n\t(mips_class_max_nregs): Add register size for MSA supported mode.\n\t(mips_cannot_change_mode_class): Allow conversion between MSA\n\tvector modes and TImode.\n\t(mips_mode_ok_for_mov_fmt_p): Allow MSA to use move.v\n\tinstruction.\n\t(mips_secondary_reload_class): Force MSA loads/stores via memory.\n\t(mips_preferred_simd_mode): Add preffered modes for MSA.\n\t(mips_vector_mode_supported_p): Add MSA supported modes.\n\t(mips_autovectorize_vector_sizes): New function.\n\t(mips_msa_output_division): Likewise.\n\t(MSA_BUILTIN, MIPS_BUILTIN_DIRECT_NO_TARGET)\n\t(MSA_NO_TARGET_BUILTIN, MSA_BUILTIN_TEST_BRANCH): New macros.\n\t(CODE_FOR_msa_adds_s_b, CODE_FOR_msa_adds_s_h)\n\t(CODE_FOR_msa_adds_s_w, CODE_FOR_msa_adds_s_d)\n\t(CODE_FOR_msa_adds_u_b, CODE_FOR_msa_adds_u_h)\n\t(CODE_FOR_msa_adds_u_w, CODE_FOR_msa_adds_u_du\n\t(CODE_FOR_msa_addv_b, CODE_FOR_msa_addv_h, CODE_FOR_msa_addv_w)\n\t(CODE_FOR_msa_addv_d, CODE_FOR_msa_and_v, CODE_FOR_msa_bmnz_v)\n\t(CODE_FOR_msa_bmnzi_b, CODE_FOR_msa_bmz_v, CODE_FOR_msa_bmzi_b)\n\t(CODE_FOR_msa_bnz_v, CODE_FOR_msa_bz_v, CODE_FOR_msa_bsel_v)\n\t(CODE_FOR_msa_bseli_b, CODE_FOR_msa_ceqi_h, CODE_FOR_msa_ceqi_w)\n\t(CODE_FOR_msa_ceqi_d, CODE_FOR_msa_clti_s_b)\n\t(CODE_FOR_msa_clti_s_h, CODE_FOR_msa_clti_s_w)\n\t(CODE_FOR_msa_clti_s_d, CODE_FOR_msa_clti_u_b)\n\t(CODE_FOR_msa_clti_u_h, CODE_FOR_msa_clti_u_w)\n\t(CODE_FOR_msa_clti_u_d, CODE_FOR_msa_clei_s_b)\n\t(CODE_FOR_msa_clei_s_h, CODE_FOR_msa_clei_s_w)\n\t(CODE_FOR_msa_clei_s_d, CODE_FOR_msa_clei_u_b)\n\t(CODE_FOR_msa_clei_u_h, CODE_FOR_msa_clei_u_w)\n\t(CODE_FOR_msa_clei_u_d, CODE_FOR_msa_div_s_b)\n\t(CODE_FOR_msa_div_s_h, CODE_FOR_msa_div_s_w)\n\t(CODE_FOR_msa_div_s_d, CODE_FOR_msa_div_u_b)\n\t(CODE_FOR_msa_div_u_h, CODE_FOR_msa_div_u_w)\n\t(CODE_FOR_msa_div_u_d, CODE_FOR_msa_fadd_w, CODE_FOR_msa_fadd_d)\n\t(CODE_FOR_msa_fexdo_w, CODE_FOR_msa_ftrunc_s_w)\n\t(CODE_FOR_msa_ftrunc_s_d, CODE_FOR_msa_ftrunc_u_w)\n\t(CODE_FOR_msa_ftrunc_u_d, CODE_FOR_msa_ffint_s_w)\n\t(CODE_FOR_msa_ffint_s_d, CODE_FOR_msa_ffint_u_w)\n\t(CODE_FOR_msa_ffint_u_d, CODE_FOR_msa_fsub_w)\n\t(CODE_FOR_msa_fsub_d, CODE_FOR_msa_fmsub_d, CODE_FOR_msa_fmadd_w)\n\t(CODE_FOR_msa_fmadd_d, CODE_FOR_msa_fmsub_w, CODE_FOR_msa_fmul_w)\n\t(CODE_FOR_msa_fmul_d, CODE_FOR_msa_fdiv_w, CODE_FOR_msa_fdiv_d)\n\t(CODE_FOR_msa_fmax_w, CODE_FOR_msa_fmax_d, CODE_FOR_msa_fmax_a_w)\n\t(CODE_FOR_msa_fmax_a_d, CODE_FOR_msa_fmin_w, CODE_FOR_msa_fmin_d)\n\t(CODE_FOR_msa_fmin_a_w, CODE_FOR_msa_fmin_a_d)\n\t(CODE_FOR_msa_fsqrt_w, CODE_FOR_msa_fsqrt_d)\n\t(CODE_FOR_msa_max_s_b, CODE_FOR_msa_max_s_h)\n\t(CODE_FOR_msa_max_s_w, CODE_FOR_msa_max_s_d)\n\t(CODE_FOR_msa_max_u_b, CODE_FOR_msa_max_u_h)\n\t(CODE_FOR_msa_max_u_w, CODE_FOR_msa_max_u_d)\n\t(CODE_FOR_msa_min_s_b, CODE_FOR_msa_min_s_h)\n\t(CODE_FOR_msa_min_s_w, CODE_FOR_msa_min_s_d)\n\t(CODE_FOR_msa_min_u_b, CODE_FOR_msa_min_u_h)\n\t(CODE_FOR_msa_min_u_w, CODE_FOR_msa_min_u_d)\n\t(CODE_FOR_msa_mod_s_b, CODE_FOR_msa_mod_s_h)\n\t(CODE_FOR_msa_mod_s_w, CODE_FOR_msa_mod_s_d)\n\t(CODE_FOR_msa_mod_u_b, CODE_FOR_msa_mod_u_h)\n\t(CODE_FOR_msa_mod_u_w, CODE_FOR_msa_mod_u_d)\n\t(CODE_FOR_msa_mod_s_b, CODE_FOR_msa_mod_s_h)\n\t(CODE_FOR_msa_mod_s_w, CODE_FOR_msa_mod_s_d)\n\t(CODE_FOR_msa_mod_u_b, CODE_FOR_msa_mod_u_h)\n\t(CODE_FOR_msa_mod_u_w, CODE_FOR_msa_mod_u_d)\n\t(CODE_FOR_msa_mulv_b, CODE_FOR_msa_mulv_h, CODE_FOR_msa_mulv_w)\n\t(CODE_FOR_msa_mulv_d, CODE_FOR_msa_nlzc_b, CODE_FOR_msa_nlzc_h)\n\t(CODE_FOR_msa_nlzc_w, CODE_FOR_msa_nlzc_d, CODE_FOR_msa_nor_v)\n\t(CODE_FOR_msa_or_v, CODE_FOR_msa_ori_b, CODE_FOR_msa_nori_b)\n\t(CODE_FOR_msa_pcnt_b, CODE_FOR_msa_pcnt_h, CODE_FOR_msa_pcnt_w)\n\t(CODE_FOR_msa_pcnt_d, CODE_FOR_msa_xor_v, CODE_FOR_msa_xori_b)\n\t(CODE_FOR_msa_sll_b, CODE_FOR_msa_sll_h, CODE_FOR_msa_sll_w)\n\t(CODE_FOR_msa_sll_d, CODE_FOR_msa_slli_b, CODE_FOR_msa_slli_h)\n\t(CODE_FOR_msa_slli_w, CODE_FOR_msa_slli_d, CODE_FOR_msa_sra_b)\n\t(CODE_FOR_msa_sra_h, CODE_FOR_msa_sra_w, CODE_FOR_msa_sra_d)\n\t(CODE_FOR_msa_srai_b, CODE_FOR_msa_srai_h, CODE_FOR_msa_srai_w)\n\t(CODE_FOR_msa_srai_d, CODE_FOR_msa_srl_b, CODE_FOR_msa_srl_h)\n\t(CODE_FOR_msa_srl_w, CODE_FOR_msa_srl_d, CODE_FOR_msa_srli_b)\n\t(CODE_FOR_msa_srli_h, CODE_FOR_msa_srli_w, CODE_FOR_msa_srli_d)\n\t(CODE_FOR_msa_subv_b, CODE_FOR_msa_subv_h, CODE_FOR_msa_subv_w)\n\t(CODE_FOR_msa_subv_d, CODE_FOR_msa_subvi_b, CODE_FOR_msa_subvi_h)\n\t(CODE_FOR_msa_subvi_w, CODE_FOR_msa_subvi_d, CODE_FOR_msa_move_v)\n\t(CODE_FOR_msa_vshf_b, CODE_FOR_msa_vshf_h, CODE_FOR_msa_vshf_w)\n\t(CODE_FOR_msa_vshf_d, CODE_FOR_msa_ilvod_d, CODE_FOR_msa_ilvev_d)\n\t(CODE_FOR_msa_pckod_d, CODE_FOR_msa_pckdev_d, CODE_FOR_msa_ldi_b)\n\t(CODE_FOR_msa_ldi_hi, CODE_FOR_msa_ldi_w)\n\t(CODE_FOR_msa_ldi_d): New code_aliasing macros.\n\t(mips_builtins): Add MSA sll_b, sll_h, sll_w, sll_d, slli_b,\n\tslli_h,\tslli_w, slli_d, sra_b, sra_h, sra_w, sra_d, srai_b,\n\tsrai_h, srai_w,\tsrai_d, srar_b, srar_h, srar_w, srar_d, srari_b,\n\tsrari_h, srari_w, srari_d, srl_b, srl_h, srl_w, srl_d, srli_b,\n\tsrli_h, srli_w, srli_d, srlr_b, srlr_h, srlr_w, srlr_d, srlri_b,\n\tsrlri_h, srlri_w, srlri_d, bclr_b, bclr_h, bclr_w, bclr_d,\n\tbclri_b, bclri_h, bclri_w, bclri_d, bset_b, bset_h, bset_w,\n\tbset_d, bseti_b, bseti_h, bseti_w, bseti_d, bneg_b, bneg_h,\n\tbneg_w, bneg_d, bnegi_b, bnegi_h, bnegi_w, bnegi_d, binsl_b,\n\tbinsl_h, binsl_w, binsl_d, binsli_b, binsli_h, binsli_w,\n\tbinsli_d, binsr_b, binsr_h, binsr_w, binsr_d, binsri_b, binsri_h,\n\tbinsri_w, binsri_d, addv_b, addv_h, addv_w, addv_d, addvi_b,\n\taddvi_h, addvi_w, addvi_d, subv_b, subv_h, subv_w, subv_d,\n\tsubvi_b, subvi_h, subvi_w, subvi_d, max_s_b, max_s_h, max_s_w,\n\tmax_s_d, maxi_s_b, maxi_s_h, maxi_s_w, maxi_s_d, max_u_b,\n\tmax_u_h, max_u_w, max_u_d, maxi_u_b, maxi_u_h, maxi_u_w,\n\tmaxi_u_d, min_s_b, min_s_h, min_s_w, min_s_d, mini_s_b, mini_s_h,\n\tmini_s_w, mini_s_d, min_u_b, min_u_h, min_u_w, min_u_d, mini_u_b,\n\tmini_u_h, mini_u_w, mini_u_d, max_a_b, max_a_h, max_a_w, max_a_d,\n\tmin_a_b, min_a_h, min_a_w, min_a_d, ceq_b, ceq_h, ceq_w, ceq_d,\n\tceqi_b, ceqi_h, ceqi_w, ceqi_d, clt_s_b, clt_s_h, clt_s_w,\n\tclt_s_d, clti_s_b, clti_s_h, clti_s_w, clti_s_d, clt_u_b,\n\tclt_u_h, clt_u_w, clt_u_d, clti_u_b, clti_u_h, clti_u_w,\n\tclti_u_d, cle_s_b, cle_s_h, cle_s_w, cle_s_d, clei_s_b, clei_s_h,\n\tclei_s_w, clei_s_d, cle_u_b, cle_u_h, cle_u_w, cle_u_d, clei_u_b,\n\tclei_u_h, clei_u_w, clei_u_d, ld_b, ld_h, ld_w, ld_d, st_b, st_h,\n\tst_w, st_d, sat_s_b, sat_s_h, sat_s_w, sat_s_d, sat_u_b, sat_u_h,\n\tsat_u_w, sat_u_d, add_a_b, add_a_h, add_a_w, add_a_d, adds_a_b,\n\tadds_a_h, adds_a_w, adds_a_d, adds_s_b, adds_s_h, adds_s_w,\n\tadds_s_d, adds_u_b, adds_u_h, adds_u_w, adds_u_d, ave_s_b,\n\tave_s_h, ave_s_w, ave_s_d, ave_u_b, ave_u_h, ave_u_w, ave_u_d,\n\taver_s_b, aver_s_h, aver_s_w, aver_s_d, aver_u_b, aver_u_h,\n\taver_u_w, aver_u_d, subs_s_b, subs_s_h, subs_s_w, subs_s_d,\n\tsubs_u_b, subs_u_h, subs_u_w, subs_u_d, subsuu_s_b, subsuu_s_h,\n\tsubsuu_s_w, subsuu_s_d, subsus_u_b, subsus_u_h, subsus_u_w,\n\tsubsus_u_d, asub_s_b, asub_s_h, asub_s_w, asub_s_d, asub_u_b,\n\tasub_u_h, asub_u_w, asub_u_d, mulv_b, mulv_h, mulv_w, mulv_d,\n\tmaddv_b, maddv_h, maddv_w, maddv_d, msubv_b, msubv_h, msubv_w,\n\tmsubv_d, div_s_b, div_s_h, div_s_w, div_s_d, div_u_b, div_u_h,\n\tdiv_u_w, div_u_d, hadd_s_h, hadd_s_w, hadd_s_d, hadd_u_h,\n\thadd_u_w, hadd_u_d, hsub_s_h, hsub_s_w, hsub_s_d, hsub_u_h,\n\thsub_u_w, hsub_u_d, mod_s_b, mod_s_h, mod_s_w, mod_s_d, mod_u_b,\n\tmod_u_h, mod_u_w, mod_u_d, dotp_s_h, dotp_s_w, dotp_s_d,\n\tdotp_u_h, dotp_u_w, dotp_u_d, dpadd_s_h, dpadd_s_w, dpadd_s_d,\n\tdpadd_u_h, dpadd_u_w, dpadd_u_d, dpsub_s_h, dpsub_s_w, dpsub_s_d,\n\tdpsub_u_h, dpsub_u_w, dpsub_u_d, sld_b, sld_h, sld_w, sld_d,\n\tsldi_b, sldi_h, sldi_w, sldi_d, splat_b, splat_h, splat_w,\n\tsplat_d, splati_b, splati_h, splati_w, splati_d, pckev_b,\n\tpckev_h, pckev_w, pckev_d, pckod_b, pckod_h, pckod_w, pckod_d,\n\tilvl_b, ilvl_h, ilvl_w, ilvl_d, ilvr_b, ilvr_h, ilvr_w, ilvr_d,\n\tilvev_b, ilvev_h, ilvev_w, ilvev_d, ilvod_b, ilvod_h, ilvod_w,\n\tilvod_d, vshf_b, vshf_h, vshf_w, vshf_d, and_v, andi_b, or_v,\n\tori_b, nor_v, nori_b, xor_v, xori_b, bmnz_v, bmnzi_b, bmz_v,\n\tbmzi_b, bsel_v, bseli_b, shf_b, shf_h, shf_w, bnz_v, bz_v,\n\tfill_b, fill_h, fill_w, fill_d, pcnt_b, pcnt_h, pcnt_w,\n\tpcnt_d, nloc_b, nloc_h, nloc_w, nloc_d, nlzc_b, nlzc_h, nlzc_w,\n\tnlzc_d, copy_s_b, copy_s_h, copy_s_w, copy_s_d, copy_u_b,\n\tcopy_u_h, copy_u_w, copy_u_d, insert_b, insert_h, insert_w,\n\tinsert_d, insve_b, insve_h, insve_w, insve_d, bnz_b, bnz_h,\n\tbnz_w, bnz_d, bz_b, bz_h, bz_w, bz_d, ldi_b, ldi_h, ldi_w, ldi_d,\n\tfcaf_w, fcaf_d, fcor_w, fcor_d, fcun_w, fcun_d, fcune_w, fcune_d,\n\tfcueq_w, fcueq_d, fceq_w, fceq_d, fcne_w, fcne_d, fclt_w, fclt_d,\n\tfcult_w, fcult_d, fcle_w, fcle_d, fcule_w, fcule_d, fsaf_w,\n\tfsaf_d, fsor_w, fsor_d, fsun_w, fsun_d, fsune_w, fsune_d,\n\tfsueq_w, fsueq_d, fseq_w, fseq_d, fsne_w, fsne_d, fslt_w,\n\tfslt_d, fsult_w, fsult_d, fsle_w, fsle_d, fsule_w, fsule_d,\n\tfadd_w,\tfadd_d, fsub_w, fsub_d, fmul_w, fmul_d, fdiv_w, fdiv_d,\n\tfmadd_w, fmadd_d, fmsub_w, fmsub_d, fexp2_w, fexp2_d, fexdo_h,\n\tfexdo_w, ftq_h, ftq_w, fmin_w, fmin_d, fmin_a_w, fmin_a_d,\n\tfmax_w, fmax_d, fmax_a_w, fmax_a_d, mul_q_h, mul_q_w, mulr_q_h,\n\tmulr_q_w, madd_q_h, madd_q_w, maddr_q_h, maddr_q_w, msub_q_h,\n\tmsub_q_w, msubr_q_h, msubr_q_w, fclass_w, fclass_d, fsqrt_w,\n\tfsqrt_d, frcp_w, frcp_d, frint_w, frint_d, frsqrt_w, frsqrt_d,\n\tflog2_w, flog2_d, fexupl_w, fexupl_d, fexupr_w, fexupr_d, ffql_w,\n\tffql_d, ffqr_w, ffqr_d, ftint_s_w, ftint_s_d, ftint_u_w,\n\tftint_u_d, ftrunc_s_w, ftrunc_s_d, ftrunc_u_w, ftrunc_u_d,\n\tffint_s_w, ffint_s_d, ffint_u_w, ffint_u_d, ctcmsa, cfcmsa,\n\tmove_v builtins.\n\t(mips_get_builtin_decl_index): New array.\n\t(MIPS_ATYPE_QI, MIPS_ATYPE_HI, MIPS_ATYPE_V2DI, MIPS_ATYPE_V4SI)\n\t(MIPS_ATYPE_V8HI, MIPS_ATYPE_V16QI, MIPS_ATYPE_V2DF)\n\t(MIPS_ATYPE_V4SF, MIPS_ATYPE_UV2DI, MIPS_ATYPE_UV4SI)\n\t(MIPS_ATYPE_UV8HI, MIPS_ATYPE_UV16QI): New.\n\t(mips_init_builtins): Initialize mips_get_builtin_decl_index\n\tarray.\n\t(TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION): Define target\n\thook.\n\t(mips_expand_builtin_insn): Prepare operands for\n\tCODE_FOR_msa_addvi_b, CODE_FOR_msa_addvi_h, CODE_FOR_msa_addvi_w,\n\tCODE_FOR_msa_addvi_d, CODE_FOR_msa_clti_u_b,\n\tCODE_FOR_msa_clti_u_h, CODE_FOR_msa_clti_u_w,\n\tCODE_FOR_msa_clti_u_d, CODE_FOR_msa_clei_u_b,\n\tCODE_FOR_msa_clei_u_h, CODE_FOR_msa_clei_u_w,\n\tCODE_FOR_msa_clei_u_d, CODE_FOR_msa_maxi_u_b,\n\tCODE_FOR_msa_maxi_u_h, CODE_FOR_msa_maxi_u_w,\n\tCODE_FOR_msa_maxi_u_d, CODE_FOR_msa_mini_u_b,\n\tCODE_FOR_msa_mini_u_h, CODE_FOR_msa_mini_u_w,\n\tCODE_FOR_msa_mini_u_d, CODE_FOR_msa_subvi_b,\n\tCODE_FOR_msa_subvi_h, CODE_FOR_msa_subvi_w, CODE_FOR_msa_subvi_d,\n\tCODE_FOR_msa_ceqi_b, CODE_FOR_msa_ceqi_h, CODE_FOR_msa_ceqi_w,\n\tCODE_FOR_msa_ceqi_d, CODE_FOR_msa_clti_s_b,\n\tCODE_FOR_msa_clti_s_h, CODE_FOR_msa_clti_s_w,\n\tCODE_FOR_msa_clti_s_d, CODE_FOR_msa_clei_s_b,\n\tCODE_FOR_msa_clei_s_h, CODE_FOR_msa_clei_s_w,\n\tCODE_FOR_msa_clei_s_d, CODE_FOR_msa_maxi_s_b,\n\tCODE_FOR_msa_maxi_s_h, CODE_FOR_msa_maxi_s_w,\n\tCODE_FOR_msa_maxi_s_d, CODE_FOR_msa_mini_s_b,\n\tCODE_FOR_msa_mini_s_h, CODE_FOR_msa_mini_s_w,\n\tCODE_FOR_msa_mini_s_d, CODE_FOR_msa_andi_b, CODE_FOR_msa_ori_b,\n\tCODE_FOR_msa_nori_b, CODE_FOR_msa_xori_b, CODE_FOR_msa_bmzi_b,\n\tCODE_FOR_msa_bmnzi_b, CODE_FOR_msa_bseli_b, CODE_FOR_msa_fill_b,\n\tCODE_FOR_msa_fill_h, CODE_FOR_msa_fill_w, CODE_FOR_msa_fill_d,\n\tCODE_FOR_msa_ilvl_b, CODE_FOR_msa_ilvl_h, CODE_FOR_msa_ilvl_w,\n\tCODE_FOR_msa_ilvl_d, CODE_FOR_msa_ilvr_b, CODE_FOR_msa_ilvr_h,\n\tCODE_FOR_msa_ilvr_w, CODE_FOR_msa_ilvr_d, CODE_FOR_msa_ilvev_b,\n\tCODE_FOR_msa_ilvev_h, CODE_FOR_msa_ilvev_w, CODE_FOR_msa_ilvod_b,\n\tCODE_FOR_msa_ilvod_h, CODE_FOR_msa_ilvod_w, CODE_FOR_msa_pckev_b,\n\tCODE_FOR_msa_pckev_h, CODE_FOR_msa_pckev_w, CODE_FOR_msa_pckod_b,\n\tCODE_FOR_msa_pckod_h, CODE_FOR_msa_pckod_w, CODE_FOR_msa_slli_b,\n\tCODE_FOR_msa_slli_h, CODE_FOR_msa_slli_w, CODE_FOR_msa_slli_d,\n\tCODE_FOR_msa_srai_b, CODE_FOR_msa_srai_h, CODE_FOR_msa_srai_w,\n\tCODE_FOR_msa_srai_d, CODE_FOR_msa_srli_b, CODE_FOR_msa_srli_h,\n\tCODE_FOR_msa_srli_w, CODE_FOR_msa_srli_d, CODE_FOR_msa_insert_b,\n\tCODE_FOR_msa_insert_h, CODE_FOR_msa_insert_w,\n\tCODE_FOR_msa_insert_d, CODE_FOR_msa_insve_b,\n\tCODE_FOR_msa_insve_h, CODE_FOR_msa_insve_w, CODE_FOR_msa_insve_d,\n\tCODE_FOR_msa_shf_b, CODE_FOR_msa_shf_h, CODE_FOR_msa_shf_w,\n\tCODE_FOR_msa_shf_w_f, CODE_FOR_msa_vshf_b, CODE_FOR_msa_vshf_h,\n\tCODE_FOR_msa_vshf_w, CODE_FOR_msa_vshf_d.\n\t(mips_expand_builtin): Add case for MIPS_BULTIN_MSA_TEST_BRANCH.\n\t(mips_set_compression_mode): Disallow MSA with MIPS16 code.\n\t(mips_option_override): -mmsa requires -mfp64 and -mhard-float.\n\tThese are set implicitly and an error is reported if overridden.\n\t(mips_expand_builtin_msa_test_branch): New function.\n\t(mips_expand_msa_shuffle): Likewise.\n\t(MAX_VECT_LEN): Increase maximum length of a vector to 16 bytes.\n\t(TARGET_SCHED_REASSOCIATION_WIDTH): Define target hook.\n\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Likewise.\n\t(mips_expand_vec_unpack): Add support for MSA.\n\t(mips_expand_vector_init): Likewise.\n\t(mips_expand_vi_constant): Use CONST0_RTX (element_mode)\n\tinstead of const0_rtx.\n\t(mips_msa_vec_parallel_const_half): New function.\n\t(mips_gen_const_int_vector): Likewise.\n\t(mips_gen_const_int_vector_shuffle): Likewise.\n\t(mips_expand_msa_cmp): Likewise.\n\t(mips_expand_vec_cond_expr): Likewise.\n\t* config/mips/mips.h\n\t(TARGET_CPU_CPP_BUILTINS): Add __mips_msa and __mips_msa_width.\n\t(OPTION_DEFAULT_SPECS): Ignore --with-fp-32 if -mmsa is\n\tspecified.\n\t(ASM_SPEC): Pass mmsa and mno-msa to the assembler.\n\t(ISA_HAS_MSA): New macro.\n\t(UNITS_PER_MSA_REG): Likewise.\n\t(BITS_PER_MSA_REG): Likewise.\n\t(BIGGEST_ALIGNMENT): Redefine using ISA_HAS_MSA.\n\t(MSA_REG_FIRST): New macro.\n\t(MSA_REG_LAST): Likewise.\n\t(MSA_REG_NUM): Likewise.\n\t(MSA_REG_P): Likewise.\n\t(MSA_REG_RTX_P): Likewise.\n\t(MSA_SUPPORTED_MODE_P): Likewise.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): Redefine using TARGET_MSA.\n\t(ADDITIONAL_REGISTER_NAMES): Add named registers $w0-$w31.\n\t* config/mips/mips.md: Include mips-msa.md.\n\t(alu_type): Add simd_add.\n\t(mode): Add V2DI, V4SI, V8HI, V16QI, V2DF, V4SF.\n\t(type): Add simd_div, simd_fclass, simd_flog2, simd_fadd,\n\tsimd_fcvt, simd_fmul, simd_fmadd, simd_fdiv, simd_bitins,\n\tsimd_bitmov, simd_insert, simd_sld, simd_mul, simd_fcmp,\n\tsimd_fexp2, simd_int_arith, simd_bit, simd_shift, simd_splat,\n\tsimd_fill, simd_permute, simd_shf, simd_sat, simd_pcnt,\n\tsimd_copy, simd_branch, simd_cmsa, simd_fminmax, simd_logic,\n\tsimd_move, simd_load, simd_store.  Choose \"multi\" for moves\n\tfor \"qword_mode\".\n\t(qword_mode): New attribute.\n\t(insn_count): Add instruction count for quad moves.\n\tIncrease the count for MIPS SIMD division.\n\t(UNITMODE): Add UNITMODEs for vector types.\n\t(addsub): New code iterator.\n\t* config/mips/mips.opt (mmsa): New option.\n\t* config/mips/msa.h: New file.\n\t* config/mips/mti-elf.h: Don't infer -mfpxx if -mmsa is\n\tspecified.\n\t* config/mips/mti-linux.h: Likewise.\n\t* config/mips/predicates.md\n\t(const_msa_branch_operand): New constraint.\n\t(const_uimm3_operand): Likewise.\n\t(const_uimm4_operand): Likewise.\n\t(const_uimm5_operand): Likewise.\n\t(const_uimm8_operand): Likewise.\n\t(const_imm5_operand): Likewise.\n\t(aq10b_operand): Likewise.\n\t(aq10h_operand): Likewise.\n\t(aq10w_operand): Likewise.\n\t(aq10d_operand): Likewise.\n\t(const_m1_operand): Likewise.\n\t(reg_or_m1_operand): Likewise.\n\t(const_exp_2_operand): Likewise.\n\t(const_exp_4_operand): Likewise.\n\t(const_exp_8_operand): Likewise.\n\t(const_exp_16_operand): Likewise.\n\t(const_vector_same_val_operand): Likewise.\n\t(const_vector_same_simm5_operand): Likewise.\n\t(const_vector_same_uimm5_operand): Likewise.\n\t(const_vector_same_uimm6_operand): Likewise.\n\t(const_vector_same_uimm8_operand): Likewise.\n\t(par_const_vector_shf_set_operand): Likewise.\n\t(reg_or_vector_same_val_operand): Likewise.\n\t(reg_or_vector_same_simm5_operand): Likewise.\n\t(reg_or_vector_same_uimm6_operand): Likewise.\n\t* doc/extend.texi (MIPS SIMD Architecture Functions): New\n\tsection.\n\t* doc/invoke.texi (-mmsa): Document new option.\n\nCo-Authored-By: Chao-ying Fu <chao-ying.fu@imgtec.com>\nCo-Authored-By: Graham Stott <graham.stott@imgtec.com>\nCo-Authored-By: Matthew Fortune <matthew.fortune@imgtec.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@imgtec.com>\n\nFrom-SVN: r236030", "tree": {"sha": "4db471861ec03139d8b8c2adbf6318334f91c622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db471861ec03139d8b8c2adbf6318334f91c622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf538daaead38a5bc09a79bfb26c34c83fec91e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf538daaead38a5bc09a79bfb26c34c83fec91e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf538daaead38a5bc09a79bfb26c34c83fec91e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf538daaead38a5bc09a79bfb26c34c83fec91e/comments", "author": null, "committer": null, "parents": [{"sha": "ad103b01538743f91ba51cfa51da273d34c901c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad103b01538743f91ba51cfa51da273d34c901c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad103b01538743f91ba51cfa51da273d34c901c4"}], "stats": {"total": 7235, "additions": 7166, "deletions": 69}, "files": [{"sha": "6928d0a8c19acdf112ef84f693725964fcdfe7f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -1,3 +1,376 @@\n+2016-05-09  Robert Suchanek  <robert.suchanek@imgtec.com>\n+\t    Sameera Deshpande  <sameera.deshpande@imgtec.com>\n+\t    Matthew Fortune  <matthew.fortune@imgtec.com>\n+\t    Graham Stott  <graham.stott@imgtec.com>\n+\t    Chao-ying Fu  <chao-ying.fu@imgtec.com>\n+\n+\t* config.gcc: Add MSA header file for mips*-*-* target.\n+\t* config/mips/constraints.md (YI, YC, YZ, Unv5, Uuv5, Usv5, Uuv6)\n+\t(Ubv8i, Urv8):\tNew constraints.\n+\t* config/mips/mips-ftypes.def: Add function types for MSA\n+\tbuiltins.\n+\t* config/mips/mips-modes.def (V16QI, V8HI, V4SI, V2DI, V4SF)\n+\t(V2DF, V32QI, V16HI, V8SI, V4DI, V8SF, V4DF): New modes.\n+\t* config/mips/mips-msa.md: New file.\n+\t* config/mips/mips-protos.h\n+\t(mips_split_128bit_const_insns): New prototype.\n+\t(mips_msa_idiv_insns): Likewise.\n+\t(mips_split_128bit_move): Likewise.\n+\t(mips_split_128bit_move_p): Likewise.\n+\t(mips_split_msa_copy_d): Likewise.\n+\t(mips_split_msa_insert_d): Likewise.\n+\t(mips_split_msa_fill_d): Likewise.\n+\t(mips_expand_msa_branch): Likewise.\n+\t(mips_const_vector_same_val_p): Likewise.\n+\t(mips_const_vector_same_bytes_p): Likewise.\n+\t(mips_const_vector_same_int_p): Likewise.\n+\t(mips_const_vector_shuffle_set_p): Likewise.\n+\t(mips_const_vector_bitimm_set_p): Likewise.\n+\t(mips_const_vector_bitimm_clr_p): Likewise.\n+\t(mips_msa_vec_parallel_const_half): Likewise.\n+\t(mips_msa_output_division): Likewise.\n+\t(mips_ldst_scaled_shift): Likewise.\n+\t(mips_expand_vec_cond_expr): Likewise.\n+\t* config/mips/mips.c (enum mips_builtin_type): Add\n+\tMIPS_BUILTIN_MSA_TEST_BRANCH.\n+\t(mips_gen_const_int_vector_shuffle): New prototype.\n+\t(mips_const_vector_bitimm_set_p): New function.\n+\t(mips_const_vector_bitimm_clr_p): Likewise.\n+\t(mips_const_vector_same_val_p): Likewise.\n+\t(mips_const_vector_same_bytes_p): Likewise.\n+\t(mips_const_vector_same_int_p): Likewise.\n+\t(mips_const_vector_shuffle_set_p): Likewise.\n+\t(mips_symbol_insns): Forbid loading symbols via immediate for\n+\tMSA.\n+\t(mips_valid_offset_p): Limit offset to 10-bit for MSA loads and\n+\tstores.\n+\t(mips_valid_lo_sum_p): Forbid loadings symbols via %lo(base) for\n+\tMSA.\n+\t(mips_lx_address_p): Add support load indexed address for MSA.\n+\t(mips_address_insns): Add calculation of instructions needed for\n+\tstores and loads for MSA.\n+\t(mips_const_insns): Move CONST_DOUBLE below CONST_VECTOR.  Handle\n+\tCONST_VECTOR for MSA and let it fall through.\n+\t(mips_ldst_scaled_shift): New function.\n+\t(mips_subword_at_byte): Likewise.\n+\t(mips_msa_idiv_insns): Likewise.\n+\t(mips_legitimize_move): Validate MSA moves.\n+\t(mips_rtx_costs): Add UNGE, UNGT, UNLE, UNLT cases.  Add\n+\tcalculation of costs for MSA division.\n+\t(mips_split_move_p): Check if MSA moves need splitting.\n+\t(mips_split_move): Split MSA moves if necessary.\n+\t(mips_split_128bit_move_p): New function.\n+\t(mips_split_128bit_move): Likewise.\n+\t(mips_split_msa_copy_d): Likewise.\n+\t(mips_split_msa_insert_d): Likewise.\n+\t(mips_split_msa_fill_d): Likewise.\n+\t(mips_output_move): Handle MSA moves.\n+\t(mips_expand_msa_branch): New function.\n+\t(mips_print_operand): Add 'E', 'B', 'w', 'v' and 'V' modifiers.\n+\tReinstate 'y' modifier.\n+\t(mips_file_start): Add MSA .gnu_attribute.\n+\t(mips_hard_regno_mode_ok_p): Allow TImode and 128-bit vectors in\n+\tFPRs.\n+\t(mips_hard_regno_nregs): Always return 1 for MSA supported mode.\n+\t(mips_class_max_nregs): Add register size for MSA supported mode.\n+\t(mips_cannot_change_mode_class): Allow conversion between MSA\n+\tvector modes and TImode.\n+\t(mips_mode_ok_for_mov_fmt_p): Allow MSA to use move.v\n+\tinstruction.\n+\t(mips_secondary_reload_class): Force MSA loads/stores via memory.\n+\t(mips_preferred_simd_mode): Add preffered modes for MSA.\n+\t(mips_vector_mode_supported_p): Add MSA supported modes.\n+\t(mips_autovectorize_vector_sizes): New function.\n+\t(mips_msa_output_division): Likewise.\n+\t(MSA_BUILTIN, MIPS_BUILTIN_DIRECT_NO_TARGET)\n+\t(MSA_NO_TARGET_BUILTIN, MSA_BUILTIN_TEST_BRANCH): New macros.\n+\t(CODE_FOR_msa_adds_s_b, CODE_FOR_msa_adds_s_h)\n+\t(CODE_FOR_msa_adds_s_w, CODE_FOR_msa_adds_s_d)\n+\t(CODE_FOR_msa_adds_u_b, CODE_FOR_msa_adds_u_h)\n+\t(CODE_FOR_msa_adds_u_w, CODE_FOR_msa_adds_u_du\n+\t(CODE_FOR_msa_addv_b, CODE_FOR_msa_addv_h, CODE_FOR_msa_addv_w)\n+\t(CODE_FOR_msa_addv_d, CODE_FOR_msa_and_v, CODE_FOR_msa_bmnz_v)\n+\t(CODE_FOR_msa_bmnzi_b, CODE_FOR_msa_bmz_v, CODE_FOR_msa_bmzi_b)\n+\t(CODE_FOR_msa_bnz_v, CODE_FOR_msa_bz_v, CODE_FOR_msa_bsel_v)\n+\t(CODE_FOR_msa_bseli_b, CODE_FOR_msa_ceqi_h, CODE_FOR_msa_ceqi_w)\n+\t(CODE_FOR_msa_ceqi_d, CODE_FOR_msa_clti_s_b)\n+\t(CODE_FOR_msa_clti_s_h, CODE_FOR_msa_clti_s_w)\n+\t(CODE_FOR_msa_clti_s_d, CODE_FOR_msa_clti_u_b)\n+\t(CODE_FOR_msa_clti_u_h, CODE_FOR_msa_clti_u_w)\n+\t(CODE_FOR_msa_clti_u_d, CODE_FOR_msa_clei_s_b)\n+\t(CODE_FOR_msa_clei_s_h, CODE_FOR_msa_clei_s_w)\n+\t(CODE_FOR_msa_clei_s_d, CODE_FOR_msa_clei_u_b)\n+\t(CODE_FOR_msa_clei_u_h, CODE_FOR_msa_clei_u_w)\n+\t(CODE_FOR_msa_clei_u_d, CODE_FOR_msa_div_s_b)\n+\t(CODE_FOR_msa_div_s_h, CODE_FOR_msa_div_s_w)\n+\t(CODE_FOR_msa_div_s_d, CODE_FOR_msa_div_u_b)\n+\t(CODE_FOR_msa_div_u_h, CODE_FOR_msa_div_u_w)\n+\t(CODE_FOR_msa_div_u_d, CODE_FOR_msa_fadd_w, CODE_FOR_msa_fadd_d)\n+\t(CODE_FOR_msa_fexdo_w, CODE_FOR_msa_ftrunc_s_w)\n+\t(CODE_FOR_msa_ftrunc_s_d, CODE_FOR_msa_ftrunc_u_w)\n+\t(CODE_FOR_msa_ftrunc_u_d, CODE_FOR_msa_ffint_s_w)\n+\t(CODE_FOR_msa_ffint_s_d, CODE_FOR_msa_ffint_u_w)\n+\t(CODE_FOR_msa_ffint_u_d, CODE_FOR_msa_fsub_w)\n+\t(CODE_FOR_msa_fsub_d, CODE_FOR_msa_fmsub_d, CODE_FOR_msa_fmadd_w)\n+\t(CODE_FOR_msa_fmadd_d, CODE_FOR_msa_fmsub_w, CODE_FOR_msa_fmul_w)\n+\t(CODE_FOR_msa_fmul_d, CODE_FOR_msa_fdiv_w, CODE_FOR_msa_fdiv_d)\n+\t(CODE_FOR_msa_fmax_w, CODE_FOR_msa_fmax_d, CODE_FOR_msa_fmax_a_w)\n+\t(CODE_FOR_msa_fmax_a_d, CODE_FOR_msa_fmin_w, CODE_FOR_msa_fmin_d)\n+\t(CODE_FOR_msa_fmin_a_w, CODE_FOR_msa_fmin_a_d)\n+\t(CODE_FOR_msa_fsqrt_w, CODE_FOR_msa_fsqrt_d)\n+\t(CODE_FOR_msa_max_s_b, CODE_FOR_msa_max_s_h)\n+\t(CODE_FOR_msa_max_s_w, CODE_FOR_msa_max_s_d)\n+\t(CODE_FOR_msa_max_u_b, CODE_FOR_msa_max_u_h)\n+\t(CODE_FOR_msa_max_u_w, CODE_FOR_msa_max_u_d)\n+\t(CODE_FOR_msa_min_s_b, CODE_FOR_msa_min_s_h)\n+\t(CODE_FOR_msa_min_s_w, CODE_FOR_msa_min_s_d)\n+\t(CODE_FOR_msa_min_u_b, CODE_FOR_msa_min_u_h)\n+\t(CODE_FOR_msa_min_u_w, CODE_FOR_msa_min_u_d)\n+\t(CODE_FOR_msa_mod_s_b, CODE_FOR_msa_mod_s_h)\n+\t(CODE_FOR_msa_mod_s_w, CODE_FOR_msa_mod_s_d)\n+\t(CODE_FOR_msa_mod_u_b, CODE_FOR_msa_mod_u_h)\n+\t(CODE_FOR_msa_mod_u_w, CODE_FOR_msa_mod_u_d)\n+\t(CODE_FOR_msa_mod_s_b, CODE_FOR_msa_mod_s_h)\n+\t(CODE_FOR_msa_mod_s_w, CODE_FOR_msa_mod_s_d)\n+\t(CODE_FOR_msa_mod_u_b, CODE_FOR_msa_mod_u_h)\n+\t(CODE_FOR_msa_mod_u_w, CODE_FOR_msa_mod_u_d)\n+\t(CODE_FOR_msa_mulv_b, CODE_FOR_msa_mulv_h, CODE_FOR_msa_mulv_w)\n+\t(CODE_FOR_msa_mulv_d, CODE_FOR_msa_nlzc_b, CODE_FOR_msa_nlzc_h)\n+\t(CODE_FOR_msa_nlzc_w, CODE_FOR_msa_nlzc_d, CODE_FOR_msa_nor_v)\n+\t(CODE_FOR_msa_or_v, CODE_FOR_msa_ori_b, CODE_FOR_msa_nori_b)\n+\t(CODE_FOR_msa_pcnt_b, CODE_FOR_msa_pcnt_h, CODE_FOR_msa_pcnt_w)\n+\t(CODE_FOR_msa_pcnt_d, CODE_FOR_msa_xor_v, CODE_FOR_msa_xori_b)\n+\t(CODE_FOR_msa_sll_b, CODE_FOR_msa_sll_h, CODE_FOR_msa_sll_w)\n+\t(CODE_FOR_msa_sll_d, CODE_FOR_msa_slli_b, CODE_FOR_msa_slli_h)\n+\t(CODE_FOR_msa_slli_w, CODE_FOR_msa_slli_d, CODE_FOR_msa_sra_b)\n+\t(CODE_FOR_msa_sra_h, CODE_FOR_msa_sra_w, CODE_FOR_msa_sra_d)\n+\t(CODE_FOR_msa_srai_b, CODE_FOR_msa_srai_h, CODE_FOR_msa_srai_w)\n+\t(CODE_FOR_msa_srai_d, CODE_FOR_msa_srl_b, CODE_FOR_msa_srl_h)\n+\t(CODE_FOR_msa_srl_w, CODE_FOR_msa_srl_d, CODE_FOR_msa_srli_b)\n+\t(CODE_FOR_msa_srli_h, CODE_FOR_msa_srli_w, CODE_FOR_msa_srli_d)\n+\t(CODE_FOR_msa_subv_b, CODE_FOR_msa_subv_h, CODE_FOR_msa_subv_w)\n+\t(CODE_FOR_msa_subv_d, CODE_FOR_msa_subvi_b, CODE_FOR_msa_subvi_h)\n+\t(CODE_FOR_msa_subvi_w, CODE_FOR_msa_subvi_d, CODE_FOR_msa_move_v)\n+\t(CODE_FOR_msa_vshf_b, CODE_FOR_msa_vshf_h, CODE_FOR_msa_vshf_w)\n+\t(CODE_FOR_msa_vshf_d, CODE_FOR_msa_ilvod_d, CODE_FOR_msa_ilvev_d)\n+\t(CODE_FOR_msa_pckod_d, CODE_FOR_msa_pckdev_d, CODE_FOR_msa_ldi_b)\n+\t(CODE_FOR_msa_ldi_hi, CODE_FOR_msa_ldi_w)\n+\t(CODE_FOR_msa_ldi_d): New code_aliasing macros.\n+\t(mips_builtins): Add MSA sll_b, sll_h, sll_w, sll_d, slli_b,\n+\tslli_h,\tslli_w, slli_d, sra_b, sra_h, sra_w, sra_d, srai_b,\n+\tsrai_h, srai_w,\tsrai_d, srar_b, srar_h, srar_w, srar_d, srari_b,\n+\tsrari_h, srari_w, srari_d, srl_b, srl_h, srl_w, srl_d, srli_b,\n+\tsrli_h, srli_w, srli_d, srlr_b, srlr_h, srlr_w, srlr_d, srlri_b,\n+\tsrlri_h, srlri_w, srlri_d, bclr_b, bclr_h, bclr_w, bclr_d,\n+\tbclri_b, bclri_h, bclri_w, bclri_d, bset_b, bset_h, bset_w,\n+\tbset_d, bseti_b, bseti_h, bseti_w, bseti_d, bneg_b, bneg_h,\n+\tbneg_w, bneg_d, bnegi_b, bnegi_h, bnegi_w, bnegi_d, binsl_b,\n+\tbinsl_h, binsl_w, binsl_d, binsli_b, binsli_h, binsli_w,\n+\tbinsli_d, binsr_b, binsr_h, binsr_w, binsr_d, binsri_b, binsri_h,\n+\tbinsri_w, binsri_d, addv_b, addv_h, addv_w, addv_d, addvi_b,\n+\taddvi_h, addvi_w, addvi_d, subv_b, subv_h, subv_w, subv_d,\n+\tsubvi_b, subvi_h, subvi_w, subvi_d, max_s_b, max_s_h, max_s_w,\n+\tmax_s_d, maxi_s_b, maxi_s_h, maxi_s_w, maxi_s_d, max_u_b,\n+\tmax_u_h, max_u_w, max_u_d, maxi_u_b, maxi_u_h, maxi_u_w,\n+\tmaxi_u_d, min_s_b, min_s_h, min_s_w, min_s_d, mini_s_b, mini_s_h,\n+\tmini_s_w, mini_s_d, min_u_b, min_u_h, min_u_w, min_u_d, mini_u_b,\n+\tmini_u_h, mini_u_w, mini_u_d, max_a_b, max_a_h, max_a_w, max_a_d,\n+\tmin_a_b, min_a_h, min_a_w, min_a_d, ceq_b, ceq_h, ceq_w, ceq_d,\n+\tceqi_b, ceqi_h, ceqi_w, ceqi_d, clt_s_b, clt_s_h, clt_s_w,\n+\tclt_s_d, clti_s_b, clti_s_h, clti_s_w, clti_s_d, clt_u_b,\n+\tclt_u_h, clt_u_w, clt_u_d, clti_u_b, clti_u_h, clti_u_w,\n+\tclti_u_d, cle_s_b, cle_s_h, cle_s_w, cle_s_d, clei_s_b, clei_s_h,\n+\tclei_s_w, clei_s_d, cle_u_b, cle_u_h, cle_u_w, cle_u_d, clei_u_b,\n+\tclei_u_h, clei_u_w, clei_u_d, ld_b, ld_h, ld_w, ld_d, st_b, st_h,\n+\tst_w, st_d, sat_s_b, sat_s_h, sat_s_w, sat_s_d, sat_u_b, sat_u_h,\n+\tsat_u_w, sat_u_d, add_a_b, add_a_h, add_a_w, add_a_d, adds_a_b,\n+\tadds_a_h, adds_a_w, adds_a_d, adds_s_b, adds_s_h, adds_s_w,\n+\tadds_s_d, adds_u_b, adds_u_h, adds_u_w, adds_u_d, ave_s_b,\n+\tave_s_h, ave_s_w, ave_s_d, ave_u_b, ave_u_h, ave_u_w, ave_u_d,\n+\taver_s_b, aver_s_h, aver_s_w, aver_s_d, aver_u_b, aver_u_h,\n+\taver_u_w, aver_u_d, subs_s_b, subs_s_h, subs_s_w, subs_s_d,\n+\tsubs_u_b, subs_u_h, subs_u_w, subs_u_d, subsuu_s_b, subsuu_s_h,\n+\tsubsuu_s_w, subsuu_s_d, subsus_u_b, subsus_u_h, subsus_u_w,\n+\tsubsus_u_d, asub_s_b, asub_s_h, asub_s_w, asub_s_d, asub_u_b,\n+\tasub_u_h, asub_u_w, asub_u_d, mulv_b, mulv_h, mulv_w, mulv_d,\n+\tmaddv_b, maddv_h, maddv_w, maddv_d, msubv_b, msubv_h, msubv_w,\n+\tmsubv_d, div_s_b, div_s_h, div_s_w, div_s_d, div_u_b, div_u_h,\n+\tdiv_u_w, div_u_d, hadd_s_h, hadd_s_w, hadd_s_d, hadd_u_h,\n+\thadd_u_w, hadd_u_d, hsub_s_h, hsub_s_w, hsub_s_d, hsub_u_h,\n+\thsub_u_w, hsub_u_d, mod_s_b, mod_s_h, mod_s_w, mod_s_d, mod_u_b,\n+\tmod_u_h, mod_u_w, mod_u_d, dotp_s_h, dotp_s_w, dotp_s_d,\n+\tdotp_u_h, dotp_u_w, dotp_u_d, dpadd_s_h, dpadd_s_w, dpadd_s_d,\n+\tdpadd_u_h, dpadd_u_w, dpadd_u_d, dpsub_s_h, dpsub_s_w, dpsub_s_d,\n+\tdpsub_u_h, dpsub_u_w, dpsub_u_d, sld_b, sld_h, sld_w, sld_d,\n+\tsldi_b, sldi_h, sldi_w, sldi_d, splat_b, splat_h, splat_w,\n+\tsplat_d, splati_b, splati_h, splati_w, splati_d, pckev_b,\n+\tpckev_h, pckev_w, pckev_d, pckod_b, pckod_h, pckod_w, pckod_d,\n+\tilvl_b, ilvl_h, ilvl_w, ilvl_d, ilvr_b, ilvr_h, ilvr_w, ilvr_d,\n+\tilvev_b, ilvev_h, ilvev_w, ilvev_d, ilvod_b, ilvod_h, ilvod_w,\n+\tilvod_d, vshf_b, vshf_h, vshf_w, vshf_d, and_v, andi_b, or_v,\n+\tori_b, nor_v, nori_b, xor_v, xori_b, bmnz_v, bmnzi_b, bmz_v,\n+\tbmzi_b, bsel_v, bseli_b, shf_b, shf_h, shf_w, bnz_v, bz_v,\n+\tfill_b, fill_h, fill_w, fill_d, pcnt_b, pcnt_h, pcnt_w,\n+\tpcnt_d, nloc_b, nloc_h, nloc_w, nloc_d, nlzc_b, nlzc_h, nlzc_w,\n+\tnlzc_d, copy_s_b, copy_s_h, copy_s_w, copy_s_d, copy_u_b,\n+\tcopy_u_h, copy_u_w, copy_u_d, insert_b, insert_h, insert_w,\n+\tinsert_d, insve_b, insve_h, insve_w, insve_d, bnz_b, bnz_h,\n+\tbnz_w, bnz_d, bz_b, bz_h, bz_w, bz_d, ldi_b, ldi_h, ldi_w, ldi_d,\n+\tfcaf_w, fcaf_d, fcor_w, fcor_d, fcun_w, fcun_d, fcune_w, fcune_d,\n+\tfcueq_w, fcueq_d, fceq_w, fceq_d, fcne_w, fcne_d, fclt_w, fclt_d,\n+\tfcult_w, fcult_d, fcle_w, fcle_d, fcule_w, fcule_d, fsaf_w,\n+\tfsaf_d, fsor_w, fsor_d, fsun_w, fsun_d, fsune_w, fsune_d,\n+\tfsueq_w, fsueq_d, fseq_w, fseq_d, fsne_w, fsne_d, fslt_w,\n+\tfslt_d, fsult_w, fsult_d, fsle_w, fsle_d, fsule_w, fsule_d,\n+\tfadd_w,\tfadd_d, fsub_w, fsub_d, fmul_w, fmul_d, fdiv_w, fdiv_d,\n+\tfmadd_w, fmadd_d, fmsub_w, fmsub_d, fexp2_w, fexp2_d, fexdo_h,\n+\tfexdo_w, ftq_h, ftq_w, fmin_w, fmin_d, fmin_a_w, fmin_a_d,\n+\tfmax_w, fmax_d, fmax_a_w, fmax_a_d, mul_q_h, mul_q_w, mulr_q_h,\n+\tmulr_q_w, madd_q_h, madd_q_w, maddr_q_h, maddr_q_w, msub_q_h,\n+\tmsub_q_w, msubr_q_h, msubr_q_w, fclass_w, fclass_d, fsqrt_w,\n+\tfsqrt_d, frcp_w, frcp_d, frint_w, frint_d, frsqrt_w, frsqrt_d,\n+\tflog2_w, flog2_d, fexupl_w, fexupl_d, fexupr_w, fexupr_d, ffql_w,\n+\tffql_d, ffqr_w, ffqr_d, ftint_s_w, ftint_s_d, ftint_u_w,\n+\tftint_u_d, ftrunc_s_w, ftrunc_s_d, ftrunc_u_w, ftrunc_u_d,\n+\tffint_s_w, ffint_s_d, ffint_u_w, ffint_u_d, ctcmsa, cfcmsa,\n+\tmove_v builtins.\n+\t(mips_get_builtin_decl_index): New array.\n+\t(MIPS_ATYPE_QI, MIPS_ATYPE_HI, MIPS_ATYPE_V2DI, MIPS_ATYPE_V4SI)\n+\t(MIPS_ATYPE_V8HI, MIPS_ATYPE_V16QI, MIPS_ATYPE_V2DF)\n+\t(MIPS_ATYPE_V4SF, MIPS_ATYPE_UV2DI, MIPS_ATYPE_UV4SI)\n+\t(MIPS_ATYPE_UV8HI, MIPS_ATYPE_UV16QI): New.\n+\t(mips_init_builtins): Initialize mips_get_builtin_decl_index\n+\tarray.\n+\t(TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION): Define target\n+\thook.\n+\t(mips_expand_builtin_insn): Prepare operands for\n+\tCODE_FOR_msa_addvi_b, CODE_FOR_msa_addvi_h, CODE_FOR_msa_addvi_w,\n+\tCODE_FOR_msa_addvi_d, CODE_FOR_msa_clti_u_b,\n+\tCODE_FOR_msa_clti_u_h, CODE_FOR_msa_clti_u_w,\n+\tCODE_FOR_msa_clti_u_d, CODE_FOR_msa_clei_u_b,\n+\tCODE_FOR_msa_clei_u_h, CODE_FOR_msa_clei_u_w,\n+\tCODE_FOR_msa_clei_u_d, CODE_FOR_msa_maxi_u_b,\n+\tCODE_FOR_msa_maxi_u_h, CODE_FOR_msa_maxi_u_w,\n+\tCODE_FOR_msa_maxi_u_d, CODE_FOR_msa_mini_u_b,\n+\tCODE_FOR_msa_mini_u_h, CODE_FOR_msa_mini_u_w,\n+\tCODE_FOR_msa_mini_u_d, CODE_FOR_msa_subvi_b,\n+\tCODE_FOR_msa_subvi_h, CODE_FOR_msa_subvi_w, CODE_FOR_msa_subvi_d,\n+\tCODE_FOR_msa_ceqi_b, CODE_FOR_msa_ceqi_h, CODE_FOR_msa_ceqi_w,\n+\tCODE_FOR_msa_ceqi_d, CODE_FOR_msa_clti_s_b,\n+\tCODE_FOR_msa_clti_s_h, CODE_FOR_msa_clti_s_w,\n+\tCODE_FOR_msa_clti_s_d, CODE_FOR_msa_clei_s_b,\n+\tCODE_FOR_msa_clei_s_h, CODE_FOR_msa_clei_s_w,\n+\tCODE_FOR_msa_clei_s_d, CODE_FOR_msa_maxi_s_b,\n+\tCODE_FOR_msa_maxi_s_h, CODE_FOR_msa_maxi_s_w,\n+\tCODE_FOR_msa_maxi_s_d, CODE_FOR_msa_mini_s_b,\n+\tCODE_FOR_msa_mini_s_h, CODE_FOR_msa_mini_s_w,\n+\tCODE_FOR_msa_mini_s_d, CODE_FOR_msa_andi_b, CODE_FOR_msa_ori_b,\n+\tCODE_FOR_msa_nori_b, CODE_FOR_msa_xori_b, CODE_FOR_msa_bmzi_b,\n+\tCODE_FOR_msa_bmnzi_b, CODE_FOR_msa_bseli_b, CODE_FOR_msa_fill_b,\n+\tCODE_FOR_msa_fill_h, CODE_FOR_msa_fill_w, CODE_FOR_msa_fill_d,\n+\tCODE_FOR_msa_ilvl_b, CODE_FOR_msa_ilvl_h, CODE_FOR_msa_ilvl_w,\n+\tCODE_FOR_msa_ilvl_d, CODE_FOR_msa_ilvr_b, CODE_FOR_msa_ilvr_h,\n+\tCODE_FOR_msa_ilvr_w, CODE_FOR_msa_ilvr_d, CODE_FOR_msa_ilvev_b,\n+\tCODE_FOR_msa_ilvev_h, CODE_FOR_msa_ilvev_w, CODE_FOR_msa_ilvod_b,\n+\tCODE_FOR_msa_ilvod_h, CODE_FOR_msa_ilvod_w, CODE_FOR_msa_pckev_b,\n+\tCODE_FOR_msa_pckev_h, CODE_FOR_msa_pckev_w, CODE_FOR_msa_pckod_b,\n+\tCODE_FOR_msa_pckod_h, CODE_FOR_msa_pckod_w, CODE_FOR_msa_slli_b,\n+\tCODE_FOR_msa_slli_h, CODE_FOR_msa_slli_w, CODE_FOR_msa_slli_d,\n+\tCODE_FOR_msa_srai_b, CODE_FOR_msa_srai_h, CODE_FOR_msa_srai_w,\n+\tCODE_FOR_msa_srai_d, CODE_FOR_msa_srli_b, CODE_FOR_msa_srli_h,\n+\tCODE_FOR_msa_srli_w, CODE_FOR_msa_srli_d, CODE_FOR_msa_insert_b,\n+\tCODE_FOR_msa_insert_h, CODE_FOR_msa_insert_w,\n+\tCODE_FOR_msa_insert_d, CODE_FOR_msa_insve_b,\n+\tCODE_FOR_msa_insve_h, CODE_FOR_msa_insve_w, CODE_FOR_msa_insve_d,\n+\tCODE_FOR_msa_shf_b, CODE_FOR_msa_shf_h, CODE_FOR_msa_shf_w,\n+\tCODE_FOR_msa_shf_w_f, CODE_FOR_msa_vshf_b, CODE_FOR_msa_vshf_h,\n+\tCODE_FOR_msa_vshf_w, CODE_FOR_msa_vshf_d.\n+\t(mips_expand_builtin): Add case for MIPS_BULTIN_MSA_TEST_BRANCH.\n+\t(mips_set_compression_mode): Disallow MSA with MIPS16 code.\n+\t(mips_option_override): -mmsa requires -mfp64 and -mhard-float.\n+\tThese are set implicitly and an error is reported if overridden.\n+\t(mips_expand_builtin_msa_test_branch): New function.\n+\t(mips_expand_msa_shuffle): Likewise.\n+\t(MAX_VECT_LEN): Increase maximum length of a vector to 16 bytes.\n+\t(TARGET_SCHED_REASSOCIATION_WIDTH): Define target hook.\n+\t(TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES): Likewise.\n+\t(mips_expand_vec_unpack): Add support for MSA.\n+\t(mips_expand_vector_init): Likewise.\n+\t(mips_expand_vi_constant): Use CONST0_RTX (element_mode)\n+\tinstead of const0_rtx.\n+\t(mips_msa_vec_parallel_const_half): New function.\n+\t(mips_gen_const_int_vector): Likewise.\n+\t(mips_gen_const_int_vector_shuffle): Likewise.\n+\t(mips_expand_msa_cmp): Likewise.\n+\t(mips_expand_vec_cond_expr): Likewise.\n+\t* config/mips/mips.h\n+\t(TARGET_CPU_CPP_BUILTINS): Add __mips_msa and __mips_msa_width.\n+\t(OPTION_DEFAULT_SPECS): Ignore --with-fp-32 if -mmsa is\n+\tspecified.\n+\t(ASM_SPEC): Pass mmsa and mno-msa to the assembler.\n+\t(ISA_HAS_MSA): New macro.\n+\t(UNITS_PER_MSA_REG): Likewise.\n+\t(BITS_PER_MSA_REG): Likewise.\n+\t(BIGGEST_ALIGNMENT): Redefine using ISA_HAS_MSA.\n+\t(MSA_REG_FIRST): New macro.\n+\t(MSA_REG_LAST): Likewise.\n+\t(MSA_REG_NUM): Likewise.\n+\t(MSA_REG_P): Likewise.\n+\t(MSA_REG_RTX_P): Likewise.\n+\t(MSA_SUPPORTED_MODE_P): Likewise.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): Redefine using TARGET_MSA.\n+\t(ADDITIONAL_REGISTER_NAMES): Add named registers $w0-$w31.\n+\t* config/mips/mips.md: Include mips-msa.md.\n+\t(alu_type): Add simd_add.\n+\t(mode): Add V2DI, V4SI, V8HI, V16QI, V2DF, V4SF.\n+\t(type): Add simd_div, simd_fclass, simd_flog2, simd_fadd,\n+\tsimd_fcvt, simd_fmul, simd_fmadd, simd_fdiv, simd_bitins,\n+\tsimd_bitmov, simd_insert, simd_sld, simd_mul, simd_fcmp,\n+\tsimd_fexp2, simd_int_arith, simd_bit, simd_shift, simd_splat,\n+\tsimd_fill, simd_permute, simd_shf, simd_sat, simd_pcnt,\n+\tsimd_copy, simd_branch, simd_cmsa, simd_fminmax, simd_logic,\n+\tsimd_move, simd_load, simd_store.  Choose \"multi\" for moves\n+\tfor \"qword_mode\".\n+\t(qword_mode): New attribute.\n+\t(insn_count): Add instruction count for quad moves.\n+\tIncrease the count for MIPS SIMD division.\n+\t(UNITMODE): Add UNITMODEs for vector types.\n+\t(addsub): New code iterator.\n+\t* config/mips/mips.opt (mmsa): New option.\n+\t* config/mips/msa.h: New file.\n+\t* config/mips/mti-elf.h: Don't infer -mfpxx if -mmsa is\n+\tspecified.\n+\t* config/mips/mti-linux.h: Likewise.\n+\t* config/mips/predicates.md\n+\t(const_msa_branch_operand): New constraint.\n+\t(const_uimm3_operand): Likewise.\n+\t(const_uimm4_operand): Likewise.\n+\t(const_uimm5_operand): Likewise.\n+\t(const_uimm8_operand): Likewise.\n+\t(const_imm5_operand): Likewise.\n+\t(aq10b_operand): Likewise.\n+\t(aq10h_operand): Likewise.\n+\t(aq10w_operand): Likewise.\n+\t(aq10d_operand): Likewise.\n+\t(const_m1_operand): Likewise.\n+\t(reg_or_m1_operand): Likewise.\n+\t(const_exp_2_operand): Likewise.\n+\t(const_exp_4_operand): Likewise.\n+\t(const_exp_8_operand): Likewise.\n+\t(const_exp_16_operand): Likewise.\n+\t(const_vector_same_val_operand): Likewise.\n+\t(const_vector_same_simm5_operand): Likewise.\n+\t(const_vector_same_uimm5_operand): Likewise.\n+\t(const_vector_same_uimm6_operand): Likewise.\n+\t(const_vector_same_uimm8_operand): Likewise.\n+\t(par_const_vector_shf_set_operand): Likewise.\n+\t(reg_or_vector_same_val_operand): Likewise.\n+\t(reg_or_vector_same_simm5_operand): Likewise.\n+\t(reg_or_vector_same_uimm6_operand): Likewise.\n+\t* doc/extend.texi (MIPS SIMD Architecture Functions): New\n+\tsection.\n+\t* doc/invoke.texi (-mmsa): Document new option.\n+\n 2016-05-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (enable_vtable_verify): Handle --enable-vtable-verify."}, {"sha": "51af122aafbee74fd8fdc18ab041a9cfffc6d529", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -427,7 +427,7 @@ microblaze*-*-*)\n         ;;\n mips*-*-*)\n \tcpu_type=mips\n-\textra_headers=\"loongson.h\"\n+\textra_headers=\"loongson.h msa.h\"\n \textra_objs=\"frame-header-opt.o\"\n \textra_options=\"${extra_options} g.opt fused-madd.opt mips/mips-tables.opt\"\n \t;;"}, {"sha": "56b363e699b7312d6c6cecd54f0a28ff2621aa2d", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -308,6 +308,61 @@\n    \"@internal\"\n    (match_operand 0 \"low_bitmask_operand\"))\n \n+(define_constraint \"YI\"\n+  \"@internal\n+   A replicated vector const in which the replicated value is in the range\n+   [-512,511].\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_same_int_p (op, mode, -512, 511)\")))\n+\n+(define_constraint \"YC\"\n+  \"@internal\n+   A replicated vector const in which the replicated value has a single\n+   bit set.\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_bitimm_set_p (op, mode)\")))\n+\n+(define_constraint \"YZ\"\n+  \"@internal\n+   A replicated vector const in which the replicated value has a single\n+   bit clear.\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_bitimm_clr_p (op, mode)\")))\n+\n+(define_constraint \"Unv5\"\n+  \"@internal\n+   A replicated vector const in which the replicated value is in the range\n+   [-31,0].\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_same_int_p (op, mode, -31, 0)\")))\n+\n+(define_constraint \"Uuv5\"\n+  \"@internal\n+   A replicated vector const in which the replicated value is in the range\n+   [0,31].\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_same_int_p (op, mode, 0, 31)\")))\n+\n+(define_constraint \"Usv5\"\n+  \"@internal\n+   A replicated vector const in which the replicated value is in the range\n+   [-16,15].\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_same_int_p (op, mode, -16, 15)\")))\n+\n+(define_constraint \"Uuv6\"\n+  \"@internal\n+   A replicated vector const in which the replicated value is in the range\n+   [0,63].\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_same_int_p (op, mode, 0, 63)\")))\n+\n+(define_constraint \"Urv8\"\n+  \"@internal\n+   A replicated vector const with replicated byte values as well as elements\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mips_const_vector_same_bytes_p (op, mode)\")))\n+\n (define_memory_constraint \"ZC\"\n   \"A memory operand whose address is formed by a base register and offset\n    that is suitable for use in instructions with the same addressing mode"}, {"sha": "69cf4379ed10ce884351d68774f0af7fefe59d86", "filename": "gcc/config/mips/mips-ftypes.def", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n    Please keep this list lexicographically sorted by the LIST argument.  */\n DEF_MIPS_FTYPE (1, (DF, DF))\n DEF_MIPS_FTYPE (2, (DF, DF, DF))\n+DEF_MIPS_FTYPE (1, (DF, V2DF))\n \n DEF_MIPS_FTYPE (2, (DI, DI, DI))\n DEF_MIPS_FTYPE (2, (DI, DI, SI))\n@@ -45,6 +46,7 @@ DEF_MIPS_FTYPE (3, (DI, DI, V4QI, V4QI))\n DEF_MIPS_FTYPE (2, (DI, POINTER, SI))\n DEF_MIPS_FTYPE (2, (DI, SI, SI))\n DEF_MIPS_FTYPE (2, (DI, USI, USI))\n+DEF_MIPS_FTYPE (2, (DI, V2DI, UQI))\n \n DEF_MIPS_FTYPE (2, (INT, DF, DF))\n DEF_MIPS_FTYPE (2, (INT, SF, SF))\n@@ -54,23 +56,51 @@ DEF_MIPS_FTYPE (4, (INT, V2SF, V2SF, V2SF, V2SF))\n DEF_MIPS_FTYPE (1, (SF, SF))\n DEF_MIPS_FTYPE (2, (SF, SF, SF))\n DEF_MIPS_FTYPE (1, (SF, V2SF))\n+DEF_MIPS_FTYPE (1, (SF, V4SF))\n \n DEF_MIPS_FTYPE (2, (SI, DI, SI))\n DEF_MIPS_FTYPE (2, (SI, POINTER, SI))\n DEF_MIPS_FTYPE (1, (SI, SI))\n DEF_MIPS_FTYPE (2, (SI, SI, SI))\n DEF_MIPS_FTYPE (3, (SI, SI, SI, SI))\n+DEF_MIPS_FTYPE (1, (SI, UQI))\n+DEF_MIPS_FTYPE (1, (SI, UV16QI))\n+DEF_MIPS_FTYPE (1, (SI, UV2DI))\n+DEF_MIPS_FTYPE (1, (SI, UV4SI))\n+DEF_MIPS_FTYPE (1, (SI, UV8HI))\n+DEF_MIPS_FTYPE (2, (SI, V16QI, UQI))\n DEF_MIPS_FTYPE (1, (SI, V2HI))\n DEF_MIPS_FTYPE (2, (SI, V2HI, V2HI))\n DEF_MIPS_FTYPE (1, (SI, V4QI))\n DEF_MIPS_FTYPE (2, (SI, V4QI, V4QI))\n+DEF_MIPS_FTYPE (2, (SI, V4SI, UQI))\n+DEF_MIPS_FTYPE (2, (SI, V8HI, UQI))\n DEF_MIPS_FTYPE (1, (SI, VOID))\n \n DEF_MIPS_FTYPE (2, (UDI, UDI, UDI))\n DEF_MIPS_FTYPE (2, (UDI, UV2SI, UV2SI))\n+DEF_MIPS_FTYPE (2, (UDI, V2DI, UQI))\n \n+DEF_MIPS_FTYPE (2, (USI, V16QI, UQI))\n+DEF_MIPS_FTYPE (2, (USI, V4SI, UQI))\n+DEF_MIPS_FTYPE (2, (USI, V8HI, UQI))\n DEF_MIPS_FTYPE (1, (USI, VOID))\n \n+DEF_MIPS_FTYPE (2, (UV16QI, UV16QI, UQI))\n+DEF_MIPS_FTYPE (2, (UV16QI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (3, (UV16QI, UV16QI, UV16QI, UQI))\n+DEF_MIPS_FTYPE (3, (UV16QI, UV16QI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (2, (UV16QI, UV16QI, V16QI))\n+\n+DEF_MIPS_FTYPE (2, (UV2DI, UV2DI, UQI))\n+DEF_MIPS_FTYPE (2, (UV2DI, UV2DI, UV2DI))\n+DEF_MIPS_FTYPE (3, (UV2DI, UV2DI, UV2DI, UQI))\n+DEF_MIPS_FTYPE (3, (UV2DI, UV2DI, UV2DI, UV2DI))\n+DEF_MIPS_FTYPE (3, (UV2DI, UV2DI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (2, (UV2DI, UV2DI, V2DI))\n+DEF_MIPS_FTYPE (2, (UV2DI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (1, (UV2DI, V2DF))\n+\n DEF_MIPS_FTYPE (2, (UV2SI, UV2SI, UQI))\n DEF_MIPS_FTYPE (2, (UV2SI, UV2SI, UV2SI))\n \n@@ -82,10 +112,75 @@ DEF_MIPS_FTYPE (3, (UV4HI, UV4HI, UV4HI, USI))\n DEF_MIPS_FTYPE (1, (UV4HI, UV8QI))\n DEF_MIPS_FTYPE (2, (UV4HI, UV8QI, UV8QI))\n \n+DEF_MIPS_FTYPE (2, (UV4SI, UV4SI, UQI))\n+DEF_MIPS_FTYPE (2, (UV4SI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (3, (UV4SI, UV4SI, UV4SI, UQI))\n+DEF_MIPS_FTYPE (3, (UV4SI, UV4SI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (3, (UV4SI, UV4SI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (2, (UV4SI, UV4SI, V4SI))\n+DEF_MIPS_FTYPE (2, (UV4SI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (1, (UV4SI, V4SF))\n+\n+DEF_MIPS_FTYPE (2, (UV8HI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (2, (UV8HI, UV8HI, UQI))\n+DEF_MIPS_FTYPE (3, (UV8HI, UV8HI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (2, (UV8HI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (3, (UV8HI, UV8HI, UV8HI, UQI))\n+DEF_MIPS_FTYPE (3, (UV8HI, UV8HI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (2, (UV8HI, UV8HI, V8HI))\n+\n DEF_MIPS_FTYPE (2, (UV8QI, UV4HI, UV4HI))\n DEF_MIPS_FTYPE (1, (UV8QI, UV8QI))\n DEF_MIPS_FTYPE (2, (UV8QI, UV8QI, UV8QI))\n \n+DEF_MIPS_FTYPE (2, (V16QI, CVPOINTER, SI))\n+DEF_MIPS_FTYPE (1, (V16QI, HI))\n+DEF_MIPS_FTYPE (1, (V16QI, SI))\n+DEF_MIPS_FTYPE (2, (V16QI, UV16QI, UQI))\n+DEF_MIPS_FTYPE (2, (V16QI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (1, (V16QI, V16QI))\n+DEF_MIPS_FTYPE (2, (V16QI, V16QI, QI))\n+DEF_MIPS_FTYPE (2, (V16QI, V16QI, SI))\n+DEF_MIPS_FTYPE (2, (V16QI, V16QI, UQI))\n+DEF_MIPS_FTYPE (3, (V16QI, V16QI, UQI, SI))\n+DEF_MIPS_FTYPE (3, (V16QI, V16QI, UQI, V16QI))\n+DEF_MIPS_FTYPE (2, (V16QI, V16QI, V16QI))\n+DEF_MIPS_FTYPE (3, (V16QI, V16QI, V16QI, SI))\n+DEF_MIPS_FTYPE (3, (V16QI, V16QI, V16QI, UQI))\n+DEF_MIPS_FTYPE (3, (V16QI, V16QI, V16QI, V16QI))\n+\n+DEF_MIPS_FTYPE (1, (V2DF, DF))\n+DEF_MIPS_FTYPE (1, (V2DF, UV2DI))\n+DEF_MIPS_FTYPE (1, (V2DF, V2DF))\n+DEF_MIPS_FTYPE (2, (V2DF, V2DF, V2DF))\n+DEF_MIPS_FTYPE (3, (V2DF, V2DF, V2DF, V2DF))\n+DEF_MIPS_FTYPE (2, (V2DF, V2DF, V2DI))\n+DEF_MIPS_FTYPE (1, (V2DF, V2DI))\n+DEF_MIPS_FTYPE (1, (V2DF, V4SF))\n+DEF_MIPS_FTYPE (1, (V2DF, V4SI))\n+\n+DEF_MIPS_FTYPE (2, (V2DI, CVPOINTER, SI))\n+DEF_MIPS_FTYPE (1, (V2DI, DI))\n+DEF_MIPS_FTYPE (1, (V2DI, HI))\n+DEF_MIPS_FTYPE (2, (V2DI, UV2DI, UQI))\n+DEF_MIPS_FTYPE (2, (V2DI, UV2DI, UV2DI))\n+DEF_MIPS_FTYPE (2, (V2DI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (1, (V2DI, V2DF))\n+DEF_MIPS_FTYPE (2, (V2DI, V2DF, V2DF))\n+DEF_MIPS_FTYPE (1, (V2DI, V2DI))\n+DEF_MIPS_FTYPE (2, (V2DI, V2DI, QI))\n+DEF_MIPS_FTYPE (2, (V2DI, V2DI, SI))\n+DEF_MIPS_FTYPE (2, (V2DI, V2DI, UQI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, UQI, DI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, UQI, V2DI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (2, (V2DI, V2DI, V2DI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, V2DI, SI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, V2DI, UQI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, V2DI, V2DI))\n+DEF_MIPS_FTYPE (3, (V2DI, V2DI, V4SI, V4SI))\n+DEF_MIPS_FTYPE (2, (V2DI, V4SI, V4SI))\n+\n DEF_MIPS_FTYPE (1, (V2HI, SI))\n DEF_MIPS_FTYPE (2, (V2HI, SI, SI))\n DEF_MIPS_FTYPE (3, (V2HI, SI, SI, SI))\n@@ -118,12 +213,74 @@ DEF_MIPS_FTYPE (1, (V4QI, V4QI))\n DEF_MIPS_FTYPE (2, (V4QI, V4QI, SI))\n DEF_MIPS_FTYPE (2, (V4QI, V4QI, V4QI))\n \n+DEF_MIPS_FTYPE (1, (V4SF, SF))\n+DEF_MIPS_FTYPE (1, (V4SF, UV4SI))\n+DEF_MIPS_FTYPE (2, (V4SF, V2DF, V2DF))\n+DEF_MIPS_FTYPE (1, (V4SF, V4SF))\n+DEF_MIPS_FTYPE (2, (V4SF, V4SF, V4SF))\n+DEF_MIPS_FTYPE (3, (V4SF, V4SF, V4SF, V4SF))\n+DEF_MIPS_FTYPE (2, (V4SF, V4SF, V4SI))\n+DEF_MIPS_FTYPE (1, (V4SF, V4SI))\n+DEF_MIPS_FTYPE (1, (V4SF, V8HI))\n+\n+DEF_MIPS_FTYPE (2, (V4SI, CVPOINTER, SI))\n+DEF_MIPS_FTYPE (1, (V4SI, HI))\n+DEF_MIPS_FTYPE (1, (V4SI, SI))\n+DEF_MIPS_FTYPE (2, (V4SI, UV4SI, UQI))\n+DEF_MIPS_FTYPE (2, (V4SI, UV4SI, UV4SI))\n+DEF_MIPS_FTYPE (2, (V4SI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (2, (V4SI, V2DF, V2DF))\n+DEF_MIPS_FTYPE (1, (V4SI, V4SF))\n+DEF_MIPS_FTYPE (2, (V4SI, V4SF, V4SF))\n+DEF_MIPS_FTYPE (1, (V4SI, V4SI))\n+DEF_MIPS_FTYPE (2, (V4SI, V4SI, QI))\n+DEF_MIPS_FTYPE (2, (V4SI, V4SI, SI))\n+DEF_MIPS_FTYPE (2, (V4SI, V4SI, UQI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, UQI, SI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, UQI, V4SI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (2, (V4SI, V4SI, V4SI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, V4SI, SI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, V4SI, UQI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, V4SI, V4SI))\n+DEF_MIPS_FTYPE (3, (V4SI, V4SI, V8HI, V8HI))\n+DEF_MIPS_FTYPE (2, (V4SI, V8HI, V8HI))\n+\n+DEF_MIPS_FTYPE (2, (V8HI, CVPOINTER, SI))\n+DEF_MIPS_FTYPE (1, (V8HI, HI))\n+DEF_MIPS_FTYPE (1, (V8HI, SI))\n+DEF_MIPS_FTYPE (2, (V8HI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (2, (V8HI, UV8HI, UQI))\n+DEF_MIPS_FTYPE (2, (V8HI, UV8HI, UV8HI))\n+DEF_MIPS_FTYPE (2, (V8HI, V16QI, V16QI))\n+DEF_MIPS_FTYPE (2, (V8HI, V4SF, V4SF))\n+DEF_MIPS_FTYPE (1, (V8HI, V8HI))\n+DEF_MIPS_FTYPE (2, (V8HI, V8HI, QI))\n+DEF_MIPS_FTYPE (2, (V8HI, V8HI, SI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, SI, UQI))\n+DEF_MIPS_FTYPE (2, (V8HI, V8HI, UQI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, UQI, SI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, UQI, V8HI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, UV16QI, UV16QI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, V16QI, V16QI))\n+DEF_MIPS_FTYPE (2, (V8HI, V8HI, V8HI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, V8HI, SI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, V8HI, UQI))\n+DEF_MIPS_FTYPE (3, (V8HI, V8HI, V8HI, V8HI))\n+\n DEF_MIPS_FTYPE (2, (V8QI, V4HI, V4HI))\n DEF_MIPS_FTYPE (1, (V8QI, V8QI))\n DEF_MIPS_FTYPE (2, (V8QI, V8QI, V8QI))\n \n DEF_MIPS_FTYPE (2, (VOID, SI, CVPOINTER))\n DEF_MIPS_FTYPE (2, (VOID, SI, SI))\n+DEF_MIPS_FTYPE (2, (VOID, UQI, SI))\n DEF_MIPS_FTYPE (1, (VOID, USI))\n+DEF_MIPS_FTYPE (3, (VOID, V16QI, CVPOINTER, SI))\n+DEF_MIPS_FTYPE (3, (VOID, V2DF, POINTER, SI))\n+DEF_MIPS_FTYPE (3, (VOID, V2DI, CVPOINTER, SI))\n DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))\n DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))\n+DEF_MIPS_FTYPE (3, (VOID, V4SF, POINTER, SI))\n+DEF_MIPS_FTYPE (3, (VOID, V4SI, CVPOINTER, SI))\n+DEF_MIPS_FTYPE (3, (VOID, V8HI, CVPOINTER, SI))"}, {"sha": "b21f5d16c9587777fbbb0b24a45627b5877222a2", "filename": "gcc/config/mips/mips-modes.def", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-modes.def?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -24,11 +24,17 @@ VECTOR_MODES (INT, 4);        /* V4QI  V2HI      */\n VECTOR_MODES (INT, 8);        /* V8QI  V4HI V2SI */\n VECTOR_MODES (FLOAT, 8);      /*       V4HF V2SF */\n \n+/* For MIPS MSA 128 bits.  */\n+VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n+VECTOR_MODES (FLOAT, 16);     /*            V4SF V2DF */\n+\n /* Double-sized vector modes for vec_concat.  */\n-VECTOR_MODE (INT, QI, 16);    /* V16QI           */\n-VECTOR_MODE (INT, HI, 8);     /*       V8HI      */\n-VECTOR_MODE (INT, SI, 4);     /*            V4SI */\n-VECTOR_MODE (FLOAT, SF, 4);   /*            V4SF */\n+VECTOR_MODE (INT, QI, 32);    /* V32QI                */\n+VECTOR_MODE (INT, HI, 16);    /*       V16HI          */\n+VECTOR_MODE (INT, SI, 8);     /*            V8SI      */\n+VECTOR_MODE (INT, DI, 4);     /*                 V4DI */\n+VECTOR_MODE (FLOAT, SF, 8);   /*            V8SF      */\n+VECTOR_MODE (FLOAT, DF, 4);   /*                 V4DF */\n \n VECTOR_MODES (FRACT, 4);\t/* V4QQ  V2HQ */\n VECTOR_MODES (UFRACT, 4);\t/* V4UQQ V2UHQ */"}, {"sha": "1082856dd98bd57bcb480a66f7e9bc9aaed043e1", "filename": "gcc/config/mips/mips-msa.md", "status": "added", "additions": 2736, "deletions": 0, "changes": 2736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-msa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-msa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-msa.md?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -0,0 +1,2736 @@\n+;; Machine Description for MIPS MSA ASE\n+;; Based on the MIPS MSA spec Revision 1.11 8/4/2014\n+;;\n+;; Copyright (C) 2015 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+;;\n+\n+(define_c_enum \"unspec\" [\n+  UNSPEC_MSA_ASUB_S\n+  UNSPEC_MSA_ASUB_U\n+  UNSPEC_MSA_AVE_S\n+  UNSPEC_MSA_AVE_U\n+  UNSPEC_MSA_AVER_S\n+  UNSPEC_MSA_AVER_U\n+  UNSPEC_MSA_BCLR\n+  UNSPEC_MSA_BCLRI\n+  UNSPEC_MSA_BINSL\n+  UNSPEC_MSA_BINSLI\n+  UNSPEC_MSA_BINSR\n+  UNSPEC_MSA_BINSRI\n+  UNSPEC_MSA_BNEG\n+  UNSPEC_MSA_BNEGI\n+  UNSPEC_MSA_BSET\n+  UNSPEC_MSA_BSETI\n+  UNSPEC_MSA_BRANCH_V\n+  UNSPEC_MSA_BRANCH\n+  UNSPEC_MSA_CFCMSA\n+  UNSPEC_MSA_CTCMSA\n+  UNSPEC_MSA_FCAF\n+  UNSPEC_MSA_FCLASS\n+  UNSPEC_MSA_FCUNE\n+  UNSPEC_MSA_FEXDO\n+  UNSPEC_MSA_FEXP2\n+  UNSPEC_MSA_FEXUPL\n+  UNSPEC_MSA_FEXUPR\n+  UNSPEC_MSA_FFQL\n+  UNSPEC_MSA_FFQR\n+  UNSPEC_MSA_FLOG2\n+  UNSPEC_MSA_FRCP\n+  UNSPEC_MSA_FRINT\n+  UNSPEC_MSA_FRSQRT\n+  UNSPEC_MSA_FSAF\n+  UNSPEC_MSA_FSEQ\n+  UNSPEC_MSA_FSLE\n+  UNSPEC_MSA_FSLT\n+  UNSPEC_MSA_FSNE\n+  UNSPEC_MSA_FSOR\n+  UNSPEC_MSA_FSUEQ\n+  UNSPEC_MSA_FSULE\n+  UNSPEC_MSA_FSULT\n+  UNSPEC_MSA_FSUN\n+  UNSPEC_MSA_FSUNE\n+  UNSPEC_MSA_FTINT_S\n+  UNSPEC_MSA_FTINT_U\n+  UNSPEC_MSA_FTQ\n+  UNSPEC_MSA_MADD_Q\n+  UNSPEC_MSA_MADDR_Q\n+  UNSPEC_MSA_MSUB_Q\n+  UNSPEC_MSA_MSUBR_Q\n+  UNSPEC_MSA_MUL_Q\n+  UNSPEC_MSA_MULR_Q\n+  UNSPEC_MSA_NLOC\n+  UNSPEC_MSA_SAT_S\n+  UNSPEC_MSA_SAT_U\n+  UNSPEC_MSA_SLD\n+  UNSPEC_MSA_SLDI\n+  UNSPEC_MSA_SPLAT\n+  UNSPEC_MSA_SPLATI\n+  UNSPEC_MSA_SRAR\n+  UNSPEC_MSA_SRARI\n+  UNSPEC_MSA_SRLR\n+  UNSPEC_MSA_SRLRI\n+  UNSPEC_MSA_SUBS_S\n+  UNSPEC_MSA_SUBS_U\n+  UNSPEC_MSA_SUBSUU_S\n+  UNSPEC_MSA_SUBSUS_U\n+  UNSPEC_MSA_VSHF\n+])\n+\n+;; All vector modes with 128 bits.\n+(define_mode_iterator MSA      [V2DF V4SF V2DI V4SI V8HI V16QI])\n+\n+;; Same as MSA.  Used by vcond to iterate two modes.\n+(define_mode_iterator MSA_2    [V2DF V4SF V2DI V4SI V8HI V16QI])\n+\n+;; Only used for splitting insert_d and copy_{u,s}.d.\n+(define_mode_iterator MSA_D    [V2DI V2DF])\n+\n+;; Only used for copy_{u,s}.w.\n+(define_mode_iterator MSA_W    [V4SI V4SF])\n+\n+;; Only integer modes.\n+(define_mode_iterator IMSA     [V2DI V4SI V8HI V16QI])\n+\n+;; As IMSA but excludes V16QI.\n+(define_mode_iterator IMSA_DWH [V2DI V4SI V8HI])\n+\n+;; As IMSA but excludes V2DI.\n+(define_mode_iterator IMSA_WHB [V4SI V8HI V16QI])\n+\n+;; Only integer modes equal or larger than a word.\n+(define_mode_iterator IMSA_DW  [V2DI V4SI])\n+\n+;; Only integer modes smaller than a word.\n+(define_mode_iterator IMSA_HB  [V8HI V16QI])\n+\n+;; Only integer modes for fixed-point madd_q/maddr_q.\n+(define_mode_iterator IMSA_WH  [V4SI V8HI])\n+\n+;; Only floating-point modes.\n+(define_mode_iterator FMSA     [V2DF V4SF])\n+\n+;; Only used for immediate set shuffle elements instruction.\n+(define_mode_iterator MSA_WHB_W [V4SI V8HI V16QI V4SF])\n+\n+;; The attribute gives the integer vector mode with same size.\n+(define_mode_attr VIMODE\n+  [(V2DF \"V2DI\")\n+   (V4SF \"V4SI\")\n+   (V2DI \"V2DI\")\n+   (V4SI \"V4SI\")\n+   (V8HI \"V8HI\")\n+   (V16QI \"V16QI\")])\n+\n+;; The attribute gives half modes for vector modes.\n+(define_mode_attr VHMODE\n+  [(V8HI \"V16QI\")\n+   (V4SI \"V8HI\")\n+   (V2DI \"V4SI\")])\n+\n+;; The attribute gives double modes for vector modes.\n+(define_mode_attr VDMODE\n+  [(V4SI \"V2DI\")\n+   (V8HI \"V4SI\")\n+   (V16QI \"V8HI\")])\n+\n+;; The attribute gives half modes with same number of elements for vector modes.\n+(define_mode_attr VTRUNCMODE\n+  [(V8HI \"V8QI\")\n+   (V4SI \"V4HI\")\n+   (V2DI \"V2SI\")])\n+\n+;; This attribute gives the mode of the result for \"copy_s_b, copy_u_b\" etc.\n+(define_mode_attr VRES\n+  [(V2DF \"DF\")\n+   (V4SF \"SF\")\n+   (V2DI \"DI\")\n+   (V4SI \"SI\")\n+   (V8HI \"SI\")\n+   (V16QI \"SI\")])\n+\n+;; Only used with MSA_D iterator.\n+(define_mode_attr msa_d\n+  [(V2DI \"reg_or_0\")\n+   (V2DF \"register\")])\n+\n+;; This attribute gives the integer vector mode with same size.\n+(define_mode_attr mode_i\n+  [(V2DF \"v2di\")\n+   (V4SF \"v4si\")\n+   (V2DI \"v2di\")\n+   (V4SI \"v4si\")\n+   (V8HI \"v8hi\")\n+   (V16QI \"v16qi\")])\n+\n+;; This attribute gives suffix for MSA instructions.\n+(define_mode_attr msafmt\n+  [(V2DF \"d\")\n+   (V4SF \"w\")\n+   (V2DI \"d\")\n+   (V4SI \"w\")\n+   (V8HI \"h\")\n+   (V16QI \"b\")])\n+\n+;; This attribute gives suffix for integers in VHMODE.\n+(define_mode_attr hmsafmt\n+  [(V2DI \"w\")\n+   (V4SI \"h\")\n+   (V8HI \"b\")])\n+\n+;; This attribute gives define_insn suffix for MSA instructions that need\n+;; distinction between integer and floating point.\n+(define_mode_attr msafmt_f\n+  [(V2DF \"d_f\")\n+   (V4SF \"w_f\")\n+   (V2DI \"d\")\n+   (V4SI \"w\")\n+   (V8HI \"h\")\n+   (V16QI \"b\")])\n+\n+;; This is used to form an immediate operand constraint using\n+;; \"const_<indeximm>_operand\".\n+(define_mode_attr indeximm\n+  [(V2DF \"0_or_1\")\n+   (V4SF \"0_to_3\")\n+   (V2DI \"0_or_1\")\n+   (V4SI \"0_to_3\")\n+   (V8HI \"uimm3\")\n+   (V16QI \"uimm4\")])\n+\n+;; This attribute represents bitmask needed for vec_merge using\n+;; \"const_<bitmask>_operand\".\n+(define_mode_attr bitmask\n+  [(V2DF \"exp_2\")\n+   (V4SF \"exp_4\")\n+   (V2DI \"exp_2\")\n+   (V4SI \"exp_4\")\n+   (V8HI \"exp_8\")\n+   (V16QI \"exp_16\")])\n+\n+;; This attribute is used to form an immediate operand constraint using\n+;; \"const_<bitimm>_operand\".\n+(define_mode_attr bitimm\n+  [(V16QI \"uimm3\")\n+   (V8HI  \"uimm4\")\n+   (V4SI  \"uimm5\")\n+   (V2DI  \"uimm6\")])\n+\n+(define_expand \"vec_init<mode>\"\n+  [(match_operand:MSA 0 \"register_operand\")\n+   (match_operand:MSA 1 \"\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  mips_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; pckev pattern with implicit type conversion.\n+(define_insn \"vec_pack_trunc_<mode>\"\n+   [(set (match_operand:<VHMODE> 0 \"register_operand\" \"=f\")\n+\t (vec_concat:<VHMODE>\n+\t   (truncate:<VTRUNCMODE>\n+\t     (match_operand:IMSA_DWH 1 \"register_operand\" \"f\"))\n+\t   (truncate:<VTRUNCMODE>\n+\t     (match_operand:IMSA_DWH 2 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"pckev.<hmsafmt>\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"vec_unpacks_hi_v4sf\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:V2DF\n+\t  (vec_select:V2SF\n+\t    (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t    (match_dup 2))))]\n+  \"ISA_HAS_MSA\"\n+{\n+  operands[2] = mips_msa_vec_parallel_const_half (V4SFmode, true/*high_p*/);\n+})\n+\n+(define_expand \"vec_unpacks_lo_v4sf\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:V2DF\n+\t  (vec_select:V2SF\n+\t    (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t    (match_dup 2))))]\n+  \"ISA_HAS_MSA\"\n+{\n+  operands[2] = mips_msa_vec_parallel_const_half (V4SFmode, false/*high_p*/);\n+})\n+\n+(define_expand \"vec_unpacks_hi_<mode>\"\n+  [(match_operand:<VDMODE> 0 \"register_operand\")\n+   (match_operand:IMSA_WHB 1 \"register_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  mips_expand_vec_unpack (operands, false/*unsigned_p*/, true/*high_p*/);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_lo_<mode>\"\n+  [(match_operand:<VDMODE> 0 \"register_operand\")\n+   (match_operand:IMSA_WHB 1 \"register_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  mips_expand_vec_unpack (operands, false/*unsigned_p*/, false/*high_p*/);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_hi_<mode>\"\n+  [(match_operand:<VDMODE> 0 \"register_operand\")\n+   (match_operand:IMSA_WHB 1 \"register_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  mips_expand_vec_unpack (operands, true/*unsigned_p*/, true/*high_p*/);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_lo_<mode>\"\n+  [(match_operand:<VDMODE> 0 \"register_operand\")\n+   (match_operand:IMSA_WHB 1 \"register_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  mips_expand_vec_unpack (operands, true/*unsigned_p*/, false/*high_p*/);\n+  DONE;\n+})\n+\n+(define_expand \"vec_extract<mode>\"\n+  [(match_operand:<UNITMODE> 0 \"register_operand\")\n+   (match_operand:IMSA 1 \"register_operand\")\n+   (match_operand 2 \"const_<indeximm>_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (<UNITMODE>mode == QImode || <UNITMODE>mode == HImode)\n+    {\n+      rtx dest1 = gen_reg_rtx (SImode);\n+      emit_insn (gen_msa_copy_s_<msafmt> (dest1, operands[1], operands[2]));\n+      emit_move_insn (operands[0],\n+\t\t      gen_lowpart (<UNITMODE>mode, dest1));\n+    }\n+  else\n+    emit_insn (gen_msa_copy_s_<msafmt> (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extract<mode>\"\n+  [(match_operand:<UNITMODE> 0 \"register_operand\")\n+   (match_operand:FMSA 1 \"register_operand\")\n+   (match_operand 2 \"const_<indeximm>_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx temp;\n+  HOST_WIDE_INT val = INTVAL (operands[2]);\n+\n+  if (val == 0)\n+    temp = operands[1];\n+  else\n+    {\n+      /* We need to do the SLDI operation in V16QImode and adjust\n+\t operands[2] accordingly.  */\n+      rtx wd = gen_reg_rtx (V16QImode);\n+      rtx ws = gen_reg_rtx (V16QImode);\n+      emit_move_insn (ws, gen_rtx_SUBREG (V16QImode, operands[1], 0));\n+      rtx n = GEN_INT (val * GET_MODE_SIZE (<UNITMODE>mode));\n+      gcc_assert (INTVAL (n) < GET_MODE_NUNITS (V16QImode));\n+      emit_insn (gen_msa_sldi_b (wd, ws, ws, n));\n+      temp = gen_reg_rtx (<MODE>mode);\n+      emit_move_insn (temp, gen_rtx_SUBREG (<MODE>mode, wd, 0));\n+    }\n+  emit_insn (gen_msa_vec_extract_<msafmt_f> (operands[0], temp));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"msa_vec_extract_<msafmt_f>\"\n+  [(set (match_operand:<UNITMODE> 0 \"register_operand\" \"=f\")\n+\t(vec_select:<UNITMODE>\n+\t  (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t  (parallel [(const_int 0)])))]\n+  \"ISA_HAS_MSA\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = gen_rtx_REG (<UNITMODE>mode, REGNO (operands[1]));\"\n+  [(set_attr \"move_type\" \"fmove\")\n+   (set_attr \"mode\" \"<UNITMODE>\")])\n+\n+(define_expand \"vec_set<mode>\"\n+  [(match_operand:IMSA 0 \"register_operand\")\n+   (match_operand:<UNITMODE> 1 \"reg_or_0_operand\")\n+   (match_operand 2 \"const_<indeximm>_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx index = GEN_INT (1 << INTVAL (operands[2]));\n+  emit_insn (gen_msa_insert_<msafmt> (operands[0], operands[1],\n+\t\t\t\t      operands[0], index));\n+  DONE;\n+})\n+\n+(define_expand \"vec_set<mode>\"\n+  [(match_operand:FMSA 0 \"register_operand\")\n+   (match_operand:<UNITMODE> 1 \"register_operand\")\n+   (match_operand 2 \"const_<indeximm>_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx index = GEN_INT (1 << INTVAL (operands[2]));\n+  emit_insn (gen_msa_insve_<msafmt_f>_scalar (operands[0], operands[1],\n+\t\t\t\t\t      operands[0], index));\n+  DONE;\n+})\n+\n+(define_expand \"vcondu<MSA:mode><IMSA:mode>\"\n+  [(match_operand:MSA 0 \"register_operand\")\n+   (match_operand:MSA 1 \"reg_or_m1_operand\")\n+   (match_operand:MSA 2 \"reg_or_0_operand\")\n+   (match_operator 3 \"\"\n+     [(match_operand:IMSA 4 \"register_operand\")\n+      (match_operand:IMSA 5 \"register_operand\")])]\n+  \"ISA_HAS_MSA\n+   && (GET_MODE_NUNITS (<MSA:MODE>mode) == GET_MODE_NUNITS (<IMSA:MODE>mode))\"\n+{\n+  mips_expand_vec_cond_expr (<MSA:MODE>mode, <MSA:VIMODE>mode, operands);\n+  DONE;\n+})\n+\n+(define_expand \"vcond<MSA:mode><MSA_2:mode>\"\n+  [(match_operand:MSA 0 \"register_operand\")\n+   (match_operand:MSA 1 \"reg_or_m1_operand\")\n+   (match_operand:MSA 2 \"reg_or_0_operand\")\n+   (match_operator 3 \"\"\n+     [(match_operand:MSA_2 4 \"register_operand\")\n+      (match_operand:MSA_2 5 \"register_operand\")])]\n+  \"ISA_HAS_MSA\n+   && (GET_MODE_NUNITS (<MSA:MODE>mode) == GET_MODE_NUNITS (<MSA_2:MODE>mode))\"\n+{\n+  mips_expand_vec_cond_expr (<MSA:MODE>mode, <MSA:VIMODE>mode, operands);\n+  DONE;\n+})\n+\n+(define_insn \"msa_insert_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(vec_merge:MSA\n+\t  (vec_duplicate:MSA\n+\t    (match_operand:<UNITMODE> 1 \"reg_or_0_operand\" \"dJ\"))\n+\t  (match_operand:MSA 2 \"register_operand\" \"0\")\n+\t  (match_operand 3 \"const_<bitmask>_operand\" \"\")))]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (!TARGET_64BIT && (<MODE>mode == V2DImode || <MODE>mode == V2DFmode))\n+    return \"#\";\n+  else\n+    return \"insert.<msafmt>\\t%w0[%y3],%z1\";\n+}\n+  [(set_attr \"type\" \"simd_insert\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_split\n+  [(set (match_operand:MSA_D 0 \"register_operand\")\n+\t(vec_merge:MSA_D\n+\t  (vec_duplicate:MSA_D\n+\t    (match_operand:<UNITMODE> 1 \"<MSA_D:msa_d>_operand\"))\n+\t  (match_operand:MSA_D 2 \"register_operand\")\n+\t  (match_operand 3 \"const_<bitmask>_operand\")))]\n+  \"reload_completed && ISA_HAS_MSA && !TARGET_64BIT\"\n+  [(const_int 0)]\n+{\n+  mips_split_msa_insert_d (operands[0], operands[2], operands[3], operands[1]);\n+  DONE;\n+})\n+\n+(define_insn \"msa_insve_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(vec_merge:MSA\n+\t  (vec_duplicate:MSA\n+\t    (vec_select:<UNITMODE>\n+\t      (match_operand:MSA 1 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 0)])))\n+\t  (match_operand:MSA 2 \"register_operand\" \"0\")\n+\t  (match_operand 3 \"const_<bitmask>_operand\" \"\")))]\n+  \"ISA_HAS_MSA\"\n+  \"insve.<msafmt>\\t%w0[%y3],%w1[0]\"\n+  [(set_attr \"type\" \"simd_insert\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Operand 3 is a scalar.\n+(define_insn \"msa_insve_<msafmt_f>_scalar\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(vec_merge:FMSA\n+\t  (vec_duplicate:FMSA\n+\t    (match_operand:<UNITMODE> 1 \"register_operand\" \"f\"))\n+\t  (match_operand:FMSA 2 \"register_operand\" \"0\")\n+\t  (match_operand 3 \"const_<bitmask>_operand\" \"\")))]\n+  \"ISA_HAS_MSA\"\n+  \"insve.<msafmt>\\t%w0[%y3],%w1[0]\"\n+  [(set_attr \"type\" \"simd_insert\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_copy_<su>_<msafmt>\"\n+  [(set (match_operand:<VRES> 0 \"register_operand\" \"=d\")\n+\t(any_extend:<VRES>\n+\t  (vec_select:<UNITMODE>\n+\t    (match_operand:IMSA_HB 1 \"register_operand\" \"f\")\n+\t    (parallel [(match_operand 2 \"const_<indeximm>_operand\" \"\")]))))]\n+  \"ISA_HAS_MSA\"\n+  \"copy_<su>.<msafmt>\\t%0,%w1[%2]\"\n+  [(set_attr \"type\" \"simd_copy\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_copy_u_w\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:DI\n+\t  (vec_select:SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t    (parallel [(match_operand 2 \"const_0_to_3_operand\" \"\")]))))]\n+  \"ISA_HAS_MSA && TARGET_64BIT\"\n+  \"copy_u.w\\t%0,%w1[%2]\"\n+  [(set_attr \"type\" \"simd_copy\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_copy_s_<msafmt_f>_64bit\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:DI\n+\t  (vec_select:<UNITMODE>\n+\t    (match_operand:MSA_W 1 \"register_operand\" \"f\")\n+\t    (parallel [(match_operand 2 \"const_<indeximm>_operand\" \"\")]))))]\n+  \"ISA_HAS_MSA && TARGET_64BIT\"\n+  \"copy_s.<msafmt>\\t%0,%w1[%2]\"\n+  [(set_attr \"type\" \"simd_copy\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_copy_s_<msafmt_f>\"\n+  [(set (match_operand:<UNITMODE> 0 \"register_operand\" \"=d\")\n+\t(vec_select:<UNITMODE>\n+\t  (match_operand:MSA_W 1 \"register_operand\" \"f\")\n+\t  (parallel [(match_operand 2 \"const_<indeximm>_operand\" \"\")])))]\n+  \"ISA_HAS_MSA\"\n+  \"copy_s.<msafmt>\\t%0,%w1[%2]\"\n+  [(set_attr \"type\" \"simd_copy\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn_and_split \"msa_copy_s_<msafmt_f>\"\n+  [(set (match_operand:<UNITMODE> 0 \"register_operand\" \"=d\")\n+\t(vec_select:<UNITMODE>\n+\t  (match_operand:MSA_D 1 \"register_operand\" \"f\")\n+\t  (parallel [(match_operand 2 \"const_<indeximm>_operand\" \"\")])))]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (TARGET_64BIT)\n+    return \"copy_s.<msafmt>\\t%0,%w1[%2]\";\n+  else\n+    return \"#\";\n+}\n+  \"reload_completed && ISA_HAS_MSA && !TARGET_64BIT\"\n+  [(const_int 0)]\n+{\n+  mips_split_msa_copy_d (operands[0], operands[1], operands[2],\n+\t\t\t gen_msa_copy_s_w);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"simd_copy\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"vec_perm_const<mode>\"\n+  [(match_operand:MSA 0 \"register_operand\")\n+   (match_operand:MSA 1 \"register_operand\")\n+   (match_operand:MSA 2 \"register_operand\")\n+   (match_operand:<VIMODE> 3 \"\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (mips_expand_vec_perm_const (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"abs<mode>2\"\n+  [(match_operand:IMSA 0 \"register_operand\" \"=f\")\n+   (abs:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\"))]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx reg = gen_reg_rtx (<MODE>mode);\n+  emit_move_insn (reg, CONST0_RTX (<MODE>mode));\n+  emit_insn (gen_msa_add_a_<msafmt> (operands[0], operands[1], reg));\n+  DONE;\n+})\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:MSA 0 \"register_operand\")\n+\t(minus:MSA (match_dup 2)\n+\t\t   (match_operand:MSA 1 \"register_operand\")))]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx reg = gen_reg_rtx (<MODE>mode);\n+  emit_move_insn (reg, CONST0_RTX (<MODE>mode));\n+  operands[2] = reg;\n+})\n+\n+(define_expand \"msa_ldi<mode>\"\n+  [(match_operand:IMSA 0 \"register_operand\")\n+   (match_operand 1 \"const_imm10_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (<MODE>mode == V16QImode)\n+    operands[1] = GEN_INT (trunc_int_for_mode (INTVAL (operands[1]),\n+\t\t\t\t\t       <UNITMODE>mode));\n+  emit_move_insn (operands[0],\n+\t\t  mips_gen_const_int_vector (<MODE>mode, INTVAL (operands[1])));\n+  DONE;\n+})\n+\n+(define_insn \"vec_perm<mode>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(unspec:MSA [(match_operand:MSA 1 \"register_operand\" \"f\")\n+\t\t     (match_operand:MSA 2 \"register_operand\" \"f\")\n+\t\t     (match_operand:<VIMODE> 3 \"register_operand\" \"0\")]\n+\t\t    UNSPEC_MSA_VSHF))]\n+  \"ISA_HAS_MSA\"\n+  \"vshf.<msafmt>\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_sld\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:MSA 0)\n+\t(match_operand:MSA 1))]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (mips_legitimize_move (<MODE>mode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+(define_expand \"movmisalign<mode>\"\n+  [(set (match_operand:MSA 0)\n+\t(match_operand:MSA 1))]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (mips_legitimize_move (<MODE>mode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+;; 128-bit MSA modes can only exist in MSA registers or memory.  An exception\n+;; is allowing MSA modes for GP registers for arguments and return values.\n+(define_insn \"mov<mode>_msa\"\n+  [(set (match_operand:MSA 0 \"nonimmediate_operand\" \"=f,f,R,*d,*f\")\n+\t(match_operand:MSA 1 \"move_operand\" \"fYGYI,R,f,*f,*d\"))]\n+  \"ISA_HAS_MSA\"\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\" \"simd_move,simd_load,simd_store,simd_copy,simd_insert\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_split\n+  [(set (match_operand:MSA 0 \"nonimmediate_operand\")\n+\t(match_operand:MSA 1 \"move_operand\"))]\n+  \"reload_completed && ISA_HAS_MSA\n+   && mips_split_move_insn_p (operands[0], operands[1], insn)\"\n+  [(const_int 0)]\n+{\n+  mips_split_move_insn (operands[0], operands[1], curr_insn);\n+  DONE;\n+})\n+\n+;; Offset load\n+(define_expand \"msa_ld_<msafmt_f>\"\n+  [(match_operand:MSA 0 \"register_operand\")\n+   (match_operand 1 \"pmode_register_operand\")\n+   (match_operand 2 \"aq10<msafmt>_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx addr = plus_constant (GET_MODE (operands[1]), operands[1],\n+\t\t\t\t      INTVAL (operands[2]));\n+  mips_emit_move (operands[0], gen_rtx_MEM (<MODE>mode, addr));\n+  DONE;\n+})\n+\n+;; Offset store\n+(define_expand \"msa_st_<msafmt_f>\"\n+  [(match_operand:MSA 0 \"register_operand\")\n+   (match_operand 1 \"pmode_register_operand\")\n+   (match_operand 2 \"aq10<msafmt>_operand\")]\n+  \"ISA_HAS_MSA\"\n+{\n+  rtx addr = plus_constant (GET_MODE (operands[1]), operands[1],\n+\t\t\t    INTVAL (operands[2]));\n+  mips_emit_move (gen_rtx_MEM (<MODE>mode, addr), operands[0]);\n+  DONE;\n+})\n+\n+;; Integer operations\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f,f\")\n+\t(plus:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_ximm5_operand\" \"f,Unv5,Uuv5\")))]\n+  \"ISA_HAS_MSA\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"addv.<msafmt>\\t%w0,%w1,%w2\";\n+    case 1:\n+      {\n+\tHOST_WIDE_INT val = INTVAL (CONST_VECTOR_ELT (operands[2], 0));\n+\n+\toperands[2] = GEN_INT (-val);\n+\treturn \"subvi.<msafmt>\\t%w0,%w1,%d2\";\n+      }\n+    case 2:\n+      return \"addvi.<msafmt>\\t%w0,%w1,%E2\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"alu_type\" \"simd_add\")\n+   (set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(minus:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_uimm5_operand\" \"f,Uuv5\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   subv.<msafmt>\\t%w0,%w1,%w2\n+   subvi.<msafmt>\\t%w0,%w1,%E2\"\n+  [(set_attr \"alu_type\" \"simd_add\")\n+   (set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(mult:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"mulv.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_maddv_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(plus:IMSA (mult:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\"))\n+\t\t   (match_operand:IMSA 3 \"register_operand\" \"0\")))]\n+  \"ISA_HAS_MSA\"\n+  \"maddv.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_msubv_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(minus:IMSA (match_operand:IMSA 1 \"register_operand\" \"0\")\n+\t\t    (mult:IMSA (match_operand:IMSA 2 \"register_operand\" \"f\")\n+\t\t\t       (match_operand:IMSA 3 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"msubv.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(div:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  { return mips_msa_output_division (\"div_s.<msafmt>\\t%w0,%w1,%w2\", operands); }\n+  [(set_attr \"type\" \"simd_div\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"udiv<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(udiv:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  { return mips_msa_output_division (\"div_u.<msafmt>\\t%w0,%w1,%w2\", operands); }\n+  [(set_attr \"type\" \"simd_div\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"mod<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(mod:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  { return mips_msa_output_division (\"mod_s.<msafmt>\\t%w0,%w1,%w2\", operands); }\n+  [(set_attr \"type\" \"simd_div\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"umod<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(umod:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  { return mips_msa_output_division (\"mod_u.<msafmt>\\t%w0,%w1,%w2\", operands); }\n+  [(set_attr \"type\" \"simd_div\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f,f\")\n+\t(xor:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_val_operand\" \"f,YC,Urv8\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   xor.v\\t%w0,%w1,%w2\n+   bnegi.%v0\\t%w0,%w1,%V2\n+   xori.b\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_logic,simd_bit,simd_logic\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f,f\")\n+\t(ior:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_val_operand\" \"f,YC,Urv8\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   or.v\\t%w0,%w1,%w2\n+   bseti.%v0\\t%w0,%w1,%V2\n+   ori.b\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_logic,simd_bit,simd_logic\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"and<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f,f\")\n+\t(and:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_val_operand\" \"f,YZ,Urv8\")))]\n+  \"ISA_HAS_MSA\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"and.v\\t%w0,%w1,%w2\";\n+    case 1:\n+      {\n+\trtx elt0 = CONST_VECTOR_ELT (operands[2], 0);\n+\tunsigned HOST_WIDE_INT val = ~UINTVAL (elt0);\n+\toperands[2] = mips_gen_const_int_vector (<MODE>mode, val & (-val));\n+\treturn \"bclri.%v0\\t%w0,%w1,%V2\";\n+      }\n+    case 2:\n+      return \"andi.b\\t%w0,%w1,%B2\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"simd_logic,simd_bit,simd_logic\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(not:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"nor.v\\t%w0,%w1,%w1\"\n+  [(set_attr \"type\" \"simd_logic\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"vlshr<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(lshiftrt:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_uimm6_operand\" \"f,Uuv6\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   srl.<msafmt>\\t%w0,%w1,%w2\n+   srli.<msafmt>\\t%w0,%w1,%E2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"vashr<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(ashiftrt:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_uimm6_operand\" \"f,Uuv6\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   sra.<msafmt>\\t%w0,%w1,%w2\n+   srai.<msafmt>\\t%w0,%w1,%E2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"vashl<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(ashift:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_uimm6_operand\" \"f,Uuv6\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   sll.<msafmt>\\t%w0,%w1,%w2\n+   slli.<msafmt>\\t%w0,%w1,%E2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Floating-point operations\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(plus:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fadd.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fadd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(minus:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fsub.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fadd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(mult:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fmul.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fmul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(div:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fdiv.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fdiv\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fma<mode>4\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(fma:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:FMSA 2 \"register_operand\" \"f\")\n+\t\t  (match_operand:FMSA 3 \"register_operand\" \"0\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fmadd.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fmadd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fnma<mode>4\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(fma:FMSA (neg:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\"))\n+\t\t  (match_operand:FMSA 2 \"register_operand\" \"f\")\n+\t\t  (match_operand:FMSA 3 \"register_operand\" \"0\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fmsub.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fmadd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(sqrt:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fsqrt.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fdiv\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Built-in functions\n+(define_insn \"msa_add_a_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(plus:IMSA (abs:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\"))\n+\t\t   (abs:IMSA (match_operand:IMSA 2 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"add_a.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_adds_a_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(ss_plus:IMSA\n+\t  (abs:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\"))\n+\t  (abs:IMSA (match_operand:IMSA 2 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"adds_a.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"ssadd<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(ss_plus:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"adds_s.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"usadd<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(us_plus:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"adds_u.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_asub_s_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_ASUB_S))]\n+  \"ISA_HAS_MSA\"\n+  \"asub_s.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_asub_u_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_ASUB_U))]\n+  \"ISA_HAS_MSA\"\n+  \"asub_u.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_ave_s_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_AVE_S))]\n+  \"ISA_HAS_MSA\"\n+  \"ave_s.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_ave_u_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_AVE_U))]\n+  \"ISA_HAS_MSA\"\n+  \"ave_u.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_aver_s_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_AVER_S))]\n+  \"ISA_HAS_MSA\"\n+  \"aver_s.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_aver_u_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_AVER_U))]\n+  \"ISA_HAS_MSA\"\n+  \"aver_u.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bclr_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_BCLR))]\n+  \"ISA_HAS_MSA\"\n+  \"bclr.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bclri_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand 2 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_BCLRI))]\n+  \"ISA_HAS_MSA\"\n+  \"bclri.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_binsl_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 3 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_BINSL))]\n+  \"ISA_HAS_MSA\"\n+  \"binsl.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_bitins\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_binsli_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")\n+\t\t      (match_operand 3 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_BINSLI))]\n+  \"ISA_HAS_MSA\"\n+  \"binsli.<msafmt>\\t%w0,%w2,%3\"\n+  [(set_attr \"type\" \"simd_bitins\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_binsr_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 3 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_BINSR))]\n+  \"ISA_HAS_MSA\"\n+  \"binsr.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_bitins\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_binsri_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")\n+\t\t      (match_operand 3 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_BINSRI))]\n+  \"ISA_HAS_MSA\"\n+  \"binsri.<msafmt>\\t%w0,%w2,%3\"\n+  [(set_attr \"type\" \"simd_bitins\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bmnz_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(ior:IMSA (and:IMSA (match_operand:IMSA 2 \"register_operand\" \"f,f\")\n+\t\t\t    (match_operand:IMSA 3 \"reg_or_vector_same_val_operand\" \"f,Urv8\"))\n+\t\t  (and:IMSA (not:IMSA (match_dup 3))\n+\t\t\t    (match_operand:IMSA 1 \"register_operand\" \"0,0\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   bmnz.v\\t%w0,%w2,%w3\n+   bmnzi.b\\t%w0,%w2,%B3\"\n+  [(set_attr \"type\" \"simd_bitmov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bmz_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(ior:IMSA (and:IMSA (not:IMSA\n+\t\t\t      (match_operand:IMSA 3 \"reg_or_vector_same_val_operand\" \"f,Urv8\"))\n+\t\t\t    (match_operand:IMSA 2 \"register_operand\" \"f,f\"))\n+\t\t  (and:IMSA (match_operand:IMSA 1 \"register_operand\" \"0,0\")\n+\t\t\t    (match_dup 3))))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   bmz.v\\t%w0,%w2,%w3\n+   bmzi.b\\t%w0,%w2,%B3\"\n+  [(set_attr \"type\" \"simd_bitmov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bneg_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_BNEG))]\n+  \"ISA_HAS_MSA\"\n+  \"bneg.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bnegi_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t       (match_operand 2 \"const_msa_branch_operand\" \"\")]\n+\t\t     UNSPEC_MSA_BNEGI))]\n+  \"ISA_HAS_MSA\"\n+  \"bnegi.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bsel_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(ior:IMSA (and:IMSA (not:IMSA\n+\t\t\t      (match_operand:IMSA 1 \"register_operand\" \"0,0\"))\n+\t\t\t    (match_operand:IMSA 2 \"register_operand\" \"f,f\"))\n+\t\t  (and:IMSA (match_dup 1)\n+\t\t\t    (match_operand:IMSA 3 \"reg_or_vector_same_val_operand\" \"f,Urv8\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   bsel.v\\t%w0,%w2,%w3\n+   bseli.b\\t%w0,%w2,%B3\"\n+  [(set_attr \"type\" \"simd_bitmov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bset_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_BSET))]\n+  \"ISA_HAS_MSA\"\n+  \"bset.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_bseti_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand 2 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_BSETI))]\n+  \"ISA_HAS_MSA\"\n+  \"bseti.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_code_iterator ICC [eq le leu lt ltu])\n+\n+(define_code_attr icc\n+  [(eq  \"eq\")\n+   (le  \"le_s\")\n+   (leu \"le_u\")\n+   (lt  \"lt_s\")\n+   (ltu \"lt_u\")])\n+\n+(define_code_attr icci\n+  [(eq  \"eqi\")\n+   (le  \"lei_s\")\n+   (leu \"lei_u\")\n+   (lt  \"lti_s\")\n+   (ltu \"lti_u\")])\n+\n+(define_code_attr cmpi\n+  [(eq   \"s\")\n+   (le   \"s\")\n+   (leu  \"u\")\n+   (lt   \"s\")\n+   (ltu  \"u\")])\n+\n+(define_insn \"msa_c<ICC:icc>_<IMSA:msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(ICC:IMSA\n+\t  (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t  (match_operand:IMSA 2 \"reg_or_vector_same_<ICC:cmpi>imm5_operand\" \"f,U<ICC:cmpi>v5\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   c<ICC:icc>.<IMSA:msafmt>\\t%w0,%w1,%w2\n+   c<ICC:icci>.<IMSA:msafmt>\\t%w0,%w1,%E2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_dotp_<su>_d\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=f\")\n+\t(plus:V2DI\n+\t  (mult:V2DI\n+\t    (any_extend:V2DI\n+\t      (vec_select:V2SI\n+\t\t(match_operand:V4SI 1 \"register_operand\" \"%f\")\n+\t\t(parallel [(const_int 0) (const_int 2)])))\n+\t    (any_extend:V2DI\n+\t      (vec_select:V2SI\n+\t\t(match_operand:V4SI 2 \"register_operand\" \"f\")\n+\t\t(parallel [(const_int 0) (const_int 2)]))))\n+\t  (mult:V2DI\n+\t    (any_extend:V2DI\n+\t      (vec_select:V4SI (match_dup 1)\n+\t\t(parallel [(const_int 1) (const_int 3)])))\n+\t    (any_extend:V2DI\n+\t      (vec_select:V4SI (match_dup 2)\n+\t\t(parallel [(const_int 1) (const_int 3)]))))))]\n+  \"ISA_HAS_MSA\"\n+  \"dotp_<su>.d\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V2DI\")])\n+\n+(define_insn \"msa_dotp_<su>_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(plus:V4SI\n+\t  (mult:V4SI\n+\t    (any_extend:V4SI\n+\t      (vec_select:V4HI\n+\t\t(match_operand:V8HI 1 \"register_operand\" \"%f\")\n+\t\t(parallel [(const_int 0) (const_int 2)\n+\t\t\t   (const_int 4) (const_int 6)])))\n+\t    (any_extend:V4SI\n+\t      (vec_select:V4HI\n+\t\t(match_operand:V8HI 2 \"register_operand\" \"f\")\n+\t\t(parallel [(const_int 0) (const_int 2)\n+\t\t\t   (const_int 4) (const_int 6)]))))\n+\t  (mult:V4SI\n+\t    (any_extend:V4SI\n+\t      (vec_select:V4HI (match_dup 1)\n+\t\t(parallel [(const_int 1) (const_int 3)\n+\t\t\t   (const_int 5) (const_int 7)])))\n+\t    (any_extend:V4SI\n+\t      (vec_select:V4HI (match_dup 2)\n+\t\t(parallel [(const_int 1) (const_int 3)\n+\t\t\t   (const_int 5) (const_int 7)]))))))]\n+  \"ISA_HAS_MSA\"\n+  \"dotp_<su>.w\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_dotp_<su>_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(plus:V8HI\n+\t  (mult:V8HI\n+\t    (any_extend:V8HI\n+\t      (vec_select:V8QI\n+\t\t(match_operand:V16QI 1 \"register_operand\" \"%f\")\n+\t\t(parallel [(const_int 0) (const_int 2)\n+\t\t\t   (const_int 4) (const_int 6)\n+\t\t\t   (const_int 8) (const_int 10)\n+\t\t\t   (const_int 12) (const_int 14)])))\n+\t    (any_extend:V8HI\n+\t      (vec_select:V8QI\n+\t\t(match_operand:V16QI 2 \"register_operand\" \"f\")\n+\t\t(parallel [(const_int 0) (const_int 2)\n+\t\t\t   (const_int 4) (const_int 6)\n+\t\t\t   (const_int 8) (const_int 10)\n+\t\t\t   (const_int 12) (const_int 14)]))))\n+\t  (mult:V8HI\n+\t    (any_extend:V8HI\n+\t      (vec_select:V8QI (match_dup 1)\n+\t\t(parallel [(const_int 1) (const_int 3)\n+\t\t\t   (const_int 5) (const_int 7)\n+\t\t\t   (const_int 9) (const_int 11)\n+\t\t\t   (const_int 13) (const_int 15)])))\n+\t    (any_extend:V8HI\n+\t      (vec_select:V8QI (match_dup 2)\n+\t\t(parallel [(const_int 1) (const_int 3)\n+\t\t\t   (const_int 5) (const_int 7)\n+\t\t\t   (const_int 9) (const_int 11)\n+\t\t\t   (const_int 13) (const_int 15)]))))))]\n+  \"ISA_HAS_MSA\"\n+  \"dotp_<su>.h\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_dpadd_<su>_d\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=f\")\n+\t(plus:V2DI\n+\t  (plus:V2DI\n+\t    (mult:V2DI\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V2SI\n+\t\t  (match_operand:V4SI 2 \"register_operand\" \"%f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)])))\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V2SI\n+\t\t  (match_operand:V4SI 3 \"register_operand\" \"f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)]))))\n+\t    (mult:V2DI\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V4SI (match_dup 2)\n+\t\t  (parallel [(const_int 1) (const_int 3)])))\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V4SI (match_dup 3)\n+\t\t  (parallel [(const_int 1) (const_int 3)])))))\n+\t  (match_operand:V2DI 1 \"register_operand\" \"0\")))]\n+  \"ISA_HAS_MSA\"\n+  \"dpadd_<su>.d\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V2DI\")])\n+\n+(define_insn \"msa_dpadd_<su>_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(plus:V4SI\n+\t  (plus:V4SI\n+\t    (mult:V4SI\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI\n+\t\t  (match_operand:V8HI 2 \"register_operand\" \"%f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)])))\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI\n+\t\t  (match_operand:V8HI 3 \"register_operand\" \"f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)]))))\n+\t    (mult:V4SI\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI (match_dup 2)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)])))\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI (match_dup 3)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)])))))\n+\t  (match_operand:V4SI 1 \"register_operand\" \"0\")))]\n+  \"ISA_HAS_MSA\"\n+  \"dpadd_<su>.w\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_dpadd_<su>_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(plus:V8HI\n+\t  (plus:V8HI\n+\t    (mult:V8HI\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI\n+\t\t  (match_operand:V16QI 2 \"register_operand\" \"%f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)\n+\t\t\t     (const_int 8) (const_int 10)\n+\t\t\t     (const_int 12) (const_int 14)])))\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI\n+\t\t  (match_operand:V16QI 3 \"register_operand\" \"f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)\n+\t\t\t     (const_int 8) (const_int 10)\n+\t\t\t     (const_int 12) (const_int 14)]))))\n+\t    (mult:V8HI\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI (match_dup 2)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)\n+\t\t\t     (const_int 9) (const_int 11)\n+\t\t\t     (const_int 13) (const_int 15)])))\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI (match_dup 3)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)\n+\t\t\t     (const_int 9) (const_int 11)\n+\t\t\t     (const_int 13) (const_int 15)])))))\n+\t  (match_operand:V8HI 1 \"register_operand\" \"0\")))]\n+  \"ISA_HAS_MSA\"\n+  \"dpadd_<su>.h\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_dpsub_<su>_d\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=f\")\n+\t(minus:V2DI\n+\t  (match_operand:V2DI 1 \"register_operand\" \"0\")\n+\t  (plus:V2DI\n+\t    (mult:V2DI\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V2SI\n+\t\t  (match_operand:V4SI 2 \"register_operand\" \"%f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)])))\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V2SI\n+\t\t  (match_operand:V4SI 3 \"register_operand\" \"f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)]))))\n+\t    (mult:V2DI\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V4SI (match_dup 2)\n+\t\t  (parallel [(const_int 1) (const_int 3)])))\n+\t      (any_extend:V2DI\n+\t\t(vec_select:V4SI (match_dup 3)\n+\t\t  (parallel [(const_int 1) (const_int 3)])))))))]\n+  \"ISA_HAS_MSA\"\n+  \"dpsub_<su>.d\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V2DI\")])\n+\n+(define_insn \"msa_dpsub_<su>_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(minus:V4SI\n+\t  (match_operand:V4SI 1 \"register_operand\" \"0\")\n+\t  (plus:V4SI\n+\t    (mult:V4SI\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI\n+\t\t  (match_operand:V8HI 2 \"register_operand\" \"%f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)])))\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI\n+\t\t  (match_operand:V8HI 3 \"register_operand\" \"f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)]))))\n+\t    (mult:V4SI\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI (match_dup 2)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)])))\n+\t      (any_extend:V4SI\n+\t\t(vec_select:V4HI (match_dup 3)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)])))))))]\n+  \"ISA_HAS_MSA\"\n+  \"dpsub_<su>.w\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_dpsub_<su>_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(minus:V8HI\n+\t  (match_operand:V8HI 1 \"register_operand\" \"0\")\n+\t  (plus:V8HI\n+\t    (mult:V8HI\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI\n+\t\t  (match_operand:V16QI 2 \"register_operand\" \"%f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)\n+\t\t\t     (const_int 8) (const_int 10)\n+\t\t\t     (const_int 12) (const_int 14)])))\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI\n+\t\t  (match_operand:V16QI 3 \"register_operand\" \"f\")\n+\t\t  (parallel [(const_int 0) (const_int 2)\n+\t\t\t     (const_int 4) (const_int 6)\n+\t\t\t     (const_int 8) (const_int 10)\n+\t\t\t     (const_int 12) (const_int 14)]))))\n+\t    (mult:V8HI\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI (match_dup 2)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)\n+\t\t\t     (const_int 9) (const_int 11)\n+\t\t\t     (const_int 13) (const_int 15)])))\n+\t      (any_extend:V8HI\n+\t\t(vec_select:V8QI (match_dup 3)\n+\t\t  (parallel [(const_int 1) (const_int 3)\n+\t\t\t     (const_int 5) (const_int 7)\n+\t\t\t     (const_int 9) (const_int 11)\n+\t\t\t     (const_int 13) (const_int 15)])))))))]\n+  \"ISA_HAS_MSA\"\n+  \"dpsub_<su>.h\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_fclass_<msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unspec:<VIMODE> [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t\t UNSPEC_MSA_FCLASS))]\n+  \"ISA_HAS_MSA\"\n+  \"fclass.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fclass\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_fcaf_<msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unspec:<VIMODE> [(match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t\t  (match_operand:FMSA 2 \"register_operand\" \"f\")]\n+\t\t\t UNSPEC_MSA_FCAF))]\n+  \"ISA_HAS_MSA\"\n+  \"fcaf.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_fcune_<FMSA:msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unspec:<VIMODE> [(match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t\t  (match_operand:FMSA 2 \"register_operand\" \"f\")]\n+\t\t\t UNSPEC_MSA_FCUNE))]\n+  \"ISA_HAS_MSA\"\n+  \"fcune.<FMSA:msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_code_iterator FCC [unordered ordered eq ne le lt uneq unle unlt])\n+\n+(define_code_attr fcc\n+  [(unordered \"fcun\")\n+   (ordered   \"fcor\")\n+   (eq        \"fceq\")\n+   (ne        \"fcne\")\n+   (uneq      \"fcueq\")\n+   (unle      \"fcule\")\n+   (unlt      \"fcult\")\n+   (le        \"fcle\")\n+   (lt        \"fclt\")])\n+\n+(define_int_iterator FSC_UNS [UNSPEC_MSA_FSAF UNSPEC_MSA_FSUN UNSPEC_MSA_FSOR\n+\t\t\t      UNSPEC_MSA_FSEQ UNSPEC_MSA_FSNE UNSPEC_MSA_FSUEQ\n+\t\t\t      UNSPEC_MSA_FSUNE UNSPEC_MSA_FSULE UNSPEC_MSA_FSULT\n+\t\t\t      UNSPEC_MSA_FSLE UNSPEC_MSA_FSLT])\n+\n+(define_int_attr fsc\n+  [(UNSPEC_MSA_FSAF  \"fsaf\")\n+   (UNSPEC_MSA_FSUN  \"fsun\")\n+   (UNSPEC_MSA_FSOR  \"fsor\")\n+   (UNSPEC_MSA_FSEQ  \"fseq\")\n+   (UNSPEC_MSA_FSNE  \"fsne\")\n+   (UNSPEC_MSA_FSUEQ \"fsueq\")\n+   (UNSPEC_MSA_FSUNE \"fsune\")\n+   (UNSPEC_MSA_FSULE \"fsule\")\n+   (UNSPEC_MSA_FSULT \"fsult\")\n+   (UNSPEC_MSA_FSLE  \"fsle\")\n+   (UNSPEC_MSA_FSLT  \"fslt\")])\n+\n+(define_insn \"msa_<FCC:fcc>_<FMSA:msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(FCC:<VIMODE> (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"<FCC:fcc>.<FMSA:msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_<fsc>_<FMSA:msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unspec:<VIMODE> [(match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t\t   (match_operand:FMSA 2 \"register_operand\" \"f\")]\n+\t\t\t FSC_UNS))]\n+  \"ISA_HAS_MSA\"\n+  \"<fsc>.<FMSA:msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_fexp2_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:<VIMODE> 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FEXP2))]\n+  \"ISA_HAS_MSA\"\n+  \"fexp2.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fexp2\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_mode_attr fint\n+  [(V4SF \"v4si\")\n+   (V2DF \"v2di\")])\n+\n+(define_mode_attr FQ\n+  [(V4SF \"V8HI\")\n+   (V2DF \"V4SI\")])\n+\n+(define_mode_attr FINTCNV\n+  [(V4SF \"I2S\")\n+   (V2DF \"I2D\")])\n+\n+(define_mode_attr FINTCNV_2\n+  [(V4SF \"S2I\")\n+   (V2DF \"D2I\")])\n+\n+(define_insn \"float<fint><FMSA:mode>2\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(float:FMSA (match_operand:<VIMODE> 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"ffint_s.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"floatuns<fint><FMSA:mode>2\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unsigned_float:FMSA\n+\t  (match_operand:<VIMODE> 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"ffint_u.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_mode_attr FFQ\n+  [(V4SF \"V8HI\")\n+   (V2DF \"V4SI\")])\n+\n+(define_insn \"msa_ffql_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:<FQ> 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FFQL))]\n+  \"ISA_HAS_MSA\"\n+  \"ffql.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_ffqr_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:<FQ> 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FFQR))]\n+  \"ISA_HAS_MSA\"\n+  \"ffqr.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_fill_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f,f\")\n+\t(vec_duplicate:MSA\n+\t  (match_operand:<UNITMODE> 1 \"reg_or_0_operand\" \"d,J\")))]\n+  \"ISA_HAS_MSA\"\n+{\n+  if (which_alternative == 1)\n+    return \"ldi.<msafmt>\\t%w0,0\";\n+\n+  if (!TARGET_64BIT && (<MODE>mode == V2DImode || <MODE>mode == V2DFmode))\n+    return \"#\";\n+  else\n+    return \"fill.<msafmt>\\t%w0,%z1\";\n+}\n+  [(set_attr \"type\" \"simd_fill\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_split\n+  [(set (match_operand:MSA_D 0 \"register_operand\")\n+\t(vec_duplicate:MSA_D\n+\t  (match_operand:<UNITMODE> 1 \"register_operand\")))]\n+  \"reload_completed && ISA_HAS_MSA && !TARGET_64BIT\"\n+  [(const_int 0)]\n+{\n+  mips_split_msa_fill_d (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_insn \"msa_flog2_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FLOG2))]\n+  \"ISA_HAS_MSA\"\n+  \"flog2.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_flog2\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"smax<mode>3\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(smax:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fmax.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fminmax\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_fmax_a_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(if_then_else\n+\t   (gt (abs:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\"))\n+\t       (abs:FMSA (match_operand:FMSA 2 \"register_operand\" \"f\")))\n+\t   (match_dup 1)\n+\t   (match_dup 2)))]\n+  \"ISA_HAS_MSA\"\n+  \"fmax_a.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fminmax\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"smin<mode>3\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(smin:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:FMSA 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"fmin.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fminmax\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_fmin_a_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(if_then_else\n+\t   (lt (abs:FMSA (match_operand:FMSA 1 \"register_operand\" \"f\"))\n+\t       (abs:FMSA (match_operand:FMSA 2 \"register_operand\" \"f\")))\n+\t   (match_dup 1)\n+\t   (match_dup 2)))]\n+  \"ISA_HAS_MSA\"\n+  \"fmin_a.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fminmax\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_frcp_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FRCP))]\n+  \"ISA_HAS_MSA\"\n+  \"frcp.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fdiv\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_frint_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FRINT))]\n+  \"ISA_HAS_MSA\"\n+  \"frint.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_frsqrt_<msafmt>\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FRSQRT))]\n+  \"ISA_HAS_MSA\"\n+  \"frsqrt.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fdiv\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_ftint_s_<msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unspec:<VIMODE> [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t\t UNSPEC_MSA_FTINT_S))]\n+  \"ISA_HAS_MSA\"\n+  \"ftint_s.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV_2>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_ftint_u_<msafmt>\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unspec:<VIMODE> [(match_operand:FMSA 1 \"register_operand\" \"f\")]\n+\t\t\t UNSPEC_MSA_FTINT_U))]\n+  \"ISA_HAS_MSA\"\n+  \"ftint_u.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV_2>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fix_trunc<FMSA:mode><mode_i>2\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(fix:<VIMODE> (match_operand:FMSA 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"ftrunc_s.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV_2>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"fixuns_trunc<FMSA:mode><mode_i>2\"\n+  [(set (match_operand:<VIMODE> 0 \"register_operand\" \"=f\")\n+\t(unsigned_fix:<VIMODE> (match_operand:FMSA 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"ftrunc_u.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"<FINTCNV_2>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_ftq_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(unspec:V8HI [(match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:V4SF 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FTQ))]\n+  \"ISA_HAS_MSA\"\n+  \"ftq.h\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"S2I\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_ftq_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(unspec:V4SI [(match_operand:V2DF 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:V2DF 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FTQ))]\n+  \"ISA_HAS_MSA\"\n+  \"ftq.w\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"cnv_mode\" \"D2I\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"msa_h<optab>_<su>_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(addsub:V8HI\n+\t  (any_extend:V8HI\n+\t    (vec_select:V8QI\n+\t      (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 1) (const_int 3)\n+\t\t\t (const_int 5) (const_int 7)\n+\t\t\t (const_int 9) (const_int 11)\n+\t\t\t (const_int 13) (const_int 15)])))\n+\t  (any_extend:V8HI\n+\t    (vec_select:V8QI\n+\t      (match_operand:V16QI 2 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 0) (const_int 2)\n+\t\t\t (const_int 4) (const_int 6)\n+\t\t\t (const_int 8) (const_int 10)\n+\t\t\t (const_int 12) (const_int 14)])))))]\n+  \"ISA_HAS_MSA\"\n+  \"h<optab>_<su>.h\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_h<optab>_<su>_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(addsub:V4SI\n+\t  (any_extend:V4SI\n+\t    (vec_select:V4HI\n+\t      (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 1) (const_int 3)\n+\t\t\t (const_int 5) (const_int 7)])))\n+\t  (any_extend:V4SI\n+\t    (vec_select:V4HI\n+\t      (match_operand:V8HI 2 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 0) (const_int 2)\n+\t\t\t (const_int 4) (const_int 6)])))))]\n+  \"ISA_HAS_MSA\"\n+  \"h<optab>_<su>.w\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_h<optab>_<su>_d\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=f\")\n+\t(addsub:V2DI\n+\t  (any_extend:V2DI\n+\t    (vec_select:V2SI\n+\t      (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 1) (const_int 3)])))\n+\t  (any_extend:V2DI\n+\t    (vec_select:V2SI\n+\t      (match_operand:V4SI 2 \"register_operand\" \"f\")\n+\t      (parallel [(const_int 0) (const_int 2)])))))]\n+  \"ISA_HAS_MSA\"\n+  \"h<optab>_<su>.d\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"V2DI\")])\n+\n+(define_insn \"msa_ilvev_b\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V16QI\n+\t  (vec_concat:V32QI\n+\t    (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V16QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0)  (const_int 16)\n+\t\t     (const_int 2)  (const_int 18)\n+\t\t     (const_int 4)  (const_int 20)\n+\t\t     (const_int 6)  (const_int 22)\n+\t\t     (const_int 8)  (const_int 24)\n+\t\t     (const_int 10) (const_int 26)\n+\t\t     (const_int 12) (const_int 28)\n+\t\t     (const_int 14) (const_int 30)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvev.b\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V16QI\")])\n+\n+(define_insn \"msa_ilvev_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8HI\n+\t  (vec_concat:V16HI\n+\t    (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 8)\n+\t\t     (const_int 2) (const_int 10)\n+\t\t     (const_int 4) (const_int 12)\n+\t\t     (const_int 6) (const_int 14)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvev.h\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_ilvev_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SI\n+\t  (vec_concat:V8SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 2) (const_int 6)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvev.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_ilvev_w_f\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SF\n+\t  (vec_concat:V8SF\n+\t    (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 2) (const_int 6)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvev.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_ilvl_b\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V16QI\n+\t  (vec_concat:V32QI\n+\t    (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V16QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 8)  (const_int 24)\n+\t\t     (const_int 9)  (const_int 25)\n+\t\t     (const_int 10) (const_int 26)\n+\t\t     (const_int 11) (const_int 27)\n+\t\t     (const_int 12) (const_int 28)\n+\t\t     (const_int 13) (const_int 29)\n+\t\t     (const_int 14) (const_int 30)\n+\t\t     (const_int 15) (const_int 31)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvl.b\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V16QI\")])\n+\n+(define_insn \"msa_ilvl_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8HI\n+\t  (vec_concat:V16HI\n+\t    (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 4) (const_int 12)\n+\t\t     (const_int 5) (const_int 13)\n+\t\t     (const_int 6) (const_int 14)\n+\t\t     (const_int 7) (const_int 15)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvl.h\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_ilvl_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SI\n+\t  (vec_concat:V8SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 2) (const_int 6)\n+\t\t     (const_int 3) (const_int 7)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvl.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_ilvl_w_f\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SF\n+\t  (vec_concat:V8SF\n+\t    (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 2) (const_int 6)\n+\t\t     (const_int 3) (const_int 7)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvl.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_ilvl_d\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V2DI\n+\t  (vec_concat:V4DI\n+\t    (match_operand:V2DI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2DI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1) (const_int 3)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvl.d\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V2DI\")])\n+\n+(define_insn \"msa_ilvl_d_f\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=f\")\n+\t(vec_select:V2DF\n+\t  (vec_concat:V4DF\n+\t    (match_operand:V2DF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2DF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1) (const_int 3)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvl.d\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"msa_ilvod_b\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V16QI\n+\t  (vec_concat:V32QI\n+\t    (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V16QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1)  (const_int 17)\n+\t\t     (const_int 3)  (const_int 19)\n+\t\t     (const_int 5)  (const_int 21)\n+\t\t     (const_int 7)  (const_int 23)\n+\t\t     (const_int 9)  (const_int 25)\n+\t\t     (const_int 11) (const_int 27)\n+\t\t     (const_int 13) (const_int 29)\n+\t\t     (const_int 15) (const_int 31)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvod.b\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V16QI\")])\n+\n+(define_insn \"msa_ilvod_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8HI\n+\t  (vec_concat:V16HI\n+\t    (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1) (const_int 9)\n+\t\t     (const_int 3) (const_int 11)\n+\t\t     (const_int 5) (const_int 13)\n+\t\t     (const_int 7) (const_int 15)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvod.h\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_ilvod_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SI\n+\t  (vec_concat:V8SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1) (const_int 5)\n+\t\t     (const_int 3) (const_int 7)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvod.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_ilvod_w_f\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SF\n+\t  (vec_concat:V8SF\n+\t    (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1) (const_int 5)\n+\t\t     (const_int 3) (const_int 7)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvod.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_ilvr_b\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V16QI\n+\t  (vec_concat:V32QI\n+\t    (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V16QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 16)\n+\t\t     (const_int 1) (const_int 17)\n+\t\t     (const_int 2) (const_int 18)\n+\t\t     (const_int 3) (const_int 19)\n+\t\t     (const_int 4) (const_int 20)\n+\t\t     (const_int 5) (const_int 21)\n+\t\t     (const_int 6) (const_int 22)\n+\t\t     (const_int 7) (const_int 23)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvr.b\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V16QI\")])\n+\n+(define_insn \"msa_ilvr_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8HI\n+\t  (vec_concat:V16HI\n+\t    (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 8)\n+\t\t     (const_int 1) (const_int 9)\n+\t\t     (const_int 2) (const_int 10)\n+\t\t     (const_int 3) (const_int 11)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvr.h\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_ilvr_w\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SI\n+\t  (vec_concat:V8SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 1) (const_int 5)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvr.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_ilvr_w_f\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4SF\n+\t  (vec_concat:V8SF\n+\t    (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4SF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 1) (const_int 5)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvr.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_ilvr_d\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V2DI\n+\t  (vec_concat:V4DI\n+\t    (match_operand:V2DI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2DI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 2)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvr.d\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V2DI\")])\n+\n+(define_insn \"msa_ilvr_d_f\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=f\")\n+\t(vec_select:V2DF\n+\t  (vec_concat:V4DF\n+\t    (match_operand:V2DF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2DF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 2)])))]\n+  \"ISA_HAS_MSA\"\n+  \"ilvr.d\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"msa_madd_q_<msafmt>\"\n+  [(set (match_operand:IMSA_WH 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA_WH [(match_operand:IMSA_WH 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:IMSA_WH 2 \"register_operand\" \"f\")\n+\t\t\t (match_operand:IMSA_WH 3 \"register_operand\" \"f\")]\n+\t\t\tUNSPEC_MSA_MADD_Q))]\n+  \"ISA_HAS_MSA\"\n+  \"madd_q.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_maddr_q_<msafmt>\"\n+  [(set (match_operand:IMSA_WH 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA_WH [(match_operand:IMSA_WH 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:IMSA_WH 2 \"register_operand\" \"f\")\n+\t\t\t (match_operand:IMSA_WH 3 \"register_operand\" \"f\")]\n+\t\t\tUNSPEC_MSA_MADDR_Q))]\n+  \"ISA_HAS_MSA\"\n+  \"maddr_q.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_max_a_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(if_then_else\n+\t   (gt (abs:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\"))\n+\t       (abs:IMSA (match_operand:IMSA 2 \"register_operand\" \"f\")))\n+\t   (match_dup 1)\n+\t   (match_dup 2)))]\n+  \"ISA_HAS_MSA\"\n+  \"max_a.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"smax<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(smax:IMSA (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t\t   (match_operand:IMSA 2 \"reg_or_vector_same_simm5_operand\" \"f,Usv5\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   max_s.<msafmt>\\t%w0,%w1,%w2\n+   maxi_s.<msafmt>\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"umax<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(umax:IMSA (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t\t   (match_operand:IMSA 2 \"reg_or_vector_same_uimm5_operand\" \"f,Uuv5\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   max_u.<msafmt>\\t%w0,%w1,%w2\n+   maxi_u.<msafmt>\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_min_a_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(if_then_else\n+\t   (lt (abs:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\"))\n+\t       (abs:IMSA (match_operand:IMSA 2 \"register_operand\" \"f\")))\n+\t   (match_dup 1)\n+\t   (match_dup 2)))]\n+  \"ISA_HAS_MSA\"\n+  \"min_a.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"smin<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(smin:IMSA (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t\t   (match_operand:IMSA 2 \"reg_or_vector_same_simm5_operand\" \"f,Usv5\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   min_s.<msafmt>\\t%w0,%w1,%w2\n+   mini_s.<msafmt>\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"umin<mode>3\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(umin:IMSA (match_operand:IMSA 1 \"register_operand\" \"f,f\")\n+\t\t   (match_operand:IMSA 2 \"reg_or_vector_same_uimm5_operand\" \"f,Uuv5\")))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   min_u.<msafmt>\\t%w0,%w1,%w2\n+   mini_u.<msafmt>\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_msub_q_<msafmt>\"\n+  [(set (match_operand:IMSA_WH 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA_WH [(match_operand:IMSA_WH 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:IMSA_WH 2 \"register_operand\" \"f\")\n+\t\t\t (match_operand:IMSA_WH 3 \"register_operand\" \"f\")]\n+\t\t\tUNSPEC_MSA_MSUB_Q))]\n+  \"ISA_HAS_MSA\"\n+  \"msub_q.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_msubr_q_<msafmt>\"\n+  [(set (match_operand:IMSA_WH 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA_WH [(match_operand:IMSA_WH 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:IMSA_WH 2 \"register_operand\" \"f\")\n+\t\t\t (match_operand:IMSA_WH 3 \"register_operand\" \"f\")]\n+\t\t\tUNSPEC_MSA_MSUBR_Q))]\n+  \"ISA_HAS_MSA\"\n+  \"msubr_q.<msafmt>\\t%w0,%w2,%w3\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_mul_q_<msafmt>\"\n+  [(set (match_operand:IMSA_WH 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA_WH [(match_operand:IMSA_WH 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand:IMSA_WH 2 \"register_operand\" \"f\")]\n+\t\t\tUNSPEC_MSA_MUL_Q))]\n+  \"ISA_HAS_MSA\"\n+  \"mul_q.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_mulr_q_<msafmt>\"\n+  [(set (match_operand:IMSA_WH 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA_WH [(match_operand:IMSA_WH 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand:IMSA_WH 2 \"register_operand\" \"f\")]\n+\t\t\tUNSPEC_MSA_MULR_Q))]\n+  \"ISA_HAS_MSA\"\n+  \"mulr_q.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_mul\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_nloc_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_NLOC))]\n+  \"ISA_HAS_MSA\"\n+  \"nloc.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"clz<mode>2\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(clz:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"nlzc.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_bit\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_nor_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f,f\")\n+\t(and:IMSA (not:IMSA (match_operand:IMSA 1 \"register_operand\" \"f,f\"))\n+\t\t  (not:IMSA (match_operand:IMSA 2 \"reg_or_vector_same_val_operand\" \"f,Urv8\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"@\n+   nor.v\\t%w0,%w1,%w2\n+   nori.b\\t%w0,%w1,%B2\"\n+  [(set_attr \"type\" \"simd_logic\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_pckev_b\"\n+[(set (match_operand:V16QI 0 \"register_operand\" \"=f\")\n+      (vec_select:V16QI\n+\t(vec_concat:V32QI\n+\t  (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t  (match_operand:V16QI 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 0) (const_int 2)\n+\t\t   (const_int 4) (const_int 6)\n+\t\t   (const_int 8) (const_int 10)\n+\t\t   (const_int 12) (const_int 14)\n+\t\t   (const_int 16) (const_int 18)\n+\t\t   (const_int 20) (const_int 22)\n+\t\t   (const_int 24) (const_int 26)\n+\t\t   (const_int 28) (const_int 30)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckev.b\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V16QI\")])\n+\n+(define_insn \"msa_pckev_h\"\n+[(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+      (vec_select:V8HI\n+\t(vec_concat:V16HI\n+\t  (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t  (match_operand:V8HI 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 0) (const_int 2)\n+\t\t   (const_int 4) (const_int 6)\n+\t\t   (const_int 8) (const_int 10)\n+\t\t   (const_int 12) (const_int 14)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckev.h\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_pckev_w\"\n+[(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+      (vec_select:V4SI\n+\t(vec_concat:V8SI\n+\t  (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t  (match_operand:V4SI 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 0) (const_int 2)\n+\t\t   (const_int 4) (const_int 6)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckev.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_pckev_w_f\"\n+[(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+      (vec_select:V4SF\n+\t(vec_concat:V8SF\n+\t  (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t  (match_operand:V4SF 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 0) (const_int 2)\n+\t\t   (const_int 4) (const_int 6)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckev.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_pckod_b\"\n+[(set (match_operand:V16QI 0 \"register_operand\" \"=f\")\n+      (vec_select:V16QI\n+\t(vec_concat:V32QI\n+\t  (match_operand:V16QI 1 \"register_operand\" \"f\")\n+\t  (match_operand:V16QI 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 1) (const_int 3)\n+\t\t   (const_int 5) (const_int 7)\n+\t\t   (const_int 9) (const_int 11)\n+\t\t   (const_int 13) (const_int 15)\n+\t\t   (const_int 17) (const_int 19)\n+\t\t   (const_int 21) (const_int 23)\n+\t\t   (const_int 25) (const_int 27)\n+\t\t   (const_int 29) (const_int 31)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckod.b\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V16QI\")])\n+\n+(define_insn \"msa_pckod_h\"\n+[(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+      (vec_select:V8HI\n+\t(vec_concat:V16HI\n+\t  (match_operand:V8HI 1 \"register_operand\" \"f\")\n+\t  (match_operand:V8HI 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 1) (const_int 3)\n+\t\t   (const_int 5) (const_int 7)\n+\t\t   (const_int 9) (const_int 11)\n+\t\t   (const_int 13) (const_int 15)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckod.h\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"msa_pckod_w\"\n+[(set (match_operand:V4SI 0 \"register_operand\" \"=f\")\n+      (vec_select:V4SI\n+\t(vec_concat:V8SI\n+\t  (match_operand:V4SI 1 \"register_operand\" \"f\")\n+\t  (match_operand:V4SI 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 1) (const_int 3)\n+\t\t   (const_int 5) (const_int 7)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckod.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SI\")])\n+\n+(define_insn \"msa_pckod_w_f\"\n+[(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+      (vec_select:V4SF\n+\t(vec_concat:V8SF\n+\t  (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t  (match_operand:V4SF 2 \"register_operand\" \"f\"))\n+\t(parallel [(const_int 1) (const_int 3)\n+\t\t   (const_int 5) (const_int 7)])))]\n+  \"ISA_HAS_MSA\"\n+  \"pckod.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_permute\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"popcount<mode>2\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(popcount:IMSA (match_operand:IMSA 1 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_MSA\"\n+  \"pcnt.<msafmt>\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_pcnt\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_sat_s_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand 2 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_SAT_S))]\n+  \"ISA_HAS_MSA\"\n+  \"sat_s.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_sat\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_sat_u_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand 2 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_SAT_U))]\n+  \"ISA_HAS_MSA\"\n+  \"sat_u.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_sat\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_shf_<msafmt_f>\"\n+  [(set (match_operand:MSA_WHB_W 0 \"register_operand\" \"=f\")\n+\t(vec_select:MSA_WHB_W\n+\t  (match_operand:MSA_WHB_W 1 \"register_operand\" \"f\")\n+\t  (match_operand 2 \"par_const_vector_shf_set_operand\" \"\")))]\n+  \"ISA_HAS_MSA\"\n+{\n+  HOST_WIDE_INT val = 0;\n+  unsigned int i;\n+\n+  /* We convert the selection to an immediate.  */\n+  for (i = 0; i < 4; i++)\n+    val |= INTVAL (XVECEXP (operands[2], 0, i)) << (2 * i);\n+\n+  operands[2] = GEN_INT (val);\n+  return \"shf.<msafmt>\\t%w0,%w1,%X2\";\n+}\n+  [(set_attr \"type\" \"simd_shf\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_srar_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SRAR))]\n+  \"ISA_HAS_MSA\"\n+  \"srar.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_srari_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand 2 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_SRARI))]\n+  \"ISA_HAS_MSA\"\n+  \"srari.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_srlr_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SRLR))]\n+  \"ISA_HAS_MSA\"\n+  \"srlr.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_srlri_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand 2 \"const_<bitimm>_operand\" \"\")]\n+\t\t     UNSPEC_MSA_SRLRI))]\n+  \"ISA_HAS_MSA\"\n+  \"srlri.<msafmt>\\t%w0,%w1,%2\"\n+  [(set_attr \"type\" \"simd_shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_subs_s_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SUBS_S))]\n+  \"ISA_HAS_MSA\"\n+  \"subs_s.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_subs_u_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SUBS_U))]\n+  \"ISA_HAS_MSA\"\n+  \"subs_u.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_subsuu_s_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SUBSUU_S))]\n+  \"ISA_HAS_MSA\"\n+  \"subsuu_s.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_subsus_u_<msafmt>\"\n+  [(set (match_operand:IMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:IMSA [(match_operand:IMSA 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:IMSA 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SUBSUS_U))]\n+  \"ISA_HAS_MSA\"\n+  \"subsus_u.<msafmt>\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_int_arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_sld_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(unspec:MSA [(match_operand:MSA 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:MSA 2 \"register_operand\" \"f\")\n+\t\t     (match_operand:SI 3 \"reg_or_0_operand\" \"dJ\")]\n+\t\t    UNSPEC_MSA_SLD))]\n+  \"ISA_HAS_MSA\"\n+  \"sld.<msafmt>\\t%w0,%w2[%z3]\"\n+  [(set_attr \"type\" \"simd_sld\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_sldi_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(unspec:MSA [(match_operand:MSA 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:MSA 2 \"register_operand\" \"f\")\n+\t\t     (match_operand 3 \"const_<indeximm>_operand\" \"\")]\n+\t\t    UNSPEC_MSA_SLDI))]\n+  \"ISA_HAS_MSA\"\n+  \"sldi.<msafmt>\\t%w0,%w2[%3]\"\n+  [(set_attr \"type\" \"simd_sld\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_splat_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(unspec:MSA [(match_operand:MSA 1 \"register_operand\" \"f\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"d\")]\n+\t\t    UNSPEC_MSA_SPLAT))]\n+  \"ISA_HAS_MSA\"\n+  \"splat.<msafmt>\\t%w0,%w1[%z2]\"\n+  [(set_attr \"type\" \"simd_splat\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_splati_<msafmt_f>\"\n+  [(set (match_operand:MSA 0 \"register_operand\" \"=f\")\n+\t(vec_duplicate:MSA\n+\t  (vec_select:<UNITMODE>\n+\t    (match_operand:MSA 1 \"register_operand\" \"f\")\n+\t    (parallel [(match_operand 2 \"const_<indeximm>_operand\" \"\")]))))]\n+  \"ISA_HAS_MSA\"\n+  \"splati.<msafmt>\\t%w0,%w1[%2]\"\n+  [(set_attr \"type\" \"simd_splat\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_splati_<msafmt_f>_scalar\"\n+  [(set (match_operand:FMSA 0 \"register_operand\" \"=f\")\n+\t(unspec:FMSA [(match_operand:<UNITMODE> 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_SPLATI))]\n+  \"ISA_HAS_MSA\"\n+  \"splati.<msafmt>\\t%w0,%w1[0]\"\n+  [(set_attr \"type\" \"simd_splat\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"msa_cfcmsa\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec_volatile:SI [(match_operand 1 \"const_uimm5_operand\" \"\")]\n+\t\t\t    UNSPEC_MSA_CFCMSA))]\n+  \"ISA_HAS_MSA\"\n+  \"cfcmsa\\t%0,$%1\"\n+  [(set_attr \"type\" \"simd_cmsa\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"msa_ctcmsa\"\n+  [(unspec_volatile [(match_operand 0 \"const_uimm5_operand\" \"\")\n+\t\t     (match_operand:SI 1 \"register_operand\" \"d\")]\n+\t\t    UNSPEC_MSA_CTCMSA)]\n+  \"ISA_HAS_MSA\"\n+  \"ctcmsa\\t$%0,%1\"\n+  [(set_attr \"type\" \"simd_cmsa\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"msa_fexdo_h\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=f\")\n+\t(unspec:V8HI [(match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:V4SF 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FEXDO))]\n+  \"ISA_HAS_MSA\"\n+  \"fexdo.h\\t%w0,%w1,%w2\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"V8HI\")])\n+\n+(define_insn \"vec_pack_trunc_v2df\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(vec_concat:V4SF\n+\t  (float_truncate:V2SF (match_operand:V2DF 1 \"register_operand\" \"f\"))\n+\t  (float_truncate:V2SF (match_operand:V2DF 2 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_MSA\"\n+  \"fexdo.w\\t%w0,%w2,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_fexupl_w\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(unspec:V4SF [(match_operand:V8HI 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FEXUPL))]\n+  \"ISA_HAS_MSA\"\n+  \"fexupl.w\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_fexupl_d\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:V2DF\n+\t(vec_select:V2SF\n+\t  (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t  (parallel [(const_int 2) (const_int 3)]))))]\n+  \"ISA_HAS_MSA\"\n+  \"fexupl.d\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"msa_fexupr_w\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=f\")\n+\t(unspec:V4SF [(match_operand:V8HI 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_MSA_FEXUPR))]\n+  \"ISA_HAS_MSA\"\n+  \"fexupr.w\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"msa_fexupr_d\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:V2DF\n+\t(vec_select:V2SF\n+\t  (match_operand:V4SF 1 \"register_operand\" \"f\")\n+\t  (parallel [(const_int 0) (const_int 1)]))))]\n+  \"ISA_HAS_MSA\"\n+  \"fexupr.d\\t%w0,%w1\"\n+  [(set_attr \"type\" \"simd_fcvt\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_code_attr msabr\n+  [(eq \"bz\")\n+   (ne \"bnz\")])\n+\n+(define_code_attr msabr_neg\n+  [(eq \"bnz\")\n+   (ne \"bz\")])\n+\n+(define_insn \"msa_<msabr>_<msafmt_f>\"\n+ [(set (pc) (if_then_else\n+\t      (equality_op\n+\t\t(unspec:SI [(match_operand:MSA 1 \"register_operand\" \"f\")]\n+\t\t\t    UNSPEC_MSA_BRANCH)\n+\t\t  (match_operand:SI 2 \"const_0_operand\"))\n+\t\t  (label_ref (match_operand 0))\n+\t\t  (pc)))]\n+ \"ISA_HAS_MSA\"\n+{\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"<msabr>.<msafmt>\",\n+\t\t\t\t\t\t      \"%w1,%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"<msabr_neg>.<msafmt>\",\n+\t\t\t\t\t\t      \"%w1,%0\"));\n+}\n+ [(set_attr \"type\" \"simd_branch\")\n+  (set_attr \"mode\" \"<MODE>\")\n+  (set_attr \"compact_form\" \"never\")])\n+\n+(define_insn \"msa_<msabr>_v_<msafmt_f>\"\n+ [(set (pc) (if_then_else\n+\t      (equality_op\n+\t\t(unspec:SI [(match_operand:MSA 1 \"register_operand\" \"f\")]\n+\t\t\t    UNSPEC_MSA_BRANCH_V)\n+\t\t  (match_operand:SI 2 \"const_0_operand\"))\n+\t\t  (label_ref (match_operand 0))\n+\t\t  (pc)))]\n+ \"ISA_HAS_MSA\"\n+{\n+  return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t MIPS_BRANCH (\"<msabr>.v\", \"%w1,%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"<msabr_neg>.v\",\n+\t\t\t\t\t\t      \"%w1,%0\"));\n+}\n+ [(set_attr \"type\" \"simd_branch\")\n+  (set_attr \"mode\" \"TI\")\n+  (set_attr \"compact_form\" \"never\")])"}, {"sha": "09cf6626e273b042de9d5f84e3ba0062031f1b40", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -197,8 +197,9 @@ extern bool mips_stack_address_p (rtx, machine_mode);\n extern int mips_address_insns (rtx, machine_mode, bool);\n extern int mips_const_insns (rtx);\n extern int mips_split_const_insns (rtx);\n+extern int mips_split_128bit_const_insns (rtx);\n extern int mips_load_store_insns (rtx, rtx_insn *);\n-extern int mips_idiv_insns (void);\n+extern int mips_idiv_insns (machine_mode);\n extern rtx_insn *mips_emit_move (rtx, rtx);\n #ifdef RTX_CODE\n extern void mips_emit_binary (enum rtx_code, rtx, rtx, rtx);\n@@ -216,6 +217,11 @@ extern bool mips_split_move_p (rtx, rtx, enum mips_split_type);\n extern void mips_split_move (rtx, rtx, enum mips_split_type);\n extern bool mips_split_move_insn_p (rtx, rtx, rtx);\n extern void mips_split_move_insn (rtx, rtx, rtx);\n+extern void mips_split_128bit_move (rtx, rtx);\n+extern bool mips_split_128bit_move_p (rtx, rtx);\n+extern void mips_split_msa_copy_d (rtx, rtx, rtx, rtx (*)(rtx, rtx, rtx));\n+extern void mips_split_msa_insert_d (rtx, rtx, rtx, rtx);\n+extern void mips_split_msa_fill_d (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n extern bool mips_cfun_has_cprestore_slot_p (void);\n extern bool mips_cprestore_address_p (rtx, bool);\n@@ -278,6 +284,15 @@ extern void mips_expand_before_return (void);\n extern void mips_expand_epilogue (bool);\n extern bool mips_can_use_return_insn (void);\n \n+extern bool mips_const_vector_same_val_p (rtx, machine_mode);\n+extern bool mips_const_vector_same_bytes_p (rtx, machine_mode);\n+extern bool mips_const_vector_same_int_p (rtx, machine_mode, HOST_WIDE_INT,\n+\t\t\t\t\t  HOST_WIDE_INT);\n+extern bool mips_const_vector_shuffle_set_p (rtx, machine_mode);\n+extern bool mips_const_vector_bitimm_set_p (rtx, machine_mode);\n+extern bool mips_const_vector_bitimm_clr_p (rtx, machine_mode);\n+extern rtx mips_msa_vec_parallel_const_half (machine_mode, bool);\n+extern rtx mips_gen_const_int_vector (machine_mode, int);\n extern bool mips_secondary_memory_needed (enum reg_class, enum reg_class,\n \t\t\t\t\t  machine_mode);\n extern bool mips_cannot_change_mode_class (machine_mode,\n@@ -305,6 +320,7 @@ extern const char *mips_output_sync (void);\n extern const char *mips_output_sync_loop (rtx_insn *, rtx *);\n extern unsigned int mips_sync_loop_insns (rtx_insn *, rtx *);\n extern const char *mips_output_division (const char *, rtx *);\n+extern const char *mips_msa_output_division (const char *, rtx *);\n extern const char *mips_output_probe_stack_range (rtx, rtx);\n extern bool mips_hard_regno_rename_ok (unsigned int, unsigned int);\n extern unsigned int mips_hard_regno_nregs (int, machine_mode);\n@@ -343,6 +359,7 @@ extern void mips_expand_vec_reduc (rtx, rtx, rtx (*)(rtx, rtx, rtx));\n extern void mips_expand_vec_minmax (rtx, rtx, rtx,\n \t\t\t\t    rtx (*) (rtx, rtx, rtx), bool);\n \n+extern int mips_ldst_scaled_shift (machine_mode);\n extern bool mips_signed_immediate_p (unsigned HOST_WIDE_INT, int, int);\n extern bool mips_unsigned_immediate_p (unsigned HOST_WIDE_INT, int, int);\n extern const char *umips_output_save_restore (bool, rtx);\n@@ -372,5 +389,6 @@ extern mulsidi3_gen_fn mips_mulsidi3_gen_fn (enum rtx_code);\n #endif\n \n extern void mips_register_frame_header_opt (void);\n+extern void mips_expand_vec_cond_expr (machine_mode, machine_mode, rtx *);\n \n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "06acd30ec25dfb772f7950a1c03b34a9939ba269", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2187, "deletions": 42, "changes": 2229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -244,6 +244,10 @@ enum mips_builtin_type {\n   /* As above, but the instruction only sets a single $fcc register.  */\n   MIPS_BUILTIN_CMP_SINGLE,\n \n+  /* The function corresponds to an MSA conditional branch instruction\n+     combined with a compare instruction.  */\n+  MIPS_BUILTIN_MSA_TEST_BRANCH,\n+\n   /* For generating bposge32 branch instructions in MIPS32 DSP ASE.  */\n   MIPS_BUILTIN_BPOSGE32\n };\n@@ -1126,6 +1130,7 @@ static int mips_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static unsigned int mips_function_arg_boundary (machine_mode, const_tree);\n static machine_mode mips_get_reg_raw_mode (int regno);\n+static rtx mips_gen_const_int_vector_shuffle (machine_mode, int);\n \f\n /* This hash table keeps track of implicit \"mips16\" and \"nomips16\" attributes\n    for -mflip_mips16.  It maps decl names onto a boolean mode setting.  */\n@@ -1835,6 +1840,140 @@ mips_symbol_binds_local_p (const_rtx x)\n \t  : SYMBOL_REF_LOCAL_P (x));\n }\n \n+/* Return true if OP is a constant vector with the number of units in MODE,\n+   and each unit has the same bit set.  */\n+\n+bool\n+mips_const_vector_bitimm_set_p (rtx op, machine_mode mode)\n+{\n+  if (GET_CODE (op) == CONST_VECTOR && op != CONST0_RTX (mode))\n+    {\n+      unsigned HOST_WIDE_INT val = UINTVAL (CONST_VECTOR_ELT (op, 0));\n+      int vlog2 = exact_log2 (val & GET_MODE_MASK (GET_MODE_INNER (mode)));\n+\n+      if (vlog2 != -1)\n+\t{\n+\t  gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_INT);\n+\t  gcc_assert (vlog2 >= 0 && vlog2 <= GET_MODE_UNIT_BITSIZE (mode) - 1);\n+\t  return mips_const_vector_same_val_p (op, mode);\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if OP is a constant vector with the number of units in MODE,\n+   and each unit has the same bit clear.  */\n+\n+bool\n+mips_const_vector_bitimm_clr_p (rtx op, machine_mode mode)\n+{\n+  if (GET_CODE (op) == CONST_VECTOR && op != CONSTM1_RTX (mode))\n+    {\n+      unsigned HOST_WIDE_INT val = ~UINTVAL (CONST_VECTOR_ELT (op, 0));\n+      int vlog2 = exact_log2 (val & GET_MODE_MASK (GET_MODE_INNER (mode)));\n+\n+      if (vlog2 != -1)\n+\t{\n+\t  gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_INT);\n+\t  gcc_assert (vlog2 >= 0 && vlog2 <= GET_MODE_UNIT_BITSIZE (mode) - 1);\n+\t  return mips_const_vector_same_val_p (op, mode);\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if OP is a constant vector with the number of units in MODE,\n+   and each unit has the same value.  */\n+\n+bool\n+mips_const_vector_same_val_p (rtx op, machine_mode mode)\n+{\n+  int i, nunits = GET_MODE_NUNITS (mode);\n+  rtx first;\n+\n+  if (GET_CODE (op) != CONST_VECTOR || GET_MODE (op) != mode)\n+    return false;\n+\n+  first = CONST_VECTOR_ELT (op, 0);\n+  for (i = 1; i < nunits; i++)\n+    if (!rtx_equal_p (first, CONST_VECTOR_ELT (op, i)))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true if OP is a constant vector with the number of units in MODE,\n+   and each unit has the same value as well as replicated bytes in the value.\n+*/\n+\n+bool\n+mips_const_vector_same_bytes_p (rtx op, machine_mode mode)\n+{\n+  int i, bytes;\n+  HOST_WIDE_INT val, first_byte;\n+  rtx first;\n+\n+  if (!mips_const_vector_same_val_p (op, mode))\n+    return false;\n+\n+  first = CONST_VECTOR_ELT (op, 0);\n+  bytes = GET_MODE_UNIT_SIZE (mode);\n+  val = INTVAL (first);\n+  first_byte = val & 0xff;\n+  for (i = 1; i < bytes; i++)\n+    {\n+      val >>= 8;\n+      if ((val & 0xff) != first_byte)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if OP is a constant vector with the number of units in MODE,\n+   and each unit has the same integer value in the range [LOW, HIGH].  */\n+\n+bool\n+mips_const_vector_same_int_p (rtx op, machine_mode mode, HOST_WIDE_INT low,\n+\t\t\t      HOST_WIDE_INT high)\n+{\n+  HOST_WIDE_INT value;\n+  rtx elem0;\n+\n+  if (!mips_const_vector_same_val_p (op, mode))\n+    return false;\n+\n+  elem0 = CONST_VECTOR_ELT (op, 0);\n+  if (!CONST_INT_P (elem0))\n+    return false;\n+\n+  value = INTVAL (elem0);\n+  return (value >= low && value <= high);\n+}\n+\n+/* Return true if OP is a constant vector with repeated 4-element sets\n+   in mode MODE.  */\n+\n+bool\n+mips_const_vector_shuffle_set_p (rtx op, machine_mode mode)\n+{\n+  int nunits = GET_MODE_NUNITS (mode);\n+  int nsets = nunits / 4;\n+  int set = 0;\n+  int i, j;\n+\n+  /* Check if we have the same 4-element sets.  */\n+  for (j = 0; j < nsets; j++, set = 4 * j)\n+    for (i = 0; i < 4; i++)\n+      if ((INTVAL (XVECEXP (op, 0, i))\n+\t   != (INTVAL (XVECEXP (op, 0, set + i)) - set))\n+\t  || !IN_RANGE (INTVAL (XVECEXP (op, 0, set + i)), 0, set + 3))\n+\treturn false;\n+  return true;\n+}\n+\n /* Return true if rtx constants of mode MODE should be put into a small\n    data section.  */\n \n@@ -2206,6 +2345,11 @@ mips_symbol_insns_1 (enum mips_symbol_type type, machine_mode mode)\n static int\n mips_symbol_insns (enum mips_symbol_type type, machine_mode mode)\n {\n+  /* MSA LD.* and ST.* cannot support loading symbols via an immediate\n+     operand.  */\n+  if (MSA_SUPPORTED_MODE_P (mode))\n+    return 0;\n+\n   return mips_symbol_insns_1 (type, mode) * (TARGET_MIPS16 ? 2 : 1);\n }\n \f\n@@ -2325,6 +2469,12 @@ mips_valid_offset_p (rtx x, machine_mode mode)\n       && !SMALL_OPERAND (INTVAL (x) + GET_MODE_SIZE (mode) - UNITS_PER_WORD))\n     return false;\n \n+  /* MSA LD.* and ST.* supports 10-bit signed offsets.  */\n+  if (MSA_SUPPORTED_MODE_P (mode)\n+      && !mips_signed_immediate_p (INTVAL (x), 10,\n+\t\t\t\t   mips_ldst_scaled_shift (mode)))\n+    return false;\n+\n   return true;\n }\n \n@@ -2351,6 +2501,10 @@ mips_valid_lo_sum_p (enum mips_symbol_type symbol_type, machine_mode mode)\n       && GET_MODE_BITSIZE (mode) > GET_MODE_ALIGNMENT (mode))\n     return false;\n \n+  /* MSA LD.* and ST.* cannot support loading symbols via %lo($base).  */\n+  if (MSA_SUPPORTED_MODE_P (mode))\n+    return false;\n+\n   return true;\n }\n \n@@ -2480,6 +2634,8 @@ mips_lx_address_p (rtx addr, machine_mode mode)\n     return true;\n   if (ISA_HAS_LDX && mode == DImode)\n     return true;\n+  if (MSA_SUPPORTED_MODE_P (mode))\n+    return true;\n   return false;\n }\n \f\n@@ -2517,6 +2673,7 @@ mips_address_insns (rtx x, machine_mode mode, bool might_split_p)\n {\n   struct mips_address_info addr;\n   int factor;\n+  bool msa_p = (!might_split_p && MSA_SUPPORTED_MODE_P (mode));\n \n   /* BLKmode is used for single unaligned loads and stores and should\n      not count as a multiword mode.  (GET_MODE_SIZE (BLKmode) is pretty\n@@ -2531,20 +2688,29 @@ mips_address_insns (rtx x, machine_mode mode, bool might_split_p)\n     switch (addr.type)\n       {\n       case ADDRESS_REG:\n+\tif (msa_p)\n+\t  {\n+\t    /* MSA LD.* and ST.* supports 10-bit signed offsets.  */\n+\t    if (mips_signed_immediate_p (INTVAL (addr.offset), 10,\n+\t\t\t\t\t mips_ldst_scaled_shift (mode)))\n+\t      return 1;\n+\t    else\n+\t      return 0;\n+\t  }\n \tif (TARGET_MIPS16\n \t    && !mips16_unextended_reference_p (mode, addr.reg,\n \t\t\t\t\t       UINTVAL (addr.offset)))\n \t  return factor * 2;\n \treturn factor;\n \n       case ADDRESS_LO_SUM:\n-\treturn TARGET_MIPS16 ? factor * 2 : factor;\n+\treturn msa_p ? 0 : TARGET_MIPS16 ? factor * 2 : factor;\n \n       case ADDRESS_CONST_INT:\n-\treturn factor;\n+\treturn msa_p ? 0 : factor;\n \n       case ADDRESS_SYMBOLIC:\n-\treturn factor * mips_symbol_insns (addr.symbol_type, mode);\n+\treturn msa_p ? 0 : factor * mips_symbol_insns (addr.symbol_type, mode);\n       }\n   return 0;\n }\n@@ -2568,6 +2734,19 @@ mips_signed_immediate_p (unsigned HOST_WIDE_INT x, int bits, int shift = 0)\n   return mips_unsigned_immediate_p (x, bits, shift);\n }\n \n+/* Return the scale shift that applied to MSA LD/ST address offset.  */\n+\n+int\n+mips_ldst_scaled_shift (machine_mode mode)\n+{\n+  int shift = exact_log2 (GET_MODE_UNIT_SIZE (mode));\n+\n+  if (shift < 0 || shift > 8)\n+    gcc_unreachable ();\n+\n+  return shift;\n+}\n+\n /* Return true if X is legitimate for accessing values of mode MODE,\n    if it is based on a MIPS16 register, and if the offset satisfies\n    OFFSET_PREDICATE.  */\n@@ -2663,8 +2842,12 @@ mips_const_insns (rtx x)\n \n       return mips_build_integer (codes, INTVAL (x));\n \n-    case CONST_DOUBLE:\n     case CONST_VECTOR:\n+      if (ISA_HAS_MSA\n+\t  && mips_const_vector_same_int_p (x, GET_MODE (x), -512, 511))\n+\treturn 1;\n+      /* Fall through.  */\n+    case CONST_DOUBLE:\n       /* Allow zeros for normal mode, where we can use $0.  */\n       return !TARGET_MIPS16 && x == CONST0_RTX (GET_MODE (x)) ? 1 : 0;\n \n@@ -2724,6 +2907,26 @@ mips_split_const_insns (rtx x)\n   return low + high;\n }\n \n+/* Return one word of 128-bit value OP, taking into account the fixed\n+   endianness of certain registers.  BYTE selects from the byte address.  */\n+\n+rtx\n+mips_subword_at_byte (rtx op, unsigned int byte)\n+{\n+  machine_mode mode;\n+\n+  mode = GET_MODE (op);\n+  if (mode == VOIDmode)\n+    mode = TImode;\n+\n+  gcc_assert (!FP_REG_RTX_P (op));\n+\n+  if (MEM_P (op))\n+    return mips_rewrite_small_data (adjust_address (op, word_mode, byte));\n+\n+  return simplify_gen_subreg (word_mode, op, mode, byte);\n+}\n+\n /* Return the number of instructions needed to implement INSN,\n    given that it loads from or stores to MEM.  Assume that\n    BASE_INSN_LENGTH is the length of one instruction.  */\n@@ -2754,14 +2957,14 @@ mips_load_store_insns (rtx mem, rtx_insn *insn)\n    assuming that BASE_INSN_LENGTH is the length of one instruction.  */\n \n int\n-mips_idiv_insns (void)\n+mips_idiv_insns (machine_mode mode)\n {\n   int count;\n \n   count = 1;\n   if (TARGET_CHECK_ZERO_DIV)\n     {\n-      if (GENERATE_DIVIDE_TRAPS)\n+      if (GENERATE_DIVIDE_TRAPS && !MSA_SUPPORTED_MODE_P (mode))\n         count++;\n       else\n         count += 2;\n@@ -2771,6 +2974,7 @@ mips_idiv_insns (void)\n     count++;\n   return count;\n }\n+\n \f\n /* Emit a move from SRC to DEST.  Assume that the move expanders can\n    handle all moves if !can_create_pseudo_p ().  The distinction is\n@@ -3478,7 +3682,14 @@ mips_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n bool\n mips_legitimize_move (machine_mode mode, rtx dest, rtx src)\n {\n-  if (!register_operand (dest, mode) && !reg_or_0_operand (src, mode))\n+  /* Both src and dest are non-registers;  one special case is supported where\n+     the source is (const_int 0) and the store can source the zero register.\n+     MIPS16 and MSA are never able to source the zero register directly in\n+     memory operations.  */\n+  if (!register_operand (dest, mode)\n+      && !register_operand (src, mode)\n+      && (TARGET_MIPS16 || !const_0_operand (src, mode)\n+\t  || MSA_SUPPORTED_MODE_P (mode)))\n     {\n       mips_emit_move (dest, force_reg (mode, src));\n       return true;\n@@ -4044,6 +4255,10 @@ mips_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case NE:\n     case UNORDERED:\n     case LTGT:\n+    case UNGE:\n+    case UNGT:\n+    case UNLE:\n+    case UNLT:\n       /* Branch comparisons have VOIDmode, so use the first operand's\n \t mode instead.  */\n       mode = GET_MODE (XEXP (x, 0));\n@@ -4208,7 +4423,7 @@ mips_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t      *total += set_src_cost (XEXP (x, 0), mode, speed);\n \t      return true;\n \t    }\n-\t  *total = COSTS_N_INSNS (mips_idiv_insns ());\n+\t  *total = COSTS_N_INSNS (mips_idiv_insns (mode));\n \t}\n       else if (mode == DImode)\n         *total = mips_cost->int_div_di;\n@@ -4514,6 +4729,10 @@ mips_split_move_p (rtx dest, rtx src, enum mips_split_type split_type)\n \treturn false;\n     }\n \n+  /* Check if MSA moves need splitting.  */\n+  if (MSA_SUPPORTED_MODE_P (GET_MODE (dest)))\n+    return mips_split_128bit_move_p (dest, src);\n+\n   /* Otherwise split all multiword moves.  */\n   return size > UNITS_PER_WORD;\n }\n@@ -4527,7 +4746,9 @@ mips_split_move (rtx dest, rtx src, enum mips_split_type split_type)\n   rtx low_dest;\n \n   gcc_checking_assert (mips_split_move_p (dest, src, split_type));\n-  if (FP_REG_RTX_P (dest) || FP_REG_RTX_P (src))\n+  if (MSA_SUPPORTED_MODE_P (GET_MODE (dest)))\n+    mips_split_128bit_move (dest, src);\n+  else if (FP_REG_RTX_P (dest) || FP_REG_RTX_P (src))\n     {\n       if (!TARGET_64BIT && GET_MODE (dest) == DImode)\n \temit_insn (gen_move_doubleword_fprdi (dest, src));\n@@ -4600,6 +4821,199 @@ mips_insn_split_type (rtx insn)\n   return SPLIT_IF_NECESSARY;\n }\n \n+/* Return true if a 128-bit move from SRC to DEST should be split.  */\n+\n+bool\n+mips_split_128bit_move_p (rtx dest, rtx src)\n+{\n+  /* MSA-to-MSA moves can be done in a single instruction.  */\n+  if (FP_REG_RTX_P (src) && FP_REG_RTX_P (dest))\n+    return false;\n+\n+  /* Check for MSA loads and stores.  */\n+  if (FP_REG_RTX_P (dest) && MEM_P (src))\n+    return false;\n+  if (FP_REG_RTX_P (src) && MEM_P (dest))\n+    return false;\n+\n+  /* Check for MSA set to an immediate const vector with valid replicated\n+     element.  */\n+  if (FP_REG_RTX_P (dest)\n+      && mips_const_vector_same_int_p (src, GET_MODE (src), -512, 511))\n+    return false;\n+\n+  /* Check for MSA load zero immediate.  */\n+  if (FP_REG_RTX_P (dest) && src == CONST0_RTX (GET_MODE (src)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Split a 128-bit move from SRC to DEST.  */\n+\n+void\n+mips_split_128bit_move (rtx dest, rtx src)\n+{\n+  int byte, index;\n+  rtx low_dest, low_src, d, s;\n+\n+  if (FP_REG_RTX_P (dest))\n+    {\n+      gcc_assert (!MEM_P (src));\n+\n+      rtx new_dest = dest;\n+      if (!TARGET_64BIT)\n+\t{\n+\t  if (GET_MODE (dest) != V4SImode)\n+\t    new_dest = simplify_gen_subreg (V4SImode, dest, GET_MODE (dest), 0);\n+\t}\n+      else\n+\t{\n+\t  if (GET_MODE (dest) != V2DImode)\n+\t    new_dest = simplify_gen_subreg (V2DImode, dest, GET_MODE (dest), 0);\n+\t}\n+\n+      for (byte = 0, index = 0; byte < GET_MODE_SIZE (TImode);\n+\t   byte += UNITS_PER_WORD, index++)\n+\t{\n+\t  s = mips_subword_at_byte (src, byte);\n+\t  if (!TARGET_64BIT)\n+\t    emit_insn (gen_msa_insert_w (new_dest, s, new_dest,\n+\t\t\t\t\t GEN_INT (1 << index)));\n+\t  else\n+\t    emit_insn (gen_msa_insert_d (new_dest, s, new_dest,\n+\t\t\t\t\t GEN_INT (1 << index)));\n+\t}\n+    }\n+  else if (FP_REG_RTX_P (src))\n+    {\n+      gcc_assert (!MEM_P (dest));\n+\n+      rtx new_src = src;\n+      if (!TARGET_64BIT)\n+\t{\n+\t  if (GET_MODE (src) != V4SImode)\n+\t    new_src = simplify_gen_subreg (V4SImode, src, GET_MODE (src), 0);\n+\t}\n+      else\n+\t{\n+\t  if (GET_MODE (src) != V2DImode)\n+\t    new_src = simplify_gen_subreg (V2DImode, src, GET_MODE (src), 0);\n+\t}\n+\n+      for (byte = 0, index = 0; byte < GET_MODE_SIZE (TImode);\n+\t   byte += UNITS_PER_WORD, index++)\n+\t{\n+\t  d = mips_subword_at_byte (dest, byte);\n+\t  if (!TARGET_64BIT)\n+\t    emit_insn (gen_msa_copy_s_w (d, new_src, GEN_INT (index)));\n+\t  else\n+\t    emit_insn (gen_msa_copy_s_d (d, new_src, GEN_INT (index)));\n+\t}\n+    }\n+  else\n+    {\n+      low_dest = mips_subword_at_byte (dest, 0);\n+      low_src = mips_subword_at_byte (src, 0);\n+      gcc_assert (REG_P (low_dest) && REG_P (low_src));\n+      /* Make sure the source register is not written before reading.  */\n+      if (REGNO (low_dest) <= REGNO (low_src))\n+\t{\n+\t  for (byte = 0; byte < GET_MODE_SIZE (TImode);\n+\t       byte += UNITS_PER_WORD)\n+\t    {\n+\t      d = mips_subword_at_byte (dest, byte);\n+\t      s = mips_subword_at_byte (src, byte);\n+\t      mips_emit_move (d, s);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (byte = GET_MODE_SIZE (TImode) - UNITS_PER_WORD; byte >= 0;\n+\t       byte -= UNITS_PER_WORD)\n+\t    {\n+\t      d = mips_subword_at_byte (dest, byte);\n+\t      s = mips_subword_at_byte (src, byte);\n+\t      mips_emit_move (d, s);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Split a COPY_S.D with operands DEST, SRC and INDEX.  GEN is a function\n+   used to generate subregs.  */\n+\n+void\n+mips_split_msa_copy_d (rtx dest, rtx src, rtx index,\n+\t\t       rtx (*gen_fn)(rtx, rtx, rtx))\n+{\n+  gcc_assert ((GET_MODE (src) == V2DImode && GET_MODE (dest) == DImode)\n+\t      || (GET_MODE (src) == V2DFmode && GET_MODE (dest) == DFmode));\n+\n+  /* Note that low is always from the lower index, and high is always\n+     from the higher index.  */\n+  rtx low = mips_subword (dest, false);\n+  rtx high = mips_subword (dest, true);\n+  rtx new_src = simplify_gen_subreg (V4SImode, src, GET_MODE (src), 0);\n+\n+  emit_insn (gen_fn (low, new_src, GEN_INT (INTVAL (index) * 2)));\n+  emit_insn (gen_fn (high, new_src, GEN_INT (INTVAL (index) * 2 + 1)));\n+}\n+\n+/* Split a INSERT.D with operand DEST, SRC1.INDEX and SRC2.  */\n+\n+void\n+mips_split_msa_insert_d (rtx dest, rtx src1, rtx index, rtx src2)\n+{\n+  int i;\n+  gcc_assert (GET_MODE (dest) == GET_MODE (src1));\n+  gcc_assert ((GET_MODE (dest) == V2DImode\n+\t       && (GET_MODE (src2) == DImode || src2 == const0_rtx))\n+\t      || (GET_MODE (dest) == V2DFmode && GET_MODE (src2) == DFmode));\n+\n+  /* Note that low is always from the lower index, and high is always\n+     from the higher index.  */\n+  rtx low = mips_subword (src2, false);\n+  rtx high = mips_subword (src2, true);\n+  rtx new_dest = simplify_gen_subreg (V4SImode, dest, GET_MODE (dest), 0);\n+  rtx new_src1 = simplify_gen_subreg (V4SImode, src1, GET_MODE (src1), 0);\n+  i = exact_log2 (INTVAL (index));\n+  gcc_assert (i != -1);\n+\n+  emit_insn (gen_msa_insert_w (new_dest, low, new_src1,\n+\t\t\t       GEN_INT (1 << (i * 2))));\n+  emit_insn (gen_msa_insert_w (new_dest, high, new_dest,\n+\t\t\t       GEN_INT (1 << (i * 2 + 1))));\n+}\n+\n+/* Split FILL.D.  */\n+\n+void\n+mips_split_msa_fill_d (rtx dest, rtx src)\n+{\n+  gcc_assert ((GET_MODE (dest) == V2DImode\n+\t       && (GET_MODE (src) == DImode || src == const0_rtx))\n+\t      || (GET_MODE (dest) == V2DFmode && GET_MODE (src) == DFmode));\n+\n+  /* Note that low is always from the lower index, and high is always\n+     from the higher index.  */\n+  rtx low, high;\n+  if (src == const0_rtx)\n+    {\n+      low = src;\n+      high = src;\n+    }\n+  else\n+    {\n+      low = mips_subword (src, false);\n+      high = mips_subword (src, true);\n+    }\n+  rtx new_dest = simplify_gen_subreg (V4SImode, dest, GET_MODE (dest), 0);\n+  emit_insn (gen_msa_fill_w (new_dest, low));\n+  emit_insn (gen_msa_insert_w (new_dest, high, new_dest, GEN_INT (1 << 1)));\n+  emit_insn (gen_msa_insert_w (new_dest, high, new_dest, GEN_INT (1 << 3)));\n+}\n+\f\n /* Return true if a move from SRC to DEST in INSN should be split.  */\n \n bool\n@@ -4623,19 +5037,25 @@ mips_split_move_insn (rtx dest, rtx src, rtx insn)\n const char *\n mips_output_move (rtx dest, rtx src)\n {\n-  enum rtx_code dest_code, src_code;\n-  machine_mode mode;\n+  enum rtx_code dest_code = GET_CODE (dest);\n+  enum rtx_code src_code = GET_CODE (src);\n+  machine_mode mode = GET_MODE (dest);\n+  bool dbl_p = (GET_MODE_SIZE (mode) == 8);\n+  bool msa_p = MSA_SUPPORTED_MODE_P (mode);\n   enum mips_symbol_type symbol_type;\n-  bool dbl_p;\n-\n-  dest_code = GET_CODE (dest);\n-  src_code = GET_CODE (src);\n-  mode = GET_MODE (dest);\n-  dbl_p = (GET_MODE_SIZE (mode) == 8);\n \n   if (mips_split_move_p (dest, src, SPLIT_IF_NECESSARY))\n     return \"#\";\n \n+  if (msa_p\n+      && dest_code == REG && FP_REG_P (REGNO (dest))\n+      && src_code == CONST_VECTOR\n+      && CONST_INT_P (CONST_VECTOR_ELT (src, 0)))\n+    {\n+      gcc_assert (mips_const_vector_same_int_p (src, mode, -512, 511));\n+      return \"ldi.%v0\\t%w0,%E1\";\n+    }\n+\n   if ((src_code == REG && GP_REG_P (REGNO (src)))\n       || (!TARGET_MIPS16 && src == CONST0_RTX (mode)))\n     {\n@@ -4666,7 +5086,15 @@ mips_output_move (rtx dest, rtx src)\n \t    }\n \n \t  if (FP_REG_P (REGNO (dest)))\n-\t    return dbl_p ? \"dmtc1\\t%z1,%0\" : \"mtc1\\t%z1,%0\";\n+\t    {\n+\t      if (msa_p)\n+\t\t{\n+\t\t  gcc_assert (src == CONST0_RTX (GET_MODE (src)));\n+\t\t  return \"ldi.%v0\\t%w0,0\";\n+\t\t}\n+\n+\t      return dbl_p ? \"dmtc1\\t%z1,%0\" : \"mtc1\\t%z1,%0\";\n+\t    }\n \n \t  if (ALL_COP_REG_P (REGNO (dest)))\n \t    {\n@@ -4683,6 +5111,7 @@ mips_output_move (rtx dest, rtx src)\n \t  case 2: return \"sh\\t%z1,%0\";\n \t  case 4: return \"sw\\t%z1,%0\";\n \t  case 8: return \"sd\\t%z1,%0\";\n+\t  default: gcc_unreachable ();\n \t  }\n     }\n   if (dest_code == REG && GP_REG_P (REGNO (dest)))\n@@ -4711,7 +5140,10 @@ mips_output_move (rtx dest, rtx src)\n \t    }\n \n \t  if (FP_REG_P (REGNO (src)))\n-\t    return dbl_p ? \"dmfc1\\t%0,%1\" : \"mfc1\\t%0,%1\";\n+\t    {\n+\t      gcc_assert (!msa_p);\n+\t      return dbl_p ? \"dmfc1\\t%0,%1\" : \"mfc1\\t%0,%1\";\n+\t    }\n \n \t  if (ALL_COP_REG_P (REGNO (src)))\n \t    {\n@@ -4729,6 +5161,7 @@ mips_output_move (rtx dest, rtx src)\n \t  case 2: return \"lhu\\t%0,%1\";\n \t  case 4: return \"lw\\t%0,%1\";\n \t  case 8: return \"ld\\t%0,%1\";\n+\t  default: gcc_unreachable ();\n \t  }\n \n       if (src_code == CONST_INT)\n@@ -4775,17 +5208,29 @@ mips_output_move (rtx dest, rtx src)\n \t{\n \t  if (GET_MODE (dest) == V2SFmode)\n \t    return \"mov.ps\\t%0,%1\";\n+\t  else if (msa_p)\n+\t    return \"move.v\\t%w0,%w1\";\n \t  else\n \t    return dbl_p ? \"mov.d\\t%0,%1\" : \"mov.s\\t%0,%1\";\n \t}\n \n       if (dest_code == MEM)\n-\treturn dbl_p ? \"sdc1\\t%1,%0\" : \"swc1\\t%1,%0\";\n+\t{\n+\t  if (msa_p)\n+\t    return \"st.%v1\\t%w1,%0\";\n+\n+\t  return dbl_p ? \"sdc1\\t%1,%0\" : \"swc1\\t%1,%0\";\n+\t}\n     }\n   if (dest_code == REG && FP_REG_P (REGNO (dest)))\n     {\n       if (src_code == MEM)\n-\treturn dbl_p ? \"ldc1\\t%0,%1\" : \"lwc1\\t%0,%1\";\n+\t{\n+\t  if (msa_p)\n+\t    return \"ld.%v0\\t%w0,%1\";\n+\n+\t  return dbl_p ? \"ldc1\\t%0,%1\" : \"lwc1\\t%0,%1\";\n+\t}\n     }\n   if (dest_code == REG && ALL_COP_REG_P (REGNO (dest)) && src_code == MEM)\n     {\n@@ -8455,17 +8900,22 @@ mips_print_operand_punct_valid_p (unsigned char code)\n \n /* Implement TARGET_PRINT_OPERAND.  The MIPS-specific operand codes are:\n \n+   'E'\tPrint CONST_INT OP element 0 of a replicated CONST_VECTOR in decimal.\n    'X'\tPrint CONST_INT OP in hexadecimal format.\n    'x'\tPrint the low 16 bits of CONST_INT OP in hexadecimal format.\n    'd'\tPrint CONST_INT OP in decimal.\n+   'B'\tPrint CONST_INT OP element 0 of a replicated CONST_VECTOR\n+\t  as an unsigned byte [0..255].\n    'm'\tPrint one less than CONST_INT OP in decimal.\n+   'y'\tPrint exact log2 of CONST_INT OP in decimal.\n    'h'\tPrint the high-part relocation associated with OP, after stripping\n \t  any outermost HIGH.\n    'R'\tPrint the low-part relocation associated with OP.\n    'C'\tPrint the integer branch condition for comparison OP.\n    'N'\tPrint the inverse of the integer branch condition for comparison OP.\n    'F'\tPrint the FPU branch condition for comparison OP.\n    'W'\tPrint the inverse of the FPU branch condition for comparison OP.\n+   'w'\tPrint a MSA register.\n    'T'\tPrint 'f' for (eq:CC ...), 't' for (ne:CC ...),\n \t      'z' for (eq:?I ...), 'n' for (ne:?I ...).\n    't'\tLike 'T', but with the EQ/NE cases reversed\n@@ -8476,7 +8926,11 @@ mips_print_operand_punct_valid_p (unsigned char code)\n    'L'\tPrint the low-order register in a double-word register operand.\n    'M'\tPrint high-order register in a double-word register operand.\n    'z'\tPrint $0 if OP is zero, otherwise print OP normally.\n-   'b'\tPrint the address of a memory operand, without offset.  */\n+   'b'\tPrint the address of a memory operand, without offset.\n+   'v'\tPrint the insn size suffix b, h, w or d for vector modes V16QI, V8HI,\n+\t  V4SI, V2SI, and w, d for vector modes V4SF, V2DF respectively.\n+   'V'\tPrint exact log2 of CONST_INT OP element 0 of a replicated\n+\t  CONST_VECTOR in decimal.  */\n \n static void\n mips_print_operand (FILE *file, rtx op, int letter)\n@@ -8494,6 +8948,18 @@ mips_print_operand (FILE *file, rtx op, int letter)\n \n   switch (letter)\n     {\n+    case 'E':\n+      if (GET_CODE (op) == CONST_VECTOR)\n+\t{\n+\t  gcc_assert (mips_const_vector_same_val_p (op, GET_MODE (op)));\n+\t  op = CONST_VECTOR_ELT (op, 0);\n+\t  gcc_assert (CONST_INT_P (op));\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op));\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n+\n     case 'X':\n       if (CONST_INT_P (op))\n \tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));\n@@ -8515,13 +8981,54 @@ mips_print_operand (FILE *file, rtx op, int letter)\n \toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n+    case 'B':\n+      if (GET_CODE (op) == CONST_VECTOR)\n+\t{\n+\t  gcc_assert (mips_const_vector_same_val_p (op, GET_MODE (op)));\n+\t  op = CONST_VECTOR_ELT (op, 0);\n+\t  gcc_assert (CONST_INT_P (op));\n+\t  unsigned HOST_WIDE_INT val8 = UINTVAL (op) & GET_MODE_MASK (QImode);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_UNSIGNED, val8);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n+\n     case 'm':\n       if (CONST_INT_P (op))\n \tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op) - 1);\n       else\n \toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n+    case 'y':\n+      if (CONST_INT_P (op))\n+\t{\n+\t  int val = exact_log2 (INTVAL (op));\n+\t  if (val != -1)\n+\t    fprintf (file, \"%d\", val);\n+\t  else\n+\t    output_operand_lossage (\"invalid use of '%%%c'\", letter);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n+\n+    case 'V':\n+      if (GET_CODE (op) == CONST_VECTOR)\n+\t{\n+\t  machine_mode mode = GET_MODE_INNER (GET_MODE (op));\n+\t  unsigned HOST_WIDE_INT val = UINTVAL (CONST_VECTOR_ELT (op, 0));\n+\t  int vlog2 = exact_log2 (val & GET_MODE_MASK (mode));\n+\t  if (vlog2 != -1)\n+\t    fprintf (file, \"%d\", vlog2);\n+\t  else\n+\t    output_operand_lossage (\"invalid use of '%%%c'\", letter);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n+\n     case 'h':\n       if (code == HIGH)\n \top = XEXP (op, 0);\n@@ -8582,6 +9089,35 @@ mips_print_operand (FILE *file, rtx op, int letter)\n \toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n+    case 'w':\n+      if (code == REG && MSA_REG_P (REGNO (op)))\n+\tfprintf (file, \"$w%s\", &reg_names[REGNO (op)][2]);\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+      break;\n+\n+    case 'v':\n+      switch (GET_MODE (op))\n+\t{\n+\tcase V16QImode:\n+\t  fprintf (file, \"b\");\n+\t  break;\n+\tcase V8HImode:\n+\t  fprintf (file, \"h\");\n+\t  break;\n+\tcase V4SImode:\n+\tcase V4SFmode:\n+\t  fprintf (file, \"w\");\n+\t  break;\n+\tcase V2DImode:\n+\tcase V2DFmode:\n+\t  fprintf (file, \"d\");\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid use of '%%%c'\", letter);\n+\t}\n+      break;\n+\n     default:\n       switch (code)\n \t{\n@@ -9316,6 +9852,10 @@ mips_file_start (void)\n       attr = 1;\n \n     fprintf (asm_out_file, \"\\t.gnu_attribute 4, %d\\n\", attr);\n+\n+    /* 128-bit MSA.  */\n+    if (ISA_HAS_MSA)\n+      fprintf (asm_out_file, \"\\t.gnu_attribute 8, 1\\n\");\n   }\n #endif\n #endif\n@@ -12159,9 +12699,13 @@ mips_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n   size = GET_MODE_SIZE (mode);\n   mclass = GET_MODE_CLASS (mode);\n \n-  if (GP_REG_P (regno) && mode != CCFmode)\n+  if (GP_REG_P (regno) && mode != CCFmode && !MSA_SUPPORTED_MODE_P (mode))\n     return ((regno - GP_REG_FIRST) & 1) == 0 || size <= UNITS_PER_WORD;\n \n+  /* For MSA, allow TImode and 128-bit vector modes in all FPR.  */\n+  if (FP_REG_P (regno) && MSA_SUPPORTED_MODE_P (mode))\n+    return true;\n+\n   if (FP_REG_P (regno)\n       && (((regno - FP_REG_FIRST) % MAX_FPRS_PER_FMT) == 0\n \t  || (MIN_FPRS_PER_FMT == 1 && size <= UNITS_PER_FPREG)))\n@@ -12277,8 +12821,13 @@ mips_hard_regno_nregs (int regno, machine_mode mode)\n     return (GET_MODE_SIZE (mode) + 3) / 4;\n \n   if (FP_REG_P (regno))\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG;\n-\n+    {\n+      if (MSA_SUPPORTED_MODE_P (mode))\n+\treturn 1;\n+\n+      return (GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG;\n+    }\n+\n   /* All other registers are word-sized.  */\n   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n@@ -12298,12 +12847,19 @@ mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n     {\n       if (HARD_REGNO_MODE_OK (ST_REG_FIRST, mode))\n \tsize = MIN (size, 4);\n+\n       AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) ST_REGS]);\n     }\n   if (hard_reg_set_intersect_p (left, reg_class_contents[(int) FP_REGS]))\n     {\n       if (HARD_REGNO_MODE_OK (FP_REG_FIRST, mode))\n-\tsize = MIN (size, UNITS_PER_FPREG);\n+\t{\n+\t  if (MSA_SUPPORTED_MODE_P (mode))\n+\t    size = MIN (size, UNITS_PER_MSA_REG);\n+\t  else\n+\t    size = MIN (size, UNITS_PER_FPREG);\n+\t}\n+\n       AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) FP_REGS]);\n     }\n   if (!hard_reg_set_empty_p (left))\n@@ -12324,6 +12880,10 @@ mips_cannot_change_mode_class (machine_mode from,\n       && INTEGRAL_MODE_P (from) && INTEGRAL_MODE_P (to))\n     return false;\n \n+  /* Allow conversions between different MSA vector modes.  */\n+  if (MSA_SUPPORTED_MODE_P (from) && MSA_SUPPORTED_MODE_P (to))\n+    return false;\n+\n   /* Otherwise, there are several problems with changing the modes of\n      values in floating-point registers:\n \n@@ -12359,7 +12919,8 @@ mips_small_register_classes_for_mode_p (machine_mode mode\n   return TARGET_MIPS16;\n }\n \n-/* Return true if moves in mode MODE can use the FPU's mov.fmt instruction.  */\n+/* Return true if moves in mode MODE can use the FPU's mov.fmt instruction,\n+   or use the MSA's move.v instruction.  */\n \n static bool\n mips_mode_ok_for_mov_fmt_p (machine_mode mode)\n@@ -12377,7 +12938,7 @@ mips_mode_ok_for_mov_fmt_p (machine_mode mode)\n       return TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT;\n \n     default:\n-      return false;\n+      return MSA_SUPPORTED_MODE_P (mode);\n     }\n }\n \n@@ -12624,6 +13185,10 @@ mips_secondary_reload_class (enum reg_class rclass,\n \t   pairs of lwc1s and swc1s if ldc1 and sdc1 are not supported.  */\n \treturn NO_REGS;\n \n+      if (MEM_P (x) && MSA_SUPPORTED_MODE_P (mode))\n+\t/* In this case we can use MSA LD.* and ST.*.  */\n+\treturn NO_REGS;\n+\n       if (GP_REG_P (regno) || x == CONST0_RTX (mode))\n \t/* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n \treturn NO_REGS;\n@@ -12693,7 +13258,7 @@ mips_vector_mode_supported_p (machine_mode mode)\n       return TARGET_LOONGSON_VECTORS;\n \n     default:\n-      return false;\n+      return MSA_SUPPORTED_MODE_P (mode);\n     }\n }\n \n@@ -12712,14 +13277,46 @@ mips_scalar_mode_supported_p (machine_mode mode)\n /* Implement TARGET_VECTORIZE_PREFERRED_SIMD_MODE.  */\n \n static machine_mode\n-mips_preferred_simd_mode (machine_mode mode ATTRIBUTE_UNUSED)\n+mips_preferred_simd_mode (machine_mode mode)\n {\n   if (TARGET_PAIRED_SINGLE_FLOAT\n       && mode == SFmode)\n     return V2SFmode;\n+\n+  if (!ISA_HAS_MSA)\n+    return word_mode;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      return V16QImode;\n+    case HImode:\n+      return V8HImode;\n+    case SImode:\n+      return V4SImode;\n+    case DImode:\n+      return V2DImode;\n+\n+    case SFmode:\n+      return V4SFmode;\n+\n+    case DFmode:\n+      return V2DFmode;\n+\n+    default:\n+      break;\n+    }\n   return word_mode;\n }\n \n+/* Implement TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES.  */\n+\n+static unsigned int\n+mips_autovectorize_vector_sizes (void)\n+{\n+  return ISA_HAS_MSA ? 16 : 0;\n+}\n+\n /* Implement TARGET_INIT_LIBFUNCS.  */\n \n static void\n@@ -13727,6 +14324,25 @@ mips_output_division (const char *division, rtx *operands)\n     }\n   return s;\n }\n+\n+/* Return the assembly code for MSA DIV_{S,U}.DF or MOD_{S,U}.DF instructions,\n+   which has the operands given by OPERANDS.  Add in a divide-by-zero check\n+   if needed.  */\n+\n+const char *\n+mips_msa_output_division (const char *division, rtx *operands)\n+{\n+  const char *s;\n+\n+  s = division;\n+  if (TARGET_CHECK_ZERO_DIV)\n+    {\n+      output_asm_insn (\"%(bnz.%v0\\t%w2,1f\", operands);\n+      output_asm_insn (s, operands);\n+      s = \"break\\t7%)\\n1:\";\n+    }\n+  return s;\n+}\n \f\n /* Return true if destination of IN_INSN is used as add source in\n    OUT_INSN. Both IN_INSN and OUT_INSN are of type fmadd. Example:\n@@ -14480,6 +15096,7 @@ AVAIL_NON_MIPS16 (dsp_64, TARGET_64BIT && TARGET_DSP)\n AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)\n AVAIL_NON_MIPS16 (loongson, TARGET_LOONGSON_VECTORS)\n AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)\n+AVAIL_NON_MIPS16 (msa, TARGET_MSA)\n \n /* Construct a mips_builtin_description from the given arguments.\n \n@@ -14596,6 +15213,38 @@ AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)\n #define LOONGSON_BUILTIN_SUFFIX(INSN, SUFFIX, FUNCTION_TYPE)\t\t\\\n   LOONGSON_BUILTIN_ALIAS (INSN, INSN ## _ ## SUFFIX, FUNCTION_TYPE)\n \n+/* Define an MSA MIPS_BUILTIN_DIRECT function __builtin_msa_<INSN>\n+   for instruction CODE_FOR_msa_<INSN>.  FUNCTION_TYPE is a builtin_description\n+   field.  */\n+#define MSA_BUILTIN(INSN, FUNCTION_TYPE)\t\t\t\t\\\n+    { CODE_FOR_msa_ ## INSN, MIPS_FP_COND_f,\t\t\t\t\\\n+    \"__builtin_msa_\" #INSN,  MIPS_BUILTIN_DIRECT,\t\t\t\\\n+    FUNCTION_TYPE, mips_builtin_avail_msa }\n+\n+/* Define a remapped MSA MIPS_BUILTIN_DIRECT function __builtin_msa_<INSN>\n+   for instruction CODE_FOR_msa_<INSN2>.  FUNCTION_TYPE is\n+   a builtin_description field.  */\n+#define MSA_BUILTIN_REMAP(INSN, INSN2, FUNCTION_TYPE)\t\\\n+    { CODE_FOR_msa_ ## INSN2, MIPS_FP_COND_f,\t\t\t\t\\\n+    \"__builtin_msa_\" #INSN,  MIPS_BUILTIN_DIRECT,\t\t\t\\\n+    FUNCTION_TYPE, mips_builtin_avail_msa }\n+\n+/* Define an MSA MIPS_BUILTIN_MSA_TEST_BRANCH function __builtin_msa_<INSN>\n+   for instruction CODE_FOR_msa_<INSN>.  FUNCTION_TYPE is a builtin_description\n+   field.  */\n+#define MSA_BUILTIN_TEST_BRANCH(INSN, FUNCTION_TYPE)\t\t\t\\\n+    { CODE_FOR_msa_ ## INSN, MIPS_FP_COND_f,\t\t\t\t\\\n+    \"__builtin_msa_\" #INSN, MIPS_BUILTIN_MSA_TEST_BRANCH,\t\t\\\n+    FUNCTION_TYPE, mips_builtin_avail_msa }\n+\n+/* Define an MSA MIPS_BUILTIN_DIRECT_NO_TARGET function __builtin_msa_<INSN>\n+   for instruction CODE_FOR_msa_<INSN>.  FUNCTION_TYPE is a builtin_description\n+   field.  */\n+#define MSA_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE)\t\t\t\\\n+    { CODE_FOR_msa_ ## INSN, MIPS_FP_COND_f,\t\t\t\t\\\n+    \"__builtin_msa_\" #INSN,  MIPS_BUILTIN_DIRECT_NO_TARGET,\t\t\\\n+    FUNCTION_TYPE, mips_builtin_avail_msa }\n+\n #define CODE_FOR_mips_sqrt_ps CODE_FOR_sqrtv2sf2\n #define CODE_FOR_mips_addq_ph CODE_FOR_addv2hi3\n #define CODE_FOR_mips_addu_qb CODE_FOR_addv4qi3\n@@ -14636,6 +15285,203 @@ AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)\n #define CODE_FOR_loongson_psubush CODE_FOR_ussubv4hi3\n #define CODE_FOR_loongson_psubusb CODE_FOR_ussubv8qi3\n \n+#define CODE_FOR_msa_adds_s_b CODE_FOR_ssaddv16qi3\n+#define CODE_FOR_msa_adds_s_h CODE_FOR_ssaddv8hi3\n+#define CODE_FOR_msa_adds_s_w CODE_FOR_ssaddv4si3\n+#define CODE_FOR_msa_adds_s_d CODE_FOR_ssaddv2di3\n+#define CODE_FOR_msa_adds_u_b CODE_FOR_usaddv16qi3\n+#define CODE_FOR_msa_adds_u_h CODE_FOR_usaddv8hi3\n+#define CODE_FOR_msa_adds_u_w CODE_FOR_usaddv4si3\n+#define CODE_FOR_msa_adds_u_d CODE_FOR_usaddv2di3\n+#define CODE_FOR_msa_addv_b CODE_FOR_addv16qi3\n+#define CODE_FOR_msa_addv_h CODE_FOR_addv8hi3\n+#define CODE_FOR_msa_addv_w CODE_FOR_addv4si3\n+#define CODE_FOR_msa_addv_d CODE_FOR_addv2di3\n+#define CODE_FOR_msa_addvi_b CODE_FOR_addv16qi3\n+#define CODE_FOR_msa_addvi_h CODE_FOR_addv8hi3\n+#define CODE_FOR_msa_addvi_w CODE_FOR_addv4si3\n+#define CODE_FOR_msa_addvi_d CODE_FOR_addv2di3\n+#define CODE_FOR_msa_and_v CODE_FOR_andv16qi3\n+#define CODE_FOR_msa_andi_b CODE_FOR_andv16qi3\n+#define CODE_FOR_msa_bmnz_v CODE_FOR_msa_bmnz_b\n+#define CODE_FOR_msa_bmnzi_b CODE_FOR_msa_bmnz_b\n+#define CODE_FOR_msa_bmz_v CODE_FOR_msa_bmz_b\n+#define CODE_FOR_msa_bmzi_b CODE_FOR_msa_bmz_b\n+#define CODE_FOR_msa_bnz_v CODE_FOR_msa_bnz_v_b\n+#define CODE_FOR_msa_bz_v CODE_FOR_msa_bz_v_b\n+#define CODE_FOR_msa_bsel_v CODE_FOR_msa_bsel_b\n+#define CODE_FOR_msa_bseli_b CODE_FOR_msa_bsel_b\n+#define CODE_FOR_msa_ceqi_b CODE_FOR_msa_ceq_b\n+#define CODE_FOR_msa_ceqi_h CODE_FOR_msa_ceq_h\n+#define CODE_FOR_msa_ceqi_w CODE_FOR_msa_ceq_w\n+#define CODE_FOR_msa_ceqi_d CODE_FOR_msa_ceq_d\n+#define CODE_FOR_msa_clti_s_b CODE_FOR_msa_clt_s_b\n+#define CODE_FOR_msa_clti_s_h CODE_FOR_msa_clt_s_h\n+#define CODE_FOR_msa_clti_s_w CODE_FOR_msa_clt_s_w\n+#define CODE_FOR_msa_clti_s_d CODE_FOR_msa_clt_s_d\n+#define CODE_FOR_msa_clti_u_b CODE_FOR_msa_clt_u_b\n+#define CODE_FOR_msa_clti_u_h CODE_FOR_msa_clt_u_h\n+#define CODE_FOR_msa_clti_u_w CODE_FOR_msa_clt_u_w\n+#define CODE_FOR_msa_clti_u_d CODE_FOR_msa_clt_u_d\n+#define CODE_FOR_msa_clei_s_b CODE_FOR_msa_cle_s_b\n+#define CODE_FOR_msa_clei_s_h CODE_FOR_msa_cle_s_h\n+#define CODE_FOR_msa_clei_s_w CODE_FOR_msa_cle_s_w\n+#define CODE_FOR_msa_clei_s_d CODE_FOR_msa_cle_s_d\n+#define CODE_FOR_msa_clei_u_b CODE_FOR_msa_cle_u_b\n+#define CODE_FOR_msa_clei_u_h CODE_FOR_msa_cle_u_h\n+#define CODE_FOR_msa_clei_u_w CODE_FOR_msa_cle_u_w\n+#define CODE_FOR_msa_clei_u_d CODE_FOR_msa_cle_u_d\n+#define CODE_FOR_msa_div_s_b CODE_FOR_divv16qi3\n+#define CODE_FOR_msa_div_s_h CODE_FOR_divv8hi3\n+#define CODE_FOR_msa_div_s_w CODE_FOR_divv4si3\n+#define CODE_FOR_msa_div_s_d CODE_FOR_divv2di3\n+#define CODE_FOR_msa_div_u_b CODE_FOR_udivv16qi3\n+#define CODE_FOR_msa_div_u_h CODE_FOR_udivv8hi3\n+#define CODE_FOR_msa_div_u_w CODE_FOR_udivv4si3\n+#define CODE_FOR_msa_div_u_d CODE_FOR_udivv2di3\n+#define CODE_FOR_msa_fadd_w CODE_FOR_addv4sf3\n+#define CODE_FOR_msa_fadd_d CODE_FOR_addv2df3\n+#define CODE_FOR_msa_fexdo_w CODE_FOR_vec_pack_trunc_v2df\n+#define CODE_FOR_msa_ftrunc_s_w CODE_FOR_fix_truncv4sfv4si2\n+#define CODE_FOR_msa_ftrunc_s_d CODE_FOR_fix_truncv2dfv2di2\n+#define CODE_FOR_msa_ftrunc_u_w CODE_FOR_fixuns_truncv4sfv4si2\n+#define CODE_FOR_msa_ftrunc_u_d CODE_FOR_fixuns_truncv2dfv2di2\n+#define CODE_FOR_msa_ffint_s_w CODE_FOR_floatv4siv4sf2\n+#define CODE_FOR_msa_ffint_s_d CODE_FOR_floatv2div2df2\n+#define CODE_FOR_msa_ffint_u_w CODE_FOR_floatunsv4siv4sf2\n+#define CODE_FOR_msa_ffint_u_d CODE_FOR_floatunsv2div2df2\n+#define CODE_FOR_msa_fsub_w CODE_FOR_subv4sf3\n+#define CODE_FOR_msa_fsub_d CODE_FOR_subv2df3\n+#define CODE_FOR_msa_fmadd_w CODE_FOR_fmav4sf4\n+#define CODE_FOR_msa_fmadd_d CODE_FOR_fmav2df4\n+#define CODE_FOR_msa_fmsub_w CODE_FOR_fnmav4sf4\n+#define CODE_FOR_msa_fmsub_d CODE_FOR_fnmav2df4\n+#define CODE_FOR_msa_fmul_w CODE_FOR_mulv4sf3\n+#define CODE_FOR_msa_fmul_d CODE_FOR_mulv2df3\n+#define CODE_FOR_msa_fdiv_w CODE_FOR_divv4sf3\n+#define CODE_FOR_msa_fdiv_d CODE_FOR_divv2df3\n+#define CODE_FOR_msa_fmax_w CODE_FOR_smaxv4sf3\n+#define CODE_FOR_msa_fmax_d CODE_FOR_smaxv2df3\n+#define CODE_FOR_msa_fmin_w CODE_FOR_sminv4sf3\n+#define CODE_FOR_msa_fmin_d CODE_FOR_sminv2df3\n+#define CODE_FOR_msa_fsqrt_w CODE_FOR_sqrtv4sf2\n+#define CODE_FOR_msa_fsqrt_d CODE_FOR_sqrtv2df2\n+#define CODE_FOR_msa_max_s_b CODE_FOR_smaxv16qi3\n+#define CODE_FOR_msa_max_s_h CODE_FOR_smaxv8hi3\n+#define CODE_FOR_msa_max_s_w CODE_FOR_smaxv4si3\n+#define CODE_FOR_msa_max_s_d CODE_FOR_smaxv2di3\n+#define CODE_FOR_msa_maxi_s_b CODE_FOR_smaxv16qi3\n+#define CODE_FOR_msa_maxi_s_h CODE_FOR_smaxv8hi3\n+#define CODE_FOR_msa_maxi_s_w CODE_FOR_smaxv4si3\n+#define CODE_FOR_msa_maxi_s_d CODE_FOR_smaxv2di3\n+#define CODE_FOR_msa_max_u_b CODE_FOR_umaxv16qi3\n+#define CODE_FOR_msa_max_u_h CODE_FOR_umaxv8hi3\n+#define CODE_FOR_msa_max_u_w CODE_FOR_umaxv4si3\n+#define CODE_FOR_msa_max_u_d CODE_FOR_umaxv2di3\n+#define CODE_FOR_msa_maxi_u_b CODE_FOR_umaxv16qi3\n+#define CODE_FOR_msa_maxi_u_h CODE_FOR_umaxv8hi3\n+#define CODE_FOR_msa_maxi_u_w CODE_FOR_umaxv4si3\n+#define CODE_FOR_msa_maxi_u_d CODE_FOR_umaxv2di3\n+#define CODE_FOR_msa_min_s_b CODE_FOR_sminv16qi3\n+#define CODE_FOR_msa_min_s_h CODE_FOR_sminv8hi3\n+#define CODE_FOR_msa_min_s_w CODE_FOR_sminv4si3\n+#define CODE_FOR_msa_min_s_d CODE_FOR_sminv2di3\n+#define CODE_FOR_msa_mini_s_b CODE_FOR_sminv16qi3\n+#define CODE_FOR_msa_mini_s_h CODE_FOR_sminv8hi3\n+#define CODE_FOR_msa_mini_s_w CODE_FOR_sminv4si3\n+#define CODE_FOR_msa_mini_s_d CODE_FOR_sminv2di3\n+#define CODE_FOR_msa_min_u_b CODE_FOR_uminv16qi3\n+#define CODE_FOR_msa_min_u_h CODE_FOR_uminv8hi3\n+#define CODE_FOR_msa_min_u_w CODE_FOR_uminv4si3\n+#define CODE_FOR_msa_min_u_d CODE_FOR_uminv2di3\n+#define CODE_FOR_msa_mini_u_b CODE_FOR_uminv16qi3\n+#define CODE_FOR_msa_mini_u_h CODE_FOR_uminv8hi3\n+#define CODE_FOR_msa_mini_u_w CODE_FOR_uminv4si3\n+#define CODE_FOR_msa_mini_u_d CODE_FOR_uminv2di3\n+#define CODE_FOR_msa_mod_s_b CODE_FOR_modv16qi3\n+#define CODE_FOR_msa_mod_s_h CODE_FOR_modv8hi3\n+#define CODE_FOR_msa_mod_s_w CODE_FOR_modv4si3\n+#define CODE_FOR_msa_mod_s_d CODE_FOR_modv2di3\n+#define CODE_FOR_msa_mod_u_b CODE_FOR_umodv16qi3\n+#define CODE_FOR_msa_mod_u_h CODE_FOR_umodv8hi3\n+#define CODE_FOR_msa_mod_u_w CODE_FOR_umodv4si3\n+#define CODE_FOR_msa_mod_u_d CODE_FOR_umodv2di3\n+#define CODE_FOR_msa_mod_s_b CODE_FOR_modv16qi3\n+#define CODE_FOR_msa_mod_s_h CODE_FOR_modv8hi3\n+#define CODE_FOR_msa_mod_s_w CODE_FOR_modv4si3\n+#define CODE_FOR_msa_mod_s_d CODE_FOR_modv2di3\n+#define CODE_FOR_msa_mod_u_b CODE_FOR_umodv16qi3\n+#define CODE_FOR_msa_mod_u_h CODE_FOR_umodv8hi3\n+#define CODE_FOR_msa_mod_u_w CODE_FOR_umodv4si3\n+#define CODE_FOR_msa_mod_u_d CODE_FOR_umodv2di3\n+#define CODE_FOR_msa_mulv_b CODE_FOR_mulv16qi3\n+#define CODE_FOR_msa_mulv_h CODE_FOR_mulv8hi3\n+#define CODE_FOR_msa_mulv_w CODE_FOR_mulv4si3\n+#define CODE_FOR_msa_mulv_d CODE_FOR_mulv2di3\n+#define CODE_FOR_msa_nlzc_b CODE_FOR_clzv16qi2\n+#define CODE_FOR_msa_nlzc_h CODE_FOR_clzv8hi2\n+#define CODE_FOR_msa_nlzc_w CODE_FOR_clzv4si2\n+#define CODE_FOR_msa_nlzc_d CODE_FOR_clzv2di2\n+#define CODE_FOR_msa_nor_v CODE_FOR_msa_nor_b\n+#define CODE_FOR_msa_or_v CODE_FOR_iorv16qi3\n+#define CODE_FOR_msa_ori_b CODE_FOR_iorv16qi3\n+#define CODE_FOR_msa_nori_b CODE_FOR_msa_nor_b\n+#define CODE_FOR_msa_pcnt_b CODE_FOR_popcountv16qi2\n+#define CODE_FOR_msa_pcnt_h CODE_FOR_popcountv8hi2\n+#define CODE_FOR_msa_pcnt_w CODE_FOR_popcountv4si2\n+#define CODE_FOR_msa_pcnt_d CODE_FOR_popcountv2di2\n+#define CODE_FOR_msa_xor_v CODE_FOR_xorv16qi3\n+#define CODE_FOR_msa_xori_b CODE_FOR_xorv16qi3\n+#define CODE_FOR_msa_sll_b CODE_FOR_vashlv16qi3\n+#define CODE_FOR_msa_sll_h CODE_FOR_vashlv8hi3\n+#define CODE_FOR_msa_sll_w CODE_FOR_vashlv4si3\n+#define CODE_FOR_msa_sll_d CODE_FOR_vashlv2di3\n+#define CODE_FOR_msa_slli_b CODE_FOR_vashlv16qi3\n+#define CODE_FOR_msa_slli_h CODE_FOR_vashlv8hi3\n+#define CODE_FOR_msa_slli_w CODE_FOR_vashlv4si3\n+#define CODE_FOR_msa_slli_d CODE_FOR_vashlv2di3\n+#define CODE_FOR_msa_sra_b CODE_FOR_vashrv16qi3\n+#define CODE_FOR_msa_sra_h CODE_FOR_vashrv8hi3\n+#define CODE_FOR_msa_sra_w CODE_FOR_vashrv4si3\n+#define CODE_FOR_msa_sra_d CODE_FOR_vashrv2di3\n+#define CODE_FOR_msa_srai_b CODE_FOR_vashrv16qi3\n+#define CODE_FOR_msa_srai_h CODE_FOR_vashrv8hi3\n+#define CODE_FOR_msa_srai_w CODE_FOR_vashrv4si3\n+#define CODE_FOR_msa_srai_d CODE_FOR_vashrv2di3\n+#define CODE_FOR_msa_srl_b CODE_FOR_vlshrv16qi3\n+#define CODE_FOR_msa_srl_h CODE_FOR_vlshrv8hi3\n+#define CODE_FOR_msa_srl_w CODE_FOR_vlshrv4si3\n+#define CODE_FOR_msa_srl_d CODE_FOR_vlshrv2di3\n+#define CODE_FOR_msa_srli_b CODE_FOR_vlshrv16qi3\n+#define CODE_FOR_msa_srli_h CODE_FOR_vlshrv8hi3\n+#define CODE_FOR_msa_srli_w CODE_FOR_vlshrv4si3\n+#define CODE_FOR_msa_srli_d CODE_FOR_vlshrv2di3\n+#define CODE_FOR_msa_subv_b CODE_FOR_subv16qi3\n+#define CODE_FOR_msa_subv_h CODE_FOR_subv8hi3\n+#define CODE_FOR_msa_subv_w CODE_FOR_subv4si3\n+#define CODE_FOR_msa_subv_d CODE_FOR_subv2di3\n+#define CODE_FOR_msa_subvi_b CODE_FOR_subv16qi3\n+#define CODE_FOR_msa_subvi_h CODE_FOR_subv8hi3\n+#define CODE_FOR_msa_subvi_w CODE_FOR_subv4si3\n+#define CODE_FOR_msa_subvi_d CODE_FOR_subv2di3\n+\n+#define CODE_FOR_msa_move_v CODE_FOR_movv16qi\n+\n+#define CODE_FOR_msa_vshf_b CODE_FOR_vec_permv16qi\n+#define CODE_FOR_msa_vshf_h CODE_FOR_vec_permv8hi\n+#define CODE_FOR_msa_vshf_w CODE_FOR_vec_permv4si\n+#define CODE_FOR_msa_vshf_d CODE_FOR_vec_permv2di\n+\n+#define CODE_FOR_msa_ilvod_d CODE_FOR_msa_ilvl_d\n+#define CODE_FOR_msa_ilvev_d CODE_FOR_msa_ilvr_d\n+#define CODE_FOR_msa_pckod_d CODE_FOR_msa_ilvl_d\n+#define CODE_FOR_msa_pckev_d CODE_FOR_msa_ilvr_d\n+\n+#define CODE_FOR_msa_ldi_b CODE_FOR_msa_ldiv16qi\n+#define CODE_FOR_msa_ldi_h CODE_FOR_msa_ldiv8hi\n+#define CODE_FOR_msa_ldi_w CODE_FOR_msa_ldiv4si\n+#define CODE_FOR_msa_ldi_d CODE_FOR_msa_ldiv2di\n+\n static const struct mips_builtin_description mips_builtins[] = {\n #define MIPS_GET_FCSR 0\n   DIRECT_BUILTIN (get_fcsr, MIPS_USI_FTYPE_VOID, hard_float),\n@@ -14924,12 +15770,547 @@ static const struct mips_builtin_description mips_builtins[] = {\n   LOONGSON_BUILTIN_SUFFIX (punpcklwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n \n   /* Sundry other built-in functions.  */\n-  DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache)\n+  DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache),\n+\n+  /* Built-in functions for MSA.  */\n+  MSA_BUILTIN (sll_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (sll_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (sll_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (sll_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (slli_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (slli_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (slli_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (slli_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (sra_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (sra_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (sra_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (sra_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (srai_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (srai_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (srai_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (srai_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (srar_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (srar_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (srar_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (srar_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (srari_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (srari_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (srari_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (srari_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (srl_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (srl_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (srl_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (srl_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (srli_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (srli_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (srli_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (srli_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (srlr_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (srlr_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (srlr_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (srlr_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (srlri_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (srlri_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (srlri_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (srlri_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (bclr_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (bclr_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (bclr_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (bclr_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (bclri_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (bclri_h, MIPS_UV8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (bclri_w, MIPS_UV4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (bclri_d, MIPS_UV2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (bset_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (bset_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (bset_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (bset_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (bseti_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (bseti_h, MIPS_UV8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (bseti_w, MIPS_UV4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (bseti_d, MIPS_UV2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (bneg_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (bneg_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (bneg_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (bneg_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (bnegi_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (bnegi_h, MIPS_UV8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (bnegi_w, MIPS_UV4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (bnegi_d, MIPS_UV2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (binsl_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UV16QI),\n+  MSA_BUILTIN (binsl_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI_UV8HI),\n+  MSA_BUILTIN (binsl_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI_UV4SI),\n+  MSA_BUILTIN (binsl_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI_UV2DI),\n+  MSA_BUILTIN (binsli_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UQI),\n+  MSA_BUILTIN (binsli_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI_UQI),\n+  MSA_BUILTIN (binsli_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI_UQI),\n+  MSA_BUILTIN (binsli_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI_UQI),\n+  MSA_BUILTIN (binsr_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UV16QI),\n+  MSA_BUILTIN (binsr_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI_UV8HI),\n+  MSA_BUILTIN (binsr_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI_UV4SI),\n+  MSA_BUILTIN (binsr_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI_UV2DI),\n+  MSA_BUILTIN (binsri_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UQI),\n+  MSA_BUILTIN (binsri_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI_UQI),\n+  MSA_BUILTIN (binsri_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI_UQI),\n+  MSA_BUILTIN (binsri_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI_UQI),\n+  MSA_BUILTIN (addv_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (addv_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (addv_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (addv_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (addvi_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (addvi_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (addvi_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (addvi_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (subv_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (subv_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (subv_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (subv_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (subvi_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (subvi_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (subvi_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (subvi_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (max_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (max_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (max_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (max_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (maxi_s_b, MIPS_V16QI_FTYPE_V16QI_QI),\n+  MSA_BUILTIN (maxi_s_h, MIPS_V8HI_FTYPE_V8HI_QI),\n+  MSA_BUILTIN (maxi_s_w, MIPS_V4SI_FTYPE_V4SI_QI),\n+  MSA_BUILTIN (maxi_s_d, MIPS_V2DI_FTYPE_V2DI_QI),\n+  MSA_BUILTIN (max_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (max_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (max_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (max_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (maxi_u_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (maxi_u_h, MIPS_UV8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (maxi_u_w, MIPS_UV4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (maxi_u_d, MIPS_UV2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (min_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (min_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (min_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (min_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (mini_s_b, MIPS_V16QI_FTYPE_V16QI_QI),\n+  MSA_BUILTIN (mini_s_h, MIPS_V8HI_FTYPE_V8HI_QI),\n+  MSA_BUILTIN (mini_s_w, MIPS_V4SI_FTYPE_V4SI_QI),\n+  MSA_BUILTIN (mini_s_d, MIPS_V2DI_FTYPE_V2DI_QI),\n+  MSA_BUILTIN (min_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (min_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (min_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (min_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (mini_u_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (mini_u_h, MIPS_UV8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (mini_u_w, MIPS_UV4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (mini_u_d, MIPS_UV2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (max_a_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (max_a_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (max_a_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (max_a_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (min_a_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (min_a_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (min_a_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (min_a_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ceq_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (ceq_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (ceq_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (ceq_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ceqi_b, MIPS_V16QI_FTYPE_V16QI_QI),\n+  MSA_BUILTIN (ceqi_h, MIPS_V8HI_FTYPE_V8HI_QI),\n+  MSA_BUILTIN (ceqi_w, MIPS_V4SI_FTYPE_V4SI_QI),\n+  MSA_BUILTIN (ceqi_d, MIPS_V2DI_FTYPE_V2DI_QI),\n+  MSA_BUILTIN (clt_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (clt_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (clt_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (clt_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (clti_s_b, MIPS_V16QI_FTYPE_V16QI_QI),\n+  MSA_BUILTIN (clti_s_h, MIPS_V8HI_FTYPE_V8HI_QI),\n+  MSA_BUILTIN (clti_s_w, MIPS_V4SI_FTYPE_V4SI_QI),\n+  MSA_BUILTIN (clti_s_d, MIPS_V2DI_FTYPE_V2DI_QI),\n+  MSA_BUILTIN (clt_u_b, MIPS_V16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (clt_u_h, MIPS_V8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (clt_u_w, MIPS_V4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (clt_u_d, MIPS_V2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (clti_u_b, MIPS_V16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (clti_u_h, MIPS_V8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (clti_u_w, MIPS_V4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (clti_u_d, MIPS_V2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (cle_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (cle_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (cle_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (cle_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (clei_s_b, MIPS_V16QI_FTYPE_V16QI_QI),\n+  MSA_BUILTIN (clei_s_h, MIPS_V8HI_FTYPE_V8HI_QI),\n+  MSA_BUILTIN (clei_s_w, MIPS_V4SI_FTYPE_V4SI_QI),\n+  MSA_BUILTIN (clei_s_d, MIPS_V2DI_FTYPE_V2DI_QI),\n+  MSA_BUILTIN (cle_u_b, MIPS_V16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (cle_u_h, MIPS_V8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (cle_u_w, MIPS_V4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (cle_u_d, MIPS_V2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (clei_u_b, MIPS_V16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (clei_u_h, MIPS_V8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (clei_u_w, MIPS_V4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (clei_u_d, MIPS_V2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (ld_b, MIPS_V16QI_FTYPE_CVPOINTER_SI),\n+  MSA_BUILTIN (ld_h, MIPS_V8HI_FTYPE_CVPOINTER_SI),\n+  MSA_BUILTIN (ld_w, MIPS_V4SI_FTYPE_CVPOINTER_SI),\n+  MSA_BUILTIN (ld_d, MIPS_V2DI_FTYPE_CVPOINTER_SI),\n+  MSA_NO_TARGET_BUILTIN (st_b, MIPS_VOID_FTYPE_V16QI_CVPOINTER_SI),\n+  MSA_NO_TARGET_BUILTIN (st_h, MIPS_VOID_FTYPE_V8HI_CVPOINTER_SI),\n+  MSA_NO_TARGET_BUILTIN (st_w, MIPS_VOID_FTYPE_V4SI_CVPOINTER_SI),\n+  MSA_NO_TARGET_BUILTIN (st_d, MIPS_VOID_FTYPE_V2DI_CVPOINTER_SI),\n+  MSA_BUILTIN (sat_s_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (sat_s_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (sat_s_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (sat_s_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (sat_u_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (sat_u_h, MIPS_UV8HI_FTYPE_UV8HI_UQI),\n+  MSA_BUILTIN (sat_u_w, MIPS_UV4SI_FTYPE_UV4SI_UQI),\n+  MSA_BUILTIN (sat_u_d, MIPS_UV2DI_FTYPE_UV2DI_UQI),\n+  MSA_BUILTIN (add_a_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (add_a_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (add_a_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (add_a_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (adds_a_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (adds_a_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (adds_a_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (adds_a_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (adds_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (adds_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (adds_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (adds_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (adds_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (adds_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (adds_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (adds_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (ave_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (ave_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (ave_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (ave_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ave_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (ave_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (ave_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (ave_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (aver_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (aver_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (aver_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (aver_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (aver_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (aver_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (aver_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (aver_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (subs_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (subs_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (subs_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (subs_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (subs_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (subs_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (subs_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (subs_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (subsuu_s_b, MIPS_V16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (subsuu_s_h, MIPS_V8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (subsuu_s_w, MIPS_V4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (subsuu_s_d, MIPS_V2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (subsus_u_b, MIPS_UV16QI_FTYPE_UV16QI_V16QI),\n+  MSA_BUILTIN (subsus_u_h, MIPS_UV8HI_FTYPE_UV8HI_V8HI),\n+  MSA_BUILTIN (subsus_u_w, MIPS_UV4SI_FTYPE_UV4SI_V4SI),\n+  MSA_BUILTIN (subsus_u_d, MIPS_UV2DI_FTYPE_UV2DI_V2DI),\n+  MSA_BUILTIN (asub_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (asub_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (asub_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (asub_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (asub_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (asub_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (asub_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (asub_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (mulv_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (mulv_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (mulv_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (mulv_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (maddv_b, MIPS_V16QI_FTYPE_V16QI_V16QI_V16QI),\n+  MSA_BUILTIN (maddv_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (maddv_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (maddv_d, MIPS_V2DI_FTYPE_V2DI_V2DI_V2DI),\n+  MSA_BUILTIN (msubv_b, MIPS_V16QI_FTYPE_V16QI_V16QI_V16QI),\n+  MSA_BUILTIN (msubv_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (msubv_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (msubv_d, MIPS_V2DI_FTYPE_V2DI_V2DI_V2DI),\n+  MSA_BUILTIN (div_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (div_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (div_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (div_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (div_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (div_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (div_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (div_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (hadd_s_h, MIPS_V8HI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (hadd_s_w, MIPS_V4SI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (hadd_s_d, MIPS_V2DI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (hadd_u_h, MIPS_UV8HI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (hadd_u_w, MIPS_UV4SI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (hadd_u_d, MIPS_UV2DI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (hsub_s_h, MIPS_V8HI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (hsub_s_w, MIPS_V4SI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (hsub_s_d, MIPS_V2DI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (hsub_u_h, MIPS_V8HI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (hsub_u_w, MIPS_V4SI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (hsub_u_d, MIPS_V2DI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (mod_s_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (mod_s_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (mod_s_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (mod_s_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (mod_u_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (mod_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (mod_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (mod_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV2DI),\n+  MSA_BUILTIN (dotp_s_h, MIPS_V8HI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (dotp_s_w, MIPS_V4SI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (dotp_s_d, MIPS_V2DI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (dotp_u_h, MIPS_UV8HI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (dotp_u_w, MIPS_UV4SI_FTYPE_UV8HI_UV8HI),\n+  MSA_BUILTIN (dotp_u_d, MIPS_UV2DI_FTYPE_UV4SI_UV4SI),\n+  MSA_BUILTIN (dpadd_s_h, MIPS_V8HI_FTYPE_V8HI_V16QI_V16QI),\n+  MSA_BUILTIN (dpadd_s_w, MIPS_V4SI_FTYPE_V4SI_V8HI_V8HI),\n+  MSA_BUILTIN (dpadd_s_d, MIPS_V2DI_FTYPE_V2DI_V4SI_V4SI),\n+  MSA_BUILTIN (dpadd_u_h, MIPS_UV8HI_FTYPE_UV8HI_UV16QI_UV16QI),\n+  MSA_BUILTIN (dpadd_u_w, MIPS_UV4SI_FTYPE_UV4SI_UV8HI_UV8HI),\n+  MSA_BUILTIN (dpadd_u_d, MIPS_UV2DI_FTYPE_UV2DI_UV4SI_UV4SI),\n+  MSA_BUILTIN (dpsub_s_h, MIPS_V8HI_FTYPE_V8HI_V16QI_V16QI),\n+  MSA_BUILTIN (dpsub_s_w, MIPS_V4SI_FTYPE_V4SI_V8HI_V8HI),\n+  MSA_BUILTIN (dpsub_s_d, MIPS_V2DI_FTYPE_V2DI_V4SI_V4SI),\n+  MSA_BUILTIN (dpsub_u_h, MIPS_V8HI_FTYPE_V8HI_UV16QI_UV16QI),\n+  MSA_BUILTIN (dpsub_u_w, MIPS_V4SI_FTYPE_V4SI_UV8HI_UV8HI),\n+  MSA_BUILTIN (dpsub_u_d, MIPS_V2DI_FTYPE_V2DI_UV4SI_UV4SI),\n+  MSA_BUILTIN (sld_b, MIPS_V16QI_FTYPE_V16QI_V16QI_SI),\n+  MSA_BUILTIN (sld_h, MIPS_V8HI_FTYPE_V8HI_V8HI_SI),\n+  MSA_BUILTIN (sld_w, MIPS_V4SI_FTYPE_V4SI_V4SI_SI),\n+  MSA_BUILTIN (sld_d, MIPS_V2DI_FTYPE_V2DI_V2DI_SI),\n+  MSA_BUILTIN (sldi_b, MIPS_V16QI_FTYPE_V16QI_V16QI_UQI),\n+  MSA_BUILTIN (sldi_h, MIPS_V8HI_FTYPE_V8HI_V8HI_UQI),\n+  MSA_BUILTIN (sldi_w, MIPS_V4SI_FTYPE_V4SI_V4SI_UQI),\n+  MSA_BUILTIN (sldi_d, MIPS_V2DI_FTYPE_V2DI_V2DI_UQI),\n+  MSA_BUILTIN (splat_b, MIPS_V16QI_FTYPE_V16QI_SI),\n+  MSA_BUILTIN (splat_h, MIPS_V8HI_FTYPE_V8HI_SI),\n+  MSA_BUILTIN (splat_w, MIPS_V4SI_FTYPE_V4SI_SI),\n+  MSA_BUILTIN (splat_d, MIPS_V2DI_FTYPE_V2DI_SI),\n+  MSA_BUILTIN (splati_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (splati_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (splati_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (splati_d, MIPS_V2DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (pckev_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (pckev_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (pckev_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (pckev_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (pckod_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (pckod_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (pckod_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (pckod_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ilvl_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (ilvl_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (ilvl_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (ilvl_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ilvr_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (ilvr_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (ilvr_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (ilvr_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ilvev_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (ilvev_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (ilvev_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (ilvev_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (ilvod_b, MIPS_V16QI_FTYPE_V16QI_V16QI),\n+  MSA_BUILTIN (ilvod_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (ilvod_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (ilvod_d, MIPS_V2DI_FTYPE_V2DI_V2DI),\n+  MSA_BUILTIN (vshf_b, MIPS_V16QI_FTYPE_V16QI_V16QI_V16QI),\n+  MSA_BUILTIN (vshf_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (vshf_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (vshf_d, MIPS_V2DI_FTYPE_V2DI_V2DI_V2DI),\n+  MSA_BUILTIN (and_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (andi_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (or_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (ori_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (nor_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (nori_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (xor_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),\n+  MSA_BUILTIN (xori_b, MIPS_UV16QI_FTYPE_UV16QI_UQI),\n+  MSA_BUILTIN (bmnz_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UV16QI),\n+  MSA_BUILTIN (bmnzi_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UQI),\n+  MSA_BUILTIN (bmz_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UV16QI),\n+  MSA_BUILTIN (bmzi_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UQI),\n+  MSA_BUILTIN (bsel_v, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UV16QI),\n+  MSA_BUILTIN (bseli_b, MIPS_UV16QI_FTYPE_UV16QI_UV16QI_UQI),\n+  MSA_BUILTIN (shf_b, MIPS_V16QI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (shf_h, MIPS_V8HI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (shf_w, MIPS_V4SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN_TEST_BRANCH (bnz_v, MIPS_SI_FTYPE_UV16QI),\n+  MSA_BUILTIN_TEST_BRANCH (bz_v, MIPS_SI_FTYPE_UV16QI),\n+  MSA_BUILTIN (fill_b, MIPS_V16QI_FTYPE_SI),\n+  MSA_BUILTIN (fill_h, MIPS_V8HI_FTYPE_SI),\n+  MSA_BUILTIN (fill_w, MIPS_V4SI_FTYPE_SI),\n+  MSA_BUILTIN (fill_d, MIPS_V2DI_FTYPE_DI),\n+  MSA_BUILTIN (pcnt_b, MIPS_V16QI_FTYPE_V16QI),\n+  MSA_BUILTIN (pcnt_h, MIPS_V8HI_FTYPE_V8HI),\n+  MSA_BUILTIN (pcnt_w, MIPS_V4SI_FTYPE_V4SI),\n+  MSA_BUILTIN (pcnt_d, MIPS_V2DI_FTYPE_V2DI),\n+  MSA_BUILTIN (nloc_b, MIPS_V16QI_FTYPE_V16QI),\n+  MSA_BUILTIN (nloc_h, MIPS_V8HI_FTYPE_V8HI),\n+  MSA_BUILTIN (nloc_w, MIPS_V4SI_FTYPE_V4SI),\n+  MSA_BUILTIN (nloc_d, MIPS_V2DI_FTYPE_V2DI),\n+  MSA_BUILTIN (nlzc_b, MIPS_V16QI_FTYPE_V16QI),\n+  MSA_BUILTIN (nlzc_h, MIPS_V8HI_FTYPE_V8HI),\n+  MSA_BUILTIN (nlzc_w, MIPS_V4SI_FTYPE_V4SI),\n+  MSA_BUILTIN (nlzc_d, MIPS_V2DI_FTYPE_V2DI),\n+  MSA_BUILTIN (copy_s_b, MIPS_SI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (copy_s_h, MIPS_SI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN (copy_s_w, MIPS_SI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN (copy_s_d, MIPS_DI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (copy_u_b, MIPS_USI_FTYPE_V16QI_UQI),\n+  MSA_BUILTIN (copy_u_h, MIPS_USI_FTYPE_V8HI_UQI),\n+  MSA_BUILTIN_REMAP (copy_u_w, copy_s_w, MIPS_USI_FTYPE_V4SI_UQI),\n+  MSA_BUILTIN_REMAP (copy_u_d, copy_s_d, MIPS_UDI_FTYPE_V2DI_UQI),\n+  MSA_BUILTIN (insert_b, MIPS_V16QI_FTYPE_V16QI_UQI_SI),\n+  MSA_BUILTIN (insert_h, MIPS_V8HI_FTYPE_V8HI_UQI_SI),\n+  MSA_BUILTIN (insert_w, MIPS_V4SI_FTYPE_V4SI_UQI_SI),\n+  MSA_BUILTIN (insert_d, MIPS_V2DI_FTYPE_V2DI_UQI_DI),\n+  MSA_BUILTIN (insve_b, MIPS_V16QI_FTYPE_V16QI_UQI_V16QI),\n+  MSA_BUILTIN (insve_h, MIPS_V8HI_FTYPE_V8HI_UQI_V8HI),\n+  MSA_BUILTIN (insve_w, MIPS_V4SI_FTYPE_V4SI_UQI_V4SI),\n+  MSA_BUILTIN (insve_d, MIPS_V2DI_FTYPE_V2DI_UQI_V2DI),\n+  MSA_BUILTIN_TEST_BRANCH (bnz_b, MIPS_SI_FTYPE_UV16QI),\n+  MSA_BUILTIN_TEST_BRANCH (bnz_h, MIPS_SI_FTYPE_UV8HI),\n+  MSA_BUILTIN_TEST_BRANCH (bnz_w, MIPS_SI_FTYPE_UV4SI),\n+  MSA_BUILTIN_TEST_BRANCH (bnz_d, MIPS_SI_FTYPE_UV2DI),\n+  MSA_BUILTIN_TEST_BRANCH (bz_b, MIPS_SI_FTYPE_UV16QI),\n+  MSA_BUILTIN_TEST_BRANCH (bz_h, MIPS_SI_FTYPE_UV8HI),\n+  MSA_BUILTIN_TEST_BRANCH (bz_w, MIPS_SI_FTYPE_UV4SI),\n+  MSA_BUILTIN_TEST_BRANCH (bz_d, MIPS_SI_FTYPE_UV2DI),\n+  MSA_BUILTIN (ldi_b, MIPS_V16QI_FTYPE_HI),\n+  MSA_BUILTIN (ldi_h, MIPS_V8HI_FTYPE_HI),\n+  MSA_BUILTIN (ldi_w, MIPS_V4SI_FTYPE_HI),\n+  MSA_BUILTIN (ldi_d, MIPS_V2DI_FTYPE_HI),\n+  MSA_BUILTIN (fcaf_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcaf_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcor_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcor_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcun_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcun_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcune_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcune_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcueq_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcueq_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fceq_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fceq_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcne_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcne_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fclt_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fclt_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcult_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcult_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcle_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcle_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fcule_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fcule_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsaf_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsaf_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsor_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsor_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsun_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsun_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsune_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsune_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsueq_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsueq_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fseq_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fseq_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsne_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsne_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fslt_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fslt_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsult_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsult_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsle_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsle_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsule_w, MIPS_V4SI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsule_d, MIPS_V2DI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fadd_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fadd_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fsub_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fsub_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fmul_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fmul_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fdiv_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fdiv_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fmadd_w, MIPS_V4SF_FTYPE_V4SF_V4SF_V4SF),\n+  MSA_BUILTIN (fmadd_d, MIPS_V2DF_FTYPE_V2DF_V2DF_V2DF),\n+  MSA_BUILTIN (fmsub_w, MIPS_V4SF_FTYPE_V4SF_V4SF_V4SF),\n+  MSA_BUILTIN (fmsub_d, MIPS_V2DF_FTYPE_V2DF_V2DF_V2DF),\n+  MSA_BUILTIN (fexp2_w, MIPS_V4SF_FTYPE_V4SF_V4SI),\n+  MSA_BUILTIN (fexp2_d, MIPS_V2DF_FTYPE_V2DF_V2DI),\n+  MSA_BUILTIN (fexdo_h, MIPS_V8HI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fexdo_w, MIPS_V4SF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (ftq_h, MIPS_V8HI_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (ftq_w, MIPS_V4SI_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fmin_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fmin_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fmin_a_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fmin_a_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fmax_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fmax_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (fmax_a_w, MIPS_V4SF_FTYPE_V4SF_V4SF),\n+  MSA_BUILTIN (fmax_a_d, MIPS_V2DF_FTYPE_V2DF_V2DF),\n+  MSA_BUILTIN (mul_q_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (mul_q_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (mulr_q_h, MIPS_V8HI_FTYPE_V8HI_V8HI),\n+  MSA_BUILTIN (mulr_q_w, MIPS_V4SI_FTYPE_V4SI_V4SI),\n+  MSA_BUILTIN (madd_q_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (madd_q_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (maddr_q_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (maddr_q_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (msub_q_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (msub_q_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (msubr_q_h, MIPS_V8HI_FTYPE_V8HI_V8HI_V8HI),\n+  MSA_BUILTIN (msubr_q_w, MIPS_V4SI_FTYPE_V4SI_V4SI_V4SI),\n+  MSA_BUILTIN (fclass_w, MIPS_V4SI_FTYPE_V4SF),\n+  MSA_BUILTIN (fclass_d, MIPS_V2DI_FTYPE_V2DF),\n+  MSA_BUILTIN (fsqrt_w, MIPS_V4SF_FTYPE_V4SF),\n+  MSA_BUILTIN (fsqrt_d, MIPS_V2DF_FTYPE_V2DF),\n+  MSA_BUILTIN (frcp_w, MIPS_V4SF_FTYPE_V4SF),\n+  MSA_BUILTIN (frcp_d, MIPS_V2DF_FTYPE_V2DF),\n+  MSA_BUILTIN (frint_w, MIPS_V4SF_FTYPE_V4SF),\n+  MSA_BUILTIN (frint_d, MIPS_V2DF_FTYPE_V2DF),\n+  MSA_BUILTIN (frsqrt_w, MIPS_V4SF_FTYPE_V4SF),\n+  MSA_BUILTIN (frsqrt_d, MIPS_V2DF_FTYPE_V2DF),\n+  MSA_BUILTIN (flog2_w, MIPS_V4SF_FTYPE_V4SF),\n+  MSA_BUILTIN (flog2_d, MIPS_V2DF_FTYPE_V2DF),\n+  MSA_BUILTIN (fexupl_w, MIPS_V4SF_FTYPE_V8HI),\n+  MSA_BUILTIN (fexupl_d, MIPS_V2DF_FTYPE_V4SF),\n+  MSA_BUILTIN (fexupr_w, MIPS_V4SF_FTYPE_V8HI),\n+  MSA_BUILTIN (fexupr_d, MIPS_V2DF_FTYPE_V4SF),\n+  MSA_BUILTIN (ffql_w, MIPS_V4SF_FTYPE_V8HI),\n+  MSA_BUILTIN (ffql_d, MIPS_V2DF_FTYPE_V4SI),\n+  MSA_BUILTIN (ffqr_w, MIPS_V4SF_FTYPE_V8HI),\n+  MSA_BUILTIN (ffqr_d, MIPS_V2DF_FTYPE_V4SI),\n+  MSA_BUILTIN (ftint_s_w, MIPS_V4SI_FTYPE_V4SF),\n+  MSA_BUILTIN (ftint_s_d, MIPS_V2DI_FTYPE_V2DF),\n+  MSA_BUILTIN (ftint_u_w, MIPS_UV4SI_FTYPE_V4SF),\n+  MSA_BUILTIN (ftint_u_d, MIPS_UV2DI_FTYPE_V2DF),\n+  MSA_BUILTIN (ftrunc_s_w, MIPS_V4SI_FTYPE_V4SF),\n+  MSA_BUILTIN (ftrunc_s_d, MIPS_V2DI_FTYPE_V2DF),\n+  MSA_BUILTIN (ftrunc_u_w, MIPS_UV4SI_FTYPE_V4SF),\n+  MSA_BUILTIN (ftrunc_u_d, MIPS_UV2DI_FTYPE_V2DF),\n+  MSA_BUILTIN (ffint_s_w, MIPS_V4SF_FTYPE_V4SI),\n+  MSA_BUILTIN (ffint_s_d, MIPS_V2DF_FTYPE_V2DI),\n+  MSA_BUILTIN (ffint_u_w, MIPS_V4SF_FTYPE_UV4SI),\n+  MSA_BUILTIN (ffint_u_d, MIPS_V2DF_FTYPE_UV2DI),\n+  MSA_NO_TARGET_BUILTIN (ctcmsa, MIPS_VOID_FTYPE_UQI_SI),\n+  MSA_BUILTIN (cfcmsa, MIPS_SI_FTYPE_UQI),\n+  MSA_BUILTIN (move_v, MIPS_V16QI_FTYPE_V16QI),\n };\n \n /* Index I is the function declaration for mips_builtins[I], or null if the\n    function isn't defined on this target.  */\n static GTY(()) tree mips_builtin_decls[ARRAY_SIZE (mips_builtins)];\n+/* Get the index I of the function declaration for mips_builtin_decls[I]\n+   using the instruction code or return null if not defined for the target.  */\n+static GTY(()) int mips_get_builtin_decl_index[NUM_INSN_CODES];\n \n /* MODE is a vector mode whose elements have type TYPE.  Return the type\n    of the vector itself.  */\n@@ -14971,7 +16352,9 @@ mips_build_cvpointer_type (void)\n #define MIPS_ATYPE_CVPOINTER mips_build_cvpointer_type ()\n \n /* Standard mode-based argument types.  */\n+#define MIPS_ATYPE_QI intQI_type_node\n #define MIPS_ATYPE_UQI unsigned_intQI_type_node\n+#define MIPS_ATYPE_HI intHI_type_node\n #define MIPS_ATYPE_SI intSI_type_node\n #define MIPS_ATYPE_USI unsigned_intSI_type_node\n #define MIPS_ATYPE_DI intDI_type_node\n@@ -14986,6 +16369,24 @@ mips_build_cvpointer_type (void)\n #define MIPS_ATYPE_V4QI mips_builtin_vector_type (intQI_type_node, V4QImode)\n #define MIPS_ATYPE_V4HI mips_builtin_vector_type (intHI_type_node, V4HImode)\n #define MIPS_ATYPE_V8QI mips_builtin_vector_type (intQI_type_node, V8QImode)\n+\n+#define MIPS_ATYPE_V2DI\t\t\t\t\t\t\\\n+  mips_builtin_vector_type (long_long_integer_type_node, V2DImode)\n+#define MIPS_ATYPE_V4SI mips_builtin_vector_type (intSI_type_node, V4SImode)\n+#define MIPS_ATYPE_V8HI mips_builtin_vector_type (intHI_type_node, V8HImode)\n+#define MIPS_ATYPE_V16QI mips_builtin_vector_type (intQI_type_node, V16QImode)\n+#define MIPS_ATYPE_V2DF mips_builtin_vector_type (double_type_node, V2DFmode)\n+#define MIPS_ATYPE_V4SF mips_builtin_vector_type (float_type_node, V4SFmode)\n+\n+#define MIPS_ATYPE_UV2DI\t\t\t\t\t\\\n+  mips_builtin_vector_type (long_long_unsigned_type_node, V2DImode)\n+#define MIPS_ATYPE_UV4SI\t\t\t\t\t\\\n+  mips_builtin_vector_type (unsigned_intSI_type_node, V4SImode)\n+#define MIPS_ATYPE_UV8HI\t\t\t\t\t\\\n+  mips_builtin_vector_type (unsigned_intHI_type_node, V8HImode)\n+#define MIPS_ATYPE_UV16QI\t\t\t\t\t\\\n+  mips_builtin_vector_type (unsigned_intQI_type_node, V16QImode)\n+\n #define MIPS_ATYPE_UV2SI\t\t\t\t\t\\\n   mips_builtin_vector_type (unsigned_intSI_type_node, V2SImode)\n #define MIPS_ATYPE_UV4HI\t\t\t\t\t\\\n@@ -15047,10 +16448,13 @@ mips_init_builtins (void)\n     {\n       d = &mips_builtins[i];\n       if (d->avail ())\n-\tmips_builtin_decls[i]\n-\t  = add_builtin_function (d->name,\n-\t\t\t\t  mips_build_function_type (d->function_type),\n-\t\t\t\t  i, BUILT_IN_MD, NULL, NULL);\n+\t{\n+\t  mips_builtin_decls[i]\n+\t    = add_builtin_function (d->name,\n+\t\t\t\t    mips_build_function_type (d->function_type),\n+\t\t\t\t    i, BUILT_IN_MD, NULL, NULL);\n+\t  mips_get_builtin_decl_index[d->icode] = i;\n+\t}\n     }\n }\n \n@@ -15064,6 +16468,48 @@ mips_builtin_decl (unsigned int code, bool initialize_p ATTRIBUTE_UNUSED)\n   return mips_builtin_decls[code];\n }\n \n+/* Implement TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION.  */\n+\n+static tree\n+mips_builtin_vectorized_function (unsigned int fn, tree type_out, tree type_in)\n+{\n+  machine_mode in_mode, out_mode;\n+  int in_n, out_n;\n+\n+  if (TREE_CODE (type_out) != VECTOR_TYPE\n+      || TREE_CODE (type_in) != VECTOR_TYPE\n+      || !ISA_HAS_MSA)\n+    return NULL_TREE;\n+\n+  out_mode = TYPE_MODE (TREE_TYPE (type_out));\n+  out_n = TYPE_VECTOR_SUBPARTS (type_out);\n+  in_mode = TYPE_MODE (TREE_TYPE (type_in));\n+  in_n = TYPE_VECTOR_SUBPARTS (type_in);\n+\n+  /* INSN is the name of the associated instruction pattern, without\n+     the leading CODE_FOR_.  */\n+#define MIPS_GET_BUILTIN(INSN) \\\n+  mips_builtin_decls[mips_get_builtin_decl_index[CODE_FOR_##INSN]]\n+\n+  switch (fn)\n+    {\n+    case BUILT_IN_SQRT:\n+      if (out_mode == DFmode && out_n == 2\n+\t  && in_mode == DFmode && in_n == 2)\n+\treturn MIPS_GET_BUILTIN (msa_fsqrt_d);\n+      break;\n+    case BUILT_IN_SQRTF:\n+      if (out_mode == SFmode && out_n == 4\n+\t  && in_mode == SFmode && in_n == 4)\n+\treturn MIPS_GET_BUILTIN (msa_fsqrt_w);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Take argument ARGNO from EXP's argument list and convert it into\n    an expand operand.  Store the operand in *OP.  */\n \n@@ -15090,6 +16536,211 @@ static rtx\n mips_expand_builtin_insn (enum insn_code icode, unsigned int nops,\n \t\t\t  struct expand_operand *ops, bool has_target_p)\n {\n+  machine_mode imode;\n+\n+  switch (icode)\n+    {\n+    case CODE_FOR_msa_addvi_b:\n+    case CODE_FOR_msa_addvi_h:\n+    case CODE_FOR_msa_addvi_w:\n+    case CODE_FOR_msa_addvi_d:\n+    case CODE_FOR_msa_clti_u_b:\n+    case CODE_FOR_msa_clti_u_h:\n+    case CODE_FOR_msa_clti_u_w:\n+    case CODE_FOR_msa_clti_u_d:\n+    case CODE_FOR_msa_clei_u_b:\n+    case CODE_FOR_msa_clei_u_h:\n+    case CODE_FOR_msa_clei_u_w:\n+    case CODE_FOR_msa_clei_u_d:\n+    case CODE_FOR_msa_maxi_u_b:\n+    case CODE_FOR_msa_maxi_u_h:\n+    case CODE_FOR_msa_maxi_u_w:\n+    case CODE_FOR_msa_maxi_u_d:\n+    case CODE_FOR_msa_mini_u_b:\n+    case CODE_FOR_msa_mini_u_h:\n+    case CODE_FOR_msa_mini_u_w:\n+    case CODE_FOR_msa_mini_u_d:\n+    case CODE_FOR_msa_subvi_b:\n+    case CODE_FOR_msa_subvi_h:\n+    case CODE_FOR_msa_subvi_w:\n+    case CODE_FOR_msa_subvi_d:\n+      gcc_assert (has_target_p && nops == 3);\n+      /* We only generate a vector of constants iff the second argument\n+\t is an immediate.  We also validate the range of the immediate.  */\n+      if (!CONST_INT_P (ops[2].value)\n+\t  || !IN_RANGE (INTVAL (ops[2].value), 0,  31))\n+\tbreak;\n+      ops[2].mode = ops[0].mode;\n+      ops[2].value = mips_gen_const_int_vector (ops[2].mode,\n+\t\t\t\t\t\tINTVAL (ops[2].value));\n+      break;\n+\n+    case CODE_FOR_msa_ceqi_b:\n+    case CODE_FOR_msa_ceqi_h:\n+    case CODE_FOR_msa_ceqi_w:\n+    case CODE_FOR_msa_ceqi_d:\n+    case CODE_FOR_msa_clti_s_b:\n+    case CODE_FOR_msa_clti_s_h:\n+    case CODE_FOR_msa_clti_s_w:\n+    case CODE_FOR_msa_clti_s_d:\n+    case CODE_FOR_msa_clei_s_b:\n+    case CODE_FOR_msa_clei_s_h:\n+    case CODE_FOR_msa_clei_s_w:\n+    case CODE_FOR_msa_clei_s_d:\n+    case CODE_FOR_msa_maxi_s_b:\n+    case CODE_FOR_msa_maxi_s_h:\n+    case CODE_FOR_msa_maxi_s_w:\n+    case CODE_FOR_msa_maxi_s_d:\n+    case CODE_FOR_msa_mini_s_b:\n+    case CODE_FOR_msa_mini_s_h:\n+    case CODE_FOR_msa_mini_s_w:\n+    case CODE_FOR_msa_mini_s_d:\n+      gcc_assert (has_target_p && nops == 3);\n+      /* We only generate a vector of constants iff the second argument\n+\t is an immediate.  We also validate the range of the immediate.  */\n+      if (!CONST_INT_P (ops[2].value)\n+\t  || !IN_RANGE (INTVAL (ops[2].value), -16,  15))\n+\tbreak;\n+      ops[2].mode = ops[0].mode;\n+      ops[2].value = mips_gen_const_int_vector (ops[2].mode,\n+\t\t\t\t\t\tINTVAL (ops[2].value));\n+      break;\n+\n+    case CODE_FOR_msa_andi_b:\n+    case CODE_FOR_msa_ori_b:\n+    case CODE_FOR_msa_nori_b:\n+    case CODE_FOR_msa_xori_b:\n+      gcc_assert (has_target_p && nops == 3);\n+      if (!CONST_INT_P (ops[2].value))\n+\tbreak;\n+      ops[2].mode = ops[0].mode;\n+      ops[2].value = mips_gen_const_int_vector (ops[2].mode,\n+\t\t\t\t\t\tINTVAL (ops[2].value));\n+      break;\n+\n+    case CODE_FOR_msa_bmzi_b:\n+    case CODE_FOR_msa_bmnzi_b:\n+    case CODE_FOR_msa_bseli_b:\n+      gcc_assert (has_target_p && nops == 4);\n+      if (!CONST_INT_P (ops[3].value))\n+\tbreak;\n+      ops[3].mode = ops[0].mode;\n+      ops[3].value = mips_gen_const_int_vector (ops[3].mode,\n+\t\t\t\t\t\tINTVAL (ops[3].value));\n+      break;\n+\n+    case CODE_FOR_msa_fill_b:\n+    case CODE_FOR_msa_fill_h:\n+    case CODE_FOR_msa_fill_w:\n+    case CODE_FOR_msa_fill_d:\n+      /* Map the built-ins to vector fill operations.  We need fix up the mode\n+\t for the element being inserted.  */\n+      gcc_assert (has_target_p && nops == 2);\n+      imode = GET_MODE_INNER (ops[0].mode);\n+      ops[1].value = lowpart_subreg (imode, ops[1].value, ops[1].mode);\n+      ops[1].mode = imode;\n+      break;\n+\n+    case CODE_FOR_msa_ilvl_b:\n+    case CODE_FOR_msa_ilvl_h:\n+    case CODE_FOR_msa_ilvl_w:\n+    case CODE_FOR_msa_ilvl_d:\n+    case CODE_FOR_msa_ilvr_b:\n+    case CODE_FOR_msa_ilvr_h:\n+    case CODE_FOR_msa_ilvr_w:\n+    case CODE_FOR_msa_ilvr_d:\n+    case CODE_FOR_msa_ilvev_b:\n+    case CODE_FOR_msa_ilvev_h:\n+    case CODE_FOR_msa_ilvev_w:\n+    case CODE_FOR_msa_ilvod_b:\n+    case CODE_FOR_msa_ilvod_h:\n+    case CODE_FOR_msa_ilvod_w:\n+    case CODE_FOR_msa_pckev_b:\n+    case CODE_FOR_msa_pckev_h:\n+    case CODE_FOR_msa_pckev_w:\n+    case CODE_FOR_msa_pckod_b:\n+    case CODE_FOR_msa_pckod_h:\n+    case CODE_FOR_msa_pckod_w:\n+      /* Swap the operands 1 and 2 for interleave operations.  Built-ins follow\n+\t convention of ISA, which have op1 as higher component and op2 as lower\n+\t component.  However, the VEC_PERM op in tree and vec_concat in RTL\n+\t expects first operand to be lower component, because of which this\n+\t swap is needed for builtins.  */\n+      gcc_assert (has_target_p && nops == 3);\n+      std::swap (ops[1], ops[2]);\n+      break;\n+\n+    case CODE_FOR_msa_slli_b:\n+    case CODE_FOR_msa_slli_h:\n+    case CODE_FOR_msa_slli_w:\n+    case CODE_FOR_msa_slli_d:\n+    case CODE_FOR_msa_srai_b:\n+    case CODE_FOR_msa_srai_h:\n+    case CODE_FOR_msa_srai_w:\n+    case CODE_FOR_msa_srai_d:\n+    case CODE_FOR_msa_srli_b:\n+    case CODE_FOR_msa_srli_h:\n+    case CODE_FOR_msa_srli_w:\n+    case CODE_FOR_msa_srli_d:\n+      gcc_assert (has_target_p && nops == 3);\n+      if (!CONST_INT_P (ops[2].value)\n+\t  || !IN_RANGE (INTVAL (ops[2].value), 0,\n+\t\t\tGET_MODE_UNIT_PRECISION (ops[0].mode) - 1))\n+\tbreak;\n+      ops[2].mode = ops[0].mode;\n+      ops[2].value = mips_gen_const_int_vector (ops[2].mode,\n+\t\t\t\t\t\tINTVAL (ops[2].value));\n+      break;\n+\n+    case CODE_FOR_msa_insert_b:\n+    case CODE_FOR_msa_insert_h:\n+    case CODE_FOR_msa_insert_w:\n+    case CODE_FOR_msa_insert_d:\n+      /* Map the built-ins to insert operations.  We need to swap operands,\n+\t fix up the mode for the element being inserted, and generate\n+\t a bit mask for vec_merge.  */\n+      gcc_assert (has_target_p && nops == 4);\n+      std::swap (ops[1], ops[2]);\n+      std::swap (ops[1], ops[3]);\n+      imode = GET_MODE_INNER (ops[0].mode);\n+      ops[1].value = lowpart_subreg (imode, ops[1].value, ops[1].mode);\n+      ops[1].mode = imode;\n+      ops[3].value = GEN_INT (1 << INTVAL (ops[3].value));\n+      break;\n+\n+    case CODE_FOR_msa_insve_b:\n+    case CODE_FOR_msa_insve_h:\n+    case CODE_FOR_msa_insve_w:\n+    case CODE_FOR_msa_insve_d:\n+      /* Map the built-ins to element insert operations.  We need to swap\n+\t operands and generate a bit mask.  */\n+      gcc_assert (has_target_p && nops == 4);\n+      std::swap (ops[1], ops[2]);\n+      std::swap (ops[1], ops[3]);\n+      ops[3].value = GEN_INT (1 << INTVAL (ops[3].value));\n+      break;\n+\n+    case CODE_FOR_msa_shf_b:\n+    case CODE_FOR_msa_shf_h:\n+    case CODE_FOR_msa_shf_w:\n+    case CODE_FOR_msa_shf_w_f:\n+      gcc_assert (has_target_p && nops == 3);\n+      ops[2].value = mips_gen_const_int_vector_shuffle (ops[0].mode,\n+\t\t\t\t\t\t\tINTVAL (ops[2].value));\n+      break;\n+\n+    case CODE_FOR_msa_vshf_b:\n+    case CODE_FOR_msa_vshf_h:\n+    case CODE_FOR_msa_vshf_w:\n+    case CODE_FOR_msa_vshf_d:\n+      gcc_assert (has_target_p && nops == 4);\n+      std::swap (ops[1], ops[3]);\n+      break;\n+\n+    default:\n+      break;\n+  }\n+\n   if (!maybe_expand_insn (icode, nops, ops))\n     {\n       error (\"invalid argument to built-in function\");\n@@ -15182,6 +16833,50 @@ mips_expand_builtin_movtf (enum mips_builtin_type type,\n \t\t\t\t   4, ops, true);\n }\n \n+/* Expand an MSA built-in for a compare and branch instruction specified by\n+   ICODE, set a general-purpose register to 1 if the branch was taken,\n+   0 otherwise.  */\n+\n+static rtx\n+mips_expand_builtin_msa_test_branch (enum insn_code icode, tree exp)\n+{\n+  struct expand_operand ops[3];\n+  rtx_insn *cbranch;\n+  rtx_code_label *true_label, *done_label;\n+  rtx cmp_result;\n+\n+  true_label = gen_label_rtx ();\n+  done_label = gen_label_rtx ();\n+\n+  create_input_operand (&ops[0], true_label, TYPE_MODE (TREE_TYPE (exp)));\n+  mips_prepare_builtin_arg (&ops[1], exp, 0);\n+  create_fixed_operand (&ops[2], const0_rtx);\n+\n+  /* Make sure that the operand 1 is a REG.  */\n+  if (GET_CODE (ops[1].value) != REG)\n+    ops[1].value = force_reg (ops[1].mode, ops[1].value);\n+\n+  if ((cbranch = maybe_gen_insn (icode, 3, ops)) == NULL_RTX)\n+    error (\"failed to expand built-in function\");\n+\n+  cmp_result = gen_reg_rtx (SImode);\n+\n+  /* First assume that CMP_RESULT is false.  */\n+  mips_emit_move (cmp_result, const0_rtx);\n+\n+  /* Branch to TRUE_LABEL if CBRANCH is taken and DONE_LABEL otherwise.  */\n+  emit_jump_insn (cbranch);\n+  emit_jump_insn (gen_jump (done_label));\n+  emit_barrier ();\n+\n+  /* Set CMP_RESULT to true if the branch was taken.  */\n+  emit_label (true_label);\n+  mips_emit_move (cmp_result, const1_rtx);\n+\n+  emit_label (done_label);\n+  return cmp_result;\n+}\n+\n /* Move VALUE_IF_TRUE into TARGET if CONDITION is true; move VALUE_IF_FALSE\n    into TARGET otherwise.  Return TARGET.  */\n \n@@ -15318,6 +17013,9 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return mips_expand_builtin_compare (d->builtin_type, d->icode,\n \t\t\t\t\t  d->cond, target, exp);\n \n+    case MIPS_BUILTIN_MSA_TEST_BRANCH:\n+      return mips_expand_builtin_msa_test_branch (d->icode, exp);\n+\n     case MIPS_BUILTIN_BPOSGE32:\n       return mips_expand_builtin_bposge (d->builtin_type, target);\n     }\n@@ -17592,6 +19290,9 @@ mips_set_compression_mode (unsigned int compression_mode)\n \n       if (TARGET_HARD_FLOAT_ABI && !TARGET_OLDABI)\n \tsorry (\"hard-float MIPS16 code for ABIs other than o32 and o64\");\n+\n+      if (TARGET_MSA)\n+\tsorry (\"MSA MIPS16 code\");\n     }\n   else\n     {\n@@ -17768,6 +19469,11 @@ mips_option_override (void)\n   if (TARGET_MICROMIPS && TARGET_MIPS16)\n     error (\"unsupported combination: %s\", \"-mips16 -mmicromips\");\n \n+  /* Prohibit Paired-Single and MSA combination.  This is software restriction\n+     rather than architectural.  */\n+  if (ISA_HAS_MSA && TARGET_PAIRED_SINGLE_FLOAT)\n+    error (\"unsupported combination: %s\", \"-mmsa -mpaired-single\");\n+\n   /* Save the base compression state and process flags as though we\n      were generating uncompressed code.  */\n   mips_base_compression_flags = TARGET_COMPRESSION;\n@@ -17871,6 +19577,8 @@ mips_option_override (void)\n \ttarget_flags |= MASK_FLOAT64;\n       else if (TARGET_64BIT && TARGET_DOUBLE_FLOAT)\n \ttarget_flags |= MASK_FLOAT64;\n+      else if (mips_abi == ABI_32 && ISA_HAS_MSA && !TARGET_FLOATXX)\n+\ttarget_flags |= MASK_FLOAT64;\n       else\n \ttarget_flags &= ~MASK_FLOAT64;\n     }\n@@ -18129,6 +19837,11 @@ mips_option_override (void)\n       TARGET_MIPS3D = 0;\n     }\n \n+  /* Make sure that when ISA_HAS_MSA is true, TARGET_FLOAT64 and\n+     TARGET_HARD_FLOAT_ABI and  both true.  */\n+  if (ISA_HAS_MSA && !(TARGET_FLOAT64 && TARGET_HARD_FLOAT_ABI))\n+    error (\"%<-mmsa%> must be used with %<-mfp64%> and %<-mhard-float%>\");\n+\n   /* Make sure that -mpaired-single is only used on ISAs that support it.\n      We must disable it otherwise since it relies on other ISA properties\n      like ISA_HAS_8CC having their normal values.  */\n@@ -19164,7 +20877,7 @@ mips_prepare_pch_save (void)\n \f\n /* Generate or test for an insn that supports a constant permutation.  */\n \n-#define MAX_VECT_LEN 8\n+#define MAX_VECT_LEN 16\n \n struct expand_vec_perm_d\n {\n@@ -19368,6 +21081,41 @@ mips_expand_vpc_loongson_bcast (struct expand_vec_perm_d *d)\n   return true;\n }\n \n+/* Construct (set target (vec_select op0 (parallel selector))) and\n+   return true if that's a valid instruction in the active ISA.  */\n+\n+static bool\n+mips_expand_msa_shuffle (struct expand_vec_perm_d *d)\n+{\n+  rtx x, elts[MAX_VECT_LEN];\n+  rtvec v;\n+  rtx_insn *insn;\n+  unsigned i;\n+\n+  if (!ISA_HAS_MSA)\n+    return false;\n+\n+  for (i = 0; i < d->nelt; i++)\n+    elts[i] = GEN_INT (d->perm[i]);\n+\n+  v = gen_rtvec_v (d->nelt, elts);\n+  x = gen_rtx_PARALLEL (VOIDmode, v);\n+\n+  if (!mips_const_vector_shuffle_set_p (x, d->vmode))\n+    return false;\n+\n+  x = gen_rtx_VEC_SELECT (d->vmode, d->op0, x);\n+  x = gen_rtx_SET (d->target, x);\n+\n+  insn = emit_insn (x);\n+  if (recog_memoized (insn) < 0)\n+    {\n+      remove_insn (insn);\n+      return false;\n+    }\n+  return true;\n+}\n+\n static bool\n mips_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n {\n@@ -19402,6 +21150,8 @@ mips_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n     return true;\n   if (mips_expand_vpc_loongson_bcast (d))\n     return true;\n+  if (mips_expand_msa_shuffle (d))\n+    return true;\n   return false;\n }\n \n@@ -19480,6 +21230,17 @@ mips_expand_vec_perm_const (rtx operands[4])\n   return ok;\n }\n \n+/* Implement TARGET_SCHED_REASSOCIATION_WIDTH.  */\n+\n+static int\n+mips_sched_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n+\t\t\t\tmachine_mode mode)\n+{\n+  if (MSA_SUPPORTED_MODE_P (mode))\n+    return 2;\n+  return 1;\n+}\n+\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n \n static bool\n@@ -19530,24 +21291,77 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n {\n   machine_mode imode = GET_MODE (operands[1]);\n   rtx (*unpack) (rtx, rtx, rtx);\n-  rtx (*cmpgt) (rtx, rtx, rtx);\n+  rtx (*cmpFunc) (rtx, rtx, rtx);\n   rtx tmp, dest, zero;\n \n+  if (ISA_HAS_MSA)\n+    {\n+      switch (imode)\n+\t{\n+\tcase V4SImode:\n+\t  if (BYTES_BIG_ENDIAN != high_p)\n+\t    unpack = gen_msa_ilvl_w;\n+\t  else\n+\t    unpack = gen_msa_ilvr_w;\n+\n+\t  cmpFunc = gen_msa_clt_s_w;\n+\t  break;\n+\n+\tcase V8HImode:\n+\t  if (BYTES_BIG_ENDIAN != high_p)\n+\t    unpack = gen_msa_ilvl_h;\n+\t  else\n+\t    unpack = gen_msa_ilvr_h;\n+\n+\t  cmpFunc = gen_msa_clt_s_h;\n+\t  break;\n+\n+\tcase V16QImode:\n+\t  if (BYTES_BIG_ENDIAN != high_p)\n+\t    unpack = gen_msa_ilvl_b;\n+\t  else\n+\t    unpack = gen_msa_ilvr_b;\n+\n+\t  cmpFunc = gen_msa_clt_s_b;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+\n+      if (!unsigned_p)\n+\t{\n+\t  /* Extract sign extention for each element comparing each element\n+\t     with immediate zero.  */\n+\t  tmp = gen_reg_rtx (imode);\n+\t  emit_insn (cmpFunc (tmp, operands[1], CONST0_RTX (imode)));\n+\t}\n+      else\n+\ttmp = force_reg (imode, CONST0_RTX (imode));\n+\n+      dest = gen_reg_rtx (imode);\n+\n+      emit_insn (unpack (dest, operands[1], tmp));\n+      emit_move_insn (operands[0], gen_lowpart (GET_MODE (operands[0]), dest));\n+      return;\n+    }\n+\n   switch (imode)\n     {\n     case V8QImode:\n       if (high_p)\n \tunpack = gen_loongson_punpckhbh;\n       else\n \tunpack = gen_loongson_punpcklbh;\n-      cmpgt = gen_loongson_pcmpgtb;\n+      cmpFunc = gen_loongson_pcmpgtb;\n       break;\n     case V4HImode:\n       if (high_p)\n \tunpack = gen_loongson_punpckhhw;\n       else\n \tunpack = gen_loongson_punpcklhw;\n-      cmpgt = gen_loongson_pcmpgth;\n+      cmpFunc = gen_loongson_pcmpgth;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -19559,7 +21373,7 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n   else\n     {\n       tmp = gen_reg_rtx (imode);\n-      emit_insn (cmpgt (tmp, zero, operands[1]));\n+      emit_insn (cmpFunc (tmp, zero, operands[1]));\n     }\n \n   dest = gen_reg_rtx (imode);\n@@ -19568,6 +21382,28 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n   emit_move_insn (operands[0], gen_lowpart (GET_MODE (operands[0]), dest));\n }\n \n+/* Construct and return PARALLEL RTX with CONST_INTs for HIGH (high_p == TRUE)\n+   or LOW (high_p == FALSE) half of a vector for mode MODE.  */\n+\n+rtx\n+mips_msa_vec_parallel_const_half (machine_mode mode, bool high_p)\n+{\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtvec v = rtvec_alloc (nunits / 2);\n+  int base;\n+  int i;\n+\n+  if (BYTES_BIG_ENDIAN)\n+    base = high_p ? 0 : nunits / 2;\n+  else\n+    base = high_p ? nunits / 2 : 0;\n+\n+  for (i = 0; i < nunits / 2; i++)\n+    RTVEC_ELT (v, i) = GEN_INT (base + i);\n+\n+  return gen_rtx_PARALLEL (VOIDmode, v);\n+}\n+\n /* A subroutine of mips_expand_vec_init, match constant vector elements.  */\n \n static inline bool\n@@ -19615,6 +21451,42 @@ mips_expand_vi_broadcast (machine_mode vmode, rtx target, rtx elt)\n   gcc_assert (ok);\n }\n \n+/* Return a const_int vector of VAL with mode MODE.  */\n+\n+rtx\n+mips_gen_const_int_vector (machine_mode mode, int val)\n+{\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtvec v = rtvec_alloc (nunits);\n+  int i;\n+\n+  for (i = 0; i < nunits; i++)\n+    RTVEC_ELT (v, i) = gen_int_mode (val, GET_MODE_INNER (mode));\n+\n+  return gen_rtx_CONST_VECTOR (mode, v);\n+}\n+\n+/* Return a vector of repeated 4-element sets generated from\n+   immediate VAL in mode MODE.  */\n+\n+static rtx\n+mips_gen_const_int_vector_shuffle (machine_mode mode, int val)\n+{\n+  int nunits = GET_MODE_NUNITS (mode);\n+  int nsets = nunits / 4;\n+  rtx elts[MAX_VECT_LEN];\n+  int set = 0;\n+  int i, j;\n+\n+  /* Generate a const_int vector replicating the same 4-element set\n+     from an immediate.  */\n+  for (j = 0; j < nsets; j++, set = 4 * j)\n+    for (i = 0; i < 4; i++)\n+      elts[set + i] = GEN_INT (set + ((val >> (2 * i)) & 0x3));\n+\n+  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nunits, elts));\n+}\n+\n /* A subroutine of mips_expand_vec_init, replacing all of the non-constant\n    elements of VALS with zeros, copy the constant vector to TARGET.  */\n \n@@ -19627,8 +21499,9 @@ mips_expand_vi_constant (machine_mode vmode, unsigned nelt,\n \n   for (i = 0; i < nelt; ++i)\n     {\n-      if (!mips_constant_elt_p (RTVEC_ELT (vec, i)))\n-\tRTVEC_ELT (vec, i) = const0_rtx;\n+      rtx elem = RTVEC_ELT (vec, i);\n+      if (!mips_constant_elt_p (elem))\n+\tRTVEC_ELT (vec, i) = CONST0_RTX (GET_MODE (elem));\n     }\n \n   emit_move_insn (target, gen_rtx_CONST_VECTOR (vmode, vec));\n@@ -19689,6 +21562,106 @@ mips_expand_vector_init (rtx target, rtx vals)\n \tall_same = false;\n     }\n \n+  if (ISA_HAS_MSA)\n+    {\n+      if (all_same)\n+\t{\n+\t  rtx same = XVECEXP (vals, 0, 0);\n+\t  rtx temp, temp2;\n+\n+\t  if (CONST_INT_P (same) && nvar == 0\n+\t      && mips_signed_immediate_p (INTVAL (same), 10, 0))\n+\t    {\n+\t      switch (vmode)\n+\t\t{\n+\t\tcase V16QImode:\n+\t\tcase V8HImode:\n+\t\tcase V4SImode:\n+\t\tcase V2DImode:\n+\t\t  emit_move_insn (target, same);\n+\t\t  return;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  temp = gen_reg_rtx (imode);\n+\t  if (imode == GET_MODE (same))\n+\t    temp2 = same;\n+\t  else if (GET_MODE_SIZE (imode) >= UNITS_PER_WORD)\n+\t    temp2 = simplify_gen_subreg (imode, same, GET_MODE (same), 0);\n+\t  else\n+\t    temp2 = lowpart_subreg (imode, same, GET_MODE (same));\n+\t  emit_move_insn (temp, temp2);\n+\n+\t  switch (vmode)\n+\t    {\n+\t    case V16QImode:\n+\t    case V8HImode:\n+\t    case V4SImode:\n+\t    case V2DImode:\n+\t      mips_emit_move (target, gen_rtx_VEC_DUPLICATE (vmode, temp));\n+\t      break;\n+\n+\t    case V4SFmode:\n+\t      emit_insn (gen_msa_splati_w_f_scalar (target, temp));\n+\t      break;\n+\n+\t    case V2DFmode:\n+\t      emit_insn (gen_msa_splati_d_f_scalar (target, temp));\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rtvec vec = shallow_copy_rtvec (XVEC (vals, 0));\n+\n+\t  for (i = 0; i < nelt; ++i)\n+\t    RTVEC_ELT (vec, i) = CONST0_RTX (imode);\n+\n+\t  emit_move_insn (target, gen_rtx_CONST_VECTOR (vmode, vec));\n+\n+\t  for (i = 0; i < nelt; ++i)\n+\t    {\n+\t      rtx temp = gen_reg_rtx (imode);\n+\t      emit_move_insn (temp, XVECEXP (vals, 0, i));\n+\t      switch (vmode)\n+\t\t{\n+\t\tcase V16QImode:\n+\t\t  emit_insn (gen_vec_setv16qi (target, temp, GEN_INT (i)));\n+\t\t  break;\n+\n+\t\tcase V8HImode:\n+\t\t  emit_insn (gen_vec_setv8hi (target, temp, GEN_INT (i)));\n+\t\t  break;\n+\n+\t\tcase V4SImode:\n+\t\t  emit_insn (gen_vec_setv4si (target, temp, GEN_INT (i)));\n+\t\t  break;\n+\n+\t\tcase V2DImode:\n+\t\t  emit_insn (gen_vec_setv2di (target, temp, GEN_INT (i)));\n+\t\t  break;\n+\n+\t\tcase V4SFmode:\n+\t\t  emit_insn (gen_vec_setv4sf (target, temp, GEN_INT (i)));\n+\t\t  break;\n+\n+\t\tcase V2DFmode:\n+\t\t  emit_insn (gen_vec_setv2df (target, temp, GEN_INT (i)));\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+\n   /* Load constants from the pool, or whatever's handy.  */\n   if (nvar == 0)\n     {\n@@ -19839,6 +21812,169 @@ mips_hard_regno_caller_save_mode (unsigned int regno,\n     return mode;\n }\n \n+/* Generate RTL for comparing CMP_OP0 and CMP_OP1 using condition COND and\n+   store the result -1 or 0 in DEST.  */\n+\n+static void\n+mips_expand_msa_cmp (rtx dest, enum rtx_code cond, rtx op0, rtx op1)\n+{\n+  machine_mode cmp_mode = GET_MODE (op0);\n+  int unspec = -1;\n+  bool negate = false;\n+\n+  switch (cmp_mode)\n+    {\n+    case V16QImode:\n+    case V8HImode:\n+    case V4SImode:\n+    case V2DImode:\n+      switch (cond)\n+\t{\n+\tcase NE:\n+\t  cond = reverse_condition (cond);\n+\t  negate = true;\n+\t  break;\n+\tcase EQ:\n+\tcase LT:\n+\tcase LE:\n+\tcase LTU:\n+\tcase LEU:\n+\t  break;\n+\tcase GE:\n+\tcase GT:\n+\tcase GEU:\n+\tcase GTU:\n+\t  std::swap (op0, op1);\n+\t  cond = swap_condition (cond);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      mips_emit_binary (cond, dest, op0, op1);\n+      if (negate)\n+\temit_move_insn (dest, gen_rtx_NOT (GET_MODE (dest), dest));\n+      break;\n+\n+    case V4SFmode:\n+    case V2DFmode:\n+      switch (cond)\n+\t{\n+\tcase UNORDERED:\n+\tcase ORDERED:\n+\tcase EQ:\n+\tcase NE:\n+\tcase UNEQ:\n+\tcase UNLE:\n+\tcase UNLT:\n+\t  break;\n+\tcase LTGT: cond = NE; break;\n+\tcase UNGE: cond = UNLE; std::swap (op0, op1); break;\n+\tcase UNGT: cond = UNLT; std::swap (op0, op1); break;\n+\tcase LE: unspec = UNSPEC_MSA_FSLE; break;\n+\tcase LT: unspec = UNSPEC_MSA_FSLT; break;\n+\tcase GE: unspec = UNSPEC_MSA_FSLE; std::swap (op0, op1); break;\n+\tcase GT: unspec = UNSPEC_MSA_FSLT; std::swap (op0, op1); break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      if (unspec < 0)\n+\tmips_emit_binary (cond, dest, op0, op1);\n+      else\n+\t{\n+\t  rtx x = gen_rtx_UNSPEC (GET_MODE (dest),\n+\t\t\t\t  gen_rtvec (2, op0, op1), unspec);\n+\t  emit_insn (gen_rtx_SET (dest, x));\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+/* Expand VEC_COND_EXPR, where:\n+   MODE is mode of the result\n+   VIMODE equivalent integer mode\n+   OPERANDS operands of VEC_COND_EXPR.  */\n+\n+void\n+mips_expand_vec_cond_expr (machine_mode mode, machine_mode vimode,\n+\t\t\t   rtx *operands)\n+{\n+  rtx cond = operands[3];\n+  rtx cmp_op0 = operands[4];\n+  rtx cmp_op1 = operands[5];\n+  rtx cmp_res = gen_reg_rtx (vimode);\n+\n+  mips_expand_msa_cmp (cmp_res, GET_CODE (cond), cmp_op0, cmp_op1);\n+\n+  /* We handle the following cases:\n+     1) r = a CMP b ? -1 : 0\n+     2) r = a CMP b ? -1 : v\n+     3) r = a CMP b ?  v : 0\n+     4) r = a CMP b ? v1 : v2  */\n+\n+  /* Case (1) above.  We only move the results.  */\n+  if (operands[1] == CONSTM1_RTX (vimode)\n+      && operands[2] == CONST0_RTX (vimode))\n+    emit_move_insn (operands[0], cmp_res);\n+  else\n+    {\n+      rtx src1 = gen_reg_rtx (vimode);\n+      rtx src2 = gen_reg_rtx (vimode);\n+      rtx mask = gen_reg_rtx (vimode);\n+      rtx bsel;\n+\n+      /* Move the vector result to use it as a mask.  */\n+      emit_move_insn (mask, cmp_res);\n+\n+      if (register_operand (operands[1], mode))\n+\t{\n+\t  rtx xop1 = operands[1];\n+\t  if (mode != vimode)\n+\t    {\n+\t      xop1 = gen_reg_rtx (vimode);\n+\t      emit_move_insn (xop1, gen_rtx_SUBREG (vimode, operands[1], 0));\n+\t    }\n+\t  emit_move_insn (src1, xop1);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (operands[1] == CONSTM1_RTX (vimode));\n+\t  /* Case (2) if the below doesn't move the mask to src2.  */\n+\t  emit_move_insn (src1, mask);\n+\t}\n+\n+      if (register_operand (operands[2], mode))\n+\t{\n+\t  rtx xop2 = operands[2];\n+\t  if (mode != vimode)\n+\t    {\n+\t      xop2 = gen_reg_rtx (vimode);\n+\t      emit_move_insn (xop2, gen_rtx_SUBREG (vimode, operands[2], 0));\n+\t    }\n+\t  emit_move_insn (src2, xop2);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (operands[2] == CONST0_RTX (mode));\n+\t  /* Case (3) if the above didn't move the mask to src1.  */\n+\t  emit_move_insn (src2, mask);\n+\t}\n+\n+      /* We deal with case (4) if the mask wasn't moved to either src1 or src2.\n+\t In any case, we eventually do vector mask-based copy.  */\n+      bsel = gen_rtx_IOR (vimode,\n+\t\t\t  gen_rtx_AND (vimode,\n+\t\t\t\t       gen_rtx_NOT (vimode, mask), src2),\n+\t\t\t  gen_rtx_AND (vimode, mask, src1));\n+      /* The result is placed back to a register with the mask.  */\n+      emit_insn (gen_rtx_SET (mask, bsel));\n+      emit_move_insn (operands[0], gen_rtx_SUBREG (mode, mask, 0));\n+    }\n+}\n+\n /* Implement TARGET_CASE_VALUES_THRESHOLD.  */\n \n unsigned int\n@@ -20120,6 +22256,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_MODE_REP_EXTENDED\n #define TARGET_MODE_REP_EXTENDED mips_mode_rep_extended\n \n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \\\n+  mips_builtin_vectorized_function\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P mips_vector_mode_supported_p\n \n@@ -20128,6 +22267,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n \n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE mips_preferred_simd_mode\n+#undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n+#define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n+  mips_autovectorize_vector_sizes\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS mips_init_builtins\n@@ -20205,6 +22347,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n #define TARGET_VECTORIZE_VEC_PERM_CONST_OK mips_vectorize_vec_perm_const_ok\n \n+#undef TARGET_SCHED_REASSOCIATION_WIDTH\n+#define TARGET_SCHED_REASSOCIATION_WIDTH mips_sched_reassociation_width\n+\n #undef TARGET_CASE_VALUES_THRESHOLD\n #define TARGET_CASE_VALUES_THRESHOLD mips_case_values_threshold\n "}, {"sha": "1efa61a6edeaab98414e6f7691aae28a8af83110", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -472,6 +472,12 @@ struct mips_cpu_info {\n \t    builtin_define (\"__mips_dsp_rev=1\");\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      if (ISA_HAS_MSA)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  builtin_define (\"__mips_msa\");\t\t\t\t\\\n+\t  builtin_define (\"__mips_msa_width=128\");\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       MIPS_CPP_SET_PROCESSOR (\"_MIPS_ARCH\", mips_arch_info);\t\t\\\n       MIPS_CPP_SET_PROCESSOR (\"_MIPS_TUNE\", mips_tune_info);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -824,7 +830,8 @@ struct mips_cpu_info {\n    --with-fpu is ignored if -msoft-float, -msingle-float or -mdouble-float are\n      specified.\n    --with-nan is ignored if -mnan is specified.\n-   --with-fp-32 is ignored if -msoft-float, -msingle-float or -mfp are specified.\n+   --with-fp-32 is ignored if -msoft-float, -msingle-float, -mmsa or -mfp are\n+     specified.\n    --with-odd-spreg-32 is ignored if -msoft-float, -msingle-float, -modd-spreg\n      or -mno-odd-spreg are specified.\n    --with-divide is ignored if -mdivide-traps or -mdivide-breaks are\n@@ -841,7 +848,7 @@ struct mips_cpu_info {\n   {\"fpu\", \"%{!msoft-float:%{!msingle-float:%{!mdouble-float:-m%(VALUE)-float}}}\" }, \\\n   {\"nan\", \"%{!mnan=*:-mnan=%(VALUE)}\" }, \\\n   {\"fp_32\", \"%{\" OPT_ARCH32 \\\n-\t    \":%{!msoft-float:%{!msingle-float:%{!mfp*:-mfp%(VALUE)}}}}\" }, \\\n+\t    \":%{!msoft-float:%{!msingle-float:%{!mfp*:%{!mmsa:-mfp%(VALUE)}}}}}\" }, \\\n   {\"odd_spreg_32\", \"%{\" OPT_ARCH32 \":%{!msoft-float:%{!msingle-float:\" \\\n \t\t   \"%{!modd-spreg:%{!mno-odd-spreg:-m%(VALUE)}}}}}\" }, \\\n   {\"divide\", \"%{!mdivide-traps:%{!mdivide-breaks:-mdivide-%(VALUE)}}\" }, \\\n@@ -1175,6 +1182,9 @@ struct mips_cpu_info {\n /* Revision 2 of the DSP ASE is available.  */\n #define ISA_HAS_DSPR2\t\t(TARGET_DSPR2 && !TARGET_MIPS16)\n \n+/* The MSA ASE is available.  */\n+#define ISA_HAS_MSA\t\t(TARGET_MSA && !TARGET_MIPS16)\n+\n /* True if the result of a load is not available to the next instruction.\n    A nop will then be needed between instructions like \"lw $4,...\"\n    and \"addiu $4,$4,1\".  */\n@@ -1316,6 +1326,7 @@ struct mips_cpu_info {\n %{meva} %{mno-eva} \\\n %{mvirt} %{mno-virt} \\\n %{mxpa} %{mno-xpa} \\\n+%{mmsa} %{mno-msa} \\\n %{msmartmips} %{mno-smartmips} \\\n %{mmt} %{mno-mt} \\\n %{mfix-rm7000} %{mno-fix-rm7000} \\\n@@ -1487,6 +1498,11 @@ FP_ASM_SPEC \"\\\n #define MIN_UNITS_PER_WORD 4\n #endif\n \n+/* Width of a MSA vector register in bytes.  */\n+#define UNITS_PER_MSA_REG 16\n+/* Width of a MSA vector register in bits.  */\n+#define BITS_PER_MSA_REG (UNITS_PER_MSA_REG * BITS_PER_UNIT)\n+\n /* For MIPS, width of a floating point register.  */\n #define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)\n \n@@ -1559,8 +1575,11 @@ FP_ASM_SPEC \"\\\n /* 8 is observed right on a DECstation and on riscos 4.02.  */\n #define STRUCTURE_SIZE_BOUNDARY 8\n \n-/* There is no point aligning anything to a rounder boundary than this.  */\n-#define BIGGEST_ALIGNMENT LONG_DOUBLE_TYPE_SIZE\n+/* There is no point aligning anything to a rounder boundary than\n+   LONG_DOUBLE_TYPE_SIZE, unless under MSA the bigggest alignment is\n+   BITS_PER_MSA_REG.  */\n+#define BIGGEST_ALIGNMENT \\\n+  (ISA_HAS_MSA ? BITS_PER_MSA_REG : LONG_DOUBLE_TYPE_SIZE)\n \n /* All accesses must be aligned.  */\n #define STRICT_ALIGNMENT 1\n@@ -1667,7 +1686,7 @@ FP_ASM_SPEC \"\\\n /* The [d]clz instructions have the natural values at 0.  */\n \n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n-  ((VALUE) = GET_MODE_BITSIZE (MODE), 2)\n+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)\n \f\n /* Standard register usage.  */\n \n@@ -1798,6 +1817,10 @@ FP_ASM_SPEC \"\\\n #define MD_REG_NUM   (MD_REG_LAST - MD_REG_FIRST + 1)\n #define MD_DBX_FIRST (FP_DBX_FIRST + FP_REG_NUM)\n \n+#define MSA_REG_FIRST FP_REG_FIRST\n+#define MSA_REG_LAST  FP_REG_LAST\n+#define MSA_REG_NUM   FP_REG_NUM\n+\n /* The DWARF 2 CFA column which tracks the return address from a\n    signal handler context.  This means that to maintain backwards\n    compatibility, no hard register can be assigned this column if it\n@@ -1886,8 +1909,11 @@ FP_ASM_SPEC \"\\\n /* Test if REGNO is hi, lo, or one of the 6 new DSP accumulators.  */\n #define ACC_REG_P(REGNO) \\\n   (MD_REG_P (REGNO) || DSP_ACC_REG_P (REGNO))\n+#define MSA_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - MSA_REG_FIRST) < MSA_REG_NUM)\n \n #define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n+#define MSA_REG_RTX_P(X) (REG_P (X) && MSA_REG_P (REGNO (X)))\n \n /* True if X is (const (unspec [(const_int 0)] UNSPEC_GP)).  This is used\n    to initialize the mips16 gp pseudo register.  */\n@@ -1916,10 +1942,12 @@ FP_ASM_SPEC \"\\\n   mips_hard_regno_caller_save_mode (REGNO, NREGS, MODE)\n \n /* Odd-numbered single-precision registers are not considered callee-saved\n-   for o32 FPXX as they will be clobbered when run on an FR=1 FPU.  */\n+   for o32 FPXX as they will be clobbered when run on an FR=1 FPU.\n+   MSA vector registers with MODE > 64 bits are part clobbered too.  */\n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n-  (TARGET_FLOATXX && hard_regno_nregs[REGNO][MODE] == 1\t\t\t\\\n-   && FP_REG_P (REGNO) && ((REGNO) & 1))\n+  ((TARGET_FLOATXX && hard_regno_nregs[REGNO][MODE] == 1\t\t\\\n+   && FP_REG_P (REGNO) && ((REGNO) & 1))\t\t\t\t\\\n+   || (ISA_HAS_MSA && FP_REG_P (REGNO) && GET_MODE_SIZE (MODE) > 8))\n \n #define MODES_TIEABLE_P mips_modes_tieable_p\n \n@@ -2381,6 +2409,13 @@ enum reg_class\n #define FP_ARG_FIRST (FP_REG_FIRST + 12)\n #define FP_ARG_LAST  (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n \n+/* True if MODE is vector and supported in a MSA vector register.  */\n+#define MSA_SUPPORTED_MODE_P(MODE)\t\t\t\\\n+  (ISA_HAS_MSA\t\t\t\t\t\t\\\n+   && GET_MODE_SIZE (MODE) == UNITS_PER_MSA_REG\t\t\\\n+   && (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\t\\\n+       || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT))\n+\n /* Temporary register that is used when restoring $gp after a call.  $4 and $5\n    are used for returning complex double values in soft-float code, so $6 is the\n    first suitable candidate for TARGET_MIPS16.  For !TARGET_MIPS16 we can use\n@@ -2606,6 +2641,7 @@ typedef struct mips_args {\n    we generally don't want to use them for copying arbitrary data.\n    A single N-word move is usually the same cost as N single-word moves.  */\n #define MOVE_MAX UNITS_PER_WORD\n+/* We don't modify it for MSA as it is only used by the classic reload.  */\n #define MAX_MOVE_MAX 8\n \n /* Define this macro as a C expression which is nonzero if\n@@ -2767,7 +2803,39 @@ typedef struct mips_args {\n   { \"gp\",\t28 + GP_REG_FIRST },\t\t\t\t\t\\\n   { \"sp\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n   { \"fp\",\t30 + GP_REG_FIRST },\t\t\t\t\t\\\n-  { \"ra\",\t31 + GP_REG_FIRST }\t\t\t\t\t\\\n+  { \"ra\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w0\",\t 0 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w1\",\t 1 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w2\",\t 2 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w3\",\t 3 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w4\",\t 4 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w5\",\t 5 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w6\",\t 6 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w7\",\t 7 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w8\",\t 8 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w9\",\t 9 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w10\",\t10 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w11\",\t11 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w12\",\t12 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w13\",\t13 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w14\",\t14 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w15\",\t15 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w16\",\t16 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w17\",\t17 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w18\",\t18 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w19\",\t19 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w20\",\t20 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w21\",\t21 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w22\",\t22 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w23\",\t23 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w24\",\t24 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w25\",\t25 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w26\",\t26 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w27\",\t27 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w28\",\t28 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w29\",\t29 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w30\",\t30 + FP_REG_FIRST },\t\t\t\t\t\\\n+  { \"$w31\",\t31 + FP_REG_FIRST }\t\t\t\t\t\\\n }\n \n #define DBR_OUTPUT_SEQEND(STREAM)\t\t\t\t\t\\"}, {"sha": "d8d564fabd9cc74c268f98762d17e9e09987315e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -225,11 +225,12 @@\n    shift_shift\"\n   (const_string \"unknown\"))\n \n-(define_attr \"alu_type\" \"unknown,add,sub,not,nor,and,or,xor\"\n+(define_attr \"alu_type\" \"unknown,add,sub,not,nor,and,or,xor,simd_add\"\n   (const_string \"unknown\"))\n \n ;; Main data type used by the insn\n-(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,TI,SF,DF,TF,FPSW\"\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,TI,SF,DF,TF,FPSW,\n+  V2DI,V4SI,V8HI,V16QI,V2DF,V4SF\"\n   (const_string \"unknown\"))\n \n ;; True if the main data type is twice the size of a word.\n@@ -243,6 +244,13 @@\n \t (const_string \"yes\")]\n \t(const_string \"no\")))\n \n+;; True if the main data type is four times of the size of a word.\n+(define_attr \"qword_mode\" \"no,yes\"\n+  (cond [(and (eq_attr \"mode\" \"TI,TF\")\n+\t      (not (match_test \"TARGET_64BIT\")))\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n ;; Attributes describing a sync loop.  These loops have the form:\n ;;\n ;;       if (RELEASE_BARRIER == YES) sync\n@@ -365,7 +373,12 @@\n    shift,slt,signext,clz,pop,trap,imul,imul3,imul3nc,imadd,idiv,idiv3,move,\n    fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,\n    frsqrt,frsqrt1,frsqrt2,dspmac,dspmacsat,accext,accmod,dspalu,dspalusat,\n-   multi,atomic,syncloop,nop,ghost,multimem\"\n+   multi,atomic,syncloop,nop,ghost,multimem,\n+   simd_div,simd_fclass,simd_flog2,simd_fadd,simd_fcvt,simd_fmul,simd_fmadd,\n+   simd_fdiv,simd_bitins,simd_bitmov,simd_insert,simd_sld,simd_mul,simd_fcmp,\n+   simd_fexp2,simd_int_arith,simd_bit,simd_shift,simd_splat,simd_fill,\n+   simd_permute,simd_shf,simd_sat,simd_pcnt,simd_copy,simd_branch,simd_cmsa,\n+   simd_fminmax,simd_logic,simd_move,simd_load,simd_store\"\n   (cond [(eq_attr \"jal\" \"!unset\") (const_string \"call\")\n \t (eq_attr \"got\" \"load\") (const_string \"load\")\n \n@@ -400,6 +413,11 @@\n \t (eq_attr \"move_type\" \"constN,shift_shift\")\n \t   (const_string \"multi\")\n \n+\t ;; These types of move are split for quadword modes only.\n+\t (and (eq_attr \"move_type\" \"move,const\")\n+\t      (eq_attr \"qword_mode\" \"yes\"))\n+\t   (const_string \"multi\")\n+\n \t ;; These types of move are split for doubleword modes only.\n \t (and (eq_attr \"move_type\" \"move,const\")\n \t      (eq_attr \"dword_mode\" \"yes\"))\n@@ -486,6 +504,12 @@\n \t      (eq_attr \"dword_mode\" \"yes\"))\n \t (const_int 2)\n \n+\t ;; Check for quadword moves that are decomposed into four\n+\t ;; instructions.\n+\t (and (eq_attr \"move_type\" \"mtc,mfc,move\")\n+\t      (eq_attr \"qword_mode\" \"yes\"))\n+\t (const_int 4)\n+\n \t ;; Constants, loads and stores are handled by external routines.\n \t (and (eq_attr \"move_type\" \"const,constN\")\n \t      (eq_attr \"dword_mode\" \"yes\"))\n@@ -527,7 +551,7 @@\n \t (const_int 2)\n \n \t (eq_attr \"type\" \"idiv,idiv3\")\n-\t (symbol_ref \"mips_idiv_insns ()\")\n+\t (symbol_ref \"mips_idiv_insns (GET_MODE (PATTERN (insn)))\")\n \n \t (not (eq_attr \"sync_mem\" \"none\"))\n \t (symbol_ref \"mips_sync_loop_insns (insn, operands)\")]\n@@ -884,8 +908,10 @@\n (define_mode_attr fmt [(SF \"s\") (DF \"d\") (V2SF \"ps\")])\n \n ;; This attribute gives the upper-case mode name for one unit of a\n-;; floating-point mode.\n-(define_mode_attr UNITMODE [(SF \"SF\") (DF \"DF\") (V2SF \"SF\")])\n+;; floating-point mode or vector mode.\n+(define_mode_attr UNITMODE [(SF \"SF\") (DF \"DF\") (V2SF \"SF\") (V4SF \"SF\")\n+\t\t\t    (V16QI \"QI\") (V8HI \"HI\") (V4SI \"SI\") (V2DI \"DI\")\n+\t\t\t    (V2DF \"DF\")])\n \n ;; This attribute gives the integer mode that has the same size as a\n ;; fixed-point mode.\n@@ -941,6 +967,10 @@\n ;; from the same template.\n (define_code_iterator any_mod [mod umod])\n \n+;; This code iterator allows addition and subtraction to be generated\n+;; from the same template.\n+(define_code_iterator addsub [plus minus])\n+\n ;; This code iterator allows all native floating-point comparisons to be\n ;; generated from the same template.\n (define_code_iterator fcond [unordered uneq unlt unle eq lt le\n@@ -7634,6 +7664,9 @@\n ; ST-Microelectronics Loongson-2E/2F-specific patterns.\n (include \"loongson.md\")\n \n+; The MIPS MSA Instructions.\n+(include \"mips-msa.md\")\n+\n (define_c_enum \"unspec\" [\n   UNSPEC_ADDRESS_FIRST\n ])"}, {"sha": "08dd83e14ce3d590339f6dfd7276385c544e6852", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -299,6 +299,10 @@ mmicromips\n Target Report Mask(MICROMIPS)\n Use microMIPS instructions.\n \n+mmsa\n+Target Report Var(TARGET_MSA)\n+Use MIPS MSA Extension instructions.\n+\n mmt\n Target Report Var(TARGET_MT)\n Allow the use of MT instructions."}, {"sha": "341eb7f81d1a7ee791a3ebdd5981655a3cecf499", "filename": "gcc/config/mips/msa.h", "status": "added", "additions": 582, "deletions": 0, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmsa.h?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -0,0 +1,582 @@\n+/* MIPS MSA intrinsics include file.\n+\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Imagination Technologies Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _MSA_H\n+#define _MSA_H 1\n+\n+#if defined(__mips_msa)\n+typedef signed char v16i8 __attribute__ ((vector_size(16), aligned(16)));\n+typedef signed char v16i8_b __attribute__ ((vector_size(16), aligned(1)));\n+typedef unsigned char v16u8 __attribute__ ((vector_size(16), aligned(16)));\n+typedef unsigned char v16u8_b __attribute__ ((vector_size(16), aligned(1)));\n+typedef short v8i16 __attribute__ ((vector_size(16), aligned(16)));\n+typedef short v8i16_h __attribute__ ((vector_size(16), aligned(2)));\n+typedef unsigned short v8u16 __attribute__ ((vector_size(16), aligned(16)));\n+typedef unsigned short v8u16_h __attribute__ ((vector_size(16), aligned(2)));\n+typedef int v4i32 __attribute__ ((vector_size(16), aligned(16)));\n+typedef int v4i32_w __attribute__ ((vector_size(16), aligned(4)));\n+typedef unsigned int v4u32 __attribute__ ((vector_size(16), aligned(16)));\n+typedef unsigned int v4u32_w __attribute__ ((vector_size(16), aligned(4)));\n+typedef long long v2i64 __attribute__ ((vector_size(16), aligned(16)));\n+typedef long long v2i64_d __attribute__ ((vector_size(16), aligned(8)));\n+typedef unsigned long long v2u64 __attribute__ ((vector_size(16), aligned(16)));\n+typedef unsigned long long v2u64_d __attribute__ ((vector_size(16), aligned(8)));\n+typedef float v4f32 __attribute__ ((vector_size(16), aligned(16)));\n+typedef float v4f32_w __attribute__ ((vector_size(16), aligned(4)));\n+typedef double v2f64 __attribute__ ((vector_size(16), aligned(16)));\n+typedef double v2f64_d __attribute__ ((vector_size(16), aligned(8)));\n+\n+#define __msa_sll_b __builtin_msa_sll_b\n+#define __msa_sll_h __builtin_msa_sll_h\n+#define __msa_sll_w __builtin_msa_sll_w\n+#define __msa_sll_d __builtin_msa_sll_d\n+#define __msa_slli_b __builtin_msa_slli_b\n+#define __msa_slli_h __builtin_msa_slli_h\n+#define __msa_slli_w __builtin_msa_slli_w\n+#define __msa_slli_d __builtin_msa_slli_d\n+#define __msa_sra_b __builtin_msa_sra_b\n+#define __msa_sra_h __builtin_msa_sra_h\n+#define __msa_sra_w __builtin_msa_sra_w\n+#define __msa_sra_d __builtin_msa_sra_d\n+#define __msa_srai_b __builtin_msa_srai_b\n+#define __msa_srai_h __builtin_msa_srai_h\n+#define __msa_srai_w __builtin_msa_srai_w\n+#define __msa_srai_d __builtin_msa_srai_d\n+#define __msa_srar_b __builtin_msa_srar_b\n+#define __msa_srar_h __builtin_msa_srar_h\n+#define __msa_srar_w __builtin_msa_srar_w\n+#define __msa_srar_d __builtin_msa_srar_d\n+#define __msa_srari_b __builtin_msa_srari_b\n+#define __msa_srari_h __builtin_msa_srari_h\n+#define __msa_srari_w __builtin_msa_srari_w\n+#define __msa_srari_d __builtin_msa_srari_d\n+#define __msa_srl_b __builtin_msa_srl_b\n+#define __msa_srl_h __builtin_msa_srl_h\n+#define __msa_srl_w __builtin_msa_srl_w\n+#define __msa_srl_d __builtin_msa_srl_d\n+#define __msa_srli_b __builtin_msa_srli_b\n+#define __msa_srli_h __builtin_msa_srli_h\n+#define __msa_srli_w __builtin_msa_srli_w\n+#define __msa_srli_d __builtin_msa_srli_d\n+#define __msa_srlr_b __builtin_msa_srlr_b\n+#define __msa_srlr_h __builtin_msa_srlr_h\n+#define __msa_srlr_w __builtin_msa_srlr_w\n+#define __msa_srlr_d __builtin_msa_srlr_d\n+#define __msa_srlri_b __builtin_msa_srlri_b\n+#define __msa_srlri_h __builtin_msa_srlri_h\n+#define __msa_srlri_w __builtin_msa_srlri_w\n+#define __msa_srlri_d __builtin_msa_srlri_d\n+#define __msa_bclr_b __builtin_msa_bclr_b\n+#define __msa_bclr_h __builtin_msa_bclr_h\n+#define __msa_bclr_w __builtin_msa_bclr_w\n+#define __msa_bclr_d __builtin_msa_bclr_d\n+#define __msa_bclri_b __builtin_msa_bclri_b\n+#define __msa_bclri_h __builtin_msa_bclri_h\n+#define __msa_bclri_w __builtin_msa_bclri_w\n+#define __msa_bclri_d __builtin_msa_bclri_d\n+#define __msa_bset_b __builtin_msa_bset_b\n+#define __msa_bset_h __builtin_msa_bset_h\n+#define __msa_bset_w __builtin_msa_bset_w\n+#define __msa_bset_d __builtin_msa_bset_d\n+#define __msa_bseti_b __builtin_msa_bseti_b\n+#define __msa_bseti_h __builtin_msa_bseti_h\n+#define __msa_bseti_w __builtin_msa_bseti_w\n+#define __msa_bseti_d __builtin_msa_bseti_d\n+#define __msa_bneg_b __builtin_msa_bneg_b\n+#define __msa_bneg_h __builtin_msa_bneg_h\n+#define __msa_bneg_w __builtin_msa_bneg_w\n+#define __msa_bneg_d __builtin_msa_bneg_d\n+#define __msa_bnegi_b __builtin_msa_bnegi_b\n+#define __msa_bnegi_h __builtin_msa_bnegi_h\n+#define __msa_bnegi_w __builtin_msa_bnegi_w\n+#define __msa_bnegi_d __builtin_msa_bnegi_d\n+#define __msa_binsl_b __builtin_msa_binsl_b\n+#define __msa_binsl_h __builtin_msa_binsl_h\n+#define __msa_binsl_w __builtin_msa_binsl_w\n+#define __msa_binsl_d __builtin_msa_binsl_d\n+#define __msa_binsli_b __builtin_msa_binsli_b\n+#define __msa_binsli_h __builtin_msa_binsli_h\n+#define __msa_binsli_w __builtin_msa_binsli_w\n+#define __msa_binsli_d __builtin_msa_binsli_d\n+#define __msa_binsr_b __builtin_msa_binsr_b\n+#define __msa_binsr_h __builtin_msa_binsr_h\n+#define __msa_binsr_w __builtin_msa_binsr_w\n+#define __msa_binsr_d __builtin_msa_binsr_d\n+#define __msa_binsri_b __builtin_msa_binsri_b\n+#define __msa_binsri_h __builtin_msa_binsri_h\n+#define __msa_binsri_w __builtin_msa_binsri_w\n+#define __msa_binsri_d __builtin_msa_binsri_d\n+#define __msa_addv_b __builtin_msa_addv_b\n+#define __msa_addv_h __builtin_msa_addv_h\n+#define __msa_addv_w __builtin_msa_addv_w\n+#define __msa_addv_d __builtin_msa_addv_d\n+#define __msa_addvi_b __builtin_msa_addvi_b\n+#define __msa_addvi_h __builtin_msa_addvi_h\n+#define __msa_addvi_w __builtin_msa_addvi_w\n+#define __msa_addvi_d __builtin_msa_addvi_d\n+#define __msa_subv_b __builtin_msa_subv_b\n+#define __msa_subv_h __builtin_msa_subv_h\n+#define __msa_subv_w __builtin_msa_subv_w\n+#define __msa_subv_d __builtin_msa_subv_d\n+#define __msa_subvi_b __builtin_msa_subvi_b\n+#define __msa_subvi_h __builtin_msa_subvi_h\n+#define __msa_subvi_w __builtin_msa_subvi_w\n+#define __msa_subvi_d __builtin_msa_subvi_d\n+#define __msa_max_s_b __builtin_msa_max_s_b\n+#define __msa_max_s_h __builtin_msa_max_s_h\n+#define __msa_max_s_w __builtin_msa_max_s_w\n+#define __msa_max_s_d __builtin_msa_max_s_d\n+#define __msa_maxi_s_b __builtin_msa_maxi_s_b\n+#define __msa_maxi_s_h __builtin_msa_maxi_s_h\n+#define __msa_maxi_s_w __builtin_msa_maxi_s_w\n+#define __msa_maxi_s_d __builtin_msa_maxi_s_d\n+#define __msa_max_u_b __builtin_msa_max_u_b\n+#define __msa_max_u_h __builtin_msa_max_u_h\n+#define __msa_max_u_w __builtin_msa_max_u_w\n+#define __msa_max_u_d __builtin_msa_max_u_d\n+#define __msa_maxi_u_b __builtin_msa_maxi_u_b\n+#define __msa_maxi_u_h __builtin_msa_maxi_u_h\n+#define __msa_maxi_u_w __builtin_msa_maxi_u_w\n+#define __msa_maxi_u_d __builtin_msa_maxi_u_d\n+#define __msa_min_s_b __builtin_msa_min_s_b\n+#define __msa_min_s_h __builtin_msa_min_s_h\n+#define __msa_min_s_w __builtin_msa_min_s_w\n+#define __msa_min_s_d __builtin_msa_min_s_d\n+#define __msa_mini_s_b __builtin_msa_mini_s_b\n+#define __msa_mini_s_h __builtin_msa_mini_s_h\n+#define __msa_mini_s_w __builtin_msa_mini_s_w\n+#define __msa_mini_s_d __builtin_msa_mini_s_d\n+#define __msa_min_u_b __builtin_msa_min_u_b\n+#define __msa_min_u_h __builtin_msa_min_u_h\n+#define __msa_min_u_w __builtin_msa_min_u_w\n+#define __msa_min_u_d __builtin_msa_min_u_d\n+#define __msa_mini_u_b __builtin_msa_mini_u_b\n+#define __msa_mini_u_h __builtin_msa_mini_u_h\n+#define __msa_mini_u_w __builtin_msa_mini_u_w\n+#define __msa_mini_u_d __builtin_msa_mini_u_d\n+#define __msa_max_a_b __builtin_msa_max_a_b\n+#define __msa_max_a_h __builtin_msa_max_a_h\n+#define __msa_max_a_w __builtin_msa_max_a_w\n+#define __msa_max_a_d __builtin_msa_max_a_d\n+#define __msa_min_a_b __builtin_msa_min_a_b\n+#define __msa_min_a_h __builtin_msa_min_a_h\n+#define __msa_min_a_w __builtin_msa_min_a_w\n+#define __msa_min_a_d __builtin_msa_min_a_d\n+#define __msa_ceq_b __builtin_msa_ceq_b\n+#define __msa_ceq_h __builtin_msa_ceq_h\n+#define __msa_ceq_w __builtin_msa_ceq_w\n+#define __msa_ceq_d __builtin_msa_ceq_d\n+#define __msa_ceqi_b __builtin_msa_ceqi_b\n+#define __msa_ceqi_h __builtin_msa_ceqi_h\n+#define __msa_ceqi_w __builtin_msa_ceqi_w\n+#define __msa_ceqi_d __builtin_msa_ceqi_d\n+#define __msa_clt_s_b __builtin_msa_clt_s_b\n+#define __msa_clt_s_h __builtin_msa_clt_s_h\n+#define __msa_clt_s_w __builtin_msa_clt_s_w\n+#define __msa_clt_s_d __builtin_msa_clt_s_d\n+#define __msa_clti_s_b __builtin_msa_clti_s_b\n+#define __msa_clti_s_h __builtin_msa_clti_s_h\n+#define __msa_clti_s_w __builtin_msa_clti_s_w\n+#define __msa_clti_s_d __builtin_msa_clti_s_d\n+#define __msa_clt_u_b __builtin_msa_clt_u_b\n+#define __msa_clt_u_h __builtin_msa_clt_u_h\n+#define __msa_clt_u_w __builtin_msa_clt_u_w\n+#define __msa_clt_u_d __builtin_msa_clt_u_d\n+#define __msa_clti_u_b __builtin_msa_clti_u_b\n+#define __msa_clti_u_h __builtin_msa_clti_u_h\n+#define __msa_clti_u_w __builtin_msa_clti_u_w\n+#define __msa_clti_u_d __builtin_msa_clti_u_d\n+#define __msa_cle_s_b __builtin_msa_cle_s_b\n+#define __msa_cle_s_h __builtin_msa_cle_s_h\n+#define __msa_cle_s_w __builtin_msa_cle_s_w\n+#define __msa_cle_s_d __builtin_msa_cle_s_d\n+#define __msa_clei_s_b __builtin_msa_clei_s_b\n+#define __msa_clei_s_h __builtin_msa_clei_s_h\n+#define __msa_clei_s_w __builtin_msa_clei_s_w\n+#define __msa_clei_s_d __builtin_msa_clei_s_d\n+#define __msa_cle_u_b __builtin_msa_cle_u_b\n+#define __msa_cle_u_h __builtin_msa_cle_u_h\n+#define __msa_cle_u_w __builtin_msa_cle_u_w\n+#define __msa_cle_u_d __builtin_msa_cle_u_d\n+#define __msa_clei_u_b __builtin_msa_clei_u_b\n+#define __msa_clei_u_h __builtin_msa_clei_u_h\n+#define __msa_clei_u_w __builtin_msa_clei_u_w\n+#define __msa_clei_u_d __builtin_msa_clei_u_d\n+#define __msa_ld_b __builtin_msa_ld_b\n+#define __msa_ld_h __builtin_msa_ld_h\n+#define __msa_ld_w __builtin_msa_ld_w\n+#define __msa_ld_d __builtin_msa_ld_d\n+#define __msa_st_b __builtin_msa_st_b\n+#define __msa_st_h __builtin_msa_st_h\n+#define __msa_st_w __builtin_msa_st_w\n+#define __msa_st_d __builtin_msa_st_d\n+#define __msa_sat_s_b __builtin_msa_sat_s_b\n+#define __msa_sat_s_h __builtin_msa_sat_s_h\n+#define __msa_sat_s_w __builtin_msa_sat_s_w\n+#define __msa_sat_s_d __builtin_msa_sat_s_d\n+#define __msa_sat_u_b __builtin_msa_sat_u_b\n+#define __msa_sat_u_h __builtin_msa_sat_u_h\n+#define __msa_sat_u_w __builtin_msa_sat_u_w\n+#define __msa_sat_u_d __builtin_msa_sat_u_d\n+#define __msa_add_a_b __builtin_msa_add_a_b\n+#define __msa_add_a_h __builtin_msa_add_a_h\n+#define __msa_add_a_w __builtin_msa_add_a_w\n+#define __msa_add_a_d __builtin_msa_add_a_d\n+#define __msa_adds_a_b __builtin_msa_adds_a_b\n+#define __msa_adds_a_h __builtin_msa_adds_a_h\n+#define __msa_adds_a_w __builtin_msa_adds_a_w\n+#define __msa_adds_a_d __builtin_msa_adds_a_d\n+#define __msa_adds_s_b __builtin_msa_adds_s_b\n+#define __msa_adds_s_h __builtin_msa_adds_s_h\n+#define __msa_adds_s_w __builtin_msa_adds_s_w\n+#define __msa_adds_s_d __builtin_msa_adds_s_d\n+#define __msa_adds_u_b __builtin_msa_adds_u_b\n+#define __msa_adds_u_h __builtin_msa_adds_u_h\n+#define __msa_adds_u_w __builtin_msa_adds_u_w\n+#define __msa_adds_u_d __builtin_msa_adds_u_d\n+#define __msa_ave_s_b __builtin_msa_ave_s_b\n+#define __msa_ave_s_h __builtin_msa_ave_s_h\n+#define __msa_ave_s_w __builtin_msa_ave_s_w\n+#define __msa_ave_s_d __builtin_msa_ave_s_d\n+#define __msa_ave_u_b __builtin_msa_ave_u_b\n+#define __msa_ave_u_h __builtin_msa_ave_u_h\n+#define __msa_ave_u_w __builtin_msa_ave_u_w\n+#define __msa_ave_u_d __builtin_msa_ave_u_d\n+#define __msa_aver_s_b __builtin_msa_aver_s_b\n+#define __msa_aver_s_h __builtin_msa_aver_s_h\n+#define __msa_aver_s_w __builtin_msa_aver_s_w\n+#define __msa_aver_s_d __builtin_msa_aver_s_d\n+#define __msa_aver_u_b __builtin_msa_aver_u_b\n+#define __msa_aver_u_h __builtin_msa_aver_u_h\n+#define __msa_aver_u_w __builtin_msa_aver_u_w\n+#define __msa_aver_u_d __builtin_msa_aver_u_d\n+#define __msa_subs_s_b __builtin_msa_subs_s_b\n+#define __msa_subs_s_h __builtin_msa_subs_s_h\n+#define __msa_subs_s_w __builtin_msa_subs_s_w\n+#define __msa_subs_s_d __builtin_msa_subs_s_d\n+#define __msa_subs_u_b __builtin_msa_subs_u_b\n+#define __msa_subs_u_h __builtin_msa_subs_u_h\n+#define __msa_subs_u_w __builtin_msa_subs_u_w\n+#define __msa_subs_u_d __builtin_msa_subs_u_d\n+#define __msa_subsuu_s_b __builtin_msa_subsuu_s_b\n+#define __msa_subsuu_s_h __builtin_msa_subsuu_s_h\n+#define __msa_subsuu_s_w __builtin_msa_subsuu_s_w\n+#define __msa_subsuu_s_d __builtin_msa_subsuu_s_d\n+#define __msa_subsus_u_b __builtin_msa_subsus_u_b\n+#define __msa_subsus_u_h __builtin_msa_subsus_u_h\n+#define __msa_subsus_u_w __builtin_msa_subsus_u_w\n+#define __msa_subsus_u_d __builtin_msa_subsus_u_d\n+#define __msa_asub_s_b __builtin_msa_asub_s_b\n+#define __msa_asub_s_h __builtin_msa_asub_s_h\n+#define __msa_asub_s_w __builtin_msa_asub_s_w\n+#define __msa_asub_s_d __builtin_msa_asub_s_d\n+#define __msa_asub_u_b __builtin_msa_asub_u_b\n+#define __msa_asub_u_h __builtin_msa_asub_u_h\n+#define __msa_asub_u_w __builtin_msa_asub_u_w\n+#define __msa_asub_u_d __builtin_msa_asub_u_d\n+#define __msa_mulv_b __builtin_msa_mulv_b\n+#define __msa_mulv_h __builtin_msa_mulv_h\n+#define __msa_mulv_w __builtin_msa_mulv_w\n+#define __msa_mulv_d __builtin_msa_mulv_d\n+#define __msa_maddv_b __builtin_msa_maddv_b\n+#define __msa_maddv_h __builtin_msa_maddv_h\n+#define __msa_maddv_w __builtin_msa_maddv_w\n+#define __msa_maddv_d __builtin_msa_maddv_d\n+#define __msa_msubv_b __builtin_msa_msubv_b\n+#define __msa_msubv_h __builtin_msa_msubv_h\n+#define __msa_msubv_w __builtin_msa_msubv_w\n+#define __msa_msubv_d __builtin_msa_msubv_d\n+#define __msa_div_s_b __builtin_msa_div_s_b\n+#define __msa_div_s_h __builtin_msa_div_s_h\n+#define __msa_div_s_w __builtin_msa_div_s_w\n+#define __msa_div_s_d __builtin_msa_div_s_d\n+#define __msa_div_u_b __builtin_msa_div_u_b\n+#define __msa_div_u_h __builtin_msa_div_u_h\n+#define __msa_div_u_w __builtin_msa_div_u_w\n+#define __msa_div_u_d __builtin_msa_div_u_d\n+#define __msa_hadd_s_h __builtin_msa_hadd_s_h\n+#define __msa_hadd_s_w __builtin_msa_hadd_s_w\n+#define __msa_hadd_s_d __builtin_msa_hadd_s_d\n+#define __msa_hadd_u_h __builtin_msa_hadd_u_h\n+#define __msa_hadd_u_w __builtin_msa_hadd_u_w\n+#define __msa_hadd_u_d __builtin_msa_hadd_u_d\n+#define __msa_hsub_s_h __builtin_msa_hsub_s_h\n+#define __msa_hsub_s_w __builtin_msa_hsub_s_w\n+#define __msa_hsub_s_d __builtin_msa_hsub_s_d\n+#define __msa_hsub_u_h __builtin_msa_hsub_u_h\n+#define __msa_hsub_u_w __builtin_msa_hsub_u_w\n+#define __msa_hsub_u_d __builtin_msa_hsub_u_d\n+#define __msa_mod_s_b __builtin_msa_mod_s_b\n+#define __msa_mod_s_h __builtin_msa_mod_s_h\n+#define __msa_mod_s_w __builtin_msa_mod_s_w\n+#define __msa_mod_s_d __builtin_msa_mod_s_d\n+#define __msa_mod_u_b __builtin_msa_mod_u_b\n+#define __msa_mod_u_h __builtin_msa_mod_u_h\n+#define __msa_mod_u_w __builtin_msa_mod_u_w\n+#define __msa_mod_u_d __builtin_msa_mod_u_d\n+#define __msa_dotp_s_h __builtin_msa_dotp_s_h\n+#define __msa_dotp_s_w __builtin_msa_dotp_s_w\n+#define __msa_dotp_s_d __builtin_msa_dotp_s_d\n+#define __msa_dotp_u_h __builtin_msa_dotp_u_h\n+#define __msa_dotp_u_w __builtin_msa_dotp_u_w\n+#define __msa_dotp_u_d __builtin_msa_dotp_u_d\n+#define __msa_dpadd_s_h __builtin_msa_dpadd_s_h\n+#define __msa_dpadd_s_w __builtin_msa_dpadd_s_w\n+#define __msa_dpadd_s_d __builtin_msa_dpadd_s_d\n+#define __msa_dpadd_u_h __builtin_msa_dpadd_u_h\n+#define __msa_dpadd_u_w __builtin_msa_dpadd_u_w\n+#define __msa_dpadd_u_d __builtin_msa_dpadd_u_d\n+#define __msa_dpsub_s_h __builtin_msa_dpsub_s_h\n+#define __msa_dpsub_s_w __builtin_msa_dpsub_s_w\n+#define __msa_dpsub_s_d __builtin_msa_dpsub_s_d\n+#define __msa_dpsub_u_h __builtin_msa_dpsub_u_h\n+#define __msa_dpsub_u_w __builtin_msa_dpsub_u_w\n+#define __msa_dpsub_u_d __builtin_msa_dpsub_u_d\n+#define __msa_sld_b __builtin_msa_sld_b\n+#define __msa_sld_h __builtin_msa_sld_h\n+#define __msa_sld_w __builtin_msa_sld_w\n+#define __msa_sld_d __builtin_msa_sld_d\n+#define __msa_sldi_b __builtin_msa_sldi_b\n+#define __msa_sldi_h __builtin_msa_sldi_h\n+#define __msa_sldi_w __builtin_msa_sldi_w\n+#define __msa_sldi_d __builtin_msa_sldi_d\n+#define __msa_splat_b __builtin_msa_splat_b\n+#define __msa_splat_h __builtin_msa_splat_h\n+#define __msa_splat_w __builtin_msa_splat_w\n+#define __msa_splat_d __builtin_msa_splat_d\n+#define __msa_splati_b __builtin_msa_splati_b\n+#define __msa_splati_h __builtin_msa_splati_h\n+#define __msa_splati_w __builtin_msa_splati_w\n+#define __msa_splati_d __builtin_msa_splati_d\n+#define __msa_pckev_b __builtin_msa_pckev_b\n+#define __msa_pckev_h __builtin_msa_pckev_h\n+#define __msa_pckev_w __builtin_msa_pckev_w\n+#define __msa_pckev_d __builtin_msa_pckev_d\n+#define __msa_pckod_b __builtin_msa_pckod_b\n+#define __msa_pckod_h __builtin_msa_pckod_h\n+#define __msa_pckod_w __builtin_msa_pckod_w\n+#define __msa_pckod_d __builtin_msa_pckod_d\n+#define __msa_ilvl_b __builtin_msa_ilvl_b\n+#define __msa_ilvl_h __builtin_msa_ilvl_h\n+#define __msa_ilvl_w __builtin_msa_ilvl_w\n+#define __msa_ilvl_d __builtin_msa_ilvl_d\n+#define __msa_ilvr_b __builtin_msa_ilvr_b\n+#define __msa_ilvr_h __builtin_msa_ilvr_h\n+#define __msa_ilvr_w __builtin_msa_ilvr_w\n+#define __msa_ilvr_d __builtin_msa_ilvr_d\n+#define __msa_ilvev_b __builtin_msa_ilvev_b\n+#define __msa_ilvev_h __builtin_msa_ilvev_h\n+#define __msa_ilvev_w __builtin_msa_ilvev_w\n+#define __msa_ilvev_d __builtin_msa_ilvev_d\n+#define __msa_ilvod_b __builtin_msa_ilvod_b\n+#define __msa_ilvod_h __builtin_msa_ilvod_h\n+#define __msa_ilvod_w __builtin_msa_ilvod_w\n+#define __msa_ilvod_d __builtin_msa_ilvod_d\n+#define __msa_vshf_b __builtin_msa_vshf_b\n+#define __msa_vshf_h __builtin_msa_vshf_h\n+#define __msa_vshf_w __builtin_msa_vshf_w\n+#define __msa_vshf_d __builtin_msa_vshf_d\n+#define __msa_and_v __builtin_msa_and_v\n+#define __msa_andi_b __builtin_msa_andi_b\n+#define __msa_or_v __builtin_msa_or_v\n+#define __msa_ori_b __builtin_msa_ori_b\n+#define __msa_nor_v __builtin_msa_nor_v\n+#define __msa_nori_b __builtin_msa_nori_b\n+#define __msa_xor_v __builtin_msa_xor_v\n+#define __msa_xori_b __builtin_msa_xori_b\n+#define __msa_bmnz_v __builtin_msa_bmnz_v\n+#define __msa_bmnzi_b __builtin_msa_bmnzi_b\n+#define __msa_bmz_v __builtin_msa_bmz_v\n+#define __msa_bmzi_b __builtin_msa_bmzi_b\n+#define __msa_bsel_v __builtin_msa_bsel_v\n+#define __msa_bseli_b __builtin_msa_bseli_b\n+#define __msa_shf_b __builtin_msa_shf_b\n+#define __msa_shf_h __builtin_msa_shf_h\n+#define __msa_shf_w __builtin_msa_shf_w\n+#define __msa_test_bnz_v __builtin_msa_bnz_v\n+#define __msa_test_bz_v __builtin_msa_bz_v\n+#define __msa_fill_b __builtin_msa_fill_b\n+#define __msa_fill_h __builtin_msa_fill_h\n+#define __msa_fill_w __builtin_msa_fill_w\n+#define __msa_fill_d __builtin_msa_fill_d\n+#define __msa_pcnt_b __builtin_msa_pcnt_b\n+#define __msa_pcnt_h __builtin_msa_pcnt_h\n+#define __msa_pcnt_w __builtin_msa_pcnt_w\n+#define __msa_pcnt_d __builtin_msa_pcnt_d\n+#define __msa_nloc_b __builtin_msa_nloc_b\n+#define __msa_nloc_h __builtin_msa_nloc_h\n+#define __msa_nloc_w __builtin_msa_nloc_w\n+#define __msa_nloc_d __builtin_msa_nloc_d\n+#define __msa_nlzc_b __builtin_msa_nlzc_b\n+#define __msa_nlzc_h __builtin_msa_nlzc_h\n+#define __msa_nlzc_w __builtin_msa_nlzc_w\n+#define __msa_nlzc_d __builtin_msa_nlzc_d\n+#define __msa_copy_s_b __builtin_msa_copy_s_b\n+#define __msa_copy_s_h __builtin_msa_copy_s_h\n+#define __msa_copy_s_w __builtin_msa_copy_s_w\n+#define __msa_copy_s_d __builtin_msa_copy_s_d\n+#define __msa_copy_u_b __builtin_msa_copy_u_b\n+#define __msa_copy_u_h __builtin_msa_copy_u_h\n+#define __msa_copy_u_w __builtin_msa_copy_u_w\n+#define __msa_copy_u_d __builtin_msa_copy_u_d\n+#define __msa_insert_b __builtin_msa_insert_b\n+#define __msa_insert_h __builtin_msa_insert_h\n+#define __msa_insert_w __builtin_msa_insert_w\n+#define __msa_insert_d __builtin_msa_insert_d\n+#define __msa_insve_b __builtin_msa_insve_b\n+#define __msa_insve_h __builtin_msa_insve_h\n+#define __msa_insve_w __builtin_msa_insve_w\n+#define __msa_insve_d __builtin_msa_insve_d\n+#define __msa_test_bnz_b __builtin_msa_bnz_b\n+#define __msa_test_bnz_h __builtin_msa_bnz_h\n+#define __msa_test_bnz_w __builtin_msa_bnz_w\n+#define __msa_test_bnz_d __builtin_msa_bnz_d\n+#define __msa_test_bz_b __builtin_msa_bz_b\n+#define __msa_test_bz_h __builtin_msa_bz_h\n+#define __msa_test_bz_w __builtin_msa_bz_w\n+#define __msa_test_bz_d __builtin_msa_bz_d\n+#define __msa_ldi_b __builtin_msa_ldi_b\n+#define __msa_ldi_h __builtin_msa_ldi_h\n+#define __msa_ldi_w __builtin_msa_ldi_w\n+#define __msa_ldi_d __builtin_msa_ldi_d\n+#define __msa_fcaf_w __builtin_msa_fcaf_w\n+#define __msa_fcaf_d __builtin_msa_fcaf_d\n+#define __msa_fcor_w __builtin_msa_fcor_w\n+#define __msa_fcor_d __builtin_msa_fcor_d\n+#define __msa_fcun_w __builtin_msa_fcun_w\n+#define __msa_fcun_d __builtin_msa_fcun_d\n+#define __msa_fcune_w __builtin_msa_fcune_w\n+#define __msa_fcune_d __builtin_msa_fcune_d\n+#define __msa_fcueq_w __builtin_msa_fcueq_w\n+#define __msa_fcueq_d __builtin_msa_fcueq_d\n+#define __msa_fceq_w __builtin_msa_fceq_w\n+#define __msa_fceq_d __builtin_msa_fceq_d\n+#define __msa_fcne_w __builtin_msa_fcne_w\n+#define __msa_fcne_d __builtin_msa_fcne_d\n+#define __msa_fclt_w __builtin_msa_fclt_w\n+#define __msa_fclt_d __builtin_msa_fclt_d\n+#define __msa_fcult_w __builtin_msa_fcult_w\n+#define __msa_fcult_d __builtin_msa_fcult_d\n+#define __msa_fcle_w __builtin_msa_fcle_w\n+#define __msa_fcle_d __builtin_msa_fcle_d\n+#define __msa_fcule_w __builtin_msa_fcule_w\n+#define __msa_fcule_d __builtin_msa_fcule_d\n+#define __msa_fsaf_w __builtin_msa_fsaf_w\n+#define __msa_fsaf_d __builtin_msa_fsaf_d\n+#define __msa_fsor_w __builtin_msa_fsor_w\n+#define __msa_fsor_d __builtin_msa_fsor_d\n+#define __msa_fsun_w __builtin_msa_fsun_w\n+#define __msa_fsun_d __builtin_msa_fsun_d\n+#define __msa_fsune_w __builtin_msa_fsune_w\n+#define __msa_fsune_d __builtin_msa_fsune_d\n+#define __msa_fsueq_w __builtin_msa_fsueq_w\n+#define __msa_fsueq_d __builtin_msa_fsueq_d\n+#define __msa_fseq_w __builtin_msa_fseq_w\n+#define __msa_fseq_d __builtin_msa_fseq_d\n+#define __msa_fsne_w __builtin_msa_fsne_w\n+#define __msa_fsne_d __builtin_msa_fsne_d\n+#define __msa_fslt_w __builtin_msa_fslt_w\n+#define __msa_fslt_d __builtin_msa_fslt_d\n+#define __msa_fsult_w __builtin_msa_fsult_w\n+#define __msa_fsult_d __builtin_msa_fsult_d\n+#define __msa_fsle_w __builtin_msa_fsle_w\n+#define __msa_fsle_d __builtin_msa_fsle_d\n+#define __msa_fsule_w __builtin_msa_fsule_w\n+#define __msa_fsule_d __builtin_msa_fsule_d\n+#define __msa_fadd_w __builtin_msa_fadd_w\n+#define __msa_fadd_d __builtin_msa_fadd_d\n+#define __msa_fsub_w __builtin_msa_fsub_w\n+#define __msa_fsub_d __builtin_msa_fsub_d\n+#define __msa_fmul_w __builtin_msa_fmul_w\n+#define __msa_fmul_d __builtin_msa_fmul_d\n+#define __msa_fdiv_w __builtin_msa_fdiv_w\n+#define __msa_fdiv_d __builtin_msa_fdiv_d\n+#define __msa_fmadd_w __builtin_msa_fmadd_w\n+#define __msa_fmadd_d __builtin_msa_fmadd_d\n+#define __msa_fmsub_w __builtin_msa_fmsub_w\n+#define __msa_fmsub_d __builtin_msa_fmsub_d\n+#define __msa_fexp2_w __builtin_msa_fexp2_w\n+#define __msa_fexp2_d __builtin_msa_fexp2_d\n+#define __msa_fexdo_h __builtin_msa_fexdo_h\n+#define __msa_fexdo_w __builtin_msa_fexdo_w\n+#define __msa_ftq_h __builtin_msa_ftq_h\n+#define __msa_ftq_w __builtin_msa_ftq_w\n+#define __msa_fmin_w __builtin_msa_fmin_w\n+#define __msa_fmin_d __builtin_msa_fmin_d\n+#define __msa_fmin_a_w __builtin_msa_fmin_a_w\n+#define __msa_fmin_a_d __builtin_msa_fmin_a_d\n+#define __msa_fmax_w __builtin_msa_fmax_w\n+#define __msa_fmax_d __builtin_msa_fmax_d\n+#define __msa_fmax_a_w __builtin_msa_fmax_a_w\n+#define __msa_fmax_a_d __builtin_msa_fmax_a_d\n+#define __msa_mul_q_h __builtin_msa_mul_q_h\n+#define __msa_mul_q_w __builtin_msa_mul_q_w\n+#define __msa_mulr_q_h __builtin_msa_mulr_q_h\n+#define __msa_mulr_q_w __builtin_msa_mulr_q_w\n+#define __msa_madd_q_h __builtin_msa_madd_q_h\n+#define __msa_madd_q_w __builtin_msa_madd_q_w\n+#define __msa_maddr_q_h __builtin_msa_maddr_q_h\n+#define __msa_maddr_q_w __builtin_msa_maddr_q_w\n+#define __msa_msub_q_h __builtin_msa_msub_q_h\n+#define __msa_msub_q_w __builtin_msa_msub_q_w\n+#define __msa_msubr_q_h __builtin_msa_msubr_q_h\n+#define __msa_msubr_q_w __builtin_msa_msubr_q_w\n+#define __msa_fclass_w __builtin_msa_fclass_w\n+#define __msa_fclass_d __builtin_msa_fclass_d\n+#define __msa_fsqrt_w __builtin_msa_fsqrt_w\n+#define __msa_fsqrt_d __builtin_msa_fsqrt_d\n+#define __msa_frcp_w __builtin_msa_frcp_w\n+#define __msa_frcp_d __builtin_msa_frcp_d\n+#define __msa_frint_w __builtin_msa_frint_w\n+#define __msa_frint_d __builtin_msa_frint_d\n+#define __msa_frsqrt_w __builtin_msa_frsqrt_w\n+#define __msa_frsqrt_d __builtin_msa_frsqrt_d\n+#define __msa_flog2_w __builtin_msa_flog2_w\n+#define __msa_flog2_d __builtin_msa_flog2_d\n+#define __msa_fexupl_w __builtin_msa_fexupl_w\n+#define __msa_fexupl_d __builtin_msa_fexupl_d\n+#define __msa_fexupr_w __builtin_msa_fexupr_w\n+#define __msa_fexupr_d __builtin_msa_fexupr_d\n+#define __msa_ffql_w __builtin_msa_ffql_w\n+#define __msa_ffql_d __builtin_msa_ffql_d\n+#define __msa_ffqr_w __builtin_msa_ffqr_w\n+#define __msa_ffqr_d __builtin_msa_ffqr_d\n+#define __msa_ftint_s_w __builtin_msa_ftint_s_w\n+#define __msa_ftint_s_d __builtin_msa_ftint_s_d\n+#define __msa_ftint_u_w __builtin_msa_ftint_u_w\n+#define __msa_ftint_u_d __builtin_msa_ftint_u_d\n+#define __msa_ftrunc_s_w __builtin_msa_ftrunc_s_w\n+#define __msa_ftrunc_s_d __builtin_msa_ftrunc_s_d\n+#define __msa_ftrunc_u_w __builtin_msa_ftrunc_u_w\n+#define __msa_ftrunc_u_d __builtin_msa_ftrunc_u_d\n+#define __msa_ffint_s_w __builtin_msa_ffint_s_w\n+#define __msa_ffint_s_d __builtin_msa_ffint_s_d\n+#define __msa_ffint_u_w __builtin_msa_ffint_u_w\n+#define __msa_ffint_u_d __builtin_msa_ffint_u_d\n+#define __msa_cfcmsa __builtin_msa_cfcmsa\n+#define __msa_move_v __builtin_msa_move_v\n+#endif /* defined(__mips_msa) */\n+#endif /* _MSA_H */"}, {"sha": "c4ae24bac36aef49ceb71ed64b89971e059669f2", "filename": "gcc/config/mips/mti-elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmti-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmti-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmti-elf.h?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -39,8 +39,8 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t\t\t\t\t\t\\\n   /* If no FP ABI option is specified, infer one from the\t\t\\\n      ABI/ISA level.  */\t\t\t\t\t\t\t\\\n-  \"%{!msoft-float: %{!msingle-float: %{!mfp*: %{mabi=32: %{\"\t\t\\\n-  MIPS_FPXX_OPTION_SPEC \": -mfpxx}}}}}\",\t\t\t\t\\\n+  \"%{!msoft-float: %{!msingle-float: %{!mfp*: %{!mmsa: %{mabi=32: %{\"\t\\\n+  MIPS_FPXX_OPTION_SPEC \": -mfpxx}}}}}}\",\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Make sure that an endian option is always present.  This makes\t\\\n      things like LINK_SPEC easier to write.  */\t\t\t\t\\"}, {"sha": "76b0f34059cf8b4e8b846c68ad62ab14d5b92369", "filename": "gcc/config/mips/mti-linux.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmti-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fmti-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmti-linux.h?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -61,9 +61,9 @@ along with GCC; see the file COPYING3.  If not see\n   \"%{!mabi=*: %{\" MIPS_32BIT_OPTION_SPEC \": -mabi=32;: -mabi=n32}}\",\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* If no FP ABI option is specified, infer one from the\t\t\\\n-     ABI/ISA level.  */\t\t\t\t\t\t\t\\\n-  \"%{!msoft-float: %{!msingle-float: %{!mfp*: %{mabi=32: %{\"\t\t\\\n-  MIPS_FPXX_OPTION_SPEC \": -mfpxx}}}}}\",\t\t\t\t\\\n+     ABI/ISA level unless there is a conflicting option.  */\t\t\\\n+  \"%{!msoft-float: %{!msingle-float: %{!mfp*: %{!mmsa: %{mabi=32: %{\"\t\\\n+  MIPS_FPXX_OPTION_SPEC \": -mfpxx}}}}}}\",\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Base SPECs.  */\t\t\t\t\t\t\t\\\n   BASE_DRIVER_SELF_SPECS\t\t\t\t\t\t\\"}, {"sha": "e6b6d2f60da7a7e1f22e3aa595b5d86a8609accd", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 128, "deletions": 1, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -35,12 +35,36 @@\n \n (define_predicate \"const_immlsa_operand\"\n   (and (match_code \"const_int\")\n-         (match_test \"IN_RANGE (INTVAL (op), 1, 4)\")))\n+       (match_test \"IN_RANGE (INTVAL (op), 1, 4)\")))\n+\n+(define_predicate \"const_msa_branch_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -1024, 1023)\")))\n+\n+(define_predicate \"const_uimm3_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 7)\")))\n+\n+(define_predicate \"const_uimm4_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 15)\")))\n+\n+(define_predicate \"const_uimm5_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 31)\")))\n \n (define_predicate \"const_uimm6_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"UIMM6_OPERAND (INTVAL (op))\")))\n \n+(define_predicate \"const_uimm8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 255)\")))\n+\n+(define_predicate \"const_imm5_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -16, 15)\")))\n+\n (define_predicate \"const_imm10_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"IMM10_OPERAND (INTVAL (op))\")))\n@@ -49,6 +73,22 @@\n   (ior (match_operand 0 \"const_imm10_operand\")\n        (match_operand 0 \"register_operand\")))\n \n+(define_predicate \"aq10b_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"mips_signed_immediate_p (INTVAL (op), 10, 0)\")))\n+\n+(define_predicate \"aq10h_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"mips_signed_immediate_p (INTVAL (op), 10, 1)\")))\n+\n+(define_predicate \"aq10w_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"mips_signed_immediate_p (INTVAL (op), 10, 2)\")))\n+\n+(define_predicate \"aq10d_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"mips_signed_immediate_p (INTVAL (op), 10, 3)\")))\n+\n (define_predicate \"sle_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"SMALL_OPERAND (INTVAL (op) + 1)\")))\n@@ -61,6 +101,14 @@\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n \n+(define_predicate \"const_m1_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"reg_or_m1_operand\"\n+  (ior (match_operand 0 \"const_m1_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n (define_predicate \"reg_or_0_operand\"\n   (ior (and (match_operand 0 \"const_0_operand\")\n \t    (not (match_test \"TARGET_MIPS16\")))\n@@ -74,6 +122,23 @@\n   (ior (match_operand 0 \"const_1_operand\")\n        (match_operand 0 \"register_operand\")))\n \n+;; These are used in vec_merge, hence accept bitmask as const_int.\n+(define_predicate \"const_exp_2_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 (INTVAL (op)), 0, 1)\")))\n+\n+(define_predicate \"const_exp_4_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 (INTVAL (op)), 0, 3)\")))\n+\n+(define_predicate \"const_exp_8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 (INTVAL (op)), 0, 7)\")))\n+\n+(define_predicate \"const_exp_16_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 (INTVAL (op)), 0, 15)\")))\n+\n ;; This is used for indexing into vectors, and hence only accepts const_int.\n (define_predicate \"const_0_or_1_operand\"\n   (and (match_code \"const_int\")\n@@ -507,3 +572,65 @@\n (define_predicate \"non_volatile_mem_operand\"\n   (and (match_operand 0 \"memory_operand\")\n        (not (match_test \"MEM_VOLATILE_P (op)\"))))\n+\n+(define_predicate \"const_vector_same_val_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return mips_const_vector_same_val_p (op, mode);\n+})\n+\n+(define_predicate \"const_vector_same_simm5_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return mips_const_vector_same_int_p (op, mode, -16, 15);\n+})\n+\n+(define_predicate \"const_vector_same_uimm5_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return mips_const_vector_same_int_p (op, mode, 0, 31);\n+})\n+\n+(define_predicate \"const_vector_same_ximm5_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return mips_const_vector_same_int_p (op, mode, -31, 31);\n+})\n+\n+(define_predicate \"const_vector_same_uimm6_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return mips_const_vector_same_int_p (op, mode, 0, 63);\n+})\n+\n+(define_predicate \"const_vector_same_uimm8_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return mips_const_vector_same_int_p (op, mode, 0, 255);\n+})\n+\n+(define_predicate \"par_const_vector_shf_set_operand\"\n+  (match_code \"parallel\")\n+{\n+  return mips_const_vector_shuffle_set_p (op, mode);\n+})\n+\n+(define_predicate \"reg_or_vector_same_val_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_vector_same_val_operand\")))\n+\n+(define_predicate \"reg_or_vector_same_simm5_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_vector_same_simm5_operand\")))\n+\n+(define_predicate \"reg_or_vector_same_uimm5_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_vector_same_uimm5_operand\")))\n+\n+(define_predicate \"reg_or_vector_same_ximm5_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_vector_same_ximm5_operand\")))\n+\n+(define_predicate \"reg_or_vector_same_uimm6_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_vector_same_uimm6_operand\")))"}, {"sha": "e4d6c1c88be1e2d7ed471a5b5efba0103f17f8cf", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 789, "deletions": 0, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -11451,6 +11451,7 @@ instructions, but allow the compiler to schedule those calls.\n * MIPS DSP Built-in Functions::\n * MIPS Paired-Single Support::\n * MIPS Loongson Built-in Functions::\n+* MIPS SIMD Architecture (MSA) Support::\n * Other MIPS Built-in Functions::\n * MSP430 Built-in Functions::\n * NDS32 Built-in Functions::\n@@ -13561,6 +13562,794 @@ else\n @end smallexample\n @end table\n \n+@node MIPS SIMD Architecture (MSA) Support\n+@subsection MIPS SIMD Architecture (MSA) Support\n+\n+@menu\n+* MIPS SIMD Architecture Built-in Functions::\n+@end menu\n+\n+GCC provides intrinsics to access the SIMD instructions provided by the\n+MSA MIPS SIMD Architecture.  The interface is made available by including\n+@code{<msa.h>} and using @option{-mmsa -mhard-float -mfp64 -mnan=2008}.\n+For each @code{__builtin_msa_*}, there is a shortened name of the intrinsic,\n+@code{__msa_*}.\n+\n+MSA implements 128-bit wide vector registers, operating on 8-, 16-, 32- and\n+64-bit integer, 16- and 32-bit fixed-point, or 32- and 64-bit floating point\n+data elements.  The following vectors typedefs are included in @code{msa.h}:\n+@itemize\n+@item @code{v16i8}, a vector of sixteen signed 8-bit integers;\n+@item @code{v16u8}, a vector of sixteen unsigned 8-bit integers;\n+@item @code{v8i16}, a vector of eight signed 16-bit integers;\n+@item @code{v8u16}, a vector of eight unsigned 16-bit integers;\n+@item @code{v4i32}, a vector of four signed 32-bit integers;\n+@item @code{v4u32}, a vector of four unsigned 32-bit integers;\n+@item @code{v2i64}, a vector of two signed 64-bit integers;\n+@item @code{v2u64}, a vector of two unsigned 64-bit integers;\n+@item @code{v4f32}, a vector of four 32-bit floats;\n+@item @code{v2f64}, a vector of two 64-bit doubles.\n+@end itemize\n+\n+Intructions and corresponding built-ins may have additional restrictions and/or\n+input/output values manipulated:\n+@itemize\n+@item @code{imm0_1}, an integer literal in range 0 to 1;\n+@item @code{imm0_3}, an integer literal in range 0 to 3;\n+@item @code{imm0_7}, an integer literal in range 0 to 7;\n+@item @code{imm0_15}, an integer literal in range 0 to 15;\n+@item @code{imm0_31}, an integer literal in range 0 to 31;\n+@item @code{imm0_63}, an integer literal in range 0 to 63;\n+@item @code{imm0_255}, an integer literal in range 0 to 255;\n+@item @code{imm_n16_15}, an integer literal in range -16 to 15;\n+@item @code{imm_n512_511}, an integer literal in range -512 to 511;\n+@item @code{imm_n1024_1022}, an integer literal in range -512 to 511 left\n+shifted by 1 bit, i.e., -1024, -1022, @dots{}, 1020, 1022;\n+@item @code{imm_n2048_2044}, an integer literal in range -512 to 511 left\n+shifted by 2 bits, i.e., -2048, -2044, @dots{}, 2040, 2044;\n+@item @code{imm_n4096_4088}, an integer literal in range -512 to 511 left\n+shifted by 3 bits, i.e., -4096, -4088, @dots{}, 4080, 4088;\n+@item @code{imm1_4}, an integer literal in range 1 to 4;\n+@item @code{i32, i64, u32, u64, f32, f64}, defined as follows:\n+@end itemize\n+\n+@smallexample\n+@{\n+typedef int i32;\n+#if __LONG_MAX__ == __LONG_LONG_MAX__\n+typedef long i64;\n+#else\n+typedef long long i64;\n+#endif\n+\n+typedef unsigned int u32;\n+#if __LONG_MAX__ == __LONG_LONG_MAX__\n+typedef unsigned long u64;\n+#else\n+typedef unsigned long long u64;\n+#endif\n+\n+typedef double f64;\n+typedef float f32;\n+@}\n+@end smallexample\n+\n+@node MIPS SIMD Architecture Built-in Functions\n+@subsubsection MIPS SIMD Architecture Built-in Functions\n+\n+The intrinsics provided are listed below; each is named after the\n+machine instruction.\n+\n+@smallexample\n+v16i8 __builtin_msa_add_a_b (v16i8, v16i8);\n+v8i16 __builtin_msa_add_a_h (v8i16, v8i16);\n+v4i32 __builtin_msa_add_a_w (v4i32, v4i32);\n+v2i64 __builtin_msa_add_a_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_adds_a_b (v16i8, v16i8);\n+v8i16 __builtin_msa_adds_a_h (v8i16, v8i16);\n+v4i32 __builtin_msa_adds_a_w (v4i32, v4i32);\n+v2i64 __builtin_msa_adds_a_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_adds_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_adds_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_adds_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_adds_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_adds_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_adds_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_adds_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_adds_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_addv_b (v16i8, v16i8);\n+v8i16 __builtin_msa_addv_h (v8i16, v8i16);\n+v4i32 __builtin_msa_addv_w (v4i32, v4i32);\n+v2i64 __builtin_msa_addv_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_addvi_b (v16i8, imm0_31);\n+v8i16 __builtin_msa_addvi_h (v8i16, imm0_31);\n+v4i32 __builtin_msa_addvi_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_addvi_d (v2i64, imm0_31);\n+\n+v16u8 __builtin_msa_and_v (v16u8, v16u8);\n+\n+v16u8 __builtin_msa_andi_b (v16u8, imm0_255);\n+\n+v16i8 __builtin_msa_asub_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_asub_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_asub_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_asub_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_asub_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_asub_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_asub_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_asub_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_ave_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_ave_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_ave_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_ave_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_ave_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_ave_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_ave_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_ave_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_aver_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_aver_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_aver_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_aver_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_aver_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_aver_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_aver_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_aver_u_d (v2u64, v2u64);\n+\n+v16u8 __builtin_msa_bclr_b (v16u8, v16u8);\n+v8u16 __builtin_msa_bclr_h (v8u16, v8u16);\n+v4u32 __builtin_msa_bclr_w (v4u32, v4u32);\n+v2u64 __builtin_msa_bclr_d (v2u64, v2u64);\n+\n+v16u8 __builtin_msa_bclri_b (v16u8, imm0_7);\n+v8u16 __builtin_msa_bclri_h (v8u16, imm0_15);\n+v4u32 __builtin_msa_bclri_w (v4u32, imm0_31);\n+v2u64 __builtin_msa_bclri_d (v2u64, imm0_63);\n+\n+v16u8 __builtin_msa_binsl_b (v16u8, v16u8, v16u8);\n+v8u16 __builtin_msa_binsl_h (v8u16, v8u16, v8u16);\n+v4u32 __builtin_msa_binsl_w (v4u32, v4u32, v4u32);\n+v2u64 __builtin_msa_binsl_d (v2u64, v2u64, v2u64);\n+\n+v16u8 __builtin_msa_binsli_b (v16u8, v16u8, imm0_7);\n+v8u16 __builtin_msa_binsli_h (v8u16, v8u16, imm0_15);\n+v4u32 __builtin_msa_binsli_w (v4u32, v4u32, imm0_31);\n+v2u64 __builtin_msa_binsli_d (v2u64, v2u64, imm0_63);\n+\n+v16u8 __builtin_msa_binsr_b (v16u8, v16u8, v16u8);\n+v8u16 __builtin_msa_binsr_h (v8u16, v8u16, v8u16);\n+v4u32 __builtin_msa_binsr_w (v4u32, v4u32, v4u32);\n+v2u64 __builtin_msa_binsr_d (v2u64, v2u64, v2u64);\n+\n+v16u8 __builtin_msa_binsri_b (v16u8, v16u8, imm0_7);\n+v8u16 __builtin_msa_binsri_h (v8u16, v8u16, imm0_15);\n+v4u32 __builtin_msa_binsri_w (v4u32, v4u32, imm0_31);\n+v2u64 __builtin_msa_binsri_d (v2u64, v2u64, imm0_63);\n+\n+v16u8 __builtin_msa_bmnz_v (v16u8, v16u8, v16u8);\n+\n+v16u8 __builtin_msa_bmnzi_b (v16u8, v16u8, imm0_255);\n+\n+v16u8 __builtin_msa_bmz_v (v16u8, v16u8, v16u8);\n+\n+v16u8 __builtin_msa_bmzi_b (v16u8, v16u8, imm0_255);\n+\n+v16u8 __builtin_msa_bneg_b (v16u8, v16u8);\n+v8u16 __builtin_msa_bneg_h (v8u16, v8u16);\n+v4u32 __builtin_msa_bneg_w (v4u32, v4u32);\n+v2u64 __builtin_msa_bneg_d (v2u64, v2u64);\n+\n+v16u8 __builtin_msa_bnegi_b (v16u8, imm0_7);\n+v8u16 __builtin_msa_bnegi_h (v8u16, imm0_15);\n+v4u32 __builtin_msa_bnegi_w (v4u32, imm0_31);\n+v2u64 __builtin_msa_bnegi_d (v2u64, imm0_63);\n+\n+i32 __builtin_msa_bnz_b (v16u8);\n+i32 __builtin_msa_bnz_h (v8u16);\n+i32 __builtin_msa_bnz_w (v4u32);\n+i32 __builtin_msa_bnz_d (v2u64);\n+\n+i32 __builtin_msa_bnz_v (v16u8);\n+\n+v16u8 __builtin_msa_bsel_v (v16u8, v16u8, v16u8);\n+\n+v16u8 __builtin_msa_bseli_b (v16u8, v16u8, imm0_255);\n+\n+v16u8 __builtin_msa_bset_b (v16u8, v16u8);\n+v8u16 __builtin_msa_bset_h (v8u16, v8u16);\n+v4u32 __builtin_msa_bset_w (v4u32, v4u32);\n+v2u64 __builtin_msa_bset_d (v2u64, v2u64);\n+\n+v16u8 __builtin_msa_bseti_b (v16u8, imm0_7);\n+v8u16 __builtin_msa_bseti_h (v8u16, imm0_15);\n+v4u32 __builtin_msa_bseti_w (v4u32, imm0_31);\n+v2u64 __builtin_msa_bseti_d (v2u64, imm0_63);\n+\n+i32 __builtin_msa_bz_b (v16u8);\n+i32 __builtin_msa_bz_h (v8u16);\n+i32 __builtin_msa_bz_w (v4u32);\n+i32 __builtin_msa_bz_d (v2u64);\n+\n+i32 __builtin_msa_bz_v (v16u8);\n+\n+v16i8 __builtin_msa_ceq_b (v16i8, v16i8);\n+v8i16 __builtin_msa_ceq_h (v8i16, v8i16);\n+v4i32 __builtin_msa_ceq_w (v4i32, v4i32);\n+v2i64 __builtin_msa_ceq_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_ceqi_b (v16i8, imm_n16_15);\n+v8i16 __builtin_msa_ceqi_h (v8i16, imm_n16_15);\n+v4i32 __builtin_msa_ceqi_w (v4i32, imm_n16_15);\n+v2i64 __builtin_msa_ceqi_d (v2i64, imm_n16_15);\n+\n+i32 __builtin_msa_cfcmsa (imm0_31);\n+\n+v16i8 __builtin_msa_cle_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_cle_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_cle_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_cle_s_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_cle_u_b (v16u8, v16u8);\n+v8i16 __builtin_msa_cle_u_h (v8u16, v8u16);\n+v4i32 __builtin_msa_cle_u_w (v4u32, v4u32);\n+v2i64 __builtin_msa_cle_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_clei_s_b (v16i8, imm_n16_15);\n+v8i16 __builtin_msa_clei_s_h (v8i16, imm_n16_15);\n+v4i32 __builtin_msa_clei_s_w (v4i32, imm_n16_15);\n+v2i64 __builtin_msa_clei_s_d (v2i64, imm_n16_15);\n+\n+v16i8 __builtin_msa_clei_u_b (v16u8, imm0_31);\n+v8i16 __builtin_msa_clei_u_h (v8u16, imm0_31);\n+v4i32 __builtin_msa_clei_u_w (v4u32, imm0_31);\n+v2i64 __builtin_msa_clei_u_d (v2u64, imm0_31);\n+\n+v16i8 __builtin_msa_clt_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_clt_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_clt_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_clt_s_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_clt_u_b (v16u8, v16u8);\n+v8i16 __builtin_msa_clt_u_h (v8u16, v8u16);\n+v4i32 __builtin_msa_clt_u_w (v4u32, v4u32);\n+v2i64 __builtin_msa_clt_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_clti_s_b (v16i8, imm_n16_15);\n+v8i16 __builtin_msa_clti_s_h (v8i16, imm_n16_15);\n+v4i32 __builtin_msa_clti_s_w (v4i32, imm_n16_15);\n+v2i64 __builtin_msa_clti_s_d (v2i64, imm_n16_15);\n+\n+v16i8 __builtin_msa_clti_u_b (v16u8, imm0_31);\n+v8i16 __builtin_msa_clti_u_h (v8u16, imm0_31);\n+v4i32 __builtin_msa_clti_u_w (v4u32, imm0_31);\n+v2i64 __builtin_msa_clti_u_d (v2u64, imm0_31);\n+\n+i32 __builtin_msa_copy_s_b (v16i8, imm0_15);\n+i32 __builtin_msa_copy_s_h (v8i16, imm0_7);\n+i32 __builtin_msa_copy_s_w (v4i32, imm0_3);\n+i64 __builtin_msa_copy_s_d (v2i64, imm0_1);\n+\n+u32 __builtin_msa_copy_u_b (v16i8, imm0_15);\n+u32 __builtin_msa_copy_u_h (v8i16, imm0_7);\n+u32 __builtin_msa_copy_u_w (v4i32, imm0_3);\n+u64 __builtin_msa_copy_u_d (v2i64, imm0_1);\n+\n+void __builtin_msa_ctcmsa (imm0_31, i32);\n+\n+v16i8 __builtin_msa_div_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_div_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_div_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_div_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_div_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_div_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_div_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_div_u_d (v2u64, v2u64);\n+\n+v8i16 __builtin_msa_dotp_s_h (v16i8, v16i8);\n+v4i32 __builtin_msa_dotp_s_w (v8i16, v8i16);\n+v2i64 __builtin_msa_dotp_s_d (v4i32, v4i32);\n+\n+v8u16 __builtin_msa_dotp_u_h (v16u8, v16u8);\n+v4u32 __builtin_msa_dotp_u_w (v8u16, v8u16);\n+v2u64 __builtin_msa_dotp_u_d (v4u32, v4u32);\n+\n+v8i16 __builtin_msa_dpadd_s_h (v8i16, v16i8, v16i8);\n+v4i32 __builtin_msa_dpadd_s_w (v4i32, v8i16, v8i16);\n+v2i64 __builtin_msa_dpadd_s_d (v2i64, v4i32, v4i32);\n+\n+v8u16 __builtin_msa_dpadd_u_h (v8u16, v16u8, v16u8);\n+v4u32 __builtin_msa_dpadd_u_w (v4u32, v8u16, v8u16);\n+v2u64 __builtin_msa_dpadd_u_d (v2u64, v4u32, v4u32);\n+\n+v8i16 __builtin_msa_dpsub_s_h (v8i16, v16i8, v16i8);\n+v4i32 __builtin_msa_dpsub_s_w (v4i32, v8i16, v8i16);\n+v2i64 __builtin_msa_dpsub_s_d (v2i64, v4i32, v4i32);\n+\n+v8i16 __builtin_msa_dpsub_u_h (v8i16, v16u8, v16u8);\n+v4i32 __builtin_msa_dpsub_u_w (v4i32, v8u16, v8u16);\n+v2i64 __builtin_msa_dpsub_u_d (v2i64, v4u32, v4u32);\n+\n+v4f32 __builtin_msa_fadd_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fadd_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcaf_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcaf_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fceq_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fceq_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fclass_w (v4f32);\n+v2i64 __builtin_msa_fclass_d (v2f64);\n+\n+v4i32 __builtin_msa_fcle_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcle_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fclt_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fclt_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcne_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcne_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcor_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcor_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcueq_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcueq_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcule_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcule_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcult_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcult_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcun_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcun_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fcune_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fcune_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fdiv_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fdiv_d (v2f64, v2f64);\n+\n+v8i16 __builtin_msa_fexdo_h (v4f32, v4f32);\n+v4f32 __builtin_msa_fexdo_w (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fexp2_w (v4f32, v4i32);\n+v2f64 __builtin_msa_fexp2_d (v2f64, v2i64);\n+\n+v4f32 __builtin_msa_fexupl_w (v8i16);\n+v2f64 __builtin_msa_fexupl_d (v4f32);\n+\n+v4f32 __builtin_msa_fexupr_w (v8i16);\n+v2f64 __builtin_msa_fexupr_d (v4f32);\n+\n+v4f32 __builtin_msa_ffint_s_w (v4i32);\n+v2f64 __builtin_msa_ffint_s_d (v2i64);\n+\n+v4f32 __builtin_msa_ffint_u_w (v4u32);\n+v2f64 __builtin_msa_ffint_u_d (v2u64);\n+\n+v4f32 __builtin_msa_ffql_w (v8i16);\n+v2f64 __builtin_msa_ffql_d (v4i32);\n+\n+v4f32 __builtin_msa_ffqr_w (v8i16);\n+v2f64 __builtin_msa_ffqr_d (v4i32);\n+\n+v16i8 __builtin_msa_fill_b (i32);\n+v8i16 __builtin_msa_fill_h (i32);\n+v4i32 __builtin_msa_fill_w (i32);\n+v2i64 __builtin_msa_fill_d (i64);\n+\n+v4f32 __builtin_msa_flog2_w (v4f32);\n+v2f64 __builtin_msa_flog2_d (v2f64);\n+\n+v4f32 __builtin_msa_fmadd_w (v4f32, v4f32, v4f32);\n+v2f64 __builtin_msa_fmadd_d (v2f64, v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fmax_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fmax_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fmax_a_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fmax_a_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fmin_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fmin_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fmin_a_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fmin_a_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fmsub_w (v4f32, v4f32, v4f32);\n+v2f64 __builtin_msa_fmsub_d (v2f64, v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fmul_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fmul_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_frint_w (v4f32);\n+v2f64 __builtin_msa_frint_d (v2f64);\n+\n+v4f32 __builtin_msa_frcp_w (v4f32);\n+v2f64 __builtin_msa_frcp_d (v2f64);\n+\n+v4f32 __builtin_msa_frsqrt_w (v4f32);\n+v2f64 __builtin_msa_frsqrt_d (v2f64);\n+\n+v4i32 __builtin_msa_fsaf_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsaf_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fseq_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fseq_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsle_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsle_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fslt_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fslt_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsne_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsne_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsor_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsor_d (v2f64, v2f64);\n+\n+v4f32 __builtin_msa_fsqrt_w (v4f32);\n+v2f64 __builtin_msa_fsqrt_d (v2f64);\n+\n+v4f32 __builtin_msa_fsub_w (v4f32, v4f32);\n+v2f64 __builtin_msa_fsub_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsueq_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsueq_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsule_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsule_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsult_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsult_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsun_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsun_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_fsune_w (v4f32, v4f32);\n+v2i64 __builtin_msa_fsune_d (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_ftint_s_w (v4f32);\n+v2i64 __builtin_msa_ftint_s_d (v2f64);\n+\n+v4u32 __builtin_msa_ftint_u_w (v4f32);\n+v2u64 __builtin_msa_ftint_u_d (v2f64);\n+\n+v8i16 __builtin_msa_ftq_h (v4f32, v4f32);\n+v4i32 __builtin_msa_ftq_w (v2f64, v2f64);\n+\n+v4i32 __builtin_msa_ftrunc_s_w (v4f32);\n+v2i64 __builtin_msa_ftrunc_s_d (v2f64);\n+\n+v4u32 __builtin_msa_ftrunc_u_w (v4f32);\n+v2u64 __builtin_msa_ftrunc_u_d (v2f64);\n+\n+v8i16 __builtin_msa_hadd_s_h (v16i8, v16i8);\n+v4i32 __builtin_msa_hadd_s_w (v8i16, v8i16);\n+v2i64 __builtin_msa_hadd_s_d (v4i32, v4i32);\n+\n+v8u16 __builtin_msa_hadd_u_h (v16u8, v16u8);\n+v4u32 __builtin_msa_hadd_u_w (v8u16, v8u16);\n+v2u64 __builtin_msa_hadd_u_d (v4u32, v4u32);\n+\n+v8i16 __builtin_msa_hsub_s_h (v16i8, v16i8);\n+v4i32 __builtin_msa_hsub_s_w (v8i16, v8i16);\n+v2i64 __builtin_msa_hsub_s_d (v4i32, v4i32);\n+\n+v8i16 __builtin_msa_hsub_u_h (v16u8, v16u8);\n+v4i32 __builtin_msa_hsub_u_w (v8u16, v8u16);\n+v2i64 __builtin_msa_hsub_u_d (v4u32, v4u32);\n+\n+v16i8 __builtin_msa_ilvev_b (v16i8, v16i8);\n+v8i16 __builtin_msa_ilvev_h (v8i16, v8i16);\n+v4i32 __builtin_msa_ilvev_w (v4i32, v4i32);\n+v2i64 __builtin_msa_ilvev_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_ilvl_b (v16i8, v16i8);\n+v8i16 __builtin_msa_ilvl_h (v8i16, v8i16);\n+v4i32 __builtin_msa_ilvl_w (v4i32, v4i32);\n+v2i64 __builtin_msa_ilvl_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_ilvod_b (v16i8, v16i8);\n+v8i16 __builtin_msa_ilvod_h (v8i16, v8i16);\n+v4i32 __builtin_msa_ilvod_w (v4i32, v4i32);\n+v2i64 __builtin_msa_ilvod_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_ilvr_b (v16i8, v16i8);\n+v8i16 __builtin_msa_ilvr_h (v8i16, v8i16);\n+v4i32 __builtin_msa_ilvr_w (v4i32, v4i32);\n+v2i64 __builtin_msa_ilvr_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_insert_b (v16i8, imm0_15, i32);\n+v8i16 __builtin_msa_insert_h (v8i16, imm0_7, i32);\n+v4i32 __builtin_msa_insert_w (v4i32, imm0_3, i32);\n+v2i64 __builtin_msa_insert_d (v2i64, imm0_1, i64);\n+\n+v16i8 __builtin_msa_insve_b (v16i8, imm0_15, v16i8);\n+v8i16 __builtin_msa_insve_h (v8i16, imm0_7, v8i16);\n+v4i32 __builtin_msa_insve_w (v4i32, imm0_3, v4i32);\n+v2i64 __builtin_msa_insve_d (v2i64, imm0_1, v2i64);\n+\n+v16i8 __builtin_msa_ld_b (void *, imm_n512_511);\n+v8i16 __builtin_msa_ld_h (void *, imm_n1024_1022);\n+v4i32 __builtin_msa_ld_w (void *, imm_n2048_2044);\n+v2i64 __builtin_msa_ld_d (void *, imm_n4096_4088);\n+\n+v16i8 __builtin_msa_ldi_b (imm_n512_511);\n+v8i16 __builtin_msa_ldi_h (imm_n512_511);\n+v4i32 __builtin_msa_ldi_w (imm_n512_511);\n+v2i64 __builtin_msa_ldi_d (imm_n512_511);\n+\n+v8i16 __builtin_msa_madd_q_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_madd_q_w (v4i32, v4i32, v4i32);\n+\n+v8i16 __builtin_msa_maddr_q_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_maddr_q_w (v4i32, v4i32, v4i32);\n+\n+v16i8 __builtin_msa_maddv_b (v16i8, v16i8, v16i8);\n+v8i16 __builtin_msa_maddv_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_maddv_w (v4i32, v4i32, v4i32);\n+v2i64 __builtin_msa_maddv_d (v2i64, v2i64, v2i64);\n+\n+v16i8 __builtin_msa_max_a_b (v16i8, v16i8);\n+v8i16 __builtin_msa_max_a_h (v8i16, v8i16);\n+v4i32 __builtin_msa_max_a_w (v4i32, v4i32);\n+v2i64 __builtin_msa_max_a_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_max_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_max_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_max_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_max_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_max_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_max_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_max_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_max_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_maxi_s_b (v16i8, imm_n16_15);\n+v8i16 __builtin_msa_maxi_s_h (v8i16, imm_n16_15);\n+v4i32 __builtin_msa_maxi_s_w (v4i32, imm_n16_15);\n+v2i64 __builtin_msa_maxi_s_d (v2i64, imm_n16_15);\n+\n+v16u8 __builtin_msa_maxi_u_b (v16u8, imm0_31);\n+v8u16 __builtin_msa_maxi_u_h (v8u16, imm0_31);\n+v4u32 __builtin_msa_maxi_u_w (v4u32, imm0_31);\n+v2u64 __builtin_msa_maxi_u_d (v2u64, imm0_31);\n+\n+v16i8 __builtin_msa_min_a_b (v16i8, v16i8);\n+v8i16 __builtin_msa_min_a_h (v8i16, v8i16);\n+v4i32 __builtin_msa_min_a_w (v4i32, v4i32);\n+v2i64 __builtin_msa_min_a_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_min_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_min_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_min_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_min_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_min_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_min_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_min_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_min_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_mini_s_b (v16i8, imm_n16_15);\n+v8i16 __builtin_msa_mini_s_h (v8i16, imm_n16_15);\n+v4i32 __builtin_msa_mini_s_w (v4i32, imm_n16_15);\n+v2i64 __builtin_msa_mini_s_d (v2i64, imm_n16_15);\n+\n+v16u8 __builtin_msa_mini_u_b (v16u8, imm0_31);\n+v8u16 __builtin_msa_mini_u_h (v8u16, imm0_31);\n+v4u32 __builtin_msa_mini_u_w (v4u32, imm0_31);\n+v2u64 __builtin_msa_mini_u_d (v2u64, imm0_31);\n+\n+v16i8 __builtin_msa_mod_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_mod_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_mod_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_mod_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_mod_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_mod_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_mod_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_mod_u_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_move_v (v16i8);\n+\n+v8i16 __builtin_msa_msub_q_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_msub_q_w (v4i32, v4i32, v4i32);\n+\n+v8i16 __builtin_msa_msubr_q_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_msubr_q_w (v4i32, v4i32, v4i32);\n+\n+v16i8 __builtin_msa_msubv_b (v16i8, v16i8, v16i8);\n+v8i16 __builtin_msa_msubv_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_msubv_w (v4i32, v4i32, v4i32);\n+v2i64 __builtin_msa_msubv_d (v2i64, v2i64, v2i64);\n+\n+v8i16 __builtin_msa_mul_q_h (v8i16, v8i16);\n+v4i32 __builtin_msa_mul_q_w (v4i32, v4i32);\n+\n+v8i16 __builtin_msa_mulr_q_h (v8i16, v8i16);\n+v4i32 __builtin_msa_mulr_q_w (v4i32, v4i32);\n+\n+v16i8 __builtin_msa_mulv_b (v16i8, v16i8);\n+v8i16 __builtin_msa_mulv_h (v8i16, v8i16);\n+v4i32 __builtin_msa_mulv_w (v4i32, v4i32);\n+v2i64 __builtin_msa_mulv_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_nloc_b (v16i8);\n+v8i16 __builtin_msa_nloc_h (v8i16);\n+v4i32 __builtin_msa_nloc_w (v4i32);\n+v2i64 __builtin_msa_nloc_d (v2i64);\n+\n+v16i8 __builtin_msa_nlzc_b (v16i8);\n+v8i16 __builtin_msa_nlzc_h (v8i16);\n+v4i32 __builtin_msa_nlzc_w (v4i32);\n+v2i64 __builtin_msa_nlzc_d (v2i64);\n+\n+v16u8 __builtin_msa_nor_v (v16u8, v16u8);\n+\n+v16u8 __builtin_msa_nori_b (v16u8, imm0_255);\n+\n+v16u8 __builtin_msa_or_v (v16u8, v16u8);\n+\n+v16u8 __builtin_msa_ori_b (v16u8, imm0_255);\n+\n+v16i8 __builtin_msa_pckev_b (v16i8, v16i8);\n+v8i16 __builtin_msa_pckev_h (v8i16, v8i16);\n+v4i32 __builtin_msa_pckev_w (v4i32, v4i32);\n+v2i64 __builtin_msa_pckev_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_pckod_b (v16i8, v16i8);\n+v8i16 __builtin_msa_pckod_h (v8i16, v8i16);\n+v4i32 __builtin_msa_pckod_w (v4i32, v4i32);\n+v2i64 __builtin_msa_pckod_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_pcnt_b (v16i8);\n+v8i16 __builtin_msa_pcnt_h (v8i16);\n+v4i32 __builtin_msa_pcnt_w (v4i32);\n+v2i64 __builtin_msa_pcnt_d (v2i64);\n+\n+v16i8 __builtin_msa_sat_s_b (v16i8, imm0_7);\n+v8i16 __builtin_msa_sat_s_h (v8i16, imm0_15);\n+v4i32 __builtin_msa_sat_s_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_sat_s_d (v2i64, imm0_63);\n+\n+v16u8 __builtin_msa_sat_u_b (v16u8, imm0_7);\n+v8u16 __builtin_msa_sat_u_h (v8u16, imm0_15);\n+v4u32 __builtin_msa_sat_u_w (v4u32, imm0_31);\n+v2u64 __builtin_msa_sat_u_d (v2u64, imm0_63);\n+\n+v16i8 __builtin_msa_shf_b (v16i8, imm0_255);\n+v8i16 __builtin_msa_shf_h (v8i16, imm0_255);\n+v4i32 __builtin_msa_shf_w (v4i32, imm0_255);\n+\n+v16i8 __builtin_msa_sld_b (v16i8, v16i8, i32);\n+v8i16 __builtin_msa_sld_h (v8i16, v8i16, i32);\n+v4i32 __builtin_msa_sld_w (v4i32, v4i32, i32);\n+v2i64 __builtin_msa_sld_d (v2i64, v2i64, i32);\n+\n+v16i8 __builtin_msa_sldi_b (v16i8, v16i8, imm0_15);\n+v8i16 __builtin_msa_sldi_h (v8i16, v8i16, imm0_7);\n+v4i32 __builtin_msa_sldi_w (v4i32, v4i32, imm0_3);\n+v2i64 __builtin_msa_sldi_d (v2i64, v2i64, imm0_1);\n+\n+v16i8 __builtin_msa_sll_b (v16i8, v16i8);\n+v8i16 __builtin_msa_sll_h (v8i16, v8i16);\n+v4i32 __builtin_msa_sll_w (v4i32, v4i32);\n+v2i64 __builtin_msa_sll_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_slli_b (v16i8, imm0_7);\n+v8i16 __builtin_msa_slli_h (v8i16, imm0_15);\n+v4i32 __builtin_msa_slli_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_slli_d (v2i64, imm0_63);\n+\n+v16i8 __builtin_msa_splat_b (v16i8, i32);\n+v8i16 __builtin_msa_splat_h (v8i16, i32);\n+v4i32 __builtin_msa_splat_w (v4i32, i32);\n+v2i64 __builtin_msa_splat_d (v2i64, i32);\n+\n+v16i8 __builtin_msa_splati_b (v16i8, imm0_15);\n+v8i16 __builtin_msa_splati_h (v8i16, imm0_7);\n+v4i32 __builtin_msa_splati_w (v4i32, imm0_3);\n+v2i64 __builtin_msa_splati_d (v2i64, imm0_1);\n+\n+v16i8 __builtin_msa_sra_b (v16i8, v16i8);\n+v8i16 __builtin_msa_sra_h (v8i16, v8i16);\n+v4i32 __builtin_msa_sra_w (v4i32, v4i32);\n+v2i64 __builtin_msa_sra_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_srai_b (v16i8, imm0_7);\n+v8i16 __builtin_msa_srai_h (v8i16, imm0_15);\n+v4i32 __builtin_msa_srai_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_srai_d (v2i64, imm0_63);\n+\n+v16i8 __builtin_msa_srar_b (v16i8, v16i8);\n+v8i16 __builtin_msa_srar_h (v8i16, v8i16);\n+v4i32 __builtin_msa_srar_w (v4i32, v4i32);\n+v2i64 __builtin_msa_srar_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_srari_b (v16i8, imm0_7);\n+v8i16 __builtin_msa_srari_h (v8i16, imm0_15);\n+v4i32 __builtin_msa_srari_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_srari_d (v2i64, imm0_63);\n+\n+v16i8 __builtin_msa_srl_b (v16i8, v16i8);\n+v8i16 __builtin_msa_srl_h (v8i16, v8i16);\n+v4i32 __builtin_msa_srl_w (v4i32, v4i32);\n+v2i64 __builtin_msa_srl_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_srli_b (v16i8, imm0_7);\n+v8i16 __builtin_msa_srli_h (v8i16, imm0_15);\n+v4i32 __builtin_msa_srli_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_srli_d (v2i64, imm0_63);\n+\n+v16i8 __builtin_msa_srlr_b (v16i8, v16i8);\n+v8i16 __builtin_msa_srlr_h (v8i16, v8i16);\n+v4i32 __builtin_msa_srlr_w (v4i32, v4i32);\n+v2i64 __builtin_msa_srlr_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_srlri_b (v16i8, imm0_7);\n+v8i16 __builtin_msa_srlri_h (v8i16, imm0_15);\n+v4i32 __builtin_msa_srlri_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_srlri_d (v2i64, imm0_63);\n+\n+void __builtin_msa_st_b (v16i8, void *, imm_n512_511);\n+void __builtin_msa_st_h (v8i16, void *, imm_n1024_1022);\n+void __builtin_msa_st_w (v4i32, void *, imm_n2048_2044);\n+void __builtin_msa_st_d (v2i64, void *, imm_n4096_4088);\n+\n+v16i8 __builtin_msa_subs_s_b (v16i8, v16i8);\n+v8i16 __builtin_msa_subs_s_h (v8i16, v8i16);\n+v4i32 __builtin_msa_subs_s_w (v4i32, v4i32);\n+v2i64 __builtin_msa_subs_s_d (v2i64, v2i64);\n+\n+v16u8 __builtin_msa_subs_u_b (v16u8, v16u8);\n+v8u16 __builtin_msa_subs_u_h (v8u16, v8u16);\n+v4u32 __builtin_msa_subs_u_w (v4u32, v4u32);\n+v2u64 __builtin_msa_subs_u_d (v2u64, v2u64);\n+\n+v16u8 __builtin_msa_subsus_u_b (v16u8, v16i8);\n+v8u16 __builtin_msa_subsus_u_h (v8u16, v8i16);\n+v4u32 __builtin_msa_subsus_u_w (v4u32, v4i32);\n+v2u64 __builtin_msa_subsus_u_d (v2u64, v2i64);\n+\n+v16i8 __builtin_msa_subsuu_s_b (v16u8, v16u8);\n+v8i16 __builtin_msa_subsuu_s_h (v8u16, v8u16);\n+v4i32 __builtin_msa_subsuu_s_w (v4u32, v4u32);\n+v2i64 __builtin_msa_subsuu_s_d (v2u64, v2u64);\n+\n+v16i8 __builtin_msa_subv_b (v16i8, v16i8);\n+v8i16 __builtin_msa_subv_h (v8i16, v8i16);\n+v4i32 __builtin_msa_subv_w (v4i32, v4i32);\n+v2i64 __builtin_msa_subv_d (v2i64, v2i64);\n+\n+v16i8 __builtin_msa_subvi_b (v16i8, imm0_31);\n+v8i16 __builtin_msa_subvi_h (v8i16, imm0_31);\n+v4i32 __builtin_msa_subvi_w (v4i32, imm0_31);\n+v2i64 __builtin_msa_subvi_d (v2i64, imm0_31);\n+\n+v16i8 __builtin_msa_vshf_b (v16i8, v16i8, v16i8);\n+v8i16 __builtin_msa_vshf_h (v8i16, v8i16, v8i16);\n+v4i32 __builtin_msa_vshf_w (v4i32, v4i32, v4i32);\n+v2i64 __builtin_msa_vshf_d (v2i64, v2i64, v2i64);\n+\n+v16u8 __builtin_msa_xor_v (v16u8, v16u8);\n+\n+v16u8 __builtin_msa_xori_b (v16u8, imm0_255);\n+@end smallexample\n+\n @node Other MIPS Built-in Functions\n @subsection Other MIPS Built-in Functions\n "}, {"sha": "a54a0af77b8757478ab3738a0ed48e77474e3644", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -849,6 +849,7 @@ Objective-C and Objective-C++ Dialects}.\n -mvirt -mno-virt @gol\n -mxpa -mno-xpa @gol\n -mmicromips -mno-micromips @gol\n+-mmsa -mno-msa @gol\n -mfpu=@var{fpu-type} @gol\n -msmartmips  -mno-smartmips @gol\n -mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx @gol"}, {"sha": "3142cd53ae53e90bb1af2f595fe53778c1cbfd3b", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf538daaead38a5bc09a79bfb26c34c83fec91e/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=6cf538daaead38a5bc09a79bfb26c34c83fec91e", "patch": "@@ -1641,6 +1641,9 @@ MIPS target can generate MIPS16 code.\n MIPS target is a Loongson-2E or -2F target using an ABI that supports\n the Loongson vector modes.\n \n+@item mips_msa\n+MIPS target supports @code{-mmsa}, MIPS SIMD Architecture (MSA).\n+\n @item mips_newabi_large_long_double\n MIPS target supports @code{long double} larger than @code{double}\n when using the new ABI."}]}