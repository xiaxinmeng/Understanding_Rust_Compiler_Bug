{"sha": "548502d3b1a9d50061b1ee76ec6e94071d77029f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ4NTAyZDNiMWE5ZDUwMDYxYjFlZTc2ZWM2ZTk0MDcxZDc3MDI5Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-11-04T01:45:58Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-11-04T01:45:58Z"}, "message": "call.c (build_special_member_call): Do not try to lookup VTTs by name.\n\n\t* call.c (build_special_member_call): Do not try to lookup VTTs by\n\tname.\n\t* class.c (vtbl_init_data): Add generate_vcall_entries.\n\t(get_vtable_decl): Do not look up virtual tables by name.\n\t(copy_virtuals): Do not use BV_USE_VCALL_INDEX_P.\n\t(set_primary_base): Do not set CLASSTYPE_RTTI.\n\t(determine_primary_base): Likewise.\n\t(get_matching_virtual): Remove.\n\t(get_vcall_index): New function.\n\t(update_vtable_entry_for_fn): Do not try to use virtual thunks\n\twhen they are not required.  Assign vcall indices at this point.\n\t(finish_struct_1): Do not set CLASSTYPE_NEEDS_VIRTUAL_REINIT.\n\tDo update dynamic_classes.\n\t(build_vtt): Do not add VTTs to the symbol table.\n\t(build_ctor_vtbl_group): Likewise.\n\t(build_vtbl_initializer): Simplify handling of vcall indices.\n\t(build_vcall_offset_vtbl_entries): Pretend to build vcall offsets\n\tfor the most derived class.\n\t(add_vcall_offset_vtbl_entries_1): But do not actually add them to\n\tthe vtable.\n\t* cp-tree.h (dynamic_classes): New macro.\n\t(lang_type_class): Remove rtti.  Add vtables.  Add vcall_indices.\n\t(CLASSTYPE_RTTI): Remove.\n\t(CLASSTYPE_NEEDS_VIRTUAL_REINIT): Remove.\n\t(CLASSTYPE_VCALL_INDICES): New macro.\n\t(CLASSTYPE_VTABLES): Likewise.\n\t(BV_USE_VCALL_INDEX_P): Remove.\n\t(build_vtable_path): Remove.\n\t* decl2.c (finish_vtable_vardecl): Remove.\n\t(key_method): Remove #if 0'd code.\n\t(finish_vtable_vardecl): Rename to ...\n\t(maybe_emit_vtables): ... this.\n\t(finish_file): Use it.\n\t* search.c (look_for_overrides_here): Update comment.\n\n\t* g++.dg/abi/thunk1.C: New test.\n\t* g++.dg/abi/thunk2.C: Likewise.\n\t* g++.dg/abi/vtt1.C: Likewise.\n\nFrom-SVN: r58779", "tree": {"sha": "d9bab1647f82529995df625763d3ea7ac083c4b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9bab1647f82529995df625763d3ea7ac083c4b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/548502d3b1a9d50061b1ee76ec6e94071d77029f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548502d3b1a9d50061b1ee76ec6e94071d77029f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548502d3b1a9d50061b1ee76ec6e94071d77029f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548502d3b1a9d50061b1ee76ec6e94071d77029f/comments", "author": null, "committer": null, "parents": [{"sha": "55376e412851fb852f4b5c72d1da5e12aec0a459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55376e412851fb852f4b5c72d1da5e12aec0a459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55376e412851fb852f4b5c72d1da5e12aec0a459"}], "stats": {"total": 536, "additions": 291, "deletions": 245}, "files": [{"sha": "2fb30a9467dd6c2362b6bbfed043b223c5be0a52", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -1,3 +1,40 @@\n+2002-11-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_special_member_call): Do not try to lookup VTTs by\n+\tname.\n+\t* class.c (vtbl_init_data): Add generate_vcall_entries.\n+\t(get_vtable_decl): Do not look up virtual tables by name.\n+\t(copy_virtuals): Do not use BV_USE_VCALL_INDEX_P.\n+\t(set_primary_base): Do not set CLASSTYPE_RTTI.\n+\t(determine_primary_base): Likewise.\n+\t(get_matching_virtual): Remove.\n+\t(get_vcall_index): New function.\n+\t(update_vtable_entry_for_fn): Do not try to use virtual thunks\n+\twhen they are not required.  Assign vcall indices at this point.\n+\t(finish_struct_1): Do not set CLASSTYPE_NEEDS_VIRTUAL_REINIT.\n+\tDo update dynamic_classes.\n+\t(build_vtt): Do not add VTTs to the symbol table.\n+\t(build_ctor_vtbl_group): Likewise.\n+\t(build_vtbl_initializer): Simplify handling of vcall indices.\n+\t(build_vcall_offset_vtbl_entries): Pretend to build vcall offsets\n+\tfor the most derived class.\n+\t(add_vcall_offset_vtbl_entries_1): But do not actually add them to\n+\tthe vtable.\n+\t* cp-tree.h (dynamic_classes): New macro.\n+\t(lang_type_class): Remove rtti.  Add vtables.  Add vcall_indices.\n+\t(CLASSTYPE_RTTI): Remove.\n+\t(CLASSTYPE_NEEDS_VIRTUAL_REINIT): Remove.\n+\t(CLASSTYPE_VCALL_INDICES): New macro.\n+\t(CLASSTYPE_VTABLES): Likewise.\n+\t(BV_USE_VCALL_INDEX_P): Remove.\n+\t(build_vtable_path): Remove.\n+\t* decl2.c (finish_vtable_vardecl): Remove.\n+\t(key_method): Remove #if 0'd code.\n+\t(finish_vtable_vardecl): Rename to ...\n+\t(maybe_emit_vtables): ... this.\n+\t(finish_file): Use it.\n+\t* search.c (look_for_overrides_here): Update comment.\n+\n 2002-11-01  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR c/7353 redux"}, {"sha": "a7f9a917d15169f60cd5e1ea9fdb9d7d45751b0c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -4712,7 +4712,7 @@ build_special_member_call (tree instance, tree name, tree args,\n       /* If the current function is a complete object constructor\n \t or destructor, then we fetch the VTT directly.\n \t Otherwise, we look it up using the VTT we were given.  */\n-      vtt = IDENTIFIER_GLOBAL_VALUE (get_vtt_name (current_class_type));\n+      vtt = TREE_CHAIN (CLASSTYPE_VTABLES (current_class_type));\n       vtt = decay_conversion (vtt);\n       vtt = build (COND_EXPR, TREE_TYPE (vtt),\n \t\t   build (EQ_EXPR, boolean_type_node,"}, {"sha": "0dffc62ea695443f51d574cb29c01a67f74780cf", "filename": "gcc/cp/class.c", "status": "modified", "additions": 108, "deletions": 179, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -87,6 +87,9 @@ typedef struct vtbl_init_data_s\n   /* Nonzero if we are building the initializer for a construction\n      vtable.  */\n   int ctor_vtbl_p;\n+  /* True when adding vcall offset entries to the vtable.  False when\n+     merely computing the indices.  */\n+  bool generate_vcall_entries;\n } vtbl_init_data;\n \n /* The type of a function passed to walk_subobject_offsets.  */\n@@ -209,6 +212,7 @@ static tree dfs_base_derived_from (tree, void *);\n static bool base_derived_from (tree, tree);\n static int empty_base_at_nonzero_offset_p (tree, tree, splay_tree);\n static tree end_of_base (tree);\n+static tree get_vcall_index (tree, tree);\n \n /* Macros for dfs walking during vtt construction. See\n    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n@@ -540,21 +544,14 @@ get_vtable_decl (type, complete)\n      tree type;\n      int complete;\n {\n-  tree name = get_vtable_name (type);\n-  tree decl = IDENTIFIER_GLOBAL_VALUE (name);\n-  \n-  if (decl)\n-    {\n-      my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n-                          && DECL_VIRTUAL_P (decl), 20000118);\n-      return decl;\n-    }\n-  \n-  decl = build_vtable (type, name, void_type_node);\n-  decl = pushdecl_top_level (decl);\n-  my_friendly_assert (IDENTIFIER_GLOBAL_VALUE (name) == decl,\n-\t\t      20000517);\n+  tree decl;\n+\n+  if (CLASSTYPE_VTABLES (type))\n+    return CLASSTYPE_VTABLES (type);\n   \n+  decl = build_vtable (type, get_vtable_name (type), void_type_node);\n+  CLASSTYPE_VTABLES (type) = decl;\n+\n   /* At one time the vtable info was grabbed 2 words at a time.  This\n      fails on sparc unless you have 8-byte alignment.  (tiemann) */\n   DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n@@ -581,10 +578,7 @@ copy_virtuals (binfo)\n \n   copies = copy_list (BINFO_VIRTUALS (binfo));\n   for (t = copies; t; t = TREE_CHAIN (t))\n-    {\n-      BV_VCALL_INDEX (t) = NULL_TREE;\n-      BV_USE_VCALL_INDEX_P (t) = 0;\n-    }\n+    BV_VCALL_INDEX (t) = NULL_TREE;\n \n   return copies;\n }\n@@ -1559,7 +1553,6 @@ set_primary_base (t, binfo)\n   TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n   TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n   TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n-  CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n }\n \n /* Determine the primary class for T.  */\n@@ -1585,12 +1578,6 @@ determine_primary_base (t)\n \n       if (TYPE_CONTAINS_VPTR_P (basetype))\n \t{\n-\t  /* Even a virtual baseclass can contain our RTTI\n-\t     information.  But, we prefer a non-virtual polymorphic\n-\t     baseclass.  */\n-\t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-\t    CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n-\n \t  /* We prefer a non-virtual base, although a virtual one will\n \t     do.  */\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n@@ -2325,21 +2312,23 @@ find_final_overrider (t, binfo, fn)\n   return ffod.candidates;\n }\n \n-/* Returns the function from the BINFO_VIRTUALS entry in T which matches\n-   the signature of FUNCTION_DECL FN, or NULL_TREE if none.  In other words,\n-   the function that the slot in T's primary vtable points to.  */\n+/* Return the index of the vcall offset for FN when TYPE is used as a\n+   virtual base.  */\n \n-static tree get_matching_virtual PARAMS ((tree, tree));\n static tree\n-get_matching_virtual (t, fn)\n-     tree t, fn;\n+get_vcall_index (tree fn, tree type)\n {\n-  tree f;\n+  tree v;\n \n-  for (f = BINFO_VIRTUALS (TYPE_BINFO (t)); f; f = TREE_CHAIN (f))\n-    if (same_signature_p (BV_FN (f), fn))\n-      return BV_FN (f);\n-  return NULL_TREE;\n+  for (v = CLASSTYPE_VCALL_INDICES (type); v; v = TREE_CHAIN (v))\n+    if ((DECL_DESTRUCTOR_P (fn) && DECL_DESTRUCTOR_P (TREE_PURPOSE (v)))\n+\t|| same_signature_p (fn, TREE_PURPOSE (v)))\n+      break;\n+\n+  /* There should always be an appropriate index.  */\n+  my_friendly_assert (v, 20021103);\n+\n+  return TREE_VALUE (v);\n }\n \n /* Update an entry in the vtable for BINFO, which is in the hierarchy\n@@ -2407,7 +2396,6 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n   /* Compute the constant adjustment to the `this' pointer.  The\n      `this' pointer, when this function is called, will point at BINFO\n      (or one of its primary bases, which are at the same offset).  */\n-\n   if (virtual_base)\n     /* The `this' pointer needs to be adjusted from the declaration to\n        the nearest virtual base.  */\n@@ -2420,36 +2408,11 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n        will be zero, as it will be a primary base.  */\n     delta = size_zero_node;\n   else\n-    {\n-      /* The `this' pointer needs to be adjusted from pointing to\n-\t BINFO to pointing at the base where the final overrider\n-\t appears.  */\n-      delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n-\t\t\t   BINFO_OFFSET (binfo));\n-\n-      if (! integer_zerop (delta))\n-\t{\n-\t  /* We'll need a thunk.  But if we have a (perhaps formerly)\n-\t     primary virtual base, we have a vcall slot for this function,\n-\t     so we can use it rather than create a non-virtual thunk.  */\n-\t  \n-\t  b = get_primary_binfo (first_defn);\n-\t  for (; b; b = get_primary_binfo (b))\n-\t    {\n-\t      tree f = get_matching_virtual (BINFO_TYPE (b), fn);\n-\t      if (!f)\n-\t\t/* b doesn't have this function; no suitable vbase.  */\n-\t\tbreak;\n-\t      if (TREE_VIA_VIRTUAL (b))\n-\t\t{\n-\t\t  /* Found one; we can treat ourselves as a virtual base.  */\n-\t\t  virtual_base = binfo;\n-\t\t  delta = size_zero_node;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n+    /* The `this' pointer needs to be adjusted from pointing to\n+       BINFO to pointing at the base where the final overrider\n+       appears.  */\n+    delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n+\t\t\t BINFO_OFFSET (binfo));\n \n   modify_vtable_entry (t, \n \t\t       binfo, \n@@ -2458,7 +2421,9 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t\t       virtuals);\n \n   if (virtual_base)\n-    BV_USE_VCALL_INDEX_P (*virtuals) = 1;\n+    BV_VCALL_INDEX (*virtuals) \n+      = get_vcall_index (TREE_PURPOSE (overrider),\n+\t\t\t BINFO_TYPE (virtual_base));\n }\n \n /* Called from modify_all_vtables via dfs_walk.  */\n@@ -5101,32 +5066,8 @@ layout_class_type (tree t, tree *virtuals_p)\n   splay_tree_delete (empty_base_offsets);\n }\n \n-/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n-   (or C++ class declaration).\n-\n-   For C++, we must handle the building of derived classes.\n-   Also, C++ allows static class members.  The way that this is\n-   handled is to keep the field name where it is (as the DECL_NAME\n-   of the field), and place the overloaded decl in the bit position\n-   of the field.  layout_record and layout_union will know about this.\n-\n-   More C++ hair: inline functions have text in their\n-   DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into\n-   meaningful tree structure.  After the struct has been laid out, set\n-   things up so that this can happen.\n-\n-   And still more: virtual functions.  In the case of single inheritance,\n-   when a new virtual function is seen which redefines a virtual function\n-   from the base class, the new virtual function is placed into\n-   the virtual function table at exactly the same address that\n-   it had in the base class.  When this is extended to multiple\n-   inheritance, the same thing happens, except that multiple virtual\n-   function tables must be maintained.  The first virtual function\n-   table is treated in exactly the same way as in the case of single\n-   inheritance.  Additional virtual function tables have different\n-   DELTAs, which tell how to adjust `this' to point to the right thing.\n-\n-   ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n+/* Perform processing required when the definition of T (a class type)\n+   is complete.  */\n \n void\n finish_struct_1 (t)\n@@ -5153,7 +5094,6 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n   CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n-  CLASSTYPE_RTTI (t) = NULL_TREE;\n \n   fixup_inline_methods (t);\n   \n@@ -5210,24 +5150,6 @@ finish_struct_1 (t)\n \t/* Here we know enough to change the type of our virtual\n \t   function table, but we will wait until later this function.  */\n \tbuild_primary_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n-\n-      /* If this type has basetypes with constructors, then those\n-\t constructors might clobber the virtual function table.  But\n-\t they don't if the derived class shares the exact vtable of the base\n-\t class.  */\n-      CLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n-    }\n-  /* If we didn't need a new vtable, see if we should copy one from\n-     the base.  */\n-  else if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-    {\n-      tree binfo = CLASSTYPE_PRIMARY_BINFO (t);\n-\n-      /* If this class uses a different vtable than its primary base\n-\t then when we will need to initialize our vptr after the base\n-\t class constructor runs.  */\n-      if (TYPE_BINFO_VTABLE (t) != BINFO_VTABLE (binfo))\n-\tCLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n \n   if (TYPE_CONTAINS_VPTR_P (t))\n@@ -5253,6 +5175,9 @@ finish_struct_1 (t)\n \t\t\t? TARGET_VTABLE_USES_DESCRIPTORS : 1))\n \tif (TREE_CODE (DECL_VINDEX (BV_FN (fn))) != INTEGER_CST)\n \t  DECL_VINDEX (BV_FN (fn)) = build_shared_int_cst (vindex);\n+\n+      /* Add this class to the list of dynamic classes.  */\n+      dynamic_classes = tree_cons (NULL_TREE, t, dynamic_classes);\n     }\n \n   finish_struct_bits (t);\n@@ -7068,8 +6993,10 @@ build_vtt (t)\n \t\t\t\t \n   /* Now, build the VTT object itself.  */\n   vtt = build_vtable (t, get_vtt_name (t), type);\n-  pushdecl_top_level (vtt);\n   initialize_array (vtt, inits);\n+  /* Add the VTT to the vtables list.  */\n+  TREE_CHAIN (vtt) = TREE_CHAIN (CLASSTYPE_VTABLES (t));\n+  TREE_CHAIN (CLASSTYPE_VTABLES (t)) = vtt;\n \n   dump_vtt (t, vtt);\n }\n@@ -7404,7 +7331,7 @@ build_ctor_vtbl_group (binfo, t)\n   TREE_TYPE (vtbl) = type;\n \n   /* Initialize the construction vtable.  */\n-  pushdecl_top_level (vtbl);\n+  CLASSTYPE_VTABLES (t) = chainon (CLASSTYPE_VTABLES (t), vtbl);\n   initialize_array (vtbl, inits);\n   dump_vtable (t, binfo, vtbl);\n }\n@@ -7621,6 +7548,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   vid.last_init = &vid.inits;\n   vid.primary_vtbl_p = (binfo == TYPE_BINFO (t));\n   vid.ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n+  vid.generate_vcall_entries = true;\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n   vid.index = ssize_int (-3 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n \n@@ -7704,14 +7632,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n \t  /* Pull the offset for `this', and the function to call, out of\n \t     the list.  */\n \t  delta = BV_DELTA (v);\n-\n-\t  if (BV_USE_VCALL_INDEX_P (v))\n-\t    {\n-\t      vcall_index = BV_VCALL_INDEX (v);\n-\t      my_friendly_assert (vcall_index != NULL_TREE, 20000621);\n-\t    }\n-\t  else\n-\t    vcall_index = NULL_TREE;\n+\t  vcall_index = BV_VCALL_INDEX (v);\n \n \t  my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n \t  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n@@ -7900,31 +7821,37 @@ build_vcall_offset_vtbl_entries (binfo, vid)\n      tree binfo;\n      vtbl_init_data *vid;\n {\n-  /* We only need these entries if this base is a virtual base.  */\n-  if (!TREE_VIA_VIRTUAL (binfo))\n-    return;\n-\n-  /* We need a vcall offset for each of the virtual functions in this\n-     vtable.  For example:\n+  /* We only need these entries if this base is a virtual base.  We\n+     compute the indices -- but do not add to the vtable -- when\n+     building the main vtable for a class.  */\n+  if (TREE_VIA_VIRTUAL (binfo) || binfo == TYPE_BINFO (vid->derived))\n+    {\n+      /* We need a vcall offset for each of the virtual functions in this\n+\t vtable.  For example:\n \n-       class A { virtual void f (); };\n-       class B1 : virtual public A { virtual void f (); };\n-       class B2 : virtual public A { virtual void f (); };\n-       class C: public B1, public B2 { virtual void f (); };\n+\t   class A { virtual void f (); };\n+\t   class B1 : virtual public A { virtual void f (); };\n+\t   class B2 : virtual public A { virtual void f (); };\n+\t   class C: public B1, public B2 { virtual void f (); };\n \n-     A C object has a primary base of B1, which has a primary base of A.  A\n-     C also has a secondary base of B2, which no longer has a primary base\n-     of A.  So the B2-in-C construction vtable needs a secondary vtable for\n-     A, which will adjust the A* to a B2* to call f.  We have no way of\n-     knowing what (or even whether) this offset will be when we define B2,\n-     so we store this \"vcall offset\" in the A sub-vtable and look it up in\n-     a \"virtual thunk\" for B2::f.\n+\t A C object has a primary base of B1, which has a primary base of A.  A\n+\t C also has a secondary base of B2, which no longer has a primary base\n+\t of A.  So the B2-in-C construction vtable needs a secondary vtable for\n+\t A, which will adjust the A* to a B2* to call f.  We have no way of\n+\t knowing what (or even whether) this offset will be when we define B2,\n+\t so we store this \"vcall offset\" in the A sub-vtable and look it up in\n+\t a \"virtual thunk\" for B2::f.\n \n-     We need entries for all the functions in our primary vtable and\n-     in our non-virtual bases' secondary vtables.  */\n-  vid->vbase = binfo;\n-  /* Now, walk through the non-virtual bases, adding vcall offsets.  */\n-  add_vcall_offset_vtbl_entries_r (binfo, vid);\n+\t We need entries for all the functions in our primary vtable and\n+\t in our non-virtual bases' secondary vtables.  */\n+      vid->vbase = binfo;\n+      /* If we are just computing the vcall indices -- but do not need\n+\t the actual entries -- not that.  */\n+      if (!TREE_VIA_VIRTUAL (binfo))\n+\tvid->generate_vcall_entries = false;\n+      /* Now, walk through the non-virtual bases, adding vcall offsets.  */\n+      add_vcall_offset_vtbl_entries_r (binfo, vid);\n+    }\n }\n \n /* Build vcall offsets, starting with those for BINFO.  */\n@@ -8025,8 +7952,6 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n     {\n       tree orig_fn;\n       tree fn;\n-      tree base;\n-      tree base_binfo;\n       size_t i;\n       tree vcall_offset;\n \n@@ -8057,42 +7982,17 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \t\t even though there are two virtual table entries.  */\n \t      || (DECL_DESTRUCTOR_P (BV_FN (derived_entry))\n \t\t  && DECL_DESTRUCTOR_P (fn)))\n-\t    {\n-\t      if (!vid->ctor_vtbl_p)\n-  \t        BV_VCALL_INDEX (derived_virtuals) \n-\t\t  = BV_VCALL_INDEX (derived_entry);\n-\t      break;\n-\t    }\n+\t    break;\n \t}\n       if (i != VARRAY_ACTIVE_SIZE (vid->fns))\n \tcontinue;\n \n-      /* The FN comes from BASE.  So, we must calculate the adjustment from\n-\t vid->vbase to BASE.  We can just look for BASE in the complete\n-\t object because we are converting from a virtual base, so if there\n-\t were multiple copies, there would not be a unique final overrider\n-\t and vid->derived would be ill-formed.  */\n-      base = DECL_CONTEXT (fn);\n-      base_binfo = lookup_base (vid->derived, base, ba_any, NULL);\n-\n-      /* Compute the vcall offset.  */\n-      /* As mentioned above, the vbase we're working on is a primary base of\n-\t vid->binfo.  But it might be a lost primary, so its BINFO_OFFSET\n-         might be wrong, so we just use the BINFO_OFFSET from vid->binfo.  */\n-      vcall_offset = BINFO_OFFSET (vid->binfo);\n-      vcall_offset = size_diffop (BINFO_OFFSET (base_binfo),\n-\t\t                  vcall_offset);\n-      vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n-    \t\t\t           vcall_offset));\n-      \n-      *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n-      vid->last_init = &TREE_CHAIN (*vid->last_init);\n-\n-      /* Keep track of the vtable index where this vcall offset can be\n-\t found.  For a construction vtable, we already made this\n-\t annotation when we built the original vtable.  */\n-      if (!vid->ctor_vtbl_p)\n-\tBV_VCALL_INDEX (derived_virtuals) = vid->index;\n+      /* If we are building these vcall offsets as part of building\n+\t the vtable for the most derived class, remember the vcall\n+\t offset.  */\n+      if (vid->binfo == TYPE_BINFO (vid->derived))\n+\tCLASSTYPE_VCALL_INDICES (vid->derived) \n+\t  = tree_cons (fn, vid->index, CLASSTYPE_VCALL_INDICES (vid->derived));\n \n       /* The next vcall offset will be found at a more negative\n \t offset.  */\n@@ -8101,6 +8001,35 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \n       /* Keep track of this function.  */\n       VARRAY_PUSH_TREE (vid->fns, derived_virtuals);\n+\n+      if (vid->generate_vcall_entries)\n+\t{\n+\t  tree base;\n+\t  tree base_binfo;\n+\n+\t  /* The FN comes from BASE.  So, we must calculate the\n+\t     adjustment from vid->vbase to BASE.  We can just look for\n+\t     BASE in the complete object because we are converting\n+\t     from a virtual base, so if there were multiple copies,\n+\t     there would not be a unique final overrider and\n+\t     vid->derived would be ill-formed.  */\n+\t  base = DECL_CONTEXT (fn);\n+\t  base_binfo = lookup_base (vid->derived, base, ba_any, NULL);\n+\n+\t  /* Compute the vcall offset.  */\n+\t  /* As mentioned above, the vbase we're working on is a\n+\t     primary base of vid->binfo.  But it might be a lost\n+\t     primary, so its BINFO_OFFSET might be wrong, so we just\n+\t     use the BINFO_OFFSET from vid->binfo.  */\n+\t  vcall_offset = BINFO_OFFSET (vid->binfo);\n+\t  vcall_offset = size_diffop (BINFO_OFFSET (base_binfo),\n+\t\t\t\t      vcall_offset);\n+\t  vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t\t       vcall_offset));\n+\n+\t  *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n+\t  vid->last_init = &TREE_CHAIN (*vid->last_init);\n+\t}\n     }\n }\n "}, {"sha": "ad88103c92593a24d8116acd07e3727f6e096d13", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -47,7 +47,6 @@ struct diagnostic_context;\n       ICS_USER_FLAG (in _CONV)\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n-      BV_USE_VCALL_INDEX_P (in the BINFO_VIRTUALS TREE_LIST)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF)\n       PARMLIST_ELLIPSIS_P (in PARMLIST)\n    1: IDENTIFIER_VIRTUAL_P.\n@@ -133,9 +132,7 @@ struct diagnostic_context;\n      of the base class.\n \n      The BV_VCALL_INDEX of each node, if non-NULL, gives the vtable\n-     index of the vcall offset for this entry.  If\n-     BV_USE_VCALL_INDEX_P then the corresponding vtable entry should\n-     use a virtual thunk, as opposed to an ordinary thunk.\n+     index of the vcall offset for this entry.  \n \n      The BV_FN is the declaration for the virtual function itself.\n \n@@ -615,6 +612,8 @@ enum cp_tree_index\n     CPTI_DSO_HANDLE,\n     CPTI_DCAST,\n \n+    CPTI_DYNAMIC_CLASSES,\n+\n     CPTI_MAX\n };\n \n@@ -745,6 +744,10 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    destructors.  */\n #define vtt_parm_type                   cp_global_trees[CPTI_VTT_PARM_TYPE]\n \n+/* A TREE_LIST of all of the dynamic classes in the program.  */\n+\n+#define dynamic_classes                 cp_global_trees[CPTI_DYNAMIC_CLASSES]\n+\n /* Global state.  */\n \n struct saved_scope GTY(())\n@@ -1153,12 +1156,13 @@ struct lang_type_class GTY(())\n \n   tree primary_base;\n   tree vfields;\n+  tree vcall_indices;\n+  tree vtables;\n   tree vbases;\n   tree tags;\n   tree as_base;\n   tree pure_virtuals;\n   tree friend_classes;\n-  tree rtti;\n   tree methods;\n   tree decl_list;\n   tree template_info;\n@@ -1257,9 +1261,6 @@ struct lang_type GTY(())\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n #define TYPE_REDEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->redefined)\n \n-/* The is the basetype that contains NODE's rtti.  */\n-#define CLASSTYPE_RTTI(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->rtti)\n-\n /* Nonzero means that this _CLASSTYPE node overloads operator().  */\n #define TYPE_OVERLOADS_CALL_EXPR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->has_call_overloaded)\n@@ -1431,13 +1432,6 @@ struct lang_type GTY(())\n /* Nonzero means that this aggr type has been `closed' by a semicolon.  */\n #define CLASSTYPE_GOT_SEMICOLON(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->got_semicolon)\n \n-/* Nonzero means that the main virtual function table pointer needs to be\n-   set because base constructors have placed the wrong value there.\n-   If this is zero, it means that they placed the right value there,\n-   and there is no need to change it.  */\n-#define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->needs_virtual_reinit)\n-\n /* Nonzero means that this type has an X() constructor.  */\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->h.has_default_ctor)\n@@ -1629,6 +1623,19 @@ struct lang_type GTY(())\n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n+/* A TREE_LIST of the vcall indices associated with the class NODE.\n+   The TREE_PURPOSE of each node is a FUNCTION_DECL for a virtual\n+   function.  The TREE_VALUE is the index into the virtual table where\n+   the vcall offset for that function is stored, when NODE is a\n+   virtual base.  */\n+#define CLASSTYPE_VCALL_INDICES(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->vcall_indices)\n+\n+/* The various vtables for the class NODE.  The primary vtable will be\n+   first, followed by the construction vtables and VTT, if any.  */\n+#define CLASSTYPE_VTABLES(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->vtables)\n+\n /* Accessor macros for the vfield slots in structures.  */\n \n /* List of virtual table fields that this type contains (both the primary\n@@ -1664,8 +1671,6 @@ struct lang_type GTY(())\n /* The function to call.  */\n #define BV_FN(NODE) (TREE_VALUE (NODE))\n \n-/* Nonzero if we should use a virtual thunk for this entry.  */\n-#define BV_USE_VCALL_INDEX_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n \f\n /* Nonzero for TREE_LIST node means that this list of things\n    is a list of parameters, as opposed to a list of expressions.  */\n@@ -3546,7 +3551,6 @@ extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n /* in class.c */\n extern tree build_base_path\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n extern tree convert_to_base                     (tree, tree, bool);\n-extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n extern tree build_vfn_ref\t\t\tPARAMS ((tree, tree));\n extern tree get_vtable_decl                     PARAMS ((tree, int));"}, {"sha": "339aba317f93d27ed5d016a784e2d984c8f9455b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -60,7 +60,7 @@ typedef struct priority_info_s {\n \n static void mark_vtable_entries PARAMS ((tree));\n static void grok_function_init PARAMS ((tree, tree));\n-static int finish_vtable_vardecl PARAMS ((tree *, void *));\n+static int maybe_emit_vtables (tree);\n static int is_namespace_ancestor PARAMS ((tree, tree));\n static void add_using_namespace PARAMS ((tree, tree, int));\n static tree ambiguous_decl PARAMS ((tree, tree, tree,int));\n@@ -1658,12 +1658,7 @@ key_method (type)\n        method = TREE_CHAIN (method))\n     if (DECL_VINDEX (method) != NULL_TREE\n \t&& ! DECL_DECLARED_INLINE_P (method)\n-\t&& (! DECL_PURE_VIRTUAL_P (method)\n-#if 0\n-\t    /* This would be nice, but we didn't think of it in time.  */\n-\t    || DECL_DESTRUCTOR_P (method)\n-#endif\n-\t    ))\n+\t&& ! DECL_PURE_VIRTUAL_P (method))\n       return method;\n \n   return NULL_TREE;\n@@ -1805,28 +1800,52 @@ output_vtable_inherit (vars)\n   assemble_vtable_inherit (child_rtx, parent_rtx);\n }\n \n+/* If necessary, write out the vtables for the dynamic class CTYPE.\n+   Returns non-zero if any vtables were emitted.  */\n+\n static int\n-finish_vtable_vardecl (t, data)\n-     tree *t;\n-     void *data ATTRIBUTE_UNUSED;\n+maybe_emit_vtables (tree ctype)\n {\n-  tree vars = *t;\n-  tree ctype = DECL_CONTEXT (vars);\n+  tree vtbl;\n+  tree primary_vtbl;\n+\n+  /* If the vtables for this class have already been emitted there is\n+     nothing more to do.  */\n+  primary_vtbl = CLASSTYPE_VTABLES (ctype);\n+  if (TREE_ASM_WRITTEN (primary_vtbl))\n+    return 0;\n+  /* Ignore dummy vtables made by get_vtable_decl.  */\n+  if (TREE_TYPE (primary_vtbl) == void_type_node)\n+    return 0;\n+\n   import_export_class (ctype);\n-  import_export_vtable (vars, ctype, 1);\n+  import_export_vtable (primary_vtbl, ctype, 1);\n \n-  if (! DECL_EXTERNAL (vars)\n-      && DECL_NEEDED_P (vars)\n-      && ! TREE_ASM_WRITTEN (vars))\n+  /* See if any of the vtables are needed.  */\n+  for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n+    if (!DECL_EXTERNAL (vtbl) && DECL_NEEDED_P (vtbl))\n+      break;\n+  \n+  if (!vtbl)\n+    {\n+      /* If the references to this class' vtables are optimized away,\n+\t still emit the appropriate debugging information.  See\n+\t dfs_debug_mark.  */\n+      if (DECL_COMDAT (primary_vtbl) \n+\t  && CLASSTYPE_DEBUG_REQUESTED (ctype))\n+\tnote_debug_info_needed (ctype);\n+      return 0;\n+    }\n+\n+  /* The ABI requires that we emit all of the vtables if we emit any\n+     of them.  */\n+  for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n     {\n-      if (TREE_TYPE (vars) == void_type_node)\n-        /* It is a dummy vtable made by get_vtable_decl. Ignore it.  */\n-        return 0;\n-      \n       /* Write it out.  */\n-      mark_vtable_entries (vars);\n-      if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n-\tstore_init_value (vars, DECL_INITIAL (vars));\n+      import_export_vtable (vtbl, ctype, 1);\n+      mark_vtable_entries (vtbl);\n+      if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n+\tstore_init_value (vtbl, DECL_INITIAL (vtbl));\n \n       if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n \t{\n@@ -1851,37 +1870,29 @@ finish_vtable_vardecl (t, data)\n \t      `S' get written (which would solve the problem) but that would\n \t      require more intrusive changes to the g++ front end.  */\n \n-\t  DECL_IGNORED_P (vars) = 1;\n+\t  DECL_IGNORED_P (vtbl) = 1;\n \t}\n \n       /* Always make vtables weak.  */\n       if (flag_weak)\n-\tcomdat_linkage (vars);\n+\tcomdat_linkage (vtbl);\n \n-      rest_of_decl_compilation (vars, NULL, 1, 1);\n+      rest_of_decl_compilation (vtbl, NULL, 1, 1);\n \n       if (flag_vtable_gc)\n-\toutput_vtable_inherit (vars);\n+\toutput_vtable_inherit (vtbl);\n \n       /* Because we're only doing syntax-checking, we'll never end up\n \t actually marking the variable as written.  */\n       if (flag_syntax_only)\n-\tTREE_ASM_WRITTEN (vars) = 1;\n-\n-      /* Since we're writing out the vtable here, also write the debug \n-\t info.  */\n-      note_debug_info_needed (ctype);\n-\n-      return 1;\n+\tTREE_ASM_WRITTEN (vtbl) = 1;\n     }\n \n-  /* If the references to this class' vtables were optimized away, still\n-     emit the appropriate debugging information.  See dfs_debug_mark.  */\n-  if (DECL_COMDAT (vars)\n-      && CLASSTYPE_DEBUG_REQUESTED (ctype))\n-    note_debug_info_needed (ctype);\n+  /* Since we're writing out the vtable here, also write the debug\n+     info.  */\n+  note_debug_info_needed (ctype);\n \n-  return 0;\n+  return 1;\n }\n \n /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n@@ -2755,6 +2766,8 @@ finish_file ()\n   \n   do \n     {\n+      tree t;\n+\n       reconsider = 0;\n \n       /* If there are templates that we've put off instantiating, do\n@@ -2764,10 +2777,9 @@ finish_file ()\n       /* Write out virtual tables as required.  Note that writing out\n \t the virtual table for a template class may cause the\n \t instantiation of members of that class.  */\n-      if (walk_vtables (vtable_decl_p,\n-\t\t\tfinish_vtable_vardecl,\n-\t\t\t/*data=*/0))\n-\treconsider = 1;\n+      for (t = dynamic_classes; t; t = TREE_CHAIN (t))\n+\tif (maybe_emit_vtables (TREE_VALUE (t)))\n+\t  reconsider = 1;\n       \n       /* Write out needed type info variables. Writing out one variable\n          might cause others to be needed.  */"}, {"sha": "c14287b02026e469300ebe4ba0a39d270d4e722b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -1955,9 +1955,8 @@ look_for_overrides (type, fndecl)\n   return found;\n }\n \n-/* Look in TYPE for virtual functions with the same signature as FNDECL.\n-   This differs from get_matching_virtual in that it will only return\n-   a function from TYPE.  */\n+/* Look in TYPE for virtual functions with the same signature as\n+   FNDECL.  */\n \n tree\n look_for_overrides_here (type, fndecl)"}, {"sha": "a2b9f53b5caf5b82d6122147a3ec62bfbe632765", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -1,3 +1,9 @@\n+2002-11-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/thunk1.C: New test.\n+\t* g++.dg/abi/thunk2.C: Likewise.\n+\t* g++.dg/abi/vtt1.C: Likewise.\n+\n 2002-11-02  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR optimization/8423"}, {"sha": "c9ad5b478f9c170ae22e181fb2598bbd495536ba", "filename": "gcc/testsuite/g++.dg/abi/thunk1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fthunk1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fthunk1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fthunk1.C?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile { target i?86-*-* } }\n+\n+struct A {\n+  virtual void f ();\n+};\n+\n+struct B : public virtual A {\n+  virtual void f ();\n+};\n+\n+struct C {\n+  virtual void g ();\n+};\n+\n+struct D : public C, public B {\n+  virtual void f ();\n+};\n+\n+void D::f () {}\n+\n+// { dg-final { scan-assembler _ZThn4_N1D1fEv } }\n+// { dg-final { scan-assembler _ZTv0_n12_N1D1fEv } }"}, {"sha": "b1c9788e6d0bc0d56040fd1cb9613d5f95f4ce1f", "filename": "gcc/testsuite/g++.dg/abi/thunk2.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fthunk2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fthunk2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fthunk2.C?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target i?86-*-* } }\n+// { dg-options -w }\n+\n+struct A {\n+  virtual void f2 ();\n+  virtual void f3 ();\n+};\n+\n+struct B : virtual public A {\n+  virtual void f3 ();\n+};\n+\n+struct C : public A, public B {\n+  virtual void f4 ();\n+};\n+\n+struct D : virtual public B, virtual public C, virtual public A \n+{\n+  virtual void f5 ();\n+  virtual void f6 ();\n+  virtual void f3 ();\n+};\n+\n+void D::f3 () {}\n+\n+// { dg-final { scan-assembler _ZTvn4_n20_N1D2f3Ev } }"}, {"sha": "8235c460b97f75635b079e462c8a28b493df0b51", "filename": "gcc/testsuite/g++.dg/abi/vtt1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvtt1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548502d3b1a9d50061b1ee76ec6e94071d77029f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvtt1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvtt1.C?ref=548502d3b1a9d50061b1ee76ec6e94071d77029f", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+struct A {\n+};\n+\n+struct B : virtual public A {\n+};\n+\n+B b;\n+\n+// { dg-final { scan-assembler _ZTT1B } }"}]}