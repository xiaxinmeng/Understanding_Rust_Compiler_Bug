{"sha": "4c7f5feab54c9fe78473a10d6c6f61738770fa63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM3ZjVmZWFiNTRjOWZlNzg0NzNhMTBkNmM2ZjYxNzM4NzcwZmE2Mw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-01-19T21:28:22Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-01-19T21:28:22Z"}, "message": "cfganal.c (compute_dominance_frontiers_1): Replace with new algorithm\n\n2005-01-19  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* cfganal.c (compute_dominance_frontiers_1): Replace with new algorithm\n\t(compute_dominance_frontiers): Ditto.\n\nFrom-SVN: r93922", "tree": {"sha": "30fd0b97abd1b75c251c0fe8dca344ab9566f16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30fd0b97abd1b75c251c0fe8dca344ab9566f16e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c7f5feab54c9fe78473a10d6c6f61738770fa63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7f5feab54c9fe78473a10d6c6f61738770fa63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7f5feab54c9fe78473a10d6c6f61738770fa63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7f5feab54c9fe78473a10d6c6f61738770fa63/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be33b7296925c67e09faeb6d6cb2a7426d05b756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be33b7296925c67e09faeb6d6cb2a7426d05b756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be33b7296925c67e09faeb6d6cb2a7426d05b756"}], "stats": {"total": 105, "additions": 48, "deletions": 57}, "files": [{"sha": "e2554395a66be36cdaf3c9fdf21599d10bc168c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7f5feab54c9fe78473a10d6c6f61738770fa63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7f5feab54c9fe78473a10d6c6f61738770fa63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c7f5feab54c9fe78473a10d6c6f61738770fa63", "patch": "@@ -1,3 +1,8 @@\n+2005-01-19  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* cfganal.c (compute_dominance_frontiers_1): Replace with new algorithm\n+\t(compute_dominance_frontiers): Ditto.\n+\n 2005-01-19  Ralf Corsepius  <ralf.corsepius@rtems.org>\n \n \tPR target/19529"}, {"sha": "a7fe994fa4b1b167f19326c3ca70c8c416694820", "filename": "gcc/cfganal.c", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7f5feab54c9fe78473a10d6c6f61738770fa63/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7f5feab54c9fe78473a10d6c6f61738770fa63/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=4c7f5feab54c9fe78473a10d6c6f61738770fa63", "patch": "@@ -933,80 +933,66 @@ dfs_enumerate_from (basic_block bb, int reverse,\n }\n \n \n-/* Computing the Dominance Frontier:\n+/* Compute dominance frontiers, ala Harvey, Ferrante, et al.\n+   \n+   This algorithm can be found in Timothy Harvey's PhD thesis, at\n+   http://www.cs.rice.edu/~harv/thesis.pdf in the section on iterative\n+   dominance algorithms.\n \n-   As described in Morgan, section 3.5, this may be done simply by\n-   walking the dominator tree bottom-up, computing the frontier for\n-   the children before the parent.  When considering a block B,\n-   there are two cases:\n+   First, we identify each join point, j (any node with more than one\n+   incoming edge is a join point). \n \n-   (1) A flow graph edge leaving B that does not lead to a child\n-   of B in the dominator tree must be a block that is either equal\n-   to B or not dominated by B.  Such blocks belong in the frontier\n-   of B.\n+   We then examine each predecessor, p, of j and walk up the dominator tree\n+   starting at p. \n+   \n+   We stop the walk when we reach j's immediate dominator - j is in the\n+   dominance frontier of each of  the nodes in the walk, except for j's\n+   immediate dominator. Intuitively, all of the rest of j's dominators are\n+   shared by j's predecessors as well.\n+   Since they dominate j, they will not have j in their dominance frontiers.\n+\n+   The number of nodes touched by this algorithm is equal to the size \n+   of the dominance frontiers, no more, no less.\n+*/\n \n-   (2) Consider a block X in the frontier of one of the children C\n-   of B.  If X is not equal to B and is not dominated by B, it\n-   is in the frontier of B.  */\n \n static void\n-compute_dominance_frontiers_1 (bitmap *frontiers, basic_block bb, sbitmap done)\n+compute_dominance_frontiers_1 (bitmap *frontiers)\n {\n-  edge e;\n+  edge p;\n   edge_iterator ei;\n-  basic_block c;\n-\n-  SET_BIT (done, bb->index);\n-\n-  /* Do the frontier of the children first.  Not all children in the\n-     dominator tree (blocks dominated by this one) are children in the\n-     CFG, so check all blocks.  */\n-  for (c = first_dom_son (CDI_DOMINATORS, bb);\n-       c;\n-       c = next_dom_son (CDI_DOMINATORS, c))\n-    {\n-      if (! TEST_BIT (done, c->index))\n-    \tcompute_dominance_frontiers_1 (frontiers, c, done);\n-    }\n-      \n-  /* Find blocks conforming to rule (1) above.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-      if (get_immediate_dominator (CDI_DOMINATORS, e->dest) != bb)\n-\tbitmap_set_bit (frontiers[bb->index], e->dest->index);\n-    }\n-\n-  /* Find blocks conforming to rule (2).  */\n-  for (c = first_dom_son (CDI_DOMINATORS, bb);\n-       c;\n-       c = next_dom_son (CDI_DOMINATORS, c))\n+  basic_block b;\n+  FOR_EACH_BB (b)\n     {\n-      unsigned x;\n-      bitmap_iterator bi;\n-\n-      EXECUTE_IF_SET_IN_BITMAP (frontiers[c->index], 0, x, bi)\n+      if (EDGE_COUNT (b->preds) >= 2)\n \t{\n-\t  if (get_immediate_dominator (CDI_DOMINATORS, BASIC_BLOCK (x)) != bb)\n-\t    bitmap_set_bit (frontiers[bb->index], x);\n+\t  FOR_EACH_EDGE (p, ei, b->preds)\n+\t    {\n+\t      basic_block runner = p->src;\n+\t      basic_block domsb;\n+\t      if (runner == ENTRY_BLOCK_PTR)\n+\t\tcontinue;\n+\t      \n+\t      domsb = get_immediate_dominator (CDI_DOMINATORS, b);\n+\t      while (runner != domsb)\n+\t\t{\n+\t\t  bitmap_set_bit (frontiers[runner->index], \n+\t\t\t\t  b->index);\n+\t\t  runner = get_immediate_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t    runner);\n+\t\t}\n+\t    }\n \t}\n     }\n-}\n-\n+}\t      \n+  \n \n void\n compute_dominance_frontiers (bitmap *frontiers)\n {\n-  sbitmap done = sbitmap_alloc (last_basic_block);\n-\n   timevar_push (TV_DOM_FRONTIERS);\n \n-  sbitmap_zero (done);\n-\n-  compute_dominance_frontiers_1 (frontiers, EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest, done);\n-\n-  sbitmap_free (done);\n+  compute_dominance_frontiers_1 (frontiers);\n \n   timevar_pop (TV_DOM_FRONTIERS);\n }"}]}