{"sha": "490350a11f82ee214aa8dd50b1222f3e7cffe630", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkwMzUwYTExZjgyZWUyMTRhYThkZDUwYjEyMjJmM2U3Y2ZmZTYzMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-25T14:16:42Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-25T17:01:50Z"}, "message": "libstdc++: Remove __memmove wrapper for constexpr algorithms\n\nThe mutating sequence algorithms std::copy, std::copy_backward,\nstd::move and std::move_backward conditionally use __builtin_memmove\nfor trivially copyable types. However, because memmove isn't usable in\nconstant expressions the use of __builtin_memmove is wrapped in a\n__memmove function which replaces __builtin_memmove with a handwritten\nloop when std::is_constant_evaluated() is true.\n\nThis means we have a manual loop for non-trivially copyable cases, and a\ndifferent manual loop for trivially copyable but constexpr cases. The\nlatter loop has incorrect semantics for the {copy,move}_backward cases\nand so isn't used for them. Until earlier today the latter loop also had\nincorrect semantics for the std::move cases, trying to move from const\nrvalues.\n\nThe approach taken by this patch is to remove the __memmove function\nentirely and use the original (and correct) manual loops for the\nconstexpr cases as well as the non-trivially copyable cases. This was\nalready done for move_backward and copy_backward, but was incorrectly\nturning copy_backward into move_backward, by failing to use the _IsMove\nconstant to select the right specialization. This patch also fixes that.\n\n\t* include/bits/ranges_algobase.h (__copy_or_move): Do not use memmove\n\tduring constant evaluation. Call __builtin_memmove directly instead of\n\t__memmove.\n\t(__copy_or_move_backward): Likewise.\n\t* include/bits/stl_algobase.h (__memmove): Remove.\n\t(__copy_move<M, true, random_access_iterator_tag>::__copy_m)\n\t(__copy_move_backward<M, true, random_access_iterator_tag>::__copy_m):\n\tUse __builtin_memmove directly instead of __memmove.\n\t(__copy_move_a2): Do not use memmove during constant evaluation.\n\t(__copy_move_backward_a2): Use _IsMove constant to select correct\n\t__copy_move_backward specialization.\n\t* testsuite/25_algorithms/copy_backward/constexpr.cc: Check for copies\n\tbegin turned into moves during constant evaluation.", "tree": {"sha": "d3b3a9e7fecf510b746fd6f6cf9ccbd810d4a588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3b3a9e7fecf510b746fd6f6cf9ccbd810d4a588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/490350a11f82ee214aa8dd50b1222f3e7cffe630", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490350a11f82ee214aa8dd50b1222f3e7cffe630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/490350a11f82ee214aa8dd50b1222f3e7cffe630", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490350a11f82ee214aa8dd50b1222f3e7cffe630/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfb93d0524615ce15d5f4e132f799fd836099f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb93d0524615ce15d5f4e132f799fd836099f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb93d0524615ce15d5f4e132f799fd836099f59"}], "stats": {"total": 209, "additions": 110, "deletions": 99}, "files": [{"sha": "2adf9cba26fc8adb8947ca6308184b4aea579a63", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=490350a11f82ee214aa8dd50b1222f3e7cffe630", "patch": "@@ -1,5 +1,19 @@\n 2020-02-25  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/ranges_algobase.h (__copy_or_move): Do not use memmove\n+\tduring constant evaluation. Call __builtin_memmove directly instead of\n+\t__memmove.\n+\t(__copy_or_move_backward): Likewise.\n+\t* include/bits/stl_algobase.h (__memmove): Remove.\n+\t(__copy_move<M, true, random_access_iterator_tag>::__copy_m)\n+\t(__copy_move_backward<M, true, random_access_iterator_tag>::__copy_m):\n+\tUse __builtin_memmove directly instead of __memmove.\n+\t(__copy_move_a2): Do not use memmove during constant evaluation.\n+\t(__copy_move_backward_a2): Use _IsMove constant to select correct\n+\t__copy_move_backward specialization.\n+\t* testsuite/25_algorithms/copy_backward/constexpr.cc: Check for copies\n+\tbegin turned into moves during constant evaluation.\n+\n \t* testsuite/25_algorithms/move_backward/93872.cc: Add test left out of\n \tprevious commit.\n "}, {"sha": "feb6c5723dd26220a2270f9e8f8764d10864c570", "filename": "libstdc++-v3/include/bits/ranges_algobase.h", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h?ref=490350a11f82ee214aa8dd50b1222f3e7cffe630", "patch": "@@ -248,37 +248,41 @@ namespace ranges\n \t}\n       else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n \t{\n-\t  using _ValueTypeI = iter_value_t<_Iter>;\n-\t  using _ValueTypeO = typename iterator_traits<_Out>::value_type;\n-\t  constexpr bool __use_memmove\n-\t    = (is_trivially_copyable_v<_ValueTypeI>\n-\t       && is_same_v<_ValueTypeI, _ValueTypeO>\n-\t       && is_pointer_v<_Iter>\n-\t       && is_pointer_v<_Out>);\n-\n-\t  if constexpr (__use_memmove)\n+#ifdef __cpp_lib_is_constant_evaluated\n+\t  if (!std::is_constant_evaluated())\n+#endif\n \t    {\n-\t      static_assert(_IsMove\n-\t\t\t    ? is_move_assignable_v<_ValueTypeI>\n-\t\t\t    : is_copy_assignable_v<_ValueTypeI>);\n-\t      auto __num = __last - __first;\n-\t      if (__num)\n-\t\tstd::__memmove<_IsMove>(__result, __first, __num);\n-\t      return {__first + __num, __result + __num};\n-\t    }\n-\t  else\n-\t    {\n-\t      for (auto __n = __last - __first; __n > 0; --__n)\n+\t      using _ValueTypeI = iter_value_t<_Iter>;\n+\t      using _ValueTypeO = typename iterator_traits<_Out>::value_type;\n+\t      constexpr bool __use_memmove\n+\t\t= (is_trivially_copyable_v<_ValueTypeI>\n+\t\t    && is_same_v<_ValueTypeI, _ValueTypeO>\n+\t\t    && is_pointer_v<_Iter>\n+\t\t    && is_pointer_v<_Out>);\n+\n+\t      if constexpr (__use_memmove)\n \t\t{\n-\t\t  if constexpr (_IsMove)\n-\t\t    *__result = std::move(*__first);\n-\t\t  else\n-\t\t    *__result = *__first;\n-\t\t  ++__first;\n-\t\t  ++__result;\n+\t\t  static_assert(_IsMove\n+\t\t      ? is_move_assignable_v<_ValueTypeI>\n+\t\t      : is_copy_assignable_v<_ValueTypeI>);\n+\t\t  auto __num = __last - __first;\n+\t\t  if (__num)\n+\t\t    __builtin_memmove(__result, __first,\n+\t\t\tsizeof(_ValueTypeI) * __num);\n+\t\t  return {__first + __num, __result + __num};\n \t\t}\n-\t      return {std::move(__first), std::move(__result)};\n \t    }\n+\n+\t  for (auto __n = __last - __first; __n > 0; --__n)\n+\t    {\n+\t      if constexpr (_IsMove)\n+\t\t*__result = std::move(*__first);\n+\t      else\n+\t\t*__result = *__first;\n+\t      ++__first;\n+\t      ++__result;\n+\t    }\n+\t  return {std::move(__first), std::move(__result)};\n \t}\n       else\n \t{\n@@ -385,39 +389,43 @@ namespace ranges\n \t}\n       else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n \t{\n-\t  using _ValueTypeI = iter_value_t<_Iter>;\n-\t  using _ValueTypeO = typename iterator_traits<_Out>::value_type;\n-\t  constexpr bool __use_memmove\n-\t    = (is_trivially_copyable_v<_ValueTypeI>\n-\t       && is_same_v<_ValueTypeI, _ValueTypeO>\n-\t       && is_pointer_v<_Iter>\n-\t       && is_pointer_v<_Out>);\n-\t  if constexpr (__use_memmove)\n-\t    {\n-\t      static_assert(_IsMove\n-\t\t\t    ? is_move_assignable_v<_ValueTypeI>\n-\t\t\t    : is_copy_assignable_v<_ValueTypeI>);\n-\t      auto __num = __last - __first;\n-\t      if (__num)\n-\t\tstd::__memmove<_IsMove>(__result - __num, __first, __num);\n-\t      return {__first + __num, __result - __num};\n-\t    }\n-\t  else\n+#ifdef __cpp_lib_is_constant_evaluated\n+\t  if (!std::is_constant_evaluated())\n+#endif\n \t    {\n-\t      auto __lasti = ranges::next(__first, __last);\n-\t      auto __tail = __lasti;\n-\n-\t      for (auto __n = __last - __first; __n > 0; --__n)\n+\t      using _ValueTypeI = iter_value_t<_Iter>;\n+\t      using _ValueTypeO = typename iterator_traits<_Out>::value_type;\n+\t      constexpr bool __use_memmove\n+\t\t= (is_trivially_copyable_v<_ValueTypeI>\n+\t\t    && is_same_v<_ValueTypeI, _ValueTypeO>\n+\t\t    && is_pointer_v<_Iter>\n+\t\t    && is_pointer_v<_Out>);\n+\t      if constexpr (__use_memmove)\n \t\t{\n-\t\t  --__tail;\n-\t\t  --__result;\n-\t\t  if constexpr (_IsMove)\n-\t\t    *__result = std::move(*__tail);\n-\t\t  else\n-\t\t    *__result = *__tail;\n+\t\t  static_assert(_IsMove\n+\t\t      ? is_move_assignable_v<_ValueTypeI>\n+\t\t      : is_copy_assignable_v<_ValueTypeI>);\n+\t\t  auto __num = __last - __first;\n+\t\t  if (__num)\n+\t\t    __builtin_memmove(__result - __num, __first,\n+\t\t\t\t      sizeof(_ValueTypeI) * __num);\n+\t\t  return {__first + __num, __result - __num};\n \t\t}\n-\t      return {std::move(__lasti), std::move(__result)};\n \t    }\n+\n+\t  auto __lasti = ranges::next(__first, __last);\n+\t  auto __tail = __lasti;\n+\n+\t  for (auto __n = __last - __first; __n > 0; --__n)\n+\t    {\n+\t      --__tail;\n+\t      --__result;\n+\t      if constexpr (_IsMove)\n+\t\t*__result = std::move(*__tail);\n+\t      else\n+\t\t*__result = *__tail;\n+\t    }\n+\t  return {std::move(__lasti), std::move(__result)};\n \t}\n       else\n \t{"}, {"sha": "268569336b0fe87d8b8f28911cd0c4fb058cb872", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=490350a11f82ee214aa8dd50b1222f3e7cffe630", "patch": "@@ -80,39 +80,6 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  /*\n-   * A constexpr wrapper for __builtin_memmove.\n-   * @param __num The number of elements of type _Tp (not bytes).\n-   */\n-  template<bool _IsMove, typename _Tp>\n-    _GLIBCXX14_CONSTEXPR\n-    inline void*\n-    __memmove(_Tp* __dst, const _Tp* __src, size_t __num)\n-    {\n-#ifdef __cpp_lib_is_constant_evaluated\n-      if (std::is_constant_evaluated())\n-\t{\n-\t  for(; __num > 0; --__num)\n-\t    {\n-\t      if constexpr (_IsMove)\n-\t\t// This const_cast looks unsafe, but we only use this function\n-\t\t// for trivially-copyable types, which means this assignment\n-\t\t// is trivial and so doesn't alter the source anyway.\n-\t\t// See PR 93872 for why it's needed.\n-\t\t*__dst = std::move(*const_cast<_Tp*>(__src));\n-\t      else\n-\t\t*__dst = *__src;\n-\t      ++__src;\n-\t      ++__dst;\n-\t    }\n-\t  return __dst;\n-\t}\n-      else\n-#endif\n-\treturn __builtin_memmove(__dst, __src, sizeof(_Tp) * __num);\n-      return __dst;\n-    }\n-\n   /*\n    * A constexpr wrapper for __builtin_memcmp.\n    * @param __num The number of elements of type _Tp (not bytes).\n@@ -453,7 +420,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \t  const ptrdiff_t _Num = __last - __first;\n \t  if (_Num)\n-\t    std::__memmove<_IsMove>(__result, __first, _Num);\n+\t    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);\n \t  return __result + _Num;\n \t}\n     };\n@@ -492,9 +459,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline _OI\n     __copy_move_a2(_II __first, _II __last, _OI __result)\n     {\n+      typedef typename iterator_traits<_II>::iterator_category _Category;\n+#ifdef __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn std::__copy_move<_IsMove, false, _Category>::\n+\t  __copy_m(__first, __last, __result);\n+#endif\n       typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n       typedef typename iterator_traits<_OI>::value_type _ValueTypeO;\n-      typedef typename iterator_traits<_II>::iterator_category _Category;\n       const bool __simple = (__is_trivially_copyable(_ValueTypeI)\n \t\t\t     && __is_pointer<_II>::__value\n \t\t\t     && __is_pointer<_OI>::__value\n@@ -719,7 +691,7 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n #endif\n \t  const ptrdiff_t _Num = __last - __first;\n \t  if (_Num)\n-\t    std::__memmove<_IsMove>(__result - _Num, __first, _Num);\n+\t    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n \t  return __result - _Num;\n \t}\n     };\n@@ -729,20 +701,19 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n     inline _BI2\n     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)\n     {\n+      typedef typename iterator_traits<_BI1>::iterator_category _Category;\n+#ifdef __cpp_lib_is_constant_evaluated\n+      if (std::is_constant_evaluated())\n+\treturn std::__copy_move_backward<_IsMove, false, _Category>::\n+\t  __copy_move_b(__first, __last, __result);\n+#endif\n       typedef typename iterator_traits<_BI1>::value_type _ValueType1;\n       typedef typename iterator_traits<_BI2>::value_type _ValueType2;\n-      typedef typename iterator_traits<_BI1>::iterator_category _Category;\n       const bool __simple = (__is_trivially_copyable(_ValueType1)\n \t\t\t     && __is_pointer<_BI1>::__value\n \t\t\t     && __is_pointer<_BI2>::__value\n \t\t\t     && __are_same<_ValueType1, _ValueType2>::__value);\n \n-#ifdef __cpp_lib_is_constant_evaluated\n-      if (std::is_constant_evaluated())\n-\treturn std::__copy_move_backward<true, false,\n-\t\t\t      _Category>::__copy_move_b(__first, __last,\n-\t\t\t\t\t\t\t__result);\n-#endif\n       return std::__copy_move_backward<_IsMove, __simple,\n \t\t\t\t       _Category>::__copy_move_b(__first,\n \t\t\t\t\t\t\t\t __last,"}, {"sha": "704dcf513c042b1dd62a92bc5fdcea4cad7b9322", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_backward/constexpr.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/490350a11f82ee214aa8dd50b1222f3e7cffe630/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2Fconstexpr.cc?ref=490350a11f82ee214aa8dd50b1222f3e7cffe630", "patch": "@@ -34,3 +34,21 @@ test()\n }\n \n static_assert(test());\n+\n+constexpr bool\n+test02()\n+{\n+  struct X\n+  {\n+    X() = default;\n+    X& operator=(const X&) = default;\n+    constexpr X& operator=(X&& x) { i = x.i; x.i = 0; return *this; }\n+    int i = 1;\n+  };\n+\n+  X from[1], to[1];\n+  std::copy_backward(std::begin(from), std::end(from), std::end(to));\n+  return from[0].i == 1;\n+}\n+\n+static_assert(test02());"}]}