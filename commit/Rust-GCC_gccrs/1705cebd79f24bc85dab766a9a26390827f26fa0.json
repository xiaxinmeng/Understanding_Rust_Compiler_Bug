{"sha": "1705cebd79f24bc85dab766a9a26390827f26fa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcwNWNlYmQ3OWYyNGJjODVkYWI3NjZhOWEyNjM5MDgyN2YyNmZhMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-11-16T08:28:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-16T08:28:50Z"}, "message": "re PR sanitizer/77823 (ICE: in ubsan_encode_value, at ubsan.c:137 with -fsanitize=undefined and vector types)\n\n\tPR sanitizer/77823\n\t* ubsan.c (ubsan_build_overflow_builtin): Add DATAP argument, if\n\tit points to non-NULL tree, use it instead of ubsan_create_data.\n\t(instrument_si_overflow): Handle vector signed integer overflow\n\tchecking.\n\t* ubsan.h (ubsan_build_overflow_builtin): Add DATAP argument.\n\t* tree-vrp.c (simplify_internal_call_using_ranges): Punt for\n\tvector IFN_UBSAN_CHECK_*.\n\t* internal-fn.c (expand_addsub_overflow): Add DATAP argument,\n\tpass it through to ubsan_build_overflow_builtin.\n\t(expand_neg_overflow, expand_mul_overflow): Likewise.\n\t(expand_vector_ubsan_overflow): New function.\n\t(expand_UBSAN_CHECK_ADD, expand_UBSAN_CHECK_SUB,\n\texpand_UBSAN_CHECK_MUL): Use tit for vector arithmetics.\n\t(expand_arith_overflow): Adjust expand_*_overflow callers.\n\n\t* c-c++-common/ubsan/overflow-vec-1.c: New test.\n\t* c-c++-common/ubsan/overflow-vec-2.c: New test.\n\nFrom-SVN: r242469", "tree": {"sha": "9fffaa05cb502bdcbfd169cbadc603c4b6d31f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fffaa05cb502bdcbfd169cbadc603c4b6d31f2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1705cebd79f24bc85dab766a9a26390827f26fa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1705cebd79f24bc85dab766a9a26390827f26fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1705cebd79f24bc85dab766a9a26390827f26fa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1705cebd79f24bc85dab766a9a26390827f26fa0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00178b98eb609827f8e799931f55288ab2f58ee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00178b98eb609827f8e799931f55288ab2f58ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00178b98eb609827f8e799931f55288ab2f58ee1"}], "stats": {"total": 560, "additions": 530, "deletions": 30}, "files": [{"sha": "d54016fdcdb2479c670b2a81e99c8d09298a1121", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -1,3 +1,21 @@\n+2016-11-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/77823\n+\t* ubsan.c (ubsan_build_overflow_builtin): Add DATAP argument, if\n+\tit points to non-NULL tree, use it instead of ubsan_create_data.\n+\t(instrument_si_overflow): Handle vector signed integer overflow\n+\tchecking.\n+\t* ubsan.h (ubsan_build_overflow_builtin): Add DATAP argument.\n+\t* tree-vrp.c (simplify_internal_call_using_ranges): Punt for\n+\tvector IFN_UBSAN_CHECK_*.\n+\t* internal-fn.c (expand_addsub_overflow): Add DATAP argument,\n+\tpass it through to ubsan_build_overflow_builtin.\n+\t(expand_neg_overflow, expand_mul_overflow): Likewise.\n+\t(expand_vector_ubsan_overflow): New function.\n+\t(expand_UBSAN_CHECK_ADD, expand_UBSAN_CHECK_SUB,\n+\texpand_UBSAN_CHECK_MUL): Use tit for vector arithmetics.\n+\t(expand_arith_overflow): Adjust expand_*_overflow callers.\n+\n 2016-11-16  Matthias Klose  <doko@ubuntu.com>\n \n \t* doc/install.texi: Remove references to java/libjava."}, {"sha": "ca347c59cfb693a82a9f1ffa9efba62647acb6bf", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 170, "deletions": 19, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ubsan.h\"\n #include \"recog.h\"\n #include \"builtins.h\"\n+#include \"optabs-tree.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -513,7 +514,7 @@ expand_ubsan_result_store (rtx target, rtx res)\n static void\n expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\ttree arg0, tree arg1, bool unsr_p, bool uns0_p,\n-\t\t\tbool uns1_p, bool is_ubsan)\n+\t\t\tbool uns1_p, bool is_ubsan, tree *datap)\n {\n   rtx res, target = NULL_RTX;\n   tree fn;\n@@ -929,7 +930,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       /* Expand the ubsan builtin call.  */\n       push_temp_slots ();\n       fn = ubsan_build_overflow_builtin (code, loc, TREE_TYPE (arg0),\n-\t\t\t\t\t arg0, arg1);\n+\t\t\t\t\t arg0, arg1, datap);\n       expand_normal (fn);\n       pop_temp_slots ();\n       do_pending_stack_adjust ();\n@@ -958,7 +959,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n /* Add negate overflow checking to the statement STMT.  */\n \n static void\n-expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan)\n+expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n+\t\t     tree *datap)\n {\n   rtx res, op1;\n   tree fn;\n@@ -1024,7 +1026,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan)\n       /* Expand the ubsan builtin call.  */\n       push_temp_slots ();\n       fn = ubsan_build_overflow_builtin (NEGATE_EXPR, loc, TREE_TYPE (arg1),\n-\t\t\t\t\t arg1, NULL_TREE);\n+\t\t\t\t\t arg1, NULL_TREE, datap);\n       expand_normal (fn);\n       pop_temp_slots ();\n       do_pending_stack_adjust ();\n@@ -1048,7 +1050,8 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan)\n \n static void\n expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n-\t\t     bool unsr_p, bool uns0_p, bool uns1_p, bool is_ubsan)\n+\t\t     bool unsr_p, bool uns0_p, bool uns1_p, bool is_ubsan,\n+\t\t     tree *datap)\n {\n   rtx res, op0, op1;\n   tree fn, type;\n@@ -1685,7 +1688,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       /* Expand the ubsan builtin call.  */\n       push_temp_slots ();\n       fn = ubsan_build_overflow_builtin (MULT_EXPR, loc, TREE_TYPE (arg0),\n-\t\t\t\t\t arg0, arg1);\n+\t\t\t\t\t arg0, arg1, datap);\n       expand_normal (fn);\n       pop_temp_slots ();\n       do_pending_stack_adjust ();\n@@ -1734,6 +1737,145 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     }\n }\n \n+/* Expand UBSAN_CHECK_* internal function if it has vector operands.  */\n+\n+static void\n+expand_vector_ubsan_overflow (location_t loc, enum tree_code code, tree lhs,\n+\t\t\t      tree arg0, tree arg1)\n+{\n+  int cnt = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));\n+  rtx_code_label *loop_lab = NULL;\n+  rtx cntvar = NULL_RTX;\n+  tree cntv = NULL_TREE;\n+  tree eltype = TREE_TYPE (TREE_TYPE (arg0));\n+  tree sz = TYPE_SIZE (eltype);\n+  tree data = NULL_TREE;\n+  tree resv = NULL_TREE;\n+  rtx lhsr = NULL_RTX;\n+  rtx resvr = NULL_RTX;\n+\n+  if (lhs)\n+    {\n+      optab op;\n+      lhsr = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (GET_MODE (lhsr) == BLKmode\n+\t  || (op = optab_for_tree_code (code, TREE_TYPE (arg0),\n+\t\t\t\t\toptab_default)) == unknown_optab\n+\t  || (optab_handler (op, TYPE_MODE (TREE_TYPE (arg0)))\n+\t      == CODE_FOR_nothing))\n+\t{\n+\t  if (MEM_P (lhsr))\n+\t    resv = make_tree (TREE_TYPE (lhs), lhsr);\n+\t  else\n+\t    {\n+\t      resvr = assign_temp (TREE_TYPE (lhs), 1, 1);\n+\t      resv = make_tree (TREE_TYPE (lhs), resvr);\n+\t    }\n+\t}\n+    }\n+  if (cnt > 4)\n+    {\n+      do_pending_stack_adjust ();\n+      loop_lab = gen_label_rtx ();\n+      cntvar = gen_reg_rtx (TYPE_MODE (sizetype));\n+      cntv = make_tree (sizetype, cntvar);\n+      emit_move_insn (cntvar, const0_rtx);\n+      emit_label (loop_lab);\n+    }\n+  if (TREE_CODE (arg0) != VECTOR_CST)\n+    {\n+      rtx arg0r = expand_normal (arg0);\n+      arg0 = make_tree (TREE_TYPE (arg0), arg0r);\n+    }\n+  if (TREE_CODE (arg1) != VECTOR_CST)\n+    {\n+      rtx arg1r = expand_normal (arg1);\n+      arg1 = make_tree (TREE_TYPE (arg1), arg1r);\n+    }\n+  for (int i = 0; i < (cnt > 4 ? 1 : cnt); i++)\n+    {\n+      tree op0, op1, res = NULL_TREE;\n+      if (cnt > 4)\n+\t{\n+\t  tree atype = build_array_type_nelts (eltype, cnt);\n+\t  op0 = fold_build1_loc (loc, VIEW_CONVERT_EXPR, atype, arg0);\n+\t  op0 = build4_loc (loc, ARRAY_REF, eltype, op0, cntv,\n+\t\t\t    NULL_TREE, NULL_TREE);\n+\t  op1 = fold_build1_loc (loc, VIEW_CONVERT_EXPR, atype, arg1);\n+\t  op1 = build4_loc (loc, ARRAY_REF, eltype, op1, cntv,\n+\t\t\t    NULL_TREE, NULL_TREE);\n+\t  if (resv)\n+\t    {\n+\t      res = fold_build1_loc (loc, VIEW_CONVERT_EXPR, atype, resv);\n+\t      res = build4_loc (loc, ARRAY_REF, eltype, res, cntv,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree bitpos = bitsize_int (tree_to_uhwi (sz) * i);\n+\t  op0 = fold_build3_loc (loc, BIT_FIELD_REF, eltype, arg0, sz, bitpos);\n+\t  op1 = fold_build3_loc (loc, BIT_FIELD_REF, eltype, arg1, sz, bitpos);\n+\t  if (resv)\n+\t    res = fold_build3_loc (loc, BIT_FIELD_REF, eltype, resv, sz,\n+\t\t\t\t   bitpos);\n+\t}\n+      switch (code)\n+\t{\n+\tcase PLUS_EXPR:\n+\t  expand_addsub_overflow (loc, PLUS_EXPR, res, op0, op1,\n+\t\t\t\t  false, false, false, true, &data);\n+\t  break;\n+\tcase MINUS_EXPR:\n+\t  if (cnt > 4 ? integer_zerop (arg0) : integer_zerop (op0))\n+\t    expand_neg_overflow (loc, res, op1, true, &data);\n+\t  else\n+\t    expand_addsub_overflow (loc, MINUS_EXPR, res, op0, op1,\n+\t\t\t\t    false, false, false, true, &data);\n+\t  break;\n+\tcase MULT_EXPR:\n+\t  expand_mul_overflow (loc, res, op0, op1, false, false, false,\n+\t\t\t       true, &data);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  if (cnt > 4)\n+    {\n+      struct separate_ops ops;\n+      ops.code = PLUS_EXPR;\n+      ops.type = TREE_TYPE (cntv);\n+      ops.op0 = cntv;\n+      ops.op1 = build_int_cst (TREE_TYPE (cntv), 1);\n+      ops.op2 = NULL_TREE;\n+      ops.location = loc;\n+      rtx ret = expand_expr_real_2 (&ops, cntvar, TYPE_MODE (sizetype),\n+\t\t\t\t    EXPAND_NORMAL);\n+      if (ret != cntvar)\n+\temit_move_insn (cntvar, ret);\n+      do_compare_rtx_and_jump (cntvar, GEN_INT (cnt), NE, false,\n+\t\t\t       TYPE_MODE (sizetype), NULL_RTX, NULL, loop_lab,\n+\t\t\t       PROB_VERY_LIKELY);\n+    }\n+  if (lhs && resv == NULL_TREE)\n+    {\n+      struct separate_ops ops;\n+      ops.code = code;\n+      ops.type = TREE_TYPE (arg0);\n+      ops.op0 = arg0;\n+      ops.op1 = arg1;\n+      ops.op2 = NULL_TREE;\n+      ops.location = loc;\n+      rtx ret = expand_expr_real_2 (&ops, lhsr, TYPE_MODE (TREE_TYPE (arg0)),\n+\t\t\t\t    EXPAND_NORMAL);\n+      if (ret != lhsr)\n+\temit_move_insn (lhsr, ret);\n+    }\n+  else if (resvr)\n+    emit_move_insn (lhsr, resvr);\n+}\n+\n /* Expand UBSAN_CHECK_ADD call STMT.  */\n \n static void\n@@ -1743,8 +1885,11 @@ expand_UBSAN_CHECK_ADD (internal_fn, gcall *stmt)\n   tree lhs = gimple_call_lhs (stmt);\n   tree arg0 = gimple_call_arg (stmt, 0);\n   tree arg1 = gimple_call_arg (stmt, 1);\n-  expand_addsub_overflow (loc, PLUS_EXPR, lhs, arg0, arg1,\n-\t\t\t  false, false, false, true);\n+  if (VECTOR_TYPE_P (TREE_TYPE (arg0)))\n+    expand_vector_ubsan_overflow (loc, PLUS_EXPR, lhs, arg0, arg1);\n+  else\n+    expand_addsub_overflow (loc, PLUS_EXPR, lhs, arg0, arg1,\n+\t\t\t    false, false, false, true, NULL);\n }\n \n /* Expand UBSAN_CHECK_SUB call STMT.  */\n@@ -1756,11 +1901,13 @@ expand_UBSAN_CHECK_SUB (internal_fn, gcall *stmt)\n   tree lhs = gimple_call_lhs (stmt);\n   tree arg0 = gimple_call_arg (stmt, 0);\n   tree arg1 = gimple_call_arg (stmt, 1);\n-  if (integer_zerop (arg0))\n-    expand_neg_overflow (loc, lhs, arg1, true);\n+  if (VECTOR_TYPE_P (TREE_TYPE (arg0)))\n+    expand_vector_ubsan_overflow (loc, MINUS_EXPR, lhs, arg0, arg1);\n+  else if (integer_zerop (arg0))\n+    expand_neg_overflow (loc, lhs, arg1, true, NULL);\n   else\n     expand_addsub_overflow (loc, MINUS_EXPR, lhs, arg0, arg1,\n-\t\t\t    false, false, false, true);\n+\t\t\t    false, false, false, true, NULL);\n }\n \n /* Expand UBSAN_CHECK_MUL call STMT.  */\n@@ -1772,7 +1919,11 @@ expand_UBSAN_CHECK_MUL (internal_fn, gcall *stmt)\n   tree lhs = gimple_call_lhs (stmt);\n   tree arg0 = gimple_call_arg (stmt, 0);\n   tree arg1 = gimple_call_arg (stmt, 1);\n-  expand_mul_overflow (loc, lhs, arg0, arg1, false, false, false, true);\n+  if (VECTOR_TYPE_P (TREE_TYPE (arg0)))\n+    expand_vector_ubsan_overflow (loc, MULT_EXPR, lhs, arg0, arg1);\n+  else\n+    expand_mul_overflow (loc, lhs, arg0, arg1, false, false, false, true,\n+\t\t\t NULL);\n }\n \n /* Helper function for {ADD,SUB,MUL}_OVERFLOW call stmt expansion.  */\n@@ -1864,17 +2015,17 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n \t    case MINUS_EXPR:\n \t      if (integer_zerop (arg0) && !unsr_p)\n \t\t{\n-\t\t  expand_neg_overflow (loc, lhs, arg1, false);\n+\t\t  expand_neg_overflow (loc, lhs, arg1, false, NULL);\n \t\t  return;\n \t\t}\n \t      /* FALLTHRU */\n \t    case PLUS_EXPR:\n-\t      expand_addsub_overflow (loc, code, lhs, arg0, arg1,\n-\t\t\t\t      unsr_p, unsr_p, unsr_p, false);\n+\t      expand_addsub_overflow (loc, code, lhs, arg0, arg1, unsr_p,\n+\t\t\t\t      unsr_p, unsr_p, false, NULL);\n \t      return;\n \t    case MULT_EXPR:\n-\t      expand_mul_overflow (loc, lhs, arg0, arg1,\n-\t\t\t\t   unsr_p, unsr_p, unsr_p, false);\n+\t      expand_mul_overflow (loc, lhs, arg0, arg1, unsr_p,\n+\t\t\t\t   unsr_p, unsr_p, false, NULL);\n \t      return;\n \t    default:\n \t      gcc_unreachable ();\n@@ -1916,10 +2067,10 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n \t  arg1 = fold_convert_loc (loc, types[uns1_p], arg1);\n \t  if (code != MULT_EXPR)\n \t    expand_addsub_overflow (loc, code, lhs, arg0, arg1, unsr_p,\n-\t\t\t\t    uns0_p, uns1_p, false);\n+\t\t\t\t    uns0_p, uns1_p, false, NULL);\n \t  else\n \t    expand_mul_overflow (loc, lhs, arg0, arg1, unsr_p,\n-\t\t\t\t uns0_p, uns1_p, false);\n+\t\t\t\t uns0_p, uns1_p, false, NULL);\n \t  return;\n \t}\n "}, {"sha": "2192d5a702a055ec76b534b81d3694cc49692962", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -1,3 +1,9 @@\n+2016-11-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/77823\n+\t* c-c++-common/ubsan/overflow-vec-1.c: New test.\n+\t* c-c++-common/ubsan/overflow-vec-2.c: New test.\n+\n 2016-11-15  Marek Polacek  <polacek@redhat.com>\n \n \t* g++.dg/cpp1z/init-statement6.C: Rename a function."}, {"sha": "31d589c15cab4ed55290bbf19f60b300350b81c4", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-vec-1.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-vec-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-vec-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-vec-1.c?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -0,0 +1,144 @@\n+/* { dg-do run } */\n+/* { dg-options \"-Wno-psabi -fsanitize=signed-integer-overflow -Wno-unused-variable -fno-sanitize-recover=signed-integer-overflow\" } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SCHAR_MIN (-__SCHAR_MAX__ - 1)\n+#define SHRT_MAX __SHRT_MAX__\n+#define SHRT_MIN (-__SHRT_MAX__ - 1)\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+typedef signed char VC __attribute__((vector_size (16)));\n+typedef short VS __attribute__((vector_size (8 * sizeof (short))));\n+typedef int VI __attribute__((vector_size (4 * sizeof (int))));\n+typedef int VI2 __attribute__((vector_size (16 * sizeof (int))));\n+\n+void __attribute__((noinline,noclone))\n+checkvc (VC i, VC j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VC)))\n+    __builtin_abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+checkvs (VS i, VS j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VS)))\n+    __builtin_abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+checkvi (VI i, VI j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VI)))\n+    __builtin_abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+checkvi2 (VI2 i, VI2 j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VI2)))\n+    __builtin_abort ();\n+}\n+\n+VI __attribute__((noinline,noclone))\n+foo (VI i)\n+{\n+  return -i;\n+}\n+\n+VS __attribute__((noinline,noclone))\n+bar (VS i, VS j)\n+{\n+  return i + j;\n+}\n+\n+int\n+main (void)\n+{\n+  /* Check that for a vector operation, only the first element with UB is reported.  */\n+  volatile VC a = (VC) { 0, SCHAR_MAX - 2, SCHAR_MAX - 2, 3, 2, 3, 4, 5,  0, 7,  1,  2,  3, 4,  SCHAR_MAX - 13, SCHAR_MAX };\n+  volatile VC b = (VC) { 5, 2,\t\t   1,\t\t  5, 0, 1, 2, 7,  8, 9,  10, 11, 6, -2, 13,\t        0 };\n+  volatile VC k = b + a;\n+  checkvc (k,\t  (VC) { 5, SCHAR_MAX,     SCHAR_MAX - 1, 8, 2, 4, 6, 12, 8, 16, 11, 13, 9, 2,  SCHAR_MAX,      SCHAR_MAX });\n+  k = a + b;\n+  checkvc (k,     (VC) { 5, SCHAR_MAX,     SCHAR_MAX - 1, 8, 2, 4, 6, 12, 8, 16, 11, 13, 9, 2,  SCHAR_MAX,      SCHAR_MAX });\n+\n+  volatile VS c = (VS) { 0, SHRT_MAX - 2, SHRT_MAX - 2, 3, 3, 4,  SHRT_MAX - 13, SHRT_MAX };\n+  volatile VS d = (VS) { 5, 2,\t\t  -3,\t\t5, 6, -2, 13,\t         -1 };\n+  volatile VS l = d + c;\n+  checkvs (l,\t  (VS) { 5, SHRT_MAX,     SHRT_MAX - 5, 8, 9, 2,  SHRT_MAX,      SHRT_MAX - 1 });\n+  l = bar (c, d);\n+  checkvs (l,     (VS) { 5, SHRT_MAX,     SHRT_MAX - 5, 8, 9, 2,  SHRT_MAX,      SHRT_MAX - 1 });\n+\n+  volatile VI e = (VI) { INT_MAX - 4, INT_MAX - 5, INT_MAX - 13, INT_MAX };\n+  volatile VI f = (VI) { 4,\t      -6,\t   13,\t         0 };\n+  volatile VI m = f + e;\n+  checkvi (m,\t  (VI) { INT_MAX,     INT_MAX - 11,INT_MAX,      INT_MAX });\n+  m = e + f;\n+  checkvi (m,     (VI) { INT_MAX,     INT_MAX - 11,INT_MAX,      INT_MAX });\n+\n+  volatile VI2 g = (VI2) { 0, INT_MAX - 2, INT_MAX - 2, 3, 3, 4,  INT_MAX - 13, INT_MAX };\n+  volatile VI2 h = (VI2) { 5, 2,\t   -5,\t\t5, 6, -2, 13,\t        -1 };\n+  volatile VI2 n = h + g;\n+  checkvi2 (n,\t   (VI2) { 5, INT_MAX,     INT_MAX - 7, 8, 9, 2,  INT_MAX,      INT_MAX - 1 });\n+  n = g + h;\n+  checkvi2 (n,     (VI2) { 5, INT_MAX,     INT_MAX - 7, 8, 9, 2,  INT_MAX,      INT_MAX - 1 });\n+\n+  volatile VC a2 = k - b;\n+  checkvc (a2, a);\n+  volatile VC b2 = k - a;\n+  checkvc (b2, b);\n+\n+  volatile VS c2 = l - d;\n+  checkvs (c2, c);\n+  volatile VS d2 = l - c;\n+  checkvs (d2, d);\n+\n+  volatile VI e2 = m - f;\n+  checkvi (e2, e);\n+  volatile VI f2 = m - e;\n+  checkvi (f2, f);\n+\n+  volatile VI2 g2 = n - h;\n+  checkvi2 (g2, g);\n+  volatile VI2 h2 = n - g;\n+  checkvi2 (h2, h);\n+\n+  a\t    = (VC) { 0,         SCHAR_MAX / 4, SCHAR_MAX / 4, 3, 2, 3, 4, 5, 0, 7, 1, 2, 3, 4, SCHAR_MAX - 13, SCHAR_MAX };\n+  b\t    = (VC) { SCHAR_MAX, 4,\t       3,\t      2, 3, 4, 5, 2, 9, 2, 9, 1, 0, 8, 1,\t       1 };\n+  k = a * b;\n+  checkvc (k, (VC) { 0,\t\t124,\t       93,\t      6, 6,12,20,10, 0,14, 9, 2, 0,32, SCHAR_MAX - 13, SCHAR_MAX });\n+\n+  c\t    = (VS) { 0,\t\tSHRT_MAX / 8, SHRT_MAX / 7, 5, 8, 9, SHRT_MAX - 10, SHRT_MAX };\n+  d\t    = (VS) { SHRT_MAX,  8,\t      6,\t    2, 3, 4, 1,\t\t    1 };\n+  l = c * d;\n+  checkvs (l, (VS) { 0,\t\t32760,\t      28086,\t   10,24,36, SHRT_MAX - 10, SHRT_MAX });\n+\n+  e\t    = (VI) { INT_MAX,\tINT_MAX / 5,  INT_MAX / 6, INT_MAX };\n+  f\t    = (VI) { 0,\t\t5,\t      5,\t   1 };\n+  m = e * f;\n+  checkvi (m, (VI) { 0,\t\t2147483645,   1789569705,  INT_MAX });\n+\n+  g\t    = (VI2) { INT_MAX,\tINT_MAX / 9,  INT_MAX / 8, 5, 6, 7, 8, INT_MAX };\n+  h\t    = (VI2) { 0,\t8,\t      8,\t   2, 3, 4, 5, 1 };\n+  n = g * h;\n+  checkvi2 (n,(VI2) { 0,\t1908874352,   2147483640, 10,18,28,40, INT_MAX });\n+\n+  a\t    = (VC) { 5, 7, 8, 9, SCHAR_MAX, SCHAR_MIN + 1, 24, 32, 0, 1, 2, 3, 4, 5, SCHAR_MAX, SCHAR_MIN + 2 };\n+  k = -a;\n+  checkvc (k, (VC) {-5,-7,-8,-9,-SCHAR_MAX, SCHAR_MAX,\t  -24,-32, 0,-1,-2,-3,-4,-5,-SCHAR_MAX, SCHAR_MAX - 1 });\n+\n+  c\t    = (VS) { 0, 7, 23, SHRT_MIN + 1, SHRT_MIN + 2, SHRT_MAX, 2, 5 };\n+  l = -c;\n+  checkvs (l, (VS) { 0,-7,-23, SHRT_MAX,     SHRT_MAX - 1,-SHRT_MAX,-2,-5 });\n+\n+  e\t    = (VI) { 5, INT_MAX, INT_MIN + 1, INT_MIN + 2 };\n+  m = foo (e);\n+  checkvi (m, (VI) {-5,-INT_MAX, INT_MAX,     INT_MAX - 1 });\n+\n+  g\t     = (VI2) { 10, 11, 0, INT_MAX - 2, 1, INT_MIN + 1, 5, INT_MIN / 2 };\n+  n = -g;\n+  checkvi2 (n, (VI2) {-10,-11, 0,-INT_MAX + 2,-1, INT_MAX,    -5, INT_MAX / 2 + 1 });\n+  return 0;\n+}"}, {"sha": "0fffdac80c3d061a99da2b455ee80e979625a088", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-vec-2.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-vec-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-vec-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-vec-2.c?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -0,0 +1,169 @@\n+/* { dg-do run } */\n+/* { dg-options \"-Wno-psabi -fsanitize=signed-integer-overflow -Wno-unused-variable -fsanitize-recover=signed-integer-overflow\" } */\n+\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SCHAR_MIN (-__SCHAR_MAX__ - 1)\n+#define SHRT_MAX __SHRT_MAX__\n+#define SHRT_MIN (-__SHRT_MAX__ - 1)\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+\n+typedef signed char VC __attribute__((vector_size (16)));\n+typedef short VS __attribute__((vector_size (8 * sizeof (short))));\n+typedef int VI __attribute__((vector_size (4 * sizeof (int))));\n+typedef int VI2 __attribute__((vector_size (16 * sizeof (int))));\n+\n+void __attribute__((noinline,noclone))\n+checkvc (VC i, VC j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VC)))\n+    __builtin_abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+checkvs (VS i, VS j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VS)))\n+    __builtin_abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+checkvi (VI i, VI j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VI)))\n+    __builtin_abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+checkvi2 (VI2 i, VI2 j)\n+{\n+  if (__builtin_memcmp (&i, &j, sizeof (VI2)))\n+    __builtin_abort ();\n+}\n+\n+VI __attribute__((noinline,noclone))\n+foo (VI i)\n+{\n+  return -i;\n+}\n+\n+VS __attribute__((noinline,noclone))\n+bar (VS i, VS j)\n+{\n+  return i + j;\n+}\n+\n+int\n+main (void)\n+{\n+  /* Check that for a vector operation, only the first element with UB is reported.  */\n+  volatile VC a = (VC) { 0, SCHAR_MAX - 2, SCHAR_MAX - 2, 3, 2, 3, 4, 5,  0, 7,  1,  2,  3, 4,  SCHAR_MAX - 13, SCHAR_MAX };\n+  volatile VC b = (VC) { 5, 2,\t\t   3,\t\t  5, 0, 1, 2, 7,  8, 9,  10, 11, 6, -2, 13,\t        1 };\n+  volatile VC k = b + a;\n+  checkvc (k,\t  (VC) { 5, SCHAR_MAX,     SCHAR_MIN,     8, 2, 4, 6, 12, 8, 16, 11, 13, 9, 2,  SCHAR_MAX,      SCHAR_MIN });\n+  k = a + b;\n+  checkvc (k,     (VC) { 5, SCHAR_MAX,     SCHAR_MIN,     8, 2, 4, 6, 12, 8, 16, 11, 13, 9, 2,  SCHAR_MAX,      SCHAR_MIN });\n+\n+  volatile VS c = (VS) { 0, SHRT_MAX - 2, SHRT_MAX - 2, 3, 3, 4,  SHRT_MAX - 13, SHRT_MAX };\n+  volatile VS d = (VS) { 5, 2,\t\t  3,\t\t5, 6, -2, 13,\t         1 };\n+  volatile VS l = d + c;\n+  checkvs (l,\t  (VS) { 5, SHRT_MAX,     SHRT_MIN,     8, 9, 2,  SHRT_MAX,      SHRT_MIN });\n+  l = bar (c, d);\n+  checkvs (l,     (VS) { 5, SHRT_MAX,     SHRT_MIN,     8, 9, 2,  SHRT_MAX,      SHRT_MIN });\n+\n+  volatile VI e = (VI) { INT_MAX - 4, INT_MAX - 5, INT_MAX - 13, INT_MAX };\n+  volatile VI f = (VI) { 4,\t      6,\t   13,\t         1 };\n+  volatile VI m = f + e;\n+  checkvi (m,\t  (VI) { INT_MAX,     INT_MIN,     INT_MAX,      INT_MIN });\n+  m = e + f;\n+  checkvi (m,     (VI) { INT_MAX,     INT_MIN,     INT_MAX,      INT_MIN });\n+\n+  volatile VI2 g = (VI2) { 0, INT_MAX - 2, INT_MAX - 2, 3, 3, 4,  INT_MAX - 13, INT_MAX };\n+  volatile VI2 h = (VI2) { 5, 2,\t   3,\t\t5, 6, -2, 13,\t        1 };\n+  volatile VI2 n = h + g;\n+  checkvi2 (n,\t   (VI2) { 5, INT_MAX,     INT_MIN,     8, 9, 2,  INT_MAX,      INT_MIN });\n+  n = g + h;\n+  checkvi2 (n,     (VI2) { 5, INT_MAX,     INT_MIN,     8, 9, 2,  INT_MAX,      INT_MIN });\n+\n+  volatile VC a2 = k - b;\n+  checkvc (a2, a);\n+  volatile VC b2 = k - a;\n+  checkvc (b2, b);\n+\n+  volatile VS c2 = l - d;\n+  checkvs (c2, c);\n+  volatile VS d2 = l - c;\n+  checkvs (d2, d);\n+\n+  volatile VI e2 = m - f;\n+  checkvi (e2, e);\n+  volatile VI f2 = m - e;\n+  checkvi (f2, f);\n+\n+  volatile VI2 g2 = n - h;\n+  checkvi2 (g2, g);\n+  volatile VI2 h2 = n - g;\n+  checkvi2 (h2, h);\n+\n+  a\t    = (VC) { 0,         SCHAR_MAX / 4, SCHAR_MAX / 4, 3, 2, 3, 4, 5, 0, 7, 1, 2, 3, 4, SCHAR_MAX - 13, SCHAR_MAX };\n+  b\t    = (VC) { SCHAR_MAX, 4,\t       5,\t      2, 3, 4, 5, 2, 9, 2, 9, 1, 0, 8, 1,\t       2 };\n+  k = a * b;\n+  checkvc (k, (VC) { 0,\t\t124,\t       -101,\t      6, 6,12,20,10, 0,14, 9, 2, 0,32, SCHAR_MAX - 13, -2 });\n+\n+  c\t    = (VS) { 0,\t\tSHRT_MAX / 8, SHRT_MAX / 7, 5, 8, 9, SHRT_MAX - 10, SHRT_MAX };\n+  d\t    = (VS) { SHRT_MAX,  8,\t      17,\t    2, 3, 4, 1,\t\t    3 };\n+  l = c * d;\n+  checkvs (l, (VS) { 0,\t\t32760,\t      14041,\t   10,24,36, SHRT_MAX - 10, 32765 });\n+\n+  e\t    = (VI) { INT_MAX,\tINT_MAX / 5,  INT_MAX / 6, INT_MAX };\n+  f\t    = (VI) { 0,\t\t5,\t      7,\t   2 };\n+  m = e * f;\n+  checkvi (m, (VI) { 0,\t\t2147483645,   -1789569709, -2 });\n+\n+  g\t    = (VI2) { INT_MAX,\tINT_MAX / 9,  INT_MAX / 8, 5, 6, 7, 8, INT_MAX };\n+  h\t    = (VI2) { 0,\t10,\t      8,\t   2, 3, 4, 5, 1 };\n+  n = g * h;\n+  checkvi2 (n,(VI2) { 0,\t-1908874356,  2147483640, 10,18,28,40, INT_MAX });\n+\n+  a\t    = (VC) { 5, 7, 8, 9, SCHAR_MAX, SCHAR_MIN, 24, 32, 0, 1, 2, 3, 4, 5, SCHAR_MAX, SCHAR_MIN };\n+  k = -a;\n+  checkvc (k, (VC) {-5,-7,-8,-9,-SCHAR_MAX, SCHAR_MIN,-24,-32, 0,-1,-2,-3,-4,-5,-SCHAR_MAX, SCHAR_MIN });\n+\n+  c\t    = (VS) { 0, 7, 23, SHRT_MIN, SHRT_MIN, SHRT_MAX, 2, 5 };\n+  l = -c;\n+  checkvs (l, (VS) { 0,-7,-23, SHRT_MIN, SHRT_MIN,-SHRT_MAX,-2,-5 });\n+\n+  e\t    = (VI) { 5, INT_MAX, INT_MIN, INT_MIN };\n+  m = foo (e);\n+  checkvi (m, (VI) {-5,-INT_MAX, INT_MIN, INT_MIN });\n+\n+  g\t     = (VI2) { 10, 11, 0, INT_MAX - 2, 1, INT_MIN + 1, 5, INT_MIN };\n+  n = -g;\n+  checkvi2 (n, (VI2) {-10,-11, 0,-INT_MAX + 2,-1, INT_MAX,    -5, INT_MIN });\n+  return 0;\n+}\n+\n+/* { dg-output \"signed integer overflow: 3 \\\\+ 125 cannot be represented in type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 125 \\\\+ 3 cannot be represented in type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 3 \\\\+ 32765 cannot be represented in type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 32765 \\\\+ 3 cannot be represented in type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 6 \\\\+ 2147483642 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 2147483642 \\\\+ 6 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 3 \\\\+ 2147483645 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 2147483645 \\\\+ 3 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -128 - 3 cannot be represented in type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -128 - 125 cannot be represented in type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -32768 - 3 cannot be represented in type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -32768 - 32765 cannot be represented in type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 - 6 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 - 2147483642 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 - 3 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: -2147483648 - 2147483645 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 31 \\\\* 5 cannot be represented in type 'signed char'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 4681 \\\\* 17 cannot be represented in type 'short int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 357913941 \\\\* 7 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*signed integer overflow: 238609294 \\\\* 10 cannot be represented in type 'int'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*negation of -128 cannot be represented in type 'signed char'; cast to an unsigned type to negate this value to itself\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*negation of -32768 cannot be represented in type 'short int'; cast to an unsigned type to negate this value to itself\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself\" } */"}, {"sha": "c2a41332044d17b82fd3af61b61d41b31944ac19", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -10023,7 +10023,11 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n   tree op1 = gimple_call_arg (stmt, 1);\n   tree type;\n   if (is_ubsan)\n-    type = TREE_TYPE (op0);\n+    {\n+      type = TREE_TYPE (op0);\n+      if (VECTOR_TYPE_P (type))\n+\treturn false;\n+    }\n   else if (gimple_call_lhs (stmt) == NULL_TREE)\n     return false;\n   else"}, {"sha": "d5422a1283dc454e874731aebb4cdd125b3c02bd", "filename": "gcc/ubsan.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -1219,14 +1219,20 @@ instrument_null (gimple_stmt_iterator gsi, bool is_lhs)\n \n tree\n ubsan_build_overflow_builtin (tree_code code, location_t loc, tree lhstype,\n-\t\t\t      tree op0, tree op1)\n+\t\t\t      tree op0, tree op1, tree *datap)\n {\n   if (flag_sanitize_undefined_trap_on_error)\n     return build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \n-  tree data = ubsan_create_data (\"__ubsan_overflow_data\", 1, &loc,\n-\t\t\t\t ubsan_type_descriptor (lhstype), NULL_TREE,\n-\t\t\t\t NULL_TREE);\n+  tree data;\n+  if (datap && *datap)\n+    data = *datap;\n+  else\n+    data = ubsan_create_data (\"__ubsan_overflow_data\", 1, &loc,\n+\t\t\t      ubsan_type_descriptor (lhstype), NULL_TREE,\n+\t\t\t      NULL_TREE);\n+  if (datap)\n+    *datap = data;\n   enum built_in_function fn_code;\n \n   switch (code)\n@@ -1272,14 +1278,15 @@ instrument_si_overflow (gimple_stmt_iterator gsi)\n   tree_code code = gimple_assign_rhs_code (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n   tree lhstype = TREE_TYPE (lhs);\n+  tree lhsinner = VECTOR_TYPE_P (lhstype) ? TREE_TYPE (lhstype) : lhstype;\n   tree a, b;\n   gimple *g;\n \n   /* If this is not a signed operation, don't instrument anything here.\n      Also punt on bit-fields.  */\n-  if (!INTEGRAL_TYPE_P (lhstype)\n-      || TYPE_OVERFLOW_WRAPS (lhstype)\n-      || GET_MODE_BITSIZE (TYPE_MODE (lhstype)) != TYPE_PRECISION (lhstype))\n+  if (!INTEGRAL_TYPE_P (lhsinner)\n+      || TYPE_OVERFLOW_WRAPS (lhsinner)\n+      || GET_MODE_BITSIZE (TYPE_MODE (lhsinner)) != TYPE_PRECISION (lhsinner))\n     return;\n \n   switch (code)\n@@ -1305,7 +1312,7 @@ instrument_si_overflow (gimple_stmt_iterator gsi)\n       /* Represent i = -u;\n \t as\n \t i = UBSAN_CHECK_SUB (0, u);  */\n-      a = build_int_cst (lhstype, 0);\n+      a = build_zero_cst (lhstype);\n       b = gimple_assign_rhs1 (stmt);\n       g = gimple_build_call_internal (IFN_UBSAN_CHECK_SUB, 2, a, b);\n       gimple_call_set_lhs (g, lhs);\n@@ -1316,7 +1323,7 @@ instrument_si_overflow (gimple_stmt_iterator gsi)\n \t into\n \t _N = UBSAN_CHECK_SUB (0, u);\n \t i = ABS_EXPR<_N>;  */\n-      a = build_int_cst (lhstype, 0);\n+      a = build_zero_cst (lhstype);\n       b = gimple_assign_rhs1 (stmt);\n       g = gimple_build_call_internal (IFN_UBSAN_CHECK_SUB, 2, a, b);\n       a = make_ssa_name (lhstype);"}, {"sha": "c4ebec946a6040a7a5ecb85c81886585abbd1393", "filename": "gcc/ubsan.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1705cebd79f24bc85dab766a9a26390827f26fa0/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=1705cebd79f24bc85dab766a9a26390827f26fa0", "patch": "@@ -52,7 +52,8 @@ extern tree ubsan_create_data (const char *, int, const location_t *, ...);\n extern tree ubsan_type_descriptor (tree, enum ubsan_print_style = UBSAN_PRINT_NORMAL);\n extern tree ubsan_encode_value (tree, bool = false);\n extern bool is_ubsan_builtin_p (tree);\n-extern tree ubsan_build_overflow_builtin (tree_code, location_t, tree, tree, tree);\n+extern tree ubsan_build_overflow_builtin (tree_code, location_t, tree, tree,\n+\t\t\t\t\t  tree, tree *);\n extern tree ubsan_instrument_float_cast (location_t, tree, tree);\n extern tree ubsan_get_source_location_type (void);\n "}]}