{"sha": "282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgyYmM3YjRjNWZkODk1ZWNjODE3ODFlMGZlYmI4ZWMxM2Q5YWQ4Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-12-27T16:25:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-12-27T16:25:43Z"}, "message": "re PR rtl-optimization/51667 (new FAIL: 27_io/basic_*stream/* execution test with -m32)\n\n\tPR rtl-optimization/51667\n\t* ree.c (insn_merge_code): Delete.\n\t(is_insn_merge_attempted): Likewise.\n\t(get_insn_status): Likewise.\n\t(set_insn_status): Likewise.\n\t(struct ext_cand): Add CODE and MODE fields.\n\t(combine_set_extend): Rename to...\n\t(combine_set_extension): ...this.  Use above fields and tidy up.\n\t(transform_ifelse): Likewise.\n\t(get_defs): Return the chain of definitions.\n\t(is_this_a_cmove): Merge into...\n\t(is_cond_copy_insn): ...this.  Return bool.\n\t(make_defs_and_copies_lists): Adjust calls to get_defs and simplify.\n\t(merge_def_and_ext): Adjust call to combine_set_extend.\n\t(combine_reaching_defs): Remove calls to {g|s}et_insn_status.\n\t(struct extend_info): Rename to...\n\t(struct re_info): ...this.  Add DEF_MAP field.\n\t(add_ext_candidate): Merge into...\n\t(add_removable_extension): ...this.  Adjust calls to get_defs.  Ensure\n\treaching definitions are associated with only one kind of extension.\n\t(find_removable_extensions): Create and destroy the definition map.\n\t(find_and_remove_re): Return void.  Change 'long' variables to 'int'.\n\tDo not deal with is_insn_merge_attempted.\n\nFrom-SVN: r182694", "tree": {"sha": "eaf9391ce1461e4951b958573322625de296a53b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaf9391ce1461e4951b958573322625de296a53b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/comments", "author": null, "committer": null, "parents": [{"sha": "0bed228eb6a10757b28a4e3f355d88267421bf6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bed228eb6a10757b28a4e3f355d88267421bf6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bed228eb6a10757b28a4e3f355d88267421bf6e"}], "stats": {"total": 594, "additions": 267, "deletions": 327}, "files": [{"sha": "1316fec006bb2b7b1cf69d2846d015c5e5b7bf99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "patch": "@@ -1,3 +1,29 @@\n+2011-12-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/51667\n+\t* ree.c (insn_merge_code): Delete.\n+\t(is_insn_merge_attempted): Likewise.\n+\t(get_insn_status): Likewise.\n+\t(set_insn_status): Likewise.\n+\t(struct ext_cand): Add CODE and MODE fields.\n+\t(combine_set_extend): Rename to...\n+\t(combine_set_extension): ...this.  Use above fields and tidy up.\n+\t(transform_ifelse): Likewise.\n+\t(get_defs): Return the chain of definitions.\n+\t(is_this_a_cmove): Merge into...\n+\t(is_cond_copy_insn): ...this.  Return bool.\n+\t(make_defs_and_copies_lists): Adjust calls to get_defs and simplify.\n+\t(merge_def_and_ext): Adjust call to combine_set_extend.\n+\t(combine_reaching_defs): Remove calls to {g|s}et_insn_status.\n+\t(struct extend_info): Rename to...\n+\t(struct re_info): ...this.  Add DEF_MAP field.\n+\t(add_ext_candidate): Merge into...\n+\t(add_removable_extension): ...this.  Adjust calls to get_defs.  Ensure\n+\treaching definitions are associated with only one kind of extension.\n+\t(find_removable_extensions): Create and destroy the definition map.\n+\t(find_and_remove_re): Return void.  Change 'long' variables to 'int'.\n+\tDo not deal with is_insn_merge_attempted.\n+\n 2011-12-25  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/48641 "}, {"sha": "48113a966ba9cb92c7553f4f5621a04f355cd758", "filename": "gcc/ree.c", "status": "modified", "additions": 207, "deletions": 327, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "patch": "@@ -1,9 +1,9 @@\n /* Redundant Extension Elimination pass for the GNU compiler.\n-  Copyright (C) 2010-2011 Free Software Foundation, Inc.\n-  Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n+   Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+   Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n \n-  Based on the Redundant Zero-extension elimination pass contributed by\n-  Sriraman Tallam (tmsriram@google.com) and Silvius Rus (rus@google.com).\n+   Based on the Redundant Zero-extension elimination pass contributed by\n+   Sriraman Tallam (tmsriram@google.com) and Silvius Rus (rus@google.com).\n \n This file is part of GCC.\n \n@@ -71,11 +71,11 @@ along with GCC; see the file COPYING3.  If not see\n    extension differ from the other instructions.  For instance, the\n    instruction *cmov ebx, eax*\n    zero-extends eax onto rax only when the move from ebx to eax happens.\n-   Otherwise, eax may not be zero-extended.  Consider conditional move as\n+   Otherwise, eax may not be zero-extended.  Consider conditional moves as\n    RTL instructions of the form\n    (set (reg:SI x) (if_then_else (cond) (reg:SI y) (reg:SI z))).\n    This pass tries to merge an extension with a conditional move by\n-   actually merging the defintions of y and z with an extension and then\n+   actually merging the definitions of y and z with an extension and then\n    converting the conditional move into :\n    (set (reg:DI x) (if_then_else (cond) (reg:DI y) (reg:DI z))).\n    Since registers y and z are extended, register x will also be extended\n@@ -105,13 +105,13 @@ along with GCC; see the file COPYING3.  If not see\n      ........\n      400315:       b8 4e 00 00 00          mov    $0x4e,%eax\n      40031a:       0f af f8                imul   %eax,%edi\n-     40031d:       89 ff                   mov    %edi,%edi  --> Useless extend\n+     40031d:       89 ff                   mov    %edi,%edi - useless extension\n      40031f:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax\n      400326:       c3                      retq\n      ......\n      400330:       ba 2d 00 00 00          mov    $0x2d,%edx\n      400335:       0f af fa                imul   %edx,%edi\n-     400338:       89 ff                   mov    %edi,%edi  --> Useless extend\n+     400338:       89 ff                   mov    %edi,%edi - useless extension\n      40033a:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax\n      400341:       c3                      retq\n \n@@ -149,7 +149,7 @@ along with GCC; see the file COPYING3.  If not see\n      400365:       29 f0                   sub    %esi,%eax\n      400367:       83 ff 65                cmp    $0x65,%edi\n      40036a:       0f 43 c2                cmovae %edx,%eax\n-     40036d:       89 c0                   mov    %eax,%eax  --> Useless extend\n+     40036d:       89 c0                   mov    %eax,%eax - useless extension\n      40036f:       c3                      retq\n \n    $ gcc -O2 -free bad_code.c\n@@ -188,8 +188,8 @@ along with GCC; see the file COPYING3.  If not see\n     10:   0f b6 0e                movzbl (%rsi),%ecx\n     13:   0f b6 46 01             movzbl 0x1(%rsi),%eax\n     17:   48 83 c6 02             add    $0x2,%rsi\n-    1b:   0f b6 c9                movzbl %cl,%ecx  --> Useless extend\n-    1e:   0f b6 c0                movzbl %al,%eax  --> Useless extend\n+    1b:   0f b6 c9                movzbl %cl,%ecx - useless extension\n+    1e:   0f b6 c0                movzbl %al,%eax - useless extension\n     21:   69 c9 8b 4c 00 00       imul   $0x4c8b,%ecx,%ecx\n     27:   69 c0 46 96 00 00       imul   $0x9646,%eax,%eax\n \n@@ -245,52 +245,28 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"cgraph.h\"\n \n-/* This says if a register is newly created for the purpose of\n-   extension.  */\n+/* This structure represents a candidate for elimination.  */\n \n-enum insn_merge_code\n+typedef struct GTY(()) ext_cand\n {\n-  MERGE_NOT_ATTEMPTED = 0,\n-  MERGE_SUCCESS\n-};\n+  /* The expression.  */\n+  const_rtx expr;\n+\n+  /* The kind of extension.  */\n+  enum rtx_code code;\n \n-/* This structure is used to hold data about candidate for\n-   elimination.  */\n+  /* The destination mode.  */\n+  enum machine_mode mode;\n \n-typedef struct GTY(()) ext_cand\n-{\n+  /* The instruction where it lives.  */\n   rtx insn;\n-  const_rtx expr;\n-  enum machine_mode src_mode;\n-} ext_cand, *ext_cand_ref;\n+} ext_cand;\n \n DEF_VEC_O(ext_cand);\n DEF_VEC_ALLOC_O(ext_cand, heap);\n \n-/* This says if a INSN UID or its definition has already been merged\n-   with a extension or not.  */\n-\n-static enum insn_merge_code *is_insn_merge_attempted;\n static int max_insn_uid;\n \n-/* Return the merge code status for INSN.  */\n-\n-static enum insn_merge_code\n-get_insn_status (rtx insn)\n-{\n-  gcc_assert (INSN_UID (insn) < max_insn_uid);\n-  return is_insn_merge_attempted[INSN_UID (insn)];\n-}\n-\n-/* Set the merge code status of INSN to CODE.  */\n-\n-static void\n-set_insn_status (rtx insn, enum insn_merge_code code)\n-{\n-  gcc_assert (INSN_UID (insn) < max_insn_uid);\n-  is_insn_merge_attempted[INSN_UID (insn)] = code;\n-}\n-\n /* Given a insn (CURR_INSN), an extension candidate for removal (CAND)\n    and a pointer to the SET rtx (ORIG_SET) that needs to be modified,\n    this code modifies the SET rtx to a new SET rtx that extends the\n@@ -302,97 +278,80 @@ set_insn_status (rtx insn, enum insn_merge_code code)\n    (set (reg a) (expression))\n \n    Transform :\n-   (set (reg a) (extend (expression)))\n+   (set (reg a) (any_extend (expression)))\n \n    Special Cases :\n-   If the expression is a constant or another extend directly\n+   If the expression is a constant or another extension, then directly\n    assign it to the register.  */\n \n static bool\n-combine_set_extend (ext_cand_ref cand, rtx curr_insn, rtx *orig_set)\n+combine_set_extension (ext_cand *cand, rtx curr_insn, rtx *orig_set)\n {\n-  rtx temp_extension, simplified_temp_extension, new_set, new_const_int;\n-  rtx orig_src, cand_src;\n-  rtx newreg;\n-  enum machine_mode dst_mode = GET_MODE (SET_DEST (cand->expr));\n-\n-  /* Change the SET rtx and validate it.  */\n-  orig_src = SET_SRC (*orig_set);\n-  cand_src = SET_SRC (cand->expr);\n-  new_set = NULL_RTX;\n-\n-  newreg = gen_rtx_REG (dst_mode, REGNO (SET_DEST (*orig_set)));\n-\n-  /* Merge constants by directly moving the constant into the\n-     register under some conditions.  */\n+  rtx orig_src = SET_SRC (*orig_set);\n+  rtx new_reg = gen_rtx_REG (cand->mode, REGNO (SET_DEST (*orig_set)));\n+  rtx new_set;\n \n+  /* Merge constants by directly moving the constant into the register under\n+     some conditions.  Recall that RTL constants are sign-extended.  */\n   if (GET_CODE (orig_src) == CONST_INT\n-      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (dst_mode))\n+      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (cand->mode))\n     {\n-      if (INTVAL (orig_src) >= 0 || GET_CODE (cand_src) == SIGN_EXTEND)\n-\tnew_set = gen_rtx_SET (VOIDmode, newreg, orig_src);\n+      if (INTVAL (orig_src) >= 0 || cand->code == SIGN_EXTEND)\n+\tnew_set = gen_rtx_SET (VOIDmode, new_reg, orig_src);\n       else\n \t{\n \t  /* Zero-extend the negative constant by masking out the bits outside\n \t     the source mode.  */\n \t  enum machine_mode src_mode = GET_MODE (SET_DEST (*orig_set));\n-\t  new_const_int\n+\t  rtx new_const_int\n \t    = GEN_INT (INTVAL (orig_src) & GET_MODE_MASK (src_mode));\n-\t  new_set = gen_rtx_SET (VOIDmode, newreg, new_const_int);\n+\t  new_set = gen_rtx_SET (VOIDmode, new_reg, new_const_int);\n \t}\n     }\n   else if (GET_MODE (orig_src) == VOIDmode)\n     {\n-      /* This is mostly due to a call insn that should not be\n-\t optimized.  */\n-\n+      /* This is mostly due to a call insn that should not be optimized.  */\n       return false;\n     }\n-  else if (GET_CODE (orig_src) == GET_CODE (cand_src))\n+  else if (GET_CODE (orig_src) == cand->code)\n     {\n-      /* Here is a sequence of two extensions.  Try to merge them into a\n-\t single one.  */\n-\n-      temp_extension\n-\t= gen_rtx_fmt_e (GET_CODE (orig_src), dst_mode, XEXP (orig_src, 0));\n-      simplified_temp_extension = simplify_rtx (temp_extension);\n+      /* Here is a sequence of two extensions.  Try to merge them.  */\n+      rtx temp_extension\n+\t= gen_rtx_fmt_e (cand->code, cand->mode, XEXP (orig_src, 0));\n+      rtx simplified_temp_extension = simplify_rtx (temp_extension);\n       if (simplified_temp_extension)\n         temp_extension = simplified_temp_extension;\n-      new_set = gen_rtx_SET (VOIDmode, newreg, temp_extension);\n+      new_set = gen_rtx_SET (VOIDmode, new_reg, temp_extension);\n     }\n   else if (GET_CODE (orig_src) == IF_THEN_ELSE)\n     {\n       /* Only IF_THEN_ELSE of phi-type copies are combined.  Otherwise,\n          in general, IF_THEN_ELSE should not be combined.  */\n-\n       return false;\n     }\n   else\n     {\n-      /* This is the normal case we expect.  */\n-\n-      temp_extension\n-\t= gen_rtx_fmt_e (GET_CODE (cand_src), dst_mode, orig_src);\n-      simplified_temp_extension = simplify_rtx (temp_extension);\n+      /* This is the normal case.  */\n+      rtx temp_extension\n+\t= gen_rtx_fmt_e (cand->code, cand->mode, orig_src);\n+      rtx simplified_temp_extension = simplify_rtx (temp_extension);\n       if (simplified_temp_extension)\n         temp_extension = simplified_temp_extension;\n-      new_set = gen_rtx_SET (VOIDmode, newreg, temp_extension);\n+      new_set = gen_rtx_SET (VOIDmode, new_reg, temp_extension);\n     }\n \n-  gcc_assert (new_set != NULL_RTX);\n-\n   /* This change is a part of a group of changes.  Hence,\n      validate_change will not try to commit the change.  */\n-\n   if (validate_change (curr_insn, orig_set, new_set, true))\n     {\n       if (dump_file)\n         {\n-          fprintf (dump_file, \"Merged Instruction with EXTEND:\\n\");\n+          fprintf (dump_file, \"Merged instruction with extension:\\n\");\n           print_rtl_single (dump_file, curr_insn);\n         }\n       return true;\n     }\n+\n   return false;\n }\n \n@@ -405,258 +364,180 @@ combine_set_extend (ext_cand_ref cand, rtx curr_insn, rtx *orig_set)\n    DEF_INSN is the if_then_else insn.  */\n \n static bool\n-transform_ifelse (ext_cand_ref cand, rtx def_insn)\n+transform_ifelse (ext_cand *cand, rtx def_insn)\n {\n   rtx set_insn = PATTERN (def_insn);\n   rtx srcreg, dstreg, srcreg2;\n   rtx map_srcreg, map_dstreg, map_srcreg2;\n   rtx ifexpr;\n   rtx cond;\n   rtx new_set;\n-  enum machine_mode dst_mode = GET_MODE (SET_DEST (cand->expr));\n \n   gcc_assert (GET_CODE (set_insn) == SET);\n+\n   cond = XEXP (SET_SRC (set_insn), 0);\n   dstreg = SET_DEST (set_insn);\n   srcreg = XEXP (SET_SRC (set_insn), 1);\n   srcreg2 = XEXP (SET_SRC (set_insn), 2);\n-  map_srcreg = gen_rtx_REG (dst_mode, REGNO (srcreg));\n-  map_srcreg2 = gen_rtx_REG (dst_mode, REGNO (srcreg2));\n-  map_dstreg = gen_rtx_REG (dst_mode, REGNO (dstreg));\n-  ifexpr = gen_rtx_IF_THEN_ELSE (dst_mode, cond, map_srcreg, map_srcreg2);\n+  map_srcreg = gen_rtx_REG (cand->mode, REGNO (srcreg));\n+  map_srcreg2 = gen_rtx_REG (cand->mode, REGNO (srcreg2));\n+  map_dstreg = gen_rtx_REG (cand->mode, REGNO (dstreg));\n+  ifexpr = gen_rtx_IF_THEN_ELSE (cand->mode, cond, map_srcreg, map_srcreg2);\n   new_set = gen_rtx_SET (VOIDmode, map_dstreg, ifexpr);\n \n   if (validate_change (def_insn, &PATTERN (def_insn), new_set, true))\n     {\n       if (dump_file)\n         {\n-          fprintf (dump_file, \"Cond_Move Instruction's mode extended :\\n\");\n+          fprintf (dump_file,\n+\t\t   \"Mode of conditional move instruction extended:\\n\");\n           print_rtl_single (dump_file, def_insn);\n         }\n       return true;\n     }\n-  else\n-    return false;\n+\n+  return false;\n }\n \n-/* Function to get all the immediate definitions of an instruction.\n-   The reaching definitions are desired for WHICH_REG used in\n-   CURR_INSN.  This function returns 0 if there was an error getting\n-   a definition.  Upon success, this function returns the number of\n-   definitions and stores the definitions in DEST.  */\n+/* Get all the reaching definitions of an instruction.  The definitions are\n+   desired for REG used in INSN.  Return the definition list or NULL if a\n+   definition is missing.  If DEST is non-NULL, additionally push the INSN\n+   of the definitions onto DEST.  */\n \n-static int\n-get_defs (rtx curr_insn, rtx which_reg, VEC (rtx,heap) **dest)\n+static struct df_link *\n+get_defs (rtx insn, rtx reg, VEC (rtx,heap) **dest)\n {\n   df_ref reg_info, *defs;\n-  struct df_link *def_chain;\n-  int n_refs = 0;\n+  struct df_link *ref_chain, *ref_link;\n \n-  defs = DF_INSN_USES (curr_insn);\n   reg_info = NULL;\n \n-  while (*defs)\n+  for (defs = DF_INSN_USES (insn); *defs; defs++)\n     {\n       reg_info = *defs;\n       if (GET_CODE (DF_REF_REG (reg_info)) == SUBREG)\n-        return 0;\n-      if (REGNO (DF_REF_REG (reg_info)) == REGNO (which_reg))\n+        return NULL;\n+      if (REGNO (DF_REF_REG (reg_info)) == REGNO (reg))\n         break;\n-      defs++;\n     }\n \n   gcc_assert (reg_info != NULL && defs != NULL);\n-  def_chain = DF_REF_CHAIN (reg_info);\n \n-  while (def_chain)\n+  ref_chain = DF_REF_CHAIN (reg_info);\n+\n+  for (ref_link = ref_chain; ref_link; ref_link = ref_link->next)\n     {\n       /* Problem getting some definition for this instruction.  */\n-\n-      if (def_chain->ref == NULL)\n-        return 0;\n-      if (DF_REF_INSN_INFO (def_chain->ref) == NULL)\n-        return 0;\n-      def_chain = def_chain->next;\n+      if (ref_link->ref == NULL)\n+        return NULL;\n+      if (DF_REF_INSN_INFO (ref_link->ref) == NULL)\n+        return NULL;\n     }\n \n-  def_chain = DF_REF_CHAIN (reg_info);\n+  if (dest)\n+    for (ref_link = ref_chain; ref_link; ref_link = ref_link->next)\n+      VEC_safe_push (rtx, heap, *dest, DF_REF_INSN (ref_link->ref));\n \n-  if (dest == NULL)\n-    return 1;\n-\n-  while (def_chain)\n-    {\n-      VEC_safe_push (rtx, heap, *dest, DF_REF_INSN (def_chain->ref));\n-      def_chain = def_chain->next;\n-      n_refs++;\n-    }\n-  return n_refs;\n+  return ref_chain;\n }\n \n-/* rtx function to check if this SET insn, EXPR, is a conditional copy insn :\n-   (set (reg a ) (IF_THEN_ELSE (cond) (reg b) (reg c)))\n-   Called from is_insn_cond_copy.  DATA stores the two registers on each\n-   side of the condition.  */\n+/* Return true if INSN is\n+     (SET (reg REGNO (def_reg)) (if_then_else (cond) (REG x1) (REG x2)))\n+   and store x1 and x2 in REG_1 and REG_2.  */\n \n-static int\n-is_this_a_cmove (rtx expr, void *data)\n+static bool\n+is_cond_copy_insn (rtx insn, rtx *reg1, rtx *reg2)\n {\n-  /* Check for conditional (if-then-else) copy.  */\n+  rtx expr = single_set (insn);\n \n-  if (GET_CODE (expr) == SET\n+  if (expr != NULL_RTX\n+      && GET_CODE (expr) == SET\n       && GET_CODE (SET_DEST (expr)) == REG\n       && GET_CODE (SET_SRC (expr))  == IF_THEN_ELSE\n       && GET_CODE (XEXP (SET_SRC (expr), 1)) == REG\n       && GET_CODE (XEXP (SET_SRC (expr), 2)) == REG)\n     {\n-      ((rtx *)data)[0] = XEXP (SET_SRC (expr), 1);\n-      ((rtx *)data)[1] = XEXP (SET_SRC (expr), 2);\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* This returns 1 if it found\n-   (SET (reg REGNO (def_reg)) (if_then_else (cond) (REG x1) (REG x2)))\n-   in the DEF_INSN pattern.  It stores the x1 and x2 in COPY_REG_1\n-   and COPY_REG_2.  */\n-\n-static int\n-is_insn_cond_copy (rtx def_insn, rtx *copy_reg_1, rtx *copy_reg_2)\n-{\n-  int type;\n-  rtx set_expr;\n-  rtx srcreg[2];\n-\n-  srcreg[0] = NULL_RTX;\n-  srcreg[1] = NULL_RTX;\n-\n-  set_expr = single_set (def_insn);\n-\n-  if (set_expr == NULL_RTX)\n-    return 0;\n-\n-  type = is_this_a_cmove (set_expr, (void *) srcreg);\n-\n-  if (type)\n-    {\n-      *copy_reg_1 = srcreg[0];\n-      *copy_reg_2 = srcreg[1];\n-      return type;\n+      *reg1 = XEXP (SET_SRC (expr), 1);\n+      *reg2 = XEXP (SET_SRC (expr), 2);\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Reaching Definitions of the extended register could be conditional copies\n    or regular definitions.  This function separates the two types into two\n    lists, DEFS_LIST and COPIES_LIST.  This is necessary because, if a reaching\n-   definition is a conditional copy, combining the extend with this definition\n-   is wrong.  Conditional copies are merged by transitively merging its\n+   definition is a conditional copy, merging the extension with this definition\n+   is wrong.  Conditional copies are merged by transitively merging their\n    definitions.  The defs_list is populated with all the reaching definitions\n    of the extension instruction (EXTEND_INSN) which must be merged with an\n    extension.  The copies_list contains all the conditional moves that will\n-   later be extended into a wider mode conditonal move if all the merges are\n-   successful.  The function returns false when there is a failure in getting\n-   some definitions, like that of parameters.  It returns 1 upon success, 0\n-   upon failure and 2 when all definitions of the EXTEND_INSN were merged\n-   previously.  */\n+   later be extended into a wider mode conditional move if all the merges are\n+   successful.  The function returns 0 upon failure, 1 upon success and 2 when\n+   all definitions of the EXTEND_INSN have been previously merged.  */\n \n static int\n make_defs_and_copies_lists (rtx extend_insn, rtx set_pat,\n                             VEC (rtx,heap) **defs_list,\n                             VEC (rtx,heap) **copies_list)\n {\n+  VEC (rtx,heap) *work_list = VEC_alloc (rtx, heap, 8);\n+  rtx src_reg = XEXP (SET_SRC (set_pat), 0);\n   bool *is_insn_visited;\n-  VEC (rtx,heap) *work_list;\n-  rtx srcreg, copy_reg_1, copy_reg_2;\n-  rtx def_insn;\n-  int n_defs = 0;\n-  int vec_index = 0;\n-  int n_worklist = 0;\n-  int i, is_copy;\n-\n-  srcreg = XEXP (SET_SRC (set_pat), 0);\n-  work_list = VEC_alloc (rtx, heap, 8);\n+  int ret = 1;\n \n-  /* Initialize the Work List */\n-  n_worklist = get_defs (extend_insn, srcreg, &work_list);\n-\n-  if (n_worklist == 0)\n+  /* Initialize the work list.  */\n+  if (!get_defs (extend_insn, src_reg, &work_list))\n     {\n       VEC_free (rtx, heap, work_list);\n-      /* The number of defs being equal to zero can only imply that all of its\n+      /* The number of defs being equal to zero can only mean that all the\n          definitions have been previously merged.  */\n       return 2;\n     }\n \n-  is_insn_visited = XNEWVEC (bool, max_insn_uid);\n-\n-  for (i = 0; i < max_insn_uid; i++)\n-    is_insn_visited[i] = false;\n-\n+  is_insn_visited = XCNEWVEC (bool, max_insn_uid);\n \n   /* Perform transitive closure for conditional copies.  */\n-  while (n_worklist > vec_index)\n+  while (!VEC_empty (rtx, work_list))\n     {\n-      def_insn = VEC_index (rtx, work_list, vec_index);\n+      rtx def_insn = VEC_pop (rtx, work_list);\n+      rtx reg1, reg2;\n+\n       gcc_assert (INSN_UID (def_insn) < max_insn_uid);\n \n       if (is_insn_visited[INSN_UID (def_insn)])\n-        {\n-          vec_index++;\n-          continue;\n-        }\n-\n+\tcontinue;\n       is_insn_visited[INSN_UID (def_insn)] = true;\n-      copy_reg_1 = copy_reg_2 = NULL_RTX;\n-      is_copy = is_insn_cond_copy (def_insn, &copy_reg_1, &copy_reg_2);\n-      if (is_copy)\n-        {\n-          gcc_assert (copy_reg_1 && copy_reg_2);\n-\n-          /* Push it into the copy list first.  */\n-\n-          VEC_safe_push (rtx, heap, *copies_list, def_insn);\n \n-          /* Perform transitive closure here */\n-\n-          n_defs = get_defs (def_insn, copy_reg_1, &work_list);\n-\n-          if (n_defs == 0)\n-            {\n-              VEC_free (rtx, heap, work_list);\n-              XDELETEVEC (is_insn_visited);\n-              return 0;\n-            }\n-          n_worklist += n_defs;\n-\n-          n_defs = get_defs (def_insn, copy_reg_2, &work_list);\n-          if (n_defs == 0)\n-            {\n-              VEC_free (rtx, heap, work_list);\n-              XDELETEVEC (is_insn_visited);\n-              return 0;\n-            }\n-          n_worklist += n_defs;\n+      if (is_cond_copy_insn (def_insn, &reg1, &reg2))\n+\t{\n+\t  /* Push it onto the copy list first.  */\n+\t  VEC_safe_push (rtx, heap, *copies_list, def_insn);\n+\n+\t  /* Now perform the transitive closure.  */\n+\t  if (!get_defs (def_insn, reg1, &work_list)\n+\t      || !get_defs (def_insn, reg2, &work_list))\n+\t    {\n+\t      ret = 0;\n+\t      break;\n+\t    }\n         }\n       else\n-        {\n-          VEC_safe_push (rtx, heap, *defs_list, def_insn);\n-        }\n-      vec_index++;\n+\tVEC_safe_push (rtx, heap, *defs_list, def_insn);\n     }\n \n-  VEC_free (rtx, heap, work_list);\n   XDELETEVEC (is_insn_visited);\n-  return 1;\n+  VEC_free (rtx, heap, work_list);\n+\n+  return ret;\n }\n \n-/* Merge the DEF_INSN with an extension.  Calls combine_set_extend\n+/* Merge the DEF_INSN with an extension.  Calls combine_set_extension\n    on the SET pattern.  */\n \n static bool\n-merge_def_and_ext (ext_cand_ref cand, rtx def_insn)\n+merge_def_and_ext (ext_cand *cand, rtx def_insn)\n {\n   enum machine_mode ext_src_mode;\n   enum rtx_code code;\n@@ -698,7 +579,7 @@ merge_def_and_ext (ext_cand_ref cand, rtx def_insn)\n   if (GET_CODE (SET_DEST (*sub_rtx)) == REG\n       && GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode)\n     {\n-      return combine_set_extend (cand, def_insn, sub_rtx);\n+      return combine_set_extension (cand, def_insn, sub_rtx);\n     }\n \n   return false;\n@@ -714,34 +595,29 @@ merge_def_and_ext (ext_cand_ref cand, rtx def_insn)\n    and false upon failure.  */\n \n static bool\n-combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n+combine_reaching_defs (ext_cand *cand, rtx set_pat)\n {\n   rtx def_insn;\n   bool merge_successful = true;\n   int i;\n   int defs_ix;\n   int outcome;\n-\n-  /* To store the definitions that have been merged.  */\n-\n   VEC (rtx, heap) *defs_list, *copies_list, *vec;\n-  enum insn_merge_code merge_code;\n \n   defs_list = VEC_alloc (rtx, heap, 8);\n   copies_list = VEC_alloc (rtx, heap, 8);\n \n   outcome = make_defs_and_copies_lists (cand->insn,\n                                         set_pat, &defs_list, &copies_list);\n \n-  /* outcome == 2 implies that all the definitions for this extension were\n-     merged while previously when handling other extension.  */\n-\n+  /* outcome == 2 means that all the definitions for this extension have been\n+     previously merged when handling other extensions.  */\n   if (outcome == 2)\n     {\n       VEC_free (rtx, heap, defs_list);\n       VEC_free (rtx, heap, copies_list);\n       if (dump_file)\n-        fprintf (dump_file, \"All definitions have been merged previously.\\n\");\n+        fprintf (dump_file, \"All definitions have been previously merged.\\n\");\n       return true;\n     }\n \n@@ -756,13 +632,9 @@ combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n \n   /* Go through the defs vector and try to merge all the definitions\n      in this vector.  */\n-\n   vec = VEC_alloc (rtx, heap, 8);\n   FOR_EACH_VEC_ELT (rtx, defs_list, defs_ix, def_insn)\n     {\n-      merge_code = get_insn_status (def_insn);\n-      gcc_assert (merge_code == MERGE_NOT_ATTEMPTED);\n-\n       if (merge_def_and_ext (cand, def_insn))\n         VEC_safe_push (rtx, heap, vec, def_insn);\n       else\n@@ -774,7 +646,6 @@ combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n \n   /* Now go through the conditional copies vector and try to merge all\n      the copies in this vector.  */\n-\n   if (merge_successful)\n     {\n       FOR_EACH_VEC_ELT (rtx, copies_list, i, def_insn)\n@@ -793,21 +664,15 @@ combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n \n   if (merge_successful)\n     {\n-      /* Commit the changes here if possible */\n-      /* XXX : Now, it is an all or nothing scenario.  Even if one definition\n-         cannot be merged we totally fail.  In future, allow extensions to\n-         be partially eliminated along those paths where the definitions could\n-         be merged.  */\n-\n+      /* Commit the changes here if possible\n+\t FIXME: It's an all-or-nothing scenario.  Even if only one definition\n+\t cannot be merged, we entirely give up.  In the future, we should allow\n+\t extensions to be partially eliminated along those paths where the\n+\t definitions could be merged.  */\n       if (apply_change_group ())\n         {\n           if (dump_file)\n-            fprintf (dump_file, \"All merges were successful ....\\n\");\n-\n-          FOR_EACH_VEC_ELT (rtx, vec, i, def_insn)\n-            {\n-              set_insn_status (def_insn, MERGE_SUCCESS);\n-            }\n+            fprintf (dump_file, \"All merges were successful.\\n\");\n \n           VEC_free (rtx, heap, vec);\n           VEC_free (rtx, heap, defs_list);\n@@ -819,12 +684,11 @@ combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n           /* Changes need not be cancelled explicitly as apply_change_group\n              does it.  Print list of definitions in the dump_file for debug\n              purposes.  This extension cannot be deleted.  */\n-\n           if (dump_file)\n             {\n               FOR_EACH_VEC_ELT (rtx, vec, i, def_insn)\n                 {\n-                  fprintf (dump_file, \" Ummergable definitions : \\n\");\n+                  fprintf (dump_file, \"Non-mergeable definitions:\\n\");\n                   print_rtl_single (dump_file, def_insn);\n                 }\n             }\n@@ -839,58 +703,90 @@ combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n   VEC_free (rtx, heap, vec);\n   VEC_free (rtx, heap, defs_list);\n   VEC_free (rtx, heap, copies_list);\n+\n   return false;\n }\n \n-/* Carry information about extensions while walking the RTL.  */\n+/* This structure holds information while walking the RTL stream.  */\n \n-struct extend_info\n+struct re_info\n {\n-  /* The insn where the extension is.  */\n+  /* The current insn.  */\n   rtx insn;\n \n   /* The list of candidates.  */\n   VEC (ext_cand, heap) *insn_list;\n-};\n \n-static void\n-add_ext_candidate (VEC (ext_cand, heap) **exts,\n-\t\t   rtx insn, const_rtx expr)\n-{\n-  ext_cand_ref ec = VEC_safe_push (ext_cand, heap, *exts, NULL);\n-  ec->insn = insn;\n-  ec->expr = expr;\n-}\n+  /* The map of definition instructions to candidates.  */\n+  ext_cand **def_map;\n+};\n \n /* Add an extension pattern that could be eliminated.  This is called via\n    note_stores from find_removable_extensions.  */\n \n static void\n add_removable_extension (rtx x ATTRIBUTE_UNUSED, const_rtx expr, void *data)\n {\n-  struct extend_info *rei = (struct extend_info *)data;\n+  struct re_info *rei = (struct re_info *)data;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n   rtx src, dest;\n \n-  /* We are looking for SET (REG N) (EXTEND (REG N)).  */\n+  /* We are looking for SET (REG N) (ANY_EXTEND (REG N)).  */\n   if (GET_CODE (expr) != SET)\n     return;\n \n   src = SET_SRC (expr);\n+  code = GET_CODE (src);\n   dest = SET_DEST (expr);\n+  mode = GET_MODE (dest);\n \n   if (REG_P (dest)\n-      && (GET_CODE (src) == ZERO_EXTEND || GET_CODE (src) == SIGN_EXTEND)\n+      && (code == SIGN_EXTEND || code == ZERO_EXTEND)\n       && REG_P (XEXP (src, 0))\n       && REGNO (dest) == REGNO (XEXP (src, 0)))\n     {\n-      if (get_defs (rei->insn, XEXP (src, 0), NULL))\n-\tadd_ext_candidate (&rei->insn_list, rei->insn, expr);\n-      else if (dump_file)\n+      struct df_link *defs, *def;\n+      ext_cand *cand;\n+\n+      /* First, make sure we can get all the reaching definitions.  */\n+      defs = get_defs (rei->insn, XEXP (src, 0), NULL);\n+      if (!defs)\n \t{\n-\t  fprintf (dump_file, \"Cannot eliminate extension: \\n\");\n-\t  print_rtl_single (dump_file, rei->insn);\n-\t  fprintf (dump_file, \"No defs. Could be extending parameters.\\n\");\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Cannot eliminate extension:\\n\");\n+\t      print_rtl_single (dump_file, rei->insn);\n+\t      fprintf (dump_file, \" because of missing definition(s)\\n\");\n+\t    }\n+\t  return;\n \t}\n+\n+      /* Second, make sure the reaching definitions don't feed another and\n+\t different extension.  FIXME: this obviously can be improved.  */\n+      for (def = defs; def; def = def->next)\n+\tif ((cand = rei->def_map[INSN_UID(DF_REF_INSN (def->ref))])\n+\t    && (cand->code != code || cand->mode != mode))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t        fprintf (dump_file, \"Cannot eliminate extension:\\n\");\n+\t        print_rtl_single (dump_file, rei->insn);\n+\t        fprintf (dump_file, \" because of other extension\\n\");\n+\t      }\n+\t    return;\n+\t  }\n+\n+      /* Then add the candidate to the list and insert the reaching definitions\n+         into the definition map.  */\n+      cand = VEC_safe_push (ext_cand, heap, rei->insn_list, NULL);\n+      cand->expr = expr;\n+      cand->code = code;\n+      cand->mode = mode;\n+      cand->insn = rei->insn;\n+\n+      for (def = defs; def; def = def->next)\n+\trei->def_map[INSN_UID(DF_REF_INSN (def->ref))] = cand;\n     }\n }\n \n@@ -900,11 +796,12 @@ add_removable_extension (rtx x ATTRIBUTE_UNUSED, const_rtx expr, void *data)\n static VEC (ext_cand, heap)*\n find_removable_extensions (void)\n {\n-  struct extend_info rei;\n+  struct re_info rei;\n   basic_block bb;\n   rtx insn;\n \n   rei.insn_list = VEC_alloc (ext_cand, heap, 8);\n+  rei.def_map = XCNEWVEC (ext_cand *, max_insn_uid);\n \n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)\n@@ -916,81 +813,64 @@ find_removable_extensions (void)\n \tnote_stores (PATTERN (insn), add_removable_extension, &rei);\n       }\n \n+  XDELETEVEC (rei.def_map);\n+\n   return rei.insn_list;\n }\n \n /* This is the main function that checks the insn stream for redundant\n    extensions and tries to remove them if possible.  */\n \n-static unsigned int\n+static void\n find_and_remove_re (void)\n {\n-  ext_cand_ref curr_cand;\n+  ext_cand *curr_cand;\n   rtx curr_insn = NULL_RTX;\n-  int i;\n-  int ix;\n-  long num_realized = 0;\n-  long num_re_opportunities = 0;\n+  int num_re_opportunities = 0, num_realized = 0, i;\n   VEC (ext_cand, heap) *reinsn_list;\n   VEC (rtx, heap) *reinsn_del_list;\n \n   /* Construct DU chain to get all reaching definitions of each\n      extension instruction.  */\n-\n   df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n   df_analyze ();\n \n   max_insn_uid = get_max_uid ();\n-\n-  is_insn_merge_attempted\n-    = XNEWVEC (enum insn_merge_code,\n-\t       sizeof (enum insn_merge_code) * max_insn_uid);\n-\n-  for (i = 0; i < max_insn_uid; i++)\n-    is_insn_merge_attempted[i] = MERGE_NOT_ATTEMPTED;\n-\n-  num_re_opportunities = num_realized = 0;\n-\n   reinsn_del_list = VEC_alloc (rtx, heap, 4);\n-\n   reinsn_list = find_removable_extensions ();\n \n-  FOR_EACH_VEC_ELT (ext_cand, reinsn_list, ix, curr_cand)\n+  FOR_EACH_VEC_ELT (ext_cand, reinsn_list, i, curr_cand)\n     {\n       num_re_opportunities++;\n-      /* Try to combine the extension with the definition here.  */\n \n+      /* Try to combine the extension with the definition.  */\n       if (dump_file)\n         {\n-          fprintf (dump_file, \"Trying to eliminate extension : \\n\");\n-          print_rtl_single (dump_file, curr_insn);\n+          fprintf (dump_file, \"Trying to eliminate extension:\\n\");\n+          print_rtl_single (dump_file, curr_cand->insn);\n         }\n \n       if (combine_reaching_defs (curr_cand, PATTERN (curr_cand->insn)))\n         {\n           if (dump_file)\n-            fprintf (dump_file, \"Eliminated the extension...\\n\");\n+            fprintf (dump_file, \"Eliminated the extension.\\n\");\n           num_realized++;\n           VEC_safe_push (rtx, heap, reinsn_del_list, curr_cand->insn);\n         }\n     }\n \n   /* Delete all useless extensions here in one sweep.  */\n-  FOR_EACH_VEC_ELT (rtx, reinsn_del_list, ix, curr_insn)\n+  FOR_EACH_VEC_ELT (rtx, reinsn_del_list, i, curr_insn)\n     delete_insn (curr_insn);\n \n-  free (is_insn_merge_attempted);\n   VEC_free (ext_cand, heap, reinsn_list);\n   VEC_free (rtx, heap, reinsn_del_list);\n \n   if (dump_file && num_re_opportunities > 0)\n-    fprintf (dump_file, \"\\n %s : num_re_opportunities = %ld \"\n-                        \"num_realized = %ld \\n\",\n-                        current_function_name (),\n-                        num_re_opportunities, num_realized);\n+    fprintf (dump_file, \"Elimination opportunities = %d realized = %d\\n\",\n+\t     num_re_opportunities, num_realized);\n \n   df_finish_pass (false);\n-  return 0;\n }\n \n /* Find and remove redundant extensions.  */"}, {"sha": "facbfb71400fbd2e363cf812d7e436b8d4ab5028", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "patch": "@@ -1,3 +1,7 @@\n+2011-12-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20111227-1.c: New test.\n+\n 2011-12-25  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/48641 "}, {"sha": "9fe330d6e99b7bdbc664b6042983f12f42a15e64", "filename": "gcc/testsuite/gcc.c-torture/execute/20111227-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111227-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282bc7b4c5fd895ecc81781e0febb8ec13d9ad86/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111227-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111227-1.c?ref=282bc7b4c5fd895ecc81781e0febb8ec13d9ad86", "patch": "@@ -0,0 +1,30 @@\n+/* PR rtl-optimization/51667 */\n+/* Testcase by Uros Bizjak <ubizjak@gmail.com> */\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  if (a != -1)\n+    abort ();\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (short *a, int t)\n+{\n+  short r = *a;\n+\n+  if (t)\n+    bar ((unsigned short) r);\n+  else\n+    bar ((signed short) r);\n+}\n+\n+short v = -1;\n+\n+int main(void)\n+{\n+  foo (&v, 0);\n+  return 0;\n+}"}]}