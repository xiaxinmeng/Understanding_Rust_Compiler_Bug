{"sha": "cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y2MzNmNWJlOGU4MWZhMjMxNGMwY2RmNzQ0NzZkYzU4MjNlNWRmMg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-07T18:05:22Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-07T18:05:22Z"}, "message": "mips-tfile.c: Convert prototypes to ISO C90.\n\n\n\t* mips-tfile.c: Convert prototypes to ISO C90.\n\t* mips-tdump.c: Convert prototypes to ISO C90.\n\nFrom-SVN: r69048", "tree": {"sha": "c198b756c56aaf43c28c7a703b601710e0d4ffd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c198b756c56aaf43c28c7a703b601710e0d4ffd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0cea056ba1409967d888007cf43e05ac4bd0003f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cea056ba1409967d888007cf43e05ac4bd0003f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cea056ba1409967d888007cf43e05ac4bd0003f"}], "stats": {"total": 603, "additions": 244, "deletions": 359}, "files": [{"sha": "c214ee95d8d069c252604b084959fbc8917b28c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "patch": "@@ -1,3 +1,8 @@\n+2003-07-07  Andreas Jaeger  <aj@suse.de>\n+\n+\t* mips-tfile.c: Convert prototypes to ISO C90.\n+\t* mips-tdump.c: Convert prototypes to ISO C90.\n+\n 2003-07-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* rtl.h (emit_line_note): Take a location_t."}, {"sha": "3a183758c40eaec0de63b02c7be24050fe31103e", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 43, "deletions": 70, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "patch": "@@ -234,19 +234,19 @@ ulong\t*rfile_desc;\t\t/* relative file tables */\n PDR\t*proc_desc;\t\t/* procedure tables */\n \n /* Forward reference for functions.  */\n-static void *read_seek\t\t\tPARAMS ((void *, size_t, off_t, const char *));\n-static void read_tfile\t\t\tPARAMS ((void));\n-static void print_global_hdr\t\tPARAMS ((struct filehdr *));\n-static void print_sym_hdr\t\tPARAMS ((HDRR *));\n-static void print_file_desc\t\tPARAMS ((FDR *, int));\n-static void print_symbol\t\tPARAMS ((SYMR *, int, const char *, AUXU *, int, FDR *));\n-static void print_aux\t\t\tPARAMS ((AUXU, int, int));\n-static void emit_aggregate\t\tPARAMS ((char *, AUXU, AUXU, const char *, FDR *));\n-static const char *st_to_string\t\tPARAMS ((st_t));\n-static const char *sc_to_string\t\tPARAMS ((sc_t));\n-static const char *glevel_to_string\tPARAMS ((glevel_t));\n-static const char *lang_to_string\tPARAMS ((lang_t));\n-static const char *type_to_string\tPARAMS ((AUXU *, int, FDR *));\n+static void *read_seek (void *, size_t, off_t, const char *);\n+static void read_tfile (void);\n+static void print_global_hdr (struct filehdr *);\n+static void print_sym_hdr (HDRR *);\n+static void print_file_desc (FDR *, int);\n+static void print_symbol (SYMR *, int, const char *, AUXU *, int, FDR *);\n+static void print_aux (AUXU, int, int);\n+static void emit_aggregate (char *, AUXU, AUXU, const char *, FDR *);\n+static const char *st_to_string (st_t);\n+static const char *sc_to_string (sc_t);\n+static const char *glevel_to_string (glevel_t);\n+static const char *lang_to_string (lang_t);\n+static const char *type_to_string (AUXU *, int, FDR *);\n \n extern char *optarg;\n extern int   optind;\n@@ -269,14 +269,13 @@ static const struct option options[] =\n   { 0, 0, 0, 0 }\n };\n \f\n-/* Read some bytes at a specified location, and return a pointer.  */\n+/* Read some bytes at a specified location, and return a pointer.\n+   Read_seek takes a pointer PTR to a buffer or NULL and reads SIZE\n+   bytes from offset OFFSET.  In case of errors CONTEXT is used as\n+   error message.  */\n \n static void *\n-read_seek (ptr, size, offset, context)\n-     void *ptr;\t\t\t/* pointer to buffer or NULL */\n-     size_t size;\t\t/* # bytes to read */\n-     off_t offset;\t\t/* offset to read at */\n-     const char *context;\t/* context for error message */\n+read_seek (void *ptr, size_t size, off_t offset,  const char *context)\n {\n   long read_size = 0;\n \n@@ -308,8 +307,7 @@ read_seek (ptr, size, offset, context)\n /* Convert language code to string format.  */\n \n static const char *\n-lang_to_string (lang)\n-     lang_t lang;\n+lang_to_string (lang_t lang)\n {\n   switch (lang)\n     {\n@@ -331,8 +329,7 @@ lang_to_string (lang)\n /* Convert storage class to string.  */\n \n static const char *\n-sc_to_string(storage_class)\n-     sc_t storage_class;\n+sc_to_string (sc_t storage_class)\n {\n   switch(storage_class)\n     {\n@@ -369,8 +366,7 @@ sc_to_string(storage_class)\n /* Convert symbol type to string.  */\n \n static const char *\n-st_to_string(symbol_type)\n-     st_t symbol_type;\n+st_to_string (st_t symbol_type)\n {\n   switch(symbol_type)\n     {\n@@ -410,8 +406,7 @@ st_to_string(symbol_type)\n /* Convert debug level to string.  */\n \n static const char *\n-glevel_to_string (g_level)\n-     glevel_t g_level;\n+glevel_to_string (glevel_t g_level)\n {\n   switch(g_level)\n     {\n@@ -423,15 +418,12 @@ glevel_to_string (g_level)\n \n   return \"??\";\n }\n-     \n+\n \f\n /* Convert the type information to string format.  */\n \n static const char *\n-type_to_string (aux_ptr, index, fdp)\n-     AUXU *aux_ptr;\n-     int index;\n-     FDR *fdp;\n+type_to_string (AUXU *aux_ptr, int index, FDR *fdp)\n {\n   AUXU u;\n   struct qual {\n@@ -741,8 +733,7 @@ type_to_string (aux_ptr, index, fdp)\n /* Print out the global file header for object files.  */\n \n static void\n-print_global_hdr (ptr)\n-     struct filehdr *ptr;\n+print_global_hdr (struct filehdr *ptr)\n {\n   char *time = ctime ((time_t *)&ptr->f_timdat);\n   ushort flags = ptr->f_flags;\n@@ -796,8 +787,7 @@ print_global_hdr (ptr)\n /* Print out the symbolic header.  */\n \n static void\n-print_sym_hdr (sym_ptr)\n-     HDRR *sym_ptr;\n+print_sym_hdr (HDRR *sym_ptr)\n {\n   int width = 20;\n \n@@ -870,13 +860,8 @@ print_sym_hdr (sym_ptr)\n /* Print out a symbol.  */\n \n static void\n-print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n-     SYMR *sym_ptr;\n-     int number;\n-     const char *strbase;\n-     AUXU *aux_base;\n-     int ifd;\n-     FDR *fdp;\n+print_symbol (SYMR *sym_ptr, int number, const char *strbase, AUXU *aux_base,\n+\t      int ifd, FDR *fdp)\n {\n   sc_t storage_class = (sc_t) sym_ptr->sc;\n   st_t symbol_type   = (st_t) sym_ptr->st;\n@@ -1050,10 +1035,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n /* Print out a word from the aux. table in various formats.  */\n \n static void\n-print_aux (u, auxi, used)\n-     AUXU u;\n-     int auxi;\n-     int used;\n+print_aux (AUXU u, int auxi, int used)\n {\n   printf (\"\\t%s#%-5d %11ld, [%4ld/%7ld], [%2d %1d:%1d %1x:%1x:%1x:%1x:%1x:%1x]\\n\",\n \t  (used) ? \"  \" : \"* \",\n@@ -1076,20 +1058,15 @@ print_aux (u, auxi, used)\n /* Write aggregate information to a string.  */\n \n static void\n-emit_aggregate (string, u, u2, which, fdp)\n-     char *string;\n-     AUXU u;\n-     AUXU u2;\n-     const char *which;\n-     FDR *fdp;\n+emit_aggregate (char *string, AUXU u, AUXU u2, const char *which, FDR *fdp)\n {\n   unsigned int ifd = u.rndx.rfd;\n   unsigned int index = u.rndx.index;\n   const char *name;\n-  \n+\n   if (ifd == ST_RFDESCAPE)\n     ifd = u2.isym;\n-  \n+\n   /* An ifd of -1 is an opaque type.  An escaped index of 0 is a\n      struct return type of a procedure compiled without -g.  */\n   if (ifd == 0xffffffff\n@@ -1105,7 +1082,7 @@ emit_aggregate (string, u, u2, which, fdp)\n \tfdp = &file_desc[rfile_desc[fdp->rfdBase + ifd]];\n       name = &l_strings[fdp->issBase + l_symbols[index + fdp->isymBase].iss];\n     }\n-  \n+\n   sprintf (string,\n \t   \"%s %s { ifd = %u, index = %u }\",\n \t   which, name, ifd, index);\n@@ -1116,24 +1093,22 @@ emit_aggregate (string, u, u2, which, fdp)\n    procedures, and line numbers within it.  */\n \n static void\n-print_file_desc (fdp, number)\n-     FDR *fdp;\n-     int number;\n+print_file_desc (FDR *fdp, int number)\n {\n   char *str_base;\n   AUXU *aux_base;\n   int symi, pdi;\n   int width = 20;\n   char *used_base;\n-  \n-  str_base = l_strings + fdp->issBase;  \n+\n+  str_base = l_strings + fdp->issBase;\n   aux_base = aux_symbols + fdp->iauxBase;\n   used_base = aux_used + (aux_base - aux_symbols);\n \n   printf (\"\\nFile #%d, \\\"%s\\\"\\n\\n\",\n \t  number,\n \t  fdp->rss != issNil ? str_base + fdp->rss : \"<unknown>\");\n-    \n+\n   printf (\"    Name index  = %-10ld Readin      = %s\\n\",\n \t  (long) fdp->rss, (fdp->fReadin) ? \"Yes\" : \"No\");\n \n@@ -1203,7 +1178,7 @@ print_file_desc (fdp, number)\n   if (want_scope && cur_scope != (scope_t *) 0)\n     printf (\"\\n    Warning scope does not start at 0!\\n\");\n \n-  /* \n+  /*\n    * print the info about the symbol table.\n    */\n   printf (\"\\n    There are %lu local symbols, starting at %lu\\n\",\n@@ -1256,7 +1231,7 @@ print_file_desc (fdp, number)\n \t}\n     }\n \n-  /* \n+  /*\n    * do the procedure descriptors.\n    */\n   printf (\"\\n    There are %lu procedure descriptor entries, \", (ulong) fdp->cpd);\n@@ -1344,7 +1319,7 @@ print_file_desc (fdp, number)\n /* Read in the portions of the .T file that we will print out.  */\n \n static void\n-read_tfile ()\n+read_tfile (void)\n {\n   short magic;\n   off_t sym_hdr_offset = 0;\n@@ -1436,12 +1411,10 @@ read_tfile ()\n \n \f\n \n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int i, opt;\n \n@@ -1546,7 +1519,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n   for (i = 0; i < sym_hdr.ifdMax; i++)\n     print_file_desc (&file_desc[i], i);\n \n-  /* \n+  /*\n    * Print the external symbols.\n    */\n   want_scope = 0;\t\t/* scope info is meaning for extern symbols */"}, {"sha": "3dbd4e1dcd0ff1cb1cf92e33b628241f65e243cf", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 196, "deletions": 289, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf633f5be8e81fa2314c0cdf74476dc5823e5df2/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=cf633f5be8e81fa2314c0cdf74476dc5823e5df2", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 1991, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n    2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Meissner (meissner@cygnus.com).\n-   \n+\n This file is part of GCC.\n \n GCC is free software; you can redistribute it and/or modify it under\n@@ -98,44 +98,44 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t\tarray, pointer, function, etc. qualifiers.  The\n \t\tcurrent base types that I have documentation for are:\n \n-\t\t\tbtNil\t\t-- undefined \n+\t\t\tbtNil\t\t-- undefined\n \t\t\tbtAdr\t\t-- address - integer same size as ptr\n-\t\t\tbtChar\t\t-- character \n-\t\t\tbtUChar\t\t-- unsigned character \n-\t\t\tbtShort\t\t-- short \n-\t\t\tbtUShort\t-- unsigned short \n-\t\t\tbtInt\t\t-- int \n-\t\t\tbtUInt\t\t-- unsigned int \n-\t\t\tbtLong\t\t-- long \n-\t\t\tbtULong\t\t-- unsigned long \n-\t\t\tbtFloat\t\t-- float (real) \n-\t\t\tbtDouble\t-- Double (real) \n-\t\t\tbtStruct\t-- Structure (Record) \n-\t\t\tbtUnion\t\t-- Union (variant) \n-\t\t\tbtEnum\t\t-- Enumerated \n-\t\t\tbtTypedef\t-- defined via a typedef isymRef \n-\t\t\tbtRange\t\t-- subrange of int \n-\t\t\tbtSet\t\t-- pascal sets \n-\t\t\tbtComplex\t-- fortran complex \n-\t\t\tbtDComplex\t-- fortran double complex \n-\t\t\tbtIndirect\t-- forward or unnamed typedef \n-\t\t\tbtFixedDec\t-- Fixed Decimal \n-\t\t\tbtFloatDec\t-- Float Decimal \n-\t\t\tbtString\t-- Varying Length Character String \n-\t\t\tbtBit\t\t-- Aligned Bit String \n+\t\t\tbtChar\t\t-- character\n+\t\t\tbtUChar\t\t-- unsigned character\n+\t\t\tbtShort\t\t-- short\n+\t\t\tbtUShort\t-- unsigned short\n+\t\t\tbtInt\t\t-- int\n+\t\t\tbtUInt\t\t-- unsigned int\n+\t\t\tbtLong\t\t-- long\n+\t\t\tbtULong\t\t-- unsigned long\n+\t\t\tbtFloat\t\t-- float (real)\n+\t\t\tbtDouble\t-- Double (real)\n+\t\t\tbtStruct\t-- Structure (Record)\n+\t\t\tbtUnion\t\t-- Union (variant)\n+\t\t\tbtEnum\t\t-- Enumerated\n+\t\t\tbtTypedef\t-- defined via a typedef isymRef\n+\t\t\tbtRange\t\t-- subrange of int\n+\t\t\tbtSet\t\t-- pascal sets\n+\t\t\tbtComplex\t-- fortran complex\n+\t\t\tbtDComplex\t-- fortran double complex\n+\t\t\tbtIndirect\t-- forward or unnamed typedef\n+\t\t\tbtFixedDec\t-- Fixed Decimal\n+\t\t\tbtFloatDec\t-- Float Decimal\n+\t\t\tbtString\t-- Varying Length Character String\n+\t\t\tbtBit\t\t-- Aligned Bit String\n \t\t\tbtPicture\t-- Picture\n \t\t\tbtVoid\t\t-- Void (MIPS cc revision >= 2.00)\n \n \t    d)\ttq0 - tq5: type qualifier fields as needed.  The\n \t\tcurrent type qualifier fields I have documentation for\n \t\tare:\n \n-\t\t\ttqNil\t\t-- no more qualifiers \n-\t\t\ttqPtr\t\t-- pointer \n-\t\t\ttqProc\t\t-- procedure \n-\t\t\ttqArray\t\t-- array \n-\t\t\ttqFar\t\t-- 8086 far pointers \n-\t\t\ttqVol\t\t-- volatile \n+\t\t\ttqNil\t\t-- no more qualifiers\n+\t\t\ttqPtr\t\t-- pointer\n+\t\t\ttqProc\t\t-- procedure\n+\t\t\ttqArray\t\t-- array\n+\t\t\ttqFar\t\t-- 8086 far pointers\n+\t\t\ttqVol\t\t-- volatile\n \n \n    The dense number table is used in the front ends, and disappears by\n@@ -244,7 +244,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t}\n \n    Mips-tdump produces the following information:\n-   \n+\n    Global file header:\n        magic number             0x162\n        # sections               2\n@@ -253,12 +253,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n        symbolic header size     96\n        optional header          56\n        flags                    0x0\n-   \n+\n    Symbolic header, magic number = 0x7009, vstamp = 1.31:\n-   \n+\n        Info                      Offset      Number       Bytes\n        ====                      ======      ======      =====\n-   \n+\n        Line numbers                 380           4           4 [13]\n        Dense numbers                  0           0           0\n        Procedures Tables            384           1          52\n@@ -270,14 +270,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n        File Tables                 1008           2         144\n        Relative Files                 0           0           0\n        External Symbols            1152          20         320\n-   \n+\n    File #0, \"hello2.c\"\n-   \n+\n        Name index  = 1          Readin      = No\n        Merge       = No         Endian      = LITTLE\n        Debug level = G2         Language    = C\n        Adr         = 0x00000000\n-   \n+\n        Info                       Start      Number        Size      Offset\n        ====                       =====      ======        ====      ======\n        Local strings                  0          15          15         784\n@@ -287,7 +287,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n        Procedures                     0           1          52         384\n        Auxiliary symbols              0          14          56         628\n        Relative Files                 0           0           0           0\n-   \n+\n     There are 6 local symbols, starting at 436\n \n \tSymbol# 0: \"hello2.c\"\n@@ -636,13 +636,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* The following might be called from obstack or malloc,\n    so they can't be static.  */\n \n-extern void\tpfatal_with_name\n-\t\t\t\tPARAMS ((const char *)) ATTRIBUTE_NORETURN;\n-extern void\tfancy_abort\tPARAMS ((void)) ATTRIBUTE_NORETURN;\n-       void\tbotch\t\tPARAMS ((const char *)) ATTRIBUTE_NORETURN;\n+extern void pfatal_with_name (const char *) ATTRIBUTE_NORETURN;\n+extern void fancy_abort (void) ATTRIBUTE_NORETURN;\n+extern void botch (const char *) ATTRIBUTE_NORETURN;\n \n-extern void\tfatal\t\tPARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void\terror\t\tPARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n+extern void fatal (const char *format, ...) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void error (const char *format, ...) ATTRIBUTE_PRINTF_1;\n \f\n #ifndef MIPS_DEBUGGING_INFO\n \n@@ -654,7 +653,7 @@ static const char *progname;\n static const char *input_name;\n \n int\n-main ()\n+main (void)\n {\n   fprintf (stderr, \"Mips-tfile should only be run on a MIPS computer!\\n\");\n   exit (1);\n@@ -953,7 +952,7 @@ typedef struct varray {\n #define INITIALIZE_VARRAY(x,type)\t\t\t\\\n do {\t\t\t\t\t\t\t\\\n   (x)->object_size = sizeof (type);\t\t\t\\\n-  (x)->objects_per_page = OBJECTS_PER_PAGE (type); \t\\\n+  (x)->objects_per_page = OBJECTS_PER_PAGE (type);\t\\\n   (x)->objects_last_page = OBJECTS_PER_PAGE (type);\t\\\n } while (0)\n \n@@ -1508,8 +1507,8 @@ static char    *cur_line_ptr\t= (char *) 0;\t/* ptr within current line */\n static unsigned\tcur_line_nbytes\t= 0;\t\t/* # bytes for current line */\n static unsigned\tcur_line_alloc\t= 0;\t\t/* # bytes total in buffer */\n static long\tline_number\t= 0;\t\t/* current input line number */\n-static int\tdebug\t\t= 0; \t\t/* trace functions */\n-static int\tversion\t\t= 0; \t\t/* print version # */\n+static int\tdebug\t\t= 0;\t\t/* trace functions */\n+static int\tversion\t\t= 0;\t\t/* print version # */\n static int\tverbose\t\t= 0;\n static int\thad_errors\t= 0;\t\t/* != 0 if errors were found */\n static int\trename_output\t= 0;\t\t/* != 0 if rename output file*/\n@@ -1531,109 +1530,64 @@ static const char stabs_symbol[] = STABS_SYMBOL;\n #define STATIC static\n #endif\n \n-STATIC int\tout_of_bounds\tPARAMS ((symint_t, symint_t, const char *, int));\n-\n-STATIC shash_t *hash_string\tPARAMS ((const char *,\n-\t\t\t\t\t Ptrdiff_t,\n-\t\t\t\t\t shash_t **,\n-\t\t\t\t\t symint_t *));\n-\n-STATIC symint_t\tadd_string\tPARAMS ((varray_t *,\n-\t\t\t\t\t shash_t **,\n-\t\t\t\t\t const char *,\n-\t\t\t\t\t const char *,\n-\t\t\t\t\t shash_t **));\n-\n-STATIC symint_t\tadd_local_symbol\n-\t\t\t\tPARAMS ((const char *,\n-\t\t\t\t\t const char *,\n-\t\t\t\t\t st_t,\n-\t\t\t\t\t sc_t,\n-\t\t\t\t\t symint_t,\n-\t\t\t\t\t symint_t));\n-\n-STATIC symint_t\tadd_ext_symbol\tPARAMS ((EXTR *,\n-  \t\t\t\t\t int));\n-\n-STATIC symint_t\tadd_aux_sym_symint\n-\t\t\t\tPARAMS ((symint_t));\n-\n-STATIC symint_t\tadd_aux_sym_rndx\n-\t\t\t\tPARAMS ((int, symint_t));\n-\n-STATIC symint_t\tadd_aux_sym_tir\tPARAMS ((type_info_t *,\n-\t\t\t\t\t hash_state_t,\n-\t\t\t\t\t thash_t **));\n-\n-STATIC tag_t *\tget_tag\t\tPARAMS ((const char *,\n-\t\t\t\t\t const char *,\n-\t\t\t\t\t symint_t,\n-\t\t\t\t\t bt_t));\n-\n-STATIC void\tadd_unknown_tag\tPARAMS ((tag_t *));\n-\n-STATIC void\tadd_procedure\tPARAMS ((const char *,\n-\t\t\t\t\t const char *));\n-\n-STATIC void\tinitialize_init_file\tPARAMS ((void));\n-\n-STATIC void\tadd_file\tPARAMS ((const char *,\n-\t\t\t\t\t const char *));\n-\n-STATIC void\tadd_bytes\tPARAMS ((varray_t *,\n-\t\t\t\t\t char *,\n-\t\t\t\t\t Size_t));\n-\n-STATIC void\tadd_varray_page\tPARAMS ((varray_t *));\n-\n-STATIC void\tupdate_headers\tPARAMS ((void));\n-\n-STATIC void\twrite_varray\tPARAMS ((varray_t *, off_t, const char *));\n-STATIC void\twrite_object\tPARAMS ((void));\n-STATIC const char *st_to_string\tPARAMS ((st_t));\n-STATIC const char *sc_to_string\tPARAMS ((sc_t));\n-STATIC char    *read_line\tPARAMS ((void));\n-STATIC void\tparse_input\tPARAMS ((void));\n-STATIC void\tmark_stabs\tPARAMS ((const char *));\n-STATIC void\tparse_begin\tPARAMS ((const char *));\n-STATIC void\tparse_bend\tPARAMS ((const char *));\n-STATIC void\tparse_def\tPARAMS ((const char *));\n-STATIC void\tparse_end\tPARAMS ((const char *));\n-STATIC void\tparse_ent\tPARAMS ((const char *));\n-STATIC void\tparse_file\tPARAMS ((const char *));\n-STATIC void\tparse_stabs_common\n-\t\t\t\tPARAMS ((const char *, const char *, const char *));\n-STATIC void\tparse_stabs\tPARAMS ((const char *));\n-STATIC void\tparse_stabn\tPARAMS ((const char *));\n-STATIC page_t  *read_seek\tPARAMS ((Size_t, off_t, const char *));\n-STATIC void\tcopy_object\tPARAMS ((void));\n-\n-STATIC void\tcatch_signal\tPARAMS ((int)) ATTRIBUTE_NORETURN;\n-STATIC page_t  *allocate_page\tPARAMS ((void));\n-\n-STATIC page_t  *allocate_multiple_pages\n-\t\t\t\tPARAMS ((Size_t));\n-\n-STATIC void\tfree_multiple_pages\n-\t\t\t\tPARAMS ((page_t *, Size_t));\n+STATIC int out_of_bounds (symint_t, symint_t, const char *, int);\n+STATIC shash_t *hash_string (const char *, Ptrdiff_t, shash_t **, symint_t *);\n+STATIC symint_t\tadd_string (varray_t *, shash_t **, const char *, const char *,\n+\t\t\t    shash_t **);\n+STATIC symint_t\tadd_local_symbol (const char *, const char *, st_t, sc_t,\n+\t\t\t\t  symint_t, symint_t);\n+STATIC symint_t\tadd_ext_symbol (EXTR *, int);\n+STATIC symint_t\tadd_aux_sym_symint (symint_t);\n+STATIC symint_t\tadd_aux_sym_rndx (int, symint_t);\n+STATIC symint_t\tadd_aux_sym_tir (type_info_t *, hash_state_t, thash_t **);\n+STATIC tag_t *\tget_tag (const char *, const char *, symint_t, bt_t);\n+STATIC void add_unknown_tag (tag_t *);\n+STATIC void add_procedure (const char *, const char *);\n+STATIC void initialize_init_file (void);\n+STATIC void add_file (const char *, const char *);\n+STATIC void add_bytes (varray_t *, char *, Size_t);\n+STATIC void add_varray_page (varray_t *);\n+STATIC void update_headers (void);\n+STATIC void write_varray (varray_t *, off_t, const char *);\n+STATIC void write_object (void);\n+STATIC const char *st_to_string (st_t);\n+STATIC const char *sc_to_string (sc_t);\n+STATIC char *read_line (void);\n+STATIC void parse_input (void);\n+STATIC void mark_stabs (const char *);\n+STATIC void parse_begin (const char *);\n+STATIC void parse_bend (const char *);\n+STATIC void parse_def (const char *);\n+STATIC void parse_end (const char *);\n+STATIC void parse_ent (const char *);\n+STATIC void parse_file (const char *);\n+STATIC void parse_stabs_common (const char *, const char *, const char *);\n+STATIC void parse_stabs (const char *);\n+STATIC void parse_stabn (const char *);\n+STATIC page_t  *read_seek (Size_t, off_t, const char *);\n+STATIC void copy_object (void);\n+\n+STATIC void catch_signal (int) ATTRIBUTE_NORETURN;\n+STATIC page_t *allocate_page (void);\n+STATIC page_t *allocate_multiple_pages (Size_t);\n+STATIC void\tfree_multiple_pages (page_t *, Size_t);\n \n #ifndef MALLOC_CHECK\n-STATIC page_t  *allocate_cluster\n-\t\t\t\tPARAMS ((Size_t));\n+STATIC page_t  *allocate_cluster (Size_t);\n #endif\n \n-STATIC forward_t *allocate_forward\tPARAMS ((void));\n-STATIC scope_t\t *allocate_scope\tPARAMS ((void));\n-STATIC shash_t\t *allocate_shash\tPARAMS ((void));\n-STATIC tag_t\t *allocate_tag\t\tPARAMS ((void));\n-STATIC thash_t\t *allocate_thash\tPARAMS ((void));\n-STATIC thead_t\t *allocate_thead\tPARAMS ((void));\n-STATIC vlinks_t\t *allocate_vlinks\tPARAMS ((void));\n+STATIC forward_t *allocate_forward (void);\n+STATIC scope_t *allocate_scope (void);\n+STATIC shash_t *allocate_shash (void);\n+STATIC tag_t  *allocate_tag (void);\n+STATIC thash_t *allocate_thash (void);\n+STATIC thead_t *allocate_thead (void);\n+STATIC vlinks_t *allocate_vlinks (void);\n \n-STATIC void\t  free_forward\t\tPARAMS ((forward_t *));\n-STATIC void\t  free_scope\t\tPARAMS ((scope_t *));\n-STATIC void\t  free_tag\t\tPARAMS ((tag_t *));\n-STATIC void\t  free_thead\t\tPARAMS ((thead_t *));\n+STATIC void free_forward (forward_t *);\n+STATIC void free_scope (scope_t *);\n+STATIC void free_tag (tag_t *);\n+STATIC void free_thead (thead_t *);\n \n extern char *optarg;\n extern int   optind;\n@@ -1647,7 +1601,7 @@ extern int   opterr;\n typedef struct _pseudo_ops {\n   const char *const name;\t\t\t/* pseudo-op in ascii */\n   const int len;\t\t\t\t/* length of name to compare */\n-  void (*const func) PARAMS ((const char *));\t/* function to handle line */\n+  void (*const func) (const char *);\t/* function to handle line */\n } pseudo_ops_t;\n \n static const pseudo_ops_t pseudo_ops[] = {\n@@ -1677,8 +1631,7 @@ static const struct option options[] =\n /* Add a page to a varray object.  */\n \n STATIC void\n-add_varray_page (vp)\n-     varray_t *vp;\t\t\t\t/* varray to add page to */\n+add_varray_page (varray_t *vp)\n {\n   vlinks_t *new_links = allocate_vlinks ();\n \n@@ -1711,11 +1664,8 @@ add_varray_page (vp)\n #define HASHBITS 30\n \n STATIC shash_t *\n-hash_string (text, hash_len, hash_tbl, ret_hash_index)\n-     const char *text;\t\t\t/* ptr to text to hash */\n-     Ptrdiff_t hash_len;\t\t/* length of the text */\n-     shash_t **hash_tbl;\t\t/* hash table */\n-     symint_t *ret_hash_index;\t\t/* ptr to store hash index */\n+hash_string (const char *text, Ptrdiff_t hash_len, shash_t **hash_tbl,\n+\t     symint_t *ret_hash_index)\n {\n   unsigned long hi;\n   Ptrdiff_t i;\n@@ -1743,16 +1693,15 @@ hash_string (text, hash_len, hash_tbl, ret_hash_index)\n \n \f\n /* Add a string (and null pad) to one of the string tables.  A\n-   consequence of hashing strings, is that we don't let strings\n-   cross page boundaries.  The extra nulls will be ignored.  */\n+   consequence of hashing strings, is that we don't let strings cross\n+   page boundaries.  The extra nulls will be ignored.  VP is a string\n+   virtual array, HASH_TBL a pointer to the hash table, the string\n+   starts at START and the position one byte after the string is given\n+   with END_P1, the resulting hash pointer is returned in RET_HASH.  */\n \n STATIC symint_t\n-add_string (vp, hash_tbl, start, end_p1, ret_hash)\n-     varray_t *vp;\t\t\t/* string virtual array */\n-     shash_t **hash_tbl;\t\t/* ptr to hash table */\n-     const char *start;\t\t\t/* 1st byte in string */\n-     const char *end_p1;\t\t/* 1st byte after string */\n-     shash_t **ret_hash;\t\t/* return hash pointer */\n+add_string (varray_t *vp, shash_t **hash_tbl, const char *start,\n+\t    const char *end_p1, shash_t **ret_hash)\n {\n   Ptrdiff_t len = end_p1 - start;\n   shash_t *hash_ptr;\n@@ -1797,16 +1746,14 @@ add_string (vp, hash_tbl, start, end_p1, ret_hash)\n }\n \n \f\n-/* Add a local symbol.  */\n+/* Add a local symbol.  The symbol string starts at STR_START and the\n+   first byte after it is makred by STR_END_P1.  The symbol has type\n+   TYPE and storage class STORAGE and value VALUE.  INDX is an index\n+   to local/aux. symbols.  */\n \n STATIC symint_t\n-add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n-     const char *str_start;\t\t/* first byte in string */\n-     const char *str_end_p1;\t\t/* first byte after string */\n-     st_t type;\t\t\t\t/* symbol type */\n-     sc_t storage;\t\t\t/* storage class */\n-     symint_t value;\t\t\t/* value of symbol */\n-     symint_t indx;\t\t\t/* index to local/aux. syms */\n+add_local_symbol (const char *str_start, const char *str_end_p1, st_t type,\n+\t\t  sc_t storage,  symint_t value, symint_t indx)\n {\n   symint_t ret;\n   SYMR *psym;\n@@ -1975,12 +1922,11 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n }\n \n \f\n-/* Add an external symbol.  */\n+/* Add an external symbol with symbol pointer ESYM and file index\n+   IFD.  */\n \n STATIC symint_t\n-add_ext_symbol (esym, ifd)\n-     EXTR *esym;\t\t\t/* symbol pointer */\n-     int ifd;\t\t\t\t/* file index */\n+add_ext_symbol (EXTR *esym, int ifd)\n {\n   const char *str_start;\t\t/* first byte in string */\n   const char *str_end_p1;\t\t/* first byte after string */\n@@ -2032,8 +1978,7 @@ add_ext_symbol (esym, ifd)\n /* Add an auxiliary symbol (passing a symint).  */\n \n STATIC symint_t\n-add_aux_sym_symint (aux_word)\n-     symint_t aux_word;\t\t/* auxiliary information word */\n+add_aux_sym_symint (symint_t aux_word)\n {\n   AUXU *aux_ptr;\n   efdr_t *file_ptr = cur_file_ptr;\n@@ -2052,9 +1997,7 @@ add_aux_sym_symint (aux_word)\n /* Add an auxiliary symbol (passing a file/symbol index combo).  */\n \n STATIC symint_t\n-add_aux_sym_rndx (file_index, sym_index)\n-     int file_index;\n-     symint_t sym_index;\n+add_aux_sym_rndx (int file_index, symint_t sym_index)\n {\n   AUXU *aux_ptr;\n   efdr_t *file_ptr = cur_file_ptr;\n@@ -2075,10 +2018,7 @@ add_aux_sym_rndx (file_index, sym_index)\n    type qualifiers).  */\n \n STATIC symint_t\n-add_aux_sym_tir (t, state, hash_tbl)\n-     type_info_t *t;\t\t/* current type information */\n-     hash_state_t state;\t/* whether to hash type or not */\n-     thash_t **hash_tbl;\t/* pointer to hash table to use */\n+add_aux_sym_tir (type_info_t *t, hash_state_t state, thash_t **hash_tbl)\n {\n   AUXU *aux_ptr;\n   efdr_t *file_ptr = cur_file_ptr;\n@@ -2162,7 +2102,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n   ret = vp->num_allocated++;\n \n   /* Add bitfield length if it exists.\n-     \n+\n      NOTE:  Mips documentation claims bitfield goes at the end of the\n      AUX record, but the DECstation compiler emits it here.\n      (This would only make a difference for enum bitfields.)\n@@ -2237,11 +2177,11 @@ add_aux_sym_tir (t, state, hash_tbl)\n /* Add a tag to the tag table (unless it already exists).  */\n \n STATIC tag_t *\n-get_tag (tag_start, tag_end_p1, indx, basic_type)\n-     const char *tag_start;\t\t/* 1st byte of tag name */\n-     const char *tag_end_p1;\t\t/* 1st byte after tag name */\n-     symint_t indx;\t\t\t/* index of tag start block */\n-     bt_t basic_type;\t\t\t/* bt_Struct, bt_Union, or bt_Enum */\n+get_tag (const char *tag_start,\t\t/* 1st byte of tag name */\n+\t const char *tag_end_p1,\t/* 1st byte after tag name */\n+\t symint_t indx,\t\t/* index of tag start block */\n+\t bt_t basic_type)\t\t/* bt_Struct, bt_Union, or bt_Enum */\n+\n {\n   shash_t *hash_ptr;\n   tag_t *tag_ptr;\n@@ -2289,8 +2229,7 @@ get_tag (tag_start, tag_end_p1, indx, basic_type)\n /* Add an unknown {struct, union, enum} tag.  */\n \n STATIC void\n-add_unknown_tag (ptag)\n-     tag_t\t*ptag;\t\t/* pointer to tag information */\n+add_unknown_tag (tag_t *ptag)\n {\n   shash_t *hash_ptr\t= ptag->hash_ptr;\n   char *name_start\t= hash_ptr->string;\n@@ -2349,9 +2288,8 @@ add_unknown_tag (ptag)\n    this procedure, use that to initialize the current PDR.  */\n \n STATIC void\n-add_procedure (func_start, func_end_p1)\n-     const char *func_start;\t\t/* 1st byte of func name */\n-     const char *func_end_p1;\t\t/* 1st byte after func name */\n+add_procedure (const char *func_start,  /* 1st byte of func name */\n+\t       const char *func_end_p1) /* 1st byte after func name */\n {\n   PDR *new_proc_ptr;\n   efdr_t *file_ptr = cur_file_ptr;\n@@ -2413,7 +2351,7 @@ add_procedure (func_start, func_end_p1)\n /* Initialize the init_file structure.  */\n \n STATIC void\n-initialize_init_file ()\n+initialize_init_file (void)\n {\n   memset ((void*) &init_file, 0, sizeof (init_file));\n \n@@ -2438,9 +2376,8 @@ initialize_init_file ()\n    where the current file structure lives.  */\n \n STATIC void\n-add_file (file_start, file_end_p1)\n-     const char *file_start;\t\t/* first byte in string */\n-     const char *file_end_p1;\t\t/* first byte after string */\n+add_file (const char *file_start,  /* first byte in string */\n+\t  const char *file_end_p1) /* first byte after string */\n {\n   static char zero_bytes[2] = { '\\0', '\\0' };\n \n@@ -2521,10 +2458,9 @@ add_file (file_start, file_end_p1)\n /* Add a stream of random bytes to a varray.  */\n \n STATIC void\n-add_bytes (vp, input_ptr, nitems)\n-     varray_t *vp;\t\t\t/* virtual array to add too */\n-     char *input_ptr;\t\t\t/* start of the bytes */\n-     Size_t nitems;\t\t\t/* # items to move */\n+add_bytes (varray_t *vp,\t/* virtual array to add too */\n+\t   char *input_ptr,\t/* start of the bytes */\n+\t   Size_t nitems)\t/* # items to move */\n {\n   Size_t move_items;\n   Size_t move_bytes;\n@@ -2560,8 +2496,7 @@ add_bytes (vp, input_ptr, nitems)\n /* Convert storage class to string.  */\n \n STATIC const char *\n-sc_to_string (storage_class)\n-     sc_t storage_class;\n+sc_to_string (sc_t storage_class)\n {\n   switch (storage_class)\n     {\n@@ -2598,8 +2533,7 @@ sc_to_string (storage_class)\n /* Convert symbol type to string.  */\n \n STATIC const char *\n-st_to_string (symbol_type)\n-     st_t symbol_type;\n+st_to_string (st_t symbol_type)\n {\n   switch (symbol_type)\n     {\n@@ -2635,7 +2569,7 @@ st_to_string (symbol_type)\n    semi-colon, and return each logical line independently.  */\n \n STATIC char *\n-read_line ()\n+read_line (void)\n {\n   static   int line_split_p\t= 0;\n   int string_p\t\t= 0;\n@@ -2711,8 +2645,7 @@ read_line ()\n    which gives the location of the start of the block.  */\n \n STATIC void\n-parse_begin (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_begin (const char *start)\n {\n   const char *end_p1;\t\t\t/* end of label */\n   int ch;\n@@ -2763,8 +2696,7 @@ parse_begin (start)\n    which gives the location of the end of the block.  */\n \n STATIC void\n-parse_bend (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_bend (const char *start)\n {\n   const char *end_p1;\t\t\t/* end of label */\n   int ch;\n@@ -2822,8 +2754,7 @@ parse_bend (start)\n \t.tag\tspecify a tag for a struct, union, or enum.  */\n \n STATIC void\n-parse_def (name_start)\n-     const char *name_start;\t\t\t/* start of directive */\n+parse_def (const char *name_start)\n {\n   const char *dir_start;\t\t\t/* start of current directive*/\n   const char *dir_end_p1;\t\t\t/* end+1 of current directive*/\n@@ -3142,7 +3073,7 @@ parse_def (name_start)\n \t\t class, symbol type, etc.  */\n \t      else\n \t\t{\n-\t\t  shash_t *orig_hash_ptr; \t/* hash within orig sym table*/\n+\t\t  shash_t *orig_hash_ptr;\t/* hash within orig sym table*/\n \t\t  shash_t *ext_hash_ptr;\t/* hash within ext. sym table*/\n \n \t\t  ext_hash_ptr = hash_string (arg_start,\n@@ -3397,8 +3328,7 @@ parse_def (name_start)\n /* Parse .end directives.  */\n \n STATIC void\n-parse_end (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_end (const char *start)\n {\n   const char *start_func, *end_func_p1;\n   int ch;\n@@ -3460,8 +3390,7 @@ parse_end (start)\n /* Parse .ent directives.  */\n \n STATIC void\n-parse_ent (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_ent (const char *start)\n {\n   const char *start_func, *end_func_p1;\n   int ch;\n@@ -3498,8 +3427,7 @@ parse_ent (start)\n /* Parse .file directives.  */\n \n STATIC void\n-parse_file (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_file (const char *start)\n {\n   char *p;\n   char *start_name, *end_name_p1;\n@@ -3526,8 +3454,7 @@ parse_file (start)\n /* Make sure the @stabs symbol is emitted.  */\n \n static void\n-mark_stabs (start)\n-  const char *start ATTRIBUTE_UNUSED;\t/* Start of directive (ignored) */\n+mark_stabs (const char *start ATTRIBUTE_UNUSED)\n {\n   if (!stabs_seen)\n     {\n@@ -3571,10 +3498,9 @@ mark_stabs (start)\n \tvalue\t\ta numeric value or an address.  */\n \n STATIC void\n-parse_stabs_common (string_start, string_end, rest)\n-     const char *string_start;\t\t/* start of string or NULL */\n-     const char *string_end;\t\t/* end+1 of string or NULL */\n-     const char *rest;\t\t\t/* rest of the directive.  */\n+parse_stabs_common (const char *string_start,\t/* start of string or NULL */\n+\t\t    const char *string_end,\t/* end+1 of string or NULL */\n+\t\t    const char *rest)\t\t/* rest of the directive.  */\n {\n   efdr_t *save_file_ptr = cur_file_ptr;\n   symint_t code;\n@@ -3770,8 +3696,7 @@ parse_stabs_common (string_start, string_end, rest)\n \n \n STATIC void\n-parse_stabs (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_stabs (const char *start)\n {\n   const char *end = strchr (start+1, '\"');\n \n@@ -3786,8 +3711,7 @@ parse_stabs (start)\n \n \n STATIC void\n-parse_stabn (start)\n-     const char *start;\t\t\t/* start of directive */\n+parse_stabn (const char *start)\n {\n   parse_stabs_common ((const char *) 0, (const char *) 0, start);\n }\n@@ -3797,7 +3721,7 @@ parse_stabn (start)\n    if needed.  */\n \n STATIC void\n-parse_input ()\n+parse_input (void)\n {\n   char *p;\n   Size_t i;\n@@ -3860,7 +3784,7 @@ parse_input ()\n    to write out the .T file.  */\n \n STATIC void\n-update_headers ()\n+update_headers (void)\n {\n   symint_t i;\n   efdr_t *file_ptr;\n@@ -3916,7 +3840,7 @@ update_headers ()\n \t      hash_ptr = hash_string (str,\n \t\t\t\t      (Ptrdiff_t) len,\n \t\t\t\t      &file_ptr->shash_head[0],\n-\t\t\t  \t      (symint_t *) 0);\n+\t\t\t\t      (symint_t *) 0);\n \t      if (hash_ptr == (shash_t *) 0)\n \t\t{\n \t\t  (void) add_local_symbol (str, str + len,\n@@ -4046,10 +3970,9 @@ update_headers ()\n /* Write out a varray at a given location.  */\n \n STATIC void\n-write_varray (vp, offset, str)\n-     varray_t *vp;\t\t\t/* virtual array */\n-     off_t offset;\t\t\t/* offset to write varray to */\n-     const char *str;\t\t\t/* string to print out when tracing */\n+write_varray (varray_t *vp,    /* virtual array */\n+\t      off_t offset,    /* offset to write varray to */\n+\t      const char *str) /* string to print out when tracing */\n {\n   int num_write, sys_write;\n   vlinks_t *ptr;\n@@ -4064,7 +3987,7 @@ write_varray (vp, offset, str)\n       fprintf (stderr, \", offset = %7lu, size = %7lu, %s\\n\",\n \t       (unsigned long) offset, vp->num_allocated * vp->object_size, str);\n     }\n-  \n+\n   if (file_offset != (unsigned long) offset\n       && fseek (object_stream, (long) offset, SEEK_SET) < 0)\n     pfatal_with_name (object_name);\n@@ -4093,7 +4016,7 @@ write_varray (vp, offset, str)\n /* Write out the symbol table in the object file.  */\n \n STATIC void\n-write_object ()\n+write_object (void)\n {\n   int sys_write;\n   efdr_t *file_ptr;\n@@ -4332,10 +4255,9 @@ write_object ()\n /* Read some bytes at a specified location, and return a pointer.  */\n \n STATIC page_t *\n-read_seek (size, offset, str)\n-     Size_t size;\t\t/* # bytes to read */\n-     off_t offset;\t\t/* offset to read at */\n-     const char *str;\t\t/* name for tracing */\n+read_seek (Size_t size,\t\t/* # bytes to read */\n+\t   off_t offset,\t/* offset to read at */\n+\t   const char *str)\t/* name for tracing */\n {\n   page_t *ptr;\n   long sys_read = 0;\n@@ -4402,7 +4324,7 @@ read_seek (size, offset, str)\n    symbol table.  */\n \n STATIC void\n-copy_object ()\n+copy_object (void)\n {\n   char buffer[ PAGE_SIZE ];\n   int sys_read;\n@@ -4771,12 +4693,10 @@ copy_object ()\n \f\n /* Ye olde main program.  */\n \n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int iflag = 0;\n   char *p = strrchr (argv[0], '/');\n@@ -4873,7 +4793,7 @@ main (argc, argv)\n       fputs (_(\"Copyright (C) 2003 Free Software Foundation, Inc.\\n\"), stdout);\n       fputs (_(\"This is free software; see the source for copying conditions.  There is NO\\n\\\n warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"),\n-     \t     stdout);\n+\t     stdout);\n       exit (0);\n     }\n \n@@ -5009,8 +4929,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n /* Catch a signal and exit without dumping core.  */\n \n STATIC void\n-catch_signal (signum)\n-     int signum;\n+catch_signal (int signum)\n {\n   (void) signal (signum, SIG_DFL);\t/* just in case...  */\n   fatal (\"%s\", strsignal (signum));\n@@ -5020,8 +4939,7 @@ catch_signal (signum)\n    Also include a system error message based on `errno'.  */\n \n void\n-pfatal_with_name (msg)\n-  const char *msg;\n+pfatal_with_name (const char *msg)\n {\n   int save_errno = errno;\t\t/* just in case....  */\n   if (line_number > 0)\n@@ -5044,11 +4962,10 @@ pfatal_with_name (msg)\n    ORIG_xxx macros, but the function never returns.  */\n \n static int\n-out_of_bounds (indx, max, str, prog_line)\n-     symint_t indx;\t\t/* index that is out of bounds */\n-     symint_t max;\t\t/* maximum index */\n-     const char *str;\t\t/* string to print out */\n-     int prog_line;\t\t/* line number within mips-tfile.c */\n+out_of_bounds (symint_t indx,\t/* index that is out of bounds */\n+\t       symint_t max,\t/* maximum index */\n+\t       const char *str, /* string to print out */\n+\t       int prog_line)\t/* line number within mips-tfile.c */\n {\n   if (indx < max)\t\t/* just in case */\n     return 0;\n@@ -5069,8 +4986,7 @@ out_of_bounds (indx, max, str, prog_line)\n #ifdef USE_MALLOC\n \n STATIC page_t *\n-allocate_cluster (npages)\n-     Size_t npages;\n+allocate_cluster (Size_t npages)\n {\n   page_t *value = (page_t *) xcalloc (npages, PAGE_USIZE);\n \n@@ -5083,8 +4999,7 @@ allocate_cluster (npages)\n #else /* USE_MALLOC */\n \n STATIC page_t *\n-allocate_cluster (npages)\n-     Size_t npages;\n+allocate_cluster (Size_t npages)\n {\n   page_t *ptr = (page_t *) sbrk (0);\t/* current sbreak */\n   unsigned long offset = ((unsigned long) ptr) & (PAGE_SIZE - 1);\n@@ -5123,8 +5038,7 @@ static unsigned\t pages_left\t= 0;\n /* Allocate some pages (which is initialized to 0).  */\n \n STATIC page_t *\n-allocate_multiple_pages (npages)\n-     Size_t npages;\n+allocate_multiple_pages (Size_t npages)\n {\n #ifndef MALLOC_CHECK\n   if (pages_left == 0 && npages < MAX_CLUSTER_PAGES)\n@@ -5153,9 +5067,7 @@ allocate_multiple_pages (npages)\n /* Release some pages.  */\n \n STATIC void\n-free_multiple_pages (page_ptr, npages)\n-     page_t *page_ptr;\n-     Size_t npages;\n+free_multiple_pages (page_t *page_ptr, Size_t npages)\n {\n #ifndef MALLOC_CHECK\n   if (pages_left == 0)\n@@ -5184,7 +5096,7 @@ free_multiple_pages (page_ptr, npages)\n /* Allocate one page (which is initialized to 0).  */\n \n STATIC page_t *\n-allocate_page ()\n+allocate_page (void)\n {\n #ifndef MALLOC_CHECK\n   if (pages_left == 0)\n@@ -5206,7 +5118,7 @@ allocate_page ()\n /* Allocate scoping information.  */\n \n STATIC scope_t *\n-allocate_scope ()\n+allocate_scope (void)\n {\n   scope_t *ptr;\n   static scope_t initial_scope;\n@@ -5245,8 +5157,7 @@ allocate_scope ()\n /* Free scoping information.  */\n \n STATIC void\n-free_scope (ptr)\n-     scope_t *ptr;\n+free_scope (scope_t *ptr)\n {\n   alloc_counts[ (int) alloc_type_scope ].total_free++;\n \n@@ -5264,7 +5175,7 @@ free_scope (ptr)\n /* Allocate links for pages in a virtual array.  */\n \n STATIC vlinks_t *\n-allocate_vlinks ()\n+allocate_vlinks (void)\n {\n   vlinks_t *ptr;\n   static vlinks_t initial_vlinks;\n@@ -5297,7 +5208,7 @@ allocate_vlinks ()\n /* Allocate string hash buckets.  */\n \n STATIC shash_t *\n-allocate_shash ()\n+allocate_shash (void)\n {\n   shash_t *ptr;\n   static shash_t initial_shash;\n@@ -5330,7 +5241,7 @@ allocate_shash ()\n /* Allocate type hash buckets.  */\n \n STATIC thash_t *\n-allocate_thash ()\n+allocate_thash (void)\n {\n   thash_t *ptr;\n   static thash_t initial_thash;\n@@ -5363,7 +5274,7 @@ allocate_thash ()\n /* Allocate structure, union, or enum tag information.  */\n \n STATIC tag_t *\n-allocate_tag ()\n+allocate_tag (void)\n {\n   tag_t *ptr;\n   static tag_t initial_tag;\n@@ -5402,8 +5313,7 @@ allocate_tag ()\n /* Free scoping information.  */\n \n STATIC void\n-free_tag (ptr)\n-     tag_t *ptr;\n+free_tag (tag_t *ptr)\n {\n   alloc_counts[ (int) alloc_type_tag ].total_free++;\n \n@@ -5421,7 +5331,7 @@ free_tag (ptr)\n /* Allocate forward reference to a yet unknown tag.  */\n \n STATIC forward_t *\n-allocate_forward ()\n+allocate_forward (void)\n {\n   forward_t *ptr;\n   static forward_t initial_forward;\n@@ -5460,8 +5370,7 @@ allocate_forward ()\n /* Free scoping information.  */\n \n STATIC void\n-free_forward (ptr)\n-     forward_t *ptr;\n+free_forward (forward_t *ptr)\n {\n   alloc_counts[ (int) alloc_type_forward ].total_free++;\n \n@@ -5479,7 +5388,7 @@ free_forward (ptr)\n /* Allocate head of type hash list.  */\n \n STATIC thead_t *\n-allocate_thead ()\n+allocate_thead (void)\n {\n   thead_t *ptr;\n   static thead_t initial_thead;\n@@ -5518,8 +5427,7 @@ allocate_thead ()\n /* Free scoping information.  */\n \n STATIC void\n-free_thead (ptr)\n-     thead_t *ptr;\n+free_thead (thead_t *ptr)\n {\n   alloc_counts[ (int) alloc_type_thead ].total_free++;\n \n@@ -5542,7 +5450,7 @@ void\n fatal (const char *format, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n \n   if (line_number > 0)\n@@ -5564,7 +5472,7 @@ void\n error (const char *format, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n \n   if (line_number > 0)\n@@ -5587,7 +5495,7 @@ error (const char *format, ...)\n    config.h can #define abort fancy_abort if you like that sort of thing.  */\n \n void\n-fancy_abort ()\n+fancy_abort (void)\n {\n   fatal (\"internal abort\");\n }\n@@ -5597,8 +5505,7 @@ fancy_abort ()\n    it calls this function to report clobberage.  */\n \n void\n-botch (s)\n-     const char *s;\n+botch (const char *s)\n {\n   fatal (\"%s\", s);\n }"}]}