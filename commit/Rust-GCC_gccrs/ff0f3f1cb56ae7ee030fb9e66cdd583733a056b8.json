{"sha": "ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYwZjNmMWNiNTZhZTdlZTAzMGZiOWU2NmNkZDU4MzczM2EwNTZiOA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-09-07T14:56:59Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-09-07T14:56:59Z"}, "message": "Improve aarch64_legitimize_address - avoid splitting the offset if it is supported.\n\nImprove aarch64_legitimize_address - avoid splitting the offset if it is\nsupported.  When we do split, take the mode size into account.  BLKmode\nfalls into the unaligned case but should be treated like LDP/STP.\nThis improves codesize slightly due to fewer base address calculations:\n\nint f(int *p) { return p[5000] + p[7000]; }\n\nNow generates:\n\nf:\n\tadd\tx0, x0, 16384\n\tldr\tw1, [x0, 3616]\n\tldr\tw0, [x0, 11616]\n\tadd\tw0, w1, w0\n\tret\n\ninstead of:\n\nf:\n\tadd\tx1, x0, 16384\n\tadd\tx0, x0, 24576\n\tldr\tw1, [x1, 3616]\n\tldr\tw0, [x0, 3424]\n\tadd\tw0, w1, w0\n\tret\n\n    gcc/\n\t* config/aarch64/aarch64.c (aarch64_legitimize_address):\n\tAvoid use of base_offset if offset already in range.\n\nFrom-SVN: r240026", "tree": {"sha": "ec1572aa2f7fba6f3e827f68a120f7bdd0368c78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec1572aa2f7fba6f3e827f68a120f7bdd0368c78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8/comments", "author": null, "committer": null, "parents": [{"sha": "ca235a8500c9e6c5ad1983ef91bb92c6d40861a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca235a8500c9e6c5ad1983ef91bb92c6d40861a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca235a8500c9e6c5ad1983ef91bb92c6d40861a8"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "c39b35175a741cb5d82f7da20cf315a1727dd7c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8", "patch": "@@ -1,3 +1,8 @@\n+2016-09-07  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_legitimize_address):\n+\tAvoid use of base_offset if offset already in range.\n+\n 2016-09-07  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh-protos.h (struct sh_atomic_model,"}, {"sha": "2be750e7de4227bfdd4dd35f716f2344c824cc4a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ff0f3f1cb56ae7ee030fb9e66cdd583733a056b8", "patch": "@@ -5082,9 +5082,19 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n       /* For offsets aren't a multiple of the access size, the limit is\n \t -256...255.  */\n       else if (offset & (GET_MODE_SIZE (mode) - 1))\n-\tbase_offset = (offset + 0x100) & ~0x1ff;\n+\t{\n+\t  base_offset = (offset + 0x100) & ~0x1ff;\n+\n+\t  /* BLKmode typically uses LDP of X-registers.  */\n+\t  if (mode == BLKmode)\n+\t    base_offset = (offset + 512) & ~0x3ff;\n+\t}\n+      /* Small negative offsets are supported.  */\n+      else if (IN_RANGE (offset, -256, 0))\n+\tbase_offset = 0;\n+      /* Use 12-bit offset by access size.  */\n       else\n-\tbase_offset = offset & ~0xfff;\n+\tbase_offset = offset & (~0xfff * GET_MODE_SIZE (mode));\n \n       if (base_offset != 0)\n \t{"}]}