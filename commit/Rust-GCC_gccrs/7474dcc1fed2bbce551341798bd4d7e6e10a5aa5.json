{"sha": "7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ3NGRjYzFmZWQyYmJjZTU1MTM0MTc5OGJkNGQ3ZTZlMTBhNWFhNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-06-13T07:48:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-06-13T07:48:25Z"}, "message": "re PR fortran/70673 (ICE with module containing functions with allocatable character scalars)\n\n2016-06-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/70673\n\t* frontend-passes.c (realloc_string_callback): Add a call to\n\tgfc_dep_compare_expr.\n\n2016-06-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/70673\n\t* gfortran.dg/pr70673.f90: New test.\n\nFrom-SVN: r237358", "tree": {"sha": "d824da44ba24c42739cbfadd63414158e1d47e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d824da44ba24c42739cbfadd63414158e1d47e24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/comments", "author": null, "committer": null, "parents": [{"sha": "4eb27c4174aea9d4930552c77bff75b662b4b849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb27c4174aea9d4930552c77bff75b662b4b849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb27c4174aea9d4930552c77bff75b662b4b849"}], "stats": {"total": 107, "additions": 75, "deletions": 32}, "files": [{"sha": "998255a9bff26f8b71bc0efe4e3cf2cc6edad170", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "patch": "@@ -1,3 +1,9 @@\n+2016-06-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/70673\n+\t* frontend-passes.c (realloc_string_callback): Add a call to\n+\tgfc_dep_compare_expr.\n+\n 2016-06-11  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR fortran/60751"}, {"sha": "f02a52ace8b2a614dfc03c4caeb9b23c98e6d1bb", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "patch": "@@ -45,7 +45,7 @@ static void realloc_strings (gfc_namespace *);\n static gfc_expr *create_var (gfc_expr *, const char *vname=NULL);\n static int inline_matmul_assign (gfc_code **, int *, void *);\n static gfc_code * create_do_loop (gfc_expr *, gfc_expr *, gfc_expr *,\n-\t\t\t\t  locus *, gfc_namespace *, \n+\t\t\t\t  locus *, gfc_namespace *,\n \t\t\t\t  char *vname=NULL);\n \n /* How deep we are inside an argument list.  */\n@@ -108,7 +108,7 @@ static int var_num = 1;\n \n enum matrix_case { none=0, A2B2, A2B1, A1B2, A2B2T };\n \n-/* Keep track of the number of expressions we have inserted so far \n+/* Keep track of the number of expressions we have inserted so far\n    using create_var.  */\n \n int n_vars;\n@@ -142,7 +142,7 @@ gfc_run_passes (gfc_namespace *ns)\n \n /* Callback for each gfc_code node invoked from check_realloc_strings.\n    For an allocatable LHS string which also appears as a variable on\n-   the RHS, replace \n+   the RHS, replace\n \n    a = a(x:y)\n \n@@ -175,6 +175,13 @@ realloc_string_callback (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   if (!gfc_check_dependency (expr1, expr2, true))\n     return 0;\n \n+  /* gfc_check_dependency doesn't always pick up identical expressions.\n+     However, eliminating the above sends the compiler into an infinite\n+     loop on valid expressions.  Without this check, the gimplifier emits\n+     an ICE for a = a, where a is deferred character length.  */\n+  if (!gfc_dep_compare_expr (expr1, expr2))\n+    return 0;\n+\n   current_code = c;\n   inserted_block = NULL;\n   changed_statement = NULL;\n@@ -422,7 +429,7 @@ cfe_register_funcs (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n     return 0;\n \n   /* We don't do character functions with unknown charlens.  */\n-  if ((*e)->ts.type == BT_CHARACTER \n+  if ((*e)->ts.type == BT_CHARACTER\n       && ((*e)->ts.u.cl == NULL || (*e)->ts.u.cl->length == NULL\n \t  || (*e)->ts.u.cl->length->expr_type != EXPR_CONSTANT))\n     return 0;\n@@ -446,7 +453,7 @@ cfe_register_funcs (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n   if ((*e)->rank > 0 && (*e)->shape == NULL && !flag_realloc_lhs)\n     return 0;\n-  \n+\n   /* Skip the test for pure functions if -faggressive-function-elimination\n      is specified.  */\n   if ((*e)->value.function.esym)\n@@ -528,7 +535,7 @@ constant_string_length (gfc_expr *e)\n \t{\n \t  res = gfc_get_constant_expr (BT_INTEGER, gfc_charlen_int_kind,\n \t\t\t\t       &e->where);\n-\t  \n+\n \t  mpz_add_ui (res->value.integer, value, 1);\n \t  mpz_clear (value);\n \t  return res;\n@@ -568,7 +575,7 @@ insert_block ()\n       /* If the statement has a label,  make sure it is transferred to\n \t the newly created block.  */\n \n-      if ((*current_code)->here) \n+      if ((*current_code)->here)\n \t{\n \t  inserted_block->here = (*current_code)->here;\n \t  (*current_code)->here = NULL;\n@@ -640,12 +647,12 @@ create_var (gfc_expr * e, const char *vname)\n \t  for (i=0; i<e->rank; i++)\n \t    {\n \t      gfc_expr *p, *q;\n-      \n+\n \t      p = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n \t\t\t\t\t &(e->where));\n \t      mpz_set_si (p->value.integer, 1);\n \t      symbol->as->lower[i] = p;\n-\t      \n+\n \t      q = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,\n \t\t\t\t\t &(e->where));\n \t      mpz_set (q->value.integer, e->shape[i]);\n@@ -812,7 +819,7 @@ cfe_code (gfc_code **c, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       *walk_subtrees = 0;\n       return 0;\n     }\n-  \n+\n \n   return 0;\n }\n@@ -1077,8 +1084,8 @@ optimize_binop_array_assignment (gfc_code *c, gfc_expr **rhs, bool seen_op)\n \t}\n     }\n   else if (seen_op && e->expr_type == EXPR_FUNCTION && e->rank > 0\n-\t   && ! (e->value.function.esym \n-\t\t && (e->value.function.esym->attr.elemental \n+\t   && ! (e->value.function.esym\n+\t\t && (e->value.function.esym->attr.elemental\n \t\t     || e->value.function.esym->attr.allocatable\n \t\t     || e->value.function.esym->ts.type != c->expr1->ts.type\n \t\t     || e->value.function.esym->ts.kind != c->expr1->ts.kind))\n@@ -1104,7 +1111,7 @@ optimize_binop_array_assignment (gfc_code *c, gfc_expr **rhs, bool seen_op)\n       new_expr = gfc_copy_expr (c->expr1);\n       c->expr2 = e;\n       *rhs = new_expr;\n-      \n+\n       return true;\n \n     }\n@@ -1337,7 +1344,7 @@ optimize_power (gfc_expr *e)\n \t\t\t\t       \"_internal_iand\", e->where, 2, op2,\n \t\t\t\t       gfc_get_int_expr (e->ts.kind,\n \t\t\t\t\t\t\t &e->where, 1));\n-\t\t\t\t   \n+\n       ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,\n \t\t\t\t\t\"_internal_ishft\", e->where, 2, iand,\n \t\t\t\t\tgfc_get_int_expr (e->ts.kind,\n@@ -1672,7 +1679,7 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t    case INTRINSIC_EQ:\n \t      result = eq == 0;\n \t      break;\n-\t      \n+\n \t    case INTRINSIC_GE:\n \t      result = eq >= 0;\n \t      break;\n@@ -1692,7 +1699,7 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t    case INTRINSIC_LT:\n \t      result = eq < 0;\n \t      break;\n-\t      \n+\n \t    default:\n \t      gfc_internal_error (\"illegal OP in optimize_comparison\");\n \t      break;\n@@ -1876,12 +1883,12 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  FOR_EACH_VEC_ELT (doloop_list, i, cl)\n \t    {\n \t      gfc_symbol *do_sym;\n-\t      \n+\n \t      if (cl == NULL)\n \t\tbreak;\n \n \t      do_sym = cl->ext.iterator->var->symtree->n.sym;\n-\t      \n+\n \t      if (a->expr && a->expr->symtree\n \t\t  && a->expr->symtree->n.sym == do_sym)\n \t\t{\n@@ -1953,7 +1960,7 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t    break;\n \n \t  do_sym = dl->ext.iterator->var->symtree->n.sym;\n-\t  \n+\n \t  if (a->expr && a->expr->symtree\n \t      && a->expr->symtree->n.sym == do_sym)\n \t    {\n@@ -2184,7 +2191,7 @@ runtime_error_ne (gfc_expr *e1, gfc_expr *e2, const char *msg)\n /* Handle matrix reallocation.  Caller is responsible to insert into\n    the code tree.\n \n-   For the two-dimensional case, build \n+   For the two-dimensional case, build\n \n   if (allocated(c)) then\n      if (size(c,1) /= size(a,1) .or. size(c,2) /= size(b,2)) then\n@@ -2277,7 +2284,7 @@ matmul_lhs_realloc (gfc_expr *c, gfc_expr *a, gfc_expr *b,\n \n   /* We need two identical allocate statements in two\n      branches of the IF statement.  */\n-  \n+\n   allocate1 = XCNEW (gfc_code);\n   allocate1->op = EXEC_ALLOCATE;\n   allocate1->ext.alloc.list = gfc_get_alloc ();\n@@ -2300,7 +2307,7 @@ matmul_lhs_realloc (gfc_expr *c, gfc_expr *a, gfc_expr *b,\n   deallocate->ext.alloc.list->expr = gfc_copy_expr (c);\n   deallocate->next = allocate1;\n   deallocate->loc = c->where;\n-  \n+\n   if_size_2 = XCNEW (gfc_code);\n   if_size_2->op = EXEC_IF;\n   if_size_2->expr1 = cond;\n@@ -2580,7 +2587,7 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \n   /* Loop over the indices.  For each index, create the expression\n      index * stride + lbound(e, dim).  */\n-  \n+\n   i_index = 0;\n   for (i=0; i < ar->dimen; i++)\n     {\n@@ -2590,9 +2597,9 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \t    {\n \t      gfc_expr *lbound, *nindex;\n \t      gfc_expr *loopvar;\n-\t      \n-\t      loopvar = gfc_copy_expr (index[i_index]); \n-\t      \n+\n+\t      loopvar = gfc_copy_expr (index[i_index]);\n+\n \t      if (ar->stride[i])\n \t\t{\n \t\t  gfc_expr *tmp;\n@@ -2610,7 +2617,7 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \t\t}\n \t      else\n \t\tnindex = loopvar;\n-\t      \n+\n \t      /* Calculate the lower bound of the expression.  */\n \t      if (ar->start[i])\n \t\t{\n@@ -2677,12 +2684,12 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \t\t\t\t\t\t   i + 1);\n \t\t  gfc_free_expr (lbound_e);\n \t\t}\n-\t      \n+\n \t      ar->dimen_type[i] = DIMEN_ELEMENT;\n \n \t      gfc_free_expr (ar->start[i]);\n \t      ar->start[i] = get_operand (INTRINSIC_PLUS, nindex, lbound);\n-\t      \n+\n \t      gfc_free_expr (ar->end[i]);\n \t      ar->end[i] = NULL;\n \t      gfc_free_expr (ar->stride[i]);\n@@ -2781,7 +2788,7 @@ check_conjg_transpose_variable (gfc_expr *e, bool *conjg, bool *transpose)\n        end do\n      end do\n    END BLOCK\n-   \n+\n */\n \n static int\n@@ -3213,7 +3220,7 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \t\t\t\t\tmatrix_a->where, 1, ascalar);\n \n   if (conjg_b)\n-    bscalar = gfc_build_intrinsic_call (ns, GFC_ISYM_CONJG, \"conjg\", \n+    bscalar = gfc_build_intrinsic_call (ns, GFC_ISYM_CONJG, \"conjg\",\n \t\t\t\t\tmatrix_b->where, 1, bscalar);\n \n   /* First loop comes after the zero assignment.  */\n@@ -3586,7 +3593,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      /* This goto serves as a shortcut to avoid code\n \t\t duplication or a larger if or switch statement.  */\n \t      goto check_omp_clauses;\n-\t      \n+\n \t    case EXEC_OMP_WORKSHARE:\n \t    case EXEC_OMP_PARALLEL_WORKSHARE:\n "}, {"sha": "506c7f77b5331eba4649cc130295c2f4a3a4851f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "patch": "@@ -1,3 +1,8 @@\n+2016-06-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/70673\n+\t* gfortran.dg/pr70673.f90: New test.\n+\n 2016-06-13  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/64516"}, {"sha": "67856e0332e95623b664f53b7c37295fd294debe", "filename": "gcc/testsuite/gfortran.dg/pr70673.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr70673.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474dcc1fed2bbce551341798bd4d7e6e10a5aa5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr70673.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr70673.f90?ref=7474dcc1fed2bbce551341798bd4d7e6e10a5aa5", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR70673\n+!\n+! Contributed by David Kinniburgh  <davidgkinniburgh@yahoo.co.uk>\n+!\n+module m\n+contains\n+  subroutine s(inp)\n+    character(*), intent(in) :: inp\n+    character(:), allocatable :: a\n+    a = a           ! This used to ICE.\n+    a = inp\n+    a = a           ! This used to ICE too\n+    if ((len (a) .ne. 5) .or. (a .ne. \"hello\")) call abort\n+    a = a(2:3)      ! Make sure that temporary creation is not broken.\n+    if ((len (a) .ne. 2) .or. (a .ne. \"el\")) call abort\n+    deallocate (a)\n+    a = a           ! This would ICE too.\n+  end subroutine s\n+end module m\n+\n+  use m\n+  call s(\"hello\")\n+end"}]}