{"sha": "1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY3N2I1ZGE5ODFkYWU2OWU4ZThkN2VhM2RjNjBiYTk1MTUwYzI2Nw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-05-06T22:59:38Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-05-06T22:59:38Z"}, "message": "re PR rtl-optimization/3995 (i386 optimisation: joining tests)\n\n\tPR opt/3995\n\t* fold-const.c (sign_bit_p): New function.\n\t(fold) [EQ_EXPR]: Use this to convert (A & C) == 0 into A >= 0 and\n        (A & C) != 0 into A < 0, when constant C is the sign bit of A's type.\n\tReapply fold when converting (A & C) == C into (A & C) != 0.\n\t(fold_binary_op_with_conditional_arg): Fix typo in comment.\n\ntestsuite/\n\t* gcc.c-torture/execute/20020506-1.c: New test case.\n\nFrom-SVN: r53241", "tree": {"sha": "42a44a69dbd2f8b714055533a4e34ddf161eabd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a44a69dbd2f8b714055533a4e34ddf161eabd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/comments", "author": null, "committer": null, "parents": [{"sha": "a5a49440f74e957e418360804bf270a8ebc9ad8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a49440f74e957e418360804bf270a8ebc9ad8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a49440f74e957e418360804bf270a8ebc9ad8e"}], "stats": {"total": 419, "additions": 416, "deletions": 3}, "files": [{"sha": "fd44b153b6d01a7110702593f61748a28c79d41c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "patch": "@@ -1,3 +1,12 @@\n+2002-05-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR opt/3995\n+\t* fold-const.c (sign_bit_p): New function.\n+\t(fold) [EQ_EXPR]: Use this to convert (A & C) == 0 into A >= 0 and\n+        (A & C) != 0 into A < 0, when constant C is the sign bit of A's type.\n+\tReapply fold when converting (A & C) == C into (A & C) != 0.\n+\t(fold_binary_op_with_conditional_arg): Fix typo in comment.\n+\n 2002-05-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-common.c (warn_multichar): New."}, {"sha": "6b4982aad751b52437bf5f44bfe12de0893a175d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "patch": "@@ -86,6 +86,7 @@ static tree decode_field_reference PARAMS ((tree, HOST_WIDE_INT *,\n \t\t\t\t\t    enum machine_mode *, int *,\n \t\t\t\t\t    int *, tree *, tree *));\n static int all_ones_mask_p\tPARAMS ((tree, int));\n+static tree sign_bit_p\t\tPARAMS ((tree, tree));\n static int simple_operand_p\tPARAMS ((tree));\n static tree range_binop\t\tPARAMS ((enum tree_code, tree, tree, int,\n \t\t\t\t\t tree, int));\n@@ -2634,6 +2635,55 @@ all_ones_mask_p (mask, size)\n \t\t\t\t     size_int (precision - size), 0));\n }\n \n+/* Subroutine for fold: determine if VAL is the INTEGER_CONST that\n+   represents the sign bit of EXP's type.  If EXP represents a sign\n+   or zero extension, also test VAL against the unextended type.\n+   The return value is the (sub)expression whose sign bit is VAL,\n+   or NULL_TREE otherwise.  */\n+\n+static tree\n+sign_bit_p (exp, val)\n+     tree exp;\n+     tree val;\n+{\n+  unsigned HOST_WIDE_INT lo;\n+  HOST_WIDE_INT hi;\n+  int width;\n+  tree t;\n+\n+  /* Tree EXP must have a integral type.  */\n+  t = TREE_TYPE (exp);\n+  if (! INTEGRAL_TYPE_P (t))\n+    return NULL_TREE;\n+\n+  /* Tree VAL must be an integer constant.  */\n+  if (TREE_CODE (val) != INTEGER_CST\n+      || TREE_CONSTANT_OVERFLOW (val))\n+    return NULL_TREE;\n+\n+  width = TYPE_PRECISION (t);\n+  if (width > HOST_BITS_PER_WIDE_INT)\n+    {\n+      hi = (unsigned HOST_WIDE_INT) 1 << (width - HOST_BITS_PER_WIDE_INT - 1);\n+      lo = 0;\n+    }\n+  else\n+    {\n+      hi = 0;\n+      lo = (unsigned HOST_WIDE_INT) 1 << (width - 1);\n+    }\n+\n+  if (TREE_INT_CST_HIGH (val) == hi && TREE_INT_CST_LOW (val) == lo)\n+    return exp;\n+\n+  /* Handle extension from a narrower type.  */\n+  if (TREE_CODE (exp) == NOP_EXPR\n+      && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp, 0))) < width)\n+    return sign_bit_p (TREE_OPERAND (exp, 0), val);\n+\n+  return NULL_TREE;\n+}\n+\n /* Subroutine for fold_truthop: determine if an operand is simple enough\n    to be evaluated unconditionally.  */\n \n@@ -4173,7 +4223,7 @@ count_cond (expr, lim)\n   return MIN (lim, 1 + ctrue + cfalse);\n }\n \n-/* Transform `a + (b ? x : y)' into `x ? (a + b) : (a + y)'.\n+/* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.\n    Transform, `a + (x < y)' into `(x < y) ? (a + 1) : (a + 0)'.  Here\n    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x < y)'\n    expression, and ARG to `a'.  If COND_FIRST_P is non-zero, then the\n@@ -6037,8 +6087,25 @@ fold (expr)\n \t  && TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn build (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t      arg0, integer_zero_node);\n+\treturn fold (build (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n+\t\t\t    arg0, integer_zero_node));\n+\n+      /* If we have (A & C) != 0 where C is the sign bit of A, convert\n+\t this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */\n+      if ((code == EQ_EXPR || code == NE_EXPR)\n+\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && integer_zerop (arg1))\n+\t{\n+\t  tree arg00 = sign_bit_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t   TREE_OPERAND (arg0, 1));\n+\t  if (arg00 != NULL_TREE)\n+\t  {\n+\t    tree stype = (*lang_hooks.types.signed_type) (TREE_TYPE (arg00));\n+\t    return fold (build (code == EQ_EXPR ? GE_EXPR : LT_EXPR, type,\n+\t\t\t        convert (stype, arg00),\n+\t\t\t\tconvert (stype, integer_zero_node)));\n+\t  }\n+\t}\n \n       /* If X is unsigned, convert X < (1 << Y) into X >> Y == 0\n \t and similarly for >= into !=.  */"}, {"sha": "c231d99be32af4c546ffafb139ad16ca3437c759", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "patch": "@@ -1,3 +1,7 @@\n+2002-05-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/20020506-1.c: New test case.\n+\n 2002-05-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* gcc.dg/cpp/charconst-3.c: Correct tests accordingly."}, {"sha": "bcbd45bf6cae3684b5ae97e44793a8e6286a36bf", "filename": "gcc/testsuite/gcc.c-torture/execute/20020506-1.c", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020506-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f77b5da981dae69e8e8d7ea3dc60ba95150c267/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020506-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020506-1.c?ref=1f77b5da981dae69e8e8d7ea3dc60ba95150c267", "patch": "@@ -0,0 +1,333 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test that (A & C1) op C2 optimizations behave correctly where C1 is\n+   a constant power of 2, op is == or !=, and C2 is C1 or zero.\n+\n+   Written by Roger Sayle, 5th May 2002.  */\n+\n+#include <limits.h>\n+\n+extern void abort (void);\n+\n+void test1 (signed char c, int set);\n+void test2 (unsigned char c, int set);\n+void test3 (short s, int set);\n+void test4 (unsigned short s, int set);\n+void test5 (int i, int set);\n+void test6 (unsigned int i, int set);\n+void test7 (long long l, int set);\n+void test8 (unsigned long long l, int set);\n+\n+#ifndef LONG_LONG_MAX\n+#define LONG_LONG_MAX __LONG_LONG_MAX__\n+#endif\n+#ifndef LONG_LONG_MIN\n+#define LONG_LONG_MIN (-LONG_LONG_MAX-1)\n+#endif\n+#ifndef ULONG_LONG_MAX\n+#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1)\n+#endif\n+\n+\n+void\n+test1 (signed char c, int set)\n+{\n+  if ((c & (SCHAR_MAX+1)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((c & (SCHAR_MAX+1)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((c & (SCHAR_MAX+1)) == (SCHAR_MAX+1))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((c & (SCHAR_MAX+1)) != (SCHAR_MAX+1))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test2 (unsigned char c, int set)\n+{\n+  if ((c & (SCHAR_MAX+1)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((c & (SCHAR_MAX+1)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((c & (SCHAR_MAX+1)) == (SCHAR_MAX+1))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((c & (SCHAR_MAX+1)) != (SCHAR_MAX+1))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test3 (short s, int set)\n+{\n+  if ((s & (SHRT_MAX+1)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((s & (SHRT_MAX+1)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((s & (SHRT_MAX+1)) == (SHRT_MAX+1))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((s & (SHRT_MAX+1)) != (SHRT_MAX+1))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test4 (unsigned short s, int set)\n+{\n+  if ((s & (SHRT_MAX+1)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((s & (SHRT_MAX+1)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((s & (SHRT_MAX+1)) == (SHRT_MAX+1))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((s & (SHRT_MAX+1)) != (SHRT_MAX+1))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test5 (int i, int set)\n+{\n+  if ((i & (INT_MAX+1U)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((i & (INT_MAX+1U)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((i & (INT_MAX+1U)) == (INT_MAX+1U))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((i & (INT_MAX+1U)) != (INT_MAX+1U))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test6 (unsigned int i, int set)\n+{\n+  if ((i & (INT_MAX+1U)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((i & (INT_MAX+1U)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((i & (INT_MAX+1U)) == (INT_MAX+1U))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((i & (INT_MAX+1U)) != (INT_MAX+1U))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test7 (long long l, int set)\n+{\n+  if ((l & (LONG_LONG_MAX+1ULL)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((l & (LONG_LONG_MAX+1ULL)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((l & (LONG_LONG_MAX+1ULL)) == (LONG_LONG_MAX+1ULL))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((l & (LONG_LONG_MAX+1ULL)) != (LONG_LONG_MAX+1ULL))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+void\n+test8 (unsigned long long l, int set)\n+{\n+  if ((l & (LONG_LONG_MAX+1ULL)) == 0)\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+\n+  if ((l & (LONG_LONG_MAX+1ULL)) != 0)\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((l & (LONG_LONG_MAX+1ULL)) == (LONG_LONG_MAX+1ULL))\n+    {\n+      if (!set) abort ();\n+    }\n+  else\n+    if (set) abort ();\n+\n+  if ((l & (LONG_LONG_MAX+1ULL)) != (LONG_LONG_MAX+1ULL))\n+    {\n+      if (set) abort ();\n+    }\n+  else\n+    if (!set) abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test1 (0, 0);\n+  test1 (SCHAR_MAX, 0);\n+  test1 (SCHAR_MIN, 1);\n+  test1 (UCHAR_MAX, 1);\n+\n+  test2 (0, 0);\n+  test2 (SCHAR_MAX, 0);\n+  test2 (SCHAR_MIN, 1);\n+  test2 (UCHAR_MAX, 1);\n+\n+  test3 (0, 0);\n+  test3 (SHRT_MAX, 0);\n+  test3 (SHRT_MIN, 1);\n+  test3 (USHRT_MAX, 1);\n+\n+  test4 (0, 0);\n+  test4 (SHRT_MAX, 0);\n+  test4 (SHRT_MIN, 1);\n+  test4 (USHRT_MAX, 1);\n+\n+  test5 (0, 0);\n+  test5 (INT_MAX, 0);\n+  test5 (INT_MIN, 1);\n+  test5 (UINT_MAX, 1);\n+\n+  test6 (0, 0);\n+  test6 (INT_MAX, 0);\n+  test6 (INT_MIN, 1);\n+  test6 (UINT_MAX, 1);\n+\n+  test7 (0, 0);\n+  test7 (LONG_LONG_MAX, 0);\n+  test7 (LONG_LONG_MIN, 1);\n+  test7 (ULONG_LONG_MAX, 1);\n+\n+  test8 (0, 0);\n+  test8 (LONG_LONG_MAX, 0);\n+  test8 (LONG_LONG_MIN, 1);\n+  test8 (ULONG_LONG_MAX, 1);\n+\n+  return 0;\n+}\n+"}]}