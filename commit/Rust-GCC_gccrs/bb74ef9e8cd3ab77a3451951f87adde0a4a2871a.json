{"sha": "bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3NGVmOWU4Y2QzYWI3N2EzNDUxOTUxZjg3YWRkZTBhNGEyODcxYQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2019-11-08T17:51:40Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2019-11-08T17:51:40Z"}, "message": "Modify range_operator::fold_range() and wi_fold () to return via reference.\n\n2019-11-08  Andrew MacLeod <amacleod@redhat.com>\n\n\t* range-op.h (range_operator::fold_range): Return result in a\n\treference parameter instead of by value.\n\t(range_operator::wi_fold): Same.\n\t* range-op.cc (range_operator::wi_fold): Return result in a reference\n\tparameter instead of by value.\n\t(range_operator::fold_range): Same.\n\t(value_range_from_overflowed_bounds): Same.\n\t(value_range_with_overflow): Same\n\t(create_possibly_reversed_range): Same.\n\t(operator_equal::fold_range): Same.\n\t(operator_not_equal::fold_range): Same.\n\t(operator_lt::fold_range): Same.\n\t(operator_le::fold_range): Same.\n\t(operator_gt::fold_range): Same.\n\t(operator_ge::fold_range): Same.\n\t(operator_plus::wi_fold): Same.\n\t(operator_plus::op1_range): Change call to fold_range.\n\t(operator_plus::op2_range): Change call to fold_range.\n\t(operator_minus::wi_fold): Return result via reference parameter.\n\t(operator_minus::op1_range): Change call to fold_range.\n\t(operator_minus::op2_range): Change call to fold_range.\n\t(operator_min::wi_fold): Return result via reference parameter.\n\t(operator_max::wi_fold): Same.\n\t(cross_product_operator::wi_cross_product): Same.\n\t(operator_mult::wi_fold): Same.\n\t(operator_div::wi_fold): Same.\n\t(operator_div op_floor_div): Fix whitespace.\n\t(operator_exact_divide::op1_range): Change call to fold_range.\n\t(operator_lshift::fold_range): Return result via reference parameter.\n\t(operator_lshift::wi_fold): Same.\n\t(operator_rshift::fold_range): Same.\n\t(operator_rshift::wi_fold): Same.\n\t(operator_cast::fold_range): Same.\n\t(operator_cast::op1_range): Change calls to fold_range.\n\t(operator_logical_and::fold_range): Return result via reference.\n\t(wi_optimize_and_or): Adjust call to value_range_with_overflow.\n\t(operator_bitwise_and::wi_fold): Return result via reference.\n\t(operator_logical_or::fold_range): Same.\n\t(operator_bitwise_or::wi_fold): Same.\n\t(operator_bitwise_xor::wi_fold): Same.\n\t(operator_trunc_mod::wi_fold): Same.\n\t(operator_logical_not::fold_range): Same.\n\t(operator_bitwise_not::fold_range): Same.\n\t(operator_bitwise_not::op1_range): Change call to fold_range.\n\t(operator_cst::fold_range): Return result via reference.\n\t(operator_identity::fold_range): Same.\n\t(operator_abs::wi_fold): Same.\n\t(operator_absu::wi_fold): Same.\n\t(operator_negate::fold_range): Same.\n\t(operator_negate::op1_range): Change call to fold_range.\n\t(operator_addr_expr::fold_range): Return result via reference.\n\t(operator_addr_expr::op1_range): Change call to fold_range.\n\t(operator_pointer_plus::wi_fold): Return result via reference.\n\t(operator_pointer_min_max::wi_fold): Same.\n\t(operator_pointer_and::wi_fold): Same.\n\t(operator_pointer_or::wi_fold): Same.\n\t(range_op_handler): Change call to fold_range.\n\t(range_cast): Same.\n\t* tree-vrp.c (range_fold_binary_symbolics_p): Change call to\n\tfold_range.\n\t(range_fold_unary_symbolics_p): Same.\n\t(range_fold_binary_expr): Same.\n\t(range_fold_unary_expr): Same.\n\nFrom-SVN: r277979", "tree": {"sha": "064031214b7fbd5402b06b1062119f4fb87cad46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/064031214b7fbd5402b06b1062119f4fb87cad46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/comments", "author": null, "committer": null, "parents": [{"sha": "77b29023e12eb3e906026380549d57dfcc44b433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77b29023e12eb3e906026380549d57dfcc44b433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77b29023e12eb3e906026380549d57dfcc44b433"}], "stats": {"total": 913, "additions": 494, "deletions": 419}, "files": [{"sha": "b0965ed84856ecae896c88d5f03dd3c9147c0589", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "patch": "@@ -1,3 +1,69 @@\n+2019-11-08  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* range-op.h (range_operator::fold_range): Return result in a\n+\treference parameter instead of by value.\n+\t(range_operator::wi_fold): Same.\n+\t* range-op.cc (range_operator::wi_fold): Return result in a reference\n+\tparameter instead of by value.\n+\t(range_operator::fold_range): Same.\n+\t(value_range_from_overflowed_bounds): Same.\n+\t(value_range_with_overflow): Same\n+\t(create_possibly_reversed_range): Same.\n+\t(operator_equal::fold_range): Same.\n+\t(operator_not_equal::fold_range): Same.\n+\t(operator_lt::fold_range): Same.\n+\t(operator_le::fold_range): Same.\n+\t(operator_gt::fold_range): Same.\n+\t(operator_ge::fold_range): Same.\n+\t(operator_plus::wi_fold): Same.\n+\t(operator_plus::op1_range): Change call to fold_range.\n+\t(operator_plus::op2_range): Change call to fold_range.\n+\t(operator_minus::wi_fold): Return result via reference parameter.\n+\t(operator_minus::op1_range): Change call to fold_range.\n+\t(operator_minus::op2_range): Change call to fold_range.\n+\t(operator_min::wi_fold): Return result via reference parameter.\n+\t(operator_max::wi_fold): Same.\n+\t(cross_product_operator::wi_cross_product): Same.\n+\t(operator_mult::wi_fold): Same.\n+\t(operator_div::wi_fold): Same.\n+\t(operator_div op_floor_div): Fix whitespace.\n+\t(operator_exact_divide::op1_range): Change call to fold_range.\n+\t(operator_lshift::fold_range): Return result via reference parameter.\n+\t(operator_lshift::wi_fold): Same.\n+\t(operator_rshift::fold_range): Same.\n+\t(operator_rshift::wi_fold): Same.\n+\t(operator_cast::fold_range): Same.\n+\t(operator_cast::op1_range): Change calls to fold_range.\n+\t(operator_logical_and::fold_range): Return result via reference.\n+\t(wi_optimize_and_or): Adjust call to value_range_with_overflow.\n+\t(operator_bitwise_and::wi_fold): Return result via reference.\n+\t(operator_logical_or::fold_range): Same.\n+\t(operator_bitwise_or::wi_fold): Same.\n+\t(operator_bitwise_xor::wi_fold): Same.\n+\t(operator_trunc_mod::wi_fold): Same.\n+\t(operator_logical_not::fold_range): Same.\n+\t(operator_bitwise_not::fold_range): Same.\n+\t(operator_bitwise_not::op1_range): Change call to fold_range.\n+\t(operator_cst::fold_range): Return result via reference.\n+\t(operator_identity::fold_range): Same.\n+\t(operator_abs::wi_fold): Same.\n+\t(operator_absu::wi_fold): Same.\n+\t(operator_negate::fold_range): Same.\n+\t(operator_negate::op1_range): Change call to fold_range.\n+\t(operator_addr_expr::fold_range): Return result via reference.\n+\t(operator_addr_expr::op1_range): Change call to fold_range.\n+\t(operator_pointer_plus::wi_fold): Return result via reference.\n+\t(operator_pointer_min_max::wi_fold): Same.\n+\t(operator_pointer_and::wi_fold): Same.\n+\t(operator_pointer_or::wi_fold): Same.\n+\t(range_op_handler): Change call to fold_range.\n+\t(range_cast): Same.\n+\t* tree-vrp.c (range_fold_binary_symbolics_p): Change call to\n+\tfold_range.\n+\t(range_fold_unary_symbolics_p): Same.\n+\t(range_fold_binary_expr): Same.\n+\t(range_fold_unary_expr): Same.\n+\n 2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-loop.c (neutral_op_for_slp_reduction): Take the"}, {"sha": "9967f0c86532781f95c766f959acb2cf75c6b275", "filename": "gcc/range-op.cc", "status": "modified", "additions": 412, "deletions": 399, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "patch": "@@ -124,40 +124,40 @@ wi_zero_p (tree type, const wide_int &wmin, const wide_int &wmax)\n \n // Default wide_int fold operation returns [MIN, MAX].\n \n-value_range\n-range_operator::wi_fold (tree type,\n+void\n+range_operator::wi_fold (value_range &r, tree type,\n \t\t\t const wide_int &lh_lb ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &lh_ub ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &rh_lb ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &rh_ub ATTRIBUTE_UNUSED) const\n {\n-  return value_range (type);\n+  r = value_range (type);\n }\n \n // The default for fold is to break all ranges into sub-ranges and\n // invoke the wi_fold method on each sub-range pair.\n \n-value_range\n-range_operator::fold_range (tree type,\n+void\n+range_operator::fold_range (value_range &r, tree type,\n \t\t\t    const value_range &lh,\n \t\t\t    const value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n \n+  value_range tmp;\n   for (unsigned x = 0; x < lh.num_pairs (); ++x)\n     for (unsigned y = 0; y < rh.num_pairs (); ++y)\n       {\n \twide_int lh_lb = lh.lower_bound (x);\n \twide_int lh_ub = lh.upper_bound (x);\n \twide_int rh_lb = rh.lower_bound (y);\n \twide_int rh_ub = rh.upper_bound (y);\n-\tr.union_ (wi_fold (type, lh_lb, lh_ub, rh_lb, rh_ub));\n+\twi_fold (tmp, type, lh_lb, lh_ub, rh_lb, rh_ub);\n+\tr.union_ (tmp);\n \tif (r.varying_p ())\n-\t  return r;\n+\t  return;\n       }\n-  return r;\n }\n \n // The default for op1_range is to return false.\n@@ -186,8 +186,8 @@ range_operator::op2_range (value_range &r ATTRIBUTE_UNUSED,\n // Create and return a range from a pair of wide-ints that are known\n // to have overflowed (or underflowed).\n \n-static value_range\n-value_range_from_overflowed_bounds (tree type,\n+static void\n+value_range_from_overflowed_bounds (value_range &r, tree type,\n \t\t\t\t    const wide_int &wmin,\n \t\t\t\t    const wide_int &wmax)\n {\n@@ -210,17 +210,17 @@ value_range_from_overflowed_bounds (tree type,\n   // Likewise if the anti-range bounds are outside of the types\n   // values.\n   if (covers || wi::cmp (tmin, tmax, sgn) > 0)\n-    return value_range (type);\n-\n-  return value_range (VR_ANTI_RANGE, type, tmin, tmax);\n+    r = value_range (type);\n+  else\n+    r = value_range (VR_ANTI_RANGE, type, tmin, tmax);\n }\n \n // Create and return a range from a pair of wide-ints.  MIN_OVF and\n // MAX_OVF describe any overflow that might have occurred while\n // calculating WMIN and WMAX respectively.\n \n-static value_range\n-value_range_with_overflow (tree type,\n+static void\n+value_range_with_overflow (value_range &r, tree type,\n \t\t\t   const wide_int &wmin, const wide_int &wmax,\n \t\t\t   wi::overflow_type min_ovf = wi::OVF_NONE,\n \t\t\t   wi::overflow_type max_ovf = wi::OVF_NONE)\n@@ -232,7 +232,10 @@ value_range_with_overflow (tree type,\n   // For one bit precision if max != min, then the range covers all\n   // values.\n   if (prec == 1 && wi::ne_p (wmax, wmin))\n-    return value_range (type);\n+    {\n+      r = value_range (type);\n+      return;\n+    }\n \n   if (overflow_wraps)\n     {\n@@ -245,19 +248,20 @@ value_range_with_overflow (tree type,\n \t  // If the limits are swapped, we wrapped around and cover\n \t  // the entire range.\n \t  if (wi::gt_p (tmin, tmax, sgn))\n-\t    return value_range (type);\n-\n-\t  // No overflow or both overflow or underflow.  The range\n-\t  // kind stays normal.\n-\t  return value_range (type, tmin, tmax);\n+\t    r = value_range (type);\n+\t  else\n+\t    // No overflow or both overflow or underflow.  The range\n+\t    // kind stays normal.\n+\t    r = value_range (type, tmin, tmax);\n+\t  return;\n \t}\n \n       if ((min_ovf == wi::OVF_UNDERFLOW && max_ovf == wi::OVF_NONE)\n \t  || (max_ovf == wi::OVF_OVERFLOW && min_ovf == wi::OVF_NONE))\n-\treturn value_range_from_overflowed_bounds (type, wmin, wmax);\n-\n-      // Other underflow and/or overflow, drop to VR_VARYING.\n-      return value_range (type);\n+\tvalue_range_from_overflowed_bounds (r, type, wmin, wmax);\n+      else\n+\t// Other underflow and/or overflow, drop to VR_VARYING.\n+\tr = value_range (type);\n     }\n   else\n     {\n@@ -277,25 +281,25 @@ value_range_with_overflow (tree type,\n       else\n         new_ub = wmax;\n \n-      return value_range (type, new_lb, new_ub);\n+      r = value_range (type, new_lb, new_ub);\n     }\n }\n \n // Create and return a range from a pair of wide-ints.  Canonicalize\n // the case where the bounds are swapped.  In which case, we transform\n // [10,5] into [MIN,5][10,MAX].\n \n-static inline value_range\n-create_possibly_reversed_range (tree type,\n+static inline void\n+create_possibly_reversed_range (value_range &r, tree type,\n \t\t\t\tconst wide_int &new_lb, const wide_int &new_ub)\n {\n   signop s = TYPE_SIGN (type);\n   // If the bounds are swapped, treat the result as if an overflow occured.\n   if (wi::gt_p (new_lb, new_ub, s))\n-    return value_range_from_overflowed_bounds (type, new_lb, new_ub);\n-\n-  // Otherwise its just a normal range.\n-  return value_range (type, new_lb, new_ub);\n+    value_range_from_overflowed_bounds (r, type, new_lb, new_ub);\n+  else\n+    // Otherwise its just a normal range.\n+    r = value_range (type, new_lb, new_ub);\n }\n \n // Return a value_range instance that is a boolean TRUE.\n@@ -359,9 +363,9 @@ get_bool_state (value_range &r, const value_range &lhs, tree val_type)\n class operator_equal : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &val) const;\n@@ -370,14 +374,13 @@ class operator_equal : public range_operator\n \t\t\t  const value_range &val) const;\n } op_equal;\n \n-value_range\n-operator_equal::fold_range (tree type,\n+void\n+operator_equal::fold_range (value_range &r, tree type,\n \t\t\t    const value_range &op1,\n \t\t\t    const value_range &op2) const\n {\n-  value_range r;\n   if (empty_range_check (r, op1, op2))\n-    return r;\n+    return;\n \n   // We can be sure the values are always equal or not if both ranges\n   // consist of a single value, and then compare them.\n@@ -399,8 +402,6 @@ operator_equal::fold_range (tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-\n-  return r;\n }\n \n bool\n@@ -442,9 +443,9 @@ operator_equal::op2_range (value_range &r, tree type,\n class operator_not_equal : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -453,14 +454,13 @@ class operator_not_equal : public range_operator\n \t\t\t  const value_range &op1) const;\n } op_not_equal;\n \n-value_range\n-operator_not_equal::fold_range (tree type,\n+void\n+operator_not_equal::fold_range (value_range &r, tree type,\n \t\t\t\tconst value_range &op1,\n \t\t\t\tconst value_range &op2) const\n {\n-  value_range r;\n   if (empty_range_check (r, op1, op2))\n-    return r;\n+    return;\n \n   // We can be sure the values are always equal or not if both ranges\n   // consist of a single value, and then compare them.\n@@ -482,8 +482,6 @@ operator_not_equal::fold_range (tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-\n-  return r;\n }\n \n bool\n@@ -571,9 +569,9 @@ build_ge (value_range &r, tree type, const wide_int &val)\n class operator_lt :  public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -582,14 +580,13 @@ class operator_lt :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_lt;\n \n-value_range\n-operator_lt::fold_range (tree type,\n+void\n+operator_lt::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1,\n \t\t\t const value_range &op2) const\n {\n-  value_range r;\n   if (empty_range_check (r, op1, op2))\n-    return r;\n+    return;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -600,7 +597,6 @@ operator_lt::fold_range (tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n-  return r;\n }\n \n bool\n@@ -649,9 +645,9 @@ operator_lt::op2_range (value_range &r, tree type,\n class operator_le :  public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -660,14 +656,13 @@ class operator_le :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_le;\n \n-value_range\n-operator_le::fold_range (tree type,\n+void\n+operator_le::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1,\n \t\t\t const value_range &op2) const\n {\n-  value_range r;\n   if (empty_range_check (r, op1, op2))\n-    return r;\n+    return;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -678,7 +673,6 @@ operator_le::fold_range (tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n-  return r;\n }\n \n bool\n@@ -727,9 +721,9 @@ operator_le::op2_range (value_range &r, tree type,\n class operator_gt :  public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -738,13 +732,12 @@ class operator_gt :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_gt;\n \n-value_range\n-operator_gt::fold_range (tree type,\n+void\n+operator_gt::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1, const value_range &op2) const\n {\n-  value_range r;\n   if (empty_range_check (r, op1, op2))\n-    return r;\n+    return;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -755,7 +748,6 @@ operator_gt::fold_range (tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n-  return r;\n }\n \n bool\n@@ -803,9 +795,9 @@ operator_gt::op2_range (value_range &r, tree type,\n class operator_ge :  public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -814,14 +806,13 @@ class operator_ge :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_ge;\n \n-value_range\n-operator_ge::fold_range (tree type,\n+void\n+operator_ge::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1,\n \t\t\t const value_range &op2) const\n {\n-  value_range r;\n   if (empty_range_check (r, op1, op2))\n-    return r;\n+    return;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -832,7 +823,6 @@ operator_ge::fold_range (tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n-  return r;\n }\n \n bool\n@@ -887,31 +877,31 @@ class operator_plus : public range_operator\n   virtual bool op2_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op1) const;\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_plus;\n \n-value_range\n-operator_plus::wi_fold (tree type,\n+void\n+operator_plus::wi_fold (value_range &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   wi::overflow_type ov_lb, ov_ub;\n   signop s = TYPE_SIGN (type);\n   wide_int new_lb = wi::add (lh_lb, rh_lb, s, &ov_lb);\n   wide_int new_ub = wi::add (lh_ub, rh_ub, s, &ov_ub);\n-  return value_range_with_overflow (type, new_lb, new_ub, ov_lb, ov_ub);\n+  value_range_with_overflow (r, type, new_lb, new_ub, ov_lb, ov_ub);\n }\n \n bool\n operator_plus::op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const\n {\n-  r = range_op_handler (MINUS_EXPR, type)->fold_range (type, lhs, op2);\n+  range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op2);\n   return true;\n }\n \n@@ -920,7 +910,7 @@ operator_plus::op2_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op1) const\n {\n-  r = range_op_handler (MINUS_EXPR, type)->fold_range (type, lhs, op1);\n+  range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op1);\n   return true;\n }\n \n@@ -934,31 +924,31 @@ class operator_minus : public range_operator\n   virtual bool op2_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op1) const;\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_minus;\n \n-value_range\n-operator_minus::wi_fold (tree type,\n+void \n+operator_minus::wi_fold (value_range &r, tree type,\n \t\t\t const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   wi::overflow_type ov_lb, ov_ub;\n   signop s = TYPE_SIGN (type);\n   wide_int new_lb = wi::sub (lh_lb, rh_ub, s, &ov_lb);\n   wide_int new_ub = wi::sub (lh_ub, rh_lb, s, &ov_ub);\n-  return value_range_with_overflow (type, new_lb, new_ub, ov_lb, ov_ub);\n+  value_range_with_overflow (r, type, new_lb, new_ub, ov_lb, ov_ub);\n }\n \n bool\n operator_minus::op1_range (value_range &r, tree type,\n \t\t\t   const value_range &lhs,\n \t\t\t   const value_range &op2) const\n {\n-  r = range_op_handler (PLUS_EXPR, type)->fold_range (type, lhs, op2);\n+  range_op_handler (PLUS_EXPR, type)->fold_range (r, type, lhs, op2);\n   return true;\n }\n \n@@ -967,52 +957,52 @@ operator_minus::op2_range (value_range &r, tree type,\n \t\t\t   const value_range &lhs,\n \t\t\t   const value_range &op1) const\n {\n-  r = fold_range (type, op1, lhs);\n+  fold_range (r, type, op1, lhs);\n   return true;\n }\n \n \n class operator_min : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_min;\n \n-value_range\n-operator_min::wi_fold (tree type,\n+void\n+operator_min::wi_fold (value_range &r, tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   signop s = TYPE_SIGN (type);\n   wide_int new_lb = wi::min (lh_lb, rh_lb, s);\n   wide_int new_ub = wi::min (lh_ub, rh_ub, s);\n-  return value_range_with_overflow (type, new_lb, new_ub);\n+  value_range_with_overflow (r, type, new_lb, new_ub);\n }\n \n \n class operator_max : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_max;\n \n-value_range\n-operator_max::wi_fold (tree type,\n+void\n+operator_max::wi_fold (value_range &r, tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   signop s = TYPE_SIGN (type);\n   wide_int new_lb = wi::max (lh_lb, rh_lb, s);\n   wide_int new_ub = wi::max (lh_ub, rh_ub, s);\n-  return value_range_with_overflow (type, new_lb, new_ub);\n+  value_range_with_overflow (r, type, new_lb, new_ub);\n }\n \n \n@@ -1027,11 +1017,11 @@ class cross_product_operator : public range_operator\n \t\t\t\tconst wide_int &) const = 0;\n \n   // Calculate the cross product of two sets of sub-ranges and return it.\n-  value_range wi_cross_product (tree type,\n-\t\t\t\t     const wide_int &lh_lb,\n-\t\t\t\t     const wide_int &lh_ub,\n-\t\t\t\t     const wide_int &rh_lb,\n-\t\t\t\t     const wide_int &rh_ub) const;\n+  void wi_cross_product (value_range &r, tree type,\n+\t\t\t const wide_int &lh_lb,\n+\t\t\t const wide_int &lh_ub,\n+\t\t\t const wide_int &rh_lb,\n+\t\t\t const wide_int &rh_ub) const;\n };\n \n // Calculate the cross product of two sets of ranges and return it.\n@@ -1047,31 +1037,33 @@ class cross_product_operator : public range_operator\n // MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP MAX1) and then\n // figure the smallest and largest values to form the new range.\n \n-value_range\n-cross_product_operator::wi_cross_product (tree type,\n+void\n+cross_product_operator::wi_cross_product (value_range &r, tree type,\n \t\t\t\t\t  const wide_int &lh_lb,\n \t\t\t\t\t  const wide_int &lh_ub,\n \t\t\t\t\t  const wide_int &rh_lb,\n \t\t\t\t\t  const wide_int &rh_ub) const\n {\n   wide_int cp1, cp2, cp3, cp4;\n+  // Default to varying.\n+  r = value_range (type);\n \n   // Compute the 4 cross operations, bailing if we get an overflow we\n   // can't handle.\n   if (wi_op_overflows (cp1, type, lh_lb, rh_lb))\n-    return value_range (type);\n+    return;\n   if (wi::eq_p (lh_lb, lh_ub))\n     cp3 = cp1;\n   else if (wi_op_overflows (cp3, type, lh_ub, rh_lb))\n-    return value_range (type);\n+    return;\n   if (wi::eq_p (rh_lb, rh_ub))\n     cp2 = cp1;\n   else if (wi_op_overflows (cp2, type, lh_lb, rh_ub))\n-    return value_range (type);\n+    return;\n   if (wi::eq_p (lh_lb, lh_ub))\n     cp4 = cp2;\n   else if (wi_op_overflows (cp4, type, lh_ub, rh_ub))\n-    return value_range (type);\n+    return;\n \n   // Order pairs.\n   signop sign = TYPE_SIGN (type);\n@@ -1083,18 +1075,18 @@ cross_product_operator::wi_cross_product (tree type,\n   // Choose min and max from the ordered pairs.\n   wide_int res_lb = wi::min (cp1, cp3, sign);\n   wide_int res_ub = wi::max (cp2, cp4, sign);\n-  return value_range_with_overflow (type, res_lb, res_ub);\n+  value_range_with_overflow (r, type, res_lb, res_ub);\n }\n \n \n class operator_mult : public cross_product_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n   virtual bool wi_op_overflows (wide_int &res, tree type,\n \t\t\t\tconst wide_int &w0, const wide_int &w1) const;\n } op_mult;\n@@ -1119,13 +1111,16 @@ operator_mult::wi_op_overflows (wide_int &res, tree type,\n    return overflow;\n }\n \n-value_range\n-operator_mult::wi_fold (tree type,\n+void \n+operator_mult::wi_fold (value_range &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   if (TYPE_OVERFLOW_UNDEFINED (type))\n-    return wi_cross_product (type, lh_lb, lh_ub, rh_lb, rh_ub);\n+    {\n+      wi_cross_product (r, type, lh_lb, lh_ub, rh_lb, rh_ub);\n+      return;\n+    }\n \n   // Multiply the ranges when overflow wraps.  This is basically fancy\n   // code so we don't drop to varying with an unsigned\n@@ -1186,23 +1181,25 @@ operator_mult::wi_fold (tree type,\n   prod2 = prod3 - prod0;\n   if (wi::geu_p (prod2, sizem1))\n     // The range covers all values.\n-    return value_range (type);\n-\n-  wide_int new_lb = wide_int::from (prod0, prec, sign);\n-  wide_int new_ub = wide_int::from (prod3, prec, sign);\n-  return create_possibly_reversed_range (type, new_lb, new_ub);\n+    r = value_range (type);\n+  else\n+    {\n+      wide_int new_lb = wide_int::from (prod0, prec, sign);\n+      wide_int new_ub = wide_int::from (prod3, prec, sign);\n+      create_possibly_reversed_range (r, type, new_lb, new_ub);\n+    }\n }\n \n \n class operator_div : public cross_product_operator\n {\n public:\n   operator_div (enum tree_code c)  { code = c; }\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n   virtual bool wi_op_overflows (wide_int &res, tree type,\n \t\t\t\tconst wide_int &, const wide_int &) const;\n private:\n@@ -1251,14 +1248,17 @@ operator_div::wi_op_overflows (wide_int &res, tree type,\n   return overflow;\n }\n \n-value_range\n-operator_div::wi_fold (tree type,\n+void\n+operator_div::wi_fold (value_range &r, tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   // If we know we will divide by zero, return undefined.\n   if (rh_lb == 0 && rh_ub == 0)\n-    return value_range ();\n+    {\n+      r = value_range ();\n+      return;\n+    }\n \n   const wide_int dividend_min = lh_lb;\n   const wide_int dividend_max = lh_ub;\n@@ -1270,38 +1270,50 @@ operator_div::wi_fold (tree type,\n \n   // If we know we won't divide by zero, just do the division.\n   if (!wi_includes_zero_p (type, divisor_min, divisor_max))\n-    return wi_cross_product (type, dividend_min, dividend_max,\n-\t\t\t     divisor_min, divisor_max);\n+    {\n+      wi_cross_product (r, type, dividend_min, dividend_max,\n+\t\t       divisor_min, divisor_max);\n+      return;\n+    }\n \n   // If flag_non_call_exceptions, we must not eliminate a division by zero.\n   if (cfun->can_throw_non_call_exceptions)\n-    return value_range (type);\n+    {\n+      r = value_range (type);\n+      return;\n+    }\n \n   // If we're definitely dividing by zero, there's nothing to do.\n   if (wi_zero_p (type, divisor_min, divisor_max))\n-    return value_range ();\n+    {\n+      r = value_range ();\n+      return;\n+    }\n \n   // Perform the division in 2 parts, [LB, -1] and [1, UB], which will\n   // skip any division by zero.\n \n   // First divide by the negative numbers, if any.\n-  value_range r;\n   if (wi::neg_p (divisor_min, sign))\n-    r = wi_cross_product (type, dividend_min, dividend_max,\n-\t\t\t  divisor_min, wi::minus_one (prec));\n+    wi_cross_product (r, type, dividend_min, dividend_max,\n+\t\t      divisor_min, wi::minus_one (prec));\n+  else\n+    r = value_range ();\n+\n   // Then divide by the non-zero positive numbers, if any.\n   if (wi::gt_p (divisor_max, wi::zero (prec), sign))\n     {\n       value_range tmp;\n-      tmp = wi_cross_product (type, dividend_min, dividend_max,\n-\t\t\t      wi::one (prec), divisor_max);\n+      wi_cross_product (tmp, type, dividend_min, dividend_max,\n+\t\t\twi::one (prec), divisor_max);\n       r.union_ (tmp);\n     }\n-  return r;\n+  // We shouldn't still have undefined here.\n+  gcc_checking_assert (!r.undefined_p ());\n }\n \n operator_div op_trunc_div (TRUNC_DIV_EXPR);\n-operator_div op_floor_div(FLOOR_DIV_EXPR);\n+operator_div op_floor_div (FLOOR_DIV_EXPR);\n operator_div op_round_div (ROUND_DIV_EXPR);\n operator_div op_ceil_div (CEIL_DIV_EXPR);\n \n@@ -1331,7 +1343,7 @@ operator_exact_divide::op1_range (value_range &r, tree type,\n   if (op2.singleton_p (&offset)\n       && !integer_zerop (offset))\n     {\n-      r = range_op_handler (MULT_EXPR, type)->fold_range (type, lhs, op2);\n+      range_op_handler (MULT_EXPR, type)->fold_range (r, type, lhs, op2);\n       return true;\n     }\n   return false;\n@@ -1341,27 +1353,26 @@ operator_exact_divide::op1_range (value_range &r, tree type,\n class operator_lshift : public cross_product_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n \n-  virtual value_range wi_fold (tree type,\n-\t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n-\t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n+\t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n   virtual bool wi_op_overflows (wide_int &res,\n \t\t\t\ttree type,\n \t\t\t\tconst wide_int &,\n \t\t\t\tconst wide_int &) const;\n } op_lshift;\n \n-value_range\n-operator_lshift::fold_range (tree type,\n+void\n+operator_lshift::fold_range (value_range &r, tree type,\n \t\t\t     const value_range &op1,\n \t\t\t     const value_range &op2) const\n {\n-  value_range r;\n   if (undefined_shift_range_check (r, type, op2))\n-    return r;\n+    return;\n \n   // Transform left shifts by constants into multiplies.\n   if (op2.singleton_p ())\n@@ -1375,18 +1386,18 @@ operator_lshift::fold_range (tree type,\n       bool saved_flag_wrapv_pointer = flag_wrapv_pointer;\n       flag_wrapv = 1;\n       flag_wrapv_pointer = 1;\n-      r = range_op_handler (MULT_EXPR, type)->fold_range (type, op1, mult);\n+      range_op_handler (MULT_EXPR, type)->fold_range (r, type, op1, mult);\n       flag_wrapv = saved_flag_wrapv;\n       flag_wrapv_pointer = saved_flag_wrapv_pointer;\n-      return r;\n+      return;\n     }\n \n   // Otherwise, invoke the generic fold routine.\n-  return range_operator::fold_range (type, op1, op2);\n+  range_operator::fold_range (r, type, op1, op2);\n }\n \n-value_range\n-operator_lshift::wi_fold (tree type,\n+void\n+operator_lshift::wi_fold (value_range &r, tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n@@ -1440,9 +1451,9 @@ operator_lshift::wi_fold (tree type,\n     }\n \n   if (in_bounds)\n-    return wi_cross_product (type, lh_lb, lh_ub, rh_lb, rh_ub);\n-\n-  return value_range (type);\n+    wi_cross_product (r, type, lh_lb, lh_ub, rh_lb, rh_ub);\n+  else\n+   r = value_range (type);\n }\n \n bool\n@@ -1466,14 +1477,14 @@ operator_lshift::wi_op_overflows (wide_int &res, tree type,\n class operator_rshift : public cross_product_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n   virtual bool wi_op_overflows (wide_int &res,\n \t\t\t\ttree type,\n \t\t\t\tconst wide_int &w0,\n@@ -1499,49 +1510,47 @@ operator_rshift::wi_op_overflows (wide_int &res,\n   return false;\n }\n \n-value_range\n-operator_rshift::fold_range (tree type,\n+void\n+operator_rshift::fold_range (value_range &r, tree type,\n \t\t\t     const value_range &op1,\n \t\t\t     const value_range &op2) const\n {\n-  value_range r;\n   if (undefined_shift_range_check (r, type, op2))\n-    return r;\n+    return;\n \n   // Otherwise, invoke the generic fold routine.\n-  return range_operator::fold_range (type, op1, op2);\n+  range_operator::fold_range (r, type, op1, op2);\n }\n \n-value_range\n-operator_rshift::wi_fold (tree type,\n+void\n+operator_rshift::wi_fold (value_range &r, tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n-  return wi_cross_product (type, lh_lb, lh_ub, rh_lb, rh_ub);\n+  wi_cross_product (r, type, lh_lb, lh_ub, rh_lb, rh_ub);\n }\n \n \n class operator_cast: public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n \n } op_convert;\n \n-value_range\n-operator_cast::fold_range (tree type ATTRIBUTE_UNUSED,\n+void\n+operator_cast::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n-\n+    return;\n+  \n   tree inner = lh.type ();\n   tree outer = rh.type ();\n   gcc_checking_assert (rh.varying_p ());\n@@ -1551,6 +1560,8 @@ operator_cast::fold_range (tree type ATTRIBUTE_UNUSED,\n   unsigned inner_prec = TYPE_PRECISION (inner);\n   unsigned outer_prec = TYPE_PRECISION (outer);\n \n+  // Start with an empty range and add subranges.\n+  r = value_range ();\n   for (unsigned x = 0; x < lh.num_pairs (); ++x)\n     {\n       wide_int lh_lb = lh.lower_bound (x);\n@@ -1572,14 +1583,14 @@ operator_cast::fold_range (tree type ATTRIBUTE_UNUSED,\n \t      || !wi::eq_p (max, wi::max_value (outer_prec, outer_sign)))\n \t    {\n \t      value_range tmp;\n-\t      tmp = create_possibly_reversed_range (type, min, max);\n+\t      create_possibly_reversed_range (tmp, type, min, max);\n \t      r.union_ (tmp);\n \t      continue;\n \t    }\n \t}\n-      return value_range (type);\n+      r = value_range (type);\n+      return;\n     }\n-  return r;\n }\n \n bool\n@@ -1588,6 +1599,7 @@ operator_cast::op1_range (value_range &r, tree type,\n \t\t\t  const value_range &op2) const\n {\n   tree lhs_type = lhs.type ();\n+  value_range tmp;\n   gcc_checking_assert (types_compatible_p (op2.type(), type));\n \n   // If the precision of the LHS is smaller than the precision of the\n@@ -1598,15 +1610,13 @@ operator_cast::op1_range (value_range &r, tree type,\n       // If we've been passed an actual value for the RHS rather than\n       // the type, see if it fits the LHS, and if so, then we can allow\n       // it.\n-      r = op2;\n-      r = fold_range (lhs_type, r, value_range (lhs_type));\n-      r = fold_range (type, r, value_range (type));\n-      if (r == op2)\n+      fold_range (r, lhs_type, op2, value_range (lhs_type));\n+      fold_range (tmp, type, r, value_range (type));\n+      if (tmp == op2)\n         {\n \t  // We know the value of the RHS fits in the LHS type, so\n \t  // convert the LHS and remove any values that arent in OP2.\n-\t  r = lhs;\n-\t  r = fold_range (type, r, value_range (type));\n+\t  fold_range (r, type, lhs, value_range (type));\n \t  r.intersect (op2);\n \t  return true;\n \t}\n@@ -1646,27 +1656,26 @@ operator_cast::op1_range (value_range &r, tree type,\n   if (TYPE_PRECISION (lhs_type) > TYPE_PRECISION (type))\n     {\n       // Cast the range of the RHS to the type of the LHS.\n-      value_range op_type (type);\n-      op_type = fold_range (lhs_type, op_type, value_range (lhs_type));\n-\n-      // Intersect this with the LHS range will produce the RHS range.\n-      r = range_intersect (lhs, op_type);\n+      fold_range (tmp, lhs_type, value_range (type), value_range (lhs_type));\n+      // Intersect this with the LHS range will produce the range, which\n+      // will be cast to the RHS type before returning.\n+      tmp.intersect (lhs);\n     }\n   else\n-    r = lhs;\n+    tmp = lhs;\n \n   // Cast the calculated range to the type of the RHS.\n-  r = fold_range (type, r, value_range (type));\n+  fold_range (r, type, tmp, value_range (type));\n   return true;\n }\n \n \n class operator_logical_and : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &lh,\n-\t\t\t\t  const value_range &rh) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &lh,\n+\t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -1676,27 +1685,25 @@ class operator_logical_and : public range_operator\n } op_logical_and;\n \n \n-value_range\n-operator_logical_and::fold_range (tree type,\n+void\n+operator_logical_and::fold_range (value_range &r, tree type,\n \t\t\t\t  const value_range &lh,\n \t\t\t\t  const value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n \n   // 0 && anything is 0.\n   if ((wi::eq_p (lh.lower_bound (), 0) && wi::eq_p (lh.upper_bound (), 0))\n       || (wi::eq_p (lh.lower_bound (), 0) && wi::eq_p (rh.upper_bound (), 0)))\n-    return range_false (type);\n-\n-  // To reach this point, there must be a logical 1 on each side, and\n-  // the only remaining question is whether there is a zero or not.\n-  if (lh.contains_p (build_zero_cst (lh.type ()))\n-      || rh.contains_p (build_zero_cst (rh.type ())))\n-    return range_true_and_false (type);\n-\n-  return range_true (type);\n+    r = range_false (type);\n+  else if (lh.contains_p (build_zero_cst (lh.type ()))\n+\t   || rh.contains_p (build_zero_cst (rh.type ())))\n+    // To reach this point, there must be a logical 1 on each side, and\n+    // the only remaining question is whether there is a zero or not.\n+    r = range_true_and_false (type);\n+  else\n+    r = range_true (type);\n }\n \n bool\n@@ -1738,11 +1745,11 @@ class operator_bitwise_and : public range_operator\n   virtual bool op2_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op1) const;\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_bitwise_and;\n \n // Optimize BIT_AND_EXPR and BIT_IOR_EXPR in terms of a mask if\n@@ -1820,7 +1827,7 @@ wi_optimize_and_or (value_range &r,\n     }\n   else\n     gcc_unreachable ();\n-  r = value_range_with_overflow (type, res_lb, res_ub);\n+  value_range_with_overflow (r, type, res_lb, res_ub);\n   return true;\n }\n \n@@ -1864,16 +1871,15 @@ wi_set_zero_nonzero_bits (tree type,\n     }\n }\n \n-value_range\n-operator_bitwise_and::wi_fold (tree type,\n+void\n+operator_bitwise_and::wi_fold (value_range &r, tree type,\n \t\t\t       const wide_int &lh_lb,\n \t\t\t       const wide_int &lh_ub,\n \t\t\t       const wide_int &rh_lb,\n \t\t\t       const wide_int &rh_ub) const\n {\n-  value_range r;\n   if (wi_optimize_and_or (r, BIT_AND_EXPR, type, lh_lb, lh_ub, rh_lb, rh_ub))\n-    return r;\n+    return;\n \n   wide_int maybe_nonzero_lh, mustbe_nonzero_lh;\n   wide_int maybe_nonzero_rh, mustbe_nonzero_rh;\n@@ -1918,9 +1924,9 @@ operator_bitwise_and::wi_fold (tree type,\n     }\n   // If the limits got swapped around, return varying.\n   if (wi::gt_p (new_lb, new_ub,sign))\n-    return value_range (type);\n-\n-  return value_range_with_overflow (type, new_lb, new_ub);\n+    r = value_range (type);\n+  else\n+    value_range_with_overflow (r, type, new_lb, new_ub);\n }\n \n bool\n@@ -1949,9 +1955,9 @@ operator_bitwise_and::op2_range (value_range &r, tree type,\n class operator_logical_or : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &lh,\n-\t\t\t\t  const value_range &rh) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &lh,\n+\t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -1960,16 +1966,15 @@ class operator_logical_or : public range_operator\n \t\t\t  const value_range &op1) const;\n } op_logical_or;\n \n-value_range\n-operator_logical_or::fold_range (tree type ATTRIBUTE_UNUSED,\n+void\n+operator_logical_or::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const value_range &lh,\n \t\t\t\t const value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n \n-  return range_union (lh, rh);\n+  r = range_union (lh, rh);\n }\n \n bool\n@@ -2011,23 +2016,22 @@ class operator_bitwise_or : public range_operator\n   virtual bool op2_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op1) const;\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_bitwise_or;\n \n-value_range\n-operator_bitwise_or::wi_fold (tree type,\n+void\n+operator_bitwise_or::wi_fold (value_range &r, tree type,\n \t\t\t      const wide_int &lh_lb,\n \t\t\t      const wide_int &lh_ub,\n \t\t\t      const wide_int &rh_lb,\n \t\t\t      const wide_int &rh_ub) const\n {\n-  value_range r;\n   if (wi_optimize_and_or (r, BIT_IOR_EXPR, type, lh_lb, lh_ub, rh_lb, rh_ub))\n-    return r;\n+    return;\n \n   wide_int maybe_nonzero_lh, mustbe_nonzero_lh;\n   wide_int maybe_nonzero_rh, mustbe_nonzero_rh;\n@@ -2056,9 +2060,9 @@ operator_bitwise_or::wi_fold (tree type,\n     new_lb = wi::max (new_lb, rh_lb, sign);\n   // If the limits got swapped around, return varying.\n   if (wi::gt_p (new_lb, new_ub,sign))\n-    return value_range (type);\n-\n-  return value_range_with_overflow (type, new_lb, new_ub);\n+    r = value_range (type);\n+  else\n+    value_range_with_overflow (r, type, new_lb, new_ub);\n }\n \n bool\n@@ -2087,15 +2091,15 @@ operator_bitwise_or::op2_range (value_range &r, tree type,\n class operator_bitwise_xor : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_bitwise_xor;\n \n-value_range\n-operator_bitwise_xor::wi_fold (tree type,\n+void\n+operator_bitwise_xor::wi_fold (value_range &r, tree type,\n \t\t\t       const wide_int &lh_lb,\n \t\t\t       const wide_int &lh_ub,\n \t\t\t       const wide_int &rh_lb,\n@@ -2120,24 +2124,24 @@ operator_bitwise_xor::wi_fold (tree type,\n   // If the range has all positive or all negative values, the result\n   // is better than VARYING.\n   if (wi::lt_p (new_lb, 0, sign) || wi::ge_p (new_ub, 0, sign))\n-    return value_range_with_overflow (type, new_lb, new_ub);\n-\n-  return value_range (type);\n+    value_range_with_overflow (r, type, new_lb, new_ub);\n+  else\n+    r = value_range (type);\n }\n \n \n class operator_trunc_mod : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_trunc_mod;\n \n-value_range\n-operator_trunc_mod::wi_fold (tree type,\n+void\n+operator_trunc_mod::wi_fold (value_range &r, tree type,\n \t\t\t     const wide_int &lh_lb,\n \t\t\t     const wide_int &lh_ub,\n \t\t\t     const wide_int &rh_lb,\n@@ -2149,7 +2153,10 @@ operator_trunc_mod::wi_fold (tree type,\n \n   // Mod 0 is undefined.  Return undefined.\n   if (wi_zero_p (type, rh_lb, rh_ub))\n-    return value_range ();\n+    {\n+      r = value_range ();\n+      return;\n+    }\n \n   // ABS (A % B) < ABS (B) and either 0 <= A % B <= A or A <= A % B <= 0.\n   new_ub = rh_ub - 1;\n@@ -2174,16 +2181,16 @@ operator_trunc_mod::wi_fold (tree type,\n     tmp = wi::zero (prec);\n   new_ub = wi::min (new_ub, tmp, sign);\n \n-  return value_range_with_overflow (type, new_lb, new_ub);\n+  value_range_with_overflow (r, type, new_lb, new_ub);\n }\n \n \n class operator_logical_not : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &lh,\n-\t\t\t\t  const value_range &rh) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &lh,\n+\t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n@@ -2203,21 +2210,20 @@ class operator_logical_not : public range_operator\n // \t b_2 = x_1 < 20\t\t[0,0] = x_1 < 20,   false, so x_1 == [20, 255]\n //   which is the result we are looking for.. so.. pass it through.\n \n-value_range\n-operator_logical_not::fold_range (tree type,\n+void\n+operator_logical_not::fold_range (value_range &r, tree type,\n \t\t\t\t  const value_range &lh,\n \t\t\t\t  const value_range &rh ATTRIBUTE_UNUSED) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n \n   if (lh.varying_p () || lh.undefined_p ())\n     r = lh;\n   else\n     r = range_invert (lh);\n   gcc_checking_assert (lh.type() == type);\n-  return r;\n+  return;\n }\n \n bool\n@@ -2237,28 +2243,27 @@ operator_logical_not::op1_range (value_range &r,\n class operator_bitwise_not : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &lh,\n-\t\t\t\t  const value_range &rh) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &lh,\n+\t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_bitwise_not;\n \n-value_range\n-operator_bitwise_not::fold_range (tree type,\n+void\n+operator_bitwise_not::fold_range (value_range &r, tree type,\n \t\t\t\t  const value_range &lh,\n \t\t\t\t  const value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n \n   // ~X is simply -1 - X.\n   value_range minusone (type, wi::minus_one (TYPE_PRECISION (type)),\n \t\t\twi::minus_one (TYPE_PRECISION (type)));\n-  r = range_op_handler (MINUS_EXPR, type)->fold_range (type, minusone, lh);\n-  return r;\n+  range_op_handler (MINUS_EXPR, type)->fold_range (r, type, minusone, lh);\n+  return;\n }\n \n bool\n@@ -2267,45 +2272,45 @@ operator_bitwise_not::op1_range (value_range &r, tree type,\n \t\t\t\t const value_range &op2) const\n {\n   // ~X is -1 - X and since bitwise NOT is involutary...do it again.\n-  r = fold_range (type, lhs, op2);\n+  fold_range (r, type, lhs, op2);\n   return true;\n }\n \n \n class operator_cst : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n } op_integer_cst;\n \n-value_range\n-operator_cst::fold_range (tree type ATTRIBUTE_UNUSED,\n+void\n+operator_cst::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t  const value_range &lh,\n \t\t\t  const value_range &rh ATTRIBUTE_UNUSED) const\n {\n-  return lh;\n+  r = lh;\n }\n \n \n class operator_identity : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_identity;\n \n-value_range\n-operator_identity::fold_range (tree type ATTRIBUTE_UNUSED,\n+void\n+operator_identity::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t       const value_range &lh,\n \t\t\t       const value_range &rh ATTRIBUTE_UNUSED) const\n {\n-  return lh;\n+  r = lh;\n }\n \n bool\n@@ -2321,18 +2326,18 @@ operator_identity::op1_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n class operator_abs : public range_operator\n {\n  public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_abs;\n \n-value_range\n-operator_abs::wi_fold (tree type,\n+void\n+operator_abs::wi_fold (value_range &r, tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb ATTRIBUTE_UNUSED,\n \t\t       const wide_int &rh_ub ATTRIBUTE_UNUSED) const\n@@ -2343,14 +2348,20 @@ operator_abs::wi_fold (tree type,\n \n   // Pass through LH for the easy cases.\n   if (sign == UNSIGNED || wi::ge_p (lh_lb, 0, sign))\n-    return value_range (type, lh_lb, lh_ub);\n+    {\n+      r = value_range (type, lh_lb, lh_ub);\n+      return;\n+    }\n \n   // -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get\n   // a useful range.\n   wide_int min_value = wi::min_value (prec, sign);\n   wide_int max_value = wi::max_value (prec, sign);\n   if (!TYPE_OVERFLOW_UNDEFINED (type) && wi::eq_p (lh_lb, min_value))\n-    return value_range (type);\n+    {\n+      r = value_range (type, lh_lb, lh_ub);\n+      return;\n+    }\n \n   // ABS_EXPR may flip the range around, if the original range\n   // included negative values.\n@@ -2386,7 +2397,7 @@ operator_abs::wi_fold (tree type,\n       min = wi::zero (prec);\n       max = max_value;\n     }\n-  return value_range (type, min, max);\n+  r = value_range (type, min, max);\n }\n \n bool\n@@ -2418,13 +2429,13 @@ operator_abs::op1_range (value_range &r, tree type,\n class operator_absu : public range_operator\n {\n  public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n-\t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n+\t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_absu;\n \n-value_range\n-operator_absu::wi_fold (tree type,\n+void\n+operator_absu::wi_fold (value_range &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb ATTRIBUTE_UNUSED,\n \t\t\tconst wide_int &rh_ub ATTRIBUTE_UNUSED) const\n@@ -2455,33 +2466,31 @@ operator_absu::wi_fold (tree type,\n     }\n \n   gcc_checking_assert (TYPE_UNSIGNED (type));\n-  return value_range (type, new_lb, new_ub);\n+  r = value_range (type, new_lb, new_ub);\n }\n \n \n class operator_negate : public range_operator\n {\n  public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_negate;\n \n-value_range\n-operator_negate::fold_range (tree type,\n+void\n+operator_negate::fold_range (value_range &r, tree type,\n \t\t\t     const value_range &lh,\n \t\t\t     const value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n   // -X is simply 0 - X.\n-  return\n-    range_op_handler (MINUS_EXPR, type)->fold_range (type,\n-\t\t\t\t\t\t     range_zero (type), lh);\n+  range_op_handler (MINUS_EXPR, type)->fold_range (r, type,\n+\t\t\t\t\t\t   range_zero (type), lh);\n }\n \n bool\n@@ -2490,61 +2499,61 @@ operator_negate::op1_range (value_range &r, tree type,\n \t\t\t    const value_range &op2) const\n {\n   // NEGATE is involutory.\n-  r = fold_range (type, lhs, op2);\n+  fold_range (r, type, lhs, op2);\n   return true;\n }\n \n \n class operator_addr_expr : public range_operator\n {\n public:\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &op1,\n-\t\t\t\t  const value_range &op2) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &op1,\n+\t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_addr;\n \n-value_range\n-operator_addr_expr::fold_range (tree type,\n+void\n+operator_addr_expr::fold_range (value_range &r, tree type,\n \t\t\t\tconst value_range &lh,\n \t\t\t\tconst value_range &rh) const\n {\n-  value_range r;\n   if (empty_range_check (r, lh, rh))\n-    return r;\n+    return;\n \n   // Return a non-null pointer of the LHS type (passed in op2).\n   if (lh.zero_p ())\n-    return range_zero (type);\n-  if (!lh.contains_p (build_zero_cst (lh.type ())))\n-    return range_nonzero (type);\n-  return value_range (type);\n+    r = range_zero (type);\n+  else if (!lh.contains_p (build_zero_cst (lh.type ())))\n+    r = range_nonzero (type);\n+  else\n+    r = value_range (type);\n }\n \n bool\n operator_addr_expr::op1_range (value_range &r, tree type,\n \t\t\t       const value_range &lhs,\n \t\t\t       const value_range &op2) const\n {\n-  r = operator_addr_expr::fold_range (type, lhs, op2);\n+  operator_addr_expr::fold_range (r, type, lhs, op2);\n   return true;\n }\n \n \n class pointer_plus_operator : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t       const wide_int &lh_lb,\n-\t\t\t       const wide_int &lh_ub,\n-\t\t\t       const wide_int &rh_lb,\n-\t\t\t       const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n } op_pointer_plus;\n \n-value_range\n-pointer_plus_operator::wi_fold (tree type,\n+void\n+pointer_plus_operator::wi_fold (value_range &r, tree type,\n \t\t\t\tconst wide_int &lh_lb,\n \t\t\t\tconst wide_int &lh_ub,\n \t\t\t\tconst wide_int &rh_lb,\n@@ -2571,24 +2580,25 @@ pointer_plus_operator::wi_fold (tree type,\n       && !TYPE_OVERFLOW_WRAPS (type)\n       && (flag_delete_null_pointer_checks\n \t  || !wi::sign_mask (rh_ub)))\n-    return range_nonzero (type);\n-  if (lh_lb == lh_ub && lh_lb == 0\n-      && rh_lb == rh_ub && rh_lb == 0)\n-    return range_zero (type);\n-  return value_range (type);\n+    r = range_nonzero (type);\n+  else if (lh_lb == lh_ub && lh_lb == 0\n+\t   && rh_lb == rh_ub && rh_lb == 0)\n+    r = range_zero (type);\n+  else\n+   r = value_range (type);\n }\n \n \n class pointer_min_max_operator : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-                          const wide_int &lh_lb, const wide_int &lh_ub,\n-                          const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range & r, tree type,\n+\t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n+\t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_ptr_min_max;\n \n-value_range\n-pointer_min_max_operator::wi_fold (tree type,\n+void\n+pointer_min_max_operator::wi_fold (value_range &r, tree type,\n \t\t\t\t   const wide_int &lh_lb,\n \t\t\t\t   const wide_int &lh_ub,\n \t\t\t\t   const wide_int &rh_lb,\n@@ -2600,23 +2610,24 @@ pointer_min_max_operator::wi_fold (tree type,\n   // are varying.\n   if (!wi_includes_zero_p (type, lh_lb, lh_ub)\n       && !wi_includes_zero_p (type, rh_lb, rh_ub))\n-    return range_nonzero (type);\n-  if (wi_zero_p (type, lh_lb, lh_ub) && wi_zero_p (type, rh_lb, rh_ub))\n-    return range_zero (type);\n-  return value_range (type);\n+    r = range_nonzero (type);\n+  else if (wi_zero_p (type, lh_lb, lh_ub) && wi_zero_p (type, rh_lb, rh_ub))\n+    r = range_zero (type);\n+  else\n+    r = value_range (type);\n }\n \n \n class pointer_and_operator : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n-\t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n+\t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_pointer_and;\n \n-value_range\n-pointer_and_operator::wi_fold (tree type,\n+void\n+pointer_and_operator::wi_fold (value_range &r, tree type,\n \t\t\t       const wide_int &lh_lb,\n \t\t\t       const wide_int &lh_ub,\n \t\t\t       const wide_int &rh_lb ATTRIBUTE_UNUSED,\n@@ -2625,22 +2636,22 @@ pointer_and_operator::wi_fold (tree type,\n   // For pointer types, we are really only interested in asserting\n   // whether the expression evaluates to non-NULL.\n   if (wi_zero_p (type, lh_lb, lh_ub) || wi_zero_p (type, lh_lb, lh_ub))\n-    return range_zero (type);\n-\n-  return value_range (type);\n+    r = range_zero (type);\n+  else \n+    r = value_range (type);\n }\n \n \n class pointer_or_operator : public range_operator\n {\n public:\n-  virtual value_range wi_fold (tree type,\n-\t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n-\t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n+\t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_pointer_or;\n \n-value_range\n-pointer_or_operator::wi_fold (tree type,\n+void\n+pointer_or_operator::wi_fold (value_range &r, tree type,\n \t\t\t      const wide_int &lh_lb,\n \t\t\t      const wide_int &lh_ub,\n \t\t\t      const wide_int &rh_lb,\n@@ -2650,10 +2661,11 @@ pointer_or_operator::wi_fold (tree type,\n   // whether the expression evaluates to non-NULL.\n   if (!wi_includes_zero_p (type, lh_lb, lh_ub)\n       && !wi_includes_zero_p (type, rh_lb, rh_ub))\n-    return range_nonzero (type);\n-  if (wi_zero_p (type, lh_lb, lh_ub) && wi_zero_p (type, rh_lb, rh_ub))\n-    return range_zero (type);\n-  return value_range (type);\n+    r = range_nonzero (type);\n+  else if (wi_zero_p (type, lh_lb, lh_ub) && wi_zero_p (type, rh_lb, rh_ub))\n+    r = range_zero (type);\n+  else\n+    r = value_range (type);\n }\n \f\n // This implements the range operator tables as local objects in this file.\n@@ -2782,8 +2794,9 @@ range_op_handler (enum tree_code code, tree type)\n void\n range_cast (value_range &r, tree type)\n {\n+  value_range tmp = r;\n   range_operator *op = range_op_handler (CONVERT_EXPR, type);\n-  r = op->fold_range (type, r, value_range (type));\n+  op->fold_range (r, type, tmp, value_range (type));\n }\n \n #if CHECKING_P"}, {"sha": "4b0b57225a39aefaed7ec7906700bef41166a5f4", "filename": "gcc/range-op.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "patch": "@@ -50,9 +50,9 @@ class range_operator\n {\n public:\n   // Perform an operation between 2 ranges and return it.\n-  virtual value_range fold_range (tree type,\n-\t\t\t\t  const value_range &lh,\n-\t\t\t\t  const value_range &rh) const;\n+  virtual void fold_range (value_range &r, tree type,\n+\t\t\t   const value_range &lh,\n+\t\t\t   const value_range &rh) const;\n \n   // Return the range for op[12] in the general case.  LHS is the range for\n   // the LHS of the expression, OP[12]is the range for the other\n@@ -74,11 +74,11 @@ class range_operator\n \n protected:\n   // Perform an operation between 2 sub-ranges and return it.\n-  virtual value_range wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual void wi_fold (value_range &r, tree type,\n+\t\t        const wide_int &lh_lb,\n+\t\t        const wide_int &lh_ub,\n+\t\t        const wide_int &rh_lb,\n+\t\t        const wide_int &rh_ub) const;\n };\n \n extern range_operator *range_op_handler (enum tree_code code, tree type);"}, {"sha": "b8b6967dae7f94ccece136dbb1db2639842aa65a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb74ef9e8cd3ab77a3451951f87adde0a4a2871a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=bb74ef9e8cd3ab77a3451951f87adde0a4a2871a", "patch": "@@ -1781,9 +1781,8 @@ range_fold_binary_symbolics_p (value_range *vr,\n \t  return true;\n \t}\n       const range_operator *op = get_range_op_handler (vr, code, expr_type);\n-      *vr = op->fold_range (expr_type,\n-\t\t\t    vr0->normalize_symbolics (),\n-\t\t\t    vr1->normalize_symbolics ());\n+      op->fold_range (*vr, expr_type, vr0->normalize_symbolics (),\n+\t\t      vr1->normalize_symbolics ());\n       return true;\n     }\n   return false;\n@@ -1817,9 +1816,8 @@ range_fold_unary_symbolics_p (value_range *vr,\n \t  return true;\n \t}\n       const range_operator *op = get_range_op_handler (vr, code, expr_type);\n-      *vr = op->fold_range (expr_type,\n-\t\t\t    vr0->normalize_symbolics (),\n-\t\t\t    value_range (expr_type));\n+      op->fold_range (*vr, expr_type, vr0->normalize_symbolics (),\n+\t\t      value_range (expr_type));\n       return true;\n     }\n   return false;\n@@ -1846,9 +1844,8 @@ range_fold_binary_expr (value_range *vr,\n   if (range_fold_binary_symbolics_p (vr, code, expr_type, &vr0, &vr1))\n     return;\n \n-  *vr = op->fold_range (expr_type,\n-\t\t\tvr0.normalize_addresses (),\n-\t\t\tvr1.normalize_addresses ());\n+  op->fold_range (*vr, expr_type, vr0.normalize_addresses (),\n+\t\t  vr1.normalize_addresses ());\n }\n \n /* Perform a unary operation on a range.  */\n@@ -1869,9 +1866,8 @@ range_fold_unary_expr (value_range *vr,\n   if (range_fold_unary_symbolics_p (vr, code, expr_type, vr0))\n     return;\n \n-  *vr = op->fold_range (expr_type,\n-\t\t\tvr0->normalize_addresses (),\n-\t\t\tvalue_range (expr_type));\n+  op->fold_range (*vr, expr_type, vr0->normalize_addresses (),\n+\t\t  value_range (expr_type));\n }\n \n /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,"}]}