{"sha": "59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkyNTdmZjdiODdhZTlmMTczOTVjNDhhZDZlNGRkOWExMjNiMGQ5ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-06T11:35:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-06T11:35:29Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r915", "tree": {"sha": "b5209b7c5df800016e8e17a01db1d611312f1480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5209b7c5df800016e8e17a01db1d611312f1480"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/comments", "author": null, "committer": null, "parents": [{"sha": "a196f01fdf15b503763b23822770e1c945517cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a196f01fdf15b503763b23822770e1c945517cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a196f01fdf15b503763b23822770e1c945517cef"}], "stats": {"total": 291, "additions": 252, "deletions": 39}, "files": [{"sha": "8541d16a9e4a13d0ab9677ae8c4a7239d007fb02", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "patch": "@@ -800,7 +800,7 @@ expand_call (exp, target, ignore)\n \n \t      if (old_stack_level == 0)\n \t\t{\n-\t\t  old_stack_level = copy_to_mode_reg (Pmode, stack_pointer_rtx);\n+\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n \t\t  old_pending_adj = pending_stack_adjust;\n \t\t  pending_stack_adjust = 0;\n \t\t}\n@@ -1060,7 +1060,7 @@ expand_call (exp, target, ignore)\n     {\n       if (old_stack_level == 0)\n \t{\n-\t  old_stack_level = copy_to_mode_reg (Pmode, stack_pointer_rtx);\n+\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n \t  old_pending_adj = pending_stack_adjust;\n \t  pending_stack_adjust = 0;\n \t}\n@@ -1520,7 +1520,7 @@ expand_call (exp, target, ignore)\n \n   if (old_stack_level)\n     {\n-      emit_move_insn (stack_pointer_rtx, old_stack_level);\n+      emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n       pending_stack_adjust = old_pending_adj;\n     }\n \n@@ -1570,9 +1570,12 @@ expand_call (exp, target, ignore)\n     }\n #endif\n \n-  /* If this was alloca, record the new stack level for nonlocal gotos.  */\n-  if (may_be_alloca && nonlocal_goto_stack_level != 0)\n-    emit_move_insn (nonlocal_goto_stack_level, stack_pointer_rtx);\n+  /* If this was alloca, record the new stack level for nonlocal gotos.  \n+     Check for the handler slots since we might not have a save area\n+     for non-local gotos. */\n+\n+  if (may_be_alloca && nonlocal_goto_handler_slot != 0)\n+    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n \n   pop_temp_slots ();\n "}, {"sha": "d3e6bce9ccfe8f3c403b37825c1d8b47c5c9db29", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "patch": "@@ -2835,9 +2835,7 @@\n ;; Next come insns related to the calling sequence.\n ;;\n ;; First, an insn to allocate new stack space for dynamic use (e.g., alloca).\n-;; We move the back-chain and decrement the stack pointer.  This is slightly\n-;; less efficient than it needs to be for long constants, but that case\n-;; should be rare.\n+;; We move the back-chain and decrement the stack pointer.  \n \n (define_expand \"allocate_stack\"\n   [(set (reg:SI 1)\n@@ -2852,6 +2850,63 @@\n   emit_move_insn (stack_bot, chain);\n   DONE;\n }\")\n+\n+;; These patterns say how to save and restore the stack pointer.  We need not\n+;; save the stack pointer at function level since we are careful to\n+;; preserve the backchain.  At block level, we have to restore the backchain\n+;; when we restore the stack pointer.\n+;;\n+;; For nonlocal gotos, we must save both the stack pointer and its\n+;; backchain and restore both.  Note that in the nonlocal case, the\n+;; save area is a memory location.\n+\n+(define_expand \"save_stack_function\"\n+  [(use (const_int 0))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"restore_stack_function\"\n+  [(use (const_int 0))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"restore_stack_block\"\n+  [(set (match_dup 2) (mem:SI (match_operand:SI 0 \"register_operand\" \"\")))\n+   (set (match_dup 0) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (mem:SI (match_dup 0)) (match_dup 2))]\n+  \"\"\n+  \"\n+{ operands[2] = gen_reg_rtx (SImode); }\")\n+\n+(define_expand \"save_stack_nonlocal\"\n+  [(match_operand:DI 0 \"memory_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+\n+  /* Copy the backchain to the first word, sp to the second.  */\n+  emit_move_insn (temp, gen_rtx (MEM, SImode, operands[1]));\n+  emit_move_insn (operand_subword (operands[0], 0, 0, DImode), temp);\n+  emit_move_insn (operand_subword (operands[0], 1, 0, DImode), operands[1]);\n+  DONE;\n+}\")\n+\t\t  \n+(define_expand \"restore_stack_nonlocal\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"memory_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+\n+  /* Restore the backchain from the first word, sp from the second.  */\n+  emit_move_insn (temp, operand_subword (operands[1], 0, 0, DImode));\n+  emit_move_insn (operands[0], operand_subword (operands[1], 1, 0, DImode));\n+  emit_move_insn (gen_rtx (MEM, SImode, operands[0]), temp);\n+  DONE;\n+}\")\n \f\n ;; A function pointer is a pointer to a data area whose first word contains\n ;; the actual address of the function, whose second word contains a pointer"}, {"sha": "4504a73cd09eadab3dbc13f143bee6716de43b4e", "filename": "gcc/explow.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "patch": "@@ -681,6 +681,127 @@ round_push (size)\n   return size;\n }\n \f\n+/* Save the stack pointer for the purpose in SAVE_LEVEL.  PSAVE is a pointer\n+   to a previously-created save area.  If no save area has been allocated,\n+   this function will allocate one.  If a save area is specified, it\n+   must be of the proper mode.\n+\n+   The insns are emitted after insn AFTER, if nonzero, otherwise the insns\n+   are emitted at the current position.  */\n+\n+void\n+emit_stack_save (save_level, psave, after)\n+     enum save_level save_level;\n+     rtx *psave;\n+     rtx after;\n+{\n+  rtx sa = *psave;\n+  /* The default is that we use a move insn and save in a Pmode object.  */\n+  rtx (*fcn) () = gen_move_insn;\n+  enum machine_mode mode = Pmode;\n+\n+  /* See if this machine has anything special to do for this kind of save.  */\n+  switch (save_level)\n+    {\n+#ifdef HAVE_save_stack_block\n+    case SAVE_BLOCK:\n+      if (HAVE_save_stack_block)\n+\t{\n+\t  fcn = gen_save_stack_block;\n+\t  mode = insn_operand_mode[CODE_FOR_save_stack_block][0];\n+\t}\n+      break;\n+#endif\n+#ifdef HAVE_save_stack_function\n+    case SAVE_FUNCTION:\n+      if (HAVE_save_stack_function)\n+\t{\n+\t  fcn = gen_save_stack_function;\n+\t  mode = insn_operand_mode[CODE_FOR_save_stack_function][0];\n+\t}\n+      break;\n+#endif\n+#ifdef HAVE_save_stack_nonlocal\n+    case SAVE_NONLOCAL:\n+      if (HAVE_save_stack_nonlocal)\n+\t{\n+\t  fcn = gen_save_stack_nonlocal;\n+\t  mode = insn_operand_mode[CODE_FOR_save_stack_nonlocal][0];\n+\t}\n+      break;\n+#endif\n+    }\n+\n+  /* If there is no save area and we have to allocate one, do so.  Otherwise\n+     verify the save area is the proper mode.  */\n+\n+  if (sa == 0)\n+    {\n+      if (mode != VOIDmode)\n+\t{\n+\t  if (save_level == SAVE_NONLOCAL)\n+\t    *psave = sa = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n+\t  else\n+\t    *psave = sa = gen_reg_rtx (mode);\n+\t}\n+    }\n+  else\n+    {\n+      if (mode == VOIDmode || GET_MODE (sa) != mode)\n+\tabort ();\n+    }\n+\n+  if (after)\n+    emit_insn_after (fcn (sa, stack_pointer_rtx), after);\n+  else\n+    emit_insn (fcn (sa, stack_pointer_rtx));\n+}\n+\n+/* Restore the stack pointer for the purpose in SAVE_LEVEL.  SA is the save\n+   area made by emit_stack_save.  If it is zero, we have nothing to do. \n+\n+   Put any emitted insns after insn AFTER, if nonzero, otherwise at \n+   current position.  */\n+\n+void\n+emit_stack_restore (save_level, sa, after)\n+     enum save_level save_level;\n+     rtx after;\n+     rtx sa;\n+{\n+  /* The default is that we use a move insn.  */\n+  rtx (*fcn) () = gen_move_insn;\n+\n+  /* See if this machine has anything special to do for this kind of save.  */\n+  switch (save_level)\n+    {\n+#ifdef HAVE_restore_stack_block\n+    case SAVE_BLOCK:\n+      if (HAVE_restore_stack_block)\n+\tfcn = gen_restore_stack_block;\n+      break;\n+#endif\n+#ifdef HAVE_restore_stack_function\n+    case SAVE_FUNCTION:\n+      if (HAVE_restore_stack_function)\n+\tfcn = gen_restore_stack_function;\n+      break;\n+#endif\n+#ifdef HAVE_restore_stack_nonlocal\n+\n+    case SAVE_NONLOCAL:\n+      if (HAVE_restore_stack_nonlocal)\n+\tfcn = gen_restore_stack_nonlocal;\n+      break;\n+#endif\n+    }\n+\n+  if (after)\n+    emit_insn_after (fcn (stack_pointer_rtx, sa), after);\n+  else\n+    emit_insn (fcn (stack_pointer_rtx, sa));\n+}\n+\f\n /* Return an rtx representing the address of an area of memory dynamically\n    pushed on the stack.  This region of memory is always aligned to\n    a multiple of BIGGEST_ALIGNMENT."}, {"sha": "3a140d2db9bae9f20f861bb8112ea210872842c1", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "patch": "@@ -539,6 +539,15 @@ extern void adjust_stack ();\n /* Add some bytes to the stack.  An rtx says how many.  */\n extern void anti_adjust_stack ();\n \n+/* This enum is used for the following two functions.  */\n+enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n+\n+/* Save the stack pointer at the specified level.  */\n+extern void emit_stack_save ();\n+\n+/* Restore the stack pointer from a save area of the specified level.  */\n+extern void emit_stack_restore ();\n+\n /* Allocate some space on the stack dynamically and return its address.  An rtx\n    says how many bytes.  */\n extern rtx allocate_dynamic_stack_space ();"}, {"sha": "45dc777581afdcf69656e7e80b68eee27bfa94a8", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "patch": "@@ -2317,11 +2317,11 @@ delete_handlers ()\n       if (GET_CODE (insn) == CODE_LABEL)\n \tLABEL_PRESERVE_P (insn) = 0;\n       if (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && (SET_DEST (PATTERN (insn)) == nonlocal_goto_handler_slot\n-\t      || SET_SRC (PATTERN (insn)) == nonlocal_goto_handler_slot\n-\t      || SET_DEST (PATTERN (insn)) == nonlocal_goto_stack_level\n-\t      || SET_SRC (PATTERN (insn)) == nonlocal_goto_stack_level))\n+\t  && ((nonlocal_goto_handler_slot != 0\n+\t       && reg_mentioned_p (nonlocal_goto_handler_slot, PATTERN (insn)))\n+\t      || (nonlocal_goto_stack_level != 0\n+\t\t  && reg_mentioned_p (nonlocal_goto_stack_level,\n+\t\t\t\t      PATTERN (insn)))))\n \tdelete_insn (insn);\n     }\n }\n@@ -3961,10 +3961,10 @@ expand_function_end (filename, line)\n #endif\n     if (current_function_calls_alloca)\n       {\n-\trtx tem = gen_reg_rtx (Pmode);\n-\temit_insn_after (gen_rtx (SET, VOIDmode, tem, stack_pointer_rtx),\n-\t\t\t parm_birth_insn);\n-\temit_insn (gen_rtx (SET, VOIDmode, stack_pointer_rtx, tem));\n+\trtx tem = 0;\n+\n+\temit_stack_save (SAVE_FUNCTION, &tem, parm_birth_insn);\n+\temit_stack_restore (SAVE_FUNCTION, tem, 0);\n       }\n \n   /* If scalar return value was computed in a pseudo-reg,"}, {"sha": "e2c52bfed17ed3dd5e9f35d026b1c3ac4464c155", "filename": "gcc/stmt.c", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=59257ff7b87ae9f17395c48ad6e4dd9a123b0d9d", "patch": "@@ -586,11 +586,9 @@ declare_nonlocal_label (label)\n     {\n       nonlocal_goto_handler_slot\n \t= assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-      nonlocal_goto_stack_level\n-\t= assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-      emit_insn_before (gen_move_insn (nonlocal_goto_stack_level,\n-\t\t\t\t       stack_pointer_rtx),\n-\t\t\ttail_recursion_reentry);\n+      emit_stack_save (SAVE_NONLOCAL,\n+\t\t       &nonlocal_goto_stack_level,\n+\t\t       PREV_INSN (tail_recursion_reentry));\n     }\n }\n \n@@ -609,27 +607,50 @@ expand_goto (label)\n       struct function *p = find_function_data (context);\n       rtx temp;\n       p->has_nonlocal_label = 1;\n+\n+      /* Copy the rtl for the slots so that they won't be shared in\n+\t case the virtual stack vars register gets instantiated differently\n+\t in the parent than in the child.  */\n+\n #if HAVE_nonlocal_goto\n       if (HAVE_nonlocal_goto)\n \temit_insn (gen_nonlocal_goto (lookup_static_chain (label),\n-\t\t\t\t      p->nonlocal_goto_handler_slot,\n-\t\t\t\t      p->nonlocal_goto_stack_level,\n+\t\t\t\t      copy_rtx (p->nonlocal_goto_handler_slot),\n+\t\t\t\t      copy_rtx (p->nonlocal_goto_stack_level),\n \t\t\t\t      gen_rtx (LABEL_REF, Pmode,\n \t\t\t\t\t       label_rtx (label))));\n       else\n #endif\n \t{\n+\t  rtx addr;\n+\n \t  /* Restore frame pointer for containing function.\n \t     This sets the actual hard register used for the frame pointer\n \t     to the location of the function's incoming static chain info.\n \t     The non-local goto handler will then adjust it to contain the\n \t     proper value and reload the argument pointer, if needed.  */\n \t  emit_move_insn (frame_pointer_rtx, lookup_static_chain (label));\n+\n+\t  /* We have now loaded the frame pointer hardware register with\n+\t     the address of that corresponds to the start of the virtual\n+\t     stack vars.  So replace virtual_stack_vars_rtx in all\n+\t     addresses we use with stack_pointer_rtx.  */\n+\n \t  /* Get addr of containing function's current nonlocal goto handler,\n \t     which will do any cleanups and then jump to the label.  */\n-\t  temp = copy_to_reg (p->nonlocal_goto_handler_slot);\n+\t  addr = copy_rtx (p->nonlocal_goto_handler_slot);\n+\t  temp = copy_to_reg (replace_rtx (addr, virtual_stack_vars_rtx,\n+\t\t\t\t\t   frame_pointer_rtx));\n+\t  \n \t  /* Restore the stack pointer.  Note this uses fp just restored.  */\n-\t  emit_move_insn (stack_pointer_rtx, p->nonlocal_goto_stack_level);\n+\t  addr = p->nonlocal_goto_stack_level;\n+\t  if (addr)\n+\t    addr = replace_rtx (copy_rtx (p->nonlocal_goto_stack_level),\n+\t\t\t\treplace_rtx (addr, virtual_stack_vars_rtx,\n+\t\t\t\t\t     frame_pointer_rtx));\n+\n+\t  emit_stack_restore (SAVE_NONLOCAL, addr, 0);\n+\n \t  /* Put in the static chain register the nonlocal label address.  */\n \t  emit_move_insn (static_chain_rtx,\n \t\t\t  gen_rtx (LABEL_REF, Pmode, label_rtx (label)));\n@@ -691,7 +712,7 @@ expand_goto_internal (body, label, last_insn)\n \t     the stack pointer.  This one should be deleted as dead by flow. */\n \t  clear_pending_stack_adjust ();\n \t  do_pending_stack_adjust ();\n-\t  emit_move_insn (stack_pointer_rtx, stack_level);\n+\t  emit_stack_restore (SAVE_BLOCK, stack_level, 0);\n \t}\n \n       if (body != 0 && DECL_TOO_LATE (body))\n@@ -902,8 +923,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t  /* Restore stack level for the biggest contour that this\n \t     jump jumps out of.  */\n \t  if (f->stack_level)\n-\t    emit_insn_after (gen_move_insn (stack_pointer_rtx, f->stack_level),\n-\t\t\t     f->before_jump);\n+\t    emit_stack_restore (SAVE_BLOCK, f->stack_level, f->before_jump);\n \t  f->before_jump = 0;\n \t}\n     }\n@@ -2592,14 +2612,15 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \n       if (thisblock->data.block.stack_level != 0)\n \t{\n-\t  emit_move_insn (stack_pointer_rtx,\n-\t\t\t  thisblock->data.block.stack_level);\n-\t  if (nonlocal_goto_stack_level != 0)\n-\t    emit_move_insn (nonlocal_goto_stack_level, stack_pointer_rtx);\n+\t  emit_stack_restore (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n+\t\t\t      thisblock->data.block.stack_level, 0);\n+\t  if (nonlocal_goto_handler_slot != 0)\n+\t    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n \t}\n \n       /* Any gotos out of this block must also do these things.\n-\t Also report any gotos with fixups that came to labels in this level.  */\n+\t Also report any gotos with fixups that came to labels in this\n+\t level.  */\n       fixup_gotos (thisblock,\n \t\t   thisblock->data.block.stack_level,\n \t\t   thisblock->data.block.cleanups,\n@@ -2753,8 +2774,9 @@ expand_decl (decl)\n       if (thisblock->data.block.stack_level == 0)\n \t{\n \t  do_pending_stack_adjust ();\n-\t  thisblock->data.block.stack_level\n-\t    = copy_to_reg (stack_pointer_rtx);\n+\t  emit_stack_save (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n+\t\t\t   &thisblock->data.block.stack_level,\n+\t\t\t   thisblock->data.block.first_insn);\n \t  stack_block_stack = thisblock;\n \t}\n \n@@ -2765,11 +2787,14 @@ expand_decl (decl)\n \t\t\t  0, VOIDmode, 0);\n       free_temp_slots ();\n \n+      /* This is equivalent to calling alloca.  */\n+      current_function_calls_alloca = 1;\n+\n       /* Allocate space on the stack for the variable.  */\n       address = allocate_dynamic_stack_space (size, 0, DECL_ALIGN (decl));\n \n-      if (nonlocal_goto_stack_level != 0)\n-\temit_move_insn (nonlocal_goto_stack_level, stack_pointer_rtx);\n+      if (nonlocal_goto_handler_slot != 0)\n+\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n \n       /* Reference the variable indirect through that rtx.  */\n       DECL_RTL (decl) = gen_rtx (MEM, DECL_MODE (decl), address);"}]}