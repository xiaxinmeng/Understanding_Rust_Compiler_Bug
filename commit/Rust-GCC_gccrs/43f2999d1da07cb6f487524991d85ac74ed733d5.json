{"sha": "43f2999d1da07cb6f487524991d85ac74ed733d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNmMjk5OWQxZGEwN2NiNmY0ODc1MjQ5OTFkODVhYzc0ZWQ3MzNkNQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@cygnus.com", "date": "1995-04-19T17:08:54Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-19T17:08:54Z"}, "message": "66th Cygnus<->FSF merge\n\nFrom-SVN: r9418", "tree": {"sha": "e977a5f4a27b532d6c3e55982e9034aaf6097b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e977a5f4a27b532d6c3e55982e9034aaf6097b78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43f2999d1da07cb6f487524991d85ac74ed733d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f2999d1da07cb6f487524991d85ac74ed733d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43f2999d1da07cb6f487524991d85ac74ed733d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f2999d1da07cb6f487524991d85ac74ed733d5/comments", "author": null, "committer": null, "parents": [{"sha": "8a0e8d4dc4cff5cd0293a6bbef3ed77003d598e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0e8d4dc4cff5cd0293a6bbef3ed77003d598e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a0e8d4dc4cff5cd0293a6bbef3ed77003d598e1"}], "stats": {"total": 276, "additions": 268, "deletions": 8}, "files": [{"sha": "bbe5cd78180bcc8e05967861c6efb47d1ad46295", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=43f2999d1da07cb6f487524991d85ac74ed733d5", "patch": "@@ -1,3 +1,18 @@\n+Wed Apr 19 02:32:40 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (virtual_context): New function to get the virtual\n+\tcontext of a function.\n+\t(expand_upcast_fixups): New function to generate runtime vtables.\n+\t(fixup_virtual_upcast_offsets): Ditto.\n+\t(expand_indirect_vtbls_init): Use fixup_virtual_upcast_offsets to\n+\tensure that the this offsets for upcasts from virtual bases into\n+\tother virtual bases or non-virtual bases are correct at construction\n+\ttime and destruction time.\n+\t* class.c (fixup_vtable_deltas): Modify to fixup all offsets in all\n+\tvtables in all virtual bases, instead of just one vtable in each\n+\tvirtual base.\n+\t(fixup_vtable_deltas1): Ditto.\n+\n Tue Apr 18 03:57:35 1995  Michael Meissner  (meissner@cygnus.com)\n \n \t* Makefile.in (lex.o): Add dependency on c-pragma.h."}, {"sha": "03754bd4123ee516f4a195b24d6a9009338c4843", "filename": "gcc/cp/class.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=43f2999d1da07cb6f487524991d85ac74ed733d5", "patch": "@@ -2342,12 +2342,9 @@ modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n     }\n }\n \n-/* Fixup all the delta entries in this vtable that need updating.\n-   This happens when we have non-overridden virtual functions from a\n-   virtual base class, that are at a different offset, in the new\n-   hierarchy, because the layout of the virtual bases has changed.  */\n+/* Fixup all the delta entries in this one vtable that need updating.  */\n static void\n-fixup_vtable_deltas (binfo, t)\n+fixup_vtable_deltas1 (binfo, t)\n      tree binfo, t;\n {\n   tree virtuals = BINFO_VIRTUALS (binfo);\n@@ -2418,6 +2415,33 @@ fixup_vtable_deltas (binfo, t)\n     }\n }\n \n+/* Fixup all the delta entries in all the direct vtables that need updating.\n+   This happens when we have non-overridden virtual functions from a\n+   virtual base class, that are at a different offset, in the new\n+   hierarchy, because the layout of the virtual bases has changed.  */\n+static void\n+fixup_vtable_deltas (binfo, init_self, t)\n+     tree binfo, t;\n+     int init_self;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      if (! TREE_VIA_VIRTUAL (base_binfo))\n+\tfixup_vtable_deltas (base_binfo, is_not_base_vtable, t);\n+    }\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      fixup_vtable_deltas1 (binfo, t);\n+    }\n+}\n+\n /* These are the ones that are through virtual base classes. */\n static void\n modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n@@ -3707,7 +3731,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t     only doing this for vtables that come from virtual bases\n \t     that have differing offsets, but don't want to miss any\n \t     entries.  */\n-\t  fixup_vtable_deltas (vbases, t);\n+\t  fixup_vtable_deltas (vbases, 1, t);\n \t  vbases = TREE_CHAIN (vbases);\n \t}\n     }"}, {"sha": "3ed845cdd75b5f1056d44bb8fa92f9265da5f960", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=43f2999d1da07cb6f487524991d85ac74ed733d5", "patch": "@@ -138,7 +138,7 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n     }\n #if 0\n   /* Before turning this on, make sure it is correct.  */\n-  if (can_elide  && ! BINFO_MODIFIED (binfo))\n+  if (can_elide && ! BINFO_MODIFIED (binfo))\n     return;\n #endif\n   /* Should we use something besides CLASSTYPE_VFIELDS? */"}, {"sha": "dfa2315239b0572abc012574d82bad6a621b0b08", "filename": "gcc/cp/search.c", "status": "modified", "additions": 222, "deletions": 1, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f2999d1da07cb6f487524991d85ac74ed733d5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=43f2999d1da07cb6f487524991d85ac74ed733d5", "patch": "@@ -27,6 +27,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"cp-tree.h\"\n #include \"obstack.h\"\n #include \"flags.h\"\n+#include \"rtl.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -2552,6 +2553,184 @@ init_vbase_pointers (type, decl_ptr)\n   return 0;\n }\n \n+/* get the virtual context (the vbase that directly contains the\n+   DECL_CLASS_CONTEXT of the FNDECL) that the given FNDECL is declared in,\n+   or NULL_TREE if there is none.\n+\n+   FNDECL must come from a virtual table from a virtual base to ensure that\n+   there is only one possible DECL_CLASS_CONTEXT.\n+\n+   We know that if there is more than one place (binfo) the fndecl that the\n+   declared, they all refer to the same binfo.  See get_class_offset_1 for\n+   the check that ensures this.  */\n+static tree\n+virtual_context (fndecl, t, vbase)\n+     tree fndecl, t, vbase;\n+{\n+  tree path;\n+  if (get_base_distance (DECL_CLASS_CONTEXT (fndecl), t, 0, &path) < 0)\n+    {\n+      /* This shouldn't happen, I don't want errors! */\n+      warning (\"recoverable compiler error, fixups for virtual function\");\n+      return vbase;\n+    }\n+  while (path)\n+    {\n+      if (TREE_VIA_VIRTUAL (path))\n+\treturn binfo_member (BINFO_TYPE (path), CLASSTYPE_VBASECLASSES (t));\n+      path = BINFO_INHERITANCE_CHAIN (path);\n+    }\n+  return 0;\n+}\n+\n+/* Fixups upcast offsets for one vtable.\n+   Entries may stay within the VBASE given, or\n+   they may upcast into a direct base, or\n+   they may upcast into a different vbase.\n+\n+   We only need to do fixups in case 2 and 3.\n+\n+   This routine mirrors fixup_vtable_deltas in functionality, though\n+   this one is runtime based, and the other is compile time based.\n+   Conceivably that routine could be removed entirely, and all fixups\n+   done at runtime.\n+\n+   VBASE_OFFSETS is an association list of virtual bases that contains\n+   offset information, so the offsets are only calculated once.  */\n+static void\n+expand_upcast_fixups (binfo, addr, orig_addr, vbase, t, vbase_offsets)\n+     tree binfo, addr, orig_addr, vbase, t, *vbase_offsets;\n+{\n+  tree virtuals = BINFO_VIRTUALS (binfo);\n+  tree vc;\n+  tree delta;\n+  unsigned HOST_WIDE_INT n;\n+  \n+  delta = purpose_member (vbase, *vbase_offsets);\n+  if (! delta)\n+    {\n+      delta = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbase));\n+      delta = build (MINUS_EXPR, ptrdiff_type_node, delta, addr);\n+      delta = save_expr (delta);\n+      delta = tree_cons (vbase, delta, *vbase_offsets);\n+      *vbase_offsets = delta;\n+    }\n+\n+  /* Skip RTTI fake object. */\n+  n = 1;\n+  if (virtuals)\n+    virtuals = TREE_CHAIN (virtuals);\n+  while (virtuals)\n+    {\n+      tree current_fndecl = TREE_VALUE (virtuals);\n+      current_fndecl = FNADDR_FROM_VTABLE_ENTRY (current_fndecl);\n+      current_fndecl = TREE_OPERAND (current_fndecl, 0);\n+      if (current_fndecl\n+\t  && (vc=virtual_context (current_fndecl, t, vbase)) != vbase)\n+\t{\n+\t  /* This may in fact need a runtime fixup. */\n+\t  tree idx = DECL_VINDEX (current_fndecl);\n+\t  tree vtbl = BINFO_VTABLE (binfo);\n+\t  tree nvtbl = lookup_name (DECL_NAME (vtbl), 0);\n+\t  tree aref, ref, naref;\n+\t  tree old_delta, new_delta;\n+\t  tree init;\n+\n+\t  if (nvtbl == NULL_TREE\n+\t      || nvtbl == IDENTIFIER_GLOBAL_VALUE (DECL_NAME (vtbl)))\n+\t    {\n+\t      /* Dup it if it isn't in local scope yet.  */\n+\t      nvtbl = build_decl (VAR_DECL,\n+\t\t\t\t  DECL_NAME (vtbl),\n+\t\t\t\t  TYPE_MAIN_VARIANT (TREE_TYPE (BINFO_VTABLE (binfo))));\n+\t      DECL_ALIGN (nvtbl) = MAX (TYPE_ALIGN (double_type_node),\n+\t\t\t\t\tDECL_ALIGN (nvtbl));\n+\t      TREE_READONLY (nvtbl) = 0;\n+\t      nvtbl = pushdecl (nvtbl);\n+\t      init = NULL_TREE;\n+\t      finish_decl (nvtbl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+\t      DECL_VIRTUAL_P (nvtbl) = 1;\n+\t      DECL_CONTEXT (nvtbl) = t;\n+\t      init = build (MODIFY_EXPR, TREE_TYPE (nvtbl),\n+\t\t\t    nvtbl, vtbl);\n+\t      TREE_SIDE_EFFECTS (init) = 1;\n+\t      expand_expr_stmt (init);\n+\t      /* Update the vtable pointers as necessary. */\n+\t      ref = build_vfield_ref (build_indirect_ref (addr, NULL_PTR), DECL_CONTEXT (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))));\n+\t      expand_expr_stmt (build_modify_expr (ref, NOP_EXPR,\n+\t\t\t\t\t\t   build_unary_op (ADDR_EXPR, nvtbl, 0)));\n+\t    }\n+\t  assemble_external (vtbl);\n+\t  aref = build_array_ref (vtbl, idx);\n+\t  naref = build_array_ref (nvtbl, idx);\n+\t  old_delta = build_component_ref (aref, delta_identifier, 0, 0);\n+\t  new_delta = build_component_ref (naref, delta_identifier, 0, 0);\n+\t  old_delta = build_binary_op (PLUS_EXPR, old_delta,\n+\t\t\t\t       TREE_VALUE (delta), 0);\n+\t  if (vc)\n+\t    {\n+\t      /* If this is set, we need to add in delta adjustments for\n+\t\t the other virtual base.  */\n+\t      tree vc_delta = purpose_member (vc, *vbase_offsets);\n+\t      if (! vc_delta)\n+\t\t{\n+\t\t  tree vc_addr = convert_pointer_to_real (vc, orig_addr);\n+\t\t  vc_delta = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vc));\n+\t\t  vc_delta = build (MINUS_EXPR, ptrdiff_type_node,\n+\t\t\t\t    vc_addr, vc_delta);\n+\t\t  vc_delta = save_expr (vc_delta);\n+\t\t  *vbase_offsets = tree_cons (vc, vc_delta, *vbase_offsets);\n+\t\t}\n+\t      else\n+\t\tvc_delta = TREE_VALUE (vc_delta);\n+   \n+\t      old_delta = build_binary_op (PLUS_EXPR, old_delta, vc_delta, 0);\n+\t    }\n+\n+\t  TREE_READONLY (new_delta) = 0;\n+\t  expand_expr_stmt (build_modify_expr (new_delta, NOP_EXPR,\n+\t\t\t\t\t       old_delta));\n+\t}\n+      ++n;\n+      virtuals = TREE_CHAIN (virtuals);\n+    }\n+}\n+\n+/* Fixup upcast offsets for all direct vtables.  Patterned after\n+   expand_direct_vtbls_init.  */\n+static void\n+fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, orig_addr, type, vbase, vbase_offsets)\n+     tree real_binfo, binfo, addr, orig_addr, type, vbase, *vbase_offsets;\n+     int init_self, can_elide;\n+{\n+  tree real_binfos = BINFO_BASETYPES (real_binfo);\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int is_not_base_vtable =\n+\ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (real_binfo));\n+      if (! TREE_VIA_VIRTUAL (real_base_binfo))\n+\tfixup_virtual_upcast_offsets (real_base_binfo, base_binfo,\n+\t\t\t\t      is_not_base_vtable, can_elide, addr,\n+\t\t\t\t      orig_addr, type, vbase, vbase_offsets);\n+    }\n+#if 0\n+  /* Before turning this on, make sure it is correct.  */\n+  if (can_elide && ! BINFO_MODIFIED (binfo))\n+    return;\n+#endif\n+  /* Should we use something besides CLASSTYPE_VFIELDS? */\n+  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n+    {\n+      addr = convert_pointer_to_real (binfo, addr);\n+      expand_upcast_fixups (real_binfo, addr, orig_addr, vbase, type, vbase_offsets);\n+    }\n+}\n+\n /* Build a COMPOUND_EXPR which when expanded will generate the code\n    needed to initialize all the virtual function table slots of all\n    the virtual baseclasses.  MAIN_BINFO is the binfo which determines\n@@ -2577,6 +2756,7 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n   tree type = BINFO_TYPE (binfo);\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n+      rtx fixup_insns = NULL_RTX;\n       int old_flag = flag_this_is_variable;\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n       vbase_types = vbases;\n@@ -2587,9 +2767,10 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t{\n \t  /* This is an object of type IN_TYPE,  */\n \t  flag_this_is_variable = -2;\n-\t  dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep);\n \t}\n \n+      dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep);\n+\n       /* Initialized with vtables of type TYPE.  */\n       for (; vbases; vbases = TREE_CHAIN (vbases))\n \t{\n@@ -2627,6 +2808,46 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t     binfos.  (in the CLASSTPE_VFIELD_PARENT sense)  */\n \t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n \t\t\t\t    1, 0, addr);\n+\n+\t  /* If we are using computed offsets we can skip fixups.  */\n+\t  if (use_computed_offsets)\n+\t    continue;\n+\n+\t  /* Now we adjust the offsets for virtual functions that cross\n+\t     virtual boundaries on an implicit upcast on vf call so that\n+\t     the layout of the most complete type is used, instead of\n+\t     assuming the layout of the virtual bases from our current type. */\n+\n+\t  if (flag_vtable_thunks)\n+\t    {\n+\t      /* We don't have dynamic thunks yet!  So for now, just fail silently. */\n+\t    }\n+\t  else\n+\t    {\n+\t      tree vbase_offsets = NULL_TREE;\n+\t      push_to_sequence (fixup_insns);\n+\t      fixup_virtual_upcast_offsets (vbases,\n+\t\t\t\t\t    TYPE_BINFO (BINFO_TYPE (vbases)),\n+\t\t\t\t\t    1, 0, addr, vbase_decl_ptr,\n+\t\t\t\t\t    type, vbases, &vbase_offsets);\n+\t      fixup_insns = get_insns ();\n+\t      end_sequence ();\n+\t    }\n+\t}\n+\n+      if (fixup_insns)\n+\t{\n+\t  extern tree in_charge_identifier;\n+\t  tree in_charge_node = lookup_name (in_charge_identifier, 0);\n+\t  if (! in_charge_node)\n+\t    {\n+\t      warning (\"recoverable internal compiler error, nobody's in charge!\");\n+\t      in_charge_node = integer_zero_node;\n+\t    }\n+\t  in_charge_node = build_binary_op (EQ_EXPR, in_charge_node, integer_zero_node, 1);\n+\t  expand_start_cond (in_charge_node, 0);\n+\t  emit_insns (fixup_insns);\n+\t  expand_end_cond ();\n \t}\n \n       dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep);"}]}