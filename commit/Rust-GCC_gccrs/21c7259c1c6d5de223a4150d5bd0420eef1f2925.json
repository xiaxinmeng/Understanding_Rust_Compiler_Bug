{"sha": "21c7259c1c6d5de223a4150d5bd0420eef1f2925", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFjNzI1OWMxYzZkNWRlMjIzYTQxNTBkNWJkMDQyMGVlZjFmMjkyNQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-18T21:08:40Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-18T21:08:40Z"}, "message": "Enable condegen in case of cond phis.\n\nThe codegen of conditional PHIs inside the scop where one predecessor dominates\nthe other was difficult so it wasn't enabled in the previous patch. After a\ncouple of bug-fixes this has been enabled in this patch.  Not all the cases\ncould be handled in this case because it becomes difficult to map the basic\nblock back to original code in some cases.\n\nBug-fixes:\n1. The vec_find returns -1 when no element was found. This wasn't checked.\n2. When the arguments to pending phis could not be resolved in the second pass,\nthe codegen would fail so the new code should be cleaned up.\n\nThis patch passes regtest and bootstrap on linux-x86-64 with\nBOOT_CFLAGS='-O2 -fgraphite-identity -floop-nest-optimize'\n\n2015-11-14  hiraditya  <hiraditya@msn.com>\n\n\t* graphite-isl-ast-to-gimple.c (copy_loop_phi_args): Change the return\n          type to bool for early exit.\n          (translate_isl_ast_to_gimple::copy_loop_phi_nodes): Early return in\n          case of error.\n          (translate_isl_ast_to_gimple::copy_loop_close_phi_args): Same.\n          (add_phi_arg_for_new_expr): Enable codegen for if-block where one predecessor\n          dominates the other.\n          (translate_isl_ast_to_gimple::copy_cond_phi_args): Fix. When the element is not\n          found it returns -1.\n          (translate_isl_ast_to_gimple::translate_pending_phi_nodes): Bail out early when\n          codegen fails.\n          (graphite_regenerate_ast_isl): Remove codegen region when pending phis\n          could not be generated.\n\nFrom-SVN: r230567", "tree": {"sha": "c8cf60cf92fdccce7c4a2095a5758c691d9acd3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8cf60cf92fdccce7c4a2095a5758c691d9acd3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21c7259c1c6d5de223a4150d5bd0420eef1f2925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c7259c1c6d5de223a4150d5bd0420eef1f2925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c7259c1c6d5de223a4150d5bd0420eef1f2925", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c7259c1c6d5de223a4150d5bd0420eef1f2925/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98"}], "stats": {"total": 184, "additions": 122, "deletions": 62}, "files": [{"sha": "0ea6aa6075721b47e6fe4f8a028d40c9bba4510d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c7259c1c6d5de223a4150d5bd0420eef1f2925/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c7259c1c6d5de223a4150d5bd0420eef1f2925/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21c7259c1c6d5de223a4150d5bd0420eef1f2925", "patch": "@@ -1,3 +1,19 @@\n+2015-11-18  Aditya Kumar  <aditya.k7@samsung.com>\n+\n+\t* graphite-isl-ast-to-gimple.c (copy_loop_phi_args): Change the return\n+\ttype to bool for early exit.\n+\t(translate_isl_ast_to_gimple::copy_loop_phi_nodes): Early return\n+\tin case of error.\n+\t(translate_isl_ast_to_gimple::copy_loop_close_phi_args): Same.\n+\t(add_phi_arg_for_new_expr): Enable codegen for if-block where one\n+\tpredecessor dominates the other.\n+\t(translate_isl_ast_to_gimple::copy_cond_phi_args): Fix. When the\n+\telement is not found it returns -1.\n+\t(translate_isl_ast_to_gimple::translate_pending_phi_nodes): Bail\n+\tout early when codegen fails.\n+\t(graphite_regenerate_ast_isl): Remove codegen region when pending\n+\tphis could not be generated.\n+\n 2015-11-18  Aditya Kumar  <aditya.k7@samsung.com>\n \n \t* graphite-isl-ast-to-gimple.c (struct ast_build_info): Remove semicolon."}, {"sha": "3e0907de30d018cd612b50723c5e216b8595bc09", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 106, "deletions": 62, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c7259c1c6d5de223a4150d5bd0420eef1f2925/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c7259c1c6d5de223a4150d5bd0420eef1f2925/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=21c7259c1c6d5de223a4150d5bd0420eef1f2925", "patch": "@@ -352,7 +352,7 @@ class translate_isl_ast_to_gimple\n   /* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to\n      NEW_PHI must be found unless they can be POSTPONEd for later.  */\n \n-  void copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n+  bool copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n \t\t\t   gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n \t\t\t   bool postpone);\n \n@@ -1928,7 +1928,7 @@ get_edges (basic_block bb)\n /* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to NEW_PHI\n    must be found unless they can be POSTPONEd for later.  */\n \n-void\n+bool\n translate_isl_ast_to_gimple::\n copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n \t\t    gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n@@ -1969,8 +1969,9 @@ copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n \t}\n       else\n \t/* Either we should add the arg to phi or, we should postpone.  */\n-\tgcc_unreachable ();\n+\treturn false;\n     }\n+  return true;\n }\n \n /* Copy loop phi nodes from BB to NEW_BB.  */\n@@ -2006,7 +2007,8 @@ translate_isl_ast_to_gimple::copy_loop_phi_nodes (basic_block bb,\n       tree new_res = create_new_def_for (res, new_phi,\n \t\t\t\t\t gimple_phi_result_ptr (new_phi));\n       set_rename (res, new_res);\n-      copy_loop_phi_args (phi, ibp_old_bb, new_phi, ibp_new_bb, true);\n+      codegen_error = !copy_loop_phi_args (phi, ibp_old_bb, new_phi,\n+\t\t\t\t\t  ibp_new_bb, true);\n       update_stmt (new_phi);\n     }\n \n@@ -2126,7 +2128,9 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n       /* A close phi must come from a loop-phi having an init value.  */\n       if (!init)\n \t{\n-\t  gcc_assert (postpone);\n+\t  if (!postpone)\n+\t    return false;\n+\n \t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n \t  if (dump_file)\n \t    {\n@@ -2199,7 +2203,7 @@ add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n \t\t\t  gphi *phi, gphi *new_phi,\n \t\t\t  basic_block new_bb)\n {\n-  basic_block def_pred[2];\n+  basic_block def_pred[2] = { NULL, NULL };\n   int not_found_bb_index = -1;\n   for (int i = 0; i < 2; i++)\n     {\n@@ -2208,44 +2212,69 @@ add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n       if (TREE_CODE (old_phi_args[i]) == INTEGER_CST)\n \tdef_pred[i] = get_def_bb_for_const (new_bb,\n \t\t\t\t\t    gimple_phi_arg_edge (phi, i)->src);\n-      else\n+      else if (new_phi_args[i] && (TREE_CODE (new_phi_args[i]) == SSA_NAME))\n \tdef_pred[i] = gimple_bb (SSA_NAME_DEF_STMT (new_phi_args[i]));\n+\n       if (!def_pred[i])\n \t{\n-\t  gcc_assert (not_found_bb_index == -1);\n+\t  /* When non are available bail out.  */\n+\t  if (not_found_bb_index != -1)\n+\t    return false;\n \t  not_found_bb_index = i;\n \t}\n     }\n \n   /* Here we are pattern matching on the structure of CFG w.r.t. old one.  */\n   if (old_bb_dominating_edge)\n     {\n-      return false;\n+      if (not_found_bb_index != -1)\n+\treturn false;\n+\n       basic_block new_pred1 = (*new_bb->preds)[0]->src;\n       basic_block new_pred2 = (*new_bb->preds)[1]->src;\n       vec <basic_block> *bbs\n \t= region->copied_bb_map->get (old_bb_non_dominating_edge->src);\n-      gcc_assert (bbs);\n+\n+      /* Could not find a mapping.  */\n+      if (!bbs)\n+\treturn false;\n+\n       basic_block new_pred = NULL;\n       basic_block b;\n       int i;\n       FOR_EACH_VEC_ELT (*bbs, i, b)\n-\tif (new_pred1 == b || new_pred2 == b)\n-\t  {\n-\t    gcc_assert (!new_pred);\n-\t    new_pred = b;\n-\t  }\n+\t{\n+\t  if (dominated_by_p (CDI_DOMINATORS, new_pred1, b))\n+\t    {\n+\t      /* FIXME: If we have already found new_pred then we have to\n+\t\t disambiguate, bail out for now.  */\n+\t      if (new_pred)\n+\t\treturn false;\n+\t      new_pred = new_pred1;\n+\t    }\n+\t  if (dominated_by_p (CDI_DOMINATORS, new_pred2, b))\n+\t    {\n+\t      /* FIXME: If we have already found new_pred then we have to either\n+\t\t it dominates both or we have to disambiguate, bail out.  */\n+\t      if (new_pred)\n+\t\treturn false;\n+\t      new_pred = new_pred2;\n+\t    }\n+\t}\n \n-      gcc_assert (new_pred);\n+      if (!new_pred)\n+\treturn false;\n \n       edge new_non_dominating_edge = find_edge (new_pred, new_bb);\n+      gcc_assert (new_non_dominating_edge);\n+      /* FIXME: Validate each args just like in loop-phis.  */\n       /* By the process of elimination we first insert insert phi-edge for\n \t non-dominating pred which is computed above and then we insert the\n \t remaining one.  */\n       int inserted_edge = 0;\n       for (; inserted_edge < 2; inserted_edge++)\n \t{\n-\t  edge new_bb_pred_edge = gimple_phi_arg_edge (phi, inserted_edge);\n+\t  edge new_bb_pred_edge = gimple_phi_arg_edge (new_phi, inserted_edge);\n \t  if (new_non_dominating_edge == new_bb_pred_edge)\n \t    {\n \t      add_phi_arg (new_phi, new_phi_args[inserted_edge],\n@@ -2254,21 +2283,25 @@ add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n \t      break;\n \t    }\n \t}\n+      if (inserted_edge == 2)\n+\treturn false;\n \n-      int edge_dominating = 0;\n-      if (inserted_edge == 0)\n-\tedge_dominating = 1;\n+      int edge_dominating = inserted_edge == 0 ? 1 : 0;\n \n       edge new_dominating_edge = NULL;\n-      for (int i; i < 2; i++)\n+      for (inserted_edge = 0; inserted_edge < 2; inserted_edge++)\n \t{\n-\t  edge e = gimple_phi_arg_edge (new_phi, i);\n+\t  edge e = gimple_phi_arg_edge (new_phi, inserted_edge);\n \t  if (e != new_non_dominating_edge)\n-\t    new_dominating_edge = e;\n+\t    {\n+\t      new_dominating_edge = e;\n+\t      add_phi_arg (new_phi, new_phi_args[edge_dominating],\n+\t\t\t   new_dominating_edge,\n+\t\t\t   get_loc (old_phi_args[inserted_edge]));\n+\t      break;\n+\t    }\n \t}\n-\n-      add_phi_arg (new_phi, new_phi_args[edge_dominating], new_dominating_edge,\n-\t\t   get_loc (old_phi_args[inserted_edge]));\n+      gcc_assert (new_dominating_edge);\n     }\n   else\n     {\n@@ -2366,47 +2399,48 @@ translate_isl_ast_to_gimple::copy_cond_phi_args (gphi *phi, gphi *new_phi,\n \t}\n \n       /* If the phi-arg was a parameter.  */\n-      if (vec_find (region->params, old_name))\n+      if (vec_find (region->params, old_name) != -1)\n \t{\n \t  new_phi_args [i] = old_name;\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file,\n \t\t       \"\\n[codegen] parameter argument to phi, new_expr: \");\n-\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t      print_generic_expr (dump_file, new_phi_args[i], 0);\n \t    }\n \t  continue;\n \t}\n \n-      /* If the phi-arg is scev-analyzeable but only in the first stage.  */\n-      if (postpone && is_gimple_reg (old_name)\n-\t  && scev_analyzable_p (old_name, region->region))\n-\t{\n-\t  gimple_seq stmts;\n-\t  tree new_expr = get_rename_from_scev (old_name, &stmts, loop, new_bb,\n-\t\t\t\t\t\told_bb, iv_map);\n-\t  if (codegen_error_p ())\n-\t    return false;\n+      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n+      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n+\t/* FIXME: If the phi arg was a function arg, or wasn't defined, just use\n+\t   the old name.  */\n+\treturn false;\n \n-\t  gcc_assert (new_expr);\n-\t  if (dump_file)\n+      if (postpone)\n+\t{\n+\t  /* If the phi-arg is scev-analyzeable but only in the first stage.  */\n+\t  if (is_gimple_reg (old_name)\n+\t      && scev_analyzable_p (old_name, region->region))\n \t    {\n-\t      fprintf (dump_file, \"\\n[codegen] scev analyzeable, new_expr: \");\n-\t      print_generic_expr (dump_file, new_expr, 0);\n+\t      gimple_seq stmts;\n+\t      tree new_expr = get_rename_from_scev (old_name, &stmts, loop,\n+\t\t\t\t\t\t    new_bb, old_bb, iv_map);\n+\t      if (codegen_error_p ())\n+\t\treturn false;\n+\n+\t      gcc_assert (new_expr);\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"\\n[codegen] scev analyzeable, new_expr: \");\n+\t\t  print_generic_expr (dump_file, new_expr, 0);\n+\t\t}\n+\t      gsi_insert_earliest (stmts);\n+\t      new_phi_args [i] = new_name;\n+\t      continue;\n \t    }\n-\t  gsi_insert_earliest (stmts);\n-\t  new_phi_args [i] = new_name;\n-\t  continue;\n-\t}\n \n-      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n-      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n-\t/* If the phi arg was a function arg, or wasn't defined, just use the\n-\t   old name.  */\n-\tgcc_unreachable ();\n-      //add_phi_arg (new_phi, old_name, new_e, get_loc (old_name));\n-      else if (postpone)\n-\t{\n \t  /* Postpone code gen for later for back-edges.  */\n \t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n \n@@ -2420,9 +2454,15 @@ translate_isl_ast_to_gimple::copy_cond_phi_args (gphi *phi, gphi *new_phi,\n \t  continue;\n \t}\n       else\n-\tgcc_unreachable ();\n+\t/* Either we should add the arg to phi or, we should postpone.  */\n+\treturn false;\n     }\n \n+  /* If none of the args have been determined in the first stage then wait until\n+     later.  */\n+  if (postpone && !new_phi_args[0] && !new_phi_args[1])\n+    return true;\n+\n   return add_phi_arg_for_new_expr (old_phi_args, new_phi_args,\n \t\t\t\t   old_bb_dominating_edge,\n \t\t\t\t   old_bb_non_dominating_edge,\n@@ -2721,12 +2761,12 @@ translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n \n       auto_vec <tree, 1> iv_map;\n       if (bb_contains_loop_phi_nodes (new_bb))\n-\tcopy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n-\t\t\t    ibp_new_bb, false);\n+\tcodegen_error = !copy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n+\t\t\t\t\t    ibp_new_bb, false);\n       else if (bb_contains_loop_close_phi_nodes (new_bb))\n-\tcopy_loop_close_phi_args (old_bb, new_bb, false);\n-      else if (!copy_cond_phi_args (old_phi, new_phi, iv_map, false))\n-\tgcc_unreachable ();\n+\tcodegen_error = !copy_loop_close_phi_args (old_bb, new_bb, false);\n+      else\n+\tcodegen_error = !copy_cond_phi_args (old_phi, new_phi, iv_map, false);\n \n       if (dump_file)\n \t{\n@@ -2986,9 +3026,13 @@ graphite_regenerate_ast_isl (scop_p scop)\n \t  recompute_all_dominators ();\n \t  graphite_verify ();\n \t}\n-      else if (dump_file)\n-\tfprintf (dump_file, \"\\n[codegen] unsuccessful in translating\"\n-\t\t \" pending phis, reverting back to the original code.\");\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"\\n[codegen] unsuccessful in translating\"\n+\t\t     \" pending phis, reverting back to the original code.\");\n+\t  set_ifsese_condition (if_region, integer_zero_node);\n+\t}\n     }\n \n   free (if_region->true_region);"}]}