{"sha": "ae46a07ab21e91142e17d990a0a21fbd65087ae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU0NmEwN2FiMjFlOTExNDJlMTdkOTkwYTBhMjFmYmQ2NTA4N2FlNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-14T17:46:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-14T17:46:08Z"}, "message": "i386.c (ix86_expand_sse_cmp): Split out from ...\n\n        * config/i386/i386.c (ix86_expand_sse_cmp): Split out from ...\n        (ix86_expand_sse_movcc): ... here.  Take cmp as a pre-computed\n        register.\n        (ix86_expand_fp_movcc): Update to match.\n        (ix86_expand_fp_vcond, ix86_expand_int_vcond): New.\n        * config/i386/i386-protos.h: Update.\n        * config/i386/sse.md (vcondv4sf, vcondv2df): New.\n        (vcond<SSEMODE124>, vcondu<SSEMODE12>): New.\n\n        * lib/target-supports.exp (check_effective_target_vect_condition):\n        Add ia64, i?86, and x86_64.\n\nFrom-SVN: r98146", "tree": {"sha": "a6d275bbd5eaa29b0d58b9391c0d8b5f6b5c84f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6d275bbd5eaa29b0d58b9391c0d8b5f6b5c84f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae46a07ab21e91142e17d990a0a21fbd65087ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae46a07ab21e91142e17d990a0a21fbd65087ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae46a07ab21e91142e17d990a0a21fbd65087ae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae46a07ab21e91142e17d990a0a21fbd65087ae5/comments", "author": null, "committer": null, "parents": [{"sha": "25f710babd7b217d9dccbdc3d46fd3d9e1c96a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f710babd7b217d9dccbdc3d46fd3d9e1c96a92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f710babd7b217d9dccbdc3d46fd3d9e1c96a92"}], "stats": {"total": 249, "additions": 233, "deletions": 16}, "files": [{"sha": "ba76cb6a52b282bdc58912563f1ede4a4d71342a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae46a07ab21e91142e17d990a0a21fbd65087ae5", "patch": "@@ -1,3 +1,14 @@\n+2005-04-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_expand_sse_cmp): Split out from ...\n+\t(ix86_expand_sse_movcc): ... here.  Take cmp as a pre-computed\n+\tregister.\n+\t(ix86_expand_fp_movcc): Update to match.\n+\t(ix86_expand_fp_vcond, ix86_expand_int_vcond): New.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/sse.md (vcondv4sf, vcondv2df): New.\n+\t(vcond<SSEMODE124>, vcondu<SSEMODE12>): New.\n+\n 2005-04-14  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* doc/cpp.texi, doc/install.texi: Change references to GCC 3.5 to"}, {"sha": "48340719c40e4a8a36d2997af09b61a36fa5fc0c", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ae46a07ab21e91142e17d990a0a21fbd65087ae5", "patch": "@@ -150,6 +150,8 @@ extern void ix86_expand_branch (enum rtx_code, rtx);\n extern int ix86_expand_setcc (enum rtx_code, rtx);\n extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n+extern bool ix86_expand_fp_vcond (rtx[]);\n+extern bool ix86_expand_int_vcond (rtx[], bool);\n extern int ix86_expand_int_addcc (rtx[]);\n extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "2c680756723dc5703af25f2eb2ea3082e5df5eee", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 147, "deletions": 15, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ae46a07ab21e91142e17d990a0a21fbd65087ae5", "patch": "@@ -10141,12 +10141,14 @@ ix86_expand_sse_fp_minmax (rtx dest, enum rtx_code code, rtx cmp_op0,\n   return true;\n }\n \n-static void\n-ix86_expand_sse_movcc (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n-\t\t       rtx op_true, rtx op_false)\n+/* Expand an sse vector comparison.  Return the register with the result.  */\n+\n+static rtx\n+ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n+\t\t     rtx op_true, rtx op_false)\n {\n   enum machine_mode mode = GET_MODE (dest);\n-  rtx t1, t2, t3, x;\n+  rtx x;\n \n   cmp_op0 = force_reg (mode, cmp_op0);\n   if (!nonimmediate_operand (cmp_op1, mode))\n@@ -10155,24 +10157,33 @@ ix86_expand_sse_movcc (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n   if (optimize\n       || reg_overlap_mentioned_p (dest, op_true)\n       || reg_overlap_mentioned_p (dest, op_false))\n-    t1 = gen_reg_rtx (mode);\n-  else\n-    t1 = dest;\n+    dest = gen_reg_rtx (mode);\n \n   x = gen_rtx_fmt_ee (code, mode, cmp_op0, cmp_op1);\n-  gcc_assert (sse_comparison_operator (x, VOIDmode));\n-  emit_insn (gen_rtx_SET (VOIDmode, t1, x));\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+\n+  return dest;\n+}\n+\n+/* Expand DEST = CMP ? OP_TRUE : OP_FALSE into a sequence of logical\n+   operations.  This is used for both scalar and vector conditional moves.  */\n+\n+static void\n+ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n+{\n+  enum machine_mode mode = GET_MODE (dest);\n+  rtx t2, t3, x;\n \n   if (op_false == CONST0_RTX (mode))\n     {\n       op_true = force_reg (mode, op_true);\n-      x = gen_rtx_AND (mode, t1, op_true);\n+      x = gen_rtx_AND (mode, cmp, op_true);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n     }\n   else if (op_true == CONST0_RTX (mode))\n     {\n       op_false = force_reg (mode, op_false);\n-      x = gen_rtx_NOT (mode, t1);\n+      x = gen_rtx_NOT (mode, cmp);\n       x = gen_rtx_AND (mode, x, op_false);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n     }\n@@ -10187,10 +10198,10 @@ ix86_expand_sse_movcc (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n       else\n \tt3 = dest;\n \n-      x = gen_rtx_AND (mode, op_true, t1);\n+      x = gen_rtx_AND (mode, op_true, cmp);\n       emit_insn (gen_rtx_SET (VOIDmode, t2, x));\n \n-      x = gen_rtx_NOT (mode, t1);\n+      x = gen_rtx_NOT (mode, cmp);\n       x = gen_rtx_AND (mode, x, op_false);\n       emit_insn (gen_rtx_SET (VOIDmode, t3, x));\n \n@@ -10199,6 +10210,8 @@ ix86_expand_sse_movcc (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n     }\n }\n \n+/* Expand a floating-point conditional move.  Return true if successful.  */\n+\n int\n ix86_expand_fp_movcc (rtx operands[])\n {\n@@ -10230,8 +10243,9 @@ ix86_expand_fp_movcc (rtx operands[])\n \t\t\t\t     operands[3]))\n \treturn 1;\n \n-      ix86_expand_sse_movcc (operands[0], code, ix86_compare_op0,\n-\t\t\t     ix86_compare_op1, operands[2], operands[3]);\n+      tmp = ix86_expand_sse_cmp (operands[0], code, ix86_compare_op0,\n+\t\t\t\t ix86_compare_op1, operands[2], operands[3]);\n+      ix86_expand_sse_movcc (operands[0], tmp, operands[2], operands[3]);\n       return 1;\n     }\n \n@@ -10282,6 +10296,124 @@ ix86_expand_fp_movcc (rtx operands[])\n   return 1;\n }\n \n+/* Expand a floating-point vector conditional move; a vcond operation\n+   rather than a movcc operation.  */\n+\n+bool\n+ix86_expand_fp_vcond (rtx operands[])\n+{\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  rtx cmp;\n+\n+  code = ix86_prepare_sse_fp_compare_args (operands[0], code,\n+\t\t\t\t\t   &operands[4], &operands[5]);\n+  if (code == UNKNOWN)\n+    return false;\n+\n+  if (ix86_expand_sse_fp_minmax (operands[0], code, operands[4],\n+\t\t\t\t operands[5], operands[1], operands[2]))\n+    return true;\n+\n+  cmp = ix86_expand_sse_cmp (operands[0], code, operands[4], operands[5],\n+\t\t\t     operands[1], operands[2]);\n+  ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n+  return true;\n+}\n+\n+/* Expand a signed integral vector conditional move.  */\n+\n+bool\n+ix86_expand_int_vcond (rtx operands[], bool unsignedp)\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  rtx cmp, x;\n+\n+  if (unsignedp)\n+    code = signed_condition (code);\n+  if (code == NE || code == LE || code == GE)\n+    {\n+      /* Inverse of a supported code.  */\n+      x = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = x;\n+      code = reverse_condition (code);\n+    }\n+  if (code == LT)\n+    {\n+      /* Swap of a supported code.  */\n+      x = operands[4];\n+      operands[4] = operands[5];\n+      operands[5] = x;\n+      code = swap_condition (code);\n+    }\n+  gcc_assert (code == EQ || code == GT);\n+\n+  /* Unlike floating-point, we can rely on the optimizers to have already\n+     converted to MIN/MAX expressions, so we don't have to handle that.  */\n+\n+  /* Unsigned GT is not directly supported.  We can zero-extend QI and\n+     HImode elements to the next wider element size, use a signed compare,\n+     then repack.  For three extra instructions, this is definitely a win.  */\n+  if (code == GT && unsignedp)\n+    {\n+      rtx o0l, o0h, o1l, o1h, cl, ch, zero;\n+      enum machine_mode wider;\n+      rtx (*unpackl) (rtx, rtx, rtx);\n+      rtx (*unpackh) (rtx, rtx, rtx);\n+      rtx (*pack) (rtx, rtx, rtx);\n+\n+      switch (mode)\n+\t{\n+\tcase V16QImode:\n+\t  wider = V8HImode;\n+\t  unpackl = gen_sse2_punpcklbw;\n+\t  unpackh = gen_sse2_punpckhbw;\n+\t  pack = gen_sse2_packsswb;\n+\t  break;\n+\tcase V8HImode:\n+\t  wider = V4SImode;\n+\t  unpackl = gen_sse2_punpcklwd;\n+\t  unpackh = gen_sse2_punpckhwd;\n+\t  pack = gen_sse2_packssdw;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      operands[4] = force_reg (mode, operands[4]);\n+      operands[5] = force_reg (mode, operands[5]);\n+\n+      o0l = gen_reg_rtx (wider);\n+      o0h = gen_reg_rtx (wider);\n+      o1l = gen_reg_rtx (wider);\n+      o1h = gen_reg_rtx (wider);\n+      cl = gen_reg_rtx (wider);\n+      ch = gen_reg_rtx (wider);\n+      cmp = gen_reg_rtx (mode);\n+      zero = force_reg (mode, CONST0_RTX (mode));\n+\n+      emit_insn (unpackl (gen_lowpart (mode, o0l), operands[4], zero));\n+      emit_insn (unpackh (gen_lowpart (mode, o0h), operands[4], zero));\n+      emit_insn (unpackl (gen_lowpart (mode, o1l), operands[5], zero));\n+      emit_insn (unpackh (gen_lowpart (mode, o1h), operands[5], zero));\n+\n+      x = gen_rtx_GT (wider, o0l, o1l);\n+      emit_insn (gen_rtx_SET (VOIDmode, cl, x));\n+\n+      x = gen_rtx_GT (wider, o0h, o1h);\n+      emit_insn (gen_rtx_SET (VOIDmode, ch, x));\n+\n+      emit_insn (pack (cmp, cl, ch));\n+    }\n+  else\n+    cmp = ix86_expand_sse_cmp (operands[0], code, operands[4], operands[5],\n+\t\t\t       operands[1], operands[2]);\n+\n+  ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n+  return true;\n+}\n+\n /* Expand conditional increment or decrement using adb/sbb instructions.\n    The default case using setcc followed by the conditional move can be\n    done by generic code.  */"}, {"sha": "0f6c7eac97c2b3a6476ea899b55655f85b49a2e6", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ae46a07ab21e91142e17d990a0a21fbd65087ae5", "patch": "@@ -710,6 +710,22 @@\n   [(set_attr \"type\" \"ssecomi\")\n    (set_attr \"mode\" \"SF\")])\n \n+(define_expand \"vcondv4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (if_then_else:V4SF\n+          (match_operator 3 \"\"\n+            [(match_operand:V4SF 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:V4SF 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:V4SF 1 \"general_operand\" \"\")\n+          (match_operand:V4SF 2 \"general_operand\" \"\")))]\n+  \"TARGET_SSE\"\n+{\n+  if (ix86_expand_fp_vcond (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel single-precision floating point logical operations\n@@ -1648,6 +1664,22 @@\n   [(set_attr \"type\" \"ssecomi\")\n    (set_attr \"mode\" \"DF\")])\n \n+(define_expand \"vcondv2df\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+        (if_then_else:V2DF\n+          (match_operator 3 \"\"\n+            [(match_operand:V2DF 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:V2DF 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:V2DF 1 \"general_operand\" \"\")\n+          (match_operand:V2DF 2 \"general_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  if (ix86_expand_fp_vcond (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point logical operations\n@@ -2602,6 +2634,38 @@\n   [(set_attr \"type\" \"ssecmp\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_expand \"vcond<mode>\"\n+  [(set (match_operand:SSEMODE124 0 \"register_operand\" \"\")\n+        (if_then_else:SSEMODE124\n+          (match_operator 3 \"\"\n+            [(match_operand:SSEMODE124 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:SSEMODE124 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:SSEMODE124 1 \"general_operand\" \"\")\n+          (match_operand:SSEMODE124 2 \"general_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  if (ix86_expand_int_vcond (operands, false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"vcondu<mode>\"\n+  [(set (match_operand:SSEMODE12 0 \"register_operand\" \"\")\n+        (if_then_else:SSEMODE12\n+          (match_operator 3 \"\"\n+            [(match_operand:SSEMODE12 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:SSEMODE12 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:SSEMODE12 1 \"general_operand\" \"\")\n+          (match_operand:SSEMODE12 2 \"general_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  if (ix86_expand_int_vcond (operands, true))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel integral logical operations"}, {"sha": "cb73cde91c54bc547660fa85d1f5c933e2b85e45", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ae46a07ab21e91142e17d990a0a21fbd65087ae5", "patch": "@@ -1,3 +1,8 @@\n+2005-04-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_condition):\n+\tAdd ia64, i?86, and x86_64.\n+\n 2005-04-14  Steven G. Kargl  <kargls@comcast.net>\n \n \t* gfortran.dg/underflow.f90: Use tiny(x)/huge(x)."}, {"sha": "784c43582218acee560e3064420ddfd37ba02241", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae46a07ab21e91142e17d990a0a21fbd65087ae5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=ae46a07ab21e91142e17d990a0a21fbd65087ae5", "patch": "@@ -844,7 +844,10 @@ proc check_effective_target_vect_condition { } {\n \tverbose \"check_effective_target_vect_cond: using cached result\" 2\n     } else {\n \tset et_vect_cond_saved 0\n-\tif { [istarget powerpc*-*-*] } {\n+\tif { [istarget powerpc*-*-*]\n+\t     || [istarget ia64-*-*]\n+\t     || [istarget i?86-*-*]\n+\t     || [istarget x86_64-*-*] } {\n \t   set et_vect_cond_saved 1\n \t}\n     }"}]}