{"sha": "ff284b4bbe69a4d7675c1519bb304c3ed819f796", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyODRiNGJiZTY5YTRkNzY3NWMxNTE5YmIzMDRjM2VkODE5Zjc5Ng==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2009-03-17T20:49:23Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-03-17T20:49:23Z"}, "message": "re PR c++/39475 (c++0x type-traits should error out in case of incompleteness)\n\n/cp\n2009-03-17  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/39475\n\t* semantics.c (check_trait_type): New.\n\t(finish_trait_expr): Use it.\n\n/testsuite\n2009-03-17  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/39475\n\t* g++.dg/ext/unary_trait_incomplete.C: New.\n\nFrom-SVN: r144919", "tree": {"sha": "530b60fa39eabec19f05295b7fc6ca70fc1ed1f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/530b60fa39eabec19f05295b7fc6ca70fc1ed1f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff284b4bbe69a4d7675c1519bb304c3ed819f796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff284b4bbe69a4d7675c1519bb304c3ed819f796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff284b4bbe69a4d7675c1519bb304c3ed819f796", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff284b4bbe69a4d7675c1519bb304c3ed819f796/comments", "author": null, "committer": null, "parents": [{"sha": "3c072c6ba27f5f8c18688bd3816523ee8b2e7e16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c072c6ba27f5f8c18688bd3816523ee8b2e7e16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c072c6ba27f5f8c18688bd3816523ee8b2e7e16"}], "stats": {"total": 150, "additions": 143, "deletions": 7}, "files": [{"sha": "172d121681b50539258e00677d9e071176b193d7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ff284b4bbe69a4d7675c1519bb304c3ed819f796", "patch": "@@ -1,3 +1,9 @@\n+2009-03-17  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/39475\n+\t* semantics.c (check_trait_type): New.\n+\t(finish_trait_expr): Use it.\n+\n 2009-03-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* name-lookup.c (cp_emit_debug_info_for_using): Emit USING_STMTs"}, {"sha": "82a67971047532a8e490ff544ea3d335a41146a5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ff284b4bbe69a4d7675c1519bb304c3ed819f796", "patch": "@@ -4902,6 +4902,24 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     }\n }\n \n+/* Returns true if TYPE is a complete type, an array of unknown bound,\n+   or (possibly cv-qualified) void, returns false otherwise.  */\n+\n+static bool\n+check_trait_type (tree type)\n+{\n+  if (COMPLETE_TYPE_P (type))\n+    return true;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n+    return true;\n+\n+  if (VOID_TYPE_P (type))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Process a trait expression.  */\n \n tree\n@@ -4950,14 +4968,45 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n   if (type2)\n     complete_type (type2);\n \n-  /* The only required diagnostic.  */\n-  if (kind == CPTK_IS_BASE_OF\n-      && NON_UNION_CLASS_TYPE_P (type1) && NON_UNION_CLASS_TYPE_P (type2)\n-      && !same_type_ignoring_top_level_qualifiers_p (type1, type2)\n-      && !COMPLETE_TYPE_P (type2))\n+  switch (kind)\n     {\n-      error (\"incomplete type %qT not allowed\", type2);\n-      return error_mark_node;\n+    case CPTK_HAS_NOTHROW_ASSIGN:\n+    case CPTK_HAS_TRIVIAL_ASSIGN:\n+    case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n+    case CPTK_HAS_TRIVIAL_CONSTRUCTOR:\n+    case CPTK_HAS_NOTHROW_COPY:\n+    case CPTK_HAS_TRIVIAL_COPY:\n+    case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n+    case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n+    case CPTK_IS_ABSTRACT:\n+    case CPTK_IS_EMPTY:\n+    case CPTK_IS_POD:\n+    case CPTK_IS_POLYMORPHIC:\n+      if (!check_trait_type (type1))\n+\t{\n+\t  error (\"incomplete type %qT not allowed\", type1);\n+\t  return error_mark_node;\n+\t}\n+      break;\n+\n+    case CPTK_IS_BASE_OF:\n+      if (NON_UNION_CLASS_TYPE_P (type1) && NON_UNION_CLASS_TYPE_P (type2)\n+\t  && !same_type_ignoring_top_level_qualifiers_p (type1, type2)\n+\t  && !COMPLETE_TYPE_P (type2))\n+\t{\n+\t  error (\"incomplete type %qT not allowed\", type2);\n+\t  return error_mark_node;\n+\t}\n+      break;\n+\n+    case CPTK_IS_CLASS:\n+    case CPTK_IS_ENUM:\n+    case CPTK_IS_UNION:\n+      break;\n+    \n+    case CPTK_IS_CONVERTIBLE_TO:\n+    default:\n+      gcc_unreachable ();\n     }\n \n   return (trait_expr_value (kind, type1, type2)"}, {"sha": "235259478cb9e7413ec27febd5f8542081e6750e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff284b4bbe69a4d7675c1519bb304c3ed819f796", "patch": "@@ -1,3 +1,8 @@\n+2009-03-17  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/39475\n+\t* g++.dg/ext/unary_trait_incomplete.C: New.\n+\n 2009-03-17  Jing Yu  <jingyu@google.com>\n \n \tPR middle-end/39378"}, {"sha": "d5148bebbc6ed422dcf79fb0647c2dee69b48d11", "filename": "gcc/testsuite/g++.dg/ext/unary_trait_incomplete.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funary_trait_incomplete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff284b4bbe69a4d7675c1519bb304c3ed819f796/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funary_trait_incomplete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funary_trait_incomplete.C?ref=ff284b4bbe69a4d7675c1519bb304c3ed819f796", "patch": "@@ -0,0 +1,76 @@\n+// PR c++/39475\n+\n+struct I;\n+struct C { };\n+\n+bool nas1 = __has_nothrow_assign(I); // { dg-error \"incomplete type\" }\n+bool nas2 = __has_nothrow_assign(C[]);\n+bool nas3 = __has_nothrow_assign(I[]);\n+bool nas4 = __has_nothrow_assign(void);\n+bool nas5 = __has_nothrow_assign(const void);\n+\n+bool tas1 = __has_trivial_assign(I); // { dg-error \"incomplete type\" }\n+bool tas2 = __has_trivial_assign(C[]);\n+bool tas3 = __has_trivial_assign(I[]);\n+bool tas4 = __has_trivial_assign(void);\n+bool tas5 = __has_trivial_assign(const void);\n+\n+bool nco1 = __has_nothrow_constructor(I); // { dg-error \"incomplete type\" }\n+bool nco2 = __has_nothrow_constructor(C[]);\n+bool nco3 = __has_nothrow_constructor(I[]);\n+bool nco4 = __has_nothrow_constructor(void);\n+bool nco5 = __has_nothrow_constructor(const void);\n+\n+bool tco1 = __has_trivial_constructor(I); // { dg-error \"incomplete type\" }\n+bool tco2 = __has_trivial_constructor(C[]);\n+bool tco3 = __has_trivial_constructor(I[]);\n+bool tco4 = __has_trivial_constructor(void);\n+bool tco5 = __has_trivial_constructor(const void);\n+\n+bool ncp1 = __has_nothrow_copy(I); // { dg-error \"incomplete type\" }\n+bool ncp2 = __has_nothrow_copy(C[]);\n+bool ncp3 = __has_nothrow_copy(I[]);\n+bool ncp4 = __has_nothrow_copy(void);\n+bool ncp5 = __has_nothrow_copy(const void);\n+\n+bool tcp1 = __has_trivial_copy(I); // { dg-error \"incomplete type\" }\n+bool tcp2 = __has_trivial_copy(C[]);\n+bool tcp3 = __has_trivial_copy(I[]);\n+bool tcp4 = __has_trivial_copy(void);\n+bool tcp5 = __has_trivial_copy(const void);\n+\n+bool vde1 = __has_virtual_destructor(I); // { dg-error \"incomplete type\" }\n+bool vde2 = __has_virtual_destructor(C[]);\n+bool vde3 = __has_virtual_destructor(I[]);\n+bool vde4 = __has_virtual_destructor(void);\n+bool vde5 = __has_virtual_destructor(const void);\n+\n+bool tde1 = __has_trivial_destructor(I); // { dg-error \"incomplete type\" }\n+bool tde2 = __has_trivial_destructor(C[]);\n+bool tde3 = __has_trivial_destructor(I[]);\n+bool tde4 = __has_trivial_destructor(void);\n+bool tde5 = __has_trivial_destructor(const void);\n+\n+bool abs1 = __is_abstract(I); // { dg-error \"incomplete type\" }\n+bool abs2 = __is_abstract(C[]);\n+bool abs3 = __is_abstract(I[]);\n+bool abs4 = __is_abstract(void);\n+bool abs5 = __is_abstract(const void);\n+\n+bool pod1 = __is_pod(I); // { dg-error \"incomplete type\" }\n+bool pod2 = __is_pod(C[]);\n+bool pod3 = __is_pod(I[]);\n+bool pod4 = __is_pod(void);\n+bool pod5 = __is_pod(const void);\n+\n+bool emp1 = __is_empty(I); // { dg-error \"incomplete type\" }\n+bool emp2 = __is_empty(C[]);\n+bool emp3 = __is_empty(I[]);\n+bool emp4 = __is_empty(void);\n+bool emp5 = __is_empty(const void);\n+\n+bool pol1 = __is_polymorphic(I); // { dg-error \"incomplete type\" }\n+bool pol2 = __is_polymorphic(C[]);\n+bool pol3 = __is_polymorphic(I[]);\n+bool pol4 = __is_polymorphic(void);\n+bool pol5 = __is_polymorphic(const void);"}]}