{"sha": "6303331c3330222fef94eff8d8d35c99ca1d3e88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwMzMzMWMzMzMwMjIyZmVmOTRlZmY4ZDhkMzVjOTljYTFkM2U4OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-31T21:18:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-31T21:18:39Z"}, "message": "compiler: optimize append of make\n    \n    The gc compiler recognizes append(s, make([]T, n)...), and\n    generates code to directly zero the tail instead of allocating a\n    new slice and copying. This CL lets the Go frontend do basically\n    the same.\n    \n    The difficulty is that at the point we handle append, there may\n    already be temporaries introduced (e.g. in order_evaluations),\n    which makes it hard to find the append-of-make pattern. The\n    compiler could \"see through\" the value of a temporary, but it is\n    only safe to do if the temporary is not assigned multiple times.\n    For this, we add tracking of assignments and uses for temporaries.\n    \n    This also helps in optimizing non-escape slice make. We already\n    optimize non-escape slice make with constant len/cap to stack\n    allocation. But it failed to handle things like f(make([]T, n))\n    (where the slice doesn't escape and n is constant), because of\n    the temporary. With tracking of temporary assignments and uses,\n    it can handle this now as well.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/179597\n\nFrom-SVN: r271822", "tree": {"sha": "99ef20c56f1bba3d53736e534b7e49f270169863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99ef20c56f1bba3d53736e534b7e49f270169863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6303331c3330222fef94eff8d8d35c99ca1d3e88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6303331c3330222fef94eff8d8d35c99ca1d3e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6303331c3330222fef94eff8d8d35c99ca1d3e88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6303331c3330222fef94eff8d8d35c99ca1d3e88/comments", "author": null, "committer": null, "parents": [{"sha": "2b5360d7477277e7e0f32a5bd5479afac819b5e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5360d7477277e7e0f32a5bd5479afac819b5e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5360d7477277e7e0f32a5bd5479afac819b5e1"}], "stats": {"total": 359, "additions": 266, "deletions": 93}, "files": [{"sha": "d377e226cac6e0e705da7e2465c991536aa573f3", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -1,4 +1,4 @@\n-e521123b23494148d534755e2f3d7806b42c96ad\n+52176566485e20968394a5cb67a89ac676182594\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9d8c085aead90fb94e4f003952754ff02e154f9c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 190, "deletions": 46, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -1052,6 +1052,7 @@ Temporary_reference_expression*\n Expression::make_temporary_reference(Temporary_statement* statement,\n \t\t\t\t     Location location)\n {\n+  statement->add_use();\n   return new Temporary_reference_expression(statement, location);\n }\n \n@@ -8286,23 +8287,87 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n   Temporary_statement* l2tmp = NULL;\n   Expression_list* add = NULL;\n   Expression* len2;\n+  Call_expression* makecall = NULL;\n   if (this->is_varargs())\n     {\n       go_assert(args->size() == 2);\n \n-      // s2tmp := s2\n-      s2tmp = Statement::make_temporary(NULL, args->back(), loc);\n-      inserter->insert(s2tmp);\n+      std::pair<Call_expression*, Temporary_statement*> p =\n+        Expression::find_makeslice_call(args->back());\n+      makecall = p.first;\n+      if (makecall != NULL)\n+        {\n+          // We are handling\n+          // \tappend(s, make([]T, len[, cap])...))\n+          // which has already been lowered to\n+          // \tappend(s, runtime.makeslice(T, len, cap)).\n+          // We will optimize this to directly zeroing the tail,\n+          // instead of allocating a new slice then copy.\n+\n+          // Retrieve the length. Cannot reference s2 as we will remove\n+          // the makeslice call.\n+          Expression* len_arg = makecall->args()->at(1);\n+          len_arg = Expression::make_cast(int_type, len_arg, loc);\n+          l2tmp = Statement::make_temporary(int_type, len_arg, loc);\n+          inserter->insert(l2tmp);\n+\n+          Expression* cap_arg = makecall->args()->at(2);\n+          cap_arg = Expression::make_cast(int_type, cap_arg, loc);\n+          Temporary_statement* c2tmp =\n+            Statement::make_temporary(int_type, cap_arg, loc);\n+          inserter->insert(c2tmp);\n+\n+          // Check bad len/cap here.\n+          // if len2 < 0 { panicmakeslicelen(); }\n+          len2 = Expression::make_temporary_reference(l2tmp, loc);\n+          Expression* zero = Expression::make_integer_ul(0, int_type, loc);\n+          Expression* cond = Expression::make_binary(OPERATOR_LT, len2,\n+                                                     zero, loc);\n+          Expression* arg =\n+            Expression::make_integer_ul(RUNTIME_ERROR_MAKE_SLICE_LEN_OUT_OF_BOUNDS,\n+                                        NULL, loc);\n+          Expression* call = Runtime::make_call(Runtime::RUNTIME_ERROR,\n+                                                loc, 1, arg);\n+          cond = Expression::make_conditional(cond, call, zero->copy(), loc);\n+          gogo->lower_expression(function, inserter, &cond);\n+          gogo->flatten_expression(function, inserter, &cond);\n+          Statement* s = Statement::make_statement(cond, false);\n+          inserter->insert(s);\n+\n+          // if cap2 < 0 { panicmakeslicecap(); }\n+          Expression* cap2 = Expression::make_temporary_reference(c2tmp, loc);\n+          cond = Expression::make_binary(OPERATOR_LT, cap2,\n+                                         zero->copy(), loc);\n+          arg = Expression::make_integer_ul(RUNTIME_ERROR_MAKE_SLICE_CAP_OUT_OF_BOUNDS,\n+                                            NULL, loc);\n+          call = Runtime::make_call(Runtime::RUNTIME_ERROR, loc, 1, arg);\n+          cond = Expression::make_conditional(cond, call, zero->copy(), loc);\n+          gogo->lower_expression(function, inserter, &cond);\n+          gogo->flatten_expression(function, inserter, &cond);\n+          s = Statement::make_statement(cond, false);\n+          inserter->insert(s);\n+\n+          // Remove the original makeslice call.\n+          Temporary_statement* ts = p.second;\n+          if (ts != NULL && ts->uses() == 1)\n+            ts->set_init(Expression::make_nil(loc));\n+        }\n+      else\n+        {\n+          // s2tmp := s2\n+          s2tmp = Statement::make_temporary(NULL, args->back(), loc);\n+          inserter->insert(s2tmp);\n \n-      // l2tmp := len(s2tmp)\n-      lenref = Expression::make_func_reference(lenfn, NULL, loc);\n-      call_args = new Expression_list();\n-      call_args->push_back(Expression::make_temporary_reference(s2tmp, loc));\n-      len = Expression::make_call(lenref, call_args, false, loc);\n-      gogo->lower_expression(function, inserter, &len);\n-      gogo->flatten_expression(function, inserter, &len);\n-      l2tmp = Statement::make_temporary(int_type, len, loc);\n-      inserter->insert(l2tmp);\n+          // l2tmp := len(s2tmp)\n+          lenref = Expression::make_func_reference(lenfn, NULL, loc);\n+          call_args = new Expression_list();\n+          call_args->push_back(Expression::make_temporary_reference(s2tmp, loc));\n+          len = Expression::make_call(lenref, call_args, false, loc);\n+          gogo->lower_expression(function, inserter, &len);\n+          gogo->flatten_expression(function, inserter, &len);\n+          l2tmp = Statement::make_temporary(int_type, len, loc);\n+          inserter->insert(l2tmp);\n+        }\n \n       // len2 = l2tmp\n       len2 = Expression::make_temporary_reference(l2tmp, loc);\n@@ -8422,52 +8487,92 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n       inserter->insert(assign);\n     }\n \n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n   if (this->is_varargs())\n     {\n-      if (element_type->has_pointer())\n+      if (makecall != NULL)\n         {\n-          // copy(s1tmp[l1tmp:], s2tmp)\n-          a1 = Expression::make_temporary_reference(s1tmp, loc);\n-          ref = Expression::make_temporary_reference(l1tmp, loc);\n-          Expression* nil = Expression::make_nil(loc);\n-          a1 = Expression::make_array_index(a1, ref, nil, NULL, loc);\n-          a1->array_index_expression()->set_needs_bounds_check(false);\n-\n-          a2 = Expression::make_temporary_reference(s2tmp, loc);\n-\n-          Named_object* copyfn = gogo->lookup_global(\"copy\");\n-          Expression* copyref = Expression::make_func_reference(copyfn, NULL, loc);\n-          call_args = new Expression_list();\n-          call_args->push_back(a1);\n-          call_args->push_back(a2);\n-          call = Expression::make_call(copyref, call_args, false, loc);\n-        }\n-      else\n-        {\n-          // memmove(&s1tmp[l1tmp], s2tmp.ptr, l2tmp*sizeof(elem))\n+          // memclr(&s1tmp[l1tmp], l2tmp*sizeof(elem))\n           a1 = Expression::make_temporary_reference(s1tmp, loc);\n           ref = Expression::make_temporary_reference(l1tmp, loc);\n           a1 = Expression::make_array_index(a1, ref, NULL, NULL, loc);\n           a1->array_index_expression()->set_needs_bounds_check(false);\n           a1 = Expression::make_unary(OPERATOR_AND, a1, loc);\n \n-          a2 = Expression::make_temporary_reference(s2tmp, loc);\n-          a2 = (a2->type()->is_string_type()\n-                ? Expression::make_string_info(a2,\n-                                               STRING_INFO_DATA,\n-                                               loc)\n-                : Expression::make_slice_info(a2,\n-                                              SLICE_INFO_VALUE_POINTER,\n-                                              loc));\n-\n-          Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n           ref = Expression::make_temporary_reference(l2tmp, loc);\n           ref = Expression::make_cast(uintptr_type, ref, loc);\n-          a3 = Expression::make_type_info(element_type, TYPE_INFO_SIZE);\n-          a3 = Expression::make_binary(OPERATOR_MULT, a3, ref, loc);\n+          a2 = Expression::make_type_info(element_type, TYPE_INFO_SIZE);\n+          a2 = Expression::make_binary(OPERATOR_MULT, a2, ref, loc);\n \n-          call = Runtime::make_call(Runtime::BUILTIN_MEMMOVE, loc, 3,\n-                                    a1, a2, a3);\n+          Runtime::Function code = (element_type->has_pointer()\n+                                    ? Runtime::MEMCLRHASPTR\n+                                    : Runtime::MEMCLRNOPTR);\n+          call = Runtime::make_call(code, loc, 2, a1, a2);\n+\n+          if (element_type->has_pointer())\n+            {\n+              // For a slice containing pointers, growslice already zeroed\n+              // the memory. We only need to zero in non-growing case.\n+              // Note: growslice does not zero the memory in non-pointer case.\n+              Expression* left =\n+                Expression::make_temporary_reference(ntmp, loc);\n+              left = Expression::make_cast(uint_type, left, loc);\n+              Expression* right =\n+                Expression::make_temporary_reference(c1tmp, loc);\n+              right = Expression::make_cast(uint_type, right, loc);\n+              Expression* cond =\n+                Expression::make_binary(OPERATOR_GT, left, right, loc);\n+              Expression* zero = Expression::make_integer_ul(0, int_type, loc);\n+              call = Expression::make_conditional(cond, call, zero, loc);\n+            }\n+        }\n+      else\n+        {\n+          if (element_type->has_pointer())\n+            {\n+              // copy(s1tmp[l1tmp:], s2tmp)\n+              a1 = Expression::make_temporary_reference(s1tmp, loc);\n+              ref = Expression::make_temporary_reference(l1tmp, loc);\n+              Expression* nil = Expression::make_nil(loc);\n+              a1 = Expression::make_array_index(a1, ref, nil, NULL, loc);\n+              a1->array_index_expression()->set_needs_bounds_check(false);\n+\n+              a2 = Expression::make_temporary_reference(s2tmp, loc);\n+\n+              Named_object* copyfn = gogo->lookup_global(\"copy\");\n+              Expression* copyref = Expression::make_func_reference(copyfn, NULL, loc);\n+              call_args = new Expression_list();\n+              call_args->push_back(a1);\n+              call_args->push_back(a2);\n+              call = Expression::make_call(copyref, call_args, false, loc);\n+            }\n+          else\n+            {\n+              // memmove(&s1tmp[l1tmp], s2tmp.ptr, l2tmp*sizeof(elem))\n+              a1 = Expression::make_temporary_reference(s1tmp, loc);\n+              ref = Expression::make_temporary_reference(l1tmp, loc);\n+              a1 = Expression::make_array_index(a1, ref, NULL, NULL, loc);\n+              a1->array_index_expression()->set_needs_bounds_check(false);\n+              a1 = Expression::make_unary(OPERATOR_AND, a1, loc);\n+\n+              a2 = Expression::make_temporary_reference(s2tmp, loc);\n+              a2 = (a2->type()->is_string_type()\n+                    ? Expression::make_string_info(a2,\n+                                                   STRING_INFO_DATA,\n+                                                   loc)\n+                    : Expression::make_slice_info(a2,\n+                                                  SLICE_INFO_VALUE_POINTER,\n+                                                  loc));\n+\n+              ref = Expression::make_temporary_reference(l2tmp, loc);\n+              ref = Expression::make_cast(uintptr_type, ref, loc);\n+              a3 = Expression::make_type_info(element_type, TYPE_INFO_SIZE);\n+              a3 = Expression::make_binary(OPERATOR_MULT, a3, ref, loc);\n+\n+              call = Runtime::make_call(Runtime::BUILTIN_MEMMOVE, loc, 3,\n+                                        a1, a2, a3);\n+            }\n         }\n       gogo->lower_expression(function, inserter, &call);\n       gogo->flatten_expression(function, inserter, &call);\n@@ -16540,6 +16645,45 @@ Expression::make_slice_value(Type* at, Expression* valmem, Expression* len,\n   return new Slice_value_expression(at, valmem, len, cap, location);\n }\n \n+// Look through the expression of a Slice_value_expression's valmem to\n+// find an call to makeslice.  If found, return the call expression and\n+// the containing temporary statement (if any).\n+\n+std::pair<Call_expression*, Temporary_statement*>\n+Expression::find_makeslice_call(Expression* expr)\n+{\n+  Unsafe_type_conversion_expression* utce =\n+    expr->unsafe_conversion_expression();\n+  if (utce != NULL)\n+    expr = utce->expr();\n+\n+  Slice_value_expression* sve = expr->slice_value_expression();\n+  if (sve == NULL)\n+    return std::make_pair<Call_expression*, Temporary_statement*>(NULL, NULL);\n+  expr = sve->valmem();\n+\n+  utce = expr->unsafe_conversion_expression();\n+  if (utce != NULL)\n+    expr = utce->expr();\n+\n+  Temporary_reference_expression* tre = expr->temporary_reference_expression();\n+  Temporary_statement* ts = (tre != NULL ? tre->statement() : NULL);\n+  if (ts != NULL && ts->init() != NULL && !ts->assigned()\n+      && !ts->is_address_taken())\n+    expr = ts->init();\n+\n+  Call_expression* call = expr->call_expression();\n+  if (call == NULL)\n+    return std::make_pair<Call_expression*, Temporary_statement*>(NULL, NULL);\n+\n+  Func_expression* fe = call->fn()->func_expression();\n+  if (fe != NULL\n+      && fe->runtime_code() == Runtime::MAKESLICE)\n+    return std::make_pair(call, ts);\n+\n+  return std::make_pair<Call_expression*, Temporary_statement*>(NULL, NULL);\n+}\n+\n // An expression that evaluates to some characteristic of a non-empty interface.\n // This is used to access the method table or underlying object of an interface.\n "}, {"sha": "ea98facf5dc27f6a21a24b63536b2b4818dc5cd2", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -1068,6 +1068,11 @@ class Expression\n   static Expression*\n   unpack_direct_iface(Expression*, Location);\n \n+  // Look through the expression of a Slice_value_expression's valmem to\n+  // find an call to makeslice.\n+  static std::pair<Call_expression*, Temporary_statement*>\n+  find_makeslice_call(Expression*);\n+\n   // Dump an expression to a dump constext.\n   void\n   dump_expression(Ast_dump_context*) const;"}, {"sha": "fd28ed1c3df51820a362c2a7f9fa07e6bdb6e1d9", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -3627,21 +3627,24 @@ static const int RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS = 5;\n // locations.\n static const int RUNTIME_ERROR_NIL_DEREFERENCE = 6;\n \n-// Slice length or capacity out of bounds in make: negative or\n-// overflow or length greater than capacity.\n-static const int RUNTIME_ERROR_MAKE_SLICE_OUT_OF_BOUNDS = 7;\n+// Slice length out of bounds in make: negative or overflow\n+// or length greater than capacity.\n+static const int RUNTIME_ERROR_MAKE_SLICE_LEN_OUT_OF_BOUNDS = 7;\n+\n+// Slice capacity out of bounds in make: negative.\n+static const int RUNTIME_ERROR_MAKE_SLICE_CAP_OUT_OF_BOUNDS = 8;\n \n // Map capacity out of bounds in make: negative or overflow.\n-static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 8;\n+static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 9;\n \n // Channel capacity out of bounds in make: negative or overflow.\n-static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 9;\n+static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 10;\n \n // Division by zero.\n-static const int RUNTIME_ERROR_DIVISION_BY_ZERO = 10;\n+static const int RUNTIME_ERROR_DIVISION_BY_ZERO = 11;\n \n // Go statement with nil function.\n-static const int RUNTIME_ERROR_GO_NIL = 11;\n+static const int RUNTIME_ERROR_GO_NIL = 12;\n \n // This is used by some of the langhooks.\n extern Gogo* go_get_gogo();"}, {"sha": "fe9b748de726f87801fc0ca02964fc1d6995d542", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -1043,6 +1043,9 @@ Assignment_statement*\n Statement::make_assignment(Expression* lhs, Expression* rhs,\n \t\t\t   Location location)\n {\n+  Temporary_reference_expression* tre = lhs->temporary_reference_expression();\n+  if (tre != NULL)\n+    tre->statement()->set_assigned();\n   return new Assignment_statement(lhs, rhs, location);\n }\n "}, {"sha": "d621a9af7d81b07666e53ab6339d388ba9fb2bb6", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -675,7 +675,7 @@ class Temporary_statement : public Statement\n   Temporary_statement(Type* type, Expression* init, Location location)\n     : Statement(STATEMENT_TEMPORARY, location),\n       type_(type), init_(init), bvariable_(NULL), is_address_taken_(false),\n-      value_escapes_(false)\n+      value_escapes_(false), assigned_(false), uses_(0)\n   { }\n \n   // Return the type of the temporary variable.\n@@ -687,6 +687,17 @@ class Temporary_statement : public Statement\n   init() const\n   { return this->init_; }\n \n+  // Set the initializer.\n+  void\n+  set_init(Expression* expr)\n+  { this->init_ = expr; }\n+\n+  // Whether something takes the address of this temporary\n+  // variable.\n+  bool\n+  is_address_taken()\n+  { return this->is_address_taken_; }\n+\n   // Record that something takes the address of this temporary\n   // variable.\n   void\n@@ -703,6 +714,26 @@ class Temporary_statement : public Statement\n   set_value_escapes()\n   { this->value_escapes_ = true; }\n \n+  // Whether this temporary variable is assigned (after initialization).\n+  bool\n+  assigned()\n+  { return this->assigned_; }\n+\n+  // Record that this temporary variable is assigned.\n+  void\n+  set_assigned()\n+  { this->assigned_ = true; }\n+\n+  // Number of uses of this temporary variable.\n+  int\n+  uses()\n+  { return this->uses_; }\n+\n+  // Add one use of this temporary variable.\n+  void\n+  add_use()\n+  { this->uses_++; }\n+\n   // Return the temporary variable.  This should not be called until\n   // after the statement itself has been converted.\n   Bvariable*\n@@ -745,6 +776,10 @@ class Temporary_statement : public Statement\n   // True if the value assigned to this temporary variable escapes.\n   // This is used for select statements.\n   bool value_escapes_;\n+  // True if this temporary variable is assigned (after initialization).\n+  bool assigned_;\n+  // Number of uses of this temporary variable.\n+  int uses_;\n };\n \n // A variable declaration.  This marks the point in the code where a"}, {"sha": "2eae08f7bdc83e8ab5f9b0cd252832374f847367", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -41,9 +41,6 @@ class Mark_address_taken : public Traverse\n   expression(Expression**);\n \n  private:\n-  Call_expression*\n-  find_makeslice_call(Expression*);\n-\n   // General IR.\n   Gogo* gogo_;\n   // The function we are traversing.\n@@ -100,31 +97,6 @@ Mark_address_taken::statement(Block* block, size_t* pindex, Statement* s)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Look through the expression of a Slice_value_expression's valmem to\n-// find an call to makeslice.\n-\n-Call_expression*\n-Mark_address_taken::find_makeslice_call(Expression* expr)\n-{\n-  Unsafe_type_conversion_expression* utce =\n-    expr->unsafe_conversion_expression();\n-  if (utce != NULL)\n-    expr = utce->expr();\n-\n-  Call_expression* call = expr->call_expression();\n-  if (call == NULL)\n-    return NULL;\n-\n-  Func_expression* fe = call->fn()->func_expression();\n-  if (fe != NULL && fe->runtime_code() == Runtime::MAKESLICE)\n-    return call;\n-\n-  // We don't worry about MAKESLICE64 bcause we don't want to use a\n-  // stack allocation for a large slice anyhow.\n-\n-  return NULL;\n-}\n-\n // Mark variable addresses taken.\n \n int\n@@ -173,7 +145,10 @@ Mark_address_taken::expression(Expression** pexpr)\n   Slice_value_expression* sve = expr->slice_value_expression();\n   if (sve != NULL)\n     {\n-      Call_expression* call = this->find_makeslice_call(sve->valmem());\n+      std::pair<Call_expression*, Temporary_statement*> p =\n+        Expression::find_makeslice_call(sve);\n+      Call_expression* call = p.first;\n+      Temporary_statement* ts = p.second;\n       if (call != NULL\n \t  && Node::make_node(call)->encoding() == Node::ESCAPE_NONE)\n         {\n@@ -203,6 +178,8 @@ Mark_address_taken::expression(Expression** pexpr)\n \t\tExpression::make_slice_value(expr->type(), ptr, len_arg,\n \t\t\t\t\t     cap_arg, loc);\n               *pexpr = slice;\n+              if (ts != NULL && ts->uses() == 1)\n+                ts->set_init(Expression::make_nil(loc));\n             }\n         }\n     }"}, {"sha": "c9ccf98736f7d142f049d66a6da6688bd3bdec10", "filename": "libgo/runtime/go-runtime-error.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303331c3330222fef94eff8d8d35c99ca1d3e88/libgo%2Fruntime%2Fgo-runtime-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303331c3330222fef94eff8d8d35c99ca1d3e88/libgo%2Fruntime%2Fgo-runtime-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-runtime-error.c?ref=6303331c3330222fef94eff8d8d35c99ca1d3e88", "patch": "@@ -38,21 +38,24 @@ enum\n      memory locations.  */\n   NIL_DEREFERENCE = 6,\n \n-  /* Slice length or capacity out of bounds in make: negative or\n-     overflow or length greater than capacity.  */\n-  MAKE_SLICE_OUT_OF_BOUNDS = 7,\n+  /* Slice length out of bounds in make: negative or overflow or length\n+     greater than capacity.  */\n+  MAKE_SLICE_LEN_OUT_OF_BOUNDS = 7,\n+\n+  /* Slice capacity out of bounds in make: negative.  */\n+  MAKE_SLICE_CAP_OUT_OF_BOUNDS = 8,\n \n   /* Map capacity out of bounds in make: negative or overflow.  */\n-  MAKE_MAP_OUT_OF_BOUNDS = 8,\n+  MAKE_MAP_OUT_OF_BOUNDS = 9,\n \n   /* Channel capacity out of bounds in make: negative or overflow.  */\n-  MAKE_CHAN_OUT_OF_BOUNDS = 9,\n+  MAKE_CHAN_OUT_OF_BOUNDS = 10,\n \n   /* Integer division by zero.  */\n-  DIVISION_BY_ZERO = 10,\n+  DIVISION_BY_ZERO = 11,\n \n   /* Go statement with nil function.  */\n-  GO_NIL = 11\n+  GO_NIL = 12\n };\n \n extern void __go_runtime_error (int32) __attribute__ ((noreturn));\n@@ -88,8 +91,11 @@ __go_runtime_error (int32 i)\n     case NIL_DEREFERENCE:\n       runtime_panicstring (\"nil pointer dereference\");\n \n-    case MAKE_SLICE_OUT_OF_BOUNDS:\n-      runtime_panicstring (\"make slice len or cap out of range\");\n+    case MAKE_SLICE_LEN_OUT_OF_BOUNDS:\n+      runtime_panicstring (\"make slice len out of range\");\n+\n+    case MAKE_SLICE_CAP_OUT_OF_BOUNDS:\n+      runtime_panicstring (\"make slice cap out of range\");\n \n     case MAKE_MAP_OUT_OF_BOUNDS:\n       runtime_panicstring (\"make map len out of range\");"}]}