{"sha": "95a2ed0325864069bb0368d75bcf85a8b22c4127", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVhMmVkMDMyNTg2NDA2OWJiMDM2OGQ3NWJjZjg1YThiMjJjNDEyNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-01-26T22:19:17Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-01-26T22:19:17Z"}, "message": "[PR ipa/88933] Careful CFG cleanup in IPA-CP function transformation\n\n2019-01-26  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/88933\n\t* tree-inline.c: Include tree-cfgcleanup.h.\n\t(delete_unreachable_blocks_update_callgraph): Move...\n\t* tree-cfgcleanup.c (delete_unreachable_blocks_update_callgraph):\n\t...here, make externally visible, make second argument bool, adjust\n\tall callers.\n\t* tree-cfgcleanup.c: Include cgraph.h.\n\t* tree-cfgcleanup.h (delete_unreachable_blocks_update_callgraph):\n\tDeclare.\n\t* ipa-prop.c: Include tree-cfgcleanup.h.\n\t(ipcp_transform_function): Call\n\tdelete_unreachable_blocks_update_callgraph instead of cleaning uo CFG.\n\n\ttestsuite/\n\t* gfortran.dg/gomp/pr88933.f90: New test.\n\nFrom-SVN: r268305", "tree": {"sha": "04c852d893bcc50234c3b2bead6edb14dabc70bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c852d893bcc50234c3b2bead6edb14dabc70bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95a2ed0325864069bb0368d75bcf85a8b22c4127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a2ed0325864069bb0368d75bcf85a8b22c4127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95a2ed0325864069bb0368d75bcf85a8b22c4127", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a2ed0325864069bb0368d75bcf85a8b22c4127/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4e13e261060dde55de4f7135fe09a816a51f929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4e13e261060dde55de4f7135fe09a816a51f929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4e13e261060dde55de4f7135fe09a816a51f929"}], "stats": {"total": 226, "additions": 145, "deletions": 81}, "files": [{"sha": "269b6652249ea46e04f1c64f21eb02a2c746097e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -1,3 +1,18 @@\n+2019-01-26  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/88933\n+\t* tree-inline.c: Include tree-cfgcleanup.h.\n+\t(delete_unreachable_blocks_update_callgraph): Move...\n+\t* tree-cfgcleanup.c (delete_unreachable_blocks_update_callgraph):\n+\t...here, make externally visible, make second argument bool, adjust\n+\tall callers.\n+\t* tree-cfgcleanup.c: Include cgraph.h.\n+\t* tree-cfgcleanup.h (delete_unreachable_blocks_update_callgraph):\n+\tDeclare.\n+\t* ipa-prop.c: Include tree-cfgcleanup.h.\n+\t(ipcp_transform_function): Call\n+\tdelete_unreachable_blocks_update_callgraph instead of cleaning uo CFG.\n+\n 2019-01-25  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/88846"}, {"sha": "d86c2f3db5528f5fe3c67e46cecd2f3bb761a212", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"domwalk.h\"\n #include \"builtins.h\"\n+#include \"tree-cfgcleanup.h\"\n \n /* Function summary where the parameter infos are actually stored. */\n ipa_node_params_t *ipa_node_params_sum = NULL;\n@@ -5173,10 +5174,11 @@ ipcp_transform_function (struct cgraph_node *node)\n \n   if (!something_changed)\n     return 0;\n-  else if (cfg_changed)\n-    return TODO_update_ssa_only_virtuals | TODO_cleanup_cfg;\n-  else\n-    return TODO_update_ssa_only_virtuals;\n+\n+  if (cfg_changed)\n+    delete_unreachable_blocks_update_callgraph (node, false);\n+\n+  return TODO_update_ssa_only_virtuals;\n }\n \n #include \"gt-ipa-prop.h\""}, {"sha": "9fe74a08600f029d86706bea3c3f4b83d2c7dd32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -1,3 +1,8 @@\n+2019-01-26  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/88933\n+\t* gfortran.dg/gomp/pr88933.f90: New test.\n+\n 2019-01-26  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \tPR d/89042"}, {"sha": "e4f30ae9f3eb768c00152e13e5a4ba76b94d5dfe", "filename": "gcc/testsuite/gfortran.dg/gomp/pr88933.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr88933.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr88933.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr88933.f90?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -0,0 +1,39 @@\n+! PR ipa/88933\n+! { dg-do compile }\n+! { dg-options \"-O1 -fexceptions -fipa-cp -fnon-call-exceptions -fopenmp -fno-inline-functions-called-once\" }\n+\n+!$omp parallel  \n+!$omp single\n+  call a\n+!$omp end single\n+!$omp end parallel\n+contains\n+  subroutine b (c, d, e, f, g, h, i, j, k, m)\n+    character (*) c\n+    character  d\n+    integer, dimension (m) :: e\n+    integer, dimension (m) :: f\n+    character  g\n+    character  h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (:, :, :) :: j\n+    integer, dimension (:, :, :) :: k\n+     \n+    integer, dimension (m) :: l\n+!$omp task firstprivate (k) firstprivate (l)\n+    !$omp end task\n+  c = ''\n+  end  \n+  subroutine a\n+    character  c\n+    character  d\n+    integer, dimension (7) :: e\n+    integer, dimension (7) :: f\n+    character g\n+    character h\n+    real, dimension (5, 6, 7) :: i\n+    double precision, dimension (6, 6, 7) :: j\n+    integer, dimension (5, 7, 6) :: k\n+    call b (c, d, e, f, g, h, i, j, k, 7)\n+  end  \n+end"}, {"sha": "f2e8b96ee8ef556e955d8c38b9b9afc1b68d5108", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-match.h\"\n #include \"gimple-fold.h\"\n #include \"tree-ssa-loop-niter.h\"\n-\n+#include \"cgraph.h\"\n \n /* The set of blocks in that at least one of the following changes happened:\n    -- the statement at the end of the block was changed\n@@ -1380,3 +1380,76 @@ make_pass_cleanup_cfg_post_optimizing (gcc::context *ctxt)\n }\n \n \n+/* Delete all unreachable basic blocks and update callgraph.\n+   Doing so is somewhat nontrivial because we need to update all clones and\n+   remove inline function that become unreachable.  */\n+\n+bool\n+delete_unreachable_blocks_update_callgraph (cgraph_node *dst_node,\n+\t\t\t\t\t    bool update_clones)\n+{\n+  bool changed = false;\n+  basic_block b, next_bb;\n+\n+  find_unreachable_blocks ();\n+\n+  /* Delete all unreachable basic blocks.  */\n+\n+  for (b = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; b\n+       != EXIT_BLOCK_PTR_FOR_FN (cfun); b = next_bb)\n+    {\n+      next_bb = b->next_bb;\n+\n+      if (!(b->flags & BB_REACHABLE))\n+\t{\n+          gimple_stmt_iterator bsi;\n+\n+          for (bsi = gsi_start_bb (b); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t    {\n+\t      struct cgraph_edge *e;\n+\t      struct cgraph_node *node;\n+\n+\t      dst_node->remove_stmt_references (gsi_stmt (bsi));\n+\n+\t      if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n+\t\t  &&(e = dst_node->get_edge (gsi_stmt (bsi))) != NULL)\n+\t\t{\n+\t\t  if (!e->inline_failed)\n+\t\t    e->callee->remove_symbol_and_inline_clones (dst_node);\n+\t\t  else\n+\t\t    e->remove ();\n+\t\t}\n+\t      if (update_clones && dst_node->clones)\n+\t\tfor (node = dst_node->clones; node != dst_node;)\n+\t\t  {\n+\t\t    node->remove_stmt_references (gsi_stmt (bsi));\n+\t\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n+\t\t\t&& (e = node->get_edge (gsi_stmt (bsi))) != NULL)\n+\t\t      {\n+\t\t\tif (!e->inline_failed)\n+\t\t\t  e->callee->remove_symbol_and_inline_clones (dst_node);\n+\t\t\telse\n+\t\t\t  e->remove ();\n+\t\t      }\n+\n+\t\t    if (node->clones)\n+\t\t      node = node->clones;\n+\t\t    else if (node->next_sibling_clone)\n+\t\t      node = node->next_sibling_clone;\n+\t\t    else\n+\t\t      {\n+\t\t\twhile (node != dst_node && !node->next_sibling_clone)\n+\t\t\t  node = node->clone_of;\n+\t\t\tif (node != dst_node)\n+\t\t\t  node = node->next_sibling_clone;\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t  delete_basic_block (b);\n+\t  changed = true;\n+\t}\n+    }\n+\n+  return changed;\n+}\n+"}, {"sha": "bd27505fd5c8092611bcfc3800be24818807a3de", "filename": "gcc/tree-cfgcleanup.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftree-cfgcleanup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftree-cfgcleanup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.h?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -24,5 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n extern bitmap cfgcleanup_altered_bbs;\n extern bool cleanup_tree_cfg (void);\n extern bool fixup_noreturn_call (gimple *stmt);\n+extern bool delete_unreachable_blocks_update_callgraph (cgraph_node *dst_node,\n+\t\t\t\t\t\t\tbool update_clones);\n \n #endif /* GCC_TREE_CFGCLEANUP_H */"}, {"sha": "5c0c4c5ab91da61e6b8b74045f6840e4dc4b5a2a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 76, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a2ed0325864069bb0368d75bcf85a8b22c4127/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=95a2ed0325864069bb0368d75bcf85a8b22c4127", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"sreal.h\"\n+#include \"tree-cfgcleanup.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -132,7 +133,6 @@ static tree copy_decl_to_var (tree, copy_body_data *);\n static tree copy_result_decl_to_var (tree, copy_body_data *);\n static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n static gimple_seq remap_gimple_stmt (gimple *, copy_body_data *);\n-static bool delete_unreachable_blocks_update_callgraph (copy_body_data *id);\n static void insert_init_stmt (copy_body_data *, basic_block, gimple *);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n@@ -5124,7 +5124,8 @@ optimize_inline_calls (tree fn)\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (fn);\n \n-  delete_unreachable_blocks_update_callgraph (&id);\n+  delete_unreachable_blocks_update_callgraph (id.dst_node, false);\n+\n   if (flag_checking)\n     id.dst_node->verify ();\n \n@@ -5708,79 +5709,6 @@ tree_versionable_function_p (tree fndecl)\n \t  && copy_forbidden (DECL_STRUCT_FUNCTION (fndecl)) == NULL);\n }\n \n-/* Delete all unreachable basic blocks and update callgraph.\n-   Doing so is somewhat nontrivial because we need to update all clones and\n-   remove inline function that become unreachable.  */\n-\n-static bool\n-delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n-{\n-  bool changed = false;\n-  basic_block b, next_bb;\n-\n-  find_unreachable_blocks ();\n-\n-  /* Delete all unreachable basic blocks.  */\n-\n-  for (b = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; b\n-       != EXIT_BLOCK_PTR_FOR_FN (cfun); b = next_bb)\n-    {\n-      next_bb = b->next_bb;\n-\n-      if (!(b->flags & BB_REACHABLE))\n-\t{\n-          gimple_stmt_iterator bsi;\n-\n-          for (bsi = gsi_start_bb (b); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t    {\n-\t      struct cgraph_edge *e;\n-\t      struct cgraph_node *node;\n-\n-\t      id->dst_node->remove_stmt_references (gsi_stmt (bsi));\n-\n-\t      if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n-\t\t  &&(e = id->dst_node->get_edge (gsi_stmt (bsi))) != NULL)\n-\t\t{\n-\t\t  if (!e->inline_failed)\n-\t\t    e->callee->remove_symbol_and_inline_clones (id->dst_node);\n-\t\t  else\n-\t\t    e->remove ();\n-\t\t}\n-\t      if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n-\t\t  && id->dst_node->clones)\n-\t\tfor (node = id->dst_node->clones; node != id->dst_node;)\n-\t\t  {\n-\t\t    node->remove_stmt_references (gsi_stmt (bsi));\n-\t\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n-\t\t\t&& (e = node->get_edge (gsi_stmt (bsi))) != NULL)\n-\t\t      {\n-\t\t\tif (!e->inline_failed)\n-\t\t\t  e->callee->remove_symbol_and_inline_clones (id->dst_node);\n-\t\t\telse\n-\t\t\t  e->remove ();\n-\t\t      }\n-\n-\t\t    if (node->clones)\n-\t\t      node = node->clones;\n-\t\t    else if (node->next_sibling_clone)\n-\t\t      node = node->next_sibling_clone;\n-\t\t    else\n-\t\t      {\n-\t\t\twhile (node != id->dst_node && !node->next_sibling_clone)\n-\t\t\t  node = node->clone_of;\n-\t\t\tif (node != id->dst_node)\n-\t\t\t  node = node->next_sibling_clone;\n-\t\t      }\n-\t\t  }\n-\t    }\n-\t  delete_basic_block (b);\n-\t  changed = true;\n-\t}\n-    }\n-\n-  return changed;\n-}\n-\n /* Update clone info after duplication.  */\n \n static void\n@@ -6094,7 +6022,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   update_max_bb_count ();\n   fold_marked_statements (0, id.statements_to_fold);\n   delete id.statements_to_fold;\n-  delete_unreachable_blocks_update_callgraph (&id);\n+  delete_unreachable_blocks_update_callgraph (id.dst_node, update_clones);\n   if (id.dst_node->definition)\n     cgraph_edge::rebuild_references ();\n   if (loops_state_satisfies_p (LOOPS_NEED_FIXUP))"}]}