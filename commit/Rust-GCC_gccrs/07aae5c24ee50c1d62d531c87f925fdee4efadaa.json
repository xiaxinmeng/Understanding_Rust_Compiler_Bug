{"sha": "07aae5c24ee50c1d62d531c87f925fdee4efadaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdhYWU1YzI0ZWU1MGMxZDYyZDUzMWM4N2Y5MjVmZGVlNGVmYWRhYQ==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-03-04T18:05:40Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-03-04T18:05:40Z"}, "message": "New file.\n\nFrom-SVN: r3631", "tree": {"sha": "3ef654f9206fb800aff9644992ecc3250de7d8e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ef654f9206fb800aff9644992ecc3250de7d8e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07aae5c24ee50c1d62d531c87f925fdee4efadaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07aae5c24ee50c1d62d531c87f925fdee4efadaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07aae5c24ee50c1d62d531c87f925fdee4efadaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07aae5c24ee50c1d62d531c87f925fdee4efadaa/comments", "author": null, "committer": null, "parents": [{"sha": "f82eca4d69a0de0717974aa307d57f9afa369410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82eca4d69a0de0717974aa307d57f9afa369410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82eca4d69a0de0717974aa307d57f9afa369410"}], "stats": {"total": 2107, "additions": 2107, "deletions": 0}, "files": [{"sha": "f6ffedb32ffdb9b85ac791488242aae5de5022a4", "filename": "gcc/config/h8300/h8300.c", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=07aae5c24ee50c1d62d531c87f925fdee4efadaa", "patch": "@@ -0,0 +1,948 @@\n+/* Subroutines for insn-output.c for Hitachi H8/300.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+\n+   Contributed by Steve Chamberlain (sac@cygnus.com) and\n+   Jim Wilson (wilson@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"tree.h\"\n+\n+/* Forward declarations.  */\n+void print_operand_address ();\n+char *index ();\n+\n+/* True if a #pragma interrupt has been seen for the current function.  */\n+int pragma_interrupt;\n+\n+/* True if a #pragma saveall has been seen for the current function.  */\n+int pragma_saveall;\n+\n+char *names_big[] \n+ = {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\"};\n+\n+char *\n+byte_reg (x, b)\n+     rtx x;\n+     int b;\n+{\n+  static char *names_small[] \n+    =  {\"r0l\", \"r0h\", \"r1l\", \"r1h\", \"r2l\", \"r2h\", \"r3l\", \"r3h\",\n+\t\"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7lBAD\", \"r7hBAD\"};\n+\n+  return names_small[REGNO (x) * 2 + b];\n+}\n+\n+/* REGNO must be saved/restored across calls if this macro is true.  */\n+static int \n+word_reg_used (regno)\n+int regno;\n+{\n+  if (regno < 7  \n+      && (pragma_interrupt || pragma_saveall \n+\t  || (regno == FRAME_POINTER_REGNUM && regs_ever_live[regno])\n+\t  || (regs_ever_live[regno] & ! call_used_regs[regno])))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Output assembly language to FILE for the operation OP with operand size\n+   SIZE.  */\n+static void\n+dosize (file, op, size, fped)\n+     FILE *file;\n+     char *op;\n+     unsigned int size;\n+     int fped;\n+{\n+  switch (size)\n+    {\n+    case 4:\n+    case 3:\n+      fprintf (file, \"\\t%ss\\t#%d,sp\\n\", op, 2);\n+      size -= 2;\n+      /* Fall through...  */\n+    case 2:\n+    case 1:\n+      fprintf (file, \"\\t%ss\\t#%d,sp\\n\", op, size);\n+      size = 0;\n+      break;\n+    case 0:\n+      break;\n+    default:\n+      fprintf (file, \"\\tmov.w\\t#%d,r5\\n\\t%s.w\\tr5,sp\\n\", size, op);\n+      size = 0;\n+      break;\n+    }\n+}\n+\n+/* Output assembly language code for the function prologue.  */\n+static int push_order[FIRST_PSEUDO_REGISTER] \n+  = {6, 5, 4, 3, 2, 1, 0, -1, -1};\n+static int pop_order[FIRST_PSEUDO_REGISTER] \n+  = {0, 1, 2, 3, 4, 5, 6, -1, -1};\n+\n+/* This is what the stack looks like after the prolog of \n+   a function with a frame has been set up:\n+\n+\t<pushed args>\n+\treturn pc\n+   fp->\told fp\n+   \t<locals>\n+\t<saved register-0> \n+\t<saved register-1> \n+   sp->\t<saved register-n>\n+\n+\n+   This is what the stack looks like after the prolog of\n+   a function which doesn't have a frame:\n+\n+   \t<pushed args>\n+   \treturn pc\n+\t<locals>\n+\t<saved register-0>\n+   sp-> <saved register-n>\n+*/\n+\n+void\n+function_prologue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  register int mask = 0;\n+  int fsize = (size + 1) & -2;\n+  int idx;\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Push the fp.  */\n+      fprintf (file, \"\\tpush\\t%s\\n\", names_big[FRAME_POINTER_REGNUM]);\n+      fprintf (file, \"\\tmov.w\\tr7,r6\\n\");\n+\n+      /* Leave room for the locals.  */\n+      dosize (file, \"sub\", fsize, 1);\n+\n+      /* Push the rest of the registers.  */\n+      for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++) \n+\t{\n+\t  int regno = push_order[idx];\n+\n+\t  if (regno >= 0 && word_reg_used (regno)\n+\t      && regno != FRAME_POINTER_REGNUM)\n+\t    fprintf (file, \"\\tpush\\t%s\\n\", names_big[regno]);\n+\t}\n+    }\n+  else\n+    {\n+      dosize (file, \"sub\", fsize, 0);\n+      for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n+\t{\n+\t  int regno = push_order[idx];\n+\n+\t  if (regno >= 0 && word_reg_used (regno))\n+\t    fprintf (file, \"\\tpush\\t%s\\n\", names_big[regno]);\n+\t}\n+    }\n+}\n+\n+/* Output assembly language code for the function epilogue.  */\n+\n+void\n+function_epilogue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  register int regno;\n+  register int mask = 0;\n+  int fsize = (size + 1) & -2;\n+  int nregs;\n+  int offset;\n+  int idx;\n+  rtx insn = get_last_insn ();\n+\n+  /* If the last insn was a BARRIER, we don't have to write any code.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn && GET_CODE (insn) == BARRIER)\n+    return;\n+\n+  nregs = 0;\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Pop saved registers.  */\n+      for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n+\t{\n+\t  regno = pop_order[idx];\n+\t  if (regno >= 0 && regno != FRAME_POINTER_REGNUM\n+\t      && word_reg_used (regno))\n+\t    fprintf (file, \"\\tpop\\t%s\\n\", names_big[regno]);\n+\t}\n+      /* Deallocate locals.  */\n+      dosize (file, \"add\", fsize, 1);\n+      /* Pop frame pointer.  */\n+      fprintf (file, \"\\tpop\\t%s\\n\", names_big[FRAME_POINTER_REGNUM]);\n+    }\n+  else\n+    {\n+      /* Deallocate locals and pop saved registers.  */\n+      for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n+\t{\n+\t  regno = pop_order[idx];\n+\t  if (regno >= 0 && word_reg_used (regno))\n+\t    fprintf (file, \"\\tpop\\t%s\\n\", names_big[regno]);\n+\t}\n+      dosize (file, \"add\", fsize, 0);\n+    }\n+  if (pragma_interrupt)\n+    fprintf (file, \"\\trte\\n\");\n+  else\n+    fprintf (file, \"\\trts\\n\");\n+\n+  pragma_interrupt = 0;\n+  pragma_saveall = 0;\n+}\n+\f\n+/* Return true if VALUE is a valid constant for constraint 'P'.  */\n+\n+int\n+potl8 (value)\n+{\n+  switch (value)\n+    {\n+    case 1:\n+    case 2:\n+    case 4:\n+    case 8:\n+    case 16:\n+    case 32:\n+    case 64:\n+    case 128:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return true if VALUE is a valid constant for constraint 'O'.  */\n+int\n+potg8 (value)\n+     int value;\n+{\n+  switch (value)\n+    {\n+    case 256:\n+    case 512:\n+    case 1024:\n+    case 2048:\n+    case 4096:\n+    case 8192:\n+    case 16384:\n+    case 32768:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return true is OP is a valid source operand for an integer move\n+   instruction.  */\n+int\n+general_operand_src (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* We can't have a pre-dec as a source.  */\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+    return 0;\n+  return general_operand (op, mode);\n+}\n+\n+/* Return true if OP is a valid destination operand for an integer move\n+   instruction.  */\n+int\n+general_operand_dst (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* We can't have a post-inc as a dest.  */\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n+    return 0;\n+  return general_operand (op, mode);\n+}\n+\f\n+/* Handle machine specific pragmas for compatibility with existing\n+   compilers for the H8/300\n+\n+   pragma saveall generates prolog/epilog code which saves and\n+   restores all the registers on function entry.\n+   \n+   pragma interrupt saves and restores all registers, and exits with\n+   an rte instruction rather than an rts.  A pointer to a function\n+   with this attribute may be safely used in an interrupt vector.  */\n+int\n+handle_pragma (file)\n+     FILE *file;\n+{\n+  int c;\n+  char pbuf[20];\n+  int psize;\n+\n+  c = getc (file);\n+  while (c == ' ' || c == '\\t')\n+    c = getc (file);\n+\n+  if (c == '\\n' || c == EOF)\n+    return c;\n+\n+  for (psize = 0; psize < sizeof (pbuf) - 1 && isalpha (c); psize++)\n+    {\n+      pbuf[psize] = c;\n+      c = getc (file);\n+    }\n+\n+  pbuf[psize] = 0;\n+\n+  if (strcmp (pbuf, \"interrupt\") == 0)\n+    pragma_interrupt = 1;\n+\n+  if (strcmp (pbuf, \"saveall\") == 0)\n+    pragma_saveall = 1;\n+\n+  return c;\n+}\n+\f\n+/* If the next arg with MODE and TYPE is to be passed in a register, return\n+   the rtx to represent where it is passed.  CUM represents the state after\n+   the last argument.  NAMED is not used.  */\n+\n+rtx\n+function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  rtx result = 0;\n+  int libcall = 0;\n+\n+  /* Right now reload has a problem with reg passing with small reg\n+     classes.  */\n+\n+  if (cum->libcall || (named && TARGET_QUICKCALL))\n+    libcall = 1;\n+\n+  if (TARGET_NOQUICK)\n+    libcall = 0;\n+\n+  if (mode != VOIDmode && libcall && mode != DFmode && mode != SFmode)\n+    {\n+      switch (cum->nbytes)\n+\t{\n+\tcase 0:\n+\t  result = gen_rtx (REG, mode, 0);\n+\t  break;\n+\tcase 2:\n+\t  result = gen_rtx (REG, mode, 1);\n+\t  break;\n+\tcase 4:\n+\t  result = gen_rtx (REG, mode, 4);\n+\t  break;\n+\tcase 6:\n+\t  result = gen_rtx (REG, mode, 5);\n+\t  break;\n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+  return result;\n+}\n+\n+/* Documentation for the machine specific operand escapes:\n+\n+   'C' print (operand - 2).\n+   'E' low byte of reg or -ve lsb of constant\n+   'F' high byte of reg of -ve  msb of constant\n+\n+   'G' negate constant\n+   'L' fake label, changed after used twice.\n+   'M' turn a 'M' constant into its negative mod 2.\n+   'T' print operand as a word\n+   'V' print log2 of constant - used for bset instructions\n+   'X' 8 bit register or other operand\n+\n+   'Y' print either l or h depending on whether last 'Z' operand < 8 or >= 8.\n+   'Z' print int & 7\n+\n+   'e' first word of 32 bit value\n+   'f' second word of 32 bit value\n+\n+   'j' print operand as condition code.\n+   'k' print operand as reverse condition code.\n+\n+   's' low byte of 16 bit value\n+   't' high byte of 16 bit value\n+\n+   'w' 1st byte of 32 bit value           zzzzzzzz yyyyyyyy xxxxxxxx wwwwwwww\n+   'x' 2nd byte of 32 bit value\n+   'y' 3rd byte of 32 bit value\n+   'z' 4th byte of 32 bit value\n+\n+ */\n+\n+/* Return assembly language string which identifies a comparison type.  */\n+\n+char *\n+cond_string (code)\n+     enum rtx_code code;\n+{\n+  switch (code)\n+    {\n+    case NE:\n+      return \"ne\";\n+    case EQ:\n+      return \"eq\";\n+    case GE:\n+      return \"ge\";\n+    case GT:\n+      return \"gt\";\n+    case LE:\n+      return \"le\";\n+    case LT:\n+      return \"lt\";\n+    case GEU:\n+      return \"hs\";\n+    case GTU:\n+      return \"hi\";\n+    case LEU:\n+      return \"ls\";\n+    case LTU:\n+      return \"lo\";\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Print operand X using operand code CODE to assembly language output file\n+   FILE.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  /* This is used to general unique labels for the 'L' code.  */\n+  static int lab = 1000;\n+\n+  /* This is used for communication between the 'P' and 'U' codes.  */\n+  static char *last_p;\n+\n+  /* This is used for communication between the 'Z' and 'Y' codes.  */\n+  static int bitint;\n+\n+  switch (code)\n+    {\n+    case 'L':\n+      /* 'L' must always be used twice in a single pattern.  It generates\n+\t the same lable twice, and then will generate a unique label the\n+\t next time it is used.  */\n+      asm_fprintf (file, \"tl%d\", (lab++) / 2);\n+      break;\n+\n+    case 'X':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n+      else\n+\tgoto def;\n+      break;\n+\n+    case 'G':\n+      if (GET_CODE (x) != CONST_INT)\n+\tabort ();\n+      fprintf (file, \"#%d\", 0xff & (-INTVAL (x)));\n+      break;\n+\n+    case 'T':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", names_big[REGNO (x)]);\n+      else\n+\tgoto def;\n+      break;\n+\n+    case 'w':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", INTVAL (x) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 2));\n+      break;\n+\n+    case 'x':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 8) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 3));\n+      break;\n+\n+    case 'y':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 16) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n+      break;\n+\n+    case 'z':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 24) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 1));\n+      break;\n+\n+      /* FOR 16 bits.  */\n+    case 't':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 8) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 1));\n+      break;\n+\n+    case 's':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x)) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n+      break;\n+\n+    case 'u':\n+      if (GET_CODE (x) != CONST_INT)\n+\tabort ();\n+      fprintf (file, \"%d\", INTVAL (x));\n+      break;\n+\n+    case 'Z':\n+      bitint = INTVAL (x);\n+      fprintf (file, \"#%d\", bitint & 7);\n+      break;\n+\n+    case 'Y':\n+      fprintf (file, \"%c\", bitint > 7 ? 'h' : 'l');\n+      break;\n+\n+    case 'O':\n+      bitint = exact_log2 ((~INTVAL (x)) & 0xff);\n+      if (bitint == -1)\n+\tabort ();\n+      fprintf (file, \"#%d\", bitint & 7);\n+      break;\n+\n+    case 'V':\n+      bitint = exact_log2 (INTVAL (x));\n+      if (bitint == -1)\n+\tabort ();\n+      fprintf (file, \"#%d\", bitint & 7);\n+      break;\n+\n+    case 'P':\n+      if (REGNO (XEXP (XEXP (x, 0), 0)) == STACK_POINTER_REGNUM)\n+\t{\n+\t  last_p = \"\";\n+\t  fprintf (file, \".w\");\n+\t}\n+      else\n+\t{\n+\t  last_p = \"l\";\n+\t  fprintf (file, \".b\");\n+\t}\n+      break;\n+\n+    case 'U':\n+      fprintf (file, \"%s%s\", names_big[REGNO (x)], last_p);\n+      break;\n+\n+    case 'M':\n+      /* For -4 and -2, the other 2 is handled separately.  */\n+      switch (INTVAL (x))\n+\t{\n+\tcase -2:\n+\tcase -4:\n+\t  fprintf (file, \"#2\");\n+\t  break;\n+\tcase -1:\n+\tcase -3:\n+\t  fprintf (file, \"#1\");\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case 'e':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t  break;\n+\tcase MEM:\n+\t  x = adj_offsettable_operand (x, 0);\n+\t  print_operand (file, x, 0);\n+\t  break;\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#%d\", ((INTVAL (x) >> 16) & 0xffff));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t  break;\n+\t}\n+      break;\n+\n+    case 'f':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%s\", names_big[REGNO (x) + 1]);\n+\t  break;\n+\n+\tcase MEM:\n+\t  x = adj_offsettable_operand (x, 2);\n+\t  print_operand (file, x, 0);\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#%d\", INTVAL (x) & 0xffff);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case 'C':\n+      fprintf (file, \"#%d\", INTVAL (x) - 2);\n+      break;\n+\n+    case 'E':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%sl\", names_big[REGNO (x)]);\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#%d\", (-INTVAL (x)) & 0xff);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case 'F':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%sh\", names_big[REGNO (x)]);\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#%d\", ((-INTVAL (x)) & 0xff00) >> 8);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case 'j':\n+      asm_fprintf (file, cond_string (GET_CODE (x)));\n+      break;\n+\n+    case 'k':\n+      asm_fprintf (file, cond_string (reverse_condition (GET_CODE (x))));\n+      break;\n+    def: ;\n+    default:\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t  break;\n+\n+\tcase MEM:\n+\t  fprintf (file, \"@\");\n+\t  output_address (XEXP (x, 0));\n+\t  break;\n+\n+\tcase CONST_INT:\n+\tcase SYMBOL_REF:\n+\tcase CONST:\n+\tcase LABEL_REF:\n+\t  fprintf (file, \"#\");\n+\t  print_operand_address (file, x);\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Output assembly language output for the address ADDR to FILE.  */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fprintf (file, \"%s\", names_big[REGNO (addr)]);\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"-%s\", names_big[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_INC:\n+      fprintf (file, \"%s+\", names_big[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case PLUS:\n+      fprintf (file, \"(\");\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  /* reg,foo */\n+\t  print_operand_address (file, XEXP (addr, 1));\n+\t  fprintf (file, \",\");\n+\t  print_operand_address (file, XEXP (addr, 0));\n+\t}\n+      else\n+\t{\n+\t  /* foo+k */\n+\t  print_operand_address (file, XEXP (addr, 0));\n+\t  fprintf (file, \"+\");\n+\t  print_operand_address (file, XEXP (addr, 1));\n+\t}\n+      fprintf (file, \")\");\n+      break;\n+\n+    case CONST_INT:\n+      if (INTVAL (addr) < 0)\n+\t{\n+\t  int v = -INTVAL (addr);\n+\n+\t  fprintf (file, \"-%d\", v);\n+\t}\n+      else\n+\tfprintf (file, \"%d\", INTVAL (addr));\n+      break;\n+\n+    default:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\f\n+/* Output to FILE a reference to the user-level label NAME.\n+   Strip off the section name if any.  It is separated from the label name\n+   by a space.  */\n+\n+void\n+asm_output_labelref (file, name)\n+     FILE *file;\n+     char *name;\n+{\n+  char *p;\n+\n+  fputc ('_', file);\n+\n+  for (p = name; *p; p++)\n+    {\n+      if (*p == ' ')\n+\t{\n+\t  /* If we found a space in the name, then we've skipped over the\n+\t     section encoding.  */\n+\t  fputs (p + 1, file);\n+\t  return;\n+\t}\n+    }\n+\n+  /* No space, so no section.  */\n+  fputs (name, file);\n+}\n+\n+/* Output all insn addresses and their sizes into the assembly language\n+   output file.  This is helpful for debugging whether the length attributes\n+   in the md file are correct.  This is not meant to be a user selectable\n+   option.  */\n+\n+void\n+final_prescan_insn (insn, operand, num_operands)\n+     rtx insn, *operand;\n+     int num_operands;\n+{\n+  /* This holds the last insn address.  */\n+  static int last_insn_address = 0;\n+\n+  int uid = INSN_UID (insn);\n+\n+  if (TARGET_ADDRESSES)\n+    {\n+      fprintf (asm_out_file, \"; %d %d\\n\", insn_addresses[uid],\n+\t       insn_addresses[uid] - last_insn_address);\n+      last_insn_address = insn_addresses[uid];\n+    }\n+}\n+\n+static void\n+shift_n_bits (lval, operand, f, notzero)\n+     rtx lval;\n+     rtx operand;\n+     rtx (*f) ();\n+     int notzero;\n+{\n+  rtx label = gen_label_rtx ();\n+  rtx bot = gen_label_rtx ();\n+\n+  if (! notzero)\n+    {\n+      /* Have to put a zero test at the top.  */\n+      emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, lval));\n+      emit_jump_insn (gen_beq (bot));\n+    }\n+  emit_label (label);\n+  f (operand);\n+  emit_insn (gen_rtx (SET, QImode, lval,\n+\t\t      gen_rtx (MINUS, QImode, lval, const1_rtx)));\n+  emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, lval));\n+  emit_jump_insn (gen_bne (label));\n+\n+  emit_label (bot);\n+  /* We can't end an expand with a label.  */\n+  emit_move_insn (operand, operand);\n+}\n+\n+int\n+can_shift (code, operands, f, limit, fby_eight)\n+     int code;\n+     rtx operands[];\n+     rtx (*f) ();\n+     int limit;\n+     rtx (*fby_eight) ();\n+{\n+  extern int rtx_equal_function_value_matters;\n+\n+  emit_move_insn (operands[0], operands[1]);\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx lval;\n+\n+      /* Can't define expand a loop after rtl generation.  */\n+      if (! rtx_equal_function_value_matters)\n+\treturn 0;\n+\n+      lval = gen_reg_rtx (QImode);\n+\n+      convert_move (lval, operands[2], 1);\n+      shift_n_bits (lval, operands[0], f, 0);\n+    }\n+  else\n+    {\n+      int i;\n+\n+      i = INTVAL (operands[2]);\n+      if (i >= 8 && fby_eight)\n+\t{\n+\t  fby_eight (operands[0]);\n+\t  i -= 8;\n+\t}\n+      if (i > limit)\n+\t{\n+\t  rtx lval;\n+\n+\t  /* Can't define expand a loop after rtl generation.  */\n+\t  if (! rtx_equal_function_value_matters)\n+\t    return 0;\n+\t  lval = gen_reg_rtx (QImode);\n+\t  emit_move_insn (lval, gen_rtx (CONST_INT, VOIDmode, i));\n+\t  shift_n_bits (lval, operands[0], f, 1);\n+\t}\n+      else\n+\t{\n+\t  while (i--)\n+\t    f (operands[0]);\n+\t}\n+    }\n+  return 1;\n+}\n+\n+int\n+domovsi (operands)\n+     rtx operands[];\n+{\n+  rtx src = operands[1];\n+  rtx dst = operands[0];\n+\n+  if (push_operand (dst, GET_MODE (dst)))\n+    {\n+      /* Source must be a reg.  */\n+      if (! REG_P (src))\n+\t{\n+\t  rtx tmp = gen_reg_rtx (GET_MODE (dst));\n+\n+\t  emit_move_insn (tmp, src);\n+\t  operands[1] = tmp;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+int\n+io (FROM, TO)\n+{\n+  int OFFSET = 0;\n+\n+  if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\n+    (OFFSET) = 2 + frame_pointer_needed * 2;\n+  else\n+    {\n+      int regno;\n+      int offset = 0;\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif ((regs_ever_live[regno]\n+\t     && (! call_used_regs[regno] || regno == FRAME_POINTER_REGNUM)))\n+\t  offset += 2;\n+\n+      (OFFSET) = offset + get_frame_size ();\n+\n+      if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\n+\t(OFFSET) += 2;\t\t/* Skip saved PC.  */\n+    }\n+  return OFFSET;\n+}"}, {"sha": "65ff8e54ab5c2e5fb75ef09db34b8399a4d480c2", "filename": "gcc/config/h8300/h8300.h", "status": "added", "additions": 1109, "deletions": 0, "changes": 1109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=07aae5c24ee50c1d62d531c87f925fdee4efadaa", "patch": "@@ -0,0 +1,1109 @@\n+/* Definitions of target machine for GNU compiler. \n+   Hitachi H8/300 version generating coff \n+   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+   Contributed by Steve Chamberlain (sac@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-D__H8300__ -D_DOUBLE_IS_32BITS\"\n+\n+#define LIB_SPEC \"%{mrelax:-relax} %{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (Hitachi H8/300)\");\n+\f\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"int32\",8},\t\\\n+    {\"long16\",16},\t\\\n+    {\"double64\",32},\t\\\n+    {\"addresses\",64 },\t\\\n+    {\"quickcall\",128},  \\\n+    {\"slowbyte\",256},  \\\n+    {\"noquick\",512},  \\\n+    {\"relax\",1024},  \\\n+    { \"\", TARGET_DEFAULT}}\n+\n+#define OPTIMIZATION_OPTIONS(OPTIMIZE)          \\\n+{                                               \\\n+  obey_regdecls = 0;                            \\\n+  flag_omit_frame_pointer = (OPTIMIZE > 1);     \\\n+}\n+\n+#define OVERRIDE_OPTIONS                        \\\n+{                                               \\\n+  flag_no_function_cse = 1;                     \\\n+}\n+\n+#define TARGET_INT32 \t (target_flags & 8)\n+#define TARGET_LONG16 \t (target_flags & 16)\n+#define TARGET_DOUBLE32  (!(target_flags & 32))\n+#define TARGET_ADDRESSES (target_flags & 64)\n+#define TARGET_QUICKCALL (target_flags & 128)\n+#define TARGET_SLOWBYTE  (target_flags & 256)\n+#define TARGET_NOQUICK   (target_flags & 512)\n+\n+/* Default target_flags if no switches specified.  */\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+#define TARGET_NO_IMPORT (target_flags & MASK_NO_IMPORT)\n+\f\n+/* Target machine storage layout.  */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the H8/300.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on the H8/300.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.  \n+\n+   This is true on an H8/300 (actually we can make it up, but we choose to\n+   be consistent.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+#define UNITS_PER_PTR 2\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD \t16\n+#define MAX_BITS_PER_WORD 16\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 2\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 16\n+\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE (TARGET_INT32 ? 32 : 16)\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE (TARGET_DOUBLE32 ? 32 : 64)\n+#define FLOAT_TYPE_SIZE 32\n+#define LONG_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE\n+\n+#define MAX_FIXED_MODE_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 16\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY (16)\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS  0\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 16\n+\n+/* No structure field wants to be aligned rounder than this.  */\n+#define BIGGEST_FIELD_ALIGNMENT 16\n+\n+/* The stack goes in 16 bit lumps.  */\n+#define STACK_BOUNDARY 16\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  \n+\n+   Reg 8 does not correspond to any hardware register, but instead\n+   appears in the RTL as an argument pointer prior to reload, and is\n+   eliminated during reloading in favor of either the stack or frame\n+   pointer.  */\n+#define FIRST_PSEUDO_REGISTER 9\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator. \n+\n+   r7 is the stack pointer, r8 is the arg pointer.  */\n+#define FIXED_REGISTERS \\\n+   {  0,0,0,0,  0,0,0,1, 1 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you\n+   like.  \n+\n+   The H8/300 destroys r0, r1, r4 and r5.  */\n+\n+#define CALL_USED_REGISTERS \\\n+    {1,1,0,0,  1,1,0,1, 1 }\n+\n+/* This is the order in which to allocate registers\n+   normally.  */\n+#define REG_ALLOC_ORDER { 0, 1, 4, 5, 2, 3, 6, 7, 8 }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE.\n+\n+   If an even reg, then anything goes.  Otherwise the mode must be QI\n+   or HI.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+ ((((REGNO) & 1) == 0) || (MODE == HImode) || (MODE == QImode))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  ((MODE1) == (MODE2))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* H8/300 pc is not overloaded on a register.  */\n+/*#define PC_REGNUM 15*/\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 7\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 6\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 8\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The H8/300 has only one kind of register, but we mustn't do byte by\n+   byte operations on the sp, so we keep it as a different class.  */\n+\n+enum reg_class { NO_REGS, LONG_REGS, GENERAL_REGS, SP_REG, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.  */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"LONG_REGS\", \"GENERAL_REGS\", \"SP_REG\", \"ALL_REGS\", \"LIM_REGS\"}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS  \t\t\t\t\\\n+{     0,   \t\t\t/* No regs      */\t\\\n+   0x7f,                        /* LONG_REGS    */      \\\n+   0x7f,\t\t\t/* GENERAL_REGS */\t\\\n+   0x80,\t\t\t/* SP_REG       */     \t\\\n+   0xff,\t\t\t/* ALL_REGS \t*/\t\\\n+}\n+\n+  /* The same information, inverted:\n+     Return the class number of the smallest class containing\n+     reg number REGNO.  This could be a conditional expression\n+     or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\\\n+ ((REGNO) >= STACK_POINTER_REGNUM\t\t\\\n+  ? ((REGNO) >= FRAME_POINTER_REGNUM\t\t\\\n+     ? SP_REG\t\t\t\t\t\\\n+     : GENERAL_REGS)\t\t\t\t\\\n+  : LONG_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS  GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+ ((C) == 'a' ? SP_REG : (((C) == 'l') ? LONG_REGS : NO_REGS))\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\\\n+  ((C) == 'I' ? (VALUE) == 0 : \t\t\t\t\\\n+   (C) == 'J' ? (((VALUE) & 0xff00) == 0) : \t\t\\\n+   (C) == 'K' ? ((VALUE) == 1 || (VALUE) == 2) :\t\\\n+   (C) == 'L' ? ((VALUE) == -1 || (VALUE) == -2) :      \\\n+   (C) == 'M' ? ((VALUE) == 3 || (VALUE) == 4) :        \\\n+   (C) == 'N' ? ((VALUE) == -3 || (VALUE) == -4) :      \\\n+   (C) == 'O' ? (potg8 (VALUE)) :\t\t\t\\\n+   (C) == 'P' ? (potl8 (VALUE)) :\t\t\t\\\n+   0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself. \n+\n+     `G' is a floating-point zero.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)          \\\n+  ((C) == 'G' ? ((VALUE) == CONST0_RTX (DFmode)         \\\n+                 || (VALUE) == CONST0_RTX (DFmode))     \\\n+   : 0)\n+\n+/* Extra constraints - 'U' if for an operand valid for a bset\n+   destination; i.e. a register or register indirect target.  */\n+#define EXTRA_CONSTRAINT(OP, C) \t\t\t\\\n+  (((C) == 'U')\t\t\t\t\t\t\\\n+   ? ((GET_CODE (OP) == REG) \t\t\t\t\\\n+      || ((GET_CODE (OP) == MEM) \t\t\t\\\n+\t  && GET_CODE (XEXP (OP, 0)) == REG))\t\t\\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+/* On the H8, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is always enough.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Any SI register to register move may need to be reloaded, \n+   so define REGISTER_MOVE_COST to be > 2 so that reload never\n+   shortcuts.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) 3\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+\n+   On the H8/300, @-sp really pushes a byte if you ask it to - but that's\n+   dangerous, so we claim that it always pushes a word, then we catch\n+   the mov.b rx,@-sp and turn it into a mov.w rx,@-sp on output.  */\n+#define PUSH_ROUNDING(BYTES)   (((BYTES) + 1) & ~1)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+\n+/* Is equal to the size of the saved fp + pc, even if an fp isn't\n+   saved since the value is used before we know.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the H8/300 the return does not pop anything.  */\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   We have two registers that can be eliminated on the i386.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer. */\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},   \\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) OFFSET = io (FROM,TO)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0. \n+   \n+   On the H8/300 the return value is in R0/R1.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+ \tgen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On the H8/300 the return value is in R0/R1.  */\n+#define LIBCALL_VALUE(MODE) \\\n+\tgen_rtx (REG, MODE, 0)\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the H8/300, R0 is the only register thus used.  */\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the H8/300, no registers are used in this way.  */\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE 0\n+#define STRUCT_VALUE_REGNUM 0\n+#define STRUCT_VALUE_INCOMING 0\n+\n+/* Return true if X should be returned in memory.  */\n+#define RETURN_IN_MEMORY(X) (GET_MODE_SIZE (TYPE_MODE (X)) > 4)\n+\n+/* When defined, the compiler allows registers explicitly used in the\n+   rtl to be used as spill registers but prevents the compiler from\n+   extending the lifetime of these registers.  */\n+#define SMALL_REGISTER_CLASSES\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   Hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the H8/300, this is a two item struct, the first is the number of bytes\n+   scanned so far, the second the name of any libcall.  */\n+\n+#define CUMULATIVE_ARGS struct cum_arg\n+struct cum_arg { int nbytes; struct rtx_def* libcall; };\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the H8/300, the offset starts at 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+\t((CUM).nbytes = 0, (CUM).libcall = LIBNAME)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+\n+   All sizes rounded up to even bytes.  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)    \\\n+ ((CUM).nbytes += ((MODE) != BLKmode                    \\\n+\t\t   ? (GET_MODE_SIZE (MODE) + 1) & ~1    \\\n+\t\t   : (int_size_in_bytes (TYPE) + 1) & ~1))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the H8/300 all normal args are pushed, we pass args to named\n+   functions in registers.  */\n+\n+extern struct rtx_def *function_arg();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED)\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+ function_prologue (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \t\\\n+   fprintf (FILE, \"\\t; not implemented\\n\", (LABELNO));\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+ fprintf (FILE, \"\\t; not implemented \\n\", LABELNO, LABELNO);\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\\\n+ fprintf (FILE, \"\\t; not implemented\\n\");\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 0\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\\\n+ function_epilogue (FILE, SIZE)\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) \t\t\\\n+ fprintf (FILE, \" trampolines not implemented\\n\");\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 15\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+/* We copy the register-mask from the function's pure code\n+   to the start of the trampoline.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, TRAMP),\t\t\t\t\\\n+\t\t  gen_rtx (MEM, HImode, FNADDR));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), CXT);\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 11)),\t\\\n+\t\t  plus_constant (FNADDR, 2));\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.\n+   Although the H8/300 has pre decrement destinations and post\n+   increment sources on moves, they are not general enough to be much\n+   use to gcc */\n+\n+/*#define HAVE_POST_INCREMENT*/\n+/*#define HAVE_POST_DECREMENT */\n+\n+/*#define HAVE_PRE_DECREMENT*/\n+/*#define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+ \n+#define REGNO_OK_FOR_INDEX_P(regno)  0\n+\n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) (GET_CODE (X) != CONST_DOUBLE)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) 1\n+\n+#define REG_OK_FOR_INDEX_P_STRICT(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_BASE_P_STRICT(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually\n+   machine-independent.  \n+\n+\n+   On the H8/300, a legitimate address has the form\n+   REG, REG+CONSTANT_ADDRESS or CONSTANT_ADDRESS.  */\n+\n+/* Accept either REG or SUBREG where a register is valid.  */\n+  \n+#define RTX_OK_FOR_BASE_P(X)                                    \\\n+  ((REG_P (X) && REG_OK_FOR_BASE_P (X))                         \\\n+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))         \\\n+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)         \\\n+  if (RTX_OK_FOR_BASE_P (X)) goto ADDR;                 \\\n+  if (CONSTANT_ADDRESS_P (X)) goto ADDR;                \\\n+  if (GET_CODE (X) == PLUS                              \\\n+      && CONSTANT_ADDRESS_P (XEXP (X, 1))               \\\n+      && RTX_OK_FOR_BASE_P (XEXP (X, 0))) goto ADDR;\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the H8/300, don't do anything.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+\n+   On the H8/300, the predecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand)\n+   and all indexed address depend thus (because the index scale factor\n+   is the length of the operand).  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\t\\\n+ if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC) goto LABEL;\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE HImode\n+\n+/* Define this if the case instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/*#define CASE_VECTOR_PC_RELATIVE*/\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+#define CASE_DROPS_THROUGH\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.\n+\n+   On the H8/300, sign extension is expensive, so we'll say that chars\n+   are unsigned.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 2\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS TARGET_SLOWBYTE\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode HImode\n+\n+#define SIZE_TYPE \"unsigned int\"\n+#define PTRDIFF_TYPE \"int\"\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \t\\\n+    case CONST_INT:\t\t\t\t\\\n+      switch (INTVAL (RTX))\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\tcase 0:\t\t\t\t\t\\\n+\tcase 1:\t\t\t\t\t\\\n+\tcase 2:\t\t\t\t\t\\\n+\tcase -1:\t\t\t\t\\\n+\tcase -2:\t\t\t\t\\\n+\t  return 0;\t\t\t\t\\\n+\tdefault:\t\t\t\t\\\n+          return 1;\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+    case CONST:\t\t\t\t\t\\\n+    case LABEL_REF:\t\t\t\t\\\n+    case SYMBOL_REF:\t\t\t\t\\\n+      return 3;\t\t\t\t\t\\\n+    case CONST_DOUBLE:\t\t\t\t\\\n+      return 20;\t\t\t\t\n+\n+#define BRANCH_COST 2\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  */\n+\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE) \t\t\\\n+   case MOD: \t\t\t\t\t\\\n+   case DIV: \t\t\t\t\t\\\n+     return 60;\t\t\t\t\t\\\n+   case MULT: \t\t\t\t\t\\\n+     return 20; \t\t\t\t\\\n+   case LSHIFT:\t\t\t\t\t\\\n+   case ASHIFT:\t\t\t\t\t\\\n+   case ASHIFTRT:\t\t\t\t\\\n+   case LSHIFTRT:\t\t\t\t\\\n+   case ROTATE:\t\t\t\t\t\\\n+   case ROTATERT:\t\t\t\t\\\n+    if (GET_MODE (RTX) == HImode) \t\t\\\n+      return 2; \t\t\t\t\\\n+    return 10; \t\t\t\t\t\\\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+  \n+/* Store in cc_status the expressions that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP. Do not\n+   alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \t\t\t\t\t\\\n+switch (get_attr_cc (INSN))\t\t\t\t\t\t\\\n+  {\t        \t\t\t\t\t\t\t\\\n+  case CC_NONE:\t\t\t\t\t\t\t\t\\\n+    /* Insn does not affect the CC at all.  */\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case CC_NONE_0HIT:\t\t\t\t\t\t\t\\\n+    /* Insn does not change the CC, but the 0'th operand has been\t\\\n+       changed.  */\t\t\t\t        \t\t\\\n+    if (cc_status.value1 != 0\t\t\t\t\t\t\\\n+        && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\\\n+    cc_status.value1 = 0;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (cc_status.value2 != 0\t\t\t\t\t\t\\\n+        && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\\\n+    cc_status.value2 = 0;\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case CC_SET:\t\t\t\t\t\t\t\t\\\n+    /* Insn sets CC to recog_operand[0], but overflow is impossible.  */\\\n+    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n+    cc_status.flags |= CC_NO_OVERFLOW;\t\t\t\t\t\\\n+    cc_status.value1 = recog_operand[0];\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case CC_COMPARE:\t\t\t\t\t\t\t\\\n+    /* The insn is a compare instruction.  */\t\t\t\t\\\n+    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n+    cc_status.value1 = recog_operand[0];\t\t\t\t\\\n+    cc_status.value1 = recog_operand[1];\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case CC_WHOOPS:\t\t\t\t\t\t\t\\\n+  case CC_CLOBBER:\t\t\t\t\t\t\t\\\n+    /* Insn clobbers CC.  */\t\t\t\t\t\t\\\n+    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\\n+    return NO_OV;\t\t\t\t\t\t\\\n+  return NORMAL;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Control the assembler format that we output.  */\n+\n+#define ASM_IDENTIFY_GCC /* nothing */\n+\n+/* Output at beginning of assembler file.  */\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \";\\tGCC For the Hitachi H8/300\\n\");\t\t\\\n+  if (optimize)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"; -O%d\\n\", optimize);\t\t\t\\\n+  fprintf (FILE, \"\\n\\n\");\t\t\t\t\t\\\n+  output_file_directive (FILE, main_input_filename);\t\t\\\n+}\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.end\\n\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \t\"; #APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \t\"; #NO_APP\\n\"\n+\n+#define FILE_ASM_OP \t\"\\t.file\\n\"\n+#define IDENT_ASM_OP \t\"\\t.ident\\n\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP \"\\t.section .data\"\n+#define BSS_SECTION_ASM_OP  \"\\t.section .bss\"\n+\n+#define EXTRA_SECTIONS in_user\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+user_section (name)\t\t\t\t\t\\\n+    char *name;\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  fprintf (asm_out_file, \"\\t.section\\t%s\\n\", name);\t\\\n+  in_section = in_user;\t\t\t\t\t\\\n+}\n+\n+#define MAX_TEXT_ALIGN 16\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"ap\"}\n+\n+/* How to renumber registers for dbx and gdb.\n+   H8/300 needs no change in the numeration.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+#define SDB_DEBUGGING_INFO\n+#define SDB_DELIM\t\"\\n\"\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/*#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) */\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/*#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+  ASM_OUTPUT_LABEL(FILE, NAME); */\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\\\n+ asm_output_labelref (FILE, NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   It is .dfloat or .gfloat, depending.  */\n+\n+/*#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.double %.20e\\n\", (VALUE))*/\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.float %.20e\\n\", \t\t\\\n+\t   ((VALUE) > 1e30 ? 1e30\t\t\\\n+\t    : ((VALUE) < -1e30) ? -1e30 : (double) ((float) VALUE)));\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+#define ASM_OUTPUT_INT(FILE, VALUE)  \t\t\\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)  \t\t\\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)  \t\t\\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \t\t\\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)  \t\\\n+  fprintf (FILE, \"\\tpush %s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)  \t\\\n+  fprintf (FILE, \"\\tpop\\t%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute. */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  asm_fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word.w .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\\\n+  if ((LOG) != 0)\t\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"%s\\t \\\"%s\\\"\\n\", IDENT_ASM_OP, NAME)\n+\n+#define ASM_OUTPUT_SKIP(FILE, SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \t\\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t \\\n+  ((CODE) == '#')\n+\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\\\n+ print_operand (FILE, X, CODE)\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in h8300.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \t \\\n+ print_operand_address (FILE, ADDR)\n+\n+#define HANDLE_PRAGMA(FILE) handle_pragma (FILE)\n+\n+#define FINAL_PRESCAN_INSN(insn, operand, nop)\t\\\n+ final_prescan_insn (insn, operand, nop)\n+\n+/* Define this macro if GNU CC should generate calls to the System V\n+   (and ANSI C) library functions `memcpy' and `memset' rather than\n+   the BSD functions `bcopy' and `bzero'.  */\n+#define TARGET_MEM_FUNCTIONS 1\n+\n+/* Define subroutines to call to handle various operations not\n+   supported in the hardware */\n+\n+#define DIVHI3_LIBCALL \"__divhi3\"\n+#define UDIVHI3_LIBCALL \"__udivhi3\"\n+#define MULHI3_LIBCALL \"__mulhi3\"\n+#define MODHI3_LIBCALL \"__modhi3\"\n+#define UMODHI3_LIBCALL \"__umodhi3\"\n+#define ADDSI3_LIBCALL \"__addsi3\"\n+#define SUBSI3_LIBCALL \"__subsi3\"\n+\n+#define MOVE_RATIO 3\n+\n+#if 0\n+/* This stuff doesn't work currently.  */\n+#undef SELECT_SECTION\n+#define SELECT_SECTION(DECL,RELOC) select_section(DECL, RELOC)\n+#define SELECT_FUNCTION_SECTION(a,b) SELECT_SECTION(a,b)\n+#endif"}, {"sha": "a37e5d1334ffec92b883bd7820d3b3fdc4d4a600", "filename": "gcc/config/h8300/t-h8300", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Ft-h8300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Ft-h8300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ft-h8300?ref=07aae5c24ee50c1d62d531c87f925fdee4efadaa", "patch": "@@ -0,0 +1,5 @@\n+LIBGCC1 = libgcc1.null\n+T_CFLAGS = -DDONT_HAVE_STDIO -DDONT_HAVE_SETJMP \n+# we do not have DF or DI types, so fake out the libgcc2 compilation\n+LIBGCC2_CFLAGS=-O -DDF=SF -DDI=SI $(GCC_CFLAGS) \n+LIB2FUNCS_EXTRA ="}, {"sha": "cbd49121abbce7257b76a605c8a54a021f0e43b4", "filename": "gcc/config/h8300/xm-h8300.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Fxm-h8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07aae5c24ee50c1d62d531c87f925fdee4efadaa/gcc%2Fconfig%2Fh8300%2Fxm-h8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fxm-h8300.h?ref=07aae5c24ee50c1d62d531c87f925fdee4efadaa", "patch": "@@ -0,0 +1,45 @@\n+/* Configuration for GNU C-compiler for H8/300.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 16\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* If compiled with GNU C, use the built-in alloca */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#else\n+#define USE_C_ALLOCA\n+#endif\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+"}]}