{"sha": "c300e251f5b22d15b126f3c643cd55a119994e48", "node_id": "C_kwDOANBUbNoAKGMzMDBlMjUxZjViMjJkMTViMTI2ZjNjNjQzY2Q1NWExMTk5OTRlNDg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-02-07T21:10:20Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-02-07T21:10:20Z"}, "message": "analyzer: fix -Wanalyzer-use-of-uninitialized-value false +ve on \"read\" [PR108661]\n\nMy integration testing shows many false positives from\n-Wanalyzer-use-of-uninitialized-value.\n\nOne cause turns out to be that as of r13-1404-g97baacba963c06\nfd_state_machine::on_stmt recognizes calls to \"read\", and returns true,\nso that region_model::on_call_post doesn't call handle_unrecognized_call\non them, and so the analyzer erroneously \"thinks\" that the buffer\npointed to by \"read\" is never touched by the \"read\" call.\n\nThis works for \"fread\" because sm-file.cc implements kf_fread, which\nhandles calls to \"fread\" by clobbering the buffer pointed to.  In the\nlong term we should probably be smarter about this and bifurcate the\nanalysis to consider e.g. errors vs full reads vs partial reads, etc\n(which I'm tracking in PR analyzer/108689).\n\nIn the meantime, this patch adds a kf_read for \"read\" analogous to the\none for \"fread\", fixing 6 false positives seen in git-2.39.0 and\n2 in haproxy-2.7.1.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108661\n\t* sm-fd.cc (class kf_read): New.\n\t(register_known_fd_functions): Register \"read\".\n\t* sm-file.cc (class kf_fread): Update comment.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108661\n\t* gcc.dg/analyzer/fread-pr108661.c: New test.\n\t* gcc.dg/analyzer/read-pr108661.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "0783876513f134e843560857ec62015d3048882d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0783876513f134e843560857ec62015d3048882d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c300e251f5b22d15b126f3c643cd55a119994e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c300e251f5b22d15b126f3c643cd55a119994e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c300e251f5b22d15b126f3c643cd55a119994e48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c300e251f5b22d15b126f3c643cd55a119994e48/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c36f3da534e7f411c5bc48c5b6b660e238167480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36f3da534e7f411c5bc48c5b6b660e238167480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c36f3da534e7f411c5bc48c5b6b660e238167480"}], "stats": {"total": 116, "additions": 115, "deletions": 1}, "files": [{"sha": "d107390bc0058e807def257c1ba5c2a3d48de0a4", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=c300e251f5b22d15b126f3c643cd55a119994e48", "patch": "@@ -2659,6 +2659,38 @@ class kf_pipe : public known_function\n   unsigned m_num_args;\n };\n \n+/* Handler for \"read\".\n+     ssize_t read(int fildes, void *buf, size_t nbyte);\n+   See e.g. https://man7.org/linux/man-pages/man2/read.2.html   */\n+\n+class kf_read : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 3\n+\t    && cd.arg_is_pointer_p (1)\n+\t    && cd.arg_is_size_p (2));\n+  }\n+\n+  /* For now, assume that any call to \"read\" fully clobbers the buffer\n+     passed in.  This isn't quite correct (e.g. errors, partial reads;\n+     see PR analyzer/108689), but at least stops us falsely complaining\n+     about the buffer being uninitialized.  */\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (1);\n+    if (const region *reg = ptr_sval->maybe_get_region ())\n+      {\n+\tconst region *base_reg = reg->get_base_region ();\n+\tconst svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n+\tmodel->set_value (base_reg, new_sval, cd.get_ctxt ());\n+      }\n+  }\n+};\n+\n+\n /* Populate KFM with instances of known functions relating to\n    file descriptors.  */\n \n@@ -2672,6 +2704,7 @@ register_known_fd_functions (known_function_manager &kfm)\n   kfm.add (\"listen\", make_unique<kf_listen> ());\n   kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n   kfm.add (\"pipe2\", make_unique<kf_pipe> (2));\n+  kfm.add (\"read\", make_unique<kf_read> ());\n   kfm.add (\"socket\", make_unique<kf_socket> ());\n }\n "}, {"sha": "d99a09b76c4601ea3723b3b4bfa2ac2e3d9b4583", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=c300e251f5b22d15b126f3c643cd55a119994e48", "patch": "@@ -560,7 +560,11 @@ class kf_fgets : public known_function\n   }\n };\n \n-/* Handler for \"fread\"\".  */\n+/* Handler for \"fread\".\n+     size_t fread(void *restrict buffer, size_t size, size_t count,\n+\t\t  FILE *restrict stream);\n+   See e.g. https://en.cppreference.com/w/c/io/fread\n+   and https://www.man7.org/linux/man-pages/man3/fread.3.html */\n \n class kf_fread : public known_function\n {\n@@ -574,6 +578,10 @@ class kf_fread : public known_function\n \t    && cd.arg_is_pointer_p (3));\n   }\n \n+  /* For now, assume that any call to \"fread\" fully clobbers the buffer\n+     passed in.  This isn't quite correct (e.g. errors, partial reads;\n+     see PR analyzer/108689), but at least stops us falsely complaining\n+     about the buffer being uninitialized.  */\n   void impl_call_pre (const call_details &cd) const final override\n   {\n     region_model *model = cd.get_model ();"}, {"sha": "b51cf41ec2ae7db5de1d0e351964e4bf00c76ec0", "filename": "gcc/testsuite/gcc.dg/analyzer/fread-pr108661.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffread-pr108661.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffread-pr108661.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffread-pr108661.c?ref=c300e251f5b22d15b126f3c643cd55a119994e48", "patch": "@@ -0,0 +1,40 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern size_t fread (void *, size_t, size_t, void *);\n+\n+struct ring\n+{\n+  char buf[1024];\n+};\n+\n+int\n+test_one_large_item (void *fp)\n+{\n+  struct ring ring;\n+  int ret;\n+\n+  ret = fread(&ring, sizeof(ring), 1, fp);\n+\n+  if (ret != 1)\n+    return 1;\n+\n+  if (ring.buf[0] > 1) /* { dg-bogus \"use of uninitialized value\" } */\n+    return 2;\n+  return 3;\n+}\n+\n+int\n+test_many_small_items (void *fp)\n+{\n+  struct ring ring;\n+  int ret;\n+\n+  ret = fread(&ring, 1, sizeof(ring), fp);\n+\n+  if (ret != sizeof(ring))\n+    return 1;\n+\n+  if (ring.buf[0] > 1) /* { dg-bogus \"use of uninitialized value\" } */\n+    return 2;\n+  return 3;\n+}"}, {"sha": "70335e6fef16adddee2eb1200e08ddb50f152849", "filename": "gcc/testsuite/gcc.dg/analyzer/read-pr108661.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fread-pr108661.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c300e251f5b22d15b126f3c643cd55a119994e48/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fread-pr108661.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fread-pr108661.c?ref=c300e251f5b22d15b126f3c643cd55a119994e48", "patch": "@@ -0,0 +1,33 @@\n+typedef long int ssize_t;\n+typedef long unsigned int size_t;\n+\n+extern int open(const char* __file, int __oflag, ...) __attribute__((__nonnull__(1)));\n+extern int close(int __fd);\n+extern ssize_t read(int __fd, void* __buf, size_t __nbytes);\n+\n+struct ring\n+{\n+  char buf[1024];\n+};\n+\n+int\n+test(const char* name)\n+{\n+  struct ring ring;\n+  int fd;\n+  int ret;\n+\n+  fd = open(name, 00);\n+  if (fd < 0)\n+    return 0;\n+\n+  ret = read(fd, &ring, sizeof(ring));\n+  close(fd);\n+\n+  if (ret != sizeof(ring))\n+    return 1;\n+\n+  if (ring.buf[0] > 1) /* { dg-bogus \"use of uninitialized value\" } */\n+    return 2;\n+  return 3;\n+}"}]}