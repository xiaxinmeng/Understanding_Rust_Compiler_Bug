{"sha": "f3878205ddc2970e384ffaed3a95362763eee9fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4NzgyMDVkZGMyOTcwZTM4NGZmYWVkM2E5NTM2Mjc2M2VlZTlmZQ==", "commit": {"author": {"name": "Than McIntosh", "email": "thanm@google.com", "date": "2016-11-22T22:28:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-22T22:28:05Z"}, "message": "compiler: relocate ID encoding utilities to gofrontend\n    \n    Relocate the code that encodes/sanitizes identifiers to make them\n    assembler-friendly, moving it from the back end to the front end; the\n    decisions about when to encode an identifier and the calls to the\n    encoding helpers now take place entirely in gofrontend.\n    \n    Reviewed-on: https://go-review.googlesource.com/33424\n\n\t* go-gcc.cc (char_needs_encoding): Remove.\n\t(needs_encoding, fetch_utf8_char, encode_id): Remove.\n\t(Gcc_backend::global_variable): Add asm_name parameter.  Don't\n\tcompute asm_name here.\n\t(Gcc_backend::implicit_variable): Likewise.\n\t(Gcc_backend::implicit_variable_reference): Likewise.\n\t(Gcc_backend::immutable_struct): Likewise.\n\t(Gcc_backend::immutable_struct_reference): Likewise.\n\t* Make-lang.in (GO_OBJS): Add go/go-encode-id.o.\n\nFrom-SVN: r242726", "tree": {"sha": "3f3e5efdd02fec9f6bb7a55785fb00da33b93a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f3e5efdd02fec9f6bb7a55785fb00da33b93a4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3878205ddc2970e384ffaed3a95362763eee9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3878205ddc2970e384ffaed3a95362763eee9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3878205ddc2970e384ffaed3a95362763eee9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3878205ddc2970e384ffaed3a95362763eee9fe/comments", "author": {"login": "thanm", "id": 12280172, "node_id": "MDQ6VXNlcjEyMjgwMTcy", "avatar_url": "https://avatars.githubusercontent.com/u/12280172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thanm", "html_url": "https://github.com/thanm", "followers_url": "https://api.github.com/users/thanm/followers", "following_url": "https://api.github.com/users/thanm/following{/other_user}", "gists_url": "https://api.github.com/users/thanm/gists{/gist_id}", "starred_url": "https://api.github.com/users/thanm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thanm/subscriptions", "organizations_url": "https://api.github.com/users/thanm/orgs", "repos_url": "https://api.github.com/users/thanm/repos", "events_url": "https://api.github.com/users/thanm/events{/privacy}", "received_events_url": "https://api.github.com/users/thanm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e98cccbd85a0bc5ec6b7edf0017d98c2e96aef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98cccbd85a0bc5ec6b7edf0017d98c2e96aef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e98cccbd85a0bc5ec6b7edf0017d98c2e96aef5"}], "stats": {"total": 495, "additions": 303, "deletions": 192}, "files": [{"sha": "bbae1a9f01756ac4d7324154ceba22f1419f2be1", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -1,3 +1,15 @@\n+2016-11-22  Than McIntosh  <thanm@google.com>\n+\n+\t* go-gcc.cc (char_needs_encoding): Remove.\n+\t(needs_encoding, fetch_utf8_char, encode_id): Remove.\n+\t(Gcc_backend::global_variable): Add asm_name parameter.  Don't\n+\tcompute asm_name here.\n+\t(Gcc_backend::implicit_variable): Likewise.\n+\t(Gcc_backend::implicit_variable_reference): Likewise.\n+\t(Gcc_backend::immutable_struct): Likewise.\n+\t(Gcc_backend::immutable_struct_reference): Likewise.\n+\t* Make-lang.in (GO_OBJS): Add go/go-encode-id.o.\n+\n 2016-11-22  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::Gcc_backend): Add builtin function"}, {"sha": "67683304634863c28e2a2ce6342a6e4f81804b17", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -55,6 +55,7 @@ GO_OBJS = \\\n \tgo/expressions.o \\\n \tgo/go-backend.o \\\n \tgo/go-diagnostics.o \\\n+\tgo/go-encode-id.o \\\n \tgo/go-dump.o \\\n \tgo/go-gcc.o \\\n \tgo/go-gcc-diagnostics.o \\\n@@ -230,6 +231,7 @@ CFLAGS-go/go-gcc.o += $(GOINCLUDES)\n CFLAGS-go/go-linemap.o += $(GOINCLUDES)\n CFLAGS-go/go-sha1.o += $(GOINCLUDES)\n CFLAGS-go/go-gcc-diagnostics.o += $(GOINCLUDES)\n+CFLAGS-go/go-encode-id.o += $(GOINCLUDES)\n \n go/%.o: go/gofrontend/%.cc\n \t$(COMPILE) $(GOINCLUDES) $<"}, {"sha": "dc0041339aaa81531b810f3db656c213d98600d4", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 36, "deletions": 135, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -412,9 +412,8 @@ class Gcc_backend : public Backend\n   { return new Bvariable(error_mark_node); }\n \n   Bvariable*\n-  global_variable(const std::string& package_name,\n-\t\t  const std::string& pkgpath,\n-\t\t  const std::string& name,\n+  global_variable(const std::string& var_name,\n+\t\t  const std::string& asm_name,\n \t\t  Btype* btype,\n \t\t  bool is_external,\n \t\t  bool is_hidden,\n@@ -440,25 +439,27 @@ class Gcc_backend : public Backend\n \t\t     Location, Bstatement**);\n \n   Bvariable*\n-  implicit_variable(const std::string&, Btype*, bool, bool, bool,\n-\t\t    int64_t);\n+  implicit_variable(const std::string&, const std::string&, Btype*,\n+                    bool, bool, bool, int64_t);\n \n   void\n   implicit_variable_set_init(Bvariable*, const std::string&, Btype*,\n \t\t\t     bool, bool, bool, Bexpression*);\n \n   Bvariable*\n-  implicit_variable_reference(const std::string&, Btype*);\n+  implicit_variable_reference(const std::string&, const std::string&, Btype*);\n \n   Bvariable*\n-  immutable_struct(const std::string&, bool, bool, Btype*, Location);\n+  immutable_struct(const std::string&, const std::string&,\n+                   bool, bool, Btype*, Location);\n \n   void\n   immutable_struct_set_init(Bvariable*, const std::string&, bool, bool, Btype*,\n \t\t\t    Location, Bexpression*);\n \n   Bvariable*\n-  immutable_struct_reference(const std::string&, Btype*, Location);\n+  immutable_struct_reference(const std::string&, const std::string&,\n+                             Btype*, Location);\n \n   // Labels.\n \n@@ -550,102 +551,6 @@ get_identifier_from_string(const std::string& str)\n   return get_identifier_with_length(str.data(), str.length());\n }\n \n-// Return whether the character c is OK to use in the assembler.\n-\n-static bool\n-char_needs_encoding(char c)\n-{\n-  switch (c)\n-    {\n-    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n-    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n-    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n-    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n-    case 'Y': case 'Z':\n-    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n-    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n-    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n-    case 'y': case 'z':\n-    case '0': case '1': case '2': case '3': case '4':\n-    case '5': case '6': case '7': case '8': case '9':\n-    case '_': case '.': case '$': case '/':\n-      return false;\n-    default:\n-      return true;\n-    }\n-}\n-\n-// Return whether the identifier needs to be translated because it\n-// contains non-ASCII characters.\n-\n-static bool\n-needs_encoding(const std::string& str)\n-{\n-  for (std::string::const_iterator p = str.begin();\n-       p != str.end();\n-       ++p)\n-    if (char_needs_encoding(*p))\n-      return true;\n-  return false;\n-}\n-\n-// Pull the next UTF-8 character out of P and store it in *PC.  Return\n-// the number of bytes read.\n-\n-static size_t\n-fetch_utf8_char(const char* p, unsigned int* pc)\n-{\n-  unsigned char c = *p;\n-  if ((c & 0x80) == 0)\n-    {\n-      *pc = c;\n-      return 1;\n-    }\n-  size_t len = 0;\n-  while ((c & 0x80) != 0)\n-    {\n-      ++len;\n-      c <<= 1;\n-    }\n-  unsigned int rc = *p & ((1 << (7 - len)) - 1);\n-  for (size_t i = 1; i < len; i++)\n-    {\n-      unsigned int u = p[i];\n-      rc <<= 6;\n-      rc |= u & 0x3f;\n-    }\n-  *pc = rc;\n-  return len;\n-}\n-\n-// Encode an identifier using ASCII characters.\n-\n-static std::string\n-encode_id(const std::string id)\n-{\n-  std::string ret;\n-  const char* p = id.c_str();\n-  const char* pend = p + id.length();\n-  while (p < pend)\n-    {\n-      unsigned int c;\n-      size_t len = fetch_utf8_char(p, &c);\n-      if (len == 1 && !char_needs_encoding(c))\n-\tret += c;\n-      else\n-\t{\n-\t  ret += \"$U\";\n-\t  char buf[30];\n-\t  snprintf(buf, sizeof buf, \"%x\", c);\n-\t  ret += buf;\n-\t  ret += \"$\";\n-\t}\n-      p += len;\n-    }\n-  return ret;\n-}\n-\n // Define the built-in functions that are exposed to GCCGo.\n \n Gcc_backend::Gcc_backend()\n@@ -2580,9 +2485,8 @@ Gcc_backend::non_zero_size_type(tree type)\n // Make a global variable.\n \n Bvariable*\n-Gcc_backend::global_variable(const std::string& package_name,\n-\t\t\t     const std::string& pkgpath,\n-\t\t\t     const std::string& name,\n+Gcc_backend::global_variable(const std::string& var_name,\n+\t\t\t     const std::string& asm_name,\n \t\t\t     Btype* btype,\n \t\t\t     bool is_external,\n \t\t\t     bool is_hidden,\n@@ -2598,9 +2502,6 @@ Gcc_backend::global_variable(const std::string& package_name,\n   if ((is_external || !is_hidden) && int_size_in_bytes(type_tree) == 0)\n     type_tree = this->non_zero_size_type(type_tree);\n \n-  std::string var_name(package_name);\n-  var_name.push_back('.');\n-  var_name.append(name);\n   tree decl = build_decl(location.gcc_location(), VAR_DECL,\n \t\t\t get_identifier_from_string(var_name),\n \t\t\t type_tree);\n@@ -2611,17 +2512,12 @@ Gcc_backend::global_variable(const std::string& package_name,\n   if (!is_hidden)\n     {\n       TREE_PUBLIC(decl) = 1;\n-\n-      std::string asm_name(pkgpath);\n-      asm_name.push_back('.');\n-      asm_name.append(name);\n-      if (needs_encoding(asm_name))\n-\tasm_name = encode_id(asm_name);\n       SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n     }\n-  else if (needs_encoding(var_name))\n-    SET_DECL_ASSEMBLER_NAME(decl,\n-\t\t\t    get_identifier_from_string(encode_id(var_name)));\n+  else\n+    {\n+      SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+    }\n \n   TREE_USED(decl) = 1;\n \n@@ -2814,8 +2710,9 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n // generating GC root variables and storing the values of a slice initializer.\n \n Bvariable*\n-Gcc_backend::implicit_variable(const std::string& name, Btype* type,\n-\t\t\t       bool is_hidden, bool is_constant,\n+Gcc_backend::implicit_variable(const std::string& name,\n+                               const std::string& asm_name,\n+                               Btype* type, bool is_hidden, bool is_constant,\n \t\t\t       bool is_common, int64_t alignment)\n {\n   tree type_tree = type->get_tree();\n@@ -2857,8 +2754,8 @@ Gcc_backend::implicit_variable(const std::string& name, Btype* type,\n       SET_DECL_ALIGN(decl, alignment * BITS_PER_UNIT);\n       DECL_USER_ALIGN(decl) = 1;\n     }\n-  if (needs_encoding(name))\n-    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(encode_id(name)));\n+  if (! asm_name.empty())\n+    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n \n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n@@ -2899,7 +2796,9 @@ Gcc_backend::implicit_variable_set_init(Bvariable* var, const std::string&,\n // Return a reference to an implicit variable defined in another package.\n \n Bvariable*\n-Gcc_backend::implicit_variable_reference(const std::string& name, Btype* btype)\n+Gcc_backend::implicit_variable_reference(const std::string& name,\n+                                         const std::string& asm_name,\n+                                         Btype* btype)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n@@ -2911,16 +2810,18 @@ Gcc_backend::implicit_variable_reference(const std::string& name, Btype* btype)\n   TREE_PUBLIC(decl) = 1;\n   TREE_STATIC(decl) = 1;\n   DECL_ARTIFICIAL(decl) = 1;\n-  if (needs_encoding(name))\n-    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(encode_id(name)));\n+  if (! asm_name.empty())\n+    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n }\n \n // Create a named immutable initialized data structure.\n \n Bvariable*\n-Gcc_backend::immutable_struct(const std::string& name, bool is_hidden,\n+Gcc_backend::immutable_struct(const std::string& name,\n+                              const std::string& asm_name,\n+                              bool is_hidden,\n \t\t\t      bool is_common, Btype* btype, Location location)\n {\n   tree type_tree = btype->get_tree();\n@@ -2937,8 +2838,8 @@ Gcc_backend::immutable_struct(const std::string& name, bool is_hidden,\n   DECL_ARTIFICIAL(decl) = 1;\n   if (!is_hidden)\n     TREE_PUBLIC(decl) = 1;\n-  if (needs_encoding(name))\n-    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(encode_id(name)));\n+  if (! asm_name.empty())\n+    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n \n   // When the initializer for one immutable_struct refers to another,\n   // it needs to know the visibility of the referenced struct so that\n@@ -2998,7 +2899,9 @@ Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n // defined in another package.\n \n Bvariable*\n-Gcc_backend::immutable_struct_reference(const std::string& name, Btype* btype,\n+Gcc_backend::immutable_struct_reference(const std::string& name,\n+                                        const std::string& asm_name,\n+                                        Btype* btype,\n \t\t\t\t\tLocation location)\n {\n   tree type_tree = btype->get_tree();\n@@ -3013,8 +2916,8 @@ Gcc_backend::immutable_struct_reference(const std::string& name, Btype* btype,\n   DECL_ARTIFICIAL(decl) = 1;\n   TREE_PUBLIC(decl) = 1;\n   DECL_EXTERNAL(decl) = 1;\n-  if (needs_encoding(name))\n-    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(encode_id(name)));\n+  if (! asm_name.empty())\n+    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n   go_preserve_from_gc(decl);\n   return new Bvariable(decl);\n }\n@@ -3104,10 +3007,8 @@ Gcc_backend::function(Btype* fntype, const std::string& name,\n     return this->error_function();\n \n   tree decl = build_decl(location.gcc_location(), FUNCTION_DECL, id, functype);\n-  if (!asm_name.empty())\n+  if (! asm_name.empty())\n     SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n-  else if (needs_encoding(name))\n-    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(encode_id(name)));\n   if (is_visible)\n     TREE_PUBLIC(decl) = 1;\n   if (is_declaration)"}, {"sha": "fec65b8ca0dc820e01f2415846fa0d7038d0c5c7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -1,4 +1,4 @@\n-e66f30e862cb5d02b9d55bf44ac439bb8fc4ea19\n+4d8e00e730897cc7e73b1582522ecab031cfcaf2\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e93cdfece763204f21442b8f227d60e2fe3ef0bb", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -482,21 +482,19 @@ class Backend\n   virtual Bvariable*\n   error_variable() = 0;\n \n-  // Create a global variable.  PACKAGE_NAME is the name of the\n-  // package where the variable is defined.  PKGPATH is the package\n-  // path for that package, from the -fgo-pkgpath or -fgo-prefix\n-  // option.  NAME is the name of the variable.  BTYPE is the type of\n-  // the variable.  IS_EXTERNAL is true if the variable is defined in\n-  // some other package.  IS_HIDDEN is true if the variable is not\n-  // exported (name begins with a lower case letter).\n-  // IN_UNIQUE_SECTION is true if the variable should be put into a\n-  // unique section if possible; this is intended to permit the linker\n-  // to garbage collect the variable if it is not referenced.\n-  // LOCATION is where the variable was defined.\n+  // Create a global variable. NAME is the package-qualified name of\n+  // the variable.  ASM_NAME is the encoded identifier for the\n+  // variable, incorporating the package, and made safe for the\n+  // assembler.  BTYPE is the type of the variable.  IS_EXTERNAL is\n+  // true if the variable is defined in some other package.  IS_HIDDEN\n+  // is true if the variable is not exported (name begins with a lower\n+  // case letter).  IN_UNIQUE_SECTION is true if the variable should\n+  // be put into a unique section if possible; this is intended to\n+  // permit the linker to garbage collect the variable if it is not\n+  // referenced.  LOCATION is where the variable was defined.\n   virtual Bvariable*\n-  global_variable(const std::string& package_name,\n-\t\t  const std::string& pkgpath,\n-\t\t  const std::string& name,\n+  global_variable(const std::string& name,\n+                  const std::string& asm_name,\n \t\t  Btype* btype,\n \t\t  bool is_external,\n \t\t  bool is_hidden,\n@@ -561,6 +559,9 @@ class Backend\n   //\n   // NAME is the name to use for the initialized variable this will create.\n   //\n+  // ASM_NAME is encoded assembler-friendly version of the name, or the\n+  // empty string if no encoding is needed.\n+  //\n   // TYPE is the type of the implicit variable. \n   //\n   // IS_HIDDEN will be true if the descriptor should only be visible\n@@ -578,8 +579,9 @@ class Backend\n   //\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n   virtual Bvariable*\n-  implicit_variable(const std::string& name, Btype* type, bool is_hidden,\n-\t\t    bool is_constant, bool is_common, int64_t alignment) = 0;\n+  implicit_variable(const std::string& name, const std::string& asm_name,\n+                    Btype* type, bool is_hidden, bool is_constant,\n+                    bool is_common, int64_t alignment) = 0;\n \n \n   // Set the initial value of a variable created by implicit_variable.\n@@ -597,12 +599,15 @@ class Backend\n \t\t\t     bool is_hidden, bool is_constant, bool is_common,\n \t\t\t     Bexpression* init) = 0;\n \n-  // Create a reference to a named implicit variable defined in some other\n-  // package.  This will be a variable created by a call to implicit_variable\n-  // with the same NAME and TYPE and with IS_COMMON passed as false.  This\n-  // corresponds to an extern global variable in C.\n+  // Create a reference to a named implicit variable defined in some\n+  // other package.  This will be a variable created by a call to\n+  // implicit_variable with the same NAME, ASM_NAME and TYPE and with\n+  // IS_COMMON passed as false.  This corresponds to an extern global\n+  // variable in C.\n   virtual Bvariable*\n-  implicit_variable_reference(const std::string& name, Btype* type) = 0;\n+  implicit_variable_reference(const std::string& name,\n+                              const std::string& asm_name,\n+                              Btype* type) = 0;\n \n   // Create a named immutable initialized data structure.  This is\n   // used for type descriptors, map descriptors, and function\n@@ -612,6 +617,9 @@ class Backend\n   // NAME is the name to use for the initialized global variable which\n   // this call will create.\n   //\n+  // ASM_NAME is the encoded, assembler-friendly version of NAME, or\n+  // the empty string if no encoding is needed.\n+  //\n   // IS_HIDDEN will be true if the descriptor should only be visible\n   // within the current object.\n   //\n@@ -630,7 +638,9 @@ class Backend\n   // address.  After calling this the frontend will call\n   // immutable_struct_set_init.\n   virtual Bvariable*\n-  immutable_struct(const std::string& name, bool is_hidden, bool is_common,\n+  immutable_struct(const std::string& name,\n+                   const std::string& asm_name,\n+                   bool is_hidden, bool is_common,\n \t\t   Btype* type, Location) = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n@@ -648,11 +658,12 @@ class Backend\n   // Create a reference to a named immutable initialized data\n   // structure defined in some other package.  This will be a\n   // structure created by a call to immutable_struct with the same\n-  // NAME and TYPE and with IS_COMMON passed as false.  This\n+  // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This\n   // corresponds to an extern const global variable in C.\n   virtual Bvariable*\n-  immutable_struct_reference(const std::string& name, Btype* type,\n-\t\t\t     Location) = 0;\n+  immutable_struct_reference(const std::string& name,\n+                             const std::string& asm_name,\n+                             Btype* type, Location) = 0;\n \n   // Labels.\n   "}, {"sha": "0ab672608753e2b616f2ead6ccb5faa69fc891e2", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -11,6 +11,7 @@\n #include \"go-c.h\"\n #include \"gogo.h\"\n #include \"go-diagnostics.h\"\n+#include \"go-encode-id.h\"\n #include \"types.h\"\n #include \"export.h\"\n #include \"import.h\"\n@@ -1304,16 +1305,18 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n   Btype* btype = this->type()->get_backend(gogo);\n \n   Bvariable* bvar;\n+  std::string asm_name(go_selectively_encode_id(var_name));\n   if (no->package() != NULL || is_descriptor)\n-    bvar = context->backend()->immutable_struct_reference(var_name, btype,\n-\t\t\t\t\t\t\t  loc);\n+    bvar = context->backend()->immutable_struct_reference(var_name, asm_name,\n+                                                          btype, loc);\n   else\n     {\n       Location bloc = Linemap::predeclared_location();\n       bool is_hidden = ((no->is_function()\n \t\t\t && no->func_value()->enclosing() != NULL)\n \t\t\t|| Gogo::is_thunk(no));\n-      bvar = context->backend()->immutable_struct(var_name, is_hidden, false,\n+      bvar = context->backend()->immutable_struct(var_name, asm_name,\n+                                                  is_hidden, false,\n \t\t\t\t\t\t  btype, bloc);\n       Expression_list* vals = new Expression_list();\n       vals->push_back(Expression::make_func_code_reference(this->fn_, bloc));\n@@ -4283,9 +4286,11 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      // read-only, because the program is permitted to change it.\n \t      copy_to_heap = context->function() != NULL;\n \t    }\n+          std::string asm_name(go_selectively_encode_id(buf));\n \t  Bvariable* implicit =\n-\t    gogo->backend()->implicit_variable(buf, btype, true, copy_to_heap,\n-\t\t\t\t\t       false, 0);\n+              gogo->backend()->implicit_variable(buf, asm_name,\n+                                                 btype, true, copy_to_heap,\n+                                                 false, 0);\n \t  gogo->backend()->implicit_variable_set_init(implicit, buf, btype,\n \t\t\t\t\t\t      true, copy_to_heap, false,\n \t\t\t\t\t\t      bexpr);\n@@ -4299,8 +4304,10 @@ Unary_expression::do_get_backend(Translate_context* context)\n           snprintf(buf, sizeof buf, \"C%u\", counter);\n           ++counter;\n \n+          std::string asm_name(go_selectively_encode_id(buf));\n           Bvariable* decl =\n-              gogo->backend()->immutable_struct(buf, true, false, btype, loc);\n+              gogo->backend()->immutable_struct(buf, asm_name,\n+                                                true, false, btype, loc);\n           gogo->backend()->immutable_struct_set_init(decl, buf, true, false,\n                                                      btype, loc, bexpr);\n           bexpr = gogo->backend()->var_expression(decl, loc);\n@@ -15074,8 +15081,10 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n       && this->type_->named_type()->named_object()->package() != NULL)\n     {\n       Btype* btype = this->type()->get_backend(gogo);\n+      std::string asm_name(go_selectively_encode_id(mangled_name));\n       this->bvar_ =\n-          gogo->backend()->immutable_struct_reference(mangled_name, btype, loc);\n+          gogo->backend()->immutable_struct_reference(mangled_name, asm_name,\n+                                                      btype, loc);\n       return gogo->backend()->var_expression(this->bvar_, this->location());\n     }\n \n@@ -15119,7 +15128,8 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   Bexpression* ctor = mtable->get_backend(context);\n \n   bool is_public = has_hidden_methods && this->type_->named_type() != NULL;\n-  this->bvar_ = gogo->backend()->immutable_struct(mangled_name, false,\n+  std::string asm_name(go_selectively_encode_id(mangled_name));\n+  this->bvar_ = gogo->backend()->immutable_struct(mangled_name, asm_name, false,\n \t\t\t\t\t\t  !is_public, btype, loc);\n   gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, false,\n                                              !is_public, btype, loc, ctor);"}, {"sha": "978f20823d69ed80da285768a2c149181b08f63f", "filename": "gcc/go/gofrontend/go-encode-id.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -0,0 +1,113 @@\n+// go-encode-id.cc -- Go identifier encoding hooks\n+\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-location.h\"\n+#include \"go-linemap.h\"\n+#include \"go-encode-id.h\"\n+\n+// Return whether the character c is OK to use in the assembler.\n+\n+static bool\n+char_needs_encoding(char c)\n+{\n+  switch (c)\n+    {\n+    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+    case 'Y': case 'Z':\n+    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+    case 'y': case 'z':\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+    case '_': case '.': case '$': case '/':\n+      return false;\n+    default:\n+      return true;\n+    }\n+}\n+\n+// Return whether the identifier needs to be translated because it\n+// contains non-ASCII characters.\n+\n+bool\n+go_id_needs_encoding(const std::string& str)\n+{\n+  for (std::string::const_iterator p = str.begin();\n+       p != str.end();\n+       ++p)\n+    if (char_needs_encoding(*p))\n+      return true;\n+  return false;\n+}\n+\n+// Pull the next UTF-8 character out of P and store it in *PC.  Return\n+// the number of bytes read.\n+\n+static size_t\n+fetch_utf8_char(const char* p, unsigned int* pc)\n+{\n+  unsigned char c = *p;\n+  if ((c & 0x80) == 0)\n+    {\n+      *pc = c;\n+      return 1;\n+    }\n+  size_t len = 0;\n+  while ((c & 0x80) != 0)\n+    {\n+      ++len;\n+      c <<= 1;\n+    }\n+  unsigned int rc = *p & ((1 << (7 - len)) - 1);\n+  for (size_t i = 1; i < len; i++)\n+    {\n+      unsigned int u = p[i];\n+      rc <<= 6;\n+      rc |= u & 0x3f;\n+    }\n+  *pc = rc;\n+  return len;\n+}\n+\n+// Encode an identifier using ASCII characters.\n+\n+std::string\n+go_encode_id(const std::string &id)\n+{\n+  std::string ret;\n+  const char* p = id.c_str();\n+  const char* pend = p + id.length();\n+  while (p < pend)\n+    {\n+      unsigned int c;\n+      size_t len = fetch_utf8_char(p, &c);\n+      if (len == 1 && !char_needs_encoding(c))\n+        ret += c;\n+      else\n+        {\n+          ret += \"$U\";\n+          char buf[30];\n+          snprintf(buf, sizeof buf, \"%x\", c);\n+          ret += buf;\n+          ret += \"$\";\n+        }\n+      p += len;\n+    }\n+  return ret;\n+}\n+\n+std::string\n+go_selectively_encode_id(const std::string &id)\n+{\n+  if (go_id_needs_encoding(id))\n+    return go_encode_id(id);\n+  return std::string();\n+}"}, {"sha": "b95d97dd1ba19493c5435bf08014b6ca3d882e89", "filename": "gcc/go/gofrontend/go-encode-id.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -0,0 +1,30 @@\n+// go-encode-id.h -- Go identifier encoding utilities  -*- C++ -*-\n+\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_ENCODE_ID_H\n+#define GO_ENCODE_ID_H\n+\n+#include \"backend.h\"\n+\n+// Given an identifier corresponding to a function or variable,\n+// this helper returns TRUE if the identifier needs special\n+// encoding to be used as an ASM name (symbol), FALSE if the name\n+// is OK as is.\n+extern bool\n+go_id_needs_encoding(const std::string& str);\n+\n+// Encodes the specified identifier for ASM name safety, returning a\n+// string with the encoded value.\n+extern std::string\n+go_encode_id(const std::string &id);\n+\n+// Returns the empty string if the specified name needs encoding,\n+// otherwise invokes go_encode_id() on the name and returns the\n+// result.\n+extern std::string\n+go_selectively_encode_id(const std::string &id);\n+\n+#endif // !defined(GO_ENCODE_ID_H)"}, {"sha": "b671ce5bced81cbfc828c2d1cd34c8b614ec354b", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -12,6 +12,7 @@\n \n #include \"go-c.h\"\n #include \"go-diagnostics.h\"\n+#include \"go-encode-id.h\"\n #include \"go-dump.h\"\n #include \"go-optimize.h\"\n #include \"lex.h\"\n@@ -5326,6 +5327,10 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n       if ((this->pragmas_ & GOPRAGMA_NOSPLIT) != 0)\n \tdisable_split_stack = true;\n \n+      // Encode name if asm_name not already set at this point\n+      if (asm_name.empty() && go_id_needs_encoding(no->get_id(gogo)))\n+        asm_name = go_encode_id(no->get_id(gogo));\n+\n       // This should go into a unique section if that has been\n       // requested elsewhere, or if this is a nointerface function.\n       // We want to put a nointerface function into a unique section\n@@ -5379,6 +5384,8 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n               asm_name.append(rtype->mangled_name(gogo));\n             }\n         }\n+      else if (go_id_needs_encoding(no->get_id(gogo)))\n+        asm_name = go_encode_id(no->get_id(gogo));\n \n       Btype* functype = this->fntype_->get_backend_fntype(gogo);\n       this->fndecl_ =\n@@ -6594,25 +6601,39 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t      type = Type::make_pointer_type(type);\n \t    }\n \n-\t  std::string n = Gogo::unpack_hidden_name(name);\n+\t  const std::string n = Gogo::unpack_hidden_name(name);\n \t  Btype* btype = type->get_backend(gogo);\n \n \t  Bvariable* bvar;\n \t  if (Map_type::is_zero_value(this))\n \t    bvar = Map_type::backend_zero_value(gogo);\n \t  else if (this->is_global_)\n-\t    bvar = backend->global_variable((package == NULL\n-\t\t\t\t\t     ? gogo->package_name()\n-\t\t\t\t\t     : package->package_name()),\n-\t\t\t\t\t    (package == NULL\n-\t\t\t\t\t     ? gogo->pkgpath_symbol()\n-\t\t\t\t\t     : package->pkgpath_symbol()),\n-\t\t\t\t\t    n,\n-\t\t\t\t\t    btype,\n-\t\t\t\t\t    package != NULL,\n-\t\t\t\t\t    Gogo::is_hidden_name(name),\n-\t\t\t\t\t    this->in_unique_section_,\n-\t\t\t\t\t    this->location_);\n+\t    {\n+\t      std::string var_name(package != NULL\n+\t\t\t\t   ? package->package_name()\n+\t\t\t\t   : gogo->package_name());\n+\t      var_name.push_back('.');\n+\t      var_name.append(n);\n+              std::string asm_name;\n+              if (Gogo::is_hidden_name(name))\n+                asm_name = var_name;\n+              else\n+                {\n+                  asm_name = package != NULL\n+                      ? package->pkgpath_symbol()\n+                      : gogo->pkgpath_symbol();\n+                  asm_name.push_back('.');\n+                  asm_name.append(n);\n+                }\n+\t      asm_name = go_encode_id(asm_name);\n+\t      bvar = backend->global_variable(var_name,\n+\t\t\t\t\t      asm_name,\n+\t\t\t\t\t      btype,\n+\t\t\t\t\t      package != NULL,\n+\t\t\t\t\t      Gogo::is_hidden_name(name),\n+\t\t\t\t\t      this->in_unique_section_,\n+\t\t\t\t\t      this->location_);\n+\t    }\n \t  else if (function == NULL)\n \t    {\n \t      go_assert(saw_errors());"}, {"sha": "33d3460e49389d8d7fffcc31f58135fcf2ac69e1", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3878205ddc2970e384ffaed3a95362763eee9fe/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f3878205ddc2970e384ffaed3a95362763eee9fe", "patch": "@@ -11,6 +11,7 @@\n #include \"go-c.h\"\n #include \"gogo.h\"\n #include \"go-diagnostics.h\"\n+#include \"go-encode-id.h\"\n #include \"operator.h\"\n #include \"expressions.h\"\n #include \"statements.h\"\n@@ -1217,10 +1218,12 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \n       Type* td_type = Type::make_type_descriptor_type();\n       Btype* td_btype = td_type->get_backend(gogo);\n+      const char *name = \"__go_tdn_unsafe.Pointer\";\n+      std::string asm_name(go_selectively_encode_id(name));\n       this->type_descriptor_var_ =\n-\tgogo->backend()->immutable_struct_reference(\"__go_tdn_unsafe.Pointer\",\n-\t\t\t\t\t\t    td_btype,\n-\t\t\t\t\t\t    bloc);\n+\t  gogo->backend()->immutable_struct_reference(name, asm_name,\n+\t\t\t\t\t\t      td_btype,\n+\t\t\t\t\t\t      bloc);\n \n       if (phash != NULL)\n \t*phash = this->type_descriptor_var_;\n@@ -1239,10 +1242,11 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   const Package* dummy;\n   if (this->type_descriptor_defined_elsewhere(nt, &dummy))\n     {\n+      std::string asm_name(go_selectively_encode_id(var_name));\n       this->type_descriptor_var_ =\n-\tgogo->backend()->immutable_struct_reference(var_name,\n-\t\t\t\t\t\t    initializer_btype,\n-\t\t\t\t\t\t    loc);\n+\t  gogo->backend()->immutable_struct_reference(var_name, asm_name,\n+\t\t\t\t\t\t      initializer_btype,\n+\t\t\t\t\t\t      loc);\n       if (phash != NULL)\n \t*phash = this->type_descriptor_var_;\n       return;\n@@ -1271,8 +1275,9 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   // ensure that type_descriptor_pointer will work if called while\n   // converting INITIALIZER.\n \n+  std::string asm_name(go_selectively_encode_id(var_name));\n   this->type_descriptor_var_ =\n-    gogo->backend()->immutable_struct(var_name, false, is_common,\n+      gogo->backend()->immutable_struct(var_name, asm_name, false, is_common,\n \t\t\t\t      initializer_btype, loc);\n   if (phash != NULL)\n     *phash = this->type_descriptor_var_;\n@@ -2187,8 +2192,10 @@ Type::make_gc_symbol_var(Gogo* gogo)\n   const Package* dummy;\n   if (this->type_descriptor_defined_elsewhere(nt, &dummy))\n     {\n+      std::string asm_name(go_selectively_encode_id(sym_name));\n       this->gc_symbol_var_ =\n-\tgogo->backend()->implicit_variable_reference(sym_name, sym_btype);\n+          gogo->backend()->implicit_variable_reference(sym_name, asm_name,\n+                                                       sym_btype);\n       if (phash != NULL)\n \t*phash = this->gc_symbol_var_;\n       return;\n@@ -2213,8 +2220,10 @@ Type::make_gc_symbol_var(Gogo* gogo)\n   // Since we are building the GC symbol in this package, we must create the\n   // variable before converting the initializer to its backend representation\n   // because the initializer may refer to the GC symbol for this type.\n+  std::string asm_name(go_selectively_encode_id(sym_name));\n   this->gc_symbol_var_ =\n-    gogo->backend()->implicit_variable(sym_name, sym_btype, false, true, is_common, 0);\n+      gogo->backend()->implicit_variable(sym_name, asm_name,\n+                                         sym_btype, false, true, is_common, 0);\n   if (phash != NULL)\n     *phash = this->gc_symbol_var_;\n \n@@ -7034,8 +7043,10 @@ Map_type::backend_zero_value(Gogo* gogo)\n   Btype* barray_type = gogo->backend()->array_type(buint8_type, blength);\n \n   std::string zname = Map_type::zero_value->name();\n+  std::string asm_name(go_selectively_encode_id(zname));\n   Bvariable* zvar =\n-    gogo->backend()->implicit_variable(zname, barray_type, false, true, true,\n+      gogo->backend()->implicit_variable(zname, asm_name,\n+                                         barray_type, false, true, true,\n \t\t\t\t       Map_type::zero_value_align);\n   gogo->backend()->implicit_variable_set_init(zvar, zname, barray_type,\n \t\t\t\t\t      false, true, true, NULL);"}]}