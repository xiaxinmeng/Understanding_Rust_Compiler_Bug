{"sha": "6a2892a6d3aef8a1ce26386d626f26e6100099f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEyODkyYTZkM2FlZjhhMWNlMjYzODZkNjI2ZjI2ZTYxMDAwOTlmNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-19T08:32:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-19T08:32:09Z"}, "message": "omp-low.c (lower_rec_input_clauses): Handle references properly in inscan clauses.\n\n\t* omp-low.c (lower_rec_input_clauses): Handle references properly\n\tin inscan clauses.\n\t(lower_omp_scan): Likewise.\ncp/\n\t* cp-gimplify.c (cp_genericize_r): Handle OMP_CLAUSE_{IN,EX}CLUSIVE\n\tlike OMP_CLAUSE_SHARED.\ntestsuite/\n\t* g++.dg/vect/simd-3.cc: New test.\n\t* g++.dg/vect/simd-4.cc: New test.\n\t* g++.dg/vect/simd-5.cc: New test.\n\nFrom-SVN: r272471", "tree": {"sha": "70d4bfa817c70f27aac537b93810c2900938a8e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d4bfa817c70f27aac537b93810c2900938a8e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a2892a6d3aef8a1ce26386d626f26e6100099f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2892a6d3aef8a1ce26386d626f26e6100099f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2892a6d3aef8a1ce26386d626f26e6100099f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2892a6d3aef8a1ce26386d626f26e6100099f6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5460b1030c86c2d328335f141dc2972c7ea9fd1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5460b1030c86c2d328335f141dc2972c7ea9fd1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5460b1030c86c2d328335f141dc2972c7ea9fd1e"}], "stats": {"total": 492, "additions": 468, "deletions": 24}, "files": [{"sha": "7d337bcab3b15011e319df8c3aeea4a7edf7209c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -1,3 +1,9 @@\n+2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (lower_rec_input_clauses): Handle references properly\n+\tin inscan clauses.\n+\t(lower_omp_scan): Likewise.\n+\n 2019-06-19  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \n \t* tree-ssa-address.c (preferred_mem_scale_factor): Handle when"}, {"sha": "f5dab5493adfb299b3908228788497e5b1ab822f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -1,3 +1,8 @@\n+2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cp_genericize_r): Handle OMP_CLAUSE_{IN,EX}CLUSIVE\n+\tlike OMP_CLAUSE_SHARED.\n+\n 2019-06-18  Jason Merrill  <jason@redhat.com>\n \n \t* constexpr.c (cxx_eval_store_expression): Delay target evaluation."}, {"sha": "bce01f5098ebd1b3c67324afab8e100709eb18fa", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -1238,6 +1238,8 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n+\tcase OMP_CLAUSE_INCLUSIVE:\n+\tcase OMP_CLAUSE_EXCLUSIVE:\n \t  /* Don't dereference an invisiref in OpenMP clauses.  */\n \t  if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n \t    *walk_subtrees = 0;"}, {"sha": "ba85b1914c075afd3100633cfa54529971ff6881", "filename": "gcc/omp-low.c", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -5238,10 +5238,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t      if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n \t\t\t\t{\n \t\t\t\t  tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n-\t\t\t\t  x = DECL_VALUE_EXPR (new_var);\n-\t\t\t\t  SET_DECL_VALUE_EXPR (new_var, nv);\n+\t\t\t\t  x = DECL_VALUE_EXPR (new_vard);\n+\t\t\t\t  tree vexpr = nv;\n+\t\t\t\t  if (new_vard != new_var)\n+\t\t\t\t    vexpr = build_fold_addr_expr (nv);\n+\t\t\t\t  SET_DECL_VALUE_EXPR (new_vard, vexpr);\n \t\t\t\t  lower_omp (&tseq, ctx);\n-\t\t\t\t  SET_DECL_VALUE_EXPR (new_var, x);\n+\t\t\t\t  SET_DECL_VALUE_EXPR (new_vard, x);\n \t\t\t\t  gimple_seq_add_seq (ilist, tseq);\n \t\t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n \t\t\t\t}\n@@ -5367,20 +5370,23 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    {\n \t\t      if (x)\n \t\t\t{\n-\t\t\t  tree nv = create_tmp_var_raw (TREE_TYPE (new_vard));\n+\t\t\t  tree nv = create_tmp_var_raw (TREE_TYPE (new_var));\n \t\t\t  gimple_add_tmp_var (nv);\n-\t\t\t  ctx->cb.decl_map->put (new_var, nv);\n+\t\t\t  ctx->cb.decl_map->put (new_vard, nv);\n \t\t\t  x = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t(c, nv, build_outer_var_ref (var, ctx));\n \t\t\t  gimplify_and_add (x, ilist);\n \t\t\t  if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n \t\t\t    {\n \t\t\t      tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n-\t\t\t      SET_DECL_VALUE_EXPR (new_var, nv);\n-\t\t\t      DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n+\t\t\t      tree vexpr = nv;\n+\t\t\t      if (new_vard != new_var)\n+\t\t\t\tvexpr = build_fold_addr_expr (nv);\n+\t\t\t      SET_DECL_VALUE_EXPR (new_vard, vexpr);\n+\t\t\t      DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n \t\t\t      lower_omp (&tseq, ctx);\n-\t\t\t      SET_DECL_VALUE_EXPR (new_var, NULL_TREE);\n-\t\t\t      DECL_HAS_VALUE_EXPR_P (new_var) = 0;\n+\t\t\t      SET_DECL_VALUE_EXPR (new_vard, NULL_TREE);\n+\t\t\t      DECL_HAS_VALUE_EXPR_P (new_vard) = 0;\n \t\t\t      gimple_seq_add_seq (ilist, tseq);\n \t\t\t    }\n \t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n@@ -5524,10 +5530,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      gimplify_assign (ref, x, &llist[1]);\n \n \t\t    }\n-\t\t  else if (rvarp == NULL)\n+\t\t  else\n \t\t    {\n \t\t      if (omp_is_reference (var) && is_simd)\n \t\t\thandle_simd_reference (clause_loc, new_vard, ilist);\n+\t\t      if (rvarp)\n+\t\t\tbreak;\n \t\t      gimplify_assign (new_var, x, ilist);\n \t\t      if (is_simd)\n \t\t\t{\n@@ -8587,14 +8595,26 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t    && OMP_CLAUSE_REDUCTION_INSCAN (c))\n \t  {\n+\t    location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \t    tree var = OMP_CLAUSE_DECL (c);\n \t    tree new_var = lookup_decl (var, octx);\n \t    tree val = new_var;\n \t    tree var2 = NULL_TREE;\n \t    tree var3 = NULL_TREE;\n-\t    if (DECL_HAS_VALUE_EXPR_P (new_var))\n+\t    tree new_vard = new_var;\n+\t    if (omp_is_reference (var))\n+\t      {\n+\t\tnew_var = build_simple_mem_ref_loc (clause_loc, new_var);\n+\t\tval = new_var;\n+\t      }\n+\t    if (DECL_HAS_VALUE_EXPR_P (new_vard))\n \t      {\n-\t\tval = DECL_VALUE_EXPR (new_var);\n+\t\tval = DECL_VALUE_EXPR (new_vard);\n+\t\tif (omp_is_reference (var))\n+\t\t  {\n+\t\t    gcc_assert (TREE_CODE (val) == ADDR_EXPR);\n+\t\t    val = TREE_OPERAND (val, 0);\n+\t\t  }\n \t\tif (TREE_CODE (val) == ARRAY_REF\n \t\t    && VAR_P (TREE_OPERAND (val, 0)))\n \t\t  {\n@@ -8618,14 +8638,15 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t  var2 = val;\n \t\t      }\n \t\t  }\n+\t\tgcc_assert (var2);\n \t      }\n \t    else\n \t      {\n \t\tvar2 = build_outer_var_ref (var, octx);\n \t\tif (input_phase && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t\t  {\n-\t\t    var3 = maybe_lookup_decl (new_var, octx);\n-\t\t    if (var3 == new_var)\n+\t\t    var3 = maybe_lookup_decl (new_vard, octx);\n+\t\t    if (var3 == new_vard)\n \t\t      var3 = NULL_TREE;\n \t\t  }\n \t      }\n@@ -8646,34 +8667,43 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t      {\n \t\t\t/* Otherwise, assign to it the identity element.  */\n \t\t\tgimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n-\t\t\ttree x = (DECL_HAS_VALUE_EXPR_P (new_var)\n-\t\t\t\t  ? DECL_VALUE_EXPR (new_var) : NULL_TREE);\n \t\t\ttree ref = build_outer_var_ref (var, octx);\n-\t\t\tSET_DECL_VALUE_EXPR (new_var, val);\n+\t\t\ttree x = (DECL_HAS_VALUE_EXPR_P (new_vard)\n+\t\t\t\t  ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n+\t\t\tif (x)\n+\t\t\t  {\n+\t\t\t    if (omp_is_reference (var))\n+\t\t\t      val = build_fold_addr_expr_loc (clause_loc, val);\n+\t\t\t    SET_DECL_VALUE_EXPR (new_vard, val);\n+\t\t\t  }\n \t\t\tSET_DECL_VALUE_EXPR (placeholder, ref);\n \t\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n \t\t\tlower_omp (&tseq, octx);\n-\t\t\tSET_DECL_VALUE_EXPR (new_var, x);\n+\t\t\tif (x)\n+\t\t\t  SET_DECL_VALUE_EXPR (new_vard, x);\n \t\t\tSET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n \t\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n-\t\t\tif (x == NULL_TREE)\n-\t\t\t  DECL_HAS_VALUE_EXPR_P (new_var) = 0;\n \t\t\tgimple_seq_add_seq (&before, tseq);\n \t\t\tOMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n \t\t      }\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    gimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n-\t\t    tree x = (DECL_HAS_VALUE_EXPR_P (new_var)\n-\t\t\t      ? DECL_VALUE_EXPR (new_var) : NULL_TREE);\n-\t\t    SET_DECL_VALUE_EXPR (new_var, val);\n+\t\t    tree x = (DECL_HAS_VALUE_EXPR_P (new_vard)\n+\t\t\t      ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n+\t\t    tree vexpr = val;\n+\t\t    if (x && omp_is_reference (var))\n+\t\t      vexpr = build_fold_addr_expr_loc (clause_loc, val);\n+\t\t    if (x)\n+\t\t      SET_DECL_VALUE_EXPR (new_vard, vexpr);\n \t\t    SET_DECL_VALUE_EXPR (placeholder, var2);\n \t\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n \t\t    lower_omp (&tseq, octx);\n \t\t    gimple_seq_add_seq (&before, tseq);\n \t\t    OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n-\t\t    SET_DECL_VALUE_EXPR (new_var, x);\n+\t\t    if (x)\n+\t\t      SET_DECL_VALUE_EXPR (new_vard, x);\n \t\t    SET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n \t\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n \t\t    x = lang_hooks.decls.omp_clause_assign_op (c, val, var2);"}, {"sha": "ad8c1ac4fb8589c9c8165486b88146906b6cfb69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -1,3 +1,9 @@\n+2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/vect/simd-3.cc: New test.\n+\t* g++.dg/vect/simd-4.cc: New test.\n+\t* g++.dg/vect/simd-5.cc: New test.\n+\n 2019-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/ubsan/pr63956.C: Adjust expected diagnostics."}, {"sha": "d9981719f58ced487c4ffbbecb7c8a5564165bc7", "filename": "gcc/testsuite/g++.dg/vect/simd-3.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-3.cc?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -0,0 +1,120 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+int r, a[1024], b[1024], q;\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, +:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "8f3198943a7427ae3d4800bfbc5575c5849627ff", "filename": "gcc/testsuite/g++.dg/vect/simd-4.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-4.cc?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -0,0 +1,122 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+int r, a[1024], b[1024], q;\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp simd reduction (inscan, foo:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, foo:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "e9755957559cabdd5f54acc3aa4c12f42fbfea8f", "filename": "gcc/testsuite/g++.dg/vect/simd-5.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2892a6d3aef8a1ce26386d626f26e6100099f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-5.cc?ref=6a2892a6d3aef8a1ce26386d626f26e6100099f6", "patch": "@@ -0,0 +1,153 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { xfail *-*-* } } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b, S &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b, S &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp simd if (0) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  r.s = 0;\n+  baz (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}]}