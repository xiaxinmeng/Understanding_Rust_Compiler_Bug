{"sha": "39f579c7cfbde641ebd5942d96750874bad34234", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlmNTc5YzdjZmJkZTY0MWViZDU5NDJkOTY3NTA4NzRiYWQzNDIzNA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-06-16T03:46:12Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-06-16T03:46:12Z"}, "message": "trans.c (gnu_stack_free_list): Delete.\n\n\t* gcc-interface/trans.c (gnu_stack_free_list): Delete.\n\t(gnu_except_ptr_stack): Change type to VEC.  Update comment.\n\t(gnu_elab_proc_stack): Likewise.\n\t(gnu_return_label_stack): Likewise.\n\t(gnu_loop_label_stack): Likewise.\n\t(gnu_switch_label_stack): Likewise.\n\t(gnu_constraint_label_stack): Likewise.\n\t(gnu_storage_error_label_stack): Likewise.\n\t(gnu_program_error_label_stack): Likewise.\n\t(push_exception_label_stack): Take a VEC ** instead of a tree *.\n\t(push_stack): Likewise.  Remove unused second parameter.  Update\n\tcallers.\n\t(pop_stack): Take a VEC * instead of a tree *.  Update callers.\n\t(gigi): Initialize stacks as VECs.\n\t(Identifier_to_gnu): Use VEC_last instead of TREE_VALUE.\n\t(Case_Statement_to_gnu): Likewise.\n\t(Subprogram_Body_to_gnu): Likewise.\n\t(call_to_gnu): Likewise.\n\t(Exception_Handler_to_gnu_sjlj): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(get_exception_label): Likewise.\n\nFrom-SVN: r160820", "tree": {"sha": "9f5cd26f4d20c167964a778b4c42e23e3622f862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f5cd26f4d20c167964a778b4c42e23e3622f862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39f579c7cfbde641ebd5942d96750874bad34234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39f579c7cfbde641ebd5942d96750874bad34234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39f579c7cfbde641ebd5942d96750874bad34234", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39f579c7cfbde641ebd5942d96750874bad34234/comments", "author": null, "committer": null, "parents": [{"sha": "9e5fd919791c50e985f4914bdd4930372de69882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5fd919791c50e985f4914bdd4930372de69882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e5fd919791c50e985f4914bdd4930372de69882"}], "stats": {"total": 181, "additions": 89, "deletions": 92}, "files": [{"sha": "808696c40926cb70fcd91fdba581ad37b9175637", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39f579c7cfbde641ebd5942d96750874bad34234/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39f579c7cfbde641ebd5942d96750874bad34234/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39f579c7cfbde641ebd5942d96750874bad34234", "patch": "@@ -1,3 +1,27 @@\n+2010-06-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/trans.c (gnu_stack_free_list): Delete.\n+\t(gnu_except_ptr_stack): Change type to VEC.  Update comment.\n+\t(gnu_elab_proc_stack): Likewise.\n+\t(gnu_return_label_stack): Likewise.\n+\t(gnu_loop_label_stack): Likewise.\n+\t(gnu_switch_label_stack): Likewise.\n+\t(gnu_constraint_label_stack): Likewise.\n+\t(gnu_storage_error_label_stack): Likewise.\n+\t(gnu_program_error_label_stack): Likewise.\n+\t(push_exception_label_stack): Take a VEC ** instead of a tree *.\n+\t(push_stack): Likewise.  Remove unused second parameter.  Update\n+\tcallers.\n+\t(pop_stack): Take a VEC * instead of a tree *.  Update callers.\n+\t(gigi): Initialize stacks as VECs.\n+\t(Identifier_to_gnu): Use VEC_last instead of TREE_VALUE.\n+\t(Case_Statement_to_gnu): Likewise.\n+\t(Subprogram_Body_to_gnu): Likewise.\n+\t(call_to_gnu): Likewise.\n+\t(Exception_Handler_to_gnu_sjlj): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(get_exception_label): Likewise.\n+\n 2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Build_Derived_Record_Type): if derived type is an"}, {"sha": "d33aa871242d4a4ff809e757be0acd5177585290", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 65, "deletions": 92, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39f579c7cfbde641ebd5942d96750874bad34234/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39f579c7cfbde641ebd5942d96750874bad34234/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=39f579c7cfbde641ebd5942d96750874bad34234", "patch": "@@ -153,35 +153,28 @@ struct GTY((chain_next (\"%h.next\"))) elab_info {\n \n static GTY(()) struct elab_info *elab_info_list;\n \n-/* Free list of TREE_LIST nodes used for stacks.  */\n-static GTY((deletable)) tree gnu_stack_free_list;\n+/* Stack of exception pointer variables.  Each entry is the VAR_DECL\n+   that stores the address of the raised exception.  Nonzero means we\n+   are in an exception handler.  Not used in the zero-cost case.  */\n+static GTY(()) VEC(tree,gc) *gnu_except_ptr_stack;\n \n-/* List of TREE_LIST nodes representing a stack of exception pointer\n-   variables.  TREE_VALUE is the VAR_DECL that stores the address of\n-   the raised exception.  Nonzero means we are in an exception\n-   handler.  Not used in the zero-cost case.  */\n-static GTY(()) tree gnu_except_ptr_stack;\n+/* Stack for storing the current elaboration procedure decl.  */\n+static GTY(()) VEC(tree,gc) *gnu_elab_proc_stack;\n \n-/* List of TREE_LIST nodes used to store the current elaboration procedure\n-   decl.  TREE_VALUE is the decl.  */\n-static GTY(()) tree gnu_elab_proc_stack;\n+/* Stack of labels to be used as a goto target instead of a return in\n+   some functions.  See processing for N_Subprogram_Body.  */\n+static GTY(()) VEC(tree,gc) *gnu_return_label_stack;\n \n-/* Variable that stores a list of labels to be used as a goto target instead of\n-   a return in some functions.  See processing for N_Subprogram_Body.  */\n-static GTY(()) tree gnu_return_label_stack;\n+/* Stack of LOOP_STMT nodes.  */\n+static GTY(()) VEC(tree,gc) *gnu_loop_label_stack;\n \n-/* List of TREE_LIST nodes representing a stack of LOOP_STMT nodes.\n-   TREE_VALUE of each entry is the label of the corresponding LOOP_STMT.  */\n-static GTY(()) tree gnu_loop_label_stack;\n+/* Stack of labels for switch statements.  */\n+static GTY(()) VEC(tree,gc) *gnu_switch_label_stack;\n \n-/* List of TREE_LIST nodes representing labels for switch statements.\n-   TREE_VALUE of each entry is the label at the end of the switch.  */\n-static GTY(()) tree gnu_switch_label_stack;\n-\n-/* List of TREE_LIST nodes containing the stacks for N_{Push,Pop}_*_Label.  */\n-static GTY(()) tree gnu_constraint_error_label_stack;\n-static GTY(()) tree gnu_storage_error_label_stack;\n-static GTY(()) tree gnu_program_error_label_stack;\n+/* The stacks for N_{Push,Pop}_*_Label.  */\n+static GTY(()) VEC(tree,gc) *gnu_constraint_error_label_stack;\n+static GTY(()) VEC(tree,gc) *gnu_storage_error_label_stack;\n+static GTY(()) VEC(tree,gc) *gnu_program_error_label_stack;\n \n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n@@ -192,10 +185,10 @@ static void record_code_position (Node_Id);\n static void insert_code_for (Node_Id);\n static void add_cleanup (tree, Node_Id);\n static void add_stmt_list (List_Id);\n-static void push_exception_label_stack (tree *, Entity_Id);\n+static void push_exception_label_stack (VEC(tree,gc) **, Entity_Id);\n static tree build_stmt_group (List_Id, bool);\n-static void push_stack (tree *, tree, tree);\n-static void pop_stack (tree *);\n+static void push_stack (VEC(tree,gc) **, tree);\n+static void pop_stack (VEC(tree,gc) *);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n@@ -609,11 +602,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      user available facilities for Intrinsic imports.  */\n   gnat_install_builtins ();\n \n-  gnu_except_ptr_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n-  gnu_constraint_error_label_stack\n-    = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n-  gnu_storage_error_label_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n-  gnu_program_error_label_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n+  VEC_safe_push (tree, gc, gnu_except_ptr_stack, NULL_TREE);\n+  VEC_safe_push (tree, gc, gnu_constraint_error_label_stack, NULL_TREE);\n+  VEC_safe_push (tree, gc, gnu_storage_error_label_stack, NULL_TREE);\n+  VEC_safe_push (tree, gc, gnu_program_error_label_stack, NULL_TREE);\n \n   /* Process any Pragma Ident for the main unit.  */\n #ifdef ASM_OUTPUT_IDENT\n@@ -973,7 +965,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      variables of non-constant size because they are automatically allocated\n      to memory.  There might be no way of allocating a proper temporary for\n      them in any case.  We only do this for SJLJ though.  */\n-  if (TREE_VALUE (gnu_except_ptr_stack)\n+  if (VEC_last (tree, gnu_except_ptr_stack)\n       && TREE_CODE (gnu_result) == VAR_DECL\n       && TREE_CODE (DECL_SIZE_UNIT (gnu_result)) == INTEGER_CST)\n     TREE_THIS_VOLATILE (gnu_result) = TREE_SIDE_EFFECTS (gnu_result) = 1;\n@@ -1943,7 +1935,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n   /* We build a SWITCH_EXPR that contains the code with interspersed\n      CASE_LABEL_EXPRs for each label.  */\n \n-  push_stack (&gnu_switch_label_stack, NULL_TREE,\n+  push_stack (&gnu_switch_label_stack,\n \t      create_artificial_label (input_location));\n   start_stmt_group ();\n   for (gnat_when = First_Non_Pragma (Alternatives (gnat_node));\n@@ -2025,16 +2017,16 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t{\n \t  add_stmt (build_stmt_group (Statements (gnat_when), true));\n \t  add_stmt (build1 (GOTO_EXPR, void_type_node,\n-\t\t\t    TREE_VALUE (gnu_switch_label_stack)));\n+\t\t\t    VEC_last (tree, gnu_switch_label_stack)));\n \t}\n     }\n \n   /* Now emit a definition of the label all the cases branched to.  */\n   add_stmt (build1 (LABEL_EXPR, void_type_node,\n-\t\t    TREE_VALUE (gnu_switch_label_stack)));\n+\t\t    VEC_last (tree, gnu_switch_label_stack)));\n   gnu_result = build3 (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,\n \t\t       end_stmt_group (), NULL_TREE);\n-  pop_stack (&gnu_switch_label_stack);\n+  pop_stack (gnu_switch_label_stack);\n \n   return gnu_result;\n }\n@@ -2100,7 +2092,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n   /* Save the end label of this LOOP_STMT in a stack so that a corresponding\n      N_Exit_Statement can find it.  */\n-  push_stack (&gnu_loop_label_stack, NULL_TREE, gnu_loop_label);\n+  push_stack (&gnu_loop_label_stack, gnu_loop_label);\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2317,7 +2309,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   else\n     gnu_result = gnu_loop_stmt;\n \n-  pop_stack (&gnu_loop_label_stack);\n+  pop_stack (gnu_loop_label_stack);\n \n   return gnu_result;\n }\n@@ -2450,7 +2442,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      properly copies them out.  We do this by making a new block and converting\n      any inner return into a goto to a label at the end of the block.  */\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n-  push_stack (&gnu_return_label_stack, NULL_TREE,\n+  push_stack (&gnu_return_label_stack,\n \t      gnu_cico_list ? create_artificial_label (input_location)\n \t      : NULL_TREE);\n \n@@ -2540,15 +2532,15 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n        We need to make a block that contains the definition of that label and\n        the copying of the return value.  It first contains the function, then\n        the label and copy statement.  */\n-  if (TREE_VALUE (gnu_return_label_stack))\n+  if (VEC_last (tree, gnu_return_label_stack))\n     {\n       tree gnu_retval;\n \n       start_stmt_group ();\n       gnat_pushlevel ();\n       add_stmt (gnu_result);\n       add_stmt (build1 (LABEL_EXPR, void_type_node,\n-\t\t\tTREE_VALUE (gnu_return_label_stack)));\n+\t\t\tVEC_last (tree, gnu_return_label_stack)));\n \n       gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n       if (list_length (gnu_cico_list) == 1)\n@@ -2563,7 +2555,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       gnu_result = end_stmt_group ();\n     }\n \n-  pop_stack (&gnu_return_label_stack);\n+  pop_stack (gnu_return_label_stack);\n \n   /* Set the end location.  */\n   Sloc_to_locus\n@@ -2666,7 +2658,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n      so we can give them the scope of the elaboration routine at top level.  */\n   else if (!current_function_decl)\n     {\n-      current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n+      current_function_decl = VEC_last (tree, gnu_elab_proc_stack);\n       went_into_elab_proc = true;\n     }\n \n@@ -3260,7 +3252,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       start_stmt_group ();\n       gnat_pushlevel ();\n \n-      push_stack (&gnu_except_ptr_stack, NULL_TREE,\n+      push_stack (&gnu_except_ptr_stack,\n \t\t  create_var_decl (get_identifier (\"EXCEPT_PTR\"),\n \t\t\t\t   NULL_TREE,\n \t\t\t\t   build_pointer_type (except_type_node),\n@@ -3289,7 +3281,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       /* If none of the exception handlers did anything, re-raise but do not\n \t defer abortion.  */\n       gnu_expr = build_call_1_expr (raise_nodefer_decl,\n-\t\t\t\t    TREE_VALUE (gnu_except_ptr_stack));\n+\t\t\t\t    VEC_last (tree, gnu_except_ptr_stack));\n       set_expr_location_from_node\n \t(gnu_expr,\n \t Present (End_Label (gnat_node)) ? End_Label (gnat_node) : gnat_node);\n@@ -3301,7 +3293,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \n       /* End the binding level dedicated to the exception handlers and get the\n \t whole statement group.  */\n-      pop_stack (&gnu_except_ptr_stack);\n+      pop_stack (gnu_except_ptr_stack);\n       gnat_poplevel ();\n       gnu_handler = end_stmt_group ();\n \n@@ -3385,7 +3377,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t  build_component_ref\n \t\t  (build_unary_op\n \t\t   (INDIRECT_REF, NULL_TREE,\n-\t\t    TREE_VALUE (gnu_except_ptr_stack)),\n+\t\t    VEC_last (tree, gnu_except_ptr_stack)),\n \t\t   get_identifier (\"not_handled_by_others\"), NULL_TREE,\n \t\t   false)),\n \t\t integer_zero_node);\n@@ -3406,8 +3398,9 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \n \t  this_choice\n \t    = build_binary_op\n-\t      (EQ_EXPR, boolean_type_node, TREE_VALUE (gnu_except_ptr_stack),\n-\t       convert (TREE_TYPE (TREE_VALUE (gnu_except_ptr_stack)),\n+\t      (EQ_EXPR, boolean_type_node,\n+\t       VEC_last (tree, gnu_except_ptr_stack),\n+\t       convert (TREE_TYPE (VEC_last (tree, gnu_except_ptr_stack)),\n \t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr)));\n \n \t  /* If this is the distinguished exception \"Non_Ada_Error\" (and we are\n@@ -3418,7 +3411,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t      tree gnu_comp\n \t\t= build_component_ref\n \t\t  (build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t   TREE_VALUE (gnu_except_ptr_stack)),\n+\t\t\t\t   VEC_last (tree, gnu_except_ptr_stack)),\n \t\t   get_identifier (\"lang\"), NULL_TREE, false);\n \n \t      this_choice\n@@ -3555,7 +3548,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n        NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL, gnat_unit);\n   struct elab_info *info;\n \n-  push_stack (&gnu_elab_proc_stack, NULL_TREE, gnu_elab_proc_decl);\n+  push_stack (&gnu_elab_proc_stack, gnu_elab_proc_decl);\n   DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n \n   /* Initialize the information structure for the function.  */\n@@ -3642,7 +3635,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n \n   /* Generate elaboration code for this unit, if necessary, and say whether\n      we did or not.  */\n-  pop_stack (&gnu_elab_proc_stack);\n+  pop_stack (gnu_elab_proc_stack);\n \n   /* Invalidate the global renaming pointers.  This is necessary because\n      stabilization of the renamed entities may create SAVE_EXPRs which\n@@ -3744,7 +3737,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t the elaboration procedure, so mark us as being in that procedure.  */\n       if (!current_function_decl)\n \t{\n-\t  current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n+\t  current_function_decl = VEC_last (tree, gnu_elab_proc_stack);\n \t  went_into_elab_proc = true;\n \t}\n \n@@ -3755,7 +3748,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t every nested real statement instead.  This also avoids triggering\n \t spurious errors on dummy (empty) sequences created by the front-end\n \t for package bodies in some cases.  */\n-      if (current_function_decl == TREE_VALUE (gnu_elab_proc_stack)\n+      if (current_function_decl == VEC_last (tree, gnu_elab_proc_stack)\n \t  && kind != N_Handled_Sequence_Of_Statements)\n \tCheck_Elaboration_Code_Allowed (gnat_node);\n     }\n@@ -4879,7 +4872,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n \t\t  (Present (Name (gnat_node))\n \t\t   ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t   : TREE_VALUE (gnu_loop_label_stack)));\n+\t\t   : VEC_last (tree, gnu_loop_label_stack)));\n       break;\n \n     case N_Return_Statement:\n@@ -4888,13 +4881,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t/* If we have a return label defined, convert this into a branch to\n \t   that label.  The return proper will be handled elsewhere.  */\n-\tif (TREE_VALUE (gnu_return_label_stack))\n+\tif (VEC_last (tree, gnu_return_label_stack))\n \t  {\n \t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n-\t\t\t\t TREE_VALUE (gnu_return_label_stack));\n+\t\t\t\t VEC_last (tree, gnu_return_label_stack));\n \t    /* When not optimizing, make sure the return is preserved.  */\n \t    if (!optimize && Comes_From_Source (gnat_node))\n-\t      DECL_ARTIFICIAL (TREE_VALUE (gnu_return_label_stack)) = 0;\n+\t      DECL_ARTIFICIAL (VEC_last (tree, gnu_return_label_stack)) = 0;\n \t    break;\n \t  }\n \n@@ -5154,18 +5147,15 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Pop_Constraint_Error_Label:\n-      gnu_constraint_error_label_stack\n-\t= TREE_CHAIN (gnu_constraint_error_label_stack);\n+      VEC_pop (tree, gnu_constraint_error_label_stack);\n       break;\n \n     case N_Pop_Storage_Error_Label:\n-      gnu_storage_error_label_stack\n-\t= TREE_CHAIN (gnu_storage_error_label_stack);\n+      VEC_pop (tree, gnu_storage_error_label_stack);\n       break;\n \n     case N_Pop_Program_Error_Label:\n-      gnu_program_error_label_stack\n-\t= TREE_CHAIN (gnu_program_error_label_stack);\n+      VEC_pop (tree, gnu_program_error_label_stack);\n       break;\n \n     /******************************/\n@@ -5682,13 +5672,13 @@ gnat_to_gnu (Node_Id gnat_node)\n    label to push onto the stack.  */\n \n static void\n-push_exception_label_stack (tree *gnu_stack, Entity_Id gnat_label)\n+push_exception_label_stack (VEC(tree,gc) **gnu_stack, Entity_Id gnat_label)\n {\n   tree gnu_label = (Present (gnat_label)\n \t\t    ? gnat_to_gnu_entity (gnat_label, NULL_TREE, 0)\n \t\t    : NULL_TREE);\n \n-  *gnu_stack = tree_cons (NULL_TREE, gnu_label, *gnu_stack);\n+  VEC_safe_push (tree, gc, *gnu_stack, gnu_label);\n }\n \f\n /* Record the current code position in GNAT_NODE.  */\n@@ -5938,35 +5928,18 @@ build_stmt_group (List_Id gnat_list, bool binding_p)\n   return end_stmt_group ();\n }\n \f\n-/* Push and pop routines for stacks.  We keep a free list around so we\n-   don't waste tree nodes.  */\n+/* Push and pop routines for stacks.  */\n \n static void\n-push_stack (tree *gnu_stack_ptr, tree gnu_purpose, tree gnu_value)\n+push_stack (VEC(tree,gc) **gnu_stack_ptr, tree value)\n {\n-  tree gnu_node = gnu_stack_free_list;\n-\n-  if (gnu_node)\n-    {\n-      gnu_stack_free_list = TREE_CHAIN (gnu_node);\n-      TREE_CHAIN (gnu_node) = *gnu_stack_ptr;\n-      TREE_PURPOSE (gnu_node) = gnu_purpose;\n-      TREE_VALUE (gnu_node) = gnu_value;\n-    }\n-  else\n-    gnu_node = tree_cons (gnu_purpose, gnu_value, *gnu_stack_ptr);\n-\n-  *gnu_stack_ptr = gnu_node;\n+  VEC_safe_push (tree, gc, *gnu_stack_ptr, value);\n }\n \n static void\n-pop_stack (tree *gnu_stack_ptr)\n+pop_stack (VEC(tree,gc) *gnu_stack)\n {\n-  tree gnu_node = *gnu_stack_ptr;\n-\n-  *gnu_stack_ptr = TREE_CHAIN (gnu_node);\n-  TREE_CHAIN (gnu_node) = gnu_stack_free_list;\n-  gnu_stack_free_list = gnu_node;\n+  VEC_pop (tree, gnu_stack);\n }\n \f\n /* Generate GIMPLE in place for the expression at *EXPR_P.  */\n@@ -7641,11 +7614,11 @@ tree\n get_exception_label (char kind)\n {\n   if (kind == N_Raise_Constraint_Error)\n-    return TREE_VALUE (gnu_constraint_error_label_stack);\n+    return VEC_last (tree, gnu_constraint_error_label_stack);\n   else if (kind == N_Raise_Storage_Error)\n-    return TREE_VALUE (gnu_storage_error_label_stack);\n+    return VEC_last (tree, gnu_storage_error_label_stack);\n   else if (kind == N_Raise_Program_Error)\n-    return TREE_VALUE (gnu_program_error_label_stack);\n+    return VEC_last (tree, gnu_program_error_label_stack);\n   else\n     return NULL_TREE;\n }"}]}