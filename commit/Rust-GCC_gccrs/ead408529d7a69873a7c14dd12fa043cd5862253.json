{"sha": "ead408529d7a69873a7c14dd12fa043cd5862253", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkNDA4NTI5ZDdhNjk4NzNhN2MxNGRkMTJmYTA0M2NkNTg2MjI1Mw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-25T20:10:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-25T21:28:47Z"}, "message": "libstdc++: Fix conditions for optimizing uninitialized algos [PR102064]\n\nWhile laying some groundwork for constexpr std::vector, I noticed some\nbugs in the std::uninitialized_xxx algorithms. The conditions being\nchecked for optimizing trivial cases were not quite right, as shown in\nthe examples in the PR.\n\nThis consolidates the checks into a single macro. The macro has\nappropriate definitions for C++98 or for later standards, to avoid a #if\neverywhere the checks are used. For C++11 and later the check makes a\ncall to a new function doing a static_assert to ensure we don't use\nassignment in cases where construction would have been invalid.\nExtracting that check to a separate function will be useful for\nconstexpr std::vector, as that can't use std::uninitialized_copy\ndirectly because it isn't constexpr).\n\nThe consolidated checks mean that some slight variations in static\nassert message are gone, as there is only one place that does the assert\nnow. That required adjusting some tests. As part of that the redundant\n89164_c++17.cc test was merged into 89164.cc which is compiled as C++17\nby default now, but can also use other -std options if the\nC++17-specific error is made conditional with a target selector.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/102064\n\t* include/bits/stl_uninitialized.h (_GLIBCXX_USE_ASSIGN_FOR_INIT):\n\tDefine macro to check conditions for optimizing trivial cases.\n\t(__check_constructible): New function to do static assert.\n\t(uninitialized_copy, uninitialized_fill, uninitialized_fill_n):\n\tUse new macro.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc:\n\tAdjust dg-error pattern.\n\t* testsuite/23_containers/vector/cons/89164.cc: Likewise. Add\n\tC++17-specific checks from 89164_c++17.cc.\n\t* testsuite/23_containers/vector/cons/89164_c++17.cc: Removed.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_copy/102064.cc:\n\tNew test.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_copy_n/102064.cc:\n\tNew test.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_fill/102064.cc:\n\tNew test.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_fill_n/102064.cc:\n\tNew test.", "tree": {"sha": "ff885cebb8582ebf78c7bba6c66779e6ec131239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff885cebb8582ebf78c7bba6c66779e6ec131239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead408529d7a69873a7c14dd12fa043cd5862253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead408529d7a69873a7c14dd12fa043cd5862253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead408529d7a69873a7c14dd12fa043cd5862253", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead408529d7a69873a7c14dd12fa043cd5862253/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cd229dec8d6716938de5052479d059d306969da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd229dec8d6716938de5052479d059d306969da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cd229dec8d6716938de5052479d059d306969da"}], "stats": {"total": 367, "additions": 275, "deletions": 92}, "files": [{"sha": "ddc1405cb0e660882dfb700e2542f26f709b4703", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -77,6 +77,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// @cond undocumented\n \n+#if __cplusplus >= 201103L\n+  template<typename _ValueType, typename _Tp>\n+    constexpr bool\n+    __check_constructible()\n+    {\n+      // Trivial types can have deleted constructors, but std::copy etc.\n+      // only use assignment (or memmove) not construction, so we need an\n+      // explicit check that construction from _Tp is actually valid,\n+      // otherwise some ill-formed uses of std::uninitialized_xxx would\n+      // compile without errors. This gives a nice clear error message.\n+      static_assert(is_constructible<_ValueType, _Tp>::value,\n+\t  \"result type must be constructible from input type\");\n+\n+      return true;\n+    }\n+\n+// If the type is trivial we don't need to construct it, just assign to it.\n+// But trivial types can still have deleted or inaccessible assignment,\n+// so don't try to use std::copy or std::fill etc. if we can't assign.\n+# define _GLIBCXX_USE_ASSIGN_FOR_INIT(T, U) \\\n+    __is_trivial(T) && __is_assignable(T&, U) \\\n+    && std::__check_constructible<T, U>()\n+#else\n+// No need to check if is_constructible<T, U> for C++98. Trivial types have\n+// no user-declared constructors, so if the assignment is valid, construction\n+// should be too.\n+# define _GLIBCXX_USE_ASSIGN_FOR_INIT(T, U) \\\n+    __is_trivial(T) && __is_assignable(T&, U)\n+#endif\n+\n   template<bool _TrivialValueTypes>\n     struct __uninitialized_copy\n     {\n@@ -130,24 +160,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_ValueType1;\n       typedef typename iterator_traits<_ForwardIterator>::value_type\n \t_ValueType2;\n+\n+      // _ValueType1 must be trivially-copyable to use memmove, so don't\n+      // both optimizing to std::copy if it isn't.\n+      // XXX Unnecessary because std::copy would check it anyway?\n+      const bool __can_memmove = __is_trivial(_ValueType1);\n+\n #if __cplusplus < 201103L\n-      const bool __assignable = true;\n+      typedef typename iterator_traits<_InputIterator>::reference _From;\n #else\n-      // Trivial types can have deleted copy constructor, but the std::copy\n-      // optimization that uses memmove would happily \"copy\" them anyway.\n-      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,\n-\t  \"result type must be constructible from value type of input range\");\n-\n-      typedef typename iterator_traits<_InputIterator>::reference _RefType1;\n-      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;\n-      // Trivial types can have deleted assignment, so using std::copy\n-      // would be ill-formed. Require assignability before using std::copy:\n-      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;\n+      using _From = decltype(*__first);\n #endif\n+      const bool __assignable\n+\t= _GLIBCXX_USE_ASSIGN_FOR_INIT(_ValueType2, _From);\n \n-      return std::__uninitialized_copy<__is_trivial(_ValueType1)\n-\t\t\t\t       && __is_trivial(_ValueType2)\n-\t\t\t\t       && __assignable>::\n+      return std::__uninitialized_copy<__can_memmove && __assignable>::\n \t__uninit_copy(__first, __last, __result);\n     }\n \n@@ -203,20 +230,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type\n \t_ValueType;\n-#if __cplusplus < 201103L\n-      const bool __assignable = true;\n-#else\n-      // Trivial types can have deleted copy constructor, but the std::fill\n-      // optimization that uses memmove would happily \"copy\" them anyway.\n-      static_assert(is_constructible<_ValueType, const _Tp&>::value,\n-\t  \"result type must be constructible from input type\");\n \n-      // Trivial types can have deleted assignment, so using std::fill\n-      // would be ill-formed. Require assignability before using std::fill:\n-      const bool __assignable = is_copy_assignable<_ValueType>::value;\n-#endif\n+      // Trivial types do not need a constructor to begin their lifetime,\n+      // so try to use std::fill to benefit from its memset optimization.\n+      const bool __can_fill\n+\t= _GLIBCXX_USE_ASSIGN_FOR_INIT(_ValueType, const _Tp&);\n \n-      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::\n+      std::__uninitialized_fill<__can_fill>::\n \t__uninit_fill(__first, __last, __x);\n     }\n \n@@ -276,27 +296,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_ValueType;\n \n       // Trivial types do not need a constructor to begin their lifetime,\n-      // so try to use std::fill_n to benefit from its memmove optimization.\n+      // so try to use std::fill_n to benefit from its optimizations.\n+      const bool __can_fill\n+\t= _GLIBCXX_USE_ASSIGN_FOR_INIT(_ValueType, const _Tp&)\n       // For arbitrary class types and floating point types we can't assume\n       // that __n > 0 and std::__size_to_integer(__n) > 0 are equivalent,\n       // so only use std::fill_n when _Size is already an integral type.\n-#if __cplusplus < 201103L\n-      const bool __can_fill = __is_integer<_Size>::__value;\n-#else\n-      // Trivial types can have deleted copy constructor, but the std::fill_n\n-      // optimization that uses memmove would happily \"copy\" them anyway.\n-      static_assert(is_constructible<_ValueType, const _Tp&>::value,\n-\t  \"result type must be constructible from input type\");\n+\t&& __is_integer<_Size>::__value;\n \n-      // Trivial types can have deleted assignment, so using std::fill_n\n-      // would be ill-formed. Require assignability before using std::fill_n:\n-      constexpr bool __can_fill\n-\t= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;\n-#endif\n-      return __uninitialized_fill_n<__is_trivial(_ValueType) && __can_fill>::\n+      return __uninitialized_fill_n<__can_fill>::\n \t__uninit_fill_n(__first, __n, __x);\n     }\n \n+#undef _GLIBCXX_USE_ASSIGN_FOR_INIT\n+\n   /// @cond undocumented\n \n   // Extensions: versions of uninitialized_copy, uninitialized_fill,\n@@ -864,6 +877,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @param  __n      The number of elements to copy.\n    *  @param  __result An output iterator.\n    *  @return  __result + __n\n+   *  @since C++11\n    *\n    *  Like copy_n(), but does not require an initialized output range.\n   */\n@@ -894,6 +908,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @brief Default-initializes objects in the range [first,last).\n    *  @param  __first  A forward iterator.\n    *  @param  __last   A forward iterator.\n+   *  @since C++17\n   */\n   template <typename _ForwardIterator>\n     inline void\n@@ -908,6 +923,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @param  __first  A forward iterator.\n    *  @param  __count  The number of objects to construct.\n    *  @return   __first + __count\n+   *  @since C++17\n   */\n   template <typename _ForwardIterator, typename _Size>\n     inline _ForwardIterator\n@@ -920,6 +936,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @brief Value-initializes objects in the range [first,last).\n    *  @param  __first  A forward iterator.\n    *  @param  __last   A forward iterator.\n+   *  @since C++17\n   */\n   template <typename _ForwardIterator>\n     inline void\n@@ -934,6 +951,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @param  __first  A forward iterator.\n    *  @param  __count  The number of objects to construct.\n    *  @return   __result + __count\n+   *  @since C++17\n   */\n   template <typename _ForwardIterator, typename _Size>\n     inline _ForwardIterator\n@@ -948,6 +966,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @param  __last   An input iterator.\n    *  @param  __result An output iterator.\n    *  @return   __result + (__first - __last)\n+   *  @since C++17\n   */\n   template <typename _InputIterator, typename _ForwardIterator>\n     inline _ForwardIterator\n@@ -965,6 +984,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @param  __count  The number of objects to initialize.\n    *  @param  __result An output iterator.\n    *  @return  __result + __count\n+   *  @since C++17\n   */\n   template <typename _InputIterator, typename _Size, typename _ForwardIterator>\n     inline pair<_InputIterator, _ForwardIterator>"}, {"sha": "6b43b58b2776710bc6469c87513c533ec81b7ec5", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/1.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2F1.cc?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -34,4 +34,4 @@ test01(T* result)\n   T t[1];\n   std::uninitialized_copy(t, t+1, result); // { dg-error \"here\" }\n }\n-// { dg-error \"constructible from value\" \"\" { target *-*-* } 0 }\n+// { dg-error \"must be constructible from input type\" \"\" { target *-*-* } 0 }"}, {"sha": "27d37aab09f4f7f822a167020219a4d6dec1fea8", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/102064.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2F102064.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2F102064.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2F102064.cc?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do compile }\n+\n+#include <memory>\n+#include <algorithm>\n+\n+struct X;\n+\n+struct Y\n+{\n+  operator X() const;\n+};\n+\n+struct X\n+{\n+private:\n+  void operator=(const Y&);\n+};\n+\n+Y::operator X() const { return X(); }\n+\n+#if __cplusplus >= 201103L\n+static_assert( std::is_trivial<X>::value, \"\" );\n+#endif\n+\n+void test01_pr102064()\n+{\n+  unsigned char buf[sizeof(X)];\n+  X* addr = reinterpret_cast<X*>(buf);\n+  const Y y[1] = { };\n+  std::uninitialized_copy(y, y + 1, addr);\n+}\n+\n+#if __cplusplus >= 201103L\n+struct Z\n+{\n+  Z() = default;\n+  Z(int) { }\n+  Z(const Z&) = default;\n+  Z& operator=(const Z&) = default;\n+  Z& operator=(int) = delete;\n+};\n+\n+static_assert( std::is_trivial<Z>::value, \"\" );\n+\n+void test02_pr102064()\n+{\n+  unsigned char buf[sizeof(Z)];\n+  Z* addr = reinterpret_cast<Z*>(buf);\n+  const int i[1] = { 99 };\n+  std::uninitialized_copy(i, i + 1, addr);\n+}\n+#endif"}, {"sha": "963e1531a71bba0c3fd5d7a5c9febd89b8529a72", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy_n/102064.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy_n%2F102064.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy_n%2F102064.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy_n%2F102064.cc?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile { target c++11 } }\n+\n+#include <memory>\n+#include <algorithm>\n+\n+struct X;\n+\n+struct Y\n+{\n+  operator X() const;\n+};\n+\n+struct X\n+{\n+private:\n+  void operator=(const Y&);\n+};\n+\n+Y::operator X() const { return X(); }\n+\n+static_assert( std::is_trivial<X>::value, \"\" );\n+\n+void test01_pr102064()\n+{\n+  unsigned char buf[sizeof(X)];\n+  X* addr = reinterpret_cast<X*>(buf);\n+  const Y y[1] = { };\n+  std::uninitialized_copy_n(y, 1, addr);\n+}\n+\n+struct Z\n+{\n+  Z() = default;\n+  Z(int) { }\n+  Z(const Z&) = default;\n+  Z& operator=(const Z&) = default;\n+  Z& operator=(int) = delete;\n+};\n+\n+static_assert( std::is_trivial<Z>::value, \"\" );\n+\n+void test02_pr102064()\n+{\n+  unsigned char buf[sizeof(Z)];\n+  Z* addr = reinterpret_cast<Z*>(buf);\n+  const int i[1] = { 99 };\n+  std::uninitialized_copy_n(i, 1, addr);\n+}"}, {"sha": "7eb49b543a41bf07035045cb44ce870c6f2fdb6f", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/102064.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill%2F102064.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill%2F102064.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill%2F102064.cc?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do compile }\n+\n+#include <memory>\n+#include <algorithm>\n+\n+struct X;\n+\n+struct Y\n+{\n+  operator X() const;\n+};\n+\n+struct X\n+{\n+private:\n+  void operator=(const Y&);\n+};\n+\n+Y::operator X() const { return X(); }\n+\n+#if __cplusplus >= 201103L\n+static_assert( std::is_trivial<X>::value, \"\" );\n+#endif\n+\n+void test01_pr102064()\n+{\n+  unsigned char buf[sizeof(X)];\n+  X* addr = reinterpret_cast<X*>(buf);\n+  Y y;\n+  std::uninitialized_fill(addr, addr + 1, y);\n+}\n+\n+#if __cplusplus >= 201103L\n+struct Z\n+{\n+  Z() = default;\n+  Z(int) { }\n+  Z(const Z&) = default;\n+  Z& operator=(const Z&) = default;\n+  Z& operator=(int) = delete;\n+};\n+\n+static_assert( std::is_trivial<Z>::value, \"\" );\n+\n+void test02_pr102064()\n+{\n+  unsigned char buf[sizeof(Z)];\n+  Z* addr = reinterpret_cast<Z*>(buf);\n+  std::uninitialized_fill(addr, addr + 1, 99);\n+}\n+#endif"}, {"sha": "e4f2139cf6da31718ec23442d2bd2ab42185f81a", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill_n/102064.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill_n%2F102064.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill_n%2F102064.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill_n%2F102064.cc?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do compile }\n+\n+#include <memory>\n+#include <algorithm>\n+\n+struct X;\n+\n+struct Y\n+{\n+  operator X() const;\n+};\n+\n+struct X\n+{\n+private:\n+  void operator=(const Y&);\n+};\n+\n+Y::operator X() const { return X(); }\n+\n+#if __cplusplus >= 201103L\n+static_assert( std::is_trivial<X>::value, \"\" );\n+#endif\n+\n+void test01_pr102064()\n+{\n+  unsigned char buf[sizeof(X)];\n+  X* addr = reinterpret_cast<X*>(buf);\n+  Y y;\n+  std::uninitialized_fill_n(addr, 1, y);\n+}\n+\n+#if __cplusplus >= 201103L\n+struct Z\n+{\n+  Z() = default;\n+  Z(int) { }\n+  Z(const Z&) = default;\n+  Z& operator=(const Z&) = default;\n+  Z& operator=(int) = delete;\n+};\n+\n+static_assert( std::is_trivial<Z>::value, \"\" );\n+\n+void test02_pr102064()\n+{\n+  unsigned char buf[sizeof(Z)];\n+  Z* addr = reinterpret_cast<Z*>(buf);\n+  std::uninitialized_fill_n(addr, 1, 99);\n+}\n+#endif"}, {"sha": "302af9c2e97f838d64ea07df7ac3ec4fbea04aec", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/89164.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead408529d7a69873a7c14dd12fa043cd5862253/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164.cc?ref=ead408529d7a69873a7c14dd12fa043cd5862253", "patch": "@@ -36,5 +36,15 @@ void test01()\n   // Should not be able to create vector using uninitialized_fill_n:\n   std::vector<X> v2{2u, X{}};\t// { dg-error \"here\" }\n }\n-// { dg-error \"constructible from value\" \"\" { target *-*-* } 0 }\n-// { dg-error \"constructible from input\" \"\" { target *-*-* } 0 }\n+\n+void test02()\n+{\n+#if __cplusplus >= 201703L\n+  struct Y : X { };\n+  // Can create initializer_list<Y> with C++17 guaranteed copy elision,\n+  // but shouldn't be able to copy from it with uninitialized_copy:\n+  std::vector<Y> v3{Y{}, Y{}, Y{}};   // { dg-error \"here\" \"\" { target c++17 } }\n+#endif\n+}\n+\n+// { dg-error \"must be constructible from input type\" \"\" { target *-*-* } 0 }"}, {"sha": "78aadc4798b3f88e30eb41e214115e2ca3a5d357", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/89164_c++17.cc", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cd229dec8d6716938de5052479d059d306969da/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164_c%2B%2B17.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cd229dec8d6716938de5052479d059d306969da/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164_c%2B%2B17.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2F89164_c%2B%2B17.cc?ref=2cd229dec8d6716938de5052479d059d306969da", "patch": "@@ -1,49 +0,0 @@\n-// Copyright (C) 2019-2021 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// { dg-do compile { target c++17 } }\n-\n-#include <vector>\n-\n-// PR libstdc++/89164\n-\n-struct X\n-{\n-  X() = default;\n-  X(const X&) = delete;\n-};\n-\n-void test01()\n-{\n-  X x[1];\n-  // Should not be able to create vector using uninitialized_copy:\n-  std::vector<X> v1{x, x+1};\t// { dg-error \"here\" }\n-\n-  // Should not be able to create vector using uninitialized_fill_n:\n-  std::vector<X> v2{2u, X{}};\t// { dg-error \"here\" }\n-}\n-\n-void test02()\n-{\n-#if __cplusplus >= 201703L\n-  // Can create initializer_list<X> with C++17 guaranteed copy elision,\n-  // but shouldn't be able to copy from it with uninitialized_copy:\n-  std::vector<X> v3{X{}, X{}, X{}};   // { dg-error \"here\" }\n-#endif\n-}\n-// { dg-error \"constructible from value\" \"\" { target *-*-* } 0 }\n-// { dg-error \"constructible from input\" \"\" { target *-*-* } 0 }"}]}