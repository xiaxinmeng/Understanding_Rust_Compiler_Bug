{"sha": "789410e4824b60f423f7855d68f234e02f9300fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg5NDEwZTQ4MjRiNjBmNDIzZjc4NTVkNjhmMjM0ZTAyZjkzMDBmYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-20T08:51:45Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-20T08:51:45Z"}, "message": "Transform switch_conversion into a class.\n\n2018-06-20  Martin Liska  <mliska@suse.cz>\n\n\t* tree-switch-conversion.c (MAX_CASE_BIT_TESTS): Remove.\n\t(hoist_edge_and_branch_if_true): Likewise.\n\t(expand_switch_using_bit_tests_p): Likewise.\n\t(struct case_bit_test): Likewise.\n\t(case_bit_test_cmp): Likewise.\n\t(emit_case_bit_tests): Likewise.\n\t(switch_conversion::switch_conversion): New class.\n\t(struct switch_conv_info): Remove old struct.\n\t(collect_switch_conv_info): More to ...\n\t(switch_conversion::collect): ... this.\n\t(check_range): Likewise.\n\t(switch_conversion::check_range): Likewise.\n\t(check_all_empty_except_final): Likewise.\n\t(switch_conversion::check_all_empty_except_final): Likewise.\n\t(check_final_bb): Likewise.\n\t(switch_conversion::check_final_bb): Likewise.\n\t(create_temp_arrays): Likewise.\n\t(switch_conversion::create_temp_arrays): Likewise.\n\t(free_temp_arrays): Likewise.\n\t(gather_default_values): Likewise.\n\t(switch_conversion::gather_default_values): Likewise.\n\t(build_constructors): Likewise.\n\t(switch_conversion::build_constructors): Likewise.\n\t(constructor_contains_same_values_p): Likewise.\n\t(switch_conversion::contains_same_values_p): Likewise.\n\t(array_value_type): Likewise.\n\t(switch_conversion::array_value_type): Likewise.\n\t(build_one_array): Likewise.\n\t(switch_conversion::build_one_array): Likewise.\n\t(build_arrays): Likewise.\n\t(switch_conversion::build_arrays): Likewise.\n\t(gen_def_assigns): Likewise.\n\t(switch_conversion::gen_def_assigns): Likewise.\n\t(prune_bbs): Likewise.\n\t(switch_conversion::prune_bbs): Likewise.\n\t(fix_phi_nodes): Likewise.\n\t(switch_conversion::fix_phi_nodes): Likewise.\n\t(gen_inbound_check): Likewise.\n\t(switch_conversion::gen_inbound_check): Likewise.\n\t(process_switch): Use the newly created class.\n\t(switch_conversion::expand): New.\n\t(switch_conversion::~switch_conversion): New.\n\t* tree-switch-conversion.h: New file.\n\nFrom-SVN: r261792", "tree": {"sha": "9755289956547d66f8f565d1b6b35847e3bdbcfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9755289956547d66f8f565d1b6b35847e3bdbcfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/789410e4824b60f423f7855d68f234e02f9300fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/789410e4824b60f423f7855d68f234e02f9300fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/789410e4824b60f423f7855d68f234e02f9300fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/789410e4824b60f423f7855d68f234e02f9300fb/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701"}], "stats": {"total": 1413, "additions": 566, "deletions": 847}, "files": [{"sha": "61759ed5776a250d00d524b2f3a22fb3f9e5fd13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/789410e4824b60f423f7855d68f234e02f9300fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/789410e4824b60f423f7855d68f234e02f9300fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=789410e4824b60f423f7855d68f234e02f9300fb", "patch": "@@ -1,3 +1,49 @@\n+2018-06-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-switch-conversion.c (MAX_CASE_BIT_TESTS): Remove.\n+\t(hoist_edge_and_branch_if_true): Likewise.\n+\t(expand_switch_using_bit_tests_p): Likewise.\n+\t(struct case_bit_test): Likewise.\n+\t(case_bit_test_cmp): Likewise.\n+\t(emit_case_bit_tests): Likewise.\n+\t(switch_conversion::switch_conversion): New class.\n+\t(struct switch_conv_info): Remove old struct.\n+\t(collect_switch_conv_info): More to ...\n+\t(switch_conversion::collect): ... this.\n+\t(check_range): Likewise.\n+\t(switch_conversion::check_range): Likewise.\n+\t(check_all_empty_except_final): Likewise.\n+\t(switch_conversion::check_all_empty_except_final): Likewise.\n+\t(check_final_bb): Likewise.\n+\t(switch_conversion::check_final_bb): Likewise.\n+\t(create_temp_arrays): Likewise.\n+\t(switch_conversion::create_temp_arrays): Likewise.\n+\t(free_temp_arrays): Likewise.\n+\t(gather_default_values): Likewise.\n+\t(switch_conversion::gather_default_values): Likewise.\n+\t(build_constructors): Likewise.\n+\t(switch_conversion::build_constructors): Likewise.\n+\t(constructor_contains_same_values_p): Likewise.\n+\t(switch_conversion::contains_same_values_p): Likewise.\n+\t(array_value_type): Likewise.\n+\t(switch_conversion::array_value_type): Likewise.\n+\t(build_one_array): Likewise.\n+\t(switch_conversion::build_one_array): Likewise.\n+\t(build_arrays): Likewise.\n+\t(switch_conversion::build_arrays): Likewise.\n+\t(gen_def_assigns): Likewise.\n+\t(switch_conversion::gen_def_assigns): Likewise.\n+\t(prune_bbs): Likewise.\n+\t(switch_conversion::prune_bbs): Likewise.\n+\t(fix_phi_nodes): Likewise.\n+\t(switch_conversion::fix_phi_nodes): Likewise.\n+\t(gen_inbound_check): Likewise.\n+\t(switch_conversion::gen_inbound_check): Likewise.\n+\t(process_switch): Use the newly created class.\n+\t(switch_conversion::expand): New.\n+\t(switch_conversion::~switch_conversion): New.\n+\t* tree-switch-conversion.h: New file.\n+\n 2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (NUM_PATTERNS, vect_recog_func_ptr): Move to"}, {"sha": "e8b44bdd2d86b874572ef86eecb7fae4535dc13b", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 254, "deletions": 847, "changes": 1101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/789410e4824b60f423f7855d68f234e02f9300fb/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/789410e4824b60f423f7855d68f234e02f9300fb/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=789410e4824b60f423f7855d68f234e02f9300fb", "patch": "@@ -55,626 +55,78 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    type in the GIMPLE type system that is language-independent?  */\n #include \"langhooks.h\"\n \n+#include \"tree-switch-conversion.h\"\n \f\n-/* Maximum number of case bit tests.\n-   FIXME: This should be derived from PARAM_CASE_VALUES_THRESHOLD and\n-\t  targetm.case_values_threshold(), or be its own param.  */\n-#define MAX_CASE_BIT_TESTS  3\n-\n-/* Track whether or not we have altered the CFG and thus may need to\n-   cleanup the CFG when complete.  */\n-bool cfg_altered;\n-\n-/* Split the basic block at the statement pointed to by GSIP, and insert\n-   a branch to the target basic block of E_TRUE conditional on tree\n-   expression COND.\n-\n-   It is assumed that there is already an edge from the to-be-split\n-   basic block to E_TRUE->dest block.  This edge is removed, and the\n-   profile information on the edge is re-used for the new conditional\n-   jump.\n-   \n-   The CFG is updated.  The dominator tree will not be valid after\n-   this transformation, but the immediate dominators are updated if\n-   UPDATE_DOMINATORS is true.\n-   \n-   Returns the newly created basic block.  */\n+using namespace tree_switch_conversion;\n \n-static basic_block\n-hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n-\t\t\t       tree cond, edge e_true,\n-\t\t\t       bool update_dominators)\n-{\n-  tree tmp;\n-  gcond *cond_stmt;\n-  edge e_false;\n-  basic_block new_bb, split_bb = gsi_bb (*gsip);\n-  bool dominated_e_true = false;\n-\n-  gcc_assert (e_true->src == split_bb);\n-\n-  if (update_dominators\n-      && get_immediate_dominator (CDI_DOMINATORS, e_true->dest) == split_bb)\n-    dominated_e_true = true;\n-\n-  tmp = force_gimple_operand_gsi (gsip, cond, /*simple=*/true, NULL,\n-\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n-  cond_stmt = gimple_build_cond_from_tree (tmp, NULL_TREE, NULL_TREE);\n-  gsi_insert_before (gsip, cond_stmt, GSI_SAME_STMT);\n-\n-  e_false = split_block (split_bb, cond_stmt);\n-  new_bb = e_false->dest;\n-  redirect_edge_pred (e_true, split_bb);\n-\n-  e_true->flags &= ~EDGE_FALLTHRU;\n-  e_true->flags |= EDGE_TRUE_VALUE;\n-\n-  e_false->flags &= ~EDGE_FALLTHRU;\n-  e_false->flags |= EDGE_FALSE_VALUE;\n-  e_false->probability = e_true->probability.invert ();\n-  new_bb->count = e_false->count ();\n-\n-  if (update_dominators)\n-    {\n-      if (dominated_e_true)\n-\tset_immediate_dominator (CDI_DOMINATORS, e_true->dest, split_bb);\n-      set_immediate_dominator (CDI_DOMINATORS, e_false->dest, split_bb);\n-    }\n-\n-  return new_bb;\n-}\n-\n-\n-/* Return true if a switch should be expanded as a bit test.\n-   RANGE is the difference between highest and lowest case.\n-   UNIQ is number of unique case node targets, not counting the default case.\n-   COUNT is the number of comparisons needed, not counting the default case.  */\n-\n-static bool\n-expand_switch_using_bit_tests_p (tree range,\n-\t\t\t\t unsigned int uniq,\n-\t\t\t\t unsigned int count, bool speed_p)\n-{\n-  return (((uniq == 1 && count >= 3)\n-\t   || (uniq == 2 && count >= 5)\n-\t   || (uniq == 3 && count >= 6))\n-\t  && lshift_cheap_p (speed_p)\n-\t  && compare_tree_int (range, GET_MODE_BITSIZE (word_mode)) < 0\n-\t  && compare_tree_int (range, 0) > 0);\n-}\n-\f\n-/* Implement switch statements with bit tests\n-\n-A GIMPLE switch statement can be expanded to a short sequence of bit-wise\n-comparisons.  \"switch(x)\" is converted into \"if ((1 << (x-MINVAL)) & CST)\"\n-where CST and MINVAL are integer constants.  This is better than a series\n-of compare-and-banch insns in some cases,  e.g. we can implement:\n-\n-\tif ((x==4) || (x==6) || (x==9) || (x==11))\n-\n-as a single bit test:\n-\n-\tif ((1<<x) & ((1<<4)|(1<<6)|(1<<9)|(1<<11)))\n-\n-This transformation is only applied if the number of case targets is small,\n-if CST constains at least 3 bits, and \"1 << x\" is cheap.  The bit tests are\n-performed in \"word_mode\".\n-\n-The following example shows the code the transformation generates:\n-\n-\tint bar(int x)\n-\t{\n-\t\tswitch (x)\n-\t\t{\n-\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n-\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n-\t\tcase 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n-\t\tcase 'F':\n-\t\t\treturn 1;\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-==>\n-\n-\tbar (int x)\n-\t{\n-\t\ttmp1 = x - 48;\n-\t\tif (tmp1 > (70 - 48)) goto L2;\n-\t\ttmp2 = 1 << tmp1;\n-\t\ttmp3 = 0b11111100000001111111111;\n-\t\tif ((tmp2 & tmp3) != 0) goto L1 ; else goto L2;\n-\tL1:\n-\t\treturn 1;\n-\tL2:\n-\t\treturn 0;\n-\t}\n-\n-TODO: There are still some improvements to this transformation that could\n-be implemented:\n-\n-* A narrower mode than word_mode could be used if that is cheaper, e.g.\n-  for x86_64 where a narrower-mode shift may result in smaller code.\n-\n-* The compounded constant could be shifted rather than the one.  The\n-  test would be either on the sign bit or on the least significant bit,\n-  depending on the direction of the shift.  On some machines, the test\n-  for the branch would be free if the bit to test is already set by the\n-  shift operation.\n-\n-This transformation was contributed by Roger Sayle, see this e-mail:\n-   http://gcc.gnu.org/ml/gcc-patches/2003-01/msg01950.html\n-*/\n-\n-/* A case_bit_test represents a set of case nodes that may be\n-   selected from using a bit-wise comparison.  HI and LO hold\n-   the integer to be tested against, TARGET_EDGE contains the\n-   edge to the basic block to jump to upon success and BITS\n-   counts the number of case nodes handled by this test,\n-   typically the number of bits set in HI:LO.  The LABEL field\n-   is used to quickly identify all cases in this set without\n-   looking at label_to_block for every case label.  */\n-\n-struct case_bit_test\n-{\n-  wide_int mask;\n-  edge target_edge;\n-  tree label;\n-  int bits;\n-};\n-\n-/* Comparison function for qsort to order bit tests by decreasing\n-   probability of execution.  Our best guess comes from a measured\n-   profile.  If the profile counts are equal, break even on the\n-   number of case nodes, i.e. the node with the most cases gets\n-   tested first.\n-\n-   TODO: Actually this currently runs before a profile is available.\n-   Therefore the case-as-bit-tests transformation should be done\n-   later in the pass pipeline, or something along the lines of\n-   \"Efficient and effective branch reordering using profile data\"\n-   (Yang et. al., 2002) should be implemented (although, how good\n-   is a paper is called \"Efficient and effective ...\" when the\n-   latter is implied by the former, but oh well...).  */\n-\n-static int\n-case_bit_test_cmp (const void *p1, const void *p2)\n-{\n-  const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n-  const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n-\n-  if (d2->target_edge->count () < d1->target_edge->count ())\n-    return -1;\n-  if (d2->target_edge->count () > d1->target_edge->count ())\n-    return 1;\n-  if (d2->bits != d1->bits)\n-    return d2->bits - d1->bits;\n-\n-  /* Stabilize the sort.  */\n-  return LABEL_DECL_UID (d2->label) - LABEL_DECL_UID (d1->label);\n-}\n-\n-/*  Expand a switch statement by a short sequence of bit-wise\n-    comparisons.  \"switch(x)\" is effectively converted into\n-    \"if ((1 << (x-MINVAL)) & CST)\" where CST and MINVAL are\n-    integer constants.\n-\n-    INDEX_EXPR is the value being switched on.\n+/* Constructor.  */\n \n-    MINVAL is the lowest case value of in the case nodes,\n-    and RANGE is highest value minus MINVAL.  MINVAL and RANGE\n-    are not guaranteed to be of the same type as INDEX_EXPR\n-    (the gimplifier doesn't change the type of case label values,\n-    and MINVAL and RANGE are derived from those values).\n-    MAXVAL is MINVAL + RANGE.\n-\n-    There *MUST* be MAX_CASE_BIT_TESTS or less unique case\n-    node targets.  */\n-\n-static void\n-emit_case_bit_tests (gswitch *swtch, tree index_expr,\n-\t\t     tree minval, tree range, tree maxval)\n+switch_conversion::switch_conversion (): m_final_bb (NULL), m_other_count (),\n+  m_constructors (NULL), m_default_values (NULL),\n+  m_arr_ref_first (NULL), m_arr_ref_last (NULL),\n+  m_reason (NULL), m_default_case_nonstandard (false), m_cfg_altered (false)\n {\n-  struct case_bit_test test[MAX_CASE_BIT_TESTS] = { {} };\n-  unsigned int i, j, k;\n-  unsigned int count;\n-\n-  basic_block switch_bb = gimple_bb (swtch);\n-  basic_block default_bb, new_default_bb, new_bb;\n-  edge default_edge;\n-  bool update_dom = dom_info_available_p (CDI_DOMINATORS);\n-\n-  vec<basic_block> bbs_to_fix_dom = vNULL;\n-\n-  tree index_type = TREE_TYPE (index_expr);\n-  tree unsigned_index_type = unsigned_type_for (index_type);\n-  unsigned int branch_num = gimple_switch_num_labels (swtch);\n-\n-  gimple_stmt_iterator gsi;\n-  gassign *shift_stmt;\n-\n-  tree idx, tmp, csui;\n-  tree word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n-  tree word_mode_zero = fold_convert (word_type_node, integer_zero_node);\n-  tree word_mode_one = fold_convert (word_type_node, integer_one_node);\n-  int prec = TYPE_PRECISION (word_type_node);\n-  wide_int wone = wi::one (prec);\n-\n-  /* Get the edge for the default case.  */\n-  tmp = gimple_switch_default_label (swtch);\n-  default_bb = label_to_block (CASE_LABEL (tmp));\n-  default_edge = find_edge (switch_bb, default_bb);\n-\n-  /* Go through all case labels, and collect the case labels, profile\n-     counts, and other information we need to build the branch tests.  */\n-  count = 0;\n-  for (i = 1; i < branch_num; i++)\n-    {\n-      unsigned int lo, hi;\n-      tree cs = gimple_switch_label (swtch, i);\n-      tree label = CASE_LABEL (cs);\n-      edge e = find_edge (switch_bb, label_to_block (label));\n-      for (k = 0; k < count; k++)\n-\tif (e == test[k].target_edge)\n-\t  break;\n-\n-      if (k == count)\n-\t{\n-\t  gcc_checking_assert (count < MAX_CASE_BIT_TESTS);\n-\t  test[k].mask = wi::zero (prec);\n-\t  test[k].target_edge = e;\n-\t  test[k].label = label;\n-\t  test[k].bits = 1;\n-\t  count++;\n-\t}\n-      else\n-        test[k].bits++;\n-\n-      lo = tree_to_uhwi (int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t  CASE_LOW (cs), minval));\n-      if (CASE_HIGH (cs) == NULL_TREE)\n-\thi = lo;\n-      else\n-\thi = tree_to_uhwi (int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t    CASE_HIGH (cs), minval));\n-\n-      for (j = lo; j <= hi; j++)\n-\ttest[k].mask |= wi::lshift (wone, j);\n-    }\n-\n-  qsort (test, count, sizeof (*test), case_bit_test_cmp);\n-\n-  /* If all values are in the 0 .. BITS_PER_WORD-1 range, we can get rid of\n-     the minval subtractions, but it might make the mask constants more\n-     expensive.  So, compare the costs.  */\n-  if (compare_tree_int (minval, 0) > 0\n-      && compare_tree_int (maxval, GET_MODE_BITSIZE (word_mode)) < 0)\n-    {\n-      int cost_diff;\n-      HOST_WIDE_INT m = tree_to_uhwi (minval);\n-      rtx reg = gen_raw_REG (word_mode, 10000);\n-      bool speed_p = optimize_bb_for_speed_p (gimple_bb (swtch));\n-      cost_diff = set_rtx_cost (gen_rtx_PLUS (word_mode, reg,\n-\t\t\t\t\t      GEN_INT (-m)), speed_p);\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  rtx r = immed_wide_int_const (test[i].mask, word_mode);\n-\t  cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r),\n-\t\t\t\t     word_mode, speed_p);\n-\t  r = immed_wide_int_const (wi::lshift (test[i].mask, m), word_mode);\n-\t  cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r),\n-\t\t\t\t     word_mode, speed_p);\n-\t}\n-      if (cost_diff > 0)\n-\t{\n-\t  for (i = 0; i < count; i++)\n-\t    test[i].mask = wi::lshift (test[i].mask, m);\n-\t  minval = build_zero_cst (TREE_TYPE (minval));\n-\t  range = maxval;\n-\t}\n-    }\n-\n-  /* We generate two jumps to the default case label.\n-     Split the default edge, so that we don't have to do any PHI node\n-     updating.  */\n-  new_default_bb = split_edge (default_edge);\n-\n-  if (update_dom)\n-    {\n-      bbs_to_fix_dom.create (10);\n-      bbs_to_fix_dom.quick_push (switch_bb);\n-      bbs_to_fix_dom.quick_push (default_bb);\n-      bbs_to_fix_dom.quick_push (new_default_bb);\n-    }\n-\n-  /* Now build the test-and-branch code.  */\n-\n-  gsi = gsi_last_bb (switch_bb);\n-\n-  /* idx = (unsigned)x - minval.  */\n-  idx = fold_convert (unsigned_index_type, index_expr);\n-  idx = fold_build2 (MINUS_EXPR, unsigned_index_type, idx,\n-\t\t     fold_convert (unsigned_index_type, minval));\n-  idx = force_gimple_operand_gsi (&gsi, idx,\n-\t\t\t\t  /*simple=*/true, NULL_TREE,\n-\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n-\n-  /* if (idx > range) goto default */\n-  range = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t    fold_convert (unsigned_index_type, range),\n-\t\t\t\t    /*simple=*/true, NULL_TREE,\n-\t\t\t\t    /*before=*/true, GSI_SAME_STMT);\n-  tmp = fold_build2 (GT_EXPR, boolean_type_node, idx, range);\n-  new_bb = hoist_edge_and_branch_if_true (&gsi, tmp, default_edge, update_dom);\n-  if (update_dom)\n-    bbs_to_fix_dom.quick_push (new_bb);\n-  gcc_assert (gimple_bb (swtch) == new_bb);\n-  gsi = gsi_last_bb (new_bb);\n-\n-  /* Any blocks dominated by the GIMPLE_SWITCH, but that are not successors\n-     of NEW_BB, are still immediately dominated by SWITCH_BB.  Make it so.  */\n-  if (update_dom)\n-    {\n-      vec<basic_block> dom_bbs;\n-      basic_block dom_son;\n-\n-      dom_bbs = get_dominated_by (CDI_DOMINATORS, new_bb);\n-      FOR_EACH_VEC_ELT (dom_bbs, i, dom_son)\n-\t{\n-\t  edge e = find_edge (new_bb, dom_son);\n-\t  if (e && single_pred_p (e->dest))\n-\t    continue;\n-\t  set_immediate_dominator (CDI_DOMINATORS, dom_son, switch_bb);\n-\t  bbs_to_fix_dom.safe_push (dom_son);\n-\t}\n-      dom_bbs.release ();\n-    }\n-\n-  /* csui = (1 << (word_mode) idx) */\n-  csui = make_ssa_name (word_type_node);\n-  tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,\n-\t\t     fold_convert (word_type_node, idx));\n-  tmp = force_gimple_operand_gsi (&gsi, tmp,\n-\t\t\t\t  /*simple=*/false, NULL_TREE,\n-\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n-  shift_stmt = gimple_build_assign (csui, tmp);\n-  gsi_insert_before (&gsi, shift_stmt, GSI_SAME_STMT);\n-  update_stmt (shift_stmt);\n-\n-  /* for each unique set of cases:\n-        if (const & csui) goto target  */\n-  for (k = 0; k < count; k++)\n-    {\n-      tmp = wide_int_to_tree (word_type_node, test[k].mask);\n-      tmp = fold_build2 (BIT_AND_EXPR, word_type_node, csui, tmp);\n-      tmp = force_gimple_operand_gsi (&gsi, tmp,\n-\t\t\t\t      /*simple=*/true, NULL_TREE,\n-\t\t\t\t      /*before=*/true, GSI_SAME_STMT);\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, word_mode_zero);\n-      new_bb = hoist_edge_and_branch_if_true (&gsi, tmp, test[k].target_edge,\n-\t\t\t\t\t      update_dom);\n-      if (update_dom)\n-\tbbs_to_fix_dom.safe_push (new_bb);\n-      gcc_assert (gimple_bb (swtch) == new_bb);\n-      gsi = gsi_last_bb (new_bb);\n-    }\n-\n-  /* We should have removed all edges now.  */\n-  gcc_assert (EDGE_COUNT (gsi_bb (gsi)->succs) == 0);\n-\n-  /* If nothing matched, go to the default label.  */\n-  make_edge (gsi_bb (gsi), new_default_bb, EDGE_FALLTHRU);\n-\n-  /* The GIMPLE_SWITCH is now redundant.  */\n-  gsi_remove (&gsi, true);\n-\n-  if (update_dom)\n-    {\n-      /* Fix up the dominator tree.  */\n-      iterate_fix_dominators (CDI_DOMINATORS, bbs_to_fix_dom, true);\n-      bbs_to_fix_dom.release ();\n-    }\n }\n-\f\n-/*\n-     Switch initialization conversion\n-\n-The following pass changes simple initializations of scalars in a switch\n-statement into initializations from a static array.  Obviously, the values\n-must be constant and known at compile time and a default branch must be\n-provided.  For example, the following code:\n-\n-        int a,b;\n-\n-        switch (argc)\n-\t{\n-         case 1:\n-         case 2:\n-                a_1 = 8;\n-                b_1 = 6;\n-                break;\n-         case 3:\n-                a_2 = 9;\n-                b_2 = 5;\n-                break;\n-         case 12:\n-                a_3 = 10;\n-                b_3 = 4;\n-                break;\n-         default:\n-                a_4 = 16;\n-                b_4 = 1;\n-\t\tbreak;\n-        }\n-\ta_5 = PHI <a_1, a_2, a_3, a_4>\n-\tb_5 = PHI <b_1, b_2, b_3, b_4>\n-\n-\n-is changed into:\n-\n-        static const int = CSWTCH01[] = {6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 4};\n-        static const int = CSWTCH02[] = {8, 8, 9, 16, 16, 16, 16, 16, 16, 16,\n-                                 16, 16, 10};\n-\n-        if (((unsigned) argc) - 1 < 11)\n-          {\n-\t    a_6 = CSWTCH02[argc - 1];\n-            b_6 = CSWTCH01[argc - 1];\n-\t  }\n-\telse\n-\t  {\n-\t    a_7 = 16;\n-\t    b_7 = 1;\n-          }\n-\ta_5 = PHI <a_6, a_7>\n-\tb_b = PHI <b_6, b_7>\n-\n-There are further constraints.  Specifically, the range of values across all\n-case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default\n-eight) times the number of the actual switch branches.\n-\n-This transformation was contributed by Martin Jambor, see this e-mail:\n-   http://gcc.gnu.org/ml/gcc-patches/2008-07/msg00011.html  */\n-\n-/* The main structure of the pass.  */\n-struct switch_conv_info\n-{\n-  /* The expression used to decide the switch branch.  */\n-  tree index_expr;\n-\n-  /* The following integer constants store the minimum and maximum value\n-     covered by the case labels.  */\n-  tree range_min;\n-  tree range_max;\n-\n-  /* The difference between the above two numbers.  Stored here because it\n-     is used in all the conversion heuristics, as well as for some of the\n-     transformation, and it is expensive to re-compute it all the time.  */\n-  tree range_size;\n-\n-  /* Basic block that contains the actual GIMPLE_SWITCH.  */\n-  basic_block switch_bb;\n-\n-  /* Basic block that is the target of the default case.  */\n-  basic_block default_bb;\n-\n-  /* The single successor block of all branches out of the GIMPLE_SWITCH,\n-     if such a block exists.  Otherwise NULL.  */\n-  basic_block final_bb;\n-\n-  /* The probability of the default edge in the replaced switch.  */\n-  profile_probability default_prob;\n-\n-  /* The count of the default edge in the replaced switch.  */\n-  profile_count default_count;\n-\n-  /* Combined count of all other (non-default) edges in the replaced switch.  */\n-  profile_count other_count;\n-\n-  /* Number of phi nodes in the final bb (that we'll be replacing).  */\n-  int phi_count;\n-\n-  /* Array of default values, in the same order as phi nodes.  */\n-  tree *default_values;\n-\n-  /* Constructors of new static arrays.  */\n-  vec<constructor_elt, va_gc> **constructors;\n-\n-  /* Array of ssa names that are initialized with a value from a new static\n-     array.  */\n-  tree *target_inbound_names;\n-\n-  /* Array of ssa names that are initialized with the default value if the\n-     switch expression is out of range.  */\n-  tree *target_outbound_names;\n-\n-  /* VOP SSA_NAME.  */\n-  tree target_vop;\n-\n-  /* The first load statement that loads a temporary from a new static array.\n-   */\n-  gimple *arr_ref_first;\n \n-  /* The last load statement that loads a temporary from a new static array.  */\n-  gimple *arr_ref_last;\n+/* Collection information about SWTCH statement.  */\n \n-  /* String reason why the case wasn't a good candidate that is written to the\n-     dump file, if there is one.  */\n-  const char *reason;\n-\n-  /* True if default case is not used for any value between range_min and\n-     range_max inclusive.  */\n-  bool contiguous_range;\n-\n-  /* True if default case does not have the required shape for other case\n-     labels.  */\n-  bool default_case_nonstandard;\n-\n-  /* Parameters for expand_switch_using_bit_tests.  Should be computed\n-     the same way as in expand_case.  */\n-  unsigned int uniq;\n-  unsigned int count;\n-};\n-\n-/* Collect information about GIMPLE_SWITCH statement SWTCH into INFO.  */\n-\n-static void\n-collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n+void\n+switch_conversion::collect (gswitch *swtch)\n {\n   unsigned int branch_num = gimple_switch_num_labels (swtch);\n   tree min_case, max_case;\n-  unsigned int count, i;\n+  unsigned int i;\n   edge e, e_default, e_first;\n   edge_iterator ei;\n   basic_block first;\n \n-  memset (info, 0, sizeof (*info));\n+  m_switch = swtch;\n \n   /* The gimplifier has already sorted the cases by CASE_LOW and ensured there\n      is a default label which is the first in the vector.\n      Collect the bits we can deduce from the CFG.  */\n-  info->index_expr = gimple_switch_index (swtch);\n-  info->switch_bb = gimple_bb (swtch);\n-  info->default_bb\n+  m_index_expr = gimple_switch_index (swtch);\n+  m_switch_bb = gimple_bb (swtch);\n+  m_default_bb\n     = label_to_block (CASE_LABEL (gimple_switch_default_label (swtch)));\n-  e_default = find_edge (info->switch_bb, info->default_bb);\n-  info->default_prob = e_default->probability;\n-  info->default_count = e_default->count ();\n-  FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+  e_default = find_edge (m_switch_bb, m_default_bb);\n+  m_default_prob = e_default->probability;\n+  m_default_count = e_default->count ();\n+  FOR_EACH_EDGE (e, ei, m_switch_bb->succs)\n     if (e != e_default)\n-      info->other_count += e->count ();\n+      m_other_count += e->count ();\n \n   /* Get upper and lower bounds of case values, and the covered range.  */\n   min_case = gimple_switch_label (swtch, 1);\n   max_case = gimple_switch_label (swtch, branch_num - 1);\n \n-  info->range_min = CASE_LOW (min_case);\n+  m_range_min = CASE_LOW (min_case);\n   if (CASE_HIGH (max_case) != NULL_TREE)\n-    info->range_max = CASE_HIGH (max_case);\n+    m_range_max = CASE_HIGH (max_case);\n   else\n-    info->range_max = CASE_LOW (max_case);\n+    m_range_max = CASE_LOW (max_case);\n \n-  info->contiguous_range = true;\n-  tree last = CASE_HIGH (min_case) ? CASE_HIGH (min_case) : info->range_min;\n+  m_contiguous_range = true;\n+  tree last = CASE_HIGH (min_case) ? CASE_HIGH (min_case) : m_range_min;\n   for (i = 2; i < branch_num; i++)\n     {\n       tree elt = gimple_switch_label (swtch, i);\n       if (wi::to_wide (last) + 1 != wi::to_wide (CASE_LOW (elt)))\n \t{\n-\t  info->contiguous_range = false;\n+\t  m_contiguous_range = false;\n \t  break;\n \t}\n       last = CASE_HIGH (elt) ? CASE_HIGH (elt) : CASE_LOW (elt);\n     }\n \n-  if (info->contiguous_range)\n+  if (m_contiguous_range)\n     {\n       first = label_to_block (CASE_LABEL (gimple_switch_label (swtch, 1)));\n-      e_first = find_edge (info->switch_bb, first);\n+      e_first = find_edge (m_switch_bb, first);\n     }\n   else\n     {\n-      first = info->default_bb;\n+      first = m_default_bb;\n       e_first = e_default;\n     }\n \n@@ -684,103 +136,97 @@ collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n      if the range is contiguous and default case otherwise as\n      guess or its destination in case it is a forwarder block.  */\n   if (! single_pred_p (e_first->dest))\n-    info->final_bb = e_first->dest;\n+    m_final_bb = e_first->dest;\n   else if (single_succ_p (e_first->dest)\n \t   && ! single_pred_p (single_succ (e_first->dest)))\n-    info->final_bb = single_succ (e_first->dest);\n+    m_final_bb = single_succ (e_first->dest);\n   /* Require that all switch destinations are either that common\n      FINAL_BB or a forwarder to it, except for the default\n      case if contiguous range.  */\n-  if (info->final_bb)\n-    FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+  if (m_final_bb)\n+    FOR_EACH_EDGE (e, ei, m_switch_bb->succs)\n       {\n-\tif (e->dest == info->final_bb)\n+\tif (e->dest == m_final_bb)\n \t  continue;\n \n \tif (single_pred_p (e->dest)\n \t    && single_succ_p (e->dest)\n-\t    && single_succ (e->dest) == info->final_bb)\n+\t    && single_succ (e->dest) == m_final_bb)\n \t  continue;\n \n-\tif (e == e_default && info->contiguous_range)\n+\tif (e == e_default && m_contiguous_range)\n \t  {\n-\t    info->default_case_nonstandard = true;\n+\t    m_default_case_nonstandard = true;\n \t    continue;\n \t  }\n \n-\tinfo->final_bb = NULL;\n+\tm_final_bb = NULL;\n \tbreak;\n       }\n \n-  info->range_size\n-    = int_const_binop (MINUS_EXPR, info->range_max, info->range_min);\n+  m_range_size\n+    = int_const_binop (MINUS_EXPR, m_range_max, m_range_min);\n \n   /* Get a count of the number of case labels.  Single-valued case labels\n      simply count as one, but a case range counts double, since it may\n      require two compares if it gets lowered as a branching tree.  */\n-  count = 0;\n+  m_count = 0;\n   for (i = 1; i < branch_num; i++)\n     {\n       tree elt = gimple_switch_label (swtch, i);\n-      count++;\n+      m_count++;\n       if (CASE_HIGH (elt)\n \t  && ! tree_int_cst_equal (CASE_LOW (elt), CASE_HIGH (elt)))\n-\tcount++;\n+\tm_count++;\n     }\n-  info->count = count;\n- \n-  /* Get the number of unique non-default targets out of the GIMPLE_SWITCH\n-     block.  Assume a CFG cleanup would have already removed degenerate\n-     switch statements, this allows us to just use EDGE_COUNT.  */\n-  info->uniq = EDGE_COUNT (gimple_bb (swtch)->succs) - 1;\n }\n \n-/* Checks whether the range given by individual case statements of the SWTCH\n+/* Checks whether the range given by individual case statements of the switch\n    switch statement isn't too big and whether the number of branches actually\n    satisfies the size of the new array.  */\n \n-static bool\n-check_range (struct switch_conv_info *info)\n+bool\n+switch_conversion::check_range ()\n {\n-  gcc_assert (info->range_size);\n-  if (!tree_fits_uhwi_p (info->range_size))\n+  gcc_assert (m_range_size);\n+  if (!tree_fits_uhwi_p (m_range_size))\n     {\n-      info->reason = \"index range way too large or otherwise unusable\";\n+      m_reason = \"index range way too large or otherwise unusable\";\n       return false;\n     }\n \n-  if (tree_to_uhwi (info->range_size)\n-      > ((unsigned) info->count * SWITCH_CONVERSION_BRANCH_RATIO))\n+  if (tree_to_uhwi (m_range_size)\n+      > ((unsigned) m_count * SWITCH_CONVERSION_BRANCH_RATIO))\n     {\n-      info->reason = \"the maximum range-branch ratio exceeded\";\n+      m_reason = \"the maximum range-branch ratio exceeded\";\n       return false;\n     }\n \n   return true;\n }\n \n-/* Checks whether all but the FINAL_BB basic blocks are empty.  */\n+/* Checks whether all but the final BB basic blocks are empty.  */\n \n-static bool\n-check_all_empty_except_final (struct switch_conv_info *info)\n+bool\n+switch_conversion::check_all_empty_except_final ()\n {\n-  edge e, e_default = find_edge (info->switch_bb, info->default_bb);\n+  edge e, e_default = find_edge (m_switch_bb, m_default_bb);\n   edge_iterator ei;\n \n-  FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+  FOR_EACH_EDGE (e, ei, m_switch_bb->succs)\n     {\n-      if (e->dest == info->final_bb)\n+      if (e->dest == m_final_bb)\n \tcontinue;\n \n       if (!empty_block_p (e->dest))\n \t{\n-\t  if (info->contiguous_range && e == e_default)\n+\t  if (m_contiguous_range && e == e_default)\n \t    {\n-\t      info->default_case_nonstandard = true;\n+\t      m_default_case_nonstandard = true;\n \t      continue;\n \t    }\n \n-\t  info->reason = \"bad case - a non-final BB not empty\";\n+\t  m_reason = \"bad case - a non-final BB not empty\";\n \t  return false;\n \t}\n     }\n@@ -793,30 +239,30 @@ check_all_empty_except_final (struct switch_conv_info *info)\n    which is a part of the examined switch statement.  It returns true if the\n    phi nodes are OK, otherwise false.  */\n \n-static bool\n-check_final_bb (gswitch *swtch, struct switch_conv_info *info)\n+bool\n+switch_conversion::check_final_bb ()\n {\n   gphi_iterator gsi;\n \n-  info->phi_count = 0;\n-  for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  m_phi_count = 0;\n+  for (gsi = gsi_start_phis (m_final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n       unsigned int i;\n \n       if (virtual_operand_p (gimple_phi_result (phi)))\n \tcontinue;\n \n-      info->phi_count++;\n+      m_phi_count++;\n \n       for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t{\n \t  basic_block bb = gimple_phi_arg_edge (phi, i)->src;\n \n-\t  if (bb == info->switch_bb\n+\t  if (bb == m_switch_bb\n \t      || (single_pred_p (bb)\n-\t\t  && single_pred (bb) == info->switch_bb\n-\t\t  && (!info->default_case_nonstandard\n+\t\t  && single_pred (bb) == m_switch_bb\n+\t\t  && (!m_default_case_nonstandard\n \t\t      || empty_block_p (bb))))\n \t    {\n \t      tree reloc, val;\n@@ -844,25 +290,25 @@ check_final_bb (gswitch *swtch, struct switch_conv_info *info)\n \t\t  /* For contiguous range, we can allow non-constant\n \t\t     or one that needs relocation, as long as it is\n \t\t     only reachable from the default case.  */\n-\t\t  if (bb == info->switch_bb)\n-\t\t    bb = info->final_bb;\n-\t\t  if (!info->contiguous_range || bb != info->default_bb)\n+\t\t  if (bb == m_switch_bb)\n+\t\t    bb = m_final_bb;\n+\t\t  if (!m_contiguous_range || bb != m_default_bb)\n \t\t    {\n-\t\t      info->reason = reason;\n+\t\t      m_reason = reason;\n \t\t      return false;\n \t\t    }\n \n-\t\t  unsigned int branch_num = gimple_switch_num_labels (swtch);\n+\t\t  unsigned int branch_num = gimple_switch_num_labels (m_switch);\n \t\t  for (unsigned int i = 1; i < branch_num; i++)\n \t\t    {\n-\t\t      tree lab = CASE_LABEL (gimple_switch_label (swtch, i));\n+\t\t      tree lab = CASE_LABEL (gimple_switch_label (m_switch, i));\n \t\t      if (label_to_block (lab) == bb)\n \t\t\t{\n-\t\t\t  info->reason = reason;\n+\t\t\t  m_reason = reason;\n \t\t\t  return false;\n \t\t\t}\n \t\t    }\n-\t\t  info->default_case_nonstandard = true;\n+\t\t  m_default_case_nonstandard = true;\n \t\t}\n \t    }\n \t}\n@@ -875,103 +321,91 @@ check_final_bb (gswitch *swtch, struct switch_conv_info *info)\n    constructors arrays.  The last one is also populated with pointers to\n    vectors that will become constructors of new arrays.  */\n \n-static void\n-create_temp_arrays (struct switch_conv_info *info)\n+void\n+switch_conversion::create_temp_arrays ()\n {\n   int i;\n \n-  info->default_values = XCNEWVEC (tree, info->phi_count * 3);\n+  m_default_values = XCNEWVEC (tree, m_phi_count * 3);\n   /* ??? Macros do not support multi argument templates in their\n      argument list.  We create a typedef to work around that problem.  */\n   typedef vec<constructor_elt, va_gc> *vec_constructor_elt_gc;\n-  info->constructors = XCNEWVEC (vec_constructor_elt_gc, info->phi_count);\n-  info->target_inbound_names = info->default_values + info->phi_count;\n-  info->target_outbound_names = info->target_inbound_names + info->phi_count;\n-  for (i = 0; i < info->phi_count; i++)\n-    vec_alloc (info->constructors[i], tree_to_uhwi (info->range_size) + 1);\n-}\n-\n-/* Free the arrays created by create_temp_arrays().  The vectors that are\n-   created by that function are not freed here, however, because they have\n-   already become constructors and must be preserved.  */\n-\n-static void\n-free_temp_arrays (struct switch_conv_info *info)\n-{\n-  XDELETEVEC (info->constructors);\n-  XDELETEVEC (info->default_values);\n+  m_constructors = XCNEWVEC (vec_constructor_elt_gc, m_phi_count);\n+  m_target_inbound_names = m_default_values + m_phi_count;\n+  m_target_outbound_names = m_target_inbound_names + m_phi_count;\n+  for (i = 0; i < m_phi_count; i++)\n+    vec_alloc (m_constructors[i], tree_to_uhwi (m_range_size) + 1);\n }\n \n /* Populate the array of default values in the order of phi nodes.\n    DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch\n    if the range is non-contiguous or the default case has standard\n    structure, otherwise it is the first non-default case instead.  */\n \n-static void\n-gather_default_values (tree default_case, struct switch_conv_info *info)\n+void\n+switch_conversion::gather_default_values (tree default_case)\n {\n   gphi_iterator gsi;\n   basic_block bb = label_to_block (CASE_LABEL (default_case));\n   edge e;\n   int i = 0;\n \n   gcc_assert (CASE_LOW (default_case) == NULL_TREE\n-\t      || info->default_case_nonstandard);\n+\t      || m_default_case_nonstandard);\n \n-  if (bb == info->final_bb)\n-    e = find_edge (info->switch_bb, bb);\n+  if (bb == m_final_bb)\n+    e = find_edge (m_switch_bb, bb);\n   else\n     e = single_succ_edge (bb);\n \n-  for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gsi = gsi_start_phis (m_final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n       if (virtual_operand_p (gimple_phi_result (phi)))\n \tcontinue;\n       tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       gcc_assert (val);\n-      info->default_values[i++] = val;\n+      m_default_values[i++] = val;\n     }\n }\n \n /* The following function populates the vectors in the constructors array with\n    future contents of the static arrays.  The vectors are populated in the\n-   order of phi nodes.  SWTCH is the switch statement being converted.  */\n+   order of phi nodes.  */\n \n-static void\n-build_constructors (gswitch *swtch, struct switch_conv_info *info)\n+void\n+switch_conversion::build_constructors ()\n {\n-  unsigned i, branch_num = gimple_switch_num_labels (swtch);\n-  tree pos = info->range_min;\n+  unsigned i, branch_num = gimple_switch_num_labels (m_switch);\n+  tree pos = m_range_min;\n   tree pos_one = build_int_cst (TREE_TYPE (pos), 1);\n \n   for (i = 1; i < branch_num; i++)\n     {\n-      tree cs = gimple_switch_label (swtch, i);\n+      tree cs = gimple_switch_label (m_switch, i);\n       basic_block bb = label_to_block (CASE_LABEL (cs));\n       edge e;\n       tree high;\n       gphi_iterator gsi;\n       int j;\n \n-      if (bb == info->final_bb)\n-\te = find_edge (info->switch_bb, bb);\n+      if (bb == m_final_bb)\n+\te = find_edge (m_switch_bb, bb);\n       else\n \te = single_succ_edge (bb);\n       gcc_assert (e);\n \n       while (tree_int_cst_lt (pos, CASE_LOW (cs)))\n \t{\n \t  int k;\n-\t  gcc_assert (!info->contiguous_range);\n-\t  for (k = 0; k < info->phi_count; k++)\n+\t  for (k = 0; k < m_phi_count; k++)\n \t    {\n \t      constructor_elt elt;\n \n-\t      elt.index = int_const_binop (MINUS_EXPR, pos, info->range_min);\n+\t      elt.index = int_const_binop (MINUS_EXPR, pos, m_range_min);\n \t      elt.value\n-\t\t= unshare_expr_without_location (info->default_values[k]);\n-\t      info->constructors[k]->quick_push (elt);\n+\t\t= unshare_expr_without_location (m_default_values[k]);\n+\t      m_constructors[k]->quick_push (elt);\n \t    }\n \n \t  pos = int_const_binop (PLUS_EXPR, pos, pos_one);\n@@ -983,7 +417,7 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n \thigh = CASE_HIGH (cs);\n       else\n \thigh = CASE_LOW (cs);\n-      for (gsi = gsi_start_phis (info->final_bb);\n+      for (gsi = gsi_start_phis (m_final_bb);\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gphi *phi = gsi.phi ();\n@@ -997,9 +431,9 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n \t    {\n \t      constructor_elt elt;\n \n-\t      elt.index = int_const_binop (MINUS_EXPR, pos, info->range_min);\n+\t      elt.index = int_const_binop (MINUS_EXPR, pos, m_range_min);\n \t      elt.value = unshare_expr_without_location (val);\n-\t      info->constructors[j]->quick_push (elt);\n+\t      m_constructors[j]->quick_push (elt);\n \n \t      pos = int_const_binop (PLUS_EXPR, pos, pos_one);\n \t    } while (!tree_int_cst_lt (high, pos)\n@@ -1013,8 +447,8 @@ build_constructors (gswitch *swtch, struct switch_conv_info *info)\n    Otherwise return NULL_TREE.  Not supposed to be called for empty\n    vectors.  */\n \n-static tree\n-constructor_contains_same_values_p (vec<constructor_elt, va_gc> *vec)\n+tree\n+switch_conversion::contains_same_values_p (vec<constructor_elt, va_gc> *vec)\n {\n   unsigned int i;\n   tree prev = NULL_TREE;\n@@ -1034,11 +468,10 @@ constructor_contains_same_values_p (vec<constructor_elt, va_gc> *vec)\n    main variant or, for integral types, some smaller integral type\n    that can still hold all the constants.  */\n \n-static tree\n-array_value_type (gswitch *swtch, tree type, int num,\n-\t\t  struct switch_conv_info *info)\n+tree\n+switch_conversion::array_value_type (tree type, int num)\n {\n-  unsigned int i, len = vec_safe_length (info->constructors[num]);\n+  unsigned int i, len = vec_safe_length (m_constructors[num]);\n   constructor_elt *elt;\n   int sign = 0;\n   tree smaller_type;\n@@ -1058,10 +491,10 @@ array_value_type (gswitch *swtch, tree type, int num,\n   if (GET_MODE_SIZE (type_mode) <= GET_MODE_SIZE (mode))\n     return type;\n \n-  if (len < (optimize_bb_for_size_p (gimple_bb (swtch)) ? 2 : 32))\n+  if (len < (optimize_bb_for_size_p (gimple_bb (m_switch)) ? 2 : 32))\n     return type;\n \n-  FOR_EACH_VEC_SAFE_ELT (info->constructors[num], i, elt)\n+  FOR_EACH_VEC_SAFE_ELT (m_constructors[num], i, elt)\n     {\n       wide_int cst;\n \n@@ -1107,49 +540,50 @@ array_value_type (gswitch *swtch, tree type, int num,\n   return smaller_type;\n }\n \n-/* Create an appropriate array type and declaration and assemble a static array\n-   variable.  Also create a load statement that initializes the variable in\n-   question with a value from the static array.  SWTCH is the switch statement\n-   being converted, NUM is the index to arrays of constructors, default values\n-   and target SSA names for this particular array.  ARR_INDEX_TYPE is the type\n-   of the index of the new array, PHI is the phi node of the final BB that\n-   corresponds to the value that will be loaded from the created array.  TIDX\n+/* Create an appropriate array type and declaration and assemble a static\n+   array variable.  Also create a load statement that initializes\n+   the variable in question with a value from the static array.  SWTCH is\n+   the switch statement being converted, NUM is the index to\n+   arrays of constructors, default values and target SSA names\n+   for this particular array.  ARR_INDEX_TYPE is the type of the index\n+   of the new array, PHI is the phi node of the final BB that corresponds\n+   to the value that will be loaded from the created array.  TIDX\n    is an ssa name of a temporary variable holding the index for loads from the\n    new array.  */\n \n-static void\n-build_one_array (gswitch *swtch, int num, tree arr_index_type,\n-\t\t gphi *phi, tree tidx, struct switch_conv_info *info)\n+void\n+switch_conversion::build_one_array (int num, tree arr_index_type,\n+\t\t\t\t    gphi *phi, tree tidx)\n {\n   tree name, cst;\n   gimple *load;\n-  gimple_stmt_iterator gsi = gsi_for_stmt (swtch);\n-  location_t loc = gimple_location (swtch);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (m_switch);\n+  location_t loc = gimple_location (m_switch);\n \n-  gcc_assert (info->default_values[num]);\n+  gcc_assert (m_default_values[num]);\n \n   name = copy_ssa_name (PHI_RESULT (phi));\n-  info->target_inbound_names[num] = name;\n+  m_target_inbound_names[num] = name;\n \n-  cst = constructor_contains_same_values_p (info->constructors[num]);\n+  cst = contains_same_values_p (m_constructors[num]);\n   if (cst)\n     load = gimple_build_assign (name, cst);\n   else\n     {\n       tree array_type, ctor, decl, value_type, fetch, default_type;\n \n-      default_type = TREE_TYPE (info->default_values[num]);\n-      value_type = array_value_type (swtch, default_type, num, info);\n+      default_type = TREE_TYPE (m_default_values[num]);\n+      value_type = array_value_type (default_type, num);\n       array_type = build_array_type (value_type, arr_index_type);\n       if (default_type != value_type)\n \t{\n \t  unsigned int i;\n \t  constructor_elt *elt;\n \n-\t  FOR_EACH_VEC_SAFE_ELT (info->constructors[num], i, elt)\n+\t  FOR_EACH_VEC_SAFE_ELT (m_constructors[num], i, elt)\n \t    elt->value = fold_convert (value_type, elt->value);\n \t}\n-      ctor = build_constructor (array_type, info->constructors[num]);\n+      ctor = build_constructor (array_type, m_constructors[num]);\n       TREE_CONSTANT (ctor) = true;\n       TREE_STATIC (ctor) = true;\n \n@@ -1182,100 +616,101 @@ build_one_array (gswitch *swtch, int num, tree arr_index_type,\n \n   gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n   update_stmt (load);\n-  info->arr_ref_last = load;\n+  m_arr_ref_last = load;\n }\n \n /* Builds and initializes static arrays initialized with values gathered from\n-   the SWTCH switch statement.  Also creates statements that load values from\n+   the switch statement.  Also creates statements that load values from\n    them.  */\n \n-static void\n-build_arrays (gswitch *swtch, struct switch_conv_info *info)\n+void\n+switch_conversion::build_arrays ()\n {\n   tree arr_index_type;\n   tree tidx, sub, utype;\n   gimple *stmt;\n   gimple_stmt_iterator gsi;\n   gphi_iterator gpi;\n   int i;\n-  location_t loc = gimple_location (swtch);\n+  location_t loc = gimple_location (m_switch);\n \n-  gsi = gsi_for_stmt (swtch);\n+  gsi = gsi_for_stmt (m_switch);\n \n   /* Make sure we do not generate arithmetics in a subrange.  */\n-  utype = TREE_TYPE (info->index_expr);\n+  utype = TREE_TYPE (m_index_expr);\n   if (TREE_TYPE (utype))\n     utype = lang_hooks.types.type_for_mode (TYPE_MODE (TREE_TYPE (utype)), 1);\n   else\n     utype = lang_hooks.types.type_for_mode (TYPE_MODE (utype), 1);\n \n-  arr_index_type = build_index_type (info->range_size);\n+  arr_index_type = build_index_type (m_range_size);\n   tidx = make_ssa_name (utype);\n   sub = fold_build2_loc (loc, MINUS_EXPR, utype,\n-\t\t\t fold_convert_loc (loc, utype, info->index_expr),\n-\t\t\t fold_convert_loc (loc, utype, info->range_min));\n+\t\t\t fold_convert_loc (loc, utype, m_index_expr),\n+\t\t\t fold_convert_loc (loc, utype, m_range_min));\n   sub = force_gimple_operand_gsi (&gsi, sub,\n \t\t\t\t  false, NULL, true, GSI_SAME_STMT);\n   stmt = gimple_build_assign (tidx, sub);\n \n   gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n   update_stmt (stmt);\n-  info->arr_ref_first = stmt;\n+  m_arr_ref_first = stmt;\n \n-  for (gpi = gsi_start_phis (info->final_bb), i = 0;\n+  for (gpi = gsi_start_phis (m_final_bb), i = 0;\n        !gsi_end_p (gpi); gsi_next (&gpi))\n     {\n       gphi *phi = gpi.phi ();\n       if (!virtual_operand_p (gimple_phi_result (phi)))\n-\tbuild_one_array (swtch, i++, arr_index_type, phi, tidx, info);\n+\tbuild_one_array (i++, arr_index_type, phi, tidx);\n       else\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+\t  FOR_EACH_EDGE (e, ei, m_switch_bb->succs)\n \t    {\n-\t      if (e->dest == info->final_bb)\n+\t      if (e->dest == m_final_bb)\n \t\tbreak;\n-\t      if (!info->default_case_nonstandard\n-\t\t  || e->dest != info->default_bb)\n+\t      if (!m_default_case_nonstandard\n+\t\t  || e->dest != m_default_bb)\n \t\t{\n \t\t  e = single_succ_edge (e->dest);\n \t\t  break;\n \t\t}\n \t    }\n-\t  gcc_assert (e && e->dest == info->final_bb);\n-\t  info->target_vop = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t  gcc_assert (e && e->dest == m_final_bb);\n+\t  m_target_vop = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t}\n     }\n }\n \n /* Generates and appropriately inserts loads of default values at the position\n-   given by BSI.  Returns the last inserted statement.  */\n+   given by GSI.  Returns the last inserted statement.  */\n \n-static gassign *\n-gen_def_assigns (gimple_stmt_iterator *gsi, struct switch_conv_info *info)\n+gassign *\n+switch_conversion::gen_def_assigns (gimple_stmt_iterator *gsi)\n {\n   int i;\n   gassign *assign = NULL;\n \n-  for (i = 0; i < info->phi_count; i++)\n+  for (i = 0; i < m_phi_count; i++)\n     {\n-      tree name = copy_ssa_name (info->target_inbound_names[i]);\n-      info->target_outbound_names[i] = name;\n-      assign = gimple_build_assign (name, info->default_values[i]);\n+      tree name = copy_ssa_name (m_target_inbound_names[i]);\n+      m_target_outbound_names[i] = name;\n+      assign = gimple_build_assign (name, m_default_values[i]);\n       gsi_insert_before (gsi, assign, GSI_SAME_STMT);\n       update_stmt (assign);\n     }\n   return assign;\n }\n \n /* Deletes the unused bbs and edges that now contain the switch statement and\n-   its empty branch bbs.  BBD is the now dead BB containing the original switch\n-   statement, FINAL is the last BB of the converted switch statement (in terms\n-   of succession).  */\n+   its empty branch bbs.  BBD is the now dead BB containing\n+   the original switch statement, FINAL is the last BB of the converted\n+   switch statement (in terms of succession).  */\n \n-static void\n-prune_bbs (basic_block bbd, basic_block final, basic_block default_bb)\n+void\n+switch_conversion::prune_bbs (basic_block bbd, basic_block final,\n+\t\t\t      basic_block default_bb)\n {\n   edge_iterator ei;\n   edge e;\n@@ -1296,9 +731,8 @@ prune_bbs (basic_block bbd, basic_block final, basic_block default_bb)\n    block loading default values.  BBF is the last switch basic block (see the\n    bbf description in the comment below).  */\n \n-static void\n-fix_phi_nodes (edge e1f, edge e2f, basic_block bbf,\n-\t       struct switch_conv_info *info)\n+void\n+switch_conversion::fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n {\n   gphi_iterator gsi;\n   int i;\n@@ -1309,41 +743,24 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf,\n       gphi *phi = gsi.phi ();\n       tree inbound, outbound;\n       if (virtual_operand_p (gimple_phi_result (phi)))\n-\tinbound = outbound = info->target_vop;\n+\tinbound = outbound = m_target_vop;\n       else\n \t{\n-\t  inbound = info->target_inbound_names[i];\n-\t  outbound = info->target_outbound_names[i++];\n+\t  inbound = m_target_inbound_names[i];\n+\t  outbound = m_target_outbound_names[i++];\n \t}\n       add_phi_arg (phi, inbound, e1f, UNKNOWN_LOCATION);\n-      if (!info->default_case_nonstandard)\n+      if (!m_default_case_nonstandard)\n \tadd_phi_arg (phi, outbound, e2f, UNKNOWN_LOCATION);\n     }\n }\n \n /* Creates a check whether the switch expression value actually falls into the\n    range given by all the cases.  If it does not, the temporaries are loaded\n-   with default values instead.  SWTCH is the switch statement being converted.\n-\n-   bb0 is the bb with the switch statement, however, we'll end it with a\n-       condition instead.\n-\n-   bb1 is the bb to be used when the range check went ok.  It is derived from\n-       the switch BB\n-\n-   bb2 is the bb taken when the expression evaluated outside of the range\n-       covered by the created arrays.  It is populated by loads of default\n-       values.\n+   with default values instead.  */\n \n-   bbF is a fall through for both bb1 and bb2 and contains exactly what\n-       originally followed the switch statement.\n-\n-   bbD contains the switch statement (in the end).  It is unreachable but we\n-       still need to strip off its edges.\n-*/\n-\n-static void\n-gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n+void\n+switch_conversion::gen_inbound_check ()\n {\n   tree label_decl1 = create_artificial_label (UNKNOWN_LOCATION);\n   tree label_decl2 = create_artificial_label (UNKNOWN_LOCATION);\n@@ -1358,49 +775,49 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   gimple_stmt_iterator gsi;\n   basic_block bb0, bb1, bb2, bbf, bbd;\n   edge e01 = NULL, e02, e21, e1d, e1f, e2f;\n-  location_t loc = gimple_location (swtch);\n+  location_t loc = gimple_location (m_switch);\n \n-  gcc_assert (info->default_values);\n+  gcc_assert (m_default_values);\n \n-  bb0 = gimple_bb (swtch);\n+  bb0 = gimple_bb (m_switch);\n \n-  tidx = gimple_assign_lhs (info->arr_ref_first);\n+  tidx = gimple_assign_lhs (m_arr_ref_first);\n   utype = TREE_TYPE (tidx);\n \n   /* (end of) block 0 */\n-  gsi = gsi_for_stmt (info->arr_ref_first);\n+  gsi = gsi_for_stmt (m_arr_ref_first);\n   gsi_next (&gsi);\n \n-  bound = fold_convert_loc (loc, utype, info->range_size);\n+  bound = fold_convert_loc (loc, utype, m_range_size);\n   cond_stmt = gimple_build_cond (LE_EXPR, tidx, bound, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n   update_stmt (cond_stmt);\n \n   /* block 2 */\n-  if (!info->default_case_nonstandard)\n+  if (!m_default_case_nonstandard)\n     {\n       label2 = gimple_build_label (label_decl2);\n       gsi_insert_before (&gsi, label2, GSI_SAME_STMT);\n-      last_assign = gen_def_assigns (&gsi, info);\n+      last_assign = gen_def_assigns (&gsi);\n     }\n \n   /* block 1 */\n   label1 = gimple_build_label (label_decl1);\n   gsi_insert_before (&gsi, label1, GSI_SAME_STMT);\n \n   /* block F */\n-  gsi = gsi_start_bb (info->final_bb);\n+  gsi = gsi_start_bb (m_final_bb);\n   label3 = gimple_build_label (label_decl3);\n   gsi_insert_before (&gsi, label3, GSI_SAME_STMT);\n \n   /* cfg fix */\n   e02 = split_block (bb0, cond_stmt);\n   bb2 = e02->dest;\n \n-  if (info->default_case_nonstandard)\n+  if (m_default_case_nonstandard)\n     {\n       bb1 = bb2;\n-      bb2 = info->default_bb;\n+      bb2 = m_default_bb;\n       e01 = e02;\n       e01->flags = EDGE_TRUE_VALUE;\n       e02 = make_edge (bb0, bb2, EDGE_FALSE_VALUE);\n@@ -1424,26 +841,26 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n       remove_edge (e21);\n     }\n \n-  e1d = split_block (bb1, info->arr_ref_last);\n+  e1d = split_block (bb1, m_arr_ref_last);\n   bbd = e1d->dest;\n   remove_edge (e1d);\n \n-  /* flags and profiles of the edge for in-range values */\n-  if (!info->default_case_nonstandard)\n+  /* Flags and profiles of the edge for in-range values.  */\n+  if (!m_default_case_nonstandard)\n     e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n-  e01->probability = info->default_prob.invert ();\n+  e01->probability = m_default_prob.invert ();\n \n-  /* flags and profiles of the edge taking care of out-of-range values */\n+  /* Flags and profiles of the edge taking care of out-of-range values.  */\n   e02->flags &= ~EDGE_FALLTHRU;\n   e02->flags |= EDGE_FALSE_VALUE;\n-  e02->probability = info->default_prob;\n+  e02->probability = m_default_prob;\n \n-  bbf = info->final_bb;\n+  bbf = m_final_bb;\n \n   e1f = make_edge (bb1, bbf, EDGE_FALLTHRU);\n   e1f->probability = profile_probability::always ();\n \n-  if (info->default_case_nonstandard)\n+  if (m_default_case_nonstandard)\n     e2f = NULL;\n   else\n     {\n@@ -1454,23 +871,23 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   /* frequencies of the new BBs */\n   bb1->count = e01->count ();\n   bb2->count = e02->count ();\n-  if (!info->default_case_nonstandard)\n+  if (!m_default_case_nonstandard)\n     bbf->count = e1f->count () + e2f->count ();\n \n   /* Tidy blocks that have become unreachable.  */\n-  prune_bbs (bbd, info->final_bb,\n-\t     info->default_case_nonstandard ? info->default_bb : NULL);\n+  prune_bbs (bbd, m_final_bb,\n+\t     m_default_case_nonstandard ? m_default_bb : NULL);\n \n   /* Fixup the PHI nodes in bbF.  */\n-  fix_phi_nodes (e1f, e2f, bbf, info);\n+  fix_phi_nodes (e1f, e2f, bbf);\n \n   /* Fix the dominator tree, if it is available.  */\n   if (dom_info_available_p (CDI_DOMINATORS))\n     {\n       vec<basic_block> bbs_to_fix_dom;\n \n       set_immediate_dominator (CDI_DOMINATORS, bb1, bb0);\n-      if (!info->default_case_nonstandard)\n+      if (!m_default_case_nonstandard)\n \tset_immediate_dominator (CDI_DOMINATORS, bb2, bb0);\n       if (! get_immediate_dominator (CDI_DOMINATORS, bbf))\n \t/* If bbD was the immediate dominator ...  */\n@@ -1488,95 +905,84 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n     }\n }\n \n-/* The following function is invoked on every switch statement (the current one\n-   is given in SWTCH) and runs the individual phases of switch conversion on it\n-   one after another until one fails or the conversion is completed.\n-   Returns NULL on success, or a pointer to a string with the reason why the\n-   conversion failed.  */\n+/* The following function is invoked on every switch statement (the current\n+   one is given in SWTCH) and runs the individual phases of switch\n+   conversion on it one after another until one fails or the conversion\n+   is completed.  On success, NULL is in m_reason, otherwise points\n+   to a string with the reason why the conversion failed.  */\n \n-static const char *\n-process_switch (gswitch *swtch)\n+void\n+switch_conversion::expand (gswitch *swtch)\n {\n-  struct switch_conv_info info;\n-\n   /* Group case labels so that we get the right results from the heuristics\n      that decide on the code generation approach for this switch.  */\n-  cfg_altered |= group_case_labels_stmt (swtch);\n+  m_cfg_altered |= group_case_labels_stmt (swtch);\n \n   /* If this switch is now a degenerate case with only a default label,\n-     there is nothing left for us to do.   */\n+     there is nothing left for us to do.  */\n   if (gimple_switch_num_labels (swtch) < 2)\n-    return \"switch is a degenerate case\";\n+    {\n+      m_reason = \"switch is a degenerate case\";\n+      return;\n+    }\n \n-  collect_switch_conv_info (swtch, &info);\n+  collect (swtch);\n \n   /* No error markers should reach here (they should be filtered out\n      during gimplification).  */\n-  gcc_checking_assert (TREE_TYPE (info.index_expr) != error_mark_node);\n+  gcc_checking_assert (TREE_TYPE (m_index_expr) != error_mark_node);\n \n   /* A switch on a constant should have been optimized in tree-cfg-cleanup.  */\n-  gcc_checking_assert (! TREE_CONSTANT (info.index_expr));\n+  gcc_checking_assert (!TREE_CONSTANT (m_index_expr));\n \n-  if (info.uniq <= MAX_CASE_BIT_TESTS)\n+  /* If there is no common successor, we cannot do the transformation.  */\n+  if (!m_final_bb)\n     {\n-      if (expand_switch_using_bit_tests_p (info.range_size,\n-\t\t\t\t\t   info.uniq, info.count,\n-\t\t\t\t\t   optimize_bb_for_speed_p\n-\t\t\t\t\t     (gimple_bb (swtch))))\n-\t{\n-\t  if (dump_file)\n-\t    fputs (\"  expanding as bit test is preferable\\n\", dump_file);\n-\t  emit_case_bit_tests (swtch, info.index_expr, info.range_min,\n-\t\t\t       info.range_size, info.range_max);\n-\t  loops_state_set (LOOPS_NEED_FIXUP);\n-\t  return NULL;\n-\t}\n-\n-      if (info.uniq <= 2)\n-\t/* This will be expanded as a decision tree in stmt.c:expand_case.  */\n-\treturn \"  expanding as jumps is preferable\";\n+      m_reason = \"no common successor to all case label target blocks found\";\n+      return;\n     }\n \n-  /* If there is no common successor, we cannot do the transformation.  */\n-  if (! info.final_bb)\n-    return \"no common successor to all case label target blocks found\";\n-\n   /* Check the case label values are within reasonable range:  */\n-  if (!check_range (&info))\n+  if (!check_range ())\n     {\n-      gcc_assert (info.reason);\n-      return info.reason;\n+      gcc_assert (m_reason);\n+      return;\n     }\n \n   /* For all the cases, see whether they are empty, the assignments they\n      represent constant and so on...  */\n-  if (! check_all_empty_except_final (&info))\n+  if (!check_all_empty_except_final ())\n     {\n-      gcc_assert (info.reason);\n-      return info.reason;\n+      gcc_assert (m_reason);\n+      return;\n     }\n-  if (!check_final_bb (swtch, &info))\n+  if (!check_final_bb ())\n     {\n-      gcc_assert (info.reason);\n-      return info.reason;\n+      gcc_assert (m_reason);\n+      return;\n     }\n \n   /* At this point all checks have passed and we can proceed with the\n      transformation.  */\n \n-  create_temp_arrays (&info);\n-  gather_default_values (info.default_case_nonstandard\n+  create_temp_arrays ();\n+  gather_default_values (m_default_case_nonstandard\n \t\t\t ? gimple_switch_label (swtch, 1)\n-\t\t\t : gimple_switch_default_label (swtch), &info);\n-  if (info.phi_count)\n-    build_constructors (swtch, &info);\n+\t\t\t : gimple_switch_default_label (swtch));\n+  build_constructors ();\n+\n+  build_arrays (); /* Build the static arrays and assignments.  */\n+  gen_inbound_check ();\t/* Build the bounds check.  */\n \n-  build_arrays (swtch, &info); /* Build the static arrays and assignments.   */\n-  gen_inbound_check (swtch, &info);\t/* Build the bounds check.  */\n+  m_cfg_altered = true;\n+}\n \n-  /* Cleanup:  */\n-  free_temp_arrays (&info);\n-  return NULL;\n+/* Destructor.  */\n+\n+switch_conversion::~switch_conversion ()\n+{\n+  XDELETEVEC (m_constructors);\n+  XDELETEVEC (m_default_values);\n }\n \n /* The main function of the pass scans statements for switches and invokes\n@@ -1614,11 +1020,10 @@ unsigned int\n pass_convert_switch::execute (function *fun)\n {\n   basic_block bb;\n+  bool cfg_altered = false;\n \n-  cfg_altered = false;\n   FOR_EACH_BB_FN (bb, fun)\n   {\n-    const char *failure_reason;\n     gimple *stmt = last_stmt (bb);\n     if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n       {\n@@ -1633,34 +1038,36 @@ pass_convert_switch::execute (function *fun)\n \t    putc ('\\n', dump_file);\n \t  }\n \n-\tfailure_reason = process_switch (as_a <gswitch *> (stmt));\n-\tif (! failure_reason)\n+\tswitch_conversion sconv;\n+\tsconv.expand (as_a <gswitch *> (stmt));\n+\tcfg_altered |= sconv.m_cfg_altered;\n+\tif (!sconv.m_reason)\n \t  {\n-\t    cfg_altered = true;\n \t    if (dump_file)\n \t      {\n \t\tfputs (\"Switch converted\\n\", dump_file);\n \t\tfputs (\"--------------------------------\\n\", dump_file);\n \t      }\n \n-\t    /* Make no effort to update the post-dominator tree.  It is actually not\n-\t       that hard for the transformations we have performed, but it is not\n-\t       supported by iterate_fix_dominators.  */\n+\t    /* Make no effort to update the post-dominator tree.\n+\t       It is actually not that hard for the transformations\n+\t       we have performed, but it is not supported\n+\t       by iterate_fix_dominators.  */\n \t    free_dominance_info (CDI_POST_DOMINATORS);\n \t  }\n \telse\n \t  {\n \t    if (dump_file)\n \t      {\n \t\tfputs (\"Bailing out - \", dump_file);\n-\t\tfputs (failure_reason, dump_file);\n+\t\tfputs (sconv.m_reason, dump_file);\n \t\tfputs (\"\\n--------------------------------\\n\", dump_file);\n \t      }\n \t  }\n       }\n   }\n \n-  return cfg_altered ? TODO_cleanup_cfg : 0;\n+  return cfg_altered ? TODO_cleanup_cfg : 0;;\n }\n \n } // anon namespace"}, {"sha": "4518c2ed23ae272fbe1cdf343ecaa6090125ac19", "filename": "gcc/tree-switch-conversion.h", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/789410e4824b60f423f7855d68f234e02f9300fb/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/789410e4824b60f423f7855d68f234e02f9300fb/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=789410e4824b60f423f7855d68f234e02f9300fb", "patch": "@@ -0,0 +1,266 @@\n+/* Tree switch conversion for GNU compiler.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TREE_SWITCH_CONVERSION_H\n+#define TREE_SWITCH_CONVERSION_H\n+\n+namespace tree_switch_conversion {\n+\n+/*\n+     Switch initialization conversion\n+\n+The following pass changes simple initializations of scalars in a switch\n+statement into initializations from a static array.  Obviously, the values\n+must be constant and known at compile time and a default branch must be\n+provided.  For example, the following code:\n+\n+\tint a,b;\n+\n+\tswitch (argc)\n+\t{\n+\t case 1:\n+\t case 2:\n+\t\ta_1 = 8;\n+\t\tb_1 = 6;\n+\t\tbreak;\n+\t case 3:\n+\t\ta_2 = 9;\n+\t\tb_2 = 5;\n+\t\tbreak;\n+\t case 12:\n+\t\ta_3 = 10;\n+\t\tb_3 = 4;\n+\t\tbreak;\n+\t default:\n+\t\ta_4 = 16;\n+\t\tb_4 = 1;\n+\t\tbreak;\n+\t}\n+\ta_5 = PHI <a_1, a_2, a_3, a_4>\n+\tb_5 = PHI <b_1, b_2, b_3, b_4>\n+\n+\n+is changed into:\n+\n+\tstatic const int = CSWTCH01[] = {6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 4};\n+\tstatic const int = CSWTCH02[] = {8, 8, 9, 16, 16, 16, 16, 16, 16, 16,\n+\t\t\t\t 16, 16, 10};\n+\n+\tif (((unsigned) argc) - 1 < 11)\n+\t  {\n+\t    a_6 = CSWTCH02[argc - 1];\n+\t    b_6 = CSWTCH01[argc - 1];\n+\t  }\n+\telse\n+\t  {\n+\t    a_7 = 16;\n+\t    b_7 = 1;\n+\t  }\n+\ta_5 = PHI <a_6, a_7>\n+\tb_b = PHI <b_6, b_7>\n+\n+There are further constraints.  Specifically, the range of values across all\n+case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default\n+eight) times the number of the actual switch branches.\n+\n+This transformation was contributed by Martin Jambor, see this e-mail:\n+   http://gcc.gnu.org/ml/gcc-patches/2008-07/msg00011.html  */\n+\n+/* The main structure of the pass.  */\n+struct switch_conversion\n+{\n+  /* Constructor.  */\n+  switch_conversion ();\n+\n+  /* Destructor.  */\n+  ~switch_conversion ();\n+\n+  /* The following function is invoked on every switch statement (the current\n+     one is given in SWTCH) and runs the individual phases of switch\n+     conversion on it one after another until one fails or the conversion\n+     is completed.  On success, NULL is in m_reason, otherwise points\n+     to a string with the reason why the conversion failed.  */\n+  void expand (gswitch *swtch);\n+\n+  /* Collection information about SWTCH statement.  */\n+  void collect (gswitch *swtch);\n+\n+  /* Checks whether the range given by individual case statements of the switch\n+     switch statement isn't too big and whether the number of branches actually\n+     satisfies the size of the new array.  */\n+  bool check_range ();\n+\n+  /* Checks whether all but the final BB basic blocks are empty.  */\n+  bool check_all_empty_except_final ();\n+\n+  /* This function checks whether all required values in phi nodes in final_bb\n+     are constants.  Required values are those that correspond to a basic block\n+     which is a part of the examined switch statement.  It returns true if the\n+     phi nodes are OK, otherwise false.  */\n+  bool check_final_bb ();\n+\n+  /* The following function allocates default_values, target_{in,out}_names and\n+     constructors arrays.  The last one is also populated with pointers to\n+     vectors that will become constructors of new arrays.  */\n+  void create_temp_arrays ();\n+\n+  /* Populate the array of default values in the order of phi nodes.\n+     DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch\n+     if the range is non-contiguous or the default case has standard\n+     structure, otherwise it is the first non-default case instead.  */\n+  void gather_default_values (tree default_case);\n+\n+  /* The following function populates the vectors in the constructors array with\n+     future contents of the static arrays.  The vectors are populated in the\n+     order of phi nodes.  */\n+  void build_constructors ();\n+\n+  /* If all values in the constructor vector are the same, return the value.\n+     Otherwise return NULL_TREE.  Not supposed to be called for empty\n+     vectors.  */\n+  tree contains_same_values_p (vec<constructor_elt, va_gc> *vec);\n+\n+  /* Return type which should be used for array elements, either TYPE's\n+     main variant or, for integral types, some smaller integral type\n+     that can still hold all the constants.  */\n+  tree array_value_type (tree type, int num);\n+\n+  /* Create an appropriate array type and declaration and assemble a static\n+     array variable.  Also create a load statement that initializes\n+     the variable in question with a value from the static array.  SWTCH is\n+     the switch statement being converted, NUM is the index to\n+     arrays of constructors, default values and target SSA names\n+     for this particular array.  ARR_INDEX_TYPE is the type of the index\n+     of the new array, PHI is the phi node of the final BB that corresponds\n+     to the value that will be loaded from the created array.  TIDX\n+     is an ssa name of a temporary variable holding the index for loads from the\n+     new array.  */\n+  void build_one_array (int num, tree arr_index_type,\n+\t\t\tgphi *phi, tree tidx);\n+\n+  /* Builds and initializes static arrays initialized with values gathered from\n+     the switch statement.  Also creates statements that load values from\n+     them.  */\n+  void build_arrays ();\n+\n+  /* Generates and appropriately inserts loads of default values at the position\n+     given by GSI.  Returns the last inserted statement.  */\n+  gassign *gen_def_assigns (gimple_stmt_iterator *gsi);\n+\n+  /* Deletes the unused bbs and edges that now contain the switch statement and\n+     its empty branch bbs.  BBD is the now dead BB containing\n+     the original switch statement, FINAL is the last BB of the converted\n+     switch statement (in terms of succession).  */\n+  void prune_bbs (basic_block bbd, basic_block final, basic_block default_bb);\n+\n+  /* Add values to phi nodes in final_bb for the two new edges.  E1F is the edge\n+     from the basic block loading values from an array and E2F from the basic\n+     block loading default values.  BBF is the last switch basic block (see the\n+     bbf description in the comment below).  */\n+  void fix_phi_nodes (edge e1f, edge e2f, basic_block bbf);\n+\n+  /* Creates a check whether the switch expression value actually falls into the\n+     range given by all the cases.  If it does not, the temporaries are loaded\n+     with default values instead.  */\n+  void gen_inbound_check ();\n+\n+  /* Switch statement for which switch conversion takes place.  */\n+  gswitch *m_switch;\n+\n+  /* The expression used to decide the switch branch.  */\n+  tree m_index_expr;\n+\n+  /* The following integer constants store the minimum and maximum value\n+     covered by the case labels.  */\n+  tree m_range_min;\n+  tree m_range_max;\n+\n+  /* The difference between the above two numbers.  Stored here because it\n+     is used in all the conversion heuristics, as well as for some of the\n+     transformation, and it is expensive to re-compute it all the time.  */\n+  tree m_range_size;\n+\n+  /* Basic block that contains the actual GIMPLE_SWITCH.  */\n+  basic_block m_switch_bb;\n+\n+  /* Basic block that is the target of the default case.  */\n+  basic_block m_default_bb;\n+\n+  /* The single successor block of all branches out of the GIMPLE_SWITCH,\n+     if such a block exists.  Otherwise NULL.  */\n+  basic_block m_final_bb;\n+\n+  /* The probability of the default edge in the replaced switch.  */\n+  profile_probability m_default_prob;\n+\n+  /* The count of the default edge in the replaced switch.  */\n+  profile_count m_default_count;\n+\n+  /* Combined count of all other (non-default) edges in the replaced switch.  */\n+  profile_count m_other_count;\n+\n+  /* Number of phi nodes in the final bb (that we'll be replacing).  */\n+  int m_phi_count;\n+\n+  /* Constructors of new static arrays.  */\n+  vec<constructor_elt, va_gc> **m_constructors;\n+\n+  /* Array of default values, in the same order as phi nodes.  */\n+  tree *m_default_values;\n+\n+  /* Array of ssa names that are initialized with a value from a new static\n+     array.  */\n+  tree *m_target_inbound_names;\n+\n+  /* Array of ssa names that are initialized with the default value if the\n+     switch expression is out of range.  */\n+  tree *m_target_outbound_names;\n+\n+  /* VOP SSA_NAME.  */\n+  tree m_target_vop;\n+\n+  /* The first load statement that loads a temporary from a new static array.\n+   */\n+  gimple *m_arr_ref_first;\n+\n+  /* The last load statement that loads a temporary from a new static array.  */\n+  gimple *m_arr_ref_last;\n+\n+  /* String reason why the case wasn't a good candidate that is written to the\n+     dump file, if there is one.  */\n+  const char *m_reason;\n+\n+  /* True if default case is not used for any value between range_min and\n+     range_max inclusive.  */\n+  bool m_contiguous_range;\n+\n+  /* True if default case does not have the required shape for other case\n+     labels.  */\n+  bool m_default_case_nonstandard;\n+\n+  /* Count is number of non-default edges.  */\n+  unsigned int m_count;\n+\n+  /* True if CFG has been changed.  */\n+  bool m_cfg_altered;\n+};\n+\n+} // tree_switch_conversion namespace\n+\n+#endif // TREE_SWITCH_CONVERSION_H"}]}