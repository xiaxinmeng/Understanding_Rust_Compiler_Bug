{"sha": "54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQxMjlhNjRjZDVlYzgyNTRjZGY3Y2M3MzU1MzdmMTRjYjNjMjdkNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-22T20:49:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-22T20:49:00Z"}, "message": "re PR fortran/25818 ([4.1 only] Problem with handling optional and entry master arguments)\n\n2006-12-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25818\n\t* trans-array.c (gfc_trans_g77_array): If the variable is\n\toptional or not always present, make the statement conditional\n\ton presence of the argument.\n\t* gfortran.h : Add symbol_attribute not_always_present.\n\t* resolve.c (check_argument_lists): New function to check if\n\targuments are not present in all entries.\n\n\tPR fortran/30084\n\t* module.c (mio_component_ref): Move treatment of unique name\n\tvariables, during output, to fix_mio_expr.\n\t(fix_mio_expr): New function that fixes defective expressions\n\tbefore they are written to the module file.\n\t(mio_expr): Call the new function.\n\t(resolve_entries): Call check_argument_lists.\n\n2006-12-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25818\n\t* gfortran.dg/entry_array_specs_2.f: New test.\n\n\tPR fortran/30084\n\t* gfortran.dg/nested_modules_6.f90: New test.\n\nFrom-SVN: r120155", "tree": {"sha": "4e9caba7e2118566a1520357042b647f701edfe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e9caba7e2118566a1520357042b647f701edfe8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/comments", "author": null, "committer": null, "parents": [{"sha": "2b0017242d6888e91146422831551f64e9854698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0017242d6888e91146422831551f64e9854698", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b0017242d6888e91146422831551f64e9854698"}], "stats": {"total": 203, "additions": 181, "deletions": 22}, "files": [{"sha": "c47a3b85cbe733cc9f4171bd21bd9d733fa3b897", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -1,3 +1,21 @@\n+2006-12-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25818\n+\t* trans-array.c (gfc_trans_g77_array): If the variable is\n+\toptional or not always present, make the statement conditional\n+\ton presence of the argument.\n+\t* gfortran.h : Add symbol_attribute not_always_present.\n+\t* resolve.c (check_argument_lists): New function to check if\n+\targuments are not present in all entries.\n+\n+\tPR fortran/30084\n+\t* module.c (mio_component_ref): Move treatment of unique name\n+\tvariables, during output, to fix_mio_expr.\n+\t(fix_mio_expr): New function that fixes defective expressions\n+\tbefore they are written to the module file.\n+\t(mio_expr): Call the new function.\n+\t(resolve_entries): Call check_argument_lists.\n+\n 2006-12-21  Roger Sayle  <roger@eyesopen.com>\n \n \t* trans-array.c (gfc_trans_create_temp_array): When the size is known"}, {"sha": "62862977eeb1d5f0a2aa500cc3f78d09d8100900", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -480,7 +480,7 @@ typedef struct\n   /* Variable attributes.  */\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, save:1, target:1, value:1, volatile_:1,\n-    dummy:1, result:1, assign:1, threadprivate:1;\n+    dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n     protected:1,\t\t/* Symbol has been marked as protected.  */"}, {"sha": "dc138d3e5cacc2596e8f865eca9fc8eb2d1c09c7", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -2194,27 +2194,9 @@ mio_symtree_ref (gfc_symtree ** stp)\n {\n   pointer_info *p;\n   fixup_t *f;\n-  gfc_symtree * ns_st = NULL;\n \n   if (iomode == IO_OUTPUT)\n-    {\n-      /* If this is a symtree for a symbol that came from a contained module\n-\t namespace, it has a unique name and we should look in the current\n-\t namespace to see if the required, non-contained symbol is available\n-\t yet. If so, the latter should be written.  */\n-      if ((*stp)->n.sym && check_unique_name((*stp)->name))\n-\tns_st = gfc_find_symtree (gfc_current_ns->sym_root,\n-\t\t\t\t    (*stp)->n.sym->name);\n-\n-      /* On the other hand, if the existing symbol is the module name or the\n-\t new symbol is a dummy argument, do not do the promotion.  */\n-      if (ns_st && ns_st->n.sym\n-\t    && ns_st->n.sym->attr.flavor != FL_MODULE\n-\t    && !(*stp)->n.sym->attr.dummy)\n-\tmio_symbol_ref (&ns_st->n.sym);\n-      else\n-\tmio_symbol_ref (&(*stp)->n.sym);\n-    }\n+    mio_symbol_ref (&(*stp)->n.sym);\n   else\n     {\n       require_atom (ATOM_INTEGER);\n@@ -2554,6 +2536,48 @@ static const mstring intrinsics[] =\n     minit (NULL, -1)\n };\n \n+\n+/* Remedy a couple of situations where the gfc_expr's can be defective.  */\n+ \n+static void\n+fix_mio_expr (gfc_expr *e)\n+{\n+  gfc_symtree *ns_st = NULL;\n+  const char *fname;\n+\n+  if (iomode != IO_OUTPUT)\n+    return;\n+\n+  if (e->symtree)\n+    {\n+      /* If this is a symtree for a symbol that came from a contained module\n+\t namespace, it has a unique name and we should look in the current\n+\t namespace to see if the required, non-contained symbol is available\n+\t yet. If so, the latter should be written.  */\n+      if (e->symtree->n.sym && check_unique_name(e->symtree->name))\n+\tns_st = gfc_find_symtree (gfc_current_ns->sym_root,\n+\t\t\t\t    e->symtree->n.sym->name);\n+\n+      /* On the other hand, if the existing symbol is the module name or the\n+\t new symbol is a dummy argument, do not do the promotion.  */\n+      if (ns_st && ns_st->n.sym\n+\t    && ns_st->n.sym->attr.flavor != FL_MODULE\n+\t    && !e->symtree->n.sym->attr.dummy)\n+\te->symtree = ns_st;\n+    }\n+  else if (e->expr_type == EXPR_FUNCTION && e->value.function.name)\n+    {\n+      /* In some circumstances, a function used in an initialization\n+\t expression, in one use associated module, can fail to be\n+\t coupled to its symtree when used in a specification\n+\t expression in another module.  */\n+      fname = e->value.function.esym ? e->value.function.esym->name :\n+\t\t\t\t       e->value.function.isym->name;\n+      e->symtree = gfc_find_symtree (gfc_current_ns->sym_root, fname);\n+    }\n+}\n+\n+\n /* Read and write expressions.  The form \"()\" is allowed to indicate a\n    NULL expression.  */\n \n@@ -2598,6 +2622,8 @@ mio_expr (gfc_expr ** ep)\n   mio_typespec (&e->ts);\n   mio_integer (&e->rank);\n \n+  fix_mio_expr (e);\n+\n   switch (e->expr_type)\n     {\n     case EXPR_OP:"}, {"sha": "eaa939debec6901ee29213fd2c666c89244c7bdc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -342,6 +342,33 @@ merge_argument_lists (gfc_symbol *proc, gfc_formal_arglist *new_args)\n }\n \n \n+/* Flag the arguments that are not present in all entries.  */\n+\n+static void\n+check_argument_lists (gfc_symbol *proc, gfc_formal_arglist *new_args)\n+{\n+  gfc_formal_arglist *f, *head;\n+  head = new_args;\n+\n+  for (f = proc->formal; f; f = f->next)\n+    {\n+      if (f->sym == NULL)\n+\tcontinue;\n+\n+      for (new_args = head; new_args; new_args = new_args->next)\n+\t{\n+\t  if (new_args->sym == f->sym)\n+\t    break;\n+\t}\n+\n+      if (new_args)\n+\tcontinue;\n+\n+      f->sym->attr.not_always_present = 1;\n+    }\n+}\n+\n+\n /* Resolve alternate entry points.  If a symbol has multiple entry points we\n    create a new master symbol for the main routine, and turn the existing\n    symbol into an entry point.  */\n@@ -541,6 +568,11 @@ resolve_entries (gfc_namespace * ns)\n   for (el = ns->entries; el; el = el->next)\n     merge_argument_lists (proc, el->sym->formal);\n \n+  /* Check the master formal arguments for any that are not\n+     present in all entry points.  */\n+  for (el = ns->entries; el; el = el->next)\n+    check_argument_lists (proc, el->sym->formal);\n+\n   /* Use the master function for the function body.  */\n   ns->proc_name = proc;\n "}, {"sha": "10243fe5712fe8c778e4431be7a4d95635f5ab6d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -3767,6 +3767,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n   locus loc;\n   tree offset;\n   tree tmp;\n+  tree stmt;  \n   stmtblock_t block;\n \n   gfc_get_backend_locus (&loc);\n@@ -3796,13 +3797,21 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n       tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));\n       gfc_add_modify_expr (&block, parm, tmp);\n     }\n-  tmp = gfc_finish_block (&block);\n+  stmt = gfc_finish_block (&block);\n \n   gfc_set_backend_locus (&loc);\n \n   gfc_start_block (&block);\n+\n   /* Add the initialization code to the start of the function.  */\n-  gfc_add_expr_to_block (&block, tmp);\n+\n+  if (sym->attr.optional || sym->attr.not_always_present)\n+    {\n+      tmp = gfc_conv_expr_present (sym);\n+      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+    }\n+  \n+  gfc_add_expr_to_block (&block, stmt);\n   gfc_add_expr_to_block (&block, body);\n \n   return gfc_finish_block (&block);"}, {"sha": "c452eb45f09989ed31f0b4578212ed66e5cd6d03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -1,3 +1,11 @@\n+2006-12-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25818\n+\t* gfortran.dg/entry_array_specs_2.f: New test.\n+\n+\tPR fortran/30084\n+\t* gfortran.dg/nested_modules_6.f90: New test.\n+\n 2006-12-22  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR middle-end/7651"}, {"sha": "ba4de318c88462997dd95531c0660a3ac5ed129f", "filename": "gcc/testsuite/gfortran.dg/entry_array_specs_2.f", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_array_specs_2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_array_specs_2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_array_specs_2.f?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! Tests the patch for PR30025, aka 25818, in which the initialization\n+! code for the array a, was causing a segfault in runtime for a call\n+! to x, since n is missing.\n+!\n+! COntributed by Elizabeth Yip <elizabeth.l.yip@boeing.com>\n+      program test_entry\n+      common // j\n+      real a(10)\n+      a(1) = 999.\n+      call x\n+      if (j .ne. 1) call abort ()\n+      call y(a,10)\n+      if (j .ne. 2) call abort ()\n+      stop\n+      end \n+      subroutine x\n+      common // j\n+      real a(n)\n+      j = 1\n+      return\n+      entry y(a,n)\n+      call foo(a(1))\n+      end\n+      subroutine foo(a)\n+      common // j\n+      real a\n+      j = 2\n+      return\n+      end\n+"}, {"sha": "c967aaa7b13bd7a0b29d622618760a5154a4147a", "filename": "gcc/testsuite/gfortran.dg/nested_modules_6.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54129a64cd5ec8254cdf7cc735537f14cb3c27d7/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_6.f90?ref=54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! Test the patch for PR30084 in which the reference to SIZE\n+! in function diag caused a segfault in module.c.\n+!\n+! Contributed by Troban Trumsko <trumsko@yahoo.com>\n+! and reduced by Steve Kargl <kargl@gcc.gnu.org>\n+!\n+module tao_random_numbers\n+  integer, dimension(10) :: s_buffer\n+  integer :: s_last = size (s_buffer)\n+end module tao_random_numbers\n+\n+module linalg\n+  contains\n+  function diag (a) result (d)\n+    real, dimension(:,:), intent(in) :: a\n+    real, dimension(min(size(a,dim=1),size(a,dim=2))) :: d\n+    integer :: i\n+    do i = 1, min(size(a, dim = 1), size(a, dim = 2))\n+       d(i) = a(i,i)\n+    end do\n+  end function diag\n+end module linalg\n+\n+module vamp_rest\n+  use tao_random_numbers\n+  use linalg\n+end module vamp_rest\n+\n+  use vamp_rest\n+  real :: x(2, 2) = reshape ([1.,2.,3.,4.], [2,2]) ! { dg-warning \"nonstandard\" } \n+  print *, s_last\n+  print *, diag (x)\n+end\n+! { dg-final { cleanup-modules \"tao_random_numbers linalg vamp_rest\" } }"}]}