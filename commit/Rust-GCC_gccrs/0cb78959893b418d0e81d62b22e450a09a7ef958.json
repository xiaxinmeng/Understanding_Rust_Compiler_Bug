{"sha": "0cb78959893b418d0e81d62b22e450a09a7ef958", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNiNzg5NTk4OTNiNDE4ZDBlODFkNjJiMjJlNDUwYTA5YTdlZjk1OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T06:58:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T06:58:00Z"}, "message": "poly_int: reload.c\n\nThis patch makes a few small poly_int64 changes to reload.c,\nsuch as in the \"decomposition\" structure.  In practice, any\nport with polynomial-sized modes should be using LRA rather\nthan reload, but it's easier to convert reload anyway than\nto sprinkle to_constants everywhere.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* reload.h (reload::inc): Change from an int to a poly_int64_pod.\n\t* reload.c (combine_reloads, debug_reload_to_stream): Likewise.\n\t(decomposition): Change start and end from HOST_WIDE_INT\n\tto poly_int64_pod.\n\t(decompose, immune_p): Update accordingly.\n\t(find_inc_amount): Return a poly_int64 rather than an int.\n\t* reload1.c (inc_for_reload): Take the inc_amount as a poly_int64\n\trather than an int.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255915", "tree": {"sha": "229b864810d8ff93f56790e4272a2a34a5fa0039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/229b864810d8ff93f56790e4272a2a34a5fa0039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cb78959893b418d0e81d62b22e450a09a7ef958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb78959893b418d0e81d62b22e450a09a7ef958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb78959893b418d0e81d62b22e450a09a7ef958", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb78959893b418d0e81d62b22e450a09a7ef958/comments", "author": null, "committer": null, "parents": [{"sha": "f37fac2b74df114c5b3e9c8a3be2cad9acd3f4ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37fac2b74df114c5b3e9c8a3be2cad9acd3f4ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37fac2b74df114c5b3e9c8a3be2cad9acd3f4ca"}], "stats": {"total": 80, "additions": 52, "deletions": 28}, "files": [{"sha": "605c74ada55cce55e6bca56b66c94cfb281d47b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cb78959893b418d0e81d62b22e450a09a7ef958", "patch": "@@ -1,3 +1,16 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* reload.h (reload::inc): Change from an int to a poly_int64_pod.\n+\t* reload.c (combine_reloads, debug_reload_to_stream): Likewise.\n+\t(decomposition): Change start and end from HOST_WIDE_INT\n+\tto poly_int64_pod.\n+\t(decompose, immune_p): Update accordingly.\n+\t(find_inc_amount): Return a poly_int64 rather than an int.\n+\t* reload1.c (inc_for_reload): Take the inc_amount as a poly_int64\n+\trather than an int.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0d986f73b346e7574d9c67e4eb5471014f8c711b", "filename": "gcc/reload.c", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0cb78959893b418d0e81d62b22e450a09a7ef958", "patch": "@@ -168,8 +168,8 @@ struct decomposition\n   int reg_flag;\t\t/* Nonzero if referencing a register.  */\n   int safe;\t\t/* Nonzero if this can't conflict with anything.  */\n   rtx base;\t\t/* Base address for MEM.  */\n-  HOST_WIDE_INT start;\t/* Starting offset or register number.  */\n-  HOST_WIDE_INT end;\t/* Ending offset or register number.  */\n+  poly_int64_pod start;\t/* Starting offset or register number.  */\n+  poly_int64_pod end;\t/* Ending offset or register number.  */\n };\n \n /* Save MEMs needed to copy from one class of registers to another.  One MEM\n@@ -278,7 +278,7 @@ static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n static rtx find_reloads_subreg_address (rtx, int, enum reload_type,\n \t\t\t\t\tint, rtx_insn *, int *);\n static void copy_replacements_1 (rtx *, rtx *, int);\n-static int find_inc_amount (rtx, rtx);\n+static poly_int64 find_inc_amount (rtx, rtx);\n static int refers_to_mem_for_reload_p (rtx);\n static int refers_to_regno_for_reload_p (unsigned int, unsigned int,\n \t\t\t\t\t rtx, rtx *);\n@@ -1772,7 +1772,7 @@ combine_reloads (void)\n \t&& (ira_reg_class_max_nregs [(int)rld[i].rclass][(int) rld[i].inmode]\n \t    == ira_reg_class_max_nregs [(int) rld[output_reload].rclass]\n \t\t\t\t       [(int) rld[output_reload].outmode])\n-\t&& rld[i].inc == 0\n+\t&& known_eq (rld[i].inc, 0)\n \t&& rld[i].reg_rtx == 0\n \t/* Don't combine two reloads with different secondary\n \t   memory locations.  */\n@@ -2360,7 +2360,7 @@ static struct decomposition\n decompose (rtx x)\n {\n   struct decomposition val;\n-  int all_const = 0;\n+  int all_const = 0, regno;\n \n   memset (&val, 0, sizeof (val));\n \n@@ -2458,29 +2458,33 @@ decompose (rtx x)\n \n     case REG:\n       val.reg_flag = 1;\n-      val.start = true_regnum (x);\n-      if (val.start < 0 || val.start >= FIRST_PSEUDO_REGISTER)\n+      regno = true_regnum (x);\n+      if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER)\n \t{\n \t  /* A pseudo with no hard reg.  */\n \t  val.start = REGNO (x);\n \t  val.end = val.start + 1;\n \t}\n       else\n-\t/* A hard reg.  */\n-\tval.end = end_hard_regno (GET_MODE (x), val.start);\n+\t{\n+\t  /* A hard reg.  */\n+\t  val.start = regno;\n+\t  val.end = end_hard_regno (GET_MODE (x), regno);\n+\t}\n       break;\n \n     case SUBREG:\n       if (!REG_P (SUBREG_REG (x)))\n \t/* This could be more precise, but it's good enough.  */\n \treturn decompose (SUBREG_REG (x));\n-      val.reg_flag = 1;\n-      val.start = true_regnum (x);\n-      if (val.start < 0 || val.start >= FIRST_PSEUDO_REGISTER)\n+      regno = true_regnum (x);\n+      if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER)\n \treturn decompose (SUBREG_REG (x));\n-      else\n-\t/* A hard reg.  */\n-\tval.end = val.start + subreg_nregs (x);\n+\n+      /* A hard reg.  */\n+      val.reg_flag = 1;\n+      val.start = regno;\n+      val.end = regno + subreg_nregs (x);\n       break;\n \n     case SCRATCH:\n@@ -2505,7 +2509,11 @@ immune_p (rtx x, rtx y, struct decomposition ydata)\n   struct decomposition xdata;\n \n   if (ydata.reg_flag)\n-    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, (rtx*) 0);\n+    /* In this case the decomposition structure contains register\n+       numbers rather than byte offsets.  */\n+    return !refers_to_regno_for_reload_p (ydata.start.to_constant (),\n+\t\t\t\t\t  ydata.end.to_constant (),\n+\t\t\t\t\t  x, (rtx *) 0);\n   if (ydata.safe)\n     return 1;\n \n@@ -2536,7 +2544,7 @@ immune_p (rtx x, rtx y, struct decomposition ydata)\n       return 0;\n     }\n \n-  return (xdata.start >= ydata.end || ydata.start >= xdata.end);\n+  return known_ge (xdata.start, ydata.end) || known_ge (ydata.start, xdata.end);\n }\n \n /* Similar, but calls decompose.  */\n@@ -7062,7 +7070,7 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n    within X, and return the amount INCED is incremented or decremented by.\n    The value is always positive.  */\n \n-static int\n+static poly_int64\n find_inc_amount (rtx x, rtx inced)\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -7095,17 +7103,17 @@ find_inc_amount (rtx x, rtx inced)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  int tem = find_inc_amount (XEXP (x, i), inced);\n-\t  if (tem != 0)\n+\t  poly_int64 tem = find_inc_amount (XEXP (x, i), inced);\n+\t  if (maybe_ne (tem, 0))\n \t    return tem;\n \t}\n       if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n-\t      int tem = find_inc_amount (XVECEXP (x, i, j), inced);\n-\t      if (tem != 0)\n+\t      poly_int64 tem = find_inc_amount (XVECEXP (x, i, j), inced);\n+\t      if (maybe_ne (tem, 0))\n \t\treturn tem;\n \t    }\n \t}\n@@ -7266,8 +7274,11 @@ debug_reload_to_stream (FILE *f)\n       if (rld[r].nongroup)\n \tfprintf (f, \", nongroup\");\n \n-      if (rld[r].inc != 0)\n-\tfprintf (f, \", inc by %d\", rld[r].inc);\n+      if (maybe_ne (rld[r].inc, 0))\n+\t{\n+\t  fprintf (f, \", inc by \");\n+\t  print_dec (rld[r].inc, f, SIGNED);\n+\t}\n \n       if (rld[r].nocombine)\n \tfprintf (f, \", can't combine\");"}, {"sha": "2019db8b761bc9e54e71ee586f83e11d5da23412", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=0cb78959893b418d0e81d62b22e450a09a7ef958", "patch": "@@ -97,7 +97,7 @@ struct reload\n   /* Positive amount to increment or decrement by if\n      reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC.\n      Ignored otherwise (don't assume it is zero).  */\n-  int inc;\n+  poly_int64_pod inc;\n   /* A reg for which reload_in is the equivalent.\n      If reload_in is a symbol_ref which came from\n      reg_equiv_constant, then this is the pseudo"}, {"sha": "9557e3d154d8aedbb12c8683dd5339a56898474f", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb78959893b418d0e81d62b22e450a09a7ef958/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0cb78959893b418d0e81d62b22e450a09a7ef958", "patch": "@@ -398,7 +398,7 @@ static void emit_reload_insns (struct insn_chain *);\n static void delete_output_reload (rtx_insn *, int, int, rtx);\n static void delete_address_reloads (rtx_insn *, rtx_insn *);\n static void delete_address_reloads_1 (rtx_insn *, rtx, rtx_insn *);\n-static void inc_for_reload (rtx, rtx, rtx, int);\n+static void inc_for_reload (rtx, rtx, rtx, poly_int64);\n static void add_auto_inc_notes (rtx_insn *, rtx);\n static void substitute (rtx *, const_rtx, rtx);\n static bool gen_reload_chain_without_interm_reg_p (int, int);\n@@ -9075,7 +9075,7 @@ delete_address_reloads_1 (rtx_insn *dead_insn, rtx x, rtx_insn *current_insn)\n    This cannot be deduced from VALUE.  */\n \n static void\n-inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n+inc_for_reload (rtx reloadreg, rtx in, rtx value, poly_int64 inc_amount)\n {\n   /* REG or MEM to be copied and incremented.  */\n   rtx incloc = find_replacement (&XEXP (value, 0));\n@@ -9105,7 +9105,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n       if (GET_CODE (value) == PRE_DEC || GET_CODE (value) == POST_DEC)\n \tinc_amount = -inc_amount;\n \n-      inc = GEN_INT (inc_amount);\n+      inc = gen_int_mode (inc_amount, Pmode);\n     }\n \n   /* If this is post-increment, first copy the location to the reload reg.  */"}]}