{"sha": "f0a5229172374e2750307a0eacf33419952583c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBhNTIyOTE3MjM3NGUyNzUwMzA3YTBlYWNmMzM0MTk5NTI1ODNjNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:56:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:56:13Z"}, "message": "(OBJC_VERSION): Increment version.\n\n(objc_send_load, __objc_send_load): New functions.\n(__objc_send_message_in_list): New function.\n(__objc_force_linking): New function.\n(__objc_exec_class): Don't call _objc_load_callback here.\n(__objc_exec_class): Access statics from their new place in the defs variable.\n\nFrom-SVN: r13709", "tree": {"sha": "54a77ae38a122626e383ce38158ff5fd47c4bd17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54a77ae38a122626e383ce38158ff5fd47c4bd17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0a5229172374e2750307a0eacf33419952583c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a5229172374e2750307a0eacf33419952583c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0a5229172374e2750307a0eacf33419952583c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a5229172374e2750307a0eacf33419952583c7/comments", "author": null, "committer": null, "parents": [{"sha": "e335b3ee7e702baa1379c06bcf98ad2b997859a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e335b3ee7e702baa1379c06bcf98ad2b997859a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e335b3ee7e702baa1379c06bcf98ad2b997859a2"}], "stats": {"total": 145, "additions": 140, "deletions": 5}, "files": [{"sha": "fe64bf4394036701a53ae5eab957d8c5a785709d", "filename": "gcc/objc/init.c", "status": "modified", "additions": 140, "deletions": 5, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a5229172374e2750307a0eacf33419952583c7/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a5229172374e2750307a0eacf33419952583c7/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=f0a5229172374e2750307a0eacf33419952583c7", "patch": "@@ -27,7 +27,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c) */\n-#define OBJC_VERSION 7\n+#define OBJC_VERSION 8\n #define PROTOCOL_VERSION 2\n \n /* This list contains all modules currently loaded into the runtime */\n@@ -67,6 +67,25 @@ extern SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const);\n \n+/* Send +load to all classes and categories from a module that implement\n+   this method */\n+static void __objc_send_load(Module_t module);\n+\n+/* This list contains all the classes in the runtime system for whom their\n+   superclasses are not yet know to the runtime. */\n+static struct objc_list* unresolved_classes = 0;\n+\n+/* Static function used to references the Object and NXConstantString classes. */\n+static void\n+__objc_force_linking (void)\n+{\n+  extern void __objc_linking (void);\n+  __objc_linking ();\n+\n+  /* Call the function to avoid compiler warning */\n+  __objc_force_linking ();\n+}\n+\n /* Run through the statics list, removing modules as soon as all its statics\n    have been initialized.  */\n static void\n@@ -143,6 +162,10 @@ __objc_exec_class (Module_t module)\n   /* The symbol table (defined in objc-api.h) generated by gcc */\n   Symtab_t symtab = module->symtab;\n \n+  /* The statics in this module */\n+  struct objc_static_instances **statics\n+    = symtab->defs[symtab->cls_def_cnt + symtab->cat_def_cnt];\n+\n   /* Entry used to traverse hash lists */\n   struct objc_list** cell;\n \n@@ -196,6 +219,7 @@ __objc_exec_class (Module_t module)\n   for (i = 0; i < symtab->cls_def_cnt; ++i)\n     {\n       Class class = (Class) symtab->defs[i];\n+      const char* superclass = (char*)class->super_class;\n \n       /* Make sure we have what we think.  */\n       assert (CLS_ISCLASS(class));\n@@ -216,8 +240,10 @@ __objc_exec_class (Module_t module)\n       if (class->protocols)\n \t__objc_init_protocols (class->protocols);\n \n-      if (_objc_load_callback)\n-\t_objc_load_callback(class, 0);\n+      /* Check to see if the superclass is known in this point. If it's not\n+\t add the class to the unresolved_classes list. */\n+      if (superclass && !objc_lookup_class (superclass))\n+\tunresolved_classes = list_cons (class, unresolved_classes);\n    }\n \n   /* Process category information from the module.  */\n@@ -260,8 +286,8 @@ __objc_exec_class (Module_t module)\n \t}\n     }\n \n-  if (module->statics)\n-    uninitialized_statics = list_cons (module->statics, uninitialized_statics);\n+  if (statics)\n+    uninitialized_statics = list_cons (statics, uninitialized_statics);\n   if (uninitialized_statics)\n     objc_init_statics ();\n \n@@ -306,9 +332,118 @@ __objc_exec_class (Module_t module)\n       unclaimed_proto_list = 0;\n     }\n \n+  objc_send_load ();\n+\n   objc_mutex_unlock(__objc_runtime_mutex);\n }\n \n+void objc_send_load (void)\n+{\n+  if (!__objc_module_list)\n+    return;\n+ \n+  /* Try to find out if all the classes loaded so far also have their\n+     superclasses known to the runtime. We suppose that the objects that are\n+     allocated in the +load method are in general of a class declared in the\n+     same module. */\n+  if (unresolved_classes)\n+    {\n+      Class class = unresolved_classes->head;\n+\n+      while (objc_lookup_class ((char*)class->super_class))\n+\t{\n+\t  list_remove_head (&unresolved_classes);\n+\t  if (unresolved_classes)\n+\t    class = unresolved_classes->head;\n+\t  else\n+\t    break;\n+\t}\n+\n+      /*\n+       * If we still have classes for which we don't have yet their super\n+       * classes known to the runtime we don't send the +load messages.\n+       */\n+      if (unresolved_classes)\n+\treturn;\n+    }\n+\n+  /* Special check to allow sending messages to constant strings in +load\n+     methods. If the class is not yet known, even if all the classes are known,\n+     delay sending of +load. */\n+  if (!objc_lookup_class (\"NXConstantString\"))\n+    return;\n+\n+  /* Iterate over all modules in the __objc_module_list and call on them the\n+     __objc_send_load function that sends the +load message. */\n+  list_mapcar (__objc_module_list, (void(*)(void*))__objc_send_load);\n+  list_free (__objc_module_list);\n+  __objc_module_list = NULL;\n+}\n+\n+static void\n+__objc_send_message_in_list (MethodList_t method_list, id object, SEL op)\n+{\n+  while (method_list)\n+    {\n+      int i;\n+\n+      /* Search the method list. */\n+      for (i = 0; i < method_list->method_count; i++)\n+\t{\n+\t  Method_t mth = &method_list->method_list[i];\n+\n+\t  if (mth->method_name && sel_eq (mth->method_name, op))\n+\t    {\n+\t      /* The method was found. */\n+\t      (*mth->method_imp) (object, mth->method_name);\n+\t      break;\n+\t    }\n+\t}\n+      method_list = method_list->method_next;\n+    }\n+}\n+\n+static void\n+__objc_send_load(Module_t module)\n+{\n+  /* The runtime mutex is locked in this point */\n+\n+  Symtab_t symtab = module->symtab;\n+  static SEL load_sel = 0;\n+  int i;\n+\n+  if (!load_sel)\n+    load_sel = sel_register_name (\"load\");\n+\n+  /* Iterate thru classes defined in this module and send them the +load\n+     message if they implement it. At this point all methods defined in\n+     categories were added to the corresponding class, so all the +load\n+     methods of categories are in their corresponding classes. */\n+  for (i = 0; i < symtab->cls_def_cnt; i++)\n+    {\n+      Class class = (Class) symtab->defs[i];\n+      MethodList_t method_list = class->class_pointer->methods;\n+\n+      __objc_send_message_in_list (method_list, (id)class, load_sel);\n+\n+      /* Call the _objc_load_callback for this class. */\n+      if (_objc_load_callback)\n+\t_objc_load_callback(class, 0);\n+    }\n+\n+  /* Call the _objc_load_callback for categories. Don't register the instance\n+     methods as class methods for categories to root classes since they were\n+     already added in the class. */\n+  for (i = 0; i < symtab->cat_def_cnt; i++)\n+    {\n+      Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class class = objc_lookup_class (category->class_name);\n+      \n+      if (_objc_load_callback)\n+\t_objc_load_callback(class, category);\n+    }\n+}\n+\n /* Sanity check the version of gcc used to compile `module'*/\n static void init_check_module_version(Module_t module)\n {"}]}