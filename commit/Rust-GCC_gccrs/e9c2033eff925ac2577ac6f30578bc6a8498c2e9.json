{"sha": "e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTljMjAzM2VmZjkyNWFjMjU3N2FjNmYzMDU3OGJjNmE4NDk4YzJlOQ==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.vnet.ibm.com", "date": "2016-12-19T21:32:16Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2016-12-19T21:32:16Z"}, "message": "rs6000-protos.h (expand_strn_compare): Declare.\n\n\t* config/rs6000/rs6000-protos.h (expand_strn_compare): Declare.\n\t* config/rs6000/rs6000.md (UNSPEC_CMPB): New unspec.\n\t(cmpb<mode>3): pattern for generating cmpb.\n\t(cmpstrnsi): pattern to expand strncmp ().\n\t* config/rs6000/rs6000.opt (mstring-compare-inline-limit): Add a new\n\ttarget option for controlling how much code inline expansion of\n\tstrncmp() will be allowed to generate.\n\t* config/rs6000/rs6000.c (expand_strncmp_align_check): generate code\n\tfor runtime page crossing check of strncmp () args.\n\t(expand_strn_compare): Function to do builtin expansion of strncmp ().\n\nFrom-SVN: r243813", "tree": {"sha": "1e2ccf0a8a3fe5496316952c0356778ec7eade37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e2ccf0a8a3fe5496316952c0356778ec7eade37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/comments", "author": null, "committer": null, "parents": [{"sha": "f40772228541713306cc1678fda2b365fe228ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40772228541713306cc1678fda2b365fe228ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40772228541713306cc1678fda2b365fe228ebc"}], "stats": {"total": 434, "additions": 430, "deletions": 4}, "files": [{"sha": "ba3c4daa9a3d3fe9d8ded6b57bf83157678b1704", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "patch": "@@ -1,3 +1,16 @@\n+2016-12-19  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (expand_strn_compare): Declare.\n+\t* config/rs6000/rs6000.md (UNSPEC_CMPB): New unspec.\n+\t(cmpb<mode>3): pattern for generating cmpb.\n+\t(cmpstrnsi): pattern to expand strncmp ().\n+\t* config/rs6000/rs6000.opt (mstring-compare-inline-limit): Add a new\n+\ttarget option for controlling how much code inline expansion of\n+\tstrncmp() will be allowed to generate.\n+\t* config/rs6000/rs6000.c (expand_strncmp_align_check): generate code\n+\tfor runtime page crossing check of strncmp () args.\n+\t(expand_strn_compare): Function to do builtin expansion of strncmp ().\n+\n 2016-12-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* print-rtl-function.c (print_rtx_function): Update"}, {"sha": "0f24fdd9192c11b9e3ebc7f1b58a21250f2fb716", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "patch": "@@ -78,6 +78,7 @@ extern void rs6000_scale_v2df (rtx, rtx, int);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n extern bool expand_block_compare (rtx[]);\n+extern bool expand_strn_compare (rtx[]);\n extern const char * rs6000_output_load_multiple (rtx[]);\n extern bool rs6000_is_valid_mask (rtx, int *, int *, machine_mode);\n extern bool rs6000_is_valid_and_mask (rtx, machine_mode);"}, {"sha": "93088a3a7e713d5c3891d6e0423bdb5f63a8cacc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 382, "deletions": 3, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "patch": "@@ -18993,7 +18993,6 @@ rs6000_emit_dot_insn (rtx dst, rtx src, int dot, rtx ccreg)\n     }\n }\n \n-\f\n /* Figure out the correct instructions to generate to load data for\n    block compare.  MODE is used for the read from memory, and\n    data is zero extended if REG is wider than MODE.  If LE code\n@@ -19430,7 +19429,387 @@ expand_block_compare (rtx operands[])\n   return true;\n }\n \n-\f\n+/* Generate alignment check and branch code to set up for\n+   strncmp when we don't have DI alignment.\n+   STRNCMP_LABEL is the label to branch if there is a page crossing.\n+   SRC is the string pointer to be examined.\n+   BYTES is the max number of bytes to compare.  */\n+static void\n+expand_strncmp_align_check (rtx strncmp_label, rtx src, HOST_WIDE_INT bytes)\n+{\n+  rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, strncmp_label);\n+  rtx src_check = copy_addr_to_reg (XEXP (src, 0));\n+  if (GET_MODE (src_check) == SImode)\n+    emit_insn (gen_andsi3 (src_check, src_check, GEN_INT (0xfff)));\n+  else\n+    emit_insn (gen_anddi3 (src_check, src_check, GEN_INT (0xfff)));\n+  rtx cond = gen_reg_rtx (CCmode);\n+  emit_move_insn (cond, gen_rtx_COMPARE (CCmode, src_check,\n+\t\t\t\t\t GEN_INT (4096 - bytes)));\n+\n+  rtx cmp_rtx = gen_rtx_LT (VOIDmode, cond, const0_rtx);\n+\n+  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n+\t\t\t\t     pc_rtx, lab_ref);\n+  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+  JUMP_LABEL (j) = strncmp_label;\n+  LABEL_NUSES (strncmp_label) += 1;\n+}\n+\n+/* Expand a string compare operation with length, and return\n+   true if successful. Return false if we should let the\n+   compiler generate normal code, probably a strncmp call.\n+\n+   OPERANDS[0] is the target (result).\n+   OPERANDS[1] is the first source.\n+   OPERANDS[2] is the second source.\n+   OPERANDS[3] is the length.\n+   OPERANDS[4] is the alignment in bytes.  */\n+bool\n+expand_strn_compare (rtx operands[])\n+{\n+  rtx target = operands[0];\n+  rtx orig_src1 = operands[1];\n+  rtx orig_src2 = operands[2];\n+  rtx bytes_rtx = operands[3];\n+  rtx align_rtx = operands[4];\n+  HOST_WIDE_INT cmp_bytes = 0;\n+  rtx src1 = orig_src1;\n+  rtx src2 = orig_src2;\n+\n+  /* If this is not a fixed size compare, just call strncmp.  */\n+  if (!CONST_INT_P (bytes_rtx))\n+    return false;\n+\n+  /* This must be a fixed size alignment.  */\n+  if (!CONST_INT_P (align_rtx))\n+    return false;\n+\n+  int base_align = INTVAL (align_rtx);\n+  int align1 = MEM_ALIGN (orig_src1) / BITS_PER_UNIT;\n+  int align2 = MEM_ALIGN (orig_src2) / BITS_PER_UNIT;\n+\n+  /* SLOW_UNALIGNED_ACCESS -- don't do unaligned stuff.  */\n+  if (SLOW_UNALIGNED_ACCESS (word_mode, align1)\n+      || SLOW_UNALIGNED_ACCESS (word_mode, align2))\n+    return false;\n+\n+  gcc_assert (GET_MODE (target) == SImode);\n+\n+  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n+\n+  /* If we have an LE target without ldbrx and word_mode is DImode,\n+     then we must avoid using word_mode.  */\n+  int word_mode_ok = !(!BYTES_BIG_ENDIAN && !TARGET_LDBRX\n+\t\t       && word_mode == DImode);\n+\n+  int word_mode_size = GET_MODE_SIZE (word_mode);\n+\n+  int offset = 0;\n+  machine_mode load_mode =\n+    select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n+  int load_mode_size = GET_MODE_SIZE (load_mode);\n+\n+  /* We don't want to generate too much code.  Also if bytes is\n+     4096 or larger we always want the library strncmp anyway.  */\n+  int groups = ROUND_UP (bytes, load_mode_size) / load_mode_size;\n+  if (bytes >= 4096 || groups > rs6000_string_compare_inline_limit)\n+    return false;\n+\n+  rtx result_reg = gen_reg_rtx (word_mode);\n+  rtx final_move_label = gen_label_rtx ();\n+  rtx final_label = gen_label_rtx ();\n+  rtx begin_compare_label = NULL;\n+\n+  if (base_align < 8)\n+    {\n+      /* Generate code that checks distance to 4k boundary for this case.  */\n+      begin_compare_label = gen_label_rtx ();\n+      rtx strncmp_label = gen_label_rtx ();\n+      rtx jmp;\n+\n+      /* Strncmp for power8 in glibc does this:\n+\t rldicl\tr8,r3,0,52\n+\t cmpldi\tcr7,r8,4096-16\n+\t bgt\tcr7,L(pagecross) */\n+\n+      if (align1 < 8)\n+\texpand_strncmp_align_check (strncmp_label, src1, bytes);\n+      if (align2 < 8)\n+\texpand_strncmp_align_check (strncmp_label, src2, bytes);\n+\n+      /* Now generate the following sequence:\n+\t - branch to begin_compare\n+\t - strncmp_label\n+\t - call to strncmp\n+\t - branch to final_label\n+\t - begin_compare_label */\n+\n+      rtx cmp_ref = gen_rtx_LABEL_REF (VOIDmode, begin_compare_label);\n+      jmp = emit_jump_insn (gen_rtx_SET (pc_rtx, cmp_ref));\n+      JUMP_LABEL(jmp) = begin_compare_label;\n+      LABEL_NUSES (begin_compare_label) += 1;\n+      emit_barrier ();\n+\n+      emit_label (strncmp_label);\n+\n+      if (!REG_P (XEXP (src1, 0)))\n+\t{\n+\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n+\t  src1 = replace_equiv_address (src1, src1_reg);\n+\t}\n+\n+      if (!REG_P (XEXP (src2, 0)))\n+\t{\n+\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n+\t  src2 = replace_equiv_address (src2, src2_reg);\n+\t}\n+\n+      /* -m32 -mpowerpc64 results in word_mode being DImode even\n+\t though otherwise it is 32-bit. The length arg to strncmp\n+\t is a size_t which will be the same size as pointers.  */\n+      rtx len_rtx;\n+      if (TARGET_64BIT)\n+\tlen_rtx = gen_reg_rtx(DImode);\n+      else\n+\tlen_rtx = gen_reg_rtx(SImode);\n+\n+      emit_move_insn (len_rtx, bytes_rtx);\n+\n+      emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \"strncmp\"),\n+\t\t\t       target, LCT_NORMAL, GET_MODE (target), 3,\n+\t\t\t       force_reg (Pmode, XEXP (src1, 0)), Pmode,\n+\t\t\t       force_reg (Pmode, XEXP (src2, 0)), Pmode,\n+\t\t\t       len_rtx, GET_MODE (len_rtx));\n+\n+      rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n+      jmp = emit_jump_insn (gen_rtx_SET (pc_rtx, fin_ref));\n+      JUMP_LABEL (jmp) = final_label;\n+      LABEL_NUSES (final_label) += 1;\n+      emit_barrier ();\n+      emit_label (begin_compare_label);\n+    }\n+\n+  rtx cleanup_label = NULL;\n+  rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n+  rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n+\n+  /* Generate sequence of ld/ldbrx, cmpb to compare out\n+     to the length specified.  */\n+  while (bytes > 0)\n+    {\n+      /* Compare sequence:\n+         check each 8B with: ld/ld cmpd bne\n+         cleanup code at end:\n+         cmpb          get byte that differs\n+         cmpb          look for zero byte\n+         orc           combine\n+         cntlzd        get bit of first zero/diff byte\n+         subfic        convert for rldcl use\n+         rldcl rldcl   extract diff/zero byte\n+         subf          subtract for final result\n+\n+         The last compare can branch around the cleanup code if the\n+         result is zero because the strings are exactly equal.  */\n+      int align = compute_current_alignment (base_align, offset);\n+      if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n+\tload_mode = select_block_compare_mode (offset, bytes, align,\n+\t\t\t\t\t       word_mode_ok);\n+      else\n+\tload_mode = select_block_compare_mode (0, bytes, align, word_mode_ok);\n+      load_mode_size = GET_MODE_SIZE (load_mode);\n+      if (bytes >= load_mode_size)\n+\tcmp_bytes = load_mode_size;\n+      else if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n+\t{\n+\t  /* Move this load back so it doesn't go past the end.\n+\t     P8/P9 can do this efficiently.  */\n+\t  int extra_bytes = load_mode_size - bytes;\n+\t  cmp_bytes = bytes;\n+\t  if (extra_bytes < offset)\n+\t    {\n+\t      offset -= extra_bytes;\n+\t      cmp_bytes = load_mode_size;\n+\t      bytes = cmp_bytes;\n+\t    }\n+\t}\n+      else\n+\t/* P7 and earlier can't do the overlapping load trick fast,\n+\t   so this forces a non-overlapping load and a shift to get\n+\t   rid of the extra bytes.  */\n+\tcmp_bytes = bytes;\n+\n+      src1 = adjust_address (orig_src1, load_mode, offset);\n+      src2 = adjust_address (orig_src2, load_mode, offset);\n+\n+      if (!REG_P (XEXP (src1, 0)))\n+\t{\n+\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n+\t  src1 = replace_equiv_address (src1, src1_reg);\n+\t}\n+      set_mem_size (src1, cmp_bytes);\n+\n+      if (!REG_P (XEXP (src2, 0)))\n+\t{\n+\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n+\t  src2 = replace_equiv_address (src2, src2_reg);\n+\t}\n+      set_mem_size (src2, cmp_bytes);\n+\n+      do_load_for_compare (tmp_reg_src1, src1, load_mode);\n+      do_load_for_compare (tmp_reg_src2, src2, load_mode);\n+\n+      /* We must always left-align the data we read, and\n+\t clear any bytes to the right that are beyond the string.\n+\t Otherwise the cmpb sequence won't produce the correct\n+\t results.  The beginning of the compare will be done\n+\t with word_mode so will not have any extra shifts or\n+\t clear rights.  */\n+\n+      if (load_mode_size < word_mode_size)\n+\t{\n+\t  /* Rotate left first. */\n+\t  rtx sh = GEN_INT (BITS_PER_UNIT * (word_mode_size - load_mode_size));\n+\t  if (word_mode == DImode)\n+\t    {\n+\t      emit_insn (gen_rotldi3 (tmp_reg_src1, tmp_reg_src1, sh));\n+\t      emit_insn (gen_rotldi3 (tmp_reg_src2, tmp_reg_src2, sh));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_rotlsi3 (tmp_reg_src1, tmp_reg_src1, sh));\n+\t      emit_insn (gen_rotlsi3 (tmp_reg_src2, tmp_reg_src2, sh));\n+\t    }\n+\t}\n+\n+      if (cmp_bytes < word_mode_size)\n+\t{\n+\t  /* Now clear right.  This plus the rotate can be\n+\t     turned into a rldicr instruction. */\n+\t  HOST_WIDE_INT mb = BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t  if (word_mode == DImode)\n+\t    {\n+\t      emit_insn (gen_anddi3_mask (tmp_reg_src1, tmp_reg_src1, mask));\n+\t      emit_insn (gen_anddi3_mask (tmp_reg_src2, tmp_reg_src2, mask));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_andsi3_mask (tmp_reg_src1, tmp_reg_src1, mask));\n+\t      emit_insn (gen_andsi3_mask (tmp_reg_src2, tmp_reg_src2, mask));\n+\t    }\n+\t}\n+\n+      int remain = bytes - cmp_bytes;\n+\n+      rtx dst_label;\n+      if (remain > 0)\n+\t{\n+\t  if (!cleanup_label)\n+\t    cleanup_label = gen_label_rtx ();\n+\t  dst_label = cleanup_label;\n+\t}\n+      else\n+\tdst_label = final_move_label;\n+\n+      rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n+      rtx cond = gen_reg_rtx (CCmode);\n+\n+      if (remain == 0)\n+\t{\n+\t  /* For the last chunk, subf. also\n+\t     generates the zero result we need.  */\n+\t  rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n+\t  rs6000_emit_dot_insn (result_reg, tmp, 1, cond);\n+\t}\n+      else\n+\temit_move_insn (cond, gen_rtx_COMPARE (CCmode,\n+\t\t\t\t\t       tmp_reg_src1, tmp_reg_src2));\n+\n+      rtx cmp_rtx;\n+      if (remain > 0)\n+\tcmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+      else\n+\tcmp_rtx = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n+\n+      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n+\t\t\t\t\t lab_ref, pc_rtx);\n+      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+      JUMP_LABEL (j) = dst_label;\n+      LABEL_NUSES (dst_label) += 1;\n+\n+      offset += cmp_bytes;\n+      bytes -= cmp_bytes;\n+    }\n+\n+  if (cleanup_label)\n+    emit_label (cleanup_label);\n+\n+  /* Generate the final sequence that identifies the differing\n+     byte and generates the final result, taking into account\n+     zero bytes:\n+\n+     cmpb              cmpb_result1, src1, src2\n+     cmpb              cmpb_result2, src1, zero\n+     orc               cmpb_result1, cmp_result1, cmpb_result2\n+     cntlzd            get bit of first zero/diff byte\n+     addi              convert for rldcl use\n+     rldcl rldcl       extract diff/zero byte\n+     subf              subtract for final result\n+  */\n+\n+  rtx cmpb_diff = gen_reg_rtx (word_mode);\n+  rtx cmpb_zero = gen_reg_rtx (word_mode);\n+  rtx rot_amt = gen_reg_rtx (word_mode);\n+  rtx zero_reg = gen_reg_rtx (word_mode);\n+\n+  rtx rot1_1 = gen_reg_rtx(word_mode);\n+  rtx rot1_2 = gen_reg_rtx(word_mode);\n+  rtx rot2_1 = gen_reg_rtx(word_mode);\n+  rtx rot2_2 = gen_reg_rtx(word_mode);\n+\n+  if (word_mode == SImode)\n+    {\n+      emit_insn (gen_cmpbsi3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2));\n+      emit_insn (gen_movsi (zero_reg, GEN_INT(0)));\n+      emit_insn (gen_cmpbsi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n+      emit_insn (gen_one_cmplsi2 (cmpb_diff,cmpb_diff));\n+      emit_insn (gen_iorsi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n+      emit_insn (gen_clzsi2 (rot_amt, cmpb_diff));\n+      emit_insn (gen_addsi3 (rot_amt, rot_amt, GEN_INT (8)));\n+      emit_insn (gen_rotlsi3 (rot1_1, tmp_reg_src1,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_andsi3_mask (rot1_2, rot1_1, GEN_INT(0xff)));\n+      emit_insn (gen_rotlsi3 (rot2_1, tmp_reg_src2,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_andsi3_mask (rot2_2, rot2_1, GEN_INT(0xff)));\n+      emit_insn (gen_subsi3 (result_reg, rot1_2, rot2_2));\n+    }\n+  else\n+    {\n+      emit_insn (gen_cmpbdi3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2));\n+      emit_insn (gen_movdi (zero_reg, GEN_INT(0)));\n+      emit_insn (gen_cmpbdi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n+      emit_insn (gen_one_cmpldi2 (cmpb_diff,cmpb_diff));\n+      emit_insn (gen_iordi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n+      emit_insn (gen_clzdi2 (rot_amt, cmpb_diff));\n+      emit_insn (gen_adddi3 (rot_amt, rot_amt, GEN_INT (8)));\n+      emit_insn (gen_rotldi3 (rot1_1, tmp_reg_src1,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_anddi3_mask (rot1_2, rot1_1, GEN_INT(0xff)));\n+      emit_insn (gen_rotldi3 (rot2_1, tmp_reg_src2,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_anddi3_mask (rot2_2, rot2_1, GEN_INT(0xff)));\n+      emit_insn (gen_subdi3 (result_reg, rot1_2, rot2_2));\n+    }\n+\n+  emit_label (final_move_label);\n+  emit_insn (gen_movsi (target,\n+\t\t\tgen_lowpart (SImode, result_reg)));\n+  emit_label (final_label);\n+  return true;\n+}\n+\n /* Expand a block move operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code.\n \n@@ -32852,7 +33231,7 @@ power9_sched_reorder2 (rtx_insn **ready, int lastpos)\n \n \t     3  : 2 vector insns and a vector load have been issued and another\n \t\t  vector load has been found and moved to the end of the ready\n-\t\t  list.\t */\n+\t\t  list.  */\n       if (type == TYPE_VECLOAD)\n \t{\n \t  /* Issued a vecload.  */"}, {"sha": "abd2ce835f41efeef7070eca020e606b65303146", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "patch": "@@ -117,6 +117,7 @@\n    UNSPEC_BPERM\n    UNSPEC_COPYSIGN\n    UNSPEC_PARITY\n+   UNSPEC_CMPB\n    UNSPEC_FCTIW\n    UNSPEC_FCTID\n    UNSPEC_LFIWAX\n@@ -2316,6 +2317,13 @@\n   \"prty<wd> %0,%1\"\n   [(set_attr \"type\" \"popcnt\")])\n \n+(define_insn \"cmpb<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:GPR [(match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")] UNSPEC_CMPB))]\n+  \"TARGET_CMPB\"\n+  \"cmpb %0,%1,%2\"\n+  [(set_attr \"type\" \"cmp\")])\n \n ;; Since the hardware zeros the upper part of the register, save generating the\n ;; AND immediate if we are converting to unsigned\n@@ -8844,7 +8852,28 @@\n     FAIL;\n }\")\n \n-;; String/block compare insn.\n+;; String compare N insn.\n+;; Argument 0 is the target (result)\n+;; Argument 1 is the destination\n+;; Argument 2 is the source\n+;; Argument 3 is the length\n+;; Argument 4 is the alignment\n+\n+(define_expand \"cmpstrnsi\"\n+  [(parallel [(set (match_operand:SI 0)\n+               (compare:SI (match_operand:BLK 1)\n+                           (match_operand:BLK 2)))\n+\t      (use (match_operand:SI 3))\n+\t      (use (match_operand:SI 4))])]\n+  \"TARGET_CMPB && (BYTES_BIG_ENDIAN || TARGET_LDBRX)\"\n+{\n+  if (expand_strn_compare (operands))\n+    DONE;\n+  else\t\n+    FAIL;\n+})\n+\n+;; Block compare insn.\n ;; Argument 0 is the target (result)\n ;; Argument 1 is the destination\n ;; Argument 2 is the source"}, {"sha": "15cc73aa36761a273a01a112f81acdea9bc6965e", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c2033eff925ac2577ac6f30578bc6a8498c2e9/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=e9c2033eff925ac2577ac6f30578bc6a8498c2e9", "patch": "@@ -337,6 +337,10 @@ mblock-compare-inline-limit=\n Target Report Var(rs6000_block_compare_inline_limit) Init(5) RejectNegative Joined UInteger Save\n Specify the maximum number pairs of load instructions that should be generated inline for the compare.  If the number needed exceeds the limit, a call to memcmp will be generated instead.\n \n+mstring-compare-inline-limit=\n+Target Report Var(rs6000_string_compare_inline_limit) Init(8) RejectNegative Joined UInteger Save\n+Specify the maximum number pairs of load instructions that should be generated inline for the compare.  If the number needed exceeds the limit, a call to strncmp will be generated instead.\n+\n misel\n Target Report Mask(ISEL) Var(rs6000_isa_flags)\n Generate isel instructions."}]}