{"sha": "fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVkNWFlMTEzYzBjZmRiNzUyNWNiZGQ4YjBjMThlMjZmNTEyZTljNg==", "commit": {"author": {"name": "Doug Kwan", "email": "dougkwan@google.com", "date": "2009-04-20T13:27:15Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-04-20T13:27:15Z"}, "message": "cgraph.h (cgraph_node_ptr): New type for vector functions.\n\n\n\t* cgraph.h (cgraph_node_ptr): New type for vector functions.\n\t(struct cgraph_node_set_def): New type.\n\t(cgraph_node_set) New type. Also declare vector functions.\n\t(struct cgraph_node_set_element_def): New type.\n\t(cgraph_node_set_element): Ditto.\n\t(cgraph_node_set_iterator): New iterator type.\n\t(cgraph_node_set_new, cgraph_node_set_find, cgraph_node_set_add,\n\tcgraph_node_set_remove, dump_cgraph_node_set,\n\tdebug_cgraph_node_set): New prototypes.\n\t(csi_end_p, csi_next, csi_node, csi_start, cgraph_node_in_set_p,\n\tcgraph_node_set_size): New inlines.\n\t* tree-pass.h (struct cgraph_node_set_def): New decl to avoid\n\tincluding cgraph.h.\n\t(struct ipa_opt_pass): Add struct cgraph_node_set_def\n\targument to function 'write_summary'.\n\t* ipa.c: Include ggc.h.\n\t(hash_cgraph_node_set_element,\n\teq_cgraph_node_set_element, cgraph_node_set_new,\n\tcgraph_node_set_add, cgraph_node_set_remove,\n\tcgraph_node_set_find, dump_cgraph_node_set,\n\tdebug_cgraph_node_set): New functions.\n\t* Makefile.in (ipa.o): Add dependency on GGC_H.\n\nFrom-SVN: r146418", "tree": {"sha": "531b84989d400e0b1df5557da8d196ae11d78ae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/531b84989d400e0b1df5557da8d196ae11d78ae6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/comments", "author": {"login": "dougkwan", "id": 1399231, "node_id": "MDQ6VXNlcjEzOTkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1399231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dougkwan", "html_url": "https://github.com/dougkwan", "followers_url": "https://api.github.com/users/dougkwan/followers", "following_url": "https://api.github.com/users/dougkwan/following{/other_user}", "gists_url": "https://api.github.com/users/dougkwan/gists{/gist_id}", "starred_url": "https://api.github.com/users/dougkwan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dougkwan/subscriptions", "organizations_url": "https://api.github.com/users/dougkwan/orgs", "repos_url": "https://api.github.com/users/dougkwan/repos", "events_url": "https://api.github.com/users/dougkwan/events{/privacy}", "received_events_url": "https://api.github.com/users/dougkwan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97a8fb1624e2d4bca12d4421484dc953c6ea350d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a8fb1624e2d4bca12d4421484dc953c6ea350d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a8fb1624e2d4bca12d4421484dc953c6ea350d"}], "stats": {"total": 289, "additions": 286, "deletions": 3}, "files": [{"sha": "a25d3b0c7c4303784b924166ca1faa60c3ea8ab7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "patch": "@@ -1,3 +1,28 @@\n+2009-04-20  Doug Kwan  <dougkwan@google.com>\n+\n+\t* cgraph.h (cgraph_node_ptr): New type for vector functions.\n+\t(struct cgraph_node_set_def): New type.\n+\t(cgraph_node_set) New type. Also declare vector functions.\n+\t(struct cgraph_node_set_element_def): New type.\n+\t(cgraph_node_set_element): Ditto.\n+\t(cgraph_node_set_iterator): New iterator type.\n+\t(cgraph_node_set_new, cgraph_node_set_find, cgraph_node_set_add,\n+\tcgraph_node_set_remove, dump_cgraph_node_set,\n+\tdebug_cgraph_node_set): New prototypes.\n+\t(csi_end_p, csi_next, csi_node, csi_start, cgraph_node_in_set_p,\n+\tcgraph_node_set_size): New inlines.\n+\t* tree-pass.h (struct cgraph_node_set_def): New decl to avoid\n+\tincluding cgraph.h.\n+\t(struct ipa_opt_pass): Add struct cgraph_node_set_def\n+\targument to function 'write_summary'.\n+\t* ipa.c: Include ggc.h.\n+\t(hash_cgraph_node_set_element,\n+\teq_cgraph_node_set_element, cgraph_node_set_new,\n+\tcgraph_node_set_add, cgraph_node_set_remove,\n+\tcgraph_node_set_find, dump_cgraph_node_set,\n+\tdebug_cgraph_node_set): New functions.\n+\t* Makefile.in (ipa.o): Add dependency on GGC_H.\n+\n 2009-04-20  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/39675"}, {"sha": "32ea68eb4451a856141ae624d574d0ece70a4cea", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "patch": "@@ -2624,7 +2624,7 @@ varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) gt-varpool.h\n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n-   $(TREE_PASS_H) $(TIMEVAR_H)\n+   $(TREE_PASS_H) $(TIMEVAR_H) $(GGC_H)\n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\"}, {"sha": "984d727728b31965b8b962d60865b63fd4695da0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "patch": "@@ -189,6 +189,45 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   tree inline_decl;\n };\n \n+typedef struct cgraph_node *cgraph_node_ptr;\n+\n+DEF_VEC_P(cgraph_node_ptr);\n+DEF_VEC_ALLOC_P(cgraph_node_ptr,heap);\n+DEF_VEC_ALLOC_P(cgraph_node_ptr,gc);\n+\n+/* A cgraph node set is a collection of cgraph nodes.  A cgraph node\n+   can appear in multiple sets.  */\n+struct cgraph_node_set_def GTY(())\n+{\n+  htab_t GTY((param_is (struct cgraph_node_set_element_def))) hashtab;\n+  VEC(cgraph_node_ptr, gc) *nodes;\n+  PTR GTY ((skip)) aux;\n+};\n+\n+typedef struct cgraph_node_set_def *cgraph_node_set;\n+\n+DEF_VEC_P(cgraph_node_set);\n+DEF_VEC_ALLOC_P(cgraph_node_set,gc);\n+DEF_VEC_ALLOC_P(cgraph_node_set,heap);\n+\n+/* A cgraph node set element contains an index in the vector of nodes in\n+   the set.  */\n+struct cgraph_node_set_element_def GTY(())\n+{\n+  struct cgraph_node *node;\n+  HOST_WIDE_INT index;\n+};\n+\n+typedef struct cgraph_node_set_element_def *cgraph_node_set_element;\n+typedef const struct cgraph_node_set_element_def *const_cgraph_node_set_element;\n+\n+/* Iterator structure for cgraph node sets.  */\n+typedef struct\n+{\n+  cgraph_node_set set;\n+  unsigned index;\n+} cgraph_node_set_iterator;\n+\n #define DEFCIFCODE(code, string)\tCIF_ ## code,\n /* Reasons for inlining failures.  */\n typedef enum {\n@@ -397,11 +436,19 @@ int compute_call_stmt_bb_frequency (basic_block bb);\n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);\n int cgraph_postorder (struct cgraph_node **);\n+cgraph_node_set cgraph_node_set_new (void);\n+cgraph_node_set_iterator cgraph_node_set_find (cgraph_node_set,\n+\t\t\t\t\t       struct cgraph_node *);\n+void cgraph_node_set_add (cgraph_node_set, struct cgraph_node *);\n+void cgraph_node_set_remove (cgraph_node_set, struct cgraph_node *);\n+void dump_cgraph_node_set (FILE *, cgraph_node_set);\n+void debug_cgraph_node_set (cgraph_node_set);\n+\n \n+/* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n \n /* In varpool.c  */\n-\n extern GTY(()) struct varpool_node *varpool_nodes_queue;\n extern GTY(()) struct varpool_node *varpool_nodes;\n \n@@ -466,4 +513,54 @@ unsigned int compute_inline_parameters (struct cgraph_node *);\n /* Create a new static variable of type TYPE.  */\n tree add_new_static_var (tree type);\n \n+\n+/* Return true if iterator CSI points to nothing.  */\n+static inline bool\n+csi_end_p (cgraph_node_set_iterator csi)\n+{\n+  return csi.index >= VEC_length (cgraph_node_ptr, csi.set->nodes);\n+}\n+\n+/* Advance iterator CSI.  */\n+static inline void\n+csi_next (cgraph_node_set_iterator *csi)\n+{\n+  csi->index++;\n+}\n+\n+/* Return the node pointed to by CSI.  */\n+static inline struct cgraph_node *\n+csi_node (cgraph_node_set_iterator csi)\n+{\n+  return VEC_index (cgraph_node_ptr, csi.set->nodes, csi.index);\n+}\n+\n+/* Return an iterator to the first node in SET.  */\n+static inline cgraph_node_set_iterator\n+csi_start (cgraph_node_set set)\n+{\n+  cgraph_node_set_iterator csi;\n+\n+  csi.set = set;\n+  csi.index = 0;\n+  return csi;\n+}\n+\n+/* Return true if SET contains NODE.  */\n+static inline bool\n+cgraph_node_in_set_p (struct cgraph_node *node, cgraph_node_set set)\n+{\n+  cgraph_node_set_iterator csi;\n+  csi = cgraph_node_set_find (set, node);\n+  return !csi_end_p (csi);\n+}\n+\n+/* Return number of nodes in SET.  */\n+static inline size_t\n+cgraph_node_set_size (cgraph_node_set set)\n+{\n+  return htab_elements (set->hashtab);\n+}\n+\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "b486b93d34cd5d04edb9cb1a4784137860043c75", "filename": "gcc/ipa.c", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n #include \"timevar.h\"\n+#include \"ggc.h\"\n \n /* Fill array order with all nodes with output flag set in the reverse\n    topological order.  */\n@@ -285,3 +286,162 @@ struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility =\n   TODO_remove_functions | TODO_dump_cgraph/* todo_flags_finish */\n  }\n };\n+\n+\n+/* Hash a cgraph node set element.  */\n+\n+static hashval_t\n+hash_cgraph_node_set_element (const void *p)\n+{\n+  const_cgraph_node_set_element element = (const_cgraph_node_set_element) p;\n+  return htab_hash_pointer (element->node);\n+}\n+\n+/* Compare two cgraph node set elements.  */\n+\n+static int\n+eq_cgraph_node_set_element (const void *p1, const void *p2)\n+{\n+  const_cgraph_node_set_element e1 = (const_cgraph_node_set_element) p1;\n+  const_cgraph_node_set_element e2 = (const_cgraph_node_set_element) p2;\n+\n+  return e1->node == e2->node;\n+}\n+\n+/* Create a new cgraph node set.  */\n+\n+cgraph_node_set\n+cgraph_node_set_new (void)\n+{\n+  cgraph_node_set new_node_set;\n+\n+  new_node_set = GGC_NEW (struct cgraph_node_set_def);\n+  new_node_set->hashtab = htab_create_ggc (10,\n+\t\t\t\t\t   hash_cgraph_node_set_element,\n+\t\t\t\t\t   eq_cgraph_node_set_element,\n+\t\t\t\t\t   NULL);\n+  new_node_set->nodes = NULL;\n+  return new_node_set;\n+}\n+\n+/* Add cgraph_node NODE to cgraph_node_set SET.  */\n+\n+void\n+cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n+{\n+  void **slot;\n+  cgraph_node_set_element element;\n+  struct cgraph_node_set_element_def dummy;\n+\n+  dummy.node = node;\n+  slot = htab_find_slot (set->hashtab, &dummy, INSERT);\n+\n+  if (*slot != HTAB_EMPTY_ENTRY)\n+    {\n+      element = (cgraph_node_set_element) *slot;\n+      gcc_assert (node == element->node\n+\t\t  && (VEC_index (cgraph_node_ptr, set->nodes, element->index)\n+\t\t      == node));\n+      return;\n+    }\n+\n+  /* Insert node into hash table.  */\n+  element =\n+    (cgraph_node_set_element) GGC_NEW (struct cgraph_node_set_element_def);\n+  element->node = node;\n+  element->index = VEC_length (cgraph_node_ptr, set->nodes);\n+  *slot = element;\n+\n+  /* Insert into node vector.  */\n+  VEC_safe_push (cgraph_node_ptr, gc, set->nodes, node);\n+}\n+\n+/* Remove cgraph_node NODE from cgraph_node_set SET.  */\n+\n+void\n+cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n+{\n+  void **slot, **last_slot;\n+  cgraph_node_set_element element, last_element;\n+  struct cgraph_node *last_node;\n+  struct cgraph_node_set_element_def dummy;\n+\n+  dummy.node = node;\n+  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n+  if (slot == NULL)\n+    return;\n+\n+  element = (cgraph_node_set_element) *slot;\n+  gcc_assert (VEC_index (cgraph_node_ptr, set->nodes, element->index)\n+\t      == node);\n+\n+  /* Remove from vector. We do this by swapping node with the last element\n+     of the vector.  */\n+  last_node = VEC_pop (cgraph_node_ptr, set->nodes);\n+  if (last_node != node)\n+    {\n+      dummy.node = last_node;\n+      last_slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n+      last_element = (cgraph_node_set_element) *last_slot;\n+      gcc_assert (last_element);\n+\n+      /* Move the last element to the original spot of NODE.  */\n+      last_element->index = element->index;\n+      VEC_replace (cgraph_node_ptr, set->nodes, last_element->index,\n+\t\t   last_node);\n+    }\n+  \n+  /* Remove element from hash table.  */\n+  htab_clear_slot (set->hashtab, slot);\n+  ggc_free (element);\n+}\n+\n+/* Find NODE in SET and return an iterator to it if found.  A null iterator\n+   is returned if NODE is not in SET.  */\n+\n+cgraph_node_set_iterator\n+cgraph_node_set_find (cgraph_node_set set, struct cgraph_node *node)\n+{\n+  void **slot;\n+  struct cgraph_node_set_element_def dummy;\n+  cgraph_node_set_element element;\n+  cgraph_node_set_iterator csi;\n+\n+  dummy.node = node;\n+  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n+  if (slot == NULL)\n+    csi.index = (unsigned) ~0;\n+  else\n+    {\n+      element = (cgraph_node_set_element) *slot;\n+      gcc_assert (VEC_index (cgraph_node_ptr, set->nodes, element->index)\n+\t\t  == node);\n+      csi.index = element->index;\n+    }\n+  csi.set = set;\n+\n+  return csi;\n+}\n+\n+/* Dump content of SET to file F.  */\n+\n+void\n+dump_cgraph_node_set (FILE *f, cgraph_node_set set)\n+{\n+  cgraph_node_set_iterator iter;\n+\n+  for (iter = csi_start (set); !csi_end_p (iter); csi_next (&iter))\n+    {\n+      struct cgraph_node *node = csi_node (iter);\n+      dump_cgraph_node (f, node);\n+    }\n+}\n+\n+/* Dump content of SET to stderr.  */\n+\n+void\n+debug_cgraph_node_set (cgraph_node_set set)\n+{\n+  dump_cgraph_node_set (stderr, set);\n+}\n+"}, {"sha": "c74ed1b654c88b373f62817fc511f7cca97113df", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=fed5ae113c0cfdb7525cbdd8b0c18e26f512e9c6", "patch": "@@ -155,6 +155,7 @@ struct rtl_opt_pass\n \n struct varpool_node;\n struct cgraph_node;\n+struct cgraph_node_set_def;\n \n /* Description of IPA pass with generate summary, write, execute, read and\n    transform stages.  */\n@@ -167,7 +168,7 @@ struct ipa_opt_pass\n   void (*generate_summary) (void);\n \n   /* This hook is used to serialize IPA summaries on disk.  */\n-  void (*write_summary) (void);\n+  void (*write_summary) (struct cgraph_node_set_def *);\n \n   /* For most ipa passes, the information can only be deserialized in\n      one chunk.  However, function bodies are read function at a time"}]}