{"sha": "bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlY2QzMzQzYzcxYjFlZGNlNWY3MDY5ZjYzOTc5ZDI2ZTFiOWY1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-04T02:52:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-04T02:52:36Z"}, "message": "re PR tree-optimization/16341 (BOOT_CFLAGS='-O2 -fno-inline' causes a comparision failure)\n\n        PR tree-optimization/16341\n        * tree-sra.c (sra_walk_function): Increment to next stmt before\n        processing the current stmt.\n        (sra_insert_after): Always use BSI_SAME_STMT.\n\nFrom-SVN: r84070", "tree": {"sha": "bd19bf2cb69c4a29adc78e508ba6a33b8d236503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd19bf2cb69c4a29adc78e508ba6a33b8d236503"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/comments", "author": null, "committer": null, "parents": [{"sha": "ca8afd0bf055d7b8d0f27bab76cfa62cb12d6a3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8afd0bf055d7b8d0f27bab76cfa62cb12d6a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8afd0bf055d7b8d0f27bab76cfa62cb12d6a3a"}], "stats": {"total": 163, "additions": 160, "deletions": 3}, "files": [{"sha": "4bf082f1a700e86e207ff68b2933c8b26a7bcda8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "patch": "@@ -1,3 +1,10 @@\n+2004-07-03  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-optimization/16341\n+\t* tree-sra.c (sra_walk_function): Increment to next stmt before\n+\tprocessing the current stmt.\n+\t(sra_insert_after): Always use BSI_SAME_STMT.\n+\n 2004-07-03  Richard Henderson  <rth@redhat.com>\n \n \t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Don't fold"}, {"sha": "eba358d35ae31d7489e7fbf749b9690c050491b0", "filename": "gcc/testsuite/gcc.c-torture/execute/20040703-1.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040703-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040703-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040703-1.c?ref=bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "patch": "@@ -0,0 +1,147 @@\n+/* PR 16341 */\n+\n+#define PART_PRECISION (sizeof (cpp_num_part) * 8)\n+\n+typedef unsigned int cpp_num_part;\n+typedef struct cpp_num cpp_num;\n+struct cpp_num\n+{\n+   cpp_num_part high;\n+   cpp_num_part low;\n+   int unsignedp;  /* True if value should be treated as unsigned.  */\n+   int overflow;   /* True if the most recent calculation overflowed.  */\n+};\n+\n+static  int\n+num_positive (cpp_num num, unsigned int precision)\n+{\n+   if (precision > PART_PRECISION)\n+     {\n+       precision -= PART_PRECISION;\n+       return (num.high & (cpp_num_part) 1 << (precision - 1)) == 0;\n+     }\n+\n+   return (num.low & (cpp_num_part) 1 << (precision - 1)) == 0;\n+}\n+\n+static cpp_num\n+num_trim (cpp_num num, unsigned int precision)\n+{\n+   if (precision > PART_PRECISION)\n+     {\n+       precision -= PART_PRECISION;\n+       if (precision < PART_PRECISION)\n+         num.high &= ((cpp_num_part) 1 << precision) - 1;\n+     }\n+   else\n+     {\n+       if (precision < PART_PRECISION)\n+         num.low &= ((cpp_num_part) 1 << precision) - 1;\n+       num.high = 0;\n+     }\n+\n+   return num;\n+}\n+\n+/* Shift NUM, of width PRECISION, right by N bits.  */\n+static cpp_num\n+num_rshift (cpp_num num, unsigned int precision, unsigned int n)\n+{\n+   cpp_num_part sign_mask;\n+   int x = num_positive (num, precision);\n+\n+   if (num.unsignedp || x)\n+     sign_mask = 0;\n+   else\n+     sign_mask = ~(cpp_num_part) 0;\n+\n+   if (n >= precision)\n+     num.high = num.low = sign_mask;\n+   else\n+     {\n+       /* Sign-extend.  */\n+       if (precision < PART_PRECISION)\n+         num.high = sign_mask, num.low |= sign_mask << precision;\n+       else if (precision < 2 * PART_PRECISION)\n+         num.high |= sign_mask << (precision - PART_PRECISION);\n+\n+       if (n >= PART_PRECISION)\n+         {\n+           n -= PART_PRECISION;\n+           num.low = num.high;\n+           num.high = sign_mask;\n+         }\n+\n+       if (n)\n+         {\n+           num.low = (num.low >> n) | (num.high << (PART_PRECISION - n));\n+           num.high = (num.high >> n) | (sign_mask << (PART_PRECISION - n));\n+         }\n+     }\n+\n+   num = num_trim (num, precision);\n+   num.overflow = 0;\n+   return num;\n+}\n+                              #define num_zerop(num) ((num.low | num.high) == 0)\n+#define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)\n+\n+cpp_num\n+num_lshift (cpp_num num, unsigned int precision, unsigned int n)\n+{\n+   if (n >= precision)\n+     {\n+       num.overflow = !num.unsignedp && !num_zerop (num);\n+       num.high = num.low = 0;\n+     }\n+   else\n+     {\n+       cpp_num orig;\n+       unsigned int m = n;\n+\n+       orig = num;\n+       if (m >= PART_PRECISION)\n+         {\n+           m -= PART_PRECISION;\n+           num.high = num.low;\n+           num.low = 0;\n+         }\n+       if (m)\n+         {\n+           num.high = (num.high << m) | (num.low >> (PART_PRECISION - m));\n+           num.low <<= m;\n+         }\n+       num = num_trim (num, precision);\n+\n+       if (num.unsignedp)\n+         num.overflow = 0;\n+       else\n+         {\n+           cpp_num maybe_orig = num_rshift (num, precision, n);\n+           num.overflow = !num_eq (orig, maybe_orig);\n+         }\n+     }\n+\n+   return num;\n+}\n+\n+unsigned int precision = 64;\n+unsigned int n = 16;\n+\n+cpp_num num = { 0, 3, 0, 0 };\n+\n+int main()\n+{\n+   cpp_num res = num_lshift (num, 64, n);\n+\n+   if (res.low != 0x30000)\n+     abort ();\n+\n+   if (res.high != 0)\n+     abort ();\n+\n+   if (res.overflow != 0)\n+     abort ();\n+\n+   exit (0);\n+}"}, {"sha": "f315ad90b11ac8057bea0a86e59ce830b8989e28", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdecd3343c71b1edce5f7069f63979d26e1b9f5e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=bdecd3343c71b1edce5f7069f63979d26e1b9f5e", "patch": "@@ -828,20 +828,23 @@ static void\n sra_walk_function (const struct sra_walk_fns *fns)\n {\n   basic_block bb;\n-  block_stmt_iterator si;\n+  block_stmt_iterator si, ni;\n \n   /* ??? Phase 4 could derive some benefit to walking the function in\n      dominator tree order.  */\n \n   FOR_EACH_BB (bb)\n-    for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    for (si = bsi_start (bb); !bsi_end_p (si); si = ni)\n       {\n \ttree stmt, t;\n \tstmt_ann_t ann;\n \n \tstmt = bsi_stmt (si);\n \tann = stmt_ann (stmt);\n \n+\tni = si;\n+\tbsi_next (&ni);\n+\n \t/* If the statement has no virtual operands, then it doesn't\n \t   make any structure references that we care about.  */\n \tif (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n@@ -1616,7 +1619,7 @@ sra_insert_after (block_stmt_iterator *bsi, tree list)\n   if (stmt_ends_bb_p (stmt))\n     insert_edge_copies (list, bsi->bb);\n   else\n-    bsi_insert_after (bsi, list, BSI_CONTINUE_LINKING);\n+    bsi_insert_after (bsi, list, BSI_SAME_STMT);\n }\n \n /* Similarly, but replace the statement at BSI.  */"}]}