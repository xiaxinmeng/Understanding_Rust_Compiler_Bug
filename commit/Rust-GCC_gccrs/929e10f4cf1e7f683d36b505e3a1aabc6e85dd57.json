{"sha": "929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI5ZTEwZjRjZjFlN2Y2ODNkMzZiNTA1ZTNhMWFhYmM2ZTg1ZGQ1Nw==", "commit": {"author": {"name": "Mike Stump", "email": "mikestump@comcast.net", "date": "2012-04-04T20:27:17Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2012-04-04T20:27:17Z"}, "message": "rtl.texi (const_double): Document as sign-extending.\n\n\t* doc/rtl.texi (const_double): Document as sign-extending.\n\t* expmed.c (expand_mult): Ensure we don't use shift\n\tincorrectly.\n\t* emit-rtl.c (immed_double_int_const): Refine to state the\n\tvalue is signed.\n\t* simplify-rtx.c (mode_signbit_p): Add a fixme for wider than\n\tCONST_DOUBLE integers.\n\t(simplify_const_unary_operation, UNSIGNED_FLOAT): Ensure no\n\tnegative values are converted.  Fix conversions bigger than\n\tHOST_BITS_PER_WIDE_INT.\n\t(simplify_binary_operation_1): Ensure we don't use shift\n\tincorrectly.\n\t(simplify_immed_subreg): Sign-extend CONST_DOUBLEs.\n\t* explow.c (plus_constant_mode): Add.\n\t(plus_constant): Implement with plus_constant_mode.\n\t* rtl.h (plus_constant_mode): Add.\n\nFrom-SVN: r186147", "tree": {"sha": "dbe6160ad6febabb7998df1b736a4d686b578623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbe6160ad6febabb7998df1b736a4d686b578623"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/comments", "author": null, "committer": null, "parents": [{"sha": "b059fba46902f67bf76c5e80da28b423778ced1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b059fba46902f67bf76c5e80da28b423778ced1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b059fba46902f67bf76c5e80da28b423778ced1f"}], "stats": {"total": 168, "additions": 108, "deletions": 60}, "files": [{"sha": "23c9435ba682240c124e82bc3b807af074e82b69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -1,3 +1,22 @@\n+2012-04-04  Mike Stump  <mikestump@comcast.net>\n+\n+\t* doc/rtl.texi (const_double): Document as sign-extending.\n+\t* expmed.c (expand_mult): Ensure we don't use shift\n+\tincorrectly.\n+\t* emit-rtl.c (immed_double_int_const): Refine to state the\n+\tvalue is signed.\n+\t* simplify-rtx.c (mode_signbit_p): Add a fixme for wider than\n+\tCONST_DOUBLE integers.\n+\t(simplify_const_unary_operation, UNSIGNED_FLOAT): Ensure no\n+\tnegative values are converted.  Fix conversions bigger than\n+\tHOST_BITS_PER_WIDE_INT.\n+\t(simplify_binary_operation_1): Ensure we don't use shift\n+\tincorrectly.\n+\t(simplify_immed_subreg): Sign-extend CONST_DOUBLEs.\n+\t* explow.c (plus_constant_mode): Add.\n+\t(plus_constant): Implement with plus_constant_mode.\n+\t* rtl.h (plus_constant_mode): Add.\n+\n 2012-04-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/52808"}, {"sha": "82eb216292780e5b5920596f18e94d5643e91973", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -1479,8 +1479,13 @@ This type of expression represents the integer value @var{i}.  @var{i}\n is customarily accessed with the macro @code{INTVAL} as in\n @code{INTVAL (@var{exp})}, which is equivalent to @code{XWINT (@var{exp}, 0)}.\n \n-Constants generated for modes with fewer bits than @code{HOST_WIDE_INT}\n-must be sign extended to full width (e.g., with @code{gen_int_mode}).\n+Constants generated for modes with fewer bits than in\n+@code{HOST_WIDE_INT} must be sign extended to full width (e.g., with\n+@code{gen_int_mode}).  For constants for modes with more bits than in\n+@code{HOST_WIDE_INT} the implied high order bits of that constant are\n+copies of the top bit.  Note however that values are neither\n+inherently signed nor inherently unsigned; where necessary, signedness\n+is determined by the rtl operation instead.\n \n @findex const0_rtx\n @findex const1_rtx\n@@ -1510,7 +1515,13 @@ Represents either a floating-point constant of mode @var{m} or an\n integer constant too large to fit into @code{HOST_BITS_PER_WIDE_INT}\n bits but small enough to fit within twice that number of bits (GCC\n does not provide a mechanism to represent even larger constants).  In\n-the latter case, @var{m} will be @code{VOIDmode}.\n+the latter case, @var{m} will be @code{VOIDmode}.  For integral values\n+constants for modes with more bits than twice the number in\n+@code{HOST_WIDE_INT} the implied high order bits of that constant are\n+copies of the top bit of @code{CONST_DOUBLE_HIGH}.  Note however that\n+integral values are neither inherently signed nor inherently unsigned;\n+where necessary, signedness is determined by the rtl operation\n+instead.\n \n @findex CONST_DOUBLE_LOW\n If @var{m} is @code{VOIDmode}, the bits of the value are stored in"}, {"sha": "8d7d4417d59c94952928d946fbb3385232adafeb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -517,8 +517,11 @@ immed_double_int_const (double_int i, enum machine_mode mode)\n \n /* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair\n    of ints: I0 is the low-order word and I1 is the high-order word.\n-   Do not use this routine for non-integer modes; convert to\n-   REAL_VALUE_TYPE and use CONST_DOUBLE_FROM_REAL_VALUE.  */\n+   For values that are larger than 2*HOST_BITS_PER_WIDE_INT, the\n+   implied upper bits are copies of the high bit of i1.  The value\n+   itself is neither signed nor unsigned.  Do not use this routine for\n+   non-integer modes; convert to REAL_VALUE_TYPE and use\n+   CONST_DOUBLE_FROM_REAL_VALUE.  */\n \n rtx\n immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n@@ -531,10 +534,9 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n \n      1) If GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT, then we use\n \tgen_int_mode.\n-     2) GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT, but the value of\n-\tthe integer fits into HOST_WIDE_INT anyway (i.e., i1 consists only\n-\tfrom copies of the sign bit, and sign of i0 and i1 are the same),  then\n-\twe return a CONST_INT for i0.\n+     2) If the value of the integer fits into HOST_WIDE_INT anyway\n+        (i.e., i1 consists only from copies of the sign bit, and sign\n+\tof i0 and i1 are the same), then we return a CONST_INT for i0.\n      3) Otherwise, we create a CONST_DOUBLE for i0 and i1.  */\n   if (mode != VOIDmode)\n     {\n@@ -546,8 +548,6 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n \n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \treturn gen_int_mode (i0, mode);\n-\n-      gcc_assert (GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT);\n     }\n \n   /* If this integer fits in one word, return a CONST_INT.  */"}, {"sha": "ff26dbf605c471281fe6c34fe96ab802b1f1b7e3", "filename": "gcc/explow.c", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -74,14 +74,20 @@ trunc_int_for_mode (HOST_WIDE_INT c, enum machine_mode mode)\n   return c;\n }\n \n-/* Return an rtx for the sum of X and the integer C.  */\n+/* Return an rtx for the sum of X and the integer C, given that X has\n+   mode MODE.  This routine should be used instead of plus_constant\n+   when they want to ensure that addition happens in a particular\n+   mode, which is necessary when X can be a VOIDmode CONST_INT or\n+   CONST_DOUBLE and the width of the constant is different from the\n+   width of the expression.  */\n+/* TODO: All callers of plus_constant should migrate to this routine,\n+   and once they do, we can assert that mode is not VOIDmode.  */\n \n rtx\n-plus_constant (rtx x, HOST_WIDE_INT c)\n+plus_constant_mode (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n {\n   RTX_CODE code;\n   rtx y;\n-  enum machine_mode mode;\n   rtx tem;\n   int all_constant = 0;\n \n@@ -91,24 +97,41 @@ plus_constant (rtx x, HOST_WIDE_INT c)\n  restart:\n \n   code = GET_CODE (x);\n-  mode = GET_MODE (x);\n   y = x;\n \n   switch (code)\n     {\n     case CONST_INT:\n+      if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  unsigned HOST_WIDE_INT l1 = INTVAL (x);\n+\t  HOST_WIDE_INT h1 = (l1 >> (HOST_BITS_PER_WIDE_INT - 1)) ? -1 : 0;\n+\t  unsigned HOST_WIDE_INT l2 = c;\n+\t  HOST_WIDE_INT h2 = c < 0 ? -1 : 0;\n+\t  unsigned HOST_WIDE_INT lv;\n+\t  HOST_WIDE_INT hv;\n+\n+\t  if (add_double_with_sign (l1, h1, l2, h2, &lv, &hv, false))\n+\t    gcc_unreachable ();\n+\n+\t  return immed_double_const (lv, hv, VOIDmode);\n+\t}\n+\n       return GEN_INT (INTVAL (x) + c);\n \n     case CONST_DOUBLE:\n       {\n \tunsigned HOST_WIDE_INT l1 = CONST_DOUBLE_LOW (x);\n \tHOST_WIDE_INT h1 = CONST_DOUBLE_HIGH (x);\n \tunsigned HOST_WIDE_INT l2 = c;\n-\tHOST_WIDE_INT h2 = c < 0 ? ~0 : 0;\n+\tHOST_WIDE_INT h2 = c < 0 ? -1 : 0;\n \tunsigned HOST_WIDE_INT lv;\n \tHOST_WIDE_INT hv;\n \n-\tadd_double (l1, h1, l2, h2, &lv, &hv);\n+\tif (add_double_with_sign (l1, h1, l2, h2, &lv, &hv, false))\n+\t  /* Sorry, we have no way to represent overflows this wide.\n+\t     To fix, add constant support wider than CONST_DOUBLE.  */\n+\t  gcc_assert (GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT);\n \n \treturn immed_double_const (lv, hv, VOIDmode);\n       }\n@@ -120,10 +143,8 @@ plus_constant (rtx x, HOST_WIDE_INT c)\n       if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n \t{\n-\t  tem\n-\t    = force_const_mem (GET_MODE (x),\n-\t\t\t       plus_constant (get_pool_constant (XEXP (x, 0)),\n-\t\t\t\t\t      c));\n+\t  tem = plus_constant_mode (mode, get_pool_constant (XEXP (x, 0)), c);\n+\t  tem = force_const_mem (GET_MODE (x), tem);\n \t  if (memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t    return tem;\n \t}\n@@ -142,31 +163,17 @@ plus_constant (rtx x, HOST_WIDE_INT c)\n       break;\n \n     case PLUS:\n-      /* The interesting case is adding the integer to a sum.\n-\t Look for constant term in the sum and combine\n-\t with C.  For an integer constant term, we make a combined\n-\t integer.  For a constant term that is not an explicit integer,\n-\t we cannot really combine, but group them together anyway.\n-\n-\t Restart or use a recursive call in case the remaining operand is\n-\t something that we handle specially, such as a SYMBOL_REF.\n+      /* The interesting case is adding the integer to a sum.  Look\n+\t for constant term in the sum and combine with C.  For an\n+\t integer constant term or a constant term that is not an\n+\t explicit integer, we combine or group them together anyway.\n \n \t We may not immediately return from the recursive call here, lest\n \t all_constant gets lost.  */\n \n-      if (CONST_INT_P (XEXP (x, 1)))\n+      if (CONSTANT_P (XEXP (x, 1)))\n \t{\n-\t  c += INTVAL (XEXP (x, 1));\n-\n-\t  if (GET_MODE (x) != VOIDmode)\n-\t    c = trunc_int_for_mode (c, GET_MODE (x));\n-\n-\t  x = XEXP (x, 0);\n-\t  goto restart;\n-\t}\n-      else if (CONSTANT_P (XEXP (x, 1)))\n-\t{\n-\t  x = gen_rtx_PLUS (mode, XEXP (x, 0), plus_constant (XEXP (x, 1), c));\n+\t  x = gen_rtx_PLUS (mode, XEXP (x, 0), plus_constant_mode (mode, XEXP (x, 1), c));\n \t  c = 0;\n \t}\n       else if (find_constant_term_loc (&y))\n@@ -176,7 +183,7 @@ plus_constant (rtx x, HOST_WIDE_INT c)\n \t  rtx copy = copy_rtx (x);\n \t  rtx *const_loc = find_constant_term_loc (&copy);\n \n-\t  *const_loc = plus_constant (*const_loc, c);\n+\t  *const_loc = plus_constant_mode (mode, *const_loc, c);\n \t  x = copy;\n \t  c = 0;\n \t}\n@@ -196,6 +203,14 @@ plus_constant (rtx x, HOST_WIDE_INT c)\n   else\n     return x;\n }\n+\n+/* Return an rtx for the sum of X and the integer C.  */\n+\n+rtx\n+plus_constant (rtx x, HOST_WIDE_INT c)\n+{\n+  return plus_constant_mode (GET_MODE (x), x, c);\n+}\n \f\n /* If X is a sum, return a new sum like X but lacking any constant terms.\n    Add all the removed constant terms into *CONSTPTR."}, {"sha": "aa24fbf630bf1e6371ecdc353ec8cd608cd0bc0a", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -3139,8 +3139,10 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t    {\n \t      int shift = floor_log2 (CONST_DOUBLE_HIGH (op1))\n \t\t\t  + HOST_BITS_PER_WIDE_INT;\n-\t      return expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t   shift, target, unsignedp);\n+\t      if (shift < 2 * HOST_BITS_PER_WIDE_INT - 1\n+\t\t  || GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT)\n+\t\treturn expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t     shift, target, unsignedp);\n \t    }\n \t}\n "}, {"sha": "915ef136538f3552eb98658f1729a154ed7e95da", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -1644,6 +1644,7 @@ extern int ceil_log2 (unsigned HOST_WIDE_INT);\n /* In explow.c */\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\n extern rtx plus_constant (rtx, HOST_WIDE_INT);\n+extern rtx plus_constant_mode (enum machine_mode, rtx, HOST_WIDE_INT);\n \n /* In rtl.c */\n extern rtx rtx_alloc_stat (RTX_CODE MEM_STAT_DECL);"}, {"sha": "1d82a375673a1c17e393a822a188b29d8f6fa2fe", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929e10f4cf1e7f683d36b505e3a1aabc6e85dd57/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=929e10f4cf1e7f683d36b505e3a1aabc6e85dd57", "patch": "@@ -97,6 +97,7 @@ mode_signbit_p (enum machine_mode mode, const_rtx x)\n       width -= HOST_BITS_PER_WIDE_INT;\n     }\n   else\n+    /* FIXME: We don't yet have a representation for wider modes.  */\n     return false;\n \n   if (width < HOST_BITS_PER_WIDE_INT)\n@@ -1355,16 +1356,11 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n       else\n \tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n \n-      if (op_mode == VOIDmode)\n-\t{\n-\t  /* We don't know how to interpret negative-looking numbers in\n-\t     this case, so don't try to fold those.  */\n-\t  if (hv < 0)\n-\t    return 0;\n-\t}\n-      else if (GET_MODE_PRECISION (op_mode) >= HOST_BITS_PER_WIDE_INT * 2)\n-\t;\n-      else\n+      if (op_mode == VOIDmode\n+\t  || GET_MODE_PRECISION (op_mode) > 2 * HOST_BITS_PER_WIDE_INT)\n+\t/* We should never get a negative number.  */\n+\tgcc_assert (hv >= 0);\n+      else if (GET_MODE_PRECISION (op_mode) <= HOST_BITS_PER_WIDE_INT)\n \thv = 0, lv &= GET_MODE_MASK (op_mode);\n \n       REAL_VALUE_FROM_UNSIGNED_INT (d, lv, hv, mode);\n@@ -1718,7 +1714,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n   else if (GET_CODE (op) == CONST_DOUBLE\n \t   && SCALAR_FLOAT_MODE_P (GET_MODE (op))\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && width <= 2*HOST_BITS_PER_WIDE_INT && width > 0)\n+\t   && width <= 2 * HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n       /* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX\n \t operators are intentionally left unspecified (to ease implementation\n@@ -1783,7 +1779,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    return const0_rtx;\n \n \t  /* Test against the unsigned upper bound.  */\n-\t  if (width == 2*HOST_BITS_PER_WIDE_INT)\n+\t  if (width == 2 * HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      th = -1;\n \t      tl = -1;\n@@ -2380,7 +2376,9 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      || GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_INT)\n \t  && GET_MODE (op0) == mode\n \t  && CONST_DOUBLE_LOW (trueop1) == 0\n-\t  && (val = exact_log2 (CONST_DOUBLE_HIGH (trueop1))) >= 0)\n+\t  && (val = exact_log2 (CONST_DOUBLE_HIGH (trueop1))) >= 0\n+\t  && (val < 2 * HOST_BITS_PER_WIDE_INT - 1\n+\t      || GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT))\n \treturn simplify_gen_binary (ASHIFT, mode, op0,\n \t\t\t\t    GEN_INT (val + HOST_BITS_PER_WIDE_INT));\n \n@@ -5189,6 +5187,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \tcase CONST_DOUBLE:\n \t  if (GET_MODE (el) == VOIDmode)\n \t    {\n+\t      unsigned char extend = 0;\n \t      /* If this triggers, someone should have generated a\n \t\t CONST_INT instead.  */\n \t      gcc_assert (elem_bitsize > HOST_BITS_PER_WIDE_INT);\n@@ -5201,10 +5200,11 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t\t    = CONST_DOUBLE_HIGH (el) >> (i - HOST_BITS_PER_WIDE_INT);\n \t\t  i += value_bit;\n \t\t}\n-\t      /* It shouldn't matter what's done here, so fill it with\n-\t\t zero.  */\n+\n+\t      if (CONST_DOUBLE_HIGH (el) >> (HOST_BITS_PER_WIDE_INT - 1))\n+\t\textend = -1;\n \t      for (; i < elem_bitsize; i += value_bit)\n-\t\t*vp++ = 0;\n+\t\t*vp++ = extend;\n \t    }\n \t  else\n \t    {"}]}