{"sha": "b8aa7986909d7752a29cfd612c1fb6d9bfb5f571", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhYTc5ODY5MDlkNzc1MmEyOWNmZDYxMmMxZmI2ZDliZmI1ZjU3MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-10T22:13:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-10T22:13:04Z"}, "message": "(add[hs]i3): Only use two addq.w or subq.w instructions when...\n\n(add[hs]i3): Only use two addq.w or subq.w instructions\nwhen adding or subtracting constants 8 < N < 16 on TARGET_CPU32.\nUse lea instead of add.w when adding 16 bit constants to address\nregisters on all but TARGET_68040.\n\nFrom-SVN: r13265", "tree": {"sha": "2c08f58a40a204489bdccdbf16b01331ec542f1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c08f58a40a204489bdccdbf16b01331ec542f1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8aa7986909d7752a29cfd612c1fb6d9bfb5f571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8aa7986909d7752a29cfd612c1fb6d9bfb5f571", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8aa7986909d7752a29cfd612c1fb6d9bfb5f571", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8aa7986909d7752a29cfd612c1fb6d9bfb5f571/comments", "author": null, "committer": null, "parents": [{"sha": "b686ee306b97517bf8805f6ba95999bf431930ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b686ee306b97517bf8805f6ba95999bf431930ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b686ee306b97517bf8805f6ba95999bf431930ec"}], "stats": {"total": 71, "additions": 51, "deletions": 20}, "files": [{"sha": "61e4a663e9c763130b0ea620e745d3203f6bd312", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8aa7986909d7752a29cfd612c1fb6d9bfb5f571/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8aa7986909d7752a29cfd612c1fb6d9bfb5f571/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=b8aa7986909d7752a29cfd612c1fb6d9bfb5f571", "patch": "@@ -789,7 +789,24 @@\n   \"*\n {\n   if (ADDRESS_REG_P (operands[0]))\n-    return \\\"sub%.l %0,%0\\\";\n+    {\n+      /* On the '040, 'subl an,an' takes 2 clocks while lea takes only 1 */\n+      if (!TARGET_68040 && !TARGET_68060)\n+\treturn \\\"sub%.l %0,%0\\\";\n+      else\n+\t{\n+#ifdef MOTOROLA\n+#ifdef SGS\n+\t  /* Many SGS assemblers croak on size specifiers for constants. */\n+\t  return \\\"lea 0,%0\\\";\n+#else\n+\t  return \\\"lea 0.w,%0\\\";\n+#endif\n+#else\n+\t  return \\\"lea 0:w,%0\\\";\n+#endif\n+\t}\n+    }\n   /* moveq is faster on the 68000.  */\n   if (DATA_REG_P (operands[0]) && (!TARGET_68020 && !TARGET_5200))\n #if defined(MOTOROLA) && !defined(CRDS)\n@@ -2149,11 +2166,10 @@\n \t\t  ? \\\"subq%.w %2,%0\\\"\n \t\t  : \\\"subq%.l %2,%0\\\");\n \t}\n-      /* On the 68020 it is faster to use two addqw instructions to\n+      /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to an address register.\n \t Likewise for subqw. */\n-      if (TARGET_68020 && !TARGET_68040 && !TARGET_68060 \n-          && ADDRESS_REG_P (operands[0]))\n+      if (TARGET_CPU32 && ADDRESS_REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[2]) > 8\n \t      && INTVAL (operands[2]) <= 16)\n@@ -2175,7 +2191,7 @@\n \t  && INTVAL (operands[2]) >= -0x8000\n \t  && INTVAL (operands[2]) < 0x8000)\n \t{\n-\t  if (!TARGET_5200)\n+\t  if (TARGET_68040)\n \t    return \\\"add%.w %2,%0\\\";\n \t  else\n #ifdef MOTOROLA  \n@@ -2203,9 +2219,9 @@\n   \"!TARGET_5200\"\n   \"*\n {\n-#ifndef NO_ADDSUB_Q\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n+#ifndef NO_ADDSUB_Q\n       /* If the constant would be a negative number when interpreted as\n \t HImode, make it negative.  This is usually, but not always, done\n \t elsewhere in the compiler.  First check for constants out of range,\n@@ -2225,11 +2241,10 @@\n \t\t\t         - INTVAL (operands[2]));\n \t  return \\\"subq%.w %2,%0\\\";\n \t}\n-      /* On the 68020 it is faster to use two addqw instructions to\n+      /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to an address register.  \n \t Likewise for subqw. */\n-      if (TARGET_68020 && !TARGET_68040 && !TARGET_68060 \n-          && ADDRESS_REG_P (operands[0]))\n+      if (TARGET_CPU32 && ADDRESS_REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[2]) > 8\n \t      && INTVAL (operands[2]) <= 16)\n@@ -2246,8 +2261,14 @@\n \t      return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n \t    }\n \t}\n-    }\n #endif\n+      if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n+#ifdef MOTOROLA  \n+\t    return \\\"lea (%c2,%0),%0\\\";\n+#else\n+\t    return \\\"lea %0@(%c2),%0\\\";\n+#endif\n+    }\n   return \\\"add%.w %2,%0\\\";\n }\")\n \n@@ -2264,9 +2285,9 @@\n   \"!TARGET_5200\"\n   \"*\n {\n-#ifndef NO_ADDSUB_Q\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n+#ifndef NO_ADDSUB_Q\n       /* If the constant would be a negative number when interpreted as\n \t HImode, make it negative.  This is usually, but not always, done\n \t elsewhere in the compiler.  First check for constants out of range,\n@@ -2286,11 +2307,10 @@\n \t\t\t         - INTVAL (operands[1]));\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n-      /* On the 68020 it is faster to use two addqw instructions to\n+      /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to an address register. \n \t Likewise for subqw. */\n-      if (TARGET_68020 && !TARGET_68040 && !TARGET_68060 \n-          && ADDRESS_REG_P (operands[0]))\n+      if (TARGET_CPU32 && ADDRESS_REG_P (operands[0]))\n \t{\n \t  if (INTVAL (operands[1]) > 8\n \t      && INTVAL (operands[1]) <= 16)\n@@ -2307,8 +2327,14 @@\n \t      return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n \t    }\n \t}\n-    }\n #endif\n+      if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n+#ifdef MOTOROLA  \n+\t    return \\\"lea (%c1,%0),%0\\\";\n+#else\n+\t    return \\\"lea %0@(%c1),%0\\\";\n+#endif\n+    }\n   return \\\"add%.w %1,%0\\\";\n }\")\n \n@@ -2319,9 +2345,9 @@\n   \"!TARGET_5200\"\n   \"*\n {\n-#ifndef NO_ADDSUB_Q\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n+#ifndef NO_ADDSUB_Q\n       /* If the constant would be a negative number when interpreted as\n \t HImode, make it negative.  This is usually, but not always, done\n \t elsewhere in the compiler.  First check for constants out of range,\n@@ -2341,11 +2367,10 @@\n \t\t\t         - INTVAL (operands[1]));\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n-      /* On the 68020 it is faster to use two addqw instructions to\n+      /* On the CPU32 it is faster to use two addqw instructions to\n \t add a small integer (8 < N <= 16) to an address register.\n \t Likewise for subqw. */\n-      if (TARGET_68020 && !TARGET_68040 && !TARGET_68060 \n-          && ADDRESS_REG_P (operands[0])) \n+      if (TARGET_CPU32 && ADDRESS_REG_P (operands[0])) \n \t{\n \t  if (INTVAL (operands[1]) > 8\n \t      && INTVAL (operands[1]) <= 16)\n@@ -2362,8 +2387,14 @@\n \t      return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n \t    }\n \t}\n-    }\n #endif\n+      if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n+#ifdef MOTOROLA  \n+\t    return \\\"lea (%c1,%0),%0\\\";\n+#else\n+\t    return \\\"lea %0@(%c1),%0\\\";\n+#endif\n+    }\n   return \\\"add%.w %1,%0\\\";\n }\")\n "}]}