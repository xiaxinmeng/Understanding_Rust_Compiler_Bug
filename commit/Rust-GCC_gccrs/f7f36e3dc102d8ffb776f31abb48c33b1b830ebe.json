{"sha": "f7f36e3dc102d8ffb776f31abb48c33b1b830ebe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdmMzZlM2RjMTAyZDhmZmI3NzZmMzFhYmI0OGMzM2IxYjgzMGViZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-05-07T22:37:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-05-07T22:37:24Z"}, "message": "PR c++/90171 - reorganize usual_deallocation_fn_p\n\nWhen fixing 90171 it struck me as undesirable to have so many separate\nfunctions that all needed to know about the definition of a usual\ndeallocation function.  So this patch condenses them into one.  I left\ndestroying_delete_p because it is used by other files as well.\n\n\t* call.c (struct dealloc_info): New.\n\t(usual_deallocation_fn_p): Take a dealloc_info*.\n\t(aligned_deallocation_fn_p, sized_deallocation_fn_p): Remove.\n\t(build_op_delete_call): Adjust.\n\nFrom-SVN: r270986", "tree": {"sha": "162c78828b3ac970b0fc97d39e22db261dd558c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/162c78828b3ac970b0fc97d39e22db261dd558c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f16ac89313843929da15e0d7dceefb85992da2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f16ac89313843929da15e0d7dceefb85992da2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f16ac89313843929da15e0d7dceefb85992da2e"}], "stats": {"total": 152, "additions": 70, "deletions": 82}, "files": [{"sha": "dade3e0c8b945b18d6faaae01c4ac5fa4fb5e8f0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f7f36e3dc102d8ffb776f31abb48c33b1b830ebe", "patch": "@@ -1,3 +1,11 @@\n+2019-05-06  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/90171 - reorganize usual_deallocation_fn_p\n+\t* call.c (struct dealloc_info): New.\n+\t(usual_deallocation_fn_p): Take a dealloc_info*.\n+\t(aligned_deallocation_fn_p, sized_deallocation_fn_p): Remove.\n+\t(build_op_delete_call): Adjust.\n+\n 2019-05-07  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/86485 - -Wmaybe-unused with empty class ?:"}, {"sha": "20db2974b56bbc21b819bbba305f9fabb8304c66", "filename": "gcc/cp/call.c", "status": "modified", "additions": 62, "deletions": 82, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7f36e3dc102d8ffb776f31abb48c33b1b830ebe/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f7f36e3dc102d8ffb776f31abb48c33b1b830ebe", "patch": "@@ -6348,63 +6348,22 @@ destroying_delete_p (tree t)\n   return std_destroying_delete_t_p (type) ? type : NULL_TREE;\n }\n \n-/* Returns true iff T, an element of an OVERLOAD chain, is a usual deallocation\n-   function (3.7.4.2 [basic.stc.dynamic.deallocation]) with a parameter of\n-   std::align_val_t.  */\n-\n-static bool\n-aligned_deallocation_fn_p (tree t)\n+struct dealloc_info\n {\n-  if (!aligned_new_threshold)\n-    return false;\n-\n-  /* A template instance is never a usual deallocation function,\n-     regardless of its signature.  */\n-  if (TREE_CODE (t) == TEMPLATE_DECL\n-      || primary_template_specialization_p (t))\n-    return false;\n-\n-  tree a = FUNCTION_ARG_CHAIN (t);\n-  if (destroying_delete_p (t))\n-    a = TREE_CHAIN (a);\n-  if (same_type_p (TREE_VALUE (a), align_type_node)\n-      && TREE_CHAIN (a) == void_list_node)\n-    return true;\n-  if (!same_type_p (TREE_VALUE (a), size_type_node))\n-    return false;\n-  a = TREE_CHAIN (a);\n-  if (a && same_type_p (TREE_VALUE (a), align_type_node)\n-      && TREE_CHAIN (a) == void_list_node)\n-    return true;\n-  return false;\n-}\n+  bool sized;\n+  bool aligned;\n+  tree destroying;\n+};\n \n-/* Returns true if FN is a usual deallocation fn with a size_t parameter.  */\n+/* Returns true iff T, an element of an OVERLOAD chain, is a usual deallocation\n+   function (3.7.4.2 [basic.stc.dynamic.deallocation]).  If so, and DI is\n+   non-null, also set *DI. */\n \n static bool\n-sized_deallocation_fn_p (tree fn)\n+usual_deallocation_fn_p (tree t, dealloc_info *di)\n {\n-  tree t = FUNCTION_ARG_CHAIN (fn);\n-  if (destroying_delete_p (fn))\n-    t = TREE_CHAIN (t);\n-  if (!t || !same_type_p (TREE_VALUE (t), size_type_node))\n-    return false;\n-  t = TREE_CHAIN (t);\n-  if (t == void_list_node)\n-    return true;\n-  if (aligned_new_threshold && t\n-      && same_type_p (TREE_VALUE (t), align_type_node)\n-      && TREE_CHAIN (t) == void_list_node)\n-    return true;\n-  return false;\n-}\n+  if (di) *di = dealloc_info();\n \n-/* Returns true iff T, an element of an OVERLOAD chain, is a usual\n-   deallocation function (3.7.4.2 [basic.stc.dynamic.deallocation]).  */\n-\n-bool\n-usual_deallocation_fn_p (tree t)\n-{\n   /* A template instance is never a usual deallocation function,\n      regardless of its signature.  */\n   if (TREE_CODE (t) == TEMPLATE_DECL\n@@ -6418,17 +6377,33 @@ usual_deallocation_fn_p (tree t)\n      - optionally, a parameter of type std::align_val_t.  */\n   bool global = DECL_NAMESPACE_SCOPE_P (t);\n   tree chain = FUNCTION_ARG_CHAIN (t);\n-  if (!chain)\n-    return false;\n-  if (destroying_delete_p (t))\n-    chain = TREE_CHAIN (chain);\n-  if (chain == void_list_node\n-      || ((!global || flag_sized_deallocation)\n-\t  && sized_deallocation_fn_p (t)))\n-    return true;\n-  if (aligned_deallocation_fn_p (t))\n-    return true;\n-  return false;\n+  if (chain && destroying_delete_p (t))\n+    {\n+      if (di) di->destroying = TREE_VALUE (chain);\n+      chain = TREE_CHAIN (chain);\n+    }\n+  if (chain\n+      && (!global || flag_sized_deallocation)\n+      && same_type_p (TREE_VALUE (chain), size_type_node))\n+    {\n+      if (di) di->sized = true;\n+      chain = TREE_CHAIN (chain);\n+    }\n+  if (chain && aligned_new_threshold\n+      && same_type_p (TREE_VALUE (chain), align_type_node))\n+    {\n+      if (di) di->aligned = true;\n+      chain = TREE_CHAIN (chain);\n+    }\n+  return (chain == void_list_node);\n+}\n+\n+/* Just return whether FN is a usual deallocation function.  */\n+\n+bool\n+usual_deallocation_fn_p (tree fn)\n+{\n+  return usual_deallocation_fn_p (fn, NULL);\n }\n \n /* Build a call to operator delete.  This has to be handled very specially,\n@@ -6457,6 +6432,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n {\n   tree fn = NULL_TREE;\n   tree fns, fnname, type, t;\n+  dealloc_info di_fn = { };\n \n   if (addr == error_mark_node)\n     return error_mark_node;\n@@ -6575,24 +6551,27 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n     for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (fns)); iter; ++iter)\n       {\n \ttree elt = *iter;\n-\tif (usual_deallocation_fn_p (elt))\n+\tdealloc_info di_elt;\n+\tif (usual_deallocation_fn_p (elt, &di_elt))\n \t  {\n \t    if (!fn)\n \t      {\n \t\tfn = elt;\n+\t\tdi_fn = di_elt;\n \t\tcontinue;\n \t      }\n \n \t    /* -- If any of the deallocation functions is a destroying\n \t       operator delete, all deallocation functions that are not\n \t       destroying operator deletes are eliminated from further\n \t       consideration.  */\n-\t    bool fn_destroying = destroying_delete_p (fn);\n-\t    bool elt_destroying = destroying_delete_p (elt);\n-\t    if (elt_destroying != fn_destroying)\n+\t    if (di_elt.destroying != di_fn.destroying)\n \t      {\n-\t\tif (elt_destroying)\n-\t\t  fn = elt;\n+\t\tif (di_elt.destroying)\n+\t\t  {\n+\t\t    fn = elt;\n+\t\t    di_fn = di_elt;\n+\t\t  }\n \t\tcontinue;\n \t      }\n \n@@ -6606,13 +6585,13 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t    if (aligned_new_threshold)\n \t      {\n \t\tbool want_align = type_has_new_extended_alignment (type);\n-\t\tbool fn_align = aligned_deallocation_fn_p (fn);\n-\t\tbool elt_align = aligned_deallocation_fn_p (elt);\n-\n-\t\tif (elt_align != fn_align)\n+\t\tif (di_elt.aligned != di_fn.aligned)\n \t\t  {\n-\t\t    if (want_align == elt_align)\n-\t\t      fn = elt;\n+\t\t    if (want_align == di_elt.aligned)\n+\t\t      {\n+\t\t\tfn = elt;\n+\t\t\tdi_fn = di_elt;\n+\t\t      }\n \t\t    continue;\n \t\t  }\n \t      }\n@@ -6639,11 +6618,12 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t\t  /* We need a cookie to determine the array size.  */\n \t\t  want_size = false;\n \t      }\n-\t    bool fn_size = sized_deallocation_fn_p (fn);\n-\t    bool elt_size = sized_deallocation_fn_p (elt);\n-\t    gcc_assert (fn_size != elt_size);\n-\t    if (want_size == elt_size)\n-\t      fn = elt;\n+\t    gcc_assert (di_fn.sized != di_elt.sized);\n+\t    if (want_size == di_elt.sized)\n+\t      {\n+\t\tfn = elt;\n+\t\tdi_fn = di_elt;\n+\t      }\n \t  }\n       }\n \n@@ -6678,7 +6658,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t}\n       else\n \t{\n-\t  tree destroying = destroying_delete_p (fn);\n+\t  tree destroying = di_fn.destroying;\n \t  if (destroying)\n \t    {\n \t      /* Strip const and volatile from addr but retain the type of the\n@@ -6696,9 +6676,9 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t  args->quick_push (addr);\n \t  if (destroying)\n \t    args->quick_push (destroying);\n-\t  if (sized_deallocation_fn_p (fn))\n+\t  if (di_fn.sized)\n \t    args->quick_push (size);\n-\t  if (aligned_deallocation_fn_p (fn))\n+\t  if (di_fn.aligned)\n \t    {\n \t      tree al = build_int_cst (align_type_node, TYPE_ALIGN_UNIT (type));\n \t      args->quick_push (al);"}]}