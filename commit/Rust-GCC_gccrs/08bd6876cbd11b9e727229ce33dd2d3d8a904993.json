{"sha": "08bd6876cbd11b9e727229ce33dd2d3d8a904993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhiZDY4NzZjYmQxMWI5ZTcyNzIyOWNlMzNkZDJkM2Q4YTkwNDk5Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-21T22:48:14Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-21T22:48:14Z"}, "message": "re PR bootstrap/44970 (Revision 162270 failed to bootstrap)\n\n\tPR bootstrap/44970\n\tPR middle-end/45009\n\t* postreload.c: Include \"target.h\".\n\t(reload_combine_closest_single_use): Don't take DEBUG_INSNs\n\tinto account.\n\t(fixup_debug_insns): Don't copy the rtx.\n\t(reload_combine_recognize_const_pattern): DEBUG_INSNs can't\n\thave uses.  Don't copy when replacing.  Call fixup_debug_insns\n\tin the case where we merged one add with another.\n\t(reload_combine_recognize_pattern): Fail if there aren't any\n\tuses.  Try harder to determine whether we're picking a valid\n\tindex register.  Don't set store_ruid for an insn we're going\n\tto scan in the next iteration.\n\t(reload_combine): Remove unused code.\n\t(reload_combine_note_use): When updating use information for\n\tan old insn, ignore a use that occurs after store_ruid.\n\t* Makefile.in (postreload.o): Update dependencies.\n\nFrom-SVN: r162390", "tree": {"sha": "3abbfbe051e6bcc5b14e4184efc654dc1564c420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3abbfbe051e6bcc5b14e4184efc654dc1564c420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08bd6876cbd11b9e727229ce33dd2d3d8a904993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08bd6876cbd11b9e727229ce33dd2d3d8a904993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08bd6876cbd11b9e727229ce33dd2d3d8a904993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08bd6876cbd11b9e727229ce33dd2d3d8a904993/comments", "author": null, "committer": null, "parents": [{"sha": "6168fc435e1b56df4582cebe3de6b9cf71f9d55d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6168fc435e1b56df4582cebe3de6b9cf71f9d55d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6168fc435e1b56df4582cebe3de6b9cf71f9d55d"}], "stats": {"total": 66, "additions": 41, "deletions": 25}, "files": [{"sha": "74607e5839bea0a56bdae2c3a54130a64d771de2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08bd6876cbd11b9e727229ce33dd2d3d8a904993/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08bd6876cbd11b9e727229ce33dd2d3d8a904993/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08bd6876cbd11b9e727229ce33dd2d3d8a904993", "patch": "@@ -1,3 +1,23 @@\n+2010-07-22  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR bootstrap/44970\n+\tPR middle-end/45009\n+\t* postreload.c: Include \"target.h\".\n+\t(reload_combine_closest_single_use): Don't take DEBUG_INSNs\n+\tinto account.\n+\t(fixup_debug_insns): Don't copy the rtx.\n+\t(reload_combine_recognize_const_pattern): DEBUG_INSNs can't\n+\thave uses.  Don't copy when replacing.  Call fixup_debug_insns\n+\tin the case where we merged one add with another.\n+\t(reload_combine_recognize_pattern): Fail if there aren't any\n+\tuses.  Try harder to determine whether we're picking a valid\n+\tindex register.  Don't set store_ruid for an insn we're going\n+\tto scan in the next iteration.\n+\t(reload_combine): Remove unused code.\n+\t(reload_combine_note_use): When updating use information for\n+\tan old insn, ignore a use that occurs after store_ruid.\n+\t* Makefile.in (postreload.o): Update dependencies.\n+\n 2010-07-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/45015"}, {"sha": "55f3cdfe7b23fa777b6ea43dafd8d2370ee31bf7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08bd6876cbd11b9e727229ce33dd2d3d8a904993/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08bd6876cbd11b9e727229ce33dd2d3d8a904993/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=08bd6876cbd11b9e727229ce33dd2d3d8a904993", "patch": "@@ -3288,7 +3288,7 @@ postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \\\n    hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \\\n    $(FUNCTION_H) $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) cselib.h $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(MACHMODE_H) \\\n-   $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)\n+   $(OBSTACK_H) $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)\n postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "31012214682ceddf1ebf89e9fc1fcbc8013c2257", "filename": "gcc/postreload.c", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08bd6876cbd11b9e727229ce33dd2d3d8a904993/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08bd6876cbd11b9e727229ce33dd2d3d8a904993/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=08bd6876cbd11b9e727229ce33dd2d3d8a904993", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"tree.h\"\n+#include \"target.h\"\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n@@ -816,8 +817,7 @@ reload_combine_purge_reg_uses_after_ruid (unsigned regno, int ruid)\n \n /* Find the use of REGNO with the ruid that is highest among those\n    lower than RUID_LIMIT, and return it if it is the only use of this\n-   reg in the insn (or if the insn is a debug insn).  Return NULL\n-   otherwise.  */\n+   reg in the insn.  Return NULL otherwise.  */\n \n static struct reg_use *\n reload_combine_closest_single_use (unsigned regno, int ruid_limit)\n@@ -838,9 +838,9 @@ reload_combine_closest_single_use (unsigned regno, int ruid_limit)\n       if (this_ruid > best_ruid)\n \t{\n \t  best_ruid = this_ruid;\n-\t  retval = reg_state[regno].reg_use + i;\n+\t  retval = use;\n \t}\n-      else if (this_ruid == best_ruid && !DEBUG_INSN_P (use->insn))\n+      else if (this_ruid == best_ruid)\n \tretval = NULL;\n     }\n   if (last_label_ruid >= best_ruid)\n@@ -866,7 +866,7 @@ fixup_debug_insns (rtx reg, rtx replacement, rtx from, rtx to)\n \tcontinue;\n       \n       t = INSN_VAR_LOCATION_LOC (insn);\n-      t = simplify_replace_rtx (t, reg, copy_rtx (replacement));\n+      t = simplify_replace_rtx (t, reg, replacement);\n       validate_change (insn, &INSN_VAR_LOCATION_LOC (insn), t, 0);\n     }\n }\n@@ -938,10 +938,6 @@ reload_combine_recognize_const_pattern (rtx insn)\n \t/* Start the search for the next use from here.  */\n \tfrom_ruid = use->ruid;\n \n-      /* We'll fix up DEBUG_INSNs after we're done.  */\n-      if (use && DEBUG_INSN_P (use->insn))\n-\tcontinue;\n-\n       if (use && GET_MODE (*use->usep) == Pmode)\n \t{\n \t  rtx use_insn = use->insn;\n@@ -972,7 +968,7 @@ reload_combine_recognize_const_pattern (rtx insn)\n \t      int old_cost = address_cost (oldaddr, GET_MODE (mem), as, speed);\n \t      int new_cost;\n \n-\t      newaddr = simplify_replace_rtx (oldaddr, reg, copy_rtx (src));\n+\t      newaddr = simplify_replace_rtx (oldaddr, reg, src);\n \t      if (memory_address_addr_space_p (GET_MODE (mem), newaddr, as))\n \t\t{\n \t\t  XEXP (mem, 0) = newaddr;\n@@ -1008,8 +1004,7 @@ reload_combine_recognize_const_pattern (rtx insn)\n \t\t  int old_cost = rtx_cost (SET_SRC (new_set), SET, speed);\n \n \t\t  gcc_assert (rtx_equal_p (XEXP (SET_SRC (new_set), 0), reg));\n-\t\t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg,\n-\t\t\t\t\t\t  copy_rtx (src));\n+\t\t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg, src);\n \n \t\t  if (rtx_cost (new_src, SET, speed) <= old_cost\n \t\t      && validate_change (use_insn, &SET_SRC (new_set),\n@@ -1024,6 +1019,7 @@ reload_combine_recognize_const_pattern (rtx insn)\n \t\t\t  /* See if that took care of the add insn.  */\n \t\t\t  if (rtx_equal_p (SET_DEST (new_set), reg))\n \t\t\t    {\n+\t\t\t      fixup_debug_insns (reg, src, insn, use_insn);\n \t\t\t      delete_insn (insn);\n \t\t\t      return true;\n \t\t\t    }\n@@ -1102,6 +1098,8 @@ reload_combine_recognize_pattern (rtx insn)\n       && REG_P (XEXP (src, 1))\n       && rtx_equal_p (XEXP (src, 0), reg)\n       && !rtx_equal_p (XEXP (src, 1), reg)\n+      && reg_state[regno].use_index >= 0\n+      && reg_state[regno].use_index < RELOAD_COMBINE_MAX_USES\n       && last_label_ruid < reg_state[regno].use_ruid)\n     {\n       rtx base = XEXP (src, 1);\n@@ -1134,7 +1132,11 @@ reload_combine_recognize_pattern (rtx insn)\n \t      if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i)\n \t\t  && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n \t\t  && reg_state[i].store_ruid <= reg_state[regno].use_ruid\n-\t\t  && hard_regno_nregs[i][GET_MODE (reg)] == 1)\n+\t\t  && (call_used_regs[i] || df_regs_ever_live_p (i))\n+\t\t  && (!frame_pointer_needed || i != HARD_FRAME_POINTER_REGNUM)\n+\t\t  && !fixed_regs[i] && !global_regs[i]\n+\t\t  && hard_regno_nregs[i][GET_MODE (reg)] == 1\n+\t\t  && targetm.hard_regno_scratch_ok (i))\n \t\t{\n \t\t  index_reg = gen_rtx_REG (GET_MODE (reg), i);\n \t\t  reg_sum = gen_rtx_PLUS (GET_MODE (reg), index_reg, base);\n@@ -1150,7 +1152,6 @@ reload_combine_recognize_pattern (rtx insn)\n \t  && prev_set\n \t  && CONST_INT_P (SET_SRC (prev_set))\n \t  && rtx_equal_p (SET_DEST (prev_set), reg)\n-\t  && reg_state[regno].use_index >= 0\n \t  && (reg_state[REGNO (base)].store_ruid\n \t      <= reg_state[regno].use_ruid))\n \t{\n@@ -1201,8 +1202,6 @@ reload_combine_recognize_pattern (rtx insn)\n \t\tremove_reg_equal_equiv_notes (prev);\n \n \t      reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n-\t      reg_state[REGNO (index_reg)].store_ruid\n-\t\t= reload_combine_ruid;\n \t      return true;\n \t    }\n \t}\n@@ -1244,14 +1243,6 @@ reload_combine (void)\n \t}\n     }\n \n-#if 0\n-  /* If reg+reg can be used in offsetable memory addresses, the main chunk of\n-     reload has already used it where appropriate, so there is no use in\n-     trying to generate it now.  */\n-  if (double_reg_address_ok || last_index_reg == -1)\n-    return;\n-#endif\n-\n   /* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime\n      information is a bit fuzzy immediately after reload, but it's\n      still good enough to determine which registers are live at a jump\n@@ -1511,6 +1502,11 @@ reload_combine_note_use (rtx *xp, rtx insn, int ruid, rtx containing_mem)\n \t    return;\n \t  }\n \n+\t/* We may be called to update uses in previously seen insns.\n+\t   Don't add uses beyond the last store we saw.  */\n+\tif (ruid < reg_state[regno].store_ruid)\n+\t  return;\n+\n \t/* If this register is already used in some unknown fashion, we\n \t   can't do anything.\n \t   If we decrement the index from zero to -1, we can't store more"}]}