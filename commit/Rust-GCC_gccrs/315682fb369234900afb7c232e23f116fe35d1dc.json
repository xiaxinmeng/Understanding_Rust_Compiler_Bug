{"sha": "315682fb369234900afb7c232e23f116fe35d1dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1NjgyZmIzNjkyMzQ5MDBhZmI3YzIzMmUyM2YxMTZmZTM1ZDFkYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-03T14:09:57Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-03T14:09:57Z"}, "message": "cfghooks.c, [...]: Fix comment typos.\n\n\t* cfghooks.c, cfgrtl.c, modulo-sched.c, config/i386/winnt.c:\n\tFix comment typos.\n\nFrom-SVN: r97490", "tree": {"sha": "bd4b4f2c491dbc0ee7621f452f734180790eb8a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd4b4f2c491dbc0ee7621f452f734180790eb8a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315682fb369234900afb7c232e23f116fe35d1dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315682fb369234900afb7c232e23f116fe35d1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315682fb369234900afb7c232e23f116fe35d1dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315682fb369234900afb7c232e23f116fe35d1dc/comments", "author": null, "committer": null, "parents": [{"sha": "ee307009db460dd07589e6bc2d31aad4c5a40426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee307009db460dd07589e6bc2d31aad4c5a40426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee307009db460dd07589e6bc2d31aad4c5a40426"}], "stats": {"total": 21, "additions": 13, "deletions": 8}, "files": [{"sha": "4c971bdfa203c5a3d442f101e06f5822afca88be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=315682fb369234900afb7c232e23f116fe35d1dc", "patch": "@@ -1,3 +1,8 @@\n+2005-04-03  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cfghooks.c, cfgrtl.c, modulo-sched.c, config/i386/winnt.c:\n+\tFix comment typos.\n+\n 2005-04-03  Steven Bosscher  <stevenb@suse.de>\n \n \tPR middle-end/20648"}, {"sha": "bf7921806b25b8a75d424d51e12dfd0b1ec8885f", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=315682fb369234900afb7c232e23f116fe35d1dc", "patch": "@@ -867,7 +867,7 @@ extract_cond_bb_edges (basic_block b, edge *e1, edge *e2)\n }\n \n /* Responsible for updating the ssa info (PHI nodes) on the\n-   new conidtion basic block that guargs the versioned loop.  */\n+   new condition basic block that guards the versioned loop.  */\n void\n lv_adjust_loop_header_phi (basic_block first, basic_block second,\n \t\t\t   basic_block new, edge e)"}, {"sha": "ea7d1ba9b623f2b82c32729757ef1b7d51794677", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=315682fb369234900afb7c232e23f116fe35d1dc", "patch": "@@ -2998,7 +2998,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n }\n \n /* Add COMP_RTX as a condition at end of COND_BB.  FIRST_HEAD is\n-   the conditional branch traget, SECOND_HEAD should be the fall-thru\n+   the conditional branch target, SECOND_HEAD should be the fall-thru\n    there is no need to handle this here the loop versioning code handles\n    this.  the reason for SECON_HEAD is that it is needed for condition\n    in trees, and this should be of the same type since it is a hook.  */"}, {"sha": "cfab2270b68a86d2f3ea9ea96838df05638226e7", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=315682fb369234900afb7c232e23f116fe35d1dc", "patch": "@@ -681,7 +681,7 @@ i386_pe_asm_named_section (const char *name, unsigned int flags,\n       /* Functions may have been compiled at various levels of\n \t optimization so we can't use `same_size' here.\n \t Instead, have the linker pick one, without warning.\n-\t If 'selectany' attibute has been specified,  MS compiler\n+\t If 'selectany' attribute has been specified,  MS compiler\n \t sets 'discard' characteristic, rather than telling linker\n \t to warn of size or content mismatch, so do the same.  */ \n       bool discard = (flags & SECTION_CODE)"}, {"sha": "2a7beee065e687ec08f82f802f6dd9fbe904f89e", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315682fb369234900afb7c232e23f116fe35d1dc/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=315682fb369234900afb7c232e23f116fe35d1dc", "patch": "@@ -934,7 +934,7 @@ canon_loop (struct loop *loop)\n \n /* Build the loop information without loop\n    canonization, the loop canonization will\n-   be perfromed if the loop is SMSable.  */\n+   be performed if the loop is SMSable.  */\n static struct loops *\n build_loops_structure (FILE *dumpfile)\n {\n@@ -1417,11 +1417,11 @@ sms_schedule (FILE *dump_file)\n #define DFA_HISTORY SMS_DFA_HISTORY\n \n /* Given the partial schedule PS, this function calculates and returns the\n-   cycles in wich we can schedule the node with the given index I.\n+   cycles in which we can schedule the node with the given index I.\n    NOTE: Here we do the backtracking in SMS, in some special cases. We have\n    noticed that there are several cases in which we fail    to SMS the loop\n    because the sched window of a node is empty    due to tight data-deps. In\n-   such cases we want to unschedule    some of the predecssors/successors\n+   such cases we want to unschedule    some of the predecessors/successors\n    until we get non-empty    scheduling window.  It returns -1 if the\n    scheduling window is empty and zero otherwise.  */\n \n@@ -2535,8 +2535,8 @@ rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n   ps->min_cycle -= start_cycle;\n }\n \n-/* Remove the node N from the partial schedule PS; becuase we restart the DFA\n-   each time we want to check for resuorce conflicts; this is equivalent to\n+/* Remove the node N from the partial schedule PS; because we restart the DFA\n+   each time we want to check for resource conflicts; this is equivalent to\n    unscheduling the node N.  */\n static bool\n ps_unschedule_node (partial_schedule_ptr ps, ddg_node_ptr n)"}]}