{"sha": "8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0N2ZkNjJmYTk0MTQwMTdmMGZlNGYzMDc1MTEyZTJhOWNlOWU0NA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2008-05-16T17:42:44Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2008-05-16T17:42:44Z"}, "message": "Part 1.1 of PR25561.\n\n2008-05-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libfortran/25561\n\t* io/io.h (struct fbuf): Change pointer to position offset.\n\t* io/fbuf.c (fbuf_init): Reduce default size of buffer, ptr=>pos\n\tchanges.\n\t(fbuf_reset): ptr=>pos changes.\n\t(fbuf_alloc): If the request doesn't fit, don't waste memory by\n\tkeeping flushed bytes. ptr=>pos changes.\n\t(fbuf_flush): ptr=>pos changes.\n\t(fbuf_seek): Don't seek past the left tab limit, don't update active\n\tbyte count.\n\t* io/open.c (new_unit): If RECL has been specified, used that as\n\tinitial buffer size.\n\nFrom-SVN: r135433", "tree": {"sha": "b8d80d6121e1e056d1aaacd9882dd2ff45f168cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d80d6121e1e056d1aaacd9882dd2ff45f168cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/comments", "author": null, "committer": null, "parents": [{"sha": "65686652e48ae64f331078abe64b344e3318cfb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65686652e48ae64f331078abe64b344e3318cfb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65686652e48ae64f331078abe64b344e3318cfb8"}], "stats": {"total": 111, "additions": 82, "deletions": 29}, "files": [{"sha": "4d095a6ddcdc0f8b9268c6ba6f6f1a2d3a74284c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "patch": "@@ -1,3 +1,18 @@\n+2008-05-16  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/25561\n+\t* io/io.h (struct fbuf): Change pointer to position offset.\n+\t* io/fbuf.c (fbuf_init): Reduce default size of buffer, ptr=>pos\n+\tchanges.\n+\t(fbuf_reset): ptr=>pos changes.\n+\t(fbuf_alloc): If the request doesn't fit, don't waste memory by\n+\tkeeping flushed bytes. ptr=>pos changes.\n+\t(fbuf_flush): ptr=>pos changes.\n+\t(fbuf_seek): Don't seek past the left tab limit, don't update active\n+\tbyte count.\n+\t* io/open.c (new_unit): If RECL has been specified, used that as\n+\tinitial buffer size.\n+\n 2008-05-16  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/35632"}, {"sha": "a0d033bf8758f754e93d1e8ae8dcb92512232015", "filename": "libgfortran/io/fbuf.c", "status": "modified", "additions": 59, "deletions": 27, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2Fio%2Ffbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2Fio%2Ffbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.c?ref=8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "patch": "@@ -37,20 +37,19 @@ void\n fbuf_init (gfc_unit * u, size_t len)\n {\n   if (len == 0)\n-    len = 4096;\t\t\t/* Default size one page.  */\n+    len = 512;\t\t\t/* Default size.  */\n \n   u->fbuf = get_mem (sizeof (fbuf));\n-  u->fbuf->buf = u->fbuf->ptr = get_mem (len);\n+  u->fbuf->buf = get_mem (len);\n   u->fbuf->len = len;\n-  u->fbuf->act = u->fbuf->flushed = 0;\n+  u->fbuf->act = u->fbuf->flushed = u->fbuf->pos = 0;\n }\n \n \n void\n fbuf_reset (gfc_unit * u)\n {\n-  u->fbuf->act = u->fbuf->flushed = 0;\n-  u->fbuf->ptr = u->fbuf->buf;\n+  u->fbuf->act = u->fbuf->flushed = u->fbuf->pos = 0;\n }\n \n \n@@ -67,33 +66,65 @@ fbuf_destroy (gfc_unit * u)\n \n /* Return a pointer to the current position in the buffer, and increase\n    the pointer by len. Makes sure that the buffer is big enough, \n-   reallocating if necessary.  */\n+   reallocating if necessary. If the buffer is not big enough, there are\n+   three cases to consider:\n+   1. If we haven't flushed anything, realloc\n+   2. If we have flushed enough that by discarding the flushed bytes\n+      the request fits into the buffer, do that.\n+   3. Else allocate a new buffer, memcpy unflushed active bytes from old\n+      buffer. */\n \n char *\n fbuf_alloc (gfc_unit * u, size_t len)\n {\n-  size_t newlen, ptrpos;\n+  size_t newlen;\n   char *dest;\n-  if (u->fbuf->ptr + len > u->fbuf->buf + u->fbuf->len)\n+  if (u->fbuf->pos + len > u->fbuf->len)\n     {\n-      /* Round up to nearest multiple of the current buffer length.  */\n-      ptrpos = u->fbuf->ptr - u->fbuf->buf;\n-      newlen = ((ptrpos + len) / u->fbuf->len + 1) * u->fbuf->len;\n-      dest = realloc (u->fbuf->buf, newlen);\n-      if (dest == NULL)\n-\treturn NULL;\n-      u->fbuf->buf = dest;\n-      u->fbuf->ptr = dest + ptrpos;\n-      u->fbuf->len = newlen;\n+      if (u->fbuf->flushed == 0)\n+\t{\n+\t  /* Round up to nearest multiple of the current buffer length.  */\n+\t  newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) * u->fbuf->len;\n+\t  dest = realloc (u->fbuf->buf, newlen);\n+\t  if (dest == NULL)\n+\t    return NULL;\n+\t  u->fbuf->buf = dest;\n+\t  u->fbuf->len = newlen;\n+\t}\n+      else if (u->fbuf->act - u->fbuf->flushed + len < u->fbuf->len)\n+\t{\n+\t  memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->flushed,\n+\t\t   u->fbuf->act - u->fbuf->flushed);\n+\t  u->fbuf->act -= u->fbuf->flushed;\n+\t  u->fbuf->pos -= u->fbuf->flushed;\n+\t  u->fbuf->flushed = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Most general case, flushed != 0, request doesn't fit.  */\n+\t  newlen = ((u->fbuf->pos - u->fbuf->flushed + len)\n+\t\t    / u->fbuf->len + 1) * u->fbuf->len;\n+\t  dest = get_mem (newlen);\n+\t  memcpy (dest, u->fbuf->buf + u->fbuf->flushed,\n+\t\t  u->fbuf->act - u->fbuf->flushed);\n+\t  u->fbuf->act -= u->fbuf->flushed;\n+\t  u->fbuf->pos -= u->fbuf->flushed;\n+\t  u->fbuf->flushed = 0;\n+\t  u->fbuf->buf = dest;\n+\t  u->fbuf->len = newlen;\n+\t}\n     }\n-  dest = u->fbuf->ptr;\n-  u->fbuf->ptr += len;\n-  if ((size_t) (u->fbuf->ptr - u->fbuf->buf) > u->fbuf->act)\n-    u->fbuf->act = u->fbuf->ptr - u->fbuf->buf;\n+\n+  dest = u->fbuf->buf + u->fbuf->pos;\n+  u->fbuf->pos += len;\n+  if (u->fbuf->pos > u->fbuf->act)\n+    u->fbuf->act = u->fbuf->pos;\n   return dest;\n }\n \n \n+\n+\n int\n fbuf_flush (gfc_unit * u, int record_done)\n {\n@@ -107,7 +138,7 @@ fbuf_flush (gfc_unit * u, int record_done)\n       if (record_done)\n         nbytes = u->fbuf->act - u->fbuf->flushed;\n       else\t\n-        nbytes = u->fbuf->ptr - u->fbuf->buf - u->fbuf->flushed;\t\n+        nbytes = u->fbuf->pos - u->fbuf->flushed;\t\n       status = swrite (u->s, u->fbuf->buf + u->fbuf->flushed, &nbytes);\n       u->fbuf->flushed += nbytes;\n     }\n@@ -122,11 +153,12 @@ fbuf_flush (gfc_unit * u, int record_done)\n int\n fbuf_seek (gfc_unit * u, gfc_offset off)\n {\n-  gfc_offset pos = u->fbuf->ptr - u->fbuf->buf + off;\n-  if (pos < 0)\n+  gfc_offset pos = u->fbuf->pos + off;\n+  /* Moving to the left past the flushed marked would imply moving past\n+     the left tab limit, which is never allowed. So return error if\n+     that is attempted.  */\n+  if (pos < u->fbuf->flushed)\n     return -1;\n-  u->fbuf->ptr = u->fbuf->buf + pos;\n-  if (pos > (gfc_offset) u->fbuf->act)\n-    u->fbuf->act = pos;\n+  u->fbuf->pos = pos;\n   return 0;\n }"}, {"sha": "7f9f38f80c0194264a2965224f00f30ae3b67047", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "patch": "@@ -537,7 +537,7 @@ typedef struct fbuf\n   size_t len;\t\t\t/* Length of buffer.  */\n   size_t act;\t\t\t/* Active bytes in buffer.  */\n   size_t flushed;\t\t/* Flushed bytes from beginning of buffer.  */\n-  char *ptr;\t\t\t/* Current position in buffer.  */\n+  size_t pos;\t\t\t/* Current position in buffer.  */\n }\n fbuf;\n "}, {"sha": "84575f7bb01ed6eeb774bfbf4f1d66574ed97d54", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8947fd62fa9414017f0fe4f3075112e2a9ce9e44/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=8947fd62fa9414017f0fe4f3075112e2a9ce9e44", "patch": "@@ -628,9 +628,15 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n     free_mem (opp->file);\n     \n   if (flags->form == FORM_FORMATTED && (flags->action != ACTION_READ))\n-    fbuf_init (u, 0);\n+    {\n+      if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN))\n+        fbuf_init (u, u->recl);\n+      else\n+        fbuf_init (u, 0);\n+    }\n   else\n     u->fbuf = NULL;\n+\n     \n     \n   return u;"}]}