{"sha": "9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY0Y2JhYjg0ZDNiYzVkNGYzNTI1OGNiYzJlNmRmNDhkODgyMTQ5Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:57:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:57:36Z"}, "message": "[AArch64] SVE load/store_lanes support\n\nThis patch adds support for SVE LD[234], ST[234] and associated\nstructure modes.  Unlike Advanced SIMD, these modes are extra-long\nvector modes instead of integer modes.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-modes.def: Define x2, x3 and x4 vector\n\tmodes for SVE.\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_sve_struct_memory_operand_p): Declare.\n\t* config/aarch64/iterators.md (SVE_STRUCT): New mode iterator.\n\t(vector_count, insn_length, VSINGLE, vsingle): New mode attributes.\n\t(VPRED, vpred): Handle SVE structure modes.\n\t* config/aarch64/constraints.md (Utx): New constraint.\n\t* config/aarch64/predicates.md (aarch64_sve_struct_memory_operand)\n\t(aarch64_sve_struct_nonimmediate_operand): New predicates.\n\t* config/aarch64/aarch64.md (UNSPEC_LDN, UNSPEC_STN): New unspecs.\n\t* config/aarch64/aarch64-sve.md (mov<mode>, *aarch64_sve_mov<mode>_le)\n\t(*aarch64_sve_mov<mode>_be, pred_mov<mode>): New patterns for\n\tstructure modes.  Split into pieces after RA.\n\t(vec_load_lanes<mode><vsingle>, vec_mask_load_lanes<mode><vsingle>)\n\t(vec_store_lanes<mode><vsingle>, vec_mask_store_lanes<mode><vsingle>):\n\tNew patterns.\n\t* config/aarch64/aarch64.c (aarch64_classify_vector_mode): Handle\n\tSVE structure modes.\n\t(aarch64_classify_address): Likewise.\n\t(sizetochar): Move earlier in file.\n\t(aarch64_print_operand): Handle SVE register lists.\n\t(aarch64_array_mode): New function.\n\t(aarch64_sve_struct_memory_operand_p): Likewise.\n\t(TARGET_ARRAY_MODE): Redefine.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_load_lanes):\n\tReturn true for SVE too.\n\t* g++.dg/vect/pr36648.cc: XFAIL for variable-length vectors\n\tif load/store lanes are supported.\n\t* gcc.dg/vect/slp-10.c: Likewise.\n\t* gcc.dg/vect/slp-12c.c: Likewise.\n\t* gcc.dg/vect/slp-17.c: Likewise.\n\t* gcc.dg/vect/slp-33.c: Likewise.\n\t* gcc.dg/vect/slp-6.c: Likewise.\n\t* gcc.dg/vect/slp-cond-1.c: Likewise.\n\t* gcc.dg/vect/slp-multitypes-11-big-array.c: Likewise.\n\t* gcc.dg/vect/slp-multitypes-11.c: Likewise.\n\t* gcc.dg/vect/slp-multitypes-12.c: Likewise.\n\t* gcc.dg/vect/slp-perm-5.c: Remove XFAIL for variable-length SVE.\n\t* gcc.dg/vect/slp-perm-6.c: Likewise.\n\t* gcc.dg/vect/slp-perm-9.c: Likewise.\n\t* gcc.dg/vect/slp-reduc-6.c: Remove XFAIL for variable-length vectors.\n\t* gcc.dg/vect/vect-load-lanes-peeling-1.c: Expect an epilogue loop\n\tfor variable-length vectors.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256618", "tree": {"sha": "ac6171e2181856d5e0b86b0026a2e8a388d522d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac6171e2181856d5e0b86b0026a2e8a388d522d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/comments", "author": null, "committer": null, "parents": [{"sha": "695da53448dcc40e1e5db83bcf14d16217ffbd4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695da53448dcc40e1e5db83bcf14d16217ffbd4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695da53448dcc40e1e5db83bcf14d16217ffbd4a"}], "stats": {"total": 473, "additions": 425, "deletions": 48}, "files": [{"sha": "fba27e19675916d48f4f724eed3f4c0254ea9b3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -1,3 +1,33 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64-modes.def: Define x2, x3 and x4 vector\n+\tmodes for SVE.\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_sve_struct_memory_operand_p): Declare.\n+\t* config/aarch64/iterators.md (SVE_STRUCT): New mode iterator.\n+\t(vector_count, insn_length, VSINGLE, vsingle): New mode attributes.\n+\t(VPRED, vpred): Handle SVE structure modes.\n+\t* config/aarch64/constraints.md (Utx): New constraint.\n+\t* config/aarch64/predicates.md (aarch64_sve_struct_memory_operand)\n+\t(aarch64_sve_struct_nonimmediate_operand): New predicates.\n+\t* config/aarch64/aarch64.md (UNSPEC_LDN, UNSPEC_STN): New unspecs.\n+\t* config/aarch64/aarch64-sve.md (mov<mode>, *aarch64_sve_mov<mode>_le)\n+\t(*aarch64_sve_mov<mode>_be, pred_mov<mode>): New patterns for\n+\tstructure modes.  Split into pieces after RA.\n+\t(vec_load_lanes<mode><vsingle>, vec_mask_load_lanes<mode><vsingle>)\n+\t(vec_store_lanes<mode><vsingle>, vec_mask_store_lanes<mode><vsingle>):\n+\tNew patterns.\n+\t* config/aarch64/aarch64.c (aarch64_classify_vector_mode): Handle\n+\tSVE structure modes.\n+\t(aarch64_classify_address): Likewise.\n+\t(sizetochar): Move earlier in file.\n+\t(aarch64_print_operand): Handle SVE register lists.\n+\t(aarch64_array_mode): New function.\n+\t(aarch64_sve_struct_memory_operand_p): Likewise.\n+\t(TARGET_ARRAY_MODE): Redefine.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1a05b6cc70828ce929c39ef6197b50ee5589e058", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -88,6 +88,9 @@ INT_MODE (XI, 64);\n /* Give SVE vectors the names normally used for 256-bit vectors.\n    The actual number depends on command-line flags.  */\n SVE_MODES (1, VNx16, VNx8, VNx4, VNx2)\n+SVE_MODES (2, VNx32, VNx16, VNx8, VNx4)\n+SVE_MODES (3, VNx48, VNx24, VNx12, VNx6)\n+SVE_MODES (4, VNx64, VNx32, VNx16, VNx8)\n \n /* Quad float: 128-bit floating mode for long doubles.  */\n FLOAT_MODE (TF, 16, ieee_quad_format);"}, {"sha": "2d705d2864760cae34da6d748bf37e41acd2ee00", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -432,6 +432,7 @@ rtx aarch64_simd_gen_const_vector_dup (machine_mode, HOST_WIDE_INT);\n bool aarch64_simd_mem_operand_p (rtx);\n bool aarch64_sve_ld1r_operand_p (rtx);\n bool aarch64_sve_ldr_operand_p (rtx);\n+bool aarch64_sve_struct_memory_operand_p (rtx);\n rtx aarch64_simd_vect_par_cnst_half (machine_mode, int, bool);\n rtx aarch64_tls_get_addr (void);\n tree aarch64_fold_builtin (tree, int, tree *, bool);"}, {"sha": "e83d4f6c718e3e5c295f604d2c0597668d453101", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -189,6 +189,105 @@\n   \"st1<Vesize>\\t%1.<Vetype>, %2, %0\"\n )\n \n+;; SVE structure moves.\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:SVE_STRUCT 0 \"nonimmediate_operand\")\n+\t(match_operand:SVE_STRUCT 1 \"general_operand\"))]\n+  \"TARGET_SVE\"\n+  {\n+    /* Big-endian loads and stores need to be done via LD1 and ST1;\n+       see the comment at the head of the file for details.  */\n+    if ((MEM_P (operands[0]) || MEM_P (operands[1]))\n+\t&& BYTES_BIG_ENDIAN)\n+      {\n+\tgcc_assert (can_create_pseudo_p ());\n+\taarch64_expand_sve_mem_move (operands[0], operands[1], <VPRED>mode);\n+\tDONE;\n+      }\n+\n+    if (CONSTANT_P (operands[1]))\n+      {\n+\taarch64_expand_mov_immediate (operands[0], operands[1]);\n+\tDONE;\n+      }\n+  }\n+)\n+\n+;; Unpredicated structure moves (little-endian).\n+(define_insn \"*aarch64_sve_mov<mode>_le\"\n+  [(set (match_operand:SVE_STRUCT 0 \"aarch64_sve_nonimmediate_operand\" \"=w, Utr, w, w\")\n+\t(match_operand:SVE_STRUCT 1 \"aarch64_sve_general_operand\" \"Utr, w, w, Dn\"))]\n+  \"TARGET_SVE && !BYTES_BIG_ENDIAN\"\n+  \"#\"\n+  [(set_attr \"length\" \"<insn_length>\")]\n+)\n+\n+;; Unpredicated structure moves (big-endian).  Memory accesses require\n+;; secondary reloads.\n+(define_insn \"*aarch64_sve_mov<mode>_le\"\n+  [(set (match_operand:SVE_STRUCT 0 \"register_operand\" \"=w, w\")\n+\t(match_operand:SVE_STRUCT 1 \"aarch64_nonmemory_operand\" \"w, Dn\"))]\n+  \"TARGET_SVE && BYTES_BIG_ENDIAN\"\n+  \"#\"\n+  [(set_attr \"length\" \"<insn_length>\")]\n+)\n+\n+;; Split unpredicated structure moves into pieces.  This is the same\n+;; for both big-endian and little-endian code, although it only needs\n+;; to handle memory operands for little-endian code.\n+(define_split\n+  [(set (match_operand:SVE_STRUCT 0 \"aarch64_sve_nonimmediate_operand\")\n+\t(match_operand:SVE_STRUCT 1 \"aarch64_sve_general_operand\"))]\n+  \"TARGET_SVE && reload_completed\"\n+  [(const_int 0)]\n+  {\n+    rtx dest = operands[0];\n+    rtx src = operands[1];\n+    if (REG_P (dest) && REG_P (src))\n+      aarch64_simd_emit_reg_reg_move (operands, <VSINGLE>mode, <vector_count>);\n+    else\n+      for (unsigned int i = 0; i < <vector_count>; ++i)\n+\t{\n+\t  rtx subdest = simplify_gen_subreg (<VSINGLE>mode, dest, <MODE>mode,\n+\t\t\t\t\t     i * BYTES_PER_SVE_VECTOR);\n+\t  rtx subsrc = simplify_gen_subreg (<VSINGLE>mode, src, <MODE>mode,\n+\t\t\t\t\t    i * BYTES_PER_SVE_VECTOR);\n+\t  emit_insn (gen_rtx_SET (subdest, subsrc));\n+\t}\n+    DONE;\n+  }\n+)\n+\n+;; Predicated structure moves.  This works for both endiannesses but in\n+;; practice is only useful for big-endian.\n+(define_insn_and_split \"pred_mov<mode>\"\n+  [(set (match_operand:SVE_STRUCT 0 \"aarch64_sve_struct_nonimmediate_operand\" \"=w, Utx\")\n+\t(unspec:SVE_STRUCT\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand:SVE_STRUCT 2 \"aarch64_sve_struct_nonimmediate_operand\" \"Utx, w\")]\n+\t  UNSPEC_MERGE_PTRUE))]\n+  \"TARGET_SVE\n+   && (register_operand (operands[0], <MODE>mode)\n+       || register_operand (operands[2], <MODE>mode))\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    for (unsigned int i = 0; i < <vector_count>; ++i)\n+      {\n+\trtx subdest = simplify_gen_subreg (<VSINGLE>mode, operands[0],\n+\t\t\t\t\t   <MODE>mode,\n+\t\t\t\t\t   i * BYTES_PER_SVE_VECTOR);\n+\trtx subsrc = simplify_gen_subreg (<VSINGLE>mode, operands[2],\n+\t\t\t\t\t  <MODE>mode,\n+\t\t\t\t\t  i * BYTES_PER_SVE_VECTOR);\n+\taarch64_emit_sve_pred_move (subdest, operands[1], subsrc);\n+      }\n+    DONE;\n+  }\n+  [(set_attr \"length\" \"<insn_length>\")]\n+)\n+\n (define_expand \"mov<mode>\"\n   [(set (match_operand:PRED_ALL 0 \"nonimmediate_operand\")\n \t(match_operand:PRED_ALL 1 \"general_operand\"))]\n@@ -460,6 +559,60 @@\n   }\n )\n \n+;; Unpredicated LD[234].\n+(define_expand \"vec_load_lanes<mode><vsingle>\"\n+  [(set (match_operand:SVE_STRUCT 0 \"register_operand\")\n+\t(unspec:SVE_STRUCT\n+\t  [(match_dup 2)\n+\t   (match_operand:SVE_STRUCT 1 \"memory_operand\")]\n+\t  UNSPEC_LDN))]\n+  \"TARGET_SVE\"\n+  {\n+    operands[2] = force_reg (<VPRED>mode, CONSTM1_RTX (<VPRED>mode));\n+  }\n+)\n+\n+;; Predicated LD[234].\n+(define_insn \"vec_mask_load_lanes<mode><vsingle>\"\n+  [(set (match_operand:SVE_STRUCT 0 \"register_operand\" \"=w\")\n+\t(unspec:SVE_STRUCT\n+\t  [(match_operand:<VPRED> 2 \"register_operand\" \"Upl\")\n+\t   (match_operand:SVE_STRUCT 1 \"memory_operand\" \"m\")]\n+\t  UNSPEC_LDN))]\n+  \"TARGET_SVE\"\n+  \"ld<vector_count><Vesize>\\t%0, %2/z, %1\"\n+)\n+\n+;; Unpredicated ST[234].  This is always a full update, so the dependence\n+;; on the old value of the memory location (via (match_dup 0)) is redundant.\n+;; There doesn't seem to be any obvious benefit to treating the all-true\n+;; case differently though.  In particular, it's very unlikely that we'll\n+;; only find out during RTL that a store_lanes is dead.\n+(define_expand \"vec_store_lanes<mode><vsingle>\"\n+  [(set (match_operand:SVE_STRUCT 0 \"memory_operand\")\n+\t(unspec:SVE_STRUCT\n+\t  [(match_dup 2)\n+\t   (match_operand:SVE_STRUCT 1 \"register_operand\")\n+\t   (match_dup 0)]\n+\t  UNSPEC_STN))]\n+  \"TARGET_SVE\"\n+  {\n+    operands[2] = force_reg (<VPRED>mode, CONSTM1_RTX (<VPRED>mode));\n+  }\n+)\n+\n+;; Predicated ST[234].\n+(define_insn \"vec_mask_store_lanes<mode><vsingle>\"\n+  [(set (match_operand:SVE_STRUCT 0 \"memory_operand\" \"+m\")\n+\t(unspec:SVE_STRUCT\n+\t  [(match_operand:<VPRED> 2 \"register_operand\" \"Upl\")\n+\t   (match_operand:SVE_STRUCT 1 \"register_operand\" \"w\")\n+\t   (match_dup 0)]\n+\t  UNSPEC_STN))]\n+  \"TARGET_SVE\"\n+  \"st<vector_count><Vesize>\\t%1, %2, %0\"\n+)\n+\n (define_expand \"vec_perm<mode>\"\n   [(match_operand:SVE_ALL 0 \"register_operand\")\n    (match_operand:SVE_ALL 1 \"register_operand\")"}, {"sha": "964cc540d85c9bbebdc25cfaabe520cdfcadc007", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -1178,9 +1178,15 @@ aarch64_classify_vector_mode (machine_mode mode)\n \t  || inner == DImode\n \t  || inner == DFmode))\n     {\n-      if (TARGET_SVE\n-\t  && known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR))\n-\treturn VEC_SVE_DATA;\n+      if (TARGET_SVE)\n+\t{\n+\t  if (known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR))\n+\t    return VEC_SVE_DATA;\n+\t  if (known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR * 2)\n+\t      || known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR * 3)\n+\t      || known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR * 4))\n+\t    return VEC_SVE_DATA | VEC_STRUCT;\n+\t}\n \n       /* This includes V1DF but not V1DI (which doesn't exist).  */\n       if (TARGET_SIMD\n@@ -1208,6 +1214,18 @@ aarch64_sve_data_mode_p (machine_mode mode)\n   return aarch64_classify_vector_mode (mode) & VEC_SVE_DATA;\n }\n \n+/* Implement target hook TARGET_ARRAY_MODE.  */\n+static opt_machine_mode\n+aarch64_array_mode (machine_mode mode, unsigned HOST_WIDE_INT nelems)\n+{\n+  if (aarch64_classify_vector_mode (mode) == VEC_SVE_DATA\n+      && IN_RANGE (nelems, 2, 4))\n+    return mode_for_vector (GET_MODE_INNER (mode),\n+\t\t\t    GET_MODE_NUNITS (mode) * nelems);\n+\n+  return opt_machine_mode ();\n+}\n+\n /* Implement target hook TARGET_ARRAY_MODE_SUPPORTED_P.  */\n static bool\n aarch64_array_mode_supported_p (machine_mode mode,\n@@ -5590,6 +5608,18 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t\t    ? offset_4bit_signed_scaled_p (mode, offset)\n \t\t    : offset_9bit_signed_scaled_p (mode, offset));\n \n+\t  if (vec_flags == (VEC_SVE_DATA | VEC_STRUCT))\n+\t    {\n+\t      poly_int64 end_offset = (offset\n+\t\t\t\t       + GET_MODE_SIZE (mode)\n+\t\t\t\t       - BYTES_PER_SVE_VECTOR);\n+\t      return (type == ADDR_QUERY_M\n+\t\t      ? offset_4bit_signed_scaled_p (mode, offset)\n+\t\t      : (offset_9bit_signed_scaled_p (SVE_BYTE_MODE, offset)\n+\t\t\t && offset_9bit_signed_scaled_p (SVE_BYTE_MODE,\n+\t\t\t\t\t\t\t end_offset)));\n+\t    }\n+\n \t  if (vec_flags == VEC_SVE_PRED)\n \t    return offset_9bit_signed_scaled_p (mode, offset);\n \n@@ -6302,6 +6332,20 @@ aarch64_print_vector_float_operand (FILE *f, rtx x, bool negate)\n   return true;\n }\n \n+/* Return the equivalent letter for size.  */\n+static char\n+sizetochar (int size)\n+{\n+  switch (size)\n+    {\n+    case 64: return 'd';\n+    case 32: return 's';\n+    case 16: return 'h';\n+    case 8 : return 'b';\n+    default: gcc_unreachable ();\n+    }\n+}\n+\n /* Print operand X to file F in a target specific manner according to CODE.\n    The acceptable formatting commands given by CODE are:\n      'c':\t\tAn integer or symbol address without a preceding #\n@@ -6589,7 +6633,18 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n \t{\n \tcase REG:\n \t  if (aarch64_sve_data_mode_p (GET_MODE (x)))\n-\t    asm_fprintf (f, \"z%d\", REGNO (x) - V0_REGNUM);\n+\t    {\n+\t      if (REG_NREGS (x) == 1)\n+\t\tasm_fprintf (f, \"z%d\", REGNO (x) - V0_REGNUM);\n+\t      else\n+\t\t{\n+\t\t  char suffix\n+\t\t    = sizetochar (GET_MODE_UNIT_BITSIZE (GET_MODE (x)));\n+\t\t  asm_fprintf (f, \"{z%d.%c - z%d.%c}\",\n+\t\t\t       REGNO (x) - V0_REGNUM, suffix,\n+\t\t\t       END_REGNO (x) - V0_REGNUM - 1, suffix);\n+\t\t}\n+\t    }\n \t  else\n \t    asm_fprintf (f, \"%s\", reg_names [REGNO (x)]);\n \t  break;\n@@ -12760,20 +12815,6 @@ aarch64_final_prescan_insn (rtx_insn *insn)\n }\n \n \n-/* Return the equivalent letter for size.  */\n-static char\n-sizetochar (int size)\n-{\n-  switch (size)\n-    {\n-    case 64: return 'd';\n-    case 32: return 's';\n-    case 16: return 'h';\n-    case 8 : return 'b';\n-    default: gcc_unreachable ();\n-    }\n-}\n-\n /* Return true if BASE_OR_STEP is a valid immediate operand for an SVE INDEX\n    instruction.  */\n \n@@ -13368,6 +13409,28 @@ aarch64_sve_ldr_operand_p (rtx op)\n \t  && addr.type == ADDRESS_REG_IMM);\n }\n \n+/* Return true if OP is a valid MEM operand for an SVE_STRUCT mode.\n+   We need to be able to access the individual pieces, so the range\n+   is different from LD[234] and ST[234].  */\n+bool\n+aarch64_sve_struct_memory_operand_p (rtx op)\n+{\n+  if (!MEM_P (op))\n+    return false;\n+\n+  machine_mode mode = GET_MODE (op);\n+  struct aarch64_address_info addr;\n+  if (!aarch64_classify_address (&addr, XEXP (op, 0), SVE_BYTE_MODE, false,\n+\t\t\t\t ADDR_QUERY_ANY)\n+      || addr.type != ADDRESS_REG_IMM)\n+    return false;\n+\n+  poly_int64 first = addr.const_offset;\n+  poly_int64 last = first + GET_MODE_SIZE (mode) - BYTES_PER_SVE_VECTOR;\n+  return (offset_4bit_signed_scaled_p (SVE_BYTE_MODE, first)\n+\t  && offset_4bit_signed_scaled_p (SVE_BYTE_MODE, last));\n+}\n+\n /* Emit a register copy from operand to operand, taking care not to\n    early-clobber source registers in the process.\n \n@@ -17376,6 +17439,9 @@ aarch64_libgcc_floating_mode_supported_p\n #define TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT \\\n   aarch64_builtin_support_vector_misalignment\n \n+#undef TARGET_ARRAY_MODE\n+#define TARGET_ARRAY_MODE aarch64_array_mode\n+\n #undef TARGET_ARRAY_MODE_SUPPORTED_P\n #define TARGET_ARRAY_MODE_SUPPORTED_P aarch64_array_mode_supported_p\n "}, {"sha": "33eff586c2aef033e7c6537fad7fb9daf3b83998", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -161,6 +161,8 @@\n     UNSPEC_PACK\n     UNSPEC_FLOAT_CONVERT\n     UNSPEC_WHILE_LO\n+    UNSPEC_LDN\n+    UNSPEC_STN\n ])\n \n (define_c_enum \"unspecv\" ["}, {"sha": "6cc4cadfd103313d9df75ac75005ee5c43f0be29", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -249,6 +249,12 @@\n   (and (match_code \"mem\")\n        (match_test \"aarch64_sve_ld1r_operand_p (op)\")))\n \n+(define_memory_constraint \"Utx\"\n+  \"@internal\n+   An address valid for SVE structure mov patterns (as distinct from\n+   LD[234] and ST[234] patterns).\"\n+  (match_operand 0 \"aarch64_sve_struct_memory_operand\"))\n+\n (define_constraint \"Ufc\"\n   \"A floating point constant which can be used with an\\\n    FMOV immediate operation.\""}, {"sha": "607f9c3027a37428fa9c7aad67c33a17f34142bc", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 97, "deletions": 6, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -250,6 +250,14 @@\n (define_mode_iterator SVE_ALL [VNx16QI VNx8HI VNx4SI VNx2DI\n \t\t\t       VNx8HF VNx4SF VNx2DF])\n \n+;; All SVE vector structure modes.\n+(define_mode_iterator SVE_STRUCT [VNx32QI VNx16HI VNx8SI VNx4DI\n+\t\t\t\t  VNx16HF VNx8SF VNx4DF\n+\t\t\t\t  VNx48QI VNx24HI VNx12SI VNx6DI\n+\t\t\t\t  VNx24HF VNx12SF VNx6DF\n+\t\t\t\t  VNx64QI VNx32HI VNx16SI VNx8DI\n+\t\t\t\t  VNx32HF VNx16SF VNx8DF])\n+\n ;; All SVE vector modes that have 8-bit or 16-bit elements.\n (define_mode_iterator SVE_BH [VNx16QI VNx8HI VNx8HF])\n \n@@ -604,9 +612,16 @@\n \n ;; Equivalent of \"size\" for a vector element.\n (define_mode_attr Vesize [(VNx16QI \"b\")\n-\t\t\t  (VNx8HI  \"h\") (VNx8HF \"h\")\n-\t\t\t  (VNx4SI  \"w\") (VNx4SF \"w\")\n-\t\t\t  (VNx2DI  \"d\") (VNx2DF \"d\")])\n+\t\t\t  (VNx8HI  \"h\") (VNx8HF  \"h\")\n+\t\t\t  (VNx4SI  \"w\") (VNx4SF  \"w\")\n+\t\t\t  (VNx2DI  \"d\") (VNx2DF  \"d\")\n+\t\t\t  (VNx32QI \"b\") (VNx48QI \"b\") (VNx64QI \"b\")\n+\t\t\t  (VNx16HI \"h\") (VNx24HI \"h\") (VNx32HI \"h\")\n+\t\t\t  (VNx16HF \"h\") (VNx24HF \"h\") (VNx32HF \"h\")\n+\t\t\t  (VNx8SI  \"w\") (VNx12SI \"w\") (VNx16SI \"w\")\n+\t\t\t  (VNx8SF  \"w\") (VNx12SF \"w\") (VNx16SF \"w\")\n+\t\t\t  (VNx4DI  \"d\") (VNx6DI  \"d\") (VNx8DI  \"d\")\n+\t\t\t  (VNx4DF  \"d\") (VNx6DF  \"d\") (VNx8DF  \"d\")])\n \n ;; Vetype is used everywhere in scheduling type and assembly output,\n ;; sometimes they are not the same, for example HF modes on some\n@@ -983,17 +998,93 @@\n \n (define_code_attr f16mac [(plus \"a\") (minus \"s\")])\n \n-;; The predicate mode associated with an SVE data mode.\n+;; The number of subvectors in an SVE_STRUCT.\n+(define_mode_attr vector_count [(VNx32QI \"2\") (VNx16HI \"2\")\n+\t\t\t\t(VNx8SI  \"2\") (VNx4DI  \"2\")\n+\t\t\t\t(VNx16HF \"2\") (VNx8SF  \"2\") (VNx4DF \"2\")\n+\t\t\t\t(VNx48QI \"3\") (VNx24HI \"3\")\n+\t\t\t\t(VNx12SI \"3\") (VNx6DI  \"3\")\n+\t\t\t\t(VNx24HF \"3\") (VNx12SF \"3\") (VNx6DF \"3\")\n+\t\t\t\t(VNx64QI \"4\") (VNx32HI \"4\")\n+\t\t\t\t(VNx16SI \"4\") (VNx8DI  \"4\")\n+\t\t\t\t(VNx32HF \"4\") (VNx16SF \"4\") (VNx8DF \"4\")])\n+\n+;; The number of instruction bytes needed for an SVE_STRUCT move.  This is\n+;; equal to vector_count * 4.\n+(define_mode_attr insn_length [(VNx32QI \"8\")  (VNx16HI \"8\")\n+\t\t\t       (VNx8SI  \"8\")  (VNx4DI  \"8\")\n+\t\t\t       (VNx16HF \"8\")  (VNx8SF  \"8\")  (VNx4DF \"8\")\n+\t\t\t       (VNx48QI \"12\") (VNx24HI \"12\")\n+\t\t\t       (VNx12SI \"12\") (VNx6DI  \"12\")\n+\t\t\t       (VNx24HF \"12\") (VNx12SF \"12\") (VNx6DF \"12\")\n+\t\t\t       (VNx64QI \"16\") (VNx32HI \"16\")\n+\t\t\t       (VNx16SI \"16\") (VNx8DI  \"16\")\n+\t\t\t       (VNx32HF \"16\") (VNx16SF \"16\") (VNx8DF \"16\")])\n+\n+;; The type of a subvector in an SVE_STRUCT.\n+(define_mode_attr VSINGLE [(VNx32QI \"VNx16QI\")\n+\t\t\t   (VNx16HI \"VNx8HI\") (VNx16HF \"VNx8HF\")\n+\t\t\t   (VNx8SI \"VNx4SI\") (VNx8SF \"VNx4SF\")\n+\t\t\t   (VNx4DI \"VNx2DI\") (VNx4DF \"VNx2DF\")\n+\t\t\t   (VNx48QI \"VNx16QI\")\n+\t\t\t   (VNx24HI \"VNx8HI\") (VNx24HF \"VNx8HF\")\n+\t\t\t   (VNx12SI \"VNx4SI\") (VNx12SF \"VNx4SF\")\n+\t\t\t   (VNx6DI \"VNx2DI\") (VNx6DF \"VNx2DF\")\n+\t\t\t   (VNx64QI \"VNx16QI\")\n+\t\t\t   (VNx32HI \"VNx8HI\") (VNx32HF \"VNx8HF\")\n+\t\t\t   (VNx16SI \"VNx4SI\") (VNx16SF \"VNx4SF\")\n+\t\t\t   (VNx8DI \"VNx2DI\") (VNx8DF \"VNx2DF\")])\n+\n+;; ...and again in lower case.\n+(define_mode_attr vsingle [(VNx32QI \"vnx16qi\")\n+\t\t\t   (VNx16HI \"vnx8hi\") (VNx16HF \"vnx8hf\")\n+\t\t\t   (VNx8SI \"vnx4si\") (VNx8SF \"vnx4sf\")\n+\t\t\t   (VNx4DI \"vnx2di\") (VNx4DF \"vnx2df\")\n+\t\t\t   (VNx48QI \"vnx16qi\")\n+\t\t\t   (VNx24HI \"vnx8hi\") (VNx24HF \"vnx8hf\")\n+\t\t\t   (VNx12SI \"vnx4si\") (VNx12SF \"vnx4sf\")\n+\t\t\t   (VNx6DI \"vnx2di\") (VNx6DF \"vnx2df\")\n+\t\t\t   (VNx64QI \"vnx16qi\")\n+\t\t\t   (VNx32HI \"vnx8hi\") (VNx32HF \"vnx8hf\")\n+\t\t\t   (VNx16SI \"vnx4si\") (VNx16SF \"vnx4sf\")\n+\t\t\t   (VNx8DI \"vnx2di\") (VNx8DF \"vnx2df\")])\n+\n+;; The predicate mode associated with an SVE data mode.  For structure modes\n+;; this is equivalent to the <VPRED> of the subvector mode.\n (define_mode_attr VPRED [(VNx16QI \"VNx16BI\")\n \t\t\t (VNx8HI \"VNx8BI\") (VNx8HF \"VNx8BI\")\n \t\t\t (VNx4SI \"VNx4BI\") (VNx4SF \"VNx4BI\")\n-\t\t\t (VNx2DI \"VNx2BI\") (VNx2DF \"VNx2BI\")])\n+\t\t\t (VNx2DI \"VNx2BI\") (VNx2DF \"VNx2BI\")\n+\t\t\t (VNx32QI \"VNx16BI\")\n+\t\t\t (VNx16HI \"VNx8BI\") (VNx16HF \"VNx8BI\")\n+\t\t\t (VNx8SI \"VNx4BI\") (VNx8SF \"VNx4BI\")\n+\t\t\t (VNx4DI \"VNx2BI\") (VNx4DF \"VNx2BI\")\n+\t\t\t (VNx48QI \"VNx16BI\")\n+\t\t\t (VNx24HI \"VNx8BI\") (VNx24HF \"VNx8BI\")\n+\t\t\t (VNx12SI \"VNx4BI\") (VNx12SF \"VNx4BI\")\n+\t\t\t (VNx6DI \"VNx2BI\") (VNx6DF \"VNx2BI\")\n+\t\t\t (VNx64QI \"VNx16BI\")\n+\t\t\t (VNx32HI \"VNx8BI\") (VNx32HF \"VNx8BI\")\n+\t\t\t (VNx16SI \"VNx4BI\") (VNx16SF \"VNx4BI\")\n+\t\t\t (VNx8DI \"VNx2BI\") (VNx8DF \"VNx2BI\")])\n \n ;; ...and again in lower case.\n (define_mode_attr vpred [(VNx16QI \"vnx16bi\")\n \t\t\t (VNx8HI \"vnx8bi\") (VNx8HF \"vnx8bi\")\n \t\t\t (VNx4SI \"vnx4bi\") (VNx4SF \"vnx4bi\")\n-\t\t\t (VNx2DI \"vnx2bi\") (VNx2DF \"vnx2bi\")])\n+\t\t\t (VNx2DI \"vnx2bi\") (VNx2DF \"vnx2bi\")\n+\t\t\t (VNx32QI \"vnx16bi\")\n+\t\t\t (VNx16HI \"vnx8bi\") (VNx16HF \"vnx8bi\")\n+\t\t\t (VNx8SI \"vnx4bi\") (VNx8SF \"vnx4bi\")\n+\t\t\t (VNx4DI \"vnx2bi\") (VNx4DF \"vnx2bi\")\n+\t\t\t (VNx48QI \"vnx16bi\")\n+\t\t\t (VNx24HI \"vnx8bi\") (VNx24HF \"vnx8bi\")\n+\t\t\t (VNx12SI \"vnx4bi\") (VNx12SF \"vnx4bi\")\n+\t\t\t (VNx6DI \"vnx2bi\") (VNx6DF \"vnx2bi\")\n+\t\t\t (VNx64QI \"vnx16bi\")\n+\t\t\t (VNx32HI \"vnx8bi\") (VNx32HF \"vnx4bi\")\n+\t\t\t (VNx16SI \"vnx4bi\") (VNx16SF \"vnx4bi\")\n+\t\t\t (VNx8DI \"vnx2bi\") (VNx8DF \"vnx2bi\")])\n \n ;; -------------------------------------------------------------------\n ;; Code Iterators"}, {"sha": "701789a08d13eb760d2a214c36920905eb8e8391", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -496,6 +496,14 @@\n \t    (match_operand 0 \"aarch64_sve_ldr_operand\")\n \t    (match_test \"aarch64_mov_operand_p (op, mode)\"))))\n \n+(define_predicate \"aarch64_sve_struct_memory_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"aarch64_sve_struct_memory_operand_p (op)\")))\n+\n+(define_predicate \"aarch64_sve_struct_nonimmediate_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sve_struct_memory_operand\")))\n+\n ;; Doesn't include immediates, since those are handled by the move\n ;; patterns instead.\n (define_predicate \"aarch64_sve_dup_operand\""}, {"sha": "02cd4181344b9232ca2e9af215223b9e38a29248", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -1,3 +1,27 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_load_lanes):\n+\tReturn true for SVE too.\n+\t* g++.dg/vect/pr36648.cc: XFAIL for variable-length vectors\n+\tif load/store lanes are supported.\n+\t* gcc.dg/vect/slp-10.c: Likewise.\n+\t* gcc.dg/vect/slp-12c.c: Likewise.\n+\t* gcc.dg/vect/slp-17.c: Likewise.\n+\t* gcc.dg/vect/slp-33.c: Likewise.\n+\t* gcc.dg/vect/slp-6.c: Likewise.\n+\t* gcc.dg/vect/slp-cond-1.c: Likewise.\n+\t* gcc.dg/vect/slp-multitypes-11-big-array.c: Likewise.\n+\t* gcc.dg/vect/slp-multitypes-11.c: Likewise.\n+\t* gcc.dg/vect/slp-multitypes-12.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-5.c: Remove XFAIL for variable-length SVE.\n+\t* gcc.dg/vect/slp-perm-6.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-9.c: Likewise.\n+\t* gcc.dg/vect/slp-reduc-6.c: Remove XFAIL for variable-length vectors.\n+\t* gcc.dg/vect/vect-load-lanes-peeling-1.c: Expect an epilogue loop\n+\tfor variable-length vectors.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8d24d3d445d5deacc2ec3af2074844df807ce639", "filename": "gcc/testsuite/g++.dg/vect/pr36648.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -25,6 +25,6 @@ int main() { }\n    targets, ! vect_no_align is a sufficient test.  */\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { { { !  vect_no_align } && { ! powerpc*-*-* } } || { powerpc*-*-* && vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { { { ! vect_no_align } && { ! powerpc*-*-* } } || { powerpc*-*-* && vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { { { ! vect_no_align } && { ! powerpc*-*-* } } || { powerpc*-*-* && vect_hw_misalign } } xfail { vect_variable_length && vect_load_lanes } } } } */\n \n "}, {"sha": "d5775ef737b17537da8891aa2c6c2dc73b7044a6", "filename": "gcc/testsuite/gcc.dg/vect/slp-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-10.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -107,7 +107,7 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target {vect_uintfloat_cvt && vect_int_mult} } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target {{! { vect_uintfloat_cvt}} && vect_int_mult} } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target {{! { vect_uintfloat_cvt}} && { ! {vect_int_mult}}} } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target { vect_uintfloat_cvt && vect_int_mult } xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target { vect_uintfloat_cvt && vect_int_mult } xfail { vect_variable_length && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  {target {{! { vect_uintfloat_cvt}} && vect_int_mult} } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  {target {{! { vect_uintfloat_cvt}} && { ! {vect_int_mult}}} } } } */\n   "}, {"sha": "df760327b5d99bbc15ed3a8e216a6d433154b2c5", "filename": "gcc/testsuite/gcc.dg/vect/slp-12c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12c.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -48,5 +48,5 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_int_mult } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  { target { ! vect_int_mult } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_int_mult xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_int_mult xfail { vect_variable_length && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target { ! vect_int_mult } } } } */"}, {"sha": "7f26884388a7dfe0a6831b1edd80f3e5ea8611f8", "filename": "gcc/testsuite/gcc.dg/vect/slp-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-17.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -51,5 +51,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail { vect_variable_length && vect_load_lanes } } } } */\n   "}, {"sha": "2404a5f19b407ef47d4ed6e597da9381629530ff", "filename": "gcc/testsuite/gcc.dg/vect/slp-33.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-33.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -105,7 +105,7 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target {vect_uintfloat_cvt && vect_int_mult} } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target {{! { vect_uintfloat_cvt}} && vect_int_mult} } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target {{! { vect_uintfloat_cvt}} && {! {vect_int_mult}}} } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target {vect_uintfloat_cvt && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target {vect_uintfloat_cvt && vect_int_mult} xfail { vect_variable_length && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  {target {{! { vect_uintfloat_cvt}} && vect_int_mult} } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  {target {{! { vect_uintfloat_cvt}} && {! {vect_int_mult}}} } } } */\n   "}, {"sha": "8205d542f4dcd222e3307d863b425f0324c62151", "filename": "gcc/testsuite/gcc.dg/vect/slp-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-6.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -116,6 +116,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target vect_int_mult} } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target  { ! { vect_int_mult } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target vect_int_mult xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target vect_int_mult xfail { vect_variable_length && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" {target  { ! { vect_int_mult } } } } } */\n   "}, {"sha": "fd9165fec812411a7e5fd8d47d298c72a9cb1975", "filename": "gcc/testsuite/gcc.dg/vect/slp-cond-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-1.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -122,4 +122,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail { vect_variable_length && vect_load_lanes } } } } */"}, {"sha": "a3d0670cea98379af381fd7282f28e9724096a93", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-11-big-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11-big-array.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -55,5 +55,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_unpack } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack xfail { vect_variable_length && vect_load_lanes } } } } */\n "}, {"sha": "5200ed1cd94948a8b5bad59b989d330de2c6bdba", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -49,5 +49,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_unpack } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack xfail { vect_variable_length && vect_load_lanes } } } } */\n   "}, {"sha": "d37434593d45526ee3391ecdd7862b48afb4420a", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-12.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -62,5 +62,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail { vect_variable_length && vect_load_lanes } } } } */\n   "}, {"sha": "52939133ca856d8ae20be81bef3c20e66fc285d2", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-5.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -104,9 +104,7 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* Fails for variable-length SVE because we fall back to Advanced SIMD\n-   and use LD3/ST3.  Will be fixed when SVE LOAD_LANES support is added.  */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } xfail { aarch64_sve && vect_variable_length } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && { ! vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "b7d7657939f07245214a6415033fcc807cbb1952", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-6.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -103,10 +103,8 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* Fails for variable-length SVE because we fall back to Advanced SIMD\n-   and use LD3/ST3.  Will be fixed when SVE LOAD_LANES support is added.  */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } xfail { aarch64_sve && vect_variable_length } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_load_lanes } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && { ! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_load_lanes xfail { vect_variable_length && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "b01d493b6e73e4700d5e4bf7137de4a3848c1f92", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-9.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -57,9 +57,7 @@ int main (int argc, const char* argv[])\n   return 0;\n }\n \n-/* Fails for variable-length SVE because we fall back to Advanced SIMD\n-   and use LD3/ST3.  Will be fixed when SVE LOAD_LANES support is added.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { vect_perm_short || vect_load_lanes } } xfail { aarch64_sve && vect_variable_length } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { vect_perm_short || vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_perm_short || vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target { vect_perm_short && { ! vect_perm3_short } } } } } */\n /* { dg-final { scan-tree-dump-not \"permutation requires at least three vectors\" \"vect\" { target vect_perm3_short } } } */"}, {"sha": "88591c5bdcbab0d066349b74503c3eb0a0a4cc8d", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-6.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -44,5 +44,5 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail { vect_no_int_add || { ! { vect_unpack || vect_strided2 } } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"different interleaving chains in one node\" 1 \"vect\" { target { ! vect_no_int_add } xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"different interleaving chains in one node\" 1 \"vect\" { target { ! vect_no_int_add } } } } */\n "}, {"sha": "447b32df97a5ccf2c80b9ef71cb5b5a191535caf", "filename": "gcc/testsuite/gcc.dg/vect/vect-load-lanes-peeling-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-load-lanes-peeling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-load-lanes-peeling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-load-lanes-peeling-1.c?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -10,4 +10,4 @@ f (int *__restrict a, int *__restrict b)\n }\n \n /* { dg-final { scan-tree-dump-not \"Data access with gaps\" \"vect\" } } */\n-/* { dg-final { scan-tree-dump-not \"epilog loop required\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"epilog loop required\" \"vect\" { xfail vect_variable_length } } } */"}, {"sha": "aedb7980da2e5ab205f2dcd699c9d7786dc6e616", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4cbab84d3bc5d4f35258cbc2e6df48d8821497/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=9f4cbab84d3bc5d4f35258cbc2e6df48d8821497", "patch": "@@ -6579,8 +6579,7 @@ proc check_effective_target_vect_load_lanes { } {\n     } else {\n \tset et_vect_load_lanes 0\n \tif { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])\n-\t     || ([istarget aarch64*-*-*]\n-\t\t && ![check_effective_target_aarch64_sve]) } {\n+\t     || [istarget aarch64*-*-*] } {\n \t    set et_vect_load_lanes 1\n \t}\n     }"}]}