{"sha": "8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRmODNlYWUxZWQ4ZjhmN2NmYjY1M2JkZWIxNGYyYjUwNzFkN2M0Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-04-01T03:50:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-04-01T03:50:43Z"}, "message": "builtins.c, [...]: Change most occurrences of TREE_UNSIGNED to TYPE_UNSIGNED.\n\n\t* builtins.c, c-aux-info.c, c-common.c, c-cppbuiltin.c, c-decl.c:\n\tChange most occurrences of TREE_UNSIGNED to TYPE_UNSIGNED.\n\t* c-format.c, c-opts.c, c-pretty-print.c, c-typeck.c: Likewise.\n\t* calls.c, convert.c, dbxout.c, dojump.c, dwarf2out.c: Likewise.\n\t* expmed.c, expr.c, fold-const.c, function.c, integrate.c: Likewise.\n\t* optabs.c, sdbout.c, stmt.c, stor-layout.c, tree-dump.c: Likewise.\n\t* tree.c, config/iq2000/iq2000.c, config/m32r/m32r.c: Likewise.\n\t* config/mips/mips.c, config/rs6000/rs6000.c: Likewise.\n\t* config/s390/s390.c, config/sparc/sparc.c, objc/objc-act.c: Likewise.\n\t* stor-layout.c (layout_type, case COMPLEX_TYPE): Test for\n\tREAL_TYPE, not INTEGER_TYPE.\n\t(layout_type, case VECTOR_TYPE): Simplify code.\n\t* tree.c (build_vector_type_for_mode): Remove dup unsigned setting.\n\t* tree.h: Update comments.\n\t(STRIP_NOPS): Use TYPE_UNSIGNED.\n\t(TYPE_UNSIGNED): New macro.\n\t(TYPE_TRAP_SIGNED): Remove now redundant check.\n\t(SAVE_EXPR_NOPLACEHOLDER): Don't use TREE_UNSIGNED.\n\n\t* cp/call.c (joust): Use TYPE_UNSIGNED, not TREE_UNSIGNED.\n\t* cp/class.c (check_bitfield_decl): Likewise.\n\t* cp/cvt.c (type_promotes_to): Likewise.\n\t* cp/decl.c (finish_enum): Likewise.\n\t* cp/mangle.c (write_builtin_type): Likewise.\n\t* cp/semantics.c (finish_switch_cond, finish_unary_op_expr): Likewise.\n\t* cp/typeck.c (type_after_usual_arithmetic_conversions): Likewise.\n\t(build_binary_op): Likewise.\n\n\t* f/com.c (ffecom_arrayref_): Use TYPE_UNSIGNED, not TREE_UNSIGNED.\n\t(ffecom_expr_): Likewise.\n\n\t* java/jcf-write.c (generate_bytecode_insns): Use TYPE_UNSIGNED.\n\n\t* treelang/treetree.c (tree_lang_signed_or_unsigned_type):\n\tUse TYPE_UNSIGNED, not TREE_UNSIGNED.\n\n\t* ada/decl.c (gnat_to_gnu_entity, make_type_from_size):\n\tUse TYPE_UNSIGNED, not TREE_UNSIGNED.\n\t* ada/trans.c (tree_transform, convert_with_check): Likewise.\n\t* ada/utils.c (gnat_signed_or_unsigned_type): Likewise.\n\t(build_vms_descriptor, unchecked_convert): Likewise.\n\t* ada/utils2.c (nonbinary_modular_operation): Likewise.\n\nFrom-SVN: r80287", "tree": {"sha": "cdd0771bc6e7a796038424b013a8a89e08667dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdd0771bc6e7a796038424b013a8a89e08667dea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/comments", "author": null, "committer": null, "parents": [{"sha": "d9175b871cddac9b9d3c7216bf3a8f665539d782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9175b871cddac9b9d3c7216bf3a8f665539d782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9175b871cddac9b9d3c7216bf3a8f665539d782"}], "stats": {"total": 711, "additions": 389, "deletions": 322}, "files": [{"sha": "c35a9cf1625f8ea0a78526948798bedf3dc847f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1,3 +1,24 @@\n+2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* builtins.c, c-aux-info.c, c-common.c, c-cppbuiltin.c, c-decl.c:\n+\tChange most occurrences of TREE_UNSIGNED to TYPE_UNSIGNED.\n+\t* c-format.c, c-opts.c, c-pretty-print.c, c-typeck.c: Likewise.\n+\t* calls.c, convert.c, dbxout.c, dojump.c, dwarf2out.c: Likewise.\n+\t* expmed.c, expr.c, fold-const.c, function.c, integrate.c: Likewise.\n+\t* optabs.c, sdbout.c, stmt.c, stor-layout.c, tree-dump.c: Likewise.\n+\t* tree.c, config/iq2000/iq2000.c, config/m32r/m32r.c: Likewise.\n+\t* config/mips/mips.c, config/rs6000/rs6000.c: Likewise.\n+\t* config/s390/s390.c, config/sparc/sparc.c, objc/objc-act.c: Likewise.\n+\t* stor-layout.c (layout_type, case COMPLEX_TYPE): Test for\n+\tREAL_TYPE, not INTEGER_TYPE.\n+\t(layout_type, case VECTOR_TYPE): Simplify code.\n+\t* tree.c (build_vector_type_for_mode): Remove dup unsigned setting.\n+\t* tree.h: Update comments.\n+\t(STRIP_NOPS): Use TYPE_UNSIGNED.\n+\t(TYPE_UNSIGNED): New macro.\n+\t(TYPE_TRAP_SIGNED): Remove now redundant check.\n+\t(SAVE_EXPR_NOPLACEHOLDER): Don't use TREE_UNSIGNED.\n+\n 2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* function.c (put_var_into_stack): Properly set orig_reg for indirect."}, {"sha": "5fe33e42659bf632bed22cbc571e07d8116df3b3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1,3 +1,12 @@\n+2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (gnat_to_gnu_entity, make_type_from_size):\n+\tUse TYPE_UNSIGNED, not TREE_UNSIGNED.\n+\t* trans.c (tree_transform, convert_with_check): Likewise.\n+\t* utils.c (gnat_signed_or_unsigned_type): Likewise.\n+\t(build_vms_descriptor, unchecked_convert): Likewise.\n+\t* utils2.c (nonbinary_modular_operation): Likewise.\n+\n 2004-03-29  Javier Miranda  <miranda@gnat.com>\n \n \t* checks.adb (Null_Exclusion_Static_Checks): New subprogram"}, {"sha": "c7b66c7f15e2df1be10114c33e12a2f691aa98db", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1221,7 +1221,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = TYPE_MODULAR_P (gnu_type)\n \t\t? gnu_high : TYPE_MAX_VALUE (gnu_type);\n \t    TYPE_PRECISION (gnu_subtype) = esize;\n-\t    TREE_UNSIGNED (gnu_subtype) = 1;\n+\t    TYPE_UNSIGNED (gnu_subtype) = 1;\n \t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n \t    TYPE_PACKED_ARRAY_TYPE_P (gnu_subtype)\n \t      = Is_Packed_Array_Type (gnat_entity);\n@@ -1299,8 +1299,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n      /* This should be an unsigned type if the lower bound is constant\n \t and non-negative or if the base type is unsigned; a signed type\n \t otherwise.    */\n-      TREE_UNSIGNED (gnu_type)\n-\t= (TREE_UNSIGNED (TREE_TYPE (gnu_type))\n+      TYPE_UNSIGNED (gnu_type)\n+\t= (TYPE_UNSIGNED (TREE_TYPE (gnu_type))\n \t   || (TREE_CODE (TYPE_MIN_VALUE (gnu_type)) == INTEGER_CST\n \t       && TREE_INT_CST_HIGH (TYPE_MIN_VALUE (gnu_type)) >= 0)\n \t   || TYPE_BIASED_REPRESENTATION_P (gnu_type)\n@@ -1806,7 +1806,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      else if (TREE_CODE (gnu_high) == INTEGER_CST\n \t\t       && TREE_OVERFLOW (gnu_high))\n \t\tgnu_high = gnu_max;\n-\t      else if (TREE_UNSIGNED (gnu_base_subtype)\n+\t      else if (TYPE_UNSIGNED (gnu_base_subtype)\n \t\t       || TREE_CODE (gnu_high) == INTEGER_CST)\n \t\tgnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n \t      else\n@@ -2081,8 +2081,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t= TYPE_MAX_VALUE (gnu_inner_type);\n \t\t      TYPE_PRECISION (gnu_subtype)\n \t\t\t= TYPE_PRECISION (gnu_inner_type);\n-\t\t      TREE_UNSIGNED (gnu_subtype)\n-\t\t\t= TREE_UNSIGNED (gnu_inner_type);\n+\t\t      TYPE_UNSIGNED (gnu_subtype)\n+\t\t\t= TYPE_UNSIGNED (gnu_inner_type);\n \t\t      TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n \t\t      layout_type (gnu_subtype);\n \n@@ -6010,8 +6010,8 @@ make_type_from_size (tree type, tree size_tree, int biased_p)\n \t= ((TREE_CODE (type) == INTEGER_TYPE\n \t    && TYPE_BIASED_REPRESENTATION_P (type))\n \t   || biased_p);\n-      TREE_UNSIGNED (new_type)\n-\t= TREE_UNSIGNED (type) | TYPE_BIASED_REPRESENTATION_P (new_type);\n+      TYPE_UNSIGNED (new_type)\n+\t= TYPE_UNSIGNED (type) | TYPE_BIASED_REPRESENTATION_P (new_type);\n       TYPE_RM_SIZE_INT (new_type) = bitsize_int (size);\n       return new_type;\n "}, {"sha": "efa99fe0169d33bd05ac8d58a657f0d1e7a4050e", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1886,10 +1886,10 @@ tree_transform (Node_Id gnat_node)\n \t/* For right shifts, the type says what kind of shift to do,\n \t   so we may need to choose a different type.  */\n \tif (Nkind (gnat_node) == N_Op_Shift_Right\n-\t    && ! TREE_UNSIGNED (gnu_type))\n+\t    && ! TYPE_UNSIGNED (gnu_type))\n \t  gnu_type = gnat_unsigned_type (gnu_type);\n \telse if (Nkind (gnat_node) == N_Op_Shift_Right_Arithmetic\n-\t\t && TREE_UNSIGNED (gnu_type))\n+\t\t && TYPE_UNSIGNED (gnu_type))\n \t  gnu_type = gnat_signed_type (gnu_type);\n \n \tif (gnu_type != gnu_result_type)\n@@ -4729,17 +4729,17 @@ convert_with_check (Entity_Id gnat_type,\n       /* Convert the lower bounds to signed types, so we're sure we're\n \t comparing them properly.  Likewise, convert the upper bounds\n \t to unsigned types.  */\n-      if (INTEGRAL_TYPE_P (gnu_in_basetype) && TREE_UNSIGNED (gnu_in_basetype))\n+      if (INTEGRAL_TYPE_P (gnu_in_basetype) && TYPE_UNSIGNED (gnu_in_basetype))\n \tgnu_in_lb = convert (gnat_signed_type (gnu_in_basetype), gnu_in_lb);\n \n       if (INTEGRAL_TYPE_P (gnu_in_basetype)\n-\t  && ! TREE_UNSIGNED (gnu_in_basetype))\n+\t  && !TYPE_UNSIGNED (gnu_in_basetype))\n \tgnu_in_ub = convert (gnat_unsigned_type (gnu_in_basetype), gnu_in_ub);\n \n-      if (INTEGRAL_TYPE_P (gnu_base_type) && TREE_UNSIGNED (gnu_base_type))\n+      if (INTEGRAL_TYPE_P (gnu_base_type) && TYPE_UNSIGNED (gnu_base_type))\n \tgnu_out_lb = convert (gnat_signed_type (gnu_base_type), gnu_out_lb);\n \n-      if (INTEGRAL_TYPE_P (gnu_base_type) && ! TREE_UNSIGNED (gnu_base_type))\n+      if (INTEGRAL_TYPE_P (gnu_base_type) && !TYPE_UNSIGNED (gnu_base_type))\n \tgnu_out_ub = convert (gnat_unsigned_type (gnu_base_type), gnu_out_ub);\n \n       /* Check each bound separately and only if the result bound"}, {"sha": "3fba0c0848795afaebb1a35d04d469720720950a", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2118,7 +2118,7 @@ gnat_signed_type (tree type_node)\n tree\n gnat_signed_or_unsigned_type (int unsignedp, tree type)\n {\n-  if (! INTEGRAL_TYPE_P (type) || TREE_UNSIGNED (type) == unsignedp)\n+  if (! INTEGRAL_TYPE_P (type) || TYPE_UNSIGNED (type) == unsignedp)\n     return type;\n   else\n     return gnat_type_for_size (TYPE_PRECISION (type), unsignedp);\n@@ -2355,19 +2355,19 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n \t  {\n \t  case 8:\n-\t    dtype = TREE_UNSIGNED (type) ? 2 : 6;\n+\t    dtype = TYPE_UNSIGNED (type) ? 2 : 6;\n \t    break;\n \t  case 16:\n-\t    dtype = TREE_UNSIGNED (type) ? 3 : 7;\n+\t    dtype = TYPE_UNSIGNED (type) ? 3 : 7;\n \t    break;\n \t  case 32:\n-\t    dtype = TREE_UNSIGNED (type) ? 4 : 8;\n+\t    dtype = TYPE_UNSIGNED (type) ? 4 : 8;\n \t    break;\n \t  case 64:\n-\t    dtype = TREE_UNSIGNED (type) ? 5 : 9;\n+\t    dtype = TYPE_UNSIGNED (type) ? 5 : 9;\n \t    break;\n \t  case 128:\n-\t    dtype = TREE_UNSIGNED (type) ? 25 : 26;\n+\t    dtype = TYPE_UNSIGNED (type) ? 25 : 26;\n \t    break;\n \t  }\n       break;\n@@ -3388,15 +3388,15 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n       && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n \t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (type)))\n       && ! (INTEGRAL_TYPE_P (etype)\n-\t    && TREE_UNSIGNED (type) == TREE_UNSIGNED (etype)\n+\t    && TYPE_UNSIGNED (type) == TYPE_UNSIGNED (etype)\n \t    && operand_equal_p (TYPE_RM_SIZE (type),\n \t\t\t\t(TYPE_RM_SIZE (etype) != 0\n \t\t\t\t ? TYPE_RM_SIZE (etype) : TYPE_SIZE (etype)),\n \t\t\t\t0))\n-      && ! (TREE_UNSIGNED (type) && TREE_UNSIGNED (etype)))\n+      && ! (TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))\n     {\n       tree base_type = gnat_type_for_mode (TYPE_MODE (type),\n-\t\t\t\t\t   TREE_UNSIGNED (type));\n+\t\t\t\t\t   TYPE_UNSIGNED (type));\n       tree shift_expr\n \t= convert (base_type,\n \t\t   size_binop (MINUS_EXPR,"}, {"sha": "453841b8eccd7db7b7028050222f92dcf649b559", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -512,7 +512,7 @@ nonbinary_modular_operation (enum tree_code op_code,\n   /* If our type is the wrong signedness or isn't wide enough, make a new\n      type and convert both our operands to it.  */\n   if (TYPE_PRECISION (op_type) < precision\n-      || TREE_UNSIGNED (op_type) != unsignedp)\n+      || TYPE_UNSIGNED (op_type) != unsignedp)\n     {\n       /* Copy the node so we ensure it can be modified to make it modular.  */\n       op_type = copy_node (gnat_type_for_size (precision, unsignedp));"}, {"sha": "33df5eca6846c8f4f1b95219d20eab0b72b98b64", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -3166,7 +3166,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n \t\t\t       XEXP (arg1_rtx, 0), Pmode,\n \t\t\t       XEXP (arg2_rtx, 0), Pmode,\n \t\t\t       convert_to_mode (TYPE_MODE (sizetype), arg3_rtx,\n-\t\t\t\t\t\tTREE_UNSIGNED (sizetype)),\n+\t\t\t\t\t\tTYPE_UNSIGNED (sizetype)),\n \t\t\t       TYPE_MODE (sizetype));\n \n     /* Return the value in the proper mode for this function.  */"}, {"sha": "70c85a225d8a4ed15b786126524a5dc13ecb6b22", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -430,7 +430,7 @@ gen_type (const char *ret_val, tree t, formals_style style)\n           data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n           /* Normally, `unsigned' is part of the deal.  Not so if it comes\n \t     with a type qualifier.  */\n-          if (TREE_UNSIGNED (t) && TYPE_QUALS (t))\n+          if (TYPE_UNSIGNED (t) && TYPE_QUALS (t))\n \t    data_type = concat (\"unsigned \", data_type, NULL);\n \t  break;\n "}, {"sha": "a3904cac7c060d0fdde63399e5894e933e154be4", "filename": "gcc/c-common.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1248,7 +1248,7 @@ unsigned_conversion_warning (tree result, tree operand)\n \n   if (TREE_CODE (operand) == INTEGER_CST\n       && TREE_CODE (type) == INTEGER_TYPE\n-      && TREE_UNSIGNED (type)\n+      && TYPE_UNSIGNED (type)\n       && skip_evaluation == 0\n       && !int_fits_type_p (operand, type))\n     {\n@@ -1292,13 +1292,13 @@ convert_and_check (tree type, tree expr)\n \t  TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (expr);\n \n \t  /* No warning for converting 0x80000000 to int.  */\n-\t  if (!(TREE_UNSIGNED (type) < TREE_UNSIGNED (TREE_TYPE (expr))\n+\t  if (!(TYPE_UNSIGNED (type) < TYPE_UNSIGNED (TREE_TYPE (expr))\n \t\t&& TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n \t\t&& TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (expr))))\n \t    /* If EXPR fits in the unsigned version of TYPE,\n \t       don't warn unless pedantic.  */\n \t    if ((pedantic\n-\t\t || TREE_UNSIGNED (type)\n+\t\t || TYPE_UNSIGNED (type)\n \t\t || ! constant_fits_type_p (expr,\n \t\t\t\t\t    c_common_unsigned_type (type)))\n \t        && skip_evaluation == 0)\n@@ -1963,7 +1963,7 @@ tree\n c_common_signed_or_unsigned_type (int unsignedp, tree type)\n {\n   if (! INTEGRAL_TYPE_P (type)\n-      || TREE_UNSIGNED (type) == unsignedp)\n+      || TYPE_UNSIGNED (type) == unsignedp)\n     return type;\n \n   /* Must check the mode of the types, not the precision.  Enumeral types\n@@ -2148,9 +2148,9 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n      but it *requires* conversion to FINAL_TYPE.  */\n \n   if (op0 == primop0 && TREE_TYPE (op0) != *restype_ptr)\n-    unsignedp0 = TREE_UNSIGNED (TREE_TYPE (op0));\n+    unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n   if (op1 == primop1 && TREE_TYPE (op1) != *restype_ptr)\n-    unsignedp1 = TREE_UNSIGNED (TREE_TYPE (op1));\n+    unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n \n   /* If one of the operands must be floated, we cannot optimize.  */\n   real1 = TREE_CODE (TREE_TYPE (primop0)) == REAL_TYPE;\n@@ -2222,7 +2222,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n       int min_gt, max_gt, min_lt, max_lt;\n       tree maxval, minval;\n       /* 1 if comparison is nominally unsigned.  */\n-      int unsignedp = TREE_UNSIGNED (*restype_ptr);\n+      int unsignedp = TYPE_UNSIGNED (*restype_ptr);\n       tree val;\n \n       type = c_common_signed_or_unsigned_type (unsignedp0,\n@@ -2379,7 +2379,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n     {\n       type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1));\n       type = c_common_signed_or_unsigned_type (unsignedp0\n-\t\t\t\t\t       || TREE_UNSIGNED (*restype_ptr),\n+\t\t\t\t\t       || TYPE_UNSIGNED (*restype_ptr),\n \t\t\t\t\t       type);\n       /* Make sure shorter operand is extended the right way\n \t to match the longer operand.  */\n@@ -2401,7 +2401,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n       primop1 = op1;\n \n       if (!real1 && !real2 && integer_zerop (primop1)\n-\t  && TREE_UNSIGNED (*restype_ptr))\n+\t  && TYPE_UNSIGNED (*restype_ptr))\n \t{\n \t  tree value = 0;\n \t  switch (code)\n@@ -2502,7 +2502,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n       /* If the constant is unsigned, and smaller than the pointer size,\n \t then we must skip this optimization.  This is because it could cause\n \t an overflow error if the constant is negative but INTOP is not.  */\n-      && (! TREE_UNSIGNED (TREE_TYPE (intop))\n+      && (! TYPE_UNSIGNED (TREE_TYPE (intop))\n \t  || (TYPE_PRECISION (TREE_TYPE (intop))\n \t      == TYPE_PRECISION (TREE_TYPE (ptrop)))))\n     {\n@@ -2522,9 +2522,9 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      so the multiply won't overflow spuriously.  */\n \n   if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype)\n-      || TREE_UNSIGNED (TREE_TYPE (intop)) != TREE_UNSIGNED (sizetype))\n+      || TYPE_UNSIGNED (TREE_TYPE (intop)) != TYPE_UNSIGNED (sizetype))\n     intop = convert (c_common_type_for_size (TYPE_PRECISION (sizetype),\n-\t\t\t\t\t     TREE_UNSIGNED (sizetype)), intop);\n+\t\t\t\t\t     TYPE_UNSIGNED (sizetype)), intop);\n \n   /* Replace the integer argument with a suitable product by the object size.\n      Do this multiplication as signed, then convert to the appropriate\n@@ -2821,7 +2821,7 @@ c_common_get_alias_set (tree t)\n   /* The C standard specifically allows aliasing between signed and\n      unsigned variants of the same type.  We treat the signed\n      variant as canonical.  */\n-  if (TREE_CODE (t) == INTEGER_TYPE && TREE_UNSIGNED (t))\n+  if (TREE_CODE (t) == INTEGER_TYPE && TYPE_UNSIGNED (t))\n     {\n       tree t1 = c_common_signed_type (t);\n \n@@ -3220,7 +3220,7 @@ c_common_nodes_and_builtins (void)\n   wchar_type_size = TYPE_PRECISION (wchar_type_node);\n   if (c_dialect_cxx ())\n     {\n-      if (TREE_UNSIGNED (wchar_type_node))\n+      if (TYPE_UNSIGNED (wchar_type_node))\n \twchar_type_node = make_unsigned_type (wchar_type_size);\n       else\n \twchar_type_node = make_signed_type (wchar_type_size);\n@@ -4608,7 +4608,7 @@ handle_mode_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n \t  warning (\"use __attribute__ ((vector_size)) instead\");\n \t}\n \n-      typefm = lang_hooks.types.type_for_mode (mode, TREE_UNSIGNED (type));\n+      typefm = lang_hooks.types.type_for_mode (mode, TYPE_UNSIGNED (type));\n       if (typefm == NULL_TREE)\n \terror (\"no data type for mode `%s'\", p);\n "}, {"sha": "84bd6f5f9094a2cc38dee22ddf3a0e020216e975", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -401,7 +401,7 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (!flag_signed_char)\n     cpp_define (pfile, \"__CHAR_UNSIGNED__\");\n \n-  if (c_dialect_cxx () && TREE_UNSIGNED (wchar_type_node))\n+  if (c_dialect_cxx () && TYPE_UNSIGNED (wchar_type_node))\n     cpp_define (pfile, \"__WCHAR_UNSIGNED__\");\n \n   /* Make the choice of ObjC runtime visible to source code.  */\n@@ -581,8 +581,8 @@ builtin_define_type_max (const char *macro, tree type, int is_long)\n     default:    abort ();\n     }\n \n-  value = values[idx + TREE_UNSIGNED (type)];\n-  suffix = suffixes[is_long * 2 + TREE_UNSIGNED (type)];\n+  value = values[idx + TYPE_UNSIGNED (type)];\n+  suffix = suffixes[is_long * 2 + TYPE_UNSIGNED (type)];\n \n   buf = alloca (strlen (macro) + 1 + strlen (value) + strlen (suffix) + 1);\n   sprintf (buf, \"%s=%s%s\", macro, value, suffix);"}, {"sha": "871592a357f47127e30e242d48d1340a7004e04b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -3295,8 +3295,9 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n     w = tree_low_cst (*width, 1);\n \n   if (TREE_CODE (*type) == ENUMERAL_TYPE\n-      && (w < min_precision (TYPE_MIN_VALUE (*type), TREE_UNSIGNED (*type))\n-\t  || w < min_precision (TYPE_MAX_VALUE (*type), TREE_UNSIGNED (*type))))\n+      && (w < min_precision (TYPE_MIN_VALUE (*type), TYPE_UNSIGNED (*type))\n+\t  || w < min_precision (TYPE_MAX_VALUE (*type),\n+\t\t\t\tTYPE_UNSIGNED (*type))))\n     warning (\"`%s' is narrower than values of its type\", name);\n }\n \f\n@@ -4910,7 +4911,7 @@ xref_tag (enum tree_code code, tree name)\n       TYPE_MODE (ref) = TYPE_MODE (unsigned_type_node);\n       TYPE_ALIGN (ref) = TYPE_ALIGN (unsigned_type_node);\n       TYPE_USER_ALIGN (ref) = 0;\n-      TREE_UNSIGNED (ref) = 1;\n+      TYPE_UNSIGNED (ref) = 1;\n       TYPE_PRECISION (ref) = TYPE_PRECISION (unsigned_type_node);\n       TYPE_MIN_VALUE (ref) = TYPE_MIN_VALUE (unsigned_type_node);\n       TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);\n@@ -5427,7 +5428,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   TYPE_MIN_VALUE (enumtype) = minnode;\n   TYPE_MAX_VALUE (enumtype) = maxnode;\n   TYPE_PRECISION (enumtype) = precision;\n-  TREE_UNSIGNED (enumtype) = unsign;\n+  TYPE_UNSIGNED (enumtype) = unsign;\n   TYPE_SIZE (enumtype) = 0;\n   layout_type (enumtype);\n \n@@ -5479,7 +5480,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       TYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n       TYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n       TYPE_USER_ALIGN (tem) = TYPE_USER_ALIGN (enumtype);\n-      TREE_UNSIGNED (tem) = TREE_UNSIGNED (enumtype);\n+      TYPE_UNSIGNED (tem) = TYPE_UNSIGNED (enumtype);\n     }\n \n   /* Finish debugging output for this type.  */\n@@ -5551,7 +5552,7 @@ build_enumerator (tree name, tree value)\n \t\t\t\t      TYPE_PRECISION (integer_type_node)),\n \t\t\t\t (TYPE_PRECISION (type)\n \t\t\t\t  >= TYPE_PRECISION (integer_type_node)\n-\t\t\t\t  && TREE_UNSIGNED (type)));\n+\t\t\t\t  && TYPE_UNSIGNED (type)));\n \n   decl = build_decl (CONST_DECL, name, type);\n   DECL_INITIAL (decl) = convert (type, value);\n@@ -5770,7 +5771,7 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   if (c_promoting_integer_type_p (restype))\n     {\n       /* It retains unsignedness if not really getting wider.  */\n-      if (TREE_UNSIGNED (restype)\n+      if (TYPE_UNSIGNED (restype)\n \t  && (TYPE_PRECISION (restype)\n \t\t  == TYPE_PRECISION (integer_type_node)))\n \trestype = unsigned_type_node;"}, {"sha": "3a51c6b63b426b9a683cc3b5b61fd65bdc683ae1", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2390,7 +2390,7 @@ check_format_types (int *status, format_wanted_type *types)\n       if (TREE_CODE (wanted_type) == INTEGER_TYPE\n \t  && TREE_CODE (cur_type) == INTEGER_TYPE\n \t  && (! pedantic || i == 0 || (i == 1 && char_type_flag))\n-\t  && (TREE_UNSIGNED (wanted_type)\n+\t  && (TYPE_UNSIGNED (wanted_type)\n \t      ? wanted_type == c_common_unsigned_type (cur_type)\n \t      : wanted_type == c_common_signed_type (cur_type)))\n \tcontinue;"}, {"sha": "7aa21c4458f57bbd389efc68549b0e27671c82b5", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1193,7 +1193,7 @@ c_common_init (void)\n   cpp_opts->char_precision = TYPE_PRECISION (char_type_node);\n   cpp_opts->int_precision = TYPE_PRECISION (integer_type_node);\n   cpp_opts->wchar_precision = TYPE_PRECISION (wchar_type_node);\n-  cpp_opts->unsigned_wchar = TREE_UNSIGNED (wchar_type_node);\n+  cpp_opts->unsigned_wchar = TYPE_UNSIGNED (wchar_type_node);\n   cpp_opts->bytes_big_endian = BYTES_BIG_ENDIAN;\n \n   /* This can't happen until after wchar_precision and bytes_big_endian"}, {"sha": "5673d73c7c1cfde29d02c30870ca9ea0a4636713", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -291,7 +291,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n       if (TYPE_NAME (t))\n         t = TYPE_NAME (t);\n       else\n-        t = c_common_type_for_mode (TYPE_MODE (t), TREE_UNSIGNED (t));\n+        t = c_common_type_for_mode (TYPE_MODE (t), TYPE_UNSIGNED (t));\n       pp_c_type_specifier (pp, t);\n       break;\n \n@@ -767,7 +767,7 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n                TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n       pp_string (pp, pp_buffer (pp)->digit_buffer);\n     }\n-  if (TREE_UNSIGNED (type))\n+  if (TYPE_UNSIGNED (type))\n     pp_character (pp, 'u');\n   if (type == long_integer_type_node || type == long_unsigned_type_node)\n     pp_character (pp, 'l');\n@@ -785,8 +785,8 @@ pp_c_character_constant (c_pretty_printer *pp, tree c)\n   if (type == wchar_type_node)\n     pp_character (pp, 'L'); \n   pp_quote (pp);\n-  if (host_integerp (c, TREE_UNSIGNED (type)))\n-    pp_c_char (pp, tree_low_cst (c, TREE_UNSIGNED (type)));\n+  if (host_integerp (c, TYPE_UNSIGNED (type)))\n+    pp_c_char (pp, tree_low_cst (c, TYPE_UNSIGNED (type)));\n   else\n     pp_scalar (pp, \"\\\\x%x\", (unsigned) TREE_INT_CST_LOW (c));\n   pp_quote (pp);"}, {"sha": "9bd63e571a28e64e0e366b0f0071544d97c36dd2", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -180,7 +180,7 @@ c_type_promotes_to (tree type)\n   if (c_promoting_integer_type_p (type))\n     {\n       /* Preserve unsignedness if not really getting any wider.  */\n-      if (TREE_UNSIGNED (type)\n+      if (TYPE_UNSIGNED (type)\n           && (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n         return unsigned_type_node;\n       return integer_type_node;\n@@ -286,7 +286,7 @@ common_type (tree t1, tree t2)\n \t{\n \t  /* But preserve unsignedness from the other type,\n \t     since long cannot hold all the values of an unsigned int.  */\n-\t  if (TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n+\t  if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n \t     t1 = long_unsigned_type_node;\n \t  else\n \t     t1 = long_integer_type_node;\n@@ -301,7 +301,7 @@ common_type (tree t1, tree t2)\n \n       /* Otherwise prefer the unsigned one.  */\n \n-      if (TREE_UNSIGNED (t1))\n+      if (TYPE_UNSIGNED (t1))\n \treturn build_type_attribute_variant (t1, attributes);\n       else\n \treturn build_type_attribute_variant (t2, attributes);\n@@ -477,9 +477,9 @@ comptypes (tree type1, tree type2, int flags)\n      are compatible with each other only if they are the same type.  */\n \n   if (TREE_CODE (t1) == ENUMERAL_TYPE && TREE_CODE (t2) != ENUMERAL_TYPE)\n-    t1 = c_common_type_for_size (TYPE_PRECISION (t1), TREE_UNSIGNED (t1));\n+    t1 = c_common_type_for_size (TYPE_PRECISION (t1), TYPE_UNSIGNED (t1));\n   else if (TREE_CODE (t2) == ENUMERAL_TYPE && TREE_CODE (t1) != ENUMERAL_TYPE)\n-    t2 = c_common_type_for_size (TYPE_PRECISION (t2), TREE_UNSIGNED (t2));\n+    t2 = c_common_type_for_size (TYPE_PRECISION (t2), TYPE_UNSIGNED (t2));\n \n   if (t1 == t2)\n     return 1;\n@@ -1189,7 +1189,7 @@ default_conversion (tree exp)\n \t\t\t\t\t  TYPE_PRECISION (integer_type_node)),\n \t\t\t\t     ((TYPE_PRECISION (type)\n \t\t\t\t       >= TYPE_PRECISION (integer_type_node))\n-\t\t\t\t      && TREE_UNSIGNED (type)));\n+\t\t\t\t      && TYPE_UNSIGNED (type)));\n \n       return convert (type, exp);\n     }\n@@ -1205,7 +1205,7 @@ default_conversion (tree exp)\n   if (c_promoting_integer_type_p (type))\n     {\n       /* Preserve unsignedness if not really getting any wider.  */\n-      if (TREE_UNSIGNED (type)\n+      if (TYPE_UNSIGNED (type)\n \t  && TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n \treturn convert (unsigned_type_node, exp);\n \n@@ -1908,7 +1908,7 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n \t\t\t;\n \t\t      else if (formal_prec != TYPE_PRECISION (type1))\n \t\t\twarn_for_assignment (\"%s with different width due to prototype\", (char *) 0, name, parmnum + 1);\n-\t\t      else if (TREE_UNSIGNED (type) == TREE_UNSIGNED (type1))\n+\t\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n \t\t\t;\n \t\t      /* Don't complain if the formal parameter type\n \t\t\t is an enum, because we can't tell now whether\n@@ -1930,9 +1930,9 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n \t\t\t pass it as signed or unsigned; the value\n \t\t\t certainly is the same either way.  */\n \t\t      else if (TYPE_PRECISION (TREE_TYPE (val)) < TYPE_PRECISION (type)\n-\t\t\t       && TREE_UNSIGNED (TREE_TYPE (val)))\n+\t\t\t       && TYPE_UNSIGNED (TREE_TYPE (val)))\n \t\t\t;\n-\t\t      else if (TREE_UNSIGNED (type))\n+\t\t      else if (TYPE_UNSIGNED (type))\n \t\t\twarn_for_assignment (\"%s as unsigned due to prototype\", (char *) 0, name, parmnum + 1);\n \t\t      else\n \t\t\twarn_for_assignment (\"%s as signed due to prototype\", (char *) 0, name, parmnum + 1);\n@@ -2701,15 +2701,15 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \t will be considered, but default promotions won't.  */\n       if (warn_sign_compare && !skip_evaluation)\n \t{\n-\t  int unsigned_op1 = TREE_UNSIGNED (TREE_TYPE (orig_op1));\n-\t  int unsigned_op2 = TREE_UNSIGNED (TREE_TYPE (orig_op2));\n+\t  int unsigned_op1 = TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n+\t  int unsigned_op2 = TYPE_UNSIGNED (TREE_TYPE (orig_op2));\n \n \t  if (unsigned_op1 ^ unsigned_op2)\n \t    {\n \t      /* Do not warn if the result type is signed, since the\n \t\t signed type will only be chosen if it can represent\n \t\t all the values of the unsigned type.  */\n-\t      if (! TREE_UNSIGNED (result_type))\n+\t      if (! TYPE_UNSIGNED (result_type))\n \t\t/* OK */;\n \t      /* Do not warn if the signed quantity is an unsuffixed\n \t\t integer literal (or some static constant expression\n@@ -5281,7 +5281,7 @@ set_nonincremental_init_from_string (tree str)\n \t    }\n \t}\n \n-      if (!TREE_UNSIGNED (type))\n+      if (!TYPE_UNSIGNED (type))\n \t{\n \t  bitpos = ((wchar_bytes - 1) * charwidth) + HOST_BITS_PER_CHAR;\n \t  if (bitpos < HOST_BITS_PER_WIDE_INT)\n@@ -6512,7 +6512,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t       undefined if the quotient can't be represented in the\n \t       computation mode.  We shorten only if unsigned or if\n \t       dividing by something we know != -1.  */\n-\t    shorten = (TREE_UNSIGNED (TREE_TYPE (orig_op0))\n+\t    shorten = (TYPE_UNSIGNED (TREE_TYPE (orig_op0))\n \t\t       || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t   && ! integer_all_onesp (op1)));\n \t  common = 1;\n@@ -6539,7 +6539,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     on some targets, since the modulo instruction is undefined if the\n \t     quotient can't be represented in the computation mode.  We shorten\n \t     only if unsigned or if dividing by something we know != -1.  */\n-\t  shorten = (TREE_UNSIGNED (TREE_TYPE (orig_op0))\n+\t  shorten = (TYPE_UNSIGNED (TREE_TYPE (orig_op0))\n \t\t     || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t && ! integer_all_onesp (op1)));\n \t  common = 1;\n@@ -6828,7 +6828,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  tree arg0 = get_narrower (op0, &unsigned0);\n \t  tree arg1 = get_narrower (op1, &unsigned1);\n \t  /* UNS is 1 if the operation to be done is an unsigned one.  */\n-\t  int uns = TREE_UNSIGNED (result_type);\n+\t  int uns = TYPE_UNSIGNED (result_type);\n \t  tree type;\n \n \t  final_type = result_type;\n@@ -6839,11 +6839,11 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if ((TYPE_PRECISION (TREE_TYPE (op0))\n \t       == TYPE_PRECISION (TREE_TYPE (arg0)))\n \t      && TREE_TYPE (op0) != final_type)\n-\t    unsigned0 = TREE_UNSIGNED (TREE_TYPE (op0));\n+\t    unsigned0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n \t  if ((TYPE_PRECISION (TREE_TYPE (op1))\n \t       == TYPE_PRECISION (TREE_TYPE (arg1)))\n \t      && TREE_TYPE (op1) != final_type)\n-\t    unsigned1 = TREE_UNSIGNED (TREE_TYPE (op1));\n+\t    unsigned1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n \n \t  /* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */\n \n@@ -6898,14 +6898,14 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  final_type = result_type;\n \n \t  if (arg0 == op0 && final_type == TREE_TYPE (op0))\n-\t    unsigned_arg = TREE_UNSIGNED (TREE_TYPE (op0));\n+\t    unsigned_arg = TYPE_UNSIGNED (TREE_TYPE (op0));\n \n \t  if (TYPE_PRECISION (TREE_TYPE (arg0)) < TYPE_PRECISION (result_type)\n \t      /* We can shorten only if the shift count is less than the\n \t\t number of bits in the smaller type size.  */\n \t      && compare_tree_int (op1, TYPE_PRECISION (TREE_TYPE (arg0))) < 0\n \t      /* We cannot drop an unsigned shift after sign-extension.  */\n-\t      && (!TREE_UNSIGNED (final_type) || unsigned_arg))\n+\t      && (!TYPE_UNSIGNED (final_type) || unsigned_arg))\n \t    {\n \t      /* Do an unsigned shift if the operand was zero-extended.  */\n \t      result_type\n@@ -6941,8 +6941,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \t  if (warn_sign_compare && skip_evaluation == 0)\n \t    {\n-\t      int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n-\t      int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n+\t      int op0_signed = ! TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n+\t      int op1_signed = ! TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n \t      int unsignedp0, unsignedp1;\n \t      tree primop0 = get_narrower (op0, &unsignedp0);\n \t      tree primop1 = get_narrower (op1, &unsignedp1);\n@@ -6961,7 +6961,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t Do not warn if the comparison is being done in a signed type,\n \t\t since the signed type will only be chosen if it can represent\n \t\t all the values of the unsigned type.  */\n-\t      if (! TREE_UNSIGNED (result_type))\n+\t      if (! TYPE_UNSIGNED (result_type))\n \t\t/* OK */;\n               /* Do not warn if both operands are the same signedness.  */\n               else if (op0_signed == op1_signed)"}, {"sha": "d8ffb058cb57dd66269d99b4345c125129617581", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1195,7 +1195,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t}\n \n       mode = TYPE_MODE (type);\n-      unsignedp = TREE_UNSIGNED (type);\n+      unsignedp = TYPE_UNSIGNED (type);\n \n       if (targetm.calls.promote_function_args (fndecl ? TREE_TYPE (fndecl) : 0))\n \tmode = promote_mode (type, mode, &unsignedp, 1);\n@@ -3346,7 +3346,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n \t{\n \t  tree type = TREE_TYPE (exp);\n-\t  int unsignedp = TREE_UNSIGNED (type);\n+\t  int unsignedp = TYPE_UNSIGNED (type);\n \t  int offset = 0;\n \n \t  /* If we don't promote as expected, something is wrong.  */"}, {"sha": "41d4a0e17975d055bb604f471fe6594d0d06a077", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2657,7 +2657,7 @@ iq2000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n {\n   int reg = GP_RETURN;\n   enum machine_mode mode = TYPE_MODE (valtype);\n-  int unsignedp = TREE_UNSIGNED (valtype);\n+  int unsignedp = TYPE_UNSIGNED (valtype);\n \n   /* Since we define TARGET_PROMOTE_FUNCTION_RETURN that returns true,\n      we must promote the mode just as PROMOTE_MODE does.  */"}, {"sha": "734d75743c11df190dc0d1bf51013911139edd73", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2758,13 +2758,13 @@ block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n \t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n-\t\t\t\t      TREE_UNSIGNED (sizetype)),\n+\t\t\t\t      TYPE_UNSIGNED (sizetype)),\n \t\t     TYPE_MODE (sizetype));\n #else\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"bcopy\"), 0,\n \t\t     VOIDmode, 3, src_reg, Pmode, dest_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (integer_type_node), bytes_rtx,\n-\t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n+\t\t\t\t      TYPE_UNSIGNED (integer_type_node)),\n \t\t     TYPE_MODE (integer_type_node));\n #endif\n }"}, {"sha": "de0d9874f4ac35e89d9558b7c60cc1c835ae6d60", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -7509,7 +7509,7 @@ mips_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n       int unsignedp;\n \n       mode = TYPE_MODE (valtype);\n-      unsignedp = TREE_UNSIGNED (valtype);\n+      unsignedp = TYPE_UNSIGNED (valtype);\n \n       /* Since we define TARGET_PROMOTE_FUNCTION_RETURN that returns\n \t true, we must promote the mode just as PROMOTE_MODE does.  */"}, {"sha": "f92a12c85b4d6647b36653e4355d7e9eb96490e6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -14916,7 +14916,7 @@ rs6000_handle_altivec_attribute (tree *node, tree name, tree args,\n   switch (altivec_type)\n     {\n     case 'v':\n-      unsigned_p = TREE_UNSIGNED (type);\n+      unsigned_p = TYPE_UNSIGNED (type);\n       switch (mode)\n \t{\n \t  case SImode:"}, {"sha": "63fc3e57c9af6021fd5e010600d7662075b0a381", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -6127,7 +6127,7 @@ s390_function_value (tree type, enum machine_mode mode)\n {\n   if (type)\n     {\n-      int unsignedp = TREE_UNSIGNED (type);\n+      int unsignedp = TYPE_UNSIGNED (type);\n       mode = promote_mode (type, TYPE_MODE (type), &unsignedp, 1);\n     }\n "}, {"sha": "bdb9ed40eefd80e0f26b9399ddc2a4bdf6e08cbe", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -7323,7 +7323,7 @@ sparc_type_code (register tree type)\n \n \t  /* Carefully distinguish all the standard types of C,\n \t     without messing up if the language is not C.  We do this by\n-\t     testing TYPE_PRECISION and TREE_UNSIGNED.  The old code used to\n+\t     testing TYPE_PRECISION and TYPE_UNSIGNED.  The old code used to\n \t     look at both the names and the above fields, but that's redundant.\n \t     Any type whose size is between two C types will be considered\n \t     to be the wider of the two types.  Also, we do not have a\n@@ -7333,16 +7333,16 @@ sparc_type_code (register tree type)\n \t     size, but that's fine, since neither can the assembler.  */\n \n \t  if (TYPE_PRECISION (type) <= CHAR_TYPE_SIZE)\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 12 : 2));\n+\t    return (qualifiers | (TYPE_UNSIGNED (type) ? 12 : 2));\n   \n \t  else if (TYPE_PRECISION (type) <= SHORT_TYPE_SIZE)\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 13 : 3));\n+\t    return (qualifiers | (TYPE_UNSIGNED (type) ? 13 : 3));\n   \n \t  else if (TYPE_PRECISION (type) <= INT_TYPE_SIZE)\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 14 : 4));\n+\t    return (qualifiers | (TYPE_UNSIGNED (type) ? 14 : 4));\n   \n \t  else\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 15 : 5));\n+\t    return (qualifiers | (TYPE_UNSIGNED (type) ? 15 : 5));\n   \n \tcase REAL_TYPE:\n \t  /* If this is a range type, consider it to be the underlying"}, {"sha": "dcab84a9aa9466e155097bf43d315d10681bc88c", "filename": "gcc/convert.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -397,7 +397,7 @@ convert_to_integer (tree type, tree expr)\n \t     conversion necessitates an explicit sign-extension.  In\n \t     the signed-to-unsigned case the high-order bits have to\n \t     be cleared.  */\n-\t  if (TREE_UNSIGNED (type) != TREE_UNSIGNED (TREE_TYPE (expr))\n+\t  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (TREE_TYPE (expr))\n \t      && (TYPE_PRECISION (TREE_TYPE (expr))\n \t\t  != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (expr)))))\n \t    code = CONVERT_EXPR;\n@@ -415,7 +415,7 @@ convert_to_integer (tree type, tree expr)\n \t       || outprec != GET_MODE_BITSIZE (TYPE_MODE (type)))\n \treturn build1 (NOP_EXPR, type,\n \t\t       convert (lang_hooks.types.type_for_mode\n-\t\t\t\t(TYPE_MODE (type), TREE_UNSIGNED (type)),\n+\t\t\t\t(TYPE_MODE (type), TYPE_UNSIGNED (type)),\n \t\t\t\texpr));\n \n       /* Here detect when we can distribute the truncation down past some\n@@ -456,7 +456,7 @@ convert_to_integer (tree type, tree expr)\n \t     the target type is unsigned.  */\n \t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n \t      && tree_int_cst_sgn (TREE_OPERAND (expr, 1)) >= 0\n-\t      && TREE_UNSIGNED (type)\n+\t      && TYPE_UNSIGNED (type)\n \t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n \t    {\n \t      /* If shift count is less than the width of the truncated type,\n@@ -498,8 +498,8 @@ convert_to_integer (tree type, tree expr)\n \t\t&& outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n \t\t/* If signedness of arg0 and arg1 don't match,\n \t\t   we can't necessarily find a type to compare them in.  */\n-\t\t&& (TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t    == TREE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\t&& (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t    == TYPE_UNSIGNED (TREE_TYPE (arg1))))\n \t      goto trunc1;\n \t    break;\n \t  }\n@@ -527,7 +527,7 @@ convert_to_integer (tree type, tree expr)\n \t\t   so use an integer type that will hold the values.  */\n \t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n \t\t  typex = lang_hooks.types.type_for_size\n-\t\t    (TYPE_PRECISION (typex), TREE_UNSIGNED (typex));\n+\t\t    (TYPE_PRECISION (typex), TYPE_UNSIGNED (typex));\n \n \t\t/* But now perhaps TYPEX is as wide as INPREC.\n \t\t   In that case, do nothing special here.\n@@ -545,9 +545,9 @@ convert_to_integer (tree type, tree expr)\n \t\t       signed-overflow undefinedness.\n \t\t       And we may need to do it as unsigned\n \t\t       if we truncate to the original size.  */\n-\t\t    if (TREE_UNSIGNED (TREE_TYPE (expr))\n-\t\t\t|| (TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t    && (TREE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t    if (TYPE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t|| (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t\t    && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n \t\t\t\t|| ex_form == LSHIFT_EXPR\n \t\t\t\t|| ex_form == RSHIFT_EXPR\n \t\t\t\t|| ex_form == LROTATE_EXPR\n@@ -576,7 +576,7 @@ convert_to_integer (tree type, tree expr)\n \t       so use an integer type that will hold the values.  */\n \t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n \t      typex = lang_hooks.types.type_for_size\n-\t\t(TYPE_PRECISION (typex), TREE_UNSIGNED (typex));\n+\t\t(TYPE_PRECISION (typex), TYPE_UNSIGNED (typex));\n \n \t    /* But now perhaps TYPEX is as wide as INPREC.\n \t       In that case, do nothing special here.\n@@ -585,7 +585,7 @@ convert_to_integer (tree type, tree expr)\n \t      {\n \t\t/* Don't do unsigned arithmetic where signed was wanted,\n \t\t   or vice versa.  */\n-\t\tif (TREE_UNSIGNED (TREE_TYPE (expr)))\n+\t\tif (TYPE_UNSIGNED (TREE_TYPE (expr)))\n \t\t  typex = lang_hooks.types.unsigned_type (typex);\n \t\telse\n \t\t  typex = lang_hooks.types.signed_type (typex);"}, {"sha": "077fcef09854689a05a93741c5f700b5043f7ab2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1,3 +1,14 @@\n+2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* call.c (joust): Use TYPE_UNSIGNED, not TREE_UNSIGNED.\n+\t* class.c (check_bitfield_decl): Likewise.\n+\t* cvt.c (type_promotes_to): Likewise.\n+\t* decl.c (finish_enum): Likewise.\n+\t* mangle.c (write_builtin_type): Likewise.\n+\t* semantics.c (finish_switch_cond, finish_unary_op_expr): Likewise.\n+\t* typeck.c (type_after_usual_arithmetic_conversions): Likewise.\n+\t(build_binary_op): Likewise.\n+\n 2004-03-31  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.h (optimize_function): Kill prototype."}, {"sha": "56e089dd2e4a849efb446c8ba44ba8d2f7932c58", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -5922,7 +5922,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t      && TREE_CODE (t2->type) == INTEGER_TYPE\n \t      && (TYPE_PRECISION (t1->type)\n \t\t  == TYPE_PRECISION (t2->type))\n-\t      && (TREE_UNSIGNED (t1->u.next->type)\n+\t      && (TYPE_UNSIGNED (t1->u.next->type)\n \t\t  || (TREE_CODE (t1->u.next->type)\n \t\t      == ENUMERAL_TYPE)))\n \t    {"}, {"sha": "fe49e267eae5032d6ee3ce84213e5f56865e6259", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2710,11 +2710,11 @@ check_bitfield_decl (tree field)\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n \t       && (0 > compare_tree_int (w,\n \t\t\t\t\t min_precision (TYPE_MIN_VALUE (type),\n-\t\t\t\t\t\t\tTREE_UNSIGNED (type)))\n+\t\t\t\t\t\t\tTYPE_UNSIGNED (type)))\n \t\t   ||  0 > compare_tree_int (w,\n \t\t\t\t\t     min_precision\n \t\t\t\t\t     (TYPE_MAX_VALUE (type),\n-\t\t\t\t\t      TREE_UNSIGNED (type)))))\n+\t\t\t\t\t      TYPE_UNSIGNED (type)))))\n \tcp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n \t\t       field, type);\n     }\n@@ -6906,15 +6906,13 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   return inits;\n }\n \n-/* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo\n-   for the base in most derived. DATA is a TREE_LIST who's\n-   TREE_CHAIN is the type of the base being\n-   constructed whilst this secondary vptr is live.  The TREE_UNSIGNED\n-   flag of DATA indicates that this is a constructor vtable.  The\n+/* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo for the base\n+   in most derived. DATA is a TREE_LIST who's TREE_CHAIN is the type of the\n+   base being constructed whilst this secondary vptr is live.  The\n    TREE_TOP_LEVEL flag indicates that this is the primary VTT.  */\n \n static tree\n-dfs_build_secondary_vptr_vtt_inits (tree binfo, void* data)\n+dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data)\n {\n   tree l; \n   tree t;"}, {"sha": "bf906fd969e1c65484f2684e4442fc9db38376a1", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1116,7 +1116,7 @@ type_promotes_to (tree type)\n       int precision = MAX (TYPE_PRECISION (type),\n \t\t\t   TYPE_PRECISION (integer_type_node));\n       tree totype = c_common_type_for_size (precision, 0);\n-      if (TREE_UNSIGNED (type)\n+      if (TYPE_UNSIGNED (type)\n \t  && ! int_fits_type_p (TYPE_MAX_VALUE (type), totype))\n \ttype = c_common_type_for_size (precision, 1);\n       else\n@@ -1125,7 +1125,7 @@ type_promotes_to (tree type)\n   else if (c_promoting_integer_type_p (type))\n     {\n       /* Retain unsignedness if really not getting bigger.  */\n-      if (TREE_UNSIGNED (type)\n+      if (TYPE_UNSIGNED (type)\n \t  && TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n \ttype = unsigned_type_node;\n       else"}, {"sha": "4570d8b7549a1d5e7e724c4db2558e8aea5882f5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -9759,7 +9759,7 @@ finish_enum (tree enumtype)\n     {\n       underlying_type = integer_types[itk];\n       if (TYPE_PRECISION (underlying_type) >= precision\n-\t  && TREE_UNSIGNED (underlying_type) == unsignedp)\n+\t  && TYPE_UNSIGNED (underlying_type) == unsignedp)\n \tbreak;\n     }\n   if (itk == itk_none)\n@@ -9796,7 +9796,7 @@ finish_enum (tree enumtype)\n   TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n   TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n   TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n-  TREE_UNSIGNED (enumtype) = TREE_UNSIGNED (underlying_type);\n+  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n \n   /* Convert each of the enumerators to the type of the underlying\n      type of the enumeration.  */\n@@ -9822,7 +9822,7 @@ finish_enum (tree enumtype)\n       TYPE_PRECISION (t) = TYPE_PRECISION (enumtype);\n       TYPE_ALIGN (t) = TYPE_ALIGN (enumtype);\n       TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (enumtype);\n-      TREE_UNSIGNED (t) = TREE_UNSIGNED (enumtype);\n+      TYPE_UNSIGNED (t) = TYPE_UNSIGNED (enumtype);\n     }\n \n   /* Finish debugging output for this type.  */"}, {"sha": "81ac4ad1b220c92ac5b55ea29fce35cbf54b82ec", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1693,11 +1693,11 @@ write_builtin_type (tree type)\n \t  if (itk == itk_none)\n \t    {\n \t      tree t = c_common_type_for_mode (TYPE_MODE (type),\n-\t\t\t\t\t       TREE_UNSIGNED (type));\n+\t\t\t\t\t       TYPE_UNSIGNED (type));\n \t      if (type == t)\n \t\t{\n \t\t  if (TYPE_PRECISION (type) == 128)\n-\t\t    write_char (TREE_UNSIGNED (type) ? 'o' : 'n');\n+\t\t    write_char (TYPE_UNSIGNED (type) ? 'o' : 'n');\n \t\t  else\n \t\t    /* Couldn't find this type.  */\n \t\t    abort ();"}, {"sha": "6e15e61131750b6ff14979e762d9cd0147e5cd66", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -766,8 +766,8 @@ finish_switch_cond (tree cond, tree switch_stmt)\n \t     because if we did, int_fits_type_p would do the wrong thing\n \t     when checking case values for being in range,\n \t     and it's too hard to do the right thing.  */\n-\t  if (TREE_UNSIGNED (TREE_TYPE (cond))\n-\t      == TREE_UNSIGNED (TREE_TYPE (index)))\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (cond))\n+\t      == TYPE_UNSIGNED (TREE_TYPE (index)))\n \t    cond = index;\n \t}\n     }\n@@ -1838,7 +1838,7 @@ finish_unary_op_expr (enum tree_code code, tree expr)\n      setting TREE_NEGATED_INT.  */\n   if (code == NEGATE_EXPR && TREE_CODE (expr) == INTEGER_CST\n       && TREE_CODE (result) == INTEGER_CST\n-      && !TREE_UNSIGNED (TREE_TYPE (result))\n+      && !TYPE_UNSIGNED (TREE_TYPE (result))\n       && INT_CST_LT (result, integer_zero_node))\n     TREE_NEGATED_INT (result) = 1;\n   overflow_warning (result);"}, {"sha": "a0145a0d0ad5e0a709d6d892a366c9a06cf8eb03", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -347,7 +347,7 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n       if (same_type_p (TYPE_MAIN_VARIANT (t1), long_long_integer_type_node)\n \t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_long_integer_type_node))\n \t{\n-\t  tree t = ((TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n+\t  tree t = ((TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n \t\t    ? long_long_unsigned_type_node \n \t\t    : long_long_integer_type_node);\n \t  return build_type_attribute_variant (t, attributes);\n@@ -361,12 +361,12 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n       if (same_type_p (TYPE_MAIN_VARIANT (t1), long_integer_type_node)\n \t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_integer_type_node))\n \t{\n-\t  tree t = ((TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n+\t  tree t = ((TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n \t\t    ? long_unsigned_type_node : long_integer_type_node);\n \t  return build_type_attribute_variant (t, attributes);\n \t}\n       /* Otherwise prefer the unsigned one.  */\n-      if (TREE_UNSIGNED (t1))\n+      if (TYPE_UNSIGNED (t1))\n \treturn build_type_attribute_variant (t1, attributes);\n       else\n \treturn build_type_attribute_variant (t2, attributes);\n@@ -2872,7 +2872,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t       point, so we have to dig out the original type to find out if\n \t       it was unsigned.  */\n \t    shorten = ((TREE_CODE (op0) == NOP_EXPR\n-\t\t\t&& TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n+\t\t\t&& TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t\t       || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t   && ! integer_all_onesp (op1)));\n \n@@ -2901,7 +2901,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     quotient can't be represented in the computation mode.  We shorten\n \t     only if unsigned or if dividing by something we know != -1.  */\n \t  shorten = ((TREE_CODE (op0) == NOP_EXPR\n-\t\t      && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n+\t\t      && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t\t     || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t && ! integer_all_onesp (op1)));\n \t  common = 1;\n@@ -3160,7 +3160,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  tree arg0 = get_narrower (op0, &unsigned0);\n \t  tree arg1 = get_narrower (op1, &unsigned1);\n \t  /* UNS is 1 if the operation to be done is an unsigned one.  */\n-\t  int uns = TREE_UNSIGNED (result_type);\n+\t  int uns = TYPE_UNSIGNED (result_type);\n \t  tree type;\n \n \t  final_type = result_type;\n@@ -3169,9 +3169,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     but it *requires* conversion to FINAL_TYPE.  */\n \n \t  if (op0 == arg0 && TREE_TYPE (op0) != final_type)\n-\t    unsigned0 = TREE_UNSIGNED (TREE_TYPE (op0));\n+\t    unsigned0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n \t  if (op1 == arg1 && TREE_TYPE (op1) != final_type)\n-\t    unsigned1 = TREE_UNSIGNED (TREE_TYPE (op1));\n+\t    unsigned1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n \n \t  /* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */\n \n@@ -3223,7 +3223,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  final_type = result_type;\n \n \t  if (arg0 == op0 && final_type == TREE_TYPE (op0))\n-\t    unsigned_arg = TREE_UNSIGNED (TREE_TYPE (op0));\n+\t    unsigned_arg = TYPE_UNSIGNED (TREE_TYPE (op0));\n \n \t  if (TYPE_PRECISION (TREE_TYPE (arg0)) < TYPE_PRECISION (result_type)\n \t      /* We can shorten only if the shift count is less than the\n@@ -3236,7 +3236,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t ones made by sign-extension and bring in zeros.\n \t\t We can't optimize that case at all, but in most machines\n \t\t it never happens because available widths are 2**N.  */\n-\t      && (!TREE_UNSIGNED (final_type)\n+\t      && (!TYPE_UNSIGNED (final_type)\n \t\t  || unsigned_arg\n \t\t  || (((unsigned) 2 * TYPE_PRECISION (TREE_TYPE (arg0)))\n \t\t      <= TYPE_PRECISION (result_type))))\n@@ -3278,8 +3278,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     bound the ranges of the arguments until that point.  */\n \t  && !processing_template_decl)\n \t{\n-\t  int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n-\t  int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n+\t  int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n+\t  int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n \n \t  int unsignedp0, unsignedp1;\n \t  tree primop0 = get_narrower (op0, &unsignedp0);\n@@ -3303,7 +3303,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  /* Do not warn if the comparison is being done in a signed type,\n \t     since the signed type will only be chosen if it can represent\n \t     all the values of the unsigned type.  */\n-\t  if (! TREE_UNSIGNED (result_type))\n+\t  if (!TYPE_UNSIGNED (result_type))\n \t    /* OK */;\n \t  /* Do not warn if both operands are unsigned.  */\n \t  else if (op0_signed == op1_signed)\n@@ -5557,10 +5557,9 @@ dubious_conversion_warnings (tree type, tree expr,\n     }\n   /* And warn about assigning a negative value to an unsigned\n      variable.  */\n-  else if (TREE_UNSIGNED (type) && TREE_CODE (type) != BOOLEAN_TYPE)\n+  else if (TYPE_UNSIGNED (type) && TREE_CODE (type) != BOOLEAN_TYPE)\n     {\n-      if (TREE_CODE (expr) == INTEGER_CST\n-\t  && TREE_NEGATED_INT (expr))\n+      if (TREE_CODE (expr) == INTEGER_CST && TREE_NEGATED_INT (expr))\n \t{\n \t  if (fndecl)\n \t    warning (\"passing negative value `%E' for %s %P of `%D'\","}, {"sha": "1118a1826908427c25c248e830fa80a4f48b2703", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1384,7 +1384,7 @@ dbxout_type (tree type, int full)\n       break;\n \n     case INTEGER_TYPE:\n-      if (type == char_type_node && ! TREE_UNSIGNED (type))\n+      if (type == char_type_node && ! TYPE_UNSIGNED (type))\n \t{\n \t  /* Output the type `char' as a subrange of itself!\n \t     I don't understand this definition, just copied it\n@@ -1492,7 +1492,7 @@ dbxout_type (tree type, int full)\n \t  fprintf (asmfile, \"r\");\n \t  CHARS (1);\n \t  dbxout_type_index (char_type_node);\n-\t  fprintf (asmfile, \";0;%d;\", TREE_UNSIGNED (type) ? 255 : 127);\n+\t  fprintf (asmfile, \";0;%d;\", TYPE_UNSIGNED (type) ? 255 : 127);\n \t  CHARS (7);\n \t}\n       break;\n@@ -1914,10 +1914,10 @@ print_int_cst_bounds_in_octal_p (tree type)\n       && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n       && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n \t  || ((TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n-\t      && TREE_UNSIGNED (type))\n+\t      && TYPE_UNSIGNED (type))\n \t  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT\n \t  || (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT\n-\t      && TREE_UNSIGNED (type))))\n+\t      && TYPE_UNSIGNED (type))))\n     return TRUE;\n   else\n     return FALSE;"}, {"sha": "eb98e76e4a86011fba94d9e28b39aa8a5869eebc", "filename": "gcc/dojump.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -642,7 +642,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t\ttemp = copy_to_reg (temp);\n \t    }\n \t  do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n-\t\t\t\t   NE, TREE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t\t   NE, TYPE_UNSIGNED (TREE_TYPE (exp)),\n \t\t\t\t   GET_MODE (temp), NULL_RTX,\n \t\t\t\t   if_false_label, if_true_label);\n \t}\n@@ -672,9 +672,10 @@ do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,\n   rtx op0 = expand_expr (TREE_OPERAND (exp, swap), NULL_RTX, VOIDmode, 0);\n   rtx op1 = expand_expr (TREE_OPERAND (exp, !swap), NULL_RTX, VOIDmode, 0);\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  int unsignedp = TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \n-  do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true_label);\n+  do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,\n+\t\t\t\tif_true_label);\n }\n \n /* Compare OP0 with OP1, word at a time, in mode MODE.\n@@ -747,7 +748,7 @@ do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)\n   for (i = 0; i < nwords; i++)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n                              operand_subword_force (op1, i, mode),\n-                             EQ, TREE_UNSIGNED (TREE_TYPE (exp)),\n+                             EQ, TYPE_UNSIGNED (TREE_TYPE (exp)),\n                              word_mode, NULL_RTX, if_false_label, NULL_RTX);\n \n   if (if_true_label)\n@@ -1017,7 +1018,7 @@ do_compare_and_jump (tree exp, enum rtx_code signed_code,\n       type = TREE_TYPE (TREE_OPERAND (exp, 1));\n       mode = TYPE_MODE (type);\n     }\n-  unsignedp = TREE_UNSIGNED (type);\n+  unsignedp = TYPE_UNSIGNED (type);\n   code = unsignedp ? unsigned_code : signed_code;\n \n #ifdef HAVE_canonicalize_funcptr_for_compare"}, {"sha": "86512a4f8f5f8d4e74a62e9263492c2a484b458e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -7853,7 +7853,7 @@ base_type_die (tree type)\n \t\t || ! strcmp (type_name, \"signed char\")\n \t\t || ! strcmp (type_name, \"unsigned char\"))))\n \t{\n-\t  if (TREE_UNSIGNED (type))\n+\t  if (TYPE_UNSIGNED (type))\n \t    encoding = DW_ATE_unsigned;\n \t  else\n \t    encoding = DW_ATE_signed;\n@@ -7863,7 +7863,7 @@ base_type_die (tree type)\n \n     case CHAR_TYPE:\n       /* GNU Pascal/Ada CHAR type.  Not used in C.  */\n-      if (TREE_UNSIGNED (type))\n+      if (TYPE_UNSIGNED (type))\n \tencoding = DW_ATE_unsigned_char;\n       else\n \tencoding = DW_ATE_signed_char;\n@@ -8729,7 +8729,7 @@ loc_descriptor_from_tree (tree loc, int addressp)\n {\n   dw_loc_descr_ref ret, ret1;\n   int indirect_p = 0;\n-  int unsignedp = TREE_UNSIGNED (TREE_TYPE (loc));\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n   enum dwarf_location_atom op;\n \n   /* ??? Most of the time we do not take proper care for sign/zero\n@@ -8988,28 +8988,28 @@ loc_descriptor_from_tree (tree loc, int addressp)\n       goto do_binop;\n \n     case LE_EXPR:\n-      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n \treturn 0;\n \n       op = DW_OP_le;\n       goto do_binop;\n \n     case GE_EXPR:\n-      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n \treturn 0;\n \n       op = DW_OP_ge;\n       goto do_binop;\n \n     case LT_EXPR:\n-      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n \treturn 0;\n \n       op = DW_OP_lt;\n       goto do_binop;\n \n     case GT_EXPR:\n-      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n \treturn 0;\n \n       op = DW_OP_gt;\n@@ -10904,7 +10904,7 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \t  add_name_attribute (enum_die,\n \t\t\t      IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n \n-\t  if (host_integerp (value, TREE_UNSIGNED (TREE_TYPE (value))))\n+\t  if (host_integerp (value, TYPE_UNSIGNED (TREE_TYPE (value))))\n \t    /* DWARF2 does not provide a way of indicating whether or\n \t       not enumeration constants are signed or unsigned.  GDB\n \t       always assumes the values are signed, so we output all"}, {"sha": "5d213c38b3d0f98432cb6e634ba1bcbf33ba0b44", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -4176,8 +4176,9 @@ make_tree (tree type, rtx x)\n     {\n     case CONST_INT:\n       t = build_int_2 (INTVAL (x),\n-\t\t       (TREE_UNSIGNED (type)\n-\t\t\t&& (GET_MODE_BITSIZE (TYPE_MODE (type)) < HOST_BITS_PER_WIDE_INT))\n+\t\t       (TYPE_UNSIGNED (type)\n+\t\t\t&& (GET_MODE_BITSIZE (TYPE_MODE (type))\n+\t\t\t    < HOST_BITS_PER_WIDE_INT))\n \t\t       || INTVAL (x) >= 0 ? 0 : -1);\n       TREE_TYPE (t) = type;\n       return t;"}, {"sha": "3365aef2e10beb44aa0280ce59ecf4f3c4fc6bb8", "filename": "gcc/expr.c", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2151,7 +2151,7 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n \n   if (GET_MODE (srcreg) != BLKmode\n       && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n-    srcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n+    srcreg = convert_to_mode (word_mode, srcreg, TYPE_UNSIGNED (type));\n \n   /* If the structure doesn't take up a whole number of words, see whether\n      SRCREG is padded on the left or on the right.  If it's on the left,\n@@ -3881,7 +3881,7 @@ expand_assignment (tree to, tree from, int want_value)\n       return (want_value ? convert_modes (TYPE_MODE (TREE_TYPE (to)),\n \t\t\t\t\t  TYPE_MODE (TREE_TYPE (from)),\n \t\t\t\t\t  result,\n-\t\t\t\t\t  TREE_UNSIGNED (TREE_TYPE (to)))\n+\t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (to)))\n \t      : NULL_RTX);\n     }\n \n@@ -3971,15 +3971,15 @@ expand_assignment (tree to, tree from, int want_value)\n \t\t\t   VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n \t\t\t   XEXP (from_rtx, 0), Pmode,\n \t\t\t   convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t    size, TREE_UNSIGNED (sizetype)),\n+\t\t\t\t\t    size, TYPE_UNSIGNED (sizetype)),\n \t\t\t   TYPE_MODE (sizetype));\n       else\n         emit_library_call (bcopy_libfunc, LCT_NORMAL,\n \t\t\t   VOIDmode, 3, XEXP (from_rtx, 0), Pmode,\n \t\t\t   XEXP (to_rtx, 0), Pmode,\n \t\t\t   convert_to_mode (TYPE_MODE (integer_type_node),\n \t\t\t\t\t    size,\n-\t\t\t\t\t    TREE_UNSIGNED (integer_type_node)),\n+\t\t\t\t\t    TYPE_UNSIGNED (integer_type_node)),\n \t\t\t   TYPE_MODE (integer_type_node));\n \n       preserve_temp_slots (to_rtx);\n@@ -4149,7 +4149,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (exp))\n \t  && TREE_TYPE (TREE_TYPE (exp)) == 0)\n \t{\n-\t  if (TREE_UNSIGNED (TREE_TYPE (exp))\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (exp))\n \t      != SUBREG_PROMOTED_UNSIGNED_P (target))\n \t    exp = convert\n \t      (lang_hooks.types.signed_or_unsigned_type\n@@ -4238,7 +4238,7 @@ store_expr (tree exp, rtx target, int want_value)\n       && TREE_CODE (exp) != ERROR_MARK\n       && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n     temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t  temp, TREE_UNSIGNED (TREE_TYPE (exp)));\n+\t\t\t  temp, TYPE_UNSIGNED (TREE_TYPE (exp)));\n \n   /* If value was not generated in the target, store it there.\n      Convert the value to TARGET's type first if necessary and emit the\n@@ -4279,7 +4279,7 @@ store_expr (tree exp, rtx target, int want_value)\n       if (GET_MODE (temp) != GET_MODE (target)\n \t  && GET_MODE (temp) != VOIDmode)\n \t{\n-\t  int unsignedp = TREE_UNSIGNED (TREE_TYPE (exp));\n+\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n \t  if (dont_return_target)\n \t    {\n \t      /* In this case, we will return TEMP,\n@@ -4320,7 +4320,7 @@ store_expr (tree exp, rtx target, int want_value)\n \n \t      /* Copy that much.  */\n \t      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx,\n-\t\t\t\t\t       TREE_UNSIGNED (sizetype));\n+\t\t\t\t\t       TYPE_UNSIGNED (sizetype));\n \t      emit_block_move (target, temp, copy_size_rtx,\n \t\t\t       (want_value & 2\n \t\t\t\t? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n@@ -4342,7 +4342,7 @@ store_expr (tree exp, rtx target, int want_value)\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t\t  if (GET_MODE (copy_size_rtx) != Pmode)\n \t\t    copy_size_rtx = convert_to_mode (Pmode, copy_size_rtx,\n-\t\t\t\t\t\t     TREE_UNSIGNED (sizetype));\n+\t\t\t\t\t\t     TYPE_UNSIGNED (sizetype));\n #endif\n \n \t\t  target = offset_address (target, copy_size_rtx,\n@@ -4685,7 +4685,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      if (TYPE_PRECISION (type) < BITS_PER_WORD)\n \t\t{\n \t\t  type = lang_hooks.types.type_for_size\n-\t\t    (BITS_PER_WORD, TREE_UNSIGNED (type));\n+\t\t    (BITS_PER_WORD, TYPE_UNSIGNED (type));\n \t\t  value = convert (type, value);\n \t\t}\n \n@@ -4848,7 +4848,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  if (cleared && is_zeros_p (value))\n \t    continue;\n \n-\t  unsignedp = TREE_UNSIGNED (elttype);\n+\t  unsignedp = TYPE_UNSIGNED (elttype);\n \t  mode = TYPE_MODE (elttype);\n \t  if (mode == BLKmode)\n \t    bitsize = (host_integerp (TYPE_SIZE (elttype), 1)\n@@ -4906,7 +4906,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  expand_expr (hi_index, NULL_RTX, VOIDmode, 0);\n \t\t  loop_end = gen_label_rtx ();\n \n-\t\t  unsignedp = TREE_UNSIGNED (domain);\n+\t\t  unsignedp = TYPE_UNSIGNED (domain);\n \n \t\t  index = build_decl (VAR_DECL, NULL_TREE, domain);\n \n@@ -5450,7 +5450,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   else\n     {\n       mode = TYPE_MODE (TREE_TYPE (exp));\n-      *punsignedp = TREE_UNSIGNED (TREE_TYPE (exp));\n+      *punsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n \n       if (mode == BLKmode)\n \tsize_tree = TYPE_SIZE (TREE_TYPE (exp));\n@@ -6160,7 +6160,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n {\n   rtx op0, op1, temp;\n   tree type = TREE_TYPE (exp);\n-  int unsignedp = TREE_UNSIGNED (type);\n+  int unsignedp;\n   enum machine_mode mode;\n   enum tree_code code = TREE_CODE (exp);\n   optab this_optab;\n@@ -6178,6 +6178,8 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n     }\n \n   mode = TYPE_MODE (type);\n+  unsignedp = TYPE_UNSIGNED (type);\n+\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n   subtarget = get_subtarget (target);\n   original_target = target;\n@@ -6918,7 +6920,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t    enum machine_mode imode\n \t\t      = TYPE_MODE (TREE_TYPE (TREE_PURPOSE (elt)));\n \n-\t\t    if (TREE_UNSIGNED (TREE_TYPE (TREE_PURPOSE (elt))))\n+\t\t    if (TYPE_UNSIGNED (TREE_TYPE (TREE_PURPOSE (elt))))\n \t\t      {\n \t\t\top1 = GEN_INT (((HOST_WIDE_INT) 1 << bitsize) - 1);\n \t\t\top0 = expand_and (imode, op0, op1, target);\n@@ -7277,7 +7279,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \n \ttree set = TREE_OPERAND (exp, 0);\n \ttree index = TREE_OPERAND (exp, 1);\n-\tint iunsignedp = TREE_UNSIGNED (TREE_TYPE (index));\n+\tint iunsignedp = TYPE_UNSIGNED (TREE_TYPE (index));\n \ttree set_type = TREE_TYPE (set);\n \ttree set_low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (set_type));\n \ttree set_high_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (set_type));\n@@ -7475,7 +7477,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t  /* If the signedness of the conversion differs and OP0 is\n \t     a promoted SUBREG, clear that indication since we now\n \t     have to do the proper extension.  */\n-\t  if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))) != unsignedp\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))) != unsignedp\n \t      && GET_CODE (op0) == SUBREG)\n \t    SUBREG_PROMOTED_VAR_P (op0) = 0;\n \n@@ -7498,7 +7500,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t\t       inner_mode));\n \t  else\n \t    return convert_modes (mode, inner_mode, op0,\n-\t\t\t\t  TREE_UNSIGNED (inner_type));\n+\t\t\t\t  TYPE_UNSIGNED (inner_type));\n \t}\n \n       if (modifier == EXPAND_INITIALIZER)\n@@ -7507,10 +7509,10 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n       if (target == 0)\n \treturn\n \t  convert_to_mode (mode, op0,\n-\t\t\t   TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t\t   TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       else\n \tconvert_move (target, op0,\n-\t\t      TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t      TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       return target;\n \n     case VIEW_CONVERT_EXPR:\n@@ -7804,18 +7806,22 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t   || exact_log2 (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))) < 0))\n \t      ||\n \t      (TREE_CODE (TREE_OPERAND (exp, 1)) == NOP_EXPR\n-\t       && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)))\n-\t\t   ==\n-\t\t   TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))))\n+\t       && (TYPE_PRECISION (TREE_TYPE\n+\t\t\t\t   (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)))\n+\t\t   == TYPE_PRECISION (TREE_TYPE\n+\t\t\t\t      (TREE_OPERAND\n+\t\t\t\t       (TREE_OPERAND (exp, 0), 0))))\n \t       /* If both operands are extended, they must either both\n \t\t  be zero-extended or both be sign-extended.  */\n-\t       && (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)))\n-\t\t   ==\n-\t\t   TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))))))\n+\t       && (TYPE_UNSIGNED (TREE_TYPE\n+\t\t\t\t  (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)))\n+\t\t   == TYPE_UNSIGNED (TREE_TYPE\n+\t\t\t\t     (TREE_OPERAND\n+\t\t\t\t      (TREE_OPERAND (exp, 0), 0)))))))\n \t{\n \t  tree op0type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0));\n \t  enum machine_mode innermode = TYPE_MODE (op0type);\n-\t  bool zextend_p = TREE_UNSIGNED (op0type);\n+\t  bool zextend_p = TYPE_UNSIGNED (op0type);\n \t  optab other_optab = zextend_p ? smul_widen_optab : umul_widen_optab;\n \t  this_optab = zextend_p ? umul_widen_optab : smul_widen_optab;\n \n@@ -7924,7 +7930,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \top0 = copy_to_mode_reg (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n \t\t\t\top0);\n       expand_float (target, op0,\n-\t\t    TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t    TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       return target;\n \n     case NEGATE_EXPR:\n@@ -7951,7 +7957,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \n       /* Unsigned abs is simply the operand.  Testing here means we don't\n \t risk generating incorrect code below.  */\n-      if (TREE_UNSIGNED (type))\n+      if (TYPE_UNSIGNED (type))\n \treturn op0;\n \n       return expand_abs (mode, op0, target, unsignedp,\n@@ -9286,7 +9292,7 @@ expand_increment (tree exp, int post, int ignore)\n \n   /* Increment however we can.  */\n   op1 = expand_binop (mode, this_optab, value, op1, op0,\n-\t\t      TREE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n+\t\t      TYPE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n \n   /* Make sure the value is stored into OP0.  */\n   if (op1 != op0)\n@@ -9346,7 +9352,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n \n   type = TREE_TYPE (arg0);\n   operand_mode = TYPE_MODE (type);\n-  unsignedp = TREE_UNSIGNED (type);\n+  unsignedp = TYPE_UNSIGNED (type);\n \n   /* We won't bother with BLKmode store-flag operations because it would mean\n      passing a lot of information to emit_store_flag.  */\n@@ -9619,7 +9625,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \n   op_mode = insn_data[(int) CODE_FOR_casesi].operand[1].mode;\n   op1 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (minval)),\n-\t\t       op1, TREE_UNSIGNED (TREE_TYPE (minval)));\n+\t\t       op1, TYPE_UNSIGNED (TREE_TYPE (minval)));\n   if (! (*insn_data[(int) CODE_FOR_casesi].operand[1].predicate)\n       (op1, op_mode))\n     op1 = copy_to_mode_reg (op_mode, op1);\n@@ -9628,7 +9634,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \n   op_mode = insn_data[(int) CODE_FOR_casesi].operand[2].mode;\n   op2 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (range)),\n-\t\t       op2, TREE_UNSIGNED (TREE_TYPE (range)));\n+\t\t       op2, TYPE_UNSIGNED (TREE_TYPE (range)));\n   if (! (*insn_data[(int) CODE_FOR_casesi].operand[2].predicate)\n       (op2, op_mode))\n     op2 = copy_to_mode_reg (op_mode, op2);\n@@ -9742,7 +9748,7 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n \t\t\t       TYPE_MODE (TREE_TYPE (range)),\n \t\t\t       expand_expr (range, NULL_RTX,\n \t\t\t\t\t    VOIDmode, 0),\n-\t\t\t       TREE_UNSIGNED (TREE_TYPE (range))),\n+\t\t\t       TYPE_UNSIGNED (TREE_TYPE (range))),\n \t\ttable_label, default_label);\n   return 1;\n }"}, {"sha": "f81e5a383671ec472c6df93594f8dbe4e38c63d2", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1,3 +1,8 @@\n+2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* com.c (ffecom_arrayref_): Use TYPE_UNSIGNED, not TREE_UNSIGNED.\n+\t(ffecom_expr_): Likewise.\n+\n 2004-03-30  Zack Weinberg  <zack@codesourcery.com>\n \n \t* com.c: Use new shorter form of GTY markers."}, {"sha": "178326b0ea8f64495426e6f48424420ceaf7c347", "filename": "gcc/f/com.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -912,7 +912,7 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n \t  if (tree_type\n \t      && GET_MODE_CLASS (TYPE_MODE (tree_type)) == MODE_INT\n \t      && TYPE_PRECISION (tree_type) < TYPE_PRECISION (sizetype))\n-\t    tree_type_x = (TREE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n+\t    tree_type_x = (TYPE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n \n \t  if (TREE_TYPE (min) != tree_type_x)\n \t    min = convert (tree_type_x, min);\n@@ -958,7 +958,7 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n \t  if (tree_type\n \t      && GET_MODE_CLASS (TYPE_MODE (tree_type)) == MODE_INT\n \t      && TYPE_PRECISION (tree_type) < TYPE_PRECISION (sizetype))\n-\t    tree_type_x = (TREE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n+\t    tree_type_x = (TYPE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n \n \t  element = convert (tree_type_x, element);\n \n@@ -2955,7 +2955,7 @@ ffecom_expr_ (ffebld expr, tree dest_tree, ffebld dest, bool *dest_used,\n   if (widenp && tree_type\n       && GET_MODE_CLASS (TYPE_MODE (tree_type)) == MODE_INT\n       && TYPE_PRECISION (tree_type) < TYPE_PRECISION (sizetype))\n-    tree_type_x = (TREE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n+    tree_type_x = (TYPE_UNSIGNED (tree_type) ? usizetype : ssizetype);\n \n   switch (ffebld_op (expr))\n     {"}, {"sha": "78fb2789d87af6b3330a8be7478e4cc1b488e6bd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -224,7 +224,7 @@ force_fit_type (tree t, int overflow)\n \n   /* Unsigned types do not suffer sign extension or overflow unless they\n      are a sizetype.  */\n-  if (TREE_UNSIGNED (TREE_TYPE (t))\n+  if (TYPE_UNSIGNED (TREE_TYPE (t))\n       && ! (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n \t    && TYPE_IS_SIZETYPE (TREE_TYPE (t))))\n     return overflow;\n@@ -853,7 +853,7 @@ negate_expr_p (tree t)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n-      if (TREE_UNSIGNED (type) || ! flag_trapv)\n+      if (TYPE_UNSIGNED (type) || ! flag_trapv)\n \treturn true;\n \n       /* Check that -CST will not overflow type.  */\n@@ -897,7 +897,7 @@ negate_expr_p (tree t)\n \t\t\t\t    TREE_OPERAND (t, 1));\n \n     case MULT_EXPR:\n-      if (TREE_UNSIGNED (TREE_TYPE (t)))\n+      if (TYPE_UNSIGNED (TREE_TYPE (t)))\n         break;\n \n       /* Fall through.  */\n@@ -962,7 +962,7 @@ negate_expr (tree t)\n     case INTEGER_CST:\n       tem = fold_negate_const (t, type);\n       if (! TREE_OVERFLOW (tem)\n-\t  || TREE_UNSIGNED (type)\n+\t  || TYPE_UNSIGNED (type)\n \t  || ! flag_trapv)\n \treturn tem;\n       break;\n@@ -1021,7 +1021,7 @@ negate_expr (tree t)\n       break;\n \n     case MULT_EXPR:\n-      if (TREE_UNSIGNED (TREE_TYPE (t)))\n+      if (TYPE_UNSIGNED (TREE_TYPE (t)))\n         break;\n \n       /* Fall through.  */\n@@ -1077,7 +1077,7 @@ negate_expr (tree t)\n \t      && (unsigned HOST_WIDE_INT) (TYPE_PRECISION (type) - 1)\n \t\t == TREE_INT_CST_LOW (op1))\n \t    {\n-\t      tree ntype = TREE_UNSIGNED (type)\n+\t      tree ntype = TYPE_UNSIGNED (type)\n \t\t\t   ? lang_hooks.types.signed_type (type)\n \t\t\t   : lang_hooks.types.unsigned_type (type);\n \t      tree temp = fold_convert (ntype, TREE_OPERAND (t, 0));\n@@ -1241,7 +1241,7 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n   HOST_WIDE_INT garbageh;\n   tree t;\n   tree type = TREE_TYPE (arg1);\n-  int uns = TREE_UNSIGNED (type);\n+  int uns = TYPE_UNSIGNED (type);\n   int is_sizetype\n     = (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type));\n   int overflow = 0;\n@@ -1682,7 +1682,7 @@ size_diffop (tree arg0, tree arg1)\n     abort ();\n \n   /* If the type is already signed, just do the simple thing.  */\n-  if (! TREE_UNSIGNED (type))\n+  if (!TYPE_UNSIGNED (type))\n     return size_binop (MINUS_EXPR, arg0, arg1);\n \n   ctype = (type == bitsizetype || type == ubitsizetype\n@@ -1751,8 +1751,8 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t  TREE_OVERFLOW (t)\n \t    = ((force_fit_type (t,\n \t\t\t\t(TREE_INT_CST_HIGH (arg1) < 0\n-\t\t\t\t && (TREE_UNSIGNED (type)\n-\t\t\t\t    < TREE_UNSIGNED (TREE_TYPE (arg1)))))\n+\t\t\t\t && (TYPE_UNSIGNED (type)\n+\t\t\t\t    < TYPE_UNSIGNED (TREE_TYPE (arg1)))))\n \t\t&& ! POINTER_TYPE_P (TREE_TYPE (arg1)))\n \t       || TREE_OVERFLOW (arg1));\n \t  TREE_CONSTANT_OVERFLOW (t)\n@@ -2159,10 +2159,14 @@ operand_equal_p (tree arg0, tree arg1, int only_const)\n {\n   tree fndecl;\n \n+  /* If either is ERROR_MARK, they aren't equal.  */\n+  if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n+    return 0;\n+\n   /* If both types don't have the same signedness, then we can't consider\n      them equal.  We must check this before the STRIP_NOPS calls\n      because they may change the signedness of the arguments.  */\n-  if (TREE_UNSIGNED (TREE_TYPE (arg0)) != TREE_UNSIGNED (TREE_TYPE (arg1)))\n+  if (TYPE_UNSIGNED (TREE_TYPE (arg0)) != TYPE_UNSIGNED (TREE_TYPE (arg1)))\n     return 0;\n \n   STRIP_NOPS (arg0);\n@@ -2253,8 +2257,8 @@ operand_equal_p (tree arg0, tree arg1, int only_const)\n     case '1':\n       /* Two conversions are equal only if signedness and modes match.  */\n       if ((TREE_CODE (arg0) == NOP_EXPR || TREE_CODE (arg0) == CONVERT_EXPR)\n-\t  && (TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t      != TREE_UNSIGNED (TREE_TYPE (arg1))))\n+\t  && (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t      != TYPE_UNSIGNED (TREE_TYPE (arg1))))\n \treturn 0;\n \n       return operand_equal_p (TREE_OPERAND (arg0, 0),\n@@ -3057,7 +3061,7 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n      the outer type, then the outer type gives the signedness. Otherwise\n      (in case of a small bitfield) the signedness is unchanged.  */\n   if (outer_type && *pbitsize == tree_low_cst (TYPE_SIZE (outer_type), 1))\n-    *punsignedp = TREE_UNSIGNED (outer_type);\n+    *punsignedp = TYPE_UNSIGNED (outer_type);\n \n   /* Compute the mask to access the bitfield.  */\n   unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);\n@@ -3377,7 +3381,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t     greater than or equal to zero.  We base the range tests we make\n \t     on that fact, so we record it here so we can parse existing\n \t     range tests.  */\n-\t  if (TREE_UNSIGNED (type) && (low == 0 || high == 0))\n+\t  if (TYPE_UNSIGNED (type) && (low == 0 || high == 0))\n \t    {\n \t      if (! merge_ranges (&n_in_p, &n_low, &n_high, in_p, low, high,\n \t\t\t\t  1, fold_convert (type, integer_zero_node),\n@@ -3481,7 +3485,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n \t     So we have to make sure that the original unsigned value will\n \t     be interpreted as positive.  */\n-\t  if (TREE_UNSIGNED (type) && ! TREE_UNSIGNED (TREE_TYPE (exp)))\n+\t  if (TYPE_UNSIGNED (type) && ! TYPE_UNSIGNED (TREE_TYPE (exp)))\n \t    {\n \t      tree equiv_type = lang_hooks.types.type_for_mode\n \t\t(TYPE_MODE (type), 1);\n@@ -3582,7 +3586,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \n   if (integer_zerop (low))\n     {\n-      if (! TREE_UNSIGNED (etype))\n+      if (! TYPE_UNSIGNED (etype))\n \t{\n \t  etype = lang_hooks.types.unsigned_type (etype);\n \t  high = fold_convert (etype, high);\n@@ -3612,7 +3616,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \n       if (TREE_INT_CST_HIGH (high) == hi && TREE_INT_CST_LOW (high) == lo)\n \t{\n-\t  if (TREE_UNSIGNED (etype))\n+\t  if (TYPE_UNSIGNED (etype))\n \t    {\n \t      etype = lang_hooks.types.signed_type (etype);\n \t      exp = fold_convert (etype, exp);\n@@ -3866,7 +3870,7 @@ unextend (tree c, int p, int unsignedp, tree mask)\n      do the type conversion here.  At this point, the constant is either\n      zero or one, and the conversion to a signed type can never overflow.\n      We could get an overflow if this conversion is done anywhere else.  */\n-  if (TREE_UNSIGNED (type))\n+  if (TYPE_UNSIGNED (type))\n     temp = fold_convert (lang_hooks.types.signed_type (type), temp);\n \n   temp = const_binop (LSHIFT_EXPR, temp, size_int (modesize - 1), 0);\n@@ -3875,7 +3879,7 @@ unextend (tree c, int p, int unsignedp, tree mask)\n     temp = const_binop (BIT_AND_EXPR, temp,\n \t\t\tfold_convert (TREE_TYPE (c), mask), 0);\n   /* If necessary, convert the type back to match the type of C.  */\n-  if (TREE_UNSIGNED (type))\n+  if (TYPE_UNSIGNED (type))\n     temp = fold_convert (type, temp);\n \n   return fold_convert (type, const_binop (BIT_XOR_EXPR, c, temp, 0));\n@@ -4504,7 +4508,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t   || TREE_CODE_CLASS (TREE_CODE (op0)) == 'e')\n \t  /* ... and is unsigned, and its type is smaller than ctype,\n \t     then we cannot pass through as widening.  */\n-\t  && ((TREE_UNSIGNED (TREE_TYPE (op0))\n+\t  && ((TYPE_UNSIGNED (TREE_TYPE (op0))\n \t       && ! (TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n \t\t     && TYPE_IS_SIZETYPE (TREE_TYPE (op0)))\n \t       && (GET_MODE_SIZE (TYPE_MODE (ctype))\n@@ -4516,8 +4520,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t      /* ... or signedness changes for division or modulus,\n \t\t then we cannot pass through this conversion.  */\n \t      || (code != MULT_EXPR\n-\t\t  && (TREE_UNSIGNED (ctype)\n-\t\t      != TREE_UNSIGNED (TREE_TYPE (op0))))))\n+\t\t  && (TYPE_UNSIGNED (ctype)\n+\t\t      != TYPE_UNSIGNED (TREE_TYPE (op0))))))\n \tbreak;\n \n       /* Pass the constant down and see if we can make a simplification.  If\n@@ -4540,7 +4544,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n     case MIN_EXPR:  case MAX_EXPR:\n       /* If widening the type changes the signedness, then we can't perform\n \t this optimization as that changes the result.  */\n-      if (TREE_UNSIGNED (ctype) != TREE_UNSIGNED (type))\n+      if (TYPE_UNSIGNED (ctype) != TYPE_UNSIGNED (type))\n \tbreak;\n \n       /* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */\n@@ -4631,7 +4635,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       /* If we have an unsigned type is not a sizetype, we cannot widen\n \t the operation since it will change the result if the original\n \t computation overflowed.  */\n-      if (TREE_UNSIGNED (ctype)\n+      if (TYPE_UNSIGNED (ctype)\n \t  && ! (TREE_CODE (ctype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (ctype))\n \t  && ctype != type)\n \tbreak;\n@@ -4696,7 +4700,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t If we have an unsigned type that is not a sizetype, we cannot do\n \t this since it will change the result if the original computation\n \t overflowed.  */\n-      if ((! TREE_UNSIGNED (ctype)\n+      if ((! TYPE_UNSIGNED (ctype)\n \t   || (TREE_CODE (ctype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (ctype)))\n \t  && ! flag_wrapv\n \t  && ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR)\n@@ -5631,17 +5635,17 @@ fold (tree expr)\n \t  int inside_ptr = POINTER_TYPE_P (inside_type);\n \t  int inside_float = FLOAT_TYPE_P (inside_type);\n \t  unsigned int inside_prec = TYPE_PRECISION (inside_type);\n-\t  int inside_unsignedp = TREE_UNSIGNED (inside_type);\n+\t  int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n \t  int inter_int = INTEGRAL_TYPE_P (inter_type);\n \t  int inter_ptr = POINTER_TYPE_P (inter_type);\n \t  int inter_float = FLOAT_TYPE_P (inter_type);\n \t  unsigned int inter_prec = TYPE_PRECISION (inter_type);\n-\t  int inter_unsignedp = TREE_UNSIGNED (inter_type);\n+\t  int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n \t  int final_int = INTEGRAL_TYPE_P (type);\n \t  int final_ptr = POINTER_TYPE_P (type);\n \t  int final_float = FLOAT_TYPE_P (type);\n \t  unsigned int final_prec = TYPE_PRECISION (type);\n-\t  int final_unsignedp = TREE_UNSIGNED (type);\n+\t  int final_unsignedp = TYPE_UNSIGNED (type);\n \n \t  /* In addition to the cases of two conversions in a row\n \t     handled below, if we are converting something to its own\n@@ -5733,7 +5737,7 @@ fold (tree expr)\n \t  tree and0 = TREE_OPERAND (and, 0), and1 = TREE_OPERAND (and, 1);\n \t  int change = 0;\n \n-\t  if (TREE_UNSIGNED (TREE_TYPE (and))\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (and))\n \t      || (TYPE_PRECISION (type)\n \t\t  <= TYPE_PRECISION (TREE_TYPE (and))))\n \t    change = 1;\n@@ -6087,7 +6091,7 @@ fold (tree expr)\n \t     || (code1 == RSHIFT_EXPR && code0 == LSHIFT_EXPR))\n \t    && operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t        TREE_OPERAND (arg1, 0), 0)\n-\t    && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t    && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t  {\n \t    tree tree01, tree11;\n \t    enum tree_code code01, code11;\n@@ -6668,7 +6672,7 @@ fold (tree expr)\n \treturn t1;\n       /* Simplify ((int)c & 0377) into (int)c, if c is unsigned char.  */\n       if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n-\t  && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t{\n \t  unsigned int prec\n \t    = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n@@ -6938,7 +6942,7 @@ fold (tree expr)\n \n     case RSHIFT_EXPR:\n       /* Optimize -1 >> x for arithmetic right shifts.  */\n-      if (integer_all_onesp (arg0) && ! TREE_UNSIGNED (type))\n+      if (integer_all_onesp (arg0) && !TYPE_UNSIGNED (type))\n \treturn omit_one_operand (type, arg0, arg1);\n       /* ... fall through ...  */\n \n@@ -7413,7 +7417,7 @@ fold (tree expr)\n \n \t    signed_max = ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1;\n \n-\t    if (TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t    if (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n \t      {\n \t        max = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n \t\tmin = 0;\n@@ -7502,7 +7506,7 @@ fold (tree expr)\n \n \t    else if (TREE_INT_CST_HIGH (arg1) == 0\n \t\t     && TREE_INT_CST_LOW (arg1) == signed_max\n-\t\t     && TREE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t     && TYPE_UNSIGNED (TREE_TYPE (arg1))\n \t\t     /* signed_type does not work on pointer types.  */\n \t\t     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n \t      {\n@@ -7559,8 +7563,8 @@ fold (tree expr)\n \t       && TREE_CODE (arg0) == NOP_EXPR\n \t       && (tem = get_unwidened (arg0, NULL_TREE)) != arg0\n \t       && (code == EQ_EXPR || code == NE_EXPR\n-\t\t   || TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t      == TREE_UNSIGNED (TREE_TYPE (tem)))\n+\t\t   || TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t      == TYPE_UNSIGNED (TREE_TYPE (tem)))\n \t       && (t1 = get_unwidened (arg1, TREE_TYPE (tem))) != 0\n \t       && (TREE_TYPE (t1) == TREE_TYPE (tem)\n \t\t   || (TREE_CODE (t1) == INTEGER_CST\n@@ -7631,7 +7635,7 @@ fold (tree expr)\n \t the MOD operation unsigned since it is simpler and equivalent.  */\n       if ((code == NE_EXPR || code == EQ_EXPR)\n \t  && integer_zerop (arg1)\n-\t  && ! TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t  && (TREE_CODE (arg0) == TRUNC_MOD_EXPR\n \t      || TREE_CODE (arg0) == CEIL_MOD_EXPR\n \t      || TREE_CODE (arg0) == FLOOR_MOD_EXPR\n@@ -7706,7 +7710,7 @@ fold (tree expr)\n       /* If X is unsigned, convert X < (1 << Y) into X >> Y == 0\n \t and similarly for >= into !=.  */\n       if ((code == LT_EXPR || code == GE_EXPR)\n-\t  && TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t  && TREE_CODE (arg1) == LSHIFT_EXPR\n \t  && integer_onep (TREE_OPERAND (arg1, 0)))\n \treturn build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n@@ -7715,7 +7719,7 @@ fold (tree expr)\n \t\t      fold_convert (TREE_TYPE (arg0), integer_zero_node));\n \n       else if ((code == LT_EXPR || code == GE_EXPR)\n-\t       && TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t       && TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t       && (TREE_CODE (arg1) == NOP_EXPR\n \t\t   || TREE_CODE (arg1) == CONVERT_EXPR)\n \t       && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n@@ -8001,14 +8005,14 @@ fold (tree expr)\n \t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n \t      case GE_EXPR:\n \t      case GT_EXPR:\n-\t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n \t\t  arg1 = fold_convert (lang_hooks.types.signed_type\n \t\t\t\t       (TREE_TYPE (arg1)), arg1);\n \t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \t\treturn pedantic_non_lvalue (fold_convert (type, arg1));\n \t      case LE_EXPR:\n \t      case LT_EXPR:\n-\t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n \t\t  arg1 = fold_convert (lang_hooks.types.signed_type\n \t\t\t\t       (TREE_TYPE (arg1)), arg1);\n \t\targ1 = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n@@ -8655,7 +8659,7 @@ multiple_of_p (tree type, tree top, tree bottom)\n \n     case INTEGER_CST:\n       if (TREE_CODE (bottom) != INTEGER_CST\n-\t  || (TREE_UNSIGNED (type)\n+\t  || (TYPE_UNSIGNED (type)\n \t      && (tree_int_cst_sgn (top) < 0\n \t\t  || tree_int_cst_sgn (bottom) < 0)))\n \treturn 0;\n@@ -8696,8 +8700,8 @@ tree_expr_nonnegative_p (tree t)\n \t{\n \t  tree inner1 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \t  tree inner2 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0));\n-\t  if (TREE_CODE (inner1) == INTEGER_TYPE && TREE_UNSIGNED (inner1)\n-\t      && TREE_CODE (inner2) == INTEGER_TYPE && TREE_UNSIGNED (inner2))\n+\t  if (TREE_CODE (inner1) == INTEGER_TYPE && TYPE_UNSIGNED (inner1)\n+\t      && TREE_CODE (inner2) == INTEGER_TYPE && TYPE_UNSIGNED (inner2))\n \t    {\n \t      unsigned int prec = MAX (TYPE_PRECISION (inner1),\n \t\t\t\t       TYPE_PRECISION (inner2)) + 1;\n@@ -8724,8 +8728,8 @@ tree_expr_nonnegative_p (tree t)\n \t{\n \t  tree inner1 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n \t  tree inner2 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0));\n-\t  if (TREE_CODE (inner1) == INTEGER_TYPE && TREE_UNSIGNED (inner1)\n-\t      && TREE_CODE (inner2) == INTEGER_TYPE && TREE_UNSIGNED (inner2))\n+\t  if (TREE_CODE (inner1) == INTEGER_TYPE && TYPE_UNSIGNED (inner1)\n+\t      && TREE_CODE (inner2) == INTEGER_TYPE && TYPE_UNSIGNED (inner2))\n \t    return TYPE_PRECISION (inner1) + TYPE_PRECISION (inner2)\n \t\t   < TYPE_PRECISION (TREE_TYPE (t));\n \t}\n@@ -8767,7 +8771,7 @@ tree_expr_nonnegative_p (tree t)\n \t      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n \t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n \t      {\n-\t\tif (TREE_UNSIGNED (inner_type))\n+\t\tif (TYPE_UNSIGNED (inner_type))\n \t\t  return 1;\n \t\treturn tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n \t      }\n@@ -8778,7 +8782,7 @@ tree_expr_nonnegative_p (tree t)\n \t      return tree_expr_nonnegative_p (TREE_OPERAND (t,0));\n \t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n \t      return TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type)\n-\t\t      && TREE_UNSIGNED (inner_type);\n+\t\t      && TYPE_UNSIGNED (inner_type);\n \t  }\n       }\n       break;\n@@ -8916,14 +8920,14 @@ tree_expr_nonzero_p (tree t)\n   switch (TREE_CODE (t))\n     {\n     case ABS_EXPR:\n-      if (!TREE_UNSIGNED (type) && !flag_wrapv)\n+      if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n \treturn tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n \n     case INTEGER_CST:\n       return !integer_zerop (t);\n \n     case PLUS_EXPR:\n-      if (!TREE_UNSIGNED (type) && !flag_wrapv)\n+      if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n \t{\n \t  /* With the presence of negative values it is hard\n \t     to say something.  */\n@@ -8937,7 +8941,7 @@ tree_expr_nonzero_p (tree t)\n       break;\n \n     case MULT_EXPR:\n-      if (!TREE_UNSIGNED (type) && !flag_wrapv)\n+      if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n \t{\n \t  return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n \t          && tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n@@ -9068,7 +9072,7 @@ fold_negate_const (tree arg0, tree type)\n       TREE_TYPE (t) = type;\n       TREE_OVERFLOW (t)\n \t= (TREE_OVERFLOW (arg0)\n-\t   | force_fit_type (t, overflow && !TREE_UNSIGNED (type)));\n+\t   | force_fit_type (t, overflow && !TYPE_UNSIGNED (type)));\n       TREE_CONSTANT_OVERFLOW (t)\n \t= TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg0);\n     }\n@@ -9096,7 +9100,7 @@ fold_abs_const (tree arg0, tree type)\n     {\n       /* If the value is unsigned, then the absolute value is\n \t the same as the ordinary value.  */\n-      if (TREE_UNSIGNED (type))\n+      if (TYPE_UNSIGNED (type))\n \treturn arg0;\n       /* Similarly, if the value is non-negative.  */\n       else if (INT_CST_LT (integer_minus_one_node, arg0))\n@@ -9180,7 +9184,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n       if (code == EQ_EXPR)\n         tem = build_int_2 (tree_int_cst_equal (op0, op1), 0);\n       else\n-        tem = build_int_2 ((TREE_UNSIGNED (TREE_TYPE (op0))\n+        tem = build_int_2 ((TYPE_UNSIGNED (TREE_TYPE (op0))\n \t\t\t    ? INT_CST_LT_UNSIGNED (op0, op1)\n \t\t\t    : INT_CST_LT (op0, op1)),\n \t\t\t   0);"}, {"sha": "90de28400e50fc05dce37e366225435e3f895940", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -852,7 +852,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n \n   mode = TYPE_MODE (type);\n #ifndef PROMOTE_FOR_CALL_ONLY\n-  unsignedp = TREE_UNSIGNED (type);\n+  unsignedp = TYPE_UNSIGNED (type);\n #endif\n \n   if (mode == BLKmode || memory_required)\n@@ -1488,7 +1488,7 @@ static void\n schedule_fixup_var_refs (struct function *function, rtx reg, tree type,\n \t\t\t enum machine_mode promoted_mode, htab_t ht)\n {\n-  int unsigned_p = type ? TREE_UNSIGNED (type) : 0;\n+  int unsigned_p = type ? TYPE_UNSIGNED (type) : 0;\n \n   if (function != 0)\n     {\n@@ -2882,7 +2882,7 @@ gen_mem_addressof (rtx reg, tree decl, int rescan)\n \n       if (rescan\n \t  && (TREE_USED (decl) || (DECL_P (decl) && DECL_INITIAL (decl) != 0)))\n-\tfixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), reg, 0);\n+\tfixup_var_refs (reg, GET_MODE (reg), TYPE_UNSIGNED (type), reg, 0);\n     }\n   else if (rescan)\n     {\n@@ -4476,8 +4476,9 @@ assign_parms (tree fndecl)\n       if (targetm.calls.promote_function_args (TREE_TYPE (fndecl)))\n \t{\n \t  /* Compute the mode in which the arg is actually extended to.  */\n-\t  unsignedp = TREE_UNSIGNED (passed_type);\n-\t  promoted_mode = promote_mode (passed_type, promoted_mode, &unsignedp, 1);\n+\t  unsignedp = TYPE_UNSIGNED (passed_type);\n+\t  promoted_mode = promote_mode (passed_type, promoted_mode,\n+\t\t\t\t\t&unsignedp, 1);\n \t}\n \n       /* Let machine desc say which reg (if any) the parm arrives in.\n@@ -4901,7 +4902,7 @@ assign_parms (tree fndecl)\n \t  rtx parmreg;\n \t  unsigned int regno, regnoi = 0, regnor = 0;\n \n-\t  unsignedp = TREE_UNSIGNED (TREE_TYPE (parm));\n+\t  unsignedp = TYPE_UNSIGNED (TREE_TYPE (parm));\n \n \t  promoted_nominal_mode\n \t    = promote_mode (TREE_TYPE (parm), nominal_mode, &unsignedp, 0);\n@@ -5001,7 +5002,7 @@ assign_parms (tree fndecl)\n \t      if (GET_MODE (parmreg) != GET_MODE (DECL_RTL (parm)))\n \t\t{\n \t\t  rtx tempreg = gen_reg_rtx (GET_MODE (DECL_RTL (parm)));\n-\t\t  int unsigned_p = TREE_UNSIGNED (TREE_TYPE (parm));\n+\t\t  int unsigned_p = TYPE_UNSIGNED (TREE_TYPE (parm));\n \t\t  push_to_sequence (conversion_insns);\n \t\t  emit_move_insn (tempreg, DECL_RTL (parm));\n \t\t  SET_DECL_RTL (parm,\n@@ -5194,7 +5195,7 @@ assign_parms (tree fndecl)\n \n \t      push_to_sequence (conversion_insns);\n \t      entry_parm = convert_to_mode (nominal_mode, tempreg,\n-\t\t\t\t\t    TREE_UNSIGNED (TREE_TYPE (parm)));\n+\t\t\t\t\t    TYPE_UNSIGNED (TREE_TYPE (parm)));\n \t      if (stack_parm)\n \t\t/* ??? This may need a big-endian conversion on sparc64.  */\n \t\tstack_parm = adjust_address (stack_parm, nominal_mode, 0);\n@@ -5442,7 +5443,7 @@ promoted_input_arg (unsigned int regno, enum machine_mode *pmode, int *punsigned\n \t&& TYPE_MODE (DECL_ARG_TYPE (arg)) == TYPE_MODE (TREE_TYPE (arg)))\n       {\n \tenum machine_mode mode = TYPE_MODE (TREE_TYPE (arg));\n-\tint unsignedp = TREE_UNSIGNED (TREE_TYPE (arg));\n+\tint unsignedp = TYPE_UNSIGNED (TREE_TYPE (arg));\n \n \tmode = promote_mode (TREE_TYPE (arg), mode, &unsignedp, 1);\n \tif (mode == GET_MODE (DECL_INCOMING_RTL (arg))\n@@ -7135,7 +7136,7 @@ expand_function_end (void)\n \t     extension.  */\n \t  if (GET_MODE (real_decl_rtl) != GET_MODE (decl_rtl))\n \t    {\n-\t      int unsignedp = TREE_UNSIGNED (TREE_TYPE (decl_result));\n+\t      int unsignedp = TYPE_UNSIGNED (TREE_TYPE (decl_result));\n \n \t      if (targetm.calls.promote_function_return (TREE_TYPE (current_function_decl)))\n \t\tpromote_mode (TREE_TYPE (decl_result), GET_MODE (decl_rtl),"}, {"sha": "567cd9317cafbebe9a5b2ddfe7761befe453836b", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -761,7 +761,7 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n \t{\n \t  if (GET_MODE (loc) != TYPE_MODE (TREE_TYPE (arg)))\n \t    {\n-\t      int unsignedp = TREE_UNSIGNED (TREE_TYPE (formal));\n+\t      int unsignedp = TYPE_UNSIGNED (TREE_TYPE (formal));\n \t      enum machine_mode pmode = TYPE_MODE (TREE_TYPE (formal));\n \n \t      pmode = promote_mode (TREE_TYPE (formal), pmode,"}, {"sha": "b63afb3592380146f14ed9ece3eaac4f877d5233", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1,3 +1,7 @@\n+2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* jcf-write.c (generate_bytecode_insns): Use TYPE_UNSIGNED.\n+\n 2004-03-31  Andrew Haley  <aph@redhat.com>\n \n \tPR java/14104"}, {"sha": "36a21d3f7405956f1cbdaa5e9bdc1e48f701d535", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -2241,7 +2241,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t\t    /* Already converted to int, if needed. */\n \t\t    if (TYPE_PRECISION (dst_type) <= 8)\n \t\t      OP1 (OPCODE_i2b);\n-\t\t    else if (TREE_UNSIGNED (dst_type))\n+\t\t    else if (TYPE_UNSIGNED (dst_type))\n \t\t      OP1 (OPCODE_i2c);\n \t\t    else\n \t\t      OP1 (OPCODE_i2s);"}, {"sha": "8c65f08257b6180c6a57f4f7fc700eec1c86f171", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -7342,16 +7342,16 @@ encode_type (tree type, int curtype, int format)\n     {\n       switch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n \t{\n-\tcase 8:  c = TREE_UNSIGNED (type) ? 'C' : 'c'; break;\n-\tcase 16: c = TREE_UNSIGNED (type) ? 'S' : 's'; break;\n+\tcase 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n+\tcase 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n \tcase 32: \n \t  if (type == long_unsigned_type_node\n \t      || type == long_integer_type_node)\n-\t         c = TREE_UNSIGNED (type) ? 'L' : 'l';\n+\t         c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n \t  else\n-\t         c = TREE_UNSIGNED (type) ? 'I' : 'i';\n+\t         c = TYPE_UNSIGNED (type) ? 'I' : 'i';\n \t  break;\n-\tcase 64: c = TREE_UNSIGNED (type) ? 'Q' : 'q'; break;\n+\tcase 64: c = TYPE_UNSIGNED (type) ? 'Q' : 'q'; break;\n \tdefault: abort ();\n \t}\n       obstack_1grow (&util_obstack, c);"}, {"sha": "1091cc81201a602c9d56500db1ad41614e587dfe", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -3644,7 +3644,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       result_mode = TYPE_MODE (integer_type_node);\n       cmp_mode = TYPE_MODE (length_type);\n       size = convert_to_mode (TYPE_MODE (length_type), size,\n-\t\t\t      TREE_UNSIGNED (length_type));\n+\t\t\t      TYPE_UNSIGNED (length_type));\n \n       result = emit_library_call_value (libfunc, 0, LCT_PURE_MAKE_BLOCK,\n \t\t\t\t\tresult_mode, 3,"}, {"sha": "a6dda21568500d55658ef41a7c65464c6c76f94c", "filename": "gcc/sdbout.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -538,15 +538,15 @@ plain_type_1 (tree type, int level)\n \t  }\n \n \tif (size == INT_TYPE_SIZE)\n-\t  return (TREE_UNSIGNED (type) ? T_UINT : T_INT);\n+\t  return (TYPE_UNSIGNED (type) ? T_UINT : T_INT);\n \tif (size == CHAR_TYPE_SIZE)\n-\t  return (TREE_UNSIGNED (type) ? T_UCHAR : T_CHAR);\n+\t  return (TYPE_UNSIGNED (type) ? T_UCHAR : T_CHAR);\n \tif (size == SHORT_TYPE_SIZE)\n-\t  return (TREE_UNSIGNED (type) ? T_USHORT : T_SHORT);\n+\t  return (TYPE_UNSIGNED (type) ? T_USHORT : T_SHORT);\n \tif (size == LONG_TYPE_SIZE)\n-\t  return (TREE_UNSIGNED (type) ? T_ULONG : T_LONG);\n+\t  return (TYPE_UNSIGNED (type) ? T_ULONG : T_LONG);\n \tif (size == LONG_LONG_TYPE_SIZE)\t/* better than nothing */\n-\t  return (TREE_UNSIGNED (type) ? T_ULONG : T_LONG);\n+\t  return (TYPE_UNSIGNED (type) ? T_ULONG : T_LONG);\n \treturn 0;\n       }\n "}, {"sha": "aee574441952ab627d856f8ccf2630892f454eca", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -3002,7 +3002,7 @@ expand_value_return (rtx val)\n       tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n       if (targetm.calls.promote_function_return (TREE_TYPE (current_function_decl)))\n       {\n-\tint unsignedp = TREE_UNSIGNED (type);\n+\tint unsignedp = TYPE_UNSIGNED (type);\n \tenum machine_mode old_mode\n \t  = DECL_MODE (DECL_RESULT (current_function_decl));\n \tenum machine_mode mode\n@@ -3359,7 +3359,7 @@ tail_recursion_args (tree actuals, tree formals)\n       else\n \t{\n \t  rtx tmp = argvec[i];\n-\t  int unsignedp = TREE_UNSIGNED (TREE_TYPE (TREE_VALUE (a)));\n+\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_VALUE (a)));\n \t  promote_mode(TREE_TYPE (TREE_VALUE (a)), GET_MODE (tmp),\n \t\t       &unsignedp, 0);\n \t  if (DECL_MODE (f) != GET_MODE (DECL_RTL (f)))\n@@ -3945,7 +3945,7 @@ expand_decl (tree decl)\n \t   && (DECL_REGISTER (decl) || DECL_ARTIFICIAL (decl) || optimize))\n     {\n       /* Automatic variable that can go in a register.  */\n-      int unsignedp = TREE_UNSIGNED (type);\n+      int unsignedp = TYPE_UNSIGNED (type);\n       enum machine_mode reg_mode\n \t= promote_mode (type, DECL_MODE (decl), &unsignedp, 0);\n \n@@ -5344,7 +5344,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \n   index_expr = thiscase->data.case_stmt.index_expr;\n   index_type = TREE_TYPE (index_expr);\n-  unsignedp = TREE_UNSIGNED (index_type);\n+  unsignedp = TYPE_UNSIGNED (index_type);\n   if (orig_type == NULL)\n     orig_type = TREE_TYPE (orig_index);\n \n@@ -6145,7 +6145,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t tree index_type)\n {\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n-  int unsignedp = TREE_UNSIGNED (index_type);\n+  int unsignedp = TYPE_UNSIGNED (index_type);\n   enum machine_mode mode = GET_MODE (index);\n   enum machine_mode imode = TYPE_MODE (index_type);\n "}, {"sha": "340608fc1ddb84c129fecb8e976c53e7ac95b9a3", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -364,7 +364,7 @@ layout_decl (tree decl, unsigned int known_align)\n      size in bytes from the size in bits.  If we have already set the mode,\n      don't set it again since we can be called twice for FIELD_DECLs.  */\n \n-  TREE_UNSIGNED (decl) = TREE_UNSIGNED (type);\n+  TREE_UNSIGNED (decl) = TYPE_UNSIGNED (type);\n   if (DECL_MODE (decl) == VOIDmode)\n     DECL_MODE (decl) = TYPE_MODE (type);\n \n@@ -1529,7 +1529,7 @@ layout_type (tree type)\n     case CHAR_TYPE:\n       if (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n \t  && tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0)\n-\tTREE_UNSIGNED (type) = 1;\n+\tTYPE_UNSIGNED (type) = 1;\n \n       TYPE_MODE (type) = smallest_mode_for_size (TYPE_PRECISION (type),\n \t\t\t\t\t\t MODE_INT);\n@@ -1544,25 +1544,20 @@ layout_type (tree type)\n       break;\n \n     case COMPLEX_TYPE:\n-      TREE_UNSIGNED (type) = TREE_UNSIGNED (TREE_TYPE (type));\n+      TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n       TYPE_MODE (type)\n \t= mode_for_size (2 * TYPE_PRECISION (TREE_TYPE (type)),\n-\t\t\t (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n-\t\t\t  ? MODE_COMPLEX_INT : MODE_COMPLEX_FLOAT),\n+\t\t\t (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE\n+\t\t\t  ? MODE_COMPLEX_FLOAT : MODE_COMPLEX_INT),\n \t\t\t 0);\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case VECTOR_TYPE:\n-      {\n-\ttree subtype;\n-\n-\tsubtype = TREE_TYPE (type);\n-\tTREE_UNSIGNED (type) = TREE_UNSIGNED (subtype);\n-\tTYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n-\tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n-      }\n+      TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case VOID_TYPE:\n@@ -1602,7 +1597,7 @@ layout_type (tree type)\n \n \tTYPE_SIZE (type) = bitsize_int (nbits);\n \tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));\n-\tTREE_UNSIGNED (type) = 1;\n+\tTYPE_UNSIGNED (type) = 1;\n \tTYPE_PRECISION (type) = nbits;\n       }\n       break;\n@@ -1652,7 +1647,7 @@ layout_type (tree type)\n \t       sure the size is never negative.  We should really do this\n \t       if *either* bound is non-constant, but this is the best\n \t       compromise between C and Ada.  */\n-\t    if (! TREE_UNSIGNED (sizetype)\n+\t    if (!TYPE_UNSIGNED (sizetype)\n \t\t&& TREE_CODE (TYPE_MIN_VALUE (index)) != INTEGER_CST\n \t\t&& TREE_CODE (TYPE_MAX_VALUE (index)) != INTEGER_CST)\n \t      length = size_binop (MAX_EXPR, length, size_zero_node);\n@@ -1851,7 +1846,7 @@ initialize_sizetypes (void)\n   TYPE_USER_ALIGN (t) = 0;\n   TYPE_SIZE (t) = build_int_2 (GET_MODE_BITSIZE (SImode), 0);\n   TYPE_SIZE_UNIT (t) = build_int_2 (GET_MODE_SIZE (SImode), 0);\n-  TREE_UNSIGNED (t) = 1;\n+  TYPE_UNSIGNED (t) = 1;\n   TYPE_PRECISION (t) = GET_MODE_BITSIZE (SImode);\n   TYPE_MIN_VALUE (t) = build_int_2 (0, 0);\n   TYPE_IS_SIZETYPE (t) = 1;\n@@ -1895,14 +1890,14 @@ set_sizetype (tree type)\n   TYPE_PRECISION (bitsizetype) = precision;\n   TYPE_IS_SIZETYPE (bitsizetype) = 1;\n \n-  if (TREE_UNSIGNED (type))\n+  if (TYPE_UNSIGNED (type))\n     fixup_unsigned_type (bitsizetype);\n   else\n     fixup_signed_type (bitsizetype);\n \n   layout_type (bitsizetype);\n \n-  if (TREE_UNSIGNED (type))\n+  if (TYPE_UNSIGNED (type))\n     {\n       usizetype = sizetype;\n       ubitsizetype = bitsizetype;"}, {"sha": "e0dd6f1e437149efd1a6696fa4241b0b18581695", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -409,7 +409,7 @@ dequeue_and_dump (dump_info_p di)\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n       dump_int (di, \"prec\", TYPE_PRECISION (t));\n-      if (TREE_UNSIGNED (t))\n+      if (TYPE_UNSIGNED (t))\n \tdump_string (di, \"unsigned\");\n       dump_child (\"min\", TYPE_MIN_VALUE (t));\n       dump_child (\"max\", TYPE_MAX_VALUE (t));"}, {"sha": "be153225cf0e4720dc4f50b781cd8f01b99890be", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -499,7 +499,7 @@ real_value_from_int_cst (tree type, tree i)\n \n   real_from_integer (&d, type ? TYPE_MODE (type) : VOIDmode,\n \t\t     TREE_INT_CST_LOW (i), TREE_INT_CST_HIGH (i),\n-\t\t     TREE_UNSIGNED (TREE_TYPE (i)));\n+\t\t     TYPE_UNSIGNED (TREE_TYPE (i)));\n   return d;\n }\n \n@@ -630,7 +630,7 @@ integer_all_onesp (tree expr)\n \t   || TREE_CONSTANT_OVERFLOW (expr))\n     return 0;\n \n-  uns = TREE_UNSIGNED (TREE_TYPE (expr));\n+  uns = TYPE_UNSIGNED (TREE_TYPE (expr));\n   if (!uns)\n     return (TREE_INT_CST_LOW (expr) == ~(unsigned HOST_WIDE_INT) 0\n \t    && TREE_INT_CST_HIGH (expr) == -1);\n@@ -3473,7 +3473,7 @@ tree_int_cst_lt (tree t1, tree t2)\n   if (t1 == t2)\n     return 0;\n \n-  if (TREE_UNSIGNED (TREE_TYPE (t1)) != TREE_UNSIGNED (TREE_TYPE (t2)))\n+  if (TYPE_UNSIGNED (TREE_TYPE (t1)) != TYPE_UNSIGNED (TREE_TYPE (t2)))\n     {\n       int t1_sgn = tree_int_cst_sgn (t1);\n       int t2_sgn = tree_int_cst_sgn (t2);\n@@ -3486,7 +3486,7 @@ tree_int_cst_lt (tree t1, tree t2)\n \t unsigned just in case one of them would overflow a signed\n \t type.  */\n     }\n-  else if (! TREE_UNSIGNED (TREE_TYPE (t1)))\n+  else if (!TYPE_UNSIGNED (TREE_TYPE (t1)))\n     return INT_CST_LT (t1, t2);\n \n   return INT_CST_LT_UNSIGNED (t1, t2);\n@@ -3519,7 +3519,7 @@ host_integerp (tree t, int pos)\n \t       && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) >= 0)\n \t      || (! pos && TREE_INT_CST_HIGH (t) == -1\n \t\t  && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) < 0\n-\t\t  && ! TREE_UNSIGNED (TREE_TYPE (t)))\n+\t\t  && !TYPE_UNSIGNED (TREE_TYPE (t)))\n \t      || (pos && TREE_INT_CST_HIGH (t) == 0)));\n }\n \n@@ -3562,7 +3562,7 @@ tree_int_cst_sgn (tree t)\n {\n   if (TREE_INT_CST_LOW (t) == 0 && TREE_INT_CST_HIGH (t) == 0)\n     return 0;\n-  else if (TREE_UNSIGNED (TREE_TYPE (t)))\n+  else if (TYPE_UNSIGNED (TREE_TYPE (t)))\n     return 1;\n   else if (TREE_INT_CST_HIGH (t) < 0)\n     return -1;\n@@ -4364,7 +4364,7 @@ get_unwidened (tree op, tree for_type)\n   int uns\n     = (for_type != 0 && for_type != type\n        && final_prec > TYPE_PRECISION (type)\n-       && TREE_UNSIGNED (type));\n+       && TYPE_UNSIGNED (type));\n   tree win = op;\n \n   while (TREE_CODE (op) == NOP_EXPR)\n@@ -4394,11 +4394,11 @@ get_unwidened (tree op, tree for_type)\n \t{\n \t  if (! uns || final_prec <= TYPE_PRECISION (TREE_TYPE (op)))\n \t    win = op;\n-\t  /* TREE_UNSIGNED says whether this is a zero-extension.\n+\t  /* TYPE_UNSIGNED says whether this is a zero-extension.\n \t     Let's avoid computing it if it does not affect WIN\n \t     and if UNS will not be needed again.  */\n \t  if ((uns || TREE_CODE (op) == NOP_EXPR)\n-\t      && TREE_UNSIGNED (TREE_TYPE (op)))\n+\t      && TYPE_UNSIGNED (TREE_TYPE (op)))\n \t    {\n \t      uns = 1;\n \t      win = op;\n@@ -4416,7 +4416,7 @@ get_unwidened (tree op, tree for_type)\n       unsigned int innerprec\n \t= tree_low_cst (DECL_SIZE (TREE_OPERAND (op, 1)), 1);\n       int unsignedp = (TREE_UNSIGNED (TREE_OPERAND (op, 1))\n-\t\t       || TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op, 1))));\n+\t\t       || TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op, 1))));\n       type = lang_hooks.types.type_for_size (innerprec, unsignedp);\n \n       /* We can get this structure field in the narrowest type it fits in.\n@@ -4471,11 +4471,11 @@ get_narrower (tree op, int *unsignedp_ptr)\n \t  /* An extension: the outermost one can be stripped,\n \t     but remember whether it is zero or sign extension.  */\n \t  if (first)\n-\t    uns = TREE_UNSIGNED (TREE_TYPE (op));\n+\t    uns = TYPE_UNSIGNED (TREE_TYPE (op));\n \t  /* Otherwise, if a sign extension has been stripped,\n \t     only sign extensions can now be stripped;\n \t     if a zero extension has been stripped, only zero-extensions.  */\n-\t  else if (uns != TREE_UNSIGNED (TREE_TYPE (op)))\n+\t  else if (uns != TYPE_UNSIGNED (TREE_TYPE (op)))\n \t    break;\n \t  first = 0;\n \t}\n@@ -4484,7 +4484,7 @@ get_narrower (tree op, int *unsignedp_ptr)\n \t  /* A change in nominal type can always be stripped, but we must\n \t     preserve the unsignedness.  */\n \t  if (first)\n-\t    uns = TREE_UNSIGNED (TREE_TYPE (op));\n+\t    uns = TYPE_UNSIGNED (TREE_TYPE (op));\n \t  first = 0;\n \t  op = TREE_OPERAND (op, 0);\n \t}\n@@ -4501,7 +4501,7 @@ get_narrower (tree op, int *unsignedp_ptr)\n       unsigned HOST_WIDE_INT innerprec\n \t= tree_low_cst (DECL_SIZE (TREE_OPERAND (op, 1)), 1);\n       int unsignedp = (TREE_UNSIGNED (TREE_OPERAND (op, 1))\n-\t\t       || TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op, 1))));\n+\t\t       || TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op, 1))));\n       tree type = lang_hooks.types.type_for_size (innerprec, unsignedp);\n \n       /* We can get this structure field in a narrower type that fits it,\n@@ -4542,10 +4542,10 @@ int_fits_type_p (tree c, tree type)\n   /* Perform some generic filtering first, which may allow making a decision\n      even if the bounds are not constant.  First, negative integers never fit\n      in unsigned types, */\n-  if ((TREE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n+  if ((TYPE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n       /* Also, unsigned integers with top bit set never fit signed types.  */\n-      || (! TREE_UNSIGNED (type)\n-\t  && TREE_UNSIGNED (TREE_TYPE (c)) && tree_int_cst_msb (c)))\n+      || (! TYPE_UNSIGNED (type)\n+\t  && TYPE_UNSIGNED (TREE_TYPE (c)) && tree_int_cst_msb (c)))\n     return 0;\n \n   /* If at least one bound of the type is a constant integer, we can check\n@@ -5356,7 +5356,6 @@ build_vector_type_for_mode (tree innertype, enum machine_mode mode)\n   t = make_node (VECTOR_TYPE);\n   TREE_TYPE (t) = innertype;\n   TYPE_MODE (t) = mode;\n-  TREE_UNSIGNED (t) = TREE_UNSIGNED (innertype);\n   finish_vector_type (t);\n   return t;\n }"}, {"sha": "d57e4abf41060b2f939fac010f0aaa2b8a0e4df0", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -262,8 +262,10 @@ struct tree_common GTY(())\n \n    unsigned_flag:\n \n+       TYPE_UNSIGNED in\n+           all types\n        TREE_UNSIGNED in\n-           INTEGER_TYPE, ENUMERAL_TYPE, FIELD_DECL\n+           FIELD_DECL\n        SAVE_EXPR_NOPLACEHOLDER in\n \t   SAVE_EXPR\n \n@@ -516,8 +518,8 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n \t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n \t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\\\n-\t && (TREE_UNSIGNED (TREE_TYPE (EXP))\t\t\t\\\n-\t     == TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \\\n+\t && (TYPE_UNSIGNED (TREE_TYPE (EXP))\t\t\t\\\n+\t     == TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \\\n     (EXP) = TREE_OPERAND (EXP, 0)\n \n /* Like STRIP_NOPS, but don't alter the TREE_TYPE main variant either.  */\n@@ -712,8 +714,11 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    In FIELD_DECL nodes, means an unsigned bit field.  */\n #define TREE_UNSIGNED(NODE) ((NODE)->common.unsigned_flag)\n \n+/* In integral and pointer types, means an unsigned type.  */\n+#define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->common.unsigned_flag)\n+\n #define TYPE_TRAP_SIGNED(NODE) \\\n-  (flag_trapv && ! TREE_UNSIGNED (TYPE_CHECK (NODE)))\n+  (flag_trapv && ! TYPE_UNSIGNED (NODE))\n \n /* Nonzero in a VAR_DECL means assembler code has been written.\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n@@ -903,7 +908,9 @@ struct tree_vec GTY(())\n #define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND_CHECK_CODE (NODE, SAVE_EXPR, 1)\n #define SAVE_EXPR_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, SAVE_EXPR, 2)\n \n-#define SAVE_EXPR_NOPLACEHOLDER(NODE) TREE_UNSIGNED (SAVE_EXPR_CHECK (NODE))\n+#define SAVE_EXPR_NOPLACEHOLDER(NODE) \\\n+  (SAVE_EXPR_CHECK (NODE)->common.unsigned_flag)\n+\n /* Nonzero if the SAVE_EXPRs value should be kept, even if it occurs\n    both in normal code and in a handler.  (Normally, in a handler, all\n    SAVE_EXPRs are unsaved, meaning that their values are"}, {"sha": "06a962bdae5c7d535a32b742e884ead8f79a1c26", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1,3 +1,8 @@\n+2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* treetree.c (tree_lang_signed_or_unsigned_type): Use TYPE_UNSIGNED,\n+\tnot TREE_UNSIGNED.\n+\n 2004-03-21  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* treelang.texi: Update link to \"G++ and GCC\"."}, {"sha": "c8be057ddacffe9ff023d5ef7ad6dc3a52d95143", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=8df83eae1ed8f8f7cfb653bdeb14f2b5071d7c4f", "patch": "@@ -1027,7 +1027,7 @@ tree_lang_signed_type (tree type_node)\n static tree\n tree_lang_signed_or_unsigned_type (int unsignedp, tree type)\n {\n-  if (! INTEGRAL_TYPE_P (type) || TREE_UNSIGNED (type) == unsignedp)\n+  if (! INTEGRAL_TYPE_P (type) || TYPE_UNSIGNED (type) == unsignedp)\n     return type;\n   else\n     return tree_lang_type_for_size (TYPE_PRECISION (type), unsignedp);"}]}