{"sha": "7a50e7087567cffb21e81fff566546b8a8dac270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E1MGU3MDg3NTY3Y2ZmYjIxZTgxZmZmNTY2NTQ2YjhhOGRhYzI3MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-14T07:58:53Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-14T07:58:53Z"}, "message": "openmp: cgraph support for late declare variant resolution\n\nThis is a new version of the\nhttps://gcc.gnu.org/legacy-ml/gcc-patches/2019-11/msg01493.html\npatch.  Unlike the previous version, this one actually works properly\nexcept for LTO, bootstrapped/regtested on x86_64-linux and i686-linux\ntoo.\n\nIn short, #pragma omp declare variant is a directive which allows\nredirection of direct calls to certain function to other calls with a\nscoring system and some of those decisions need to be deferred until after\nIPA.  The patch represents them with calls to an artificial FUNCTION_DECL\nwith declare_variant_alt in the cgraph_node set.\n\nFor LTO, the patch only saves/restores the two cgraph_node bits added in the\npatch, but doesn't yet stream out and back in the on the side info for the\ndeclare_variant_alt.  For the LTO partitioning, I believe those artificial\nFUNCTION_DECLs with declare_variant_alt need to go into partition together\nwith anything that calls them (possibly duplicated), any way how to achieve\nthat?  Say if declare variant artificial fn foobar is directly\ncalled from all of foo, bar and baz and not from qux and we want 4\npartitions, one for each of foo, bar, baz, qux, then foobar is needed in the\nfirst 3 partitions, and the IPA_REF_ADDRs recorded for foobar that right\nafter IPA the foobar call will be replaced with calls to foobar1, foobar2,\nfoobar3 or foobar (non-artificial) can of course stay in different\npartitions if needed.\n\n2020-05-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* Makefile.in (GTFILES): Add omp-general.c.\n\t* cgraph.h (struct cgraph_node): Add declare_variant_alt and\n\tcalls_declare_variant_alt members and initialize them in the\n\tctor.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Handle direct\n\tcalls to declare_variant_alt nodes.\n\t* lto-cgraph.c (lto_output_node): Write declare_variant_alt\n\tand calls_declare_variant_alt.\n\t(input_overwrite_node): Read them back.\n\t* omp-simd-clone.c (simd_clone_create): Copy calls_declare_variant_alt\n\tbit.\n\t* tree-inline.c (expand_call_inline): Or in calls_declare_variant_alt\n\tbit.\n\t(tree_function_versioning): Copy calls_declare_variant_alt bit.\n\t* omp-offload.c (execute_omp_device_lower): Call\n\tomp_resolve_declare_variant on direct function calls.\n\t(pass_omp_device_lower::gate): Also enable for\n\tcalls_declare_variant_alt functions.\n\t* omp-general.c (omp_maybe_offloaded): Return false after inlining.\n\t(omp_context_selector_matches): Handle the case when\n\tcfun->curr_properties has PROP_gimple_any bit set.\n\t(struct omp_declare_variant_entry): New type.\n\t(struct omp_declare_variant_base_entry): New type.\n\t(struct omp_declare_variant_hasher): New type.\n\t(omp_declare_variant_hasher::hash, omp_declare_variant_hasher::equal):\n\tNew methods.\n\t(omp_declare_variants): New variable.\n\t(struct omp_declare_variant_alt_hasher): New type.\n\t(omp_declare_variant_alt_hasher::hash,\n\tomp_declare_variant_alt_hasher::equal): New methods.\n\t(omp_declare_variant_alt): New variables.\n\t(omp_resolve_late_declare_variant): New function.\n\t(omp_resolve_declare_variant): Call omp_resolve_late_declare_variant\n\twhen called late.  Create a magic declare_variant_alt fndecl and\n\tcgraph node and return that if decision needs to be deferred until\n\tafter gimplification.\n\t* cgraph.c (symbol_table::create_edge): Or in calls_declare_variant_alt\n\tbit.\n\n\t* c-c++-common/gomp/declare-variant-14.c: New test.", "tree": {"sha": "7b4fc05ad96c8d9a07a0d6a62c587b88ce04abcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b4fc05ad96c8d9a07a0d6a62c587b88ce04abcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a50e7087567cffb21e81fff566546b8a8dac270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a50e7087567cffb21e81fff566546b8a8dac270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a50e7087567cffb21e81fff566546b8a8dac270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a50e7087567cffb21e81fff566546b8a8dac270/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0fb9ffc1b8f3b86bbdf0e915cec2136141b329b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fb9ffc1b8f3b86bbdf0e915cec2136141b329b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0fb9ffc1b8f3b86bbdf0e915cec2136141b329b"}], "stats": {"total": 419, "additions": 409, "deletions": 10}, "files": [{"sha": "360ad7a5b583d86ee40631997e6778cd65014ea5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -1,5 +1,44 @@\n 2020-05-14  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* Makefile.in (GTFILES): Add omp-general.c.\n+\t* cgraph.h (struct cgraph_node): Add declare_variant_alt and\n+\tcalls_declare_variant_alt members and initialize them in the\n+\tctor.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Handle direct\n+\tcalls to declare_variant_alt nodes.\n+\t* lto-cgraph.c (lto_output_node): Write declare_variant_alt\n+\tand calls_declare_variant_alt.\n+\t(input_overwrite_node): Read them back.\n+\t* omp-simd-clone.c (simd_clone_create): Copy calls_declare_variant_alt\n+\tbit.\n+\t* tree-inline.c (expand_call_inline): Or in calls_declare_variant_alt\n+\tbit.\n+\t(tree_function_versioning): Copy calls_declare_variant_alt bit.\n+\t* omp-offload.c (execute_omp_device_lower): Call\n+\tomp_resolve_declare_variant on direct function calls.\n+\t(pass_omp_device_lower::gate): Also enable for\n+\tcalls_declare_variant_alt functions.\n+\t* omp-general.c (omp_maybe_offloaded): Return false after inlining.\n+\t(omp_context_selector_matches): Handle the case when\n+\tcfun->curr_properties has PROP_gimple_any bit set.\n+\t(struct omp_declare_variant_entry): New type.\n+\t(struct omp_declare_variant_base_entry): New type.\n+\t(struct omp_declare_variant_hasher): New type. \n+\t(omp_declare_variant_hasher::hash, omp_declare_variant_hasher::equal):\n+\tNew methods.\n+\t(omp_declare_variants): New variable.\n+\t(struct omp_declare_variant_alt_hasher): New type.\n+\t(omp_declare_variant_alt_hasher::hash,\n+\tomp_declare_variant_alt_hasher::equal): New methods.\n+\t(omp_declare_variant_alt): New variables.\n+\t(omp_resolve_late_declare_variant): New function.\n+\t(omp_resolve_declare_variant): Call omp_resolve_late_declare_variant\n+\twhen called late.  Create a magic declare_variant_alt fndecl and\n+\tcgraph node and return that if decision needs to be deferred until\n+\tafter gimplification.\n+\t* cgraph.c (symbol_table::create_edge): Or in calls_declare_variant_alt\n+\tbit.\n+\n \tPR middle-end/95108\n \t* omp-simd-clone.c (struct modify_stmt_info): Add after_stmt member.\n \t(ipa_simd_modify_stmt_ops): For PHIs, only add before first stmt in"}, {"sha": "9ba21f735f6dfe632f57a18a0a9216ce6dac50a4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -2616,6 +2616,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/omp-offload.h \\\n   $(srcdir)/omp-offload.c \\\n   $(srcdir)/omp-expand.c \\\n+  $(srcdir)/omp-general.c \\\n   $(srcdir)/omp-low.c \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n   $(srcdir)/cgraphclones.c \\"}, {"sha": "c0b457950595e800c1a40a60ff3f26879b4953f9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -915,6 +915,8 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n \t\t\t\t      caller->decl);\n   else\n     edge->in_polymorphic_cdtor = caller->thunk.thunk_p;\n+  if (callee)\n+    caller->calls_declare_variant_alt |= callee->declare_variant_alt;\n \n   if (callee && symtab->state != LTO_STREAMING\n       && edge->callee->comdat_local_p ())"}, {"sha": "cfae6e91da92bd50474e2925b12311c3dd69c410", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -937,7 +937,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n       split_part (false), indirect_call_target (false), local (false),\n       versionable (false), can_change_signature (false),\n       redefined_extern_inline (false), tm_may_enter_irr (false),\n-      ipcp_clone (false), m_uid (uid), m_summary_id (-1)\n+      ipcp_clone (false), declare_variant_alt (false),\n+      calls_declare_variant_alt (false), m_uid (uid), m_summary_id (-1)\n   {}\n \n   /* Remove the node from cgraph and all inline clones inlined into it.\n@@ -1539,6 +1540,11 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   unsigned tm_may_enter_irr : 1;\n   /* True if this was a clone created by ipa-cp.  */\n   unsigned ipcp_clone : 1;\n+  /* True if this is the deferred declare variant resolution artificial\n+     function.  */\n+  unsigned declare_variant_alt : 1;\n+  /* True if the function calls declare_variant_alt functions.  */\n+  unsigned calls_declare_variant_alt : 1;\n \n private:\n   /* Unique id of the node.  */"}, {"sha": "288b58cf73d01d6b7560eb7e22c9413e91dcabdb", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -450,6 +450,9 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t\t\treachable.add (body);\n \t\t      reachable.add (e->callee);\n \t\t    }\n+\t\t  else if (e->callee->declare_variant_alt\n+\t\t\t   && !e->callee->in_other_partition)\n+\t\t    reachable.add (e->callee);\n \t\t  enqueue_node (e->callee, &first, &reachable);\n \t\t}\n "}, {"sha": "17b6cfd83a78de48aff616687a6160b74cd8d900", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -535,6 +535,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->merged_extern_inline, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p, 1);\n   bp_pack_value (&bp, node->parallelized_function, 1);\n+  bp_pack_value (&bp, node->declare_variant_alt, 1);\n+  bp_pack_value (&bp, node->calls_declare_variant_alt, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN,\n \t\t/* When doing incremental link, we will get new resolution\n@@ -1186,6 +1188,8 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->merged_extern_inline = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n   node->parallelized_function = bp_unpack_value (bp, 1);\n+  node->declare_variant_alt = bp_unpack_value (bp, 1);\n+  node->calls_declare_variant_alt = bp_unpack_value (bp, 1);\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n   node->split_part = bp_unpack_value (bp, 1);"}, {"sha": "315f24aeddf3454e8816829d8d3b06aacd1915ec", "filename": "gcc/omp-general.c", "status": "modified", "additions": 298, "deletions": 7, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -642,6 +642,8 @@ omp_maybe_offloaded (void)\n   if (symtab->state == PARSING)\n     /* Maybe.  */\n     return true;\n+  if (cfun && cfun->after_inlining)\n+    return false;\n   if (current_function_decl\n       && lookup_attribute (\"omp declare target\",\n \t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n@@ -694,8 +696,7 @@ omp_context_selector_matches (tree ctx)\n \t     (so in most of the cases), and we'd need to maintain set of\n \t     surrounding OpenMP constructs, which is better handled during\n \t     gimplification.  */\n-\t  if (symtab->state == PARSING\n-\t      || (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t  if (symtab->state == PARSING)\n \t    {\n \t      ret = -1;\n \t      continue;\n@@ -704,6 +705,28 @@ omp_context_selector_matches (tree ctx)\n \t  enum tree_code constructs[5];\n \t  int nconstructs\n \t    = omp_constructor_traits_to_codes (TREE_VALUE (t1), constructs);\n+\n+\t  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t    {\n+\t      if (!cfun->after_inlining)\n+\t\t{\n+\t\t  ret = -1;\n+\t\t  continue;\n+\t\t}\n+\t      int i;\n+\t      for (i = 0; i < nconstructs; ++i)\n+\t\tif (constructs[i] == OMP_SIMD)\n+\t\t  break;\n+\t      if (i < nconstructs)\n+\t\t{\n+\t\t  ret = -1;\n+\t\t  continue;\n+\t\t}\n+\t      /* If there is no simd, assume it is ok after IPA,\n+\t\t constructs should have been checked before.  */\n+\t      continue;\n+\t    }\n+\n \t  int r = omp_construct_selector_matches (constructs, nconstructs,\n \t\t\t\t\t\t  NULL);\n \t  if (r == 0)\n@@ -738,6 +761,9 @@ omp_context_selector_matches (tree ctx)\n \t    case 'a':\n \t      if (set == 'i' && !strcmp (sel, \"atomic_default_mem_order\"))\n \t\t{\n+\t\t  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t\t    break;\n+\n \t\t  enum omp_memory_order omo\n \t\t    = ((enum omp_memory_order)\n \t\t       (omp_requires_mask\n@@ -816,6 +842,9 @@ omp_context_selector_matches (tree ctx)\n \t    case 'u':\n \t      if (set == 'i' && !strcmp (sel, \"unified_address\"))\n \t\t{\n+\t\t  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t\t    break;\n+\n \t\t  if ((omp_requires_mask & OMP_REQUIRES_UNIFIED_ADDRESS) == 0)\n \t\t    {\n \t\t      if (symtab->state == PARSING)\n@@ -827,6 +856,9 @@ omp_context_selector_matches (tree ctx)\n \t\t}\n \t      if (set == 'i' && !strcmp (sel, \"unified_shared_memory\"))\n \t\t{\n+\t\t  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t\t    break;\n+\n \t\t  if ((omp_requires_mask\n \t\t       & OMP_REQUIRES_UNIFIED_SHARED_MEMORY) == 0)\n \t\t    {\n@@ -841,6 +873,9 @@ omp_context_selector_matches (tree ctx)\n \t    case 'd':\n \t      if (set == 'i' && !strcmp (sel, \"dynamic_allocators\"))\n \t\t{\n+\t\t  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t\t    break;\n+\n \t\t  if ((omp_requires_mask\n \t\t       & OMP_REQUIRES_DYNAMIC_ALLOCATORS) == 0)\n \t\t    {\n@@ -855,6 +890,9 @@ omp_context_selector_matches (tree ctx)\n \t    case 'r':\n \t      if (set == 'i' && !strcmp (sel, \"reverse_offload\"))\n \t\t{\n+\t\t  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+\t\t    break;\n+\n \t\t  if ((omp_requires_mask & OMP_REQUIRES_REVERSE_OFFLOAD) == 0)\n \t\t    {\n \t\t      if (symtab->state == PARSING)\n@@ -944,7 +982,8 @@ omp_context_selector_matches (tree ctx)\n \t\t\t   #pragma omp declare simd on it, some simd clones\n \t\t\t   might have the isa added later on.  */\n \t\t\tif (r == -1\n-\t\t\t    && targetm.simd_clone.compute_vecsize_and_simdlen)\n+\t\t\t    && targetm.simd_clone.compute_vecsize_and_simdlen\n+\t\t\t    && (cfun == NULL || !cfun->after_inlining))\n \t\t\t  {\n \t\t\t    tree attrs\n \t\t\t      = DECL_ATTRIBUTES (current_function_decl);\n@@ -1415,13 +1454,201 @@ omp_context_compute_score (tree ctx, widest_int *score, bool declare_simd)\n   return ret;\n }\n \n+/* Class describing a single variant.  */\n+struct GTY(()) omp_declare_variant_entry {\n+  /* NODE of the variant.  */\n+  cgraph_node *variant;\n+  /* Score if not in declare simd clone.  */\n+  widest_int score;\n+  /* Score if in declare simd clone.  */\n+  widest_int score_in_declare_simd_clone;\n+  /* Context selector for the variant.  */\n+  tree ctx;\n+  /* True if the context selector is known to match already.  */\n+  bool matches;\n+};\n+\n+/* Class describing a function with variants.  */\n+struct GTY((for_user)) omp_declare_variant_base_entry {\n+  /* NODE of the base function.  */\n+  cgraph_node *base;\n+  /* NODE of the artificial function created for the deferred variant\n+     resolution.  */\n+  cgraph_node *node;\n+  /* Vector of the variants.  */\n+  vec<omp_declare_variant_entry, va_gc> *variants;\n+};\n+\n+struct omp_declare_variant_hasher\n+  : ggc_ptr_hash<omp_declare_variant_base_entry> {\n+  static hashval_t hash (omp_declare_variant_base_entry *);\n+  static bool equal (omp_declare_variant_base_entry *,\n+\t\t     omp_declare_variant_base_entry *);\n+};\n+\n+hashval_t\n+omp_declare_variant_hasher::hash (omp_declare_variant_base_entry *x)\n+{\n+  inchash::hash hstate;\n+  hstate.add_int (DECL_UID (x->base->decl));\n+  hstate.add_int (x->variants->length ());\n+  omp_declare_variant_entry *variant;\n+  unsigned int i;\n+  FOR_EACH_VEC_SAFE_ELT (x->variants, i, variant)\n+    {\n+      hstate.add_int (DECL_UID (variant->variant->decl));\n+      hstate.add_wide_int (variant->score);\n+      hstate.add_wide_int (variant->score_in_declare_simd_clone);\n+      hstate.add_ptr (variant->ctx);\n+      hstate.add_int (variant->matches);\n+    }\n+  return hstate.end ();\n+}\n+\n+bool\n+omp_declare_variant_hasher::equal (omp_declare_variant_base_entry *x,\n+\t\t\t\t   omp_declare_variant_base_entry *y)\n+{\n+  if (x->base != y->base\n+      || x->variants->length () != y->variants->length ())\n+    return false;\n+  omp_declare_variant_entry *variant;\n+  unsigned int i;\n+  FOR_EACH_VEC_SAFE_ELT (x->variants, i, variant)\n+    if (variant->variant != (*y->variants)[i].variant\n+\t|| variant->score != (*y->variants)[i].score\n+\t|| (variant->score_in_declare_simd_clone\n+\t    != (*y->variants)[i].score_in_declare_simd_clone)\n+\t|| variant->ctx != (*y->variants)[i].ctx\n+\t|| variant->matches != (*y->variants)[i].matches)\n+      return false;\n+  return true;\n+}\n+\n+static GTY(()) hash_table<omp_declare_variant_hasher> *omp_declare_variants;\n+\n+struct omp_declare_variant_alt_hasher\n+  : ggc_ptr_hash<omp_declare_variant_base_entry> {\n+  static hashval_t hash (omp_declare_variant_base_entry *);\n+  static bool equal (omp_declare_variant_base_entry *,\n+\t\t     omp_declare_variant_base_entry *);\n+};\n+\n+hashval_t\n+omp_declare_variant_alt_hasher::hash (omp_declare_variant_base_entry *x)\n+{\n+  return DECL_UID (x->node->decl);\n+}\n+\n+bool\n+omp_declare_variant_alt_hasher::equal (omp_declare_variant_base_entry *x,\n+\t\t\t\t       omp_declare_variant_base_entry *y)\n+{\n+  return x->node == y->node;\n+}\n+\n+static GTY(()) hash_table<omp_declare_variant_alt_hasher>\n+  *omp_declare_variant_alt;\n+\n+/* Try to resolve declare variant after gimplification.  */\n+\n+static tree\n+omp_resolve_late_declare_variant (tree alt)\n+{\n+  cgraph_node *node = cgraph_node::get (alt);\n+  cgraph_node *cur_node = cgraph_node::get (cfun->decl);\n+  if (node == NULL\n+      || !node->declare_variant_alt\n+      || !cfun->after_inlining)\n+    return alt;\n+\n+  omp_declare_variant_base_entry entry;\n+  entry.base = NULL;\n+  entry.node = node;\n+  entry.variants = NULL;\n+  omp_declare_variant_base_entry *entryp\n+    = omp_declare_variant_alt->find_with_hash (&entry, DECL_UID (alt));\n+\n+  unsigned int i, j;\n+  omp_declare_variant_entry *varentry1, *varentry2;\n+  auto_vec <bool, 16> matches;\n+  unsigned int nmatches = 0;\n+  FOR_EACH_VEC_SAFE_ELT (entryp->variants, i, varentry1)\n+    {\n+      if (varentry1->matches)\n+\t{\n+\t  /* This has been checked to be ok already.  */\n+\t  matches.safe_push (true);\n+\t  nmatches++;\n+\t  continue;\n+\t}\n+      switch (omp_context_selector_matches (varentry1->ctx))\n+\t{\n+\tcase 0:\n+          matches.safe_push (false);\n+\t  break;\n+\tcase -1:\n+\t  return alt;\n+\tdefault:\n+\t  matches.safe_push (true);\n+\t  nmatches++;\n+\t  break;\n+\t}\n+    }\n+\n+  if (nmatches == 0)\n+    return entryp->base->decl;\n+\n+  /* A context selector that is a strict subset of another context selector\n+     has a score of zero.  */\n+  FOR_EACH_VEC_SAFE_ELT (entryp->variants, i, varentry1)\n+    if (matches[i])\n+      {\n+        for (j = i + 1;\n+\t     vec_safe_iterate (entryp->variants, j, &varentry2); ++j)\n+\t  if (matches[j])\n+\t    {\n+\t      int r = omp_context_selector_compare (varentry1->ctx,\n+\t\t\t\t\t\t    varentry2->ctx);\n+\t      if (r == -1)\n+\t\t{\n+\t\t  /* ctx1 is a strict subset of ctx2, ignore ctx1.  */\n+\t\t  matches[i] = false;\n+\t\t  break;\n+\t\t}\n+\t      else if (r == 1)\n+\t\t/* ctx2 is a strict subset of ctx1, remove ctx2.  */\n+\t\tmatches[j] = false;\n+\t    }\n+      }\n+\n+  widest_int max_score = -1;\n+  varentry2 = NULL;\n+  FOR_EACH_VEC_SAFE_ELT (entryp->variants, i, varentry1)\n+    if (matches[i])\n+      {\n+\twidest_int score\n+\t  = (cur_node->simdclone ? varentry1->score_in_declare_simd_clone\n+\t     : varentry1->score);\n+\tif (score > max_score)\n+\t  {\n+\t    max_score = score;\n+\t    varentry2 = varentry1;\n+\t  }\n+      }\n+  return varentry2->variant->decl;\n+}\n+\n /* Try to resolve declare variant, return the variant decl if it should\n    be used instead of base, or base otherwise.  */\n \n tree\n omp_resolve_declare_variant (tree base)\n {\n   tree variant1 = NULL_TREE, variant2 = NULL_TREE;\n+  if (cfun && (cfun->curr_properties & PROP_gimple_any) != 0)\n+    return omp_resolve_late_declare_variant (base);\n+\n   auto_vec <tree, 16> variants;\n   auto_vec <bool, 16> defer;\n   bool any_deferred = false;\n@@ -1459,6 +1686,10 @@ omp_resolve_declare_variant (tree base)\n       bool first = true;\n       unsigned int i;\n       tree attr1, attr2;\n+      omp_declare_variant_base_entry entry;\n+      entry.base = cgraph_node::get_create (base);\n+      entry.node = NULL;\n+      vec_alloc (entry.variants, variants.length ());\n       FOR_EACH_VEC_ELT (variants, i, attr1)\n \t{\n \t  widest_int score1;\n@@ -1498,6 +1729,14 @@ omp_resolve_declare_variant (tree base)\n \t\t  variant2 = defer[i] ? NULL_TREE : attr1;\n \t\t}\n \t    }\n+\t  omp_declare_variant_entry varentry;\n+\t  varentry.variant\n+\t    = cgraph_node::get_create (TREE_PURPOSE (TREE_VALUE (attr1)));\n+\t  varentry.score = score1;\n+\t  varentry.score_in_declare_simd_clone = score2;\n+\t  varentry.ctx = ctx;\n+\t  varentry.matches = !defer[i];\n+\t  entry.variants->quick_push (varentry);\n \t}\n \n       /* If there is a clear winner variant with the score which is not\n@@ -1522,17 +1761,67 @@ omp_resolve_declare_variant (tree base)\n \t\t}\n \t    }\n \t  if (variant1)\n-\t    return TREE_PURPOSE (TREE_VALUE (variant1));\n+\t    {\n+\t      vec_free (entry.variants);\n+\t      return TREE_PURPOSE (TREE_VALUE (variant1));\n+\t    }\n+\t}\n+\n+      if (omp_declare_variants == NULL)\n+\tomp_declare_variants\n+\t  = hash_table<omp_declare_variant_hasher>::create_ggc (64);\n+      omp_declare_variant_base_entry **slot\n+\t= omp_declare_variants->find_slot (&entry, INSERT);\n+      if (*slot != NULL)\n+\t{\n+\t  vec_free (entry.variants);\n+\t  return (*slot)->node->decl;\n \t}\n \n-      return base;\n+      *slot = ggc_cleared_alloc<omp_declare_variant_base_entry> ();\n+      (*slot)->base = entry.base;\n+      (*slot)->node = entry.base;\n+      (*slot)->variants = entry.variants;\n+      tree alt = build_decl (DECL_SOURCE_LOCATION (base), FUNCTION_DECL,\n+\t\t\t     DECL_NAME (base), TREE_TYPE (base));\n+      DECL_ARTIFICIAL (alt) = 1;\n+      DECL_IGNORED_P (alt) = 1;\n+      TREE_STATIC (alt) = 1;\n+      tree attributes = DECL_ATTRIBUTES (base);\n+      if (lookup_attribute (\"noipa\", attributes) == NULL)\n+\t{\n+\t  attributes = tree_cons (get_identifier (\"noipa\"), NULL, attributes);\n+\t  if (lookup_attribute (\"noinline\", attributes) == NULL)\n+\t    attributes = tree_cons (get_identifier (\"noinline\"), NULL,\n+\t\t\t\t    attributes);\n+\t  if (lookup_attribute (\"noclone\", attributes) == NULL)\n+\t    attributes = tree_cons (get_identifier (\"noclone\"), NULL,\n+\t\t\t\t    attributes);\n+\t  if (lookup_attribute (\"no_icf\", attributes) == NULL)\n+\t    attributes = tree_cons (get_identifier (\"no_icf\"), NULL,\n+\t\t\t\t    attributes);\n+\t}\n+      DECL_ATTRIBUTES (alt) = attributes;\n+      DECL_INITIAL (alt) = error_mark_node;\n+      (*slot)->node = cgraph_node::create (alt);\n+      (*slot)->node->declare_variant_alt = 1;\n+      (*slot)->node->create_reference (entry.base, IPA_REF_ADDR);\n+      omp_declare_variant_entry *varentry;\n+      FOR_EACH_VEC_SAFE_ELT (entry.variants, i, varentry)\n+\t(*slot)->node->create_reference (varentry->variant, IPA_REF_ADDR);\n+      if (omp_declare_variant_alt == NULL)\n+\tomp_declare_variant_alt\n+\t  = hash_table<omp_declare_variant_alt_hasher>::create_ggc (64);\n+      *omp_declare_variant_alt->find_slot_with_hash (*slot, DECL_UID (alt),\n+\t\t\t\t\t\t     INSERT) = *slot;\n+      return alt;\n     }\n \n   if (variants.length () == 1)\n     return TREE_PURPOSE (TREE_VALUE (variants[0]));\n \n-  /* A context selector that is a strict subset of another context selector has a score\n-     of zero.  */\n+  /* A context selector that is a strict subset of another context selector\n+     has a score of zero.  */\n   tree attr1, attr2;\n   unsigned int i, j;\n   FOR_EACH_VEC_ELT (variants, i, attr1)\n@@ -1948,3 +2237,5 @@ oacc_get_ifn_dim_arg (const gimple *stmt)\n   gcc_checking_assert (axis >= 0 && axis < GOMP_DIM_MAX);\n   return (int) axis;\n }\n+\n+#include \"gt-omp-general.h\""}, {"sha": "b2df91a5724b73949a1d85fa0f1b6651b0dd5e57", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -2066,12 +2066,28 @@ execute_omp_device_lower ()\n   bool regimplify = false;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n+  bool calls_declare_variant_alt\n+    = cgraph_node::get (cfun->decl)->calls_declare_variant_alt;\n   FOR_EACH_BB_FN (bb, cfun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n \tgimple *stmt = gsi_stmt (gsi);\n-\tif (!is_gimple_call (stmt) || !gimple_call_internal_p (stmt))\n+\tif (!is_gimple_call (stmt))\n \t  continue;\n+\tif (!gimple_call_internal_p (stmt))\n+\t  {\n+\t    if (calls_declare_variant_alt)\n+\t      if (tree fndecl = gimple_call_fndecl (stmt))\n+\t\t{\n+\t\t  tree new_fndecl = omp_resolve_declare_variant (fndecl);\n+\t\t  if (new_fndecl != fndecl)\n+\t\t    {\n+\t\t      gimple_call_set_fndecl (stmt, new_fndecl);\n+\t\t      update_stmt (stmt);\n+\t\t    }\n+\t\t}\n+\t    continue;\n+\t  }\n \ttree lhs = gimple_call_lhs (stmt), rhs = NULL_TREE;\n \ttree type = lhs ? TREE_TYPE (lhs) : integer_type_node;\n \tswitch (gimple_call_internal_fn (stmt))\n@@ -2165,7 +2181,9 @@ class pass_omp_device_lower : public gimple_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *fun)\n     {\n-      return !(fun->curr_properties & PROP_gimple_lomp_dev);\n+      return (!(fun->curr_properties & PROP_gimple_lomp_dev)\n+\t      || (flag_openmp\n+\t\t  && cgraph_node::get (fun->decl)->calls_declare_variant_alt));\n     }\n   virtual unsigned int execute (function *)\n     {"}, {"sha": "942fb971cb786e47ad444662d9654d3580b4c468", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -477,6 +477,7 @@ simd_clone_create (struct cgraph_node *old_node)\n      the old node.  */\n   new_node->local = old_node->local;\n   new_node->externally_visible = old_node->externally_visible;\n+  new_node->calls_declare_variant_alt = old_node->calls_declare_variant_alt;\n \n   return new_node;\n }"}, {"sha": "2b6d4becf4eca2c1c3ea8045ad854d2bf2fe7122", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -1,5 +1,7 @@\n 2020-05-14  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/declare-variant-14.c: New test.\n+\n \tPR middle-end/95108\n \t* gcc.dg/gomp/pr95108.c: New test.\n "}, {"sha": "cdb0bb34f505bc9bd82a14b57d35138800bc4523", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-14.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-14.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile { target vect_simd_clones } } */\n+/* { dg-additional-options \"-fdump-tree-gimple -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+int f01 (int);\n+int f02 (int);\n+int f03 (int);\n+#pragma omp declare variant (f01) match (device={isa(\"avx512f\")}) /* 4 or 8 */\n+#pragma omp declare variant (f02) match (implementation={vendor(score(3):gnu)},device={kind(cpu)}) /* (1 or 2) + 3 */\n+#pragma omp declare variant (f03) match (implementation={vendor(score(5):gnu)},device={kind(host)}) /* (1 or 2) + 5 */\n+int f04 (int);\n+\n+#pragma omp declare simd\n+int\n+test1 (int x)\n+{\n+  /* At gimplification time, we can't decide yet which function to call.  */\n+  /* { dg-final { scan-tree-dump-times \"f04 \\\\\\(x\" 2 \"gimple\" } } */\n+  /* After simd clones are created, the original non-clone test1 shall\n+     call f03 (score 6), the sse2/avx/avx2 clones too, but avx512f clones\n+     shall call f01 with score 8.  */\n+  /* { dg-final { scan-tree-dump-not \"f04 \\\\\\(x\" \"optimized\" } } */\n+  /* { dg-final { scan-tree-dump-times \"f03 \\\\\\(x\" 14 \"optimized\" } } */\n+  /* { dg-final { scan-tree-dump-times \"f01 \\\\\\(x\" 4 \"optimized\" } } */\n+  int a = f04 (x);\n+  int b = f04 (x);\n+  return a + b;\n+}"}, {"sha": "ee96c9cfff08a12324a1e77fd411b0996d184950", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a50e7087567cffb21e81fff566546b8a8dac270/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=7a50e7087567cffb21e81fff566546b8a8dac270", "patch": "@@ -4900,6 +4900,8 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n   if (src_properties != prop_mask)\n     dst_cfun->curr_properties &= src_properties | ~prop_mask;\n   dst_cfun->calls_eh_return |= id->src_cfun->calls_eh_return;\n+  id->dst_node->calls_declare_variant_alt\n+    |= id->src_node->calls_declare_variant_alt;\n \n   gcc_assert (!id->src_cfun->after_inlining);\n \n@@ -6231,6 +6233,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   DECL_ARGUMENTS (new_decl) = DECL_ARGUMENTS (old_decl);\n   initialize_cfun (new_decl, old_decl,\n \t\t   new_entry ? new_entry->count : old_entry_block->count);\n+  new_version_node->calls_declare_variant_alt\n+    = old_version_node->calls_declare_variant_alt;\n   if (DECL_STRUCT_FUNCTION (new_decl)->gimple_df)\n     DECL_STRUCT_FUNCTION (new_decl)->gimple_df->ipa_pta\n       = id.src_cfun->gimple_df->ipa_pta;"}]}