{"sha": "0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwMzMyOWE2ZjVlNmFiZjdkZjlhZGI4MzMxMTM2NDE0ZTZmYjVhNg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-05-25T11:12:47Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-05-25T11:12:47Z"}, "message": "c-parse.in (array_declarator): New.\n\n\t* c-parse.in (array_declarator): New.  Handle C99 constructs.\n\tDon't restrict [*] declarators to C only.\n\t(after_type_declarator, parm_declarator_starttypename,\n\tparm_declarator_nostarttypename, notype_declarator,\n\tdirect_absdcl1): Use it.\n\t* c-decl.c (build_array_declarator, set_array_declarator_type):\n\tNew functions.  Warn that [*] isn't properly implemented; pedwarn\n\tfor [*] outside C99 mode if pedantic rather than giving a hard\n\terror.\n\t(grokdeclarator): Handle static and type qualifiers in parameter\n\tarray declarators.\n\t* c-tree.h (build_array_declarator, set_array_declarator_type):\n\tDeclare.\n\t* extend.texi (Attribute Syntax): Document attributes in parameter\n\tarray declarators.\n\ntestsuite:\n\t* gcc.dg/c90-arraydecl-1.c, gcc.dg/c99-arraydecl-1.c: New tests.\n\nFrom-SVN: r42574", "tree": {"sha": "0d9cee59da5c70c8d1b6baefbc0569ba13d97432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d9cee59da5c70c8d1b6baefbc0569ba13d97432"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b60868e00c8cc0fdda3018293c6c1149a62bed52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60868e00c8cc0fdda3018293c6c1149a62bed52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b60868e00c8cc0fdda3018293c6c1149a62bed52"}], "stats": {"total": 373, "additions": 329, "deletions": 44}, "files": [{"sha": "8701ae30e454e3ec7e496a26c49bb04ef8d69259", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -1,3 +1,21 @@\n+2001-05-25  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-parse.in (array_declarator): New.  Handle C99 constructs.\n+\tDon't restrict [*] declarators to C only.\n+\t(after_type_declarator, parm_declarator_starttypename,\n+\tparm_declarator_nostarttypename, notype_declarator,\n+\tdirect_absdcl1): Use it.\n+\t* c-decl.c (build_array_declarator, set_array_declarator_type):\n+\tNew functions.  Warn that [*] isn't properly implemented; pedwarn\n+\tfor [*] outside C99 mode if pedantic rather than giving a hard\n+\terror.\n+\t(grokdeclarator): Handle static and type qualifiers in parameter\n+\tarray declarators.\n+\t* c-tree.h (build_array_declarator, set_array_declarator_type):\n+\tDeclare.\n+\t* extend.texi (Attribute Syntax): Document attributes in parameter\n+\tarray declarators.\n+\n 2001-05-25  Mark  <mark@codesourcery.com>\n \n \t* config/i386/i386.md: Make sure cmpstr peepholes do not "}, {"sha": "758888561a4f8c1b7ed2159d9e5a3dfd0e2e6838", "filename": "gcc/c-decl.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -3278,6 +3278,60 @@ shadow_tag_warned (declspecs, warned)\n     }\n }\n \f\n+/* Construct an array declarator.  EXPR is the expression inside [], or\n+   NULL_TREE.  QUALS are the type qualifiers inside the [] (to be applied\n+   to the pointer to which a parameter array is converted).  STATIC_P is\n+   non-zero if \"static\" is inside the [], zero otherwise.  VLA_UNSPEC_P\n+   is non-zero is the array is [*], a VLA of unspecified length which is\n+   nevertheless a complete type (not currently implemented by GCC),\n+   zero otherwise.  The declarator is constructed as an ARRAY_REF\n+   (to be decoded by grokdeclarator), whose operand 0 is what's on the\n+   left of the [] (filled by in set_array_declarator_type) and operand 1\n+   is the expression inside; whose TREE_TYPE is the type qualifiers and\n+   which has TREE_STATIC set if \"static\" is used.  */\n+\n+tree\n+build_array_declarator (expr, quals, static_p, vla_unspec_p)\n+     tree expr;\n+     tree quals;\n+     int static_p;\n+     int vla_unspec_p;\n+{\n+  tree decl;\n+  decl = build_nt (ARRAY_REF, NULL_TREE, expr);\n+  TREE_TYPE (decl) = quals;\n+  TREE_STATIC (decl) = (static_p ? 1 : 0);\n+  if (pedantic && !flag_isoc99)\n+    {\n+      if (static_p || quals != NULL_TREE)\n+\tpedwarn (\"ISO C89 does not support `static' or type qualifiers in parameter array declarators\");\n+      if (vla_unspec_p)\n+\tpedwarn (\"ISO C89 does not support `[*]' array declarators\");\n+    }\n+  if (vla_unspec_p)\n+    warning (\"GCC does not yet properly implement `[*]' array declarators\");\n+  return decl;\n+}\n+\n+/* Set the type of an array declarator.  DECL is the declarator, as\n+   constructed by build_array_declarator; TYPE is what appears on the left\n+   of the [] and goes in operand 0.  ABSTRACT_P is non-zero if it is an\n+   abstract declarator, zero otherwise; this is used to reject static and\n+   type qualifiers in abstract declarators, where they are not in the\n+   C99 grammar.  */\n+\n+tree\n+set_array_declarator_type (decl, type, abstract_p)\n+     tree decl;\n+     tree type;\n+     int abstract_p;\n+{\n+  TREE_OPERAND (decl, 0) = type;\n+  if (abstract_p && (TREE_TYPE (decl) != NULL_TREE || TREE_STATIC (decl)))\n+    error (\"static or type qualifiers in abstract declarator\");\n+  return decl;\n+}\n+\f\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n@@ -3861,6 +3915,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   int bitfield = 0;\n   int size_varies = 0;\n   tree decl_machine_attr = NULL_TREE;\n+  tree array_ptr_quals = NULL_TREE;\n+  int array_parm_static = 0;\n \n   if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n@@ -4289,13 +4345,26 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t array or function or pointer, and DECLARATOR has had its\n \t outermost layer removed.  */\n \n+      if (array_ptr_quals != NULL_TREE || array_parm_static)\n+\t{\n+\t  /* Only the innermost declarator (making a parameter be of\n+\t     array type which is converted to pointer type)\n+\t     may have static or type qualifiers.  */\n+\t  error (\"static or type qualifiers in non-parameter array declarator\");\n+\t  array_ptr_quals = NULL_TREE;\n+\t  array_parm_static = 0;\n+\t}\n+\n       if (TREE_CODE (declarator) == ARRAY_REF)\n \t{\n \t  register tree itype = NULL_TREE;\n \t  register tree size = TREE_OPERAND (declarator, 1);\n \t  /* The index is a signed object `sizetype' bits wide.  */\n \t  tree index_type = signed_type (sizetype);\n \n+\t  array_ptr_quals = TREE_TYPE (declarator);\n+\t  array_parm_static = TREE_STATIC (declarator);\n+\n \t  declarator = TREE_OPERAND (declarator, 0);\n \n \t  /* Check for some types that there cannot be arrays of.  */\n@@ -4445,6 +4514,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t      TYPE_SIZE (type) = bitsize_zero_node;\n \t      TYPE_SIZE_UNIT (type) = size_zero_node;\n \t    }\n+\t  if (decl_context != PARM\n+\t      && (array_ptr_quals != NULL_TREE || array_parm_static))\n+\t    {\n+\t      error (\"static or type qualifiers in non-parameter array declarator\");\n+\t      array_ptr_quals = NULL_TREE;\n+\t      array_parm_static = 0;\n+\t    }\n \t}\n       else if (TREE_CODE (declarator) == CALL_EXPR)\n \t{\n@@ -4696,6 +4772,44 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t      type = c_build_qualified_type (type, type_quals);\n \t    type = build_pointer_type (type);\n \t    type_quals = TYPE_UNQUALIFIED;\n+\t    if (array_ptr_quals)\n+\t      {\n+\t\ttree new_ptr_quals, new_ptr_attrs;\n+\t\tint erred = 0;\n+\t\tsplit_specs_attrs (array_ptr_quals, &new_ptr_quals, &new_ptr_attrs);\n+\t\t/* We don't yet implement attributes in this context.  */\n+\t\tif (new_ptr_attrs != NULL_TREE)\n+\t\t  warning (\"attributes in parameter array declarator ignored\");\n+\n+\t\tconstp = 0;\n+\t\tvolatilep = 0;\n+\t\trestrictp = 0;\n+\t\tfor (; new_ptr_quals; new_ptr_quals = TREE_CHAIN (new_ptr_quals))\n+\t\t  {\n+\t\t    tree qualifier = TREE_VALUE (new_ptr_quals);\n+\n+\t\t    if (C_IS_RESERVED_WORD (qualifier))\n+\t\t      {\n+\t\t\tif (C_RID_CODE (qualifier) == RID_CONST)\n+\t\t\t  constp++;\n+\t\t\telse if (C_RID_CODE (qualifier) == RID_VOLATILE)\n+\t\t\t  volatilep++;\n+\t\t\telse if (C_RID_CODE (qualifier) == RID_RESTRICT)\n+\t\t\t  restrictp++;\n+\t\t\telse\n+\t\t\t  erred++;\n+\t\t      }\n+\t\t    else\n+\t\t      erred++;\n+\t\t  }\n+\n+\t\tif (erred)\n+\t\t  error (\"invalid type modifier within array declarator\");\n+\n+\t\ttype_quals = ((constp ? TYPE_QUAL_CONST : 0)\n+\t\t\t      | (restrictp ? TYPE_QUAL_RESTRICT : 0)\n+\t\t\t      | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n+\t      }\n \t    size_varies = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)"}, {"sha": "e64e140dfa1e5cda8ee5f75787eb7c2b5fa77d8c", "filename": "gcc/c-parse.in", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -198,6 +198,7 @@ end ifc\n %type <ttype> notype_declarator after_type_declarator\n %type <ttype> parm_declarator\n %type <ttype> parm_declarator_starttypename parm_declarator_nostarttypename\n+%type <ttype> array_declarator\n \n %type <ttype> structsp_attr structsp_nonattr\n %type <ttype> component_decl_list component_decl_list2\n@@ -1668,10 +1669,8 @@ after_type_declarator:\n /*\t| after_type_declarator '(' error ')'  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n \t\t  poplevel (0, 0, 0); }  */\n-\t| after_type_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| after_type_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| after_type_declarator array_declarator  %prec '.'\n+\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n \t| '*' maybe_type_quals_setattrs after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| TYPENAME\n@@ -1695,17 +1694,8 @@ parm_declarator_starttypename:\n /*\t| parm_declarator_starttypename '(' error ')'  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n \t\t  poplevel (0, 0, 0); }  */\n-ifc\n-\t| parm_declarator_starttypename '[' '*' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE);\n-\t\t  if (! flag_isoc99)\n-\t\t    error (\"`[*]' in parameter declaration only allowed in ISO C 99\");\n-\t\t}\n-end ifc\n-\t| parm_declarator_starttypename '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| parm_declarator_starttypename '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| parm_declarator_starttypename array_declarator  %prec '.'\n+\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n \t| TYPENAME\n \t;\n \n@@ -1715,17 +1705,8 @@ parm_declarator_nostarttypename:\n /*\t| parm_declarator_nostarttypename '(' error ')'  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n \t\t  poplevel (0, 0, 0); }  */\n-ifc\n-\t| parm_declarator_nostarttypename '[' '*' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE);\n-\t\t  if (! flag_isoc99)\n-\t\t    error (\"`[*]' in parameter declaration only allowed in ISO C 99\");\n-\t\t}\n-end ifc\n-\t| parm_declarator_nostarttypename '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| parm_declarator_nostarttypename '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| parm_declarator_nostarttypename array_declarator  %prec '.'\n+\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n \t| '*' maybe_type_quals_setattrs parm_declarator_starttypename  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| '*' maybe_type_quals_setattrs parm_declarator_nostarttypename  %prec UNARY\n@@ -1747,17 +1728,8 @@ notype_declarator:\n \t\t{ $$ = $3; }\n \t| '*' maybe_type_quals_setattrs notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-ifc\n-\t| notype_declarator '[' '*' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE);\n-\t\t  if (! flag_isoc99)\n-\t\t    error (\"`[*]' in parameter declaration only allowed in ISO C 99\");\n-\t\t}\n-end ifc\n-\t| notype_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| notype_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| notype_declarator array_declarator  %prec '.'\n+\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n \t| IDENTIFIER\n \t;\n \n@@ -2035,16 +2007,42 @@ direct_absdcl1:\n \t\t{ $$ = $3; }\n \t| direct_absdcl1 '(' parmlist\n \t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-\t| direct_absdcl1 '[' expr ']'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| direct_absdcl1 '[' ']'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| direct_absdcl1 array_declarator\n+\t\t{ $$ = set_array_declarator_type ($2, $1, 1); }\n \t| '(' parmlist\n \t\t{ $$ = build_nt (CALL_EXPR, NULL_TREE, $2, NULL_TREE); }\n-\t| '[' expr ']'\n-\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n+\t| array_declarator\n+\t\t{ $$ = set_array_declarator_type ($1, NULL_TREE, 1); }\n+\t;\n+\n+/* The [...] part of a declarator for an array type.  */\n+\n+array_declarator:\n+\t  '[' expr ']'\n+\t\t{ $$ = build_array_declarator ($2, NULL_TREE, 0, 0); }\n+\t| '[' declspecs_nosc expr ']'\n+\t\t{ $$ = build_array_declarator ($3, $2, 0, 0); }\n \t| '[' ']'\n-\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n+\t\t{ $$ = build_array_declarator (NULL_TREE, NULL_TREE, 0, 0); }\n+\t| '[' declspecs_nosc ']'\n+\t\t{ $$ = build_array_declarator (NULL_TREE, $2, 0, 0); }\n+\t| '[' '*' ']'\n+\t\t{ $$ = build_array_declarator (NULL_TREE, NULL_TREE, 0, 1); }\n+\t| '[' declspecs_nosc '*' ']'\n+\t\t{ $$ = build_array_declarator (NULL_TREE, $2, 0, 1); }\n+\t| '[' SCSPEC expr ']'\n+\t\t{ if (C_RID_CODE ($2) != RID_STATIC)\n+\t\t    error (\"storage class specifier in array declarator\");\n+\t\t  $$ = build_array_declarator ($3, NULL_TREE, 1, 0); }\n+\t| '[' SCSPEC declspecs_nosc expr ']'\n+\t\t{ if (C_RID_CODE ($2) != RID_STATIC)\n+\t\t    error (\"storage class specifier in array declarator\");\n+\t\t  $$ = build_array_declarator ($4, $3, 1, 0); }\n+\t| '[' declspecs_nosc SCSPEC expr ']'\n+\t\t{ if (C_RID_CODE ($3) != RID_STATIC)\n+\t\t    error (\"storage class specifier in array declarator\");\n+\t\t  $$ = build_array_declarator ($4, $2, 1, 0); }\n+\t;\n \n /* A nonempty series of declarations and statements (possibly followed by\n    some labels) that can form the body of a compound statement."}, {"sha": "8264ebd06901d92c10f4f76bd4b1e107ae6fcdad", "filename": "gcc/c-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -153,6 +153,7 @@ extern int yyparse_1\t\t\t\tPARAMS ((void));\n extern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n \n /* in c-decl.c */\n+extern tree build_array_declarator              PARAMS ((tree, tree, int, int));\n extern tree build_enumerator                    PARAMS ((tree, tree));\n \n #define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n@@ -197,6 +198,7 @@ extern void push_label_level                    PARAMS ((void));\n extern void push_parm_decl                      PARAMS ((tree));\n extern tree pushdecl_top_level                  PARAMS ((tree));\n extern void pushtag                             PARAMS ((tree, tree));\n+extern tree set_array_declarator_type           PARAMS ((tree, tree, int));\n extern tree shadow_label                        PARAMS ((tree));\n extern void shadow_record_fields                PARAMS ((tree));\n extern void shadow_tag                          PARAMS ((tree));"}, {"sha": "8f40ef77f15db795feed08ad921282f5fbd8f352", "filename": "gcc/extend.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -2182,6 +2182,13 @@ An attribute specifier list may, in future, be permitted to appear after\n the declarator in a function definition (before any old-style parameter\n declarations or the function body).\n \n+Attribute specifiers may be mixed with type qualifiers appearing inside\n+the @code{[]} of a parameter array declarator, in the C99 construct by\n+which such qualifiers are applied to the pointer to which the array is\n+implicitly converted.  Such attribute specifiers apply to the pointer,\n+not to the array, but at present this is not implemented and they are\n+ignored.\n+\n An attribute specifier list may appear at the start of a nested\n declarator.  At present, there are some limitations in this usage: the\n attributes apply to the identifer declared, and to all subsequent"}, {"sha": "5ce646c146abc4de1e5a35024db6ac01d22fb26a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -1,3 +1,7 @@\n+2001-05-25  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/c90-arraydecl-1.c, gcc.dg/c99-arraydecl-1.c: New tests.\n+\n 2001-05-24  Mark Mitchell  <mark@codesourcery.com>\n \n \tG++ no longer defines builtins that do not begin with __builtin."}, {"sha": "b3e7035c05904b497d27e5577fc7b97e11d6c16b", "filename": "gcc/testsuite/gcc.dg/c90-arraydecl-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-arraydecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-arraydecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-arraydecl-1.c?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -0,0 +1,31 @@\n+/* Test for C99 forms of array declarator: rejected in C90.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+/* Use of [*] (possibly with type qualifiers) in an array declarator with\n+   function prototype scope is a C99 feature.  GCC does not yet implement\n+   it correctly, so gives a warning about this. so we can't yet test here\n+   that we get just one error and no warnings.  */\n+\n+void foo0 (int a, int b[*]); /* { dg-error \"ISO C89\" \"\\[*\\] not in C89\" } */\n+/* { dg-warning \"implement\" \"\\[*\\] not implemented\" { target *-*-* } 11 } */\n+void foo1 (int, int [*]); /* { dg-error \"ISO C89\" \"\\[*\\] not in C89\" } */\n+/* { dg-warning \"implement\" \"\\[*\\] not implemented\" { target *-*-* } 13 } */\n+\n+/* Use of static and type qualifiers (not allowed with abstract declarators)\n+   is a C99 feature.  */\n+\n+void bar0 (int a[const]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"ISO C89\" \"\\[quals\\] not in C89\" { target *-*-* } 19 } */\n+void bar1 (int a[const 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"ISO C89\" \"\\[quals expr\\] not in C89\" { target *-*-* } 21 } */\n+void bar2 (int a[static 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"ISO C89\" \"\\[static expr\\] not in C89\" { target *-*-* } 23 } */\n+void bar3 (int a[static const 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"ISO C89\" \"\\[static quals expr\\] not in C89\" { target *-*-* } 25 } */\n+void bar4 (int a[const static 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"ISO C89\" \"\\[quals static expr\\] not in C89\" { target *-*-* } 27 } */\n+\n+/* Because [*] isn't properly implemented and so warns, we don't test here\n+   for [const *] yet.  */"}, {"sha": "24ddd6571cd6761cf6829db6c295546eef98d1fe", "filename": "gcc/testsuite/gcc.dg/c99-arraydecl-1.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-arraydecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e03329a6f5e6abf7df9adb8331136414e6fb5a6/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-arraydecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-arraydecl-1.c?ref=0e03329a6f5e6abf7df9adb8331136414e6fb5a6", "patch": "@@ -0,0 +1,111 @@\n+/* Test for C99 forms of array declarator.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+/* Because GCC doesn't yet implement it, we don't yet test for [*] here.  */\n+\n+/* Test each of: [quals], [quals expr], [static expr], [static quals expr],\n+   [quals static expr].  Not yet: [quals *].  */\n+\n+void f00 (int a[const]);\n+void f01 (int [const]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"abstract\" \"\\[quals\\] in abstract declarator\" { target *-*-* } 12 } */\n+void\n+f02 (int a[const])\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 17 } */\n+  int *const *c = &a;\n+}\n+void\n+f03 (a)\n+     int a[const];\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 25 } */\n+  int *const *c = &a;\n+}\n+\n+void f10 (int a[const 2]);\n+void f11 (int [const 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"abstract\" \"\\[quals expr\\] in abstract declarator\" { target *-*-* } 31 } */\n+void\n+f12 (int a[const 2])\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 36 } */\n+  int *const *c = &a;\n+}\n+void\n+f13 (a)\n+     int a[const 2];\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 44 } */\n+  int *const *c = &a;\n+}\n+\n+void f20 (int a[static 2]);\n+void f21 (int [static 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"abstract\" \"\\[static expr\\] in abstract declarator\" { target *-*-* } 50 } */\n+void\n+f22 (int a[static 2])\n+{\n+  int **b = &a;\n+  int *const *c = &a;\n+}\n+void\n+f23 (a)\n+     int a[static 2];\n+{\n+  int **b = &a;\n+  int *const *c = &a;\n+}\n+\n+void f30 (int a[static const 2]);\n+void f31 (int [static const 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"abstract\" \"\\[static quals expr\\] in abstract declarator\" { target *-*-* } 67 } */\n+void\n+f32 (int a[static const 2])\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 72 } */\n+  int *const *c = &a;\n+}\n+void\n+f33 (a)\n+     int a[static const 2];\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 80 } */\n+  int *const *c = &a;\n+}\n+\n+void f40 (int a[const static 2]);\n+void f41 (int [const static 2]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"abstract\" \"\\[quals static expr\\] in abstract declarator\" { target *-*-* } 86 } */\n+void\n+f42 (int a[const static 2])\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 91 } */\n+  int *const *c = &a;\n+}\n+void\n+f43 (a)\n+     int a[const static 2];\n+{\n+  int **b = &a; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"discards\" \"discards quals\" { target *-*-* } 99 } */\n+  int *const *c = &a;\n+}\n+\n+/* Test rejection of static and type qualifiers in non-parameter contexts.  */\n+int x[const 2]; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"non-parameter\" \"quals in non-parm array\" { target *-*-* } 105 } */\n+int y[static 2]; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"non-parameter\" \"static in non-parm array\" { target *-*-* } 107 } */\n+void g (int a[static 2][3]);\n+void h (int a[2][static 3]); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"non-parameter\" \"static in non-final parm array\" { target *-*-* } 110 } */"}]}