{"sha": "776fbb7478011611c58ba664a4c8ef3a0df8f75f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc2ZmJiNzQ3ODAxMTYxMWM1OGJhNjY0YTRjOGVmM2EwZGY4Zjc1Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T08:59:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-20T08:59:02Z"}, "message": "[multiple changes]\n\n2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch13.adb (Add_Invariant): Do not replace\n\tthe saved expression of an invariatn aspect when inheriting\n\ta class-wide type invariant as this clobbers the existing\n\texpression. Do not use New_Copy_List as it is unnecessary\n\tand leaves the parent pointers referencing the wrong part of\n\tthe tree. Do not replace the type references for ASIS when\n\tinheriting a class-wide type invariant as this clobbers the\n\texisting replacement.\n\n2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Build_Explicit_Dereference): If the designated\n\texpression is an entity name, generate reference to the entity\n\tbecause it will not be resolved again.\n\nFrom-SVN: r235238", "tree": {"sha": "a315c178373ebadba5cbdbb438ee08abaa5cf2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a315c178373ebadba5cbdbb438ee08abaa5cf2c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/776fbb7478011611c58ba664a4c8ef3a0df8f75f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776fbb7478011611c58ba664a4c8ef3a0df8f75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/776fbb7478011611c58ba664a4c8ef3a0df8f75f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776fbb7478011611c58ba664a4c8ef3a0df8f75f/comments", "author": null, "committer": null, "parents": [{"sha": "60d393e89c924e71208f72a7007e16dc8720bcc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d393e89c924e71208f72a7007e16dc8720bcc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d393e89c924e71208f72a7007e16dc8720bcc9"}], "stats": {"total": 94, "additions": 62, "deletions": 32}, "files": [{"sha": "64294deb8319a9a5d642a2974405adb4c906a1e7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776fbb7478011611c58ba664a4c8ef3a0df8f75f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776fbb7478011611c58ba664a4c8ef3a0df8f75f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=776fbb7478011611c58ba664a4c8ef3a0df8f75f", "patch": "@@ -1,3 +1,20 @@\n+2016-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch13.adb (Add_Invariant): Do not replace\n+\tthe saved expression of an invariatn aspect when inheriting\n+\ta class-wide type invariant as this clobbers the existing\n+\texpression. Do not use New_Copy_List as it is unnecessary\n+\tand leaves the parent pointers referencing the wrong part of\n+\tthe tree. Do not replace the type references for ASIS when\n+\tinheriting a class-wide type invariant as this clobbers the\n+\texisting replacement.\n+\n+2016-04-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Build_Explicit_Dereference): If the designated\n+\texpression is an entity name, generate reference to the entity\n+\tbecause it will not be resolved again.\n+\n 2016-04-19  Arnaud Charlet  <charlet@adacore.com>\n \n \t* doc/gnat_rm/standard_and_implementation_defined_restrictions.rst,"}, {"sha": "2302e666032bf673064e5377067d7481b56ef28a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776fbb7478011611c58ba664a4c8ef3a0df8f75f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776fbb7478011611c58ba664a4c8ef3a0df8f75f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=776fbb7478011611c58ba664a4c8ef3a0df8f75f", "patch": "@@ -8048,9 +8048,11 @@ package body Sem_Ch13 is\n             --  If the invariant pragma comes from an aspect, replace the saved\n             --  expression because we need the subtype references replaced for\n             --  the calls to Preanalyze_Spec_Expression in Check_Aspect_At_xxx\n-            --  routines.\n+            --  routines. This is not done for interited class-wide invariants\n+            --  because the original pragma of the parent type must remain\n+            --  unchanged.\n \n-            if Present (Asp) then\n+            if not Inherit and then Present (Asp) then\n                Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n             end if;\n \n@@ -8066,40 +8068,46 @@ package body Sem_Ch13 is\n             Set_Parent (Expr, Parent (Arg2));\n             Preanalyze_Assert_Expression (Expr, Any_Boolean);\n \n-            --  A class-wide invariant may be inherited in a separate unit,\n-            --  where the corresponding expression cannot be resolved by\n-            --  visibility, because it refers to a local function. Propagate\n-            --  semantic information to the original representation item, to\n-            --  be used when an invariant procedure for a derived type is\n-            --  constructed.\n+            --  Both modifications performed below are not done for inherited\n+            --  class-wide invariants because the origial aspect/pragma of the\n+            --  parent type must remain unchanged.\n \n-            --  ??? Unclear how to handle class-wide invariants that are not\n-            --  function calls.\n+            if not Inherit then\n \n-            if not Inherit\n-              and then Class_Present (Prag)\n-              and then Nkind (Expr) = N_Function_Call\n-              and then Nkind (Arg2) = N_Indexed_Component\n-            then\n-               Rewrite (Arg2,\n-                 Make_Function_Call (Ploc,\n-                   Name                   =>\n-                     New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n-                   Parameter_Associations =>\n-                     New_Copy_List (Expressions (Arg2))));\n-            end if;\n+               --  A class-wide invariant may be inherited in a separate unit,\n+               --  where the corresponding expression cannot be resolved by\n+               --  visibility, because it refers to a local function. Propagate\n+               --  semantic information to the original representation item, to\n+               --  be used when an invariant procedure for a derived type is\n+               --  constructed.\n \n-            --  In ASIS mode, even if assertions are not enabled, we must\n-            --  analyze the original expression in the aspect specification\n-            --  because it is part of the original tree.\n+               --  ??? Unclear how to handle class-wide invariants that are not\n+               --  function calls.\n \n-            if ASIS_Mode and then Present (Asp) then\n-               declare\n-                  Orig_Expr : constant Node_Id := Expression (Asp);\n-               begin\n-                  Replace_Type_References (Orig_Expr, T);\n-                  Preanalyze_Assert_Expression (Orig_Expr, Any_Boolean);\n-               end;\n+               if Class_Present (Prag)\n+                 and then Nkind (Expr) = N_Function_Call\n+                 and then Nkind (Arg2) = N_Indexed_Component\n+               then\n+                  Rewrite (Arg2,\n+                    Make_Function_Call (Ploc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n+                      Parameter_Associations => Expressions (Arg2)));\n+               end if;\n+\n+               --  In ASIS mode, even if assertions are not enabled, we must\n+               --  analyze the original expression in the aspect specification\n+               --  because it is part of the original tree.\n+\n+               if ASIS_Mode and then Present (Asp) then\n+                  declare\n+                     Asp_Expr : constant Node_Id := Expression (Asp);\n+\n+                  begin\n+                     Replace_Type_References (Asp_Expr, T);\n+                     Preanalyze_Assert_Expression (Asp_Expr, Any_Boolean);\n+                  end;\n+               end if;\n             end if;\n \n             --  An ignored invariant must not generate a runtime check. Add a"}, {"sha": "d03eca8c960b29eba10dbc305e021569006126e4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776fbb7478011611c58ba664a4c8ef3a0df8f75f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776fbb7478011611c58ba664a4c8ef3a0df8f75f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=776fbb7478011611c58ba664a4c8ef3a0df8f75f", "patch": "@@ -1759,6 +1759,11 @@ package body Sem_Util is\n       if Is_Entity_Name (Expr) then\n          Set_Etype (Expr, Etype (Entity (Expr)));\n \n+         --  The designated entity will not be examined again when resolving\n+         --  the dereference, so generate a reference to it now.\n+\n+         Generate_Reference (Entity (Expr), Expr);\n+\n       elsif Nkind (Expr) = N_Function_Call then\n \n          --  If the name of the indexing function is overloaded, locate the one"}]}