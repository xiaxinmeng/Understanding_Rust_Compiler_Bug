{"sha": "884d9d372eb7518d50b6bd77d1420909a0e701cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg0ZDlkMzcyZWI3NTE4ZDUwYjZiZDc3ZDE0MjA5MDlhMGU3MDFjZg==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2006-09-20T07:53:18Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2006-09-20T07:53:18Z"}, "message": "InetAddress.java: Updated to latest.\n\n2006-09-20  Gary Benson  <gbenson@redhat.com>\n\n\t* classpath/java/net/InetAddress.java: Updated to latest.\n\t* classpath/java/net/Inet4Address.java: Likewise.\n\t* classpath/java/net/Inet6Address.java: Likewise.\n\t* classpath/java/net/ResolverCache.java: Likewise.\n\t* classpath/java/net/SocketPermission.java: Likewise.\n\n\t* classpath/java/net/Inet4Address.java\n\t(AF_INET): Renamed to FAMILY.\n\t(<init>, writeReplace): Reflect the above.\n\t* classpath/java/net/Inet6Address.java\n\t(AF_INET6): Renamed to FAMILY.\n\t(<init>): Reflect the above.\n\nFrom-SVN: r117074", "tree": {"sha": "d481eaee86d8ea88a0c28ad7474bd0df6ae1e401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d481eaee86d8ea88a0c28ad7474bd0df6ae1e401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/884d9d372eb7518d50b6bd77d1420909a0e701cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884d9d372eb7518d50b6bd77d1420909a0e701cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884d9d372eb7518d50b6bd77d1420909a0e701cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884d9d372eb7518d50b6bd77d1420909a0e701cf/comments", "author": null, "committer": null, "parents": [{"sha": "7c324b07c6ec8af614b6763c32b94c5c860a413b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c324b07c6ec8af614b6763c32b94c5c860a413b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c324b07c6ec8af614b6763c32b94c5c860a413b"}], "stats": {"total": 899, "additions": 649, "deletions": 250}, "files": [{"sha": "2f098d7e40c1d3d70113adde2865fb12808dba98", "filename": "libjava/classpath/ChangeLog.gcj", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gcj?ref=884d9d372eb7518d50b6bd77d1420909a0e701cf", "patch": "@@ -1,3 +1,18 @@\n+2006-09-20  Gary Benson  <gbenson@redhat.com>\n+\n+\t* classpath/java/net/InetAddress.java: Updated to latest.\n+\t* classpath/java/net/Inet4Address.java: Likewise.\n+\t* classpath/java/net/Inet6Address.java: Likewise.\n+\t* classpath/java/net/ResolverCache.java: Likewise.\n+\t* classpath/java/net/SocketPermission.java: Likewise.\n+\n+\t* classpath/java/net/Inet4Address.java\n+\t(AF_INET): Renamed to FAMILY.\n+\t(<init>, writeReplace): Reflect the above.\n+\t* classpath/java/net/Inet6Address.java\n+\t(AF_INET6): Renamed to FAMILY.\n+\t(<init>): Reflect the above.\n+\n 2006-09-18  Tom Tromey  <tromey@redhat.com>\n \n \t* gnu/javax/net/ssl/provider/SSLSocket.java (isBound, isClosed,"}, {"sha": "28018a39c1cbed74075def7d3bd3b2ab3a9a670f", "filename": "libjava/classpath/java/net/Inet4Address.java", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FInet4Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FInet4Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FInet4Address.java?ref=884d9d372eb7518d50b6bd77d1420909a0e701cf", "patch": "@@ -1,5 +1,5 @@\n /* Inet4Address.java --\n-   Copyright (C) 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -57,11 +57,16 @@ public final class Inet4Address extends InetAddress\n   static final long serialVersionUID = 3286316764910316507L;\n \n   /**\n-   * needed for serialization\n+   * The address family of these addresses (used for serialization).\n+   */\n+  private static final int FAMILY = 2; // AF_INET\n+\n+  /**\n+   * Inet4Address objects are serialized as InetAddress objects.\n    */\n   private Object writeReplace() throws ObjectStreamException\n   {\n-    return new InetAddress(addr, hostName);\n+    return new InetAddress(addr, hostName, FAMILY);\n   }\n   \n   /**\n@@ -74,7 +79,7 @@ private Object writeReplace() throws ObjectStreamException\n    */\n   Inet4Address(byte[] addr, String host)\n   {\n-    super(addr, host);\n+    super(addr, host, FAMILY);\n   }\n \n   /**\n@@ -84,15 +89,15 @@ private Object writeReplace() throws ObjectStreamException\n    */\n   public boolean isMulticastAddress()\n   {\n-    return super.isMulticastAddress();\n+    return (addr[0] & 0xf0) == 0xe0;\n   }\n \n   /**\n    * Checks if this address is a loopback address\n    */\n   public boolean isLoopbackAddress()\n   {\n-    return super.isLoopbackAddress();\n+    return (addr[0] & 0xff) == 0x7f;\n   }\n \n   /**\n@@ -102,7 +107,7 @@ public boolean isLoopbackAddress()\n    */\n   public boolean isAnyLocalAddress()\n   {\n-    return super.isAnyLocalAddress();\n+    return equals(InetAddress.ANY_IF);\n   }\n \n   /**\n@@ -112,7 +117,7 @@ public boolean isAnyLocalAddress()\n    */\n   public boolean isLinkLocalAddress()\n   {\n-    return super.isLinkLocalAddress();\n+    return false;\n   }\n \n   /**\n@@ -122,7 +127,19 @@ public boolean isLinkLocalAddress()\n    */\n   public boolean isSiteLocalAddress()\n   {\n-    return super.isSiteLocalAddress();\n+    // 10.0.0.0/8\n+    if ((addr[0] & 0xff) == 0x0a)\n+      return true;\n+\n+    // 172.16.0.0/12\n+    if ((addr[0] & 0xff) == 0xac && (addr[1] & 0xf0) == 0x10)\n+      return true;\n+\n+    // 192.168.0.0/16\n+    if ((addr[0] & 0xff) == 0xc0 && (addr[1] & 0xff) == 0xa8)\n+      return true;\n+\n+    return false;\n   }\n \n   /**\n@@ -132,7 +149,7 @@ public boolean isSiteLocalAddress()\n    */\n   public boolean isMCGlobal()\n   {\n-    return super.isMCGlobal();\n+    return false;\n   }\n \n   /**\n@@ -142,7 +159,7 @@ public boolean isMCGlobal()\n    */\n   public boolean isMCNodeLocal()\n   {\n-    return super.isMCNodeLocal();\n+    return false;\n   }\n \n   /**\n@@ -152,7 +169,12 @@ public boolean isMCNodeLocal()\n    */\n   public boolean isMCLinkLocal()\n   {\n-    return super.isMCLinkLocal();\n+    if (! isMulticastAddress())\n+      return false;\n+\n+    return ((addr[0] & 0xff) == 0xe0\n+\t    && (addr[1] & 0xff)  == 0x00\n+\t    && (addr[2] & 0xff)  == 0x00);\n   }\n \n   /**\n@@ -162,7 +184,7 @@ public boolean isMCLinkLocal()\n    */\n   public boolean isMCSiteLocal()\n   {\n-    return super.isMCSiteLocal();\n+    return false;\n   }\n \n   /**\n@@ -172,7 +194,7 @@ public boolean isMCSiteLocal()\n    */\n   public boolean isMCOrgLocal()\n   {\n-    return super.isMCOrgLocal();\n+    return false;\n   }\n \n   /**\n@@ -190,7 +212,23 @@ public byte[] getAddress()\n    */\n   public String getHostAddress()\n   {\n-    return super.getHostAddress();\n+    StringBuffer sb = new StringBuffer(40);\n+\n+    int len = addr.length;\n+    int i = 0;\n+    \n+    for ( ; ; )\n+      {\n+        sb.append(addr[i] & 0xff);\n+        i++;\n+\t\n+        if (i == len)\n+          break;\n+\t\n+        sb.append('.');\n+      }\n+\n+    return sb.toString();\n   }\n \n   /**"}, {"sha": "2015fe1eb96817321896edb5e1336b029d110c85", "filename": "libjava/classpath/java/net/Inet6Address.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FInet6Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FInet6Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FInet6Address.java?ref=884d9d372eb7518d50b6bd77d1420909a0e701cf", "patch": "@@ -1,5 +1,5 @@\n /* Inet6Address.java --\n-   Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -92,6 +92,11 @@ public final class Inet6Address extends InetAddress\n    */\n   private transient NetworkInterface nif; \n \n+  /**\n+   * The address family of these addresses (used for serialization).\n+   */\n+  private static final int FAMILY = 10; // AF_INET6\n+\n   /**\n    * Create an Inet6Address object\n    *\n@@ -100,7 +105,7 @@ public final class Inet6Address extends InetAddress\n    */\n   Inet6Address(byte[] addr, String host)\n   {\n-    super(addr, host);\n+    super(addr, host, FAMILY);\n     // Super constructor clones the addr.  Get a reference to the clone.\n     this.ipaddress = this.addr;\n     ifname = null;"}, {"sha": "f6f97285fe653664cf41a9b03150891d4d86c238", "filename": "libjava/classpath/java/net/InetAddress.java", "status": "modified", "additions": 174, "deletions": 203, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FInetAddress.java?ref=884d9d372eb7518d50b6bd77d1420909a0e701cf", "patch": "@@ -1,5 +1,6 @@\n /* InetAddress.java -- Class to model an Internet address\n-   Copyright (C) 1998, 1999, 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2002, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -43,7 +44,6 @@\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamException;\n import java.io.Serializable;\n-import java.util.StringTokenizer;\n \n /**\n  * This class models an Internet address.  It does not have a public\n@@ -57,45 +57,56 @@\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Per Bothner\n+ * @author Gary Benson (gbenson@redhat.com)\n  *\n  * @specnote This class is not final since JK 1.4\n  */\n public class InetAddress implements Serializable\n {\n   private static final long serialVersionUID = 3286316764910316507L;\n \n-  /**\n-   * The special IP address INADDR_ANY.\n-   */\n-  private static InetAddress inaddr_any;\n-\n   /**\n    * Dummy InetAddress, used to bind socket to any (all) network interfaces.\n    */\n   static InetAddress ANY_IF;\n-\n+  static\n+  {\n+    byte[] addr;\n+    try\n+      {\n+\taddr = VMInetAddress.lookupInaddrAny();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\t// Make one up and hope it works.\n+\taddr = new byte[] {0, 0, 0, 0};\n+      }\n+    try\n+      {\n+\tANY_IF = getByAddress(addr);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n+      }\n+    ANY_IF.hostName = ANY_IF.getHostName();\n+  }\n+  \n   /**\n    * Stores static localhost address object.\n    */\n   static InetAddress LOCALHOST;\n-\n   static\n   {\n-    // precompute the ANY_IF address\n     try\n       {\n-        ANY_IF = getInaddrAny();\n-\n-\tbyte[] ip_localhost = { 127, 0, 0, 1 };\n-\tLOCALHOST = new Inet4Address(ip_localhost, \"localhost\");\n+\tLOCALHOST = getByAddress(\"localhost\", new byte[] {127, 0, 0, 1});\n       }\n-    catch (UnknownHostException uhe)\n+    catch (UnknownHostException e)\n       {\n-        // Hmmm, make one up and hope that it works.\n-        byte[] zeros = { 0, 0, 0, 0 };\n-        ANY_IF = new Inet4Address(zeros, \"0.0.0.0\");\n+\tthrow new RuntimeException(\"should never happen\", e);\n       }\n-  }\n+  }    \n \n   /**\n    * The Serialized Form specifies that an int 'address' is saved/restored.\n@@ -115,179 +126,173 @@ public class InetAddress implements Serializable\n   String hostName;\n \n   /**\n-   * The field 'family' seems to be the AF_ value.\n-   * FIXME: Much of the code in the other java.net classes does not make\n-   * use of this family field.  A better implementation would be to make\n-   * use of getaddrinfo() and have other methods just check the family\n-   * field rather than examining the length of the address each time.\n+   * Needed for serialization.\n    */\n-  int family;\n+  private int family;\n \n   /**\n-   * Initializes this object's addr instance variable from the passed in\n-   * byte array.  Note that this constructor is protected and is called\n-   * only by static methods in this class.\n+   * Constructor.  Prior to the introduction of IPv6 support in 1.4,\n+   * methods such as InetAddress.getByName() would return InetAddress\n+   * objects.  From 1.4 such methods returned either Inet4Address or\n+   * Inet6Address objects, but for compatibility Inet4Address objects\n+   * are serialized as InetAddresses.  As such, there are only two\n+   * places where it is appropriate to invoke this constructor: within\n+   * subclasses constructors and within Inet4Address.writeReplace().\n    *\n    * @param ipaddr The IP number of this address as an array of bytes\n    * @param hostname The hostname of this IP address.\n+   * @param family The address family of this IP address.\n    */\n-  InetAddress(byte[] ipaddr, String hostname)\n+  InetAddress(byte[] ipaddr, String hostname, int family)\n   {\n     addr = (null == ipaddr) ? null : (byte[]) ipaddr.clone();\n     hostName = hostname;\n-    \n-    family = 2; /* AF_INET */\n+    this.family = family;\n   }\n \n   /**\n    * Returns true if this address is a multicast address, false otherwise.\n    * An address is multicast if the high four bits are \"1110\".  These are\n    * also known as \"Class D\" addresses.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @return true if mulitcast, false if not\n    *\n    * @since 1.1\n    */\n   public boolean isMulticastAddress()\n   {\n-    // Mask against high order bits of 1110\n-    if (addr.length == 4)\n-      return (addr[0] & 0xf0) == 0xe0;\n-\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if the InetAddress in a wildcard address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isAnyLocalAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    return equals(ANY_IF);\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if the InetAddress is a loopback address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isLoopbackAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    return (addr[0] & 0xff) == 0x7f;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a link local address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isLinkLocalAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a site local address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isSiteLocalAddress()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-\n-    // 10.0.0.0/8\n-    if ((addr[0] & 0xff) == 0x0a)\n-      return true;\n-\n-    // 172.16.0.0/12\n-    if ((addr[0] & 0xff) == 0xac && (addr[1] & 0xf0) == 0x10)\n-      return true;\n-\n-    // 192.168.0.0/16\n-    if ((addr[0] & 0xff) == 0xc0 && (addr[1] & 0xff) == 0xa8)\n-      return true;\n-\n-    // XXX: Do we need to check more addresses here ?\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a global multicast address\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCGlobal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a node local multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCNodeLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a link local multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCLinkLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    if (! isMulticastAddress())\n-      return false;\n-\n-    return ((addr[0] & 0xff) == 0xe0\n-\t    && (addr[1] & 0xff)  == 0x00\n-\t    && (addr[2] & 0xff)  == 0x00);\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a site local multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCSiteLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a organization local\n    * multicast address.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @since 1.4\n    */\n   public boolean isMCOrgLocal()\n   {\n-    // This is the IPv4 implementation.\n-    // Any class derived from InetAddress should override this.\n-    // XXX: This seems to not exist with IPv4 addresses\n-    return false;\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n@@ -298,13 +303,20 @@ public boolean isMCOrgLocal()\n    */\n   public String getHostName()\n   {\n-    if (hostName != null)\n-      return hostName;\n+    if (hostName == null)\n+      hostName = getCanonicalHostName();\n \n+    return hostName;\n+  }\n+\n+  /**\n+   * Returns the canonical hostname represented by this InetAddress\n+   */\n+  String internalGetCanonicalHostName()\n+  {\n     try\n       {\n-\thostName = VMInetAddress.getHostByAddr(addr);\n-\treturn hostName;\n+\treturn ResolverCache.getHostByAddr(addr);\n       }\n     catch (UnknownHostException e)\n       {\n@@ -319,29 +331,22 @@ public String getHostName()\n    */\n   public String getCanonicalHostName()\n   {\n+    String hostname = internalGetCanonicalHostName();\n+\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       {\n         try\n \t  {\n-            sm.checkConnect(hostName, -1);\n+            sm.checkConnect(hostname, -1);\n \t  }\n \tcatch (SecurityException e)\n \t  {\n \t    return getHostAddress();\n \t  }\n       }\n \n-    // Try to find the FDQN now\n-    InetAddress address;\n-    byte[] ipaddr = getAddress();\n-\n-    if (ipaddr.length == 16)\n-      address = new Inet6Address(getAddress(), null);\n-    else\n-      address = new Inet4Address(getAddress(), null);\n-\n-    return address.getHostName();\n+    return hostname;\n   }\n \n   /**\n@@ -357,32 +362,19 @@ public byte[] getAddress()\n   }\n \n   /**\n-   * Returns the IP address of this object as a String.  The address is in\n-   * the dotted octet notation, for example, \"127.0.0.1\".\n+   * Returns the IP address of this object as a String.\n    *\n+   * <p>This method cannot be abstract for backward compatibility reasons. By\n+   * default it always throws {@link UnsupportedOperationException} unless\n+   * overridden.</p>\n+   * \n    * @return The IP address of this object in String form\n    *\n    * @since 1.0.2\n    */\n   public String getHostAddress()\n   {\n-    StringBuffer sb = new StringBuffer(40);\n-\n-    int len = addr.length;\n-    int i = 0;\n-    \n-    for ( ; ; )\n-      {\n-        sb.append(addr[i] & 0xff);\n-        i++;\n-\t\n-        if (i == len)\n-          break;\n-\t\n-        sb.append('.');\n-      }\n-\n-    return sb.toString();\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n@@ -488,48 +480,50 @@ public static InetAddress getByAddress(String host, byte[] addr)\n       return new Inet4Address(addr, host);\n \n     if (addr.length == 16)\n-      return new Inet6Address(addr, host);\n+      {\n+\tfor (int i = 0; i < 12; i++)\n+\t  {\n+\t    if (addr[i] != (i < 10 ? 0 : (byte) 0xFF))\n+\t      return new Inet6Address(addr, host);\n+\t  }\n+\t  \n+\tbyte[] ip4addr = new byte[4];\n+\tip4addr[0] = addr[12];\n+\tip4addr[1] = addr[13];\n+\tip4addr[2] = addr[14];\n+\tip4addr[3] = addr[15];\n+\treturn new Inet4Address(ip4addr, host);\n+      }\n \n     throw new UnknownHostException(\"IP address has illegal length\");\n   }\n \n   /**\n-   * If hostname is a valid numeric IP address, return the numeric address.\n-   * Otherwise, return null.\n+   * Returns an InetAddress object representing the IP address of\n+   * the given literal IP address in dotted decimal format such as\n+   * \"127.0.0.1\".  This is used by SocketPermission.setHostPort()\n+   * to parse literal IP addresses without performing a DNS lookup.\n+   *\n+   * @param literal The literal IP address to create the InetAddress\n+   * object from\n    *\n-   * @param hostname the name of the host\n+   * @return The address of the host as an InetAddress object, or\n+   * null if the IP address is invalid.\n    */\n-  private static byte[] aton(String hostname)\n+  static InetAddress getByLiteral(String literal)\n   {\n-    StringTokenizer st = new StringTokenizer(hostname, \".\");\n-\n-    if (st.countTokens() == 4)\n+    byte[] address = VMInetAddress.aton(literal);\n+    if (address == null)\n+      return null;\n+    \n+    try\n       {\n-\tint index;\n-\tbyte[] address = new byte[4];\n-\n-\tfor (index = 0; index < 4; index++)\n-\t  {\n-\t    try\n-\t      {\n-\t\tshort n = Short.parseShort(st.nextToken());\n-\n-\t\tif ((n < 0) || (n > 255))\n-\t\t  break;\n-\n-\t\taddress[index] = (byte) n;\n-\t      }\n-\t    catch (NumberFormatException e)\n-\t      {\n-\t\tbreak;\n-\t      }\n-\t  }\n-\n-\tif (index == 4)\n-\t  return address;\n+\treturn getByAddress(address);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tthrow new RuntimeException(\"should never happen\", e);\n       }\n-\n-    return null;\n   }\n \n   /**\n@@ -577,62 +571,33 @@ public static InetAddress getByName(String hostname)\n   public static InetAddress[] getAllByName(String hostname)\n     throws UnknownHostException\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkConnect(hostname, -1);\n-\n-    InetAddress[] addresses;\n-\n-    if (hostname != null)\n-      hostname = hostname.trim();\n+    // If null or the empty string is supplied, the loopback address\n+    // is returned.\n+    if (hostname == null || hostname.length() == 0)\n+      return new InetAddress[] {LOCALHOST};\n \n-    // Default to current host if necessary\n-    if (hostname == null || hostname.equals(\"\"))\n-      {\n-\taddresses = new InetAddress[1];\n-\taddresses[0] = LOCALHOST;\n-\treturn addresses;\n-      }\n+    // Check if hostname is an IP address\n+    InetAddress address = getByLiteral(hostname);\n+    if (address != null)\n+      return new InetAddress[] {address};\n \n-    // Not in cache, try the lookup\n-    byte[][] iplist = VMInetAddress.getHostByName(hostname);\n+    // Perform security check before resolving\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkConnect(hostname, -1);\n \n+    // Resolve the hostname\n+    byte[][] iplist = ResolverCache.getHostByName(hostname);\n     if (iplist.length == 0)\n       throw new UnknownHostException(hostname);\n \n-    addresses = new InetAddress[iplist.length];\n-\n+    InetAddress[] addresses = new InetAddress[iplist.length];\n     for (int i = 0; i < iplist.length; i++)\n-      {\n-\tif (iplist[i].length != 4)\n-\t  throw new UnknownHostException(hostname);\n-\n-\taddresses[i] = new Inet4Address(iplist[i], hostname);\n-      }\n+      addresses[i] = getByAddress(hostname, iplist[i]);\n \n     return addresses;\n   }\n \n-  /**\n-   * Returns the special address INADDR_ANY used for binding to a local\n-   * port on all IP addresses hosted by a the local host.\n-   *\n-   * @return An InetAddress object representing INDADDR_ANY\n-   *\n-   * @exception UnknownHostException If an error occurs\n-   */\n-  static InetAddress getInaddrAny() throws UnknownHostException\n-  {\n-    if (inaddr_any == null)\n-      {\n-\tbyte[] tmp = VMInetAddress.lookupInaddrAny();\n-\tinaddr_any = new Inet4Address(tmp, null);\n-\tinaddr_any.hostName = inaddr_any.getHostName();\n-      }\n-\n-    return inaddr_any;\n-  }\n-\n   /**\n    * Returns an InetAddress object representing the address of the current\n    * host.\n@@ -645,11 +610,19 @@ static InetAddress getInaddrAny() throws UnknownHostException\n   public static InetAddress getLocalHost() throws UnknownHostException\n   {\n     String hostname = VMInetAddress.getLocalHostname();\n-    return getByName(hostname);\n+    try\n+      {\n+\treturn getByName(hostname);\n+      }\n+    catch (SecurityException e)\n+      {\n+\treturn LOCALHOST;\n+      }\n   }\n \n-  /*\n-   * Needed for serialization\n+  /**\n+   * Inet4Address objects are serialized as InetAddress objects.\n+   * This deserializes them back into Inet4Address objects.\n    */\n   private Object readResolve() throws ObjectStreamException\n   {\n@@ -665,8 +638,6 @@ private void readObject(ObjectInputStream ois)\n \n     for (int i = 2; i >= 0; --i)\n       addr[i] = (byte) (address >>= 8);\n-\n-    family = 2; /* AF_INET  */\n   }\n \n   private void writeObject(ObjectOutputStream oos) throws IOException"}, {"sha": "f8790666a0acd24fa1501983cb5de48353dfecd8", "filename": "libjava/classpath/java/net/ResolverCache.java", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FResolverCache.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FResolverCache.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FResolverCache.java?ref=884d9d372eb7518d50b6bd77d1420909a0e701cf", "patch": "@@ -0,0 +1,269 @@\n+/* ResolverCache.java -- A cache of resolver lookups for InetAddress.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.net;\n+\n+import java.security.Security;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+/**\n+ * This class provides a cache of name service resolutions.  By\n+ * default successful resolutions are cached forever to guard\n+ * against DNS spoofing attacks and failed resolutions are cached\n+ * for 10 seconds to improve performance.  The length of time that\n+ * results remain in the cache is determined by the following\n+ * security properties:\n+ * <dl>\n+ *   <dt><code>networkaddress.cache.ttl</code></dt>\n+ *   <dd>\n+ *     This property specifies the length of time in seconds that\n+ *     successful resolutions remain in the cache.  The default is\n+ *     -1, indicating to cache forever.\n+ *   </dd>\n+ *   <dt><code>networkaddress.cache.negative.ttl</code></dt>\n+ *   <dd>\n+ *     This property specifies the length of time in seconds that\n+ *     unsuccessful resolutions remain in the cache.  The default\n+ *     is 10, indicating to cache for 10 seconds.\n+ *   </dd>\n+ * In both cases, a value of -1 indicates to cache forever and a\n+ * value of 0 indicates not to cache.\n+ *\n+ * @author Gary Benson (gbenson@redhat.com)\n+ */\n+class ResolverCache\n+{\n+  /**\n+   * The time in seconds for which successful lookups are cached.\n+   */\n+  private static final int POSITIVE_TTL =\n+    getTTL(\"networkaddress.cache.ttl\", -1);\n+\n+  /**\n+   * The time in seconds for which unsuccessful lookups are cached.\n+   */\n+  private static final int NEGATIVE_TTL =\n+    getTTL(\"networkaddress.cache.negative.ttl\", 10);\n+\n+  /**\n+   * Helper function to set the TTLs.\n+   */\n+  private static int getTTL(String propName, int defaultValue)\n+  {\n+    String propValue = Security.getProperty(propName);\n+    if (propValue == null)\n+      return defaultValue;\n+\n+    return Integer.parseInt(propValue);\n+  }\n+\n+  /**\n+   * The cache itself.\n+   */\n+  private static HashMap cache = new HashMap();\n+\n+  /**\n+   * List of entries which may expire.\n+   */\n+  private static LinkedList killqueue = new LinkedList();\n+\n+  /**\n+   * Return the hostname for the specified IP address.\n+   *\n+   * @param ip The IP address as a byte array\n+   *\n+   * @return The hostname\n+   *\n+   * @exception UnknownHostException If the reverse lookup fails\n+   */\n+  public static String getHostByAddr(byte[] addr) throws UnknownHostException\n+  {\n+    Object key = makeHashableAddress(addr);\n+    Entry entry = (Entry) get(key);\n+    if (entry != null)\n+      {\n+\tif (entry.value == null)\n+\t  throw new UnknownHostException();\n+\treturn (String) entry.value;\n+      }\n+\n+    try\n+      {\n+\tString hostname = VMInetAddress.getHostByAddr(addr);\n+\tput(new Entry(key, hostname));\n+\treturn hostname;\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tput(new Entry(key, null));\n+\tthrow e;\n+      }\n+  }\n+\n+  /**\n+   * Return a list of all IP addresses for the specified hostname.\n+   *\n+   * @param hostname The hostname\n+   *\n+   * @return An list of IP addresses as byte arrays\n+   *\n+   * @exception UnknownHostException If the lookup fails\n+   */\n+  public static byte[][] getHostByName(String hostname)\n+    throws UnknownHostException\n+  {\n+    Entry entry = (Entry) get(hostname);\n+    if (entry != null)\n+      {\n+\tif (entry.value == null)\n+\t  throw new UnknownHostException();\n+\treturn (byte[][]) entry.value;\n+      }\n+\n+    try\n+      {\n+\tbyte[][] addrs = VMInetAddress.getHostByName(hostname);\n+\tput(new Entry(hostname, addrs));\n+\treturn addrs;\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\tput(new Entry(hostname, null));\n+\tthrow e;\n+      }\n+  }\n+\n+  /**\n+   * Convert an IP address expressed as a byte array into something\n+   * we can use as a hashtable key.\n+   */\n+  private static Object makeHashableAddress(byte[] addr)\n+  {\n+    char[] chars = new char[addr.length];\n+    for (int i = 0; i < addr.length; i++)\n+      chars[i] = (char) addr[i];\n+    return new String(chars);\n+  }\n+\n+  /**\n+   * Return the entry in the cache associated with the supplied key,\n+   * or <code>null</code> if the cache does not contain an entry\n+   * associated with this key.\n+   */\n+  private static synchronized Entry get(Object key)\n+  {\n+    reap();\n+    return (Entry) cache.get(key);\n+  }\n+\n+  /**\n+   * Insert the supplied entry into the cache.\n+   */\n+  private static synchronized void put(Entry entry)\n+  {\n+    reap();\n+    if (entry.expires != 0)\n+      {\n+\tif (entry.expires != -1)\n+\t  killqueue.add(entry);\n+\tcache.put(entry.key, entry);\n+      }\n+  }\n+\n+  /**\n+   * Clear expired entries.  This method is not synchronized, so\n+   * it must only be called by methods that are.\n+   */\n+  private static void reap()\n+  {\n+    if (!killqueue.isEmpty())\n+      {\n+\tlong now = System.currentTimeMillis();\n+\n+\tIterator iter = killqueue.iterator();\n+\twhile (iter.hasNext())\n+\t  {\n+\t    Entry entry = (Entry) iter.next();\n+\t    if (entry.expires > now)\n+\t      break;\n+\t    cache.remove(entry.key);\n+\t    iter.remove();\n+\t  }\n+      }\n+  }\n+  \n+  /**\n+   * An entry in the cache.\n+   */\n+  private static class Entry\n+  {\n+    /**\n+     * The key by which this entry is referenced.\n+     */\n+    public final Object key;\n+\n+    /**\n+     * The entry itself.  A null value indicates a failed lookup.\n+     */\n+    public final Object value;\n+    \n+    /**\n+     * The time when this cache entry expires.  If set to -1 then\n+     * this entry will never expire.  If set to 0 then this entry\n+     * expires immediately and will not be inserted into the cache.\n+     */\n+    public final long expires;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public Entry(Object key, Object value)\n+    {\n+      this.key = key;\n+      this.value = value;\n+\n+      int ttl = value != null ? POSITIVE_TTL : NEGATIVE_TTL;\n+      if (ttl < 1)\n+\texpires = ttl;\n+      else\n+\texpires = System.currentTimeMillis() + ttl * 1000;\n+    }\n+  }\n+}"}, {"sha": "2d6343dc570e41be5414b05678bb055dcd049dfd", "filename": "libjava/classpath/java/net/SocketPermission.java", "status": "modified", "additions": 131, "deletions": 30, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FSocketPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884d9d372eb7518d50b6bd77d1420909a0e701cf/libjava%2Fclasspath%2Fjava%2Fnet%2FSocketPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fnet%2FSocketPermission.java?ref=884d9d372eb7518d50b6bd77d1420909a0e701cf", "patch": "@@ -117,10 +117,17 @@ public final class SocketPermission extends Permission implements Serializable\n   static final long serialVersionUID = -7204263841984476862L;\n \n   /**\n-   * A hostname (possibly wildcarded) or IP address (IPv4 or IPv6).\n+   * A hostname (possibly wildcarded).  Will be set if and only if\n+   * this object was initialized with a hostname.\n    */\n-  private transient String host;\n+  private transient String hostname = null;\n \n+  /**\n+   * An IP address (IPv4 or IPv6).  Will be set if and only if this\n+   * object was initialized with a single literal IP address.\n+   */  \n+  private transient InetAddress address = null;\n+  \n   /**\n    * A range of ports.\n    */\n@@ -225,7 +232,7 @@ private static String processHostport(String hostport)\n   private void setHostPort(String hostport)\n   {\n     // Split into host and ports\n-    String ports;\n+    String host, ports;\n     if (hostport.charAt(0) == '[')\n       {\n \t// host is a bracketed IPv6 address\n@@ -234,6 +241,10 @@ private void setHostPort(String hostport)\n \t  throw new IllegalArgumentException(\"Unmatched '['\");\n \thost = hostport.substring(1, end);\n \n+\taddress = InetAddress.getByLiteral(host);\n+\tif (address == null)\n+\t  throw new IllegalArgumentException(\"Bad IPv6 address\");\n+\n \tif (end == hostport.length() - 1)\n \t  ports = \"\";\n \telse if (hostport.charAt(end + 1) == ':')\n@@ -255,6 +266,15 @@ else if (hostport.charAt(end + 1) == ':')\n \t    host = hostport.substring(0, sep);\n \t    ports = hostport.substring(sep + 1);\n \t  }\n+\n+\taddress = InetAddress.getByLiteral(host);\n+\tif (address == null)\n+\t  {\n+\t    if (host.lastIndexOf('*') > 0)\n+\t      throw new IllegalArgumentException(\"Bad hostname\");\n+\n+\t    hostname = host;\n+\t  }\n       }\n \n     // Parse and validate the ports\n@@ -362,10 +382,25 @@ public boolean equals(Object obj)\n     else\n       return false;\n \n-    return p.actionmask == actionmask &&\n-      p.minport == minport &&\n-      p.maxport == maxport &&\n-      p.host.equals(host);\n+    if (p.actionmask != actionmask ||\n+\tp.minport != minport ||\n+\tp.maxport != maxport)\n+      return false;\n+\n+    if (address != null)\n+      {\n+\tif (p.address == null)\n+\t  return false;\n+\telse\n+\t  return p.address.equals(address);\n+      }\n+    else\n+      {\n+\tif (p.hostname == null)\n+\t  return false;\n+\telse\n+\t  return p.hostname.equals(hostname);\n+      }\n   }\n \n   /**\n@@ -376,7 +411,12 @@ public boolean equals(Object obj)\n    */\n   public int hashCode()\n   {\n-    return actionmask + minport + maxport + host.hashCode();\n+    int code = actionmask + minport + maxport;\n+    if (address != null)\n+      code += address.hashCode();\n+    else\n+      code += hostname.hashCode();\n+    return code;\n   }\n \n   /**\n@@ -415,6 +455,44 @@ public PermissionCollection newPermissionCollection()\n     return null;\n   }\n \n+  /**\n+   * Returns an array of all IP addresses represented by this object.\n+   */\n+  private InetAddress[] getAddresses()\n+  {\n+    if (address != null)\n+      return new InetAddress[] {address};\n+\n+    try\n+      {\n+\treturn InetAddress.getAllByName(hostname);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\treturn new InetAddress[0];\n+      }\n+  }\n+\n+  /**\n+   * Returns the canonical hostname represented by this object,\n+   * or null if this object represents a wildcarded domain.\n+   */\n+  private String getCanonicalHostName()\n+  {\n+    if (address != null)\n+      return address.internalGetCanonicalHostName();\n+    if (hostname.charAt(0) == '*')\n+      return null;\n+    try\n+      {\n+\treturn InetAddress.getByName(hostname).internalGetCanonicalHostName();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\treturn null;\n+      }\n+  }\n+  \n   /**\n    * Returns true if the permission object passed it is implied by the\n    * this permission.  This will be true if:\n@@ -450,6 +528,11 @@ public boolean implies(Permission perm)\n     else\n       return false;\n \n+    // If p was initialised with an empty hostname then we do not\n+    // imply it. This is not part of the spec, but it seems necessary.\n+    if (p.hostname != null && p.hostname.length() == 0)\n+      return false;\n+    \n     // Next check the actions\n     if ((p.actionmask & actionmask) != p.actionmask)\n \treturn false;\n@@ -459,36 +542,54 @@ public boolean implies(Permission perm)\n       return false;\n \n     // Finally check the hosts\n-    if (host.equals(p.host))\n-      return true;\n+    String p_canon = null;\n \n-    // Try the canonical names\n-    String ourcanonical = null;\n-    String theircanonical = null;\n-    try\n+    // Return true if this object was initialized with a single\n+    // IP address which one of p's IP addresses is equal to.\n+    if (address != null)\n       {\n-\tourcanonical = InetAddress.getByName(host).getHostName();\n-\ttheircanonical = InetAddress.getByName(p.host).getHostName();\n+\tInetAddress[] addrs = p.getAddresses();\n+\tfor (int i = 0; i < addrs.length; i++)\n+\t  {\n+\t    if (address.equals(addrs[i]))\n+\t      return true;\n+\t  }\n       }\n-    catch (UnknownHostException e)\n+\n+    // Return true if this object is a wildcarded domain that\n+    // p's canonical name matches.\n+    if (hostname != null && hostname.charAt(0) == '*')\n       {\n-\t// Who didn't resolve?  Just assume current address is canonical enough\n-\t// Is this ok to do?\n-\tif (ourcanonical == null)\n-\t  ourcanonical = host;\n-\tif (theircanonical == null)\n-\t  theircanonical = p.host;\n+\tp_canon = p.getCanonicalHostName();\n+\tif (p_canon != null && p_canon.endsWith(hostname.substring(1)))\n+\t  return true;\n+\t\n       }\n \n-    if (ourcanonical.equals(theircanonical))\n-      return true;\n+    // Return true if this one of this object's IP addresses\n+    // is equal to one of p's.\n+    if (address == null)\n+      {\n+\tInetAddress[] addrs = p.getAddresses();\n+\tInetAddress[] p_addrs = p.getAddresses();\n+\n+\tfor (int i = 0; i < addrs.length; i++)\n+\t  {\n+\t    for (int j = 0; j < p_addrs.length; j++)\n+\t      {\n+\t\tif (addrs[i].equals(p_addrs[j]))\n+\t\t  return true;\n+\t      }\n+\t  }\n+      }\n \n-    // Well, last chance.  Try for a wildcard\n-    if (host.indexOf(\"*.\") != -1)\n+    // Return true if this object's canonical name equals p's.\n+    String canon = getCanonicalHostName();\n+    if (canon != null)\n       {\n-\tString wild_domain =\n-\t  host.substring(host.indexOf(\"*\" + 1));\n-\tif (theircanonical.endsWith(wild_domain))\n+\tif (p_canon == null)\n+\t  p_canon = p.getCanonicalHostName();\n+\tif (p_canon != null && canon.equals(p_canon))\n \t  return true;\n       }\n "}]}