{"sha": "14d6281388bad11de8c328be7ea825b184fc7efe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRkNjI4MTM4OGJhZDExZGU4YzMyOGJlN2VhODI1YjE4NGZjN2VmZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-08-29T05:03:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-08-29T05:03:36Z"}, "message": "tree-ssa-dom.c (edge_info::record_simple_equiv): Call derive_equivalences.\n\n\t* tree-ssa-dom.c (edge_info::record_simple_equiv): Call\n\tderive_equivalences.\n\t(derive_equivalences_from_bit_ior, record_temporary_equivalences):\n\tCode moved into....\n\t(edge_info::derive_equivalences): New private member function\n\n\t* gcc.dg/torture/pr57214.c: Fix type of loop counter.\n\t* gcc.dg/tree-ssa/ssa-sink-16.c: Disable DOM.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-11.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-12.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-13.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-14.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-15.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-16.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-17.c: New test.\n\nFrom-SVN: r251397", "tree": {"sha": "802fed8e9c969a046bce19e8b30ad8f48cde2916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/802fed8e9c969a046bce19e8b30ad8f48cde2916"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14d6281388bad11de8c328be7ea825b184fc7efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d6281388bad11de8c328be7ea825b184fc7efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14d6281388bad11de8c328be7ea825b184fc7efe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d6281388bad11de8c328be7ea825b184fc7efe/comments", "author": null, "committer": null, "parents": [{"sha": "a09f784a60ab1685b8711ae6820c77403fe6a299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09f784a60ab1685b8711ae6820c77403fe6a299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a09f784a60ab1685b8711ae6820c77403fe6a299"}], "stats": {"total": 611, "additions": 516, "deletions": 95}, "files": [{"sha": "9a60a80b7466b635e77ae4c881f21c14e7e63748", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -1,5 +1,11 @@\n 2017-08-28  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-dom.c (edge_info::record_simple_equiv): Call\n+\tderive_equivalences.\n+\t(derive_equivalences_from_bit_ior, record_temporary_equivalences):\n+\tCode moved into....\n+\t(edge_info::derive_equivalences): New private member function\n+\n \t* tree-ssa-dom.c (class edge_info): Changed from a struct\n \tto a class.  Add ctor/dtor, methods and data members.\n \t(edge_info::edge_info): Renamed from allocate_edge_info."}, {"sha": "0ffc4f9a70fb2d516e88e2bf9ac207ffc6ba370c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -1,3 +1,15 @@\n+2017-08-28  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/torture/pr57214.c: Fix type of loop counter.\n+\t* gcc.dg/tree-ssa/ssa-sink-16.c: Disable DOM.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-11.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-12.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-13.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-14.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-15.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-16.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-17.c: New test.\n+\n 2017-08-28  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/81770"}, {"sha": "c697f84514ea95ec6dbf8434840788323c7f4e89", "filename": "gcc/testsuite/gcc.dg/torture/pr57214.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57214.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57214.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57214.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -15,7 +15,7 @@ bar (_Bool b)\n       b = 1;\n       baz ();\n       x = 0;\n-      int i;\n+      unsigned int i;\n       while (buf[i] && i)\n \ti++;\n       foo ();"}, {"sha": "f42d64bed7102e4822bf0ca7948f2054950510f8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-11.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-11.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { ! logical_op_short_circuit  } } } */\n+/* { dg-options \"-O2 -fdump-tree-dom2-details\" } */\n+\n+static int *bb_ticks;\n+extern void frob (void);\n+void\n+mark_target_live_regs (int b, int block, int bb_tick)\n+{\n+  if (b == block && b != -1 && bb_tick == bb_ticks[b])\n+      return;\n+  if (b != -1)\n+    frob ();\n+}\n+\n+/* When the first two conditionals in the first IF are true, but\n+   the third conditional is false, then there's a jump threading\n+   opportunity to bypass the second IF statement.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom2\"} } */"}, {"sha": "63bd12a06a413cec1937f1011665d253cbefe640", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-12.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-12.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-dom2-details -w\" } */\n+typedef long unsigned int size_t;\n+union tree_node;\n+typedef union tree_node *tree;\n+typedef union gimple_statement_d *gimple;\n+typedef const union gimple_statement_d *const_gimple;\n+union gimple_statement_d\n+{\n+  unsigned num_ops;\n+  tree exp;\n+};\n+\n+unsigned int x;\n+static inline tree\n+gimple_op (const_gimple gs, unsigned i)\n+{\n+  if (!(i < gs->num_ops))\n+    abort ();\n+  return gs->exp;\n+}\n+\n+unsigned char\n+scan_function (gimple stmt)\n+{\n+  unsigned i;\n+  for (i = 0; i < stmt->num_ops - 3 ; i++)\n+    gimple_call_arg (stmt, i);\n+  gimple_op (stmt, 1);\n+}\n+\n+/* The test which bypasses the loop is simplified prior to DOM to check\n+   that stmt->num_ops - 3 != 0.  When that test is false, we can derive\n+   a value for stmt->num_ops.  That in turn allows us to thread the jump\n+   for the conditional at the start of the call to gimple_op.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom2\"} } */"}, {"sha": "209c40d4c95b3eb549d8639d4d891ac0c5169436", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-13.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-13.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-dom2-details -w\" } */\n+\n+union tree_node;\n+typedef union tree_node *tree;\n+extern unsigned char tree_contains_struct[0xdead][64];\n+struct tree_base\n+{\n+  int code:16;\n+};\n+struct tree_typed\n+{\n+  tree type;\n+};\n+struct tree_type_common\n+{\n+  tree main_variant;\n+};\n+extern tree build_target_option_node (void);\n+union tree_node\n+{\n+  struct tree_base base;\n+  struct tree_typed typed;\n+  struct tree_type_common type_common;\n+};\n+tree\n+convert (tree type, tree expr)\n+{\n+  tree e = expr;\n+  int code = (type)->base.code;\n+  const char *invalid_conv_diag;\n+  tree ret;\n+  if (tree_contains_struct[expr->base.code][(42)] != 1)\n+    abort ();\n+  if (type->type_common.main_variant == expr->typed.type->type_common.main_variant\n+      && (expr->typed.type->base.code != 123\n+\t  || e->base.code == 456))\n+    return arf ();\n+  if (expr->typed.type->base.code == 42)\n+    error (\"void value not ignored as it ought to be\");\n+}\n+\n+/* When the *->base.code tests in the second IF statement are false, we\n+   know that expr->typed.base->base.code has the value 123.  That allows\n+   us to thread the test for the final IF statement on that path.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom2\"} } */"}, {"sha": "2d97f86fa28eef6fb90608a5c9ea54da086d76ba", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-14.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-14.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile { target { ! logical_op_short_circuit  } } } */\n+/* { dg-options \"-O2 -fdump-tree-dom2-details -w\" } */\n+\n+enum optab_methods\n+{\n+  OPTAB_DIRECT,\n+  OPTAB_LIB,\n+  OPTAB_WIDEN,\n+  OPTAB_LIB_WIDEN,\n+  OPTAB_MUST_WIDEN\n+};\n+struct optab_d { };\n+typedef struct optab_d *optab;\n+void\n+expand_shift_1 (int code, int unsignedp, int rotate,\n+\t\toptab lshift_optab, optab rshift_arith_optab)\n+{\n+  int left = (code == 42 || code == 0xde);\n+  int attempt;\n+  enum optab_methods methods;\n+  if (attempt == 0)\n+    methods = OPTAB_DIRECT;\n+  else if (attempt == 1)\n+    methods = OPTAB_WIDEN;\n+  if ((!unsignedp || (!left && methods == OPTAB_WIDEN)))\n+    {\n+      enum optab_methods methods1 = methods;\n+      if (unsignedp)\n+\tmethods1 = OPTAB_MUST_WIDEN;\n+      expand_binop (left ? lshift_optab : rshift_arith_optab,\n+\t\t\t   unsignedp, methods1);\n+    }\n+}\n+\n+/* When UNSIGNEDP is true, LEFT is false and METHOD == OPTAB_WIDEN\n+   we will enter the TRUE arm of the conditional and we can thread\n+   the test to compute the first first argument of the expand_binop\n+   call if we look backwards through the boolean logicals.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom2\"} } */\n+"}, {"sha": "df6a9b32eb1b3bc70417d4c62b591bb97b36be2b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-15.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-15.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-dom2-details -w\" } */\n+struct rtx_def;\n+typedef struct rtx_def *rtx;\n+struct machine_frame_state\n+{\n+  rtx cfa_reg;\n+  long sp_offset;\n+};\n+struct machine_function {\n+  struct machine_frame_state fs;\n+};\n+enum global_rtl_index\n+{\n+  GR_PC,\n+  GR_CC0,\n+  GR_RETURN,\n+  GR_SIMPLE_RETURN,\n+  GR_STACK_POINTER,\n+  GR_FRAME_POINTER,\n+  GR_HARD_FRAME_POINTER,\n+  GR_ARG_POINTER,\n+  GR_VIRTUAL_INCOMING_ARGS,\n+  GR_VIRTUAL_STACK_ARGS,\n+  GR_VIRTUAL_STACK_DYNAMIC,\n+  GR_VIRTUAL_OUTGOING_ARGS,\n+  GR_VIRTUAL_CFA,\n+  GR_VIRTUAL_PREFERRED_STACK_BOUNDARY,\n+  GR_MAX\n+};\n+struct target_rtl {\n+  rtx x_global_rtl[GR_MAX];\n+};\n+extern struct target_rtl default_target_rtl;\n+struct function {\n+  struct machine_function * machine;\n+};\n+extern struct function *cfun;\n+struct ix86_frame\n+{\n+  long stack_pointer_offset;\n+};\n+void\n+ix86_expand_prologue (void)\n+{\n+  struct machine_function *m = (cfun + 0)->machine;\n+  struct ix86_frame frame;\n+  long allocate;\n+  allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n+  if (allocate == 0)\n+    ;\n+  else if (!ix86_target_stack_probe ()) \n+    {\n+      pro_epilogue_adjust_stack ((((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]), (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]),\n+            gen_rtx_CONST_INT ((-allocate)), -1,\n+            m->fs.cfa_reg == (((&default_target_rtl)->x_global_rtl)[GR_STACK_POINTER]));\n+    }\n+  ((void)(!(m->fs.sp_offset == frame.stack_pointer_offset) ? fancy_abort (\"../../gcc-4.7.3/gcc/config/i386/i386.c\", 10435, __FUNCTION__), 0 : 0));\n+}\n+\n+/* In the case where ALLOCATE is zero, we know that sp_offset and\n+   stack_poitner_offset within their respective structures are the\n+   same.  That allows us to thread the jump from the true arm of the\n+   first IF conditional around the test controlling the call to\n+   fancy_abort.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom2\"} } */\n+"}, {"sha": "e2e0d20fb9fb9b641b12ba17c04cb3fd6c32c3c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-16.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-16.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { ! logical_op_short_circuit  } } } */\n+/* { dg-options \"-O2 -fdump-tree-dom2-details -w\" } */\n+unsigned char\n+validate_subreg (unsigned int offset, unsigned int isize, unsigned int osize, int zz, int qq)\n+{\n+if (osize >= (((zz & (1L << 2)) != 0) ? 8 : 4) && isize >= osize)\n+    ;\n+  else if (qq == 99)\n+ return 0;\n+  if (osize > isize)\n+    return offset == 0;\n+  return 1;\n+}\n+/* When we test isize >= osize in the first IF conditional and it is\n+   false and qq != 99, then we can thread the osize > isize test of\n+   the second conditional.  */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"dom2\"} } */"}, {"sha": "2c5c5a6cf941ff815ab2ade4224c6c25e581ab32", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-17.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-17.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom2 -w\" } */\n+\n+struct rtx_def;\n+typedef struct rtx_def *rtx;\n+struct reload\n+{\n+  rtx in;\n+  rtx reg_rtx;\n+};\n+extern struct reload rld[(2 * 30 * (2 + 1))];\n+static rtx find_dummy_reload (rtx);\n+extern int frob ();\n+extern int arf ();\n+int\n+push_reload (rtx in, rtx out\n+)\n+{\n+  int i;\n+  if (out != 0 && in != out)\n+    {\n+      rld[i].reg_rtx = find_dummy_reload (out);\n+      if (rld[i].reg_rtx == out)\n+\t rld[i].in = out;\n+    }\n+}\n+rtx\n+find_dummy_reload (rtx real_out)\n+{\n+   unsigned int nwords = frob ();\n+   unsigned int regno = frob ();\n+   unsigned int i;\n+   for (i = 0; i < nwords; i++)\n+     if (arf ())\n+       break;\n+   if (i == nwords)\n+     return real_out;\n+  return 0;\n+}\n+\n+/* In the case where the call to find_dummy_reload returns 0,\n+   the final test in push_reload will never be true and it will\n+   be eliminated.  */\n+/* { dg-final { scan-tree-dump-not \"out_\\[^\\n\\r]+ == 0\" \"dom2\"} } */"}, {"sha": "610c8d60ebeec421ab1e884b9b747551c8848127", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sink-16.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n-/* Note PRE rotates the loop and blocks the sinking opportunity.  */\n-/* { dg-options \"-O2 -fno-tree-pre -fdump-tree-sink -fdump-tree-optimized\" } */\n+/* Note PRE and DOM jump threading rotate the loop and blocks the sinking opportunity.  */\n+/* { dg-options \"-O2 -fno-tree-pre -fno-tree-dominator-opts -fdump-tree-sink -fdump-tree-optimized\" } */\n \n int f(int n)\n {"}, {"sha": "d91766e902e4846383ab7e843a13ba5adc64e969", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 227, "deletions": 92, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d6281388bad11de8c328be7ea825b184fc7efe/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=14d6281388bad11de8c328be7ea825b184fc7efe", "patch": "@@ -136,19 +136,240 @@ edge_info::edge_info (edge e)\n }\n \n /* Destructor just needs to release the vectors.  */\n+\n edge_info::~edge_info (void)\n {\n   this->cond_equivalences.release ();\n   this->simple_equivalences.release ();\n }\n \n-/* Record that LHS is known to be equal to RHS at runtime when the\n-   edge associated with THIS is traversed.  */\n+/* NAME is known to have the value VALUE, which must be a constant.\n+\n+   Walk through its use-def chain to see if there are other equivalences\n+   we might be able to derive.\n+\n+   RECURSION_LIMIT controls how far back we recurse through the use-def\n+   chains.  */\n+\n+void\n+edge_info::derive_equivalences (tree name, tree value, int recursion_limit)\n+{\n+  if (TREE_CODE (name) != SSA_NAME || TREE_CODE (value) != INTEGER_CST)\n+    return;\n+\n+  /* This records the equivalence for the toplevel object.  Do\n+     this before checking the recursion limit.  */\n+  simple_equivalences.safe_push (equiv_pair (name, value));\n+\n+  /* Limit how far up the use-def chains we are willing to walk.  */\n+  if (recursion_limit == 0)\n+    return;\n+\n+  /* We can walk up the use-def chains to potentially find more\n+     equivalences.  */\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+  if (is_gimple_assign (def_stmt))\n+    {\n+      /* We know the result of DEF_STMT was zero.  See if that allows\n+\t us to deduce anything about the SSA_NAMEs used on the RHS.  */\n+      enum tree_code code = gimple_assign_rhs_code (def_stmt);\n+      switch (code)\n+\t{\n+\tcase BIT_IOR_EXPR:\n+\t  if (integer_zerop (value))\n+\t    {\n+\t      tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\n+\t      value = build_zero_cst (TREE_TYPE (rhs1));\n+\t      derive_equivalences (rhs1, value, recursion_limit - 1);\n+\t      value = build_zero_cst (TREE_TYPE (rhs2));\n+\t      derive_equivalences (rhs2, value, recursion_limit - 1);\n+\t    }\n+\t  break;\n+\n+      /* We know the result of DEF_STMT was one.  See if that allows\n+\t us to deduce anything about the SSA_NAMEs used on the RHS.  */\n+\tcase BIT_AND_EXPR:\n+\t  if (!integer_zerop (value))\n+\t    {\n+\t      tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\n+\t      /* If either operand has a boolean range, then we\n+\t\t know its value must be one, otherwise we just know it\n+\t\t is nonzero.  The former is clearly useful, I haven't\n+\t\t seen cases where the latter is helpful yet.  */\n+\t      if (TREE_CODE (rhs1) == SSA_NAME)\n+\t\t{\n+\t\t  if (ssa_name_has_boolean_range (rhs1))\n+\t\t    {\n+\t\t      value = build_one_cst (TREE_TYPE (rhs1));\n+\t\t      derive_equivalences (rhs1, value, recursion_limit - 1);\n+\t\t    }\n+\t\t}\n+\t      if (TREE_CODE (rhs2) == SSA_NAME)\n+\t\t{\n+\t\t  if (ssa_name_has_boolean_range (rhs2))\n+\t\t    {\n+\t\t      value = build_one_cst (TREE_TYPE (rhs2));\n+\t\t      derive_equivalences (rhs2, value, recursion_limit - 1);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\t/* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n+\t   set via a widening type conversion, then we may be able to record\n+\t   additional equivalences.  */\n+\tcase NOP_EXPR:\n+\tcase CONVERT_EXPR:\n+\t  {\n+\t    tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t    tree rhs_type = TREE_TYPE (rhs);\n+\t    if (INTEGRAL_TYPE_P (rhs_type)\n+\t\t&& (TYPE_PRECISION (TREE_TYPE (name))\n+\t\t    >= TYPE_PRECISION (rhs_type))\n+\t\t&& int_fits_type_p (value, rhs_type))\n+\t      derive_equivalences (rhs,\n+\t\t\t\t   fold_convert (rhs_type, value),\n+\t\t\t\t   recursion_limit - 1);\n+\t    break;\n+\t  }\n+\n+\t/* We can invert the operation of these codes trivially if\n+\t   one of the RHS operands is a constant to produce a known\n+\t   value for the other RHS operand.  */\n+\tcase POINTER_PLUS_EXPR:\n+\tcase PLUS_EXPR:\n+\t  {\n+\t    tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t    tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\n+\t    /* If either argument is a constant, then we can compute\n+\t       a constant value for the nonconstant argument.  */\n+\t    if (TREE_CODE (rhs1) == INTEGER_CST\n+\t\t&& TREE_CODE (rhs2) == SSA_NAME)\n+\t      derive_equivalences (rhs2,\n+\t\t\t\t   fold_binary (MINUS_EXPR, TREE_TYPE (rhs1),\n+\t\t\t\t\t\tvalue, rhs1),\n+\t\t\t\t   recursion_limit - 1);\n+\t    else if (TREE_CODE (rhs2) == INTEGER_CST\n+\t\t     && TREE_CODE (rhs1) == SSA_NAME)\n+\t      derive_equivalences (rhs1,\n+\t\t\t\t   fold_binary (MINUS_EXPR, TREE_TYPE (rhs1),\n+\t\t\t\t\t\tvalue, rhs2),\n+\t\t\t\t   recursion_limit - 1);\n+\t    break;\n+\t  }\n+\n+\t/* If one of the operands is a constant, then we can compute\n+\t   the value of the other operand.  If both operands are\n+\t   SSA_NAMEs, then they must be equal if the result is zero.  */\n+\tcase MINUS_EXPR:\n+\t  {\n+\t    tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t    tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\n+\t    /* If either argument is a constant, then we can compute\n+\t       a constant value for the nonconstant argument.  */\n+\t    if (TREE_CODE (rhs1) == INTEGER_CST\n+\t\t&& TREE_CODE (rhs2) == SSA_NAME)\n+\t      derive_equivalences (rhs2,\n+\t\t\t\t   fold_binary (MINUS_EXPR, TREE_TYPE (rhs1),\n+\t\t\t\t\t\trhs1, value),\n+\t\t\t\t   recursion_limit - 1);\n+\t    else if (TREE_CODE (rhs2) == INTEGER_CST\n+\t\t     && TREE_CODE (rhs1) == SSA_NAME)\n+\t      derive_equivalences (rhs1,\n+\t\t\t\t   fold_binary (PLUS_EXPR, TREE_TYPE (rhs1),\n+\t\t\t\t\t\tvalue, rhs2),\n+\t\t\t\t   recursion_limit - 1);\n+\t    else if (integer_zerop (value))\n+\t      {\n+\t\ttree cond = build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t    gimple_assign_rhs1 (def_stmt),\n+\t\t\t\t    gimple_assign_rhs2 (def_stmt));\n+\t\ttree inverted = invert_truthvalue (cond);\n+\t\trecord_conditions (&this->cond_equivalences, cond, inverted);\n+\t      }\n+\t    break;\n+\t  }\n+\n+\n+\tcase EQ_EXPR:\n+\tcase NE_EXPR:\n+\t  {\n+\t    if ((code == EQ_EXPR && integer_onep (value))\n+\t\t|| (code == NE_EXPR && integer_zerop (value)))\n+\t      {\n+\t\ttree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t\ttree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\n+\t\t/* If either argument is a constant, then record the\n+\t\t   other argument as being the same as that constant.\n+\n+\t\t   If neither operand is a constant, then we have a\n+\t\t   conditional name == name equivalence.  */\n+\t\tif (TREE_CODE (rhs1) == INTEGER_CST)\n+\t\t  derive_equivalences (rhs2, rhs1, recursion_limit - 1);\n+\t\telse if (TREE_CODE (rhs2) == INTEGER_CST)\n+\t\t  derive_equivalences (rhs1, rhs2, recursion_limit - 1);\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree cond = build2 (code, boolean_type_node,\n+\t\t\t\t    gimple_assign_rhs1 (def_stmt),\n+\t\t\t\t    gimple_assign_rhs2 (def_stmt));\n+\t\ttree inverted = invert_truthvalue (cond);\n+\t\tif (integer_zerop (value))\n+\t\t  std::swap (cond, inverted);\n+\t\trecord_conditions (&this->cond_equivalences, cond, inverted);\n+\t      }\n+\t    break;\n+\t  }\n+\n+\t/* For BIT_NOT and NEGATE, we can just apply the operation to the\n+\t   VALUE to get the new equivalence.  It will always be a constant\n+\t   so we can recurse.  */\n+\tcase BIT_NOT_EXPR:\n+\tcase NEGATE_EXPR:\n+\t  {\n+\t    tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t    tree res = fold_build1 (code, TREE_TYPE (rhs), value);\n+\t    derive_equivalences (rhs, res, recursion_limit - 1);\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  {\n+\t    if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t      {\n+\t\ttree cond = build2 (code, boolean_type_node,\n+\t\t\t\t    gimple_assign_rhs1 (def_stmt),\n+\t\t\t\t    gimple_assign_rhs2 (def_stmt));\n+\t\ttree inverted = invert_truthvalue (cond);\n+\t\tif (integer_zerop (value))\n+\t\t  std::swap (cond, inverted);\n+\t\trecord_conditions (&this->cond_equivalences, cond, inverted);\n+\t\tbreak;\n+\t      }\n+\t    break;\n+\t  }\n+\t}\n+    }\n+}\n \n void\n edge_info::record_simple_equiv (tree lhs, tree rhs)\n {\n-  simple_equivalences.safe_push (equiv_pair (lhs, rhs));\n+  /* If the RHS is a constant, then we may be able to derive\n+     further equivalences.  Else just record the name = name\n+     equivalence.  */\n+  if (TREE_CODE (rhs) == INTEGER_CST)\n+    derive_equivalences (lhs, rhs, 4);\n+  else\n+    simple_equivalences.safe_push (equiv_pair (lhs, rhs));\n }\n \n /* Free the edge_info data attached to E, if it exists.  */\n@@ -702,42 +923,6 @@ back_propagate_equivalences (tree lhs, edge e,\n     BITMAP_FREE (domby);\n }\n \n-/* Record NAME has the value zero and if NAME was set from a BIT_IOR_EXPR\n-   recurse into both operands recording their values as zero too. \n-   RECURSION_DEPTH controls how far back we recurse through the operands\n-   of the BIT_IOR_EXPR.  */\n-\n-static void\n-derive_equivalences_from_bit_ior (tree name,\n-\t\t\t\t  const_and_copies *const_and_copies,\n-\t\t\t\t  int recursion_limit)\n-{\n-  if (recursion_limit == 0)\n-    return;\n-\n-  if (TREE_CODE (name) == SSA_NAME)\n-    {\n-      tree value = build_zero_cst (TREE_TYPE (name));\n-\n-      /* This records the equivalence for the toplevel object.  */\n-      record_equality (name, value, const_and_copies);\n-\n-      /* And we can recurse into each operand to potentially find more\n-\t equivalences.  */\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-      if (is_gimple_assign (def_stmt)\n-\t  && gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR)\n-\t{\n-\t  derive_equivalences_from_bit_ior (gimple_assign_rhs1 (def_stmt),\n-\t\t\t\t\t    const_and_copies,\n-\t\t\t\t\t    recursion_limit - 1);\n-\t  derive_equivalences_from_bit_ior (gimple_assign_rhs2 (def_stmt),\n-\t\t\t\t\t    const_and_copies,\n-\t\t\t\t\t    recursion_limit - 1);\n-\t}\n-    }\n-}\n-\n /* Record into CONST_AND_COPIES and AVAIL_EXPRS_STACK any equivalences implied\n    by traversing edge E (which are cached in E->aux).\n \n@@ -758,28 +943,7 @@ record_temporary_equivalences (edge e,\n       /* If we have 0 = COND or 1 = COND equivalences, record them\n \t into our expression hash tables.  */\n       for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\t{\n-\t  avail_exprs_stack->record_cond (eq);\n-\n-\t  /* If the condition is testing that X == 0 is true or X != 0 is false\n-\t     and X is set from a BIT_IOR_EXPR, then we can record equivalences\n-\t     for the operands of the BIT_IOR_EXPR (and recurse on those).  */\n-\t  tree op0 = eq->cond.ops.binary.opnd0;\n-\t  tree op1 = eq->cond.ops.binary.opnd1;\n-\t  if (TREE_CODE (op0) == SSA_NAME && integer_zerop (op1))\n-\t    {\n-\t      enum tree_code code = eq->cond.ops.binary.op;\n-\t      if ((code == EQ_EXPR && eq->value == boolean_true_node)\n-\t\t  || (code == NE_EXPR && eq->value == boolean_false_node))\n-\t\tderive_equivalences_from_bit_ior (op0, const_and_copies, 4);\n-\n-\t      /* TODO: We could handle BIT_AND_EXPR in a similar fashion\n-\t\t recording that the operands have a nonzero value.  */\n-\n-\t      /* TODO: We can handle more cases here, particularly when OP0 is\n-\t\t known to have a boolean range.  */\n-\t    }\n-\t}\n+\tavail_exprs_stack->record_cond (eq);\n \n       edge_info::equiv_pair *seq;\n       for (i = 0; edge_info->simple_equivalences.iterate (i, &seq); ++i)\n@@ -806,42 +970,13 @@ record_temporary_equivalences (edge e,\n \t      int lhs_cost = estimate_num_insns (lhs_def, &eni_size_weights);\n \n \t      if (rhs_cost > lhs_cost)\n-\t\trecord_equality (rhs, lhs, const_and_copies);\n+\t        record_equality (rhs, lhs, const_and_copies);\n \t      else if (rhs_cost < lhs_cost)\n-\t\trecord_equality (lhs, rhs, const_and_copies);\n+\t        record_equality (lhs, rhs, const_and_copies);\n \t    }\n \t  else\n \t    record_equality (lhs, rhs, const_and_copies);\n \n-\t  /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n-\t     set via a widening type conversion, then we may be able to record\n-\t     additional equivalences.  */\n-\t  if (TREE_CODE (rhs) == INTEGER_CST)\n-\t    {\n-\t      gimple *defstmt = SSA_NAME_DEF_STMT (lhs);\n-\n-\t      if (defstmt\n-\t\t  && is_gimple_assign (defstmt)\n-\t\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (defstmt)))\n-\t\t{\n-\t\t  tree old_rhs = gimple_assign_rhs1 (defstmt);\n-\n-\t\t  /* If the conversion widens the original value and\n-\t\t     the constant is in the range of the type of OLD_RHS,\n-\t\t     then convert the constant and record the equivalence.\n-\n-\t\t     Note that int_fits_type_p does not check the precision\n-\t\t     if the upper and lower bounds are OK.  */\n-\t\t  if (INTEGRAL_TYPE_P (TREE_TYPE (old_rhs))\n-\t\t      && (TYPE_PRECISION (TREE_TYPE (lhs))\n-\t\t\t  > TYPE_PRECISION (TREE_TYPE (old_rhs)))\n-\t\t      && int_fits_type_p (rhs, TREE_TYPE (old_rhs)))\n-\t\t    {\n-\t\t      tree newval = fold_convert (TREE_TYPE (old_rhs), rhs);\n-\t\t      record_equality (old_rhs, newval, const_and_copies);\n-\t\t    }\n-\t\t}\n-\t    }\n \n \t  /* Any equivalence found for LHS may result in additional\n \t     equivalences for other uses of LHS that we have already"}]}