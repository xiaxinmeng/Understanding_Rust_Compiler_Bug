{"sha": "3dec4024284c5108d43f436b4696edc0f40db749", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RlYzQwMjQyODRjNTEwOGQ0M2Y0MzZiNDY5NmVkYzBmNDBkYjc0OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-03-06T10:17:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-03-06T10:17:23Z"}, "message": "cfgrtl.c (delete_insn_and_edges, [...]): New.\n\n\t* cfgrtl.c (delete_insn_and_edges, delete_insn_chain_and_edges): New.\n\t* rtl.h (delete_insn_and_edges, delete_insn_chain_and_edges): Declare\n\n\t* basic-block.h (update_life_info, update_life_info_in_dirty_blocks,\n\tdelete_noop_moves): Return indeger.\n\t* flow.c (ndead): New variable.\n\t(propagate_block_delete_insn): Use delete_insn_and_edges; remove\n\tBB argument; update callers.\n\t(propagate_block_delete_libcall): Use delete_insn_chain_and_edges.\n\t(life_analysis): Do not call purge_all_dead_edges.\n\t(update_life_info): Return number of deleted insns; print statistics.\n\t(update_life_info_in_dirty_blocks): likewise.\n\t(delete_noop_moves): Use delete_insn_and_edges; print statistics;\n\treturn number of insns deleted.\n\n\t* cse.c: Include timevar.h\n\t(delete_trivially_dead_insns): Kill preserve_basic_blocks argument;\n\titerate until stabilizes; print statistics; return number of killed\n\tinsns.\n\t* Makefile.in: (cse.o): Add timevar.h dependency\n\t* rtl.h (delete_trivially_dead_insns): New.\n\t* timever.def: Add TV_DELETE_TRIVIALLY_DEAD timer.\n\t* toplev.c (rest_of_compilation): Update callers.\n\n\t* cfgcleanup.c (try_optimize_cfg): Kill blocks.\n\t(try_optimize_cfg): Do not update liveness.\n\t(cleanup-cfg): Loop until try_optimize_cfg and dead code\n\tremoval stabilizes; use delete_trivially_dead_insns.\n\n\t* cfgrtl.c (verify_flow_info): Sanity check outgoing edges.\n\nFrom-SVN: r50355", "tree": {"sha": "1a7be85532d6be381af338d07dbdca5f8fd08db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a7be85532d6be381af338d07dbdca5f8fd08db0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dec4024284c5108d43f436b4696edc0f40db749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dec4024284c5108d43f436b4696edc0f40db749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dec4024284c5108d43f436b4696edc0f40db749", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dec4024284c5108d43f436b4696edc0f40db749/comments", "author": null, "committer": null, "parents": [{"sha": "9533dec17344558707c2338385daeab4474305d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9533dec17344558707c2338385daeab4474305d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9533dec17344558707c2338385daeab4474305d0"}], "stats": {"total": 577, "additions": 391, "deletions": 186}, "files": [{"sha": "3be7304970b95ae4d10d3fd72ecdcc2c0b1b7c1f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -1,3 +1,36 @@\n+Wed Mar  6 10:59:39 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfgrtl.c (delete_insn_and_edges, delete_insn_chain_and_edges): New.\n+\t* rtl.h (delete_insn_and_edges, delete_insn_chain_and_edges): Declare\n+\n+\t* basic-block.h (update_life_info, update_life_info_in_dirty_blocks,\n+\tdelete_noop_moves): Return indeger.\n+\t* flow.c (ndead): New variable.\n+\t(propagate_block_delete_insn): Use delete_insn_and_edges; remove\n+\tBB argument; update callers.\n+\t(propagate_block_delete_libcall): Use delete_insn_chain_and_edges.\n+\t(life_analysis): Do not call purge_all_dead_edges.\n+\t(update_life_info): Return number of deleted insns; print statistics.\n+\t(update_life_info_in_dirty_blocks): likewise.\n+\t(delete_noop_moves): Use delete_insn_and_edges; print statistics;\n+\treturn number of insns deleted.\n+\n+\t* cse.c: Include timevar.h\n+\t(delete_trivially_dead_insns): Kill preserve_basic_blocks argument;\n+\titerate until stabilizes; print statistics; return number of killed\n+\tinsns.\n+\t* Makefile.in: (cse.o): Add timevar.h dependency\n+\t* rtl.h (delete_trivially_dead_insns): New.\n+\t* timever.def: Add TV_DELETE_TRIVIALLY_DEAD timer.\n+\t* toplev.c (rest_of_compilation): Update callers.\n+\n+\t* cfgcleanup.c (try_optimize_cfg): Kill blocks.\n+\t(try_optimize_cfg): Do not update liveness.\n+\t(cleanup-cfg): Loop until try_optimize_cfg and dead code\n+\tremoval stabilizes; use delete_trivially_dead_insns.\n+\n+\t* cfgrtl.c (verify_flow_info): Sanity check outgoing edges.\n+\n 2002-03-05  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cppmain.c (setup_callbacks): Disable #pragma and #ident"}, {"sha": "2aabcdb5c3e07bb8548d5af845217ab3b7b27bdf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -1445,7 +1445,7 @@ cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    output.h function.h cselib.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h \\\n-   $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H)\n+   $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H)\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) hard-reg-set.h \\\n    flags.h real.h insn-config.h ggc.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n    function.h output.h toplev.h $(TM_P_H) $(PARAMS_H)"}, {"sha": "e615a5dbd5f69ece53a02f055a0b58cdb2086136", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -295,7 +295,10 @@ extern void free_basic_block_vars\tPARAMS ((int));\n extern edge split_block\t\t\tPARAMS ((basic_block, rtx));\n extern basic_block split_edge\t\tPARAMS ((edge));\n extern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\n+\n extern void commit_edge_insertions\tPARAMS ((void));\n+extern void commit_edge_insertions_watch_calls\tPARAMS ((void));\n+\n extern void remove_fake_edges\t\tPARAMS ((void));\n extern void add_noreturn_fake_exit_edges\tPARAMS ((void));\n extern void connect_infinite_loops_to_exit\tPARAMS ((void));\n@@ -588,9 +591,9 @@ enum update_life_extent\n #define LOOP_ALL\t       31\t/* All of the above  */\n \n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n-extern void update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n+extern int update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n \t\t\t\t\t int));\n-extern void update_life_info_in_dirty_blocks PARAMS ((enum update_life_extent,\n+extern int update_life_info_in_dirty_blocks PARAMS ((enum update_life_extent,\n \t\t\t\t\t\t      int));\n extern int count_or_remove_death_notes\tPARAMS ((sbitmap, int));\n extern int propagate_block\tPARAMS ((basic_block, regset, regset, regset,\n@@ -636,7 +639,7 @@ extern void allocate_bb_life_data\tPARAMS ((void));\n extern void expunge_block\t\tPARAMS ((basic_block));\n extern basic_block alloc_block\t\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n-extern void delete_noop_moves\t\tPARAMS ((rtx));\n+extern int delete_noop_moves\t\tPARAMS ((rtx));\n extern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n extern basic_block force_nonfallthru\tPARAMS ((edge));\n extern bool redirect_edge_and_branch\tPARAMS ((edge, basic_block));"}, {"sha": "46c4758d3e7b78c807606a95485e1b11d28a7375", "filename": "gcc/cfganal.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -55,7 +55,6 @@ static void flow_dfs_compute_reverse_finish\n   PARAMS ((depth_first_search_ds));\n static void remove_fake_successors\tPARAMS ((basic_block));\n static bool need_fake_edge_p\t\tPARAMS ((rtx));\n-static bool keep_with_call_p\t\tPARAMS ((rtx));\n \f\n /* Return true if the block has no effect and only forwards control flow to\n    its single destination.  */\n@@ -212,32 +211,6 @@ need_fake_edge_p (insn)\n \t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n }\n \n-/* Return true if INSN should be kept in the same block as a preceding call.\n-   This is done for a single-set whose destination is a fixed register or\n-   whose source is the function return value.  This is a helper function for\n-   flow_call_edges_add.  */\n-\n-static bool\n-keep_with_call_p (insn)\n-     rtx insn;\n-{\n-  rtx set;\n-\n-  if (INSN_P (insn) && (set = single_set (insn)) != NULL)\n-    {\n-      if (GET_CODE (SET_DEST (set)) == REG\n-\t  && fixed_regs[REGNO (SET_DEST (set))]\n-\t  && general_operand (SET_SRC (set), VOIDmode))\n-\treturn true;\n-      if (GET_CODE (SET_SRC (set)) == REG\n-\t  && FUNCTION_VALUE_REGNO_P (REGNO (SET_SRC (set)))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n /* Add fake edges to the function exit for any non constant and non noreturn\n    calls, volatile inline assembly in the bitmap of blocks specified by\n    BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks"}, {"sha": "a4dccbea80581422625daae6e373e16d72d00074", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -1510,7 +1510,6 @@ try_optimize_cfg (mode)\n   bool changed_overall = false;\n   bool changed;\n   int iterations = 0;\n-  sbitmap blocks;\n \n   if (mode & CLEANUP_CROSSJUMP)\n     add_noreturn_fake_exit_edges ();\n@@ -1673,11 +1672,6 @@ try_optimize_cfg (mode)\n   if (mode & CLEANUP_CROSSJUMP)\n     remove_fake_edges ();\n \n-  if ((mode & CLEANUP_UPDATE_LIFE) && changed_overall)\n-    update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL,\n-\t\t\t\t      PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n-\t\t\t\t      | PROP_KILL_DEAD_CODE | PROP_LOG_LINKS);\n-\n   for (i = 0; i < n_basic_blocks; i++)\n     BASIC_BLOCK (i)->aux = NULL;\n \n@@ -1720,9 +1714,39 @@ cleanup_cfg (mode)\n   bool changed = false;\n \n   timevar_push (TV_CLEANUP_CFG);\n-  changed = delete_unreachable_blocks ();\n-  if (try_optimize_cfg (mode))\n-    delete_unreachable_blocks (), changed = true;\n+  if (delete_unreachable_blocks ())\n+    {\n+      changed = true;\n+      /* We've possibly created trivially dead code.  Cleanup it right\n+\t now to introduce more oppurtunities for try_optimize_cfg.  */\n+      if (!(mode & (CLEANUP_UPDATE_LIFE | CLEANUP_PRE_SIBCALL))\n+\t  && !reload_completed)\n+\tdelete_trivially_dead_insns (get_insns(), max_reg_num ());\n+    }\n+  while (try_optimize_cfg (mode))\n+    {\n+      delete_unreachable_blocks (), changed = true;\n+      if (mode & CLEANUP_UPDATE_LIFE)\n+\t{\n+\t  /* Cleaning up CFG introduces more oppurtunities for dead code\n+\t     removal that in turn may introduce more oppurtunities for\n+\t     cleaning up the CFG.  */\n+\t  if (!update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL,\n+\t\t\t\t\t\t PROP_DEATH_NOTES\n+\t\t\t\t\t\t | PROP_SCAN_DEAD_CODE\n+\t\t\t\t\t\t | PROP_KILL_DEAD_CODE\n+\t\t\t\t\t\t | PROP_LOG_LINKS))\n+\t    break;\n+\t}\n+      else if (!(mode & CLEANUP_PRE_SIBCALL) && !reload_completed)\n+\t{\n+\t  if (!delete_trivially_dead_insns (get_insns(), max_reg_num ()))\n+\t    break;\n+\t}\n+      else\n+\tbreak;\n+      delete_dead_jumptables ();\n+    }\n \n   /* Kill the data we won't maintain.  */\n   free_EXPR_LIST_list (&label_value_list);"}, {"sha": "81722ac1b33276dfd106918a15c035ae862c46e0", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 203, "deletions": 57, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -74,7 +74,7 @@ rtx tail_recursion_label_list;\n \n static int can_delete_note_p\t\tPARAMS ((rtx));\n static int can_delete_label_p\t\tPARAMS ((rtx));\n-static void commit_one_edge_insertion\tPARAMS ((edge));\n+static void commit_one_edge_insertion\tPARAMS ((edge, int));\n static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n@@ -178,6 +178,26 @@ delete_insn (insn)\n   return next;\n }\n \n+/* Like delete_insn but also purge dead edges from BB.  */\n+rtx\n+delete_insn_and_edges (insn)\n+     rtx insn;\n+{\n+  rtx x;\n+  bool purge = false;\n+\n+  if (basic_block_for_insn\n+      && INSN_P (insn)\n+      && (unsigned int)INSN_UID (insn) < basic_block_for_insn->num_elements\n+      && BLOCK_FOR_INSN (insn)\n+      && BLOCK_FOR_INSN (insn)->end == insn)\n+    purge = true;\n+  x = delete_insn (insn);\n+  if (purge)\n+    purge_dead_edges (BLOCK_FOR_INSN (insn));\n+  return x;\n+}\n+\n /* Unlink a chain of insns between START and FINISH, leaving notes\n    that must be paired.  */\n \n@@ -203,6 +223,24 @@ delete_insn_chain (start, finish)\n       start = next;\n     }\n }\n+\n+/* Like delete_insn but also purge dead edges from BB.  */\n+void\n+delete_insn_chain_and_edges (first, last)\n+     rtx first, last;\n+{\n+  bool purge = false;\n+\n+  if (basic_block_for_insn\n+      && INSN_P (last)\n+      && (unsigned int)INSN_UID (last) < basic_block_for_insn->num_elements\n+      && BLOCK_FOR_INSN (last)\n+      && BLOCK_FOR_INSN (last)->end == last)\n+    purge = true;\n+  delete_insn_chain (first, last);\n+  if (purge)\n+    purge_dead_edges (BLOCK_FOR_INSN (last));\n+}\n \f\n /* Create a new basic block consisting of the instructions between HEAD and END\n    inclusive.  This function is designed to allow fast BB construction - reuses\n@@ -1271,8 +1309,9 @@ insert_insn_on_edge (pattern, e)\n /* Update the CFG for the instructions queued on edge E.  */\n \n static void\n-commit_one_edge_insertion (e)\n+commit_one_edge_insertion (e, watch_calls)\n      edge e;\n+     int watch_calls;\n {\n   rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;\n   basic_block bb;\n@@ -1281,63 +1320,84 @@ commit_one_edge_insertion (e)\n   insns = e->insns;\n   e->insns = NULL_RTX;\n \n-  /* Figure out where to put these things.  If the destination has\n-     one predecessor, insert there.  Except for the exit block.  */\n-  if (e->dest->pred->pred_next == NULL\n-      && e->dest != EXIT_BLOCK_PTR)\n+  /* Special case -- avoid inserting code between call and storing\n+     its return value.  */\n+  if (watch_calls && (e->flags & EDGE_FALLTHRU) && !e->dest->pred->pred_next\n+      && e->src != ENTRY_BLOCK_PTR\n+      && GET_CODE (e->src->end) == CALL_INSN)\n     {\n-      bb = e->dest;\n+      rtx next = next_nonnote_insn (e->src->end);\n \n-      /* Get the location correct wrt a code label, and \"nice\" wrt\n-\t a basic block note, and before everything else.  */\n-      tmp = bb->head;\n-      if (GET_CODE (tmp) == CODE_LABEL)\n-\ttmp = NEXT_INSN (tmp);\n-      if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n-\ttmp = NEXT_INSN (tmp);\n-      if (tmp == bb->head)\n-\tbefore = tmp;\n-      else\n-\tafter = PREV_INSN (tmp);\n+      after = e->dest->head;\n+      /* The first insn after the call may be a stack pop, skip it.  */\n+      while (next\n+\t     && keep_with_call_p (next))\n+        {\n+          after = next;\n+\t  next = next_nonnote_insn (next);\n+\t}\n+      bb = e->dest;\n     }\n-\n-  /* If the source has one successor and the edge is not abnormal,\n-     insert there.  Except for the entry block.  */\n-  else if ((e->flags & EDGE_ABNORMAL) == 0\n-\t   && e->src->succ->succ_next == NULL\n-\t   && e->src != ENTRY_BLOCK_PTR)\n+  if (!before && !after)\n     {\n-      bb = e->src;\n-\n-      /* It is possible to have a non-simple jump here.  Consider a target\n-\t where some forms of unconditional jumps clobber a register.  This\n-\t happens on the fr30 for example.\n-\n-\t We know this block has a single successor, so we can just emit\n-\t the queued insns before the jump.  */\n-      if (GET_CODE (bb->end) == JUMP_INSN)\n-\tfor (before = bb->end;\n-\t     GET_CODE (PREV_INSN (before)) == NOTE\n-\t     && NOTE_LINE_NUMBER (PREV_INSN (before)) == NOTE_INSN_LOOP_BEG;\n-\t     before = PREV_INSN (before))\n-\t  ;\n-      else\n+      /* Figure out where to put these things.  If the destination has\n+         one predecessor, insert there.  Except for the exit block.  */\n+      if (e->dest->pred->pred_next == NULL && e->dest != EXIT_BLOCK_PTR)\n \t{\n-\t  /* We'd better be fallthru, or we've lost track of what's what.  */\n-\t  if ((e->flags & EDGE_FALLTHRU) == 0)\n-\t    abort ();\n+\t  bb = e->dest;\n+\n+\t  /* Get the location correct wrt a code label, and \"nice\" wrt\n+\t     a basic block note, and before everything else.  */\n+\t  tmp = bb->head;\n+\t  if (GET_CODE (tmp) == CODE_LABEL)\n+\t    tmp = NEXT_INSN (tmp);\n+\t  if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n+\t    tmp = NEXT_INSN (tmp);\n+\t  if (tmp == bb->head)\n+\t    before = tmp;\n+\t  else if (tmp)\n+\t    after = PREV_INSN (tmp);\n+\t  else\n+\t    after = get_last_insn ();\n+\t}\n+\n+      /* If the source has one successor and the edge is not abnormal,\n+         insert there.  Except for the entry block.  */\n+      else if ((e->flags & EDGE_ABNORMAL) == 0\n+\t       && e->src->succ->succ_next == NULL\n+\t       && e->src != ENTRY_BLOCK_PTR)\n+\t{\n+\t  bb = e->src;\n+\n+\t  /* It is possible to have a non-simple jump here.  Consider a target\n+\t     where some forms of unconditional jumps clobber a register.  This\n+\t     happens on the fr30 for example.\n+\n+\t     We know this block has a single successor, so we can just emit\n+\t     the queued insns before the jump.  */\n+\t  if (GET_CODE (bb->end) == JUMP_INSN)\n+\t    for (before = bb->end;\n+\t\t GET_CODE (PREV_INSN (before)) == NOTE\n+\t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) ==\n+\t\t NOTE_INSN_LOOP_BEG; before = PREV_INSN (before))\n+\t      ;\n+\t  else\n+\t    {\n+\t      /* We'd better be fallthru, or we've lost track of what's what.  */\n+\t      if ((e->flags & EDGE_FALLTHRU) == 0)\n+\t\tabort ();\n \n+\t      after = bb->end;\n+\t    }\n+\t}\n+      /* Otherwise we must split the edge.  */\n+      else\n+\t{\n+\t  bb = split_edge (e);\n \t  after = bb->end;\n \t}\n     }\n \n-  /* Otherwise we must split the edge.  */\n-  else\n-    {\n-      bb = split_edge (e);\n-      after = bb->end;\n-    }\n-\n   /* Now that we've found the spot, do the insertion.  */\n \n   if (before)\n@@ -1352,13 +1412,12 @@ commit_one_edge_insertion (e)\n     {\n       /* ??? Remove all outgoing edges from BB and add one for EXIT.\n          This is not currently a problem because this only happens\n-\t for the (single) epilogue, which already has a fallthru edge\n-\t to EXIT.  */\n+         for the (single) epilogue, which already has a fallthru edge\n+         to EXIT.  */\n \n       e = bb->succ;\n       if (e->dest != EXIT_BLOCK_PTR\n-\t  || e->succ_next != NULL\n-\t  || (e->flags & EDGE_FALLTHRU) == 0)\n+\t  || e->succ_next != NULL || (e->flags & EDGE_FALLTHRU) == 0)\n \tabort ();\n \n       e->flags &= ~EDGE_FALLTHRU;\n@@ -1395,7 +1454,39 @@ commit_edge_insertions ()\n \t{\n \t  next = e->succ_next;\n \t  if (e->insns)\n-\t    commit_one_edge_insertion (e);\n+\t    commit_one_edge_insertion (e, false);\n+\t}\n+\n+      if (++i >= n_basic_blocks)\n+\tbreak;\n+      bb = BASIC_BLOCK (i);\n+    }\n+}\n+\f\n+/* Update the CFG for all queued instructions, taking special care of inserting\n+   code on edges between call and storing its return value.  */\n+\n+void\n+commit_edge_insertions_watch_calls ()\n+{\n+  int i;\n+  basic_block bb;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+\n+  i = -1;\n+  bb = ENTRY_BLOCK_PTR;\n+  while (1)\n+    {\n+      edge e, next;\n+\n+      for (e = bb->succ; e; e = next)\n+\t{\n+\t  next = e->succ_next;\n+\t  if (e->insns)\n+\t    commit_one_edge_insertion (e, true);\n \t}\n \n       if (++i >= n_basic_blocks)\n@@ -1649,7 +1740,7 @@ verify_flow_info ()\n   for (i = n_basic_blocks - 1; i >= 0; i--)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n-      int has_fallthru = 0;\n+      int n_fallthru = 0, n_eh = 0, n_call = 0, n_abnormal = 0, n_branch = 0;\n       edge e;\n       rtx note;\n \n@@ -1705,7 +1796,18 @@ verify_flow_info ()\n \t  last_visited [e->dest->index + 2] = bb;\n \n \t  if (e->flags & EDGE_FALLTHRU)\n-\t    has_fallthru = 1;\n+\t    n_fallthru++;\n+\n+\t  if ((e->flags & ~EDGE_DFS_BACK) == 0)\n+\t    n_branch++;\n+\n+\t  if (e->flags & EDGE_ABNORMAL_CALL)\n+\t    n_call++;\n+\n+\t  if (e->flags & EDGE_EH)\n+\t    n_eh++;\n+\t  else if (e->flags & EDGE_ABNORMAL)\n+\t    n_abnormal++;\n \n \t  if ((e->flags & EDGE_FALLTHRU)\n \t      && e->src != ENTRY_BLOCK_PTR\n@@ -1753,7 +1855,51 @@ verify_flow_info ()\n \t  edge_checksum[e->dest->index + 2] += (size_t) e;\n \t}\n \n-      if (!has_fallthru)\n+      if (n_eh && !find_reg_note (bb->end, REG_EH_REGION, NULL_RTX))\n+\t{\n+\t  error (\"Missing REG_EH_REGION note in the end of bb %i\", bb->index);\n+\t  err = 1;\n+\t}\n+      if (n_branch\n+\t  && (GET_CODE (bb->end) != JUMP_INSN\n+\t      || (n_branch > 1 && (any_uncondjump_p (bb->end)\n+\t\t\t\t   || any_condjump_p (bb->end)))))\n+\t{\n+\t  error (\"Too many outgoing branch edges from bb %i\", bb->index);\n+\t  err = 1;\n+\t}\n+      if (n_fallthru && any_uncondjump_p (bb->end))\n+\t{\n+\t  error (\"Fallthru edge after unconditional jump %i\", bb->index);\n+\t  err = 1;\n+\t}\n+      if (n_branch != 1 && any_uncondjump_p (bb->end))\n+\t{\n+\t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n+\t  err = 1;\n+\t}\n+      if (n_branch != 1 && any_condjump_p (bb->end)\n+\t  && JUMP_LABEL (bb->end) != BASIC_BLOCK (bb->index + 1)->head)\n+\t{\n+\t  error (\"Wrong amount of branch edges after conditional jump %i\", bb->index);\n+\t  err = 1;\n+\t}\n+      if (n_call && GET_CODE (bb->end) != CALL_INSN)\n+\t{\n+\t  error (\"Call edges for non-call insn in bb %i\", bb->index);\n+\t  err = 1;\n+\t}\n+      if (n_abnormal\n+\t  && (GET_CODE (bb->end) != CALL_INSN && n_call != n_abnormal)\n+\t  && (GET_CODE (bb->end) != JUMP_INSN\n+\t      || any_condjump_p (bb->end)\n+\t      || any_uncondjump_p (bb->end)))\n+\t{\n+\t  error (\"Abnormal edges for no purpose in bb %i\", bb->index);\n+\t  err = 1;\n+\t}\n+\t\n+      if (!n_fallthru)\n \t{\n \t  rtx insn;\n "}, {"sha": "7a05dad03077c4bb391caa6012862826abb1ebd4", "filename": "gcc/cse.c", "status": "modified", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -7605,81 +7606,42 @@ dead_libcall_p (insn)\n    move dead invariants out of loops or make givs for dead quantities.  The\n    remaining passes of the compilation are also sped up.  */\n \n-void\n-delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n+int\n+delete_trivially_dead_insns (insns, nreg)\n      rtx insns;\n      int nreg;\n-     int preserve_basic_blocks;\n {\n   int *counts;\n   rtx insn, prev;\n-  int i;\n   int in_libcall = 0, dead_libcall = 0;\n-  basic_block bb;\n+  int ndead = 0, nlastdead, niterations = 0;\n \n+  timevar_push (TV_DELETE_TRIVIALLY_DEAD);\n   /* First count the number of times each register is used.  */\n   counts = (int *) xcalloc (nreg, sizeof (int));\n   for (insn = next_real_insn (insns); insn; insn = next_real_insn (insn))\n     count_reg_usage (insn, counts, NULL_RTX, 1);\n \n-  /* Go from the last insn to the first and delete insns that only set unused\n-     registers or copy a register to itself.  As we delete an insn, remove\n-     usage counts for registers it uses.\n-\n-     The first jump optimization pass may leave a real insn as the last\n-     insn in the function.   We must not skip that insn or we may end\n-     up deleting code that is not really dead.  */\n-  insn = get_last_insn ();\n-  if (! INSN_P (insn))\n-    insn = prev_real_insn (insn);\n-\n-  if (!preserve_basic_blocks)\n-    for (; insn; insn = prev)\n-      {\n-\tint live_insn = 0;\n-\n-\tprev = prev_real_insn (insn);\n-\n-\t/* Don't delete any insns that are part of a libcall block unless\n-\t   we can delete the whole libcall block.\n-\n-\t   Flow or loop might get confused if we did that.  Remember\n-\t   that we are scanning backwards.  */\n-\tif (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t  {\n-\t    in_libcall = 1;\n-\t    live_insn = 1;\n-\t    dead_libcall = dead_libcall_p (insn);\n-\t  }\n-\telse if (in_libcall)\n-\t  live_insn = ! dead_libcall;\n-\telse\n-\t  live_insn = insn_live_p (insn, counts);\n-\n-\t/* If this is a dead insn, delete it and show registers in it aren't\n-\t   being used.  */\n-\n-\tif (! live_insn)\n-\t  {\n-\t    count_reg_usage (insn, counts, NULL_RTX, -1);\n-\t    delete_related_insns (insn);\n-\t  }\n+  do\n+    {\n+      nlastdead = ndead;\n+      niterations++;\n+      /* Go from the last insn to the first and delete insns that only set unused\n+\t registers or copy a register to itself.  As we delete an insn, remove\n+\t usage counts for registers it uses.\n+\n+\t The first jump optimization pass may leave a real insn as the last\n+\t insn in the function.   We must not skip that insn or we may end\n+\t up deleting code that is not really dead.  */\n+      insn = get_last_insn ();\n+      if (! INSN_P (insn))\n+\tinsn = prev_real_insn (insn);\n \n-\tif (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t  {\n-\t    in_libcall = 0;\n-\t    dead_libcall = 0;\n-\t  }\n-      }\n-  else\n-    for (i = 0; i < n_basic_blocks; i++)\n-      for (bb = BASIC_BLOCK (i), insn = bb->end; insn != bb->head; insn = prev)\n+      for (; insn; insn = prev)\n \t{\n \t  int live_insn = 0;\n \n-\t  prev = PREV_INSN (insn);\n-\t  if (!INSN_P (insn))\n-\t    continue;\n+\t  prev = prev_real_insn (insn);\n \n \t  /* Don't delete any insns that are part of a libcall block unless\n \t     we can delete the whole libcall block.\n@@ -7703,7 +7665,8 @@ delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n \t  if (! live_insn)\n \t    {\n \t      count_reg_usage (insn, counts, NULL_RTX, -1);\n-\t      delete_insn (insn);\n+\t      delete_insn_and_edges (insn);\n+\t      ndead++;\n \t    }\n \n \t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n@@ -7712,7 +7675,13 @@ delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n \t      dead_libcall = 0;\n \t    }\n \t}\n+    } while (ndead != nlastdead);\n \n+  if (rtl_dump_file && ndead)\n+    fprintf (rtl_dump_file, \"Deleted %i trivially dead insns; %i iterations\\n\",\n+\t     ndead, niterations);\n   /* Clean up.  */\n   free (counts);\n+  timevar_pop (TV_DELETE_TRIVIALLY_DEAD);\n+  return ndead;\n }"}, {"sha": "47574278e9dbb365b0fab863079973f0b413df07", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -2468,6 +2468,17 @@ get_insns ()\n   return first_insn;\n }\n \n+/* Specify a new insn as the first in the chain.  */\n+\n+void\n+set_first_insn (insn)\n+     rtx insn;\n+{\n+  if (PREV_INSN (insn) != 0)\n+    abort ();\n+  first_insn = insn;\n+}\n+\n /* Return the last insn emitted in current sequence or current function.  */\n \n rtx"}, {"sha": "ee127a5ad0dafe2311a7233d65cd3464b5d7b24c", "filename": "gcc/flow.c", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -276,6 +276,9 @@ struct propagate_block_info\n   int flags;\n };\n \n+/* Number of dead insns removed.  */\n+static int ndead;\n+\n /* Maximum length of pbi->mem_set_list before we start dropping\n    new elements on the floor.  */\n #define MAX_MEM_SET_LIST_LEN\t100\n@@ -290,7 +293,7 @@ static void mark_reg\t\t\tPARAMS ((rtx, void *));\n static void mark_regs_live_at_end\tPARAMS ((regset));\n static int set_phi_alternative_reg      PARAMS ((rtx, int, int, void *));\n static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n-static void propagate_block_delete_insn PARAMS ((basic_block, rtx));\n+static void propagate_block_delete_insn PARAMS ((rtx));\n static rtx propagate_block_delete_libcall PARAMS ((rtx, rtx));\n static int insn_dead_p\t\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, int, rtx));\n@@ -448,7 +451,6 @@ life_analysis (f, file, flags)\n   /* Always remove no-op moves.  Do this before other processing so\n      that we don't have to keep re-scanning them.  */\n   delete_noop_moves (f);\n-  purge_all_dead_edges (false);\n \n   /* Some targets can emit simpler epilogues if they know that sp was\n      not ever modified during the function.  After reload, of course,\n@@ -623,7 +625,7 @@ verify_local_live_at_start (new_live_at_start, bb)\n    Including PROP_REG_INFO does not properly refresh regs_ever_live\n    unless the caller resets it to zero.  */\n \n-void\n+int\n update_life_info (blocks, extent, prop_flags)\n      sbitmap blocks;\n      enum update_life_extent extent;\n@@ -634,6 +636,7 @@ update_life_info (blocks, extent, prop_flags)\n   int i;\n \n   tmp = INITIALIZE_REG_SET (tmp_head);\n+  ndead = 0;\n \n   timevar_push ((extent == UPDATE_LIFE_LOCAL || blocks)\n \t\t? TV_LIFE_UPDATE : TV_LIFE);\n@@ -743,18 +746,22 @@ update_life_info (blocks, extent, prop_flags)\n     }\n   timevar_pop ((extent == UPDATE_LIFE_LOCAL || blocks)\n \t       ? TV_LIFE_UPDATE : TV_LIFE);\n+  if (ndead && rtl_dump_file)\n+    fprintf (rtl_dump_file, \"deleted %i dead insns\\n\", ndead);\n+  return ndead;\n }\n \n /* Update life information in all blocks where BB_DIRTY is set.  */\n \n-void\n+int\n update_life_info_in_dirty_blocks (extent, prop_flags)\n      enum update_life_extent extent;\n      int prop_flags;\n {\n   sbitmap update_life_blocks = sbitmap_alloc (n_basic_blocks);\n   int block_num;\n   int n = 0;\n+  int ndead;\n \n   sbitmap_zero (update_life_blocks);\n   for (block_num = 0; block_num < n_basic_blocks; block_num++)\n@@ -765,9 +772,10 @@ update_life_info_in_dirty_blocks (extent, prop_flags)\n       }\n \n   if (n)\n-    update_life_info (update_life_blocks, extent, prop_flags);\n+    ndead = update_life_info (update_life_blocks, extent, prop_flags);\n \n   sbitmap_free (update_life_blocks);\n+  return ndead;\n }\n \n /* Free the variables allocated by find_basic_blocks.\n@@ -796,13 +804,14 @@ free_basic_block_vars (keep_head_end_p)\n \n /* Delete any insns that copy a register to itself.  */\n \n-void\n+int\n delete_noop_moves (f)\n      rtx f ATTRIBUTE_UNUSED;\n {\n   int i;\n   rtx insn, next;\n   basic_block bb;\n+  int nnoops = 0;\n \n   for (i = 0; i < n_basic_blocks; i++)\n     {\n@@ -829,14 +838,14 @@ delete_noop_moves (f)\n \t\t  XEXP (retval_note, 0) = new_libcall_insn;\n \t\t}\n \n-\t      /* Do not call delete_insn here since that may change\n-\t         the basic block boundaries which upsets some callers.  */\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t      delete_insn_and_edges (insn);\n+\t      nnoops++;\n \t    }\n \t}\n     }\n+  if (nnoops && rtl_dump_file)\n+    fprintf (rtl_dump_file, \"deleted %i noop moves\", nnoops);\n+  return nnoops;\n }\n \n /* Delete any jump tables never referenced.  We can't delete them at the\n@@ -1483,12 +1492,11 @@ allocate_reg_life_data ()\n /* Delete dead instructions for propagate_block.  */\n \n static void\n-propagate_block_delete_insn (bb, insn)\n-     basic_block bb;\n+propagate_block_delete_insn (insn)\n      rtx insn;\n {\n   rtx inote = find_reg_note (insn, REG_LABEL, NULL_RTX);\n-  bool purge = false;\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   /* If the insn referred to a label, and that label was attached to\n      an ADDR_VEC, it's safe to delete the ADDR_VEC.  In fact, it's\n@@ -1526,15 +1534,13 @@ propagate_block_delete_insn (bb, insn)\n \t  for (i = 0; i < len; i++)\n \t    LABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n \n-\t  delete_insn (next);\n+\t  delete_insn_and_edges (next);\n+\t  ndead++;\n \t}\n     }\n \n-  if (bb->end == insn)\n-    purge = true;\n-  delete_insn (insn);\n-  if (purge)\n-    purge_dead_edges (bb);\n+  delete_insn_and_edges (insn);\n+  ndead++;\n }\n \n /* Delete dead libcalls for propagate_block.  Return the insn\n@@ -1547,7 +1553,8 @@ propagate_block_delete_libcall ( insn, note)\n   rtx first = XEXP (note, 0);\n   rtx before = PREV_INSN (first);\n \n-  delete_insn_chain (first, insn);\n+  delete_insn_chain_and_edges (first, insn);\n+  ndead++;\n   return before;\n }\n \n@@ -1608,7 +1615,7 @@ propagate_one_insn (pbi, insn)\n       if (libcall_is_dead)\n \tprev = propagate_block_delete_libcall ( insn, note);\n       else\n-\tpropagate_block_delete_insn (pbi->bb, insn);\n+\tpropagate_block_delete_insn (insn);\n \n       return prev;\n     }\n@@ -3940,7 +3947,7 @@ try_pre_increment_1 (pbi, insn)\n     {\n       /* We have found a suitable auto-increment and already changed\n \t insn Y to do it.  So flush this increment instruction.  */\n-      propagate_block_delete_insn (pbi->bb, insn);\n+      propagate_block_delete_insn (insn);\n \n       /* Count a reference to this reg for the increment insn we are\n \t deleting.  When a reg is incremented, spilling it is worse,"}, {"sha": "09fab359a8959b1aba557d0ef3c5d453c5f53f90", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -169,7 +169,7 @@ instrument_edges (el)\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n \n-  commit_edge_insertions ();\n+  commit_edge_insertions_watch_calls ();\n }\n \n /* Output STRING to bb_file, surrounded by DELIMITER.  */"}, {"sha": "e8f819c9dd77e8eb9f776e2876a88e5cc5669f90", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -1518,6 +1518,7 @@ extern void remove_node_from_expr_list\tPARAMS ((rtx, rtx *));\n extern int insns_safe_to_move_p         PARAMS ((rtx, rtx, rtx *));\n extern int loc_mentioned_in_p\t\tPARAMS ((rtx *, rtx));\n extern rtx find_first_parameter_load\tPARAMS ((rtx, rtx));\n+extern bool keep_with_call_p\t\tPARAMS ((rtx));\n \n /* flow.c */\n \n@@ -1792,7 +1793,7 @@ struct cse_basic_block_data;\n \n extern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\n extern int address_cost\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern void delete_trivially_dead_insns\tPARAMS ((rtx, int, int));\n+extern int delete_trivially_dead_insns\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n extern int cse_main\t\t\tPARAMS ((rtx, int, int, FILE *));\n #endif\n@@ -1873,6 +1874,8 @@ extern void renumber_insns                      PARAMS ((FILE *));\n extern void remove_unnecessary_notes             PARAMS ((void));\n extern rtx delete_insn\t\t\tPARAMS ((rtx));\n extern void delete_insn_chain\t\tPARAMS ((rtx, rtx));\n+extern rtx delete_insn_and_edges\tPARAMS ((rtx));\n+extern void delete_insn_chain_and_edges\tPARAMS ((rtx, rtx));\n \n /* In combine.c */\n extern int combine_instructions\t\tPARAMS ((rtx, unsigned int));"}, {"sha": "997bb525a2be0d2cf0d28a6f7cb6139b014c0901", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -3119,3 +3119,38 @@ find_first_parameter_load (call_insn, boundary)\n     }\n   return before;\n }\n+\n+/* Return true if we should avoid inserting code between INSN and preceeding\n+   call instruction.  */\n+\n+bool\n+keep_with_call_p (insn)\n+     rtx insn;\n+{\n+  rtx set;\n+\n+  if (INSN_P (insn) && (set = single_set (insn)) != NULL)\n+    {\n+      if (GET_CODE (SET_DEST (set)) == REG\n+\t  && fixed_regs[REGNO (SET_DEST (set))]\n+\t  && general_operand (SET_SRC (set), VOIDmode))\n+\treturn true;\n+      if (GET_CODE (SET_SRC (set)) == REG\n+\t  && FUNCTION_VALUE_REGNO_P (REGNO (SET_SRC (set)))\n+\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n+\treturn true;\n+      /* There may be stack pop just after the call and\n+         before actual store of return register.  Search\n+\t for the actual store when deciding if we can break\n+\t or not.  */\n+      if (SET_DEST (set) == stack_pointer_rtx)\n+\t{\n+\t  rtx i2 = next_nonnote_insn (insn);\n+\t  if (i2 && keep_with_call_p (insn))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+"}, {"sha": "74f8907ae7b58b363e681840ed4b169cec15ce53", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -43,6 +43,7 @@ DEFTIMEVAR (TV_DUMP                  , \"dump files\")\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n /* Time spent by cleaning up CFG.  */\n DEFTIMEVAR (TV_CLEANUP_CFG           , \"cfg cleanup\")\n+DEFTIMEVAR (TV_DELETE_TRIVIALLY_DEAD , \"trivially dead code\")\n /* Time spent by life analysis.  */\n DEFTIMEVAR (TV_LIFE\t\t     , \"life analysis\")\n DEFTIMEVAR (TV_LIFE_UPDATE\t     , \"life info update\")"}, {"sha": "f97db60235008ad5ec14f3154a6c3004cfa7da55", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dec4024284c5108d43f436b4696edc0f40db749/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3dec4024284c5108d43f436b4696edc0f40db749", "patch": "@@ -2778,7 +2778,7 @@ rest_of_compilation (decl)\n \n       /* Run this after jump optmizations remove all the unreachable code\n \t so that unreachable code will not keep values live.  */\n-      delete_trivially_dead_insns (insns, max_reg_num (), 1);\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n \n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks || flag_thread_jumps)\n@@ -2851,7 +2851,7 @@ rest_of_compilation (decl)\n \t  tem = tem2 = 0;\n \t  timevar_push (TV_JUMP);\n \t  rebuild_jump_labels (insns);\n-\t  delete_trivially_dead_insns (insns, max_reg_num (), 1);\n+\t  delete_trivially_dead_insns (insns, max_reg_num ());\n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \t  timevar_pop (TV_JUMP);\n \n@@ -2899,7 +2899,7 @@ rest_of_compilation (decl)\n \t     trivially dead.  We delete those instructions now in the\n \t     hope that doing so will make the heuristics in loop work\n \t     better and possibly speed up compilation.  */\n-\t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n+\t  delete_trivially_dead_insns (insns, max_reg_num ());\n \n \t  /* The regscan pass is currently necessary as the alias\n \t\t  analysis code depends on this information.  */\n@@ -2911,7 +2911,7 @@ rest_of_compilation (decl)\n \t\t     | (flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0));\n \n       /* Loop can create trivially dead instructions.  */\n-      delete_trivially_dead_insns (insns, max_reg_num (), 0);\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n       close_dump_file (DFI_loop, print_rtl, insns);\n       timevar_pop (TV_LOOP);\n "}]}