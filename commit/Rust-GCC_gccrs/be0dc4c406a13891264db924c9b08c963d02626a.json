{"sha": "be0dc4c406a13891264db924c9b08c963d02626a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUwZGM0YzQwNmExMzg5MTI2NGRiOTI0YzliMDhjOTYzZDAyNjI2YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-31T12:47:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-31T12:47:49Z"}, "message": "Initial revision\n\nFrom-SVN: r11131", "tree": {"sha": "593ff2b6ec5ad883f93348adf40225cc78cf509c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/593ff2b6ec5ad883f93348adf40225cc78cf509c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be0dc4c406a13891264db924c9b08c963d02626a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0dc4c406a13891264db924c9b08c963d02626a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be0dc4c406a13891264db924c9b08c963d02626a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0dc4c406a13891264db924c9b08c963d02626a/comments", "author": null, "committer": null, "parents": [{"sha": "9f8aaea1bce127e3f1888ce835247f0473b456ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f8aaea1bce127e3f1888ce835247f0473b456ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f8aaea1bce127e3f1888ce835247f0473b456ca"}], "stats": {"total": 1107, "additions": 1107, "deletions": 0}, "files": [{"sha": "fdf21a471f17d4bafaff26d01083cee58c02ddd9", "filename": "gcc/config/i386/ptx4-i.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0dc4c406a13891264db924c9b08c963d02626a/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0dc4c406a13891264db924c9b08c963d02626a/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fptx4-i.h?ref=be0dc4c406a13891264db924c9b08c963d02626a", "patch": "@@ -0,0 +1,247 @@\n+/* Target definitions for GNU compiler for Intel 80386 running Dynix/ptx v4\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+   Modified from sysv4.h\n+   Originally written by Ron Guilmette (rfg@netcom.com).\n+   Modified by Tim Wright (timw@sequent.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"i386/i386.h\"\t/* Base i386 target machine definitions */\n+#include \"i386/att.h\"\t/* Use the i386 AT&T assembler syntax */\n+#include \"ptx4.h\"\t/* Rest of definitions (non architecture dependent) */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i386 Sequent Dynix/ptx Version 4)\");\n+\n+/* The svr4 ABI for the i386 says that records and unions are returned\n+   in memory.  */\n+\n+#undef RETURN_IN_MEMORY\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  (TYPE_MODE (TYPE) == BLKmode)\n+\n+/* Define which macros to predefine.  _SEQUENT_ is our extension.  */\n+/* This used to define X86, but james@bigtex.cactus.org says that\n+   is supposed to be defined optionally by user programs--not by default.  */\n+#define CPP_PREDEFINES \\\n+  \"-Di386 -Dunix -D_SEQUENT_ -Asystem(unix) -Asystem(ptx4) -Acpu(i386) -Amachine(i386)\"\n+\n+/* This is how to output assembly code to define a `float' constant.\n+   We always have to use a .long pseudo-op to do this because the native\n+   SVR4 ELF assembler is buggy and it generates incorrect values when we\n+   try to use the .float pseudo-op instead.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+do { long value;\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE ((VALUE), value);\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value);\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value);\t\t\\\n+   } while (0)\n+\n+/* This is how to output assembly code to define a `double' constant.\n+   We always have to use a pair of .long pseudo-ops to do this because\n+   the native SVR4 ELF assembler is buggy and it generates incorrect\n+   values when we try to use the the .double pseudo-op instead.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+do { long value[2];\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), value);\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[1]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[1]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+   } while (0)\n+\n+\n+#undef ASM_OUTPUT_LONG_DOUBLE\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+do { long value[3];\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE ((VALUE), value);\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[1]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[2]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[0]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[1]);\t\t\\\n+         fprintf((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, value[2]);\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+   } while (0)\n+\n+/* Output at beginning of assembler file.  */\n+/* The .file command should always begin the output.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+\toutput_file_directive (FILE, main_input_filename);\t\t\\\n+\tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Define the register numbers to be used in Dwarf debugging information.\n+   The SVR4 reference port C compiler uses the following register numbers\n+   in its Dwarf output code:\n+\n+\t0 for %eax (gnu regno = 0)\n+\t1 for %ecx (gnu regno = 2)\n+\t2 for %edx (gnu regno = 1)\n+\t3 for %ebx (gnu regno = 3)\n+\t4 for %esp (gnu regno = 7)\n+\t5 for %ebp (gnu regno = 6)\n+\t6 for %esi (gnu regno = 4)\n+\t7 for %edi (gnu regno = 5)\n+\n+   The following three DWARF register numbers are never generated by\n+   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n+   believes these numbers have these meanings.\n+\n+\t8  for %eip    (no gnu equivalent)\n+\t9  for %eflags (no gnu equivalent)\n+\t10 for %trapno (no gnu equivalent)\n+\n+   It is not at all clear how we should number the FP stack registers\n+   for the x86 architecture.  If the version of SDB on x86/svr4 were\n+   a bit less brain dead with respect to floating-point then we would\n+   have a precedent to follow with respect to DWARF register numbers\n+   for x86 FP registers, but the SDB on x86/svr4 is so completely\n+   broken with respect to FP registers that it is hardly worth thinking\n+   of it as something to strive for compatibility with.\n+\n+   The version of x86/svr4 SDB I have at the moment does (partially)\n+   seem to believe that DWARF register number 11 is associated with\n+   the x86 register %st(0), but that's about all.  Higher DWARF\n+   register numbers don't seem to be associated with anything in\n+   particular, and even for DWARF regno 11, SDB only seems to under-\n+   stand that it should say that a variable lives in %st(0) (when\n+   asked via an `=' command) if we said it was in DWARF regno 11,\n+   but SDB still prints garbage when asked for the value of the\n+   variable in question (via a `/' command).\n+\n+   (Also note that the labels SDB prints for various FP stack regs\n+   when doing an `x' command are all wrong.)\n+\n+   Note that these problems generally don't affect the native SVR4\n+   C compiler because it doesn't allow the use of -O with -g and\n+   because when it is *not* optimizing, it allocates a memory\n+   location for each floating-point variable, and the memory\n+   location is what gets described in the DWARF AT_location\n+   attribute for the variable in question.\n+\n+   Regardless of the severe mental illness of the x86/svr4 SDB, we\n+   do something sensible here and we use the following DWARF\n+   register numbers.  Note that these are all stack-top-relative\n+   numbers.\n+\n+\t11 for %st(0) (gnu regno = 8)\n+\t12 for %st(1) (gnu regno = 9)\n+\t13 for %st(2) (gnu regno = 10)\n+\t14 for %st(3) (gnu regno = 11)\n+\t15 for %st(4) (gnu regno = 12)\n+\t16 for %st(5) (gnu regno = 13)\n+\t17 for %st(6) (gnu regno = 14)\n+\t18 for %st(7) (gnu regno = 15)\n+*/\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n) \\\n+((n) == 0 ? 0 \\\n+ : (n) == 1 ? 2 \\\n+ : (n) == 2 ? 1 \\\n+ : (n) == 3 ? 3 \\\n+ : (n) == 4 ? 6 \\\n+ : (n) == 5 ? 7 \\\n+ : (n) == 6 ? 5 \\\n+ : (n) == 7 ? 4 \\\n+ : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n+ : (-1))\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 64)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fputc ('\\n', (FILE));\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fputc ('\\n', (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"\\t.byte\\t\");\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfputc (',', (FILE));\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"0x%02x\", *_ascii_bytes);\t\t\\\n+\t      bytes_in_chunk += 5;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   This is only used for PIC code.  See comments by the `casesi' insn in\n+   i386.md for an explanation of the expression this outputs. */\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION"}, {"sha": "c4f163c22d7ca66af5de80ebd376a9289fe77dc4", "filename": "gcc/config/ptx4.h", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0dc4c406a13891264db924c9b08c963d02626a/gcc%2Fconfig%2Fptx4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0dc4c406a13891264db924c9b08c963d02626a/gcc%2Fconfig%2Fptx4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fptx4.h?ref=be0dc4c406a13891264db924c9b08c963d02626a", "patch": "@@ -0,0 +1,860 @@\n+/* Operating system specific defines to be used when targeting GCC for some\n+   generic System V Release 4 system.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Ron Guilmette (rfg@segfault.us.com).\n+   Renamed and changed to suit Dynix/ptx v4 and later.\n+   Modified by Tim Wright (timw@sequent.com).\n+  \n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+*/\n+\n+/* Define a symbol indicating that we are using svr4.h.  */\n+#define USING_SVR4_H\n+\n+/* For the sake of libgcc2.c, indicate target supports atexit.  */\n+#define HAVE_ATEXIT\n+\n+/* Cpp, assembler, linker, library, and startfile spec's.  */\n+\n+/* This defines which switch letters take arguments.  On svr4, most of\n+   the normal cases (defined in gcc.c) apply, and we also have -h* and\n+   -z* options (for the linker).  Note however that there is no such\n+   thing as a -T option for svr4.  */\n+\n+#define SWITCH_TAKES_ARG(CHAR) \\\n+  (   (CHAR) == 'D' \\\n+   || (CHAR) == 'U' \\\n+   || (CHAR) == 'o' \\\n+   || (CHAR) == 'e' \\\n+   || (CHAR) == 'u' \\\n+   || (CHAR) == 'I' \\\n+   || (CHAR) == 'm' \\\n+   || (CHAR) == 'L' \\\n+   || (CHAR) == 'A' \\\n+   || (CHAR) == 'h' \\\n+   || (CHAR) == 'z')\n+\n+/* This defines which multi-letter switches take arguments.  On svr4,\n+   there are no such switches except those implemented by GCC itself.  */\n+\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\\\n+ (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\t\t\t\\\n+  && strcmp (STR, \"Tdata\") && strcmp (STR, \"Ttext\")\t\\\n+  && strcmp (STR, \"Tbss\"))\n+\n+/* You should redefine CPP_PREDEFINES in any file which includes this one.\n+   The definition should be appropriate for the type of target system\n+   involved, and it should include any -A (assertion) options which are\n+   appropriate for the given target system.  */\n+#undef CPP_PREDEFINES\n+\n+/* Provide an ASM_SPEC appropriate for svr4.  Here we try to support as\n+   many of the specialized svr4 assembler options as seems reasonable,\n+   given that there are certain options which we can't (or shouldn't)\n+   support directly due to the fact that they conflict with other options \n+   for other svr4 tools (e.g. ld) or with other options for GCC itself.\n+   For example, we don't support the -o (output file) or -R (remove\n+   input file) options because GCC already handles these things.  We\n+   also don't support the -m (run m4) option for the assembler because\n+   that conflicts with the -m (produce load map) option of the svr4\n+   linker.  We do however allow passing arbitrary options to the svr4\n+   assembler via the -Wa, option.\n+\n+   Note that gcc doesn't allow a space to follow -Y in a -Ym,* or -Yd,*\n+   option.\n+*/\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+  \"-no_0f_fix %{V} %{v:%{!V:-V}} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n+\n+/* svr4 assemblers need the `-' (indicating input from stdin) to come after\n+   the -o option (and its argument) for some reason.  If we try to put it\n+   before the -o option, the assembler will try to read the file named as\n+   the output file in the -o option as an input file (after it has already\n+   written some stuff to it) and the binary stuff contained therein will\n+   cause totally confuse the assembler, resulting in many spurious error\n+   messages.  */\n+\n+#undef ASM_FINAL_SPEC\n+#define ASM_FINAL_SPEC \"%{pipe:-}\"\n+\n+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default\n+   standard C library (unless we are building a shared library).  */\n+\n+#undef\tLIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{!symbolic:-lc}}\"\n+\n+/* Provide a LIBGCC_SPEC appropriate for svr4.  We also want to exclude\n+   libgcc when -symbolic.  */\n+\n+#undef  LIBGCC_SPEC\n+#define LIBGCC_SPEC \"%{!shared:%{!symbolic:-lgcc}}\"\n+\n+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own\n+   magical crtend.o file (see crtstuff.c) which provides part of the\n+   support for getting C++ file-scope static object constructed before\n+   entering `main', followed by the normal svr3/svr4 \"finalizer\" file,\n+   which is either `gcrtn.o' or `crtn.o'.  */\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s %{pg:gcrtn.o}%{!pg:crtn.o%s}\"\n+\n+/* Provide a LINK_SPEC appropriate for svr4.  Here we provide support\n+   for the special GCC options -static, -shared, and -symbolic which\n+   allow us to link things in one of these three modes by applying the\n+   appropriate combinations of options at link-time.  We also provide\n+   support here for as many of the other svr4 linker options as seems\n+   reasonable, given that some of them conflict with options for other\n+   svr4 tools (e.g. the assembler).  In particular, we do support the\n+   -h*, -z*, -V, -b, -t, -Qy, -Qn, and -YP* options here, and the -e*,\n+   -l*, -o*, -r, -s, -u*, and -L* options are directly supported\n+   by gcc.c itself.  We don't directly support the -m (generate load\n+   map) option because that conflicts with the -m (run m4) option of\n+   the svr4 assembler.  We also don't directly support the svr4 linker's\n+   -I* or -M* options because these conflict with existing GCC options.\n+   We do however allow passing arbitrary options to the svr4 linker\n+   via the -Wl, option.  We don't support the svr4 linker's -a option\n+   at all because it is totally useless and because it conflicts with\n+   GCC's own -a option.\n+\n+   Note that gcc doesn't allow a space to follow -Y in a -YP,* option.\n+\n+   When the -G link option is used (-shared and -symbolic) a final link is\n+   not being done.  */\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"%{h*} %{V} %{v:%{!V:-V}} \\\n+\t\t   %{b} %{Wl,*:%*} \\\n+\t\t   %{static:-dn -Bstatic} \\\n+\t\t   %{shared:-G -dy -z text %{!h*:%{o*:-h %*}}} \\\n+\t\t   %{symbolic:-Bsymbolic -G -dy -z text %{!h*:%{o*:-h %*}}} \\\n+\t\t   %{G:-G} \\\n+\t\t   %{YP,*} \\\n+\t\t   %{!YP,*:%{p:-Y P,/lib/libp:/usr/lib/libp:/lib:/usr/lib} \\\n+\t\t    %{!p:-Y P,/lib:/usr/lib}} \\\n+\t\t   %{Qy:} %{!Qn:-Qy}\"\n+\n+/* Gcc automatically adds in one of the files /lib/values-Xc.o,\n+   /lib/values-Xa.o, or /lib/values-Xt.o for each final link\n+   step (depending upon the other gcc options selected, such as\n+   -traditional and -ansi).  These files each contain one (initialized)\n+   copy of a special variable called `_lib_version'.  Each one of these\n+   files has `_lib_version' initialized to a different (enum) value.\n+   The SVR4 library routines query the value of `_lib_version' at run\n+   to decide how they should behave.  Specifically, they decide (based\n+   upon the value of `_lib_version') if they will act in a strictly ANSI\n+   conforming manner or not.\n+*/\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared: \\\n+\t\t\t %{!symbolic: \\\n+\t\t\t  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}}}\\\n+\t\t\t%{pg:gcrti.o%s}%{!pg:crti.o%s} \\\n+\t\t\t%{ansi:values-Xc.o%s} \\\n+\t\t\t%{!ansi: \\\n+\t\t\t %{traditional:values-Xt.o%s} \\\n+\t\t\t %{!traditional:values-Xa.o%s}} \\\n+ \t\t\tcrtbegin.o%s\"\n+\n+/* Attach a special .ident directive to the end of the file to identify\n+   the version of GCC which compiled this code.  The format of the\n+   .ident string is patterned after the ones produced by native svr4\n+   C compilers.  */\n+\n+#define IDENT_ASM_OP \".ident\"\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+do {\t\t\t\t \t\t\t\t\\\n+     fprintf ((FILE), \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\\\n+\t      IDENT_ASM_OP, version_string);\t\t\t\\\n+   } while (0)\n+\n+/* Allow #sccs in preprocessor.  */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n+\n+/* Use periods rather than dollar signs in special g++ assembler names.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* Writing `int' for a bitfield forces int alignment for the structure.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Handle #pragma weak and #pragma pack.  */\n+\n+#define HANDLE_SYSV_PRAGMA\n+\n+/* System V Release 4 uses DWARF debugging info.  */\n+\n+#define DWARF_DEBUGGING_INFO\n+\n+/* The numbers used to denote specific machine registers in the System V\n+   Release 4 DWARF debugging information are quite likely to be totally\n+   different from the numbers used in BSD stabs debugging information\n+   for the same kind of target machine.  Thus, we undefine the macro\n+   DBX_REGISTER_NUMBER here as an extra inducement to get people to\n+   provide proper machine-specific definitions of DBX_REGISTER_NUMBER\n+   (which is also used to provide DWARF registers numbers in dwarfout.c)\n+   in their tm.h files which include this file.  */\n+\n+#undef DBX_REGISTER_NUMBER\n+\n+/* gas on SVR4 supports the use of .stabs.  Permit -gstabs to be used\n+   in general, although it will only work when using gas.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Use DWARF debugging info by default.  */\n+\n+#ifndef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n+#endif\n+\n+/* Make LBRAC and RBRAC addresses relative to the start of the\n+   function.  The native Solaris stabs debugging format works this\n+   way, gdb expects it, and it reduces the number of relocation\n+   entries.  */\n+\n+#define DBX_BLOCKS_FUNCTION_RELATIVE 1\n+\n+/* When using stabs, gcc2_compiled must be a stabs entry, not an\n+   ordinary symbol, or gdb won't see it.  The stabs entry must be\n+   before the N_SO in order for gdb to find it.  */\n+\n+#define ASM_IDENTIFY_GCC(FILE)\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (write_symbols != DBX_DEBUG)\t\t\t\t\t\\\n+      fputs (\"gcc2_compiled.:\\n\", FILE);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.stabs\\t\\\"gcc2_compiled.\\\", 0x3c, 0, 0, 0\\n\", FILE);\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Like block addresses, stabs line numbers are relative to the\n+   current function.  */\n+\n+#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static int sym_lineno = 1;\t\t\t\t\t\t\\\n+    fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n+\t     line, sym_lineno);\t\t\t\t\t\t\\\n+    assemble_name (file,\t\t\t\t\t\t\\\n+\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\\\n+    fprintf (file, \"\\n.LM%d:\\n\", sym_lineno);\t\t\t\t\\\n+    sym_lineno += 1;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* In order for relative line numbers to work, we must output the\n+   stabs entry for the function name first.  */\n+\n+#define DBX_FUNCTION_FIRST\n+\n+/* Generate a blank trailing N_SO to mark the end of the .o file, since\n+   we can't depend upon the linker to mark .o file boundaries with\n+   embedded stabs.  */\n+\n+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n+  fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t   \"\\t.text\\n\\t.stabs \\\"\\\",%d,0,0,.Letext\\n.Letext:\\n\", N_SO)\n+\n+/* Define the actual types of some ANSI-mandated types.  (These\n+   definitions should work for most SVR4 systems).  */\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+/* This causes trouble, because it requires the host machine\n+   to support ANSI C.  */\n+/* #define MULTIBYTE_CHARS */\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\".byte\"\n+\n+#undef SET_ASM_OP\n+#define SET_ASM_OP\t\".set\"\n+\n+/* This is how to begin an assembly language file.  Most svr4 assemblers want\n+   at least a .file directive to come first, and some want to see a .version\n+   directive come right after that.  Here we just establish a default\n+   which generates only the .file directive.  If you need a .version\n+   directive for any specific target, you should override this definition\n+   in the target-specific file which includes this one.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)                                    \\\n+  output_file_directive ((FILE), main_input_filename)\n+\n+/* This is how to allocate empty space in some section.  The .zero\n+   pseudo-op is used for this on most svr4 assemblers.  */\n+\n+#define SKIP_ASM_OP\t\".zero\"\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n+  fprintf (FILE, \"\\t%s\\t%u\\n\", SKIP_ASM_OP, (SIZE))\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.\n+\n+   For System V Release 4 the convention is *not* to prepend a leading\n+   underscore onto user-level symbol names.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler. */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler. */\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM);\t\t\t\t\\\n+} while (0)\n+\n+/* Output the label which precedes a jumptable.  Note that for all svr4\n+   systems where we actually generate jumptables (which is to say every\n+   svr4 target except i386, where we use casesi instead) we put the jump-\n+   tables into the .rodata section and since other stuff could have been\n+   put into the .rodata section prior to any given jumptable, we have to\n+   make sure that the location counter for the .rodata section gets pro-\n+   perly re-aligned prior to the actual beginning of the jump table.  */\n+\n+#define ALIGN_ASM_OP \".align\"\n+\n+#ifndef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n+  ASM_OUTPUT_ALIGN ((FILE), 2);\n+#endif\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n+    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n+  } while (0)\n+\n+/* The standard SVR4 assembler seems to require that certain builtin\n+   library routines (e.g. .udiv) be explicitly declared as .globl\n+   in each assembly file where they are referenced.  */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n+  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized external linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define COMMON_ASM_OP\t\".comm\"\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized internal linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define LOCAL_ASM_OP\t\".local\"\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n+} while (0)\n+\n+/* This is the pseudo-op used to generate a 32-bit word of data with a\n+   specific value in some section.  This is the same for all known svr4\n+   assemblers.  */\n+\n+#define INT_ASM_OP\t\t\".long\"\n+\n+/* This is the pseudo-op used to generate a contiguous sequence of byte\n+   values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n+   AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP\t\".ascii\"\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n+\n+#define USE_CONST_SECTION\t1\n+\n+#define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n+\n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+\n+   Note that we want to give these sections the SHF_WRITE attribute\n+   because these sections will actually contain data (i.e. tables of\n+   addresses of functions in the current root executable or shared library\n+   file) and, in the case of a shared library, the relocatable addresses\n+   will have to be properly resolved/relocated (and then written into) by\n+   the dynamic linker when it actually attaches the given shared library\n+   to the executing process.  (Note that on SVR4, you may wish to use the\n+   `-z text' option to the ELF linker, when building a shared library, as\n+   an additional check that you are doing everything right.  But if you do\n+   use the `-z text' option when building a shared library, you will get\n+   errors unless the .ctors and .dtors sections are marked as writable\n+   via the SHF_WRITE attribute.)  */\n+\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\"\"\n+\n+/* On svr4, we *do* have support for the .init and .fini sections, and we\n+   can put stuff in there to be executed before and after `main'.  We let\n+   crtstuff.c and other files know this by defining the following symbols.\n+   The definitions say how to change sections to the .init and .fini\n+   sections.  This is the same for all known svr4 assemblers.  */\n+\n+#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n+#define FINI_SECTION_ASM_OP\t\".section\\t.fini\"\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n+\n+/* A default list of extra section function definitions.  For targets\n+   that use additional sections (e.g. .tdesc) you should override this\n+   definition in the target-specific file which includes this file.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+extern void text_section ();\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch into a generic section.\n+   This is currently only used to support section attributes.\n+\n+   We make the section read-only and executable for a function decl,\n+   read-only for a const data decl, and writable for a non-const data decl. */\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME) \\\n+  fprintf (FILE, \".section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, \\\n+\t   (DECL) && TREE_CODE (DECL) == FUNCTION_DECL ? \"ax\" : \\\n+\t   (DECL) && TREE_READONLY (DECL) ? \"a\" : \"aw\")\n+\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE,RTX) const_section()\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n+  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n+       fputc ('\\n', FILE); } while (0)\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare a function properly.\n+   Some svr4 assemblers need to also have something extra said about the\n+   function's return value.  We allow for that here.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n+/* This is how to declare the size of a function.  */\n+\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n+   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table\n+   corresponds to a particular byte value [0..255].  For any\n+   given byte value, if the value in the corresponding table\n+   position is zero, the given character can be output directly.\n+   If the table value is 1, the byte must be output as a \\ooo\n+   octal escape.  If the tables value is anything else, then the\n+   byte value should be output as a \\ followed by the value\n+   in the table.  Note that we can use standard UN*X escape\n+   sequences for many control characters, but we don't use\n+   \\a to represent BEL because some svr4 assemblers (e.g. on\n+   the i386) don't know about that.  Also, we don't use \\v\n+   since some versions of gas, such as 2.2 did not accept it.  */\n+\n+#define ESCAPES \\\n+\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n+\n+/* Some svr4 assemblers have a limit on the number of characters which\n+   can appear in the operand of a .string directive.  If your assembler\n+   has such a limitation, you should define STRING_LIMIT to reflect that\n+   limit.  Note that at least some svr4 assemblers have a limit on the\n+   actual number of bytes in the double-quoted string, and that they\n+   count each character in an escape sequence as one byte.  Thus, an\n+   escape sequence like \\377 would count as four bytes.\n+\n+   If your target assembler doesn't support the .string directive, you\n+   should define this to zero.\n+*/\n+\n+#define STRING_LIMIT\t((unsigned) 256)\n+\n+#define STRING_ASM_OP\t\".string\"\n+\n+/* The routine used to output NUL terminated strings.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable, especially for targets like the i386\n+   (where the only alternative is to output character sequences as\n+   comma separated lists of numbers).   */\n+\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_limited_str = (unsigned char *) (STR);\t\\\n+      register unsigned ch;\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n+      for (; ch = *_limited_str; _limited_str++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register int escape;\t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      register int escape;\t\t\t\t\t\\\n+\t      register unsigned ch;\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\t\\\n+\t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\tcase 0:\t\t\t\t\t\t\t\\\n+\t\t  putc (ch, (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk++;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tcase 1:\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\\\n+\t\t  bytes_in_chunk += 4;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tdefault:\t\t\t\t\t\t\\\n+\t\t  putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t\t  putc (escape, (FILE));\t\t\t\t\\\n+\t\t  bytes_in_chunk += 2;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* All SVR4 targets use the ELF object file format.  */\n+#define OBJECT_FORMAT_ELF"}]}