{"sha": "3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2ZGNiN2Y4YmM5NzdlMThkMjBiZDE3YTFiNGJhMmY4OGQ2ZWVlYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-06T14:04:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-06T14:04:11Z"}, "message": "tree-ssa-operands.c (clobbered_v_may_defs, [...]): Use VEC instead of VARRAY.\n\n\t* tree-ssa-operands.c (clobbered_v_may_defs, clobbered_vuses,\n\tro_call_vuse, fini_ssa_operands, add_call_clobber_ops,\n\tadd_call_read_ops): Use VEC instead of VARRAY.\n\nFrom-SVN: r99316", "tree": {"sha": "12579039218fdf1dc37a20c4984e5b12b0cae294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12579039218fdf1dc37a20c4984e5b12b0cae294"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea/comments", "author": null, "committer": null, "parents": [{"sha": "6e1f65b5446d38f86db908b071d4b953f5c7d7da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1f65b5446d38f86db908b071d4b953f5c7d7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1f65b5446d38f86db908b071d4b953f5c7d7da"}], "stats": {"total": 73, "additions": 30, "deletions": 43}, "files": [{"sha": "cca08f2c2289dca1d3d5e7509ce518e4db8878bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea", "patch": "@@ -1,3 +1,9 @@\n+2005-05-06  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-operands.c (clobbered_v_may_defs, clobbered_vuses,\n+\tro_call_vuse, fini_ssa_operands, add_call_clobber_ops,\n+\tadd_call_read_ops): Use VEC instead of VARRAY.\n+\n 2005-05-06  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/mcore/mcore.c (mcore_print_operand_address): Use"}, {"sha": "ccc2033dbc0daf880642267bd7ca7d7460f114aa", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=3d6dcb7f8bc977e18d20bd17a1b4ba2f88d6eeea", "patch": "@@ -133,9 +133,9 @@ bool ssa_call_clobbered_cache_valid;\n bool ssa_ro_call_cache_valid;\n \n /* These arrays are the cached operand vectors for call clobbered calls.  */\n-static GTY (()) varray_type clobbered_v_may_defs;\n-static GTY (()) varray_type clobbered_vuses;\n-static GTY (()) varray_type ro_call_vuses;\n+static VEC(tree,heap) *clobbered_v_may_defs;\n+static VEC(tree,heap) *clobbered_vuses;\n+static VEC(tree,heap) *ro_call_vuses;\n static bool clobbered_aliased_loads;\n static bool clobbered_aliased_stores;\n static bool ro_call_aliased_loads;\n@@ -428,18 +428,9 @@ fini_ssa_operands (void)\n       ggc_free (ptr);\n     }\n \n-  if (clobbered_v_may_defs)\n-    {\n-      ggc_free (clobbered_v_may_defs);\n-      ggc_free (clobbered_vuses);\n-      clobbered_v_may_defs = NULL;\n-      clobbered_vuses = NULL;\n-    }\n-  if (ro_call_vuses)\n-    {\n-      ggc_free (ro_call_vuses);\n-      ro_call_vuses = NULL;\n-    }\n+  VEC_free (tree, heap, clobbered_v_may_defs);\n+  VEC_free (tree, heap, clobbered_vuses);\n+  VEC_free (tree, heap, ro_call_vuses);\n   ops_active = false;\n }\n \n@@ -1975,16 +1966,16 @@ add_call_clobber_ops (tree stmt)\n     {\n       /* Process the caches in reverse order so we are always inserting at\n          the head of the list.  */\n-      for (i = VARRAY_ACTIVE_SIZE (clobbered_vuses) - 1; i >=0; i--)\n+      for (i = VEC_length (tree, clobbered_vuses) - 1; i >=0; i--)\n \t{\n-\t  t = VARRAY_TREE (clobbered_vuses, i);\n+\t  t = VEC_index (tree, clobbered_vuses, i);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_vuse_list = 1;\n \t  opbuild_append_virtual (&build_vuses, t);\n \t}\n-      for (i = VARRAY_ACTIVE_SIZE (clobbered_v_may_defs) - 1; i >= 0; i--)\n+      for (i = VEC_length (tree, clobbered_v_may_defs) - 1; i >= 0; i--)\n \t{\n-\t  t = VARRAY_TREE (clobbered_v_may_defs, i);\n+\t  t = VEC_index (tree, clobbered_v_may_defs, i);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_v_may_def_list = 1;\n \t  opbuild_append_virtual (&build_v_may_defs, t);\n@@ -2020,34 +2011,27 @@ add_call_clobber_ops (tree stmt)\n     }\n \n   /* Prepare empty cache vectors.  */\n-  if (clobbered_v_may_defs)\n-    {\n-      VARRAY_POP_ALL (clobbered_vuses);\n-      VARRAY_POP_ALL (clobbered_v_may_defs);\n-    }\n-  else\n-    {\n-      VARRAY_TREE_INIT (clobbered_v_may_defs, 10, \"clobbered_v_may_defs\");\n-      VARRAY_TREE_INIT (clobbered_vuses, 10, \"clobbered_vuses\");\n-    }\n+  VEC_truncate (tree, clobbered_vuses, 0);\n+  VEC_truncate (tree, clobbered_v_may_defs, 0);\n \n   /* Now fill the clobbered cache with the values that have been found.  */\n   for (i = opbuild_first (&build_vuses);\n        i != OPBUILD_LAST;\n        i = opbuild_next (&build_vuses, i))\n-    VARRAY_PUSH_TREE (clobbered_vuses, opbuild_elem_virtual (&build_vuses, i));\n+    VEC_safe_push (tree, heap, clobbered_vuses,\n+\t\t   opbuild_elem_virtual (&build_vuses, i));\n \n   gcc_assert (opbuild_num_elems (&build_vuses) \n-\t      == VARRAY_ACTIVE_SIZE (clobbered_vuses));\n+\t      == VEC_length (tree, clobbered_vuses));\n \n   for (i = opbuild_first (&build_v_may_defs);\n        i != OPBUILD_LAST;\n        i = opbuild_next (&build_v_may_defs, i))\n-    VARRAY_PUSH_TREE (clobbered_v_may_defs, \n-\t\t      opbuild_elem_virtual (&build_v_may_defs, i));\n+    VEC_safe_push (tree, heap, clobbered_v_may_defs, \n+\t\t   opbuild_elem_virtual (&build_v_may_defs, i));\n \n   gcc_assert (opbuild_num_elems (&build_v_may_defs) \n-\t      == VARRAY_ACTIVE_SIZE (clobbered_v_may_defs));\n+\t      == VEC_length (tree, clobbered_v_may_defs));\n \n   ssa_call_clobbered_cache_valid = true;\n }\n@@ -2078,11 +2062,11 @@ add_call_read_ops (tree stmt)\n   /* If cache is valid, copy the elements into the build vector.  */\n   if (ssa_ro_call_cache_valid)\n     {\n-      for (i = VARRAY_ACTIVE_SIZE (ro_call_vuses) - 1; i >=0 ; i--)\n+      for (i = VEC_length (tree, ro_call_vuses) - 1; i >=0 ; i--)\n \t{\n \t  /* Process the caches in reverse order so we are always inserting at\n \t     the head of the list.  */\n-\t  t = VARRAY_TREE (ro_call_vuses, i);\n+\t  t = VEC_index (tree, ro_call_vuses, i);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_vuse_list = 1;\n \t  opbuild_append_virtual (&build_vuses, t);\n@@ -2106,20 +2090,17 @@ add_call_read_ops (tree stmt)\n     s_ann->makes_aliased_loads = empty_ann.makes_aliased_loads;\n \n   /* Prepare empty cache vectors.  */\n-  if (ro_call_vuses)\n-    VARRAY_POP_ALL (ro_call_vuses);\n-  else\n-    VARRAY_TREE_INIT (ro_call_vuses, 10, \"ro_call_vuses\");\n-\n+  VEC_truncate (tree, ro_call_vuses, 0);\n \n   /* Now fill the clobbered cache with the values that have been found.  */\n   for (i = opbuild_first (&build_vuses);\n        i != OPBUILD_LAST;\n        i = opbuild_next (&build_vuses, i))\n-    VARRAY_PUSH_TREE (ro_call_vuses, opbuild_elem_virtual (&build_vuses, i));\n+    VEC_safe_push (tree, heap, ro_call_vuses,\n+\t\t   opbuild_elem_virtual (&build_vuses, i));\n \n   gcc_assert (opbuild_num_elems (&build_vuses) \n-\t      == VARRAY_ACTIVE_SIZE (ro_call_vuses));\n+\t      == VEC_length (tree, ro_call_vuses));\n \n   ssa_ro_call_cache_valid = true;\n }"}]}