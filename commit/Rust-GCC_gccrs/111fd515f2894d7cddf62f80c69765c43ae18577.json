{"sha": "111fd515f2894d7cddf62f80c69765c43ae18577", "node_id": "C_kwDOANBUbNoAKDExMWZkNTE1ZjI4OTRkN2NkZGY2MmY4MGM2OTc2NWM0M2FlMTg1Nzc", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-16T15:36:49Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-17T02:01:14Z"}, "message": "analyzer: fix missing -Wanalyzer-write-to-const [PR102695]\n\nThis patch fixes -Wanalyzer-write-to-const so that it will complain\nabout attempts to write to functions, to labels.\nIt also \"teaches\" the analyzer about strchr, in that strchr can either\nreturn a pointer into the input area (and thus -Wanalyzer-write-to-const\ncan now complain about writes into a string literal seen this way),\nor return NULL (and thus the analyzer can complain about NULL\ndereferences if the result is used without a check).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/102695\n\t* region-model-impl-calls.cc (region_model::impl_call_strchr): New.\n\t* region-model-manager.cc\n\t(region_model_manager::maybe_fold_unaryop): Simplify cast to\n\tpointer type of an existing pointer to a region.\n\t* region-model.cc (region_model::on_call_pre): Handle\n\tBUILT_IN_STRCHR and \"strchr\".\n\t(write_to_const_diagnostic::emit): Add auto_diagnostic_group.  Add\n\talternate wordings for functions and labels.\n\t(write_to_const_diagnostic::describe_final_event): Add alternate\n\twordings for functions and labels.\n\t(region_model::check_for_writable_region): Handle RK_FUNCTION and\n\tRK_LABEL.\n\t* region-model.h (region_model::impl_call_strchr): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/102695\n\t* gcc.dg/analyzer/pr102695.c: New test.\n\t* gcc.dg/analyzer/strchr-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "525f35425a21be411304a53e4904071ebec2fe50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/525f35425a21be411304a53e4904071ebec2fe50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/111fd515f2894d7cddf62f80c69765c43ae18577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111fd515f2894d7cddf62f80c69765c43ae18577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111fd515f2894d7cddf62f80c69765c43ae18577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111fd515f2894d7cddf62f80c69765c43ae18577/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a80d4e098b10d5cd161f55e4fce64a6be9683ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80d4e098b10d5cd161f55e4fce64a6be9683ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a80d4e098b10d5cd161f55e4fce64a6be9683ed3"}], "stats": {"total": 199, "additions": 196, "deletions": 3}, "files": [{"sha": "ae50e69542edb503292675837e756992ab8ef2b8", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=111fd515f2894d7cddf62f80c69765c43ae18577", "patch": "@@ -678,6 +678,75 @@ region_model::impl_call_realloc (const call_details &cd)\n     }\n }\n \n+/* Handle the on_call_pre part of \"strchr\" and \"__builtin_strchr\".  */\n+\n+void\n+region_model::impl_call_strchr (const call_details &cd)\n+{\n+  class strchr_call_info : public call_info\n+  {\n+  public:\n+    strchr_call_info (const call_details &cd, bool found)\n+    : call_info (cd), m_found (found)\n+    {\n+    }\n+\n+    label_text get_desc (bool can_colorize) const FINAL OVERRIDE\n+    {\n+      if (m_found)\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"when %qE returns non-NULL\",\n+\t\t\t\tget_fndecl ());\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"when %qE returns NULL\",\n+\t\t\t\tget_fndecl ());\n+    }\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const FINAL OVERRIDE\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+      if (tree lhs_type = cd.get_lhs_type ())\n+\t{\n+\t  region_model_manager *mgr = model->get_manager ();\n+\t  const svalue *result;\n+\t  if (m_found)\n+\t    {\n+\t      const svalue *str_sval = cd.get_arg_svalue (0);\n+\t      const region *str_reg\n+\t\t= model->deref_rvalue (str_sval, cd.get_arg_tree (0),\n+\t\t\t\t       cd.get_ctxt ());\n+\t      /* We want str_sval + OFFSET for some unknown OFFSET.\n+\t\t Use a conjured_svalue to represent the offset,\n+\t\t using the str_reg as the id of the conjured_svalue.  */\n+\t      const svalue *offset\n+\t\t= mgr->get_or_create_conjured_svalue (size_type_node,\n+\t\t\t\t\t\t      cd.get_call_stmt (),\n+\t\t\t\t\t\t      str_reg);\n+\t      result = mgr->get_or_create_binop (lhs_type, POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t str_sval, offset);\n+\t    }\n+\t  else\n+\t    result = mgr->get_or_create_int_cst (lhs_type, 0);\n+\t  cd.maybe_set_lhs (result);\n+\t}\n+      return true;\n+    }\n+  private:\n+    bool m_found;\n+  };\n+\n+  /* Bifurcate state, creating a \"not found\" out-edge.  */\n+  if (cd.get_ctxt ())\n+    cd.get_ctxt ()->bifurcate (new strchr_call_info (cd, false));\n+\n+  /* The \"unbifurcated\" state is the \"found\" case.  */\n+  strchr_call_info found (cd, true);\n+  found.update_model (this, NULL, cd.get_ctxt ());\n+}\n+\n /* Handle the on_call_pre part of \"strcpy\" and \"__builtin_strcpy_chk\".  */\n \n void"}, {"sha": "fdf32122deae926db8b255e2048fcb0e2e7f632d", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=111fd515f2894d7cddf62f80c69765c43ae18577", "patch": "@@ -380,6 +380,13 @@ region_model_manager::maybe_fold_unaryop (tree type, enum tree_code op,\n \t\t    == boolean_true_node))\n \t      return maybe_fold_unaryop (type, op, innermost_arg);\n \t  }\n+\t/* Avoid creating symbolic regions for pointer casts by\n+\t   simplifying (T*)(&REGION) to ((T*)&REGION).  */\n+\tif (const region_svalue *region_sval = arg->dyn_cast_region_svalue ())\n+\t  if (POINTER_TYPE_P (type)\n+\t      && region_sval->get_type ()\n+\t      && POINTER_TYPE_P (region_sval->get_type ()))\n+\t    return get_ptr_svalue (type, region_sval->get_pointee ());\n       }\n       break;\n     case TRUTH_NOT_EXPR:"}, {"sha": "bbb15abdfe2223105a0ffb2fd3cfabcfd3483777", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=111fd515f2894d7cddf62f80c69765c43ae18577", "patch": "@@ -1133,6 +1133,9 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t    break;\n \t  case BUILT_IN_REALLOC:\n \t    return false;\n+\t  case BUILT_IN_STRCHR:\n+\t    impl_call_strchr (cd);\n+\t    return false;\n \t  case BUILT_IN_STRCPY:\n \t  case BUILT_IN_STRCPY_CHK:\n \t    impl_call_strcpy (cd);\n@@ -1225,6 +1228,12 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_memset (cd);\n \t  return false;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"strchr\", call, 2)\n+\t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n+\t{\n+\t  impl_call_strchr (cd);\n+\t  return false;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"strlen\", call, 1)\n \t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n \t{\n@@ -2161,16 +2170,39 @@ class write_to_const_diagnostic\n \n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    bool warned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n-\t\t\t      \"write to %<const%> object %qE\", m_decl);\n+    auto_diagnostic_group d;\n+    bool warned;\n+    switch (m_reg->get_kind ())\n+      {\n+      default:\n+\twarned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n+\t\t\t     \"write to %<const%> object %qE\", m_decl);\n+\tbreak;\n+      case RK_FUNCTION:\n+\twarned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n+\t\t\t     \"write to function %qE\", m_decl);\n+\tbreak;\n+      case RK_LABEL:\n+\twarned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n+\t\t\t     \"write to label %qE\", m_decl);\n+\tbreak;\n+      }\n     if (warned)\n       inform (DECL_SOURCE_LOCATION (m_decl), \"declared here\");\n     return warned;\n   }\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n-    return ev.formatted_print (\"write to %<const%> object %qE here\", m_decl);\n+    switch (m_reg->get_kind ())\n+      {\n+      default:\n+\treturn ev.formatted_print (\"write to %<const%> object %qE here\", m_decl);\n+      case RK_FUNCTION:\n+\treturn ev.formatted_print (\"write to function %qE here\", m_decl);\n+      case RK_LABEL:\n+\treturn ev.formatted_print (\"write to label %qE here\", m_decl);\n+      }\n   }\n \n private:\n@@ -2231,6 +2263,20 @@ region_model::check_for_writable_region (const region* dest_reg,\n     {\n     default:\n       break;\n+    case RK_FUNCTION:\n+      {\n+\tconst function_region *func_reg = as_a <const function_region *> (base_reg);\n+\ttree fndecl = func_reg->get_fndecl ();\n+\tctxt->warn (new write_to_const_diagnostic (func_reg, fndecl));\n+      }\n+      break;\n+    case RK_LABEL:\n+      {\n+\tconst label_region *label_reg = as_a <const label_region *> (base_reg);\n+\ttree label = label_reg->get_label ();\n+\tctxt->warn (new write_to_const_diagnostic (label_reg, label));\n+      }\n+      break;\n     case RK_DECL:\n       {\n \tconst decl_region *decl_reg = as_a <const decl_region *> (base_reg);"}, {"sha": "543401167ae8e9113017046a6179d8b5edd2f6d1", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=111fd515f2894d7cddf62f80c69765c43ae18577", "patch": "@@ -586,6 +586,7 @@ class region_model\n   void impl_call_memcpy (const call_details &cd);\n   void impl_call_memset (const call_details &cd);\n   void impl_call_realloc (const call_details &cd);\n+  void impl_call_strchr (const call_details &cd);\n   void impl_call_strcpy (const call_details &cd);\n   void impl_call_strlen (const call_details &cd);\n   void impl_call_operator_new (const call_details &cd);"}, {"sha": "2ca988254fef7568e7ecc9999c4300aadbaf1b73", "filename": "gcc/testsuite/gcc.dg/analyzer/pr102695.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr102695.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr102695.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr102695.c?ref=111fd515f2894d7cddf62f80c69765c43ae18577", "patch": "@@ -0,0 +1,44 @@\n+extern void* malloc (__SIZE_TYPE__);\n+\n+const char* write_strchr_literal (int x)\n+{\n+  char *p = __builtin_strchr (\"123\", x); \n+  *p = 0; /* { dg-warning \"dereference of NULL 'p'\" \"null deref\" } */\n+  /* { dg-warning \"write to string literal\" \"string literal\" { target *-*-* } .-1 } */  \n+  return p;\n+}\n+\n+const char* write_strchr_const_array (int x)\n+{\n+  static const char a[] = \"123\";\n+  char *p = __builtin_strchr (a, x);\n+  *p = 0; /* { dg-warning \"dereference of NULL 'p'\" \"null deref\" } */\n+  /* { dg-warning \"write to 'const' object 'a'\" \"write to const\" { target *-*-* } .-1 } */  \n+  return a;\n+}\n+\n+char* write_function (void)\n+{\n+  char *p = (char*)malloc /* forgot arguments */;\n+  p[1] = 'a'; /* { dg-warning \"write to function 'malloc'\" } */\n+  __builtin_strcpy (p, \"123\");  /* { dg-warning \"write to function 'malloc'\" } */\n+  return p;\n+}\n+\n+char* write_label (void)\n+{\n+  char *p = (char*)&&L;\n+  *p = 0; /* { dg-warning \"write to label 'L'\" } */\n+L:\n+  return p;\n+}\n+\n+struct A { const int i; };\n+\n+extern /* not const */ struct A a;\n+\n+void write_const_member (void)\n+{\n+  char *p = (char*)&a.i;\n+  *p = 0;   // missing warning\n+}"}, {"sha": "dfe1bc9ea1a0bd16cce839a766848978d1301e38", "filename": "gcc/testsuite/gcc.dg/analyzer/strchr-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstrchr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/111fd515f2894d7cddf62f80c69765c43ae18577/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstrchr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstrchr-1.c?ref=111fd515f2894d7cddf62f80c69765c43ae18577", "patch": "@@ -0,0 +1,26 @@\n+#include <string.h>\n+#include \"analyzer-decls.h\"\n+\n+const char* test_literal (int x)\n+{\n+  char *p = __builtin_strchr (\"123\", x);\n+  if (p)\n+    {\n+      __analyzer_eval (*p == x); /* { dg-message \"UNKNOWN\" } */\n+      /* TODO: this ought to be TRUE, but it's unclear that it's\n+\t worth stashing this constraint.  */\n+    }\n+  return p;\n+}\n+\n+void test_2 (const char *s, int c)\n+{\n+  char *p = __builtin_strchr (s, c); /* { dg-message \"when '__builtin_strchr' returns NULL\"} */\n+  *p = 'A'; /* { dg-warning \"dereference of NULL 'p'\" \"null deref\" } */\n+}\n+\n+void test_3 (const char *s, int c)\n+{\n+  char *p = strchr (s, c); /* { dg-message \"when 'strchr' returns NULL\"} */\n+  *p = 'A'; /* { dg-warning \"dereference of NULL 'p'\" \"null deref\" } */\n+}"}]}