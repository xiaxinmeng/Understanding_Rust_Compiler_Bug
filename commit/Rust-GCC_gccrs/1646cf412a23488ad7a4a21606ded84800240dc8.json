{"sha": "1646cf412a23488ad7a4a21606ded84800240dc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY0NmNmNDEyYTIzNDg4YWQ3YTRhMjE2MDZkZWQ4NDgwMDI0MGRjOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-11-27T16:29:52Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-11-27T16:29:52Z"}, "message": "ChangeLog\n\nFrom-SVN: r37798", "tree": {"sha": "f6c31584587ada163960a879ddadcb3092ef5a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6c31584587ada163960a879ddadcb3092ef5a4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1646cf412a23488ad7a4a21606ded84800240dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1646cf412a23488ad7a4a21606ded84800240dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1646cf412a23488ad7a4a21606ded84800240dc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1646cf412a23488ad7a4a21606ded84800240dc8/comments", "author": null, "committer": null, "parents": [{"sha": "4211a8fbc353ffb79e81ace5ed2f67cfd2002dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4211a8fbc353ffb79e81ace5ed2f67cfd2002dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4211a8fbc353ffb79e81ace5ed2f67cfd2002dcb"}], "stats": {"total": 155, "additions": 115, "deletions": 40}, "files": [{"sha": "5fc13defe9840663c6310706d1cb93a9bf2538ae", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1646cf412a23488ad7a4a21606ded84800240dc8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1646cf412a23488ad7a4a21606ded84800240dc8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1646cf412a23488ad7a4a21606ded84800240dc8", "patch": "@@ -4126,6 +4126,13 @@ arm_gen_rotated_half_load (memref)\n   return gen_rtx_ROTATE (SImode, base, GEN_INT (16));\n }\n \n+/* Select a dominance comparison mode if possible.  We support three forms.\n+   COND_OR == 0 => (X && Y) \n+   COND_OR == 1 => ((! X( || Y)\n+   COND_OR == 2 => (X || Y) \n+   If we are unable to support a dominance comparsison we return CC mode.  \n+   This will then fail to match for the RTL expressions that generate this\n+   call.  */\n static enum machine_mode\n select_dominance_cc_mode (x, y, cond_or)\n      rtx x;\n@@ -4144,7 +4151,10 @@ select_dominance_cc_mode (x, y, cond_or)\n \t  != CCmode))\n     return CCmode;\n \n-  if (cond_or)\n+  /* The if_then_else variant of this tests the second condition if the\n+     first passes, but is true if the first fails.  Reverse the first\n+     condition to get a true \"inclusive-or\" expression.  */\n+  if (cond_or == 1)\n     cond1 = reverse_condition (cond1);\n \n   /* If the comparisons are not equal, and one doesn't dominate the other,\n@@ -4296,6 +4306,29 @@ arm_select_cc_mode (op, x, y)\n       && GET_CODE (y) == CONST_INT)\n     return CC_Zmode;\n \n+  /* A construct for a conditional compare, if the false arm contains\n+     0, then both conditions must be true, otherwise either condition\n+     must be true.  Not all conditions are possible, so CCmode is\n+     returned if it can't be done.  */\n+  if (GET_CODE (x) == IF_THEN_ELSE\n+      && (XEXP (x, 2) == const0_rtx\n+\t  || XEXP (x, 2) == const1_rtx)\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), \n+\t\t\t\t     INTVAL (XEXP (x, 2)));\n+\n+  /* Alternate canonicalizations of the above.  These are somewhat cleaner.  */\n+  if (GET_CODE (x) == AND\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), 0);\n+\n+  if (GET_CODE (x) == IOR\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), 2);\n+\n   /* An operation that sets the condition codes as a side-effect, the\n      V flag is not set correctly, so we can only use comparisons where\n      this doesn't matter.  (For LT and GE we can use \"mi\" and \"pl\"\n@@ -4312,18 +4345,6 @@ arm_select_cc_mode (op, x, y)\n \t  || GET_CODE (x) == ROTATERT || GET_CODE (x) == ZERO_EXTRACT))\n     return CC_NOOVmode;\n \n-  /* A construct for a conditional compare, if the false arm contains\n-     0, then both conditions must be true, otherwise either condition\n-     must be true.  Not all conditions are possible, so CCmode is\n-     returned if it can't be done.  */\n-  if (GET_CODE (x) == IF_THEN_ELSE\n-      && (XEXP (x, 2) == const0_rtx\n-\t  || XEXP (x, 2) == const1_rtx)\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n-    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), \n-\t\t\t\t     INTVAL (XEXP (x, 2)));\n-\n   if (GET_MODE (x) == QImode && (op == EQ || op == NE))\n     return CC_Zmode;\n "}, {"sha": "15c2cd9df6f0f29fb6208f0646dbdf296c736848", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 81, "deletions": 27, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1646cf412a23488ad7a4a21606ded84800240dc8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1646cf412a23488ad7a4a21606ded84800240dc8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=1646cf412a23488ad7a4a21606ded84800240dc8", "patch": "@@ -7130,6 +7130,76 @@\n    (set_attr \"length\" \"8\")]\n )\n \n+(define_insn \"*cmp_and\"\n+  [(set (match_operand 6 \"dominant_cc_register\" \"\")\n+\t(compare\n+\t (and:SI\n+\t  (match_operator 4 \"arm_comparison_operator\"\n+\t   [(match_operand:SI 0 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 1 \"arm_add_operand\" \"rI,L,rI,L\")])\n+\t  (match_operator:SI 5 \"arm_comparison_operator\"\n+\t   [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 3 \"arm_add_operand\" \"rI,rI,L,L\")]))\n+\t (const_int 0)))]\n+  \"TARGET_ARM\"\n+  \"*\n+  {\n+    const char * opcodes[4][2] =\n+    {\n+      {\\\"cmp\\\\t%2, %3\\;cmp%d5\\\\t%0, %1\\\",\n+       \\\"cmp\\\\t%0, %1\\;cmp%d4\\\\t%2, %3\\\"},\n+      {\\\"cmp\\\\t%2, %3\\;cmn%d5\\\\t%0, #%n1\\\",\n+       \\\"cmn\\\\t%0, #%n1\\;cmp%d4\\\\t%2, %3\\\"},\n+      {\\\"cmn\\\\t%2, #%n3\\;cmp%d5\\\\t%0, %1\\\",\n+       \\\"cmp\\\\t%0, %1\\;cmn%d4\\\\t%2, #%n3\\\"},\n+      {\\\"cmn\\\\t%2, #%n3\\;cmn%d5\\\\t%0, #%n1\\\",\n+       \\\"cmn\\\\t%0, #%n1\\;cmn%d4\\\\t%2, #%n3\\\"}\n+    };\n+    int swap =\n+      comparison_dominates_p (GET_CODE (operands[5]), GET_CODE (operands[4]));\n+\n+    return opcodes[which_alternative][swap];\n+  }\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"predicable\" \"no\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n+(define_insn \"*cmp_ior\"\n+  [(set (match_operand 6 \"dominant_cc_register\" \"\")\n+\t(compare\n+\t (ior:SI\n+\t  (match_operator 4 \"arm_comparison_operator\"\n+\t   [(match_operand:SI 0 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 1 \"arm_add_operand\" \"rI,L,rI,L\")])\n+\t  (match_operator:SI 5 \"arm_comparison_operator\"\n+\t   [(match_operand:SI 2 \"s_register_operand\" \"r,r,r,r\")\n+\t    (match_operand:SI 3 \"arm_add_operand\" \"rI,rI,L,L\")]))\n+\t (const_int 0)))]\n+  \"TARGET_ARM\"\n+  \"*\n+{\n+  const char * opcodes[4][2] =\n+  {\n+    {\\\"cmp\\\\t%0, %1\\;cmp%D4\\\\t%2, %3\\\",\n+     \\\"cmp\\\\t%2, %3\\;cmp%D5\\\\t%0, %1\\\"},\n+    {\\\"cmn\\\\t%0, #%n1\\;cmp%D4\\\\t%2, %3\\\",\n+     \\\"cmp\\\\t%2, %3\\;cmn%D5\\\\t%0, #%n1\\\"},\n+    {\\\"cmp\\\\t%0, %1\\;cmn%D4\\\\t%2, #%n3\\\",\n+     \\\"cmn\\\\t%2, #%n3\\;cmp%D5\\\\t%0, %1\\\"},\n+    {\\\"cmn\\\\t%0, #%n1\\;cmn%D4\\\\t%2, #%n3\\\",\n+     \\\"cmn\\\\t%2, #%n3\\;cmn%D5\\\\t%0, #%n1\\\"}\n+  };\n+  int swap =\n+    comparison_dominates_p (GET_CODE (operands[5]), GET_CODE (operands[4]));\n+\n+  return opcodes[which_alternative][swap];\n+}\n+\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n (define_insn \"*negscc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(neg:SI (match_operator 3 \"arm_comparison_operator\"\n@@ -8595,29 +8665,6 @@\n   }\"\n )\n \n-(define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(if_then_else:SI (match_operator 1 \"arm_comparison_operator\"\n-\t\t\t  [(match_operand 2 \"\" \"\") (match_operand 3 \"\" \"\")])\n-\t\t\t (match_operand 4 \"\" \"\")\n-\t\t\t (match_operand 5 \"\" \"\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed && 0\"\n-  [(set (match_dup 6) (match_dup 7))\n-   (set (match_dup 0) \n-\t(if_then_else:SI (match_op_dup 1 [(match_dup 6) (const_int 0)])\n-\t\t\t (match_dup 4)\n-\t\t\t (match_dup 5)))]\n-  \"\n-  {\n-    enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n-\t\t\t\t\t     operands[2], operands[3]);\n-\n-    operands[6] = gen_rtx_REG (mode, CC_REGNUM);\n-    operands[7] = gen_rtx_COMPARE (mode, operands[2], operands[3]);\n-  }\"\n-)\n-\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(if_then_else:SI (match_operator 1 \"arm_comparison_operator\"\n@@ -8629,17 +8676,24 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ARM && reload_completed\"\n   [(set (match_dup 6) (match_dup 7))\n-   (set (match_dup 0) \n-\t(if_then_else:SI (match_op_dup 1 [(match_dup 6) (const_int 0)])\n-\t\t\t (match_dup 4)\n-\t\t\t (not:SI (match_dup 5))))]\n+   (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])\n+\t      (set (match_dup 0) (match_dup 4)))\n+   (cond_exec (match_dup 8)\n+\t      (set (match_dup 0) (not:SI (match_dup 5))))]\n   \"\n   {\n     enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n \t\t\t\t\t     operands[2], operands[3]);\n+    enum rtx_code rc = GET_CODE (operands[1]);\n \n     operands[6] = gen_rtx_REG (mode, CC_REGNUM);\n     operands[7] = gen_rtx (COMPARE, mode, operands[2], operands[3]);\n+    if (mode == CCFPmode || mode == CCFPEmode)\n+      rc = reverse_condition_maybe_unordered (rc);\n+    else\n+      rc = reverse_condition (rc);\n+\n+    operands[8] = gen_rtx_fmt_ee (rc, VOIDmode, operands[6], const0_rtx);\n   }\"\n )\n "}]}