{"sha": "f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAyYjhiYjg3N2Y0ZTEwMDBjOTJkZjY3YjRhOGI1YjFlZmMyNjNiZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-11-15T13:51:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:51:09Z"}, "message": "re PR ada/18434 (Ada: cannot build gnattools on Tru64 UNIX V5.1B)\n\n2005-11-14  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\tPR ada/18434\n\n\t* types.ads: Include All_Checks in Suppress_Array\n\n\t* checks.adb (Check_Needed): Remove kludge for a/=b rewritten as\n\tnot(a=b), since we no longer do this rewriting, and hence it is not\n\tneeded.\n\t(Elaboration_Checks_Suppressed): Add special casing to\n\tdeal with different cases of static and dynamic elaboration checks (all\n\tchecks does not count in the first case, but does in the second).\n\t(Expr_Known_Valid): Do not assume that the result of any arbitrary\n\tfunction call is valid, since this is not the case.\n\t(Ensure_Valid): Do not apply validity check to a real literal\n\tin a universal or fixed context\n\n\t* exp_ch4.adb (Expand_N_Op_Ne): Don't expand a/=b to not(a=b) for\n\telementary types using the operator in standard. It is cleaner not to\n\tmodify the programmers intent, especially in the case of floating-point.\n\t(Rewrite_Comparison): Fix handling of /= (this was always wrong, but\n\tit did not matter because we always rewrote a/=b to not(a=b).\n\t(Expand_Allocator_Expression): For an allocator expression whose nominal\n\tsubtype is an unconstrained packed type, convert the expression to its\n\tactual constrained subtype.\n\tImplement warning for <= or >= where < or > not possible\n\tFix to Vax_Float tests (too early in many routines, causing premature\n\tVax_Float expansions.\n\n\t* sem_prag.adb (Analyze_Pragma, case Obsolescent): Allow this pragma\n\tto be used with packages and generic packages as well as with\n\tsubprograms.\n\t(Suppress): Set All_Checks, but not Elaboration_Check, for case\n\tof pragma Suppress (All_Checks)\n\t(Analyze_Pragma, case Warnings): Implement first argument allowed to be\n\ta string literal for precise control over warnings.\n\tAvoid raise of pragma in case of unrecognized pragma and just return\n\tinstead.\n\n\t* sem_prag.ads: Minor reformatting\n\n\t* switch-c.adb (Scan_Front_End_Switches): Replace \"raise Bad_Switch;\"\n\twith call to new procedure Bad_Switch. Call Scan_Pos with new parameter\n\tSwitch. Do not handle any exception.\n\tInclude -gnatwx as part of -gnatg (warn on redundant parens)\n\tAllow optional = after -gnatm\n\t(Scan_Front_End_Switches): The -gnatp switch sets All_Checks, but no\n\tlonger sets Elaboration_Checks.\n\tCode to set warning mode moved to Sem_Warn\n\tso that it can be shared by pragma processing.\n\n\t* s-mastop-tru64.adb (Pop_Frame): Remove redundant parentheses in if\n\tstatement.\n\n\t* s-taprop-solaris.adb: \n\tChange some <= to =, to avoid new warning\n\n\t* a-exexda.adb, prj-proc.adb: \n\tFix obvious typo (Num_Tracebacks compared <= 0 instead of < 0)\n\tFix obvious typo (Total_Errors_Detected <= 0 should be = 0)\n\nFrom-SVN: r106950", "tree": {"sha": "0efbfab4fb3d55403546ebeaa30ac64cbc05ef81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0efbfab4fb3d55403546ebeaa30ac64cbc05ef81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/comments", "author": null, "committer": null, "parents": [{"sha": "3e1fd98f3dcc4c06007d1dfbe9fc913e0032a38c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e1fd98f3dcc4c06007d1dfbe9fc913e0032a38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e1fd98f3dcc4c06007d1dfbe9fc913e0032a38c"}], "stats": {"total": 914, "additions": 475, "deletions": 439}, "files": [{"sha": "6b3b802d117743ae4c48f01d33bc2c9b33551550", "filename": "gcc/ada/a-exexda.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fa-exexda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fa-exexda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexda.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -386,7 +386,7 @@ package body Exception_Data is\n       Ptr  : in out Natural)\n    is\n    begin\n-      if X.Num_Tracebacks <= 0 then\n+      if X.Num_Tracebacks = 0 then\n          return;\n       end if;\n "}, {"sha": "d53dcc07d8f609394de469b3fe4250fb2acee0d7", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2481,13 +2481,11 @@ package body Checks is\n             exit when N = Right_Opnd (P)\n               and then Nkind (Left_Opnd (P)) = N_Op_Eq;\n \n-         --  And/And then case, left operand must be inequality test. Note that\n-         --  at this stage, the expander will have changed a/=b to not (a=b).\n+         --  And/And then case, left operand must be inequality test\n \n          elsif K = N_Op_And or else K = N_And_Then then\n             exit when N = Right_Opnd (P)\n-              and then Nkind (Left_Opnd (P)) = N_Op_Not\n-              and then Nkind (Right_Opnd (Left_Opnd (P))) = N_Op_Eq;\n+              and then Nkind (Left_Opnd (P)) = N_Op_Ne;\n          end if;\n \n          N := P;\n@@ -3259,15 +3257,32 @@ package body Checks is\n \n    function Elaboration_Checks_Suppressed (E : Entity_Id) return Boolean is\n    begin\n+      --  The complication in this routine is that if we are in the dynamic\n+      --  model of elaboration, we also check All_Checks, since All_Checks\n+      --  does not set Elaboration_Check explicitly.\n+\n       if Present (E) then\n          if Kill_Elaboration_Checks (E) then\n             return True;\n+\n          elsif Checks_May_Be_Suppressed (E) then\n-            return Is_Check_Suppressed (E, Elaboration_Check);\n+            if Is_Check_Suppressed (E, Elaboration_Check) then\n+               return True;\n+            elsif Dynamic_Elaboration_Checks then\n+               return Is_Check_Suppressed (E, All_Checks);\n+            else\n+               return False;\n+            end if;\n          end if;\n       end if;\n \n-      return Scope_Suppress (Elaboration_Check);\n+      if Scope_Suppress (Elaboration_Check) then\n+         return True;\n+      elsif Dynamic_Elaboration_Checks then\n+         return Scope_Suppress (All_Checks);\n+      else\n+         return False;\n+      end if;\n    end Elaboration_Checks_Suppressed;\n \n    ---------------------------\n@@ -3690,6 +3705,15 @@ package body Checks is\n       then\n          return;\n \n+      --  No check on a univeral real constant. The context will eventually\n+      --  convert it to a machine number for some target type, or report an\n+      --  illegality.\n+\n+      elsif Nkind (Expr) = N_Real_Literal\n+        and then Etype (Expr) = Universal_Real\n+      then\n+         return;\n+\n       --  An annoying special case. If this is an out parameter of a scalar\n       --  type, then the value is not going to be accessed, therefore it is\n       --  inappropriate to do any validity check at the call site.\n@@ -3845,11 +3869,10 @@ package body Checks is\n       then\n          return Expr_Known_Valid (Expression (Expr));\n \n-      --  The result of any function call or operator is always considered\n-      --  valid, since we assume the necessary checks are done by the call.\n-      --  For operators on floating-point operations, we must also check\n-      --  when the operation is the right-hand side of an assignment, or\n-      --  is an actual in a call.\n+      --  The result of any operator is always considered valid, since we\n+      --  assume the necessary checks are done by the operator. For operators\n+      --  on floating-point operations, we must also check when the operation\n+      --  is the right-hand side of an assignment, or is an actual in a call.\n \n       elsif\n         Nkind (Expr) in N_Binary_Op or else Nkind (Expr) in N_Unary_Op\n@@ -3866,9 +3889,6 @@ package body Checks is\n             return True;\n          end if;\n \n-      elsif Nkind (Expr) = N_Function_Call then\n-         return True;\n-\n       --  For all other cases, we do not know the expression is valid\n \n       else"}, {"sha": "2e1f38f88e4110a8a0bcb01d7e38a70cebbee489", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 208, "deletions": 114, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,7 @@ with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n+with Freeze;   use Freeze;\n with Hostparm; use Hostparm;\n with Inline;   use Inline;\n with Nlists;   use Nlists;\n@@ -361,14 +362,15 @@ package body Exp_Ch4 is\n    ---------------------------------\n \n    procedure Expand_Allocator_Expression (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Exp   : constant Node_Id    := Expression (Expression (N));\n-      Indic : constant Node_Id    := Subtype_Mark (Expression (N));\n-      PtrT  : constant Entity_Id  := Etype (N);\n-      T     : constant Entity_Id  := Entity (Indic);\n-      Flist : Node_Id;\n-      Node  : Node_Id;\n-      Temp  : Entity_Id;\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Exp    : constant Node_Id    := Expression (Expression (N));\n+      Indic  : constant Node_Id    := Subtype_Mark (Expression (N));\n+      PtrT   : constant Entity_Id  := Etype (N);\n+      DesigT : constant Entity_Id  := Designated_Type (PtrT);\n+      T      : constant Entity_Id  := Entity (Indic);\n+      Flist  : Node_Id;\n+      Node   : Node_Id;\n+      Temp   : Entity_Id;\n \n       Aggr_In_Place : constant Boolean := Is_Delayed_Aggregate (Exp);\n \n@@ -456,7 +458,7 @@ package body Exp_Ch4 is\n          --  body, so a run-time check is needed in general.\n \n          if Ada_Version >= Ada_05\n-           and then Is_Class_Wide_Type (Designated_Type (PtrT))\n+           and then Is_Class_Wide_Type (DesigT)\n            and then not Scope_Suppress (Accessibility_Check)\n            and then\n              (Is_Class_Wide_Type (Etype (Exp))\n@@ -539,7 +541,7 @@ package body Exp_Ch4 is\n             end;\n          end if;\n \n-         if Controlled_Type (Designated_Type (PtrT))\n+         if Controlled_Type (DesigT)\n             and then Controlled_Type (T)\n          then\n             declare\n@@ -629,14 +631,14 @@ package body Exp_Ch4 is\n          Rewrite (N, New_Reference_To (Temp, Loc));\n          Analyze_And_Resolve (N, PtrT);\n \n-      elsif Is_Access_Type (Designated_Type (PtrT))\n+      elsif Is_Access_Type (DesigT)\n         and then Nkind (Exp) = N_Allocator\n         and then Nkind (Expression (Exp)) /= N_Qualified_Expression\n       then\n          --  Apply constraint to designated subtype indication\n \n          Apply_Constraint_Check (Expression (Exp),\n-           Designated_Type (Designated_Type (PtrT)),\n+           Designated_Type (DesigT),\n            No_Sliding => True);\n \n          if Nkind (Expression (Exp)) = N_Raise_Constraint_Error then\n@@ -663,12 +665,12 @@ package body Exp_Ch4 is\n          --  on the qualified expression does not allow sliding,\n          --  but this check does (a relaxation from Ada 83).\n \n-         if Is_Constrained (Designated_Type (PtrT))\n+         if Is_Constrained (DesigT)\n            and then not Subtypes_Statically_Match\n-                          (T, Designated_Type (PtrT))\n+                          (T, DesigT)\n          then\n             Apply_Constraint_Check\n-              (Exp, Designated_Type (PtrT), No_Sliding => False);\n+              (Exp, DesigT, No_Sliding => False);\n \n          --  The nonsliding check should really be performed\n          --  (unconditionally) against the subtype of the\n@@ -677,8 +679,33 @@ package body Exp_Ch4 is\n \n          else\n             Apply_Constraint_Check\n-              (Exp, Designated_Type (PtrT), No_Sliding => True);\n+              (Exp, DesigT, No_Sliding => True);\n+         end if;\n+\n+         --  For an access to unconstrained packed array, GIGI needs\n+         --  to see an expression with a constrained subtype in order\n+         --  to compute the proper size for the allocator.\n+\n+         if Is_Array_Type (T)\n+           and then not Is_Constrained (T)\n+           and then Is_Packed (T)\n+         then\n+            declare\n+               ConstrT      : constant Entity_Id :=\n+                                Make_Defining_Identifier (Loc,\n+                                  Chars => New_Internal_Name ('A'));\n+               Internal_Exp : constant Node_Id   := Relocate_Node (Exp);\n+            begin\n+               Insert_Action (Exp,\n+                 Make_Subtype_Declaration (Loc,\n+                   Defining_Identifier => ConstrT,\n+                   Subtype_Indication  =>\n+                     Make_Subtype_From_Expr (Exp, T)));\n+               Freeze_Itype (ConstrT, Exp);\n+               Rewrite (Exp, OK_Convert_To (ConstrT, Internal_Exp));\n+            end;\n          end if;\n+\n       end if;\n \n    exception\n@@ -3854,13 +3881,6 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      --  Vax_Float is a special case\n-\n-      if Vax_Float (Typ) then\n-         Expand_Vax_Arith (N);\n-         return;\n-      end if;\n-\n       --  N / 1 = N for integer types\n \n       if Is_Integer_Type (Typ)\n@@ -3951,7 +3971,7 @@ package body Exp_Ch4 is\n \n          Analyze_And_Resolve (Left_Opnd (N), Universal_Real);\n \n-      --  Non-fixed point cases, do zero divide and overflow checks\n+      --  Non-fixed point cases, do integer zero divide and overflow checks\n \n       elsif Is_Integer_Type (Typ) then\n          Apply_Divide_Check (N);\n@@ -3963,6 +3983,12 @@ package body Exp_Ch4 is\n          then\n             Error_Msg_CRT (\"64-bit division\", N);\n          end if;\n+\n+      --  Deal with Vax_Float\n+\n+      elsif Vax_Float (Typ) then\n+         Expand_Vax_Arith (N);\n+         return;\n       end if;\n    end Expand_N_Op_Divide;\n \n@@ -4023,7 +4049,7 @@ package body Exp_Ch4 is\n             begin\n                --  Per-object constrained selected components require special\n                --  attention. If the enclosing scope of the component is an\n-               --  Unchecked_Union, we can not reference its discriminants\n+               --  Unchecked_Union, we cannot reference its discriminants\n                --  directly. This is why we use the two extra parameters of\n                --  the equality function of the enclosing Unchecked_Union.\n \n@@ -4239,14 +4265,13 @@ package body Exp_Ch4 is\n                return False;\n             end if;\n \n+            --  We only need to test one component\n+\n             declare\n                Comp : Node_Id := First (Component_Items (Clist));\n \n             begin\n                while Present (Comp) loop\n-\n-                  --  One component is sufficent\n-\n                   if Component_Is_Unconstrained_UU (Comp) then\n                      return True;\n                   end if;\n@@ -4324,9 +4349,10 @@ package body Exp_Ch4 is\n \n       if Ekind (Typl) = E_Private_Type then\n          Typl := Underlying_Type (Typl);\n-\n       elsif Ekind (Typl) = E_Private_Subtype then\n          Typl := Underlying_Type (Base_Type (Typl));\n+      else\n+         null;\n       end if;\n \n       --  It may happen in error situations that the underlying type is not\n@@ -4339,15 +4365,9 @@ package body Exp_Ch4 is\n \n       Typl := Base_Type (Typl);\n \n-      --  Vax float types\n-\n-      if Vax_Float (Typl) then\n-         Expand_Vax_Comparison (N);\n-         return;\n-\n       --  Boolean types (requiring handling of non-standard case)\n \n-      elsif Is_Boolean_Type (Typl) then\n+      if Is_Boolean_Type (Typl) then\n          Adjust_Condition (Left_Opnd (N));\n          Adjust_Condition (Right_Opnd (N));\n          Set_Etype (N, Standard_Boolean);\n@@ -4551,11 +4571,18 @@ package body Exp_Ch4 is\n       end if;\n \n       --  If we still have an equality comparison (i.e. it was not rewritten\n-      --  in some way), then we can test if result is needed at compile time).\n+      --  in some way), then we can test if result is known at compile time).\n \n       if Nkind (N) = N_Op_Eq then\n          Rewrite_Comparison (N);\n       end if;\n+\n+      --  If we still have comparison for Vax_Float, process it\n+\n+      if Vax_Float (Typl) and then Nkind (N) in N_Op_Compare  then\n+         Expand_Vax_Comparison (N);\n+         return;\n+      end if;\n    end Expand_N_Op_Eq;\n \n    -----------------------\n@@ -4870,11 +4897,7 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      if Vax_Float (Typ1) then\n-         Expand_Vax_Comparison (N);\n-         return;\n-\n-      elsif Is_Array_Type (Typ1) then\n+      if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n@@ -4887,6 +4910,13 @@ package body Exp_Ch4 is\n       end if;\n \n       Rewrite_Comparison (N);\n+\n+      --  If we still have comparison, and Vax_Float type, process it\n+\n+      if Vax_Float (Typ1) and then Nkind (N) in N_Op_Compare then\n+         Expand_Vax_Comparison (N);\n+         return;\n+      end if;\n    end Expand_N_Op_Ge;\n \n    --------------------\n@@ -4902,11 +4932,7 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      if Vax_Float (Typ1) then\n-         Expand_Vax_Comparison (N);\n-         return;\n-\n-      elsif Is_Array_Type (Typ1) then\n+      if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n@@ -4919,6 +4945,13 @@ package body Exp_Ch4 is\n       end if;\n \n       Rewrite_Comparison (N);\n+\n+      --  If we still have comparison, and Vax_Float type, process it\n+\n+      if Vax_Float (Typ1) and then Nkind (N) in N_Op_Compare then\n+         Expand_Vax_Comparison (N);\n+         return;\n+      end if;\n    end Expand_N_Op_Gt;\n \n    --------------------\n@@ -4934,11 +4967,7 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      if Vax_Float (Typ1) then\n-         Expand_Vax_Comparison (N);\n-         return;\n-\n-      elsif Is_Array_Type (Typ1) then\n+      if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n@@ -4951,6 +4980,13 @@ package body Exp_Ch4 is\n       end if;\n \n       Rewrite_Comparison (N);\n+\n+      --  If we still have comparison, and Vax_Float type, process it\n+\n+      if Vax_Float (Typ1) and then Nkind (N) in N_Op_Compare then\n+         Expand_Vax_Comparison (N);\n+         return;\n+      end if;\n    end Expand_N_Op_Le;\n \n    --------------------\n@@ -4966,11 +5002,7 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      if Vax_Float (Typ1) then\n-         Expand_Vax_Comparison (N);\n-         return;\n-\n-      elsif Is_Array_Type (Typ1) then\n+      if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n@@ -4983,6 +5015,13 @@ package body Exp_Ch4 is\n       end if;\n \n       Rewrite_Comparison (N);\n+\n+      --  If we still have comparison, and Vax_Float type, process it\n+\n+      if Vax_Float (Typ1) and then Nkind (N) in N_Op_Compare then\n+         Expand_Vax_Comparison (N);\n+         return;\n+      end if;\n    end Expand_N_Op_Lt;\n \n    -----------------------\n@@ -5187,13 +5226,6 @@ package body Exp_Ch4 is\n          end if;\n       end if;\n \n-      --  Deal with VAX float case\n-\n-      if Vax_Float (Typ) then\n-         Expand_Vax_Arith (N);\n-         return;\n-      end if;\n-\n       --  Convert x * 2 ** y to Shift_Left (x, y). Note that the fact that\n       --  Is_Power_Of_2_For_Shift is set means that we know that our left\n       --  operand is an integer, as required for this to work.\n@@ -5304,46 +5336,87 @@ package body Exp_Ch4 is\n \n       elsif Is_Signed_Integer_Type (Etype (N)) then\n          Apply_Arithmetic_Overflow_Check (N);\n+\n+      --  Deal with VAX float case\n+\n+      elsif Vax_Float (Typ) then\n+         Expand_Vax_Arith (N);\n+         return;\n       end if;\n    end Expand_N_Op_Multiply;\n \n    --------------------\n    -- Expand_N_Op_Ne --\n    --------------------\n \n-   --  Rewrite node as the negation of an equality operation, and reanalyze.\n-   --  The equality to be used is defined in the same scope and has the same\n-   --  signature. It must be set explicitly because in an instance it may not\n-   --  have the same visibility as in the generic unit.\n-\n    procedure Expand_N_Op_Ne (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-      Neg : Node_Id;\n-      Ne  : constant Entity_Id := Entity (N);\n+      Typ : constant Entity_Id := Etype (Left_Opnd (N));\n \n    begin\n-      Binary_Op_Validity_Checks (N);\n+      --  Case of elementary type with standard operator\n \n-      Neg :=\n-        Make_Op_Not (Loc,\n-          Right_Opnd =>\n-            Make_Op_Eq (Loc,\n-              Left_Opnd =>  Left_Opnd (N),\n-              Right_Opnd => Right_Opnd (N)));\n-      Set_Paren_Count (Right_Opnd (Neg), 1);\n+      if Is_Elementary_Type (Typ)\n+        and then Sloc (Entity (N)) = Standard_Location\n+      then\n+         Binary_Op_Validity_Checks (N);\n \n-      if Scope (Ne) /= Standard_Standard then\n-         Set_Entity (Right_Opnd (Neg), Corresponding_Equality (Ne));\n-      end if;\n+         --  Boolean types (requiring handling of non-standard case)\n \n-      --  For navigation purposes, the inequality is treated as an implicit\n-      --  reference to the corresponding equality. Preserve the Comes_From_\n-      --  source flag so that the proper Xref entry is generated.\n+         if Is_Boolean_Type (Typ) then\n+            Adjust_Condition (Left_Opnd (N));\n+            Adjust_Condition (Right_Opnd (N));\n+            Set_Etype (N, Standard_Boolean);\n+            Adjust_Result_Type (N, Typ);\n+         end if;\n \n-      Preserve_Comes_From_Source (Neg, N);\n-      Preserve_Comes_From_Source (Right_Opnd (Neg), N);\n-      Rewrite (N, Neg);\n-      Analyze_And_Resolve (N, Standard_Boolean);\n+         Rewrite_Comparison (N);\n+\n+         --  If we still have comparison for Vax_Float, process it\n+\n+         if Vax_Float (Typ) and then Nkind (N) in N_Op_Compare  then\n+            Expand_Vax_Comparison (N);\n+            return;\n+         end if;\n+\n+      --  For all cases other than elementary types, we rewrite node as the\n+      --  negation of an equality operation, and reanalyze. The equality to be\n+      --  used is defined in the same scope and has the same signature. This\n+      --  signature must be set explicitly since in an instance it may not have\n+      --  the same visibility as in the generic unit. This avoids duplicating\n+      --  or factoring the complex code for record/array equality tests etc.\n+\n+      else\n+         declare\n+            Loc : constant Source_Ptr := Sloc (N);\n+            Neg : Node_Id;\n+            Ne  : constant Entity_Id := Entity (N);\n+\n+         begin\n+            Binary_Op_Validity_Checks (N);\n+\n+            Neg :=\n+              Make_Op_Not (Loc,\n+                Right_Opnd =>\n+                  Make_Op_Eq (Loc,\n+                    Left_Opnd =>  Left_Opnd (N),\n+                    Right_Opnd => Right_Opnd (N)));\n+            Set_Paren_Count (Right_Opnd (Neg), 1);\n+\n+            if Scope (Ne) /= Standard_Standard then\n+               Set_Entity (Right_Opnd (Neg), Corresponding_Equality (Ne));\n+            end if;\n+\n+            --  For navigation purposes, the inequality is treated as an\n+            --  implicit reference to the corresponding equality. Preserve the\n+            --  Comes_From_ source flag so that the proper Xref entry is\n+            --  generated.\n+\n+            Preserve_Comes_From_Source (Neg, N);\n+            Preserve_Comes_From_Source (Right_Opnd (Neg), N);\n+            Rewrite (N, Neg);\n+            Analyze_And_Resolve (N, Standard_Boolean);\n+         end;\n+      end if;\n    end Expand_N_Op_Ne;\n \n    ---------------------\n@@ -6480,8 +6553,8 @@ package body Exp_Ch4 is\n          --  then we do not trust it to be in range (might be infinite)\n \n          declare\n-            S_Lo : constant Node_Id   := Type_Low_Bound (Xtyp);\n-            S_Hi : constant Node_Id   := Type_High_Bound (Xtyp);\n+            S_Lo : constant Node_Id := Type_Low_Bound (Xtyp);\n+            S_Hi : constant Node_Id := Type_High_Bound (Xtyp);\n \n          begin\n             if (not Is_Floating_Point_Type (Xtyp)\n@@ -6533,9 +6606,9 @@ package body Exp_Ch4 is\n            (Subtype_Mark (Conv), New_Occurrence_Of (Btyp, Loc));\n          Set_Etype (Conv, Btyp);\n \n-         --  Enable overflow except in the case of integer to float\n-         --  conversions, where it is never required, since we can\n-         --  never have overflow in this case.\n+         --  Enable overflow except for case of integer to float conversions,\n+         --  where it is never required, since we can never have overflow in\n+         --  this case.\n \n          if not Is_Integer_Type (Etype (Operand)) then\n             Enable_Overflow_Check (Conv);\n@@ -6588,13 +6661,6 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  Deal with Vax floating-point cases\n-\n-      if Vax_Float (Operand_Type) or else Vax_Float (Target_Type) then\n-         Expand_Vax_Conversion (N);\n-         return;\n-      end if;\n-\n       --  Nothing to do if this is the second argument of read. This\n       --  is a \"backwards\" conversion that will be handled by the\n       --  specialized code in attribute processing.\n@@ -6881,19 +6947,19 @@ package body Exp_Ch4 is\n          --  this type with proper overflow checking, and so gigi is doing an\n          --  approximation of what is required by doing floating-point compares\n          --  with the end-point. But that can lose precision in some cases, and\n-         --  give a wrong result. Converting the operand to Long_Long_Float is\n+         --  give a wrong result. Converting the operand to Universal_Real is\n          --  helpful, but still does not catch all cases with 64-bit integers\n          --  on targets with only 64-bit floats ???\n \n          if Do_Range_Check (Operand) then\n             Rewrite (Operand,\n               Make_Type_Conversion (Loc,\n                 Subtype_Mark =>\n-                  New_Occurrence_Of (Standard_Long_Long_Float, Loc),\n+                  New_Occurrence_Of (Universal_Real, Loc),\n                 Expression =>\n                   Relocate_Node (Operand)));\n \n-            Set_Etype (Operand, Standard_Long_Long_Float);\n+            Set_Etype (Operand, Universal_Real);\n             Enable_Range_Check (Operand);\n             Set_Do_Range_Check (Expression (Operand), False);\n          end if;\n@@ -6986,11 +7052,6 @@ package body Exp_Ch4 is\n \n       elsif Is_Floating_Point_Type (Target_Type) then\n          Real_Range_Check;\n-\n-      --  The remaining cases require no front end processing\n-\n-      else\n-         null;\n       end if;\n \n       --  At this stage, either the conversion node has been transformed\n@@ -7065,6 +7126,16 @@ package body Exp_Ch4 is\n             end if;\n          end;\n       end if;\n+\n+      --  Final step, if the result is a type conversion involving Vax_Float\n+      --  types, then it is subject for further special processing.\n+\n+      if Nkind (N) = N_Type_Conversion\n+        and then (Vax_Float (Operand_Type) or else Vax_Float (Target_Type))\n+      then\n+         Expand_Vax_Conversion (N);\n+         return;\n+      end if;\n    end Expand_N_Type_Conversion;\n \n    -----------------------------------\n@@ -7803,7 +7874,6 @@ package body Exp_Ch4 is\n               Statements => New_List (If_Stat)));\n \n       return Func_Body;\n-\n    end Make_Array_Comparison_Op;\n \n    ---------------------------\n@@ -7960,6 +8030,18 @@ package body Exp_Ch4 is\n             True_Result  := Res in Compare_GE;\n             False_Result := Res = LT;\n \n+            if Res = LE\n+              and then Constant_Condition_Warnings\n+              and then Comes_From_Source (Original_Node (N))\n+              and then Nkind (Original_Node (N)) = N_Op_Ge\n+              and then not In_Instance\n+              and then not Warnings_Off (Etype (Left_Opnd (N)))\n+              and then Is_Integer_Type (Etype (Left_Opnd (N)))\n+            then\n+               Error_Msg_N\n+                 (\"can never be greater than, could replace by \"\"'=\"\"?\", N);\n+            end if;\n+\n          when N_Op_Gt =>\n             True_Result  := Res = GT;\n             False_Result := Res in Compare_LE;\n@@ -7972,9 +8054,21 @@ package body Exp_Ch4 is\n             True_Result  := Res in Compare_LE;\n             False_Result := Res = GT;\n \n+            if Res = GE\n+              and then Constant_Condition_Warnings\n+              and then Comes_From_Source (Original_Node (N))\n+              and then Nkind (Original_Node (N)) = N_Op_Le\n+              and then not In_Instance\n+              and then not Warnings_Off (Etype (Left_Opnd (N)))\n+              and then Is_Integer_Type (Etype (Left_Opnd (N)))\n+            then\n+               Error_Msg_N\n+                 (\"can never be less than, could replace by \"\"'=\"\"?\", N);\n+            end if;\n+\n          when N_Op_Ne =>\n-            True_Result  := Res = NE;\n-            False_Result := Res = LT or else Res = GT or else Res = EQ;\n+            True_Result  := Res = NE or else Res = GT or else Res = LT;\n+            False_Result := Res = EQ;\n       end case;\n \n       if True_Result then"}, {"sha": "f9b5619c5bce2df0804abd736f3586381b117074", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1129,7 +1129,7 @@ package body Prj.Proc is\n          end loop;\n       end if;\n \n-      Success := Total_Errors_Detected <= 0;\n+      Success := Total_Errors_Detected = 0;\n    end Process;\n \n    -------------------------------"}, {"sha": "ce379033a40a84030a067abba5bb39d70dec09b7", "filename": "gcc/ada/s-mastop-tru64.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fs-mastop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fs-mastop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-tru64.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                         (Version for Alpha/Dec Unix)                     --\n --                                                                          --\n---           Copyright (C) 1999-2005 Ada Core Technologies, Inc.            --\n+--                     Copyright (C) 1999-2005, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -143,7 +143,7 @@ package body System.Machine_State_Operations is\n       Prf : constant System.Address := exc_lookup_function (Get_Code_Loc (M));\n \n    begin\n-      if (Prf = System.Null_Address) then\n+      if Prf = System.Null_Address then\n          c_set_code_loc (M, 0);\n       else\n          exc_virtual_unwind (Prf, M);"}, {"sha": "c9e1504779a889aa7ec99f1f9498fe979badd2c3", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -1382,7 +1382,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       --  Check that caller is abort-deferred\n \n-      if Self_ID.Deferral_Level <= 0 then\n+      if Self_ID.Deferral_Level = 0 then\n          return False;\n       end if;\n \n@@ -1419,7 +1419,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Check that caller is abort-deferred\n \n-      if Self_ID.Deferral_Level <= 0 then\n+      if Self_ID.Deferral_Level = 0 then\n          return False;\n       end if;\n \n@@ -1498,7 +1498,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       --  Check that caller is abort-deferred\n \n-      if Self_ID.Deferral_Level <= 0 then\n+      if Self_ID.Deferral_Level = 0 then\n          return False;\n       end if;\n \n@@ -1617,7 +1617,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Check that caller is abort-deferred\n \n-      if Self_ID.Deferral_Level <= 0 then\n+      if Self_ID.Deferral_Level = 0 then\n          return False;\n       end if;\n \n@@ -1646,7 +1646,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       --  Check that caller is abort-deferred\n \n-      if Self_ID.Deferral_Level <= 0 then\n+      if Self_ID.Deferral_Level = 0 then\n          return False;\n       end if;\n \n@@ -1833,7 +1833,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Check that caller is abort-deferred\n \n-      if Self_ID.Deferral_Level <= 0 then\n+      if Self_ID.Deferral_Level = 0 then\n          return False;\n       end if;\n "}, {"sha": "b06f117e1589802966843051b7db8403a46ff54e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 107, "deletions": 31, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -64,6 +64,7 @@ with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_VFpt; use Sem_VFpt;\n+with Sem_Warn; use Sem_Warn;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinfo.CN; use Sinfo.CN;\n@@ -236,8 +237,9 @@ package body Sem_Prag is\n \n       Pragma_Exit : exception;\n       --  This exception is used to exit pragma processing completely. It\n-      --  is used when an error is detected, and in other situations where\n-      --  it is known that no further processing is required.\n+      --  is used when an error is detected, and no further processing is\n+      --  required. It is also used if an earlier error has left the tree\n+      --  in a state where the pragma should not be processed.\n \n       Arg_Count : Nat;\n       --  Number of pragma argument associations\n@@ -1331,15 +1333,12 @@ package body Sem_Prag is\n \n                   Analyze (Expression (Arg1));\n \n-                  if        Unit_Kind = N_Generic_Subprogram_Declaration\n+                  if Unit_Kind = N_Generic_Subprogram_Declaration\n                     or else Unit_Kind = N_Subprogram_Declaration\n                   then\n                      Unit_Name := Defining_Entity (Unit_Node);\n \n-                  elsif     Unit_Kind = N_Function_Instantiation\n-                    or else Unit_Kind = N_Package_Instantiation\n-                    or else Unit_Kind = N_Procedure_Instantiation\n-                  then\n+                  elsif Unit_Kind in N_Generic_Instantiation then\n                      Unit_Name := Defining_Entity (Unit_Node);\n \n                   else\n@@ -2141,7 +2140,7 @@ package body Sem_Prag is\n            and then Ekind (E) /= E_Variable\n            and then not\n              (Is_Access_Type (E)\n-              and then Ekind (Designated_Type (E)) = E_Subprogram_Type)\n+                and then Ekind (Designated_Type (E)) = E_Subprogram_Type)\n          then\n             Error_Pragma_Arg\n               (\"second argument of pragma% must be subprogram (type)\",\n@@ -3784,9 +3783,21 @@ package body Sem_Prag is\n             --  suppress check for any check id value.\n \n             if C = All_Checks then\n+\n+               --  For All_Checks, we set all specific checks with the\n+               --  exception of Elaboration_Check, which is handled specially\n+               --  because of not wanting All_Checks to have the effect of\n+               --  deactivating static elaboration order processing.\n+\n                for J in Scope_Suppress'Range loop\n-                  Scope_Suppress (J) := Suppress_Case;\n+                  if J /= Elaboration_Check then\n+                     Scope_Suppress (J) := Suppress_Case;\n+                  end if;\n                end loop;\n+\n+            --  If not All_Checks, just set appropriate entry. Note that we\n+            --  will set Elaboration_Check if this is explicitly specified.\n+\n             else\n                Scope_Suppress (C) := Suppress_Case;\n             end if;\n@@ -4259,7 +4270,7 @@ package body Sem_Prag is\n          if Warn_On_Unrecognized_Pragma then\n             Error_Pragma (\"unrecognized pragma%!?\");\n          else\n-            raise Pragma_Exit;\n+            return;\n          end if;\n       else\n          Prag_Id := Get_Pragma_Id (Chars (N));\n@@ -5885,7 +5896,7 @@ package body Sem_Prag is\n                Error_Pragma (\"pragma% must refer to a spec, not a body\");\n             else\n                Set_Body_Required (Cunit_Node, True);\n-               Set_Has_Pragma_Elaborate_Body     (Cunit_Ent);\n+               Set_Has_Pragma_Elaborate_Body (Cunit_Ent);\n \n                --  If we are in dynamic elaboration mode, then we suppress\n                --  elaboration warnings for the unit, since it is definitely\n@@ -5991,7 +6002,7 @@ package body Sem_Prag is\n                 Present (Source_Location)\n             then\n                Error_Pragma\n-                 (\"parameter profile and source location can not \" &\n+                 (\"parameter profile and source location cannot \" &\n                   \"be used together in pragma%\");\n             end if;\n \n@@ -8141,6 +8152,28 @@ package body Sem_Prag is\n             S      : String_Id;\n             Active : Boolean := True;\n \n+            procedure Check_Obsolete_Subprogram;\n+            --  Checks if Subp is a subprogram declaration node, and if so\n+            --  replaces Subp by the defining entity of the subprogram. If not,\n+            --  issues an error message\n+\n+            ------------------------------\n+            -- Check_Obsolete_Subprogram--\n+            ------------------------------\n+\n+            procedure Check_Obsolete_Subprogram is\n+            begin\n+               if Nkind (Subp) /= N_Subprogram_Declaration then\n+                  Error_Pragma\n+                    (\"pragma% misplaced, must immediately \" &\n+                     \"follow subprogram/package declaration\");\n+               else\n+                  Subp := Defining_Entity (Subp);\n+               end if;\n+            end Check_Obsolete_Subprogram;\n+\n+         --  Start of processing for pragma Obsolescent\n+\n          begin\n             GNAT_Pragma;\n             Check_At_Most_N_Arguments (2);\n@@ -8153,6 +8186,7 @@ package body Sem_Prag is\n \n             if Present (Prev (N)) then\n                Subp := Prev (N);\n+               Check_Obsolete_Subprogram;\n \n             --  Second possibility, stand alone subprogram declaration with the\n             --  pragma immediately following the declaration.\n@@ -8161,25 +8195,22 @@ package body Sem_Prag is\n               and then Nkind (Parent (N)) = N_Compilation_Unit_Aux\n             then\n                Subp := Unit (Parent (Parent (N)));\n+               Check_Obsolete_Subprogram;\n \n-            --  Any other possibility is a misplacement\n+            --  Only other possibility is library unit placement for package\n \n             else\n-               Subp := Empty;\n-            end if;\n-\n-            --  Check correct placement\n+               Subp := Find_Lib_Unit_Name;\n \n-            if Nkind (Subp) /= N_Subprogram_Declaration then\n-               Error_Pragma\n-                 (\"pragma% misplaced, must immediately \" &\n-                  \"follow subprogram spec\");\n+               if Ekind (Subp) /= E_Package\n+                 and then Ekind (Subp) /= E_Generic_Package\n+               then\n+                  Check_Obsolete_Subprogram;\n+               end if;\n             end if;\n \n             --  If OK placement, acquire arguments\n \n-            Subp := Defining_Entity (Subp);\n-\n             if Arg_Count >= 1 then\n \n                --  Deal with static string argument\n@@ -9907,8 +9938,7 @@ package body Sem_Prag is\n                  (\"pragma% requires separate spec and must come before body\");\n \n             elsif Rep_Item_Too_Early (E, N)\n-                 or else\n-               Rep_Item_Too_Late (E, N)\n+              or else Rep_Item_Too_Late (E, N)\n             then\n                raise Pragma_Exit;\n \n@@ -10346,16 +10376,58 @@ package body Sem_Prag is\n          --------------\n \n          --  pragma Warnings (On | Off, [LOCAL_NAME])\n+         --  pragma Warnings (static_string_EXPRESSION);\n \n          when Pragma_Warnings => Warnings : begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n-            Check_At_Most_N_Arguments (2);\n             Check_No_Identifiers;\n \n-            --  One argument case was processed by parser in Par.Prag\n+            --  One argument case\n \n-            if Arg_Count /= 1 then\n+            if Arg_Count = 1 then\n+               declare\n+                  Argx : constant Node_Id := Get_Pragma_Arg (Arg1);\n+\n+               begin\n+                  --  On/Off one argument case was processed by parser\n+\n+                  if Nkind (Argx) = N_Identifier\n+                    and then\n+                      (Chars (Argx) = Name_On\n+                         or else\n+                       Chars (Argx) = Name_Off)\n+                  then\n+                     null;\n+\n+                  else\n+                     Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+\n+                     declare\n+                        Lit : constant Node_Id   := Expr_Value_S (Argx);\n+                        Str : constant String_Id := Strval (Lit);\n+                        C   : Char_Code;\n+\n+                     begin\n+                        for J in 1 .. String_Length (Str) loop\n+                           C := Get_String_Char (Str, J);\n+\n+                           if In_Character_Range (C)\n+                             and then Set_Warning_Switch (Get_Character (C))\n+                           then\n+                              null;\n+                           else\n+                              Error_Pragma_Arg\n+                                (\"invalid warning switch character\", Arg1);\n+                           end if;\n+                        end loop;\n+                     end;\n+                  end if;\n+               end;\n+\n+            --  Two argument case\n+\n+            elsif Arg_Count /= 1 then\n                Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n                Check_Arg_Count (2);\n \n@@ -10372,7 +10444,7 @@ package body Sem_Prag is\n                   --  is a conversion. Retrieve the real entity name.\n \n                   if (In_Instance_Body\n-                       or else In_Inlined_Body)\n+                      or else In_Inlined_Body)\n                     and then Nkind (E_Id) = N_Unchecked_Type_Conversion\n                   then\n                      E_Id := Expression (E_Id);\n@@ -10390,8 +10462,8 @@ package body Sem_Prag is\n                      return;\n                   else\n                      loop\n-                        Set_Warnings_Off (E,\n-                          (Chars (Expression (Arg1)) = Name_Off));\n+                        Set_Warnings_Off\n+                          (E, (Chars (Expression (Arg1)) = Name_Off));\n \n                         if Is_Enumeration_Type (E) then\n                            declare\n@@ -10410,6 +10482,10 @@ package body Sem_Prag is\n                      end loop;\n                   end if;\n                end;\n+\n+               --  More than two arguments\n+            else\n+               Check_At_Most_N_Arguments (2);\n             end if;\n          end Warnings;\n "}, {"sha": "ed2a9a06f7d9f4e7e31fc13df1538582fc7baf84", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,62 +28,62 @@\n --  (logically this processing belongs in chapter 4)\n \n with Types; use Types;\n+\n package Sem_Prag is\n \n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean;\n-   --  N is a pragma appearing in a configuration pragma file. Most\n-   --  such pragmas are analyzed when the file is read, before parsing\n-   --  and analyzing the main unit. However, the analysis of certain\n-   --  pragmas results in adding information to the compiled main unit,\n-   --  and this cannot be done till the main unit is processed. Such\n-   --  pragmas return True from this function and in Frontend pragmas\n-   --  where Delay_Config_Pragma_Analyze is True have their analysis\n-   --  delayed until after the main program is parsed and analyzed.\n+   --  N is a pragma appearing in a configuration pragma file. Most such\n+   --  pragmas are analyzed when the file is read, before parsing and analyzing\n+   --  the main unit. However, the analysis of certain pragmas results in\n+   --  adding information to the compiled main unit, and this cannot be done\n+   --  till the main unit is processed. Such pragmas return True from this\n+   --  function and in Frontend pragmas where Delay_Config_Pragma_Analyze is\n+   --  True have their analysis delayed until after the main program is parsed\n+   --  and analyzed.\n \n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean;\n    --  The node N is a node for an entity and the issue is whether the\n-   --  occurrence is a reference for the purposes of giving warnings\n-   --  about unreferenced variables. This function returns True if the\n-   --  reference is not a reference from this point of view (e.g. the\n-   --  occurrence in a pragma Pack) and False if it is a real reference\n-   --  (e.g. the occcurrence in a pragma Export);\n+   --  occurrence is a reference for the purposes of giving warnings about\n+   --  unreferenced variables. This function returns True if the reference is\n+   --  not a reference from this point of view (e.g. the occurrence in a pragma\n+   --  Pack) and False if it is a real reference (e.g. the occcurrence in a\n+   --  pragma Export);\n \n    function Is_Pragma_String_Literal (Par : Node_Id) return Boolean;\n-   --  Given an N_Pragma_Argument_Association node, Par, which has the form\n-   --  of an operator symbol, determines whether or not it should be treated\n-   --  as an string literal. This is called by Sem_Ch6.Analyze_Operator_Symbol.\n-   --  If True is returned, the argument is converted to a string literal. If\n+   --  Given an N_Pragma_Argument_Association node, Par, which has the form of\n+   --  an operator symbol, determines whether or not it should be treated as an\n+   --  string literal. This is called by Sem_Ch6.Analyze_Operator_Symbol. If\n+   --  True is returned, the argument is converted to a string literal. If\n    --  False is returned, then the argument is treated as an entity reference\n    --  to the operator.\n \n    function Is_Config_Static_String (Arg : Node_Id) return Boolean;\n-   --  This is called for a configuration pragma that requires either a\n-   --  string literal or a concatenation of string literals. We cannot\n-   --  use normal static string processing because it is too early in\n-   --  the case of the pragma appearing in a configuration pragmas file.\n-   --  If Arg is of an appropriate form, then this call obtains the string\n-   --  (doing any necessary concatenations) and places it in Name_Buffer,\n-   --  setting Name_Len to its length, and then returns True. If it is\n-   --  not of the correct form, then an appropriate error message is\n-   --  posted, and False is returned.\n+   --  This is called for a configuration pragma that requires either string\n+   --  literal or a concatenation of string literals. We cannot use normal\n+   --  static string processing because it is too early in the case of the\n+   --  pragma appearing in a configuration pragmas file. If Arg is of an\n+   --  appropriate form, then this call obtains the string (doing any necessary\n+   --  concatenations) and places it in Name_Buffer, setting Name_Len to its\n+   --  length, and then returns True. If it is not of the correct form, then an\n+   --  appropriate error message is posted, and False is returned.\n \n    procedure Process_Compilation_Unit_Pragmas (N : Node_Id);\n-   --  Called at the start of processing compilation unit N to deal with\n-   --  any special issues regarding pragmas. In particular, we have to\n-   --  deal with Suppress_All at this stage, since it appears after the\n-   --  unit instead of before.\n+   --  Called at the start of processing compilation unit N to deal with any\n+   --  special issues regarding pragmas. In particular, we have to deal with\n+   --  Suppress_All at this stage, since it appears after the unit instead of\n+   --  before.\n \n    procedure Set_Encoded_Interface_Name (E : Entity_Id; S : Node_Id);\n-   --  This routine is used to set an encoded interface name. The node\n-   --  S is an N_String_Literal node for the external name to be set, and\n-   --  E is an entity whose Interface_Name field is to be set. In the\n-   --  normal case where S contains a name that is a valid C identifier,\n-   --  then S is simply set as the value of the Interface_Name. Otherwise\n-   --  it is encoded. See the body for details of the encoding. This\n-   --  encoding is only done on VMS systems, since it seems pretty silly,\n-   --  but is needed to pass some dubious tests in the test suite.\n+   --  This routine is used to set an encoded interface name. The node S is an\n+   --  N_String_Literal node for the external name to be set, and E is an\n+   --  entity whose Interface_Name field is to be set. In the normal case where\n+   --  S contains a name that is a valid C identifier, then S is simply set as\n+   --  the value of the Interface_Name. Otherwise it is encoded. See the body\n+   --  for details of the encoding. This encoding is only done on VMS systems,\n+   --  since it seems pretty silly, but is needed to pass some dubious tests in\n+   --  the test suite.\n \n end Sem_Prag;"}, {"sha": "fe7545edadfb762ca1be8cda4f802c0843ca2d51", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 60, "deletions": 221, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,7 @@ with Osint;    use Osint;\n with Opt;      use Opt;\n with Prepcomp; use Prepcomp;\n with Validsw;  use Validsw;\n+with Sem_Warn; use Sem_Warn;\n with Stylesw;  use Stylesw;\n \n with System.WCh_Con; use System.WCh_Con;\n@@ -67,7 +68,7 @@ package body Switch.C is\n       --  Skip past the initial character (must be the switch character)\n \n       if Ptr = Max then\n-         raise Bad_Switch;\n+         Bad_Switch (C);\n       else\n          Ptr := Ptr + 1;\n       end if;\n@@ -104,7 +105,7 @@ package body Switch.C is\n                   Ptr := Ptr + 1;\n \n                   if Ptr > Max then\n-                     raise Bad_Switch;\n+                     Bad_Switch (C);\n                   end if;\n \n                   --  Find out whether this is a -I- or regular -Ixxx switch\n@@ -179,7 +180,7 @@ package body Switch.C is\n                      end if;\n                   end if;\n                else\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n          when True =>\n@@ -261,7 +262,7 @@ package body Switch.C is\n                      Dot := True;\n \n                   else\n-                     raise Bad_Switch;\n+                     Bad_Switch (C);\n                   end if;\n                end loop;\n \n@@ -289,7 +290,7 @@ package body Switch.C is\n                --  so we must always have a character after the e.\n \n                if Ptr > Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                case Switch_Chars (Ptr) is\n@@ -308,7 +309,7 @@ package body Switch.C is\n                      end if;\n \n                      if Ptr > Max then\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                      end if;\n \n                      declare\n@@ -351,7 +352,7 @@ package body Switch.C is\n                      Ptr := Ptr + 1;\n \n                      if Ptr > Max then\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                      end if;\n \n                      Add_Symbol_Definition (Switch_Chars (Ptr .. Max));\n@@ -378,7 +379,8 @@ package body Switch.C is\n \n                   when 'I' =>\n                      Ptr := Ptr + 1;\n-                     Scan_Pos (Switch_Chars, Max, Ptr, Multiple_Unit_Index);\n+                     Scan_Pos\n+                       (Switch_Chars, Max, Ptr, Multiple_Unit_Index, C);\n \n                   --  -gnatem (mapping file)\n \n@@ -394,7 +396,7 @@ package body Switch.C is\n                      end if;\n \n                      if Ptr > Max then\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                      end if;\n \n                      Mapping_File_Name :=\n@@ -415,7 +417,7 @@ package body Switch.C is\n                      end if;\n \n                      if Ptr > Max then\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                      end if;\n \n                      Preprocessing_Data_File :=\n@@ -446,7 +448,7 @@ package body Switch.C is\n                   --  All other -gnate? switches are unassigned\n \n                   when others =>\n-                     raise Bad_Switch;\n+                     Bad_Switch (C);\n                end case;\n \n             --  -gnatE (dynamic elaboration checks)\n@@ -502,7 +504,7 @@ package body Switch.C is\n                Warn_On_Unchecked_Conversion := True;\n                Warn_On_Unrecognized_Pragma  := True;\n \n-               Set_Style_Check_Options (\"3abcdefhiklmnprstu\");\n+               Set_Style_Check_Options (\"3abcdefhiklmnprstux\");\n \n             --  Processing for G switch\n \n@@ -526,7 +528,7 @@ package body Switch.C is\n \n             when 'i' =>\n                if Ptr = Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                Ptr := Ptr + 1;\n@@ -544,14 +546,15 @@ package body Switch.C is\n                   Ptr := Ptr + 1;\n \n                else\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n             --  Processing for k switch\n \n             when 'k' =>\n                Ptr := Ptr + 1;\n-               Scan_Pos (Switch_Chars, Max, Ptr, Maximum_File_Name_Length);\n+                  Scan_Pos\n+                    (Switch_Chars, Max, Ptr, Maximum_File_Name_Length, C);\n \n             --  Processing for l switch\n \n@@ -570,7 +573,14 @@ package body Switch.C is\n \n             when 'm' =>\n                Ptr := Ptr + 1;\n-               Scan_Pos (Switch_Chars, Max, Ptr, Maximum_Errors);\n+\n+               --  There may be an equal sign between -gnatm and the value\n+\n+               if Ptr <= Max and then Switch_Chars (Ptr) = '=' then\n+                  Ptr := Ptr + 1;\n+               end if;\n+\n+               Scan_Pos (Switch_Chars, Max, Ptr, Maximum_Errors, C);\n \n             --  Processing for n switch\n \n@@ -603,7 +613,18 @@ package body Switch.C is\n \n             when 'p' =>\n                Ptr := Ptr + 1;\n-               Suppress_Options           := (others => True);\n+\n+               --  Set all specific options as well as All_Checks in the\n+               --  Suppress_Options array, excluding Elaboration_Check, since\n+               --  this is treated specially because we do not want -gnatp to\n+               --  disable static elaboration processing.\n+\n+               for J in Suppress_Options'Range loop\n+                  if J /= Elaboration_Check then\n+                     Suppress_Options (J) := True;\n+                  end if;\n+               end loop;\n+\n                Validity_Checks_On         := False;\n                Opt.Suppress_Checks        := True;\n                Opt.Enable_Overflow_Checks := False;\n@@ -648,7 +669,7 @@ package body Switch.C is\n                      List_Representation_Info_Mechanisms := True;\n \n                   else\n-                     raise Bad_Switch;\n+                     Bad_Switch (C);\n                   end if;\n \n                   Ptr := Ptr + 1;\n@@ -687,7 +708,7 @@ package body Switch.C is\n \n             when 'T' =>\n                Ptr := Ptr + 1;\n-               Scan_Pos (Switch_Chars, Max, Ptr, Table_Factor);\n+               Scan_Pos (Switch_Chars, Max, Ptr, Table_Factor, C);\n \n             --  Processing for u switch\n \n@@ -715,7 +736,7 @@ package body Switch.C is\n                Ptr := Ptr + 1;\n \n                if Ptr > Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n \n                else\n                   declare\n@@ -726,7 +747,7 @@ package body Switch.C is\n                        (Switch_Chars (Ptr .. Max), OK, Ptr);\n \n                      if not OK then\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                      end if;\n \n                      for Index in First_Char + 1 .. Max loop\n@@ -748,188 +769,17 @@ package body Switch.C is\n                Ptr := Ptr + 1;\n \n                if Ptr > Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                while Ptr <= Max loop\n                   C := Switch_Chars (Ptr);\n \n-                  case C is\n-                     when 'a' =>\n-                        Check_Unreferenced              := True;\n-                        Check_Unreferenced_Formals      := True;\n-                        Check_Withs                     := True;\n-                        Constant_Condition_Warnings     := True;\n-                        Implementation_Unit_Warnings    := True;\n-                        Ineffective_Inline_Warnings     := True;\n-                        Warn_On_Ada_2005_Compatibility  := True;\n-                        Warn_On_Bad_Fixed_Value         := True;\n-                        Warn_On_Constant                := True;\n-                        Warn_On_Export_Import           := True;\n-                        Warn_On_Modified_Unread         := True;\n-                        Warn_On_No_Value_Assigned       := True;\n-                        Warn_On_Obsolescent_Feature     := True;\n-                        Warn_On_Redundant_Constructs    := True;\n-                        Warn_On_Unchecked_Conversion    := True;\n-                        Warn_On_Unrecognized_Pragma     := True;\n-\n-                     when 'A' =>\n-                        Check_Unreferenced              := False;\n-                        Check_Unreferenced_Formals      := False;\n-                        Check_Withs                     := False;\n-                        Constant_Condition_Warnings     := False;\n-                        Elab_Warnings                   := False;\n-                        Implementation_Unit_Warnings    := False;\n-                        Ineffective_Inline_Warnings     := False;\n-                        Warn_On_Ada_2005_Compatibility  := False;\n-                        Warn_On_Bad_Fixed_Value         := False;\n-                        Warn_On_Constant                := False;\n-                        Warn_On_Dereference             := False;\n-                        Warn_On_Export_Import           := False;\n-                        Warn_On_Hiding                  := False;\n-                        Warn_On_Modified_Unread         := False;\n-                        Warn_On_No_Value_Assigned       := False;\n-                        Warn_On_Obsolescent_Feature     := False;\n-                        Warn_On_Redundant_Constructs    := False;\n-                        Warn_On_Unchecked_Conversion    := False;\n-                        Warn_On_Unrecognized_Pragma     := False;\n-\n-                     when 'b' =>\n-                        Warn_On_Bad_Fixed_Value         := True;\n-\n-                     when 'B' =>\n-                        Warn_On_Bad_Fixed_Value         := False;\n-\n-                     when 'c' =>\n-                        Constant_Condition_Warnings     := True;\n-\n-                     when 'C' =>\n-                        Constant_Condition_Warnings     := False;\n-\n-                     when 'd' =>\n-                        Warn_On_Dereference             := True;\n-\n-                     when 'D' =>\n-                        Warn_On_Dereference             := False;\n-\n-                     when 'e' =>\n-                        Warning_Mode                    := Treat_As_Error;\n-\n-                     when 'f' =>\n-                        Check_Unreferenced_Formals      := True;\n-\n-                     when 'F' =>\n-                        Check_Unreferenced_Formals      := False;\n-\n-                     when 'g' =>\n-                        Warn_On_Unrecognized_Pragma     := True;\n-\n-                     when 'G' =>\n-                        Warn_On_Unrecognized_Pragma     := False;\n-\n-                     when 'h' =>\n-                        Warn_On_Hiding                  := True;\n-\n-                     when 'H' =>\n-                        Warn_On_Hiding                  := False;\n-\n-                     when 'i' =>\n-                        Implementation_Unit_Warnings    := True;\n-\n-                     when 'I' =>\n-                        Implementation_Unit_Warnings    := False;\n-\n-                     when 'j' =>\n-                        Warn_On_Obsolescent_Feature     := True;\n-\n-                     when 'J' =>\n-                        Warn_On_Obsolescent_Feature     := False;\n-\n-                     when 'k' =>\n-                        Warn_On_Constant                := True;\n-\n-                     when 'K' =>\n-                        Warn_On_Constant                := False;\n-\n-                     when 'l' =>\n-                        Elab_Warnings                   := True;\n-\n-                     when 'L' =>\n-                        Elab_Warnings                   := False;\n-\n-                     when 'm' =>\n-                        Warn_On_Modified_Unread         := True;\n-\n-                     when 'M' =>\n-                        Warn_On_Modified_Unread         := False;\n-\n-                     when 'n' =>\n-                        Warning_Mode                    := Normal;\n-\n-                     when 'o' =>\n-                        Address_Clause_Overlay_Warnings := True;\n-\n-                     when 'O' =>\n-                        Address_Clause_Overlay_Warnings := False;\n-\n-                     when 'p' =>\n-                        Ineffective_Inline_Warnings     := True;\n-\n-                     when 'P' =>\n-                        Ineffective_Inline_Warnings     := False;\n-\n-                     when 'r' =>\n-                        Warn_On_Redundant_Constructs    := True;\n-\n-                     when 'R' =>\n-                        Warn_On_Redundant_Constructs    := False;\n-\n-                     when 's' =>\n-                        Warning_Mode                    := Suppress;\n-\n-                     when 'u' =>\n-                        Check_Unreferenced              := True;\n-                        Check_Withs                     := True;\n-                        Check_Unreferenced_Formals      := True;\n-\n-                     when 'U' =>\n-                        Check_Unreferenced              := False;\n-                        Check_Withs                     := False;\n-                        Check_Unreferenced_Formals      := False;\n-\n-                     when 'v' =>\n-                        Warn_On_No_Value_Assigned       := True;\n-\n-                     when 'V' =>\n-                        Warn_On_No_Value_Assigned       := False;\n-\n-                     when 'x' =>\n-                        Warn_On_Export_Import           := True;\n-\n-                     when 'X' =>\n-                        Warn_On_Export_Import           := False;\n-\n-                     when 'y' =>\n-                        Warn_On_Ada_2005_Compatibility  := True;\n-\n-                     when 'Y' =>\n-                        Warn_On_Ada_2005_Compatibility  := False;\n-\n-                     when 'z' =>\n-                        Warn_On_Unchecked_Conversion    := True;\n-\n-                     when 'Z' =>\n-                        Warn_On_Unchecked_Conversion    := False;\n-\n-                        --  Allow and ignore 'w' so that the old\n-                        --  format (e.g. -gnatwuwl) will work.\n-\n-                     when 'w' =>\n-                        null;\n-\n-                     when others =>\n-                        raise Bad_Switch;\n-                  end case;\n+                  if Set_Warning_Switch (C) then\n+                     null;\n+                  else\n+                     Bad_Switch (C);\n+                  end if;\n \n                   if C /= 'w' then\n                      Storing (First_Stored + 1) := C;\n@@ -948,7 +798,7 @@ package body Switch.C is\n                Ptr := Ptr + 1;\n \n                if Ptr > Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                for J in WC_Encoding_Method loop\n@@ -957,7 +807,7 @@ package body Switch.C is\n                      exit;\n \n                   elsif J = WC_Encoding_Method'Last then\n-                     raise Bad_Switch;\n+                     Bad_Switch (C);\n                   end if;\n                end loop;\n \n@@ -1002,7 +852,7 @@ package body Switch.C is\n                        (Switch_Chars (Ptr .. Max), OK, Ptr);\n \n                      if not OK then\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                      end if;\n \n                      Ptr := First_Char + 1;\n@@ -1047,7 +897,7 @@ package body Switch.C is\n                         Distribution_Stub_Mode := Generate_Caller_Stub_Body;\n \n                      when others =>\n-                        raise Bad_Switch;\n+                        Bad_Switch (C);\n                   end case;\n \n                   Ptr := Ptr + 1;\n@@ -1065,13 +915,13 @@ package body Switch.C is\n \n             when '8' =>\n                if Ptr = Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                Ptr := Ptr + 1;\n \n                if Switch_Chars (Ptr) /= '3' then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                else\n                   Ptr := Ptr + 1;\n                   Ada_Version := Ada_83;\n@@ -1082,13 +932,13 @@ package body Switch.C is\n \n             when '9' =>\n                if Ptr = Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                Ptr := Ptr + 1;\n \n                if Switch_Chars (Ptr) /= '5' then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                else\n                   Ptr := Ptr + 1;\n                   Ada_Version := Ada_95;\n@@ -1099,13 +949,13 @@ package body Switch.C is\n \n             when '0' =>\n                if Ptr = Max then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n \n                Ptr := Ptr + 1;\n \n                if Switch_Chars (Ptr) /= '5' then\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                else\n                   Ptr := Ptr + 1;\n                   Ada_Version := Ada_05;\n@@ -1120,7 +970,7 @@ package body Switch.C is\n             --  Anything else is an error (illegal switch character)\n \n             when others =>\n-               raise Bad_Switch;\n+               Bad_Switch (C);\n             end case;\n          end case;\n \n@@ -1133,17 +983,6 @@ package body Switch.C is\n \n          First_Switch := False;\n       end loop;\n-\n-   exception\n-      when Bad_Switch =>\n-         Osint.Fail (\"invalid switch: \", (1 => C));\n-\n-      when Bad_Switch_Value =>\n-         Osint.Fail (\"numeric value out of range for switch: \", (1 => C));\n-\n-      when Missing_Switch_Value =>\n-         Osint.Fail (\"missing numeric value for switch: \", (1 => C));\n-\n    end Scan_Front_End_Switches;\n \n end Switch.C;"}, {"sha": "2367a91c2ffe65270493b01dc558dc39bae3fbf4", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b8bb877f4e1000c92df67b4a8b5b1efc263bd/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=f02b8bb877f4e1000c92df67b4a8b5b1efc263bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -311,14 +311,14 @@ package Types is\n    --  is in practice infinite and there is no need to check the range.\n \n    Ureal_Low_Bound : constant := 500_000_000;\n-   --  Low bound for Ureal values.\n+   --  Low bound for Ureal values\n \n    Ureal_High_Bound : constant := 599_999_999;\n    --  Maximum number of Ureal values stored is 100_000_000 which is in\n    --  practice infinite so that no check is required.\n \n    Uint_Low_Bound : constant := 600_000_000;\n-   --  Low bound for Uint values.\n+   --  Low bound for Uint values\n \n    Uint_Table_Start : constant := 2_000_000_000;\n    --  Location where table entries for universal integers start (see\n@@ -479,7 +479,7 @@ package Types is\n    --  are not valid.\n \n    First_Elist_Id : constant Elist_Id := No_Elist + 1;\n-   --  Subscript of first allocated Elist header.\n+   --  Subscript of first allocated Elist header\n \n    --  Element Id values are used to identify individual elements of an\n    --  element list (see package Elists for further details).\n@@ -696,12 +696,19 @@ package Types is\n       Tag_Check,\n       All_Checks);\n \n-   --  The following record contains an entry for each recognized check name\n+   --  The following array contains an entry for each recognized check name\n    --  for pragma Suppress. It is used to represent current settings of scope\n    --  based suppress actions from pragma Suppress or command line settings.\n \n-   type Suppress_Array is\n-     array (Check_Id range Access_Check .. Tag_Check) of Boolean;\n+   --  Note: when Suppress_Array (All_Checks) is True, then generally all other\n+   --  specific check entries are set True, except for the Elaboration_Check\n+   --  entry which is set only if an explicit Suppress for this check is given.\n+   --  The reason for this non-uniformity is that we do not want All_Checks to\n+   --  suppress elaboration checking when using the static elaboration model.\n+   --  We recognize only an explicit suppress of Elaboration_Check as a signal\n+   --  that the static elaboration checking should skip a compile time check.\n+\n+   type Suppress_Array is array (Check_Id) of Boolean;\n    pragma Pack (Suppress_Array);\n \n    --  To add a new check type to GNAT, the following steps are required:"}]}