{"sha": "3e3d9d17aaee8c46c94b73916859dbf05693c082", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UzZDlkMTdhYWVlOGM0NmM5NGI3MzkxNjg1OWRiZjA1NjkzYzA4Mg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2013-09-12T00:16:03Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2013-09-12T00:16:03Z"}, "message": "predicates.md (rl78_cmp_operator_signed): New.\n\n* config/rl78/predicates.md (rl78_cmp_operator_signed): New.\n(rl78_stack_based_mem): New.\n* config/rl78/constraints.md (Iv08): New.\n(Iv16): New.\n(Iv24): New.\n(Is09): New.\n(Is17): New.\n(Is25): New.\n(ISsi): New.\n(IShi): New.\n(ISqi): New.\n* config/rl78/rl78-expand.md (movqi): Reject more SUBREG operands.\n(movhi): Likewise.\n(movsi): Change from expand to insn-and-split.\n(ashrsi3): Clobber AX.\n(lshrsi3): New.\n(ashlsi3): New.\n(cbranchsi4): New.\n* config/rl78/rl78.md (CC_REG): Fix.\n(addsi3): Allow memory and immediate operands.\n(addsi3_internal): Split into...\n(addsi3_internal_virt): ...new, and ...\n(addsi3_internal_real): ...new.\n(subsi): New.\n(subsi3_internal_virt): New.\n(subsi3_internal_real): New.\n(mulsi3): Add memory operand.\n(mulsi3_rl78): Likewise.\n(mulsi3_g13): Likewise.\n* config/rl78/rl78-real.md (cbranchqi4_real_signed): New.\n(cbranchqi4_real): Add more constraint options.\n(cbranchhi4_real): Expand pattern.\n(cbranchhi4_real_signed): New.\n(cbranchhi4_real_inverted): New.\n(cbranchsi4_real_lt): New.\n(cbranchsi4_real_ge): New.\n(cbranchsi4_real_signed): New.\n(cbranchsi4_real): New.\n(peephole2): New.\n* config/rl78/rl78-virt.md (ashrsi3_virt): Add custom cases for constant shifts.\n(lshrsi3_virt): Likewise.\n(ashlsi3_virt): Likewise.\n(cbranchqi4_virt_signed): New.\n(cbranchhi4_virt_signed): New.\n(cbranchsi4_virt): New.\n* config/rl78/rl78.c: Whitespace fixes throughout.\n(move_elim_pass): New.\n(pass_data_rl78_move_elim): New.\n(pass_rl78_move_elim): New.\n(make_pass_rl78_move_elim): New.\n(rl78_devirt_info): Run devirt earlier.\n(rl78_move_elim_info): New.\n(rl78_asm_file_start): Register it.\n(rl78_split_movsi): New.\n(rl78_as_legitimate_address): Allow virtual base registers when\nappropriate.\n(rl78_addr_space_convert): Remove spurious debug stuff.\n(rl78_print_operand_1): Add z,s,S,r,E modifiers.\n(rl78_print_operand): More cases for not printing '#'.\n(rl78_expand_compare): Remove most of the logic.\n(content_memory): New.\n(clear_content_memory): New.\n(get_content_index): New.\n(get_content_name): New.\n(display_content_memory): New.\n(update_content): New.\n(record_content): New.\n(already_contains): New.\n(insn_ok_now): Re-recog insns with virtual registers.\n(add_postponed_content_update): New.\n(process_postponed_content_update): New.\n(gen_and_emit_move): New.\n(transcode_memory_rtx): Record new location content.  Use\ngen_and_emit_move.\n(force_into_acc): New.\n(move_to_acc): Use gen_and_emit_move.\n(move_from_acc): Likewise.\n(move_acc_to_reg): Likewise.\n(move_to_x): Likewise.\n(move_to_hl): Likewise.\n(move_to_de): Likewise.\n(rl78_alloc_physical_registers_op1): Record location content.\n(has_constraint): New.\n(rl78_alloc_physical_registers_op2): Record location content.\nOptimize use of HL.\n(rl78_alloc_physical_registers_ro1): Likewise.\n(rl78_alloc_physical_registers_cmp): Likewise.\n(rl78_alloc_physical_registers_umul): Likewise.\n(rl78_alloc_address_registers_macax): New.\n(rl78_alloc_physical_registers): Initialize and set location\ncontent memory as needed.\n(rl78_reorg): Make sure split2 is called.\n(rl78_rtx_costs): New.\n\nCo-Authored-By: Nick Clifton <nickc@redhat.com>\n\nFrom-SVN: r202511", "tree": {"sha": "4aea08d2edac609748062a818bbd39114a9c90b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aea08d2edac609748062a818bbd39114a9c90b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e3d9d17aaee8c46c94b73916859dbf05693c082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3d9d17aaee8c46c94b73916859dbf05693c082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e3d9d17aaee8c46c94b73916859dbf05693c082", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3d9d17aaee8c46c94b73916859dbf05693c082/comments", "author": null, "committer": null, "parents": [{"sha": "4b47d65500aac94a4726fa57935366dd1616c14c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b47d65500aac94a4726fa57935366dd1616c14c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b47d65500aac94a4726fa57935366dd1616c14c"}], "stats": {"total": 1921, "additions": 1628, "deletions": 293}, "files": [{"sha": "e05cb8ef66763727af541cdb45714ab1758929b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -1,3 +1,100 @@\n+2013-09-11  DJ Delorie  <dj@redhat.com>\n+\t    Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/predicates.md (rl78_cmp_operator_signed): New.\n+\t(rl78_stack_based_mem): New.\n+\t* config/rl78/constraints.md (Iv08): New.\n+\t(Iv16): New.\n+\t(Iv24): New.\n+\t(Is09): New.\n+\t(Is17): New.\n+\t(Is25): New.\n+\t(ISsi): New.\n+\t(IShi): New.\n+\t(ISqi): New.\n+\t* config/rl78/rl78-expand.md (movqi): Reject more SUBREG operands.\n+\t(movhi): Likewise.\n+\t(movsi): Change from expand to insn-and-split.\n+\t(ashrsi3): Clobber AX.\n+\t(lshrsi3): New.\n+\t(ashlsi3): New.\n+\t(cbranchsi4): New.\n+\t* config/rl78/rl78.md (CC_REG): Fix.\n+\t(addsi3): Allow memory and immediate operands.\n+\t(addsi3_internal): Split into...\n+\t(addsi3_internal_virt): ...new, and ...\n+\t(addsi3_internal_real): ...new.\n+\t(subsi): New.\n+\t(subsi3_internal_virt): New.\n+\t(subsi3_internal_real): New.\n+\t(mulsi3): Add memory operand.\n+\t(mulsi3_rl78): Likewise.\n+\t(mulsi3_g13): Likewise.\n+\t* config/rl78/rl78-real.md (cbranchqi4_real_signed): New.\n+\t(cbranchqi4_real): Add more constraint options.\n+\t(cbranchhi4_real): Expand pattern.\n+\t(cbranchhi4_real_signed): New.\n+\t(cbranchhi4_real_inverted): New.\n+\t(cbranchsi4_real_lt): New.\n+\t(cbranchsi4_real_ge): New.\n+\t(cbranchsi4_real_signed): New.\n+\t(cbranchsi4_real): New.\n+\t(peephole2): New.\n+\t* config/rl78/rl78-virt.md (ashrsi3_virt): Add custom cases for constant shifts.\n+\t(lshrsi3_virt): Likewise.\n+\t(ashlsi3_virt): Likewise.\n+\t(cbranchqi4_virt_signed): New.\n+\t(cbranchhi4_virt_signed): New.\n+\t(cbranchsi4_virt): New.\n+\t* config/rl78/rl78.c: Whitespace fixes throughout.\n+\t(move_elim_pass): New.\n+\t(pass_data_rl78_move_elim): New.\n+\t(pass_rl78_move_elim): New.\n+\t(make_pass_rl78_move_elim): New.\n+\t(rl78_devirt_info): Run devirt earlier.\n+\t(rl78_move_elim_info): New.\n+\t(rl78_asm_file_start): Register it.\n+\t(rl78_split_movsi): New.\n+\t(rl78_as_legitimate_address): Allow virtual base registers when\n+\tappropriate.\n+\t(rl78_addr_space_convert): Remove spurious debug stuff.\n+\t(rl78_print_operand_1): Add z,s,S,r,E modifiers.\n+\t(rl78_print_operand): More cases for not printing '#'.\n+\t(rl78_expand_compare): Remove most of the logic.\n+\t(content_memory): New.\n+\t(clear_content_memory): New.\n+\t(get_content_index): New.\n+\t(get_content_name): New.\n+\t(display_content_memory): New.\n+\t(update_content): New.\n+\t(record_content): New.\n+\t(already_contains): New.\n+\t(insn_ok_now): Re-recog insns with virtual registers.\n+\t(add_postponed_content_update): New.\n+\t(process_postponed_content_update): New.\n+\t(gen_and_emit_move): New.\n+\t(transcode_memory_rtx): Record new location content.  Use\n+\tgen_and_emit_move.\n+\t(force_into_acc): New.\n+\t(move_to_acc): Use gen_and_emit_move.\n+\t(move_from_acc): Likewise.\n+\t(move_acc_to_reg): Likewise.\n+\t(move_to_x): Likewise.\n+\t(move_to_hl): Likewise.\n+\t(move_to_de): Likewise.\n+\t(rl78_alloc_physical_registers_op1): Record location content.\n+\t(has_constraint): New.\n+\t(rl78_alloc_physical_registers_op2): Record location content.\n+\tOptimize use of HL.\n+\t(rl78_alloc_physical_registers_ro1): Likewise.\n+\t(rl78_alloc_physical_registers_cmp): Likewise.\n+\t(rl78_alloc_physical_registers_umul): Likewise.\n+\t(rl78_alloc_address_registers_macax): New.\n+\t(rl78_alloc_physical_registers): Initialize and set location\n+\tcontent memory as needed.\n+\t(rl78_reorg): Make sure split2 is called.\n+\t(rl78_rtx_costs): New.\n+\n 2013-09-11  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* simplify-rtx.c (simplify_unary_operation_1): Use simplify_gen_binary"}, {"sha": "1edb58d80681c050f3ec9249f0cb290f916104fa", "filename": "gcc/config/rl78/constraints.md", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fconstraints.md?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -43,6 +43,7 @@\n ; Y - any valid memory\n ; Wxx - various memory addressing modes\n ; Qxx - conditionals\n+; U = usual memory references mov-able to/from AX\n ; v = virtual registers\n ; Zxx = specific virtual registers\n \n@@ -56,6 +57,56 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, 1, 7)\")))\n \n+(define_constraint \"Iv08\"\n+  \"@internal\n+   Integer constant equal to 8.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 8, 8)\")))\n+(define_constraint \"Iv16\"\n+  \"@internal\n+   Integer constant equal to 16.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 16, 16)\")))\n+(define_constraint \"Iv24\"\n+  \"@internal\n+   Integer constant equal to 24.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 24, 24)\")))\n+\n+(define_constraint \"Is09\"\n+  \"@internal\n+   Integer constant in the range 9 @dots{} 15 (for shifts).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 9, 15)\")))\n+(define_constraint \"Is17\"\n+  \"@internal\n+   Integer constant in the range 17 @dots{} 23 (for shifts).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 17, 23)\")))\n+(define_constraint \"Is25\"\n+  \"@internal\n+   Integer constant in the range 25 @dots{} 31 (for shifts).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 25, 31)\")))\n+\n+(define_constraint \"ISsi\"\n+  \"@internal\n+   Integer constant with bit 31 set.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0x80000000) != 0\")))\n+\n+(define_constraint \"IShi\"\n+  \"@internal\n+   Integer constant with bit 15 set.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0x8000) != 0\")))\n+\n+(define_constraint \"ISqi\"\n+  \"@internal\n+   Integer constant with bit 7 set.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0x80) != 0\")))\n+\n (define_constraint \"J\"\n   \"Integer constant in the range -255 @dots{} 0\"\n   (and (match_code \"const_int\")"}, {"sha": "99ee656aad596a77dda819dbec4b7f34c0d6f805", "filename": "gcc/config/rl78/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fpredicates.md?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -46,6 +46,8 @@\n        (and (match_code \"const_int\")\n \t    (match_test \"IN_RANGE (INTVAL (op), 0, 65536)\"))))\n \n+(define_predicate \"rl78_cmp_operator_signed\"\n+  (match_code \"gt,ge,lt,le\"))\n (define_predicate \"rl78_cmp_operator_real\"\n   (match_code \"eq,ne,gtu,ltu,geu,leu\"))\n (define_predicate \"rl78_cmp_operator\"\n@@ -58,3 +60,12 @@\n (define_predicate \"rl78_addw_operand\"\n   (and (match_code \"reg\")\n        (match_test \"REGNO (op) == AX_REG || REGNO (op) == SP_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER\")))\n+\n+(define_predicate \"rl78_stack_based_mem\"\n+  (and (match_code \"mem\")\n+       (ior (and (match_code \"reg\" \"0\")\n+\t\t (match_test \"REGNO (XEXP (op, 0)) == SP_REG\"))\n+\t    (and (match_code \"plus\" \"0\")\n+\t\t (and (match_code \"reg\" \"00\")\n+\t\t      (match_test \"REGNO (XEXP (XEXP (op, 0), 0)) == SP_REG\")\n+\t\t      (match_code \"const_int\" \"01\"))))))"}, {"sha": "40c416251d3fe33195b24b5d6d292c4a2e9f157b", "filename": "gcc/config/rl78/rl78-expand.md", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-expand.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-expand.md?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -35,9 +35,24 @@\n     if (GET_CODE (operand1) == SUBREG\n         && GET_CODE (XEXP (operand1, 0)) == SYMBOL_REF)\n       FAIL;\n+    /* Similarly for (SUBREG (CONST (PLUS (SYMBOL_REF)))).\n+       cf. g++.dg/abi/packed.C.  */\n+    if (GET_CODE (operand1) == SUBREG\n+\t&& GET_CODE (XEXP (operand1, 0)) == CONST\n+        && GET_CODE (XEXP (XEXP (operand1, 0), 0)) == PLUS\n+        && GET_CODE (XEXP (XEXP (XEXP (operand1, 0), 0), 0)) == SYMBOL_REF)\n+      FAIL;\n+\n+    /* Similarly for (SUBREG (CONST (PLUS (SYMBOL_REF)))).\n+       cf. g++.dg/abi/packed.C.  */\n+    if (GET_CODE (operand1) == SUBREG\n+\t&& GET_CODE (XEXP (operand1, 0)) == CONST\n+        && GET_CODE (XEXP (XEXP (operand1, 0), 0)) == PLUS\n+        && GET_CODE (XEXP (XEXP (XEXP (operand1, 0), 0), 0)) == SYMBOL_REF)\n+      FAIL;\n \n     if (CONST_INT_P (operand1) && ! IN_RANGE (INTVAL (operand1), (-1 << 8) + 1, (1 << 8) - 1))\n-      gcc_unreachable();\n+      FAIL;\n   }\n )\n \n@@ -56,17 +71,27 @@\n     if (GET_CODE (operand1) == SUBREG\n         && GET_CODE (XEXP (operand1, 0)) == SYMBOL_REF)\n       FAIL;\n+    /* Similarly for (SUBREG (CONST (PLUS (SYMBOL_REF)))).  */\n+    if (GET_CODE (operand1) == SUBREG\n+\t&& GET_CODE (XEXP (operand1, 0)) == CONST\n+        && GET_CODE (XEXP (XEXP (operand1, 0), 0)) == PLUS\n+        && GET_CODE (XEXP (XEXP (XEXP (operand1, 0), 0), 0)) == SYMBOL_REF)\n+      FAIL;\n   }\n )\n \n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\")\n-\t(match_operand:SI 1 \"general_operand\"))]\n+(define_insn_and_split \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=vYS,v,Wfr\")\n+\t(match_operand:SI 1 \"general_operand\" \"viYS,Wfr,v\"))]\n   \"\"\n-  {\n-    rl78_expand_movsi (operands);\n-    DONE;\n-  }\n+  \"#\"\n+  \"\"\n+  [(set (match_operand:HI 2 \"nonimmediate_operand\")\n+\t(match_operand:HI 4 \"general_operand\"))\n+   (set (match_operand:HI 3 \"nonimmediate_operand\")\n+\t(match_operand:HI 5 \"general_operand\"))]\n+  \"rl78_split_movsi (operands);\"\n+  [(set_attr \"valloc\" \"op1\")]\n )\n \n ;;---------- Conversions ------------------------\n@@ -200,13 +225,33 @@\n )\n \n (define_expand \"ashrsi3\"\n-  [(set (match_operand:SI               0 \"register_operand\")\n-\t(ashiftrt:SI (match_operand:SI  1 \"register_operand\")\n-\t\t      (match_operand:SI 2 \"immediate_operand\")))\n+  [(parallel [(set (match_operand:SI               0 \"nonimmediate_operand\")\n+\t\t   (ashiftrt:SI (match_operand:SI  1 \"nonimmediate_operand\")\n+\t\t\t\t(match_operand:SI  2 \"nonmemory_operand\")))\n+\t      (clobber (reg:HI X_REG))])\n    ]\n   \"\"\n-  \"if (GET_CODE (operands[2]) != CONST_INT)\n-     FAIL;\"\n+  \"\"\n+)\n+\n+(define_expand \"lshrsi3\"\n+  [(parallel [(set (match_operand:SI               0 \"nonimmediate_operand\")\n+\t\t   (lshiftrt:SI (match_operand:SI  1 \"nonimmediate_operand\")\n+\t\t\t\t(match_operand:SI  2 \"nonmemory_operand\")))\n+\t      (clobber (reg:HI X_REG))])\n+   ]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_expand \"ashlsi3\"\n+  [(parallel [(set (match_operand:SI               0 \"nonimmediate_operand\")\n+\t(ashift:SI (match_operand:SI  1 \"nonimmediate_operand\")\n+\t\t      (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:HI X_REG))])\n+   ]\n+  \"\"\n+  \"\"\n )\n \n ;;---------- Branching ------------------------\n@@ -254,3 +299,16 @@\n   \"\"\n   \"rl78_expand_compare (operands);\"\n )\n+\n+(define_expand \"cbranchsi4\"\n+  [(parallel [(set (pc) (if_then_else\n+\t\t\t (match_operator 0 \"rl78_cmp_operator\"\n+\t\t\t\t\t [(match_operand:SI 1 \"general_operand\")\n+\t\t\t\t\t  (match_operand:SI 2 \"nonmemory_operand\")])\n+\t\t\t (label_ref (match_operand 3 \"\" \"\"))\n+\t\t\t (pc)))\n+\t      (clobber (reg:HI AX_REG))\n+\t      ])]\n+  \"1\"\n+  \"rl78_expand_compare (operands);\"\n+)"}, {"sha": "580609da2f9360fc284d9ab9c5bf187f3781a18c", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -21,6 +21,7 @@\n void\t\trl78_emit_eh_epilogue (rtx);\n void\t\trl78_expand_compare (rtx *);\n void\t\trl78_expand_movsi (rtx *);\n+void\t\trl78_split_movsi (rtx *);\n int\t\trl78_force_nonfar_2 (rtx *, rtx (*gen)(rtx,rtx));\n int\t\trl78_force_nonfar_3 (rtx *, rtx (*gen)(rtx,rtx,rtx));\n void\t\trl78_expand_eh_epilogue (rtx);"}, {"sha": "409abcc4a2a71310ae0b59989bf0310d60d63558", "filename": "gcc/config/rl78/rl78-real.md", "status": "modified", "additions": 129, "deletions": 7, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-real.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-real.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-real.md?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -312,11 +312,26 @@\n    call\\t%A1\"\n   )\n \n+(define_insn \"cbranchqi4_real_signed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_signed\"\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"A,A,A\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"ISqi,i,v\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   cmp\\t%1, %2 \\;xor1 CY,%1.7\\;not1 CY\\;sk%c0 \\;br\\t!!%3\n+   cmp\\t%1, %2 \\;xor1 CY,%1.7\\;sk%c0 \\;br\\t!!%3\n+   cmp\\t%1, %2 \\;xor1 CY,%1.7\\;xor1 CY,%2.7\\;sk%c0 \\;br\\t!!%3\"\n+  )\n+\n+\n (define_insn \"*cbranchqi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:QI 1 \"general_operand\" \"Wabvaxbc,a,          v,bcdehl\")\n-\t\t\t       (match_operand:QI 2 \"general_operand\" \"M,       irWhlWh1Whb,i,a\")])\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"Wabvaxbc,a,              v,bcdehl\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"M,       irvWabWhlWh1Whb,i,a\")])\n               (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n   \"rl78_real_insns_ok ()\"\n@@ -327,13 +342,120 @@\n    cmp\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\"\n   )\n \n-(define_insn \"*cbranchhi4_real\"\n+(define_insn \"cbranchhi4_real_signed\"\n   [(set (pc) (if_then_else\n-\t      (match_operator 0 \"rl78_cmp_operator_real\"\n-\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A\")\n-\t\t\t       (match_operand:HI 2 \"general_operand\" \"iBDTWhlWh1\")])\n-              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (match_operator 0 \"rl78_cmp_operator_signed\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A,A,A,vR\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"IShi,i,v,1\")])\n+              (label_ref (match_operand 3))\n \t      (pc)))]\n   \"rl78_real_insns_ok ()\"\n+  \"@\n+   cmpw\\t%1, %2 \\;xor1 CY,%Q1.7\\;not1 CY\\;sk%c0 \\;br\\t!!%3\n+   cmpw\\t%1, %2 \\;xor1 CY,%Q1.7\\;sk%c0 \\;br\\t!!%3\n+   cmpw\\t%1, %2 \\;xor1 CY,%Q1.7\\;xor1 CY,%Q2.7\\;sk%c0 \\;br\\t!!%3\n+   %z0\\t!!%3\"\n+  )\n+\n+(define_insn \"cbranchhi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A,vR\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"iBDTvWabWhlWh1,1\")])\n+              (label_ref (match_operand          3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+  cmpw\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\n+  %z0\\t!!%3\"\n+  )\n+\n+(define_insn \"cbranchhi4_real_inverted\"  \n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"A\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"iBDTvWabWhlWh1\")])\n+\t      (pc)\n+              (label_ref (match_operand          3 \"\" \"\"))))]\n+  \"rl78_real_insns_ok ()\"\n   \"cmpw\\t%1, %2 \\;sk%c0 \\;br\\t!!%3\"\n   )\n+\n+(define_insn \"cbranchsi4_real_lt\"\n+  [(set (pc) (if_then_else\n+\t      (lt (match_operand:SI 0 \"general_operand\" \"U,vWabWhlWh1\")\n+\t\t  (const_int 0))\n+              (label_ref (match_operand 1 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:HI AX_REG))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   mov a, %E0 \\;mov1 CY,a.7 \\;sknc \\;br\\t!!%1\n+   mov1 CY,%E0.7 \\;sknc \\;br\\t!!%1\"\n+  )\n+\n+(define_insn \"cbranchsi4_real_ge\"\n+  [(set (pc) (if_then_else\n+\t      (ge (match_operand:SI 0 \"general_operand\" \"U,vWabWhlWh1\")\n+\t\t  (const_int 0))\n+              (label_ref (match_operand 1 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:HI AX_REG))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   mov a, %E0 \\;mov1 CY,a.7 \\;skc \\;br\\t!!%1\n+   mov1 CY,%E0.7 \\;skc \\;br\\t!!%1\"\n+  )\n+\n+(define_insn \"cbranchsi4_real_signed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_signed\"\n+\t\t\t      [(match_operand:SI 1 \"nonimmediate_operand\" \"vU,vU,vU\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"ISsi,i,v\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:HI AX_REG))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;not1 CY\\;      movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%c0 \\;br\\t!!%3\n+   movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;               movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%c0 \\;br\\t!!%3\n+   movw ax,%H1 \\;cmpw  ax, %H2 \\;xor1 CY,a.7\\;xor1 CY,%E2.7\\;movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%c0 \\;br\\t!!%3\"\n+  )\n+\n+(define_insn \"cbranchsi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_real\"\n+\t\t\t      [(match_operand:SI 1 \"general_operand\" \"vUi\")\n+\t\t\t       (match_operand:SI 2 \"general_operand\" \"iWhlWh1v\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:HI AX_REG))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"movw ax,%H1 \\;cmpw  ax, %H2 \\;movw ax,%h1 \\;sknz \\;cmpw  ax, %h2 \\;sk%c0 \\;br\\t!!%3\"\n+  )\n+\n+;; Peephole to match:\n+;;\n+;;     (set (mem (sp)) (ax))\n+;;     (set (ax) (mem (sp)))\n+;; or:\n+;;     (set (mem (plus (sp) (const)) (ax))\n+;;     (set (ax) (mem (plus (sp) (const))))\n+;;\n+;; which can be generated as the last instruction of the conversion\n+;; of one virtual insn into a real insn and the first instruction of\n+;; the conversion of the following virtual insn.\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"rl78_stack_based_mem\")\n+\t(reg:HI AX_REG))\n+   (set (reg:HI AX_REG)\n+\t(match_dup 0))]\n+  \"\"\n+  [(set (match_dup 0) (reg:HI AX_REG))]\n+  )\n+"}, {"sha": "0585ef52cc2bbb683ded76f24cc610cddf83a1eb", "filename": "gcc/config/rl78/rl78-virt.md", "status": "modified", "additions": 156, "deletions": 8, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -161,20 +161,130 @@\n   \"v.shr\\t%0, %1, %2\"\n )\n \n-;; really a macro\n-(define_insn \"*ashrsi3_virt\"\n-  [(set (match_operand:SI               0 \"register_operand\" \"=v,v,v\")\n-\t(ashiftrt:SI (match_operand:SI  1 \"register_operand\" \"0,v,0\")\n-\t\t      (match_operand:SI 2 \"immediate_operand\" \"M,K,i\")))\n+;; This is complex mostly because the RL78 has no SImode operations,\n+;; and very limited HImode operations, and no variable shifts.  This\n+;; pattern is optimized for each constant shift count and operand\n+;; types, so as to use a hand-optimized pattern.  For readability, the\n+;; usual \\t\\; syntax is not used here.  Also, there's no easy way to \n+;; constrain to avoid partial overlaps, hence the duplication.\n+(define_insn \"ashrsi3_virt\"                                  ;;   0  1      2-7            8         9-15           16   17-23     24   25-31 var\n+  [(set (match_operand:SI               0 \"nonimmediate_operand\" \"=v,vU,&vU,v,  &vU,  &vU, v,  &vU,  v,  &vU, &vU,  vU,  v,&vU,    vU,  vU,   vU\")\n+\t(ashiftrt:SI (match_operand:SI  1 \"nonimmediate_operand\" \"0, 0,  vU,0,   vWab, U,  0,   vU,  0,   vWab,U,   vU,  0, vU,    vU,  vU,   0\")\n+\t\t      (match_operand:SI 2 \"nonmemory_operand\"    \"M, K,  K, Int3,Int3,Int3,Iv08,Iv08,Is09,Is09,Is09,Iv16,Is17,Is17,Iv24,Is25, iv\")))\n+   (clobber (reg:HI X_REG))\n+    ]\n+   \"\"\n+   \"@\n+    ; ashrsi %0, 0\n+\n+   movw ax,%H1 | sarw ax,1 | movw %H0,ax | mov a,%Q1 | rorc a,1 | mov %Q0,a | mov a,%q1 | rorc a,1 | mov %q0,a\n+   movw ax,%H1 | sarw ax,1 | movw %H0,ax | mov a,%Q1 | rorc a,1 | mov %Q0,a | mov a,%q1 | rorc a,1 | mov %q0,a\n+\n+   movw ax,%1 | shlw ax,%r2 | mov %0,a             | mov x,%Q1 | mov a,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | sarw ax,%u2 | movw %H0,ax\n+   movw ax,%1 | shlw ax,%r2 | mov %0,a             | mov x,%Q1 | mov a,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | sarw ax,%u2 | movw %H0,ax\n+   movw ax,%1 | shlw ax,%r2 | mov %0,a | mov a,%Q1 | mov x,a   | mov a,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | sarw ax,%u2 | movw %H0,ax\n+\n+   mov x,%Q1            | mov a,%H1 | movw %0,ax | movw ax,%H1 | sarw ax,8 | movw %H0,ax\n+   mov a,%Q1 | mov x, a | mov a,%H1 | movw %0,ax | movw ax,%H1 | sarw ax,8 | movw %H0,ax\n+\n+   mov x,%Q1           | mov a,%H1 | shlw ax,%r2 | mov %0,a | movw ax,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | sarw ax,%u2 | movw %H0,ax\n+   mov x,%Q1           | mov a,%H1 | shlw ax,%r2 | mov %0,a | movw ax,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | sarw ax,%u2 | movw %H0,ax\n+   mov a,%Q1 | mov x,a | mov a,%H1 | shlw ax,%r2 | mov %0,a | movw ax,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | sarw ax,%u2 | movw %H0,ax\n+\n+   movw ax,%H1 | movw %0,ax | sarw ax,15 | movw %H0,ax\n+\n+   movw ax,%H1 | sarw ax,%S2 | movw %0,ax | sarw ax,15 | movw %H0,ax\n+   movw ax,%H1 | sarw ax,%S2 | movw %0,ax | sarw ax,15 | movw %H0,ax\n+\n+   movw ax,%H1 | mov %0,a | sarw ax,15 | movw %H0,ax | mov %Q0,a\n+\n+   movw ax,%H1 | sar a,%s2 | mov %0,a | sarw ax,15 | movw %H0,ax | mov %Q0,a\n+\n+   mov b,%2 | cmp0 b | bz $2f | 1: | movw ax,%H1 | sarw ax,1 | movw %H0,ax | mov a,%Q1 | rorc a,1 | mov %Q0,a | mov a,%q1 | rorc a,1 | mov %q0,a | dec b | bnz $1b | 2:\"\n+  [(set_attr \"valloc\" \"macax\")]\n+)\n+\n+;; Likewise.\n+(define_insn \"lshrsi3_virt\"                                  ;;   0  1      2-7            8         9-15           16   17-23     24   25-31 var\n+  [(set (match_operand:SI               0 \"nonimmediate_operand\" \"=v,vU,&vU,v,  &vU,  &vU, v,  &vU,  v,  &vU, &vU,  vU,  v,&vU,    vU,  vU,   vU\")\n+\t(lshiftrt:SI (match_operand:SI  1 \"nonimmediate_operand\" \"0, 0,  vU,0,   vWab, U,  0,   vU,  0,   vWab,U,   vU,  0, vU,    vU,  vU,   0\")\n+\t\t      (match_operand:SI 2 \"nonmemory_operand\"    \"M, K,  K, Int3,Int3,Int3,Iv08,Iv08,Is09,Is09,Is09,Iv16,Is17,Is17,Iv24,Is25, iv\")))\n+   (clobber (reg:HI X_REG))\n    ]\n   \"\"\n   \"@\n-   ; ashrsi %0, 0\n-   movw\\tax,%H1\\;sarw\\tax,1\\;movw\\t%H0,ax\\;mov\\ta,%Q1\\;rorc\\ta,1\\;mov\\t%Q0,a\\;mov\\ta,%q1\\;rorc\\ta,1\\;mov\\t%q0,a\n-   mov\\tb,%2\\;1:\\;movw\\tax,%H1\\;sarw\\tax,1\\;movw\\t%H0,ax\\;mov\\ta,%Q1\\;rorc\\ta,1\\;mov\\t%Q0,a\\;mov\\ta,%q1\\;rorc\\ta,1\\;mov\\t%q0,a\\;dec\\tb\\;bnz $1b\"\n+   ; lshrsi %0, 0\n+\n+   movw ax,%H1 | shrw ax,1 | movw %H0,ax | mov a,%Q1 | rorc a,1 | mov %Q0,a | mov a,%q1 | rorc a,1 | mov %q0,a\n+   movw ax,%H1 | shrw ax,1 | movw %H0,ax | mov a,%Q1 | rorc a,1 | mov %Q0,a | mov a,%q1 | rorc a,1 | mov %q0,a\n+\n+   movw ax,%1 | shlw ax,%r2 | mov %0,a             | mov x,%Q1 | mov a,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | shrw ax,%u2 | movw %H0,ax\n+   movw ax,%1 | shlw ax,%r2 | mov %0,a             | mov x,%Q1 | mov a,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | shrw ax,%u2 | movw %H0,ax\n+   movw ax,%1 | shlw ax,%r2 | mov %0,a | mov a,%Q1 | mov x,a   | mov a,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | shrw ax,%u2 | movw %H0,ax\n+\n+   mov x,%Q1            | mov a,%H1 | movw %0,ax | movw ax,%H1 | shrw ax,8 | movw %H0,ax\n+   mov a,%Q1 | mov x, a | mov a,%H1 | movw %0,ax | movw ax,%H1 | shrw ax,8 | movw %H0,ax\n+\n+   mov x,%Q1           | mov a,%H1 | shlw ax,%r2 | mov %0,a | movw ax,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | shrw ax,%u2 | movw %H0,ax\n+   mov x,%Q1           | mov a,%H1 | shlw ax,%r2 | mov %0,a | movw ax,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | shrw ax,%u2 | movw %H0,ax\n+   mov a,%Q1 | mov x,a | mov a,%H1 | shlw ax,%r2 | mov %0,a | movw ax,%H1 | shlw ax,%r2 | mov %Q0,a | movw ax,%H1 | shrw ax,%u2 | movw %H0,ax\n+\n+   movw ax,%H1 | movw %0,ax | movw ax,#0 | movw %H0,ax\n+\n+   movw ax,%H1 | shrw ax,%S2 | movw %0,ax | movw ax,#0 | movw %H0,ax\n+   movw ax,%H1 | shrw ax,%S2 | movw %0,ax | movw ax,#0 | movw %H0,ax\n+\n+   movw ax,%H1 | mov %0,a | movw ax,#0 | movw %H0,ax | mov %Q0,a\n+\n+   movw ax,%H1 | shr a,%s2 | mov %0,a | movw ax,#0 | movw %H0,ax | mov %Q0,a\n+\n+   mov b,%2 | cmp0 b | bz $2f | 1: | movw ax,%H1 | shrw ax,1 | movw %H0,ax | mov a,%Q1 | rorc a,1 | mov %Q0,a | mov a,%q1 | rorc a,1 | mov %q0,a | dec b | bnz $1b | 2:\"\n   [(set_attr \"valloc\" \"macax\")]\n )\n \n+;; Likewise.\n+(define_insn \"ashlsi3_virt\"                                ;;   0  1      2-7            8         9-15           16        17-23     24        25-31     var\n+  [(set (match_operand:SI             0 \"nonimmediate_operand\" \"=v,vU,&vU,v,  &vU,  &vU, v,  &vU,  v,  &vU, &vU,  v,   U,   v,&vU,    v,   U,   v,   U,   vWab,vU,  vU\")\n+\t(ashift:SI (match_operand:SI  1 \"nonimmediate_operand\" \"0, 0,  vU,0,   vWab, U,  0,   vU,  0,   vWab,U,   vU,  vU,  0, vU,    vU,  vU,  vU,  vU,  0,   vWab,U\")\n+\t\t    (match_operand:SI 2 \"nonmemory_operand\"    \"M, K,  K, Int3,Int3,Int3,Iv08,Iv08,Is09,Is09,Is09,Iv16,Iv16,Is17,Is17,Iv24,Iv24,Is25,Is25,iv,  iv,  iv\")))\n+   (clobber (reg:HI X_REG))\n+   ]\n+  \"\"\n+  \"@\n+   ; lshrsi %0, 0\n+\n+   movw ax,%1 | shlw ax,1 | movw %0,ax | movw ax,%H1 | rolwc ax,1 | movw %H0,ax\n+   movw ax,%1 | shlw ax,1 | movw %0,ax | movw ax,%H1 | rolwc ax,1 | movw %H0,ax\n+\n+   movw ax,%H1 | shlw ax,%u2 | mov %E0,a | mov x,%Q1           | mov a, %H1 | shlw ax,%S2 | mov %H0,a | movw ax,%1 | shlw ax,%u2 | movw %0,ax\n+   movw ax,%H1 | shlw ax,%u2 | mov %E0,a | mov x,%Q1           | mov a, %H1 | shlw ax,%S2 | mov %H0,a | movw ax,%1 | shlw ax,%u2 | movw %0,ax\n+   movw ax,%H1 | shlw ax,%u2 | mov %E0,a | mov a,%Q1 | mov x,a | mov a, %H1 | shlw ax,%S2 | mov %H0,a | movw ax,%1 | shlw ax,%u2 | movw %0,ax\n+\n+   mov x,%Q1           | mov a,%H1 | movw %H0,ax | movw ax,%1 | shlw ax,8 | movw %0,ax\n+   mov a,%Q1 | mov x,a | mov a,%H1 | movw %H0,ax | movw ax,%1 | shlw ax,8 | movw %0,ax\n+\n+   mov x,%Q1           | mov a,%H1 | shlw ax,%s2 | movw %H0,ax | movw ax,%1 | shlw ax,%s2 | mov %H0,a | movw ax,%1 | shlw ax,%u2 | movw %0,ax\n+   mov x,%Q1           | mov a,%H1 | shlw ax,%s2 | movw %H0,ax | movw ax,%1 | shlw ax,%s2 | mov %H0,a | movw ax,%1 | shlw ax,%u2 | movw %0,ax\n+   mov a,%Q1 | mov x,a | mov a,%H1 | shlw ax,%s2 | movw %H0,ax | movw ax,%1 | shlw ax,%s2 | mov %H0,a | movw ax,%1 | shlw ax,%u2 | movw %0,ax\n+\n+   movw ax,%1 | movw %H0,ax | movw %0,#0\n+   movw ax,%1 | movw %H0,ax | movw ax,#0 | movw %0,ax\n+\n+   movw ax,%1 | shlw ax,%S2 | movw %H0,ax | movw %0,#0\n+   movw ax,%1 | shlw ax,%S2 | movw %H0,ax | movw ax,#0 | movw %0,ax\n+\n+   mov a,%1 | movw %H0,ax | mov %H0,#0 | movw %0,#0\n+   mov a,%1 | movw %H0,ax | movw ax,#0 | mov %H0,a | movW %0,ax\n+\n+   mov a,%1 | shl a,%s2 | movw %H0,ax | mov %H0,#0 | movw %0,#0\n+   mov a,%1 | shl a,%s2 | movw %H0,ax | movw ax,#0 | mov %H0,a | movW %0,ax\n+\n+   mov a,%2 | cmp0 a | bz $2f | mov d,a | movw ax,%H1 | movw bc,%1 | 1: | shlw bc,1 | rolwc ax,1 | dec d | bnz $1b | movw %H0,ax | movw ax,bc | movw %0,ax | 2:\n+   mov a,%2 | mov d,a | movw ax,%H1 | movw bc,%1 | cmp0 0xFFEFD | bz $2f | 1: | shlw bc,1 | rolwc ax,1 | dec d | bnz $1b | 2: | movw %H0,ax | movw ax,bc | movw %0,ax\n+   mov a,%2 | mov d,a | movw ax,%1 | movw bc,ax | movw ax,%H1 | cmp0 0xFFEFD | bz $2f | 1: | shlw bc,1 | rolwc ax,1 | dec d | bnz $1b | 2: | movw %H0,ax | movw ax,bc | movw %0,ax\"\n+   [(set_attr \"valloc\" \"macax\")]\n+ )\n+\n ;;---------- Branching ------------------------\n \n (define_insn \"*indirect_jump_virt\"\n@@ -202,6 +312,18 @@\n   [(set_attr \"valloc\" \"op1\")]\n   )\n \n+(define_insn \"cbranchqi4_virt_signed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_signed\"\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"vim\")\n+\t\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"vi\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.cmp\\t%1, %2\\\\n\\tv.b%c0\\t%3\"\n+  [(set_attr \"valloc\" \"cmp\")]\n+  )\n+\n (define_insn \"*cbranchqi4_virt\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n@@ -214,6 +336,18 @@\n   [(set_attr \"valloc\" \"cmp\")]\n   )\n \n+(define_insn \"cbranchhi4_virt_signed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator_signed\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"vim\")\n+\t\t\t       (match_operand:HI 2 \"nonmemory_operand\" \"vi\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.cmpw\\t%1, %2\\\\n\\tv.b%c0\\t%3\"\n+  [(set_attr \"valloc\" \"cmp\")]\n+  )\n+\n (define_insn \"*cbranchhi4_virt\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"rl78_cmp_operator_real\"\n@@ -226,6 +360,20 @@\n   [(set_attr \"valloc\" \"cmp\")]\n   )\n \n+(define_insn \"cbranchsi4_virt\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"rl78_cmp_operator\"\n+\t\t\t      [(match_operand:SI 1 \"general_operand\" \"vim\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"vi\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:HI AX_REG))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.cmpd\\t%1, %2\\\\n\\tv.b%c0\\t%3\"\n+  [(set_attr \"valloc\" \"macax\")]\n+  )\n+\n ;;---------- Peepholes ------------------------\n \n (define_peephole2"}, {"sha": "cd9010ab190559137b6ccec986826fd7d8256888", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 1042, "deletions": 238, "changes": 1280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -50,6 +50,8 @@\n #include \"dumpfile.h\"\n #include \"tree-pass.h\"\n #include \"context.h\"\n+#include \"tm-constrs.h\" /* for satisfies_constraint_*().  */\n+#include \"insn-flags.h\" /* for gen_*().  */\n \f\n static inline bool is_interrupt_func (const_tree decl);\n static inline bool is_brk_interrupt_func (const_tree decl);\n@@ -168,6 +170,86 @@ make_pass_rl78_devirt (gcc::context *ctxt)\n   return new pass_rl78_devirt (ctxt);\n }\n \n+static unsigned int\n+move_elim_pass (void)\n+{\n+  rtx insn, ninsn, prev = NULL_RTX;\n+\n+  for (insn = get_insns (); insn; insn = ninsn)\n+    {\n+      rtx set;\n+\n+      ninsn = next_nonnote_nondebug_insn (insn);\n+\n+      if ((set = single_set (insn)) == NULL_RTX)\n+\t{\n+\t  prev = NULL_RTX;\n+\t  continue;\n+\t}\n+\n+      /* If we have two SET insns in a row (without anything\n+\t between them) and the source of the second one is the\n+\t destination of the first one, and vice versa, then we\n+\t can eliminate the second SET.  */\n+      if (prev\n+\t  && rtx_equal_p (SET_DEST (prev), SET_SRC (set))\n+\t  && rtx_equal_p (SET_DEST (set), SET_SRC (prev))\n+\t  )\t  \n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" Delete insn %d because it is redundant\\n\",\n+\t\t     INSN_UID (insn));\n+\n+\t  delete_insn (insn);\n+\t  prev = NULL_RTX;\n+\t}\n+      else\n+\tprev = set;\n+    }\n+  \n+  if (dump_file)\n+    print_rtl_with_bb (dump_file, get_insns (), 0);\n+\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_rl78_move_elim =\n+{\n+  RTL_PASS, /* type */\n+  \"move_elim\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_rl78_move_elim : public rtl_opt_pass\n+{\n+public:\n+  pass_rl78_move_elim(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_rl78_move_elim, ctxt)\n+  {\n+  }\n+\n+  /* opt_pass methods: */\n+  bool gate () { return devirt_gate (); }\n+  unsigned int execute () { return move_elim_pass (); }\n+};\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_rl78_move_elim (gcc::context *ctxt)\n+{\n+  return new pass_rl78_move_elim (ctxt);\n+}\n \n #undef  TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START rl78_asm_file_start\n@@ -184,15 +266,25 @@ rl78_asm_file_start (void)\n     }\n \n   opt_pass *rl78_devirt_pass = make_pass_rl78_devirt (g);\n-  struct register_pass_info rl78_devirt_info =\n+  static struct register_pass_info rl78_devirt_info =\n     {\n       rl78_devirt_pass,\n-      \"vartrack\",\n+      \"pro_and_epilogue\",\n       1,\n       PASS_POS_INSERT_BEFORE\n     };\n \n+  opt_pass *rl78_move_elim_pass = make_pass_rl78_move_elim (g);\n+  static struct register_pass_info rl78_move_elim_info =\n+    {\n+      rl78_move_elim_pass,\n+      \"bbro\",\n+      1,\n+      PASS_POS_INSERT_AFTER\n+    };\n+\n   register_pass (& rl78_devirt_info);\n+  register_pass (& rl78_move_elim_info);\n }\n \n \f\n@@ -332,6 +424,46 @@ rl78_expand_movsi (rtx *operands)\n     }\n }\n \n+void\n+rl78_split_movsi (rtx *operands)\n+{\n+  rtx op00, op02, op10, op12;\n+\n+  op00 = rl78_subreg (HImode, operands[0], SImode, 0);\n+  op02 = rl78_subreg (HImode, operands[0], SImode, 2);\n+  if (GET_CODE (operands[1]) == CONST\n+      || GET_CODE (operands[1]) == SYMBOL_REF)\n+    {\n+      op10 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (0));\n+      op10 = gen_rtx_CONST (HImode, op10);\n+      op12 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (16));\n+      op12 = gen_rtx_CONST (HImode, op12);\n+    }\n+  else\n+    {\n+      op10 = rl78_subreg (HImode, operands[1], SImode, 0);\n+      op12 = rl78_subreg (HImode, operands[1], SImode, 2);\n+    }\n+\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    ;\n+  else if (rtx_equal_p (op00, op12))\n+    {\n+      operands[2] = op02;\n+      operands[4] = op12;\n+      operands[3] = op00;\n+      operands[5] = op10;\n+    }\n+  else\n+    {\n+      operands[2] = op00;\n+      operands[4] = op10;\n+      operands[3] = op02;\n+      operands[5] = op12;\n+    }\n+}\n+\n+\n /* Used by various two-operand expanders which cannot accept all\n    operands in the \"far\" namespace.  Force some such operands into\n    registers so that each pattern has at most one far operand.  */\n@@ -646,11 +778,11 @@ rl78_hl_b_c_addr_p (rtx op)\n int\n rl78_far_p (rtx x)\n {\n-  if (GET_CODE (x) != MEM)\n+  if (! MEM_P (x))\n     return 0;\n #if DEBUG0\n-  fprintf(stderr, \"\\033[35mrl78_far_p: \"); debug_rtx(x);\n-  fprintf(stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n+  fprintf (stderr, \"\\033[35mrl78_far_p: \"); debug_rtx(x);\n+  fprintf (stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n #endif\n   return MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR;\n }\n@@ -744,6 +876,10 @@ rl78_as_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n   if (strict && base && GET_CODE (base) == REG && REGNO (base) >= FIRST_PSEUDO_REGISTER)\n     return false;\n \n+  if (! cfun->machine->virt_insns_ok && base && GET_CODE (base) == REG\n+      && REGNO (base) >= 8 && REGNO (base) <= 31)\n+    return false;\n+\n   return true;\n }\n \n@@ -789,8 +925,6 @@ rl78_addr_space_convert (rtx op, tree from_type, tree to_type)\n     {\n       /* This always works.  */\n       result = gen_reg_rtx (SImode);\n-      debug_rtx(result);\n-      debug_rtx(op);\n       emit_move_insn (rl78_subreg (HImode, result, SImode, 0), op);\n       emit_move_insn (rl78_subreg (HImode, result, SImode, 2), const0_rtx);\n       return result;\n@@ -998,7 +1132,7 @@ rl78_start_function (FILE *file, HOST_WIDE_INT hwi_local ATTRIBUTE_UNUSED)\n       for (i = 0; i < 16; i ++)\n \tif (cfun->machine->need_to_push[i])\n \t  fprintf (file, \" %s\", word_regnames[i*2]);\n-      fprintf(file, \"\\n\");\n+      fprintf (file, \"\\n\");\n     }\n \n   if (frame_pointer_needed)\n@@ -1094,12 +1228,17 @@ rl78_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n    v - real register corresponding to a virtual register\n    m - minus - negative of CONST_INT value.\n    c - inverse of a conditional (NE vs EQ for example)\n+   z - collapsed conditional\n+   s - shift count mod 8\n+   S - shift count mod 16\n+   r - reverse shift count (8-(count mod 8))\n \n    h - bottom HI of an SI\n    H - top HI of an SI\n    q - bottom QI of an HI\n    Q - top QI of an HI\n    e - third QI of an SI (i.e. where the ES register gets values from)\n+   E - fourth QI of an SI (i.e. MSB)\n \n */\n \n@@ -1120,7 +1259,7 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n       else\n \t{\n \t  if (rl78_far_p (op))\n-\t    fprintf(file, \"es:\");\n+\t    fprintf (file, \"es:\");\n \t  if (letter == 'H')\n \t    {\n \t      op = adjust_address (op, HImode, 2);\n@@ -1146,31 +1285,36 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \t      op = adjust_address (op, QImode, 2);\n \t      letter = 0;\n \t    }\n+\t  if (letter == 'E')\n+\t    {\n+\t      op = adjust_address (op, QImode, 3);\n+\t      letter = 0;\n+\t    }\n \t  if (CONSTANT_P (XEXP (op, 0)))\n \t    {\n-\t      fprintf(file, \"!\");\n+\t      fprintf (file, \"!\");\n \t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n \t    }\n \t  else if (GET_CODE (XEXP (op, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF)\n \t    {\n-\t      fprintf(file, \"!\");\n+\t      fprintf (file, \"!\");\n \t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n \t    }\n \t  else if (GET_CODE (XEXP (op, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n \t\t   && REGNO (XEXP (XEXP (op, 0), 0)) == 2)\n \t    {\n \t      rl78_print_operand_1 (file, XEXP (XEXP (op, 0), 1), 'u');\n-\t      fprintf(file, \"[\");\n+\t      fprintf (file, \"[\");\n \t      rl78_print_operand_1 (file, XEXP (XEXP (op, 0), 0), 0);\n-\t      fprintf(file, \"]\");\n+\t      fprintf (file, \"]\");\n \t    }\n \t  else\n \t    {\n-\t      fprintf(file, \"[\");\n+\t      fprintf (file, \"[\");\n \t      rl78_print_operand_1 (file, XEXP (op, 0), letter);\n-\t      fprintf(file, \"]\");\n+\t      fprintf (file, \"]\");\n \t    }\n \t}\n       break;\n@@ -1184,6 +1328,8 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \tfprintf (file, \"%s\", reg_names [REGNO (op) & ~1]);\n       else if (letter == 'e')\n \tfprintf (file, \"%s\", reg_names [REGNO (op) + 2]);\n+      else if (letter == 'E')\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) + 3]);\n       else if (letter == 'S')\n \tfprintf (file, \"0x%x\", 0xffef8 + REGNO (op));\n       else if (GET_MODE (op) == HImode\n@@ -1209,10 +1355,20 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n \tfprintf (file, \"%ld\", INTVAL (op) & 0xffff);\n       else if (letter == 'e')\n \tfprintf (file, \"%ld\", (INTVAL (op) >> 16) & 0xff);\n+      else if (letter == 'E')\n+\tfprintf (file, \"%ld\", (INTVAL (op) >> 24) & 0xff);\n       else if (letter == 'm')\n \tfprintf (file, \"%ld\", - INTVAL (op));\n+      else if (letter == 's')\n+\tfprintf (file, \"%ld\", INTVAL (op) % 8);\n+      else if (letter == 'S')\n+\tfprintf (file, \"%ld\", INTVAL (op) % 16);\n+      else if (letter == 'r')\n+\tfprintf (file, \"%ld\", 8 - (INTVAL (op) % 8));\n+      else if (letter == 'C')\n+\tfprintf (file, \"%ld\", (INTVAL (op) ^ 0x8000) & 0xffff);\n       else\n-\tfprintf(file, \"%ld\", INTVAL (op));\n+\tfprintf (file, \"%ld\", INTVAL (op));\n       break;\n \n     case CONST:\n@@ -1316,22 +1472,68 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n       break;\n \n     case LTU:\n-      fprintf (file, letter == 'c' ? \"nc\" : \"c\");\n+      if (letter == 'z')\n+\tfprintf (file, \"#comparison eliminated\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"nc\" : \"c\");\n       break;\n     case LEU:\n-      fprintf (file, letter == 'c' ? \"h\" : \"nh\");\n+      if (letter == 'z')\n+\tfprintf (file, \"br\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"h\" : \"nh\");\n       break;\n     case GEU:\n-      fprintf (file, letter == 'c' ? \"c\" : \"nc\");\n+      if (letter == 'z')\n+\tfprintf (file, \"br\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"c\" : \"nc\");\n       break;\n     case GTU:\n-      fprintf (file, letter == 'c' ? \"nh\" : \"h\");\n+      if (letter == 'z')\n+\tfprintf (file, \"#comparison eliminated\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"nh\" : \"h\");\n       break;\n     case EQ:\n-      fprintf (file, letter == 'c' ? \"nz\" : \"z\");\n+      if (letter == 'z')\n+\tfprintf (file, \"br\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"nz\" : \"z\");\n       break;\n     case NE:\n-      fprintf (file, letter == 'c' ? \"z\" : \"nz\");\n+      if (letter == 'z')\n+\tfprintf (file, \"#comparison eliminated\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"z\" : \"nz\");\n+      break;\n+\n+    /* Note: these assume appropriate adjustments were made so that\n+       unsigned comparisons, which is all this chip has, will\n+       work.  */\n+    case LT:\n+      if (letter == 'z')\n+\tfprintf (file, \"#comparison eliminated\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"nc\" : \"c\");\n+      break;\n+    case LE:\n+      if (letter == 'z')\n+\tfprintf (file, \"br\");\n+      else\n+        fprintf (file, letter == 'c' ? \"h\" : \"nh\");\n+      break;\n+    case GE:\n+      if (letter == 'z')\n+\tfprintf (file, \"br\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"c\" : \"nc\");\n+      break;\n+    case GT:\n+      if (letter == 'z')\n+\tfprintf (file, \"#comparison eliminated\");\n+      else\n+\tfprintf (file, letter == 'c' ? \"nh\" : \"h\");\n       break;\n \n     default:\n@@ -1346,7 +1548,7 @@ rl78_print_operand_1 (FILE * file, rtx op, int letter)\n static void\n rl78_print_operand (FILE * file, rtx op, int letter)\n {\n-  if (CONSTANT_P (op) && letter != 'u')\n+  if (CONSTANT_P (op) && letter != 'u' && letter != 's' && letter != 'r' && letter != 'S')\n     fprintf (file, \"#\");\n   rl78_print_operand_1 (file, op, letter);\n }\n@@ -1391,66 +1593,8 @@ rl78_trampoline_adjust_address (rtx m_tramp)\n void\n rl78_expand_compare (rtx *operands)\n {\n-  /* RL78 does not have signed comparisons.  We must modify the\n-     operands to be in the unsigned range, and emit an unsigned\n-     comparison.  */\n-\n-  enum machine_mode mode;\n-  rtx high_bit;\n-  int i;\n-  RTX_CODE new_cond;\n-\n-  switch (GET_CODE (operands[0]))\n-    {\n-    case GE:\n-      new_cond = GEU;\n-      break;\n-    case LE:\n-      new_cond = LEU;\n-      break;\n-    case GT:\n-      new_cond = GTU;\n-      break;\n-    case LT:\n-      new_cond = LTU;\n-      break;\n-    default:\n-      return;\n-    }\n-\n-#if DEBUG0\n-  fprintf (stderr, \"\\033[38;5;129mrl78_expand_compare\\n\");\n-  debug_rtx (operands[0]);\n-  fprintf (stderr, \"\\033[0m\");\n-#endif\n-\n-  mode = GET_MODE (operands[1]);\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (operands[2]);\n-  high_bit = GEN_INT (~0 << (GET_MODE_BITSIZE (mode) - 1));\n-\n-  /* 0: conditional 1,2: operands */\n-  for (i = 1; i <= 2; i ++)\n-    {\n-      rtx r = operands[i];\n-\n-      if (GET_CODE (r) == CONST_INT)\n-\tr = GEN_INT (INTVAL (r) ^ INTVAL (high_bit));\n-      else\n-\t{\n-\t  r = gen_rtx_PLUS (mode, operands[i], high_bit);\n-\t  r = copy_to_mode_reg (mode, r);\n-\t}\n-      operands[i] = r;\n-    }\n-\n-  operands[0] = gen_rtx_fmt_ee (new_cond, GET_MODE (operands[0]), operands[1], operands[2]);\n-\n-#if DEBUG0\n-  fprintf (stderr, \"\\033[38;5;142mrl78_expand_compare\\n\");\n-  debug_rtx (operands[0]);\n-  fprintf (stderr, \"\\033[0m\");\n-#endif\n+  if (GET_CODE (operands[2]) == MEM)\n+    operands[2] = copy_to_mode_reg (GET_MODE (operands[2]), operands[2]);\n }\n \n \f\n@@ -1473,10 +1617,10 @@ rl78_peep_movhi_p (rtx *operands)\n \n #if DEBUG_PEEP\n   fprintf (stderr, \"\\033[33m\");\n-  debug_rtx(operands[0]);\n-  debug_rtx(operands[1]);\n-  debug_rtx(operands[2]);\n-  debug_rtx(operands[3]);\n+  debug_rtx (operands[0]);\n+  debug_rtx (operands[1]);\n+  debug_rtx (operands[2]);\n+  debug_rtx (operands[3]);\n   fprintf (stderr, \"\\033[0m\");\n #endif\n \n@@ -1662,14 +1806,242 @@ re-run regmove, but that has not yet been attempted.\n  */\n #define DEBUG_ALLOC 0\n \n+/* This array is used to hold knowledge about the contents of the\n+   real registers (A ... H), the memory-based registers (r8 ... r31)\n+   and the first NUM_STACK_LOCS words on the stack.  We use this to\n+   avoid generating redundant move instructions.\n+\n+   A value in the range 0 .. 31 indicates register A .. r31.\n+   A value in the range 32 .. 63 indicates stack slot (value - 32).\n+   A value of NOT_KNOWN indicates that the contents of that location\n+   are not known.  */\n+\n+#define NUM_STACK_LOCS\t32\n+#define NOT_KNOWN       127\n+\n+static unsigned char content_memory [32 + NUM_STACK_LOCS];\n+\n+static unsigned char saved_update_index = NOT_KNOWN;\n+static unsigned char saved_update_value;\n+static enum machine_mode saved_update_mode;\n+\n+\n+static inline void\n+clear_content_memory (void)\n+{\n+  memset (content_memory, NOT_KNOWN, sizeof content_memory);\n+  if (dump_file)\n+    fprintf (dump_file, \"  clear content memory\\n\");\n+  saved_update_index = NOT_KNOWN;\n+}\n+\n+/* Convert LOC into an index into the content_memory array.\n+   If LOC cannot be converted, return NOT_KNOWN.  */\n+\n+static unsigned char\n+get_content_index (rtx loc)\n+{\n+  enum machine_mode mode;\n+\n+  if (loc == NULL_RTX)\n+    return NOT_KNOWN;\n+\n+  if (REG_P (loc))\n+    {\n+      if (REGNO (loc) < 32)\n+\treturn REGNO (loc);\n+      return NOT_KNOWN;\n+    }\n+\n+  mode = GET_MODE (loc);\n+\n+  if (! rl78_stack_based_mem (loc, mode))\n+    return NOT_KNOWN;\n+\n+  loc = XEXP (loc, 0);\n+\n+  if (REG_P (loc))\n+    /* loc = MEM (SP) */\n+    return 32;\n+\n+  /* loc = MEM (PLUS (SP, INT)).  */\n+  loc = XEXP (loc, 1);\n+\n+  if (INTVAL (loc) < NUM_STACK_LOCS)\n+    return 32 + INTVAL (loc);\n+\n+  return NOT_KNOWN;\n+}\n+\n+/* Return a string describing content INDEX in mode MODE.\n+   WARNING: Can return a pointer to a static buffer.  */\n+\n+static const char *\n+get_content_name (unsigned char index, enum machine_mode mode)\n+{\n+  static char buffer [128];\n+\n+  if (index == NOT_KNOWN)\n+    return \"Unknown\";\n+\n+  if (index > 31)\n+    sprintf (buffer, \"stack slot %d\", index - 32);\n+  else if (mode == HImode)\n+    sprintf (buffer, \"%s%s\",\n+\t     reg_names [index + 1], reg_names [index]);\n+  else\n+    return reg_names [index];\n+\n+  return buffer;\n+}\n+\n+#if DEBUG_ALLOC\n+\n+static void\n+display_content_memory (FILE * file)\n+{\n+  unsigned int i;\n+\n+  fprintf (file, \" Known memory contents:\\n\");\n+\n+  for (i = 0; i < sizeof content_memory; i++)\n+    if (content_memory[i] != NOT_KNOWN)\n+      {\n+\tfprintf (file, \"   %s contains a copy of \", get_content_name (i, QImode));\n+\tfprintf (file, \"%s\\n\", get_content_name (content_memory [i], QImode));\n+      }\n+}\n+#endif\n+\n+static void\n+update_content (unsigned char index, unsigned char val, enum machine_mode mode)\n+{\n+  unsigned int i;\n+\n+  gcc_assert (index < sizeof content_memory);\n+\n+  content_memory [index] = val;\n+  if (val != NOT_KNOWN)\n+    content_memory [val] = index;\n+\n+  /* Make the entry in dump_file *before* VAL is increased below.  */\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"  %s now contains \", get_content_name (index, mode));\n+      if (val == NOT_KNOWN)\n+\tfprintf (dump_file, \"Unknown\\n\");\n+      else\n+\tfprintf (dump_file, \"%s and vice versa\\n\", get_content_name (val, mode));\n+    }\n+  \n+  if (mode == HImode)\n+    {\n+      val = val == NOT_KNOWN ? val : val + 1;\n+\n+      content_memory [index + 1] = val;\n+      if (val != NOT_KNOWN)\n+\t{\n+\t  content_memory [val] = index + 1;\n+\t  -- val;\n+\t}\n+    }\n+\n+  /* Any other places that had INDEX recorded as their contents are now invalid.  */\n+  for (i = 0; i < sizeof content_memory; i++)\n+    {\n+      if (i == index\n+\t  || (val != NOT_KNOWN && i == val))\n+\t{\n+\t  if (mode == HImode)\n+\t    ++ i;\n+\t  continue;\n+\t}\n+\t\n+      if (content_memory[i] == index\n+\t  || (val != NOT_KNOWN && content_memory[i] == val))\n+\t{\n+\t  content_memory[i] = NOT_KNOWN;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  %s cleared\\n\", get_content_name (i, mode));\n+\n+\t  if (mode == HImode)\n+\t    content_memory[++ i] = NOT_KNOWN;\n+\t}\n+    }\n+}\n+\n+/* Record that LOC contains VALUE.\n+   For HImode locations record that LOC+1 contains VALUE+1.\n+   If LOC is not a register or stack slot, do nothing.\n+   If VALUE is not a register or stack slot, clear the recorded content.  */\n+\n+static void\n+record_content (rtx loc, rtx value)\n+{\n+  enum machine_mode mode;\n+  unsigned char index;\n+  unsigned char val;\n+\n+  if ((index = get_content_index (loc)) == NOT_KNOWN)\n+    return;\n+\n+  val = get_content_index (value);\n+\n+  mode = GET_MODE (loc);\n+\n+  if (val == index)\n+    {\n+      if (! optimize)\n+\treturn;\n+\n+      /* This should not happen when optimizing.  */\n+#if 1\n+      fprintf (stderr, \"ASSIGNMENT of location to itself detected! [%s]\\n\",\n+\t       get_content_name (val, mode));\n+      return;\n+#else\n+      gcc_unreachable ();\n+#endif\n+    }\n+\n+  update_content (index, val, mode);\n+}\n+\n+/* Returns TRUE if LOC already contains a copy of VALUE.  */\n+\n+static bool\n+already_contains (rtx loc, rtx value)\n+{\n+  unsigned char index;\n+  unsigned char val;\n+\n+  if ((index = get_content_index (loc)) == NOT_KNOWN)\n+    return false;\n+\n+  if ((val = get_content_index (value)) == NOT_KNOWN)\n+    return false;\n+\n+  if (content_memory [index] != val)\n+    return false;\n+\n+  if (GET_MODE (loc) == HImode)\n+    return content_memory [index + 1] == val + 1;\n+\n+  return true;\n+}\n+\n /* Rescans an insn to see if it's recognized again.  This is done\n    carefully to ensure that all the constraint information is accurate\n    for the newly matched insn.  */\n static bool\n insn_ok_now (rtx insn)\n {\n+  rtx pattern = PATTERN (insn);\n+\n   INSN_CODE (insn) = -1;\n-  if (recog (PATTERN (insn), insn, 0) > -1)\n+\n+  if (recog (pattern, insn, 0) > -1)\n     {\n       extract_insn (insn);\n       if (constrain_operands (1))\n@@ -1679,15 +2051,34 @@ insn_ok_now (rtx insn)\n \t  debug_rtx (insn);\n \t  fprintf (stderr, \"\\033[0m\");\n #endif\n+\t  if (SET_P (pattern))\n+\t    record_content (SET_DEST (pattern), SET_SRC (pattern));\n+\n \t  return true;\n \t}\n     }\n   else\n     {\n-      fprintf (stderr, \"\\033[41;30m Unrecognized insn \\033[0m\\n\");\n+      /* We need to re-recog the insn with virtual registers to get\n+\t the operands */\n+      cfun->machine->virt_insns_ok = 1;\n+      if (recog (pattern, insn, 0) > -1)\n+\t{\n+\t  extract_insn (insn);\n+\t  if (constrain_operands (0))\n+\t    {\n+\t      cfun->machine->virt_insns_ok = 0;\n+\t      return false;\n+\t    }\n+\t}\n+\n+#if DEBUG_ALLOC\n+      fprintf (stderr, \"\\033[41;30m Unrecognized *virtual* insn \\033[0m\\n\");\n       debug_rtx (insn);\n+#endif\n       gcc_unreachable ();\n     }\n+\n #if DEBUG_ALLOC\n   fprintf (stderr, \"\\033[31m\");\n   debug_rtx (insn);\n@@ -1697,15 +2088,15 @@ insn_ok_now (rtx insn)\n }\n \n #if DEBUG_ALLOC\n-#define WORKED fprintf (stderr, \"\\033[48;5;22m Worked at line %d \\033[0m\\n\", __LINE__)\n+#define WORKED      fprintf (stderr, \"\\033[48;5;22m Worked at line %d \\033[0m\\n\", __LINE__)\n #define FAILEDSOFAR fprintf (stderr, \"\\033[48;5;52m FAILED at line %d \\033[0m\\n\", __LINE__)\n-#define FAILED fprintf (stderr, \"\\033[48;5;52m FAILED at line %d \\033[0m\\n\", __LINE__), gcc_unreachable()\n+#define FAILED      fprintf (stderr, \"\\033[48;5;52m FAILED at line %d \\033[0m\\n\", __LINE__), gcc_unreachable()\n #define MAYBE_OK(insn) if (insn_ok_now (insn)) { WORKED; return; } else { FAILEDSOFAR; }\n+#define MUST_BE_OK(insn) if (insn_ok_now (insn)) { WORKED; return; } FAILED\n #else\n-#define WORKED\n-#define FAILEDSOFAR\n #define FAILED gcc_unreachable ()\n #define MAYBE_OK(insn) if (insn_ok_now (insn)) return;\n+#define MUST_BE_OK(insn) if (insn_ok_now (insn)) return; FAILED\n #endif\n \n /* Registers into which we move the contents of virtual registers.  */\n@@ -1787,16 +2178,95 @@ rl78_hi8 (rtx addr)\n   return rl78_subreg (QImode, addr, SImode, 2);\n }\n \n-/* Copy any register values into real registers and return an RTX for\n-   the same memory, now addressed by real registers.  Any needed insns\n-   are emitted before BEFORE.  */\n+static void\n+add_postponed_content_update (rtx to, rtx value)\n+{\n+  unsigned char index;\n+\n+  if ((index = get_content_index (to)) == NOT_KNOWN)\n+    return;\n+\n+  gcc_assert (saved_update_index == NOT_KNOWN);\n+  saved_update_index = index;\n+  saved_update_value = get_content_index (value);\n+  saved_update_mode  = GET_MODE (to);\n+}\n+\n+static void\n+process_postponed_content_update (void)\n+{\n+  if (saved_update_index != NOT_KNOWN)\n+    {\n+      update_content (saved_update_index, saved_update_value, saved_update_mode);\n+      saved_update_index = NOT_KNOWN;\n+    }\n+}\n+\n+/* Generate and emit a move of (register) FROM into TO.  if WHERE is not NULL\n+   then if BEFORE is true then emit the insn before WHERE, otherwise emit it\n+   after WHERE.  If TO already contains FROM then do nothing.  Returns TO if\n+   BEFORE is true, FROM otherwise.  */\n+static rtx\n+gen_and_emit_move (rtx to, rtx from, rtx where, bool before)\n+{\n+  enum machine_mode mode = GET_MODE (to);\n+\n+  if (optimize && before && already_contains (to, from))\n+    {\n+#if DEBUG_ALLOC\n+      display_content_memory (stderr);\n+#endif\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \" Omit move of %s into \",\n+\t\t   get_content_name (get_content_index (from), mode));\n+\t  fprintf (dump_file, \"%s as it already contains this value\\n\",\n+\t\t   get_content_name (get_content_index (to), mode));\n+\t}\n+    }\n+  else\n+    {\n+      rtx move = mode == QImode ? gen_movqi (to, from) : gen_movhi (to, from);\n+      \n+      EM (move);\n+\n+      if (where == NULL_RTX)\n+\temit_insn (move);\n+      else if (before)\n+\temit_insn_before (move, where);\n+      else\n+\t{\n+\t  rtx note = find_reg_note (where, REG_EH_REGION, NULL_RTX);\n+\n+\t  /* If necessary move REG_EH_REGION notes forward.\n+\t     cf. compiling gcc.dg/pr44545.c.  */\n+\t  if (note != NULL_RTX)\n+\t    {\n+\t      add_reg_note (move, REG_EH_REGION, XEXP (note, 0));\n+\t      remove_note (where, note);\n+\t    }\n+\n+\t  emit_insn_after (move, where);\n+\t}\n+\n+      if (before)\n+\trecord_content (to, from);\n+      else\n+\tadd_postponed_content_update (to, from);\n+    }\n+  return before ? to : from;\n+}\n+\n+/* If M is MEM(REG) or MEM(PLUS(REG,INT)) and REG is virtual then\n+   copy it into NEWBASE and return the updated MEM.  Otherwise just\n+   return M.  Any needed insns are emitted before BEFORE.  */\n static rtx\n transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n {\n   rtx base, index, addendr;\n   int addend = 0;\n \n-  if (GET_CODE (m) != MEM)\n+  if (! MEM_P (m))\n     return m;\n \n   if (GET_MODE (XEXP (m, 0)) == SImode)\n@@ -1806,16 +2276,18 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n       fprintf (stderr, \"setting ES:\\n\");\n       debug_rtx(seg);\n #endif\n-      emit_insn_before (EM(gen_movqi (A, seg)), before);\n-      emit_insn_before (EM(gen_movqi_es (A)), before);\n+      emit_insn_before (EM (gen_movqi (A, seg)), before);\n+      emit_insn_before (EM (gen_movqi_es (A)), before);\n+      record_content (A, NULL_RTX);\n+\n       m = change_address (m, GET_MODE (m), rl78_lo16 (XEXP (m, 0)));\n     }\n \n-  characterize_address (XEXP (m, 0), &base, &index, &addendr);\n+  characterize_address (XEXP (m, 0), & base, & index, & addendr);\n   gcc_assert (index == NULL_RTX);\n \n #if DEBUG_ALLOC\n-  fprintf (stderr, \"\\033[33m\"); debug_rtx(m); fprintf (stderr, \"\\033[0m\");\n+  fprintf (stderr, \"\\033[33m\"); debug_rtx (m); fprintf (stderr, \"\\033[0m\");\n   debug_rtx (base);\n #endif\n   if (base == NULL_RTX)\n@@ -1824,6 +2296,9 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n   if (addendr && GET_CODE (addendr) == CONST_INT)\n     addend = INTVAL (addendr);\n \n+  gcc_assert (REG_P (base));\n+  gcc_assert (REG_P (newbase));\n+\n   if (REGNO (base) == SP_REG)\n     {\n       if (addend >= 0 && addend  <= 255)\n@@ -1844,17 +2319,22 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n       EM (emit_insn_before (gen_movhi (AX, base), before));\n       EM (emit_insn_before (gen_addhi3 (AX, AX, addendr), before));\n       EM (emit_insn_before (gen_movhi (newbase, AX), before));\n+      record_content (AX, NULL_RTX);\n+      record_content (newbase, NULL_RTX);\n+\n       base = newbase;\n       addend = 0;\n     }\n   else\n     {\n-      EM (emit_insn_before (gen_movhi (newbase, base), before));\n-      base = newbase;\n+      base = gen_and_emit_move (newbase, base, before, true);\n     }\n \n   if (addend)\n-    base = gen_rtx_PLUS (HImode, base, GEN_INT (addend));\n+    {\n+      record_content (base, NULL_RTX);\n+      base = gen_rtx_PLUS (HImode, base, GEN_INT (addend));\n+    }\n \n #if DEBUG_ALLOC\n   fprintf (stderr, \"\\033[33m\");\n@@ -1874,49 +2354,48 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n static rtx\n move_to_acc (int opno, rtx before)\n {\n-  rtx src = OP(opno);\n+  rtx src = OP (opno);\n   enum machine_mode mode = GET_MODE (src);\n \n-  if (GET_CODE (src) == REG\n-      && REGNO (src) < 2)\n+  if (REG_P (src) && REGNO (src) < 2)\n     return src;\n \n   if (mode == VOIDmode)\n     mode = recog_data.operand_mode[opno];\n \n-  if (mode == QImode)\n-    {\n-      EM (emit_insn_before (gen_movqi (A, src), before));\n-      return A;\n-    }\n-  else\n-    {\n-      EM (emit_insn_before (gen_movhi (AX, src), before));\n-      return AX;\n-    }\n+  return gen_and_emit_move (mode == QImode ? A : AX, src, before, true);\n+}\n+\n+static void\n+force_into_acc (rtx src, rtx before)\n+{\n+  enum machine_mode mode = GET_MODE (src);\n+  rtx move;\n+\n+  if (REG_P (src) && REGNO (src) < 2)\n+    return;\n+\n+  move = mode == QImode ? gen_movqi (A, src) : gen_movhi (AX, src);\n+      \n+  EM (move);\n+\n+  emit_insn_before (move, before);\n+  record_content (AX, NULL_RTX);\n }\n \n /* Copy accumulator (A or AX) to DEST, placing any generated insns\n    after AFTER.  Returns accumulator RTX.  */\n \n static rtx\n-move_from_acc (rtx dest, rtx after)\n+move_from_acc (unsigned int opno, rtx after)\n {\n+  rtx dest = OP (opno);\n   enum machine_mode mode = GET_MODE (dest);\n \n   if (REG_P (dest) && REGNO (dest) < 2)\n     return dest;\n \n-  if (mode == QImode)\n-    {\n-      EM (emit_insn_after (gen_movqi (dest, A), after));\n-      return A;\n-    }\n-  else\n-    {\n-      EM (emit_insn_after (gen_movhi (dest, AX), after));\n-      return AX;\n-    }\n+  return gen_and_emit_move (dest, mode == QImode ? A : AX, after, false);\n }\n \n /* Copy accumulator (A or AX) to REGNO, placing any generated insns\n@@ -1930,16 +2409,7 @@ move_acc_to_reg (rtx acc, int regno, rtx before)\n \n   reg = gen_rtx_REG (mode, regno);\n \n-  if (mode == QImode)\n-    {\n-      EM (emit_insn_before (gen_movqi (reg, A), before));\n-      return reg;\n-    }\n-  else\n-    {\n-      EM (emit_insn_before (gen_movhi (reg, AX), before));\n-      return reg;\n-    }\n+  return gen_and_emit_move (reg, acc, before, true);\n }\n \n /* Copy SRC to X, placing any generated insns before BEFORE.\n@@ -1948,7 +2418,7 @@ move_acc_to_reg (rtx acc, int regno, rtx before)\n static rtx\n move_to_x (int opno, rtx before)\n {\n-  rtx src = OP(opno);\n+  rtx src = OP (opno);\n   enum machine_mode mode = GET_MODE (src);\n   rtx reg;\n \n@@ -1958,17 +2428,12 @@ move_to_x (int opno, rtx before)\n \n   if (mode == QImode || ! is_virtual_register (OP (opno)))\n     {\n-      OP(opno) = move_to_acc (opno, before);\n-      OP(opno) = move_acc_to_reg (OP(opno), X_REG, before);\n+      OP (opno) = move_to_acc (opno, before);\n+      OP (opno) = move_acc_to_reg (OP(opno), X_REG, before);\n       return reg;\n     }\n \n-  if (mode == QImode)\n-    EM (emit_insn_before (gen_movqi (reg, src), before));\n-  else\n-    EM (emit_insn_before (gen_movhi (reg, src), before));\n-\n-  return reg;\n+  return gen_and_emit_move (reg, src, before, true);\n }\n \n /* Copy OP(opno) to H or HL, placing any generated insns before BEFORE.\n@@ -1992,12 +2457,7 @@ move_to_hl (int opno, rtx before)\n       return reg;\n     }\n \n-  if (mode == QImode)\n-    EM (emit_insn_before (gen_movqi (reg, src), before));\n-  else\n-    EM (emit_insn_before (gen_movhi (reg, src), before));\n-\n-  return reg;\n+  return gen_and_emit_move (reg, src, before, true);\n }\n \n /* Copy OP(opno) to E or DE, placing any generated insns before BEFORE.\n@@ -2022,9 +2482,7 @@ move_to_de (int opno, rtx before)\n     }\n   else\n     {\n-      rtx move = mode == QImode ? gen_movqi (reg, src) : gen_movhi (reg, src);\n-\n-      EM (emit_insn_before (move, before));\n+      gen_and_emit_move (reg, src, before, true);\n     }\n \n   return reg;\n@@ -2038,63 +2496,104 @@ rl78_alloc_physical_registers_op1 (rtx insn)\n \n   /* We first try using A as the destination, then copying it\n      back.  */\n-  if (rtx_equal_p (OP(0), OP(1)))\n+  if (rtx_equal_p (OP (0), OP (1)))\n     {\n-      OP(0) =\n-      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n+      OP (0) =\n+      OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n     }\n   else\n     {\n-      OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n-      OP(1) = transcode_memory_rtx (OP(1), HL, insn);\n+      /* If necessary, load the operands into BC and HL.\n+\t Check to see if we already have OP (0) in HL\n+\t and if so, swap the order.  */\n+      if (MEM_P (OP (0))\n+\t  && already_contains (HL, XEXP (OP (0), 0)))\n+\t{\n+\t  OP (0) = transcode_memory_rtx (OP (0), HL, insn);\n+\t  OP (1) = transcode_memory_rtx (OP (1), BC, insn);\n+\t}\n+      else\n+\t{\n+\t  OP (0) = transcode_memory_rtx (OP (0), BC, insn);\n+\t  OP (1) = transcode_memory_rtx (OP (1), HL, insn);\n+\t}\n     }\n \n   MAYBE_OK (insn);\n \n-  OP(0) = move_from_acc (OP(0), insn);\n+  OP (0) = move_from_acc (0, insn);\n \n   MAYBE_OK (insn);\n \n   /* Try copying the src to acc first, then.  This is for, for\n      example, ZERO_EXTEND or NOT.  */\n-  OP(1) = move_to_acc (1, insn);\n+  OP (1) = move_to_acc (1, insn);\n \n-  MAYBE_OK (insn);\n+  MUST_BE_OK (insn);\n+}\n+\n+/* Returns true if operand OPNUM contains a constraint of type CONSTRAINT.\n+   Assumes that the current insn has already been recognised and hence the\n+   constraint data has been filled in.  */\n+static bool\n+has_constraint (unsigned int opnum, enum constraint_num constraint)\n+{\n+  const char * p = recog_data.constraints[opnum];\n+\n+  /* No constraints means anything is accepted.  */\n+  if (p == NULL || *p == 0 || *p == ',')\n+    return true;\n+ \n+  do\n+    {\n+      char c;\n+      unsigned int len;\n \n-  FAILED;\n+      c = *p;\n+      len = CONSTRAINT_LEN (c, p);\n+      gcc_assert (len > 0);\n+\n+      switch (c)\n+\t{\n+\tcase 0:\n+\tcase ',':\n+\t  return false;\n+\tdefault:\n+\t  if (lookup_constraint (p) == constraint)\n+\t    return true;\n+\t}\n+      p += len;\n+    }\n+  while (1);\n }\n \n-/* Devirtualize an insn of the form (SET (op) (unop (op) (op))).  */\n+/* Devirtualize an insn of the form (SET (op) (binop (op) (op))).  */\n static void\n rl78_alloc_physical_registers_op2 (rtx insn)\n {\n-  /* op[0] = op[1] func op[2] */\n-  rtx prev = prev_nonnote_nondebug_insn (insn);\n+  rtx prev;\n   rtx first;\n   bool hl_used;\n+  int tmp_id;\n+  rtx saved_op1;\n \n-  if (rtx_equal_p (OP(0), OP(1)))\n+  if (rtx_equal_p (OP (0), OP (1)))\n     {\n-      OP(0) =\n-      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n-      prev = next_nonnote_nondebug_insn (prev);\n-      OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n-      prev = prev_nonnote_nondebug_insn (prev);\n+      OP (0) =\n+      OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n+      OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n     }\n-  else if (rtx_equal_p (OP(0), OP(2)))\n+  else if (rtx_equal_p (OP (0), OP (2)))\n     {\n-      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n-      prev = next_nonnote_nondebug_insn (prev);\n-      OP(0) =\n-      OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n-      prev = prev_nonnote_nondebug_insn (prev);\n+      OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n+      OP (0) =\n+      OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n     }\n   else\n     {\n-      OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n-      OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n-      prev = next_nonnote_nondebug_insn (prev);\n-      OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+      OP (0) = transcode_memory_rtx (OP (0), BC, insn);\n+      OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n+      OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n     }\n \n   MAYBE_OK (insn);\n@@ -2110,17 +2609,106 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n       OP (2) = tmp;\n     }\n \n-  /* Make a note of wether (H)L is being used.  It matters\n-     because if OP(2) alsoneeds reloading, then we must take\n+  /* Make a note of whether (H)L is being used.  It matters\n+     because if OP (2) alsoneeds reloading, then we must take\n      care not to corrupt HL.  */\n   hl_used = reg_mentioned_p (L, OP (0)) || reg_mentioned_p (L, OP (1));\n \n-  OP(0) = move_from_acc (OP (0), insn);\n-  OP(1) = move_to_acc (1, insn);\n+  /* If HL is not currently being used and dest == op1 then there are\n+     some possible optimizations available by reloading one of the\n+     operands into HL, before trying to use the accumulator.  */\n+  if (optimize\n+      && ! hl_used\n+      && rtx_equal_p (OP (0), OP (1)))\n+    {\n+      /* If op0 is a Ws1 type memory address then switching the base\n+\t address register to HL might allow us to perform an in-memory\n+\t operation.  (eg for the INCW instruction).\n+\t \n+\t FIXME: Adding the move into HL is costly if this optimization is not\n+\t going to work, so for now, make sure that we know that the new insn will\n+\t match the requirements of the addhi3_real pattern.  Really we ought to\n+\t generate a candidate sequence, test that, and then install it if the\n+\t results are good.  */\n+      if (satisfies_constraint_Ws1 (OP (0))\n+\t  && has_constraint (0, CONSTRAINT_Wh1)\n+\t  && (satisfies_constraint_K (OP (2)) || satisfies_constraint_L (OP (2))))\n+\t{\n+\t  rtx base, index, addend, newbase;\n+\n+\t  characterize_address (XEXP (OP (0), 0), & base, & index, & addend);\n+\t  gcc_assert (index == NULL_RTX);\n+\t  gcc_assert (REG_P (base) && REGNO (base) == SP_REG);\n+\n+\t  /* Ws1 addressing allows an offset of 0, Wh1 addressing requires a non-zero offset.  */\n+\t  if (addend != NULL_RTX)\n+\t    {\n+\t      newbase = gen_and_emit_move (HL, base, insn, true);\n+\t      record_content (newbase, NULL_RTX);\n+\t      newbase = gen_rtx_PLUS (HImode, newbase, addend);\n+      \n+\t      OP (0) = OP (1) = change_address (OP (0), VOIDmode, newbase);\n+\n+\t      /* We do not want to fail here as this means that\n+\t\t we have inserted useless insns into the stream.  */\n+\t      MUST_BE_OK (insn);\n+\t    }\n+\t}\n+      else if (REG_P (OP (0))\n+\t       && satisfies_constraint_Ws1 (OP (2))\n+\t       && has_constraint (2, CONSTRAINT_Wh1))\n+\t{\n+\t  rtx base, index, addend, newbase;\n+\n+\t  characterize_address (XEXP (OP (2), 0), & base, & index, & addend);\n+\t  gcc_assert (index == NULL_RTX);\n+\t  gcc_assert (REG_P (base) && REGNO (base) == SP_REG);\n+\n+\t  /* Ws1 addressing allows an offset of 0, Wh1 addressing requires a non-zero offset.  */\n+\t  if (addend != NULL_RTX)\n+\t    {\n+\t      gen_and_emit_move (HL, base, insn, true);\n+\n+\t      if (REGNO (OP (0)) != X_REG)\n+\t\t{\n+\t\t  OP (1) = move_to_acc (1, insn);\n+\t\t  OP (0) = move_from_acc (0, insn);\n+\t\t}\n+\n+\t      record_content (HL, NULL_RTX);\n+\t      newbase = gen_rtx_PLUS (HImode, HL, addend);\n+      \n+\t      OP (2) = change_address (OP (2), VOIDmode, newbase);\n+\n+\t      /* We do not want to fail here as this means that\n+\t\t we have inserted useless insns into the stream.  */\n+\t      MUST_BE_OK (insn);\n+\t    }\n+\t}\n+    }\n+\n+\n+  OP (0) = move_from_acc (0, insn);\n+\n+  tmp_id = get_max_insn_count ();\n+  saved_op1 = OP (1);\n+\n+  if (rtx_equal_p (OP (1), OP (2)))\n+    OP (2) = OP (1) = move_to_acc (1, insn);\n+  else\n+    OP (1) = move_to_acc (1, insn);\n \n   MAYBE_OK (insn);\n \n-  /* We have to copy op2 to HL, but that involves AX, which\n+  /* If we omitted the move of OP1 into the accumulator (because\n+     it was already there from a previous insn), then force the\n+     generation of the move instruction now.  We know that we\n+     are about to emit a move into HL (or DE) via AX, and hence\n+     our optimization to remove the load of OP1 is no longer valid.  */\n+  if (tmp_id == get_max_insn_count ())\n+    force_into_acc (saved_op1, insn);\n+\n+  /* We have to copy op2 to HL (or DE), but that involves AX, which\n      already has a live value.  Emit it before those insns.  */\n \n   if (prev)\n@@ -2131,89 +2719,160 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n \n   OP (2) = hl_used ? move_to_de (2, first) : move_to_hl (2, first);\n   \n-  MAYBE_OK (insn);\n-  \n-  FAILED;\n+  MUST_BE_OK (insn);\n }\n \n-/* Devirtualize an insn of the form (SET () (unop (op))).  */\n+/* Devirtualize an insn of the form SET (PC) (MEM/REG).  */\n \n static void\n rl78_alloc_physical_registers_ro1 (rtx insn)\n {\n-  /* (void) op[0] */\n-  OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n+  OP (0) = transcode_memory_rtx (OP (0), BC, insn);\n \n   MAYBE_OK (insn);\n \n-  OP(0) = move_to_acc (0, insn);\n-\n-  MAYBE_OK (insn);\n+  OP (0) = move_to_acc (0, insn);\n \n-  FAILED;\n+  MUST_BE_OK (insn);\n }\n \n /* Devirtualize a compare insn.  */\n+\n static void\n rl78_alloc_physical_registers_cmp (rtx insn)\n {\n-  /* op[1] cmp_op[0] op[2] */\n+  int tmp_id;\n+  rtx saved_op1;\n   rtx prev = prev_nonnote_nondebug_insn (insn);\n   rtx first;\n \n-  OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n-  OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+  OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n+  OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n \n+  /* HI compares have to have OP(1) in AX, but QI\n+     compares do not, so it is worth checking here.  */\n   MAYBE_OK (insn);\n \n-  OP(1) = move_to_acc (1, insn);\n+  /* For an HImode compare, OP(1) must always be in AX.\n+     But if OP(1) is a REG (and not AX), then we can avoid\n+     a reload of OP(1) if we reload OP(2) into AX and invert\n+     the comparison.  */\n+  if (REG_P (OP (1))\n+      && REGNO (OP (1)) != AX_REG\n+      && GET_MODE (OP (1)) == HImode\n+      && MEM_P (OP (2)))\n+    {\n+      rtx cmp = XEXP (SET_SRC (PATTERN (insn)), 0);\n+\n+      OP (2) = move_to_acc (2, insn);\n+\n+      switch (GET_CODE (cmp))\n+\t{\n+\tcase EQ:\n+\tcase NE:\n+\t  break;\n+\tcase LTU: cmp = gen_rtx_GTU (HImode, OP (2), OP (1)); break;\n+\tcase GTU: cmp = gen_rtx_LTU (HImode, OP (2), OP (1)); break;\n+\tcase LEU: cmp = gen_rtx_GEU (HImode, OP (2), OP (1)); break;\n+\tcase GEU: cmp = gen_rtx_LEU (HImode, OP (2), OP (1)); break;\n+\n+\tcase LT:\n+\tcase GT:\n+\tcase LE:\n+\tcase GE:\n+#if DEBUG_ALLOC\n+\t  debug_rtx (insn);\n+#endif\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      \n+      if (GET_CODE (cmp) == EQ || GET_CODE (cmp) == NE)\n+\tPATTERN (insn) = gen_cbranchhi4_real (cmp, OP (2), OP (1), OP (3));\n+      else\n+\tPATTERN (insn) = gen_cbranchhi4_real_inverted (cmp, OP (2), OP (1), OP (3));\n+\n+      MUST_BE_OK (insn);\n+    }\n+\n+  /* Surprisingly, gcc can generate a comparison of a register with itself, but this\n+     should be handled by the second alternative of the cbranchhi_real pattern.  */\n+  if (rtx_equal_p (OP (1), OP (2)))\n+    {\n+      OP (1) = OP (2) = BC;\n+      MUST_BE_OK (insn);\n+    }\n+  \n+  tmp_id = get_max_insn_count ();\n+  saved_op1 = OP (1);\n+\n+  OP (1) = move_to_acc (1, insn);\n \n   MAYBE_OK (insn);\n \n+  /* If we omitted the move of OP1 into the accumulator (because\n+     it was already there from a previous insn), then force the\n+     generation of the move instruction now.  We know that we\n+     are about to emit a move into HL via AX, and hence our\n+     optimization to remove the load of OP1 is no longer valid.  */\n+  if (tmp_id == get_max_insn_count ())\n+    force_into_acc (saved_op1, insn);\n+\n   /* We have to copy op2 to HL, but that involves the acc, which\n      already has a live value.  Emit it before those insns.  */\n-\n   if (prev)\n     first = next_nonnote_nondebug_insn (prev);\n   else\n     for (first = insn; prev_nonnote_nondebug_insn (first); first = prev_nonnote_nondebug_insn (first))\n       ;\n-  OP(2) = move_to_hl (2, first);\n+  OP (2) = move_to_hl (2, first);\n \n-  MAYBE_OK (insn);\n-\n-  FAILED;\n+  MUST_BE_OK (insn);\n }\n \n /* Like op2, but AX = A op X.  */\n+\n static void\n rl78_alloc_physical_registers_umul (rtx insn)\n {\n-  /* op[0] = op[1] func op[2] */\n   rtx prev = prev_nonnote_nondebug_insn (insn);\n   rtx first;\n+  int tmp_id;\n+  rtx saved_op1;\n \n-  OP(0) = transcode_memory_rtx (OP(0), BC, insn);\n-  OP(1) = transcode_memory_rtx (OP(1), DE, insn);\n-  OP(2) = transcode_memory_rtx (OP(2), HL, insn);\n+  OP (0) = transcode_memory_rtx (OP (0), BC, insn);\n+  OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n+  OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n \n   MAYBE_OK (insn);\n \n   if (recog_data.constraints[1][0] == '%'\n-      && is_virtual_register (OP(1))\n-      && !is_virtual_register (OP(2))\n-      && !CONSTANT_P (OP(2)))\n+      && is_virtual_register (OP (1))\n+      && !is_virtual_register (OP (2))\n+      && !CONSTANT_P (OP (2)))\n     {\n-      rtx tmp = OP(1);\n-      OP(1) = OP(2);\n-      OP(2) = tmp;\n+      rtx tmp = OP (1);\n+      OP (1) = OP (2);\n+      OP (2) = tmp;\n     }\n \n-  OP(0) = move_from_acc (OP(0), insn);\n-  OP(1) = move_to_acc (1, insn);\n+  OP (0) = move_from_acc (0, insn);\n+\n+  tmp_id = get_max_insn_count ();\n+  saved_op1 = OP (1);\n+  \n+  OP (1) = move_to_acc (1, insn);\n \n   MAYBE_OK (insn);\n \n+  /* If we omitted the move of OP1 into the accumulator (because\n+     it was already there from a previous insn), then force the\n+     generation of the move instruction now.  We know that we\n+     are about to emit a move into HL (or DE) via AX, and hence\n+     our optimization to remove the load of OP1 is no longer valid.  */\n+  if (tmp_id == get_max_insn_count ())\n+    force_into_acc (saved_op1, insn);\n+\n   /* We have to copy op2 to X, but that involves the acc, which\n      already has a live value.  Emit it before those insns.  */\n \n@@ -2222,11 +2881,65 @@ rl78_alloc_physical_registers_umul (rtx insn)\n   else\n     for (first = insn; prev_nonnote_nondebug_insn (first); first = prev_nonnote_nondebug_insn (first))\n       ;\n-  OP(2) = move_to_x (2, first);\n+  OP (2) = move_to_x (2, first);\n+\n+  MUST_BE_OK (insn);\n+}\n+\n+static void\n+rl78_alloc_address_registers_macax (rtx insn)\n+{\n+  int which, op;\n+  bool replace_in_op0 = false;\n+  bool replace_in_op1 = false;\n \n   MAYBE_OK (insn);\n \n-  FAILED;\n+  /* Two different MEMs are not allowed.  */\n+  which = 0;\n+  for (op = 2; op >= 0; op --)\n+    {\n+      if (MEM_P (OP (op)))\n+\t{\n+\t  if (op == 0 && replace_in_op0)\n+\t    continue;\n+\t  if (op == 1 && replace_in_op1)\n+\t    continue;\n+\n+\t  switch (which)\n+\t    {\n+\t    case 0:\n+\t      /* If we replace a MEM, make sure that we replace it for all\n+\t\t occurrences of the same MEM in the insn.  */\n+\t      replace_in_op0 = (op > 0 && rtx_equal_p (OP (op), OP (0)));\n+\t      replace_in_op1 = (op > 1 && rtx_equal_p (OP (op), OP (1)));\n+\n+\t      OP (op) = transcode_memory_rtx (OP (op), HL, insn);\n+\t      if (op == 2\n+\t\t  && MEM_P (OP (op))\n+\t\t  && (REGNO (XEXP (OP (op), 0)) == SP_REG\n+\t\t      || (GET_CODE (XEXP (OP (op), 0)) == PLUS\n+\t\t\t  && REGNO (XEXP (XEXP (OP (op), 0), 0)) == SP_REG)))\n+\t\t{\n+\t\t  emit_insn_before (gen_movhi (HL, gen_rtx_REG (HImode, SP_REG)), insn);\n+\t\t  OP (op) = replace_rtx (OP (op), gen_rtx_REG (HImode, SP_REG), HL);\n+\t\t}\n+\t      if (replace_in_op0)\n+\t\tOP (0) = OP (op);\n+\t      if (replace_in_op1)\n+\t\tOP (1) = OP (op);\n+\t      break;\n+\t    case 1:\n+\t      OP (op) = transcode_memory_rtx (OP (op), DE, insn);\n+\t      break;\n+\t    case 2:\n+\t      OP (op) = transcode_memory_rtx (OP (op), BC, insn);\n+\t      break;\n+\t    }\n+\t  which ++;\n+\t}\n+    }\n+  MUST_BE_OK (insn);\n }\n \n /* Scan all insns and devirtualize them.  */\n@@ -2266,23 +2979,46 @@ rl78_alloc_physical_registers (void)\n   cfun->machine->virt_insns_ok = 0;\n   cfun->machine->real_insns_ok = 1;\n \n+  clear_content_memory ();\n+\n   for (insn = get_insns (); insn; insn = curr)\n     {\n+      rtx pattern;\n+\n       curr = insn ? next_nonnote_nondebug_insn (insn) : NULL;\n \n       if (!INSN_P (insn))\n-\tcontinue;\n-      if (GET_CODE (PATTERN (insn)) != SET\n-\t  && GET_CODE (PATTERN (insn)) != CALL)\n-\t  continue;\n+\t{\n+\t  if (LABEL_P (insn))\n+\t    clear_content_memory ();\n+\t    \n+ \t  continue;\n+\t}\n \n-      if (GET_CODE (PATTERN (insn)) == SET\n-\t  && GET_CODE (SET_SRC (PATTERN (insn))) == ASM_OPERANDS)\n+      if (dump_file)\n+\tfprintf (dump_file, \"Converting insn %d\\n\", INSN_UID (insn));\n+\n+      pattern = PATTERN (insn);\n+      if (GET_CODE (pattern) == PARALLEL)\n+\tpattern = XVECEXP (pattern, 0, 0);\n+      if (JUMP_P (insn) || CALL_P (insn) || GET_CODE (pattern) == CALL)\n+\tclear_content_memory ();\n+      if (GET_CODE (pattern) != SET\n+\t  && GET_CODE (pattern) != CALL)\n+\tcontinue;\n+      if (GET_CODE (SET_SRC (pattern)) == ASM_OPERANDS)\n \tcontinue;\n \n       valloc_method = get_attr_valloc (insn);\n \n-      PATTERN (insn)= copy_rtx_if_shared (PATTERN (insn));\n+      PATTERN (insn) = copy_rtx_if_shared (PATTERN (insn));\n+\n+      if (valloc_method == VALLOC_MACAX)\n+\t{\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  record_content (DE, NULL_RTX);\n+\t}\n \n       if (insn_ok_now (insn))\n \tcontinue;\n@@ -2312,9 +3048,18 @@ rl78_alloc_physical_registers (void)\n \t  rl78_alloc_physical_registers_umul (insn);\n \t  break;\n \tcase VALLOC_MACAX:\n-\t  /* Macro that clobbers AX */\n+\t  /* Macro that clobbers AX.  */\n+\t  rl78_alloc_address_registers_macax (insn);\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  record_content (DE, NULL_RTX);\n \t  break;\n \t}\n+\n+      if (JUMP_P (insn) || CALL_P (insn) || GET_CODE (pattern) == CALL)\n+\tclear_content_memory ();\n+      else\n+\tprocess_postponed_content_update ();\n     }\n #if DEBUG_ALLOC\n   fprintf (stderr, \"\\033[0m\");\n@@ -2426,7 +3171,7 @@ rl78_calculate_death_notes (void)\n \t  fprintf (dump_file, \"\\nDead:\");\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i ++)\n \t    if (dead[i])\n-\t      fprintf(dump_file, \" %s\", reg_names[i]);\n+\t      fprintf (dump_file, \" %s\", reg_names[i]);\n \t  fprintf (dump_file, \"\\n\");\n \t  print_rtl_single (dump_file, insn);\n \t}\n@@ -2651,13 +3396,13 @@ rl78_propogate_register_origins (void)\n \t\t      }\n \t\t}\n \n-\t      /* Special case - our ADDSI3 macro uses AX */\n+\t      /* Special case - our ADDSI3 macro uses AX and sometimes BC.  */\n \t      if (get_attr_valloc (insn) == VALLOC_MACAX)\n \t\t{\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Resetting origin of AX for macro.\\n\");\n+\t\t    fprintf (dump_file, \"Resetting origin of AX/BC for macro.\\n\");\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    if (i <= 1 || origins[i] <= 1)\n+\t\t    if (i <= 3 || origins[i] <= 3)\n \t\t      {\n \t\t\torigins[i] = i;\n \t\t\tage[i] = 0;\n@@ -2712,13 +3457,15 @@ rl78_remove_unused_sets (void)\n     }\n }\n \n-#undef  xTARGET_MACHINE_DEPENDENT_REORG\n-#define xTARGET_MACHINE_DEPENDENT_REORG  rl78_reorg\n-\n /* This is the top of the devritualization pass.  */\n static void\n rl78_reorg (void)\n {\n+  /* split2 only happens when optimizing, but we need all movSIs to be\n+     split now.  */\n+  if (optimize <= 0)\n+    split_all_insns ();\n+\n   rl78_alloc_physical_registers ();\n \n   if (dump_file)\n@@ -2753,7 +3500,7 @@ rl78_reorg (void)\n     df_analyze ();\n }\n \n-#undef TARGET_RETURN_IN_MEMORY\n+#undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY rl78_return_in_memory\n \n static bool\n@@ -2763,6 +3510,63 @@ rl78_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   return (size == -1 || size > 8);\n }\n \n+\f\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS rl78_rtx_costs\n+\n+static bool rl78_rtx_costs (rtx   x,\n+\t\t\t    int   code,\n+\t\t\t    int   outer_code ATTRIBUTE_UNUSED,\n+\t\t\t    int   opno ATTRIBUTE_UNUSED,\n+\t\t\t    int * total,\n+\t\t\t    bool  speed ATTRIBUTE_UNUSED)\n+{\n+  if (code == IF_THEN_ELSE)\n+    return COSTS_N_INSNS (10);\n+  if (GET_MODE (x) == SImode)\n+    {\n+      switch (code)\n+\t{\n+\tcase MULT:\n+\t  if (RL78_MUL_RL78)\n+\t    *total = COSTS_N_INSNS (14);\n+\t  else if (RL78_MUL_G13)\n+\t    *total = COSTS_N_INSNS (29);\n+\t  else\n+\t    *total = COSTS_N_INSNS (500);\n+\t  return true;\n+\tcase PLUS:\n+\t  *total = COSTS_N_INSNS (8);\n+\t  return true;\n+\tcase ASHIFT:\n+\tcase ASHIFTRT:\n+\tcase LSHIFTRT:\n+\t  if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    {\n+\t      switch (INTVAL (XEXP (x, 1)))\n+\t\t{\n+\t\tcase 0:  *total = COSTS_N_INSNS (0);\tbreak;\n+\t\tcase 1:  *total = COSTS_N_INSNS (6);\tbreak;\n+\t\tcase 2: case 3: case 4: case 5: case 6: case 7:\n+\t\t  *total = COSTS_N_INSNS (10); break;\n+\t\tcase 8:  *total = COSTS_N_INSNS (6);\tbreak;\n+\t\tcase 9: case 10: case 11: case 12: case 13: case 14: case 15:\n+\t\t  *total = COSTS_N_INSNS (10); break;\n+\t\tcase 16: *total = COSTS_N_INSNS (3);\tbreak;\n+\t\tcase 17: case 18: case 19: case 20: case 21: case 22: case 23:\n+\t\t  *total = COSTS_N_INSNS (4); break;\n+\t\tcase 24: *total = COSTS_N_INSNS (4);\tbreak;\n+\t\tcase 25: case 26: case 27: case 28: case 29: case 30: case 31:\n+\t\t  *total = COSTS_N_INSNS (5); break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    *total = COSTS_N_INSNS (10+4*16);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n \f\n \n #undef  TARGET_UNWIND_WORD_MODE"}, {"sha": "314c37e5c6d14b66cb82bbb10a31593bde925f31", "filename": "gcc/config/rl78/rl78.md", "status": "modified", "additions": 70, "deletions": 27, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3d9d17aaee8c46c94b73916859dbf05693c082/gcc%2Fconfig%2Frl78%2Frl78.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.md?ref=3e3d9d17aaee8c46c94b73916859dbf05693c082", "patch": "@@ -35,7 +35,7 @@\n \n    (FP_REG 22)\n    (SP_REG 32)\n-   (CC_REG 33)\n+   (CC_REG 34)\n    (ES_REG 35)\n    (CS_REG 36)\n \n@@ -205,33 +205,76 @@\n ;; efficient than anything else.\n \n (define_expand \"addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n-\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n-\t\t (match_operand    2 \"nonmemory_operand\" \"vi\")))\n+  [(set (match_operand:SI          0 \"nonimmediate_operand\" \"=&vm\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\"      \"vim\")\n+\t\t (match_operand    2 \"general_operand\"      \"vim\")))\n    ]\n   \"\"\n-  \"if (!nonmemory_operand (operands[1], SImode))\n-     operands[1] = force_reg (SImode, operands[1]);\n-   if (!nonmemory_operand (operands[1], SImode))\n-     operands[2] = force_reg (SImode, operands[2]);\"\n+  \"emit_insn (gen_addsi3_internal_virt (operands[0], operands[1], operands[2]));\n+   DONE;\"\n )\n \n-(define_insn \"addsi3_internal\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n-\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+(define_insn \"addsi3_internal_virt\"\n+  [(set (match_operand:SI          0 \"nonimmediate_operand\" \"=v,&vm, vm\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\"      \"0, vim, vim\")\n+\t\t (match_operand    2 \"general_operand\"      \"vim,vim,vim\")))\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n    ]\n+  \"rl78_virt_insns_ok ()\"\n   \"\"\n-  \"; addSI macro %0 = %1 + %2\n-\tmovw\tax, %h1\n-\taddw\tax, %h2\n-\tmovw\t%h0, ax\n-\tmovw\tax,%H1\n-\tsknc\n-\tincw\tax\n-\taddw\tax,%H2\n-\tmovw\t%H0,ax\n-\t; end of addSI macro\"\n+  [(set_attr \"valloc\" \"macax\")]\n+)\n+\n+(define_insn \"addsi3_internal_real\"\n+  [(set (match_operand:SI          0 \"nonimmediate_operand\" \"=v,&vU, vU\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\"      \"+0, viU, viU\")\n+\t\t (match_operand    2 \"general_operand\"      \"viWabWhlWh1,viWabWhlWh1,viWabWhlWh1\")))\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   movw ax,%h1 \\;addw ax,%h2 \\;movw %h0, ax \\;movw ax,%H1 \\;sknc \\;incw ax \\;addw ax,%H2 \\;movw %H0,ax\n+   movw ax,%h1 \\;addw ax,%h2 \\;movw %h0, ax \\;movw ax,%H1 \\;sknc \\;incw ax \\;addw ax,%H2 \\;movw %H0,ax\n+   movw ax,%h1 \\;addw ax,%h2 \\;movw bc,  ax \\;movw ax,%H1 \\;sknc \\;incw ax \\;addw ax,%H2 \\;movw %H0,ax \\;movw ax,bc \\;movw %h0, ax\"\n+  [(set_attr \"valloc\" \"macax\")]\n+)\n+\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI           0 \"nonimmediate_operand\" \"=&vm\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\"      \"vim\")\n+\t\t  (match_operand    2 \"general_operand\"    \"vim\")))\n+   ]\n+  \"\"\n+  \"emit_insn (gen_subsi3_internal_virt (operands[0], operands[1], operands[2]));\n+  DONE;\"\n+)\n+\n+(define_insn \"subsi3_internal_virt\"\n+  [(set (match_operand:SI           0 \"nonimmediate_operand\" \"=v,&vm, vm\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\"      \"0, vim, vim\")\n+\t\t  (match_operand    2 \"general_operand\"      \"vim,vim,vim\")))\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"\"\n+  [(set_attr \"valloc\" \"macax\")]\n+)\n+\n+(define_insn \"subsi3_internal_real\"\n+  [(set (match_operand:SI           0 \"nonimmediate_operand\" \"=v,&vU, vU\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\"      \"+0, viU, viU\")\n+\t\t  (match_operand    2 \"general_operand\"      \"viWabWhlWh1,viWabWhlWh1,viWabWhlWh1\")))\n+   (clobber (reg:HI AX_REG))\n+   (clobber (reg:HI BC_REG))\n+   ]\n+  \"rl78_real_insns_ok ()\"\n+  \"@\n+   movw ax,%h1 \\;subw ax,%h2 \\;movw %h0, ax \\;movw ax,%H1 \\;sknc \\;decw ax \\;subw ax,%H2 \\;movw %H0,ax\n+   movw ax,%h1 \\;subw ax,%h2 \\;movw %h0, ax \\;movw ax,%H1 \\;sknc \\;decw ax \\;subw ax,%H2 \\;movw %H0,ax\n+   movw ax,%h1 \\;subw ax,%h2 \\;movw bc,  ax \\;movw ax,%H1 \\;sknc \\;decw ax \\;subw ax,%H2 \\;movw %H0,ax \\;movw ax,bc \\;movw %h0, ax\"\n   [(set_attr \"valloc\" \"macax\")]\n )\n \n@@ -255,7 +298,7 @@\n \n (define_expand \"mulsi3\"\n   [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n-\t(mult:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"+vim\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n    ]\n   \"! RL78_MUL_NONE\"\n@@ -319,8 +362,8 @@\n ;; bits of the result).\n (define_insn \"mulsi3_rl78\"\n   [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n-\t(mult:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"+viU\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"vi\")))\n    ]\n   \"RL78_MUL_RL78\"\n   \"; mulsi macro %0 = %1 * %2\n@@ -349,8 +392,8 @@\n ;; Warning: this matches the silicon not the documentation.\n (define_insn \"mulsi3_g13\"\n   [(set (match_operand:SI          0 \"register_operand\" \"=&v\")\n-\t(mult:SI (match_operand:SI 1 \"nonmemory_operand\" \"vi\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"vi\")))\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"viU\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"viU\")))\n    ]\n   \"RL78_MUL_G13\"\n   \"; mulsi macro %0 = %1 * %2"}]}