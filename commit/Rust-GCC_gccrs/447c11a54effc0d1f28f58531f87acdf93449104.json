{"sha": "447c11a54effc0d1f28f58531f87acdf93449104", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3YzExYTU0ZWZmYzBkMWYyOGY1ODUzMWY4N2FjZGY5MzQ0OTEwNA==", "commit": {"author": {"name": "Ovidiu Predescu", "email": "ovidiu@gcc.gnu.org", "date": "2000-08-06T18:54:00Z"}, "committer": {"name": "Ovidiu Predescu", "email": "ovidiu@gcc.gnu.org", "date": "2000-08-06T18:54:00Z"}, "message": "Integrated Chris Ball's <cball@fmco.com> changes to improve the Posix\nthread support for Objective-C.\n\nFrom-SVN: r35533", "tree": {"sha": "f47d9d906353570057a0993a5417c4631a8db12f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f47d9d906353570057a0993a5417c4631a8db12f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/447c11a54effc0d1f28f58531f87acdf93449104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447c11a54effc0d1f28f58531f87acdf93449104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447c11a54effc0d1f28f58531f87acdf93449104", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447c11a54effc0d1f28f58531f87acdf93449104/comments", "author": null, "committer": null, "parents": [{"sha": "137fa4d0bd71478fcc8466b62b689a9ae3dea943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137fa4d0bd71478fcc8466b62b689a9ae3dea943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/137fa4d0bd71478fcc8466b62b689a9ae3dea943"}], "stats": {"total": 69, "additions": 60, "deletions": 9}, "files": [{"sha": "364473dbdaeefb603b7880a2172cb7e16776e0ad", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447c11a54effc0d1f28f58531f87acdf93449104/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447c11a54effc0d1f28f58531f87acdf93449104/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=447c11a54effc0d1f28f58531f87acdf93449104", "patch": "@@ -92,6 +92,7 @@ __gthread_active_p (void)\n \n /* Key structure for maintaining thread specific storage */\n static pthread_key_t _objc_thread_storage;\n+static pthread_attr_t _objc_thread_attribs;\n \n /* Thread local storage for a single thread */\n static void *thread_local_storage = NULL;\n@@ -103,8 +104,19 @@ static inline int\n __gthread_objc_init_thread_system(void)\n {\n   if (__gthread_active_p ())\n-    /* Initialize the thread storage key */\n-    return pthread_key_create(&_objc_thread_storage, NULL);\n+    {\n+      /* Initialize the thread storage key */\n+      if (pthread_key_create(&_objc_thread_storage, NULL) == 0)\n+        {\n+          /* The normal default detach state for threads is\n+           * PTHREAD_CREATE_JOINABLE which causes threads to not die\n+           * when you think they should.  */\n+          if (pthread_attr_init(&_objc_thread_attribs) == 0\n+              && pthread_attr_setdetachstate(&_objc_thread_attribs, \n+                                             PTHREAD_CREATE_DETACHED) == 0)\n+            return 0;\n+        }\n+    }\n   else\n     return -1;\n }\n@@ -113,10 +125,12 @@ __gthread_objc_init_thread_system(void)\n static inline int\n __gthread_objc_close_thread_system(void)\n {\n-  if (__gthread_active_p ())\n+  if (__gthread_active_p ()\n+      && pthread_key_delete(_objc_thread_storage) == 0\n+      && pthread_attr_destroy(&_objc_thread_attribs) == 0)\n     return 0;\n-  else\n-    return -1;\n+\n+  return -1;\n }\n \n /* Backend thread functions */\n@@ -143,17 +157,54 @@ __gthread_objc_thread_detach(void (*func)(void *), void *arg)\n static inline int\n __gthread_objc_thread_set_priority(int priority)\n {\n-  /* Not implemented yet */\n-  return -1;\n+  if (!__gthread_active_p())\n+    return -1;\n+  else {\n+    pthread_t thread_id = pthread_self();\n+    int policy;\n+    struct sched_param params;\n+    int priority_min, priority_max;\n+\n+    if (pthread_getschedparam(thread_id, &policy, &params) == 0)\n+      {\n+        if ((priority_max = sched_get_priority_max(policy)) != 0)\n+          return -1;\n+\n+        if ((priority_min = sched_get_priority_min(policy)) != 0)\n+          return -1;\n+\n+        if (priority > priority_max)\n+          priority = priority_max;\n+        else if (priority < priority_min)\n+          priority = priority_min;\n+        params.sched_priority = priority;\n+\n+        /*\n+         * The solaris 7 and several other man pages incorrectly state that\n+         * this should be a pointer to policy but pthread.h is universally\n+         * at odds with this.\n+         */\n+        if (pthread_setschedparam(thread_id, policy, &params) == 0)\n+          return 0;\n+      }\n+    return -1;\n+  }\n }\n \n /* Return the current thread's priority. */\n static inline int\n __gthread_objc_thread_get_priority(void)\n {\n   if (__gthread_active_p ())\n-    /* Not implemented yet */\n-    return -1;\n+    {\n+      int policy;\n+      struct sched_param params;\n+\n+      if (pthread_getschedparam(pthread_self(), &policy, &params) == 0)\n+        return params.sched_priority;\n+      else\n+        return -1;\n+    }\n   else\n     return OBJC_THREAD_INTERACTIVE_PRIORITY;\n }"}]}