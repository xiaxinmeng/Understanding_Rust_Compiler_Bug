{"sha": "08ff96c3461e6098b4c1102818e4ee10f61b1809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhmZjk2YzM0NjFlNjA5OGI0YzExMDI4MThlNGVlMTBmNjFiMTgwOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-03-01T10:31:33Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-03-01T10:31:33Z"}, "message": "locale_facets.tcc (num_get<>::_M_extract_float): Also when parsing exponent sign, first look for thousands_sep and decimal_point...\n\n2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float):\n\tAlso when parsing exponent sign, first look for thousands_sep\n\tand decimal_point; tweak a bit.\n\t* testsuite/22_locale/num_get/get/char/15.cc: New.\n\t* testsuite/22_locale/num_get/get/wchar_t/15.cc: New.\n\n\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float,\n\tnum_get<>::_M_extract_int): Reorder some conditionals.\n\n2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (money_get<>::_M_extract):\n\tConsistently with numpunct, enforce the requirements in\n\t22.2.6.3, p3 for the thousands separators; tweak a bit.\n\t* testsuite/22_locale/money_get/get/char/15.cc: New.\n\t* testsuite/22_locale/money_get/get/wchar_t/15.cc: New.\n\nFrom-SVN: r78699", "tree": {"sha": "be1c34e4ec7b452a2200f992d00c044f4f2967a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be1c34e4ec7b452a2200f992d00c044f4f2967a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08ff96c3461e6098b4c1102818e4ee10f61b1809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ff96c3461e6098b4c1102818e4ee10f61b1809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ff96c3461e6098b4c1102818e4ee10f61b1809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ff96c3461e6098b4c1102818e4ee10f61b1809/comments", "author": null, "committer": null, "parents": [{"sha": "9a5a17f3dfc1461cf3e6ebb794dfb6e017a75f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5a17f3dfc1461cf3e6ebb794dfb6e017a75f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5a17f3dfc1461cf3e6ebb794dfb6e017a75f02"}], "stats": {"total": 370, "additions": 338, "deletions": 32}, "files": [{"sha": "251c5e00b623afb6a92c82e097f27516b74c83a8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=08ff96c3461e6098b4c1102818e4ee10f61b1809", "patch": "@@ -1,3 +1,22 @@\n+2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float):\n+\tAlso when parsing exponent sign, first look for thousands_sep\n+\tand decimal_point; tweak a bit.\n+\t* testsuite/22_locale/num_get/get/char/15.cc: New.\n+\t* testsuite/22_locale/num_get/get/wchar_t/15.cc: New.\n+\t\n+\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float,\n+\tnum_get<>::_M_extract_int): Reorder some conditionals.\n+\n+2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (money_get<>::_M_extract):\n+\tConsistently with numpunct, enforce the requirements in\n+\t22.2.6.3, p3 for the thousands separators; tweak a bit.\n+\t* testsuite/22_locale/money_get/get/char/15.cc: New.\n+\t* testsuite/22_locale/money_get/get/wchar_t/15.cc: New.\n+\t\n 2004-03-01  David Billinghurst <David.Billinghurst@riotinto.com>\n \n \t* testsuite/lib/libstdc++.exp (v3-list-tests): Use "}, {"sha": "9fb234b03b21841f587f5d7de51aa7f21ce58691", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=08ff96c3461e6098b4c1102818e4ee10f61b1809", "patch": "@@ -184,9 +184,9 @@ namespace std\n \t  const char_type __c = *__beg;\n \t  const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n \t  if ((__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n-\t      && !__traits_type::eq(__c, __lc->_M_decimal_point)\n \t      && (!__lc->_M_use_grouping\n-\t\t  || !__traits_type::eq(__c, __lc->_M_thousands_sep)))\n+\t\t  || !__traits_type::eq(__c, __lc->_M_thousands_sep))\n+\t      && !__traits_type::eq(__c, __lc->_M_decimal_point))\n \t    {\n \t      __xtrc += __plus ? '+' : '-';\n \t      ++__beg;\n@@ -197,9 +197,9 @@ namespace std\n       while (__beg != __end)\n \t{\n \t  const char_type __c = *__beg;\n-\t  if (__traits_type::eq(__c, __lc->_M_decimal_point)\n-\t      || (__lc->_M_use_grouping\n-\t\t  && __traits_type::eq(__c, __lc->_M_thousands_sep)))\n+\t  if (__lc->_M_use_grouping\n+\t      && __traits_type::eq(__c, __lc->_M_thousands_sep)\n+\t      || __traits_type::eq(__c, __lc->_M_decimal_point))\n \t    break;\n \t  else if (__traits_type::eq(__c, __lit[_S_izero]))\n \t    {\n@@ -221,7 +221,6 @@ namespace std\n       if (__lc->_M_use_grouping)\n \t__found_grouping.reserve(32);\n       int __sep_pos = 0;\n-      bool __e;\n       const char_type* __lit_zero = __lit + _S_izero;\n       const char_type* __q;\n       while (__beg != __end)\n@@ -274,22 +273,25 @@ namespace std\n \t      ++__sep_pos;\n \t      ++__beg;\n \t    }\n-\t  else if ((__e = __traits_type::eq(__c, __lit[_S_ie])\n+\t  else if ((__traits_type::eq(__c, __lit[_S_ie])\n \t\t    || __traits_type::eq(__c, __lit[_S_iE]))\n \t\t   && __found_mantissa && !__found_sci)\n \t    {\n \t      // Scientific notation.\n \t      if (__found_grouping.size() && !__found_dec)\n \t\t__found_grouping += static_cast<char>(__sep_pos);\n-\t      __xtrc += __e ? 'e' : 'E';\n+\t      __xtrc += 'e';\n \t      __found_sci = true;\n \n \t      // Remove optional plus or minus sign, if they exist.\n \t      if (++__beg != __end)\n \t\t{\n \t\t  const bool __plus = __traits_type::eq(*__beg,\n \t\t\t\t\t\t\t__lit[_S_iplus]);\n-\t\t  if (__plus || __traits_type::eq(*__beg, __lit[_S_iminus]))\n+\t\t  if ((__plus || __traits_type::eq(*__beg, __lit[_S_iminus]))\n+\t\t      && (!__lc->_M_use_grouping\n+\t\t\t  || !__traits_type::eq(*__beg, __lc->_M_thousands_sep))\n+\t\t      && !__traits_type::eq(*__beg, __lc->_M_decimal_point))\n \t\t    {\n \t\t      __xtrc += __plus ? '+' : '-';\n \t\t      ++__beg;\n@@ -351,9 +353,9 @@ namespace std\n \t    if (numeric_limits<_ValueT>::is_signed)\n \t      __negative = __traits_type::eq(__c, __lit[_S_iminus]);\n \t    if ((__negative || __traits_type::eq(__c, __lit[_S_iplus]))\n-\t\t&& !__traits_type::eq(__c, __lc->_M_decimal_point)\n \t\t&& (!__lc->_M_use_grouping\n-\t\t    || !__traits_type::eq(__c, __lc->_M_thousands_sep)))\n+\t\t    || !__traits_type::eq(__c, __lc->_M_thousands_sep))\n+\t\t&& !__traits_type::eq(__c, __lc->_M_decimal_point))\n \t      ++__beg;\n \t  }\n \n@@ -362,9 +364,9 @@ namespace std\n \twhile (__beg != __end)\n \t  {\n \t    const char_type __c = *__beg;\n-\t    if (__traits_type::eq(__c, __lc->_M_decimal_point)\n-\t\t|| (__lc->_M_use_grouping\n-\t\t    && __traits_type::eq(__c, __lc->_M_thousands_sep)))\n+\t    if (__lc->_M_use_grouping\n+\t\t&& __traits_type::eq(__c, __lc->_M_thousands_sep)\n+\t\t|| __traits_type::eq(__c, __lc->_M_decimal_point))\n \t      break;\n \t    else if (__traits_type::eq(__c, __lit[_S_izero])\n \t\t     && (!__found_num || __base == 10))\n@@ -1201,8 +1203,10 @@ namespace std\n \tstring __grouping_tmp;\n \tif (__lc->_M_use_grouping)\n \t  __grouping_tmp.reserve(32);\n-\t// Marker for thousands_sep position.\n-\tint __sep_pos = 0;\n+\t// Last position before the decimal point.\n+\tint __last_pos = 0;\n+\t// Separator positions, then, possibly, fractional digits.\n+\tint __n = 0;\n \t// If input iterator is in a valid state.\n \tbool __testvalid = true;\n \t// Flag marking when a decimal point is found.\n@@ -1277,26 +1281,23 @@ namespace std\n \t\t  if (__q = __traits_type::find(__lit_zero, 10, *__beg))\n \t\t    {\n \t\t      __res += _S_atoms[__q - __lit];\n-\t\t      ++__sep_pos;\n+\t\t      ++__n;\n \t\t    }\n \t\t  else if (*__beg == __lc->_M_decimal_point && !__testdecfound)\n \t\t    {\n-\t\t      // If no grouping chars are seen, no grouping check\n-\t\t      // is applied. Therefore __grouping_tmp is adjusted\n-\t\t      // only if decimal_point comes after some thousands_sep.\n-\t\t      if (__grouping_tmp.size())\n-\t\t\t__grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t      __sep_pos = 0;\n+\t\t      __last_pos = __n;\n+\t\t      __n = 0;\n \t\t      __testdecfound = true;\n \t\t    }\n \t\t  else if (__lc->_M_use_grouping\n-\t\t\t   && *__beg == __lc->_M_thousands_sep)\n+\t\t\t   && *__beg == __lc->_M_thousands_sep\n+\t\t\t   && !__testdecfound)\n \t\t    {\n-\t\t      if (!__testdecfound)\n+\t\t      if (__n)\n \t\t\t{\n \t\t\t  // Mark position for later analysis.\n-\t\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t\t  __sep_pos = 0;\n+\t\t\t  __grouping_tmp += static_cast<char>(__n);\n+\t\t\t  __n = 0;\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -1350,10 +1351,9 @@ namespace std\n \t    // Test for grouping fidelity.\n \t    if (__grouping_tmp.size())\n \t      {\n-\t\t// Add the ending grouping if a decimal wasn't found.\n-\t\tif (!__testdecfound)\n-\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t\n+\t\t// Add the ending grouping.\n+\t\t__grouping_tmp += static_cast<char>(__testdecfound ? __last_pos\n+\t\t\t\t\t\t                   : __n);\n \t\tif (!std::__verify_grouping(__lc->_M_grouping,\n \t\t\t\t\t    __lc->_M_grouping_size,\n \t\t\t\t\t    __grouping_tmp))\n@@ -1362,7 +1362,7 @@ namespace std\n \t    \n \t    // Iff not enough digits were supplied after the decimal-point.\n \t    if (__testdecfound && __lc->_M_frac_digits > 0\n-\t\t&& __sep_pos != __lc->_M_frac_digits)\n+\t\t&& __n != __lc->_M_frac_digits)\n \t      __testvalid = false;\n \t  }\n \telse"}, {"sha": "a5e766eb45b6b3be6e3e5edb77ed1b61691564c2", "filename": "libstdc++-v3/testsuite/22_locale/money_get/get/char/15.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fchar%2F15.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fchar%2F15.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fchar%2F15.cc?ref=08ff96c3461e6098b4c1102818e4ee10f61b1809", "patch": "@@ -0,0 +1,68 @@\n+// 2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.1.1 money_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// The grammar doesn't allow thousands separator at the beginning of a\n+// string, neither two consecutive thousands separators. \n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef istreambuf_iterator<char> iterator_type;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  locale loc_de = __gnu_test::try_named_locale(\"de_DE@euro\");\n+  VERIFY( loc_c != loc_de );\n+\n+  iterator_type end01, end02;\n+  istringstream iss;\n+  iss.imbue(loc_de);\n+  // cache the money_get facet\n+  const money_get<char>& mon_get = use_facet<money_get<char> >(iss.getloc()); \n+\n+  iss.str(\".100\");\n+  iterator_type is_it01(iss);\n+  long double result1;\n+  ios_base::iostate err01 = ios_base::goodbit;\n+  end01 = mon_get.get(is_it01, end01, true, iss, err01, result1);\n+  VERIFY( err01 == ios_base::failbit );\n+  VERIFY( *end01 == '.' );\n+\n+  iss.str(\"30..0\");\n+  iterator_type is_it02(iss);\n+  long double result2;\n+  ios_base::iostate err02 = ios_base::goodbit;\n+  end02 = mon_get.get(is_it02, end02, false, iss, err02, result2);\n+  VERIFY( err02 == ios_base::failbit );\n+  VERIFY( *end02 == '.' );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "52a4589d1cb2b14f6ffb7575d35d0697c9a4d3a3", "filename": "libstdc++-v3/testsuite/22_locale/money_get/get/wchar_t/15.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fwchar_t%2F15.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fwchar_t%2F15.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fwchar_t%2F15.cc?ref=08ff96c3461e6098b4c1102818e4ee10f61b1809", "patch": "@@ -0,0 +1,69 @@\n+// 2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.1.1 money_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// The grammar doesn't allow thousands separator at the beginning of a\n+// string, neither two consecutive thousands separators. \n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef istreambuf_iterator<wchar_t> iterator_type;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  locale loc_de = __gnu_test::try_named_locale(\"de_DE@euro\");\n+  VERIFY( loc_c != loc_de );\n+\n+  iterator_type end01, end02;\n+  wistringstream iss;\n+  iss.imbue(loc_de);\n+  // cache the money_get facet\n+  const money_get<wchar_t>& mon_get =\n+    use_facet<money_get<wchar_t> >(iss.getloc()); \n+\n+  iss.str(L\".100\");\n+  iterator_type is_it01(iss);\n+  long double result1;\n+  ios_base::iostate err01 = ios_base::goodbit;\n+  end01 = mon_get.get(is_it01, end01, true, iss, err01, result1);\n+  VERIFY( err01 == ios_base::failbit );\n+  VERIFY( *end01 == L'.' );\n+\n+  iss.str(L\"30..0\");\n+  iterator_type is_it02(iss);\n+  long double result2;\n+  ios_base::iostate err02 = ios_base::goodbit;\n+  end02 = mon_get.get(is_it02, end02, false, iss, err02, result2);\n+  VERIFY( err02 == ios_base::failbit );\n+  VERIFY( *end02 == L'.' );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c550181d4894536c340db876a9d40005213a4bf5", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/char/15.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F15.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F15.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F15.cc?ref=08ff96c3461e6098b4c1102818e4ee10f61b1809", "patch": "@@ -0,0 +1,75 @@\n+// 2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct Punct1: std::numpunct<char>\n+{\n+  std::string do_grouping() const { return \"\\1\"; }\n+  char do_thousands_sep() const { return '+'; }\n+};\n+\n+struct Punct2: std::numpunct<char>\n+{\n+  char do_decimal_point() const { return '-'; }\n+};\n+\n+// http://gcc.gnu.org/ml/libstdc++/2003-12/msg00201.html\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  istringstream iss1, iss2;\n+  iss1.imbue(locale(iss1.getloc(), static_cast<numpunct<char>*>(new Punct1)));\n+  iss2.imbue(locale(iss2.getloc(), static_cast<numpunct<char>*>(new Punct2)));\n+  const num_get<char>& ng1 = use_facet<num_get<char> >(iss1.getloc()); \n+  const num_get<char>& ng2 = use_facet<num_get<char> >(iss2.getloc()); \n+\n+  ios_base::iostate err = ios_base::goodbit;\n+  iterator_type end;\n+  double d = 0.0;\n+  double d1 = 1.0;\n+  double d2 = 3.0;\n+  \n+  iss1.str(\"1e+2\");\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, d);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( d == d1 );\n+\n+  iss2.str(\"3e-1\");\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, d);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( d == d2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ef4d7b738d9ae7ec227ee0bc2eb4111b460d5215", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/15.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F15.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ff96c3461e6098b4c1102818e4ee10f61b1809/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F15.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F15.cc?ref=08ff96c3461e6098b4c1102818e4ee10f61b1809", "patch": "@@ -0,0 +1,75 @@\n+// 2004-03-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct Punct1: std::numpunct<wchar_t>\n+{\n+  std::string do_grouping() const { return \"\\1\"; }\n+  wchar_t do_thousands_sep() const { return L'+'; }\n+};\n+\n+struct Punct2: std::numpunct<wchar_t>\n+{\n+  wchar_t do_decimal_point() const { return L'-'; }\n+};\n+\n+// http://gcc.gnu.org/ml/libstdc++/2003-12/msg00201.html\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<wchar_t> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  wistringstream iss1, iss2;\n+  iss1.imbue(locale(iss1.getloc(), static_cast<numpunct<wchar_t>*>(new Punct1)));\n+  iss2.imbue(locale(iss2.getloc(), static_cast<numpunct<wchar_t>*>(new Punct2)));\n+  const num_get<wchar_t>& ng1 = use_facet<num_get<wchar_t> >(iss1.getloc()); \n+  const num_get<wchar_t>& ng2 = use_facet<num_get<wchar_t> >(iss2.getloc()); \n+\n+  ios_base::iostate err = ios_base::goodbit;\n+  iterator_type end;\n+  double d = 0.0;\n+  double d1 = 1.0;\n+  double d2 = 3.0;\n+  \n+  iss1.str(L\"1e+2\");\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, d);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( d == d1 );\n+\n+  iss2.str(L\"3e-1\");\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, d);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( d == d2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}