{"sha": "ec6078e39bea99dc01b635d24db203caf7d26de5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2MDc4ZTM5YmVhOTlkYzAxYjYzNWQyNGRiMjAzY2FmN2QyNmRlNQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-09-05T08:01:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:01:04Z"}, "message": "sem_ch4.adb (Transform_Object_Operation): In a context off the form V (Obj.F)...\n\n2005-09-01  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch4.adb (Transform_Object_Operation): In a context off the form\n\tV (Obj.F), the rewriting does not involve the indexed component, but\n\tonly the selected component itself.\n\tDo not apply the transformation if the analyzed node is an actual of a\n\tcall to another subprogram.\n\t(Complete_Object_Operation): Retain the entity of the\n\tdispatching operation in the selector of the rewritten node. The\n\tentity will be used in the expansion of dispatching selects.\n\t(Analyze_One_Call): Improve location of the error message associated\n\twith interface.\n\t(Analyze_Selected_Component): No need to resolve prefix when it is a\n\tfunction call, resolution is done when parent node is resolved, as\n\tusual.\n\t(Analyze_One_Call): Add a flag to suppress analysis of the first actual,\n\twhen attempting to resolve a call transformed from its object notation.\n\t(Try_Object_Operation, Transform_Object_Operastion): Avoid makind copies\n\tof the argument list for each interpretation of the operation.\n\t(Try_Object_Operation): The designated type of an access parameter may\n\tbe an incomplete type obtained through a limited_with clause, in which\n\tcase the primitive operations of the type are retrieved from its full\n\tview.\n\t(Analyze_Call): If this is an indirect call, and the return type of the\n\taccess_to_subprogram is incomplete, use its full view if available.\n\nFrom-SVN: r103882", "tree": {"sha": "66bcd84806d8f45a940000c3b712a12ca87ecd1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66bcd84806d8f45a940000c3b712a12ca87ecd1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6078e39bea99dc01b635d24db203caf7d26de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6078e39bea99dc01b635d24db203caf7d26de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6078e39bea99dc01b635d24db203caf7d26de5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6078e39bea99dc01b635d24db203caf7d26de5/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173"}], "stats": {"total": 456, "additions": 219, "deletions": 237}, "files": [{"sha": "1f8eb2155c382a254fc001467639b48b2bb63f7d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 219, "deletions": 237, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6078e39bea99dc01b635d24db203caf7d26de5/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6078e39bea99dc01b635d24db203caf7d26de5/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=ec6078e39bea99dc01b635d24db203caf7d26de5", "patch": "@@ -25,7 +25,6 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n@@ -97,10 +96,11 @@ package body Sem_Ch4 is\n    --  arguments, list possible interpretations.\n \n    procedure Analyze_One_Call\n-      (N       : Node_Id;\n-       Nam     : Entity_Id;\n-       Report  : Boolean;\n-       Success : out Boolean);\n+      (N          : Node_Id;\n+       Nam        : Entity_Id;\n+       Report     : Boolean;\n+       Success    : out Boolean;\n+       Skip_First : Boolean := False);\n    --  Check one interpretation of an overloaded subprogram name for\n    --  compatibility with the types of the actuals in a call. If there is a\n    --  single interpretation which does not match, post error if Report is\n@@ -111,6 +111,13 @@ package body Sem_Ch4 is\n    --  subprogram type constructed for an access_to_subprogram. If the actuals\n    --  are compatible with Nam, then Nam is added to the list of candidate\n    --  interpretations for N, and Success is set to True.\n+   --\n+   --  The flag Skip_First is used when analyzing a call that was rewritten\n+   --  from object notation. In this case the first actual may have to receive\n+   --  an explicit dereference, depending on the first formal of the operation\n+   --  being called. The caller will have verified that the object is legal\n+   --  for the call. If the remaining parameters match, the first parameter\n+   --  will rewritten as a dereference if needed, prior to completing analysis.\n \n    procedure Check_Misspelled_Selector\n      (Prefix : Entity_Id;\n@@ -538,15 +545,6 @@ package body Sem_Ch4 is\n          Check_Restriction (No_Local_Allocators, N);\n       end if;\n \n-      --  Ada 2005 (AI-231): Static checks\n-\n-      if Ada_Version >= Ada_05\n-        and then (Null_Exclusion_Present (N)\n-                    or else Can_Never_Be_Null (Etype (N)))\n-      then\n-         Null_Exclusion_Static_Checks (N);\n-      end if;\n-\n       if Serious_Errors_Detected > Sav_Errs then\n          Set_Error_Posted (N);\n          Set_Etype (N, Any_Type);\n@@ -780,6 +778,20 @@ package body Sem_Ch4 is\n \n          Analyze_One_Call (N, Nam_Ent, True, Success);\n \n+         --  If this is an indirect call, the return type of the access_to\n+         --  subprogram may be an incomplete type. At the point of the call,\n+         --  use the full type if available, and at the same time update\n+         --  the return type of the access_to_subprogram.\n+\n+         if Success\n+           and then  Nkind (Nam) = N_Explicit_Dereference\n+           and then Ekind (Etype (N)) = E_Incomplete_Type\n+           and then Present (Full_View (Etype (N)))\n+         then\n+            Set_Etype (N, Full_View (Etype (N)));\n+            Set_Etype (Nam_Ent, Etype (N));\n+         end if;\n+\n       else\n          --  An overloaded selected component must denote overloaded\n          --  operations of a concurrent type. The interpretations are\n@@ -1918,10 +1930,11 @@ package body Sem_Ch4 is\n    ----------------------\n \n    procedure Analyze_One_Call\n-      (N       : Node_Id;\n-       Nam     : Entity_Id;\n-       Report  : Boolean;\n-       Success : out Boolean)\n+      (N          : Node_Id;\n+       Nam        : Entity_Id;\n+       Report     : Boolean;\n+       Success    : out Boolean;\n+       Skip_First : Boolean := False)\n    is\n       Actuals    : constant List_Id   := Parameter_Associations (N);\n       Prev_T     : constant Entity_Id := Etype (N);\n@@ -2104,6 +2117,16 @@ package body Sem_Ch4 is\n \n          Actual := First_Actual (N);\n          Formal := First_Formal (Nam);\n+\n+         --  If we are analyzing a call rewritten from object notation,\n+         --  skip first actual, which may be rewritten later as an\n+         --  explicit dereference.\n+\n+         if Skip_First then\n+            Next_Actual (Actual);\n+            Next_Formal (Formal);\n+         end if;\n+\n          while Present (Actual) and then Present (Formal) loop\n             if Nkind (Parent (Actual)) /= N_Parameter_Association\n               or else Chars (Selector_Name (Parent (Actual))) = Chars (Formal)\n@@ -2134,10 +2157,8 @@ package body Sem_Ch4 is\n                                       (Typ   => Etype (Actual),\n                                        Iface => Etype (Etype (Formal)))\n                      then\n-                        Error_Msg_Name_1 := Chars (Actual);\n-                        Error_Msg_Name_2 := Chars (Etype (Etype (Formal)));\n                         Error_Msg_NE\n-                          (\"(Ada 2005) % does not implement interface %\",\n+                          (\"(Ada 2005) does not implement interface }\",\n                            Actual, Etype (Etype (Formal)));\n                      end if;\n \n@@ -2557,17 +2578,6 @@ package body Sem_Ch4 is\n          return;\n \n       else\n-         --  Function calls that are prefixes of selected components must be\n-         --  fully resolved in case we need to build an actual subtype, or\n-         --  do some other operation requiring a fully resolved prefix.\n-\n-         --  Note: Resolving all Nkinds of nodes here doesn't work.\n-         --  (Breaks 2129-008) ???.\n-\n-         if Nkind (Name) = N_Function_Call then\n-            Resolve (Name);\n-         end if;\n-\n          Prefix_Type := Etype (Name);\n       end if;\n \n@@ -4845,41 +4855,38 @@ package body Sem_Ch4 is\n       Subprog         : constant Node_Id    := Selector_Name (N);\n \n       Actual          : Node_Id;\n-      Call_Node       : Node_Id;\n-      Call_Node_Case  : Node_Id := Empty;\n-      First_Actual    : Node_Id;\n+      New_Call_Node  :  Node_Id := Empty;\n       Node_To_Replace : Node_Id;\n       Obj_Type        : Entity_Id := Etype (Obj);\n \n       procedure Complete_Object_Operation\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id;\n          Subprog         : Node_Id);\n-      --  Set Subprog as the name of Call_Node, replace Node_To_Replace with\n-      --  Call_Node and reanalyze Node_To_Replace.\n+      --  Make Subprog the name of Call_Node, replace Node_To_Replace with\n+      --  Call_Node, insert the object (or its dereference) as the first actual\n+      --  in the call, and complete the analysis of the call.\n \n       procedure Transform_Object_Operation\n         (Call_Node       : out Node_Id;\n-         First_Actual    : Node_Id;\n          Node_To_Replace : out Node_Id;\n          Subprog         : Node_Id);\n-      --  Transform Object.Operation (...) to Operation (Object, ...)\n-      --  Call_Node is the resulting subprogram call node, First_Actual is\n-      --  either the object Obj or an explicit dereference of Obj in certain\n-      --  cases, Node_To_Replace is either N or the parent of N, and Subprog\n-      --  is the subprogram we are trying to match.\n+      --  Transform Obj.Operation (X, Y,,) into Operation (Obj, X, Y ..)\n+      --  Call_Node is the resulting subprogram call,\n+      --  Node_To_Replace is either N or the parent of N, and Subprog\n+      --  is a reference to the subprogram we are trying to match.\n \n       function Try_Class_Wide_Operation\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id) return Boolean;\n-      --  Traverse all the ancestor types looking for a class-wide subprogram\n-      --  that matches Subprog.\n+      --  Traverse all ancestor types looking for a class-wide subprogram\n+      --  for which the current operation is a valid non-dispatching call.\n \n       function Try_Primitive_Operation\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id) return Boolean;\n-      --  Traverse the list of primitive subprograms looking for a subprogram\n-      --  than matches Subprog.\n+      --  Traverse the list of primitive subprograms looking for a dispatching\n+      --  operation for which the current node is a valid call .\n \n       -------------------------------\n       -- Complete_Object_Operation --\n@@ -4890,9 +4897,30 @@ package body Sem_Ch4 is\n          Node_To_Replace : Node_Id;\n          Subprog         : Node_Id)\n       is\n+         First_Actual : Node_Id;\n+\n       begin\n-         Set_Name (Call_Node, New_Copy_Tree (Subprog));\n-         Set_Analyzed (Call_Node, False);\n+         First_Actual := First (Parameter_Associations (Call_Node));\n+         Set_Name (Call_Node, Subprog);\n+\n+         if Nkind (N) = N_Selected_Component\n+           and then not Inside_A_Generic\n+         then\n+            Set_Entity (Selector_Name (N), Entity (Subprog));\n+         end if;\n+\n+         --  If need be, rewrite first actual as an explicit dereference\n+\n+         if not Is_Access_Type (Etype (First_Formal (Entity (Subprog))))\n+           and then Is_Access_Type (Etype (Obj))\n+         then\n+            Rewrite (First_Actual,\n+              Make_Explicit_Dereference (Sloc (Obj), Obj));\n+            Analyze (First_Actual);\n+         else\n+            Rewrite (First_Actual, Obj);\n+         end if;\n+\n          Rewrite (Node_To_Replace, Call_Node);\n          Analyze (Node_To_Replace);\n       end Complete_Object_Operation;\n@@ -4903,51 +4931,45 @@ package body Sem_Ch4 is\n \n       procedure Transform_Object_Operation\n         (Call_Node       : out Node_Id;\n-         First_Actual    : Node_Id;\n          Node_To_Replace : out Node_Id;\n          Subprog         : Node_Id)\n       is\n-         Actuals     : List_Id;\n          Parent_Node : constant Node_Id := Parent (N);\n \n+         Dummy : constant Node_Id := New_Copy (Obj);\n+         --  Placeholder used as a first parameter in the call, replaced\n+         --  eventually by the proper object.\n+\n+         Actuals : List_Id;\n+         Actual  : Node_Id;\n+\n       begin\n-         Actuals := New_List (New_Copy_Tree (First_Actual));\n+         --  Common case covering 1) Call to a procedure and 2) Call to a\n+         --  function that has some additional actuals.\n \n          if (Nkind (Parent_Node) = N_Function_Call\n                or else\n              Nkind (Parent_Node) = N_Procedure_Call_Statement)\n \n-            --  Avoid recursive calls\n+            --  N is a selected component node containing the name of the\n+            --  subprogram. If N is not the name of the parent node we must\n+            --  not replace the parent node by the new construct. This case\n+            --  occurs when N is a parameterless call to a subprogram that\n+            --  is an actual parameter of a call to another subprogram. For\n+            --  example:\n+            --            Some_Subprogram (..., Obj.Operation, ...)\n \n-           and then N /= First (Parameter_Associations (Parent_Node))\n+            and then Name (Parent_Node) = N\n          then\n             Node_To_Replace := Parent_Node;\n \n-            --  Copy list of actuals in full before attempting to resolve call.\n-            --  This is necessary to ensure that the chaining of named actuals\n-            --  that happens during matching is done on a separate copy.\n-\n-            declare\n-               Actual : Node_Id;\n-            begin\n-               Actual := First (Parameter_Associations (Parent_Node));\n-               while Present (Actual) loop\n-                  declare\n-                     New_Actual : constant Node_Id := New_Copy_Tree (Actual);\n-\n-                  begin\n-                     Append (New_Actual, Actuals);\n-\n-                     if Nkind (Actual) = N_Function_Call\n-                       and then Is_Overloaded (Name (Actual))\n-                     then\n-                        Save_Interps (Name (Actual), Name (New_Actual));\n-                     end if;\n-                  end;\n+            Actuals := Parameter_Associations (Parent_Node);\n \n-                  Next (Actual);\n-               end loop;\n-            end;\n+            if Present (Actuals) then\n+               Prepend (Dummy, Actuals);\n+            else\n+               Actuals := New_List (Dummy);\n+            end if;\n \n             if Nkind (Parent_Node) = N_Procedure_Call_Statement then\n                Call_Node :=\n@@ -4956,48 +4978,45 @@ package body Sem_Ch4 is\n                    Parameter_Associations => Actuals);\n \n             else\n-               pragma Assert (Nkind (Parent_Node) = N_Function_Call);\n-\n                Call_Node :=\n                  Make_Function_Call (Loc,\n                    Name => New_Copy_Tree (Subprog),\n                    Parameter_Associations => Actuals);\n \n             end if;\n \n-         --  Before analysis, the function call appears as an\n-         --  indexed component.\n+         --  Before analysis, the function call appears as an indexed component\n+         --  if there are no named associations.\n \n-         elsif Nkind (Parent_Node) =  N_Indexed_Component then\n+         elsif Nkind (Parent_Node) =  N_Indexed_Component\n+           and then N = Prefix (Parent_Node)\n+         then\n             Node_To_Replace := Parent_Node;\n \n-            declare\n-               Actual : Node_Id;\n-               New_Act : Node_Id;\n-            begin\n-               Actual := First (Expressions (Parent_Node));\n-               while Present (Actual) loop\n-                  New_Act := New_Copy_Tree (Actual);\n-                  Analyze (New_Act);\n-                  Append (New_Act, Actuals);\n-                  Next (Actual);\n-               end loop;\n-            end;\n+            Actuals := Expressions (Parent_Node);\n+\n+            Actual := First (Actuals);\n+            while Present (Actual) loop\n+               Analyze (Actual);\n+               Next (Actual);\n+            end loop;\n+\n+            Prepend (Dummy, Actuals);\n \n             Call_Node :=\n                Make_Function_Call (Loc,\n                  Name => New_Copy_Tree (Subprog),\n                  Parameter_Associations => Actuals);\n \n-         --  Parameterless call\n+         --  Parameterless call:  Obj.F is rewritten as F (Obj)\n \n          else\n             Node_To_Replace := N;\n \n             Call_Node :=\n                Make_Function_Call (Loc,\n                  Name => New_Copy_Tree (Subprog),\n-                 Parameter_Associations => Actuals);\n+                 Parameter_Associations => New_List (Dummy));\n          end if;\n       end Transform_Object_Operation;\n \n@@ -5010,16 +5029,20 @@ package body Sem_Ch4 is\n          Node_To_Replace : Node_Id) return Boolean\n       is\n          Anc_Type : Entity_Id;\n-         Dummy    : Node_Id;\n          Hom      : Entity_Id;\n          Hom_Ref  : Node_Id;\n          Success  : Boolean;\n \n       begin\n-         --  Loop through ancestor types, traverse their homonym chains and\n-         --  gather all interpretations of the subprogram.\n+         --  Loop through ancestor types, traverse the homonym chain of the\n+         --  subprogram, and try out those homonyms whose first formal has the\n+         --  class-wide type of the ancestor.\n+\n+         --  Should we verify that it is declared in the same package as the\n+         --  ancestor type ???\n \n          Anc_Type := Obj_Type;\n+\n          loop\n             Hom := Current_Entity (Subprog);\n             while Present (Hom) loop\n@@ -5032,79 +5055,42 @@ package body Sem_Ch4 is\n                then\n                   Hom_Ref := New_Reference_To (Hom, Loc);\n \n-                  --  When both the type of the object and the type of the\n-                  --  first formal of the primitive operation are tagged\n-                  --  access types, we use a node with the object as first\n-                  --  actual.\n-\n-                  if Is_Access_Type (Etype (Obj))\n-                    and then Ekind (Etype (First_Formal (Hom))) =\n-                               E_Anonymous_Access_Type\n-                  then\n-                     --  Allocate the node only once\n-\n-                     if not Present (Call_Node_Case) then\n-                        Analyze_Expression (Obj);\n-                        Set_Analyzed       (Obj);\n-\n-                        Transform_Object_Operation (\n-                          Call_Node       => Call_Node_Case,\n-                          First_Actual    => Obj,\n-                          Node_To_Replace => Dummy,\n-                          Subprog         => Subprog);\n-\n-                        Set_Etype (Call_Node_Case, Any_Type);\n-                        Set_Parent (Call_Node_Case, Parent (Node_To_Replace));\n-                     end if;\n-\n-                     Set_Name (Call_Node_Case, Hom_Ref);\n-\n-                     Analyze_One_Call (\n-                       N       => Call_Node_Case,\n-                       Nam     => Hom,\n-                       Report  => False,\n-                       Success => Success);\n-\n-                     if Success then\n-                        Complete_Object_Operation (\n-                          Call_Node       => Call_Node_Case,\n-                          Node_To_Replace => Node_To_Replace,\n-                          Subprog         => Hom_Ref);\n+                  Set_Etype (Call_Node, Any_Type);\n+                  Set_Parent (Call_Node, Parent (Node_To_Replace));\n \n-                        return True;\n-                     end if;\n+                  Set_Name (Call_Node, Hom_Ref);\n \n-                  --  ??? comment required\n+                  Analyze_One_Call\n+                    (N          => Call_Node,\n+                     Nam        => Hom,\n+                     Report     => False,\n+                     Success    => Success,\n+                     Skip_First => True);\n \n-                  else\n-                     Set_Name (Call_Node, Hom_Ref);\n+                  if Success then\n \n-                     Analyze_One_Call (\n-                       N       => Call_Node,\n-                       Nam     => Hom,\n-                       Report  => False,\n-                       Success => Success);\n+                     --  Reformat into the proper call\n \n-                     if Success then\n-                        Complete_Object_Operation (\n-                          Call_Node       => Call_Node,\n-                          Node_To_Replace => Node_To_Replace,\n-                          Subprog         => Hom_Ref);\n+                     Complete_Object_Operation\n+                       (Call_Node       => Call_Node,\n+                        Node_To_Replace => Node_To_Replace,\n+                        Subprog         => Hom_Ref);\n \n-                        return True;\n-                     end if;\n+                     return True;\n                   end if;\n                end if;\n \n                Hom := Homonym (Hom);\n             end loop;\n \n-            --  Climb to ancestor type if there is one\n+            --  Examine other ancestor types\n \n             exit when Etype (Anc_Type) = Anc_Type;\n             Anc_Type := Etype (Anc_Type);\n          end loop;\n \n+         --  Nothing matched\n+\n          return False;\n       end Try_Class_Wide_Operation;\n \n@@ -5116,84 +5102,76 @@ package body Sem_Ch4 is\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id) return Boolean\n       is\n-         Dummy       : Node_Id;\n          Elmt        : Elmt_Id;\n          Prim_Op     : Entity_Id;\n          Prim_Op_Ref : Node_Id;\n          Success     : Boolean;\n \n-      begin\n-         --  Look for the subprogram in the list of primitive operations\n+         function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n+         --  Verify that the prefix, dereferenced if need be, is a valid\n+         --  controlling argument in a call to Op. The remaining actuals\n+         --  are checked in the subsequent call to Analyze_One_Call.\n \n-         Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n-         while Present (Elmt) loop\n-            Prim_Op := Node (Elmt);\n+         -----------------------------\n+         -- Valid_First_Argument_Of --\n+         -----------------------------\n \n-            if Chars (Prim_Op) = Chars (Subprog)\n-              and then Present (First_Formal (Prim_Op))\n-            then\n-               Prim_Op_Ref := New_Reference_To (Prim_Op, Loc);\n+         function Valid_First_Argument_Of (Op : Entity_Id) return Boolean is\n+            Typ : constant Entity_Id := Etype (First_Formal (Op));\n \n-               --  When both the type of the object and the type of the first\n-               --  formal of the primitive operation are tagged access types,\n-               --  we use a node with the object as first actual.\n+         begin\n+            --  Simple case\n \n-               if Is_Access_Type (Etype (Obj))\n-                 and then Ekind (Etype (First_Formal (Prim_Op))) =\n-                            E_Anonymous_Access_Type\n-               then\n-                  --  Allocate the node only once\n+            return Base_Type (Obj_Type) = Typ\n \n-                  if not Present (Call_Node_Case) then\n-                     Analyze_Expression (Obj);\n-                     Set_Analyzed       (Obj);\n+            --  Prefix can be dereferenced\n \n-                     Transform_Object_Operation (\n-                       Call_Node       => Call_Node_Case,\n-                       First_Actual    => Obj,\n-                       Node_To_Replace => Dummy,\n-                       Subprog         => Subprog);\n+              or else\n+                (Is_Access_Type (Obj_Type)\n+                  and then Designated_Type (Obj_Type) = Typ)\n \n-                     Set_Etype (Call_Node_Case, Any_Type);\n-                     Set_Parent (Call_Node_Case, Parent (Node_To_Replace));\n-                  end if;\n+            --  Formal is an access parameter, for which the object\n+            --  can provide an access.\n \n-                  Set_Name (Call_Node_Case, Prim_Op_Ref);\n+              or else\n+                (Ekind (Typ) = E_Anonymous_Access_Type\n+                  and then Designated_Type (Typ) = Obj_Type);\n+         end Valid_First_Argument_Of;\n \n-                  Analyze_One_Call (\n-                    N       => Call_Node_Case,\n-                    Nam     => Prim_Op,\n-                    Report  => False,\n-                    Success => Success);\n+      --  Start of processing for Try_Primitive_Operation\n \n-                  if Success then\n-                     Complete_Object_Operation (\n-                       Call_Node       => Call_Node_Case,\n-                       Node_To_Replace => Node_To_Replace,\n-                       Subprog         => Prim_Op_Ref);\n+      begin\n+         --  Look for the subprogram in the list of primitive operations\n \n-                     return True;\n-                  end if;\n+         Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n+         while Present (Elmt) loop\n+            Prim_Op := Node (Elmt);\n+\n+            if Chars (Prim_Op) = Chars (Subprog)\n+              and then Present (First_Formal (Prim_Op))\n+              and then Valid_First_Argument_Of (Prim_Op)\n+            then\n+               Prim_Op_Ref := New_Reference_To (Prim_Op, Loc);\n \n-               --  Comment required ???\n+               Set_Etype (Call_Node, Any_Type);\n+               Set_Parent (Call_Node, Parent (Node_To_Replace));\n \n-               else\n-                  Set_Name (Call_Node, Prim_Op_Ref);\n+               Set_Name (Call_Node, Prim_Op_Ref);\n \n-                  Analyze_One_Call (\n-                    N       => Call_Node,\n-                    Nam     => Prim_Op,\n-                    Report  => False,\n-                    Success => Success);\n+               Analyze_One_Call\n+                 (N          => Call_Node,\n+                  Nam        => Prim_Op,\n+                  Report     => False,\n+                  Success    => Success,\n+                  Skip_First => True);\n \n-                  if Success then\n-                     Complete_Object_Operation (\n-                       Call_Node       => Call_Node,\n-                       Node_To_Replace => Node_To_Replace,\n-                       Subprog         => Prim_Op_Ref);\n+               if Success then\n+                  Complete_Object_Operation\n+                    (Call_Node       => Call_Node,\n+                     Node_To_Replace => Node_To_Replace,\n+                     Subprog         => Prim_Op_Ref);\n \n-                     return True;\n-                  end if;\n+                  return True;\n                end if;\n             end if;\n \n@@ -5218,7 +5196,21 @@ package body Sem_Ch4 is\n          Obj_Type := Etype (Class_Wide_Type (Obj_Type));\n       end if;\n \n-      --  Analyze the actuals in case of subprogram call\n+      --  The type may have be obtained through a limited_with clause,\n+      --  in which case the primitive operations are available on its\n+      --  non-limited view.\n+\n+      if Ekind (Obj_Type) = E_Incomplete_Type\n+        and then From_With_Type (Obj_Type)\n+      then\n+         Obj_Type := Non_Limited_View (Obj_Type);\n+      end if;\n+\n+      if not Is_Tagged_Type (Obj_Type) then\n+         return False;\n+      end if;\n+\n+      --  Analyze the actuals if node is know to be a subprogram call\n \n       if Is_Subprg_Call and then N = Name (Parent (N)) then\n          Actual := First (Parameter_Associations (Parent (N)));\n@@ -5228,38 +5220,28 @@ package body Sem_Ch4 is\n          end loop;\n       end if;\n \n-      --  If the object is of an Access type, explicit dereference is\n-      --  required.\n-\n-      if Is_Access_Type (Etype (Obj)) then\n-         First_Actual :=\n-           Make_Explicit_Dereference (Sloc (Obj), Obj);\n-         Set_Etype (First_Actual, Obj_Type);\n-      else\n-         First_Actual := Obj;\n-      end if;\n-\n-      Analyze_Expression (First_Actual);\n-      Set_Analyzed       (First_Actual);\n+      Analyze_Expression (Obj);\n \n-      --  Build a subprogram call node\n+      --  Build a subprogram call node, using a copy of Obj as its first\n+      --  actual. This is a placeholder, to be replaced by an explicit\n+      --  dereference when needed.\n \n-      Transform_Object_Operation (\n-        Call_Node       => Call_Node,\n-        First_Actual    => First_Actual,\n-        Node_To_Replace => Node_To_Replace,\n-        Subprog         => Subprog);\n+      Transform_Object_Operation\n+        (Call_Node       => New_Call_Node,\n+         Node_To_Replace => Node_To_Replace,\n+         Subprog         => Subprog);\n \n-      Set_Etype (Call_Node, Any_Type);\n-      Set_Parent (Call_Node, Parent (Node_To_Replace));\n+      Set_Etype (New_Call_Node, Any_Type);\n+      Set_Parent (New_Call_Node, Parent (Node_To_Replace));\n \n       return\n          Try_Primitive_Operation\n-           (Call_Node       => Call_Node,\n+           (Call_Node       => New_Call_Node,\n             Node_To_Replace => Node_To_Replace)\n+\n         or else\n          Try_Class_Wide_Operation\n-           (Call_Node       => Call_Node,\n+           (Call_Node       => New_Call_Node,\n             Node_To_Replace => Node_To_Replace);\n    end Try_Object_Operation;\n "}]}