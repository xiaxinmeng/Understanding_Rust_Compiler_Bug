{"sha": "7b777afa955ad765500dfd53d6da990c84067197", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I3NzdhZmE5NTVhZDc2NTUwMGRmZDUzZDZkYTk5MGM4NDA2NzE5Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:41:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:41:49Z"}, "message": "poly_int: GET_MODE_NUNITS\n\nThis patch changes GET_MODE_NUNITS from unsigned char\nto poly_uint16, although it remains a macro when compiling\ntarget code with NUM_POLY_INT_COEFFS == 1.\n\nWe can handle permuted loads and stores for variable nunits if\nthe number of statements is a power of 2, but not otherwise.\n\nThe to_constant call in make_vector_type goes away in a later patch.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (mode_nunits): Change from unsigned char to\n\tpoly_uint16_pod.\n\t(ONLY_FIXED_SIZE_MODES): New macro.\n\t(pod_mode::measurement_type, scalar_int_mode::measurement_type)\n\t(scalar_float_mode::measurement_type, scalar_mode::measurement_type)\n\t(complex_mode::measurement_type, fixed_size_mode::measurement_type):\n\tNew typedefs.\n\t(mode_to_nunits): Return a poly_uint16 rather than an unsigned short.\n\t(GET_MODE_NUNITS): Return a constant if ONLY_FIXED_SIZE_MODES,\n\tor if measurement_type is not polynomial.\n\t* genmodes.c (ZERO_COEFFS): New macro.\n\t(emit_mode_nunits_inline): Make mode_nunits_inline return a\n\tpoly_uint16.\n\t(emit_mode_nunits): Change the type of mode_nunits to poly_uint16_pod.\n\tUse ZERO_COEFFS when emitting initializers.\n\t* data-streamer.h (bp_pack_poly_value): New function.\n\t(bp_unpack_poly_value): Likewise.\n\t* lto-streamer-in.c (lto_input_mode_table): Use bp_unpack_poly_value\n\tfor GET_MODE_NUNITS.\n\t* lto-streamer-out.c (lto_write_mode_table): Use bp_pack_poly_value\n\tfor GET_MODE_NUNITS.\n\t* tree.c (make_vector_type): Remove temporary shim and make\n\tthe real function take the number of units as a poly_uint64\n\trather than an int.\n\t(build_vector_type_for_mode): Handle polynomial nunits.\n\t* dwarf2out.c (loc_descriptor, add_const_value_attribute): Likewise.\n\t* emit-rtl.c (const_vec_series_p_1): Likewise.\n\t(gen_rtx_CONST_VECTOR): Likewise.\n\t* fold-const.c (test_vec_duplicate_folding): Likewise.\n\t* genrecog.c (validate_pattern): Likewise.\n\t* optabs-query.c (can_vec_perm_var_p, can_mult_highpart_p): Likewise.\n\t* optabs-tree.c (expand_vec_cond_expr_p): Likewise.\n\t* optabs.c (expand_vector_broadcast, expand_binop_directly): Likewise.\n\t(shift_amt_for_vec_perm_mask, expand_vec_perm_var): Likewise.\n\t(expand_vec_cond_expr, expand_mult_highpart): Likewise.\n\t* rtlanal.c (subreg_get_info): Likewise.\n\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n\t(vect_grouped_load_supported): Likewise.\n\t* tree-vect-generic.c (type_for_widest_vector_mode): Likewise.\n\t* tree-vect-loop.c (have_whole_vector_shift): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\t(simplify_const_unary_operation, simplify_binary_operation_1)\n\t(simplify_const_binary_operation, simplify_ternary_operation)\n\t(test_vector_ops_duplicate, test_vector_ops): Likewise.\n\t(simplify_immed_subreg): Use GET_MODE_NUNITS on a fixed_size_mode\n\tinstead of CONST_VECTOR_NUNITS.\n\t* varasm.c (output_constant_pool_2): Likewise.\n\t* rtx-vector-builder.c (rtx_vector_builder::build): Only include the\n\texplicit-encoded elements in the XVEC for variable-length vectors.\n\ngcc/ada/\n\t* gcc-interface/misc.c (enumerate_modes): Handle polynomial\n\tGET_MODE_NUNITS.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256195", "tree": {"sha": "59c49cc214d86eec3fc81dedbb8c6b6b71dbfcb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59c49cc214d86eec3fc81dedbb8c6b6b71dbfcb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b777afa955ad765500dfd53d6da990c84067197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b777afa955ad765500dfd53d6da990c84067197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b777afa955ad765500dfd53d6da990c84067197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b777afa955ad765500dfd53d6da990c84067197/comments", "author": null, "committer": null, "parents": [{"sha": "e5f83886b05c22f4bc221dac05e64b54ef7eece4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f83886b05c22f4bc221dac05e64b54ef7eece4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f83886b05c22f4bc221dac05e64b54ef7eece4"}], "stats": {"total": 460, "additions": 325, "deletions": 135}, "files": [{"sha": "7a96624c14d5baecee12d051b67431b3c011d995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -1,3 +1,57 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (mode_nunits): Change from unsigned char to\n+\tpoly_uint16_pod.\n+\t(ONLY_FIXED_SIZE_MODES): New macro.\n+\t(pod_mode::measurement_type, scalar_int_mode::measurement_type)\n+\t(scalar_float_mode::measurement_type, scalar_mode::measurement_type)\n+\t(complex_mode::measurement_type, fixed_size_mode::measurement_type):\n+\tNew typedefs.\n+\t(mode_to_nunits): Return a poly_uint16 rather than an unsigned short.\n+\t(GET_MODE_NUNITS): Return a constant if ONLY_FIXED_SIZE_MODES,\n+\tor if measurement_type is not polynomial.\n+\t* genmodes.c (ZERO_COEFFS): New macro.\n+\t(emit_mode_nunits_inline): Make mode_nunits_inline return a\n+\tpoly_uint16.\n+\t(emit_mode_nunits): Change the type of mode_nunits to poly_uint16_pod.\n+\tUse ZERO_COEFFS when emitting initializers.\n+\t* data-streamer.h (bp_pack_poly_value): New function.\n+\t(bp_unpack_poly_value): Likewise.\n+\t* lto-streamer-in.c (lto_input_mode_table): Use bp_unpack_poly_value\n+\tfor GET_MODE_NUNITS.\n+\t* lto-streamer-out.c (lto_write_mode_table): Use bp_pack_poly_value\n+\tfor GET_MODE_NUNITS.\n+\t* tree.c (make_vector_type): Remove temporary shim and make\n+\tthe real function take the number of units as a poly_uint64\n+\trather than an int.\n+\t(build_vector_type_for_mode): Handle polynomial nunits.\n+\t* dwarf2out.c (loc_descriptor, add_const_value_attribute): Likewise.\n+\t* emit-rtl.c (const_vec_series_p_1): Likewise.\n+\t(gen_rtx_CONST_VECTOR): Likewise.\n+\t* fold-const.c (test_vec_duplicate_folding): Likewise.\n+\t* genrecog.c (validate_pattern): Likewise.\n+\t* optabs-query.c (can_vec_perm_var_p, can_mult_highpart_p): Likewise.\n+\t* optabs-tree.c (expand_vec_cond_expr_p): Likewise.\n+\t* optabs.c (expand_vector_broadcast, expand_binop_directly): Likewise.\n+\t(shift_amt_for_vec_perm_mask, expand_vec_perm_var): Likewise.\n+\t(expand_vec_cond_expr, expand_mult_highpart): Likewise.\n+\t* rtlanal.c (subreg_get_info): Likewise.\n+\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n+\t(vect_grouped_load_supported): Likewise.\n+\t* tree-vect-generic.c (type_for_widest_vector_mode): Likewise.\n+\t* tree-vect-loop.c (have_whole_vector_shift): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\t(simplify_const_unary_operation, simplify_binary_operation_1)\n+\t(simplify_const_binary_operation, simplify_ternary_operation)\n+\t(test_vector_ops_duplicate, test_vector_ops): Likewise.\n+\t(simplify_immed_subreg): Use GET_MODE_NUNITS on a fixed_size_mode\n+\tinstead of CONST_VECTOR_NUNITS.\n+\t* varasm.c (output_constant_pool_2): Likewise.\n+\t* rtx-vector-builder.c (rtx_vector_builder::build): Only include the\n+\texplicit-encoded elements in the XVEC for variable-length vectors.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* lra-constraints.c (curr_insn_transform): Use partial_subreg_p."}, {"sha": "a4f1af0d524b5bc6cdbfef070335fd4011b30317", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/misc.c (enumerate_modes): Handle polynomial\n+\tGET_MODE_NUNITS.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "48add09f9ea105a3d07be687b497d8f8e76c39d4", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -1301,9 +1301,10 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n \t  }\n \n       /* If no predefined C types were found, register the mode itself.  */\n-      if (!skip_p)\n+      int nunits;\n+      if (!skip_p && GET_MODE_NUNITS (i).is_constant (&nunits))\n \tf (GET_MODE_NAME (i), digs, complex_p,\n-\t   vector_p ? GET_MODE_NUNITS (i) : 0, float_rep,\n+\t   vector_p ? nunits : 0, float_rep,\n \t   GET_MODE_PRECISION (i), GET_MODE_BITSIZE (i),\n \t   GET_MODE_ALIGNMENT (i));\n     }"}, {"sha": "3f969d5fa9d633e0534192e9aae0f81ed5fcf3aa", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -126,6 +126,17 @@ bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n   bp->pos = pos;\n }\n \n+/* Pack VAL into the bit-packing context BP, using NBITS for each\n+   coefficient.  */\n+static inline void\n+bp_pack_poly_value (struct bitpack_d *bp,\n+\t\t    const poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t> &val,\n+\t\t    unsigned nbits)\n+{\n+  for (int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    bp_pack_value (bp, val.coeffs[i], nbits);\n+}\n+\n /* Finishes bit-packing of BP.  */\n static inline void\n streamer_write_bitpack (struct bitpack_d *bp)\n@@ -174,6 +185,17 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n   return val & mask;\n }\n \n+/* Unpacks a polynomial value from the bit-packing context BP in which each\n+   coefficient has NBITS bits.  */\n+static inline poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t>\n+bp_unpack_poly_value (struct bitpack_d *bp, unsigned nbits)\n+{\n+  poly_int_pod<NUM_POLY_INT_COEFFS, bitpack_word_t> x;\n+  for (int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    x.coeffs[i] = bp_unpack_value (bp, nbits);\n+  return x;\n+}\n+\n \n /* Write a character to the output block.  */\n "}, {"sha": "2b6e5888a2aafef6496e0213bbb8b5cf86b2d03d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -16010,8 +16010,11 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \n       if (mode != VOIDmode && (dwarf_version >= 4 || !dwarf_strict))\n \t{\n+\t  unsigned int length;\n+\t  if (!CONST_VECTOR_NUNITS (rtl).is_constant (&length))\n+\t    return NULL;\n+\n \t  unsigned int elt_size = GET_MODE_UNIT_SIZE (GET_MODE (rtl));\n-\t  unsigned int length = CONST_VECTOR_NUNITS (rtl);\n \t  unsigned char *array\n \t    = ggc_vec_alloc<unsigned char> (length * elt_size);\n \t  unsigned int i;\n@@ -18817,9 +18820,12 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n     case CONST_VECTOR:\n       {\n+\tunsigned int length;\n+\tif (!CONST_VECTOR_NUNITS (rtl).is_constant (&length))\n+\t  return false;\n+\n \tmachine_mode mode = GET_MODE (rtl);\n \tunsigned int elt_size = GET_MODE_UNIT_SIZE (mode);\n-\tunsigned int length = CONST_VECTOR_NUNITS (rtl);\n \tunsigned char *array\n \t  = ggc_vec_alloc<unsigned char> (length * elt_size);\n \tunsigned int i;"}, {"sha": "626567a7179f55c20ad0b742d2675127c31e2843", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -5987,7 +5987,7 @@ const_vec_series_p_1 (const_rtx x, rtx *base_out, rtx *step_out)\n   /* A non-duplicated vector with two elements can always be seen as a\n      series with a nonzero step.  Longer vectors must have a stepped\n      encoding.  */\n-  if (CONST_VECTOR_NUNITS (x) != 2\n+  if (maybe_ne (CONST_VECTOR_NUNITS (x), 2)\n       && !CONST_VECTOR_STEPPED_P (x))\n     return false;\n \n@@ -6068,7 +6068,7 @@ gen_const_vector (machine_mode mode, int constant)\n rtx\n gen_rtx_CONST_VECTOR (machine_mode mode, rtvec v)\n {\n-  gcc_assert (GET_MODE_NUNITS (mode) == GET_NUM_ELEM (v));\n+  gcc_assert (known_eq (GET_MODE_NUNITS (mode), GET_NUM_ELEM (v)));\n \n   /* If the values are all the same, check to see if we can use one of the\n      standard constant vectors.  */"}, {"sha": "9f558e26c80d944f88b5761c2f598ca86784a8cb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -14625,7 +14625,7 @@ test_vec_duplicate_folding ()\n   scalar_int_mode int_mode = SCALAR_INT_TYPE_MODE (ssizetype);\n   machine_mode vec_mode = targetm.vectorize.preferred_simd_mode (int_mode);\n   /* This will be 1 if VEC_MODE isn't a vector mode.  */\n-  unsigned int nunits = GET_MODE_NUNITS (vec_mode);\n+  poly_uint64 nunits = GET_MODE_NUNITS (vec_mode);\n \n   tree type = build_vector_type (ssizetype, nunits);\n   tree dup5_expr = fold_unary (VEC_DUPLICATE_EXPR, type, ssize_int (5));"}, {"sha": "efcceb32105d5b120cca411c633062f4d6527aed", "filename": "gcc/genmodes.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -901,6 +901,16 @@ calc_wider_mode (void)\n     }\n }\n \n+/* Text to add to the constant part of a poly_int_pod initializer in\n+   order to fill out te whole structure.  */\n+#if NUM_POLY_INT_COEFFS == 1\n+#define ZERO_COEFFS \"\"\n+#elif NUM_POLY_INT_COEFFS == 2\n+#define ZERO_COEFFS \", 0\"\n+#else\n+#error \"Unknown value of NUM_POLY_INT_COEFFS\"\n+#endif\n+\n /* Output routines.  */\n \n #define tagged_printf(FMT, ARG, TAG) do {\t\t\\\n@@ -1008,11 +1018,10 @@ inline __attribute__((__always_inline__))\\n\\\n #else\\n\\\n extern __inline__ __attribute__((__always_inline__, __gnu_inline__))\\n\\\n #endif\\n\\\n-unsigned char\\n\\\n+poly_uint16\\n\\\n mode_nunits_inline (machine_mode mode)\\n\\\n {\\n\\\n-  extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\\n\\\n-  gcc_assert (mode >= 0 && mode < NUM_MACHINE_MODES);\\n\\\n+  extern poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\\n\\\n   switch (mode)\\n\\\n     {\");\n \n@@ -1381,10 +1390,10 @@ emit_mode_nunits (void)\n   int c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned char\", \"mode_nunits\", \"NUM_MACHINE_MODES\");\n+  print_decl (\"poly_uint16_pod\", \"mode_nunits\", \"NUM_MACHINE_MODES\");\n \n   for_all_modes (c, m)\n-    tagged_printf (\"%u\", m->ncomponents, m->name);\n+    tagged_printf (\"{ %u\" ZERO_COEFFS \" }\", m->ncomponents, m->name);\n \n   print_closer ();\n }"}, {"sha": "663df8c58af8e51a38aefe2ee86293a8968aa1ec", "filename": "gcc/genrecog.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -746,14 +746,20 @@ validate_pattern (rtx pattern, md_rtx_info *info, rtx set, int set_code)\n \t    = VECTOR_MODE_P (mode) ? GET_MODE_INNER (mode) : mode;\n \t  if (GET_CODE (XEXP (pattern, 1)) == PARALLEL)\n \t    {\n-\t      int expected = VECTOR_MODE_P (mode) ? GET_MODE_NUNITS (mode) : 1;\n-\t      if (XVECLEN (XEXP (pattern, 1), 0) != expected)\n+\t      int expected = 1;\n+\t      unsigned int nelems;\n+\t      if (VECTOR_MODE_P (mode)\n+\t\t  && !GET_MODE_NUNITS (mode).is_constant (&expected))\n+\t\terror_at (info->loc,\n+\t\t\t  \"vec_select with variable-sized mode %s\",\n+\t\t\t  GET_MODE_NAME (mode));\n+\t      else if (XVECLEN (XEXP (pattern, 1), 0) != expected)\n \t\terror_at (info->loc,\n \t\t\t  \"vec_select parallel with %d elements, expected %d\",\n \t\t\t  XVECLEN (XEXP (pattern, 1), 0), expected);\n-\t      else if (VECTOR_MODE_P (imode))\n+\t      else if (VECTOR_MODE_P (imode)\n+\t\t       && GET_MODE_NUNITS (imode).is_constant (&nelems))\n \t\t{\n-\t\t  unsigned int nelems = GET_MODE_NUNITS (imode);\n \t\t  int i;\n \t\t  for (i = 0; i < expected; ++i)\n \t\t    if (CONST_INT_P (XVECEXP (XEXP (pattern, 1), 0, i))"}, {"sha": "80b5671599856c759e9e8beb55fd7e57c1789489", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -1620,7 +1620,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n       unsigned int size = bp_unpack_value (&bp, 8);\n       unsigned int prec = bp_unpack_value (&bp, 16);\n       machine_mode inner = (machine_mode) bp_unpack_value (&bp, 8);\n-      unsigned int nunits = bp_unpack_value (&bp, 8);\n+      poly_uint16 nunits = bp_unpack_poly_value (&bp, 16);\n       unsigned int ibit = 0, fbit = 0;\n       unsigned int real_fmt_len = 0;\n       const char *real_fmt_name = NULL;\n@@ -1658,7 +1658,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n \t\t  : GET_MODE_INNER (mr) != table[(int) inner])\n \t      || GET_MODE_IBIT (mr) != ibit\n \t      || GET_MODE_FBIT (mr) != fbit\n-\t      || GET_MODE_NUNITS (mr) != nunits)\n+\t      || maybe_ne (GET_MODE_NUNITS (mr), nunits))\n \t    continue;\n \t  else if ((mclass == MODE_FLOAT || mclass == MODE_DECIMAL_FLOAT)\n \t\t   && strcmp (REAL_MODE_FORMAT (mr)->name, real_fmt_name) != 0)"}, {"sha": "0aea7d5eae8ce8fcacab8aa4203484f00cc0b6e5", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -2813,7 +2813,7 @@ lto_write_mode_table (void)\n \t  bp_pack_value (&bp, GET_MODE_SIZE (m), 8);\n \t  bp_pack_value (&bp, GET_MODE_PRECISION (m), 16);\n \t  bp_pack_value (&bp, GET_MODE_INNER (m), 8);\n-\t  bp_pack_value (&bp, GET_MODE_NUNITS (m), 8);\n+\t  bp_pack_poly_value (&bp, GET_MODE_NUNITS (m), 16);\n \t  switch (GET_MODE_CLASS (m))\n \t    {\n \t    case MODE_FRACT:"}, {"sha": "b97e0465ed6ab28f627dc4e520ec7ec54f6a3401", "filename": "gcc/machmode.h", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -25,7 +25,7 @@ typedef opt_mode<machine_mode> opt_machine_mode;\n extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n-extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\n+extern const poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\n extern CONST_MODE_UNIT_SIZE unsigned char mode_unit_size[NUM_MACHINE_MODES];\n extern const unsigned short mode_unit_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n@@ -76,6 +76,14 @@ struct mode_traits<machine_mode>\n   typedef machine_mode from_int;\n };\n \n+/* Always treat machine modes as fixed-size while compiling code specific\n+   to targets that have no variable-size modes.  */\n+#if defined (IN_TARGET_CODE) && NUM_POLY_INT_COEFFS == 1\n+#define ONLY_FIXED_SIZE_MODES 1\n+#else\n+#define ONLY_FIXED_SIZE_MODES 0\n+#endif\n+\n /* Get the name of mode MODE as a string.  */\n \n extern const char * const mode_name[NUM_MACHINE_MODES];\n@@ -313,6 +321,7 @@ template<typename T>\n struct pod_mode\n {\n   typedef typename mode_traits<T>::from_int from_int;\n+  typedef typename T::measurement_type measurement_type;\n \n   machine_mode m_mode;\n   ALWAYS_INLINE operator machine_mode () const { return m_mode; }\n@@ -391,6 +400,7 @@ class scalar_int_mode\n {\n public:\n   typedef mode_traits<scalar_int_mode>::from_int from_int;\n+  typedef unsigned short measurement_type;\n \n   ALWAYS_INLINE scalar_int_mode () {}\n   ALWAYS_INLINE scalar_int_mode (from_int m) : m_mode (machine_mode (m)) {}\n@@ -415,6 +425,7 @@ class scalar_float_mode\n {\n public:\n   typedef mode_traits<scalar_float_mode>::from_int from_int;\n+  typedef unsigned short measurement_type;\n \n   ALWAYS_INLINE scalar_float_mode () {}\n   ALWAYS_INLINE scalar_float_mode (from_int m) : m_mode (machine_mode (m)) {}\n@@ -439,6 +450,7 @@ class scalar_mode\n {\n public:\n   typedef mode_traits<scalar_mode>::from_int from_int;\n+  typedef unsigned short measurement_type;\n \n   ALWAYS_INLINE scalar_mode () {}\n   ALWAYS_INLINE scalar_mode (from_int m) : m_mode (machine_mode (m)) {}\n@@ -480,6 +492,7 @@ class complex_mode\n {\n public:\n   typedef mode_traits<complex_mode>::from_int from_int;\n+  typedef unsigned short measurement_type;\n \n   ALWAYS_INLINE complex_mode () {}\n   ALWAYS_INLINE complex_mode (from_int m) : m_mode (machine_mode (m)) {}\n@@ -570,7 +583,7 @@ mode_to_unit_precision (machine_mode mode)\n \n /* Return the base GET_MODE_NUNITS value for MODE.  */\n \n-ALWAYS_INLINE unsigned short\n+ALWAYS_INLINE poly_uint16\n mode_to_nunits (machine_mode mode)\n {\n #if GCC_VERSION >= 4001\n@@ -627,7 +640,29 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n /* Get the number of units in an object of mode MODE.  This is 2 for\n    complex modes and the number of elements for vector modes.  */\n \n-#define GET_MODE_NUNITS(MODE) (mode_to_nunits (MODE))\n+#if ONLY_FIXED_SIZE_MODES\n+#define GET_MODE_NUNITS(MODE) (mode_to_nunits (MODE).coeffs[0])\n+#else\n+ALWAYS_INLINE poly_uint16\n+GET_MODE_NUNITS (machine_mode mode)\n+{\n+  return mode_to_nunits (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_poly<typename T::measurement_type>::type\n+GET_MODE_NUNITS (const T &mode)\n+{\n+  return mode_to_nunits (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_nonpoly<typename T::measurement_type>::type\n+GET_MODE_NUNITS (const T &mode)\n+{\n+  return mode_to_nunits (mode).coeffs[0];\n+}\n+#endif\n \n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n@@ -660,6 +695,7 @@ class fixed_size_mode\n {\n public:\n   typedef mode_traits<fixed_size_mode>::from_int from_int;\n+  typedef unsigned short measurement_type;\n \n   ALWAYS_INLINE fixed_size_mode () {}\n   ALWAYS_INLINE fixed_size_mode (from_int m) : m_mode (machine_mode (m)) {}"}, {"sha": "cae9c30447fd3fe188874942a783390ecebafa4d", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -391,7 +391,7 @@ can_vec_perm_var_p (machine_mode mode)\n   /* We allow fallback to a QI vector mode, and adjust the mask.  */\n   machine_mode qimode;\n   if (!qimode_for_vec_perm (mode).exists (&qimode)\n-      || GET_MODE_NUNITS (qimode) > GET_MODE_MASK (QImode) + 1)\n+      || maybe_gt (GET_MODE_NUNITS (qimode), GET_MODE_MASK (QImode) + 1))\n     return false;\n \n   if (direct_optab_handler (vec_perm_optab, qimode) == CODE_FOR_nothing)\n@@ -498,7 +498,6 @@ int\n can_mult_highpart_p (machine_mode mode, bool uns_p)\n {\n   optab op;\n-  unsigned i, nunits;\n \n   op = uns_p ? umul_highpart_optab : smul_highpart_optab;\n   if (optab_handler (op, mode) != CODE_FOR_nothing)\n@@ -508,7 +507,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n   if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n     return 0;\n \n-  nunits = GET_MODE_NUNITS (mode);\n+  poly_int64 nunits = GET_MODE_NUNITS (mode);\n \n   op = uns_p ? vec_widen_umult_even_optab : vec_widen_smult_even_optab;\n   if (optab_handler (op, mode) != CODE_FOR_nothing)\n@@ -518,7 +517,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n \t{\n \t  /* The encoding has 2 interleaved stepped patterns.  */\n \t  vec_perm_builder sel (nunits, 2, 3);\n-\t  for (i = 0; i < 6; ++i)\n+\t  for (unsigned int i = 0; i < 6; ++i)\n \t    sel.quick_push (!BYTES_BIG_ENDIAN\n \t\t\t    + (i & ~1)\n \t\t\t    + ((i & 1) ? nunits : 0));\n@@ -536,7 +535,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n \t{\n \t  /* The encoding has a single stepped pattern.  */\n \t  vec_perm_builder sel (nunits, 1, 3);\n-\t  for (int i = 0; i < 3; ++i)\n+\t  for (unsigned int i = 0; i < 3; ++i)\n \t    sel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n \t  vec_perm_indices indices (sel, 2, nunits);\n \t  if (can_vec_perm_const_p (mode, indices))"}, {"sha": "69448cf82eba2b14e014b7e86bbd5c439a2c4bdc", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -328,7 +328,7 @@ expand_vec_cond_expr_p (tree value_type, tree cmp_op_type, enum tree_code code)\n     return true;\n \n   if (GET_MODE_SIZE (value_mode) != GET_MODE_SIZE (cmp_op_mode)\n-      || GET_MODE_NUNITS (value_mode) != GET_MODE_NUNITS (cmp_op_mode))\n+      || maybe_ne (GET_MODE_NUNITS (value_mode), GET_MODE_NUNITS (cmp_op_mode)))\n     return false;\n \n   if (get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),"}, {"sha": "5a85d78861f213b1facee86b9af94ae076949417", "filename": "gcc/optabs.c", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -371,17 +371,15 @@ force_expand_binop (machine_mode mode, optab binoptab,\n rtx\n expand_vector_broadcast (machine_mode vmode, rtx op)\n {\n-  enum insn_code icode;\n+  int n;\n   rtvec vec;\n-  rtx ret;\n-  int i, n;\n \n   gcc_checking_assert (VECTOR_MODE_P (vmode));\n \n   if (valid_for_const_vector_p (vmode, op))\n     return gen_const_vec_duplicate (vmode, op);\n \n-  icode = optab_handler (vec_duplicate_optab, vmode);\n+  insn_code icode = optab_handler (vec_duplicate_optab, vmode);\n   if (icode != CODE_FOR_nothing)\n     {\n       struct expand_operand ops[2];\n@@ -391,6 +389,9 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n       return ops[0].value;\n     }\n \n+  if (!GET_MODE_NUNITS (vmode).is_constant (&n))\n+    return NULL;\n+\n   /* ??? If the target doesn't have a vec_init, then we have no easy way\n      of performing this operation.  Most of this sort of generic support\n      is hidden away in the vector lowering support in gimple.  */\n@@ -399,11 +400,10 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n   if (icode == CODE_FOR_nothing)\n     return NULL;\n \n-  n = GET_MODE_NUNITS (vmode);\n   vec = rtvec_alloc (n);\n-  for (i = 0; i < n; ++i)\n+  for (int i = 0; i < n; ++i)\n     RTVEC_ELT (vec, i) = op;\n-  ret = gen_reg_rtx (vmode);\n+  rtx ret = gen_reg_rtx (vmode);\n   emit_insn (GEN_FCN (icode) (ret, gen_rtx_PARALLEL (vmode, vec)));\n \n   return ret;\n@@ -1074,7 +1074,7 @@ expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,\n \t arguments.  */\n       tmp_mode = insn_data[(int) icode].operand[0].mode;\n       if (VECTOR_MODE_P (mode)\n-\t  && GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n+\t  && maybe_ne (GET_MODE_NUNITS (tmp_mode), 2 * GET_MODE_NUNITS (mode)))\n \t{\n \t  delete_insns_since (last);\n \t  return NULL_RTX;\n@@ -5396,22 +5396,26 @@ vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n static rtx\n shift_amt_for_vec_perm_mask (machine_mode mode, const vec_perm_indices &sel)\n {\n-  unsigned int nelt = GET_MODE_NUNITS (mode);\n   unsigned int bitsize = GET_MODE_UNIT_BITSIZE (mode);\n   poly_int64 first = sel[0];\n-  if (maybe_ge (sel[0], nelt))\n+  if (maybe_ge (sel[0], GET_MODE_NUNITS (mode)))\n     return NULL_RTX;\n \n   if (!sel.series_p (0, 1, first, 1))\n-    for (unsigned int i = 1; i < nelt; i++)\n-      {\n-\tpoly_int64 expected = i + first;\n-\t/* Indices into the second vector are all equivalent.  */\n-\tif (maybe_lt (sel[i], nelt)\n-\t    ? maybe_ne (sel[i], expected)\n-\t    : maybe_lt (expected, nelt))\n-\t  return NULL_RTX;\n-      }\n+    {\n+      unsigned int nelt;\n+      if (!GET_MODE_NUNITS (mode).is_constant (&nelt))\n+\treturn NULL_RTX;\n+      for (unsigned int i = 1; i < nelt; i++)\n+\t{\n+\t  poly_int64 expected = i + first;\n+\t  /* Indices into the second vector are all equivalent.  */\n+\t  if (maybe_lt (sel[i], nelt)\n+\t      ? maybe_ne (sel[i], expected)\n+\t      : maybe_lt (expected, nelt))\n+\t    return NULL_RTX;\n+\t}\n+    }\n \n   return gen_int_shift_amount (mode, first * bitsize);\n }\n@@ -5631,7 +5635,7 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n      permutation to a byte-based permutation and try again.  */\n   machine_mode qimode;\n   if (!qimode_for_vec_perm (mode).exists (&qimode)\n-      || GET_MODE_NUNITS (qimode) > GET_MODE_MASK (QImode) + 1)\n+      || maybe_gt (GET_MODE_NUNITS (qimode), GET_MODE_MASK (QImode) + 1))\n     return NULL_RTX;\n   icode = direct_optab_handler (vec_perm_optab, qimode);\n   if (icode == CODE_FOR_nothing)\n@@ -5755,7 +5759,8 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n \n \n   gcc_assert (GET_MODE_SIZE (mode) == GET_MODE_SIZE (cmp_op_mode)\n-\t      && GET_MODE_NUNITS (mode) == GET_MODE_NUNITS (cmp_op_mode));\n+\t      && known_eq (GET_MODE_NUNITS (mode),\n+\t\t\t   GET_MODE_NUNITS (cmp_op_mode)));\n \n   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);\n   if (icode == CODE_FOR_nothing)\n@@ -5850,7 +5855,7 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n {\n   struct expand_operand eops[3];\n   enum insn_code icode;\n-  int method, i, nunits;\n+  int method, i;\n   machine_mode wmode;\n   rtx m1, m2;\n   optab tab1, tab2;\n@@ -5879,9 +5884,9 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n     }\n \n   icode = optab_handler (tab1, mode);\n-  nunits = GET_MODE_NUNITS (mode);\n   wmode = insn_data[icode].operand[0].mode;\n-  gcc_checking_assert (2 * GET_MODE_NUNITS (wmode) == nunits);\n+  gcc_checking_assert (known_eq (2 * GET_MODE_NUNITS (wmode),\n+\t\t\t\t GET_MODE_NUNITS (mode)));\n   gcc_checking_assert (GET_MODE_SIZE (wmode) == GET_MODE_SIZE (mode));\n \n   create_output_operand (&eops[0], gen_reg_rtx (wmode), wmode);\n@@ -5900,15 +5905,15 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n   if (method == 2)\n     {\n       /* The encoding has 2 interleaved stepped patterns.  */\n-      sel.new_vector (nunits, 2, 3);\n+      sel.new_vector (GET_MODE_NUNITS (mode), 2, 3);\n       for (i = 0; i < 6; ++i)\n \tsel.quick_push (!BYTES_BIG_ENDIAN + (i & ~1)\n-\t\t\t+ ((i & 1) ? nunits : 0));\n+\t\t\t+ ((i & 1) ? GET_MODE_NUNITS (mode) : 0));\n     }\n   else\n     {\n       /* The encoding has a single interleaved stepped pattern.  */\n-      sel.new_vector (nunits, 1, 3);\n+      sel.new_vector (GET_MODE_NUNITS (mode), 1, 3);\n       for (i = 0; i < 3; ++i)\n \tsel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n     }"}, {"sha": "33a0980b92e909289c42fb55d1c28bd7a7cf4643", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -3706,11 +3706,11 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n   if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n     {\n       /* As a consequence, we must be dealing with a constant number of\n-\t scalars, and thus a constant offset.  */\n+\t scalars, and thus a constant offset and number of units.  */\n       HOST_WIDE_INT coffset = offset.to_constant ();\n       HOST_WIDE_INT cysize = ysize.to_constant ();\n       nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n-      unsigned int nunits = GET_MODE_NUNITS (xmode);\n+      unsigned int nunits = GET_MODE_NUNITS (xmode).to_constant ();\n       scalar_mode xmode_unit = GET_MODE_INNER (xmode);\n       gcc_assert (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode_unit));\n       gcc_assert (nregs_xmode"}, {"sha": "33f76d05ace2b3f5e0f92ffec3318f1ccc3eec0d", "filename": "gcc/rtx-vector-builder.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Frtx-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Frtx-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtx-vector-builder.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -65,7 +65,9 @@ rtx_vector_builder::build ()\n   if (x)\n     return x;\n \n-  unsigned int nelts = GET_MODE_NUNITS (m_mode);\n+  unsigned int nelts;\n+  if (!GET_MODE_NUNITS (m_mode).is_constant (&nelts))\n+    nelts = encoded_nelts ();\n   rtvec v = rtvec_alloc (nelts);\n   for (unsigned int i = 0; i < nelts; ++i)\n     RTVEC_ELT (v, i) = elt (i);"}, {"sha": "a20782ac02c5ffedbe8f9a662b86c09faa6617ee", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 82, "deletions": 57, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -1223,7 +1223,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \n       /* If we know that the value is already truncated, we can\n \t replace the TRUNCATE with a SUBREG.  */\n-      if (GET_MODE_NUNITS (mode) == 1\n+      if (known_eq (GET_MODE_NUNITS (mode), 1)\n \t  && (TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op))\n \t      || truncated_to_mode (mode, op)))\n \t{\n@@ -1739,10 +1739,13 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n       }\n       if (CONST_SCALAR_INT_P (op) || CONST_DOUBLE_AS_FLOAT_P (op))\n \treturn gen_const_vec_duplicate (mode, op);\n-      if (GET_CODE (op) == CONST_VECTOR)\n+      unsigned int n_elts;\n+      if (GET_CODE (op) == CONST_VECTOR\n+\t  && GET_MODE_NUNITS (mode).is_constant (&n_elts))\n \t{\n-\t  unsigned int n_elts = GET_MODE_NUNITS (mode);\n-\t  unsigned int in_n_elts = CONST_VECTOR_NUNITS (op);\n+\t  /* This must be constant if we're duplicating it to a constant\n+\t     number of elements.  */\n+\t  unsigned int in_n_elts = CONST_VECTOR_NUNITS (op).to_constant ();\n \t  gcc_assert (in_n_elts < n_elts);\n \t  gcc_assert ((n_elts % in_n_elts) == 0);\n \t  rtvec v = rtvec_alloc (n_elts);\n@@ -1754,15 +1757,17 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \n   if (VECTOR_MODE_P (mode) && GET_CODE (op) == CONST_VECTOR)\n     {\n-      int elt_size = GET_MODE_UNIT_SIZE (mode);\n-      unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+      unsigned int n_elts;\n+      if (!CONST_VECTOR_NUNITS (op).is_constant (&n_elts))\n+\treturn NULL_RTX;\n+\n       machine_mode opmode = GET_MODE (op);\n-      int op_elt_size = GET_MODE_UNIT_SIZE (opmode);\n-      unsigned op_n_elts = (GET_MODE_SIZE (opmode) / op_elt_size);\n+      gcc_assert (known_eq (GET_MODE_NUNITS (mode), n_elts));\n+      gcc_assert (known_eq (GET_MODE_NUNITS (opmode), n_elts));\n+\n       rtvec v = rtvec_alloc (n_elts);\n       unsigned int i;\n \n-      gcc_assert (op_n_elts == n_elts);\n       for (i = 0; i < n_elts; i++)\n \t{\n \t  rtx x = simplify_unary_operation (code, GET_MODE_INNER (mode),\n@@ -3617,13 +3622,14 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t     nested VEC_SELECT expressions.  When input operand is a memory\n \t     operand, this operation can be simplified to a simple scalar\n \t     load from an offseted memory address.  */\n-\t  if (GET_CODE (trueop0) == VEC_SELECT)\n+\t  int n_elts;\n+\t  if (GET_CODE (trueop0) == VEC_SELECT\n+\t      && (GET_MODE_NUNITS (GET_MODE (XEXP (trueop0, 0)))\n+\t\t  .is_constant (&n_elts)))\n \t    {\n \t      rtx op0 = XEXP (trueop0, 0);\n \t      rtx op1 = XEXP (trueop0, 1);\n \n-\t      int n_elts = GET_MODE_NUNITS (GET_MODE (op0));\n-\n \t      int i = INTVAL (XVECEXP (trueop1, 0, 0));\n \t      int elem;\n \n@@ -3648,9 +3654,11 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t\t  mode00 = GET_MODE (op00);\n \t\t  mode01 = GET_MODE (op01);\n \n-\t\t  /* Find out number of elements of each operand.  */\n-\t\t  n_elts00 = GET_MODE_NUNITS (mode00);\n-\t\t  n_elts01 = GET_MODE_NUNITS (mode01);\n+\t\t  /* Find out the number of elements of each operand.\n+\t\t     Since the concatenated result has a constant number\n+\t\t     of elements, the operands must too.  */\n+\t\t  n_elts00 = GET_MODE_NUNITS (mode00).to_constant ();\n+\t\t  n_elts01 = GET_MODE_NUNITS (mode01).to_constant ();\n \n \t\t  gcc_assert (n_elts == n_elts00 + n_elts01);\n \n@@ -3689,12 +3697,11 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \n \t  if (GET_CODE (trueop0) == CONST_VECTOR)\n \t    {\n-\t      int elt_size = GET_MODE_UNIT_SIZE (mode);\n-\t      unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+\t      unsigned n_elts = XVECLEN (trueop1, 0);\n \t      rtvec v = rtvec_alloc (n_elts);\n \t      unsigned int i;\n \n-\t      gcc_assert (XVECLEN (trueop1, 0) == (int) n_elts);\n+\t      gcc_assert (known_eq (n_elts, GET_MODE_NUNITS (mode)));\n \t      for (i = 0; i < n_elts; i++)\n \t\t{\n \t\t  rtx x = XVECEXP (trueop1, 0, i);\n@@ -3763,15 +3770,18 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t    }\n \n \t  /* If we select one half of a vec_concat, return that.  */\n+\t  int l0, l1;\n \t  if (GET_CODE (trueop0) == VEC_CONCAT\n+\t      && (GET_MODE_NUNITS (GET_MODE (XEXP (trueop0, 0)))\n+\t\t  .is_constant (&l0))\n+\t      && (GET_MODE_NUNITS (GET_MODE (XEXP (trueop0, 1)))\n+\t\t  .is_constant (&l1))\n \t      && CONST_INT_P (XVECEXP (trueop1, 0, 0)))\n \t    {\n \t      rtx subop0 = XEXP (trueop0, 0);\n \t      rtx subop1 = XEXP (trueop0, 1);\n \t      machine_mode mode0 = GET_MODE (subop0);\n \t      machine_mode mode1 = GET_MODE (subop1);\n-\t      int l0 = GET_MODE_NUNITS (mode0);\n-\t      int l1 = GET_MODE_NUNITS (mode1);\n \t      int i0 = INTVAL (XVECEXP (trueop1, 0, 0));\n \t      if (i0 == 0 && !side_effects_p (op1) && mode == mode0)\n \t\t{\n@@ -3878,7 +3888,7 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t{\n \t  rtx op0_subop1 = XEXP (trueop0, 1);\n \t  gcc_assert (GET_CODE (op0_subop1) == PARALLEL);\n-\t  gcc_assert (XVECLEN (trueop1, 0) == GET_MODE_NUNITS (mode));\n+\t  gcc_assert (known_eq (XVECLEN (trueop1, 0), GET_MODE_NUNITS (mode)));\n \n \t  /* Apply the outer ordering vector to the inner one.  (The inner\n \t     ordering vector is expressly permitted to be of a different\n@@ -3922,15 +3932,16 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \telse\n \t  gcc_assert (GET_MODE_INNER (mode) == op1_mode);\n \n+\tunsigned int n_elts, in_n_elts;\n \tif ((GET_CODE (trueop0) == CONST_VECTOR\n \t     || CONST_SCALAR_INT_P (trueop0) \n \t     || CONST_DOUBLE_AS_FLOAT_P (trueop0))\n \t    && (GET_CODE (trueop1) == CONST_VECTOR\n \t\t|| CONST_SCALAR_INT_P (trueop1) \n-\t\t|| CONST_DOUBLE_AS_FLOAT_P (trueop1)))\n+\t\t|| CONST_DOUBLE_AS_FLOAT_P (trueop1))\n+\t    && GET_MODE_NUNITS (mode).is_constant (&n_elts)\n+\t    && GET_MODE_NUNITS (op0_mode).is_constant (&in_n_elts))\n \t  {\n-\t    unsigned n_elts = GET_MODE_NUNITS (mode);\n-\t    unsigned in_n_elts = GET_MODE_NUNITS (op0_mode);\n \t    rtvec v = rtvec_alloc (n_elts);\n \t    unsigned int i;\n \t    for (i = 0; i < n_elts; i++)\n@@ -4020,9 +4031,12 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n       && GET_CODE (op0) == CONST_VECTOR\n       && GET_CODE (op1) == CONST_VECTOR)\n     {\n-      unsigned int n_elts = CONST_VECTOR_NUNITS (op0);\n-      gcc_assert (n_elts == (unsigned int) CONST_VECTOR_NUNITS (op1));\n-      gcc_assert (n_elts == GET_MODE_NUNITS (mode));\n+      unsigned int n_elts;\n+      if (!CONST_VECTOR_NUNITS (op0).is_constant (&n_elts))\n+\treturn NULL_RTX;\n+\n+      gcc_assert (known_eq (n_elts, CONST_VECTOR_NUNITS (op1)));\n+      gcc_assert (known_eq (n_elts, GET_MODE_NUNITS (mode)));\n       rtvec v = rtvec_alloc (n_elts);\n       unsigned int i;\n \n@@ -4048,7 +4062,9 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \t  || CONST_DOUBLE_AS_FLOAT_P (op1)\n \t  || CONST_FIXED_P (op1)))\n     {\n-      unsigned n_elts = GET_MODE_NUNITS (mode);\n+      /* Both inputs have a constant number of elements, so the result\n+\t must too.  */\n+      unsigned n_elts = GET_MODE_NUNITS (mode).to_constant ();\n       rtvec v = rtvec_alloc (n_elts);\n \n       gcc_assert (n_elts >= 2);\n@@ -4062,8 +4078,8 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \t}\n       else\n \t{\n-\t  unsigned op0_n_elts = GET_MODE_NUNITS (GET_MODE (op0));\n-\t  unsigned op1_n_elts = GET_MODE_NUNITS (GET_MODE (op1));\n+\t  unsigned op0_n_elts = GET_MODE_NUNITS (GET_MODE (op0)).to_constant ();\n+\t  unsigned op1_n_elts = GET_MODE_NUNITS (GET_MODE (op1)).to_constant ();\n \t  unsigned i;\n \n \t  gcc_assert (GET_CODE (op0) == CONST_VECTOR);\n@@ -5566,6 +5582,7 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n   bool any_change = false;\n   rtx tem, trueop2;\n   scalar_int_mode int_mode, int_op0_mode;\n+  unsigned int n_elts;\n \n   switch (code)\n     {\n@@ -5668,14 +5685,17 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t  && GET_CODE (XEXP (op0, 1)) == CONST_VECTOR)\n \t{\n \t  rtx cv = XEXP (op0, 1);\n-\t  int nunits = CONST_VECTOR_NUNITS (cv);\n+\t  int nunits;\n \t  bool ok = true;\n-\t  for (int i = 0; i < nunits; ++i)\n-\t    if (CONST_VECTOR_ELT (cv, i) != const0_rtx)\n-\t      {\n-\t\tok = false;\n-\t\tbreak;\n-\t      }\n+\t  if (!CONST_VECTOR_NUNITS (cv).is_constant (&nunits))\n+\t    ok = false;\n+\t  else\n+\t    for (int i = 0; i < nunits; ++i)\n+\t      if (CONST_VECTOR_ELT (cv, i) != const0_rtx)\n+\t\t{\n+\t\t  ok = false;\n+\t\t  break;\n+\t\t}\n \t  if (ok)\n \t    {\n \t      rtx new_op0 = gen_rtx_NE (GET_MODE (op0),\n@@ -5749,9 +5769,9 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n       gcc_assert (GET_MODE (op1) == mode);\n       gcc_assert (VECTOR_MODE_P (mode));\n       trueop2 = avoid_constant_pool_reference (op2);\n-      if (CONST_INT_P (trueop2))\n+      if (CONST_INT_P (trueop2)\n+\t  && GET_MODE_NUNITS (mode).is_constant (&n_elts))\n \t{\n-\t  unsigned n_elts = GET_MODE_NUNITS (mode);\n \t  unsigned HOST_WIDE_INT sel = UINTVAL (trueop2);\n \t  unsigned HOST_WIDE_INT mask;\n \t  if (n_elts == HOST_BITS_PER_WIDE_INT)\n@@ -5815,7 +5835,7 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t  if (GET_CODE (op0) == VEC_DUPLICATE\n \t      && GET_CODE (XEXP (op0, 0)) == VEC_SELECT\n \t      && GET_CODE (XEXP (XEXP (op0, 0), 1)) == PARALLEL\n-\t      && mode_nunits[GET_MODE (XEXP (op0, 0))] == 1)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (op0, 0))), 1))\n \t    {\n \t      tem = XVECEXP ((XEXP (XEXP (op0, 0), 1)), 0, 0);\n \t      if (CONST_INT_P (tem) && CONST_INT_P (op2))\n@@ -5831,8 +5851,8 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t     (vec_concat (A) (X)) if N == 2.  */\n \t  if (GET_CODE (op0) == VEC_DUPLICATE\n \t      && GET_CODE (op1) == CONST_VECTOR\n-\t      && CONST_VECTOR_NUNITS (op1) == 2\n-\t      && GET_MODE_NUNITS (GET_MODE (op0)) == 2\n+\t      && known_eq (CONST_VECTOR_NUNITS (op1), 2)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op0)), 2)\n \t      && IN_RANGE (sel, 1, 2))\n \t    {\n \t      rtx newop0 = XEXP (op0, 0);\n@@ -5846,8 +5866,8 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t     Only applies for vectors of two elements.  */\n \t  if (GET_CODE (op0) == VEC_DUPLICATE\n \t      && GET_CODE (op1) == VEC_CONCAT\n-\t      && GET_MODE_NUNITS (GET_MODE (op0)) == 2\n-\t      && GET_MODE_NUNITS (GET_MODE (op1)) == 2\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op0)), 2)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op1)), 2)\n \t      && IN_RANGE (sel, 1, 2))\n \t    {\n \t      rtx newop0 = XEXP (op0, 0);\n@@ -5881,8 +5901,8 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t  if ((GET_CODE (op0) == VEC_DUPLICATE\n \t       || GET_CODE (op1) == VEC_DUPLICATE)\n \t      && GET_MODE (op0) == GET_MODE (op1)\n-\t      && GET_MODE_NUNITS (GET_MODE (op0)) == 2\n-\t      && GET_MODE_NUNITS (GET_MODE (op1)) == 2\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op0)), 2)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op1)), 2)\n \t      && IN_RANGE (sel, 1, 2))\n \t    {\n \t      rtx newop0 = op0, newop1 = op1;\n@@ -5918,8 +5938,8 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t     of N.  */\n \t  if (GET_CODE (op0) == VEC_DUPLICATE\n \t      && GET_CODE (op1) == VEC_DUPLICATE\n-\t      && GET_MODE_NUNITS (GET_MODE (op0)) == 2\n-\t      && GET_MODE_NUNITS (GET_MODE (op1)) == 2\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op0)), 2)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op1)), 2)\n \t      && IN_RANGE (sel, 1, 2))\n \t    {\n \t      rtx newop0 = XEXP (op0, 0);\n@@ -5990,7 +6010,7 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n \n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n-      num_elem = CONST_VECTOR_NUNITS (op);\n+      num_elem = GET_MODE_NUNITS (innermode);\n       elem_bitsize = GET_MODE_UNIT_BITSIZE (innermode);\n     }\n   else\n@@ -6679,7 +6699,7 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n {\n   scalar_mode inner_mode = GET_MODE_INNER (mode);\n   rtx duplicate = gen_rtx_VEC_DUPLICATE (mode, scalar_reg);\n-  unsigned int nunits = GET_MODE_NUNITS (mode);\n+  poly_uint64 nunits = GET_MODE_NUNITS (mode);\n   if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n     {\n       /* Test some simple unary cases with VEC_DUPLICATE arguments.  */\n@@ -6716,11 +6736,15 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n \t\t\t\t\t\tduplicate, zero_par));\n \n   /* And again with the final element.  */\n-  rtx last_index = gen_int_mode (GET_MODE_NUNITS (mode) - 1, word_mode);\n-  rtx last_par = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, last_index));\n-  ASSERT_RTX_PTR_EQ (scalar_reg,\n-\t\t     simplify_binary_operation (VEC_SELECT, inner_mode,\n-\t\t\t\t\t\tduplicate, last_par));\n+  unsigned HOST_WIDE_INT const_nunits;\n+  if (nunits.is_constant (&const_nunits))\n+    {\n+      rtx last_index = gen_int_mode (const_nunits - 1, word_mode);\n+      rtx last_par = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, last_index));\n+      ASSERT_RTX_PTR_EQ (scalar_reg,\n+\t\t\t simplify_binary_operation (VEC_SELECT, inner_mode,\n+\t\t\t\t\t\t    duplicate, last_par));\n+    }\n \n   /* Test a scalar subreg of a VEC_DUPLICATE.  */\n   poly_uint64 offset = subreg_lowpart_offset (inner_mode, mode);\n@@ -6729,7 +6753,8 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n \t\t\t\t      mode, offset));\n \n   machine_mode narrower_mode;\n-  if (nunits > 2\n+  if (maybe_ne (nunits, 2U)\n+      && multiple_p (nunits, 2)\n       && mode_for_vector (inner_mode, 2).exists (&narrower_mode)\n       && VECTOR_MODE_P (narrower_mode))\n     {\n@@ -6820,7 +6845,7 @@ test_vector_ops ()\n \t  rtx scalar_reg = make_test_reg (GET_MODE_INNER (mode));\n \t  test_vector_ops_duplicate (mode, scalar_reg);\n \t  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t      && GET_MODE_NUNITS (mode) > 2)\n+\t      && maybe_gt (GET_MODE_NUNITS (mode), 2))\n \t    test_vector_ops_series (mode, scalar_reg);\n \t}\n     }"}, {"sha": "4de0864774d0738092de436111f9806760b552c6", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -4582,12 +4582,22 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   /* Check that the permutation is supported.  */\n   if (VECTOR_MODE_P (mode))\n     {\n-      unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+      unsigned int i;\n       if (count == 3)\n \t{\n \t  unsigned int j0 = 0, j1 = 0, j2 = 0;\n \t  unsigned int i, j;\n \n+\t  unsigned int nelt;\n+\t  if (!GET_MODE_NUNITS (mode).is_constant (&nelt))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"cannot handle groups of 3 stores for\"\n+\t\t\t\t \" variable-length vectors\\n\");\n+\t      return false;\n+\t    }\n+\n \t  vec_perm_builder sel (nelt, nelt, 1);\n \t  sel.quick_grow (nelt);\n \t  vec_perm_indices indices;\n@@ -4638,6 +4648,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t{\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n \t  gcc_assert (pow2p_hwi (count));\n+\t  poly_uint64 nelt = GET_MODE_NUNITS (mode);\n \n \t  /* The encoding has 2 interleaved stepped patterns.  */\n \t  vec_perm_builder sel (nelt, 2, 3);\n@@ -4651,7 +4662,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t  if (can_vec_perm_const_p (mode, indices))\n \t    {\n \t      for (i = 0; i < 6; i++)\n-\t\tsel[i] += nelt / 2;\n+\t\tsel[i] += exact_div (nelt, 2);\n \t      indices.new_vector (sel, 2, nelt);\n \t      if (can_vec_perm_const_p (mode, indices))\n \t\treturn true;\n@@ -5184,10 +5195,19 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n   /* Check that the permutation is supported.  */\n   if (VECTOR_MODE_P (mode))\n     {\n-      unsigned int i, j, nelt = GET_MODE_NUNITS (mode);\n-\n+      unsigned int i, j;\n       if (count == 3)\n \t{\n+\t  unsigned int nelt;\n+\t  if (!GET_MODE_NUNITS (mode).is_constant (&nelt))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"cannot handle groups of 3 loads for\"\n+\t\t\t\t \" variable-length vectors\\n\");\n+\t      return false;\n+\t    }\n+\n \t  vec_perm_builder sel (nelt, nelt, 1);\n \t  sel.quick_grow (nelt);\n \t  vec_perm_indices indices;\n@@ -5229,6 +5249,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t{\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n \t  gcc_assert (pow2p_hwi (count));\n+\t  poly_uint64 nelt = GET_MODE_NUNITS (mode);\n \n \t  /* The encoding has a single stepped pattern.  */\n \t  vec_perm_builder sel (nelt, 1, 3);"}, {"sha": "c0cc656480904f51b653ca6ef3448e958f14d174", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -1160,7 +1160,7 @@ type_for_widest_vector_mode (tree type, optab op)\n {\n   machine_mode inner_mode = TYPE_MODE (type);\n   machine_mode best_mode = VOIDmode, mode;\n-  int best_nunits = 0;\n+  poly_int64 best_nunits = 0;\n \n   if (SCALAR_FLOAT_MODE_P (inner_mode))\n     mode = MIN_MODE_VECTOR_FLOAT;\n@@ -1177,7 +1177,7 @@ type_for_widest_vector_mode (tree type, optab op)\n \n   FOR_EACH_MODE_FROM (mode, mode)\n     if (GET_MODE_INNER (mode) == inner_mode\n-        && GET_MODE_NUNITS (mode) > best_nunits\n+\t&& maybe_gt (GET_MODE_NUNITS (mode), best_nunits)\n \t&& optab_handler (op, mode) != CODE_FOR_nothing)\n       best_mode = mode, best_nunits = GET_MODE_NUNITS (mode);\n "}, {"sha": "1f15a6417691a7b4aba0e2c0f5bd2939f00f4c78", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -3760,10 +3760,14 @@ have_whole_vector_shift (machine_mode mode)\n   if (optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n     return true;\n \n-  unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+  /* Variable-length vectors should be handled via the optab.  */\n+  unsigned int nelt;\n+  if (!GET_MODE_NUNITS (mode).is_constant (&nelt))\n+    return false;\n+\n   vec_perm_builder sel;\n   vec_perm_indices indices;\n-  for (i = nelt/2; i >= 1; i/=2)\n+  for (unsigned int i = nelt / 2; i >= 1; i /= 2)\n     {\n       calc_vec_perm_mask_for_shift (i, nelt, &sel);\n       indices.new_vector (sel, 2, nelt);"}, {"sha": "c9ca760f5dd03cdabf645f439e3e32b0d9dd384a", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -9598,19 +9598,19 @@ omp_clause_operand_check_failed (int idx, const_tree t, const char *file,\n }\n #endif /* ENABLE_TREE_CHECKING */\n \f\n-/* Create a new vector type node holding SUBPARTS units of type INNERTYPE,\n+/* Create a new vector type node holding NUNITS units of type INNERTYPE,\n    and mapped to the machine mode MODE.  Initialize its fields and build\n    the information necessary for debugging output.  */\n \n static tree\n-make_vector_type (tree innertype, int nunits, machine_mode mode)\n+make_vector_type (tree innertype, poly_int64 nunits, machine_mode mode)\n {\n   tree t;\n   tree mv_innertype = TYPE_MAIN_VARIANT (innertype);\n \n   t = make_node (VECTOR_TYPE);\n   TREE_TYPE (t) = mv_innertype;\n-  SET_TYPE_VECTOR_SUBPARTS (t, nunits);\n+  SET_TYPE_VECTOR_SUBPARTS (t, nunits.to_constant ()); /* Temporary */\n   SET_TYPE_MODE (t, mode);\n \n   if (TYPE_STRUCTURAL_EQUALITY_P (mv_innertype) || in_lto_p)\n@@ -9637,13 +9637,6 @@ make_vector_type (tree innertype, int nunits, machine_mode mode)\n   return t;\n }\n \n-/* Temporary.  */\n-static tree\n-make_vector_type (tree innertype, poly_uint64 nunits, machine_mode mode)\n-{\n-  return make_vector_type (innertype, (int) nunits.to_constant (), mode);\n-}\n-\n static tree\n make_or_reuse_type (unsigned size, int unsignedp)\n {\n@@ -10508,7 +10501,7 @@ reconstruct_complex_type (tree type, tree bottom)\n tree\n build_vector_type_for_mode (tree innertype, machine_mode mode)\n {\n-  int nunits;\n+  poly_int64 nunits;\n   unsigned int bitsize;\n \n   switch (GET_MODE_CLASS (mode))"}, {"sha": "0f5790fdc4dee513c64434d4f7f9e4145545505b", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b777afa955ad765500dfd53d6da990c84067197/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7b777afa955ad765500dfd53d6da990c84067197", "patch": "@@ -3932,7 +3932,7 @@ output_constant_pool_2 (fixed_size_mode mode, rtx x, unsigned int align)\n \tunsigned int subalign = MIN (align, GET_MODE_BITSIZE (submode));\n \n \tgcc_assert (GET_CODE (x) == CONST_VECTOR);\n-\tunits = CONST_VECTOR_NUNITS (x);\n+\tunits = GET_MODE_NUNITS (mode);\n \n \tfor (i = 0; i < units; i++)\n \t  {"}]}