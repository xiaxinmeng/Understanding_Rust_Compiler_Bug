{"sha": "c6c3db21769e8455f38e0d6ce004c44521aad7bd", "node_id": "C_kwDOANBUbNoAKGM2YzNkYjIxNzY5ZTg0NTVmMzhlMGQ2Y2UwMDRjNDQ1MjFhYWQ3YmQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T11:53:14Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add type resolution and trait solving pass\n\nThis serves to handle parts of the Rust type-system. Namely, the type\nresolution (similar to type-checking) and the trait solving algorithms\n(which ensure Rust's type contracts are upheld throughout the codebase).\n\n\tgcc/rust/\n\t* typecheck/rust-hir-trait-resolve.cc: New.\n\t* typecheck/rust-hir-trait-resolve.h: New.\n\t* typecheck/rust-hir-type-check-base.cc: New.\n\t* typecheck/rust-hir-type-check-base.h: New.\n\t* typecheck/rust-hir-type-check-enumitem.cc: New.\n\t* typecheck/rust-hir-type-check-enumitem.h: New.\n\t* typecheck/rust-hir-type-check-expr.cc: New.\n\t* typecheck/rust-hir-type-check-expr.h: New.\n\t* typecheck/rust-hir-type-check-implitem.cc: New.\n\t* typecheck/rust-hir-type-check-implitem.h: New.\n\t* typecheck/rust-hir-type-check-item.cc: New.\n\t* typecheck/rust-hir-type-check-item.h: New.\n\t* typecheck/rust-hir-type-check-path.cc: New.\n\t* typecheck/rust-hir-type-check-pattern.cc: New.\n\t* typecheck/rust-hir-type-check-pattern.h: New.\n\t* typecheck/rust-hir-type-check-stmt.cc: New.\n\t* typecheck/rust-hir-type-check-stmt.h: New.\n\t* typecheck/rust-hir-type-check-struct-field.h: New.\n\t* typecheck/rust-hir-type-check-struct.cc: New.\n\t* typecheck/rust-hir-type-check-toplevel.cc: New.\n\t* typecheck/rust-hir-type-check-toplevel.h: New.\n\t* typecheck/rust-hir-type-check-type.cc: New.\n\t* typecheck/rust-hir-type-check-type.h: New.\n\t* typecheck/rust-hir-type-check-util.cc: New.\n\t* typecheck/rust-hir-type-check-util.h: New.\n\t* typecheck/rust-hir-type-check.cc: New.\n\t* typecheck/rust-hir-type-check.h: New.\n\t* typecheck/rust-tyty-visitor.h: New.", "tree": {"sha": "fc41d0fe02aec8ad82d3ce6b62c3962e77d93972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc41d0fe02aec8ad82d3ce6b62c3962e77d93972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6c3db21769e8455f38e0d6ce004c44521aad7bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c3db21769e8455f38e0d6ce004c44521aad7bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c3db21769e8455f38e0d6ce004c44521aad7bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c3db21769e8455f38e0d6ce004c44521aad7bd/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ce37e720624accb7977ead5d0f25ac2b459c2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce37e720624accb7977ead5d0f25ac2b459c2aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce37e720624accb7977ead5d0f25ac2b459c2aa"}], "stats": {"total": 8337, "additions": 8337, "deletions": 0}, "files": [{"sha": "5ad9540868c348cd11c09ffba5bf970397ddb049", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,599 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveTraitItemToRef::visit (HIR::TraitItemType &type)\n+{\n+  // create trait-item-ref\n+  Location locus = type.get_locus ();\n+  bool is_optional = false;\n+  std::string identifier = type.get_name ();\n+\n+  resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t TraitItemReference::TraitItemType::TYPE, &type,\n+\t\t\t\t self, substitutions, locus);\n+}\n+\n+void\n+ResolveTraitItemToRef::visit (HIR::TraitItemConst &cst)\n+{\n+  // create trait-item-ref\n+  Location locus = cst.get_locus ();\n+  bool is_optional = cst.has_expr ();\n+  std::string identifier = cst.get_name ();\n+\n+  resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t TraitItemReference::TraitItemType::CONST, &cst,\n+\t\t\t\t self, substitutions, locus);\n+}\n+\n+void\n+ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n+{\n+  // create trait-item-ref\n+  Location locus = fn.get_locus ();\n+  bool is_optional = fn.has_block_defined ();\n+  std::string identifier = fn.get_decl ().get_function_name ();\n+\n+  resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t TraitItemReference::TraitItemType::FN, &fn,\n+\t\t\t\t self, std::move (substitutions), locus);\n+}\n+\n+ResolveTraitItemToRef::ResolveTraitItemToRef (\n+  TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n+  : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n+    substitutions (std::move (substitutions))\n+{}\n+\n+// TraitItemReference items\n+\n+TraitReference *\n+TraitResolver::Resolve (HIR::TypePath &path)\n+{\n+  TraitResolver resolver;\n+  return resolver.resolve_path (path);\n+}\n+\n+TraitReference *\n+TraitResolver::Resolve (HIR::Trait &trait)\n+{\n+  TraitResolver resolver;\n+  return resolver.resolve_trait (&trait);\n+}\n+\n+TraitReference *\n+TraitResolver::Lookup (HIR::TypePath &path)\n+{\n+  TraitResolver resolver;\n+  return resolver.lookup_path (path);\n+}\n+\n+TraitResolver::TraitResolver ()\n+  : TypeCheckBase (), resolved_trait_reference (nullptr)\n+{}\n+\n+TraitReference *\n+TraitResolver::resolve_path (HIR::TypePath &path)\n+{\n+  NodeId ref;\n+  if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t       &ref))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HirId hir_node = UNKNOWN_HIRID;\n+  if (!mappings->lookup_node_to_hir (ref, &hir_node))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HIR::Item *resolved_item = mappings->lookup_hir_item (hir_node);\n+\n+  rust_assert (resolved_item != nullptr);\n+  resolved_item->accept_vis (*this);\n+  rust_assert (resolved_trait_reference != nullptr);\n+\n+  return resolve_trait (resolved_trait_reference);\n+}\n+\n+TraitReference *\n+TraitResolver::resolve_trait (HIR::Trait *trait_reference)\n+{\n+  TraitReference *tref = &TraitReference::error_node ();\n+  if (context->lookup_trait_reference (\n+\ttrait_reference->get_mappings ().get_defid (), &tref))\n+    {\n+      return tref;\n+    }\n+\n+  TyTy::BaseType *self = nullptr;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  for (auto &generic_param : trait_reference->get_generic_params ())\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\tcase HIR::GenericParam::GenericKind::CONST:\n+\t  // FIXME: Skipping Lifetime and Const completely until better\n+\t  // handling.\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n+\t    substitutions.push_back (\n+\t      TyTy::SubstitutionParamMapping (typaram, param_type));\n+\n+\t    if (typaram.get_type_representation ().compare (\"Self\") == 0)\n+\t      {\n+\t\tself = param_type;\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+    }\n+  rust_assert (self != nullptr);\n+\n+  // Check if there is a super-trait, and apply this bound to the Self\n+  // TypeParam\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+\n+  // copy the substitition mappings\n+  std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n+  for (auto &sub : substitutions)\n+    self_subst_copy.push_back (sub.clone ());\n+\n+  // They also inherit themselves as a bound this enables a trait item to\n+  // reference other Self::trait_items\n+  auto self_hrtb\n+    = TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n+\t\t\t\tstd::move (self_subst_copy),\n+\t\t\t\ttrait_reference->get_locus ());\n+  specified_bounds.push_back (self_hrtb);\n+\n+  // look for any\n+  std::vector<const TraitReference *> super_traits;\n+  if (trait_reference->has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait_reference->get_type_param_bounds ())\n+\t{\n+\t  if (bound->get_bound_type ()\n+\t      == HIR::TypeParamBound::BoundType::TRAITBOUND)\n+\t    {\n+\t      HIR::TraitBound *b\n+\t\t= static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t      // FIXME this might be recursive we need a check for that\n+\t      auto predicate = get_predicate_from_bound (b->get_path ());\n+\t      specified_bounds.push_back (predicate);\n+\t      super_traits.push_back (predicate.get ());\n+\t    }\n+\t}\n+    }\n+  self->inherit_bounds (specified_bounds);\n+\n+  std::vector<TraitItemReference> item_refs;\n+  for (auto &item : trait_reference->get_trait_items ())\n+    {\n+      // make a copy of the substs\n+      std::vector<TyTy::SubstitutionParamMapping> item_subst;\n+      for (auto &sub : substitutions)\n+\titem_subst.push_back (sub.clone ());\n+\n+      TraitItemReference trait_item_ref\n+\t= ResolveTraitItemToRef::Resolve (*item.get (), self,\n+\t\t\t\t\t  std::move (item_subst));\n+      item_refs.push_back (std::move (trait_item_ref));\n+    }\n+\n+  TraitReference trait_object (trait_reference, item_refs,\n+\t\t\t       std::move (super_traits),\n+\t\t\t       std::move (substitutions));\n+  context->insert_trait_reference (\n+    trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n+\n+  tref = &TraitReference::error_node ();\n+  bool ok = context->lookup_trait_reference (\n+    trait_reference->get_mappings ().get_defid (), &tref);\n+  rust_assert (ok);\n+\n+  // hook to allow the trait to resolve its optional item blocks, we cant\n+  // resolve the blocks of functions etc because it can end up in a recursive\n+  // loop of trying to resolve traits as required by the types\n+  tref->on_resolved ();\n+\n+  return tref;\n+}\n+\n+TraitReference *\n+TraitResolver::lookup_path (HIR::TypePath &path)\n+{\n+  NodeId ref;\n+  if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t       &ref))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HirId hir_node = UNKNOWN_HIRID;\n+  if (!mappings->lookup_node_to_hir (ref, &hir_node))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HIR::Item *resolved_item = mappings->lookup_hir_item (hir_node);\n+\n+  rust_assert (resolved_item != nullptr);\n+  resolved_item->accept_vis (*this);\n+  rust_assert (resolved_trait_reference != nullptr);\n+\n+  TraitReference *tref = &TraitReference::error_node ();\n+  if (context->lookup_trait_reference (\n+\tresolved_trait_reference->get_mappings ().get_defid (), &tref))\n+    {\n+      return tref;\n+    }\n+  return &TraitReference::error_node ();\n+}\n+\n+void\n+TraitItemReference::on_resolved ()\n+{\n+  switch (type)\n+    {\n+    case CONST:\n+      resolve_item (static_cast<HIR::TraitItemConst &> (*hir_trait_item));\n+      break;\n+\n+    case TYPE:\n+      resolve_item (static_cast<HIR::TraitItemType &> (*hir_trait_item));\n+      break;\n+\n+    case FN:\n+      resolve_item (static_cast<HIR::TraitItemFunc &> (*hir_trait_item));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemType &type)\n+{\n+  TyTy::BaseType *ty\n+    = new TyTy::PlaceholderType (type.get_name (),\n+\t\t\t\t type.get_mappings ().get_hirid ());\n+  context->insert_type (type.get_mappings (), ty);\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemConst &constant)\n+{\n+  // TODO\n+}\n+\n+void\n+TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n+{\n+  if (!is_optional ())\n+    return;\n+\n+  TyTy::BaseType *item_tyty = get_tyty ();\n+  if (item_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  // check the block and return types\n+  rust_assert (item_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (item_tyty);\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (&func), expected_ret_tyty);\n+\n+  auto block_expr_ty = TypeCheckExpr::Resolve (func.get_block_expr ().get ());\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n+void\n+TraitItemReference::associated_type_set (TyTy::BaseType *ty) const\n+{\n+  rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n+\n+  TyTy::BaseType *item_ty = get_tyty ();\n+  rust_assert (item_ty->get_kind () == TyTy::TypeKind::PLACEHOLDER);\n+  TyTy::PlaceholderType *placeholder\n+    = static_cast<TyTy::PlaceholderType *> (item_ty);\n+\n+  placeholder->set_associated_type (ty->get_ty_ref ());\n+}\n+\n+void\n+TraitItemReference::associated_type_reset () const\n+{\n+  rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n+\n+  TyTy::BaseType *item_ty = get_tyty ();\n+  rust_assert (item_ty->get_kind () == TyTy::TypeKind::PLACEHOLDER);\n+  TyTy::PlaceholderType *placeholder\n+    = static_cast<TyTy::PlaceholderType *> (item_ty);\n+\n+  placeholder->clear_associated_type ();\n+}\n+\n+void\n+AssociatedImplTrait::setup_associated_types (\n+  const TyTy::BaseType *self, const TyTy::TypeBoundPredicate &bound)\n+{\n+  // compute the constrained impl block generic arguments based on self and the\n+  // higher ranked trait bound\n+  TyTy::BaseType *receiver = self->clone ();\n+\n+  // impl<Y> SliceIndex<[Y]> for Range<usize>\n+  // vs\n+  // I: SliceIndex<[<integer>]> and Range<<integer>>\n+  //\n+  // we need to figure out what Y is\n+\n+  TyTy::BaseType *associated_self = get_self ();\n+  rust_assert (associated_self->can_eq (self, false));\n+\n+  // grab the parameters\n+  HIR::ImplBlock &impl_block = *get_impl_block ();\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  for (auto &generic_param : impl_block.get_generic_params ())\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\tcase HIR::GenericParam::GenericKind::CONST:\n+\t  // FIXME: Skipping Lifetime and Const completely until better\n+\t  // handling.\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    TyTy::BaseType *l = nullptr;\n+\t    bool ok = context->lookup_type (\n+\t      generic_param->get_mappings ().get_hirid (), &l);\n+\t    if (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n+\t      {\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t  static_cast<TyTy::ParamType *> (l)));\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  // generate inference variables for these bound arguments so we can compute\n+  // their values\n+  Location locus;\n+  std::vector<TyTy::SubstitutionArg> args;\n+  for (auto &p : substitutions)\n+    {\n+      if (p.needs_substitution ())\n+\t{\n+\t  TyTy::TyVar infer_var = TyTy::TyVar::get_implicit_infer_var (locus);\n+\t  args.push_back (TyTy::SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t}\n+      else\n+\t{\n+\t  args.push_back (\n+\t    TyTy::SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t}\n+    }\n+\n+  // this callback gives us the parameters that get substituted so we can\n+  // compute the constrained type parameters for this impl block\n+  std::map<std::string, HirId> param_mappings;\n+  TyTy::ParamSubstCb param_subst_cb\n+    = [&] (const TyTy::ParamType &p, const TyTy::SubstitutionArg &a) {\n+\tparam_mappings[p.get_symbol ()] = a.get_tyty ()->get_ref ();\n+      };\n+\n+  TyTy::SubstitutionArgumentMappings infer_arguments (std::move (args), locus,\n+\t\t\t\t\t\t      param_subst_cb);\n+  TyTy::BaseType *impl_self_infer\n+    = (associated_self->needs_generic_substitutions ())\n+\t? SubstMapperInternal::Resolve (associated_self, infer_arguments)\n+\t: associated_self;\n+\n+  // FIXME this needs to do a lookup for the trait-reference DefId instead of\n+  // assuming its the first one in the list\n+  rust_assert (associated_self->num_specified_bounds () > 0);\n+  TyTy::TypeBoundPredicate &impl_predicate\n+    = associated_self->get_specified_bounds ().at (0);\n+\n+  // infer the arguments on the predicate\n+  std::vector<TyTy::BaseType *> impl_trait_predicate_args;\n+  for (const auto &arg : impl_predicate.get_substs ())\n+    {\n+      const TyTy::ParamType *p = arg.get_param_ty ();\n+      if (p->get_symbol ().compare (\"Self\") == 0)\n+\tcontinue;\n+\n+      TyTy::BaseType *r = p->resolve ();\n+      r = SubstMapperInternal::Resolve (r, infer_arguments);\n+      impl_trait_predicate_args.push_back (r);\n+    }\n+\n+  // we need to unify the receiver with the impl-block Self so that we compute\n+  // the type correctly as our receiver may be generic and we are inferring its\n+  // generic arguments and this Self might be the concrete version or vice\n+  // versa.\n+  auto result = receiver->unify (impl_self_infer);\n+  rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n+\n+  // unify the bounds arguments\n+  std::vector<TyTy::BaseType *> hrtb_bound_arguments;\n+  for (const auto &arg : bound.get_substs ())\n+    {\n+      const TyTy::ParamType *p = arg.get_param_ty ();\n+      if (p->get_symbol ().compare (\"Self\") == 0)\n+\tcontinue;\n+\n+      TyTy::BaseType *r = p->resolve ();\n+      hrtb_bound_arguments.push_back (r);\n+    }\n+\n+  rust_assert (impl_trait_predicate_args.size ()\n+\t       == hrtb_bound_arguments.size ());\n+  for (size_t i = 0; i < impl_trait_predicate_args.size (); i++)\n+    {\n+      TyTy::BaseType *a = impl_trait_predicate_args.at (i);\n+      TyTy::BaseType *b = hrtb_bound_arguments.at (i);\n+\n+      result = a->unify (b);\n+      rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n+    }\n+\n+  // create the argument list\n+  std::vector<TyTy::SubstitutionArg> associated_arguments;\n+  for (auto &p : substitutions)\n+    {\n+      std::string symbol = p.get_param_ty ()->get_symbol ();\n+      auto it = param_mappings.find (symbol);\n+      rust_assert (it != param_mappings.end ());\n+\n+      HirId id = it->second;\n+      TyTy::BaseType *argument = nullptr;\n+      bool ok = context->lookup_type (id, &argument);\n+      rust_assert (ok);\n+\n+      TyTy::SubstitutionArg arg (&p, argument);\n+      associated_arguments.push_back (arg);\n+    }\n+\n+  TyTy::SubstitutionArgumentMappings associated_type_args (\n+    std::move (associated_arguments), locus);\n+\n+  ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n+    TraitItemReference *resolved_trait_item = nullptr;\n+    bool ok = trait->lookup_trait_item (type.get_new_type_name (),\n+\t\t\t\t\t&resolved_trait_item);\n+    if (!ok)\n+      return;\n+    if (resolved_trait_item->get_trait_item_type ()\n+\t!= TraitItemReference::TraitItemType::TYPE)\n+      return;\n+\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    // this might be generic\n+    TyTy::BaseType *substituted\n+      = SubstMapperInternal::Resolve (lookup, associated_type_args);\n+    resolved_trait_item->associated_type_set (substituted);\n+  });\n+  iter.go ();\n+}\n+\n+void\n+AssociatedImplTrait::reset_associated_types ()\n+{\n+  trait->clear_associated_types ();\n+}\n+\n+Analysis::NodeMapping\n+TraitItemReference::get_parent_trait_mappings () const\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  HIR::Trait *trait\n+    = mappings->lookup_trait_item_mapping (get_mappings ().get_hirid ());\n+  rust_assert (trait != nullptr);\n+\n+  return trait->get_mappings ();\n+}\n+\n+bool\n+TraitItemReference::is_object_safe () const\n+{\n+  // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n+  switch (get_trait_item_type ())\n+    {\n+      case TraitItemReference::TraitItemType::FN: {\n+\t// lets be boring and just check that this is indeed a method will do\n+\t// for now\n+\tconst HIR::TraitItem *item = get_hir_trait_item ();\n+\tconst HIR::TraitItemFunc *fn\n+\t  = static_cast<const HIR::TraitItemFunc *> (item);\n+\treturn fn->get_decl ().is_method ();\n+      }\n+\n+      // constants are not available via dyn dispatch and so is not object safe\n+    case TraitItemReference::TraitItemType::CONST:\n+      return false;\n+\n+      // types are object safe since they are not available via dyn dispatch\n+    case TraitItemReference::TraitItemType::TYPE:\n+      return true;\n+\n+      // this is just an error so lets just fail it\n+    case TraitItemReference::TraitItemType::ERROR:\n+      return false;\n+    }\n+  return false;\n+}\n+\n+// rust-hir-path-probe.h\n+\n+void\n+PathProbeImplTrait::process_trait_impl_items_for_candidates ()\n+{\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      // just need to check if this is an impl block for this trait the next\n+      // function checks the receiver\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TraitReference *resolved\n+\t= TraitResolver::Lookup (*(impl->get_trait_ref ().get ()));\n+      if (!trait_reference->is_equal (*resolved))\n+\treturn true;\n+\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c4aaf42b141e12fb243db93bd512803ec0731536", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,87 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TRAIT_RESOLVE_H\n+#define RUST_HIR_TRAIT_RESOLVE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-ref.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveTraitItemToRef : public TypeCheckBase,\n+\t\t\t      private HIR::HIRTraitItemVisitor\n+{\n+public:\n+  static TraitItemReference\n+  Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+  {\n+    ResolveTraitItemToRef resolver (self, std::move (substitutions));\n+    item.accept_vis (resolver);\n+    return std::move (resolver.resolved);\n+  }\n+\n+  void visit (HIR::TraitItemType &type) override;\n+\n+  void visit (HIR::TraitItemConst &cst) override;\n+\n+  void visit (HIR::TraitItemFunc &fn) override;\n+\n+private:\n+  ResolveTraitItemToRef (\n+    TyTy::BaseType *self,\n+    std::vector<TyTy::SubstitutionParamMapping> &&substitutions);\n+\n+  TraitItemReference resolved;\n+  TyTy::BaseType *self;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+};\n+\n+class TraitResolver : public TypeCheckBase, private HIR::HIRFullVisitorBase\n+{\n+  using HIR::HIRFullVisitorBase::visit;\n+\n+public:\n+  static TraitReference *Resolve (HIR::TypePath &path);\n+\n+  static TraitReference *Resolve (HIR::Trait &trait);\n+\n+  static TraitReference *Lookup (HIR::TypePath &path);\n+\n+private:\n+  TraitResolver ();\n+\n+  TraitReference *resolve_path (HIR::TypePath &path);\n+\n+  TraitReference *resolve_trait (HIR::Trait *trait_reference);\n+\n+  TraitReference *lookup_path (HIR::TypePath &path);\n+\n+  HIR::Trait *resolved_trait_reference;\n+\n+public:\n+  void visit (HIR::Trait &trait) override { resolved_trait_reference = &trait; }\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TRAIT_RESOLVE_H"}, {"sha": "ac5c3b974759d57628585b181f2e423212734788", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,439 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-coercion.h\"\n+#include \"rust-casts.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+bool\n+TypeCheckBase::check_for_unconstrained (\n+  const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,\n+  const TyTy::SubstitutionArgumentMappings &constraint_a,\n+  const TyTy::SubstitutionArgumentMappings &constraint_b,\n+  const TyTy::BaseType *reference)\n+{\n+  std::set<HirId> symbols_to_constrain;\n+  std::map<HirId, Location> symbol_to_location;\n+  for (const auto &p : params_to_constrain)\n+    {\n+      HirId ref = p.get_param_ty ()->get_ref ();\n+      symbols_to_constrain.insert (ref);\n+      symbol_to_location.insert ({ref, p.get_param_locus ()});\n+    }\n+\n+  // set up the set of constrained symbols\n+  std::set<HirId> constrained_symbols;\n+  for (const auto &c : constraint_a.get_mappings ())\n+    {\n+      const TyTy::BaseType *arg = c.get_tyty ();\n+      if (arg != nullptr)\n+\t{\n+\t  const TyTy::BaseType *p = arg->get_root ();\n+\t  constrained_symbols.insert (p->get_ty_ref ());\n+\t}\n+    }\n+  for (const auto &c : constraint_b.get_mappings ())\n+    {\n+      const TyTy::BaseType *arg = c.get_tyty ();\n+      if (arg != nullptr)\n+\t{\n+\t  const TyTy::BaseType *p = arg->get_root ();\n+\t  constrained_symbols.insert (p->get_ty_ref ());\n+\t}\n+    }\n+\n+  const auto root = reference->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      const TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+      constrained_symbols.insert (p->get_ty_ref ());\n+    }\n+\n+  // check for unconstrained\n+  bool unconstrained = false;\n+  for (auto &sym : symbols_to_constrain)\n+    {\n+      bool used = constrained_symbols.find (sym) != constrained_symbols.end ();\n+      if (!used)\n+\t{\n+\t  Location locus = symbol_to_location.at (sym);\n+\t  rust_error_at (locus, \"unconstrained type parameter\");\n+\t  unconstrained = true;\n+\t}\n+    }\n+  return unconstrained;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckBase::resolve_literal (const Analysis::NodeMapping &expr_mappings,\n+\t\t\t\tHIR::Literal &literal, Location locus)\n+{\n+  TyTy::BaseType *infered = nullptr;\n+  switch (literal.get_lit_type ())\n+    {\n+      case HIR::Literal::LitType::INT: {\n+\tbool ok = false;\n+\n+\tswitch (literal.get_type_hint ())\n+\t  {\n+\t  case CORETYPE_I8:\n+\t    ok = context->lookup_builtin (\"i8\", &infered);\n+\t    break;\n+\t  case CORETYPE_I16:\n+\t    ok = context->lookup_builtin (\"i16\", &infered);\n+\t    break;\n+\t  case CORETYPE_I32:\n+\t    ok = context->lookup_builtin (\"i32\", &infered);\n+\t    break;\n+\t  case CORETYPE_I64:\n+\t    ok = context->lookup_builtin (\"i64\", &infered);\n+\t    break;\n+\t  case CORETYPE_I128:\n+\t    ok = context->lookup_builtin (\"i128\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_U8:\n+\t    ok = context->lookup_builtin (\"u8\", &infered);\n+\t    break;\n+\t  case CORETYPE_U16:\n+\t    ok = context->lookup_builtin (\"u16\", &infered);\n+\t    break;\n+\t  case CORETYPE_U32:\n+\t    ok = context->lookup_builtin (\"u32\", &infered);\n+\t    break;\n+\t  case CORETYPE_U64:\n+\t    ok = context->lookup_builtin (\"u64\", &infered);\n+\t    break;\n+\t  case CORETYPE_U128:\n+\t    ok = context->lookup_builtin (\"u128\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_F32:\n+\t    literal.set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t    ok = context->lookup_builtin (\"f32\", &infered);\n+\t    break;\n+\t  case CORETYPE_F64:\n+\t    literal.set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t    ok = context->lookup_builtin (\"f64\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_ISIZE:\n+\t    ok = context->lookup_builtin (\"isize\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_USIZE:\n+\t    ok = context->lookup_builtin (\"usize\", &infered);\n+\t    break;\n+\n+\t  default:\n+\t    ok = true;\n+\t    infered\n+\t      = new TyTy::InferType (expr_mappings.get_hirid (),\n+\t\t\t\t     TyTy::InferType::InferTypeKind::INTEGRAL,\n+\t\t\t\t     locus);\n+\t    break;\n+\t  }\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::FLOAT: {\n+\tbool ok = false;\n+\n+\tswitch (literal.get_type_hint ())\n+\t  {\n+\t  case CORETYPE_F32:\n+\t    ok = context->lookup_builtin (\"f32\", &infered);\n+\t    break;\n+\t  case CORETYPE_F64:\n+\t    ok = context->lookup_builtin (\"f64\", &infered);\n+\t    break;\n+\n+\t  default:\n+\t    ok = true;\n+\t    infered\n+\t      = new TyTy::InferType (expr_mappings.get_hirid (),\n+\t\t\t\t     TyTy::InferType::InferTypeKind::FLOAT,\n+\t\t\t\t     locus);\n+\t    break;\n+\t  }\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BOOL: {\n+\tauto ok = context->lookup_builtin (\"bool\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::CHAR: {\n+\tauto ok = context->lookup_builtin (\"char\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BYTE: {\n+\tauto ok = context->lookup_builtin (\"u8\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::STRING: {\n+\tTyTy::BaseType *base = nullptr;\n+\tauto ok = context->lookup_builtin (\"str\", &base);\n+\trust_assert (ok);\n+\n+\tinfered = new TyTy::ReferenceType (expr_mappings.get_hirid (),\n+\t\t\t\t\t   TyTy::TyVar (base->get_ref ()),\n+\t\t\t\t\t   Mutability::Imm);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BYTE_STRING: {\n+\t/* This is an arraytype of u8 reference (&[u8;size]). It isn't in\n+\t   UTF-8, but really just a byte array. Code to construct the array\n+\t   reference copied from ArrayElemsValues and ArrayType. */\n+\tTyTy::BaseType *u8;\n+\tauto ok = context->lookup_builtin (\"u8\", &u8);\n+\trust_assert (ok);\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping capacity_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t\tmappings->get_next_hir_id (\n+\t\t\t\t\t\t  crate_num),\n+\t\t\t\t\t\tUNKNOWN_LOCAL_DEFID);\n+\n+\t/* Capacity is the size of the string (number of chars).\n+\t   It is a constant, but for fold it to get a tree.  */\n+\tstd::string capacity_str\n+\t  = std::to_string (literal.as_string ().size ());\n+\tHIR::LiteralExpr *literal_capacity\n+\t  = new HIR::LiteralExpr (capacity_mapping, capacity_str,\n+\t\t\t\t  HIR::Literal::LitType::INT,\n+\t\t\t\t  PrimitiveCoreType::CORETYPE_USIZE, locus, {});\n+\n+\t// mark the type for this implicit node\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (capacity_mapping, expected_ty);\n+\n+\tAnalysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t     mappings->get_next_hir_id (\n+\t\t\t\t\t       crate_num),\n+\t\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+\tTyTy::ArrayType *array\n+\t  = new TyTy::ArrayType (array_mapping.get_hirid (), locus,\n+\t\t\t\t *literal_capacity,\n+\t\t\t\t TyTy::TyVar (u8->get_ref ()));\n+\tcontext->insert_type (array_mapping, array);\n+\n+\tinfered = new TyTy::ReferenceType (expr_mappings.get_hirid (),\n+\t\t\t\t\t   TyTy::TyVar (array->get_ref ()),\n+\t\t\t\t\t   Mutability::Imm);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  return infered;\n+}\n+\n+TyTy::ADTType::ReprOptions\n+TypeCheckBase::parse_repr_options (const AST::AttrVec &attrs, Location locus)\n+{\n+  TyTy::ADTType::ReprOptions repr;\n+  repr.pack = 0;\n+  repr.align = 0;\n+\n+  for (const auto &attr : attrs)\n+    {\n+      bool is_repr = attr.get_path ().as_string ().compare (\"repr\") == 0;\n+      if (is_repr)\n+\t{\n+\t  const AST::AttrInput &input = attr.get_attr_input ();\n+\t  bool is_token_tree = input.get_attr_input_type ()\n+\t\t\t       == AST::AttrInput::AttrInputType::TOKEN_TREE;\n+\t  rust_assert (is_token_tree);\n+\t  const auto &option = static_cast<const AST::DelimTokenTree &> (input);\n+\t  AST::AttrInputMetaItemContainer *meta_items\n+\t    = option.parse_to_meta_item ();\n+\n+\t  const std::string inline_option\n+\t    = meta_items->get_items ().at (0)->as_string ();\n+\n+\t  // TODO: it would probably be better to make the MetaItems more aware\n+\t  // of constructs with nesting like #[repr(packed(2))] rather than\n+\t  // manually parsing the string \"packed(2)\" here.\n+\n+\t  size_t oparen = inline_option.find ('(', 0);\n+\t  bool is_pack = false, is_align = false;\n+\t  unsigned char value = 1;\n+\n+\t  if (oparen == std::string::npos)\n+\t    {\n+\t      is_pack = inline_option.compare (\"packed\") == 0;\n+\t      is_align = inline_option.compare (\"align\") == 0;\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      std::string rep = inline_option.substr (0, oparen);\n+\t      is_pack = rep.compare (\"packed\") == 0;\n+\t      is_align = rep.compare (\"align\") == 0;\n+\n+\t      size_t cparen = inline_option.find (')', oparen);\n+\t      if (cparen == std::string::npos)\n+\t\t{\n+\t\t  rust_error_at (locus, \"malformed attribute\");\n+\t\t}\n+\n+\t      std::string value_str = inline_option.substr (oparen, cparen);\n+\t      value = strtoul (value_str.c_str () + 1, NULL, 10);\n+\t    }\n+\n+\t  if (is_pack)\n+\t    repr.pack = value;\n+\t  else if (is_align)\n+\t    repr.align = value;\n+\n+\t  // Multiple repr options must be specified with e.g. #[repr(C,\n+\t  // packed(2))].\n+\t  break;\n+\t}\n+    }\n+\n+  return repr;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckBase::coercion_site (HirId id, TyTy::BaseType *expected,\n+\t\t\t      TyTy::BaseType *expr, Location locus)\n+{\n+  rust_debug (\"coercion_site id={%u} expected={%s} expr={%s}\", id,\n+\t      expected->debug_str ().c_str (), expr->debug_str ().c_str ());\n+\n+  auto context = TypeCheckContext::get ();\n+  if (expected->get_kind () == TyTy::TypeKind::ERROR\n+      || expr->get_kind () == TyTy::TypeKind::ERROR)\n+    return expr;\n+\n+  // can we autoderef it?\n+  auto result = TypeCoercionRules::Coerce (expr, expected, locus);\n+\n+  // the result needs to be unified\n+  TyTy::BaseType *receiver = expr;\n+  if (!result.is_error ())\n+    {\n+      receiver = result.tyty;\n+    }\n+\n+  rust_debug (\"coerce_default_unify(a={%s}, b={%s})\",\n+\t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+  TyTy::BaseType *coerced = expected->unify (receiver);\n+  context->insert_autoderef_mappings (id, std::move (result.adjustments));\n+  return coerced;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckBase::cast_site (HirId id, TyTy::TyWithLocation from,\n+\t\t\t  TyTy::TyWithLocation to, Location cast_locus)\n+{\n+  rust_debug (\"cast_site id={%u} from={%s} to={%s}\", id,\n+\t      from.get_ty ()->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+\n+  auto context = TypeCheckContext::get ();\n+  if (from.get_ty ()->get_kind () == TyTy::TypeKind::ERROR\n+      || to.get_ty ()->get_kind () == TyTy::TypeKind::ERROR)\n+    return to.get_ty ();\n+\n+  // do the cast\n+  auto result = TypeCastRules::resolve (cast_locus, from, to);\n+\n+  // we assume error has already been emitted\n+  if (result.is_error ())\n+    return to.get_ty ();\n+\n+  // the result needs to be unified\n+  TyTy::BaseType *casted_result = result.tyty;\n+  rust_debug (\"cast_default_unify(a={%s}, b={%s})\",\n+\t      casted_result->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+  TyTy::BaseType *casted = to.get_ty ()->unify (casted_result);\n+  context->insert_cast_autoderef_mappings (id, std::move (result.adjustments));\n+  return casted;\n+}\n+\n+void\n+TypeCheckBase::resolve_generic_params (\n+  const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n+  std::vector<TyTy::SubstitutionParamMapping> &substitutions)\n+{\n+  for (auto &generic_param : generic_params)\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\t  // FIXME: Skipping Lifetime completely until better\n+\t  // handling.\n+\t  break;\n+\t  case HIR::GenericParam::GenericKind::CONST: {\n+\t    auto param\n+\t      = static_cast<HIR::ConstGenericParam *> (generic_param.get ());\n+\t    auto specified_type\n+\t      = TypeCheckType::Resolve (param->get_type ().get ());\n+\n+\t    if (param->has_default_expression ())\n+\t      {\n+\t\tauto expr_type = TypeCheckExpr::Resolve (\n+\t\t  param->get_default_expression ().get ());\n+\n+\t\tspecified_type->unify (expr_type);\n+\t      }\n+\n+\t    context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t  specified_type);\n+\t  }\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t      static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t  }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "aa42d9d6dfd9feadc6b05b62d436f872c7d68b3f", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_BASE\n+#define RUST_HIR_TYPE_CHECK_BASE\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-backend.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TraitReference;\n+class TypeCheckBase\n+{\n+public:\n+  virtual ~TypeCheckBase () {}\n+\n+  static TyTy::BaseType *coercion_site (HirId id, TyTy::BaseType *lhs,\n+\t\t\t\t\tTyTy::BaseType *rhs,\n+\t\t\t\t\tLocation coercion_locus);\n+\n+  static TyTy::BaseType *cast_site (HirId id, TyTy::TyWithLocation from,\n+\t\t\t\t    TyTy::TyWithLocation to,\n+\t\t\t\t    Location cast_locus);\n+\n+protected:\n+  TypeCheckBase ()\n+    : mappings (Analysis::Mappings::get ()), resolver (Resolver::get ()),\n+      context (TypeCheckContext::get ())\n+  {}\n+\n+  TraitReference *resolve_trait_path (HIR::TypePath &);\n+\n+  TyTy::TypeBoundPredicate get_predicate_from_bound (HIR::TypePath &path);\n+\n+  bool check_for_unconstrained (\n+    const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,\n+    const TyTy::SubstitutionArgumentMappings &constraint_a,\n+    const TyTy::SubstitutionArgumentMappings &constraint_b,\n+    const TyTy::BaseType *reference);\n+\n+  TyTy::BaseType *resolve_literal (const Analysis::NodeMapping &mappings,\n+\t\t\t\t   HIR::Literal &literal, Location locus);\n+\n+  TyTy::ADTType::ReprOptions parse_repr_options (const AST::AttrVec &attrs,\n+\t\t\t\t\t\t Location locus);\n+\n+  void resolve_generic_params (\n+    const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n+    std::vector<TyTy::SubstitutionParamMapping> &substitutions);\n+\n+  Analysis::Mappings *mappings;\n+  Resolver *resolver;\n+  TypeCheckContext *context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_BASE"}, {"sha": "e65b2011d36257da33312a3378c0fd8e543859af", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.cc", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,213 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::VariantDef *\n+TypeCheckEnumItem::Resolve (HIR::EnumItem *item, int64_t last_discriminant)\n+{\n+  TypeCheckEnumItem resolver (last_discriminant);\n+  switch (item->get_enum_item_kind ())\n+    {\n+    case HIR::EnumItem::EnumItemKind::Named:\n+      resolver.visit (static_cast<HIR::EnumItem &> (*item));\n+      break;\n+\n+    case HIR::EnumItem::EnumItemKind::Tuple:\n+      resolver.visit (static_cast<HIR::EnumItemTuple &> (*item));\n+      break;\n+\n+    case HIR::EnumItem::EnumItemKind::Struct:\n+      resolver.visit (static_cast<HIR::EnumItemStruct &> (*item));\n+      break;\n+\n+    case HIR::EnumItem::EnumItemKind::Discriminant:\n+      resolver.visit (static_cast<HIR::EnumItemDiscriminant &> (*item));\n+      break;\n+    }\n+  return resolver.variant;\n+}\n+\n+TypeCheckEnumItem::TypeCheckEnumItem (int64_t last_discriminant)\n+  : TypeCheckBase (), variant (nullptr), last_discriminant (last_discriminant)\n+{}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItem &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n+\t\t\t\t item.get_mappings ().get_nodeid (),\n+\t\t\t\t mappings->get_next_hir_id (\n+\t\t\t\t   item.get_mappings ().get_crate_num ()),\n+\t\t\t\t item.get_mappings ().get_local_defid ());\n+  HIR::LiteralExpr *discim_expr\n+    = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n+\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t    PrimitiveCoreType::CORETYPE_I64, item.get_locus (),\n+\t\t\t    {});\n+\n+  TyTy::BaseType *isize = nullptr;\n+  bool ok = context->lookup_builtin (\"isize\", &isize);\n+  rust_assert (ok);\n+  context->insert_type (mapping, isize);\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident, discim_expr);\n+}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItemDiscriminant &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  auto &discriminant = item.get_discriminant_expression ();\n+  auto capacity_type = TypeCheckExpr::Resolve (discriminant.get ());\n+  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::ISizeType *expected_ty\n+    = new TyTy::ISizeType (discriminant->get_mappings ().get_hirid ());\n+  context->insert_type (discriminant->get_mappings (), expected_ty);\n+\n+  auto unified = expected_ty->unify (capacity_type);\n+  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t     &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident,\n+\t\t\t\t  item.get_discriminant_expression ().get ());\n+}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItemTuple &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : item.get_tuple_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n+\t\t\t\t item.get_mappings ().get_nodeid (),\n+\t\t\t\t mappings->get_next_hir_id (\n+\t\t\t\t   item.get_mappings ().get_crate_num ()),\n+\t\t\t\t item.get_mappings ().get_local_defid ());\n+  HIR::LiteralExpr *discim_expr\n+    = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n+\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t    PrimitiveCoreType::CORETYPE_I64, item.get_locus (),\n+\t\t\t    {});\n+\n+  TyTy::BaseType *isize = nullptr;\n+  bool ok = context->lookup_builtin (\"isize\", &isize);\n+  rust_assert (ok);\n+  context->insert_type (mapping, isize);\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident,\n+\t\t\t\t  TyTy::VariantDef::VariantType::TUPLE,\n+\t\t\t\t  discim_expr, fields);\n+}\n+\n+void\n+TypeCheckEnumItem::visit (HIR::EnumItemStruct &item)\n+{\n+  if (last_discriminant == INT64_MAX)\n+    rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : item.get_struct_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  Analysis::NodeMapping mapping (item.get_mappings ().get_crate_num (),\n+\t\t\t\t item.get_mappings ().get_nodeid (),\n+\t\t\t\t mappings->get_next_hir_id (\n+\t\t\t\t   item.get_mappings ().get_crate_num ()),\n+\t\t\t\t item.get_mappings ().get_local_defid ());\n+  HIR::LiteralExpr *discrim_expr\n+    = new HIR::LiteralExpr (mapping, std::to_string (last_discriminant),\n+\t\t\t    HIR::Literal::LitType::INT,\n+\t\t\t    PrimitiveCoreType::CORETYPE_I64, item.get_locus (),\n+\t\t\t    {});\n+\n+  TyTy::BaseType *isize = nullptr;\n+  bool ok = context->lookup_builtin (\"isize\", &isize);\n+  rust_assert (ok);\n+  context->insert_type (mapping, isize);\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  ok = mappings->lookup_canonical_path (item.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, item.get_locus ()};\n+  variant = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t\t  item.get_identifier (), ident,\n+\t\t\t\t  TyTy::VariantDef::VariantType::STRUCT,\n+\t\t\t\t  discrim_expr, fields);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c771ea3782de4aa1307ca227b020990fedcf52ee", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_ENUMITEM\n+#define RUST_HIR_TYPE_CHECK_ENUMITEM\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckEnumItem : public TypeCheckBase\n+{\n+public:\n+  static TyTy::VariantDef *Resolve (HIR::EnumItem *item,\n+\t\t\t\t    int64_t last_discriminant);\n+\n+protected:\n+  void visit (HIR::EnumItem &item);\n+  void visit (HIR::EnumItemDiscriminant &item);\n+  void visit (HIR::EnumItemTuple &item);\n+  void visit (HIR::EnumItemStruct &item);\n+\n+private:\n+  TypeCheckEnumItem (int64_t last_discriminant);\n+\n+  TyTy::VariantDef *variant;\n+  int64_t last_discriminant;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_ENUMITEM"}, {"sha": "4371f5a59a5dd9a7d052424d08b9147b75ef8c06", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "added", "additions": 1567, "deletions": 0, "changes": 1567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,1567 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-stmt.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckExpr::TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n+\n+// Perform type checking on expr. Also runs type unification algorithm.\n+// Returns the unified type of expr\n+TyTy::BaseType *\n+TypeCheckExpr::Resolve (HIR::Expr *expr)\n+{\n+  TypeCheckExpr resolver;\n+  expr->accept_vis (resolver);\n+\n+  if (resolver.infered == nullptr)\n+    {\n+      // FIXME\n+      // this is an internal error message for debugging and should be removed\n+      // at some point\n+      rust_error_at (expr->get_locus (), \"failed to type resolve expression\");\n+      return new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n+    }\n+\n+  auto ref = expr->get_mappings ().get_hirid ();\n+  resolver.infered->set_ref (ref);\n+  resolver.context->insert_type (expr->get_mappings (), resolver.infered);\n+\n+  return resolver.infered;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::TupleIndexExpr &expr)\n+{\n+  auto resolved = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get ());\n+  if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_tuple_expr ()->get_locus (),\n+\t\t     \"failed to resolve TupleIndexExpr receiver\");\n+      return;\n+    }\n+\n+  // FIXME does this require autoderef here?\n+  if (resolved->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (resolved);\n+      resolved = r->get_base ();\n+    }\n+\n+  bool is_valid_type = resolved->get_kind () == TyTy::TypeKind::ADT\n+\t\t       || resolved->get_kind () == TyTy::TypeKind::TUPLE;\n+  if (!is_valid_type)\n+    {\n+      rust_error_at (expr.get_tuple_expr ()->get_locus (),\n+\t\t     \"Expected Tuple or ADT got: %s\",\n+\t\t     resolved->as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (resolved->get_kind () == TyTy::TypeKind::TUPLE)\n+    {\n+      TyTy::TupleType *tuple = static_cast<TyTy::TupleType *> (resolved);\n+      TupleIndex index = expr.get_tuple_index ();\n+      if ((size_t) index >= tuple->num_fields ())\n+\t{\n+\t  rust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n+\t  return;\n+\t}\n+\n+      auto field_tyty = tuple->get_field ((size_t) index);\n+      if (field_tyty == nullptr)\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"failed to lookup field type at index %i\", index);\n+\t  return;\n+\t}\n+\n+      infered = field_tyty;\n+      return;\n+    }\n+\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (resolved);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+  TupleIndex index = expr.get_tuple_index ();\n+  if ((size_t) index >= variant->num_fields ())\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n+      return;\n+    }\n+\n+  auto field_tyty = variant->get_field_at_index ((size_t) index);\n+  if (field_tyty == nullptr)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup field type at index %i\", index);\n+      return;\n+    }\n+\n+  infered = field_tyty->get_field_type ();\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    {\n+      auto unit_node_id = resolver->get_unit_type_node_id ();\n+      if (!context->lookup_builtin (unit_node_id, &infered))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"failed to lookup builtin unit type\");\n+\t}\n+      return;\n+    }\n+\n+  std::vector<TyTy::TyVar> fields;\n+  for (auto &elem : expr.get_tuple_elems ())\n+    {\n+      auto field_ty = TypeCheckExpr::Resolve (elem.get ());\n+      fields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n+    }\n+  infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t expr.get_locus (), fields);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ReturnExpr &expr)\n+{\n+  auto fn_return_tyty = context->peek_return_type ();\n+  rust_assert (fn_return_tyty != nullptr);\n+\n+  TyTy::BaseType *expr_ty\n+    = expr.has_return_expr ()\n+\t? TypeCheckExpr::Resolve (expr.get_expr ())\n+\t: TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+\n+  infered = fn_return_tyty->unify (expr_ty);\n+  fn_return_tyty->append_reference (expr_ty->get_ref ());\n+  for (auto &ref : infered->get_combined_refs ())\n+    fn_return_tyty->append_reference (ref);\n+\n+  infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::CallExpr &expr)\n+{\n+  TyTy::BaseType *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n+\n+  bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n+\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!valid_tyty)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to resolve expression of function call\");\n+      return;\n+    }\n+\n+  TyTy::VariantDef &variant = TyTy::VariantDef::get_error_node ();\n+  if (function_tyty->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (function_tyty);\n+      if (adt->is_enum ())\n+\t{\n+\t  // lookup variant id\n+\t  HirId variant_id;\n+\t  bool ok = context->lookup_variant_definition (\n+\t    expr.get_fnexpr ()->get_mappings ().get_hirid (), &variant_id);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::VariantDef *lookup_variant = nullptr;\n+\t  ok = adt->lookup_variant_by_id (variant_id, &lookup_variant);\n+\t  rust_assert (ok);\n+\n+\t  variant = *lookup_variant;\n+\t}\n+      else\n+\t{\n+\t  rust_assert (adt->number_of_variants () == 1);\n+\t  variant = *adt->get_variants ().at (0);\n+\t}\n+    }\n+\n+  infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::AssignmentExpr &expr)\n+{\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  coercion_site (expr.get_mappings ().get_hirid (), lhs, rhs,\n+\t\t expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get ());\n+\n+  // we dont care about the result of the unify from a compound assignment\n+  // since this is a unit-type expr\n+  auto result = lhs->unify (rhs);\n+  if (result->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  auto lang_item_type\n+    = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+      expr.get_expr_type ());\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+  if (operator_overloaded)\n+    return;\n+\n+  bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+  bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+  bool valid = valid_lhs && valid_rhs;\n+  if (!valid)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"cannot apply this operator to types %s and %s\",\n+\t\t     lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+      return;\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::LiteralExpr &expr)\n+{\n+  infered = resolve_literal (expr.get_mappings (), expr.get_literal (),\n+\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  auto lang_item_type\n+    = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+  if (operator_overloaded)\n+    return;\n+\n+  bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+  bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+  bool valid = valid_lhs && valid_rhs;\n+  if (!valid)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"cannot apply this operator to types %s and %s\",\n+\t\t     lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+      return;\n+    }\n+\n+  switch (expr.get_expr_type ())\n+    {\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT: {\n+\tTyTy::TyWithLocation from (rhs, expr.get_rhs ()->get_locus ());\n+\tTyTy::TyWithLocation to (lhs, expr.get_lhs ()->get_locus ());\n+\tinfered = cast_site (expr.get_mappings ().get_hirid (), from, to,\n+\t\t\t     expr.get_locus ());\n+      }\n+      break;\n+\n+    default:\n+      infered = lhs->unify (rhs);\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ComparisonExpr &expr)\n+{\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  auto result = lhs->unify (rhs);\n+  if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  bool ok = context->lookup_builtin (\"bool\", &infered);\n+  rust_assert (ok);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::LazyBooleanExpr &expr)\n+{\n+  auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+  auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+  // we expect the lhs and rhs must be bools at this point\n+  TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n+  lhs = elhs.unify (lhs);\n+  if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::BoolType rlhs (expr.get_mappings ().get_hirid ());\n+  rhs = elhs.unify (rhs);\n+  if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  infered = lhs->unify (rhs);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::NegationExpr &expr)\n+{\n+  auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+  // check for operator overload\n+  auto lang_item_type = Analysis::RustLangItem::NegationOperatorToLangItem (\n+    expr.get_expr_type ());\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, negated_expr_ty,\n+\t\t\t\t nullptr);\n+  if (operator_overloaded)\n+    return;\n+\n+  // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n+  switch (expr.get_expr_type ())\n+    {\n+      case NegationOperator::NEGATE: {\n+\tbool valid\n+\t  = (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::FLOAT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::ISIZE)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::USIZE)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t&& (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t    == TyTy::InferType::INTEGRAL))\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t&& (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t    == TyTy::InferType::FLOAT));\n+\tif (!valid)\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"cannot apply unary - to %s\",\n+\t\t\t   negated_expr_ty->as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n+      case NegationOperator::NOT: {\n+\tbool valid\n+\t  = (negated_expr_ty->get_kind () == TyTy::TypeKind::BOOL)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t    || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t&& (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t    == TyTy::InferType::INTEGRAL));\n+\tif (!valid)\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"cannot apply unary %<!%> to %s\",\n+\t\t\t   negated_expr_ty->as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+      break;\n+    }\n+\n+  infered = negated_expr_ty->clone ();\n+  infered->append_reference (negated_expr_ty->get_ref ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfExpr &expr)\n+{\n+  TypeCheckExpr::Resolve (expr.get_if_condition ());\n+  TypeCheckExpr::Resolve (expr.get_if_block ());\n+\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfExprConseqElse &expr)\n+{\n+  TypeCheckExpr::Resolve (expr.get_if_condition ());\n+  auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n+  auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_else_block ());\n+\n+  if (if_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = else_blk_resolved;\n+  else if (else_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = if_blk_resolved;\n+  else\n+    infered = if_blk_resolved->unify (else_blk_resolved);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfExprConseqIf &expr)\n+{\n+  TypeCheckExpr::Resolve (expr.get_if_condition ());\n+  auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n+  auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n+\n+  if (if_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = else_blk_resolved;\n+  else if (else_blk_resolved->get_kind () == TyTy::NEVER)\n+    infered = if_blk_resolved;\n+  else\n+    infered = if_blk_resolved->unify (else_blk_resolved);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::IfLetExpr &expr)\n+{\n+  // this needs to perform a least upper bound coercion on the blocks and then\n+  // unify the scruintee and arms\n+  TyTy::BaseType *scrutinee_tyty\n+    = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n+\n+  for (auto &pattern : expr.get_patterns ())\n+    {\n+      TyTy::BaseType *kase_arm_ty\n+\t= TypeCheckPattern::Resolve (pattern.get (), scrutinee_tyty);\n+\n+      TyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n+      if (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+\n+  TypeCheckExpr::Resolve (expr.get_if_block ());\n+\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::UnsafeBlockExpr &expr)\n+{\n+  infered = TypeCheckExpr::Resolve (expr.get_block_expr ().get ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::BlockExpr &expr)\n+{\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (!s->is_item ())\n+\tcontinue;\n+\n+      TypeCheckStmt::Resolve (s.get ());\n+    }\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (s->is_item ())\n+\tcontinue;\n+\n+      auto resolved = TypeCheckStmt::Resolve (s.get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (s->get_locus (), \"failure to resolve type\");\n+\t  return;\n+\t}\n+\n+      if (s->is_unit_check_needed () && !resolved->is_unit ())\n+\t{\n+\t  auto unit\n+\t    = TyTy::TupleType::get_unit_type (s->get_mappings ().get_hirid ());\n+\t  resolved = unit->unify (resolved);\n+\t}\n+    }\n+\n+  if (expr.has_expr ())\n+    infered = TypeCheckExpr::Resolve (expr.get_final_expr ().get ())->clone ();\n+  else if (expr.is_tail_reachable ())\n+    infered\n+      = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+  else\n+    infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFromToExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get ());\n+  TyTy::BaseType *to_ty = TypeCheckExpr::Resolve (expr.get_to_expr ().get ());\n+  TyTy::BaseType *unified = from_ty->unify (to_ty);\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, unified));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFromExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_FROM;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get ());\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, from_ty));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeToExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_TO;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty = TypeCheckExpr::Resolve (expr.get_to_expr ().get ());\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, from_ty));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFullExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_FULL;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->is_unit ());\n+\n+  infered = item_type;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::RangeFromToInclExpr &expr)\n+{\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::RANGE_INCLUSIVE;\n+\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // we need to have it maybe\n+  if (!lang_item_defined)\n+    {\n+      rust_internal_error_at (\n+\texpr.get_locus (), \"unable to find relevant lang item: %s\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+      return;\n+    }\n+\n+  // look it up and it _must_ be a struct definition\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item != nullptr);\n+\n+  TyTy::BaseType *item_type = nullptr;\n+  bool ok\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &item_type);\n+  rust_assert (ok);\n+  rust_assert (item_type->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (item_type);\n+\n+  // this is a single generic item lets assert that\n+  rust_assert (adt->get_num_substitutions () == 1);\n+\n+  // resolve the range expressions and these types must unify then we use that\n+  // type to substitute into the ADT\n+  TyTy::BaseType *from_ty\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get ());\n+  TyTy::BaseType *to_ty = TypeCheckExpr::Resolve (expr.get_to_expr ().get ());\n+  TyTy::BaseType *unified = from_ty->unify (to_ty);\n+\n+  // substitute it in\n+  std::vector<TyTy::SubstitutionArg> subst_mappings;\n+  const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n+  subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, unified));\n+\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  infered = SubstMapperInternal::Resolve (adt, subst);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n+{\n+  auto array_expr_ty = TypeCheckExpr::Resolve (expr.get_array_expr ());\n+  if (array_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  auto index_expr_ty = TypeCheckExpr::Resolve (expr.get_index_expr ());\n+  if (index_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  // first attempt to use direct array index logic\n+  auto direct_array_expr_ty = array_expr_ty;\n+  if (direct_array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      // lets try and deref it since rust allows this\n+      auto ref = static_cast<TyTy::ReferenceType *> (direct_array_expr_ty);\n+      auto base = ref->get_base ();\n+      if (base->get_kind () == TyTy::TypeKind::ARRAY)\n+\tdirect_array_expr_ty = base;\n+    }\n+\n+  TyTy::BaseType *size_ty;\n+  bool ok = context->lookup_builtin (\"usize\", &size_ty);\n+  rust_assert (ok);\n+\n+  bool maybe_simple_array_access = index_expr_ty->can_eq (size_ty, false);\n+  if (maybe_simple_array_access\n+      && direct_array_expr_ty->get_kind () == TyTy::TypeKind::ARRAY)\n+    {\n+      auto resolved_index_expr = size_ty->unify (index_expr_ty);\n+      if (resolved_index_expr->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      TyTy::ArrayType *array_type\n+\t= static_cast<TyTy::ArrayType *> (direct_array_expr_ty);\n+      infered = array_type->get_element_type ()->clone ();\n+      return;\n+    }\n+\n+  // is this a case of core::ops::index?\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::INDEX;\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, array_expr_ty,\n+\t\t\t\t index_expr_ty);\n+  if (operator_overloaded)\n+    {\n+      // index and index mut always return a reference to the element\n+      TyTy::BaseType *resolved = infered;\n+      rust_assert (resolved->get_kind () == TyTy::TypeKind::REF);\n+      TyTy::ReferenceType *ref = static_cast<TyTy::ReferenceType *> (resolved);\n+\n+      infered = ref->get_base ()->clone ();\n+      return;\n+    }\n+\n+  // error[E0277]: the type `[{integer}]` cannot be indexed by `u32`\n+  RichLocation r (expr.get_locus ());\n+  r.add_range (expr.get_array_expr ()->get_locus ());\n+  r.add_range (expr.get_index_expr ()->get_locus ());\n+  rust_error_at (r, \"the type %<%s%> cannot be indexed by %<%s%>\",\n+\t\t array_expr_ty->get_name ().c_str (),\n+\t\t index_expr_ty->get_name ().c_str ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ArrayExpr &expr)\n+{\n+  HIR::ArrayElems &elements = *expr.get_internal_elements ();\n+\n+  HIR::Expr *capacity_expr = nullptr;\n+  TyTy::BaseType *element_type = nullptr;\n+  switch (elements.get_array_expr_type ())\n+    {\n+      case HIR::ArrayElems::ArrayExprType::COPIED: {\n+\tHIR::ArrayElemsCopied &elems\n+\t  = static_cast<HIR::ArrayElemsCopied &> (elements);\n+\telement_type = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n+\n+\tauto capacity_type\n+\t  = TypeCheckExpr::Resolve (elems.get_num_copies_expr ());\n+\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tbool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n+\t\t\t      expected_ty);\n+\n+\tauto unified = expected_ty->unify (capacity_type);\n+\tif (unified->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+\n+\tcapacity_expr = elems.get_num_copies_expr ();\n+      }\n+      break;\n+\n+      case HIR::ArrayElems::ArrayExprType::VALUES: {\n+\tHIR::ArrayElemsValues &elems\n+\t  = static_cast<HIR::ArrayElemsValues &> (elements);\n+\n+\tstd::vector<TyTy::BaseType *> types;\n+\tfor (auto &elem : elems.get_values ())\n+\t  {\n+\t    types.push_back (TypeCheckExpr::Resolve (elem.get ()));\n+\t  }\n+\n+\telement_type\n+\t  = TyTy::TyVar::get_implicit_infer_var (expr.get_locus ()).get_tyty ();\n+\tfor (auto &type : types)\n+\t  {\n+\t    element_type = element_type->unify (type);\n+\t  }\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\tstd::string capacity_str = std::to_string (elems.get_num_elements ());\n+\tcapacity_expr = new HIR::LiteralExpr (mapping, capacity_str,\n+\t\t\t\t\t      HIR::Literal::LitType::INT,\n+\t\t\t\t\t      PrimitiveCoreType::CORETYPE_USIZE,\n+\t\t\t\t\t      Location (), {});\n+\n+\t// mark the type for this implicit node\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tbool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (mapping, expected_ty);\n+      }\n+      break;\n+    }\n+\n+  infered = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t expr.get_locus (), *capacity_expr,\n+\t\t\t\t TyTy::TyVar (element_type->get_ref ()));\n+}\n+\n+// empty struct\n+void\n+TypeCheckExpr::visit (HIR::StructExprStruct &struct_expr)\n+{\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n+      return;\n+    }\n+\n+  infered = struct_path_ty;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  infered = TypeCheckStructExpr::Resolve (&struct_expr);\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::GroupedExpr &expr)\n+{\n+  infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::FieldAccessExpr &expr)\n+{\n+  auto struct_base = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n+\n+  // FIXME does this require autoderef here?\n+  if (struct_base->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (struct_base);\n+      struct_base = r->get_base ();\n+    }\n+\n+  bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n+  if (!is_valid_type)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"expected algebraic data type got: [%s]\",\n+\t\t     struct_base->as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (struct_base);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *vaiant = adt->get_variants ().at (0);\n+\n+  TyTy::StructFieldType *lookup = nullptr;\n+  bool found = vaiant->lookup_field (expr.get_field_name (), &lookup, nullptr);\n+  if (!found)\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown field [%s] for type [%s]\",\n+\t\t     expr.get_field_name ().c_str (),\n+\t\t     adt->as_string ().c_str ());\n+      return;\n+    }\n+\n+  infered = lookup->get_field_type ();\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n+  if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_receiver ()->get_locus (),\n+\t\t     \"failed to resolve receiver in MethodCallExpr\");\n+      return;\n+    }\n+\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n+  auto candidate\n+    = MethodResolver::Probe (receiver_tyty,\n+\t\t\t     expr.get_method_name ().get_segment ());\n+  if (candidate.is_error ())\n+    {\n+      rust_error_at (\n+\texpr.get_method_name ().get_locus (),\n+\t\"failed to resolve method for %<%s%>\",\n+\texpr.get_method_name ().get_segment ().as_string ().c_str ());\n+      return;\n+    }\n+\n+  // Get the adjusted self\n+  Adjuster adj (receiver_tyty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // store the adjustments for code-generation to know what to do which must be\n+  // stored onto the receiver to so as we don't trigger duplicate deref mappings\n+  // ICE when an argument is a method call\n+  HirId autoderef_mappings_id\n+    = expr.get_receiver ()->get_mappings ().get_hirid ();\n+  context->insert_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated impl item is not a method\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  if (!fn->is_method ())\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated function is not a method\");\n+      return;\n+    }\n+\n+  auto root = receiver_tyty->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+      if (adt->has_substitutions () && fn->needs_substitution ())\n+\t{\n+\t  // consider the case where we have:\n+\t  //\n+\t  // struct Foo<X,Y>(X,Y);\n+\t  //\n+\t  // impl<T> Foo<T, i32> {\n+\t  //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t  // }\n+\t  //\n+\t  // In this case we end up with an fn type of:\n+\t  //\n+\t  // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t  //\n+\t  // This means the instance or self we are calling this method for\n+\t  // will be substituted such that we can get the inherited type\n+\t  // arguments but then need to use the turbo fish if available or\n+\t  // infer the remaining arguments. Luckily rust does not allow for\n+\t  // default types GenericParams on impl blocks since these must\n+\t  // always be at the end of the list\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // apply any remaining generic arguments\n+  if (expr.get_method_name ().has_generic_args ())\n+    {\n+      HIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+      lookup\n+\t= SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n+\t\t\t\t&args);\n+      if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+  else if (lookup->needs_generic_substitutions ())\n+    {\n+      lookup = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\texpr.get_method_name ().get_locus ());\n+    }\n+\n+  TyTy::BaseType *function_ret_tyty\n+    = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self, context);\n+  if (function_ret_tyty == nullptr\n+      || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type to MethodCallExpr\");\n+      return;\n+    }\n+\n+  // store the expected fntype\n+  context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  infered = function_ret_tyty;\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::LoopExpr &expr)\n+{\n+  context->push_new_loop_context (expr.get_mappings ().get_hirid (),\n+\t\t\t\t  expr.get_locus ());\n+  TyTy::BaseType *block_expr\n+    = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n+  if (!block_expr->is_unit ())\n+    {\n+      rust_error_at (expr.get_loop_block ()->get_locus (),\n+\t\t     \"expected %<()%> got %s\",\n+\t\t     block_expr->as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::BaseType *loop_context_type = context->pop_loop_context ();\n+\n+  bool loop_context_type_infered\n+    = (loop_context_type->get_kind () != TyTy::TypeKind::INFER)\n+      || ((loop_context_type->get_kind () == TyTy::TypeKind::INFER)\n+\t  && (((TyTy::InferType *) loop_context_type)->get_infer_kind ()\n+\t      != TyTy::InferType::GENERAL));\n+\n+  infered\n+    = loop_context_type_infered\n+\t? loop_context_type\n+\t: TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::WhileLoopExpr &expr)\n+{\n+  context->push_new_while_loop_context (expr.get_mappings ().get_hirid ());\n+\n+  TypeCheckExpr::Resolve (expr.get_predicate_expr ().get ());\n+  TyTy::BaseType *block_expr\n+    = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n+\n+  if (!block_expr->is_unit ())\n+    {\n+      rust_error_at (expr.get_loop_block ()->get_locus (),\n+\t\t     \"expected %<()%> got %s\",\n+\t\t     block_expr->as_string ().c_str ());\n+      return;\n+    }\n+\n+  context->pop_loop_context ();\n+  infered = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::BreakExpr &expr)\n+{\n+  if (!context->have_loop_context ())\n+    {\n+      rust_error_at (expr.get_locus (), \"cannot %<break%> outside of a loop\");\n+      return;\n+    }\n+\n+  if (expr.has_break_expr ())\n+    {\n+      TyTy::BaseType *break_expr_tyty\n+\t= TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+      TyTy::BaseType *loop_context = context->peek_loop_context ();\n+      if (loop_context->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"can only break with a value inside %<loop%>\");\n+\t  return;\n+\t}\n+\n+      TyTy::BaseType *unified_ty = loop_context->unify (break_expr_tyty);\n+      context->swap_head_loop_context (unified_ty);\n+    }\n+\n+  infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::ContinueExpr &expr)\n+{\n+  if (!context->have_loop_context ())\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"cannot %<continue%> outside of a loop\");\n+      return;\n+    }\n+\n+  infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::BorrowExpr &expr)\n+{\n+  TyTy::BaseType *resolved_base\n+    = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+  // In Rust this is valid because of DST's\n+  //\n+  // fn test() {\n+  //     let a:&str = \"TEST 1\";\n+  //     let b:&str = &\"TEST 2\";\n+  // }\n+  if (resolved_base->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      const TyTy::ReferenceType *ref\n+\t= static_cast<const TyTy::ReferenceType *> (resolved_base);\n+\n+      // this might end up being a more generic is_dyn object check but lets\n+      // double check dyn traits type-layout first\n+      if (ref->is_dyn_str_type ())\n+\t{\n+\t  infered = resolved_base;\n+\t  return;\n+\t}\n+    }\n+\n+  if (expr.get_is_double_borrow ())\n+    {\n+      // FIXME double_reference\n+      gcc_unreachable ();\n+    }\n+\n+  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t     TyTy::TyVar (resolved_base->get_ref ()),\n+\t\t\t\t     expr.get_mut ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::DereferenceExpr &expr)\n+{\n+  TyTy::BaseType *resolved_base\n+    = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+\n+  auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n+  bool operator_overloaded\n+    = resolve_operator_overload (lang_item_type, expr, resolved_base, nullptr);\n+  if (operator_overloaded)\n+    {\n+      // operator overloaded deref always refurns a reference type lets assert\n+      // this\n+      rust_assert (infered->get_kind () == TyTy::TypeKind::REF);\n+      resolved_base = infered;\n+    }\n+\n+  bool is_valid_type = resolved_base->get_kind () == TyTy::TypeKind::REF\n+\t\t       || resolved_base->get_kind () == TyTy::TypeKind::POINTER;\n+  if (!is_valid_type)\n+    {\n+      rust_error_at (expr.get_locus (), \"expected reference type got %s\",\n+\t\t     resolved_base->as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (resolved_base->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *ref_base\n+\t= static_cast<TyTy::ReferenceType *> (resolved_base);\n+      infered = ref_base->get_base ()->clone ();\n+    }\n+  else\n+    {\n+      TyTy::PointerType *ref_base\n+\t= static_cast<TyTy::PointerType *> (resolved_base);\n+      infered = ref_base->get_base ()->clone ();\n+    }\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::TypeCastExpr &expr)\n+{\n+  TyTy::BaseType *expr_to_convert\n+    = TypeCheckExpr::Resolve (expr.get_casted_expr ().get ());\n+  TyTy::BaseType *tyty_to_convert_to\n+    = TypeCheckType::Resolve (expr.get_type_to_convert_to ().get ());\n+\n+  TyTy::TyWithLocation from (expr_to_convert,\n+\t\t\t     expr.get_casted_expr ()->get_locus ());\n+  TyTy::TyWithLocation to (tyty_to_convert_to,\n+\t\t\t   expr.get_type_to_convert_to ()->get_locus ());\n+  infered = cast_site (expr.get_mappings ().get_hirid (), from, to,\n+\t\t       expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::MatchExpr &expr)\n+{\n+  // this needs to perform a least upper bound coercion on the blocks and then\n+  // unify the scruintee and arms\n+  TyTy::BaseType *scrutinee_tyty\n+    = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n+\n+  std::vector<TyTy::BaseType *> kase_block_tys;\n+  for (auto &kase : expr.get_match_cases ())\n+    {\n+      // lets check the arms\n+      HIR::MatchArm &kase_arm = kase.get_arm ();\n+      for (auto &pattern : kase_arm.get_patterns ())\n+\t{\n+\t  TyTy::BaseType *kase_arm_ty\n+\t    = TypeCheckPattern::Resolve (pattern.get (), scrutinee_tyty);\n+\n+\t  TyTy::BaseType *checked_kase = scrutinee_tyty->unify (kase_arm_ty);\n+\t  if (checked_kase->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n+\t}\n+\n+      // check the kase type\n+      TyTy::BaseType *kase_block_ty\n+\t= TypeCheckExpr::Resolve (kase.get_expr ().get ());\n+      kase_block_tys.push_back (kase_block_ty);\n+    }\n+\n+  if (kase_block_tys.size () == 0)\n+    {\n+      infered\n+\t= TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n+      return;\n+    }\n+\n+  infered = kase_block_tys.at (0);\n+  for (size_t i = 1; i < kase_block_tys.size (); i++)\n+    {\n+      TyTy::BaseType *kase_ty = kase_block_tys.at (i);\n+      infered = infered->unify (kase_ty);\n+      if (infered->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+}\n+\n+bool\n+TypeCheckExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,\n+  TyTy::BaseType *lhs, TyTy::BaseType *rhs)\n+{\n+  // look up lang item for arithmetic type\n+  std::string associated_item_name\n+    = Analysis::RustLangItem::ToString (lang_item_type);\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // probe for the lang-item\n+  if (!lang_item_defined)\n+    return false;\n+\n+  auto segment = HIR::PathIdentSegment (associated_item_name);\n+  auto candidate\n+    = MethodResolver::Probe (lhs, HIR::PathIdentSegment (associated_item_name));\n+\n+  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  if (!have_implementation_for_lang_item)\n+    return false;\n+\n+  // Get the adjusted self\n+  Adjuster adj (lhs);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // is this the case we are recursive\n+  // handle the case where we are within the impl block for this lang_item\n+  // otherwise we end up with a recursive operator overload such as the i32\n+  // operator overload trait\n+  TypeCheckContextItem &fn_context = context->peek_context ();\n+  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+    {\n+      auto &impl_item = fn_context.get_impl_item ();\n+      HIR::ImplBlock *parent = impl_item.first;\n+      HIR::Function *fn = impl_item.second;\n+\n+      if (parent->has_trait_ref ()\n+\t  && fn->get_function_name ().compare (associated_item_name) == 0)\n+\t{\n+\t  TraitReference *trait_reference\n+\t    = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t  if (!trait_reference->is_error ())\n+\t    {\n+\t      TyTy::BaseType *lookup = nullptr;\n+\t      bool ok = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t      rust_assert (ok);\n+\t      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t      rust_assert (fntype->is_method ());\n+\n+\t      bool is_lang_item_impl\n+\t\t= trait_reference->get_mappings ().get_defid ()\n+\t\t  == respective_lang_item_id;\n+\t      bool self_is_lang_item_self\n+\t\t= fntype->get_self_type ()->is_equal (*adjusted_self);\n+\t      bool recursive_operator_overload\n+\t\t= is_lang_item_impl && self_is_lang_item_self;\n+\n+\t      if (recursive_operator_overload)\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  // store the adjustments for code-generation to know what to do\n+  context->insert_autoderef_mappings (expr.get_lvalue_mappings ().get_hirid (),\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  // now its just like a method-call-expr\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  auto root = lhs->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+      if (adt->has_substitutions () && fn->needs_substitution ())\n+\t{\n+\t  // consider the case where we have:\n+\t  //\n+\t  // struct Foo<X,Y>(X,Y);\n+\t  //\n+\t  // impl<T> Foo<T, i32> {\n+\t  //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t  // }\n+\t  //\n+\t  // In this case we end up with an fn type of:\n+\t  //\n+\t  // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t  //\n+\t  // This means the instance or self we are calling this method for\n+\t  // will be substituted such that we can get the inherited type\n+\t  // arguments but then need to use the turbo fish if available or\n+\t  // infer the remaining arguments. Luckily rust does not allow for\n+\t  // default types GenericParams on impl blocks since these must\n+\t  // always be at the end of the list\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // handle generics\n+  if (lookup->needs_generic_substitutions ())\n+    lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n+\n+  // type check the arguments if required\n+  TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (type->num_params () > 0);\n+  auto fnparam = type->param_at (0);\n+  fnparam.second->unify (adjusted_self); // typecheck the self\n+  if (rhs == nullptr)\n+    {\n+      rust_assert (type->num_params () == 1);\n+    }\n+  else\n+    {\n+      rust_assert (type->num_params () == 2);\n+      auto fnparam = type->param_at (1);\n+      fnparam.second->unify (rhs); // typecheck the rhs\n+    }\n+\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  fn = static_cast<TyTy::FnType *> (lookup);\n+  fn->monomorphize ();\n+\n+  // get the return type\n+  TyTy::BaseType *function_ret_tyty\n+    = type->get_return_type ()->monomorphized_clone ();\n+\n+  // store the expected fntype\n+  context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  infered = function_ret_tyty;\n+\n+  return true;\n+}\n+\n+bool\n+TypeCheckExpr::validate_arithmetic_type (\n+  const TyTy::BaseType *tyty, HIR::ArithmeticOrLogicalExpr::ExprType expr_type)\n+{\n+  const TyTy::BaseType *type = tyty->destructure ();\n+\n+  // https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators\n+  // this will change later when traits are added\n+  switch (expr_type)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      return (type->get_kind () == TyTy::TypeKind::INT)\n+\t     || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t     || (type->get_kind () == TyTy::TypeKind::FLOAT)\n+\t     || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::ISIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::INTEGRAL))\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::FLOAT));\n+\n+      // integers or bools\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      return (type->get_kind () == TyTy::TypeKind::INT)\n+\t     || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t     || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::ISIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::BOOL)\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::INTEGRAL));\n+\n+      // integers only\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      return (type->get_kind () == TyTy::TypeKind::INT)\n+\t     || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t     || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::ISIZE)\n+\t     || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t && (((const TyTy::InferType *) type)->get_infer_kind ()\n+\t\t     == TyTy::InferType::INTEGRAL));\n+    }\n+\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "19a6c791a9d764ca93d3a0d6ddb83f463a9110ff", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,131 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_EXPR\n+#define RUST_HIR_TYPE_CHECK_EXPR\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckExpr : public TypeCheckBase, private HIR::HIRExpressionVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (HIR::Expr *expr);\n+\n+  void visit (HIR::TupleIndexExpr &expr) override;\n+  void visit (HIR::TupleExpr &expr) override;\n+  void visit (HIR::ReturnExpr &expr) override;\n+  void visit (HIR::CallExpr &expr) override;\n+  void visit (HIR::MethodCallExpr &expr) override;\n+  void visit (HIR::AssignmentExpr &expr) override;\n+  void visit (HIR::CompoundAssignmentExpr &expr) override;\n+  void visit (HIR::LiteralExpr &expr) override;\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n+  void visit (HIR::ComparisonExpr &expr) override;\n+  void visit (HIR::LazyBooleanExpr &expr) override;\n+  void visit (HIR::NegationExpr &expr) override;\n+  void visit (HIR::IfExpr &expr) override;\n+  void visit (HIR::IfExprConseqElse &expr) override;\n+  void visit (HIR::IfExprConseqIf &expr) override;\n+  void visit (HIR::IfLetExpr &expr) override;\n+  void visit (HIR::BlockExpr &expr) override;\n+  void visit (HIR::UnsafeBlockExpr &expr) override;\n+  void visit (HIR::ArrayIndexExpr &expr) override;\n+  void visit (HIR::ArrayExpr &expr) override;\n+  void visit (HIR::StructExprStruct &struct_expr) override;\n+  void visit (HIR::StructExprStructFields &struct_expr) override;\n+  void visit (HIR::GroupedExpr &expr) override;\n+  void visit (HIR::FieldAccessExpr &expr) override;\n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n+  void visit (HIR::PathInExpression &expr) override;\n+  void visit (HIR::LoopExpr &expr) override;\n+  void visit (HIR::BreakExpr &expr) override;\n+  void visit (HIR::ContinueExpr &expr) override;\n+  void visit (HIR::BorrowExpr &expr) override;\n+  void visit (HIR::DereferenceExpr &expr) override;\n+  void visit (HIR::TypeCastExpr &expr) override;\n+  void visit (HIR::MatchExpr &expr) override;\n+  void visit (HIR::RangeFromToExpr &expr) override;\n+  void visit (HIR::RangeFromExpr &expr) override;\n+  void visit (HIR::RangeToExpr &expr) override;\n+  void visit (HIR::RangeFullExpr &expr) override;\n+  void visit (HIR::RangeFromToInclExpr &expr) override;\n+  void visit (HIR::WhileLoopExpr &expr) override;\n+\n+  // TODO\n+  void visit (HIR::ClosureExprInnerTyped &) override {}\n+  void visit (HIR::ClosureExprInner &expr) override {}\n+  void visit (HIR::ErrorPropagationExpr &expr) override {}\n+  void visit (HIR::RangeToInclExpr &expr) override {}\n+  void visit (HIR::WhileLetLoopExpr &expr) override {}\n+  void visit (HIR::ForLoopExpr &expr) override {}\n+  void visit (HIR::IfExprConseqIfLet &expr) override {}\n+  void visit (HIR::IfLetExprConseqElse &expr) override {}\n+  void visit (HIR::IfLetExprConseqIf &expr) override {}\n+  void visit (HIR::IfLetExprConseqIfLet &expr) override {}\n+  void visit (HIR::AwaitExpr &expr) override {}\n+  void visit (HIR::AsyncBlockExpr &expr) override {}\n+\n+  // don't need to implement these see rust-hir-type-check-struct-field.h\n+  void visit (HIR::StructExprFieldIdentifier &field) override\n+  {\n+    gcc_unreachable ();\n+  }\n+  void visit (HIR::StructExprFieldIdentifierValue &field) override\n+  {\n+    gcc_unreachable ();\n+  }\n+  void visit (HIR::StructExprFieldIndexValue &field) override\n+  {\n+    gcc_unreachable ();\n+  }\n+\n+protected:\n+  bool\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExprMeta expr, TyTy::BaseType *lhs,\n+\t\t\t     TyTy::BaseType *rhs);\n+\n+private:\n+  TypeCheckExpr ();\n+\n+  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n+\t\t\t\t     size_t *offset,\n+\t\t\t\t     NodeId *root_resolved_node_id);\n+\n+  void resolve_segments (NodeId root_resolved_node_id,\n+\t\t\t std::vector<HIR::PathExprSegment> &segments,\n+\t\t\t size_t offset, TyTy::BaseType *tyseg,\n+\t\t\t const Analysis::NodeMapping &expr_mappings,\n+\t\t\t Location expr_locus);\n+\n+  bool\n+  validate_arithmetic_type (const TyTy::BaseType *tyty,\n+\t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type);\n+\n+  /* The return value of TypeCheckExpr::Resolve */\n+  TyTy::BaseType *infered;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_EXPR"}, {"sha": "784e4990409c3797b44307b62e75fc9e26ad0225", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.cc", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,583 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckTopLevelExternItem::TypeCheckTopLevelExternItem (\n+  const HIR::ExternBlock &parent)\n+  : TypeCheckBase (), parent (parent)\n+{}\n+\n+void\n+TypeCheckTopLevelExternItem::Resolve (HIR::ExternalItem *item,\n+\t\t\t\t      const HIR::ExternBlock &parent)\n+{\n+  TypeCheckTopLevelExternItem resolver (parent);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckTopLevelExternItem::visit (HIR::ExternalStaticItem &item)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (item.get_item_type ().get ());\n+\n+  context->insert_type (item.get_mappings (), actual_type);\n+}\n+\n+void\n+TypeCheckTopLevelExternItem::visit (HIR::ExternalFunctionItem &function)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ().get ());\n+\n+      // these are implicit mappings and not used\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      HIR::IdentifierPattern *param_pattern\n+\t= new HIR::IdentifierPattern (mapping, param.get_param_name (),\n+\t\t\t\t      Location (), false, Mutability::Imm,\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param_pattern,\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+\n+      // FIXME do we need error checking for patterns here?\n+      // see https://github.com/Rust-GCC/gccrs/issues/995\n+    }\n+\n+  uint8_t flags = TyTy::FnType::FNTYPE_IS_EXTERN_FLAG;\n+  if (function.is_variadic ())\n+    flags |= TyTy::FnType::FNTYPE_IS_VARADIC_FLAG;\n+\n+  RustIdent ident{\n+    CanonicalPath::new_seg (function.get_mappings ().get_nodeid (),\n+\t\t\t    function.get_item_name ()),\n+    function.get_locus ()};\n+\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_item_name (), ident, flags,\n+\t\t\t\t  parent.get_abi (), std::move (params),\n+\t\t\t\t  ret_type, std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+}\n+\n+TypeCheckTopLevelImplItem::TypeCheckTopLevelImplItem (\n+  TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+  : TypeCheckBase (), self (self), substitutions (substitutions)\n+{}\n+\n+void\n+TypeCheckTopLevelImplItem::Resolve (\n+  HIR::ImplItem *item, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+{\n+  TypeCheckTopLevelImplItem resolver (self, substitutions);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckTopLevelImplItem::visit (HIR::TypeAlias &alias)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+  context->insert_type (alias.get_mappings (), actual_type);\n+\n+  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+}\n+\n+void\n+TypeCheckTopLevelImplItem::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+}\n+\n+void\n+TypeCheckTopLevelImplItem::visit (HIR::Function &function)\n+{\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  if (function.is_method ())\n+    {\n+      // these are implicit mappings and not used\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      // add the synthetic self param at the front, this is a placeholder for\n+      // compilation to know parameter names. The types are ignored but we\n+      // reuse the HIR identifier pattern which requires it\n+      HIR::SelfParam &self_param = function.get_self_param ();\n+      HIR::IdentifierPattern *self_pattern\n+\t= new HIR::IdentifierPattern (mapping, \"self\", self_param.get_locus (),\n+\t\t\t\t      self_param.is_ref (),\n+\t\t\t\t      self_param.get_mut (),\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+\n+      // might have a specified type\n+      TyTy::BaseType *self_type = nullptr;\n+      if (self_param.has_type ())\n+\t{\n+\t  std::unique_ptr<HIR::Type> &specified_type = self_param.get_type ();\n+\t  self_type = TypeCheckType::Resolve (specified_type.get ());\n+\t}\n+      else\n+\t{\n+\t  switch (self_param.get_self_kind ())\n+\t    {\n+\t    case HIR::SelfParam::IMM:\n+\t    case HIR::SelfParam::MUT:\n+\t      self_type = self->clone ();\n+\t      break;\n+\n+\t    case HIR::SelfParam::IMM_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), Mutability::Imm);\n+\t      break;\n+\n+\t    case HIR::SelfParam::MUT_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), Mutability::Mut);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t      return;\n+\t    }\n+\t}\n+\n+      context->insert_type (self_param.get_mappings (), self_type);\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern, self_type));\n+    }\n+\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  function.is_method ()\n+\t\t\t\t    ? TyTy::FnType::FNTYPE_IS_METHOD_FLAG\n+\t\t\t\t    : TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n+\t\t\t\t  ABI::RUST, std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+}\n+\n+TypeCheckImplItem::TypeCheckImplItem (HIR::ImplBlock *parent,\n+\t\t\t\t      TyTy::BaseType *self)\n+  : TypeCheckBase (), parent (parent), self (self)\n+{}\n+\n+void\n+TypeCheckImplItem::Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n+\t\t\t    TyTy::BaseType *self)\n+{\n+  TypeCheckImplItem resolver (parent, self);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckImplItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+    {\n+      rust_error_at (function.get_locus (), \"failed to lookup function type\");\n+      return;\n+    }\n+\n+  if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      rust_error_at (function.get_locus (),\n+\t\t     \"found invalid type for function [%s]\",\n+\t\t     lookup->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n+  auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (parent, &function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  context->pop_return_type ();\n+  expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n+void\n+TypeCheckImplItem::visit (HIR::ConstantItem &const_item)\n+{}\n+\n+void\n+TypeCheckImplItem::visit (HIR::TypeAlias &type_alias)\n+{}\n+\n+TypeCheckImplItemWithTrait::TypeCheckImplItemWithTrait (\n+  HIR::ImplBlock *parent, TyTy::BaseType *self,\n+  TyTy::TypeBoundPredicate &trait_reference,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+  : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n+    resolved_trait_item (TyTy::TypeBoundPredicateItem::error ()),\n+    substitutions (substitutions)\n+{\n+  rust_assert (is_trait_impl_block ());\n+}\n+\n+TyTy::TypeBoundPredicateItem\n+TypeCheckImplItemWithTrait::Resolve (\n+  HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n+  TyTy::TypeBoundPredicate &trait_reference,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+{\n+  TypeCheckImplItemWithTrait resolver (parent, self, trait_reference,\n+\t\t\t\t       substitutions);\n+  item->accept_vis (resolver);\n+  return resolver.resolved_trait_item;\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::visit (HIR::ConstantItem &constant)\n+{\n+  // normal resolution of the item\n+  TypeCheckImplItem::visit (constant);\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n+    return;\n+\n+  // map the impl item to the associated trait item\n+  const auto tref = trait_reference.get ();\n+  const TraitItemReference *raw_trait_item = nullptr;\n+  bool found\n+    = tref->lookup_trait_item_by_type (constant.get_identifier (),\n+\t\t\t\t       TraitItemReference::TraitItemType::CONST,\n+\t\t\t\t       &raw_trait_item);\n+\n+  // unknown trait item\n+  if (!found || raw_trait_item->is_error ())\n+    {\n+      RichLocation r (constant.get_locus ());\n+      r.add_range (trait_reference.get_locus ());\n+      rust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n+\t\t     constant.get_identifier ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+      return;\n+    }\n+\n+  // get the item from the predicate\n+  resolved_trait_item = trait_reference.lookup_associated_item (raw_trait_item);\n+  rust_assert (!resolved_trait_item.is_error ());\n+\n+  // merge the attributes\n+  const HIR::TraitItem *hir_trait_item\n+    = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n+  merge_attributes (constant.get_outer_attrs (), *hir_trait_item);\n+\n+  // check the types are compatible\n+  auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+  if (!trait_item_type->can_eq (lookup, true))\n+    {\n+      RichLocation r (constant.get_locus ());\n+      r.add_range (resolved_trait_item.get_locus ());\n+\n+      rust_error_at (\n+\tr, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n+\tconstant.get_identifier ().c_str (),\n+\ttrait_reference.get_name ().c_str ());\n+    }\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::visit (HIR::TypeAlias &type)\n+{\n+  // normal resolution of the item\n+  TypeCheckImplItem::visit (type);\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+    return;\n+\n+  // map the impl item to the associated trait item\n+  const auto tref = trait_reference.get ();\n+  const TraitItemReference *raw_trait_item = nullptr;\n+  bool found\n+    = tref->lookup_trait_item_by_type (type.get_new_type_name (),\n+\t\t\t\t       TraitItemReference::TraitItemType::TYPE,\n+\t\t\t\t       &raw_trait_item);\n+\n+  // unknown trait item\n+  if (!found || raw_trait_item->is_error ())\n+    {\n+      RichLocation r (type.get_locus ());\n+      r.add_range (trait_reference.get_locus ());\n+      rust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n+\t\t     type.get_new_type_name ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+      return;\n+    }\n+\n+  // get the item from the predicate\n+  resolved_trait_item = trait_reference.lookup_associated_item (raw_trait_item);\n+  rust_assert (!resolved_trait_item.is_error ());\n+\n+  // merge the attributes\n+  const HIR::TraitItem *hir_trait_item\n+    = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n+  merge_attributes (type.get_outer_attrs (), *hir_trait_item);\n+\n+  // check the types are compatible\n+  auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+  if (!trait_item_type->can_eq (lookup, true))\n+    {\n+      RichLocation r (type.get_locus ());\n+      r.add_range (resolved_trait_item.get_locus ());\n+\n+      rust_error_at (\n+\tr, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n+\ttype.get_new_type_name ().c_str (),\n+\ttrait_reference.get_name ().c_str ());\n+    }\n+\n+  // its actually a projection, since we need a way to actually bind the\n+  // generic substitutions to the type itself\n+  TyTy::ProjectionType *projection\n+    = new TyTy::ProjectionType (type.get_mappings ().get_hirid (), lookup, tref,\n+\t\t\t\traw_trait_item->get_mappings ().get_defid (),\n+\t\t\t\tsubstitutions);\n+\n+  context->insert_type (type.get_mappings (), projection);\n+  raw_trait_item->associated_type_set (projection);\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::visit (HIR::Function &function)\n+{\n+  // we get the error checking from the base method here\n+  TypeCheckImplItem::visit (function);\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+    return;\n+\n+  // map the impl item to the associated trait item\n+  const auto tref = trait_reference.get ();\n+  const TraitItemReference *raw_trait_item = nullptr;\n+  bool found\n+    = tref->lookup_trait_item_by_type (function.get_function_name (),\n+\t\t\t\t       TraitItemReference::TraitItemType::FN,\n+\t\t\t\t       &raw_trait_item);\n+\n+  // unknown trait item\n+  if (!found || raw_trait_item->is_error ())\n+    {\n+      RichLocation r (function.get_locus ());\n+      r.add_range (trait_reference.get_locus ());\n+      rust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n+\t\t     function.get_function_name ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+      return;\n+    }\n+\n+  // get the item from the predicate\n+  resolved_trait_item = trait_reference.lookup_associated_item (raw_trait_item);\n+  rust_assert (!resolved_trait_item.is_error ());\n+\n+  // merge the attributes\n+  const HIR::TraitItem *hir_trait_item\n+    = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n+  merge_attributes (function.get_outer_attrs (), *hir_trait_item);\n+\n+  // check the types are compatible\n+  auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+  if (!trait_item_type->can_eq (lookup, true))\n+    {\n+      RichLocation r (function.get_locus ());\n+      r.add_range (resolved_trait_item.get_locus ());\n+\n+      rust_error_at (r,\n+\t\t     \"method %<%s%> has an incompatible type for trait %<%s%>\",\n+\t\t     function.get_function_name ().c_str (),\n+\t\t     trait_reference.get_name ().c_str ());\n+    }\n+}\n+\n+void\n+TypeCheckImplItemWithTrait::merge_attributes (AST::AttrVec &impl_item_attrs,\n+\t\t\t\t\t      const HIR::TraitItem &trait_item)\n+{\n+  for (const auto &attr : trait_item.get_outer_attrs ())\n+    {\n+      impl_item_attrs.push_back (attr);\n+    }\n+}\n+\n+bool\n+TypeCheckImplItemWithTrait::is_trait_impl_block () const\n+{\n+  return !trait_reference.is_error ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "f2f3faab9e00c4f1b3fef8ecab9dc047e72f69e5", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,114 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_IMPLITEM_H\n+#define RUST_HIR_TYPE_CHECK_IMPLITEM_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckTopLevelExternItem : public TypeCheckBase,\n+\t\t\t\t    public HIR::HIRExternalItemVisitor\n+{\n+public:\n+  static void Resolve (HIR::ExternalItem *item, const HIR::ExternBlock &parent);\n+\n+  void visit (HIR::ExternalStaticItem &item) override;\n+  void visit (HIR::ExternalFunctionItem &function) override;\n+\n+private:\n+  TypeCheckTopLevelExternItem (const HIR::ExternBlock &parent);\n+\n+  const HIR::ExternBlock &parent;\n+};\n+\n+class TypeCheckTopLevelImplItem : public TypeCheckBase,\n+\t\t\t\t  public HIR::HIRImplVisitor\n+{\n+public:\n+  static void\n+  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n+\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::Function &function) override;\n+\n+private:\n+  TypeCheckTopLevelImplItem (\n+    TyTy::BaseType *self,\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions);\n+\n+  TyTy::BaseType *self;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+};\n+\n+class TypeCheckImplItem : public TypeCheckBase, public HIR::HIRImplVisitor\n+{\n+public:\n+  static void Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n+\t\t       TyTy::BaseType *self);\n+\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::ConstantItem &const_item) override;\n+  void visit (HIR::TypeAlias &type_alias) override;\n+\n+protected:\n+  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self);\n+\n+  HIR::ImplBlock *parent;\n+  TyTy::BaseType *self;\n+};\n+\n+class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n+{\n+public:\n+  static TyTy::TypeBoundPredicateItem\n+  Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n+\t   TyTy::TypeBoundPredicate &trait_reference,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n+\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::TypeAlias &type) override;\n+  void visit (HIR::Function &function) override;\n+\n+protected:\n+  // this allows us to inherit the must_use specified on a trait definition onto\n+  // its implementation\n+  void merge_attributes (AST::AttrVec &impl_item_attrs,\n+\t\t\t const HIR::TraitItem &trait_item);\n+\n+private:\n+  TypeCheckImplItemWithTrait (\n+    HIR::ImplBlock *parent, TyTy::BaseType *self,\n+    TyTy::TypeBoundPredicate &trait_reference,\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions);\n+\n+  bool is_trait_impl_block () const;\n+\n+  TyTy::TypeBoundPredicate &trait_reference;\n+  TyTy::TypeBoundPredicateItem resolved_trait_item;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_IMPLITEM_H"}, {"sha": "d31a6df47779c10c897769b54d3687e3dc52a22e", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,237 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckItem::TypeCheckItem () : TypeCheckBase () {}\n+\n+void\n+TypeCheckItem::Resolve (HIR::Item &item)\n+{\n+  rust_assert (item.get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM);\n+  HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (item);\n+\n+  TypeCheckItem resolver;\n+  vis_item.accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (impl_block.has_generics ())\n+    {\n+      for (auto &generic_param : impl_block.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tTyTy::BaseType *l = nullptr;\n+\t\tbool ok = context->lookup_type (\n+\t\t  generic_param->get_mappings ().get_hirid (), &l);\n+\t\tif (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n+\t\t  {\n+\t\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t      static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t      static_cast<TyTy::ParamType *> (l)));\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  auto specified_bound = TyTy::TypeBoundPredicate::error ();\n+  TraitReference *trait_reference = &TraitReference::error_node ();\n+  if (impl_block.has_trait_ref ())\n+    {\n+      std::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n+      trait_reference = TraitResolver::Resolve (*ref.get ());\n+      rust_assert (!trait_reference->is_error ());\n+\n+      // we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n+      // for example\n+      specified_bound = get_predicate_from_bound (*ref.get ());\n+    }\n+\n+  TyTy::BaseType *self = nullptr;\n+  if (!context->lookup_type (\n+\timpl_block.get_type ()->get_mappings ().get_hirid (), &self))\n+    {\n+      rust_error_at (impl_block.get_locus (),\n+\t\t     \"failed to resolve Self for ImplBlock\");\n+      return;\n+    }\n+\n+  // inherit the bounds\n+  if (!specified_bound.is_error ())\n+    self->inherit_bounds ({specified_bound});\n+\n+  // check for any unconstrained type-params\n+  const TyTy::SubstitutionArgumentMappings trait_constraints\n+    = specified_bound.get_substitution_arguments ();\n+  const TyTy::SubstitutionArgumentMappings impl_constraints\n+    = GetUsedSubstArgs::From (self);\n+\n+  bool impl_block_has_unconstrained_typarams\n+    = check_for_unconstrained (substitutions, trait_constraints,\n+\t\t\t       impl_constraints, self);\n+  if (impl_block_has_unconstrained_typarams)\n+    return;\n+\n+  // validate the impl items\n+  bool is_trait_impl_block = !trait_reference->is_error ();\n+  std::vector<const TraitItemReference *> trait_item_refs;\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      if (!is_trait_impl_block)\n+\tTypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n+      else\n+\t{\n+\t  auto trait_item_ref\n+\t    = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n+\t\t\t\t\t\t   impl_item.get (), self,\n+\t\t\t\t\t\t   specified_bound,\n+\t\t\t\t\t\t   substitutions);\n+\t  trait_item_refs.push_back (trait_item_ref.get_raw_item ());\n+\t}\n+    }\n+\n+  bool impl_block_missing_trait_items\n+    = is_trait_impl_block\n+      && trait_reference->size () != trait_item_refs.size ();\n+  if (impl_block_missing_trait_items)\n+    {\n+      // filter the missing impl_items\n+      std::vector<std::reference_wrapper<const TraitItemReference>>\n+\tmissing_trait_items;\n+      for (const auto &trait_item_ref : trait_reference->get_trait_items ())\n+\t{\n+\t  bool found = false;\n+\t  for (auto implemented_trait_item : trait_item_refs)\n+\t    {\n+\t      std::string trait_item_name = trait_item_ref.get_identifier ();\n+\t      std::string impl_item_name\n+\t\t= implemented_trait_item->get_identifier ();\n+\t      found = trait_item_name.compare (impl_item_name) == 0;\n+\t      if (found)\n+\t\tbreak;\n+\t    }\n+\n+\t  bool is_required_trait_item = !trait_item_ref.is_optional ();\n+\t  if (!found && is_required_trait_item)\n+\t    missing_trait_items.push_back (trait_item_ref);\n+\t}\n+\n+      if (missing_trait_items.size () > 0)\n+\t{\n+\t  std::string missing_items_buf;\n+\t  RichLocation r (impl_block.get_locus ());\n+\t  for (size_t i = 0; i < missing_trait_items.size (); i++)\n+\t    {\n+\t      bool has_more = (i + 1) < missing_trait_items.size ();\n+\t      const TraitItemReference &missing_trait_item\n+\t\t= missing_trait_items.at (i);\n+\t      missing_items_buf += missing_trait_item.get_identifier ()\n+\t\t\t\t   + (has_more ? \", \" : \"\");\n+\t      r.add_range (missing_trait_item.get_locus ());\n+\t    }\n+\n+\t  rust_error_at (r, \"missing %s in implementation of trait %<%s%>\",\n+\t\t\t missing_items_buf.c_str (),\n+\t\t\t trait_reference->get_name ().c_str ());\n+\t}\n+    }\n+\n+  if (is_trait_impl_block)\n+    {\n+      trait_reference->clear_associated_types ();\n+\n+      AssociatedImplTrait associated (trait_reference, &impl_block, self,\n+\t\t\t\t      context);\n+      context->insert_associated_trait_impl (\n+\timpl_block.get_mappings ().get_hirid (), std::move (associated));\n+      context->insert_associated_impl_mapping (\n+\ttrait_reference->get_mappings ().get_hirid (), self,\n+\timpl_block.get_mappings ().get_hirid ());\n+    }\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+    {\n+      rust_error_at (function.get_locus (), \"failed to lookup function type\");\n+      return;\n+    }\n+\n+  if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      rust_error_at (function.get_locus (),\n+\t\t     \"found invalid type for function [%s]\",\n+\t\t     lookup->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    TypeCheckItem::Resolve (*item.get ());\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Trait &trait)\n+{\n+  TraitResolver::Resolve (trait);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "ba4de19c9c7389a5fe98523dcb304c9d241e9151", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_ITEM\n+#define RUST_HIR_TYPE_CHECK_ITEM\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckItem : private TypeCheckBase, private HIR::HIRVisItemVisitor\n+{\n+public:\n+  static void Resolve (HIR::Item &item);\n+\n+  void visit (HIR::ImplBlock &impl_block) override;\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::Module &module) override;\n+  void visit (HIR::Trait &trait) override;\n+\n+  // FIXME - get rid of toplevel pass\n+  void visit (HIR::TypeAlias &alias) override{};\n+  void visit (HIR::TupleStruct &struct_decl) override{};\n+  void visit (HIR::StructStruct &struct_decl) override{};\n+  void visit (HIR::Enum &enum_decl) override{};\n+  void visit (HIR::Union &union_decl) override{};\n+  void visit (HIR::StaticItem &var) override{};\n+  void visit (HIR::ConstantItem &constant) override{};\n+  void visit (HIR::ExternBlock &extern_block) override{};\n+\n+  // nothing to do\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n+\n+private:\n+  TypeCheckItem ();\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_ITEM"}, {"sha": "84f3b6ea6e61f0492231184977eceb5229db1b10", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,467 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n+  TyTy::BaseType *root\n+    = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  if (!qual_path_type.has_as_clause ())\n+    {\n+      NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+      resolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n+\t\t\texpr.get_mappings (), expr.get_locus ());\n+      return;\n+    }\n+\n+  // Resolve the trait now\n+  std::unique_ptr<HIR::TypePath> &trait_path_ref = qual_path_type.get_trait ();\n+  TraitReference *trait_ref = TraitResolver::Resolve (*trait_path_ref.get ());\n+  if (trait_ref->is_error ())\n+    return;\n+\n+  // does this type actually implement this type-bound?\n+  if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+    return;\n+\n+  // then we need to look at the next segment to create perform the correct\n+  // projection type\n+  if (expr.get_segments ().empty ())\n+    return;\n+\n+  // get the predicate for the bound\n+  auto specified_bound = get_predicate_from_bound (*trait_path_ref.get ());\n+  if (specified_bound.is_error ())\n+    return;\n+\n+  // inherit the bound\n+  root->inherit_bounds ({specified_bound});\n+\n+  // setup the associated types\n+  const TraitReference *specified_bound_ref = specified_bound.get ();\n+  auto candidates = TypeBoundsProbe::Probe (root);\n+  AssociatedImplTrait *associated_impl_trait = nullptr;\n+  for (auto &probed_bound : candidates)\n+    {\n+      const TraitReference *bound_trait_ref = probed_bound.first;\n+      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n+      AssociatedImplTrait *associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n+      if (found_impl_trait)\n+\t{\n+\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t  bool found_self = associated->get_self ()->can_eq (root, false);\n+\t  if (found_trait && found_self)\n+\t    {\n+\t      associated_impl_trait = associated;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (associated_impl_trait != nullptr)\n+    {\n+      associated_impl_trait->setup_associated_types (root, specified_bound);\n+    }\n+\n+  // lookup the associated item from the specified bound\n+  HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n+  HIR::PathIdentSegment item_seg_identifier = item_seg.get_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n+    {\n+      rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+\n+  // infer the root type\n+  infered = item.get_tyty_for_receiver (root);\n+\n+  // turbo-fish segment path::<ty>\n+  if (item_seg.has_generic_args ())\n+    {\n+      if (!infered->can_substitute ())\n+\t{\n+\t  rust_error_at (item_seg.get_locus (),\n+\t\t\t \"substitutions not supported for %s\",\n+\t\t\t infered->as_string ().c_str ());\n+\t  infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  return;\n+\t}\n+      infered = SubstMapper::Resolve (infered, expr.get_locus (),\n+\t\t\t\t      &item_seg.get_generic_args ());\n+    }\n+\n+  // continue on as a path-in-expression\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n+  bool fully_resolved = expr.get_segments ().size () <= 1;\n+\n+  if (fully_resolved)\n+    {\n+      resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t      root_resolved_node_id);\n+      context->insert_receiver (expr.get_mappings ().get_hirid (), root);\n+      return;\n+    }\n+\n+  resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n+\t\t    expr.get_mappings (), expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::PathInExpression &expr)\n+{\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  size_t offset = -1;\n+  TyTy::BaseType *tyseg = resolve_root_path (expr, &offset, &resolved_node_id);\n+  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  if (tyseg->needs_generic_substitutions ())\n+    {\n+      tyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n+    }\n+\n+  bool fully_resolved = offset == expr.get_segments ().size ();\n+  if (fully_resolved)\n+    {\n+      infered = tyseg;\n+      return;\n+    }\n+\n+  resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n+\t\t    expr.get_mappings (), expr.get_locus ());\n+}\n+\n+TyTy::BaseType *\n+TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n+\t\t\t\t  NodeId *root_resolved_node_id)\n+{\n+  TyTy::BaseType *root_tyty = nullptr;\n+  *offset = 0;\n+  for (size_t i = 0; i < expr.get_num_segments (); i++)\n+    {\n+      HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n+      bool have_more_segments = (expr.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n+      NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n+\n+      // then lookup the reference_node_id\n+      NodeId ref_node_id = UNKNOWN_NODEID;\n+      if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+\t{\n+\t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+\t}\n+\n+      // ref_node_id is the NodeId that the segments refers to.\n+      if (ref_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  if (root_tyty != nullptr && *offset > 0)\n+\t    {\n+\t      // then we can let the impl path probe take over now\n+\t      return root_tyty;\n+\t    }\n+\n+\t  rust_error_at (seg.get_locus (),\n+\t\t\t \"failed to type resolve root segment\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t}\n+\n+      // node back to HIR\n+      HirId ref;\n+      if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n+\t{\n+\t  rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t  rust_debug_loc (seg.get_locus (),\n+\t\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\t\t  seg.as_string ().c_str (),\n+\t\t\t  seg.get_mappings ().as_string ().c_str (),\n+\t\t\t  ref_node_id);\n+\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t}\n+\n+      auto seg_is_module = (nullptr != mappings->lookup_module (ref));\n+      auto seg_is_crate = mappings->is_local_hirid_crate (ref);\n+      if (seg_is_module || seg_is_crate)\n+\t{\n+\t  // A::B::C::this_is_a_module::D::E::F\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  //          Currently handling this.\n+\t  if (have_more_segments)\n+\t    {\n+\t      (*offset)++;\n+\t      continue;\n+\t    }\n+\n+\t  // In the case of :\n+\t  // A::B::C::this_is_a_module\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  // This is an error, we are not expecting a module.\n+\t  rust_error_at (seg.get_locus (), \"expected value\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t}\n+\n+      TyTy::BaseType *lookup = nullptr;\n+      if (!context->lookup_type (ref, &lookup))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // turbo-fish segment path::<ty>\n+      if (seg.has_generic_args ())\n+\t{\n+\t  if (!lookup->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     root_tyty->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\n+\t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t\t &seg.get_generic_args ());\n+\t  if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t}\n+\n+      *root_resolved_node_id = ref_node_id;\n+      *offset = *offset + 1;\n+      root_tyty = lookup;\n+    }\n+\n+  return root_tyty;\n+}\n+\n+void\n+TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n+\t\t\t\t std::vector<HIR::PathExprSegment> &segments,\n+\t\t\t\t size_t offset, TyTy::BaseType *tyseg,\n+\t\t\t\t const Analysis::NodeMapping &expr_mappings,\n+\t\t\t\t Location expr_locus)\n+{\n+  NodeId resolved_node_id = root_resolved_node_id;\n+  TyTy::BaseType *prev_segment = tyseg;\n+  bool reciever_is_generic = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+\n+  for (size_t i = offset; i < segments.size (); i++)\n+    {\n+      HIR::PathExprSegment &seg = segments.at (i);\n+\n+      bool probe_bounds = true;\n+      bool probe_impls = !reciever_is_generic;\n+      bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+      // probe the path is done in two parts one where we search impls if no\n+      // candidate is found then we search extensions from traits\n+      auto candidates\n+\t= PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n+\t\t\t\tfalse, ignore_mandatory_trait_items);\n+      if (candidates.size () == 0)\n+\t{\n+\t  candidates\n+\t    = PathProbeType::Probe (prev_segment, seg.get_segment (), false,\n+\t\t\t\t    probe_bounds, ignore_mandatory_trait_items);\n+\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      rust_error_at (\n+\t\tseg.get_locus (),\n+\t\t\"failed to resolve path segment using an impl Probe\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (candidates.size () > 1)\n+\t{\n+\t  ReportMultipleCandidateError::Report (candidates, seg.get_segment (),\n+\t\t\t\t\t\tseg.get_locus ());\n+\t  return;\n+\t}\n+\n+      auto &candidate = candidates.at (0);\n+      prev_segment = tyseg;\n+      tyseg = candidate.ty;\n+\n+      HIR::ImplBlock *associated_impl_block = nullptr;\n+      if (candidate.is_enum_candidate ())\n+\t{\n+\t  const TyTy::VariantDef *variant = candidate.item.enum_field.variant;\n+\n+\t  HirId variant_id = variant->get_id ();\n+\t  HIR::Item *enum_item = mappings->lookup_hir_item (variant_id);\n+\t  rust_assert (enum_item != nullptr);\n+\n+\t  resolved_node_id = enum_item->get_mappings ().get_nodeid ();\n+\n+\t  // insert the id of the variant we are resolved to\n+\t  context->insert_variant_definition (expr_mappings.get_hirid (),\n+\t\t\t\t\t      variant_id);\n+\t}\n+      else if (candidate.is_impl_candidate ())\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\n+\t  associated_impl_block = candidate.item.impl.parent;\n+\t}\n+      else\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t  // lookup the associated-impl-trait\n+\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t  if (impl != nullptr)\n+\t    {\n+\t      // get the associated impl block\n+\t      associated_impl_block = impl;\n+\t    }\n+\t}\n+\n+      if (associated_impl_block != nullptr)\n+\t{\n+\t  // get the type of the parent Self\n+\t  HirId impl_ty_id\n+\t    = associated_impl_block->get_type ()->get_mappings ().get_hirid ();\n+\t  TyTy::BaseType *impl_block_ty = nullptr;\n+\t  bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+\t  rust_assert (ok);\n+\n+\t  if (impl_block_ty->needs_generic_substitutions ())\n+\t    impl_block_ty\n+\t      = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n+\n+\t  prev_segment = prev_segment->unify (impl_block_ty);\n+\t}\n+\n+      if (tyseg->needs_generic_substitutions ())\n+\t{\n+\t  if (!prev_segment->needs_generic_substitutions ())\n+\t    {\n+\t      auto used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (prev_segment);\n+\n+\t      if (!used_args_in_prev_segment.is_error ())\n+\t\t{\n+\t\t  if (SubstMapperInternal::mappings_are_bound (\n+\t\t\ttyseg, used_args_in_prev_segment))\n+\t\t    {\n+\t\t      tyseg = SubstMapperInternal::Resolve (\n+\t\t\ttyseg, used_args_in_prev_segment);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (seg.has_generic_args ())\n+\t{\n+\t  if (!tyseg->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t     tyseg->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\n+\t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t&seg.get_generic_args ());\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n+\t}\n+      else if (tyseg->needs_generic_substitutions () && !reciever_is_generic)\n+\t{\n+\t  Location locus = seg.get_locus ();\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n+\t}\n+    }\n+\n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+  if (tyseg->needs_generic_substitutions () && !reciever_is_generic)\n+    {\n+      Location locus = segments.back ().get_locus ();\n+      tyseg = SubstMapper::InferSubst (tyseg, locus);\n+      if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+    {\n+      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t     resolved_node_id))\n+    {\n+      resolver->insert_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n+    }\n+\n+  infered = tyseg;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "429511d02921019727447af9daedec5256d4de6f", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,416 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckPattern::TypeCheckPattern (TyTy::BaseType *parent)\n+  : TypeCheckBase (), parent (parent), infered (nullptr)\n+{}\n+\n+TyTy::BaseType *\n+TypeCheckPattern::Resolve (HIR::Pattern *pattern, TyTy::BaseType *parent)\n+{\n+  TypeCheckPattern resolver (parent);\n+  pattern->accept_vis (resolver);\n+\n+  if (resolver.infered == nullptr)\n+    return new TyTy::ErrorType (pattern->get_pattern_mappings ().get_hirid ());\n+\n+  resolver.context->insert_type (pattern->get_pattern_mappings (),\n+\t\t\t\t resolver.infered);\n+  return resolver.infered;\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::PathInExpression &pattern)\n+{\n+  infered = TypeCheckExpr::Resolve (&pattern);\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::TupleStructPattern &pattern)\n+{\n+  infered = TypeCheckExpr::Resolve (&pattern.get_path ());\n+  if (infered->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  rust_assert (infered->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (infered);\n+  rust_assert (adt->number_of_variants () > 0);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+  if (adt->is_enum ())\n+    {\n+      HirId variant_id = UNKNOWN_HIRID;\n+      bool ok = context->lookup_variant_definition (\n+\tpattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+      rust_assert (ok);\n+\n+      ok = adt->lookup_variant_by_id (variant_id, &variant);\n+      rust_assert (ok);\n+    }\n+\n+  // error[E0532]: expected tuple struct or tuple variant, found struct variant\n+  // `Foo::D`\n+  if (variant->get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n+    {\n+      std::string variant_type\n+\t= TyTy::VariantDef::variant_type_string (variant->get_variant_type ());\n+\n+      rust_error_at (\n+\tpattern.get_locus (),\n+\t\"expected tuple struct or tuple variant, found %s variant %<%s::%s%>\",\n+\tvariant_type.c_str (), adt->get_name ().c_str (),\n+\tvariant->get_identifier ().c_str ());\n+      return;\n+    }\n+\n+  // check the elements\n+  // error[E0023]: this pattern has 2 fields, but the corresponding tuple\n+  // variant has 1 field\n+  // error[E0023]: this pattern has 0 fields, but the corresponding tuple\n+  // variant has 1 field\n+\n+  std::unique_ptr<HIR::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case HIR::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case HIR::TupleStructItems::NO_RANGE: {\n+\tHIR::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<HIR::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tif (items_no_range.get_patterns ().size () != variant->num_fields ())\n+\t  {\n+\t    rust_error_at (\n+\t      pattern.get_locus (),\n+\t      \"this pattern has %lu fields but the corresponding \"\n+\t      \"tuple variant has %lu field\",\n+\t      (unsigned long) items_no_range.get_patterns ().size (),\n+\t      (unsigned long) variant->num_fields ());\n+\t    // we continue on to try and setup the types as best we can for\n+\t    // type checking\n+\t  }\n+\n+\t// iterate the fields and set them up, I wish we had ZIP\n+\tsize_t i = 0;\n+\tfor (auto &pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    if (i >= variant->num_fields ())\n+\t      break;\n+\n+\t    TyTy::StructFieldType *field = variant->get_field_at_index (i++);\n+\t    TyTy::BaseType *fty = field->get_field_type ();\n+\n+\t    // setup the type on this pattern type\n+\t    context->insert_type (pattern->get_pattern_mappings (), fty);\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::StructPattern &pattern)\n+{\n+  infered = TypeCheckExpr::Resolve (&pattern.get_path ());\n+  if (infered->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  rust_assert (infered->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (infered);\n+  rust_assert (adt->number_of_variants () > 0);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+  if (adt->is_enum ())\n+    {\n+      HirId variant_id = UNKNOWN_HIRID;\n+      bool ok = context->lookup_variant_definition (\n+\tpattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+      rust_assert (ok);\n+\n+      ok = adt->lookup_variant_by_id (variant_id, &variant);\n+      rust_assert (ok);\n+    }\n+\n+  // error[E0532]: expected tuple struct or tuple variant, found struct variant\n+  // `Foo::D`\n+  if (variant->get_variant_type () != TyTy::VariantDef::VariantType::STRUCT)\n+    {\n+      std::string variant_type\n+\t= TyTy::VariantDef::variant_type_string (variant->get_variant_type ());\n+      rust_error_at (pattern.get_locus (),\n+\t\t     \"expected struct variant, found %s variant %s\",\n+\t\t     variant_type.c_str (),\n+\t\t     variant->get_identifier ().c_str ());\n+      return;\n+    }\n+\n+  // check the elements\n+  // error[E0027]: pattern does not mention fields `x`, `y`\n+  // error[E0026]: variant `Foo::D` does not have a field named `b`\n+\n+  std::vector<std::string> named_fields;\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case HIR::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT: {\n+\t    HIR::StructPatternFieldIdent &ident\n+\t      = static_cast<HIR::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    TyTy::StructFieldType *field = nullptr;\n+\t    if (!variant->lookup_field (ident.get_identifier (), &field,\n+\t\t\t\t\tnullptr))\n+\t      {\n+\t\trust_error_at (ident.get_locus (),\n+\t\t\t       \"variant %s does not have a field named %s\",\n+\t\t\t       variant->get_identifier ().c_str (),\n+\t\t\t       ident.get_identifier ().c_str ());\n+\t\tbreak;\n+\t      }\n+\t    named_fields.push_back (ident.get_identifier ());\n+\n+\t    // setup the type on this pattern\n+\t    TyTy::BaseType *fty = field->get_field_type ();\n+\t    context->insert_type (ident.get_mappings (), fty);\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  if (named_fields.size () != variant->num_fields ())\n+    {\n+      std::map<std::string, bool> missing_names;\n+\n+      // populate with all fields\n+      for (auto &field : variant->get_fields ())\n+\tmissing_names[field->get_name ()] = true;\n+\n+      // then eliminate with named_fields\n+      for (auto &named : named_fields)\n+\tmissing_names.erase (named);\n+\n+      // then get the list of missing names\n+      size_t i = 0;\n+      std::string missing_fields_str;\n+      for (auto it = missing_names.begin (); it != missing_names.end (); it++)\n+\t{\n+\t  bool has_next = (i + 1) < missing_names.size ();\n+\t  missing_fields_str += it->first + (has_next ? \", \" : \"\");\n+\t  i++;\n+\t}\n+\n+      rust_error_at (pattern.get_locus (), \"pattern does not mention fields %s\",\n+\t\t     missing_fields_str.c_str ());\n+    }\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::WildcardPattern &pattern)\n+{\n+  // wildcard patterns within the MatchArm's are simply just the same type as\n+  // the parent\n+  infered = parent->clone ();\n+  infered->set_ref (pattern.get_pattern_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::TuplePattern &pattern)\n+{\n+  std::unique_ptr<HIR::TuplePatternItems> items;\n+  switch (pattern.get_items ()->get_pattern_type ())\n+    {\n+      case HIR::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tHIR::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<HIR::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\n+\tstd::vector<TyTy::TyVar> pattern_elems;\n+\tfor (size_t i = 0; i < ref.get_patterns ().size (); i++)\n+\t  {\n+\t    auto &p = ref.get_patterns ()[i];\n+\t    TyTy::BaseType *par_type = parent;\n+\t    if (parent->get_kind () == TyTy::TUPLE)\n+\t      {\n+\t\tTyTy::TupleType &par = *static_cast<TyTy::TupleType *> (parent);\n+\t\tpar_type = par.get_field (i);\n+\t      }\n+\n+\t    TyTy::BaseType *elem\n+\t      = TypeCheckPattern::Resolve (p.get (), par_type);\n+\t    pattern_elems.push_back (TyTy::TyVar (elem->get_ref ()));\n+\t  }\n+\tinfered\n+\t  = new TyTy::TupleType (pattern.get_pattern_mappings ().get_hirid (),\n+\t\t\t\t pattern.get_locus (), pattern_elems);\n+      }\n+      break;\n+\n+      case HIR::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\t// HIR::TuplePatternItemsRanged &ref\n+\t//   = *static_cast<HIR::TuplePatternItemsRanged *> (\n+\t//     pattern.get_items ().get ());\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::LiteralPattern &pattern)\n+{\n+  infered = resolve_literal (pattern.get_pattern_mappings (),\n+\t\t\t     pattern.get_literal (), pattern.get_locus ());\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::RangePattern &pattern)\n+{\n+  // Resolve the upper and lower bounds, and ensure they are compatible types\n+  TyTy::BaseType *upper = nullptr, *lower = nullptr;\n+\n+  // TODO: It would be nice to factor this out into a helper since the logic for\n+  // both bounds is exactly the same...\n+  switch (pattern.get_upper_bound ()->get_bound_type ())\n+    {\n+      case HIR::RangePatternBound::RangePatternBoundType::LITERAL: {\n+\tHIR::RangePatternBoundLiteral &ref\n+\t  = *static_cast<HIR::RangePatternBoundLiteral *> (\n+\t    pattern.get_upper_bound ().get ());\n+\n+\tHIR::Literal lit = ref.get_literal ();\n+\n+\tupper = resolve_literal (pattern.get_pattern_mappings (), lit,\n+\t\t\t\t pattern.get_locus ());\n+      }\n+      break;\n+\n+      case HIR::RangePatternBound::RangePatternBoundType::PATH: {\n+\tHIR::RangePatternBoundPath &ref\n+\t  = *static_cast<HIR::RangePatternBoundPath *> (\n+\t    pattern.get_upper_bound ().get ());\n+\n+\tupper = TypeCheckExpr::Resolve (&ref.get_path ());\n+      }\n+      break;\n+\n+      case HIR::RangePatternBound::RangePatternBoundType::QUALPATH: {\n+\tHIR::RangePatternBoundQualPath &ref\n+\t  = *static_cast<HIR::RangePatternBoundQualPath *> (\n+\t    pattern.get_upper_bound ().get ());\n+\n+\tupper = TypeCheckExpr::Resolve (&ref.get_qualified_path ());\n+      }\n+      break;\n+    }\n+\n+  switch (pattern.get_lower_bound ()->get_bound_type ())\n+    {\n+      case HIR::RangePatternBound::RangePatternBoundType::LITERAL: {\n+\tHIR::RangePatternBoundLiteral &ref\n+\t  = *static_cast<HIR::RangePatternBoundLiteral *> (\n+\t    pattern.get_lower_bound ().get ());\n+\n+\tHIR::Literal lit = ref.get_literal ();\n+\n+\tlower = resolve_literal (pattern.get_pattern_mappings (), lit,\n+\t\t\t\t pattern.get_locus ());\n+      }\n+      break;\n+\n+      case HIR::RangePatternBound::RangePatternBoundType::PATH: {\n+\tHIR::RangePatternBoundPath &ref\n+\t  = *static_cast<HIR::RangePatternBoundPath *> (\n+\t    pattern.get_lower_bound ().get ());\n+\n+\tlower = TypeCheckExpr::Resolve (&ref.get_path ());\n+      }\n+      break;\n+\n+      case HIR::RangePatternBound::RangePatternBoundType::QUALPATH: {\n+\tHIR::RangePatternBoundQualPath &ref\n+\t  = *static_cast<HIR::RangePatternBoundQualPath *> (\n+\t    pattern.get_lower_bound ().get ());\n+\n+\tlower = TypeCheckExpr::Resolve (&ref.get_qualified_path ());\n+      }\n+      break;\n+    }\n+\n+  infered = upper->unify (lower);\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::IdentifierPattern &pattern)\n+{\n+  infered = parent;\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::GroupedPattern &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::QualifiedPathInExpression &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::ReferencePattern &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::SlicePattern &pattern)\n+{\n+  // TODO\n+  gcc_unreachable ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "8af106033b7d1bae9b0147d013b7214058c32b13", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_PATTERN\n+#define RUST_HIR_TYPE_CHECK_PATTERN\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckPattern : public TypeCheckBase, public HIR::HIRPatternVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (HIR::Pattern *pattern,\n+\t\t\t\t  TyTy::BaseType *parent);\n+\n+  void visit (HIR::PathInExpression &pattern) override;\n+  void visit (HIR::StructPattern &pattern) override;\n+  void visit (HIR::TupleStructPattern &pattern) override;\n+  void visit (HIR::WildcardPattern &pattern) override;\n+  void visit (HIR::TuplePattern &pattern) override;\n+  void visit (HIR::LiteralPattern &pattern) override;\n+  void visit (HIR::RangePattern &pattern) override;\n+  void visit (HIR::IdentifierPattern &pattern) override;\n+  void visit (HIR::GroupedPattern &pattern) override;\n+  void visit (HIR::QualifiedPathInExpression &pattern) override;\n+  void visit (HIR::ReferencePattern &pattern) override;\n+  void visit (HIR::SlicePattern &pattern) override;\n+\n+private:\n+  TypeCheckPattern (TyTy::BaseType *parent);\n+\n+  static TyTy::BaseType *\n+  typecheck_range_pattern_bound (HIR::RangePatternBound *bound,\n+\t\t\t\t Analysis::NodeMapping mappings,\n+\t\t\t\t Location locus);\n+\n+  TyTy::BaseType *parent;\n+  TyTy::BaseType *infered;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_PATTERN"}, {"sha": "9f34ed49165d0933ffadb79dce75140c373522cb", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.cc", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,498 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::BaseType *\n+TypeCheckStmt::Resolve (HIR::Stmt *stmt)\n+{\n+  TypeCheckStmt resolver;\n+  stmt->accept_vis (resolver);\n+  return resolver.infered;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ExprStmtWithBlock &stmt)\n+{\n+  infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ExprStmtWithoutBlock &stmt)\n+{\n+  infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::EmptyStmt &stmt)\n+{\n+  infered = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      TypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n+    }\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  infered = type->unify (expr_type);\n+  context->insert_type (constant.get_mappings (), infered);\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::LetStmt &stmt)\n+{\n+  infered = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n+\n+  const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n+  TyTy::BaseType *init_expr_ty = nullptr;\n+  if (stmt.has_init_expr ())\n+    {\n+      init_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n+      if (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      init_expr_ty->append_reference (\n+\tstmt_pattern.get_pattern_mappings ().get_hirid ());\n+    }\n+\n+  TyTy::BaseType *specified_ty = nullptr;\n+  if (stmt.has_type ())\n+    specified_ty = TypeCheckType::Resolve (stmt.get_type ());\n+\n+  // let x:i32 = 123;\n+  if (specified_ty != nullptr && init_expr_ty != nullptr)\n+    {\n+      // FIXME use this result and look at the regressions\n+      coercion_site (stmt.get_mappings ().get_hirid (), specified_ty,\n+\t\t     init_expr_ty, stmt.get_locus ());\n+      context->insert_type (stmt_pattern.get_pattern_mappings (), specified_ty);\n+    }\n+  else\n+    {\n+      // let x:i32;\n+      if (specified_ty != nullptr)\n+\t{\n+\t  context->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t\tspecified_ty);\n+\t}\n+      // let x = 123;\n+      else if (init_expr_ty != nullptr)\n+\t{\n+\t  context->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t\tinit_expr_ty);\n+\t}\n+      // let x;\n+      else\n+\t{\n+\t  context->insert_type (\n+\t    stmt_pattern.get_pattern_mappings (),\n+\t    new TyTy::InferType (\n+\t      stmt_pattern.get_pattern_mappings ().get_hirid (),\n+\t      TyTy::InferType::InferTypeKind::GENERAL, stmt.get_locus ()));\n+\t}\n+    }\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::TupleStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic_param : struct_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+\n+  // Process #[repr(...)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::Enum &enum_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (enum_decl.has_generics ())\n+    {\n+      for (auto &generic_param : enum_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::VariantDef *> variants;\n+  int64_t discriminant_value = 0;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      TyTy::VariantDef *field_type\n+\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+      discriminant_value++;\n+      variants.push_back (field_type);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (enum_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t enum_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (enum_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::StructStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic_param : struct_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  // Process #[repr(...)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::Union &union_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (union_decl.has_generics ())\n+    {\n+      for (auto &generic_param : union_decl.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &variant : union_decl.get_variants ())\n+    {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type);\n+      fields.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (union_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t union_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (union_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckStmt::visit (HIR::Function &function)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n+\t\t\t\t  std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+  context->insert_type (function.get_mappings (), fnType);\n+\n+  TyTy::FnType *resolved_fn_type = fnType;\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  context->pop_return_type ();\n+\n+  if (block_expr_ty->get_kind () != TyTy::NEVER)\n+    expected_ret_tyty->unify (block_expr_ty);\n+\n+  infered = fnType;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "a79f17a59cec2f6399068ae1c477426b94edd40e", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_STMT\n+#define RUST_HIR_TYPE_CHECK_STMT\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckStmt : private TypeCheckBase, private HIR::HIRStmtVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (HIR::Stmt *stmt);\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt) override;\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override;\n+  void visit (HIR::EmptyStmt &stmt) override;\n+  void visit (HIR::ExternBlock &extern_block) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::LetStmt &stmt) override;\n+  void visit (HIR::TupleStruct &struct_decl) override;\n+  void visit (HIR::Enum &enum_decl) override;\n+  void visit (HIR::StructStruct &struct_decl) override;\n+  void visit (HIR::Union &union_decl) override;\n+  void visit (HIR::Function &function) override;\n+\n+  void visit (HIR::EnumItemTuple &) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::EnumItemStruct &) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::EnumItem &item) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::EnumItemDiscriminant &) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::TypePathSegmentFunction &segment) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::TypePath &path) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::QualifiedPathInType &path) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::Module &module) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::ExternCrate &crate) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::UseDeclaration &use_decl) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::TypeAlias &type_alias) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::StaticItem &static_item) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::Trait &trait) override\n+  { /* TODO? */\n+  }\n+  void visit (HIR::ImplBlock &impl) override\n+  { /* TODO? */\n+  }\n+\n+private:\n+  TypeCheckStmt () : TypeCheckBase (), infered (nullptr) {}\n+\n+  TyTy::BaseType *infered;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_STMT"}, {"sha": "22af1aad4c31314b67b04bf442b987720472bde1", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+#define RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckStructExpr : public TypeCheckBase\n+{\n+public:\n+  static TyTy::BaseType *Resolve (HIR::StructExprStructFields *expr);\n+\n+protected:\n+  void resolve (HIR::StructExprStructFields &struct_expr);\n+\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+  void visit (HIR::StructExprFieldIndexValue &field);\n+  void visit (HIR::StructExprFieldIdentifier &field);\n+\n+private:\n+  TypeCheckStructExpr (HIR::Expr *e);\n+\n+  // result\n+  TyTy::BaseType *resolved;\n+\n+  // internal state:\n+  TyTy::ADTType *struct_path_resolved;\n+  TyTy::VariantDef *variant;\n+  TyTy::BaseType *resolved_field_value_expr;\n+  std::set<std::string> fields_assigned;\n+  std::map<size_t, HIR::StructExprField *> adtFieldIndexToField;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_STRUCT_FIELD"}, {"sha": "b2261e8cdb36977bca1d247b0c35c7d096d1bcd1", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,340 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckStructExpr::TypeCheckStructExpr (HIR::Expr *e)\n+  : TypeCheckBase (),\n+    resolved (new TyTy::ErrorType (e->get_mappings ().get_hirid ())),\n+    struct_path_resolved (nullptr),\n+    variant (&TyTy::VariantDef::get_error_node ())\n+{}\n+\n+TyTy::BaseType *\n+TypeCheckStructExpr::Resolve (HIR::StructExprStructFields *expr)\n+{\n+  TypeCheckStructExpr resolver (expr);\n+  resolver.resolve (*expr);\n+  return resolver.resolved;\n+}\n+\n+void\n+TypeCheckStructExpr::resolve (HIR::StructExprStructFields &struct_expr)\n+{\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n+      return;\n+    }\n+\n+  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n+  TyTy::ADTType *struct_def = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::BaseType *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n+      struct_def = static_cast<TyTy::ADTType *> (\n+\tstruct_path_resolved->unify (base_resolved));\n+      if (struct_def == nullptr)\n+\t{\n+\t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n+\t\t\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+\n+  // figure out the variant\n+  if (struct_path_resolved->is_enum ())\n+    {\n+      // lookup variant id\n+      HirId variant_id;\n+      bool ok = context->lookup_variant_definition (\n+\tstruct_expr.get_struct_name ().get_mappings ().get_hirid (),\n+\t&variant_id);\n+      rust_assert (ok);\n+\n+      ok = struct_path_resolved->lookup_variant_by_id (variant_id, &variant);\n+      rust_assert (ok);\n+    }\n+  else\n+    {\n+      rust_assert (struct_path_resolved->number_of_variants () == 1);\n+      variant = struct_path_resolved->get_variants ().at (0);\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> infered_fields;\n+  bool ok = true;\n+\n+  for (auto &field : struct_expr.get_fields ())\n+    {\n+      resolved_field_value_expr = nullptr;\n+\n+      switch (field->get_kind ())\n+\t{\n+\tcase HIR::StructExprField::StructExprFieldKind::IDENTIFIER:\n+\t  visit (static_cast<HIR::StructExprFieldIdentifier &> (*field.get ()));\n+\t  break;\n+\n+\tcase HIR::StructExprField::StructExprFieldKind::IDENTIFIER_VALUE:\n+\t  visit (\n+\t    static_cast<HIR::StructExprFieldIdentifierValue &> (*field.get ()));\n+\t  break;\n+\n+\tcase HIR::StructExprField::StructExprFieldKind::INDEX_VALUE:\n+\t  visit (static_cast<HIR::StructExprFieldIndexValue &> (*field.get ()));\n+\t  break;\n+\t}\n+\n+      if (resolved_field_value_expr == nullptr)\n+\t{\n+\t  rust_fatal_error (field->get_locus (),\n+\t\t\t    \"failed to resolve type for field\");\n+\t  ok = false;\n+\t  break;\n+\t}\n+\n+      context->insert_type (field->get_mappings (), resolved_field_value_expr);\n+    }\n+\n+  // something failed setting up the fields\n+  if (!ok)\n+    {\n+      rust_error_at (struct_expr.get_locus (),\n+\t\t     \"constructor type resolution failure\");\n+      return;\n+    }\n+\n+  // check the arguments are all assigned and fix up the ordering\n+  if (fields_assigned.size () != variant->num_fields ())\n+    {\n+      if (struct_def->is_union ())\n+\t{\n+\t  if (fields_assigned.size () != 1 || struct_expr.has_struct_base ())\n+\t    {\n+\t      rust_error_at (\n+\t\tstruct_expr.get_locus (),\n+\t\t\"union must have exactly one field variant assigned\");\n+\t      return;\n+\t    }\n+\t}\n+      else if (!struct_expr.has_struct_base ())\n+\t{\n+\t  rust_error_at (struct_expr.get_locus (),\n+\t\t\t \"constructor is missing fields\");\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  // we have a struct base to assign the missing fields from.\n+\t  // the missing fields can be implicit FieldAccessExprs for the value\n+\t  std::set<std::string> missing_fields;\n+\t  for (auto &field : variant->get_fields ())\n+\t    {\n+\t      auto it = fields_assigned.find (field->get_name ());\n+\t      if (it == fields_assigned.end ())\n+\t\tmissing_fields.insert (field->get_name ());\n+\t    }\n+\n+\t  // we can generate FieldAccessExpr or TupleAccessExpr for the\n+\t  // values of the missing fields.\n+\t  for (auto &missing : missing_fields)\n+\t    {\n+\t      HIR::Expr *receiver\n+\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n+\n+\t      HIR::StructExprField *implicit_field = nullptr;\n+\n+\t      AST::AttrVec outer_attribs;\n+\t      auto crate_num = mappings->get_current_crate ();\n+\t      Analysis::NodeMapping mapping (\n+\t\tcrate_num,\n+\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n+\t\t  .get_nodeid (),\n+\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n+\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n+\t\tstd::move (outer_attribs),\n+\t\tstruct_expr.struct_base->base_struct->get_locus ());\n+\n+\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n+\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n+\t\tstruct_expr.struct_base->base_struct->get_locus ());\n+\n+\t      size_t field_index;\n+\t      bool ok = variant->lookup_field (missing, nullptr, &field_index);\n+\t      rust_assert (ok);\n+\n+\t      adtFieldIndexToField[field_index] = implicit_field;\n+\t      struct_expr.get_fields ().push_back (\n+\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n+\t    }\n+\t}\n+    }\n+\n+  if (struct_def->is_union ())\n+    {\n+      // There is exactly one field in this constructor, we need to\n+      // figure out the field index to make sure we initialize the\n+      // right union field.\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  if (adtFieldIndexToField[i])\n+\t    {\n+\t      struct_expr.union_index = i;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (struct_expr.union_index != -1);\n+    }\n+  else\n+    {\n+      // everything is ok, now we need to ensure all field values are ordered\n+      // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n+      // assigned field in the constructor is in the same order as the field in\n+      // the type\n+      for (auto &field : struct_expr.get_fields ())\n+\tfield.release ();\n+\n+      std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  ordered_fields.push_back (\n+\t    std::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n+\t}\n+      struct_expr.set_fields_as_owner (std::move (ordered_fields));\n+    }\n+\n+  resolved = struct_def;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  auto it = fields_assigned.find (field.field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.field_name, &field_type, &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n+  resolved_field_value_expr\n+    = coercion_site (field.get_mappings ().get_hirid (),\n+\t\t     field_type->get_field_type (), value, field.get_locus ());\n+  if (resolved_field_value_expr != nullptr)\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  std::string field_name (std::to_string (field.get_tuple_index ()));\n+  auto it = fields_assigned.find (field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field_name, &field_type, &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n+  resolved_field_value_expr\n+    = coercion_site (field.get_mappings ().get_hirid (),\n+\t\t     field_type->get_field_type (), value, field.get_locus ());\n+  if (resolved_field_value_expr != nullptr)\n+    {\n+      fields_assigned.insert (field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  auto it = fields_assigned.find (field.get_field_name ());\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.get_field_name (), &field_type,\n+\t\t\t\t   &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  // we can make the field look like a path expr to take advantage of existing\n+  // code\n+  Analysis::NodeMapping mappings_copy1 = field.get_mappings ();\n+  Analysis::NodeMapping mappings_copy2 = field.get_mappings ();\n+\n+  HIR::PathIdentSegment ident_seg (field.get_field_name ());\n+  HIR::PathExprSegment seg (mappings_copy1, ident_seg, field.get_locus (),\n+\t\t\t    HIR::GenericArgs::create_empty ());\n+  HIR::PathInExpression expr (mappings_copy2, {seg}, field.get_locus (), false,\n+\t\t\t      {});\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr);\n+\n+  resolved_field_value_expr\n+    = coercion_site (field.get_mappings ().get_hirid (),\n+\t\t     field_type->get_field_type (), value, field.get_locus ());\n+  if (resolved_field_value_expr != nullptr)\n+\n+    {\n+      fields_assigned.insert (field.get_field_name ());\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "27f36b642fc72227444b6bef01430224096a5abd", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.cc", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,364 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-toplevel.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckTopLevel::TypeCheckTopLevel () : TypeCheckBase () {}\n+\n+void\n+TypeCheckTopLevel::Resolve (HIR::Item &item)\n+{\n+  rust_assert (item.get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM);\n+  HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (item);\n+\n+  TypeCheckTopLevel resolver;\n+  vis_item.accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::TypeAlias &alias)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+  context->insert_type (alias.get_mappings (), actual_type);\n+\n+  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::TupleStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // its a single variant ADT\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+\n+  // Process #[repr(X)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    TypeCheckTopLevel::Resolve (*item.get ());\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::StructStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // its a single variant ADT\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  // Process #[repr(X)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Enum &enum_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (enum_decl.has_generics ())\n+    resolve_generic_params (enum_decl.get_generic_params (), substitutions);\n+\n+  std::vector<TyTy::VariantDef *> variants;\n+  int64_t discriminant_value = 0;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      TyTy::VariantDef *field_type\n+\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+      discriminant_value++;\n+      variants.push_back (field_type);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (enum_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n+  // multi variant ADT\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t enum_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (enum_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Union &union_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (union_decl.has_generics ())\n+    resolve_generic_params (union_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &variant : union_decl.get_variants ())\n+    {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type);\n+      fields.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (union_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t union_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (union_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::StaticItem &var)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n+\n+  context->insert_type (var.get_mappings (), type->unify (expr_type));\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Function &function)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (function.has_generics ())\n+    resolve_generic_params (function.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *>> params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n+\t\t\t\t  std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::ImplBlock &impl_block)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (impl_block.has_generics ())\n+    resolve_generic_params (impl_block.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n+  if (self->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self, substitutions);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      TypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "d0db07d7281749aada1c3697f29e48d6647a24a7", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,56 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_TOPLEVEL\n+#define RUST_HIR_TYPE_CHECK_TOPLEVEL\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckTopLevel : private TypeCheckBase, public HIR::HIRVisItemVisitor\n+{\n+public:\n+  static void Resolve (HIR::Item &item);\n+\n+  void visit (HIR::Module &module) override;\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::TupleStruct &struct_decl) override;\n+  void visit (HIR::StructStruct &struct_decl) override;\n+  void visit (HIR::Enum &enum_decl) override;\n+  void visit (HIR::Union &union_decl) override;\n+  void visit (HIR::StaticItem &var) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::ImplBlock &impl_block) override;\n+  void visit (HIR::ExternBlock &extern_block) override;\n+\n+  // nothing to do\n+  void visit (HIR::Trait &trait_block) override {}\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n+\n+private:\n+  TypeCheckTopLevel ();\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_TOPLEVEL"}, {"sha": "3538d77b220225ca274cfe3eba0f37599fcd7e51", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "added", "additions": 838, "deletions": 0, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,838 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+HIR::GenericArgs\n+TypeCheckResolveGenericArguments::resolve (HIR::TypePathSegment *segment)\n+{\n+  TypeCheckResolveGenericArguments resolver (segment->get_locus ());\n+  switch (segment->get_type ())\n+    {\n+    case HIR::TypePathSegment::SegmentType::GENERIC:\n+      resolver.visit (static_cast<HIR::TypePathSegmentGeneric &> (*segment));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return resolver.args;\n+}\n+\n+void\n+TypeCheckResolveGenericArguments::visit (HIR::TypePathSegmentGeneric &generic)\n+{\n+  args = generic.get_generic_args ();\n+}\n+\n+TyTy::BaseType *\n+TypeCheckType::Resolve (HIR::Type *type)\n+{\n+  TypeCheckType resolver (type->get_mappings ().get_hirid ());\n+  type->accept_vis (resolver);\n+  rust_assert (resolver.translated != nullptr);\n+  resolver.context->insert_type (type->get_mappings (), resolver.translated);\n+  return resolver.translated;\n+}\n+\n+void\n+TypeCheckType::visit (HIR::BareFunctionType &fntype)\n+{\n+  TyTy::BaseType *return_type\n+    = fntype.has_return_type ()\n+\t? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n+\t: TyTy::TupleType::get_unit_type (fntype.get_mappings ().get_hirid ());\n+\n+  std::vector<TyTy::TyVar> params;\n+  for (auto &param : fntype.get_function_params ())\n+    {\n+      TyTy::BaseType *ptype = TypeCheckType::Resolve (param.get_type ().get ());\n+      params.push_back (TyTy::TyVar (ptype->get_ref ()));\n+    }\n+\n+  translated = new TyTy::FnPtr (fntype.get_mappings ().get_hirid (),\n+\t\t\t\tfntype.get_locus (), std::move (params),\n+\t\t\t\tTyTy::TyVar (return_type->get_ref ()));\n+}\n+\n+void\n+TypeCheckType::visit (HIR::TupleType &tuple)\n+{\n+  if (tuple.is_unit_type ())\n+    {\n+      auto unit_node_id = resolver->get_unit_type_node_id ();\n+      if (!context->lookup_builtin (unit_node_id, &translated))\n+\t{\n+\t  rust_error_at (tuple.get_locus (),\n+\t\t\t \"failed to lookup builtin unit type\");\n+\t}\n+      return;\n+    }\n+\n+  std::vector<TyTy::TyVar> fields;\n+  for (auto &elem : tuple.get_elems ())\n+    {\n+      auto field_ty = TypeCheckType::Resolve (elem.get ());\n+      fields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n+    }\n+\n+  translated = new TyTy::TupleType (tuple.get_mappings ().get_hirid (),\n+\t\t\t\t    tuple.get_locus (), fields);\n+}\n+\n+void\n+TypeCheckType::visit (HIR::TypePath &path)\n+{\n+  // lookup the Node this resolves to\n+  NodeId ref;\n+  auto nid = path.get_mappings ().get_nodeid ();\n+  bool is_fully_resolved = resolver->lookup_resolved_type (nid, &ref);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  if (!is_fully_resolved)\n+    {\n+      // this can happen so we need to look up the root then resolve the\n+      // remaining segments if possible\n+      size_t offset = 0;\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      TyTy::BaseType *root\n+\t= resolve_root_path (path, &offset, &resolved_node_id);\n+\n+      rust_assert (root != nullptr);\n+      if (root->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      translated\n+\t= resolve_segments (resolved_node_id, path.get_mappings ().get_hirid (),\n+\t\t\t    path.get_segments (), offset, root,\n+\t\t\t    path.get_mappings (), path.get_locus ());\n+      return;\n+    }\n+\n+  HirId hir_lookup;\n+  if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n+    {\n+      rust_error_at (path.get_locus (), \"failed to lookup HIR %d for node '%s'\",\n+\t\t     ref, path.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (!context->lookup_type (hir_lookup, &lookup))\n+    {\n+      rust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *path_type = lookup->clone ();\n+  path_type->set_ref (path.get_mappings ().get_hirid ());\n+\n+  HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n+  HIR::GenericArgs args = TypeCheckResolveGenericArguments::resolve (final_seg);\n+\n+  bool is_big_self = final_seg->is_ident_only ()\n+\t\t     && (final_seg->as_string ().compare (\"Self\") == 0);\n+\n+  if (path_type->needs_generic_substitutions ())\n+    {\n+      if (is_big_self)\n+\t{\n+\t  translated = path_type;\n+\t  return;\n+\t}\n+\n+      translated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n+    }\n+  else if (!args.is_empty ())\n+    {\n+      rust_error_at (path.get_locus (),\n+\t\t     \"TypePath %s declares generic arguments but \"\n+\t\t     \"the type %s does not have any\",\n+\t\t     path.as_string ().c_str (),\n+\t\t     path_type->as_string ().c_str ());\n+    }\n+  else\n+    {\n+      translated = path_type;\n+    }\n+}\n+\n+void\n+TypeCheckType::visit (HIR::QualifiedPathInType &path)\n+{\n+  HIR::QualifiedPathType qual_path_type = path.get_path_type ();\n+  TyTy::BaseType *root\n+    = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_debug_loc (path.get_locus (), \"failed to resolve the root\");\n+      return;\n+    }\n+\n+  if (!qual_path_type.has_as_clause ())\n+    {\n+      // then this is just a normal path-in-expression\n+      NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+      bool ok = resolver->lookup_resolved_type (\n+\tqual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t&root_resolved_node_id);\n+      rust_assert (ok);\n+\n+      translated = resolve_segments (root_resolved_node_id,\n+\t\t\t\t     path.get_mappings ().get_hirid (),\n+\t\t\t\t     path.get_segments (), 0, translated,\n+\t\t\t\t     path.get_mappings (), path.get_locus ());\n+\n+      return;\n+    }\n+\n+  // Resolve the trait now\n+  TraitReference *trait_ref\n+    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  if (trait_ref->is_error ())\n+    return;\n+\n+  // does this type actually implement this type-bound?\n+  if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+    {\n+      rust_error_at (qual_path_type.get_locus (),\n+\t\t     \"root does not satisfy specified trait-bound\");\n+      return;\n+    }\n+\n+  // get the predicate for the bound\n+  auto specified_bound\n+    = get_predicate_from_bound (*qual_path_type.get_trait ().get ());\n+  if (specified_bound.is_error ())\n+    return;\n+\n+  // inherit the bound\n+  root->inherit_bounds ({specified_bound});\n+\n+  // setup the associated types\n+  const TraitReference *specified_bound_ref = specified_bound.get ();\n+  auto candidates = TypeBoundsProbe::Probe (root);\n+  AssociatedImplTrait *associated_impl_trait = nullptr;\n+  for (auto &probed_bound : candidates)\n+    {\n+      const TraitReference *bound_trait_ref = probed_bound.first;\n+      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n+      AssociatedImplTrait *associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n+      if (found_impl_trait)\n+\t{\n+\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t  bool found_self = associated->get_self ()->can_eq (root, false);\n+\t  if (found_trait && found_self)\n+\t    {\n+\t      associated_impl_trait = associated;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (associated_impl_trait != nullptr)\n+    {\n+      associated_impl_trait->setup_associated_types (root, specified_bound);\n+    }\n+\n+  // lookup the associated item from the specified bound\n+  std::unique_ptr<HIR::TypePathSegment> &item_seg\n+    = path.get_associated_segment ();\n+  HIR::PathIdentSegment item_seg_identifier = item_seg->get_ident_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n+    {\n+      rust_error_at (item_seg->get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+\n+  // infer the root type\n+  translated = item.get_tyty_for_receiver (root);\n+\n+  // turbo-fish segment path::<ty>\n+  if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n+    {\n+      HIR::TypePathSegmentGeneric &generic_seg\n+\t= static_cast<HIR::TypePathSegmentGeneric &> (*item_seg.get ());\n+\n+      // turbo-fish segment path::<ty>\n+      if (generic_seg.has_generic_args ())\n+\t{\n+\t  if (!translated->can_substitute ())\n+\t    {\n+\t      rust_error_at (item_seg->get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     translated->as_string ().c_str ());\n+\t      translated\n+\t\t= new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t      return;\n+\t    }\n+\t  translated = SubstMapper::Resolve (translated, path.get_locus (),\n+\t\t\t\t\t     &generic_seg.get_generic_args ());\n+\t}\n+    }\n+\n+  // continue on as a path-in-expression\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n+  bool fully_resolved = path.get_segments ().empty ();\n+  if (fully_resolved)\n+    {\n+      resolver->insert_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t      root_resolved_node_id);\n+      context->insert_receiver (path.get_mappings ().get_hirid (), root);\n+      return;\n+    }\n+\n+  translated\n+    = resolve_segments (root_resolved_node_id,\n+\t\t\tpath.get_mappings ().get_hirid (), path.get_segments (),\n+\t\t\t0, translated, path.get_mappings (), path.get_locus ());\n+}\n+\n+TyTy::BaseType *\n+TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n+\t\t\t\t  NodeId *root_resolved_node_id)\n+{\n+  TyTy::BaseType *root_tyty = nullptr;\n+  *offset = 0;\n+  for (size_t i = 0; i < path.get_num_segments (); i++)\n+    {\n+      std::unique_ptr<HIR::TypePathSegment> &seg = path.get_segments ().at (i);\n+\n+      bool have_more_segments = (path.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n+      NodeId ast_node_id = seg->get_mappings ().get_nodeid ();\n+\n+      // then lookup the reference_node_id\n+      NodeId ref_node_id = UNKNOWN_NODEID;\n+      if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+\t{\n+\t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+\t}\n+\n+      // ref_node_id is the NodeId that the segments refers to.\n+      if (ref_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"unknown reference for resolved name: %<%s%>\",\n+\t\t\t     seg->get_ident_segment ().as_string ().c_str ());\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // node back to HIR\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (), \"789 reverse lookup failure\");\n+\t      rust_debug_loc (\n+\t\tseg->get_locus (),\n+\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\tseg->as_string ().c_str (),\n+\t\tseg->get_mappings ().as_string ().c_str (), ref_node_id);\n+\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\n+\t  return root_tyty;\n+\t}\n+\n+      auto seg_is_module = (nullptr != mappings->lookup_module (ref));\n+      auto seg_is_crate = mappings->is_local_hirid_crate (ref);\n+      if (seg_is_module || seg_is_crate)\n+\t{\n+\t  // A::B::C::this_is_a_module::D::E::F\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  //          Currently handling this.\n+\t  if (have_more_segments)\n+\t    {\n+\t      (*offset)++;\n+\t      continue;\n+\t    }\n+\n+\t  // In the case of :\n+\t  // A::B::C::this_is_a_module\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  // This is an error, we are not expecting a module.\n+\t  rust_error_at (seg->get_locus (), \"expected value\");\n+\t  return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t}\n+\n+      TyTy::BaseType *lookup = nullptr;\n+      if (!context->lookup_type (ref, &lookup))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // turbo-fish segment path::<ty>\n+      if (seg->is_generic_segment ())\n+\t{\n+\t  HIR::TypePathSegmentGeneric *generic_segment\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n+\n+\t  if (!lookup->can_substitute ())\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     lookup->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (lookup->get_ref ());\n+\t    }\n+\t  lookup = SubstMapper::Resolve (lookup, path.get_locus (),\n+\t\t\t\t\t &generic_segment->get_generic_args ());\n+\t}\n+\n+      *root_resolved_node_id = ref_node_id;\n+      *offset = *offset + 1;\n+      root_tyty = lookup;\n+    }\n+\n+  return root_tyty;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckType::resolve_segments (\n+  NodeId root_resolved_node_id, HirId expr_id,\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n+  TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n+  Location expr_locus)\n+{\n+  NodeId resolved_node_id = root_resolved_node_id;\n+  TyTy::BaseType *prev_segment = tyseg;\n+  for (size_t i = offset; i < segments.size (); i++)\n+    {\n+      std::unique_ptr<HIR::TypePathSegment> &seg = segments.at (i);\n+\n+      bool reciever_is_generic\n+\t= prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+      bool probe_bounds = true;\n+      bool probe_impls = !reciever_is_generic;\n+      bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+      // probe the path is done in two parts one where we search impls if no\n+      // candidate is found then we search extensions from traits\n+      auto candidates\n+\t= PathProbeType::Probe (prev_segment, seg->get_ident_segment (),\n+\t\t\t\tprobe_impls, false,\n+\t\t\t\tignore_mandatory_trait_items);\n+      if (candidates.size () == 0)\n+\t{\n+\t  candidates\n+\t    = PathProbeType::Probe (prev_segment, seg->get_ident_segment (),\n+\t\t\t\t    false, probe_bounds,\n+\t\t\t\t    ignore_mandatory_trait_items);\n+\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      rust_error_at (\n+\t\tseg->get_locus (),\n+\t\t\"failed to resolve path segment using an impl Probe\");\n+\t      return new TyTy::ErrorType (expr_id);\n+\t    }\n+\t}\n+\n+      if (candidates.size () > 1)\n+\t{\n+\t  ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\tseg->get_ident_segment (),\n+\t\t\t\t\t\tseg->get_locus ());\n+\t  return new TyTy::ErrorType (expr_id);\n+\t}\n+\n+      auto &candidate = candidates.at (0);\n+      prev_segment = tyseg;\n+      tyseg = candidate.ty;\n+\n+      if (candidate.is_impl_candidate ())\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\t}\n+      else\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\t}\n+\n+      if (seg->is_generic_segment ())\n+\t{\n+\t  HIR::TypePathSegmentGeneric *generic_segment\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n+\n+\t  if (!tyseg->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t     tyseg->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (expr_id);\n+\t    }\n+\n+\t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t&generic_segment->get_generic_args ());\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return new TyTy::ErrorType (expr_id);\n+\t}\n+    }\n+\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+  if (tyseg->needs_generic_substitutions ())\n+    {\n+      Location locus = segments.back ()->get_locus ();\n+      if (!prev_segment->needs_generic_substitutions ())\n+\t{\n+\t  auto used_args_in_prev_segment\n+\t    = GetUsedSubstArgs::From (prev_segment);\n+\t  if (!used_args_in_prev_segment.is_error ())\n+\t    tyseg\n+\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t}\n+      else\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn new TyTy::ErrorType (expr_id);\n+    }\n+\n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+  // lookup if the name resolver was able to canonically resolve this or not\n+  NodeId path_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  // check the type scope\n+  else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t   &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  else\n+    {\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+    }\n+\n+  return tyseg;\n+}\n+\n+void\n+TypeCheckType::visit (HIR::TraitObjectType &type)\n+{\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      if (bound->get_bound_type ()\n+\t  != HIR::TypeParamBound::BoundType::TRAITBOUND)\n+\tcontinue;\n+\n+      HIR::TypeParamBound &b = *bound.get ();\n+      HIR::TraitBound &trait_bound = static_cast<HIR::TraitBound &> (b);\n+\n+      TyTy::TypeBoundPredicate predicate\n+\t= get_predicate_from_bound (trait_bound.get_path ());\n+\n+      if (!predicate.is_error ()\n+\t  && predicate.is_object_safe (true, type.get_locus ()))\n+\tspecified_bounds.push_back (std::move (predicate));\n+    }\n+\n+  RustIdent ident{CanonicalPath::create_empty (), type.get_locus ()};\n+  translated\n+    = new TyTy::DynamicObjectType (type.get_mappings ().get_hirid (), ident,\n+\t\t\t\t   std::move (specified_bounds));\n+}\n+\n+void\n+TypeCheckType::visit (HIR::ArrayType &type)\n+{\n+  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr ());\n+  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::BaseType *expected_ty = nullptr;\n+  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n+  rust_assert (ok);\n+  context->insert_type (type.get_size_expr ()->get_mappings (), expected_ty);\n+\n+  auto unified = expected_ty->unify (capacity_type);\n+  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n+  translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (),\n+\t\t\t\t    type.get_locus (), *type.get_size_expr (),\n+\t\t\t\t    TyTy::TyVar (base->get_ref ()));\n+}\n+\n+void\n+TypeCheckType::visit (HIR::SliceType &type)\n+{\n+  TyTy::BaseType *base\n+    = TypeCheckType::Resolve (type.get_element_type ().get ());\n+  translated\n+    = new TyTy::SliceType (type.get_mappings ().get_hirid (), type.get_locus (),\n+\t\t\t   TyTy::TyVar (base->get_ref ()));\n+}\n+void\n+TypeCheckType::visit (HIR::ReferenceType &type)\n+{\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_base_type ().get ());\n+  translated\n+    = new TyTy::ReferenceType (type.get_mappings ().get_hirid (),\n+\t\t\t       TyTy::TyVar (base->get_ref ()), type.get_mut ());\n+}\n+\n+void\n+TypeCheckType::visit (HIR::RawPointerType &type)\n+{\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_base_type ().get ());\n+  translated\n+    = new TyTy::PointerType (type.get_mappings ().get_hirid (),\n+\t\t\t     TyTy::TyVar (base->get_ref ()), type.get_mut ());\n+}\n+\n+void\n+TypeCheckType::visit (HIR::InferredType &type)\n+{\n+  translated = new TyTy::InferType (type.get_mappings ().get_hirid (),\n+\t\t\t\t    TyTy::InferType::InferTypeKind::GENERAL,\n+\t\t\t\t    type.get_locus ());\n+}\n+\n+void\n+TypeCheckType::visit (HIR::NeverType &type)\n+{\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = context->lookup_builtin (\"!\", &lookup);\n+  rust_assert (ok);\n+\n+  translated = lookup->clone ();\n+}\n+\n+TyTy::ParamType *\n+TypeResolveGenericParam::Resolve (HIR::GenericParam *param)\n+{\n+  TypeResolveGenericParam resolver;\n+  switch (param->get_kind ())\n+    {\n+    case HIR::GenericParam::GenericKind::TYPE:\n+      resolver.visit (static_cast<HIR::TypeParam &> (*param));\n+      break;\n+\n+    case HIR::GenericParam::GenericKind::CONST:\n+      resolver.visit (static_cast<HIR::ConstGenericParam &> (*param));\n+      break;\n+\n+    case HIR::GenericParam::GenericKind::LIFETIME:\n+      resolver.visit (static_cast<HIR::LifetimeParam &> (*param));\n+      break;\n+    }\n+  return resolver.resolved;\n+}\n+\n+void\n+TypeResolveGenericParam::visit (HIR::LifetimeParam &param)\n+{\n+  // nothing to do\n+}\n+\n+void\n+TypeResolveGenericParam::visit (HIR::ConstGenericParam &param)\n+{\n+  // TODO\n+}\n+\n+void\n+TypeResolveGenericParam::visit (HIR::TypeParam &param)\n+{\n+  if (param.has_type ())\n+    TypeCheckType::Resolve (param.get_type ().get ());\n+\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  if (param.has_type_param_bounds ())\n+    {\n+      for (auto &bound : param.get_type_param_bounds ())\n+\t{\n+\t  switch (bound->get_bound_type ())\n+\t    {\n+\t      case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t\tHIR::TraitBound *b\n+\t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t\tTyTy::TypeBoundPredicate predicate\n+\t\t  = get_predicate_from_bound (b->get_path ());\n+\t\tif (!predicate.is_error ())\n+\t\t  specified_bounds.push_back (std::move (predicate));\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  resolved\n+    = new TyTy::ParamType (param.get_type_representation (), param.get_locus (),\n+\t\t\t   param.get_mappings ().get_hirid (), param,\n+\t\t\t   specified_bounds);\n+}\n+\n+void\n+ResolveWhereClauseItem::Resolve (HIR::WhereClauseItem &item)\n+{\n+  ResolveWhereClauseItem resolver;\n+  switch (item.get_item_type ())\n+    {\n+    case HIR::WhereClauseItem::LIFETIME:\n+      resolver.visit (static_cast<HIR::LifetimeWhereClauseItem &> (item));\n+      break;\n+\n+    case HIR::WhereClauseItem::TYPE_BOUND:\n+      resolver.visit (static_cast<HIR::TypeBoundWhereClauseItem &> (item));\n+      break;\n+    }\n+}\n+\n+void\n+ResolveWhereClauseItem::visit (HIR::LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+ResolveWhereClauseItem::visit (HIR::TypeBoundWhereClauseItem &item)\n+{\n+  auto &binding_type_path = item.get_bound_type ();\n+  TyTy::BaseType *binding = TypeCheckType::Resolve (binding_type_path.get ());\n+\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  for (auto &bound : item.get_type_param_bounds ())\n+    {\n+      switch (bound->get_bound_type ())\n+\t{\n+\t  case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t    HIR::TraitBound *b = static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t    TyTy::TypeBoundPredicate predicate\n+\t      = get_predicate_from_bound (b->get_path ());\n+\t    if (!predicate.is_error ())\n+\t      specified_bounds.push_back (std::move (predicate));\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  binding->inherit_bounds (specified_bounds);\n+\n+  // When we apply these bounds we must lookup which type this binding\n+  // resolves to, as this is the type which will be used during resolution\n+  // of the block.\n+  NodeId ast_node_id = binding_type_path->get_mappings ().get_nodeid ();\n+\n+  // then lookup the reference_node_id\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+    {\n+      // FIXME\n+      rust_error_at (Location (),\n+\t\t     \"Failed to lookup type reference for node: %s\",\n+\t\t     binding_type_path->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // node back to HIR\n+  HirId ref;\n+  if (!mappings->lookup_node_to_hir (ref_node_id, &ref))\n+    {\n+      // FIXME\n+      rust_error_at (Location (), \"where-clause reverse lookup failure\");\n+      return;\n+    }\n+\n+  // the base reference for this name _must_ have a type set\n+  TyTy::BaseType *lookup;\n+  if (!context->lookup_type (ref, &lookup))\n+    {\n+      rust_error_at (mappings->lookup_location (ref),\n+\t\t     \"Failed to resolve where-clause binding type: %s\",\n+\t\t     binding_type_path->as_string ().c_str ());\n+      return;\n+    }\n+\n+  // FIXME\n+  // rust_assert (binding->is_equal (*lookup));\n+  lookup->inherit_bounds (specified_bounds);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "90d5ddbb411c892b2ce44e7961812e193eab830c", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,130 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_TYPE\n+#define RUST_HIR_TYPE_CHECK_TYPE\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-path-probe.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// FIXME\n+// This simply fetches the HIR:::GenericArgs from the base class. Check to see\n+// if we can get rid of this class\n+class TypeCheckResolveGenericArguments : public TypeCheckBase\n+{\n+public:\n+  static HIR::GenericArgs resolve (HIR::TypePathSegment *segment);\n+\n+  void visit (HIR::TypePathSegmentGeneric &generic);\n+\n+private:\n+  TypeCheckResolveGenericArguments (Location locus)\n+    : TypeCheckBase (), args (HIR::GenericArgs::create_empty (locus))\n+  {}\n+\n+  HIR::GenericArgs args;\n+};\n+\n+class TypeCheckType : public TypeCheckBase, public HIR::HIRTypeVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (HIR::Type *type);\n+\n+  void visit (HIR::BareFunctionType &fntype) override;\n+  void visit (HIR::TupleType &tuple) override;\n+  void visit (HIR::TypePath &path) override;\n+  void visit (HIR::QualifiedPathInType &path) override;\n+  void visit (HIR::ArrayType &type) override;\n+  void visit (HIR::SliceType &type) override;\n+  void visit (HIR::ReferenceType &type) override;\n+  void visit (HIR::RawPointerType &type) override;\n+  void visit (HIR::InferredType &type) override;\n+  void visit (HIR::NeverType &type) override;\n+  void visit (HIR::TraitObjectType &type) override;\n+\n+  void visit (HIR::TypePathSegmentFunction &segment) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::TraitBound &bound) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::ImplTraitType &type) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::ParenthesisedType &type) override\n+  { /* TODO */\n+  }\n+  void visit (HIR::ImplTraitTypeOneBound &type) override\n+  { /* TODO */\n+  }\n+\n+private:\n+  TypeCheckType (HirId id)\n+    : TypeCheckBase (), translated (new TyTy::ErrorType (id))\n+  {}\n+\n+  TyTy::BaseType *resolve_root_path (HIR::TypePath &path, size_t *offset,\n+\t\t\t\t     NodeId *root_resolved_node_id);\n+\n+  TyTy::BaseType *resolve_segments (\n+    NodeId root_resolved_node_id, HirId expr_id,\n+    std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n+    TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n+    Location expr_locus);\n+\n+  TyTy::BaseType *translated;\n+};\n+\n+class TypeResolveGenericParam : public TypeCheckBase\n+{\n+public:\n+  static TyTy::ParamType *Resolve (HIR::GenericParam *param);\n+\n+protected:\n+  void visit (HIR::TypeParam &param);\n+  void visit (HIR::LifetimeParam &param);\n+  void visit (HIR::ConstGenericParam &param);\n+\n+private:\n+  TypeResolveGenericParam () : TypeCheckBase (), resolved (nullptr) {}\n+\n+  TyTy::ParamType *resolved;\n+};\n+\n+class ResolveWhereClauseItem : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::WhereClauseItem &item);\n+\n+protected:\n+  void visit (HIR::LifetimeWhereClauseItem &item);\n+  void visit (HIR::TypeBoundWhereClauseItem &item);\n+\n+private:\n+  ResolveWhereClauseItem () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_TYPE"}, {"sha": "e25f431a507cea49bd2bc7245ffec532dfb9f163", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-util.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ImplTypeIterator::go ()\n+{\n+  for (auto &item : impl.get_impl_items ())\n+    {\n+      item->accept_vis (*this);\n+    }\n+}\n+\n+void\n+ImplTypeIterator::visit (HIR::TypeAlias &alias)\n+{\n+  cb (alias);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "1a4b17a330375cc2d7191bb2ed28c9cb690fe946", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_UTIL_H\n+#define RUST_HIR_TYPE_CHECK_UTIL_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ImplTypeIterator : public HIR::HIRFullVisitorBase\n+{\n+  using HIR::HIRFullVisitorBase::visit;\n+\n+public:\n+  ImplTypeIterator (HIR::ImplBlock &impl,\n+\t\t    std::function<void (HIR::TypeAlias &alias)> cb)\n+    : impl (impl), cb (cb)\n+  {}\n+\n+  void go ();\n+\n+  void visit (HIR::TypeAlias &alias) override;\n+\n+private:\n+  HIR::ImplBlock &impl;\n+  std::function<void (HIR::TypeAlias &alias)> cb;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_UTIL_H"}, {"sha": "c314585cd3d40c3f917a2409a36543bf9bd81c49", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,295 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-toplevel.h\"\n+#include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-inherent-impl-overlap.h\"\n+\n+extern bool\n+saw_errors (void);\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeResolution::Resolve (HIR::Crate &crate)\n+{\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    TypeCheckTopLevel::Resolve (*it->get ());\n+\n+  if (saw_errors ())\n+    return;\n+\n+  OverlappingImplItemPass::go ();\n+  if (saw_errors ())\n+    return;\n+\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    TypeCheckItem::Resolve (*it->get ());\n+\n+  if (saw_errors ())\n+    return;\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = TypeCheckContext::get ();\n+\n+  // default inference variables if possible\n+  context->iterate ([&] (HirId id, TyTy::BaseType *ty) mutable -> bool {\n+    // nothing to do\n+    if (ty->get_kind () != TyTy::TypeKind::INFER)\n+      return true;\n+\n+    TyTy::InferType *infer_var = static_cast<TyTy::InferType *> (ty);\n+    TyTy::BaseType *default_type;\n+    bool ok = infer_var->default_type (&default_type);\n+    if (!ok)\n+      {\n+\trust_error_at (mappings->lookup_location (id),\n+\t\t       \"type annotations needed\");\n+\treturn true;\n+      }\n+    else\n+      {\n+\tauto result = ty->unify (default_type);\n+\tresult->set_ref (id);\n+\tcontext->insert_type (\n+\t  Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID),\n+\t  result);\n+      }\n+\n+    return true;\n+  });\n+}\n+\n+// rust-hir-trait-ref.h\n+\n+TraitItemReference::TraitItemReference (\n+  std::string identifier, bool optional, TraitItemType type,\n+  HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions, Location locus)\n+  : identifier (identifier), optional_flag (optional), type (type),\n+    hir_trait_item (hir_trait_item),\n+    inherited_substitutions (std::move (substitutions)), locus (locus),\n+    self (self), context (TypeCheckContext::get ())\n+{}\n+\n+TraitItemReference::TraitItemReference (TraitItemReference const &other)\n+  : identifier (other.identifier), optional_flag (other.optional_flag),\n+    type (other.type), hir_trait_item (other.hir_trait_item),\n+    locus (other.locus), self (other.self), context (TypeCheckContext::get ())\n+{\n+  inherited_substitutions.clear ();\n+  inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+  for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+    inherited_substitutions.push_back (\n+      other.inherited_substitutions.at (i).clone ());\n+}\n+\n+TraitItemReference &\n+TraitItemReference::operator= (TraitItemReference const &other)\n+{\n+  identifier = other.identifier;\n+  optional_flag = other.optional_flag;\n+  type = other.type;\n+  hir_trait_item = other.hir_trait_item;\n+  self = other.self;\n+  locus = other.locus;\n+  context = other.context;\n+\n+  inherited_substitutions.clear ();\n+  inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+  for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+    inherited_substitutions.push_back (\n+      other.inherited_substitutions.at (i).clone ());\n+\n+  return *this;\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_typealias (/*const*/\n+\t\t\t\t\t     HIR::TraitItemType &type) const\n+{\n+  TyTy::TyVar var (get_mappings ().get_hirid ());\n+  return var.get_tyty ();\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_constant (\n+  /*const*/ HIR::TraitItemConst &constant) const\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ().get ());\n+  if (constant.has_expr ())\n+    {\n+      TyTy::BaseType *expr\n+\t= TypeCheckExpr::Resolve (constant.get_expr ().get ());\n+\n+      return type->unify (expr);\n+    }\n+  return type;\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions\n+    = inherited_substitutions;\n+\n+  HIR::TraitFunctionDecl &function = fn.get_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_return_type ())\n+    ret_type = TyTy::TupleType::get_unit_type (fn.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (fn.get_locus (), \"failed to resolve return type\");\n+\t  return get_error ();\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  if (function.is_method ())\n+    {\n+      // these are implicit mappings and not used\n+      auto mappings = Analysis::Mappings::get ();\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, mappings->get_next_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      // add the synthetic self param at the front, this is a placeholder\n+      // for compilation to know parameter names. The types are ignored\n+      // but we reuse the HIR identifier pattern which requires it\n+      HIR::SelfParam &self_param = function.get_self ();\n+      HIR::IdentifierPattern *self_pattern\n+\t= new HIR::IdentifierPattern (mapping, \"self\", self_param.get_locus (),\n+\t\t\t\t      self_param.is_ref (),\n+\t\t\t\t      self_param.is_mut () ? Mutability::Mut\n+\t\t\t\t\t\t\t   : Mutability::Imm,\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+      // might have a specified type\n+      TyTy::BaseType *self_type = nullptr;\n+      if (self_param.has_type ())\n+\t{\n+\t  std::unique_ptr<HIR::Type> &specified_type = self_param.get_type ();\n+\t  self_type = TypeCheckType::Resolve (specified_type.get ());\n+\t}\n+      else\n+\t{\n+\t  switch (self_param.get_self_kind ())\n+\t    {\n+\t    case HIR::SelfParam::IMM:\n+\t    case HIR::SelfParam::MUT:\n+\t      self_type = self->clone ();\n+\t      break;\n+\n+\t    case HIR::SelfParam::IMM_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), Mutability::Imm);\n+\t      break;\n+\n+\t    case HIR::SelfParam::MUT_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), Mutability::Mut);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t      return nullptr;\n+\t    }\n+\t}\n+\n+      context->insert_type (self_param.get_mappings (), self_type);\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern, self_type));\n+    }\n+\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (fn.get_mappings ().get_nodeid (),\n+\t\t\t\t\t     &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, fn.get_locus ()};\n+  auto resolved\n+    = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n+\t\t\tfn.get_mappings ().get_defid (),\n+\t\t\tfunction.get_function_name (), ident,\n+\t\t\tfunction.is_method ()\n+\t\t\t  ? TyTy::FnType::FNTYPE_IS_METHOD_FLAG\n+\t\t\t  : TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n+\t\t\tABI::RUST, std::move (params), ret_type, substitutions);\n+\n+  context->insert_type (fn.get_mappings (), resolved);\n+  return resolved;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "21694dd302bf1fc1e5a8305ea331ac1c5fdda6c7", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,379 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK\n+#define RUST_HIR_TYPE_CHECK\n+\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-hir-trait-ref.h\"\n+#include \"rust-autoderef.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckContextItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ITEM,\n+    IMPL_ITEM,\n+    TRAIT_ITEM,\n+  };\n+\n+  TypeCheckContextItem (HIR::Function *item)\n+    : type (ItemType::ITEM), item (item)\n+  {}\n+\n+  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item)\n+    : type (ItemType::IMPL_ITEM), item (impl_block, item)\n+  {}\n+\n+  TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n+    : type (ItemType::TRAIT_ITEM), item (trait_item)\n+  {}\n+\n+  ItemType get_type () const { return type; }\n+\n+  HIR::Function *get_item ()\n+  {\n+    rust_assert (get_type () == ItemType::ITEM);\n+    return item.item;\n+  }\n+\n+  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ()\n+  {\n+    rust_assert (get_type () == ItemType::IMPL_ITEM);\n+    return item.impl_item;\n+  };\n+\n+  HIR::TraitItemFunc *get_trait_item ()\n+  {\n+    rust_assert (get_type () == ItemType::TRAIT_ITEM);\n+    return item.trait_item;\n+  }\n+\n+private:\n+  union Item\n+  {\n+    HIR::Function *item;\n+    std::pair<HIR::ImplBlock *, HIR::Function *> impl_item;\n+    HIR::TraitItemFunc *trait_item;\n+\n+    Item (HIR::Function *item) : item (item) {}\n+\n+    Item (HIR::ImplBlock *impl_block, HIR::Function *item)\n+      : impl_item ({impl_block, item})\n+    {}\n+\n+    Item (HIR::TraitItemFunc *trait_item) : trait_item (trait_item) {}\n+  };\n+\n+  ItemType type;\n+  Item item;\n+};\n+\n+class TypeCheckContext\n+{\n+public:\n+  static TypeCheckContext *get ();\n+\n+  ~TypeCheckContext ();\n+\n+  bool lookup_builtin (NodeId id, TyTy::BaseType **type);\n+  bool lookup_builtin (std::string name, TyTy::BaseType **type);\n+  void insert_builtin (HirId id, NodeId ref, TyTy::BaseType *type);\n+\n+  void insert_type (const Analysis::NodeMapping &mappings,\n+\t\t    TyTy::BaseType *type);\n+  void insert_implicit_type (TyTy::BaseType *type);\n+  bool lookup_type (HirId id, TyTy::BaseType **type) const;\n+\n+  void insert_implicit_type (HirId id, TyTy::BaseType *type);\n+\n+  void insert_type_by_node_id (NodeId ref, HirId id);\n+  bool lookup_type_by_node_id (NodeId ref, HirId *id);\n+\n+  TyTy::BaseType *peek_return_type ();\n+  TypeCheckContextItem &peek_context ();\n+  void push_return_type (TypeCheckContextItem item,\n+\t\t\t TyTy::BaseType *return_type);\n+  void pop_return_type ();\n+\n+  void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n+  {\n+    for (auto it = resolved.begin (); it != resolved.end (); it++)\n+      {\n+\tif (!cb (it->first, it->second))\n+\t  return;\n+      }\n+  }\n+\n+  bool have_loop_context () const { return !loop_type_stack.empty (); }\n+\n+  void push_new_loop_context (HirId id, Location locus)\n+  {\n+    TyTy::BaseType *infer_var\n+      = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL,\n+\t\t\t     locus);\n+    loop_type_stack.push_back (infer_var);\n+  }\n+\n+  void push_new_while_loop_context (HirId id)\n+  {\n+    TyTy::BaseType *infer_var = new TyTy::ErrorType (id);\n+    loop_type_stack.push_back (infer_var);\n+  }\n+\n+  TyTy::BaseType *peek_loop_context () { return loop_type_stack.back (); }\n+\n+  TyTy::BaseType *pop_loop_context ()\n+  {\n+    auto back = peek_loop_context ();\n+    loop_type_stack.pop_back ();\n+    return back;\n+  }\n+\n+  void swap_head_loop_context (TyTy::BaseType *val)\n+  {\n+    loop_type_stack.pop_back ();\n+    loop_type_stack.push_back (val);\n+  }\n+\n+  void insert_trait_reference (DefId id, TraitReference &&ref)\n+  {\n+    rust_assert (trait_context.find (id) == trait_context.end ());\n+    trait_context.emplace (id, std::move (ref));\n+  }\n+\n+  bool lookup_trait_reference (DefId id, TraitReference **ref)\n+  {\n+    auto it = trait_context.find (id);\n+    if (it == trait_context.end ())\n+      return false;\n+\n+    *ref = &it->second;\n+    return true;\n+  }\n+\n+  void insert_receiver (HirId id, TyTy::BaseType *t)\n+  {\n+    receiver_context[id] = t;\n+  }\n+\n+  bool lookup_receiver (HirId id, TyTy::BaseType **ref)\n+  {\n+    auto it = receiver_context.find (id);\n+    if (it == receiver_context.end ())\n+      return false;\n+\n+    *ref = it->second;\n+    return true;\n+  }\n+\n+  void insert_associated_trait_impl (HirId id, AssociatedImplTrait &&associated)\n+  {\n+    rust_assert (associated_impl_traits.find (id)\n+\t\t == associated_impl_traits.end ());\n+    associated_impl_traits.emplace (id, std::move (associated));\n+  }\n+\n+  bool lookup_associated_trait_impl (HirId id, AssociatedImplTrait **associated)\n+  {\n+    auto it = associated_impl_traits.find (id);\n+    if (it == associated_impl_traits.end ())\n+      return false;\n+\n+    *associated = &it->second;\n+    return true;\n+  }\n+\n+  void insert_associated_type_mapping (HirId id, HirId mapping)\n+  {\n+    associated_type_mappings[id] = mapping;\n+  }\n+\n+  void clear_associated_type_mapping (HirId id)\n+  {\n+    auto it = associated_type_mappings.find (id);\n+    if (it != associated_type_mappings.end ())\n+      associated_type_mappings.erase (it);\n+  }\n+\n+  // lookup any associated type mappings, the out parameter of mapping is\n+  // allowed to be nullptr which allows this interface to do a simple does exist\n+  // check\n+  bool lookup_associated_type_mapping (HirId id, HirId *mapping)\n+  {\n+    auto it = associated_type_mappings.find (id);\n+    if (it == associated_type_mappings.end ())\n+      return false;\n+\n+    if (mapping != nullptr)\n+      *mapping = it->second;\n+\n+    return true;\n+  }\n+\n+  void insert_associated_impl_mapping (HirId trait_id,\n+\t\t\t\t       const TyTy::BaseType *impl_type,\n+\t\t\t\t       HirId impl_id)\n+  {\n+    auto it = associated_traits_to_impls.find (trait_id);\n+    if (it == associated_traits_to_impls.end ())\n+      {\n+\tassociated_traits_to_impls[trait_id] = {};\n+      }\n+\n+    associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n+  }\n+\n+  bool lookup_associated_impl_mapping_for_self (HirId trait_id,\n+\t\t\t\t\t\tconst TyTy::BaseType *self,\n+\t\t\t\t\t\tHirId *mapping)\n+  {\n+    auto it = associated_traits_to_impls.find (trait_id);\n+    if (it == associated_traits_to_impls.end ())\n+      return false;\n+\n+    for (auto &item : it->second)\n+      {\n+\tif (item.first->can_eq (self, false))\n+\t  {\n+\t    *mapping = item.second;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  void insert_autoderef_mappings (HirId id,\n+\t\t\t\t  std::vector<Adjustment> &&adjustments)\n+  {\n+    rust_assert (autoderef_mappings.find (id) == autoderef_mappings.end ());\n+    autoderef_mappings.emplace (id, std::move (adjustments));\n+  }\n+\n+  bool lookup_autoderef_mappings (HirId id,\n+\t\t\t\t  std::vector<Adjustment> **adjustments)\n+  {\n+    auto it = autoderef_mappings.find (id);\n+    if (it == autoderef_mappings.end ())\n+      return false;\n+\n+    *adjustments = &it->second;\n+    return true;\n+  }\n+\n+  void insert_cast_autoderef_mappings (HirId id,\n+\t\t\t\t       std::vector<Adjustment> &&adjustments)\n+  {\n+    rust_assert (cast_autoderef_mappings.find (id)\n+\t\t == cast_autoderef_mappings.end ());\n+    cast_autoderef_mappings.emplace (id, std::move (adjustments));\n+  }\n+\n+  bool lookup_cast_autoderef_mappings (HirId id,\n+\t\t\t\t       std::vector<Adjustment> **adjustments)\n+  {\n+    auto it = cast_autoderef_mappings.find (id);\n+    if (it == cast_autoderef_mappings.end ())\n+      return false;\n+\n+    *adjustments = &it->second;\n+    return true;\n+  }\n+\n+  void insert_variant_definition (HirId id, HirId variant)\n+  {\n+    auto it = variants.find (id);\n+    rust_assert (it == variants.end ());\n+\n+    variants[id] = variant;\n+  }\n+\n+  bool lookup_variant_definition (HirId id, HirId *variant)\n+  {\n+    auto it = variants.find (id);\n+    if (it == variants.end ())\n+      return false;\n+\n+    *variant = it->second;\n+    return true;\n+  }\n+\n+  void insert_operator_overload (HirId id, TyTy::FnType *call_site)\n+  {\n+    auto it = operator_overloads.find (id);\n+    rust_assert (it == operator_overloads.end ());\n+\n+    operator_overloads[id] = call_site;\n+  }\n+\n+  bool lookup_operator_overload (HirId id, TyTy::FnType **call)\n+  {\n+    auto it = operator_overloads.find (id);\n+    if (it == operator_overloads.end ())\n+      return false;\n+\n+    *call = it->second;\n+    return true;\n+  }\n+\n+private:\n+  TypeCheckContext ();\n+\n+  std::map<NodeId, HirId> node_id_refs;\n+  std::map<HirId, TyTy::BaseType *> resolved;\n+  std::vector<std::unique_ptr<TyTy::BaseType>> builtins;\n+  std::vector<std::pair<TypeCheckContextItem, TyTy::BaseType *>>\n+    return_type_stack;\n+  std::vector<TyTy::BaseType *> loop_type_stack;\n+  std::map<DefId, TraitReference> trait_context;\n+  std::map<HirId, TyTy::BaseType *> receiver_context;\n+  std::map<HirId, AssociatedImplTrait> associated_impl_traits;\n+\n+  // trait-id -> list of < self-tyty:impl-id>\n+  std::map<HirId, std::vector<std::pair<const TyTy::BaseType *, HirId>>>\n+    associated_traits_to_impls;\n+\n+  std::map<HirId, HirId> associated_type_mappings;\n+\n+  // adjustment mappings\n+  std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n+  std::map<HirId, std::vector<Adjustment>> cast_autoderef_mappings;\n+\n+  // operator overloads\n+  std::map<HirId, TyTy::FnType *> operator_overloads;\n+\n+  // variants\n+  std::map<HirId, HirId> variants;\n+};\n+\n+class TypeResolution\n+{\n+public:\n+  static void Resolve (HIR::Crate &crate);\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK"}, {"sha": "464e70d39d7781cd517909e6320773b0249c847e", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3db21769e8455f38e0d6ce004c44521aad7bd/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=c6c3db21769e8455f38e0d6ce004c44521aad7bd", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_VISITOR\n+#define RUST_TYTY_VISITOR\n+\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class TyVisitor\n+{\n+public:\n+  virtual void visit (InferType &type) = 0;\n+  virtual void visit (ADTType &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (FnType &type) = 0;\n+  virtual void visit (FnPtr &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (BoolType &type) = 0;\n+  virtual void visit (IntType &type) = 0;\n+  virtual void visit (UintType &type) = 0;\n+  virtual void visit (FloatType &type) = 0;\n+  virtual void visit (USizeType &type) = 0;\n+  virtual void visit (ISizeType &type) = 0;\n+  virtual void visit (ErrorType &type) = 0;\n+  virtual void visit (CharType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (PointerType &type) = 0;\n+  virtual void visit (ParamType &type) = 0;\n+  virtual void visit (StrType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (PlaceholderType &type) = 0;\n+  virtual void visit (ProjectionType &type) = 0;\n+  virtual void visit (DynamicObjectType &type) = 0;\n+  virtual void visit (ClosureType &type) = 0;\n+};\n+\n+class TyConstVisitor\n+{\n+public:\n+  virtual void visit (const InferType &type) = 0;\n+  virtual void visit (const ADTType &type) = 0;\n+  virtual void visit (const TupleType &type) = 0;\n+  virtual void visit (const FnType &type) = 0;\n+  virtual void visit (const FnPtr &type) = 0;\n+  virtual void visit (const ArrayType &type) = 0;\n+  virtual void visit (const SliceType &type) = 0;\n+  virtual void visit (const BoolType &type) = 0;\n+  virtual void visit (const IntType &type) = 0;\n+  virtual void visit (const UintType &type) = 0;\n+  virtual void visit (const FloatType &type) = 0;\n+  virtual void visit (const USizeType &type) = 0;\n+  virtual void visit (const ISizeType &type) = 0;\n+  virtual void visit (const ErrorType &type) = 0;\n+  virtual void visit (const CharType &type) = 0;\n+  virtual void visit (const ReferenceType &type) = 0;\n+  virtual void visit (const PointerType &type) = 0;\n+  virtual void visit (const ParamType &type) = 0;\n+  virtual void visit (const StrType &type) = 0;\n+  virtual void visit (const NeverType &type) = 0;\n+  virtual void visit (const PlaceholderType &type) = 0;\n+  virtual void visit (const ProjectionType &type) = 0;\n+  virtual void visit (const DynamicObjectType &type) = 0;\n+  virtual void visit (const ClosureType &type) = 0;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_VISITOR"}]}