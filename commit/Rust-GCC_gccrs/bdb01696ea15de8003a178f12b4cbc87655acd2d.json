{"sha": "bdb01696ea15de8003a178f12b4cbc87655acd2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiMDE2OTZlYTE1ZGU4MDAzYTE3OGYxMmI0Y2JjODc2NTVhY2QyZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-18T08:42:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-18T08:42:57Z"}, "message": "re PR middle-end/39326 (Segmentation fault with -O1, out of memory with -O2)\n\n2013-03-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/39326\n\t* tree-ssa-loop-im.c (refs_independent_p): Exploit symmetry.\n\t(struct mem_ref): Replace mem member with ao_ref typed member.\n\t(MEM_ANALYZABLE): Adjust.\n\t(memref_eq): Likewise.\n\t(mem_ref_alloc): Likewise.\n\t(gather_mem_refs_stmt): Likewise.\n\t(mem_refs_may_alias_p): Use the ao_ref to query the alias oracle.\n\t(execute_sm_if_changed_flag_set): Adjust.\n\t(execute_sm): Likewise.\n\t(ref_always_accessed_p): Likewise.\n\t(refs_independent_p): Likewise.\n\t(can_sm_ref_p): Likewise.\n\nFrom-SVN: r196768", "tree": {"sha": "aa0416ec0f7329adcdb338ffdf19aaff6a192c84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa0416ec0f7329adcdb338ffdf19aaff6a192c84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb01696ea15de8003a178f12b4cbc87655acd2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb01696ea15de8003a178f12b4cbc87655acd2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb01696ea15de8003a178f12b4cbc87655acd2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb01696ea15de8003a178f12b4cbc87655acd2d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12d2dc5e67905a22e0bf6d8b4a49b1ce246284a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d2dc5e67905a22e0bf6d8b4a49b1ce246284a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d2dc5e67905a22e0bf6d8b4a49b1ce246284a8"}], "stats": {"total": 96, "additions": 62, "deletions": 34}, "files": [{"sha": "629ae5ae0fa795a64d2dac59f1418be4c4e06ba9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb01696ea15de8003a178f12b4cbc87655acd2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb01696ea15de8003a178f12b4cbc87655acd2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdb01696ea15de8003a178f12b4cbc87655acd2d", "patch": "@@ -1,3 +1,19 @@\n+2013-03-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39326\n+\t* tree-ssa-loop-im.c (refs_independent_p): Exploit symmetry.\n+\t(struct mem_ref): Replace mem member with ao_ref typed member.\n+\t(MEM_ANALYZABLE): Adjust.\n+\t(memref_eq): Likewise.\n+\t(mem_ref_alloc): Likewise.\n+\t(gather_mem_refs_stmt): Likewise.\n+\t(mem_refs_may_alias_p): Use the ao_ref to query the alias oracle.\n+\t(execute_sm_if_changed_flag_set): Adjust.\n+\t(execute_sm): Likewise.\n+\t(ref_always_accessed_p): Likewise.\n+\t(refs_independent_p): Likewise.\n+\t(can_sm_ref_p): Likewise.\n+\n 2013-03-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/56566"}, {"sha": "9dc40451c1dc7843529603f7aa48704923553542", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb01696ea15de8003a178f12b4cbc87655acd2d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb01696ea15de8003a178f12b4cbc87655acd2d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=bdb01696ea15de8003a178f12b4cbc87655acd2d", "patch": "@@ -117,10 +117,14 @@ typedef struct mem_ref_locs\n \n typedef struct mem_ref\n {\n-  tree mem;\t\t\t/* The memory itself.  */\n   unsigned id;\t\t\t/* ID assigned to the memory reference\n \t\t\t\t   (its index in memory_accesses.refs_list)  */\n   hashval_t hash;\t\t/* Its hash value.  */\n+\n+  /* The memory access itself and associated caching of alias-oracle\n+     query meta-data.  */\n+  ao_ref mem;\n+\n   bitmap stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n   vec<mem_ref_locs_p> accesses_in_loop;\n@@ -186,7 +190,7 @@ static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n #define SET_ALWAYS_EXECUTED_IN(BB, VAL) ((BB)->aux = (void *) (VAL))\n \n /* Whether the reference was analyzable.  */\n-#define MEM_ANALYZABLE(REF) ((REF)->mem != error_mark_node)\n+#define MEM_ANALYZABLE(REF) ((REF)->mem.ref != error_mark_node)\n \n static struct lim_aux_data *\n init_lim_data (gimple stmt)\n@@ -1449,7 +1453,7 @@ memref_eq (const void *obj1, const void *obj2)\n {\n   const struct mem_ref *const mem1 = (const struct mem_ref *) obj1;\n \n-  return operand_equal_p (mem1->mem, (const_tree) obj2, 0);\n+  return operand_equal_p (mem1->mem.ref, (const_tree) obj2, 0);\n }\n \n /* Releases list of memory reference locations ACCS.  */\n@@ -1491,7 +1495,7 @@ static mem_ref_p\n mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n {\n   mem_ref_p ref = XNEW (struct mem_ref);\n-  ref->mem = mem;\n+  ao_ref_init (&ref->mem, mem);\n   ref->id = id;\n   ref->hash = hash;\n   ref->stored = BITMAP_ALLOC (&lim_bitmap_obstack);\n@@ -1606,7 +1610,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Memory reference %u: \", id);\n-\t  print_generic_expr (dump_file, ref->mem, TDF_SLIM);\n+\t  print_generic_expr (dump_file, ref->mem.ref, TDF_SLIM);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n@@ -1730,7 +1734,8 @@ analyze_memory_references (void)\n    tree_to_aff_combination_expand.  */\n \n static bool\n-mem_refs_may_alias_p (tree mem1, tree mem2, struct pointer_map_t **ttae_cache)\n+mem_refs_may_alias_p (mem_ref_p mem1, mem_ref_p mem2,\n+\t\t      struct pointer_map_t **ttae_cache)\n {\n   /* Perform BASE + OFFSET analysis -- if MEM1 and MEM2 are based on the same\n      object and their offset differ in such a way that the locations cannot\n@@ -1739,16 +1744,16 @@ mem_refs_may_alias_p (tree mem1, tree mem2, struct pointer_map_t **ttae_cache)\n   aff_tree off1, off2;\n \n   /* Perform basic offset and type-based disambiguation.  */\n-  if (!refs_may_alias_p (mem1, mem2))\n+  if (!refs_may_alias_p_1 (&mem1->mem, &mem2->mem, true))\n     return false;\n \n   /* The expansion of addresses may be a bit expensive, thus we only do\n      the check at -O2 and higher optimization levels.  */\n   if (optimize < 2)\n     return true;\n \n-  get_inner_reference_aff (mem1, &off1, &size1);\n-  get_inner_reference_aff (mem2, &off2, &size2);\n+  get_inner_reference_aff (mem1->mem.ref, &off1, &size1);\n+  get_inner_reference_aff (mem2->mem.ref, &off2, &size2);\n   aff_combination_expand (&off1, ttae_cache);\n   aff_combination_expand (&off2, ttae_cache);\n   aff_combination_scale (&off1, double_int_minus_one);\n@@ -2079,7 +2084,7 @@ execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n   mem_ref_loc_p loc;\n   tree flag;\n   vec<mem_ref_loc_p> locs = vNULL;\n-  char *str = get_lsm_tmp_name (ref->mem, ~0);\n+  char *str = get_lsm_tmp_name (ref->mem.ref, ~0);\n \n   lsm_tmp_name_add (\"_flag\");\n   flag = create_tmp_reg (boolean_type_node, str);\n@@ -2121,16 +2126,16 @@ execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Executing store motion of \");\n-      print_generic_expr (dump_file, ref->mem, 0);\n+      print_generic_expr (dump_file, ref->mem.ref, 0);\n       fprintf (dump_file, \" from loop %d\\n\", loop->num);\n     }\n \n-  tmp_var = create_tmp_reg (TREE_TYPE (ref->mem),\n-\t\t\t      get_lsm_tmp_name (ref->mem, ~0));\n+  tmp_var = create_tmp_reg (TREE_TYPE (ref->mem.ref),\n+\t\t\t    get_lsm_tmp_name (ref->mem.ref, ~0));\n \n   fmt_data.loop = loop;\n   fmt_data.orig_loop = loop;\n-  for_each_index (&ref->mem, force_move_till, &fmt_data);\n+  for_each_index (&ref->mem.ref, force_move_till, &fmt_data);\n \n   if (block_in_transaction (loop_preheader_edge (loop)->src)\n       || !PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES))\n@@ -2148,7 +2153,7 @@ execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n   /* FIXME/TODO: For the multi-threaded variant, we could avoid this\n      load altogether, since the store is predicated by a flag.  We\n      could, do the load only if it was originally in the loop.  */\n-  load = gimple_build_assign (tmp_var, unshare_expr (ref->mem));\n+  load = gimple_build_assign (tmp_var, unshare_expr (ref->mem.ref));\n   lim_data = init_lim_data (load);\n   lim_data->max_loop = loop;\n   lim_data->tgt_loop = loop;\n@@ -2168,11 +2173,11 @@ execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n     if (!multi_threaded_model_p)\n       {\n \tgimple store;\n-\tstore = gimple_build_assign (unshare_expr (ref->mem), tmp_var);\n+\tstore = gimple_build_assign (unshare_expr (ref->mem.ref), tmp_var);\n \tgsi_insert_on_edge (ex, store);\n       }\n     else\n-      execute_sm_if_changed (ex, ref->mem, tmp_var, store_flag);\n+      execute_sm_if_changed (ex, ref->mem.ref, tmp_var, store_flag);\n }\n \n /* Hoists memory references MEM_REFS out of LOOP.  EXITS is the list of exit\n@@ -2206,9 +2211,8 @@ ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n   struct loop *must_exec;\n   tree base;\n \n-  base = get_base_address (ref->mem);\n-  if (INDIRECT_REF_P (base)\n-      || TREE_CODE (base) == MEM_REF)\n+  base = ao_ref_base (&ref->mem);\n+  if (TREE_CODE (base) == MEM_REF)\n     base = TREE_OPERAND (base, 0);\n \n   get_all_locs_in_loop (loop, ref, &locs);\n@@ -2255,32 +2259,40 @@ ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n static bool\n refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n {\n-  if (ref1 == ref2\n-      || bitmap_bit_p (ref1->indep_ref, ref2->id))\n+  if (ref1 == ref2)\n     return true;\n-  if (bitmap_bit_p (ref1->dep_ref, ref2->id))\n-    return false;\n+\n   if (!MEM_ANALYZABLE (ref1)\n       || !MEM_ANALYZABLE (ref2))\n     return false;\n \n+  /* Reference dependence in a loop is symmetric.  */\n+  if (ref1->id > ref2->id)\n+    {\n+      mem_ref_p tem = ref1;\n+      ref1 = ref2;\n+      ref2 = tem;\n+    }\n+\n+  if (bitmap_bit_p (ref1->indep_ref, ref2->id))\n+    return true;\n+  if (bitmap_bit_p (ref1->dep_ref, ref2->id))\n+    return false;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Querying dependency of refs %u and %u: \",\n \t     ref1->id, ref2->id);\n \n-  if (mem_refs_may_alias_p (ref1->mem, ref2->mem,\n-\t\t\t    &memory_accesses.ttae_cache))\n+  if (mem_refs_may_alias_p (ref1, ref2, &memory_accesses.ttae_cache))\n     {\n       bitmap_set_bit (ref1->dep_ref, ref2->id);\n-      bitmap_set_bit (ref2->dep_ref, ref1->id);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"dependent.\\n\");\n       return false;\n     }\n   else\n     {\n       bitmap_set_bit (ref1->indep_ref, ref2->id);\n-      bitmap_set_bit (ref2->indep_ref, ref1->id);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"independent.\\n\");\n       return true;\n@@ -2371,21 +2383,21 @@ can_sm_ref_p (struct loop *loop, mem_ref_p ref)\n     return false;\n \n   /* It should be movable.  */\n-  if (!is_gimple_reg_type (TREE_TYPE (ref->mem))\n-      || TREE_THIS_VOLATILE (ref->mem)\n-      || !for_each_index (&ref->mem, may_move_till, loop))\n+  if (!is_gimple_reg_type (TREE_TYPE (ref->mem.ref))\n+      || TREE_THIS_VOLATILE (ref->mem.ref)\n+      || !for_each_index (&ref->mem.ref, may_move_till, loop))\n     return false;\n \n   /* If it can throw fail, we do not properly update EH info.  */\n-  if (tree_could_throw_p (ref->mem))\n+  if (tree_could_throw_p (ref->mem.ref))\n     return false;\n \n   /* If it can trap, it must be always executed in LOOP.\n      Readonly memory locations may trap when storing to them, but\n      tree_could_trap_p is a predicate for rvalues, so check that\n      explicitly.  */\n-  base = get_base_address (ref->mem);\n-  if ((tree_could_trap_p (ref->mem)\n+  base = get_base_address (ref->mem.ref);\n+  if ((tree_could_trap_p (ref->mem.ref)\n        || (DECL_P (base) && TREE_READONLY (base)))\n       && !ref_always_accessed_p (loop, ref, true))\n     return false;"}]}