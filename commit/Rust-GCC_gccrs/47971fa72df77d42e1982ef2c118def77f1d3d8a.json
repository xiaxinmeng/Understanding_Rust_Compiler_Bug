{"sha": "47971fa72df77d42e1982ef2c118def77f1d3d8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5NzFmYTcyZGY3N2Q0MmUxOTgyZWYyYzExOGRlZjc3ZjFkM2Q4YQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2005-07-05T01:57:01Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-07-05T01:57:01Z"}, "message": "re PR target/21723 (ICE while building libgfortran)\n\n\tPR target/21723\n\t* pa.md: Remove fcpy alternative from movhi and movqi patterns.\n\t* pa32-regs.h (HARD_REGNO_NREGS): Return two floating point registers\n\tfor complex modes when generating code for PA 1.0.\n\t(VALID_FP_MODE_P): New macro.\n\t(HARD_REGNO_MODE_OK): Use VALID_FP_MODE_P.  Use non-overlapping register\n\tsets for all general and floating point modes.  Align wide floating\n\tpoint modes to even register boundaries to comply with architectural\n\trequirements.\n\t(CLASS_MAX_NREGS): Update to align with change to HARD_REGNO_NREGS.\n\t* pa64-regs.h (HARD_REGNO_NREGS): Update comment and formatting.\n\t(VALID_FP_MODE_P): New macro.\n\t(HARD_REGNO_MODE_OK): Use VALID_FP_MODE_P.  Use non-overlapping register\n\tsets for all general and floating point modes.  Align wide floating\n\tpoint modes to even register boundaries to comply with architectural\n\trequirements.\n\nFrom-SVN: r101613", "tree": {"sha": "ca9ac26e1b073140283691ca6509fb7b33a9d3fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca9ac26e1b073140283691ca6509fb7b33a9d3fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47971fa72df77d42e1982ef2c118def77f1d3d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47971fa72df77d42e1982ef2c118def77f1d3d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47971fa72df77d42e1982ef2c118def77f1d3d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47971fa72df77d42e1982ef2c118def77f1d3d8a/comments", "author": null, "committer": null, "parents": [{"sha": "f94ac7b644698a627288b8b4d613cc6ba45e48bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f94ac7b644698a627288b8b4d613cc6ba45e48bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f94ac7b644698a627288b8b4d613cc6ba45e48bd"}], "stats": {"total": 136, "additions": 104, "deletions": 32}, "files": [{"sha": "00eaf5d354b1008724de24617091e134c142d253", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47971fa72df77d42e1982ef2c118def77f1d3d8a", "patch": "@@ -1,3 +1,22 @@\n+2005-07-04  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/21723\n+\t* pa.md: Remove fcpy alternative from movhi and movqi patterns.\n+\t* pa32-regs.h (HARD_REGNO_NREGS): Return two floating point registers\n+\tfor complex modes when generating code for PA 1.0.\n+\t(VALID_FP_MODE_P): New macro.\n+\t(HARD_REGNO_MODE_OK): Use VALID_FP_MODE_P.  Use non-overlapping register\n+\tsets for all general and floating point modes.  Align wide floating\n+\tpoint modes to even register boundaries to comply with architectural\n+\trequirements.\n+\t(CLASS_MAX_NREGS): Update to align with change to HARD_REGNO_NREGS.\n+\t* pa64-regs.h (HARD_REGNO_NREGS): Update comment and formatting.\n+\t(VALID_FP_MODE_P): New macro.\n+\t(HARD_REGNO_MODE_OK): Use VALID_FP_MODE_P.  Use non-overlapping register\n+\tsets for all general and floating point modes.  Align wide floating\n+\tpoint modes to even register boundaries to comply with architectural\n+\trequirements.\n+\n 2005-07-04  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-dump.c (dump_files): Initialize dump number for .cgraph"}, {"sha": "f724209c1e9cb202afdffb5220ebc0e38b704095", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=47971fa72df77d42e1982ef2c118def77f1d3d8a", "patch": "@@ -2896,9 +2896,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"move_dest_operand\"\n-\t \t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f\")\n+\t \t\t  \"=r,r,r,r,r,Q,!*q,!r\")\n \t(match_operand:HI 1 \"move_src_operand\"\n-\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM\"))]\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q\"))]\n   \"register_operand (operands[0], HImode)\n    || reg_or_0_operand (operands[1], HImode)\"\n   \"@\n@@ -2909,11 +2909,10 @@\n    ldh%M1 %1,%0\n    sth%M0 %r1,%0\n    mtsar %r1\n-   {mfctl|mfctl,w} %sar,%0\n-   fcpy,sgl %f1,%0\"\n-  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,fpalu\")\n+   {mfctl|mfctl,w} %sar,%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move\")\n    (set_attr \"pa_combine_type\" \"addmove\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -3021,9 +3020,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"move_dest_operand\"\n-\t\t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f\")\n+\t\t\t  \"=r,r,r,r,r,Q,!*q,!r\")\n \t(match_operand:QI 1 \"move_src_operand\"\n-\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM\"))]\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q\"))]\n   \"register_operand (operands[0], QImode)\n    || reg_or_0_operand (operands[1], QImode)\"\n   \"@\n@@ -3034,11 +3033,10 @@\n    ldb%M1 %1,%0\n    stb%M0 %r1,%0\n    mtsar %r1\n-   {mfctl|mfctl,w} %%sar,%0\n-   fcpy,sgl %f1,%0\"\n-  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,fpalu\")\n+   {mfctl|mfctl,w} %%sar,%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move\")\n    (set_attr \"pa_combine_type\" \"addmove\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")"}, {"sha": "e96032e9c23c224c79a035895f118f754deee065", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=47971fa72df77d42e1982ef2c118def77f1d3d8a", "patch": "@@ -156,32 +156,69 @@\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On the HP-PA, ordinary registers hold 32 bits worth;\n-   The floating point registers are 64 bits wide. Snake fp regs are 32\n-   bits wide */\n+   On the HP-PA, general registers are 32 bits wide.  The floating\n+   point registers are 64 bits wide.  Snake fp regs are treated as\n+   32 bits wide since the left and right parts are independently\n+   accessible.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n-   ? (!TARGET_PA_11 ? 1 : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+   ? (!TARGET_PA_11\t\t\t\t\t\t\t\\\n+      ? COMPLEX_MODE_P (MODE) ? 2 : 1\t\t\t\t\t\\\n+      : (GET_MODE_SIZE (MODE) + 4 - 1) / 4) \t                        \\\n+   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* There are no instructions that use DImode in PA 1.0, so we only\n+   allow it in PA 1.1 and later.  */\n+#define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n+  ((MODE) == SFmode || (MODE) == DFmode\t\t\t\t\t\\\n+   || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n+   || (MODE) == SImode || (TARGET_PA_11 && (MODE) == DImode))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the HP-PA, the cpu registers can hold any mode.  For DImode, we\n-   choose a set of general register that includes the incoming arguments\n-   and the return value.  We specify a set with no overlaps so that we don't\n-   have to specify that the destination register in patterns using this mode\n-   is an early clobber.  */\n+\n+   On the HP-PA, the cpu registers can hold any mode that fits in 32 bits.\n+   For the 64-bit modes, we choose a set of non-overlapping general registers\n+   that includes the incoming arguments and the return value.  We specify a\n+   set with no overlaps so that we don't have to specify that the destination\n+   register is an early clobber in patterns using this mode.  Except for the\n+   return value, the starting registers are odd.  For 128 and 256 bit modes,\n+   we similarly specify non-overlapping sets of cpu registers.  However,\n+   there aren't any patterns defined for modes larger than 64 bits at the\n+   moment.\n+\n+   We limit the modes allowed in the floating point registers to the\n+   set of modes used in the machine definition.  In addition, we allow\n+   the complex modes SCmode and DCmode.  The real and imaginary parts\n+   of complex modes are allocated to separate registers.  This might\n+   allow patterns to be defined in the future to operate on these values.\n+\n+   The PA 2.0 architecture specifies that quad-precision floating-point\n+   values should start on an even floating point register.  Thus, we\n+   choose non-overlapping sets of registers starting on even register\n+   boundaries for large modes.  However, there is currently no support\n+   in the machine definition for modes larger than 64 bits.  TFmode is\n+   supported under HP-UX using libcalls.  Since TFmode values are passed\n+   by reference, they never need to be loaded into the floating-point\n+   registers.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n-   /* On 1.0 machines, don't allow wide non-fp modes in fp regs.  */\t\\\n    : !TARGET_PA_11 && FP_REGNO_P (REGNO)\t\t\t\t\\\n-     ? GET_MODE_SIZE (MODE) <= 4 || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+     ? (VALID_FP_MODE_P (MODE)\t\t\t\t\t\t\\\n+\t&& (GET_MODE_SIZE (MODE) <= 8\t\t\t\t\t\\\n+\t    || (GET_MODE_SIZE (MODE) == 16 && ((REGNO) & 3) == 0)))\t\\\n    : FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n-     ? GET_MODE_SIZE (MODE) <= 4 || ((REGNO) & 1) == 0\t\t\t\\\n+     ? (VALID_FP_MODE_P (MODE)\t\t\t\t\t\t\\\n+\t&& (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t    || (GET_MODE_SIZE (MODE) == 8 && ((REGNO) & 1) == 0)\t\\\n+\t    || (GET_MODE_SIZE (MODE) == 16 && ((REGNO) & 3) == 0)\t\\\n+\t    || (GET_MODE_SIZE (MODE) == 32 && ((REGNO) & 7) == 0)))\t\\\n    : (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\t\t\\\n       || (GET_MODE_SIZE (MODE) == 2 * UNITS_PER_WORD\t\t\t\\\n \t  && ((((REGNO) & 1) == 1 && (REGNO) <= 25) || (REGNO) == 28))\t\\\n       || (GET_MODE_SIZE (MODE) == 4 * UNITS_PER_WORD\t\t\t\\\n-\t  && (((REGNO) & 3) == 3 && (REGNO) <= 23))))\n+\t  && ((REGNO) & 3) == 3 && (REGNO) <= 23)\t\t\t\\\n+      || (GET_MODE_SIZE (MODE) == 8 * UNITS_PER_WORD\t\t\t\\\n+\t  && ((REGNO) & 7) == 3 && (REGNO) <= 19)))\n \n /* How to renumber registers for dbx and gdb.\n \n@@ -276,7 +313,9 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n   ((CLASS) == FP_REGS || (CLASS) == FPUPPER_REGS\t\t\t\\\n-   ? (!TARGET_PA_11 ? 1 : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\\\n+   ? (!TARGET_PA_11\t\t\t\t\t\t\t\\\n+      ? COMPLEX_MODE_P (MODE) ? 2 : 1\t\t\t\t\t\\\n+      : (GET_MODE_SIZE (MODE) + 4 - 1) / 4)\t\t\t\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* 1 if N is a possible register number for function argument passing.  */"}, {"sha": "fe06c7771e0ed0804a2d9e75ba76a1b40468e293", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47971fa72df77d42e1982ef2c118def77f1d3d8a/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=47971fa72df77d42e1982ef2c118def77f1d3d8a", "patch": "@@ -145,11 +145,19 @@ Boston, MA 02110-1301, USA.  */\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   For PA64, GPRs and FPRs hold 64 bits worth (we ignore the 32bit\n-   addressability of the FPRs).  i.e., we pretend each register holds\n-   precisely WORD_SIZE bits.  */\n+   For PA64, GPRs and FPRs hold 64 bits worth.  We ignore the 32-bit\n+   addressability of the FPRs and pretend each register holds precisely\n+   WORD_SIZE bits.  Note that SCmode values are placed in a single FPR.\n+   Thus, any patterns defined to operate on these values would have to\n+   use the 32-bit addressability of the FPR registers.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* These are the valid FP modes.  */\n+#define VALID_FP_MODE_P(MODE)                                           \\\n+  ((MODE) == SFmode || (MODE) == DFmode                                 \\\n+   || (MODE) == SCmode || (MODE) == DCmode                              \\\n+   || (MODE) == SImode || (MODE) == DImode)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n@@ -158,8 +166,16 @@ Boston, MA 02110-1301, USA.  */\n   ((REGNO) == 0\t\t\t\t\t\t\t\t\\\n    ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\t\t\\\n    /* Make wide modes be in aligned registers.  */\t\t\t\\\n+   : FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n+     ? (VALID_FP_MODE_P (MODE)\t\t\t\t\t\t\\\n+\t&& (GET_MODE_SIZE (MODE) <= 8\t\t\t\t\t\\\n+\t    || (GET_MODE_SIZE (MODE) == 16 && ((REGNO) & 1) == 0)\t\\\n+\t    || (GET_MODE_SIZE (MODE) == 32 && ((REGNO) & 3) == 0)))\t\\\n    : (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\t\t\\\n-      || (GET_MODE_SIZE (MODE) <= 2 * UNITS_PER_WORD && ((REGNO) & 1) == 0)))\n+      || (GET_MODE_SIZE (MODE) == 2 * UNITS_PER_WORD\t\t\t\\\n+\t  && ((((REGNO) & 1) == 1 && (REGNO) <= 25) || (REGNO) == 28))\t\\\n+      || (GET_MODE_SIZE (MODE) == 4 * UNITS_PER_WORD\t\t\t\\\n+\t  && ((REGNO) & 3) == 3 && (REGNO) <= 23)))\n \n /* How to renumber registers for dbx and gdb.\n "}]}