{"sha": "e82a312b55f88fc3d035e0c24409c71e043e9633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgyYTMxMmI1NWY4OGZjM2QwMzVlMGMyNDQwOWM3MWUwNDNlOTYzMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-05-06T03:14:10Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-05-06T03:14:10Z"}, "message": "real.c (real_powi): New function to calculate the value of a real raised to an integer power, i.e.\n\n\n\t* real.c (real_powi): New function to calculate the value of\n\ta real raised to an integer power, i.e. pow(x,n) for int n.\n\t(real_sqrt): Convert to using the faster do_add, do_multiply\n\tand do_divide API for consistency with the rest of real.c.\n\t* real.h (real_powi): Prototype here.\n\t* builtins.c (fold_builtin):  Avoid local variable mode when\n\tevaluating sqrt at compile time.  Attempt to evaluate pow at\n\tcompile-time, by checking for an integral exponent.\n\n\t* gcc.dg/builtins-14.c: New test case.\n\nFrom-SVN: r66515", "tree": {"sha": "2a99b03c08d036a34af9b1b5c844c11e3d67a3af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a99b03c08d036a34af9b1b5c844c11e3d67a3af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e82a312b55f88fc3d035e0c24409c71e043e9633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82a312b55f88fc3d035e0c24409c71e043e9633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82a312b55f88fc3d035e0c24409c71e043e9633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82a312b55f88fc3d035e0c24409c71e043e9633/comments", "author": null, "committer": null, "parents": [{"sha": "d7b4a590279f012756741c12f2027d714ea776c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b4a590279f012756741c12f2027d714ea776c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b4a590279f012756741c12f2027d714ea776c4"}], "stats": {"total": 153, "additions": 138, "deletions": 15}, "files": [{"sha": "ae2db06226cc4c98324e313ee6f85f57a12f4fe1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e82a312b55f88fc3d035e0c24409c71e043e9633", "patch": "@@ -1,3 +1,14 @@\n+2003-05-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* real.c (real_powi): New function to calculate the value of\n+\ta real raised to an integer power, i.e. pow(x,n) for int n.\n+\t(real_sqrt): Convert to using the faster do_add, do_multiply\n+\tand do_divide API for consistency with the rest of real.c.\n+\t* real.h (real_powi): Prototype here.\n+\t* builtins.c (fold_builtin):  Avoid local variable mode when\n+\tevaluating sqrt at compile time.  Attempt to evaluate pow at\n+\tcompile-time, by checking for an integral exponent.\n+\n 2003-05-05  Richard Henderson  <rth@redhat.com>\n \n \t* doc/extend.texi (Variable Attributes): Re-sort table and tidy."}, {"sha": "c309997fd972e9b1ba8d2a3f5170dc43b161304f", "filename": "gcc/builtins.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e82a312b55f88fc3d035e0c24409c71e043e9633", "patch": "@@ -5011,12 +5011,10 @@ fold_builtin (exp)\n \t  if (TREE_CODE (arg) == REAL_CST\n \t      && ! TREE_CONSTANT_OVERFLOW (arg))\n \t    {\n-\t      enum machine_mode mode;\n \t      REAL_VALUE_TYPE r, x;\n \n \t      x = TREE_REAL_CST (arg);\n-\t      mode = TYPE_MODE (type);\n-\t      if (real_sqrt (&r, mode, &x)\n+\t      if (real_sqrt (&r, TYPE_MODE (type), &x)\n \t\t  || (!flag_trapping_math && !flag_errno_math))\n \t\treturn build_real (type, r);\n \t    }\n@@ -5229,6 +5227,28 @@ fold_builtin (exp)\n \t\t      return build_function_call_expr (sqrtfn, arglist);\n \t\t    }\n \t\t}\n+\n+\t      /* Attempt to evaluate pow at compile-time.  */\n+\t      if (TREE_CODE (arg0) == REAL_CST\n+\t\t  && ! TREE_CONSTANT_OVERFLOW (arg0))\n+\t\t{\n+\t\t  REAL_VALUE_TYPE cint;\n+\t\t  HOST_WIDE_INT n;\n+\n+\t\t  n = real_to_integer(&c);\n+\t\t  real_from_integer (&cint, VOIDmode, n,\n+\t\t\t\t     n < 0 ? -1 : 0, 0);\n+\t\t  if (real_identical (&c, &cint))\n+\t\t    {\n+\t\t      REAL_VALUE_TYPE x;\n+\t\t      bool inexact;\n+\n+\t\t      x = TREE_REAL_CST (arg0);\n+\t\t      inexact = real_powi (&x, TYPE_MODE (type), &x, n);\n+\t\t      if (flag_unsafe_math_optimizations || !inexact)\n+\t\t\treturn build_real (type, x);\n+\t\t    }\n+\t\t}\n \t    }\n \n \t  /* Optimize pow(exp(x),y) = exp(x*y).  */"}, {"sha": "16cd02acb7f9b1f3053562c019cf68fdc2581546", "filename": "gcc/real.c", "status": "modified", "additions": 68, "deletions": 12, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=e82a312b55f88fc3d035e0c24409c71e043e9633", "patch": "@@ -4606,7 +4606,7 @@ real_sqrt (r, mode, x)\n \n   if (!init)\n     {\n-      real_arithmetic (&halfthree, PLUS_EXPR, &dconst1, &dconsthalf);\n+      do_add (&halfthree, &dconst1, &dconsthalf, 0);\n       init = true;\n     }\n \n@@ -4618,11 +4618,11 @@ real_sqrt (r, mode, x)\n   for (iter = 0; iter < 16; iter++)\n     {\n       /* i(n+1) = i(n) * (1.5 - 0.5*i(n)*i(n)*x).  */\n-      real_arithmetic (&t, MULT_EXPR, x, &i);\n-      real_arithmetic (&h, MULT_EXPR, &t, &i);\n-      real_arithmetic (&t, MULT_EXPR, &h, &dconsthalf);\n-      real_arithmetic (&h, MINUS_EXPR, &halfthree, &t);\n-      real_arithmetic (&t, MULT_EXPR, &i, &h);\n+      do_multiply (&t, x, &i);\n+      do_multiply (&h, &t, &i);\n+      do_multiply (&t, &h, &dconsthalf);\n+      do_add (&h, &halfthree, &t, 1);\n+      do_multiply (&t, &i, &h);\n \n       /* Check for early convergence.  */\n       if (iter >= 6 && real_identical (&i, &t))\n@@ -4633,16 +4633,72 @@ real_sqrt (r, mode, x)\n     }\n \n   /* Final iteration: r = i*x + 0.5*i*x*(1.0 - i*(i*x)).  */\n-  real_arithmetic (&t, MULT_EXPR, x, &i);\n-  real_arithmetic (&h, MULT_EXPR, &t, &i);\n-  real_arithmetic (&i, MINUS_EXPR, &dconst1, &h);\n-  real_arithmetic (&h, MULT_EXPR, &t, &i);\n-  real_arithmetic (&i, MULT_EXPR, &dconsthalf, &h);\n-  real_arithmetic (&h, PLUS_EXPR, &t, &i);\n+  do_multiply (&t, x, &i);\n+  do_multiply (&h, &t, &i);\n+  do_add (&i, &dconst1, &h, 1);\n+  do_multiply (&h, &t, &i);\n+  do_multiply (&i, &dconsthalf, &h);\n+  do_add (&h, &t, &i, 0);\n \n   /* ??? We need a Tuckerman test to get the last bit.  */\n \n   real_convert (r, mode, &h);\n   return true;\n }\n \n+/* Calculate X raised to the integer exponent N in mode MODE and store\n+   the result in R.  Return true if the result may be inexact due to\n+   loss of precision.  The algorithm is the classic \"left-to-right binary\n+   method\" described in section 4.6.3 of Donald Knuth's \"Seminumerical\n+   Algorithms\", \"The Art of Computer Programming\", Volume 2.  */\n+\n+bool\n+real_powi (r, mode, x, n)\n+     REAL_VALUE_TYPE *r;\n+     enum machine_mode mode;\n+     const REAL_VALUE_TYPE *x;\n+     HOST_WIDE_INT n;\n+{\n+  unsigned HOST_WIDE_INT bit;\n+  REAL_VALUE_TYPE t;\n+  bool inexact = false;\n+  bool init = false;\n+  bool neg;\n+  int i;\n+\n+  if (n == 0)\n+    {\n+      *r = dconst1;\n+      return false;\n+    }\n+  else if (n < 0)\n+    {\n+      /* Don't worry about overflow, from now on n is unsigned.  */\n+      neg = true;\n+      n = -n;\n+    }\n+  else\n+    neg = false;\n+\n+  t = *x;\n+  bit = (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1);\n+  for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)\n+    {\n+      if (init)\n+\t{\n+\t  inexact |= do_multiply (&t, &t, &t);\n+\t  if (n & bit)\n+\t    inexact |= do_multiply (&t, &t, x);\n+\t}\n+      else if (n & bit)\n+\tinit = true;\n+      bit >>= 1;\n+    }\n+\n+  if (neg)\n+    inexact |= do_divide (&t, &dconst1, &t);\n+\n+  real_convert (r, mode, &t);\n+  return inexact;\n+}\n+"}, {"sha": "16113924ae58c3d6f988f9757a6d4b1a7f8e3015", "filename": "gcc/real.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=e82a312b55f88fc3d035e0c24409c71e043e9633", "patch": "@@ -365,4 +365,10 @@ extern bool real_sqrt\t\t\tPARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t const REAL_VALUE_TYPE *));\n \n+/* Calculate R as X raised to the integer exponent N in mode MODE. */\n+extern bool real_powi\t\t\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t const REAL_VALUE_TYPE *,\n+\t\t\t\t\t\t HOST_WIDE_INT));\n+\n #endif /* ! GCC_REAL_H */"}, {"sha": "9c161a7fbc1f255ad142939b36379568a9376130", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e82a312b55f88fc3d035e0c24409c71e043e9633", "patch": "@@ -1,3 +1,7 @@\n+2003-05-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-14.c: New test case.\n+\n 2003-05-05  Janis Johnson  <janis187@us.ibm.com>\n \n \t* lib/compat.exp (compat-execute): New argument."}, {"sha": "e025391a9ba11819a15e710811490433d193458c", "filename": "gcc/testsuite/gcc.dg/builtins-14.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82a312b55f88fc3d035e0c24409c71e043e9633/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-14.c?ref=e82a312b55f88fc3d035e0c24409c71e043e9633", "patch": "@@ -0,0 +1,26 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that constant folding of built-in math functions doesn't\n+   break anything and produces the expected results.\n+\n+   Written by Roger Sayle, 9th April 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error(void);\n+\n+extern double pow(double,double);\n+\n+\n+int main()\n+{\n+  if (pow (2.0, 3.0) != 8.0)\n+    link_error ();\n+\n+  if (pow (2.0, -3.0) != 0.125)\n+    link_error ();\n+\n+  return 0;\n+}\n+"}]}