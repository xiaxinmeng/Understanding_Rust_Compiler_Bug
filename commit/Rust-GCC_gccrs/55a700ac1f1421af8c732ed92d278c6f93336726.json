{"sha": "55a700ac1f1421af8c732ed92d278c6f93336726", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVhNzAwYWMxZjE0MjFhZjhjNzMyZWQ5MmQyNzhjNmY5MzMzNjcyNg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-11T23:18:58Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-11T23:18:58Z"}, "message": "tree-data-ref.c (chrec_steps_divide_constant_p): Removed.\n\n\t* tree-data-ref.c (chrec_steps_divide_constant_p): Removed.\n\t(gcd_of_steps_may_divide_p): New function.\n\t(analyze_miv_subscript): Use gcd_of_steps_may_divide_p.\n\nFrom-SVN: r123731", "tree": {"sha": "9e5a1e21312d0f0e8bf33bf67a31d88c8b18863f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e5a1e21312d0f0e8bf33bf67a31d88c8b18863f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55a700ac1f1421af8c732ed92d278c6f93336726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a700ac1f1421af8c732ed92d278c6f93336726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a700ac1f1421af8c732ed92d278c6f93336726", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a700ac1f1421af8c732ed92d278c6f93336726/comments", "author": null, "committer": null, "parents": [{"sha": "8e5fc53c5c3df872251738ce82202d94b2a3610c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e5fc53c5c3df872251738ce82202d94b2a3610c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e5fc53c5c3df872251738ce82202d94b2a3610c"}], "stats": {"total": 59, "additions": 28, "deletions": 31}, "files": [{"sha": "cc2019ac6a981b8e6d96f59fc30f4e59c1a505a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a700ac1f1421af8c732ed92d278c6f93336726/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a700ac1f1421af8c732ed92d278c6f93336726/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55a700ac1f1421af8c732ed92d278c6f93336726", "patch": "@@ -1,3 +1,9 @@\n+2007-04-11  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-data-ref.c (chrec_steps_divide_constant_p): Removed.\n+\t(gcd_of_steps_may_divide_p): New function.\n+\t(analyze_miv_subscript): Use gcd_of_steps_may_divide_p.\n+\n 2007-04-11  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* reload.c (find_reloads_toplev, find_reloads_address,\n@@ -11,7 +17,7 @@\n \tinsert_innermost_unit_dist_vector, add_distance_for_zero_overlaps): New.\n \t(build_classic_dist_vector): Call add_distance_for_zero_overlaps.\n \n-2007-04-10  Zdenek Dvorak  <dvorakz@suse.cz>\n+2007-04-11  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-data-ref.c (add_multivariate_self_dist): Force the distance\n \tvector to be positive."}, {"sha": "ac5aa50ebbdeaa6df1954735423e7ba7f6b4c6f0", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a700ac1f1421af8c732ed92d278c6f93336726/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a700ac1f1421af8c732ed92d278c6f93336726/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=55a700ac1f1421af8c732ed92d278c6f93336726", "patch": "@@ -3462,36 +3462,29 @@ analyze_siv_subscript (tree chrec_a,\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* Return true when the property can be computed.  RES should contain\n-   true when calling the first time this function, then it is set to\n-   false when one of the evolution steps of an affine CHREC does not\n-   divide the constant CST.  */\n+/* Returns false if we can prove that the greatest common divisor of the steps\n+   of CHREC does not divide CST, false otherwise.  */\n \n static bool\n-chrec_steps_divide_constant_p (tree chrec, \n-\t\t\t       tree cst, \n-\t\t\t       bool *res)\n+gcd_of_steps_may_divide_p (tree chrec, tree cst)\n {\n-  switch (TREE_CODE (chrec))\n-    {\n-    case POLYNOMIAL_CHREC:\n-      if (evolution_function_is_constant_p (CHREC_RIGHT (chrec)))\n-\t{\n-\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec), cst))\n-\t    /* Keep RES to true, and iterate on other dimensions.  */\n-\t    return chrec_steps_divide_constant_p (CHREC_LEFT (chrec), cst, res);\n-\t  \n-\t  *res = false;\n-\t  return true;\n-\t}\n-      else\n-\t/* When the step is a parameter the result is undetermined.  */\n-\treturn false;\n+  HOST_WIDE_INT cd = 0, val;\n+  tree step;\n \n-    default:\n-      /* On the initial condition, return true.  */\n-      return true;\n+  if (!host_integerp (cst, 0))\n+    return true;\n+  val = tree_low_cst (cst, 0);\n+\n+  while (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    {\n+      step = CHREC_RIGHT (chrec);\n+      if (!host_integerp (step, 0))\n+\treturn true;\n+      cd = gcd (cd, tree_low_cst (step, 0));\n+      chrec = CHREC_LEFT (chrec);\n     }\n+\n+  return val % cd == 0;\n }\n \n /* Analyze a MIV (Multiple Index Variable) subscript.  *OVERLAPS_A and\n@@ -3516,7 +3509,6 @@ analyze_miv_subscript (tree chrec_a,\n      variables.  In the MIV case we have to solve a Diophantine\n      equation with 2*n variables (if the subscript uses n IVs).\n   */\n-  bool divide_p = true;\n   tree difference;\n   dependence_stats.num_miv++;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3540,14 +3532,13 @@ analyze_miv_subscript (tree chrec_a,\n   else if (evolution_function_is_constant_p (difference)\n \t   /* For the moment, the following is verified:\n \t      evolution_function_is_affine_multivariate_p (chrec_a) */\n-\t   && chrec_steps_divide_constant_p (chrec_a, difference, &divide_p)\n-\t   && !divide_p)\n+\t   && !gcd_of_steps_may_divide_p (chrec_a, difference))\n     {\n       /* testsuite/.../ssa-chrec-33.c\n \t {{21, +, 2}_1, +, -2}_2  vs.  {{20, +, 2}_1, +, -2}_2 \n \t \n-\t The difference is 1, and the evolution steps are equal to 2,\n-\t consequently there are no overlapping elements.  */\n+\t The difference is 1, and all the evolution steps are multiples\n+\t of 2, consequently there are no overlapping elements.  */\n       *overlaps_a = conflict_fn_no_dependence ();\n       *overlaps_b = conflict_fn_no_dependence ();\n       *last_conflicts = integer_zero_node;"}]}