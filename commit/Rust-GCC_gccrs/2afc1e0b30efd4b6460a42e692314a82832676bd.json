{"sha": "2afc1e0b30efd4b6460a42e692314a82832676bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFmYzFlMGIzMGVmZDRiNjQ2MGE0MmU2OTIzMTRhODI4MzI2NzZiZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-22T06:06:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-22T06:06:31Z"}, "message": "runtime: Return random number of hash of NaN.\n\nFrom-SVN: r191632", "tree": {"sha": "2ce5d179f6bcc6d9d87f045f082c26dcf3870c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce5d179f6bcc6d9d87f045f082c26dcf3870c0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2afc1e0b30efd4b6460a42e692314a82832676bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2afc1e0b30efd4b6460a42e692314a82832676bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2afc1e0b30efd4b6460a42e692314a82832676bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2afc1e0b30efd4b6460a42e692314a82832676bd/comments", "author": null, "committer": null, "parents": [{"sha": "a7a904566298c4a7a5712ddc0f631f843224ff0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a904566298c4a7a5712ddc0f631f843224ff0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a904566298c4a7a5712ddc0f631f843224ff0b"}], "stats": {"total": 28, "additions": 22, "deletions": 6}, "files": [{"sha": "106024f5c88b2c22348ab04798c7533fb90b0684", "filename": "libgo/runtime/go-type-complex.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afc1e0b30efd4b6460a42e692314a82832676bd/libgo%2Fruntime%2Fgo-type-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afc1e0b30efd4b6460a42e692314a82832676bd/libgo%2Fruntime%2Fgo-type-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-complex.c?ref=2afc1e0b30efd4b6460a42e692314a82832676bd", "patch": "@@ -32,10 +32,14 @@ __go_type_hash_complex (const void *vkey, uintptr_t key_size)\n       cf = ucf.cf;\n       cfr = __builtin_crealf (cf);\n       cfi = __builtin_cimagf (cf);\n-      if (__builtin_isinff (cfr) || __builtin_isinff (cfi)\n-\t  || __builtin_isnanf (cfr) || __builtin_isnanf (cfi))\n+      if (__builtin_isinff (cfr) || __builtin_isinff (cfi))\n \treturn 0;\n \n+      /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n+\t random so that not all NaNs wind up in the same place.  */\n+      if (__builtin_isnanf (cfr) || __builtin_isnanf (cfi))\n+\treturn runtime_fastrand1 ();\n+\n       /* Avoid negative zero.  */\n       if (cfr == 0 && cfi == 0)\n \treturn 0;\n@@ -62,10 +66,12 @@ __go_type_hash_complex (const void *vkey, uintptr_t key_size)\n       cd = ucd.cd;\n       cdr = __builtin_crealf (cd);\n       cdi = __builtin_cimagf (cd);\n-      if (__builtin_isinf (cdr) || __builtin_isinf (cdi)\n-\t  || __builtin_isnan (cdr) || __builtin_isnan (cdi))\n+      if (__builtin_isinf (cdr) || __builtin_isinf (cdi))\n \treturn 0;\n \n+      if (__builtin_isnan (cdr) || __builtin_isnan (cdi))\n+\treturn runtime_fastrand1 ();\n+\n       /* Avoid negative zero.  */\n       if (cdr == 0 && cdi == 0)\n \treturn 0;"}, {"sha": "e1c03e4284390d78c036a43b8b3aed863cf0d549", "filename": "libgo/runtime/go-type-float.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afc1e0b30efd4b6460a42e692314a82832676bd/libgo%2Fruntime%2Fgo-type-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afc1e0b30efd4b6460a42e692314a82832676bd/libgo%2Fruntime%2Fgo-type-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-float.c?ref=2afc1e0b30efd4b6460a42e692314a82832676bd", "patch": "@@ -29,8 +29,14 @@ __go_type_hash_float (const void *vkey, uintptr_t key_size)\n \n       __builtin_memcpy (uf.a, vkey, 4);\n       f = uf.f;\n-      if (__builtin_isinff (f) || __builtin_isnanf (f) || f == 0)\n+      if (__builtin_isinff (f) || f == 0)\n \treturn 0;\n+\n+      /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n+\t random so that not all NaNs wind up in the same place.  */\n+      if (__builtin_isnanf (f))\n+\treturn runtime_fastrand1 ();\n+\n       return (uintptr_t) uf.si;\n     }\n   else if (key_size == 8)\n@@ -45,8 +51,12 @@ __go_type_hash_float (const void *vkey, uintptr_t key_size)\n \n       __builtin_memcpy (ud.a, vkey, 8);\n       d = ud.d;\n-      if (__builtin_isinf (d) || __builtin_isnan (d) || d == 0)\n+      if (__builtin_isinf (d) || d == 0)\n \treturn 0;\n+\n+      if (__builtin_isnan (d))\n+\treturn runtime_fastrand1 ();\n+\n       return (uintptr_t) ud.di;\n     }\n   else"}]}