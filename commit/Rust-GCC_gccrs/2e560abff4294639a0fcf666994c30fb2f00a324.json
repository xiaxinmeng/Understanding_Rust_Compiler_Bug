{"sha": "2e560abff4294639a0fcf666994c30fb2f00a324", "node_id": "C_kwDOANBUbNoAKDJlNTYwYWJmZjQyOTQ2MzlhMGZjZjY2Njk5NGMzMGZiMmYwMGEzMjQ", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-10-28T06:28:29Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-11-02T08:41:29Z"}, "message": "Adjust testcase for O2 vect.\n\nAdjust code in check_vect_slp_store_usage to make it an exact\npattern match of the corresponding testcases.\nThese new target/xfail selectors are added as a temporary solution,\nand should be removed after real issue is fixed for Wstringop-overflow.\n\ngcc/ChangeLog:\n\n\t* doc/sourcebuild.texi (vect_slp_v4qi_store_unalign,\n\tvect_slp_v2hi_store_unalign, vect_slp_v4hi_store_unalign,\n\tvect_slp_v4si_store_unalign): Document efficient target.\n\t(vect_slp_v4qi_store_unalign_1, vect_slp_v8qi_store_unalign_1,\n\tvect_slp_v16qi_store_unalign_1): Ditto.\n\t(vect_slp_v2hi_store_align,vect_slp_v2qi_store_align,\n\tvect_slp_v2si_store_align, vect_slp_v4qi_store_align): Ditto.\n\t(struct_4char_block_move, struct_8char_block_move,\n\tstruct_16char_block_move): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\tPR testsuite/102944\n\t* c-c++-common/Wstringop-overflow-2.c: Adjust target/xfail\n\tselector.\n\t* gcc.dg/Warray-bounds-48.c: Ditto.\n\t* gcc.dg/Warray-bounds-51.c: Ditto.\n\t* gcc.dg/Warray-parameter-3.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-14.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-21.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-68.c: Ditto\n\t* gcc.dg/Wstringop-overflow-76.c: Ditto\n\t* gcc.dg/Wzero-length-array-bounds-2.c: Ditto.\n\t* lib/target-supports.exp (vect_slp_v4qi_store_unalign): New\n\tefficient target.\n\t(vect_slp_v4qi_store_unalign_1): Ditto.\n\t(struct_4char_block_move): Ditto.\n\t(struct_8char_block_move): Ditto.\n\t(stryct_16char_block_move): Ditto.\n\t(vect_slp_v2hi_store_align): Ditto.\n\t(vect_slp_v2qi_store): Rename to ..\n\t(vect_slp_v2qi_store_align): .. this.\n\t(vect_slp_v4qi_store): Rename to ..\n\t(vect_slp_v4qi_store_align): .. This.\n\t(vect_slp_v8qi_store): Rename to ..\n\t(vect_slp_v8qi_store_unalign_1): .. This.\n\t(vect_slp_v16qi_store): Rename to ..\n\t(vect_slp_v16qi_store_unalign_1): .. This.\n\t(vect_slp_v2hi_store): Rename to ..\n\t(vect_slp_v2hi_store_unalign): .. This.\n\t(vect_slp_v4hi_store): Rename to ..\n\t(vect_slp_v4hi_store_unalign): This.\n\t(vect_slp_v2si_store): Rename to ..\n\t(vect_slp_v2si_store_align): .. This.\n\t(vect_slp_v4si_store): Rename to ..\n\t(vect_slp_v4si_store_unalign): Ditto.\n\t(check_vect_slp_aligned_store_usage): Rename to ..\n\t(check_vect_slp_store_usage): .. this and adjust code to make\n\tit an exact pattern match of corresponding testcase.", "tree": {"sha": "542d61a51133ac2c327e61e9e1abe110c78eb9e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/542d61a51133ac2c327e61e9e1abe110c78eb9e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e560abff4294639a0fcf666994c30fb2f00a324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e560abff4294639a0fcf666994c30fb2f00a324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e560abff4294639a0fcf666994c30fb2f00a324", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e560abff4294639a0fcf666994c30fb2f00a324/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1188cf5fb7d9c3f0753cdb11d961fe90113991e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1188cf5fb7d9c3f0753cdb11d961fe90113991e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1188cf5fb7d9c3f0753cdb11d961fe90113991e8"}], "stats": {"total": 441, "additions": 303, "deletions": 138}, "files": [{"sha": "40b1e0d816789b225089c4143fb63e62a6af817a", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -1846,37 +1846,59 @@ Target supports loop vectorization with partial vectors and\n Target supports loop vectorization with partial vectors and\n @code{vect-partial-vector-usage} is nonzero.\n \n-@item vect_slp_v2qi_store\n+@item vect_slp_v2qi_store_align\n Target supports vectorization of 2-byte char stores with 2-byte aligned\n address at plain @option{-O2}.\n \n-@item vect_slp_v4qi_store\n+@item vect_slp_v4qi_store_align\n Target supports vectorization of 4-byte char stores with 4-byte aligned\n address at plain @option{-O2}.\n \n-@item vect_slp_v8qi_store\n-Target supports vectorization of 8-byte char stores with 8-byte aligned\n-address at plain @option{-O2}.\n+@item vect_slp_v4qi_store_unalign\n+Target supports vectorization of 4-byte char stores with unaligned address\n+at plain @option{-O2}.\n \n-@item vect_slp_v16qi_store\n-Target supports vectorization of 16-byte char stores with 16-byte aligned\n-address at plain @option{-O2}.\n+@item struct_4char_block_move\n+Target supports block move for 8-byte aligned 4-byte size struct initialization.\n+\n+@item vect_slp_v4qi_store_unalign_1\n+Target supports vectorization of 4-byte char stores with unaligned address\n+or store them with constant pool at plain @option{-O2}.\n+\n+@item struct_8char_block_move\n+Target supports block move for 8-byte aligned 8-byte size struct initialization.\n+\n+@item vect_slp_v8qi_store_unalign_1\n+Target supports vectorization of 8-byte char stores with unaligned address\n+or store them with constant pool at plain @option{-O2}.\n+\n+@item struct_16char_block_move\n+Target supports block move for 8-byte aligned 16-byte size struct\n+initialization.\n \n-@item vect_slp_v2hi_store\n+@item vect_slp_v16qi_store_unalign_1\n+Target supports vectorization of 16-byte char stores with unaligned address\n+or store them with constant pool at plain @option{-O2}.\n+\n+@item vect_slp_v2hi_store_align\n Target supports vectorization of 4-byte short stores with 4-byte aligned\n-address at plain @option{-O2}.\n+addressat plain @option{-O2}.\n \n-@item vect_slp_v4hi_store\n-Target supports vectorization of 8-byte short stores with 8-byte aligned\n-address at plain @option{-O2}.\n+@item vect_slp_v2hi_store_unalign\n+Target supports vectorization of 4-byte short stores with unaligned address\n+at plain @option{-O2}.\n \n-@item vect_slp_v2si_store\n-Target supports vectorization of 8-byte int stores with 8-byte aligned\n-address at plain @option{-O2}.\n+@item vect_slp_v4hi_store_unalign\n+Target supports vectorization of 8-byte short stores with unaligned address\n+at plain @option{-O2}.\n \n-@item vect_slp_v4si_store\n-Target supports vectorization of 16-byte int stores with 16-byte aligned\n-address at plain @option{-O2}.\n+@item vect_slp_v2si_store_align\n+Target supports vectorization of 8-byte int stores with 8-byte aligned address\n+at plain @option{-O2}.\n+\n+@item vect_slp_v4si_store_unalign\n+Target supports vectorization of 16-byte int stores with unaligned address\n+at plain @option{-O2}.\n @end table\n \n @subsubsection Thread Local Storage attributes"}, {"sha": "e5802613a9ce43d571cffafd6150456fec5b03f1", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -190,7 +190,7 @@ void ga1__ (void)\n   struct A1 a = { 1 };\n   a.a[0] = 0;\n   a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store_align } } }\n   sink (&a);\n }\n \n@@ -207,7 +207,7 @@ void ga1_0_ (void)\n   struct A1 a = { 1, { } };\n   a.a[0] = 0;\n   a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store_align } } }\n   sink (&a);\n }\n \n@@ -221,10 +221,10 @@ void ga1_1 (void)\n   a1_1.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a1_1.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n \n-  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n+  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store_align } } }\n   a.a[0] = 0;\n-  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { vect_slp_v4qi_store } } }\n-  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { vect_slp_v4qi_store } } }\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { vect_slp_v4qi_store_align } } }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { vect_slp_v4qi_store_align } } }\n   sink (&a);\n }\n \n@@ -289,7 +289,7 @@ void ga1i__ (void)\n   struct A1i a = { 0 };\n   a.a[0] = 0;\n   a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store_align } } }\n   sink (&a);\n }\n \n@@ -306,7 +306,7 @@ void ga1i_0_ (void)\n   struct A1 a = { 0, { } };\n   a.a[0] = 0;\n   a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store_align } } }\n   sink (&a);\n }\n \n@@ -320,10 +320,10 @@ void ga1i_1 (void)\n   a1i_1.a[1] = 1;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a1i_1.a[2] = 2;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n \n-  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { target { vect_slp_v4qi_store } } }\n+  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { target { vect_slp_v4qi_store_align } } }\n   a.a[0] = 1;\n-  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v4qi_store } } }\n-  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v4qi_store } } }\n+  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v4qi_store_align } } }\n+  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v4qi_store_align } } }\n   sink (&a);\n }\n "}, {"sha": "29b20863846093ef324d0209405f0eb2062d0da8", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-48.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -30,7 +30,7 @@ static void nowarn_ax_extern (struct AX *p)\n \n static void warn_ax_local_buf (struct AX *p)\n {\n-  p->ax[0] = 4; p->ax[1] = 5;  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2hi_store &&  { ! vect_slp_v4hi_store } } } }\n+  p->ax[0] = 4; p->ax[1] = 5;  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2hi_store_align &&  { ! vect_slp_v4hi_store_unalign } } } }\n \n   p->ax[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   p->ax[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n@@ -130,7 +130,7 @@ static void warn_a0_extern (struct A0 *p)\n \n static void warn_a0_local_buf (struct A0 *p)\n {\n-  p->a0[0] = 4; p->a0[1] = 5;  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2hi_store && { ! vect_slp_v4hi_store } } } }\n+  p->a0[0] = 4; p->a0[1] = 5;  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2hi_store_align && { ! vect_slp_v4hi_store_unalign } } } }\n \n   p->a0[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   p->a0[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }"}, {"sha": "7519b0fed79deb52be3c61c0c4f3a5b092ce8099", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-51.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -39,7 +39,7 @@ void test_struct_char_vla_location (void)\n   } s;\n \n   s.cvla[0] = __LINE__;\n-  s.cvla[nelts - 1] = 0; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2qi_store } } }\n+  s.cvla[nelts - 1] = 0; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2qi_store_align } } }\n   s.cvla[nelts] = 0;  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   sink (&s);"}, {"sha": "b888511ce1efdbc9ddd21de81ba3a9b6a1f9eb2b", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -77,7 +77,7 @@ gia3 (int a[3])\n __attribute__ ((noipa)) void\n gcas3 (char a[static 3])\n {\n-  a[0] = 0; a[1] = 1; a[2] = 2; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n+  a[0] = 0; a[1] = 1; a[2] = 2; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store_unalign } } }\n   a[3] = 3;                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n "}, {"sha": "3d1d9e54d4ac37f873e2d4aadbb7b013877dbd5c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-14.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -36,8 +36,8 @@ void test_memcpy_cond (int i)\n void test_int16 (void)\n {\n   char *p = a4 + 1;\n-  *(int16_t*)p = 0;    // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v2hi_store } } }\n-  *(int16_t*)(p + 2) = 0;   // { dg-warning \"writing 2 bytes into a region of size 1\" \"pr102706\" { xfail { vect_slp_v2hi_store } } }\n+  *(int16_t*)p = 0;    // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v2hi_store_unalign } } }\n+  *(int16_t*)(p + 2) = 0;   // { dg-warning \"writing 2 bytes into a region of size 1\" \"pr102706\" { xfail { vect_slp_v2hi_store_unalign } } }\n }\n \n "}, {"sha": "4cd3c1b4f624e474bb27b3c30e6a748422a5013e", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-21.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -23,10 +23,10 @@ void test_store_zero_length (int i)\n {\n   char a[3];\n   struct S0 *p = (struct S0*)a;\n-  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n+  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store_align } } }\n   p->b[0] = 0;\n   p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n-  p->b[2] = 2;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n+  p->b[2] = 2;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { xfail { vect_slp_v4qi_store_align } } }\n   p->b[i] = 2;\n   sink (p);\n }\n@@ -50,10 +50,10 @@ void test_store_flexarray (int i)\n {\n   char a[3];\n   struct Sx *p = (struct Sx*)a;\n-  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n+  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store_align } } }\n   p->b[0] = 0;\n   p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n-  p->b[2] = 1;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n+  p->b[2] = 1;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { xfail { vect_slp_v4qi_store_align } } }\n   p->b[i] = 2;\n   sink (p);\n }"}, {"sha": "05ea56fca67317c49970d23da04a07e8724e6c59", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-68.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -65,11 +65,11 @@ void warn_comp_lit (void)\n   // MEM <vector(8) char> [(char *)&a7] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n   // MEM <vector(16) char> [(char *)&a15] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n   // and warning should be expected, refer to PR102722.\n-  *(AC4*)a2 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store } } } }\n-  *(AC4*)a3 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store } } } }\n-  *(AC8*)a4 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store } } } }\n-  *(AC8*)a7 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store } } } }\n-  *(AC16*)a15 = Ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" \"pr101475\" { xfail { ! { vect_slp_v16qi_store } } } }\n+  *(AC4*)a2 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store_unalign_1 } } } }\n+  *(AC4*)a3 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store_unalign_1 } } } }\n+  *(AC8*)a4 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store_unalign_1 } } } }\n+  *(AC8*)a7 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store_unalign_1 } } } }\n+  *(AC16*)a15 = Ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" \"pr101475\" { xfail { ! { vect_slp_v16qi_store_unalign_1 } } } }\n }\n \n void warn_aggr_decl (void)"}, {"sha": "ee315a0c00279a48b2de56642a22a564b85f03a7", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-76.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -27,10 +27,10 @@ void max_a3_a5 (int i)\n      by its own warning independently of -Wstringop-overflow.  */\n   char *d = MAX (p, q);\n \n-  d[2] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n+  d[2] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v4qi_store_unalign } } }\n   d[3] = 0;\n   d[4] = 0;\n-  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102706\" { xfail { vect_slp_v4qi_store_unalign } } }\n }\n \n \n@@ -44,10 +44,10 @@ void max_b6_b4 (int i)\n   char *q = b4 + i;\n   char *d = MAX (p, q);\n \n-  d[3] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n+  d[3] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v4qi_store_unalign } } }\n   d[4] = 0;\n   d[5] = 0;\n-  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102706\" { xfail { vect_slp_v4qi_store_unalign } } }\n }\n \n \n@@ -83,7 +83,7 @@ struct A3_5\n {\n   char a3[3];  // { dg-message \"at offset 3 into destination object 'a3' of size 3\" \"pr??????\" { xfail *-*-* } }\n   // refer to pr102697 for xfail\n-  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" { xfail { vect_slp_v4qi_store } } }\n+  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" { xfail { vect_slp_v4qi_store_unalign } } }\n };\n \n void max_A3_A5 (int i, struct A3_5 *pa3_5)\n@@ -96,15 +96,15 @@ void max_A3_A5 (int i, struct A3_5 *pa3_5)\n   d[2] = 0;\n   d[3] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr??????\" { xfail *-*-* } }\n   d[4] = 0;\n-  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102697\" { xfail { vect_slp_v4qi_store } } }\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102697\" { xfail { vect_slp_v4qi_store_unalign } } }\n }\n \n \n struct B4_B6\n {\n   char b4[4];\n   // refer to pr102697 for xfail\n-  char b6[6];       // { dg-message \"at offset \\[^a-zA-Z\\n\\r\\]*6\\[^a-zA-Z0-9\\]* into destination object 'b6' of size 6\" \"note\" { xfail { vect_slp_v4qi_store } } }\n+  char b6[6];       // { dg-message \"at offset \\[^a-zA-Z\\n\\r\\]*6\\[^a-zA-Z0-9\\]* into destination object 'b6' of size 6\" \"note\" { xfail { vect_slp_v4qi_store_unalign } } }\n };\n \n void max_B6_B4 (int i, struct B4_B6 *pb4_b6)\n@@ -116,7 +116,7 @@ void max_B6_B4 (int i, struct B4_B6 *pb4_b6)\n   d[3] = 0;\n   d[4] = 0;\n   d[5] = 0;\n-  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102697\" { xfail { vect_slp_v4qi_store } } }\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102697\" { xfail { vect_slp_v4qi_store_unalign } } }\n }\n \n "}, {"sha": "2ef5ccd564ac470b6e56bee535b479ac9d63ceaf", "filename": "gcc/testsuite/gcc.dg/Wzero-length-array-bounds-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -87,7 +87,7 @@ void test_C_global_buf (void)\n   p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n   sink (p);\n \n-  p->b2.a[ 0].i = 0;    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2si_store &&  { ! vect_slp_v4si_store } } } }\n+  p->b2.a[ 0].i = 0;    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2si_store_align &&  { ! vect_slp_v4si_store_unalign } } } }\n   p->b2.a[ 1].i = 0;\n   p->b2.a[ 2].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   p->b2.a[ 3].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }"}, {"sha": "e07d563f6f4e39aa6264ecf9074db7be75dae009", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 228, "deletions": 85, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e560abff4294639a0fcf666994c30fb2f00a324/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=2e560abff4294639a0fcf666994c30fb2f00a324", "patch": "@@ -7584,95 +7584,149 @@ proc check_effective_target_vect_element_align_preferred { } {\n # Return zero if the desirable pattern isn't found.\n # It's used by Warray-bounds/Wstringop-overflow testcases which are\n # regressed by O2 vectorization, refer to PR102697/PR102462/PR102706\n-proc check_vect_slp_aligned_store_usage { pattern macro } {\n+proc check_vect_slp_store_usage { pattern macro } {\n     global tool\n \n     set result [check_compile slp_aligned_store_usage assembly {\n-\tchar a[16] __attribute__ ((aligned (16)));\n-\tshort b[4] __attribute__((aligned(8)));\n-\tint c[4] __attribute__((aligned(16)));\n-\t#ifdef TEST_V8QI\n+\textern void sink (void* );\n+\t#define Ac8 (AC8){ 0, 1, 2, 3, 4, 5, 6, 7 }\n+\t#define Ac16 (AC16){ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n+\t#ifdef TEST_V16QI\n+\ttypedef struct AC16 { char a[16]; } AC16;\n+\textern char a16[16];\n \tvoid\n-\tfoo ()\n+\tfoo1 ()\n \t{\n-\t    a[0] = 0;\n-\t    a[1] = 1;\n-\t    a[2] = 2;\n-\t    a[3] = 3;\n-\t    a[4] = 4;\n-\t    a[5] = 5;\n-\t    a[6] = 6;\n-\t    a[7] = 7;\n-\t}\n-\t#elif TEST_V16QI\n+\t    *(AC16*)a16 = Ac16;\n+\t}\n+\t#elif TEST_V8QI\n+\ttypedef struct AC8 { char a[8]; } AC8;\n+\textern char a8[8];\n \tvoid\n-\tfoo1 ()\n+\tfoo ()\n \t{\n-\t    a[0] = 0;\n-\t    a[1] = 1;\n-\t    a[2] = 2;\n-\t    a[3] = 3;\n-\t    a[4] = 4;\n-\t    a[5] = 5;\n-\t    a[6] = 6;\n-\t    a[7] = 7;\n-\t    a[8] = 8;\n-\t    a[9] = 9;\n-\t    a[10] = 10;\n-\t    a[11] = 11;\n-\t    a[12] = 12;\n-\t    a[13] = 13;\n-\t    a[14] = 14;\n-\t    a[15] = 15;\n+\t    *(AC8*)a8 = Ac8;\n \t}\n \t#elif TEST_V4QI\n+\tstruct A1\n+\t{\n+\t    char n;\n+\t    char a[3];\n+\t};\n+\n+\textern void sink (void*);\n \tvoid\n \tfoo2 ()\n \t{\n-\t    a[0] = 0;\n-\t    a[1] = 1;\n-\t    a[2] = 2;\n-\t    a[3] = 3;\n+\t    struct A1 a = { 0, {  } };\n+\t    a.a[0] = 3;\n+\t    a.a[1] = 4;\n+\t    a.a[2] = 5;\n+\t    sink (&a);\n+\t}\n+\t#elif TEST_V4QI_2\n+\textern char p[4];\n+\tvoid\n+\tfoo2_2 ()\n+\t{\n+\t    p[0] = 0;\n+\t    p[1] = 1;\n+\t    p[2] = 2;\n+\t    p[3] = 3;\n+\t}\n+\t#elif TEST_V4QI_3\n+\t#define Ac4 (AC4){ 0, 1, 2, 3 }\n+\ttypedef struct AC4 { char a[4]; } AC4;\n+\textern char a[4];\n+\tvoid\n+\tfoo ()\n+\t{\n+\t    *(AC4*)a = Ac4;\n \t}\n \t#elif TEST_V2QI\n+\tstruct A2\n+\t{\n+\t    char a[2];\n+\t};\n \tvoid\n \tfoo3 ()\n \t{\n-\t    a[0] = 0;\n-\t    a[1] = 1;\n+\t    struct A2 a;\n+\t    a.a[0] = 3;\n+\t    a.a[1] = 4;\n+\t    sink (&a);\n+\t}\n+\t#elif TEST_V4HI\n+\tstruct Ax\n+\t{\n+\t    int n;\n+\t    short a[4];\n+\t};\n+\tvoid\n+\tfoo5 (struct Ax *p)\n+\t{\n+\t    p->a[0] = 0;\n+\t    p->a[1] = 1;\n+\t    p->a[2] = 2;\n+\t    p->a[3] = 3;\n \t}\n \t#elif TEST_V2HI\n+\textern char b[4];\n \tvoid\n \tfoo4 ()\n \t{\n-\t    b[0] = 0;\n-\t    b[1] = 1;\n+\t    *(short*) b = 0;\n+\t    *(short*) (b + 2) = 1;\n \t}\n-\t#elif TEST_V4HI\n+\t#elif TEST_V2HI_2\n+\tstruct Ax\n+\t{\n+\t    int n;\n+\t    short a[2];\n+\t};\n \tvoid\n-\tfoo5 ()\n+\tfoo4_2 (struct Ax *p)\n \t{\n-\t    b[0] = 0;\n-\t    b[1] = 1;\n-\t    b[2] = 2;\n-\t    b[3] = 3;\n+\t    p->a[0] = 0;\n+\t    p->a[1] = 1;\n \t}\n-\t#elif TEST_V2SI\n+\t#elif TEST_V4SI\n+\tstruct A { int i; };\n+\tstruct B { int j; struct A a[4]; };\n+\n+\tstruct C\n+\t{\n+\t    struct B b1;\n+\t    struct B b2;\n+\t};\n+\tchar cbuf2[2 * sizeof (struct C)] = { };\n \tvoid\n \tfoo6 ()\n \t{\n-\t    c[0] = 0;\n-\t    c[1] = 1;\n+\t    struct C *p = (struct C*)&cbuf2;\n+\t    p->b2.a[0].i = 0;\n+\t    p->b2.a[1].i = 0;\n+\t    p->b2.a[2].i = 0;\n+\t    p->b2.a[3].i = 0;\n \t}\n-\t#elif TEST_V4SI\n+\t#elif TEST_V2SI\n+\tstruct A { int i; };\n+\tstruct B { int j; struct A a[2]; };\n+\n+\tstruct C\n+\t{\n+\t    struct B b1;\n+\t    struct B b2;\n+\t};\n+\tchar cbuf2[2 * sizeof (struct C)] = { };\n \tvoid\n-\tfoo7 ()\n+\tfoo6 ()\n \t{\n-\t    c[0] = 0;\n-\t    c[1] = 1;\n-\t    c[2] = 2;\n-\t    c[3] = 3;\n+\t    struct C *p = (struct C*)&cbuf2;\n+\t    p->b2.a[0].i = 0;\n+\t    p->b2.a[1].i = 0;\n \t}\n+\n \t#endif\n     } \"-O2 -fopt-info-all -D$macro\" ]\n \n@@ -7691,75 +7745,164 @@ proc check_vect_slp_aligned_store_usage { pattern macro } {\n \n # Return the true if target support vectorization of 2-byte char stores\n # with 2-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v2qi_store { } {\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v2qi_store_align { } {\n     set pattern {add new stmt: MEM <vector\\(2\\) char>}\n     set macro \"TEST_V2QI\"\n-    return [check_cached_effective_target vect_slp_v2qi_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro] }]\n+    return [check_cached_effective_target vect_slp_v2qi_store_align {\n+\texpr [check_vect_slp_store_usage $pattern $macro] }]\n \n }\n \n # Return the true if target support vectorization of 4-byte char stores\n # with 4-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v4qi_store { } {\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v4qi_store_align { } {\n     set pattern {add new stmt: MEM <vector\\(4\\) char>}\n     set macro \"TEST_V4QI\"\n-    return [check_cached_effective_target vect_slp_v4qi_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v4qi_store_align {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 4-byte char stores\n+# with unaligned address at plain O2.\n+proc check_effective_target_vect_slp_v4qi_store_unalign { } {\n+    set pattern {add new stmt: MEM <vector\\(4\\) char>}\n+    set macro \"TEST_V4QI_2\"\n+    return [check_cached_effective_target vect_slp_v4qi_store_unalign {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support block move for\n+# 8-byte aligned 4-byte size struct initialization.\n+proc check_effective_target_struct_4char_block_move { } {\n+    set pattern {not vectorized: more than one data ref in stmt:}\n+    set macro \"TEST_V4QI_3\"\n+    return [check_cached_effective_target struct_4char_block_move {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 4-byte char stores\n+# with unaligned address or store them with a constant pool at plain O2.\n+proc check_effective_target_vect_slp_v4qi_store_unalign_1 { } {\n+    set pattern {add new stmt: MEM <vector\\(4\\) char>}\n+    set macro \"TEST_V4QI_3\"\n+    return [check_cached_effective_target vect_slp_v4qi_store_unalign_1 {\n+\texpr { [check_vect_slp_store_usage $pattern $macro ]\n+\t       || [check_effective_target_struct_4char_block_move] } }]\n+}\n+\n+# Return the true if target support block move for\n+# 8-byte aligned 8-byte size struct initialization.\n+proc check_effective_target_struct_8char_block_move { } {\n+    set pattern {not vectorized: more than one data ref in stmt:}\n+    set macro \"TEST_V8QI\"\n+    return [check_cached_effective_target struct_8char_block_move {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n }\n \n # Return the true if target support vectorization of 8-byte char stores\n-# with 8-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v8qi_store { } {\n+# with unaligned address or store them with a constant pool at plain O2.\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v8qi_store_unalign_1 { } {\n     set pattern {add new stmt: MEM <vector\\(8\\) char>}\n     set macro \"TEST_V8QI\"\n-    return [check_cached_effective_target vect_slp_v8qi_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v8qi_store_unalign_1 {\n+\texpr { [check_vect_slp_store_usage $pattern $macro ]\n+\t       || [check_effective_target_struct_8char_block_move] } }]\n+}\n+\n+# Return the true if target support block move for\n+# 8-byte aligned 16-byte size struct initialization.\n+proc check_effective_target_struct_16char_block_move { } {\n+    set pattern {not vectorized: more than one data ref in stmt:}\n+    set macro \"TEST_V16QI\"\n+    return [check_cached_effective_target struct_16char_block_move {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n }\n \n # Return the true if target support vectorization of 16-byte char stores\n-# with 16-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v16qi_store { } {\n+# with unaligned address or store them with a constant pool at plain O2.\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v16qi_store_unalign_1 { } {\n     set pattern {add new stmt: MEM <vector\\(16\\) char>}\n     set macro \"TEST_V16QI\"\n-    return [check_cached_effective_target vect_slp_v16qi_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v16qi_store_unalign_1 {\n+\texpr { [check_vect_slp_store_usage $pattern $macro ]\n+\t       || [check_effective_target_struct_16char_block_move] } }]\n }\n \n # Return the true if target support vectorization of 4-byte short stores\n-# with 4-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v2hi_store { } {\n+# with unaligned address at plain O2.\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v2hi_store_unalign { } {\n     set pattern {add new stmt: MEM <vector\\(2\\) short int>}\n     set macro \"TEST_V2HI\"\n-    return [check_cached_effective_target vect_slp_v2hi_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v2hi_store_unalign {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 4-byte short stores\n+# with 4-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v2hi_store_align { } {\n+    set pattern {add new stmt: MEM <vector\\(2\\) short int>}\n+    set macro \"TEST_V2HI_2\"\n+    return [check_cached_effective_target vect_slp_v2hi_store_align {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n }\n \n # Return the true if target support vectorization of 8-byte short stores\n-# with 8-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v4hi_store { } {\n+# with unaligned address at plain O2.\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v4hi_store_unalign { } {\n     set pattern {add new stmt: MEM <vector\\(4\\) short int>}\n     set macro \"TEST_V4HI\"\n-    return [check_cached_effective_target vect_slp_v4hi_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v4hi_store_unalign {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n }\n \n # Return the true if target support vectorization of 8-byte int stores\n # with 8-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v2si_store { } {\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v2si_store_align { } {\n     set pattern {add new stmt: MEM <vector\\(2\\) int>}\n     set macro \"TEST_V2SI\"\n-    return [check_cached_effective_target vect_slp_v2si_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v2si_store_align {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n }\n \n # Return the true if target support vectorization of 16-byte int stores\n-# with 16-byte aligned address at plain O2.\n-proc check_effective_target_vect_slp_v4si_store { } {\n+# with unaligned address at plain O2.\n+# NB: This target should be removed after real issues are fixed for\n+# -Wstringop-overflow with O2 vect. Be careful if you want to reuse\n+# this target since tests in check_vect_slp_store_usage\n+# is the exact match of relative testcases\n+proc check_effective_target_vect_slp_v4si_store_unalign { } {\n     set pattern {add new stmt: MEM <vector\\(4\\) int>}\n     set macro \"TEST_V4SI\"\n-    return [check_cached_effective_target vect_slp_v4si_store {\n-\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+    return [check_cached_effective_target vect_slp_v4si_store_unalign {\n+\texpr [check_vect_slp_store_usage $pattern $macro ] }]\n }\n \n # Return 1 if we can align stack data to the preferred vector alignment."}]}