{"sha": "61eece67a6b6c97edec67b6ecb8c1144149ff228", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFlZWNlNjdhNmI2Yzk3ZWRlYzY3YjZlY2I4YzExNDQxNDlmZjIyOA==", "commit": {"author": {"name": "Dan Nicolaescu", "email": "dann@ics.uci.edu", "date": "2002-03-11T18:01:54Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-03-11T18:01:54Z"}, "message": "C++ alias analysis improvement.\n\n2002-03-06  Dan Nicolaescu  <dann@ics.uci.edu>\n            Daniel Berlin  <dan@dberlin.org>\n\n        C++ alias analysis improvement.\n\t* alias.c (record_component_aliases): Record aliases for base\n        classes too.\n\t* cp/cp-lang.c (ok_to_generate_alias_set_for_type): New function.\n\t(cxx_get_alias_set): Use it.\n\nCo-Authored-By: Daniel Berlin <dberlin@dberlin.org>\n\nFrom-SVN: r50587", "tree": {"sha": "0f32dcc7135957b2a24b097ca12ea0850be9f8be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f32dcc7135957b2a24b097ca12ea0850be9f8be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61eece67a6b6c97edec67b6ecb8c1144149ff228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61eece67a6b6c97edec67b6ecb8c1144149ff228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61eece67a6b6c97edec67b6ecb8c1144149ff228", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61eece67a6b6c97edec67b6ecb8c1144149ff228/comments", "author": null, "committer": null, "parents": [{"sha": "ff080abaf5df0d726139dcc5ac2d4233e14b4b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff080abaf5df0d726139dcc5ac2d4233e14b4b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff080abaf5df0d726139dcc5ac2d4233e14b4b76"}], "stats": {"total": 82, "additions": 79, "deletions": 3}, "files": [{"sha": "9a9478bfa329afe41ccd403c5ae35422b94807a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61eece67a6b6c97edec67b6ecb8c1144149ff228", "patch": "@@ -1,3 +1,10 @@\n+2002-03-11  Dan Nicolaescu  <dann@ics.uci.edu>\n+\t    Daniel Berlin  <dan@dberlin.org>\n+\n+\tC++ alias analysis improvement.\n+\t* alias.c (record_component_aliases): Record aliases for base \n+\tclasses too.\n+\n 2002-03-11  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.h (REG_ALLOC_ORDER): Add missing register."}, {"sha": "9b46fe1be5249e3bfbc8318181dbaa07550d6f7a", "filename": "gcc/alias.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=61eece67a6b6c97edec67b6ecb8c1144149ff228", "patch": "@@ -679,6 +679,17 @@ record_component_aliases (type)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n+      /* Recursively record aliases for the base classes, if there are any */\n+      if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n+        {\n+          int i;\n+          for (i = 0; i < TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)); i++)\n+            {\n+              tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n+              record_alias_subset (superset,\n+\t\t\t\t   get_alias_set (BINFO_TYPE (binfo)));\n+            }\n+        }\n       for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL && ! DECL_NONADDRESSABLE_P (field))\n \t  record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));"}, {"sha": "d2f15802dc7dd9433272e07e0b4105efc7975c89", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=61eece67a6b6c97edec67b6ecb8c1144149ff228", "patch": "@@ -1,3 +1,9 @@\n+2002-03-11  Dan Nicolaescu  <dann@ics.uci.edu>\n+\t    Daniel Berlin  <dan@dberlin.org>\n+\n+\t* cp-lang.c (ok_to_generate_alias_set_for_type): New function.\n+\t(cxx_get_alias_set): Use it.\n+\n 2002-03-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp-tree.h (stabilize_expr): Prototype."}, {"sha": "da0718e14a0fc6bb0cbcf1108b4154118116260f", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61eece67a6b6c97edec67b6ecb8c1144149ff228/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=61eece67a6b6c97edec67b6ecb8c1144149ff228", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks-def.h\"\n \n static HOST_WIDE_INT cxx_get_alias_set PARAMS ((tree));\n+static bool ok_to_generate_alias_set_for_type PARAMS ((tree));\n \n #undef LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME \"GNU C++\"\n@@ -99,15 +100,66 @@ static HOST_WIDE_INT cxx_get_alias_set PARAMS ((tree));\n /* Each front end provides its own hooks, for toplev.c.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n+/* Check if a C++ type is safe for aliasing.\n+   Return TRUE if T safe for aliasing FALSE otherwise.  */\n+\n+static bool\n+ok_to_generate_alias_set_for_type (t)\n+     tree t;\n+{\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    return true;\n+  if (AGGREGATE_TYPE_P (t))\n+    {\n+      if ((TREE_CODE (t) == RECORD_TYPE) || (TREE_CODE (t) == UNION_TYPE))\n+\t{\n+\t  tree fields;\n+\t  /* PODs are safe.  */\n+\t  if (! CLASSTYPE_NON_POD_P(t))\n+\t    return true;\n+\t  /* Classes with virtual baseclasses are not.  */\n+\t  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n+\t    return false;\n+\t  /* Recursively check the base classes.  */\n+\t  if (TYPE_BINFO (t) != NULL && TYPE_BINFO_BASETYPES (t) != NULL)\n+\t    {\n+\t      int i;\n+\t      for (i = 0; i < TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (t)); i++)\n+\t\t{\n+\t\t  tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n+\t\t  if (!ok_to_generate_alias_set_for_type (BINFO_TYPE (binfo)))\n+\t\t    return false;\n+\t\t}\n+\t    }\n+\t  /* Check all the fields.  */\n+\t  for (fields = TYPE_FIELDS (t); fields; fields = TREE_CHAIN (fields))\n+\t    {\n+\t      if (TREE_CODE (fields) != FIELD_DECL)\n+\t\tcontinue;\n+\t      if (! ok_to_generate_alias_set_for_type (TREE_TYPE (fields)))\n+\t\treturn false;\n+\t    }\n+\t  return true;\n+\t}\n+      else if (TREE_CODE (t) == ARRAY_TYPE)\n+\treturn ok_to_generate_alias_set_for_type (TREE_TYPE (t));\n+      else\n+\t/* This should never happen, we dealt with all the aggregate\n+\t   types that can appear in C++ above.  */\n+\tabort ();\n+    }\n+  else\n+    return true;\n+}\n+\n /* Special routine to get the alias set for C++.  */\n \n static HOST_WIDE_INT\n cxx_get_alias_set (t)\n      tree t;\n {\n-  /* It's not yet safe to use alias sets for classes in C++ because\n-     the TYPE_FIELDs list for a class doesn't mention base classes.  */\n-  if (AGGREGATE_TYPE_P (t))\n+  /* It's not yet safe to use alias sets for classes in C++.  */\n+  if (!ok_to_generate_alias_set_for_type(t))\n     return 0;\n \n   return c_common_get_alias_set (t);"}]}