{"sha": "731866ba53c49d2633c2d298a71462dbbd7f356b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMxODY2YmE1M2M0OWQyNjMzYzJkMjk4YTcxNDYyZGJiZDdmMzU2Yg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@redhat.com", "date": "2001-09-07T18:30:29Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-09-07T18:30:29Z"}, "message": "re PR java/4230 (gcj -C segfaults on static string continuation '+' in gcj 3.1 expermental.)\n\n2001-09-05 Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* jcf-write.c (generate_classfile): Issue an error in case of\n\tfield/initial value mismatch.\n\t* parse.y (analyze_clinit_body): Keep <clinit> if an array is\n\tbeing initialized and we're generating bytecode.\n\t(java_complete_lhs): In MODIFY_EXPR section: added comments,\n\tset DECL_INITIAL properly when appropriate.\n\tFixes PR java/4230\n\tFixes PR java/4204\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-09/msg00247.html )\n\nFrom-SVN: r45474", "tree": {"sha": "8098278e0ae77ece871e4167b796a3e9826f8024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8098278e0ae77ece871e4167b796a3e9826f8024"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/731866ba53c49d2633c2d298a71462dbbd7f356b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731866ba53c49d2633c2d298a71462dbbd7f356b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/731866ba53c49d2633c2d298a71462dbbd7f356b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731866ba53c49d2633c2d298a71462dbbd7f356b/comments", "author": null, "committer": null, "parents": [{"sha": "9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b"}], "stats": {"total": 50, "additions": 46, "deletions": 4}, "files": [{"sha": "a33de53023ae93da8962f6fadf863cf101d16ea8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731866ba53c49d2633c2d298a71462dbbd7f356b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731866ba53c49d2633c2d298a71462dbbd7f356b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=731866ba53c49d2633c2d298a71462dbbd7f356b", "patch": "@@ -17,6 +17,17 @@\n \tresource files.\n \t* gcj.texi (Code Generation): Add documentation for -R flag.\n \n+2001-09-05 Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* jcf-write.c (generate_classfile): Issue an error in case of\n+\tfield/initial value mismatch.\n+\t* parse.y (analyze_clinit_body): Keep <clinit> if an array is\n+\tbeing initialized and we're generating bytecode.\n+\t(java_complete_lhs): In MODIFY_EXPR section: added comments,\n+\tset DECL_INITIAL properly when appropriate.\n+\tFixes PR java/4230\n+\tFixes PR java/4204\n+\n 2001-09-01  Per Bothner  <per@bothner.com>\n \n \t* parse.y (maybe_yank_clinit):  A field without an initializer is not"}, {"sha": "44c676f54d96a4380a6156baebd38eebc52e2b8b", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731866ba53c49d2633c2d298a71462dbbd7f356b/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731866ba53c49d2633c2d298a71462dbbd7f356b/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=731866ba53c49d2633c2d298a71462dbbd7f356b", "patch": "@@ -2899,8 +2899,8 @@ generate_classfile (clas, state)\n \t{\n \t  tree init = DECL_INITIAL (part);\n \t  static tree ConstantValue_node = NULL_TREE;\n-\t  // This conversion is a work-around for front-end bug.\n-\t  init = convert (TREE_TYPE (part), init);\n+\t  if (TREE_TYPE (part) != TREE_TYPE (init))\n+\t    fatal_error (\"field initializer type mismatch.\");\n \t  ptr = append_chunk (NULL, 8, state);\n \t  if (ConstantValue_node == NULL_TREE)\n \t    ConstantValue_node = get_identifier (\"ConstantValue\");"}, {"sha": "0c544fb0b203a224a19a0bf55559ef6c86521847", "filename": "gcc/java/parse.y", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731866ba53c49d2633c2d298a71462dbbd7f356b/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731866ba53c49d2633c2d298a71462dbbd7f356b/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=731866ba53c49d2633c2d298a71462dbbd7f356b", "patch": "@@ -7813,6 +7813,11 @@ analyze_clinit_body (bbody)\n \tbreak;\n \t\n       case MODIFY_EXPR:\n+\t/* If we're generating to class file and we're dealing with an\n+\t   array initialization, we return 1 to keep <clinit> */\n+\tif (TREE_CODE (TREE_OPERAND (bbody, 1)) == NEW_ARRAY_INIT\n+\t    && flag_emit_class_files)\n+\t  return 1;\n \t/* Return 0 if the operand is constant, 1 otherwise.  */\n \treturn ! TREE_CONSTANT (TREE_OPERAND (bbody, 1));\n \n@@ -11898,16 +11903,31 @@ java_complete_lhs (node)\n \t  \n \t  value = fold_constant_for_init (nn, nn);\n \n+\t  /* When we have a primitype type, or a string and we're not\n+             emitting a class file, we actually don't want to generate\n+             anything for the assignment. */\n \t  if (value != NULL_TREE &&\n \t      (JPRIMITIVE_TYPE_P (TREE_TYPE (value)) || \n \t       (TREE_TYPE (value) == string_ptr_type_node &&\n \t\t! flag_emit_class_files)))\n \t    {\n+\t      /* Prepare node for patch_assignment */\n \t      TREE_OPERAND (node, 1) = value;\n+\t      /* Call patch assignment to verify the assignment */\n \t      if (patch_assignment (node, wfl_op1, value) == error_mark_node)\n \t\treturn error_mark_node;\n+\t      /* Set DECL_INITIAL properly (a conversion might have\n+                 been decided by patch_assignment) and return the\n+                 empty statement. */\n \t      else\n-\t\treturn empty_stmt_node;\n+\t\t{\n+\t\t  tree patched = patch_string (TREE_OPERAND (node, 1));\n+\t\t  if (patched)\n+\t\t    DECL_INITIAL (nn) = patched;\n+\t\t  else\n+\t\t    DECL_INITIAL (nn) = TREE_OPERAND (node, 1);\n+\t\t  return empty_stmt_node;\n+\t\t}\n \t    }\n \t  if (! flag_emit_class_files)\n \t    DECL_INITIAL (nn) = NULL_TREE;\n@@ -11999,7 +12019,18 @@ java_complete_lhs (node)\n \t\t       || JSTRING_P (TREE_TYPE (node))))\n \t    node = java_refold (node);\n \t}\n-      \n+\n+      /* Seek to set DECL_INITIAL to a proper value, since it might have\n+\t undergone a conversion in patch_assignment. We do that only when\n+\t it's necessary to have DECL_INITIAL properly set. */\n+      nn = TREE_OPERAND (node, 0);\n+      if (TREE_CODE (nn) == VAR_DECL \n+\t  && DECL_INITIAL (nn) && CONSTANT_VALUE_P (DECL_INITIAL (nn))\n+\t  && FIELD_STATIC (nn) && FIELD_FINAL (nn) \n+\t  && (JPRIMITIVE_TYPE_P (TREE_TYPE (nn))\n+\t      || TREE_TYPE (nn) == string_ptr_type_node))\n+\tDECL_INITIAL (nn) = TREE_OPERAND (node, 1);\n+\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       return node;\n "}]}