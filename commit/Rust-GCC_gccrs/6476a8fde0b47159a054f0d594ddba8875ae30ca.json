{"sha": "6476a8fde0b47159a054f0d594ddba8875ae30ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ3NmE4ZmRlMGI0NzE1OWEwNTRmMGQ1OTRkZGJhODg3NWFlMzBjYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-05-11T23:33:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-05-11T23:33:12Z"}, "message": "Merge expand_asm_operands into expand_asm_stmt\n\nPrepatory to converting from tree chains to vectors.\n\nFrom-SVN: r223023", "tree": {"sha": "66bde823d051c8d67a21d2f66fa55f57f5909ced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66bde823d051c8d67a21d2f66fa55f57f5909ced"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6476a8fde0b47159a054f0d594ddba8875ae30ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6476a8fde0b47159a054f0d594ddba8875ae30ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6476a8fde0b47159a054f0d594ddba8875ae30ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6476a8fde0b47159a054f0d594ddba8875ae30ca/comments", "author": null, "committer": null, "parents": [{"sha": "5570ddd5a8ce2125c8290598037a40481f193197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5570ddd5a8ce2125c8290598037a40481f193197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5570ddd5a8ce2125c8290598037a40481f193197"}], "stats": {"total": 170, "additions": 75, "deletions": 95}, "files": [{"sha": "f544900002549a7928f631863f0a23c3100f2843", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6476a8fde0b47159a054f0d594ddba8875ae30ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6476a8fde0b47159a054f0d594ddba8875ae30ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6476a8fde0b47159a054f0d594ddba8875ae30ca", "patch": "@@ -1,5 +1,8 @@\n 2015-05-11  Richard Henderson  <rth@redhat.com>\n \n+\t* cfgexpand.c (expand_asm_operands): Merge into...\n+\t(expand_asm_stmt): ... here.\n+\n \t* cfgexpand.c (expand_asm_operands): Don't call\n \tresolve_asm_operand_names.\n \t* stmt.c (resolve_asm_operand_names): Clarify block comment."}, {"sha": "5d44c48b6c4daca55f74212e5c284d3951469a92", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 72, "deletions": 95, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6476a8fde0b47159a054f0d594ddba8875ae30ca/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6476a8fde0b47159a054f0d594ddba8875ae30ca/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6476a8fde0b47159a054f0d594ddba8875ae30ca", "patch": "@@ -2522,22 +2522,78 @@ tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n    VOL nonzero means the insn is volatile; don't optimize it.  */\n \n static void\n-expand_asm_operands (tree string, tree outputs, tree inputs,\n-\t\t     tree clobbers, tree labels, basic_block fallthru_bb,\n-\t\t     int vol, location_t locus)\n+expand_asm_stmt (gasm *stmt)\n {\n+  int noutputs, ninputs, nclobbers, nlabels, i;\n+  tree string, outputs, inputs, clobbers, labels, tail, t;\n+  location_t locus = gimple_location (stmt);\n+  basic_block fallthru_bb = NULL;\n+\n+  /* Meh... convert the gimple asm operands into real tree lists.\n+     Eventually we should make all routines work on the vectors instead\n+     of relying on TREE_CHAIN.  */\n+  outputs = NULL_TREE;\n+  noutputs = gimple_asm_noutputs (stmt);\n+  if (noutputs > 0)\n+    {\n+      t = outputs = gimple_asm_output_op (stmt, 0);\n+      for (i = 1; i < noutputs; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n+    }\n+\n+  inputs = NULL_TREE;\n+  ninputs = gimple_asm_ninputs (stmt);\n+  if (ninputs > 0)\n+    {\n+      t = inputs = gimple_asm_input_op (stmt, 0);\n+      for (i = 1; i < ninputs; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n+    }\n+\n+  clobbers = NULL_TREE;\n+  nclobbers = gimple_asm_nclobbers (stmt);\n+  if (nclobbers > 0)\n+    {\n+      t = clobbers = gimple_asm_clobber_op (stmt, 0);\n+      for (i = 1; i < nclobbers; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n+    }\n+\n+  labels = NULL_TREE;\n+  nlabels = gimple_asm_nlabels (stmt);\n+  if (nlabels > 0)\n+    {\n+      edge fallthru = find_fallthru_edge (gimple_bb (stmt)->succs);\n+      if (fallthru)\n+\tfallthru_bb = fallthru->dest;\n+      t = labels = gimple_asm_label_op (stmt, 0);\n+      for (i = 1; i < nlabels; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_label_op (stmt, i);\n+    }\n+\n+  {\n+    const char *s = gimple_asm_string (stmt);\n+    string = build_string (strlen (s), s);\n+  }\n+\n+  if (gimple_asm_input_p (stmt))\n+    {\n+      expand_asm_loc (string, gimple_asm_volatile_p (stmt), locus);\n+      return;\n+    }\n+\n+  /* Record the contents of OUTPUTS before it is modified.  */\n+  tree *orig_outputs = XALLOCAVEC (tree, noutputs);\n+  for (i = 0; i < noutputs; ++i)\n+    orig_outputs[i] = TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\n+  bool vol = gimple_asm_volatile_p (stmt);\n+\n   rtvec argvec, constraintvec, labelvec;\n   rtx body;\n-  int ninputs = list_length (inputs);\n-  int noutputs = list_length (outputs);\n-  int nlabels = list_length (labels);\n   int ninout;\n-  int nclobbers;\n   HARD_REG_SET clobbered_regs;\n   int clobber_conflict_found = 0;\n-  tree tail;\n-  tree t;\n-  int i;\n   /* Vector of RTX's of evaluated output operands.  */\n   rtx *output_rtx = XALLOCAVEC (rtx, noutputs);\n   int *inout_opnum = XALLOCAVEC (int, noutputs);\n@@ -2994,101 +3050,22 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n     if (real_output_rtx[i])\n       emit_move_insn (real_output_rtx[i], output_rtx[i]);\n \n-  crtl->has_asm_statement = 1;\n-  free_temp_slots ();\n-}\n-\n-\n-static void\n-expand_asm_stmt (gasm *stmt)\n-{\n-  int noutputs;\n-  tree outputs, tail, t;\n-  tree *o;\n-  size_t i, n;\n-  const char *s;\n-  tree str, out, in, cl, labels;\n-  location_t locus = gimple_location (stmt);\n-  basic_block fallthru_bb = NULL;\n-\n-  /* Meh... convert the gimple asm operands into real tree lists.\n-     Eventually we should make all routines work on the vectors instead\n-     of relying on TREE_CHAIN.  */\n-  out = NULL_TREE;\n-  n = gimple_asm_noutputs (stmt);\n-  if (n > 0)\n-    {\n-      t = out = gimple_asm_output_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n-    }\n-\n-  in = NULL_TREE;\n-  n = gimple_asm_ninputs (stmt);\n-  if (n > 0)\n-    {\n-      t = in = gimple_asm_input_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n-    }\n-\n-  cl = NULL_TREE;\n-  n = gimple_asm_nclobbers (stmt);\n-  if (n > 0)\n-    {\n-      t = cl = gimple_asm_clobber_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n-    }\n-\n-  labels = NULL_TREE;\n-  n = gimple_asm_nlabels (stmt);\n-  if (n > 0)\n-    {\n-      edge fallthru = find_fallthru_edge (gimple_bb (stmt)->succs);\n-      if (fallthru)\n-\tfallthru_bb = fallthru->dest;\n-      t = labels = gimple_asm_label_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_label_op (stmt, i);\n-    }\n-\n-  s = gimple_asm_string (stmt);\n-  str = build_string (strlen (s), s);\n-\n-  if (gimple_asm_input_p (stmt))\n-    {\n-      expand_asm_loc (str, gimple_asm_volatile_p (stmt), locus);\n-      return;\n-    }\n-\n-  outputs = out;\n-  noutputs = gimple_asm_noutputs (stmt);\n-  /* o[I] is the place that output number I should be written.  */\n-  o = (tree *) alloca (noutputs * sizeof (tree));\n-\n-  /* Record the contents of OUTPUTS before it is modified.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    o[i] = TREE_VALUE (tail);\n-\n-  /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n-     OUTPUTS some trees for where the values were actually stored.  */\n-  expand_asm_operands (str, outputs, in, cl, labels, fallthru_bb,\n-\t\t       gimple_asm_volatile_p (stmt), locus);\n-\n   /* Copy all the intermediate outputs into the specified outputs.  */\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n     {\n-      if (o[i] != TREE_VALUE (tail))\n+      if (orig_outputs[i] != TREE_VALUE (tail))\n \t{\n-\t  expand_assignment (o[i], TREE_VALUE (tail), false);\n+\t  expand_assignment (orig_outputs[i], TREE_VALUE (tail), false);\n \t  free_temp_slots ();\n \n \t  /* Restore the original value so that it's correct the next\n \t     time we expand this function.  */\n-\t  TREE_VALUE (tail) = o[i];\n+\t  TREE_VALUE (tail) = orig_outputs[i];\n \t}\n     }\n+\n+  crtl->has_asm_statement = 1;\n+  free_temp_slots ();\n }\n \n /* Emit code to jump to the address"}]}