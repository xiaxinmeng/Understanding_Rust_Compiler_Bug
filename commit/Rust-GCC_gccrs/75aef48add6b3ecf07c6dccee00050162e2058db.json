{"sha": "75aef48add6b3ecf07c6dccee00050162e2058db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVhZWY0OGFkZDZiM2VjZjA3YzZkY2NlZTAwMDUwMTYyZTIwNThkYg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-07-19T19:24:43Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-07-19T19:24:43Z"}, "message": "cppexp.c (ALWAYS_EVAL): Remove.\n\n\t* cppexp.c (ALWAYS_EVAL): Remove.\n\t(optab, reduce): Always evaluate.\n\t(num_unary_op, num_binary_op, num_div_op): Issue diagnostics\n\tonly if not skipping evaluation.\ntestsuite:\n\t* gcc.dg/cpp/expr.c: New tests.\n\nFrom-SVN: r55595", "tree": {"sha": "62b42c3aa3319f8724a11cbe166c57a37698d77b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b42c3aa3319f8724a11cbe166c57a37698d77b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75aef48add6b3ecf07c6dccee00050162e2058db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75aef48add6b3ecf07c6dccee00050162e2058db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75aef48add6b3ecf07c6dccee00050162e2058db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75aef48add6b3ecf07c6dccee00050162e2058db/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72a5503d6216f912f7050bb99ce3cc5adbf57ec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a5503d6216f912f7050bb99ce3cc5adbf57ec1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a5503d6216f912f7050bb99ce3cc5adbf57ec1"}], "stats": {"total": 241, "additions": 133, "deletions": 108}, "files": [{"sha": "a0dea73ba5bdc07bd977c7e5fed2d50c9ceb6dbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75aef48add6b3ecf07c6dccee00050162e2058db", "patch": "@@ -1,3 +1,10 @@\n+2002-07-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cppexp.c (ALWAYS_EVAL): Remove.\n+\t(optab, reduce): Always evaluate.\n+\t(num_unary_op, num_binary_op, num_div_op): Issue diagnostics\n+\tonly if not skipping evaluation.\n+\n 2002-07-19  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n \n \t* config/avr/avr.c (debug_hard_reg_set): Remove."}, {"sha": "58538444d0817a888f0e7f76b81494ab21337631", "filename": "gcc/cppexp.c", "status": "modified", "additions": 105, "deletions": 108, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=75aef48add6b3ecf07c6dccee00050162e2058db", "patch": "@@ -630,12 +630,9 @@ The parser assumes all shifted operators require a left operand unless\n the flag NO_L_OPERAND is set.  These semantics are automatic; any\n extra semantics need to be handled with operator-specific code.  */\n \n-/* Flags.  ALWAYS_EVAL is for operators that should be evaluated even\n-   if skip_eval is true; perhaps they are invalid and require a\n-   diagnostic, or they might modify skip_eval.  */\n+/* Flags.  */\n #define NO_L_OPERAND\t(1 << 0)\n #define LEFT_ASSOC\t(1 << 1)\n-#define ALWAYS_EVAL\t(1 << 2)\n \n /* Operator to priority map.  Must be in the same order as the first\n    N entries of enum cpp_ttype.  */\n@@ -664,12 +661,12 @@ static const struct operator\n   /* MAX */\t\t{10, LEFT_ASSOC},\n \n   /* COMPL */\t\t{16, NO_L_OPERAND},\n-  /* AND_AND */\t\t{6, LEFT_ASSOC | ALWAYS_EVAL},\n-  /* OR_OR */\t\t{5, LEFT_ASSOC | ALWAYS_EVAL},\n-  /* QUERY */\t\t{3, ALWAYS_EVAL},\n-  /* COLON */\t\t{4, LEFT_ASSOC | ALWAYS_EVAL},\n+  /* AND_AND */\t\t{6, LEFT_ASSOC},\n+  /* OR_OR */\t\t{5, LEFT_ASSOC},\n+  /* QUERY */\t\t{3, 0},\n+  /* COLON */\t\t{4, LEFT_ASSOC},\n   /* COMMA */\t\t{2, LEFT_ASSOC},\n-  /* OPEN_PAREN */\t{1, NO_L_OPERAND | ALWAYS_EVAL},\n+  /* OPEN_PAREN */\t{1, NO_L_OPERAND},\n   /* CLOSE_PAREN */\t{0, 0},\n   /* EOF */\t\t{0, 0},\n   /* EQ_EQ */\t\t{11, LEFT_ASSOC},\n@@ -863,110 +860,109 @@ reduce (pfile, top, op)\n   prio = optab[op].prio - ((optab[op].flags & LEFT_ASSOC) != 0);\n   while (prio < optab[top->op].prio)\n     {\n-      if (!pfile->state.skip_eval || optab[top->op].flags & ALWAYS_EVAL)\n-\tswitch (top->op)\n-\t  {\n-\t  case CPP_UPLUS:\n-\t  case CPP_UMINUS:\n-\t  case CPP_NOT:\n-\t  case CPP_COMPL:\n-\t    top[-1].value = num_unary_op (pfile, top->value, top->op);\n-\t    break;\n+      switch (top->op)\n+\t{\n+\tcase CPP_UPLUS:\n+\tcase CPP_UMINUS:\n+\tcase CPP_NOT:\n+\tcase CPP_COMPL:\n+\t  top[-1].value = num_unary_op (pfile, top->value, top->op);\n+\t  break;\n \n-\t  case CPP_PLUS:\n-\t  case CPP_MINUS:\n-\t  case CPP_RSHIFT:\n-\t  case CPP_LSHIFT:\n-\t  case CPP_MIN:\n-\t  case CPP_MAX:\n-\t  case CPP_COMMA:\n-\t    top[-1].value = num_binary_op (pfile, top[-1].value,\n-\t\t\t\t\t   top->value, top->op);\n-\t    break;\n+\tcase CPP_PLUS:\n+\tcase CPP_MINUS:\n+\tcase CPP_RSHIFT:\n+\tcase CPP_LSHIFT:\n+\tcase CPP_MIN:\n+\tcase CPP_MAX:\n+\tcase CPP_COMMA:\n+\t  top[-1].value = num_binary_op (pfile, top[-1].value,\n+\t\t\t\t\t top->value, top->op);\n+\t  break;\n \n-\t  case CPP_GREATER:\n-\t  case CPP_LESS:\n-\t  case CPP_GREATER_EQ:\n-\t  case CPP_LESS_EQ:\n-\t    top[-1].value\n-\t      = num_inequality_op (pfile, top[-1].value, top->value, top->op);\n-\t    break;\n+\tcase CPP_GREATER:\n+\tcase CPP_LESS:\n+\tcase CPP_GREATER_EQ:\n+\tcase CPP_LESS_EQ:\n+\t  top[-1].value\n+\t    = num_inequality_op (pfile, top[-1].value, top->value, top->op);\n+\t  break;\n \n-\t  case CPP_EQ_EQ:\n-\t  case CPP_NOT_EQ:\n-\t    top[-1].value\n-\t      = num_equality_op (pfile, top[-1].value, top->value, top->op);\n-\t    break;\n+\tcase CPP_EQ_EQ:\n+\tcase CPP_NOT_EQ:\n+\t  top[-1].value\n+\t    = num_equality_op (pfile, top[-1].value, top->value, top->op);\n+\t  break;\n \n-\t  case CPP_AND:\n-\t  case CPP_OR:\n-\t  case CPP_XOR:\n-\t    top[-1].value\n-\t      = num_bitwise_op (pfile, top[-1].value, top->value, top->op);\n-\t    break;\n+\tcase CPP_AND:\n+\tcase CPP_OR:\n+\tcase CPP_XOR:\n+\t  top[-1].value\n+\t    = num_bitwise_op (pfile, top[-1].value, top->value, top->op);\n+\t  break;\n \n-\t  case CPP_MULT:\n-\t    top[-1].value = num_mul (pfile, top[-1].value, top->value);\n-\t    break;\n+\tcase CPP_MULT:\n+\t  top[-1].value = num_mul (pfile, top[-1].value, top->value);\n+\t  break;\n \n-\t  case CPP_DIV:\n-\t  case CPP_MOD:\n-\t    top[-1].value = num_div_op (pfile, top[-1].value,\n-\t\t\t\t\ttop->value, top->op);\n-\t    break;\n+\tcase CPP_DIV:\n+\tcase CPP_MOD:\n+\t  top[-1].value = num_div_op (pfile, top[-1].value,\n+\t\t\t\t      top->value, top->op);\n+\t  break;\n \n-\t  case CPP_OR_OR:\n-\t    top--;\n-\t    if (!num_zerop (top->value))\n-\t      pfile->state.skip_eval--;\n-\t    top->value.low = (!num_zerop (top->value)\n-\t\t\t      || !num_zerop (top[1].value));\n-\t    top->value.high = 0;\n-\t    top->value.unsignedp = false;\n-\t    top->value.overflow = false;\n-\t    continue;\n-\n-\t  case CPP_AND_AND:\n-\t    top--;\n-\t    if (num_zerop (top->value))\n+\tcase CPP_OR_OR:\n+\t  top--;\n+\t  if (!num_zerop (top->value))\n+\t    pfile->state.skip_eval--;\n+\t  top->value.low = (!num_zerop (top->value)\n+\t\t\t    || !num_zerop (top[1].value));\n+\t  top->value.high = 0;\n+\t  top->value.unsignedp = false;\n+\t  top->value.overflow = false;\n+\t  continue;\n+\n+\tcase CPP_AND_AND:\n+\t  top--;\n+\t  if (num_zerop (top->value))\n+\t    pfile->state.skip_eval--;\n+\t  top->value.low = (!num_zerop (top->value)\n+\t\t\t    && !num_zerop (top[1].value));\n+\t  top->value.high = 0;\n+\t  top->value.unsignedp = false;\n+\t  top->value.overflow = false;\n+\t  continue;\n+\n+\tcase CPP_OPEN_PAREN:\n+\t  if (op != CPP_CLOSE_PAREN)\n+\t    {\n+\t      cpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n+\t      return 0;\n+\t    }\n+\t  top--;\n+\t  top->value = top[1].value;\n+\t  return top;\n+\n+\tcase CPP_COLON:\n+\t  top -= 2;\n+\t  if (!num_zerop (top->value))\n+\t    {\n \t      pfile->state.skip_eval--;\n-\t    top->value.low = (!num_zerop (top->value)\n-\t\t\t      && !num_zerop (top[1].value));\n-\t    top->value.high = 0;\n-\t    top->value.unsignedp = false;\n-\t    top->value.overflow = false;\n-\t    continue;\n-\n-\t  case CPP_OPEN_PAREN:\n-\t    if (op != CPP_CLOSE_PAREN)\n-\t      {\n-\t\tcpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n-\t\treturn 0;\n-\t      }\n-\t    top--;\n-\t    top->value = top[1].value;\n-\t    return top;\n-\n-\t  case CPP_COLON:\n-\t    top -= 2;\n-\t    if (!num_zerop (top->value))\n-\t      {\n-\t\tpfile->state.skip_eval--;\n-\t\ttop->value = top[1].value;\n-\t      }\n-\t    else\n-\t      top->value = top[2].value;\n-\t    top->value.unsignedp = (top[1].value.unsignedp\n-\t\t\t\t    || top[2].value.unsignedp);\n-\t    continue;\n-\n-\t  case CPP_QUERY:\n-\t    cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n-\t    return 0;\n-\n-\t  default:\n-\t    goto bad_op;\n-\t  }\n+\t      top->value = top[1].value;\n+\t    }\n+\t  else\n+\t    top->value = top[2].value;\n+\t  top->value.unsignedp = (top[1].value.unsignedp\n+\t\t\t\t  || top[2].value.unsignedp);\n+\t  continue;\n+\n+\tcase CPP_QUERY:\n+\t  cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n+\t  return 0;\n+\n+\tdefault:\n+\t  goto bad_op;\n+\t}\n \n       top--;\n       if (top->value.overflow && !pfile->state.skip_eval)\n@@ -1273,7 +1269,7 @@ num_unary_op (pfile, num, op)\n   switch (op)\n     {\n     case CPP_UPLUS:\n-      if (CPP_WTRADITIONAL (pfile))\n+      if (CPP_WTRADITIONAL (pfile) && !pfile->state.skip_eval)\n \tcpp_error (pfile, DL_WARNING,\n \t\t   \"traditional C rejects the unary plus operator\");\n       num.overflow = false;\n@@ -1375,7 +1371,7 @@ num_binary_op (pfile, lhs, rhs, op)\n \n       /* Comma.  */\n     default: /* case CPP_COMMA: */\n-      if (CPP_PEDANTIC (pfile))\n+      if (CPP_PEDANTIC (pfile) && !pfile->state.skip_eval)\n \tcpp_error (pfile, DL_PEDWARN,\n \t\t   \"comma operator in operand of #if\");\n       lhs = rhs;\n@@ -1512,7 +1508,8 @@ num_div_op (pfile, lhs, rhs, op)\n     }\n   else\n     {\n-      cpp_error (pfile, DL_ERROR, \"division by zero in #if\");\n+      if (!pfile->state.skip_eval)\n+\tcpp_error (pfile, DL_ERROR, \"division by zero in #if\");\n       return lhs;\n     }\n "}, {"sha": "2375247f53a7019f350ce204806ab28350c95aca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75aef48add6b3ecf07c6dccee00050162e2058db", "patch": "@@ -1,3 +1,7 @@\n+2002-07-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* gcc.dg/cpp/expr.c: New tests.\n+\n 2002 07-18  David Edelsohn  <edelsohn@gnu.org>\n \n \t* g++.dg/opt/pr6713.C: Add template instantiation."}, {"sha": "532bd6812378b9c29874baacdc3c9e61aadcded1", "filename": "gcc/testsuite/gcc.dg/cpp/expr.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75aef48add6b3ecf07c6dccee00050162e2058db/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fexpr.c?ref=75aef48add6b3ecf07c6dccee00050162e2058db", "patch": "@@ -0,0 +1,17 @@\n+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Test we get signedness of ?: operator correct.  We would skip\n+   evaluation of one argument, and might therefore not transfer its\n+   unsignedness to the result.  */\n+\n+/* Neil Booth, 19 Jul 2002.  */\n+\n+#if (1 ? -2: 0 + 1U) < 0\n+#error\t\t\t\t/* { dg-bogus \"error\" } */\n+#endif\n+\n+#if (0 ? 0 + 1U: -2) < 0\n+#error\t\t\t\t/* { dg-bogus \"error\" } */\n+#endif"}]}