{"sha": "2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1OGZmOTExNmQ4MTY3ZTRiMGQyZjcwYTlkNjFlNGU4Y2E1MTY4ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-10-20T12:14:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-10-20T12:14:30Z"}, "message": "re PR rtl-optimization/23585 (mem_fun* code fine with -O1, bus error with -O2)\n\n\tPR rtl-optimization/23585\n\t* rtlanal.c (rtx_addr_can_trap_p_1): New predicate extracted from...\n\t(rtx_addr_can_trap_p): ... here.  Invoke rtx_addr_can_trap_p_1.\n\t(may_trap_p_1): New predicate extracted from...\n\t(may_trap_p): ... here.  Invoke may_trap_p_1.\n\t(may_trap_or_fault_p): New predicate.\n\t* rtl.h (may_trap_or_fault_p): Declare it.\n\t* reorg.c (steal_delay_list_from_target): Use may_trap_or_fault_p\n\tinstead of may_trap_p.\n\t(steal_delay_list_from_fallthrough): Likewise.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t* function.c (pad_to_arg_alignment): Rework comment about\n\tSPARC_STACK_BOUNDARY_HACK.\n\t* config/sparc/sparc.h: Likewise.\n\nFrom-SVN: r105671", "tree": {"sha": "53ad2a0ca4edd7bccde7701601db72e04f5fd33c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53ad2a0ca4edd7bccde7701601db72e04f5fd33c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b88a7564ad502161fc35d980c75a19c29c5835c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88a7564ad502161fc35d980c75a19c29c5835c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b88a7564ad502161fc35d980c75a19c29c5835c1"}], "stats": {"total": 291, "additions": 258, "deletions": 33}, "files": [{"sha": "e5de23f842136c248035759a8aa82597158f8ba5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -1,3 +1,21 @@\n+2005-10-20  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/23585\n+\t* rtlanal.c (rtx_addr_can_trap_p_1): New predicate extracted from...\n+\t(rtx_addr_can_trap_p): ... here.  Invoke rtx_addr_can_trap_p_1.\n+\t(may_trap_p_1): New predicate extracted from...\n+\t(may_trap_p): ... here.  Invoke may_trap_p_1.\n+\t(may_trap_or_fault_p): New predicate.\n+\t* rtl.h (may_trap_or_fault_p): Declare it.\n+\t* reorg.c (steal_delay_list_from_target): Use may_trap_or_fault_p\n+\tinstead of may_trap_p.\n+\t(steal_delay_list_from_fallthrough): Likewise.\n+\t(fill_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t* function.c (pad_to_arg_alignment): Rework comment about\n+\tSPARC_STACK_BOUNDARY_HACK.\n+\t* config/sparc/sparc.h: Likewise.\n+\n 2005-10-19  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_insv): New."}, {"sha": "a72cc90910b6875075a35bacfb1d1bafe8626ddf", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -624,11 +624,9 @@ if (TARGET_ARCH64\t\t\t\t\\\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n /* FIXME, this is wrong when TARGET_ARCH64 and TARGET_STACK_BIAS, because\n-   then sp+2047 is 128-bit aligned so sp is really only byte-aligned.  */\n+   then %sp+2047 is 128-bit aligned so %sp is really only byte-aligned.  */\n #define STACK_BOUNDARY (TARGET_ARCH64 ? 128 : 64)\n-/* Temporary hack until the FIXME above is fixed.  This macro is used\n-   only in pad_to_arg_alignment in function.c; see the comment there\n-   for details about what it does.  */\n+/* Temporary hack until the FIXME above is fixed.  */\n #define SPARC_STACK_BOUNDARY_HACK (TARGET_ARCH64 && TARGET_STACK_BIAS)\n \n /* ALIGN FRAMES on double word boundaries */"}, {"sha": "941021edc6678ac7783f9305d9da15d191763453", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -3370,10 +3370,9 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n   HOST_WIDE_INT sp_offset = STACK_POINTER_OFFSET;\n \n #ifdef SPARC_STACK_BOUNDARY_HACK\n-  /* The sparc port has a bug.  It sometimes claims a STACK_BOUNDARY\n-     higher than the real alignment of %sp.  However, when it does this,\n-     the alignment of %sp+STACK_POINTER_OFFSET will be STACK_BOUNDARY.\n-     This is a temporary hack while the sparc port is fixed.  */\n+  /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n+     the real alignment of %sp.  However, when it does this, the\n+     alignment of %sp+STACK_POINTER_OFFSET is STACK_BOUNDARY.  */\n   if (SPARC_STACK_BOUNDARY_HACK)\n     sp_offset = 0;\n #endif"}, {"sha": "46154f1fd3a780023b26e317bd82e4e142cf1bd4", "filename": "gcc/reorg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -1337,7 +1337,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n       if (! must_annul\n \t  && ((condition == const_true_rtx\n \t       || (! insn_sets_resource_p (trial, other_needed, 0)\n-\t\t   && ! may_trap_p (PATTERN (trial)))))\n+\t\t   && ! may_trap_or_fault_p (PATTERN (trial)))))\n \t  ? eligible_for_delay (insn, total_slots_filled, trial, flags)\n \t  : (must_annul || (delay_list == NULL && new_delay_list == NULL))\n \t     && (must_annul = 1,\n@@ -1431,7 +1431,7 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n       if (! must_annul\n \t  && ((condition == const_true_rtx\n \t       || (! insn_sets_resource_p (trial, other_needed, 0)\n-\t\t   && ! may_trap_p (PATTERN (trial)))))\n+\t\t   && ! may_trap_or_fault_p (PATTERN (trial)))))\n \t  ? eligible_for_delay (insn, *pslots_filled, trial, flags)\n \t  : (must_annul || delay_list == NULL) && (must_annul = 1,\n \t     check_annul_list_true_false (1, delay_list)\n@@ -2323,7 +2323,7 @@ fill_simple_delay_slots (int non_jumps_p)\n #ifdef HAVE_cc0\n \t\t    && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n #endif\n-\t\t    && ! (maybe_never && may_trap_p (pat))\n+\t\t    && ! (maybe_never && may_trap_or_fault_p (pat))\n \t\t    && (trial = try_split (pat, trial, 0))\n \t\t    && eligible_for_delay (insn, slots_filled, trial, flags)\n \t\t    && ! can_throw_internal(trial))\n@@ -2376,7 +2376,7 @@ fill_simple_delay_slots (int non_jumps_p)\n #ifdef HAVE_cc0\n \t      && ! reg_mentioned_p (cc0_rtx, PATTERN (next_trial))\n #endif\n-\t      && ! (maybe_never && may_trap_p (PATTERN (next_trial)))\n+\t      && ! (maybe_never && may_trap_or_fault_p (PATTERN (next_trial)))\n \t      && (next_trial = try_split (PATTERN (next_trial), next_trial, 0))\n \t      && eligible_for_delay (insn, slots_filled, next_trial, flags)\n \t      && ! can_throw_internal (trial))\n@@ -2656,7 +2656,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t  if (!must_annul\n \t      && (condition == const_true_rtx\n \t          || (! insn_sets_resource_p (trial, &opposite_needed, 1)\n-\t\t      && ! may_trap_p (pat))))\n+\t\t      && ! may_trap_or_fault_p (pat))))\n \t    {\n \t      old_trial = trial;\n \t      trial = try_split (pat, trial, 0);"}, {"sha": "ceb23941b88f29f4b7f7768de2c3d694186e531c", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -1611,6 +1611,7 @@ extern int side_effects_p (rtx);\n extern int volatile_refs_p (rtx);\n extern int volatile_insn_p (rtx);\n extern int may_trap_p (rtx);\n+extern int may_trap_or_fault_p (rtx);\n extern int inequality_comparisons_p (rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n extern rtx replace_regs (rtx, rtx *, unsigned int, int);"}, {"sha": "594b2e47f64308d43b14fadfe69e128d62bcf403", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 114, "deletions": 20, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -223,10 +223,13 @@ rtx_varies_p (rtx x, int for_alias)\n   return 0;\n }\n \n-/* Return 0 if the use of X as an address in a MEM can cause a trap.  */\n+/* Return nonzero if the use of X as an address in a MEM can cause a trap.\n+   MODE is the mode of the MEM (not that of X) and UNALIGNED_MEMS controls\n+   whether nonzero is returned for unaligned memory accesses on strict\n+   alignment machines.  */\n \n-int\n-rtx_addr_can_trap_p (rtx x)\n+static int\n+rtx_addr_can_trap_p_1 (rtx x, enum machine_mode mode, bool unaligned_mems)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -252,27 +255,52 @@ rtx_addr_can_trap_p (rtx x)\n       return 1;\n \n     case CONST:\n-      return rtx_addr_can_trap_p (XEXP (x, 0));\n+      return rtx_addr_can_trap_p_1 (XEXP (x, 0), mode, unaligned_mems);\n \n     case PLUS:\n-      /* An address is assumed not to trap if it is an address that can't\n-\t trap plus a constant integer or it is the pic register plus a\n-\t constant.  */\n-      return ! ((! rtx_addr_can_trap_p (XEXP (x, 0))\n-\t\t && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t\t|| (XEXP (x, 0) == pic_offset_table_rtx\n-\t\t    && CONSTANT_P (XEXP (x, 1))));\n+      /* An address is assumed not to trap if:\n+\t - it is an address that can't trap plus a constant integer,\n+\t   with the proper remainder modulo the mode size if we are\n+\t   considering unaligned memory references.  */\n+      if (!rtx_addr_can_trap_p_1 (XEXP (x, 0), mode, unaligned_mems)\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT offset;\n+\n+\t  if (!STRICT_ALIGNMENT || !unaligned_mems)\n+\t    return 0;\n+\n+\t  offset = INTVAL (XEXP (x, 1));\n+\n+#ifdef SPARC_STACK_BOUNDARY_HACK\n+\t  /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n+\t     the real alignment of %sp.  However, when it does this, the\n+\t     alignment of %sp+STACK_POINTER_OFFSET is STACK_BOUNDARY.  */\n+\t  if (SPARC_STACK_BOUNDARY_HACK\n+\t      && (XEXP (x, 0) == stack_pointer_rtx\n+\t\t  || XEXP (x, 0) == hard_frame_pointer_rtx))\n+\t    offset -= STACK_POINTER_OFFSET;\n+#endif\n+\n+\t  return offset % GET_MODE_SIZE (mode) != 0;\n+\t}\n+\n+      /* - or it is the pic register plus a constant.  */\n+      if (XEXP (x, 0) == pic_offset_table_rtx && CONSTANT_P (XEXP (x, 1)))\n+\treturn 0;\n+\n+      return 1;\n \n     case LO_SUM:\n     case PRE_MODIFY:\n-      return rtx_addr_can_trap_p (XEXP (x, 1));\n+      return rtx_addr_can_trap_p_1 (XEXP (x, 1), mode, unaligned_mems);\n \n     case PRE_DEC:\n     case PRE_INC:\n     case POST_DEC:\n     case POST_INC:\n     case POST_MODIFY:\n-      return rtx_addr_can_trap_p (XEXP (x, 0));\n+      return rtx_addr_can_trap_p_1 (XEXP (x, 0), mode, unaligned_mems);\n \n     default:\n       break;\n@@ -282,6 +310,14 @@ rtx_addr_can_trap_p (rtx x)\n   return 1;\n }\n \n+/* Return nonzero if the use of X as an address in a MEM can cause a trap.  */\n+\n+int\n+rtx_addr_can_trap_p (rtx x)\n+{\n+  return rtx_addr_can_trap_p_1 (x, VOIDmode, false);\n+}\n+\n /* Return true if X is an address that is known to not be zero.  */\n \n bool\n@@ -2065,10 +2101,12 @@ side_effects_p (rtx x)\n   return 0;\n }\n \f\n-/* Return nonzero if evaluating rtx X might cause a trap.  */\n+/* Return nonzero if evaluating rtx X might cause a trap.  UNALIGNED_MEMS\n+   controls whether nonzero is returned for unaligned memory accesses on\n+   strict alignment machines.  */\n \n-int\n-may_trap_p (rtx x)\n+static int\n+may_trap_p_1 (rtx x, bool unaligned_mems)\n {\n   int i;\n   enum rtx_code code;\n@@ -2102,9 +2140,11 @@ may_trap_p (rtx x)\n \n       /* Memory ref can trap unless it's a static var or a stack slot.  */\n     case MEM:\n-      if (MEM_NOTRAP_P (x))\n+      if (MEM_NOTRAP_P (x)\n+\t  && (!STRICT_ALIGNMENT || !unaligned_mems))\n \treturn 0;\n-      return rtx_addr_can_trap_p (XEXP (x, 0));\n+      return\n+\trtx_addr_can_trap_p_1 (XEXP (x, 0), GET_MODE (x), unaligned_mems);\n \n       /* Division by a non-constant might trap.  */\n     case DIV:\n@@ -2180,19 +2220,73 @@ may_trap_p (rtx x)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  if (may_trap_p (XEXP (x, i)))\n+\t  if (may_trap_p_1 (XEXP (x, i), unaligned_mems))\n \t    return 1;\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (may_trap_p (XVECEXP (x, i, j)))\n+\t    if (may_trap_p_1 (XVECEXP (x, i, j), unaligned_mems))\n \t      return 1;\n \t}\n     }\n   return 0;\n }\n+\n+/* Return nonzero if evaluating rtx X might cause a trap.  */\n+\n+int\n+may_trap_p (rtx x)\n+{\n+  return may_trap_p_1 (x, false);\n+}\n+\n+/* Same as above, but additionally return non-zero if evaluating rtx X might\n+   cause a fault.  We define a fault for the purpose of this function as a\n+   erroneous execution condition that cannot be encountered during the normal\n+   execution of a valid program; the typical example is an unaligned memory\n+   access on a strict alignment machine.  The compiler guarantees that it\n+   doesn't generate code that will fault from a valid program, but this\n+   guarantee doesn't mean anything for individual instructions.  Consider\n+   the following example:\n+\n+      struct S { int d; union { char *cp; int *ip; }; };\n+\n+      int foo(struct S *s)\n+      {\n+\tif (s->d == 1)\n+\t  return *s->ip;\n+\telse\n+\t  return *s->cp;\n+      }\n+\n+   on a strict alignment machine.  In a valid program, foo will never be\n+   invoked on a structure for which d is equal to 1 and the underlying\n+   unique field of the union not aligned on a 4-byte boundary, but the\n+   expression *s->ip might cause a fault if considered individually.\n+\n+   At the RTL level, potentially problematic expressions will almost always\n+   verify may_trap_p; for example, the above dereference can be emitted as\n+   (mem:SI (reg:P)) and this expression is may_trap_p for a generic register.\n+   However, suppose that foo is inlined in a caller that causes s->cp to\n+   point to a local character variable and guarantees that s->d is not set\n+   to 1; foo may have been effectively translated into pseudo-RTL as:\n+\n+      if ((reg:SI) == 1)\n+\t(set (reg:SI) (mem:SI (%fp - 7)))\n+      else\n+\t(set (reg:QI) (mem:QI (%fp - 7)))\n+\n+   Now (mem:SI (%fp - 7)) is considered as not may_trap_p since it is a\n+   memory reference to a stack slot, but it will certainly cause a fault\n+   on a strict alignment machine.  */\n+\n+int\n+may_trap_or_fault_p (rtx x)\n+{\n+  return may_trap_p_1 (x, true);\n+}\n \f\n /* Return nonzero if X contains a comparison that is not either EQ or NE,\n    i.e., an inequality.  */"}, {"sha": "82e1f048e183958ccc19bcfe0f67ef7c247591da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -1,3 +1,7 @@\n+2005-10-20  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* g++.dg/opt/delay-slot-1.C: New test.\n+\n 2005-10-20  Erik Edelmann  <erik.edelmann@iki.fi>\n \n \tPR fortran/21625"}, {"sha": "e180e48105e15287c1bb5275cb4a292dc30f373a", "filename": "gcc/testsuite/g++.dg/opt/delay-slot-1.C", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdelay-slot-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdelay-slot-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdelay-slot-1.C?ref=2358ff9116d8167e4b0d2f70a9d61e4e8ca5168e", "patch": "@@ -0,0 +1,111 @@\n+/* PR rtl-optimization/23585 */\n+/* Testcase by Matti Rintala <matti.rintala@iki.fi> */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+template <class _Ret, class _Tp>\n+class const_mem_fun_t\n+{\n+public:\n+  explicit\n+  const_mem_fun_t(_Ret (_Tp::*__pf)() const)\n+    : _M_f(__pf) {}\n+  \n+  _Ret\n+  operator()(const _Tp* __p) const\n+  { return (__p->*_M_f)(); }\n+private:\n+  _Ret (_Tp::*_M_f)() const;\n+};\n+\n+template <class _Ret, class _Tp>\n+class const_mem_fun_ref_t\n+{\n+public:\n+  explicit\n+  const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)\n+    : _M_f(__pf) {}\n+  \n+  _Ret\n+  operator()(const _Tp& __r) const\n+  { return (__r.*_M_f)(); }\n+private:\n+  _Ret (_Tp::*_M_f)() const;\n+};\n+\n+template <class _Ret, class _Tp, class _Arg>\n+class const_mem_fun1_t\n+{\n+public:\n+  explicit\n+  const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)\n+    : _M_f(__pf) {}\n+  \n+  _Ret\n+  operator()(const _Tp* __p, _Arg __x) const\n+  { return (__p->*_M_f)(__x); }\n+private:\n+  _Ret (_Tp::*_M_f)(_Arg) const;\n+};\n+\n+\n+template <class _Ret, class _Tp, class _Arg>\n+class const_mem_fun1_ref_t\n+{\n+public:\n+  explicit\n+  const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)\n+    : _M_f(__pf) {}\n+  \n+  _Ret\n+  operator()(const _Tp& __r, _Arg __x) const\n+  { return (__r.*_M_f)(__x); }\n+private:\n+  _Ret (_Tp::*_M_f)(_Arg) const;\n+};\n+\n+template <class _Ret, class _Tp>\n+inline const_mem_fun_t<_Ret, _Tp>\n+mem_fun(_Ret (_Tp::*__f)() const)\n+{ return const_mem_fun_t<_Ret, _Tp>(__f); }\n+\n+template <class _Ret, class _Tp>\n+inline const_mem_fun_ref_t<_Ret, _Tp>\n+mem_fun_ref(_Ret (_Tp::*__f)() const)\n+{ return const_mem_fun_ref_t<_Ret, _Tp>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_t<_Ret, _Tp, _Arg>\n+mem_fun(_Ret (_Tp::*__f)(_Arg) const)\n+{ return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n+\n+template <class _Ret, class _Tp, class _Arg>\n+inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>\n+mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n+{ return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n+\n+class Class {\n+public:\n+  void vf0c() const;\n+  void vf1c(const int&) const;\n+};\n+\n+int main()\n+{\n+  Class obj;\n+  const Class& objc = obj;\n+\n+  mem_fun(&Class::vf0c)(&objc);\n+  mem_fun(&Class::vf1c)(&objc, 1);\n+\n+  mem_fun_ref(&Class::vf0c)(objc);\n+  mem_fun_ref(&Class::vf1c)(objc, 1);\n+  return 0;\n+}\n+\n+void Class::vf0c() const\n+{}\n+\n+void Class::vf1c(const int&) const\n+{}"}]}