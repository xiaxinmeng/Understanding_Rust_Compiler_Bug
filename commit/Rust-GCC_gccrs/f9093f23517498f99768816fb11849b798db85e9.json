{"sha": "f9093f23517498f99768816fb11849b798db85e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwOTNmMjM1MTc0OThmOTk3Njg4MTZmYjExODQ5Yjc5OGRiODVlOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-01T11:03:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-02-01T11:03:17Z"}, "message": "[AArch64] Generalise aarch64_simd_valid_immediate for SVE\n\nThe current aarch64_simd_valid_immediate code predates the move\nto the new CONST_VECTOR representation, so for variable-length SVE\nit only handles duplicates of single elements, rather than duplicates\nof repeating patterns.\n\nThis patch removes the restriction.  It means that the validity\nof a duplicated constant depends only on the bit pattern, not on\nthe mode used to represent it.\n\nThe patch is needed by a later big-endian fix.\n\n2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): Handle\n\tall CONST_VECTOR_DUPLICATE_P vectors, not just those with a single\n\tduplicated element.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nFrom-SVN: r257286", "tree": {"sha": "0656a9cae26eb657f0061400eb9cb763158487c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0656a9cae26eb657f0061400eb9cb763158487c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9093f23517498f99768816fb11849b798db85e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9093f23517498f99768816fb11849b798db85e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9093f23517498f99768816fb11849b798db85e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9093f23517498f99768816fb11849b798db85e9/comments", "author": null, "committer": null, "parents": [{"sha": "9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a1b9cb4d6fcf88d68f55b97c7d9d09c5606fed7"}], "stats": {"total": 40, "additions": 25, "deletions": 15}, "files": [{"sha": "d665f3df3266015179f0780d66cdaae285d6fe1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9093f23517498f99768816fb11849b798db85e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9093f23517498f99768816fb11849b798db85e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9093f23517498f99768816fb11849b798db85e9", "patch": "@@ -1,3 +1,9 @@\n+2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): Handle\n+\tall CONST_VECTOR_DUPLICATE_P vectors, not just those with a single\n+\tduplicated element.\n+\n 2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tearget/83845"}, {"sha": "1278f83aaa9092ab6b3bb999e61744989857e082", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9093f23517498f99768816fb11849b798db85e9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9093f23517498f99768816fb11849b798db85e9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f9093f23517498f99768816fb11849b798db85e9", "patch": "@@ -13164,10 +13164,11 @@ aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n     return false;\n \n   scalar_mode elt_mode = GET_MODE_INNER (mode);\n-  rtx elt = NULL, base, step;\n+  rtx base, step;\n   unsigned int n_elts;\n-  if (const_vec_duplicate_p (op, &elt))\n-    n_elts = 1;\n+  if (GET_CODE (op) == CONST_VECTOR\n+      && CONST_VECTOR_DUPLICATE_P (op))\n+    n_elts = CONST_VECTOR_NPATTERNS (op);\n   else if ((vec_flags & VEC_SVE_DATA)\n \t   && const_vec_series_p (op, &base, &step))\n     {\n@@ -13192,14 +13193,17 @@ aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n \t    || op == CONSTM1_RTX (mode));\n \n   scalar_float_mode elt_float_mode;\n-  if (elt\n-      && is_a <scalar_float_mode> (elt_mode, &elt_float_mode)\n-      && (aarch64_float_const_zero_rtx_p (elt)\n-\t  || aarch64_float_const_representable_p (elt)))\n+  if (n_elts == 1\n+      && is_a <scalar_float_mode> (elt_mode, &elt_float_mode))\n     {\n-      if (info)\n-\t*info = simd_immediate_info (elt_float_mode, elt);\n-      return true;\n+      rtx elt = CONST_VECTOR_ENCODED_ELT (op, 0);\n+      if (aarch64_float_const_zero_rtx_p (elt)\n+\t  || aarch64_float_const_representable_p (elt))\n+\t{\n+\t  if (info)\n+\t    *info = simd_immediate_info (elt_float_mode, elt);\n+\t  return true;\n+\t}\n     }\n \n   unsigned int elt_size = GET_MODE_SIZE (elt_mode);\n@@ -13214,11 +13218,11 @@ aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n   bytes.reserve (n_elts * elt_size);\n   for (unsigned int i = 0; i < n_elts; i++)\n     {\n-      if (!elt || n_elts != 1)\n-\t/* The vector is provided in gcc endian-neutral fashion.\n-\t   For aarch64_be, it must be laid out in the vector register\n-\t   in reverse order.  */\n-\telt = CONST_VECTOR_ELT (op, BYTES_BIG_ENDIAN ? (n_elts - 1 - i) : i);\n+      /* The vector is provided in gcc endian-neutral fashion.\n+\t For aarch64_be Advanced SIMD, it must be laid out in the vector\n+\t register in reverse order.  */\n+      bool swap_p = ((vec_flags & VEC_ADVSIMD) != 0 && BYTES_BIG_ENDIAN);\n+      rtx elt = CONST_VECTOR_ELT (op, swap_p ? (n_elts - 1 - i) : i);\n \n       if (elt_mode != elt_int_mode)\n \telt = gen_lowpart (elt_int_mode, elt);"}]}