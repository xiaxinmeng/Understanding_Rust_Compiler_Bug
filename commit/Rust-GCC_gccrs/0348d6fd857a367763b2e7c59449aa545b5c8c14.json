{"sha": "0348d6fd857a367763b2e7c59449aa545b5c8c14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM0OGQ2ZmQ4NTdhMzY3NzYzYjJlN2M1OTQ0OWFhNTQ1YjVjOGMxNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-09-08T18:46:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-09-08T18:46:06Z"}, "message": "re PR fortran/15326 ([4.0 only] ICE with assumed length character strings)\n\n\tPR fortran/15326\n\t* trans-array.c (gfc_add_loop_ss_code): Set ss->string_length in\n\tthe GFC_SS_FUNCTION case too.\n\t* trans-expr.c (gfc_conv_function_val): Allow symbols to be bound\n\tto function pointers as well as function decls.\n\t(gfc_interface_sym_mapping, gfc_interface_mapping): New structures.\n\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n\t(gfc_get_interface_mapping_charlen, gfc_get_interface_mapping_array)\n\t(gfc_set_interface_mapping_bounds, gfc_add_interface_mapping)\n\t(gfc_finish_interface_mapping, gfc_apply_interface_mapping_to_cons)\n\t(gfc_apply_interface_mapping_to_ref)\n\t(gfc_apply_interface_mapping_to_expr)\n\t(gfc_apply_interface_mapping): New functions.\n\t(gfc_conv_function_call): Evaluate the arguments before working\n\tout where the result should go.  Make the null pointer case provide\n\tthe string length in parmse.string_length.  Cope with non-constant\n\tstring lengths, using the above functions to evaluate such lengths.\n\tUse a temporary typespec; don't assign to sym->cl->backend_decl.\n\tDon't assign to se->string_length when returning a cached array\n\tdescriptor.\n\nFrom-SVN: r104040", "tree": {"sha": "b6a188c252604f0bb8093a302e7455b168cbfa98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6a188c252604f0bb8093a302e7455b168cbfa98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0348d6fd857a367763b2e7c59449aa545b5c8c14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0348d6fd857a367763b2e7c59449aa545b5c8c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0348d6fd857a367763b2e7c59449aa545b5c8c14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0348d6fd857a367763b2e7c59449aa545b5c8c14/comments", "author": null, "committer": null, "parents": [{"sha": "5c9186cec38354d5b51e41cbfb37d89a1a8ddca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9186cec38354d5b51e41cbfb37d89a1a8ddca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c9186cec38354d5b51e41cbfb37d89a1a8ddca9"}], "stats": {"total": 1403, "additions": 1296, "deletions": 107}, "files": [{"sha": "38624469cefe7fccf068332037e886931e1a1932", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -1,3 +1,26 @@\n+2005-09-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/15326\n+\t* trans-array.c (gfc_add_loop_ss_code): Set ss->string_length in\n+\tthe GFC_SS_FUNCTION case too.\n+\t* trans-expr.c (gfc_conv_function_val): Allow symbols to be bound\n+\tto function pointers as well as function decls.\n+\t(gfc_interface_sym_mapping, gfc_interface_mapping): New structures.\n+\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n+\t(gfc_get_interface_mapping_charlen, gfc_get_interface_mapping_array)\n+\t(gfc_set_interface_mapping_bounds, gfc_add_interface_mapping)\n+\t(gfc_finish_interface_mapping, gfc_apply_interface_mapping_to_cons)\n+\t(gfc_apply_interface_mapping_to_ref)\n+\t(gfc_apply_interface_mapping_to_expr)\n+\t(gfc_apply_interface_mapping): New functions.\n+\t(gfc_conv_function_call): Evaluate the arguments before working\n+\tout where the result should go.  Make the null pointer case provide\n+\tthe string length in parmse.string_length.  Cope with non-constant\n+\tstring lengths, using the above functions to evaluate such lengths.\n+\tUse a temporary typespec; don't assign to sym->cl->backend_decl.\n+\tDon't assign to se->string_length when returning a cached array\n+\tdescriptor.\n+\n 2005-09-08  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/19928"}, {"sha": "fbd8b5b598fec134a11e725570bd951181ca81e8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -1233,6 +1233,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \t  gfc_conv_expr (&se, ss->expr);\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n+\t  ss->string_length = se.string_length;\n \t  break;\n \n \tcase GFC_SS_CONSTRUCTOR:"}, {"sha": "cf49ba4e29827a998775244abd1f40101e0e877c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 552, "deletions": 107, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -1058,21 +1058,463 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n       tmp = gfc_get_symbol_decl (sym);\n       gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (tmp))) == FUNCTION_TYPE);\n-\n-      se->expr = tmp;\n     }\n   else\n     {\n       if (!sym->backend_decl)\n \tsym->backend_decl = gfc_get_extern_function_decl (sym);\n \n       tmp = sym->backend_decl;\n-      gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n-      se->expr = gfc_build_addr_expr (NULL, tmp);\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t{\n+\t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n+\t  tmp = gfc_build_addr_expr (NULL, tmp);\n+\t}\n+    }\n+  se->expr = tmp;\n+}\n+\n+\n+/* This group of functions allows a caller to evaluate an expression from\n+   the callee's interface.  It establishes a mapping between the interface's\n+   dummy arguments and the caller's actual arguments, then applies that\n+   mapping to a given gfc_expr.\n+\n+   You can initialize a mapping structure like so:\n+\n+       gfc_interface_mapping mapping;\n+       ...\n+       gfc_init_interface_mapping (&mapping);\n+\n+   You should then evaluate each actual argument into a temporary\n+   gfc_se structure, here called \"se\", and map the result to the\n+   dummy argument's symbol, here called \"sym\":\n+\n+       gfc_add_interface_mapping (&mapping, sym, &se);\n+\n+   After adding all mappings, you should call:\n+\n+       gfc_finish_interface_mapping (&mapping, pre, post);\n+\n+   where \"pre\" and \"post\" are statement blocks for initialization\n+   and finalization code respectively.  You can then evaluate an\n+   interface expression \"expr\" as follows:\n+\n+       gfc_apply_interface_mapping (&mapping, se, expr);\n+\n+   Once you've evaluated all expressions, you should free\n+   the mapping structure with:\n+\n+       gfc_free_interface_mapping (&mapping); */\n+\n+\n+/* This structure represents a mapping from OLD to NEW, where OLD is a\n+   dummy argument symbol and NEW is a symbol that represents the value\n+   of an actual argument.  Mappings are linked together using NEXT\n+   (in no particular order).  */\n+typedef struct gfc_interface_sym_mapping\n+{\n+  struct gfc_interface_sym_mapping *next;\n+  gfc_symbol *old;\n+  gfc_symtree *new;\n+}\n+gfc_interface_sym_mapping;\n+\n+\n+/* This structure is used by callers to evaluate an expression from\n+   a callee's interface.  */\n+typedef struct gfc_interface_mapping\n+{\n+  /* Maps the interface's dummy arguments to the values that the caller\n+     is passing.  The whole list is owned by this gfc_interface_mapping.  */\n+  gfc_interface_sym_mapping *syms;\n+\n+  /* A list of gfc_charlens that were needed when creating copies of\n+     expressions.  The whole list is owned by this gfc_interface_mapping.  */\n+  gfc_charlen *charlens;\n+}\n+gfc_interface_mapping;\n+\n+\n+static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n+\t\t\t\t\t\t gfc_expr *);\n+\n+/* Initialize MAPPING.  */\n+\n+static void\n+gfc_init_interface_mapping (gfc_interface_mapping * mapping)\n+{\n+  mapping->syms = NULL;\n+  mapping->charlens = NULL;\n+}\n+\n+\n+/* Free all memory held by MAPPING (but not MAPPING itself).  */\n+\n+static void\n+gfc_free_interface_mapping (gfc_interface_mapping * mapping)\n+{\n+  gfc_interface_sym_mapping *sym;\n+  gfc_interface_sym_mapping *nextsym;\n+  gfc_charlen *cl;\n+  gfc_charlen *nextcl;\n+\n+  for (sym = mapping->syms; sym; sym = nextsym)\n+    {\n+      nextsym = sym->next;\n+      gfc_free_symbol (sym->new->n.sym);\n+      gfc_free (sym->new);\n+      gfc_free (sym);\n+    }\n+  for (cl = mapping->charlens; cl; cl = nextcl)\n+    {\n+      nextcl = cl->next;\n+      gfc_free_expr (cl->length);\n+      gfc_free (cl);\n+    }\n+}\n+\n+\n+/* Return a copy of gfc_charlen CL.  Add the returned structure to\n+   MAPPING so that it will be freed by gfc_free_interface_mapping.  */\n+\n+static gfc_charlen *\n+gfc_get_interface_mapping_charlen (gfc_interface_mapping * mapping,\n+\t\t\t\t   gfc_charlen * cl)\n+{\n+  gfc_charlen *new;\n+\n+  new = gfc_get_charlen ();\n+  new->next = mapping->charlens;\n+  new->length = gfc_copy_expr (cl->length);\n+\n+  mapping->charlens = new;\n+  return new;\n+}\n+\n+\n+/* A subroutine of gfc_add_interface_mapping.  Return a descriptorless\n+   array variable that can be used as the actual argument for dummy\n+   argument SYM.  Add any initialization code to BLOCK.  PACKED is as\n+   for gfc_get_nodesc_array_type and DATA points to the first element\n+   in the passed array.  */\n+\n+static tree\n+gfc_get_interface_mapping_array (stmtblock_t * block, gfc_symbol * sym,\n+\t\t\t\t int packed, tree data)\n+{\n+  tree type;\n+  tree var;\n+\n+  type = gfc_typenode_for_spec (&sym->ts);\n+  type = gfc_get_nodesc_array_type (type, sym->as, packed);\n+\n+  var = gfc_create_var (type, \"parm\");\n+  gfc_add_modify_expr (block, var, fold_convert (type, data));\n+\n+  return var;\n+}\n+\n+\n+/* A subroutine of gfc_add_interface_mapping.  Set the stride, upper bounds\n+   and offset of descriptorless array type TYPE given that it has the same\n+   size as DESC.  Add any set-up code to BLOCK.  */\n+\n+static void\n+gfc_set_interface_mapping_bounds (stmtblock_t * block, tree type, tree desc)\n+{\n+  int n;\n+  tree dim;\n+  tree offset;\n+  tree tmp;\n+\n+  offset = gfc_index_zero_node;\n+  for (n = 0; n < GFC_TYPE_ARRAY_RANK (type); n++)\n+    {\n+      GFC_TYPE_ARRAY_STRIDE (type, n) = gfc_conv_array_stride (desc, n);\n+      if (GFC_TYPE_ARRAY_UBOUND (type, n) == NULL_TREE)\n+\t{\n+\t  dim = gfc_rank_cst[n];\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_ubound (desc, dim),\n+\t\t\t     gfc_conv_descriptor_lbound (desc, dim));\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     GFC_TYPE_ARRAY_LBOUND (type, n),\n+\t\t\t     tmp);\n+\t  tmp = gfc_evaluate_now (tmp, block);\n+\t  GFC_TYPE_ARRAY_UBOUND (type, n) = tmp;\n+\t}\n+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t GFC_TYPE_ARRAY_LBOUND (type, n),\n+\t\t\t GFC_TYPE_ARRAY_STRIDE (type, n));\n+      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n+    }\n+  offset = gfc_evaluate_now (offset, block);\n+  GFC_TYPE_ARRAY_OFFSET (type) = offset;\n+}\n+\n+\n+/* Extend MAPPING so that it maps dummy argument SYM to the value stored\n+   in SE.  The caller may still use se->expr and se->string_length after\n+   calling this function.  */\n+\n+static void\n+gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n+\t\t\t   gfc_symbol * sym, gfc_se * se)\n+{\n+  gfc_interface_sym_mapping *sm;\n+  tree desc;\n+  tree tmp;\n+  tree value;\n+  gfc_symbol *new_sym;\n+  gfc_symtree *root;\n+  gfc_symtree *new_symtree;\n+\n+  /* Create a new symbol to represent the actual argument.  */\n+  new_sym = gfc_new_symbol (sym->name, NULL);\n+  new_sym->ts = sym->ts;\n+  new_sym->attr.referenced = 1;\n+  new_sym->attr.dimension = sym->attr.dimension;\n+  new_sym->attr.pointer = sym->attr.pointer;\n+  new_sym->attr.flavor = sym->attr.flavor;\n+\n+  /* Create a fake symtree for it.  */\n+  root = NULL;\n+  new_symtree = gfc_new_symtree (&root, sym->name);\n+  new_symtree->n.sym = new_sym;\n+  gcc_assert (new_symtree == root);\n+\n+  /* Create a dummy->actual mapping.  */\n+  sm = gfc_getmem (sizeof (*sm));\n+  sm->next = mapping->syms;\n+  sm->old = sym;\n+  sm->new = new_symtree;\n+  mapping->syms = sm;\n+\n+  /* Stabilize the argument's value.  */\n+  se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+\n+  if (sym->ts.type == BT_CHARACTER)\n+    {\n+      /* Create a copy of the dummy argument's length.  */\n+      new_sym->ts.cl = gfc_get_interface_mapping_charlen (mapping, sym->ts.cl);\n+\n+      /* If the length is specified as \"*\", record the length that\n+\t the caller is passing.  We should use the callee's length\n+\t in all other cases.  */\n+      if (!new_sym->ts.cl->length)\n+\t{\n+\t  se->string_length = gfc_evaluate_now (se->string_length, &se->pre);\n+\t  new_sym->ts.cl->backend_decl = se->string_length;\n+\t}\n+    }\n+\n+  /* Use the passed value as-is if the argument is a function.  */\n+  if (sym->attr.flavor == FL_PROCEDURE)\n+    value = se->expr;\n+\n+  /* If the argument is either a string or a pointer to a string,\n+     convert it to a boundless character type.  */\n+  else if (!sym->attr.dimension && sym->ts.type == BT_CHARACTER)\n+    {\n+      tmp = gfc_get_character_type_len (sym->ts.kind, NULL);\n+      tmp = build_pointer_type (tmp);\n+      if (sym->attr.pointer)\n+\ttmp = build_pointer_type (tmp);\n+\n+      value = fold_convert (tmp, se->expr);\n+      if (sym->attr.pointer)\n+\tvalue = gfc_build_indirect_ref (value);\n+    }\n+\n+  /* If the argument is a scalar or a pointer to an array, dereference it.  */\n+  else if (!sym->attr.dimension || sym->attr.pointer)\n+    value = gfc_build_indirect_ref (se->expr);\n+\n+  /* If the argument is an array descriptor, use it to determine\n+     information about the actual argument's shape.  */\n+  else if (POINTER_TYPE_P (TREE_TYPE (se->expr))\n+\t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se->expr))))\n+    {\n+      /* Get the actual argument's descriptor.  */\n+      desc = gfc_build_indirect_ref (se->expr);\n+\n+      /* Create the replacement variable.  */\n+      tmp = gfc_conv_descriptor_data_get (desc);\n+      value = gfc_get_interface_mapping_array (&se->pre, sym, 0, tmp);\n+\n+      /* Use DESC to work out the upper bounds, strides and offset.  */\n+      gfc_set_interface_mapping_bounds (&se->pre, TREE_TYPE (value), desc);\n+    }\n+  else\n+    /* Otherwise we have a packed array.  */\n+    value = gfc_get_interface_mapping_array (&se->pre, sym, 2, se->expr);\n+\n+  new_sym->backend_decl = value;\n+}\n+\n+\n+/* Called once all dummy argument mappings have been added to MAPPING,\n+   but before the mapping is used to evaluate expressions.  Pre-evaluate\n+   the length of each argument, adding any initialization code to PRE and\n+   any finalization code to POST.  */\n+\n+static void\n+gfc_finish_interface_mapping (gfc_interface_mapping * mapping,\n+\t\t\t      stmtblock_t * pre, stmtblock_t * post)\n+{\n+  gfc_interface_sym_mapping *sym;\n+  gfc_expr *expr;\n+  gfc_se se;\n+\n+  for (sym = mapping->syms; sym; sym = sym->next)\n+    if (sym->new->n.sym->ts.type == BT_CHARACTER\n+\t&& !sym->new->n.sym->ts.cl->backend_decl)\n+      {\n+\texpr = sym->new->n.sym->ts.cl->length;\n+\tgfc_apply_interface_mapping_to_expr (mapping, expr);\n+\tgfc_init_se (&se, NULL);\n+\tgfc_conv_expr (&se, expr);\n+\n+\tse.expr = gfc_evaluate_now (se.expr, &se.pre);\n+\tgfc_add_block_to_block (pre, &se.pre);\n+\tgfc_add_block_to_block (post, &se.post);\n+\n+\tsym->new->n.sym->ts.cl->backend_decl = se.expr;\n+      }\n+}\n+\n+\n+/* Like gfc_apply_interface_mapping_to_expr, but applied to\n+   constructor C.  */\n+\n+static void\n+gfc_apply_interface_mapping_to_cons (gfc_interface_mapping * mapping,\n+\t\t\t\t     gfc_constructor * c)\n+{\n+  for (; c; c = c->next)\n+    {\n+      gfc_apply_interface_mapping_to_expr (mapping, c->expr);\n+      if (c->iterator)\n+\t{\n+\t  gfc_apply_interface_mapping_to_expr (mapping, c->iterator->start);\n+\t  gfc_apply_interface_mapping_to_expr (mapping, c->iterator->end);\n+\t  gfc_apply_interface_mapping_to_expr (mapping, c->iterator->step);\n+\t}\n+    }\n+}\n+\n+\n+/* Like gfc_apply_interface_mapping_to_expr, but applied to\n+   reference REF.  */\n+\n+static void\n+gfc_apply_interface_mapping_to_ref (gfc_interface_mapping * mapping,\n+\t\t\t\t    gfc_ref * ref)\n+{\n+  int n;\n+\n+  for (; ref; ref = ref->next)\n+    switch (ref->type)\n+      {\n+      case REF_ARRAY:\n+\tfor (n = 0; n < ref->u.ar.dimen; n++)\n+\t  {\n+\t    gfc_apply_interface_mapping_to_expr (mapping, ref->u.ar.start[n]);\n+\t    gfc_apply_interface_mapping_to_expr (mapping, ref->u.ar.end[n]);\n+\t    gfc_apply_interface_mapping_to_expr (mapping, ref->u.ar.stride[n]);\n+\t  }\n+\tgfc_apply_interface_mapping_to_expr (mapping, ref->u.ar.offset);\n+\tbreak;\n+\n+      case REF_COMPONENT:\n+\tbreak;\n+\n+      case REF_SUBSTRING:\n+\tgfc_apply_interface_mapping_to_expr (mapping, ref->u.ss.start);\n+\tgfc_apply_interface_mapping_to_expr (mapping, ref->u.ss.end);\n+\tbreak;\n+      }\n+}\n+\n+\n+/* EXPR is a copy of an expression that appeared in the interface\n+   associated with MAPPING.  Walk it recursively looking for references to\n+   dummy arguments that MAPPING maps to actual arguments.  Replace each such\n+   reference with a reference to the associated actual argument.  */\n+\n+static void\n+gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n+\t\t\t\t     gfc_expr * expr)\n+{\n+  gfc_interface_sym_mapping *sym;\n+  gfc_actual_arglist *actual;\n+\n+  if (!expr)\n+    return;\n+\n+  /* Copying an expression does not copy its length, so do that here.  */\n+  if (expr->ts.type == BT_CHARACTER && expr->ts.cl)\n+    {\n+      expr->ts.cl = gfc_get_interface_mapping_charlen (mapping, expr->ts.cl);\n+      gfc_apply_interface_mapping_to_expr (mapping, expr->ts.cl->length);\n+    }\n+\n+  /* Apply the mapping to any references.  */\n+  gfc_apply_interface_mapping_to_ref (mapping, expr->ref);\n+\n+  /* ...and to the expression's symbol, if it has one.  */\n+  if (expr->symtree)\n+    for (sym = mapping->syms; sym; sym = sym->next)\n+      if (sym->old == expr->symtree->n.sym)\n+\texpr->symtree = sym->new;\n+\n+  /* ...and to subexpressions in expr->value.  */\n+  switch (expr->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+    case EXPR_CONSTANT:\n+    case EXPR_NULL:\n+    case EXPR_SUBSTRING:\n+      break;\n+\n+    case EXPR_OP:\n+      gfc_apply_interface_mapping_to_expr (mapping, expr->value.op.op1);\n+      gfc_apply_interface_mapping_to_expr (mapping, expr->value.op.op2);\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      for (sym = mapping->syms; sym; sym = sym->next)\n+\tif (sym->old == expr->value.function.esym)\n+\t  expr->value.function.esym = sym->new->n.sym;\n+\n+      for (actual = expr->value.function.actual; actual; actual = actual->next)\n+\tgfc_apply_interface_mapping_to_expr (mapping, actual->expr);\n+      break;\n+\n+    case EXPR_ARRAY:\n+    case EXPR_STRUCTURE:\n+      gfc_apply_interface_mapping_to_cons (mapping, expr->value.constructor);\n+      break;\n     }\n }\n \n \n+/* Evaluate interface expression EXPR using MAPPING.  Store the result\n+   in SE.  */\n+\n+static void\n+gfc_apply_interface_mapping (gfc_interface_mapping * mapping,\n+\t\t\t     gfc_se * se, gfc_expr * expr)\n+{\n+  expr = gfc_copy_expr (expr);\n+  gfc_apply_interface_mapping_to_expr (mapping, expr);\n+  gfc_conv_expr (se, expr);\n+  se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+  gfc_free_expr (expr);\n+}\n+\n+\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.  */\n@@ -1081,7 +1523,9 @@ int\n gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t\tgfc_actual_arglist * arg)\n {\n+  gfc_interface_mapping mapping;\n   tree arglist;\n+  tree retargs;\n   tree tmp;\n   tree fntype;\n   gfc_se parmse;\n@@ -1094,21 +1538,16 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   tree stringargs;\n   gfc_formal_arglist *formal;\n   int has_alternate_specifier = 0;\n+  bool need_interface_mapping;\n+  gfc_typespec ts;\n+  gfc_charlen cl;\n \n   arglist = NULL_TREE;\n+  retargs = NULL_TREE;\n   stringargs = NULL_TREE;\n   var = NULL_TREE;\n   len = NULL_TREE;\n \n-  /* Obtain the string length now because it is needed often below.  */\n-  if (sym->ts.type == BT_CHARACTER)\n-    {\n-      gcc_assert (sym->ts.cl && sym->ts.cl->length\n-\t\t  && sym->ts.cl->length->expr_type == EXPR_CONSTANT);\n-      len = gfc_conv_mpz_to_tree\n-\t      (sym->ts.cl->length->value.integer, sym->ts.cl->length->ts.kind);\n-    }\n-\n   if (se->ss != NULL)\n     {\n       if (!sym->attr.elemental)\n@@ -1123,9 +1562,6 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n               /* Access the previously obtained result.  */\n               gfc_conv_tmp_array_ref (se);\n               gfc_advance_se_ss_chain (se);\n-\n-\t      /* Bundle in the string length.  */\n-\t      se->string_length = len;\n               return 0;\n             }\n \t}\n@@ -1134,91 +1570,9 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   else\n     info = NULL;\n \n-  byref = gfc_return_by_reference (sym);\n-  if (byref)\n-    {\n-      if (se->direct_byref) \n-\t{\n-\t  arglist = gfc_chainon_list (arglist, se->expr);\n-\n-\t  /* Add string length to argument list.  */\n-\t  if (sym->ts.type == BT_CHARACTER)\n-\t    {\n-\t      sym->ts.cl->backend_decl = len;\n-\t      arglist = gfc_chainon_list (arglist, \n-\t\t\t\tconvert (gfc_charlen_type_node, len));\n-\t    }\n-\t}\n-      else if (sym->result->attr.dimension)\n-\t{\n-\t  gcc_assert (se->loop && se->ss);\n-\n-\t  /* Set the type of the array.  */\n-\t  tmp = gfc_typenode_for_spec (&sym->ts);\n-\t  info->dimen = se->loop->dimen;\n-\n-\t  /* Allocate a temporary to store the result.  */\n-\t  gfc_trans_allocate_temp_array (se->loop, info, tmp);\n-\n-\t  /* Zero the first stride to indicate a temporary.  */\n-\t  tmp =\n-\t    gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n-\t  gfc_add_modify_expr (&se->pre, tmp,\n-\t\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n-\n-\t  /* Pass the temporary as the first argument.  */\n-\t  tmp = info->descriptor;\n-\t  tmp = gfc_build_addr_expr (NULL, tmp);\n-\t  arglist = gfc_chainon_list (arglist, tmp);\n-\n-\t  /* Add string length to argument list.  */\n-\t  if (sym->ts.type == BT_CHARACTER)\n-\t    {\n-\t      sym->ts.cl->backend_decl = len;\n-\t      arglist = gfc_chainon_list (arglist, \n-\t\t\t      convert (gfc_charlen_type_node, len));\n-\t    }\n-\n-\t}\n-      else if (sym->ts.type == BT_CHARACTER)\n-\t{\n-\n-\t  /* Pass the string length.  */\n-\t  sym->ts.cl->backend_decl = len;\n-\t  type = gfc_get_character_type (sym->ts.kind, sym->ts.cl);\n-\t  type = build_pointer_type (type);\n-\n-\t  /* Return an address to a char[0:len-1]* temporary for character pointers.  */\n-\t  if (sym->attr.pointer || sym->attr.allocatable)\n-\t    {\n-\t      /* Build char[0:len-1] * pstr.  */\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n-\t\t\t\t build_int_cst (gfc_charlen_type_node, 1));\n-\t      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n-\t      tmp = build_array_type (gfc_character1_type_node, tmp);\n-\t      var = gfc_create_var (build_pointer_type (tmp), \"pstr\");\n-\n-\t      /* Provide an address expression for the function arguments.  */\n-\t      var = gfc_build_addr_expr (NULL, var);\n-\t    }\n-\t  else\n-\t    {\n-\t      var = gfc_conv_string_tmp (se, type, len);\n-\t    }\n-\t  arglist = gfc_chainon_list (arglist, var);\n-\t  arglist = gfc_chainon_list (arglist, \n-\t\t\t\t      convert (gfc_charlen_type_node, len));\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (gfc_option.flag_f2c && sym->ts.type == BT_COMPLEX);\n-\n-\t  type = gfc_get_complex_type (sym->ts.kind);\n-\t  var = gfc_build_addr_expr (NULL, gfc_create_var (type, \"cmplx\"));\n-\t  arglist = gfc_chainon_list (arglist, var);\n-\t}\n-    }\n-\n+  gfc_init_interface_mapping (&mapping);\n+  need_interface_mapping = (sym->ts.type == BT_CHARACTER\n+\t\t\t    && sym->ts.cl->length->expr_type != EXPR_CONSTANT);\n   formal = sym->formal;\n   /* Evaluate the arguments.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n@@ -1243,12 +1597,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      gfc_init_se (&parmse, NULL);\n \t      parmse.expr = null_pointer_node;\n               if (arg->missing_arg_type == BT_CHARACTER)\n-                {\n-                  stringargs =\n-\t\t    gfc_chainon_list (stringargs,\n-\t\t\t\t      convert (gfc_charlen_type_node,\n-\t\t\t\t\t       integer_zero_node));\n-                }\n+\t\tparmse.string_length = convert (gfc_charlen_type_node,\n+\t\t\t\t\t\tinteger_zero_node);\n \t    }\n \t}\n       else if (se->ss && se->ss->useflags)\n@@ -1293,6 +1643,9 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t    } \n \t}\n \n+      if (formal && need_interface_mapping)\n+\tgfc_add_interface_mapping (&mapping, formal->sym, &parmse);\n+\n       gfc_add_block_to_block (&se->pre, &parmse.pre);\n       gfc_add_block_to_block (&se->post, &parmse.post);\n \n@@ -1303,6 +1656,98 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \n       arglist = gfc_chainon_list (arglist, parmse.expr);\n     }\n+  gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n+\n+  ts = sym->ts;\n+  if (ts.type == BT_CHARACTER)\n+    {\n+      /* Calculate the length of the returned string.  */\n+      gfc_init_se (&parmse, NULL);\n+      if (need_interface_mapping)\n+\tgfc_apply_interface_mapping (&mapping, &parmse, sym->ts.cl->length);\n+      else\n+\tgfc_conv_expr (&parmse, sym->ts.cl->length);\n+      gfc_add_block_to_block (&se->pre, &parmse.pre);\n+      gfc_add_block_to_block (&se->post, &parmse.post);\n+\n+      /* Set up a charlen structure for it.  */\n+      cl.next = NULL;\n+      cl.length = NULL;\n+      cl.backend_decl = fold_convert (gfc_charlen_type_node, parmse.expr);\n+      ts.cl = &cl;\n+\n+      len = cl.backend_decl;\n+    }\n+  gfc_free_interface_mapping (&mapping);\n+\n+  byref = gfc_return_by_reference (sym);\n+  if (byref)\n+    {\n+      if (se->direct_byref)\n+\tretargs = gfc_chainon_list (retargs, se->expr);\n+      else if (sym->result->attr.dimension)\n+\t{\n+\t  gcc_assert (se->loop && info);\n+\n+\t  /* Set the type of the array.  */\n+\t  tmp = gfc_typenode_for_spec (&ts);\n+\t  info->dimen = se->loop->dimen;\n+\n+\t  /* Allocate a temporary to store the result.  */\n+\t  gfc_trans_allocate_temp_array (se->loop, info, tmp);\n+\n+\t  /* Zero the first stride to indicate a temporary.  */\n+\t  tmp = gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n+\t  gfc_add_modify_expr (&se->pre, tmp,\n+\t\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n+\n+\t  /* Pass the temporary as the first argument.  */\n+\t  tmp = info->descriptor;\n+\t  tmp = gfc_build_addr_expr (NULL, tmp);\n+\t  retargs = gfc_chainon_list (retargs, tmp);\n+\t}\n+      else if (ts.type == BT_CHARACTER)\n+\t{\n+\t  /* Pass the string length.  */\n+\t  type = gfc_get_character_type (ts.kind, ts.cl);\n+\t  type = build_pointer_type (type);\n+\n+\t  /* Return an address to a char[0:len-1]* temporary for\n+\t     character pointers.  */\n+\t  if (sym->attr.pointer || sym->attr.allocatable)\n+\t    {\n+\t      /* Build char[0:len-1] * pstr.  */\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n+\t\t\t\t build_int_cst (gfc_charlen_type_node, 1));\n+\t      tmp = build_range_type (gfc_array_index_type,\n+\t\t\t\t      gfc_index_zero_node, tmp);\n+\t      tmp = build_array_type (gfc_character1_type_node, tmp);\n+\t      var = gfc_create_var (build_pointer_type (tmp), \"pstr\");\n+\n+\t      /* Provide an address expression for the function arguments.  */\n+\t      var = gfc_build_addr_expr (NULL, var);\n+\t    }\n+\t  else\n+\t    var = gfc_conv_string_tmp (se, type, len);\n+\n+\t  retargs = gfc_chainon_list (retargs, var);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (gfc_option.flag_f2c && ts.type == BT_COMPLEX);\n+\n+\t  type = gfc_get_complex_type (ts.kind);\n+\t  var = gfc_build_addr_expr (NULL, gfc_create_var (type, \"cmplx\"));\n+\t  retargs = gfc_chainon_list (retargs, var);\n+\t}\n+\n+      /* Add the string length to the argument list.  */\n+      if (ts.type == BT_CHARACTER)\n+\tretargs = gfc_chainon_list (retargs, len);\n+    }\n+\n+  /* Add the return arguments.  */\n+  arglist = chainon (retargs, arglist);\n \n   /* Add the hidden string length parameters to the arguments.  */\n   arglist = chainon (arglist, stringargs);"}, {"sha": "9690bb5e355b857f179519192cb09530c6d2371a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -1,3 +1,15 @@\n+2005-09-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/15326\n+\t* gfortran.dg/char_result_1.f90,\n+\t* gfortran.dg/char_result_2.f90,\n+\t* gfortran.dg/char_result_3.f90,\n+\t* gfortran.dg/char_result_4.f90,\n+\t* gfortran.dg/char_result_5.f90,\n+\t* gfortran.dg/char_result_6.f90,\n+\t* gfortran.dg/char_result_7.f90,\n+\t* gfortran.dg/char_result_8.f90: New tests.\n+\n 2005-09-08  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/19928"}, {"sha": "84799e6a6c2fca32d86856fab069ca2691155bf3", "filename": "gcc/testsuite/gfortran.dg/char_result_1.f90", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_1.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,113 @@\n+! Related to PR 15326.  Try calling string functions whose lengths depend\n+! on the lengths of other strings.\n+! { dg-do run }\n+pure function double (string)\n+  character (len = *), intent (in) :: string\n+  character (len = len (string) * 2) :: double\n+  double = string // string\n+end function double\n+\n+function f1 (string)\n+  character (len = *) :: string\n+  character (len = len (string)) :: f1\n+  f1 = ''\n+end function f1\n+\n+function f2 (string1, string2)\n+  character (len = *) :: string1\n+  character (len = len (string1) - 20) :: string2\n+  character (len = len (string1) + len (string2) / 2) :: f2\n+  f2 = ''\n+end function f2\n+\n+program main\n+  implicit none\n+\n+  interface\n+    pure function double (string)\n+      character (len = *), intent (in) :: string\n+      character (len = len (string) * 2) :: double\n+    end function double\n+    function f1 (string)\n+      character (len = *) :: string\n+      character (len = len (string)) :: f1\n+    end function f1\n+    function f2 (string1, string2)\n+      character (len = *) :: string1\n+      character (len = len (string1) - 20) :: string2\n+      character (len = len (string1) + len (string2) / 2) :: f2\n+    end function f2\n+  end interface\n+\n+  integer :: a\n+  character (len = 80), target :: text\n+  character (len = 70), pointer :: textp\n+\n+  a = 42\n+  textp => text\n+\n+  call test (f1 (text), 80)\n+  call test (f2 (text, text), 110)\n+  call test (f3 (text), 115)\n+  call test (f4 (text), 192)\n+  call test (f5 (text), 160)\n+  call test (f6 (text), 39)\n+\n+  call test (f1 (textp), 70)\n+  call test (f2 (textp, text), 95)\n+  call test (f3 (textp), 105)\n+  call test (f4 (textp), 192)\n+  call test (f5 (textp), 140)\n+  call test (f6 (textp), 29)\n+\n+  call indirect (textp)\n+contains\n+  function f3 (string)\n+    integer, parameter :: l1 = 30\n+    character (len = *) :: string\n+    character (len = len (string) + l1 + 5) :: f3\n+    f3 = ''\n+  end function f3\n+\n+  function f4 (string)\n+    character (len = len (text) - 10) :: string\n+    character (len = len (string) + len (text) + a) :: f4\n+    f4 = ''\n+  end function f4\n+\n+  function f5 (string)\n+    character (len = *) :: string\n+    character (len = len (double (string))) :: f5\n+    f5 = ''\n+  end function f5\n+\n+  function f6 (string)\n+    character (len = *) :: string\n+    character (len = len (string (a:))) :: f6\n+    f6 = ''\n+  end function f6\n+\n+  subroutine indirect (text2)\n+    character (len = *) :: text2\n+\n+    call test (f1 (text), 80)\n+    call test (f2 (text, text), 110)\n+    call test (f3 (text), 115)\n+    call test (f4 (text), 192)\n+    call test (f5 (text), 160)\n+    call test (f6 (text), 39)\n+\n+    call test (f1 (text2), 70)\n+    call test (f2 (text2, text2), 95)\n+    call test (f3 (text2), 105)\n+    call test (f4 (text2), 192)\n+    call test (f5 (text2), 140)\n+    call test (f6 (text2), 29)\n+  end subroutine indirect\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "cc4a5c4e11ebb2bba2650874ecd521226fd84b39", "filename": "gcc/testsuite/gfortran.dg/char_result_2.f90", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_2.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,105 @@\n+! Like char_result_1.f90, but the string arguments are pointers.\n+! { dg-do run }\n+pure function double (string)\n+  character (len = *), intent (in) :: string\n+  character (len = len (string) * 2) :: double\n+  double = string // string\n+end function double\n+\n+function f1 (string)\n+  character (len = *), pointer :: string\n+  character (len = len (string)) :: f1\n+  f1 = ''\n+end function f1\n+\n+function f2 (string1, string2)\n+  character (len = *), pointer :: string1\n+  character (len = len (string1) - 20), pointer :: string2\n+  character (len = len (string1) + len (string2) / 2) :: f2\n+  f2 = ''\n+end function f2\n+\n+program main\n+  implicit none\n+\n+  interface\n+    pure function double (string)\n+      character (len = *), intent (in) :: string\n+      character (len = len (string) * 2) :: double\n+    end function double\n+    function f1 (string)\n+      character (len = *), pointer :: string\n+      character (len = len (string)) :: f1\n+    end function f1\n+    function f2 (string1, string2)\n+      character (len = *), pointer :: string1\n+      character (len = len (string1) - 20), pointer :: string2\n+      character (len = len (string1) + len (string2) / 2) :: f2\n+    end function f2\n+  end interface\n+\n+  integer :: a\n+  character (len = 80), target :: text\n+  character (len = 70), pointer :: textp\n+\n+  a = 42\n+  textp => text\n+\n+  call test (f1 (textp), 70)\n+  call test (f2 (textp, textp), 95)\n+  call test (f3 (textp), 105)\n+  call test (f4 (textp), 192)\n+  call test (f5 (textp), 140)\n+  call test (f6 (textp), 29)\n+\n+  call indirect (textp)\n+contains\n+  function f3 (string)\n+    integer, parameter :: l1 = 30\n+    character (len = *), pointer :: string\n+    character (len = len (string) + l1 + 5) :: f3\n+    f3 = ''\n+  end function f3\n+\n+  function f4 (string)\n+    character (len = len (text) - 10), pointer :: string\n+    character (len = len (string) + len (text) + a) :: f4\n+    f4 = ''\n+  end function f4\n+\n+  function f5 (string)\n+    character (len = *), pointer :: string\n+    character (len = len (double (string))) :: f5\n+    f5 = ''\n+  end function f5\n+\n+  function f6 (string)\n+    character (len = *), pointer :: string\n+    character (len = len (string (a:))) :: f6\n+    f6 = ''\n+  end function f6\n+\n+  subroutine indirect (textp2)\n+    character (len = 50), pointer :: textp2\n+\n+    call test (f1 (textp), 70)\n+    call test (f2 (textp, textp), 95)\n+    call test (f3 (textp), 105)\n+    call test (f4 (textp), 192)\n+    call test (f5 (textp), 140)\n+    call test (f6 (textp), 29)\n+\n+    call test (f1 (textp2), 50)\n+    call test (f2 (textp2, textp), 65)\n+    call test (f3 (textp2), 85)\n+    call test (f4 (textp2), 192)\n+    call test (f5 (textp2), 100)\n+    call test (f6 (textp2), 9)\n+  end subroutine indirect\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "8b9aa92477f92a9022e6930adddc5f1eb7cbc434", "filename": "gcc/testsuite/gfortran.dg/char_result_3.f90", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_3.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,78 @@\n+! Related to PR 15326.  Try calling string functions whose lengths involve\n+! some sort of array calculation.\n+! { dg-do run }\n+pure elemental function double (x)\n+  integer, intent (in) :: x\n+  integer :: double\n+  double = x * 2\n+end function double\n+\n+program main\n+  implicit none\n+\n+  interface\n+    pure elemental function double (x)\n+      integer, intent (in) :: x\n+      integer :: double\n+    end function double\n+  end interface\n+\n+  integer, dimension (100:104), target :: a\n+  integer, dimension (:), pointer :: ap\n+  integer :: i, lower\n+\n+  a = (/ (i + 5, i = 0, 4) /)\n+  ap => a\n+  lower = 11\n+\n+  call test (f1 (a), 35)\n+  call test (f1 (ap), 35)\n+  call test (f1 ((/ 5, 10, 50 /)), 65)\n+  call test (f1 (a (101:103)), 21)\n+\n+  call test (f2 (a), 115)\n+  call test (f2 (ap), 115)\n+  call test (f2 ((/ 5, 10, 50 /)), 119)\n+  call test (f2 (a (101:103)), 116)\n+\n+  call test (f3 (a), 60)\n+  call test (f3 (ap), 60)\n+  call test (f3 ((/ 5, 10, 50 /)), 120)\n+  call test (f3 (a (101:103)), 30)\n+\n+  call test (f4 (a, 13, 1), 21)\n+  call test (f4 (ap, 13, 2), 14)\n+  call test (f4 ((/ 5, 10, 50 /), 12, 1), 60)\n+  call test (f4 (a (101:103), 12, 1), 15)\n+contains\n+  function f1 (array)\n+    integer, dimension (10:) :: array\n+    character (len = sum (array)) :: f1\n+    f1 = ''\n+  end function f1\n+\n+  function f2 (array)\n+    integer, dimension (10:) :: array\n+    character (len = array (11) + a (104) + 100) :: f2\n+    f2 = ''\n+  end function f2\n+\n+  function f3 (array)\n+    integer, dimension (:) :: array\n+    character (len = sum (double (array (2:)))) :: f3\n+    f3 = ''\n+  end function f3\n+\n+  function f4 (array, upper, stride)\n+    integer, dimension (10:) :: array\n+    integer :: upper, stride\n+    character (len = sum (array (lower:upper:stride))) :: f4\n+    f4 = ''\n+  end function f4\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "0224f43c0b4a87a6670022e957b0c0a0df0c8549", "filename": "gcc/testsuite/gfortran.dg/char_result_4.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_4.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,62 @@\n+! Like char_result_3.f90, but the array arguments are pointers.\n+! { dg-do run }\n+pure elemental function double (x)\n+  integer, intent (in) :: x\n+  integer :: double\n+  double = x * 2\n+end function double\n+\n+program main\n+  implicit none\n+\n+  interface\n+    pure elemental function double (x)\n+      integer, intent (in) :: x\n+      integer :: double\n+    end function double\n+  end interface\n+\n+  integer, dimension (100:104), target :: a\n+  integer, dimension (:), pointer :: ap\n+  integer :: i, lower\n+\n+  a = (/ (i + 5, i = 0, 4) /)\n+  ap => a\n+  lower = 1\n+\n+  call test (f1 (ap), 35)\n+  call test (f2 (ap), 115)\n+  call test (f3 (ap), 60)\n+  call test (f4 (ap, 5, 2), 21)\n+contains\n+  function f1 (array)\n+    integer, dimension (:), pointer :: array\n+    character (len = sum (array)) :: f1\n+    f1 = ''\n+  end function f1\n+\n+  function f2 (array)\n+    integer, dimension (:), pointer :: array\n+    character (len = array (2) + a (104) + 100) :: f2\n+    f2 = ''\n+  end function f2\n+\n+  function f3 (array)\n+    integer, dimension (:), pointer :: array\n+    character (len = sum (double (array (2:)))) :: f3\n+    f3 = ''\n+  end function f3\n+\n+  function f4 (array, upper, stride)\n+    integer, dimension (:), pointer :: array\n+    integer :: upper, stride\n+    character (len = sum (array (lower:upper:stride))) :: f4\n+    f4 = ''\n+  end function f4\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "96832b3b32cd70b3c79e19fe5a954802a568cae9", "filename": "gcc/testsuite/gfortran.dg/char_result_5.f90", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_5.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,137 @@\n+! Related to PR 15326.  Test calls to string functions whose lengths\n+! depend on various types of scalar value.\n+! { dg-do run }\n+pure function select (selector, iftrue, iffalse)\n+  logical, intent (in) :: selector\n+  integer, intent (in) :: iftrue, iffalse\n+  integer :: select\n+\n+  if (selector) then\n+    select = iftrue\n+  else\n+    select = iffalse\n+  end if\n+end function select\n+\n+program main\n+  implicit none\n+\n+  interface\n+    pure function select (selector, iftrue, iffalse)\n+      logical, intent (in) :: selector\n+      integer, intent (in) :: iftrue, iffalse\n+      integer :: select\n+    end function select\n+  end interface\n+\n+  type pair\n+    integer :: left, right\n+  end type pair\n+\n+  integer, target :: i\n+  integer, pointer :: ip\n+  real, target :: r\n+  real, pointer :: rp\n+  logical, target :: l\n+  logical, pointer :: lp\n+  complex, target :: c\n+  complex, pointer :: cp\n+  character, target :: ch\n+  character, pointer :: chp\n+  type (pair), target :: p\n+  type (pair), pointer :: pp\n+\n+  character (len = 10) :: dig\n+\n+  i = 100\n+  r = 50.5\n+  l = .true.\n+  c = (10.9, 11.2)\n+  ch = '1'\n+  p%left = 40\n+  p%right = 50\n+\n+  ip => i\n+  rp => r\n+  lp => l\n+  cp => c\n+  chp => ch\n+  pp => p\n+\n+  dig = '1234567890'\n+\n+  call test (f1 (i), 200)\n+  call test (f1 (ip), 200)\n+  call test (f1 (-30), 60)\n+  call test (f1 (i / (-4)), 50)\n+\n+  call test (f2 (r), 100)\n+  call test (f2 (rp), 100)\n+  call test (f2 (70.1), 140)\n+  call test (f2 (r / 4), 24)\n+  call test (f2 (real (i)), 200)\n+\n+  call test (f3 (l), 50)\n+  call test (f3 (lp), 50)\n+  call test (f3 (.false.), 55)\n+  call test (f3 (i < 30), 55)\n+\n+  call test (f4 (c), 10)\n+  call test (f4 (cp), 10)\n+  call test (f4 (cmplx (60.0, r)), 60)\n+  call test (f4 (cmplx (r, 1.0)), 50)\n+\n+  call test (f5 (ch), 11)\n+  call test (f5 (chp), 11)\n+  call test (f5 ('23'), 12)\n+  call test (f5 (dig (3:)), 13)\n+  call test (f5 (dig (10:)), 10)\n+\n+  call test (f6 (p), 145)\n+  call test (f6 (pp), 145)\n+  call test (f6 (pair (20, 10)), 85)\n+  call test (f6 (pair (i / 2, 1)), 106)\n+contains\n+  function f1 (i)\n+    integer :: i\n+    character (len = abs (i) * 2) :: f1\n+    f1 = ''\n+  end function f1\n+\n+  function f2 (r)\n+    real :: r\n+    character (len = floor (r) * 2) :: f2\n+    f2 = ''\n+  end function f2\n+\n+  function f3 (l)\n+    logical :: l\n+    character (len = select (l, 50, 55)) :: f3\n+    f3 = ''\n+  end function f3\n+\n+  function f4 (c)\n+    complex :: c\n+    character (len = int (c)) :: f4\n+    f4 = ''\n+  end function f4\n+\n+  function f5 (c)\n+    character :: c\n+    character (len = scan ('123456789', c) + 10) :: f5\n+    f5 = ''\n+  end function f5\n+\n+  function f6 (p)\n+    type (pair) :: p\n+    integer :: i\n+    character (len = sum ((/ p%left, p%right, (i, i = 1, 10) /))) :: f6\n+    f6 = ''\n+  end function f6\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "de8e1059c28216e93d20940be15ac92363549b45", "filename": "gcc/testsuite/gfortran.dg/char_result_6.f90", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_6.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,107 @@\n+! Like char_result_5.f90, but the function arguments are pointers to scalars.\n+! { dg-do run }\n+pure function select (selector, iftrue, iffalse)\n+  logical, intent (in) :: selector\n+  integer, intent (in) :: iftrue, iffalse\n+  integer :: select\n+\n+  if (selector) then\n+    select = iftrue\n+  else\n+    select = iffalse\n+  end if\n+end function select\n+\n+program main\n+  implicit none\n+\n+  interface\n+    pure function select (selector, iftrue, iffalse)\n+      logical, intent (in) :: selector\n+      integer, intent (in) :: iftrue, iffalse\n+      integer :: select\n+    end function select\n+  end interface\n+\n+  type pair\n+    integer :: left, right\n+  end type pair\n+\n+  integer, target :: i\n+  integer, pointer :: ip\n+  real, target :: r\n+  real, pointer :: rp\n+  logical, target :: l\n+  logical, pointer :: lp\n+  complex, target :: c\n+  complex, pointer :: cp\n+  character, target :: ch\n+  character, pointer :: chp\n+  type (pair), target :: p\n+  type (pair), pointer :: pp\n+\n+  i = 100\n+  r = 50.5\n+  l = .true.\n+  c = (10.9, 11.2)\n+  ch = '1'\n+  p%left = 40\n+  p%right = 50\n+\n+  ip => i\n+  rp => r\n+  lp => l\n+  cp => c\n+  chp => ch\n+  pp => p\n+\n+  call test (f1 (ip), 200)\n+  call test (f2 (rp), 100)\n+  call test (f3 (lp), 50)\n+  call test (f4 (cp), 10)\n+  call test (f5 (chp), 11)\n+  call test (f6 (pp), 145)\n+contains\n+  function f1 (i)\n+    integer, pointer :: i\n+    character (len = abs (i) * 2) :: f1\n+    f1 = ''\n+  end function f1\n+\n+  function f2 (r)\n+    real, pointer :: r\n+    character (len = floor (r) * 2) :: f2\n+    f2 = ''\n+  end function f2\n+\n+  function f3 (l)\n+    logical, pointer :: l\n+    character (len = select (l, 50, 55)) :: f3\n+    f3 = ''\n+  end function f3\n+\n+  function f4 (c)\n+    complex, pointer :: c\n+    character (len = int (c)) :: f4\n+    f4 = ''\n+  end function f4\n+\n+  function f5 (c)\n+    character, pointer :: c\n+    character (len = scan ('123456789', c) + 10) :: f5\n+    f5 = ''\n+  end function f5\n+\n+  function f6 (p)\n+    type (pair), pointer :: p\n+    integer :: i\n+    character (len = sum ((/ p%left, p%right, (i, i = 1, 10) /))) :: f6\n+    f6 = ''\n+  end function f6\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "a037d2b268a959c01f16380786c03e99836ab2cf", "filename": "gcc/testsuite/gfortran.dg/char_result_7.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_7.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,55 @@\n+! Related to PR 15326.  Try calling string functions whose lengths depend\n+! on a dummy procedure.\n+! { dg-do run }\n+integer pure function double (x)\n+  integer, intent (in) :: x\n+  double = x * 2\n+end function double\n+\n+program main\n+  implicit none\n+\n+  interface\n+    integer pure function double (x)\n+      integer, intent (in) :: x\n+    end function double\n+  end interface\n+\n+  call test (f1 (double, 100), 200)\n+  call test (f2 (double, 70), 140)\n+\n+  call indirect (double)\n+contains\n+  function f1 (fn, i)\n+    integer :: i\n+    interface\n+      integer pure function fn (x)\n+        integer, intent (in) :: x\n+      end function fn\n+    end interface\n+    character (len = fn (i)) :: f1\n+    f1 = ''\n+  end function f1\n+\n+  function f2 (fn, i)\n+    integer :: i, fn\n+    character (len = fn (i)) :: f2\n+    f2 = ''\n+  end function f2\n+\n+  subroutine indirect (fn)\n+    interface\n+      integer pure function fn (x)\n+        integer, intent (in) :: x\n+      end function fn\n+    end interface\n+    call test (f1 (fn, 100), 200)\n+    call test (f2 (fn, 70), 140)\n+  end subroutine indirect\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}, {"sha": "b1dda89a600f082da23fc37b9a184e690121f121", "filename": "gcc/testsuite/gfortran.dg/char_result_8.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0348d6fd857a367763b2e7c59449aa545b5c8c14/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_8.f90?ref=0348d6fd857a367763b2e7c59449aa545b5c8c14", "patch": "@@ -0,0 +1,51 @@\n+! Related to PR 15326.  Compare functions that return string pointers with\n+! functions that return strings.\n+! { dg-do run }\n+program main\n+  implicit none\n+\n+  character (len = 100), target :: string\n+\n+  call test (f1 (), 30)\n+  call test (f2 (50), 50)\n+  call test (f3 (), 30)\n+  call test (f4 (70), 70)\n+\n+  call indirect (100)\n+contains\n+  function f1\n+    character (len = 30) :: f1\n+    f1 = ''\n+  end function f1\n+\n+  function f2 (i)\n+    integer :: i\n+    character (len = i) :: f2\n+    f2 = ''\n+  end function f2\n+\n+  function f3\n+    character (len = 30), pointer :: f3\n+    f3 => string\n+  end function f3\n+\n+  function f4 (i)\n+    integer :: i\n+    character (len = i), pointer :: f4\n+    f4 => string\n+  end function f4\n+\n+  subroutine indirect (i)\n+    integer :: i\n+    call test (f1 (), 30)\n+    call test (f2 (i), i)\n+    call test (f3 (), 30)\n+    call test (f4 (i), i)\n+  end subroutine indirect\n+\n+  subroutine test (string, length)\n+    character (len = *) :: string\n+    integer, intent (in) :: length\n+    if (len (string) .ne. length) call abort\n+  end subroutine test\n+end program main"}]}