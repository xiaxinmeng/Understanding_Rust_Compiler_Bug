{"sha": "152d4916efac917dd1fc64cc4950e299b54476f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyZDQ5MTZlZmFjOTE3ZGQxZmM2NGNjNDk1MGUyOTliNTQ0NzZmMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-01-24T01:05:12Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-01-24T01:05:12Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (awt_java_source_files): Added new files.\n\t* java/awt/image/AreaAveragingScaleFilter.java: New file from\n\tClasspath.\n\t* java/awt/image/CropImageFilter.java: New file from Classpath.\n\t* java/awt/image/FilteredImageSource.java: New file from\n\tClasspath.\n\t* java/awt/image/ImageFilter.java: New file from Classpath.\n\t* java/awt/image/MemoryImageSource.java: New file from Classpath.\n\t* java/awt/image/PixelGrabber.java: New file from Classpath.\n\t* java/awt/image/RGBImageFilter.java: New file from Classpath.\n\t* java/awt/image/ReplicateScaleFilter.java: New file from\n\tClasspath.\n\t* java/awt/image/ImageProducer.java: Replaced with Classpath\n\tversion.\n\t* java/awt/image/ImageObserver.java: Replaced with Classpath\n\tversion.\n\t* java/awt/image/ImageConsumer.java: Replaced with Classpath\n\tversion.\n\t* java/awt/GridBagConstraints.java (clone): Catch\n\tCloneNotSupportedException.\n\nFrom-SVN: r49157", "tree": {"sha": "3d14cc496cb398dbff3f84504e63b43a6671202f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d14cc496cb398dbff3f84504e63b43a6671202f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152d4916efac917dd1fc64cc4950e299b54476f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152d4916efac917dd1fc64cc4950e299b54476f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152d4916efac917dd1fc64cc4950e299b54476f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152d4916efac917dd1fc64cc4950e299b54476f0/comments", "author": null, "committer": null, "parents": [{"sha": "aac0eb5d465103f10c0bc8baaafc9ea4d06a9007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac0eb5d465103f10c0bc8baaafc9ea4d06a9007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac0eb5d465103f10c0bc8baaafc9ea4d06a9007"}], "stats": {"total": 1781, "additions": 1774, "deletions": 7}, "files": [{"sha": "3db9ddc0bf381685927a469fe8817330685f4bb7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -1,3 +1,27 @@\n+2002-01-23  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (awt_java_source_files): Added new files.\n+\t* java/awt/image/AreaAveragingScaleFilter.java: New file from\n+\tClasspath.\n+\t* java/awt/image/CropImageFilter.java: New file from Classpath.\n+\t* java/awt/image/FilteredImageSource.java: New file from\n+\tClasspath.\n+\t* java/awt/image/ImageFilter.java: New file from Classpath.\n+\t* java/awt/image/MemoryImageSource.java: New file from Classpath.\n+\t* java/awt/image/PixelGrabber.java: New file from Classpath.\n+\t* java/awt/image/RGBImageFilter.java: New file from Classpath.\n+\t* java/awt/image/ReplicateScaleFilter.java: New file from\n+\tClasspath.\n+\t* java/awt/image/ImageProducer.java: Replaced with Classpath\n+\tversion.\n+\t* java/awt/image/ImageObserver.java: Replaced with Classpath\n+\tversion.\n+\t* java/awt/image/ImageConsumer.java: Replaced with Classpath\n+\tversion.\n+\t* java/awt/GridBagConstraints.java (clone): Catch\n+\tCloneNotSupportedException.\n+\n 2002-01-23  Per Bothner  <per@bothner.com>\n \n \t* java/lang/reflect/natField.cc (setAddr):  New function."}, {"sha": "e93dd949b8f2a1004edb732a208bd30d519ea812", "filename": "libjava/Makefile.am", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -726,22 +726,30 @@ java/awt/geom/Point2D.java \\\n java/awt/geom/Rectangle2D.java \\\n java/awt/geom/RectangularShape.java \\\n java/awt/geom/RoundRectangle2D.java \\\n+java/awt/image/AreaAveragingScaleFilter.java \\\n java/awt/image/BufferedImage.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java\t\\\n java/awt/image/ComponentSampleModel.java \\\n+java/awt/image/CropImageFilter.java \\\n java/awt/image/DataBuffer.java \\\n java/awt/image/DataBufferByte.java \\\n java/awt/image/DataBufferInt.java \\\n java/awt/image/DataBufferUShort.java \\\n java/awt/image/DirectColorModel.java \\\n+java/awt/image/FilteredImageSource.java\t\\\n java/awt/image/ImageConsumer.java \\\n+java/awt/image/ImageFilter.java\t\\\n java/awt/image/ImageObserver.java \\\n java/awt/image/ImageProducer.java \\\n java/awt/image/IndexColorModel.java \\\n+java/awt/image/MemoryImageSource.java \\\n java/awt/image/PackedColorModel.java \\\n+java/awt/image/PixelGrabber.java \\\n+java/awt/image/RGBImageFilter.java \\\n java/awt/image/Raster.java \\\n java/awt/image/RasterOp.java \\\n+java/awt/image/ReplicateScaleFilter.java \\\n java/awt/image/SampleModel.java\t\\\n java/awt/image/SinglePixelPackedSampleModel.java \\\n java/awt/image/WritableRaster.java \\"}, {"sha": "f5757531ee43f9f1176ebbcb194dd448e00639e6", "filename": "libjava/Makefile.in", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -477,22 +477,30 @@ java/awt/geom/Point2D.java \\\n java/awt/geom/Rectangle2D.java \\\n java/awt/geom/RectangularShape.java \\\n java/awt/geom/RoundRectangle2D.java \\\n+java/awt/image/AreaAveragingScaleFilter.java \\\n java/awt/image/BufferedImage.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java\t\\\n java/awt/image/ComponentSampleModel.java \\\n+java/awt/image/CropImageFilter.java \\\n java/awt/image/DataBuffer.java \\\n java/awt/image/DataBufferByte.java \\\n java/awt/image/DataBufferInt.java \\\n java/awt/image/DataBufferUShort.java \\\n java/awt/image/DirectColorModel.java \\\n+java/awt/image/FilteredImageSource.java\t\\\n java/awt/image/ImageConsumer.java \\\n+java/awt/image/ImageFilter.java\t\\\n java/awt/image/ImageObserver.java \\\n java/awt/image/ImageProducer.java \\\n java/awt/image/IndexColorModel.java \\\n+java/awt/image/MemoryImageSource.java \\\n java/awt/image/PackedColorModel.java \\\n+java/awt/image/PixelGrabber.java \\\n+java/awt/image/RGBImageFilter.java \\\n java/awt/image/Raster.java \\\n java/awt/image/RasterOp.java \\\n+java/awt/image/ReplicateScaleFilter.java \\\n java/awt/image/SampleModel.java\t\\\n java/awt/image/SinglePixelPackedSampleModel.java \\\n java/awt/image/WritableRaster.java \\\n@@ -2070,19 +2078,27 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/geom/Rectangle2D.P \\\n .deps/java/awt/geom/RectangularShape.P \\\n .deps/java/awt/geom/RoundRectangle2D.P \\\n+.deps/java/awt/image/AreaAveragingScaleFilter.P \\\n .deps/java/awt/image/BufferedImage.P .deps/java/awt/image/ColorModel.P \\\n .deps/java/awt/image/ComponentColorModel.P \\\n .deps/java/awt/image/ComponentSampleModel.P \\\n+.deps/java/awt/image/CropImageFilter.P \\\n .deps/java/awt/image/DataBuffer.P .deps/java/awt/image/DataBufferByte.P \\\n .deps/java/awt/image/DataBufferInt.P \\\n .deps/java/awt/image/DataBufferUShort.P \\\n .deps/java/awt/image/DirectColorModel.P \\\n-.deps/java/awt/image/ImageConsumer.P \\\n+.deps/java/awt/image/FilteredImageSource.P \\\n+.deps/java/awt/image/ImageConsumer.P .deps/java/awt/image/ImageFilter.P \\\n .deps/java/awt/image/ImageObserver.P \\\n .deps/java/awt/image/ImageProducer.P \\\n .deps/java/awt/image/IndexColorModel.P \\\n-.deps/java/awt/image/PackedColorModel.P .deps/java/awt/image/Raster.P \\\n-.deps/java/awt/image/RasterOp.P .deps/java/awt/image/SampleModel.P \\\n+.deps/java/awt/image/MemoryImageSource.P \\\n+.deps/java/awt/image/PackedColorModel.P \\\n+.deps/java/awt/image/PixelGrabber.P \\\n+.deps/java/awt/image/RGBImageFilter.P .deps/java/awt/image/Raster.P \\\n+.deps/java/awt/image/RasterOp.P \\\n+.deps/java/awt/image/ReplicateScaleFilter.P \\\n+.deps/java/awt/image/SampleModel.P \\\n .deps/java/awt/image/SinglePixelPackedSampleModel.P \\\n .deps/java/awt/image/WritableRaster.P .deps/java/awt/peer/ButtonPeer.P \\\n .deps/java/awt/peer/CanvasPeer.P \\"}, {"sha": "dd72a519a8de56ac1960d23495f3743faf1f0efc", "filename": "libjava/java/awt/GridBagConstraints.java", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2FGridBagConstraints.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2FGridBagConstraints.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagConstraints.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -1,6 +1,6 @@\n // GridBagConstraints.java - Constraints for GridBag layout manager\n \n-/* Copyright (C) 2000, 2001  Free Software Foundation\n+/* Copyright (C) 2000, 2001, 2002  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -93,9 +93,17 @@ public class GridBagConstraints implements Cloneable, Serializable\n   /** Create a copy of this object.  */\n   public Object clone ()\n   {\n-    GridBagConstraints g = (GridBagConstraints) super.clone ();\n-    g.insets = (Insets) insets.clone ();\n-    return g;\n+    try\n+      {\n+\tGridBagConstraints g = (GridBagConstraints) super.clone ();\n+\tg.insets = (Insets) insets.clone ();\n+\treturn g;\n+      }\n+    catch (CloneNotSupportedException _)\n+      {\n+\t// Can't happen.\n+\treturn null;\n+      }\n   }\n \n   /** Create a new GridBagConstraints object with the default"}, {"sha": "f2e6ea54cb601a56b973c1fa01c336a59979066c", "filename": "libjava/java/awt/image/AreaAveragingScaleFilter.java", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FAreaAveragingScaleFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FAreaAveragingScaleFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FAreaAveragingScaleFilter.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,127 @@\n+/* AreaAveragingScaleFilter.java -- Java class for filtering images\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+/**\n+ * This filter should produce images which do not have image artifacts\n+ * like broken lines which were originally unbroken.  The cost is of\n+ * course speed.  Using bi-linear interpolation here against 4 pixel\n+ * points should give the desired results although Sun does not \n+ * specify what the exact algorithm should be.\n+ * <br>\n+ * Currently this filter does nothing and needs to be implemented.\n+ *\n+ * @author C. Brian Jones (cbj@gnu.org) \n+ */\n+public class AreaAveragingScaleFilter extends ReplicateScaleFilter\n+{\n+    /**\n+     * Construct an instance of <code>AreaAveragingScaleFilter</code> which\n+     * should be used in conjunction with a <code>FilteredImageSource</code>\n+     * object.\n+     * \n+     * @param width the width of the destination image\n+     * @param height the height of the destination image\n+     */\n+    public AreaAveragingScaleFilter(int width, int height) {\n+\tsuper(width, height);\n+    }\n+\n+    /**\n+     * The <code>ImageProducer</code> should call this method with a\n+     * bit mask of hints from any of <code>RANDOMPIXELORDER</code>,\n+     * <code>TOPDOWNLEFTRIGHT</code>, <code>COMPLETESCANLINES</code>,\n+     * <code>SINGLEPASS</code>, <code>SINGLEFRAME</code> from the \n+     * <code>ImageConsumer</code> interface.\n+     * <br>\n+     * FIXME - more than likely Sun's implementation desires \n+     * <code>TOPDOWNLEFTRIGHT</code> order and this method is overloaded here\n+     * in order to assure that mask is part of the hints added to\n+     * the consumer.\n+     * \n+     * @param flags a bit mask of hints\n+     * @see ImageConsumer\n+     */\n+    public void setHints(int flags)\n+    {\n+\tconsumer.setHints(flags);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as a <code>byte</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as an <code>int</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+           ColorModel model, int[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+}\n+"}, {"sha": "8ffc148b22b6e90238023e20f4609d788891e2d8", "filename": "libjava/java/awt/image/CropImageFilter.java", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FCropImageFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FCropImageFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FCropImageFilter.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,140 @@\n+/* CropImageFilter.java -- Java class for cropping image filter\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ * <br>\n+ * Currently this filter does almost nothing and needs to be implemented.\n+ *\n+ * @author C. Brian Jones (cbj@gnu.org) \n+ */\n+public class CropImageFilter extends ImageFilter\n+{\n+    int x;\n+    int y;\n+    int width;\n+    int height;\n+\n+    /**\n+     * Construct a new <code>CropImageFilter</code> instance.\n+     *\n+     * @param x the x-coordinate location of the top-left of the cropped rectangle\n+     * @param y the y-coordinate location of the top-left of the cropped rectangle\n+     * @param width the width of the cropped rectangle\n+     * @param height the height of the cropped rectangle\n+     */\n+    public CropImageFilter(int x, int y, int width, int height) {\n+\tthis.x = x;\n+\tthis.y = y;\n+\tthis.width = width;\n+\tthis.height = height;\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> indicates the size of the image\n+     * being produced using this method.  This filter overrides this\n+     * method in order to set the dimentions to the size of the\n+     * cropped rectangle instead of the size of the image.\n+     * \n+     * @param width the width of the image\n+     * @param height the height of the image \n+     */\n+    public void setDimensions(int width, int height)\n+    {\n+\tconsumer.setDimensions(this.width, this.height);\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> can set a list of properties\n+     * associated with this image by using this method.\n+     * <br>\n+     * FIXME - What property is set for this class?\n+     *\n+     * @param props the list of properties associated with this image \n+     */\n+    public void setProperties(Hashtable props)\n+    {\n+//  \tprops.put(\"filters\", \"ReplicateScaleFilter\");\n+\tconsumer.setProperties(props);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as a <code>byte</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as an <code>int</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+           ColorModel model, int[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+}\n+"}, {"sha": "8f64f897f27671426ef7c0ab8aac205fadaf4956", "filename": "libjava/java/awt/image/FilteredImageSource.java", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FFilteredImageSource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FFilteredImageSource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FFilteredImageSource.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,125 @@\n+/* FilteredImageSource.java -- Java class for providing image data \n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ *\n+ * @see ImageConsumer\n+ * @author C. Brian Jones (cbj@gnu.org) \n+ */\n+public class FilteredImageSource implements ImageProducer\n+{\n+    ImageProducer ip;\n+    ImageFilter filter;\n+    Hashtable consumers = new Hashtable();\n+\n+    /**\n+     * The given filter is applied to the given image producer\n+     * to create a new image producer.  \n+     */\n+    public FilteredImageSource(ImageProducer ip, ImageFilter filter) {\n+\tthis.ip = ip;\n+\tthis.filter = filter;\n+    }\n+\n+    /**\n+     * Used to register an <code>ImageConsumer</code> with this\n+     * <code>ImageProducer</code>.  \n+     */\n+    public synchronized void addConsumer(ImageConsumer ic) {\n+\tif (consumers.containsKey(ic))\n+\t    return;\n+\n+\tImageFilter f = filter.getFilterInstance(ic);\n+\tconsumers.put(ic, f);\n+\tip.addConsumer(f);\n+    }\n+\n+    /**\n+     * Used to determine if the given <code>ImageConsumer</code> is\n+     * already registered with this <code>ImageProducer</code>.  \n+     */\n+    public synchronized boolean isConsumer(ImageConsumer ic) {\n+\tImageFilter f = (ImageFilter)consumers.get(ic);\n+\tif (f != null)\n+\t    return ip.isConsumer(f);\n+\treturn false;\n+    }\n+\n+    /**\n+     * Used to remove an <code>ImageConsumer</code> from the list of\n+     * registered consumers for this <code>ImageProducer</code>.  \n+     */\n+    public synchronized void removeConsumer(ImageConsumer ic) {\n+\tImageFilter f = (ImageFilter)consumers.remove(ic);\n+\tif (f != null)\n+\t    ip.removeConsumer(f);\n+    }\n+\n+    /**\n+     * Used to register an <code>ImageConsumer</code> with this\n+     * <code>ImageProducer</code> and then immediately start\n+     * reconstruction of the image data to be delivered to all\n+     * registered consumers.  \n+     */\n+    public void startProduction(ImageConsumer ic) {\n+\tImageFilter f;\n+\tif (!(consumers.containsKey(ic))) {\n+\t    f = filter.getFilterInstance(ic);\n+\t    consumers.put(ic, f);\n+\t    ip.addConsumer(f);\n+\t} else { \n+\t    f = (ImageFilter)consumers.get( ic );\n+\t}\n+\tip.startProduction(f);\n+    }\n+\n+    /**\n+     * Used to register an <code>ImageConsumer</code> with this\n+     * <code>ImageProducer</code> and then request that this producer\n+     * resend the image data in the order top-down, left-right.  \n+     */\n+    public void requestTopDownLeftRightResend(ImageConsumer ic) {\n+\tImageFilter f = (ImageFilter)consumers.get(ic);\n+\tip.requestTopDownLeftRightResend(f);\n+    }\n+}\n+"}, {"sha": "b34bb7d9cd38208bcbdeeb6d8fa24a9d5c6226be", "filename": "libjava/java/awt/image/ImageFilter.java", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FImageFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FImageFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FImageFilter.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,218 @@\n+/* ImageFilter.java -- Java class for filtering images\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ * The <code>ImageFilter</code> class is a base class which can be\n+ * extended to provide different types of filters for an image.  By\n+ * default this class does nothing to an image passing through it.\n+ *\n+ * @author C. Brian Jones (cbj@gnu.org) \n+ */\n+public class ImageFilter implements ImageConsumer, Cloneable\n+{\n+    /**\n+     * The consumer this filter is filtering an image data stream for.\n+     * It is initialized in the method <code>getFilterInstance</code>.  \n+     */\n+    protected ImageConsumer consumer = null;\n+\n+    /**\n+     * The <code>ImageConsumer</code> can use this method to request\n+     * the pixels be delivered in top-down, left-right order.  \n+     * <br> \n+     * The filter can respond in three different ways.  \n+     * <ul>\n+     *   <li>The default behavior is to forward the request to the \n+     *       <code>ImageProducer</code> \n+     *       using the method <code>requestTopDownLeftRightResend</code>\n+     *       and using the filter as the consumer.</li>\n+     *   <li>The filter has the pixels and can retransmit them in the\n+     *       top-down, left-right order.</li>\n+     *   <li>The filter can do nothing when this method is called.</li>\n+     * </ul>\n+     */\n+    public void resendTopDownLeftRight(ImageProducer ip)\n+    {\n+\tip.requestTopDownLeftRightResend(this);\n+    }\n+\n+    /**\n+     * By default, returns a shallow copy of the object created by\n+     * <code>Object.clone()</code> \n+     *\n+     * @see java.lang.Object#clone ()\n+     */\n+    public Object clone() throws CloneNotSupportedException\n+    {\n+\treturn (super.clone());\n+    }\n+\n+    /**\n+     * This is the only method which can set the\n+     * <code>ImageConsumer</code> for this filter.  By default a clone\n+     * of this filter with the appropriate consumer set is returned.  \n+     *\n+     * @see #clone ()\n+     */\n+    public ImageFilter getFilterInstance(ImageConsumer ic)\n+    {\n+\tif ( ic == null )\n+\t    throw new IllegalArgumentException(\"null argument for ImageFilter.getFilterInstance(ImageConsumer)\");\n+\n+\tconsumer = ic;\n+\ttry { \n+\t    ImageFilter f = (ImageFilter)clone();\n+\t    consumer = null;\n+\t    return f;\n+\t} catch ( CloneNotSupportedException cnse ) {\n+\t    cnse.printStackTrace();\n+\t    consumer = null;\n+\t    return null;\n+\t}\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> indicates the size of the image\n+     * being produced using this method.  A filter can override this \n+     * method to intercept these calls from the producer in order to\n+     * change either the width or the height before in turn calling\n+     * the consumer's <code>setDimensions</code> method.\n+     * \n+     * @param width the width of the image\n+     * @param height the height of the image \n+     */\n+    public void setDimensions(int width, int height)\n+    {\n+\tconsumer.setDimensions(width, height);\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> can set a list of properties\n+     * associated with this image by using this method.\n+     *\n+     * @param props the list of properties associated with this image \n+     */\n+    public void setProperties(Hashtable props)\n+    {\n+\tprops.put(\"filters\", \"ImageFilter\");\n+\tconsumer.setProperties(props);\n+    }\n+\n+    /**\n+     * Override this method to process calls to this method from the\n+     * <code>ImageProducer</code>.  By default the <code>setColorModel</code>\n+     * method of the consumer is called with the specified <code>model</code>.\n+     *\n+     * @param model the color model to be used most often by setPixels\n+     * @see ColorModel */\n+    public void setColorModel(ColorModel model)\n+    {\n+\tconsumer.setColorModel(model);\n+    }\n+\n+    /**\n+     * The <code>ImageProducer</code> should call this method with a\n+     * bit mask of hints from any of <code>RANDOMPIXELORDER</code>,\n+     * <code>TOPDOWNLEFTRIGHT</code>, <code>COMPLETESCANLINES</code>,\n+     * <code>SINGLEPASS</code>, <code>SINGLEFRAME</code> from the \n+     * <code>ImageConsumer</code> interface.\n+     * \n+     * @param flags a bit mask of hints\n+     * @see ImageConsumer\n+     */\n+    public void setHints(int flags)\n+    {\n+\tconsumer.setHints(flags);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as a <code>byte</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as an <code>int</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+           ColorModel model, int[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+    /**\n+     * The <code>ImageProducer</code> calls this method to indicate a\n+     * single frame or the entire image is complete.  The method is\n+     * also used to indicate an error in loading or producing the\n+     * image.  \n+     */\n+    public void imageComplete(int status)\n+    {\n+\tconsumer.imageComplete(status);\n+    }\n+}\n+"}, {"sha": "fce112a0656006a3299f4e0e24e3993e5ff44bd8", "filename": "libjava/java/awt/image/MemoryImageSource.java", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,333 @@\n+/* MemoryImageSource.java -- Java class for providing image data \n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+import java.awt.Image;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+\n+public class MemoryImageSource implements ImageProducer \n+{\n+    private boolean animated = false;\n+    private boolean fullbuffers = false;\n+    private int pixeli[], width, height, offset, scansize;\n+    private byte pixelb[];\n+    private ColorModel cm;\n+    private Hashtable props, consumers = new Hashtable();\n+\n+    /**\n+       Constructs an ImageProducer from memory\n+    */\n+    public MemoryImageSource(int w, int h, ColorModel cm,\n+\t\t\t     byte pix[], int off, int scan)\n+    {\n+\tthis ( w, h, cm, pix, off, scan, null );\n+    }\n+    /**\n+       Constructs an ImageProducer from memory\n+    */\n+    public MemoryImageSource( int w, int h, ColorModel cm,\n+\t\t\t      byte pix[], int off, int scan,\n+\t\t\t      Hashtable props)\n+    {\n+\twidth = w;\n+\theight = h;\n+\tthis.cm = cm;\n+\toffset = off;\n+\tscansize = scan;\n+\tthis.props = props;\n+\tint max = (( scansize > width ) ? scansize : width );\n+\tpixelb = new byte[ max  * height ];\n+\tSystem.arraycopy( pix, 0, pixelb, 0, max );\n+    }\n+    /**\n+       Constructs an ImageProducer from memory\n+    */\n+    public MemoryImageSource(int w, int h, ColorModel cm,\n+\t\t\t     int pix[], int off, int scan)\n+    {\n+\tthis ( w, h, cm, pix, off, scan, null );\n+    }\n+\n+    /**\n+       Constructs an ImageProducer from memory\n+    */\n+    public MemoryImageSource(int w, int h, ColorModel cm,\n+\t\t\t     int pix[], int off, int scan,\n+\t\t\t     Hashtable props)\n+    {\n+\twidth = w;\n+\theight = h;\n+\tthis.cm = cm;\n+\toffset = off;\n+\tscansize = scan;\n+\tthis.props = props;\n+\tint max = (( scansize > width ) ? scansize : width );\n+\tpixeli = new int[ max  * height ];\n+\tSystem.arraycopy( pix, 0, pixeli, 0, max );\n+    }\n+    /**\n+       Constructs an ImageProducer from memory using the default RGB ColorModel\n+    */\n+    public MemoryImageSource(int w, int h,\n+\t\t\t     int pix[], int off, int scan,\n+\t\t\t     Hashtable props)\n+    {\n+\tthis ( w, h, ColorModel.getRGBdefault(), pix, off, scan, props);\n+    }\n+\n+    /**\n+       Constructs an ImageProducer from memory using the default RGB ColorModel\n+    */\n+    public MemoryImageSource(int w, int h,\n+\t\t\t     byte pix[], int off, int scan)\n+    {\n+\tthis ( w, h, ColorModel.getRGBdefault(), pix, off, scan, null);\n+    }\n+\n+    /**\n+     * Used to register an <code>ImageConsumer</code> with this\n+     * <code>ImageProducer</code>.  \n+     */\n+    public synchronized void addConsumer(ImageConsumer ic) {\n+\tif (consumers.containsKey(ic))\n+\t    return;\n+\n+\tconsumers.put(ic, ic);\n+    }\n+\n+    /**\n+     * Used to determine if the given <code>ImageConsumer</code> is\n+     * already registered with this <code>ImageProducer</code>.  \n+     */\n+    public synchronized boolean isConsumer(ImageConsumer ic) {\n+\tif (consumers.containsKey(ic))\n+\t    return true;\n+\treturn false;\n+    }\n+\n+    /**\n+     * Used to remove an <code>ImageConsumer</code> from the list of\n+     * registered consumers for this <code>ImageProducer</code>.  \n+     */\n+    public synchronized void removeConsumer(ImageConsumer ic) {\n+\tconsumers.remove(ic);\n+    }\n+\n+    /**\n+     * Used to register an <code>ImageConsumer</code> with this\n+     * <code>ImageProducer</code> and then immediately start\n+     * reconstruction of the image data to be delivered to all\n+     * registered consumers.  \n+     */\n+    public void startProduction(ImageConsumer ic) {\n+\tif (!(consumers.containsKey(ic))) {\n+\t    consumers.put(ic, ic);\n+\t}        \n+\tEnumeration e = consumers.elements();\n+\tfor( ; e.hasMoreElements(); ) {\n+\t\tic = (ImageConsumer)e.nextElement();\n+\t\tsendPicture( ic );\n+\t\tic.imageComplete( ImageConsumer.SINGLEFRAME );\n+\t    }\t\n+\n+    }\n+\n+    /**\n+     * Used to register an <code>ImageConsumer</code> with this\n+     * <code>ImageProducer</code> and then request that this producer\n+     * resend the image data in the order top-down, left-right.  \n+     */\n+    public void requestTopDownLeftRightResend(ImageConsumer ic) {\n+\tstartProduction ( ic );\n+    }\n+\n+\n+    /**\n+       Changes a flag to indicate whether this MemoryImageSource supports\n+       animations.\n+\n+       @param animated A flag indicating whether this class supports animations\n+     */    \n+    public synchronized void setAnimated(boolean animated)\n+    {\n+\tthis.animated = animated;\n+    }\n+\n+\n+    /**\n+       A flag to indicate whether or not to send full buffer updates when\n+       sending animation. If this flag is set then full buffers are sent\n+       in the newPixels methods instead of just regions.\n+\n+       @param fullbuffers - a flag indicating whether to send the full buffers \n+     */\n+    public synchronized void setFullBufferUpdates(boolean fullbuffers)\n+    {\n+\tthis.fullbuffers = fullbuffers;\n+    }\n+\n+    /**\n+       Send an animation frame to the image consumers.\n+     */\n+    public void newPixels()\n+    {\n+\tif( animated == true ) {\n+\t\tImageConsumer ic;\n+\t\tEnumeration e = consumers.elements();\n+\t\tfor( ; e.hasMoreElements(); ) {\n+\t\t\tic = (ImageConsumer)e.nextElement();\n+\t\t\tsendPicture( ic );\n+\t\t\tic.imageComplete( ImageConsumer.SINGLEFRAME );\n+\t\t    }\t\n+\t    }\n+    }\n+\n+    \n+    private void sendPicture ( ImageConsumer ic )\n+    {\n+\tic.setHints( ImageConsumer.TOPDOWNLEFTRIGHT );\n+\tif( props != null ) {\n+\t    ic.setProperties( props );\n+\t}\n+\tif( pixeli != null ) {\n+\t    ic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n+\t} else {\n+\t    ic.setPixels( 0, 0, width, height, cm, pixelb, offset, scansize );\n+\t}\n+    }\n+\n+    /**\n+       Send an animation frame to the image consumers containing the specified\n+       pixels unless setFullBufferUpdates is set.\n+     */\n+    public synchronized void newPixels(int x,\n+\t\t\t\t       int y,\n+\t\t\t\t       int w,\n+\t\t\t\t       int h)\n+    {\n+\tif( animated == true )\n+\t    {\n+\t\tif( fullbuffers ) {\n+\t\t    newPixels();\n+\t\t} else {\n+\t\t    ImageConsumer ic;\n+\t\t    Enumeration e = consumers.elements();\n+\t\t    for( ; e.hasMoreElements(); ) {\n+\t\t\t    ic = (ImageConsumer)e.nextElement();\n+\t\t\t    ic.setHints( ImageConsumer.TOPDOWNLEFTRIGHT );\n+\t\t\t    if( props != null ) {\n+\t\t\t\tic.setProperties( props );\n+\t\t\t    }\n+\t\t\t    if( pixeli != null ) {\n+\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n+\t\t\t    } else {\n+\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixelb, offset, scansize );\n+\t\t\t    }\n+\t\t\t    ic.imageComplete( ImageConsumer.SINGLEFRAME );\n+\t\t    }\n+\t\t}     \n+\t    }\n+    }\n+\n+\n+\n+    /**\n+       Send an animation frame to the image consumers containing the specified\n+       pixels unless setFullBufferUpdates is set.\n+\n+       If framenotify is set then a notification is sent when the frame \n+       is sent otherwise no status is sent.\n+     */\n+    public synchronized void newPixels(int x,\n+\t\t\t\t       int y,\n+\t\t\t\t       int w,\n+\t\t\t\t       int h,\n+\t\t\t\t       boolean framenotify)\n+    {\n+\tif( animated == true )\n+\t    {\n+\t\tif( fullbuffers ) {\n+\t\t    newPixels();\n+\t\t} else {\n+\t\t    ImageConsumer ic;\n+\t\t    Enumeration e = consumers.elements();\n+\t\t    for( ; e.hasMoreElements(); ) {\n+\t\t\t    ic = (ImageConsumer)e.nextElement();\n+\t\t\t    ic.setHints( ImageConsumer.TOPDOWNLEFTRIGHT );\n+\t\t\t    if( props != null ) {\n+\t\t\t\tic.setProperties( props );\n+\t\t\t    }\n+\t\t\t    if( pixeli != null ) {\n+\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n+\t\t\t    } else {\n+\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixelb, offset, scansize );\n+\t\t\t    }\n+\t\t\t    if( framenotify == true )\n+\t\t\t\tic.imageComplete( ImageConsumer.SINGLEFRAME );\n+\t\t    }\n+\t\t}     \n+\t    }\n+    }\n+\n+    public synchronized void newPixels(byte newpix[],\n+\t\t\t\t       ColorModel newmodel,\n+\t\t\t\t       int offset,\n+\t\t\t\t       int scansize)\n+\n+    {\n+\tif( animated == true )\n+\t    {\n+\t\t//FIXME\n+\t    }\n+    }\n+\n+    public synchronized void newPixels(int newpix[],\n+\t\t\t\t       ColorModel newmodel,\n+\t\t\t\t       int offset,\n+\t\t\t\t       int scansize)\n+\n+    {\n+\tif( animated == true )\n+\t    {\n+\t\t//FIXME\n+\t    }\n+    }\n+\n+}"}, {"sha": "efa98856ca32591ac181c8163ece575fa34b47c9", "filename": "libjava/java/awt/image/PixelGrabber.java", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FPixelGrabber.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FPixelGrabber.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FPixelGrabber.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,361 @@\n+/* PixelGrabber.java -- Java class for providing image data \n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+import java.awt.Image;\n+import java.util.Hashtable;\n+\n+/**\n+   PixelGrabber is an ImageConsumer designed to extract a rectangular region of pixels\n+   from an Image\n+ */\n+public class PixelGrabber implements ImageConsumer \n+{\n+    int x, y, width, height, status, scansize, offset;\n+    ColorModel model = ColorModel.getRGBdefault();\n+    //int hints;\n+    //Hashtable props;\n+    int pixel_bufferi[];\n+    byte pixel_bufferb[];\n+    boolean grabbing;\n+    ImageProducer ip;\n+\n+    /**\n+     * Create a PixelGrabber used to grab pixels from the specified Image \n+     * in the specified rectangle\n+     *\n+     * @param img the Image to grab pixels from\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public PixelGrabber(Image img, int x, int y, int w, int h,\n+\t\t\tint pix[], int off, int scansize)\n+    {\n+\tthis( img.getSource(), x, y, w, h, pix, off, scansize );\n+    }\n+\n+    /**\n+     * Create a PixelGrabber used to grab pixels from the specified ImageProducer\n+     * in the specified rectangle\n+     *\n+     * @param ip the ImageProducer to grab pixels from\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public PixelGrabber(ImageProducer ip, int x, int y, int w, int h,\n+\t\t\tint pix[], int off, int scansize)\n+    {\n+\tthis.ip = ip;\n+\tthis.x = x;\n+\tthis.y = y;\n+\tthis.width = w;\n+\tthis.height = h;\n+\tthis.pixel_bufferi = pix;\n+\tthis.offset = off;\n+\tthis.scansize = scansize;\n+\tpixel_bufferb = new byte[pix.length * 4];\n+    }\n+\n+\n+    /**\n+     * Create a PixelGrabber used to grab pixels from the specified Image \n+     * in the specified rectangle\n+     *\n+     * @param img the Image to grab pixels from\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param forceRGB true to force conversion to RGB\n+     */\n+    public PixelGrabber(Image img,\n+\t\t\tint x, int y,\n+\t\t\tint w, int h,\n+\t\t\tboolean forceRGB)\n+    {\n+\t//FIXME\n+    }\n+\n+    /**\n+       Start Grabbing Pixels\n+     */\n+    public synchronized void startGrabbing()\n+    {\n+\tif ( grabbing == false )\n+\t    {\n+\t\tgrabbing = true;\n+\t\tip.startProduction( this );\n+\t    }\n+    }\n+\n+    /**\n+       Abort the grabbing of pixels\n+     */\n+    public synchronized void abortGrabbing()\n+    {\n+\tif ( grabbing == true )\n+\t    {\n+\t\tgrabbing = false;\n+\t\tip.removeConsumer( this );\n+\t    }\n+    }\n+\n+    /**\n+       Grab the Pixels.\n+\n+       @return true if successful\n+\n+       @throws InterruptedExcpetion if interrupted by another thread.\n+     */\n+    public boolean grabPixels() throws InterruptedException\n+    {\n+\tstartGrabbing();\n+\twhile ( (status != ImageObserver.ALLBITS ) ||\n+\t\t(status != ImageObserver.ERROR ) ||\n+\t\t(status != ImageObserver.ABORT ) );\n+\n+\tif( status == ImageObserver.ALLBITS )\n+\t    return true;\n+\telse\n+\t    return false;\n+    }\n+\n+    /**\n+       Grab the Pixels and abort if it takes too long\n+\n+       @return true if successful\n+\n+       @throws InterruptedExcpetion if interrupted by another thread.\n+               or time runs out\n+     */\n+    public synchronized boolean grabPixels(long ms) throws InterruptedException\n+    {\n+\tlong start = System.currentTimeMillis();\n+\tstartGrabbing();\n+\twhile ( (status != ImageObserver.ALLBITS ) ||\n+\t\t(status != ImageObserver.ERROR ) ||\n+\t\t(status != ImageObserver.ABORT ) )\n+\t    {\n+\t\tif( (System.currentTimeMillis() - start ) >= ms )\n+\t\t    {\n+\t\t\tabortGrabbing();\n+\t\t\tthrow new InterruptedException();\n+\t\t    }\n+\t    }\n+\n+\tif( status == ImageObserver.ALLBITS )\n+\t    return true;\n+\telse\n+\t    return false;\n+\t\n+    }\n+\n+    /**\n+       Get the status of the pixel grabbing representing by ImageObserver flags\n+\n+       @return the status\n+    */\n+    public synchronized int getStatus()\n+    {\n+\treturn status;\n+    }\n+\n+    /**\n+       Return width of pixel region\n+\n+       @return width of region\n+    */\n+    public synchronized int getWidth()\n+    {\n+\treturn width;\n+    }\n+\n+    /**\n+       Return height of pixel region\n+       \n+       @return height of region\n+    */\n+    public synchronized int getHeight()\n+    {\n+\treturn height;\n+    }\n+\n+    /**\n+       Returns the grabbed pixel buffer \n+\n+       @return a byte or int array\n+    */\n+    public synchronized Object getPixels()\n+    {\n+\tif( pixel_bufferi != null )\n+\t    return pixel_bufferi;\n+\treturn pixel_bufferb;\n+    }\n+\n+    /**\n+       Get the ColorModel of the image\n+       \n+       @return the ColorModel\n+    */\n+    public synchronized ColorModel getColorModel()\n+    {\n+\treturn model;\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> indicates the size of the image\n+     * being produced using this method.\n+     * \n+     * @param width the width of the image\n+     * @param height the height of the image \n+     */\n+    public  void setDimensions(int width, int height)\n+    {\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> can set a list of properties\n+     * associated with this image by using this method.\n+     *\n+     * @param props the list of properties associated with this image \n+     */\n+    public  void setProperties(Hashtable props)\n+    {\n+\t//this.props = props; //FIXME - DO WE NEED THIS\n+    }\n+\n+    /**\n+     * This <code>ColorModel</code> should indicate the model used by\n+     * the majority of calls to <code>setPixels</code>.  Each call to\n+     * <code>setPixels</code> could however indicate a different\n+     * <code>ColorModel</code>.\n+     *\n+     * @param model the color model to be used most often by setPixels\n+     * @see ColorModel \n+     */\n+    public  void setColorModel(ColorModel model)\n+    {\n+\tthis.model = model;\n+    }\n+\n+    /**\n+     * The <code>ImageProducer</code> should call this method with a\n+     * bit mask of hints from any of <code>RANDOMPIXELORDER</code>,\n+     * <code>TOPDOWNLEFTRIGHT</code>, <code>COMPLETESCANLINES</code>,\n+     * <code>SINGLEPASS</code>, <code>SINGLEFRAME</code>.\n+     * \n+     * @param flags a bit mask of hints\n+     */\n+    public  void setHints(int flags)\n+    {\n+\t//hints = flags; // FIXME - DO NOT KNOW WHAT TO DO WITH THE HINTS\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as a <code>byte</code> at\n+     * index (n * scansize + m + offset).  \n+     */\n+    public  void setPixels(int x, int y, int w, int h, \n+\t\t\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+    {\n+\t//FIXME - I hate bytes\n+\tint xp, yp;\n+\tfor( xp = x; xp < ( x + w); xp++ )\n+\t    for( yp = y; yp < (y + h); yp++ )\n+\t\tif( xp >= this.x && \n+\t\t    yp >= this.y && \n+\t\t    xp <= ( this.x + this.width ) && \n+\t\t    yp <= ( this.y + this.height ) ) {\n+\t\t    pixel_bufferb[(yp - this.y) * this.scansize + (xp - this.x) + this.offset] =\n+\t\t\tpixels[ offset + yp * scansize + xp ];\n+\t\t}\n+\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as an <code>int</code> at\n+     * index (n * scansize + m + offset).  \n+     */\n+    public  void setPixels(int x, int y, int w, int h, \n+\t\t\t   ColorModel model, int[] pixels, int offset, int scansize)\n+    {\n+\tint xp, yp;\n+\tfor( xp = x; xp < ( x + w); xp++ )\n+\t    for( yp = y; yp < (y + h); yp++ )\n+\t\tif( xp >= this.x && \n+\t\t    yp >= this.y && \n+\t\t    xp <= ( this.x + this.width ) && \n+\t\t    yp <= ( this.y + this.height ) ) {\n+\t\t    pixel_bufferi[(yp - this.y) * this.scansize + (xp - this.x) + this.offset] =\n+\t\t\tpixels[ offset + yp * scansize + xp ];\n+\t\t}\n+    }\n+\n+    /**\n+     * The <code>ImageProducer</code> calls this method to indicate a\n+     * single frame or the entire image is complete.  The method is\n+     * also used to indicate an error in loading or producing the\n+     * image.  \n+     */\n+    public synchronized void imageComplete(int status)\n+    {\n+\tthis.status = status;\n+    }\n+\n+    /**\n+       @deprecated by getStatus\n+    */\n+    public synchronized int status()\n+    {\n+\treturn getStatus();\n+    }\n+\n+}"}, {"sha": "f682cd8b959c30abca148ebcb014d672091bd4e0", "filename": "libjava/java/awt/image/RGBImageFilter.java", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,244 @@\n+/* RGBImageFilter.java -- Java class for filtering Pixels by RGB values\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+/**\n+ * A filter designed to filter images in the default RGBColorModel regardless of \n+ * the ImageProducer's ColorModel.\n+ *\n+ * @author Mark Benvenuto <mcb54@columbia.edu>\n+ */\n+public abstract class RGBImageFilter extends ImageFilter\n+{\n+    protected ColorModel origmodel = ColorModel.getRGBdefault();\n+\n+    protected ColorModel newmodel;\n+    \n+    /**\n+       Specifies whether to apply the filter to the index entries of the \n+       IndexColorModel. Subclasses should set this to true if the filter \n+       does not depend on the pixel's coordinate.\n+     */\n+    protected boolean canFilterIndexColorModel = false;\n+\n+    /**\n+       Construct new RGBImageFilter.\n+     */\n+    public RGBImageFilter() \n+    {\n+    }\n+\n+    /**\n+     * Sets the ColorModel used to filter with. If the specified ColorModel is IndexColorModel \n+     * and canFilterIndexColorModel is true, we subsitute the ColorModel for a filtered one\n+     * here and in setPixels whenever the original one appears. Otherwise overrides the default\n+     * ColorModel of ImageProducer and specifies the default RGBColorModel\n+     *\n+     * @param model the color model to be used most often by setPixels\n+     * @see ColorModel */\n+    public void setColorModel(ColorModel model) \n+    {\n+\torigmodel = model;\n+\tnewmodel = model;\n+\n+\tif( ( model instanceof IndexColorModel) && canFilterIndexColorModel  ) {\n+\t\tnewmodel = filterIndexColorModel( (IndexColorModel) model );\n+\t    }\n+    }\n+    \n+    /**\n+       Registers a new ColorModel to subsitute for the old ColorModel when \n+       setPixels encounters the a pixel with the old ColorModel. The pixel \n+       remains unchanged except for a new ColorModel.\n+       \n+       @param oldcm the old ColorModel\n+       @param newcm the new ColorModel\n+     */\n+    public void substituteColorModel(ColorModel oldcm,\n+\t\t\t\t     ColorModel newcm)\n+    {\n+\torigmodel = oldcm;\n+\tnewmodel = newcm;\n+    }\n+\n+    /**\n+       Filters an IndexColorModel through the filterRGB function. Uses\n+       coordinates of -1 to indicate its filtering an index and not a pixel.\n+\n+       @param icm an IndexColorModel to filter\n+     */\n+    public IndexColorModel filterIndexColorModel(IndexColorModel icm) \n+    {\n+\tint len = icm.getMapSize(), rgb;\n+\tbyte reds[] = new byte[len], greens[] = new byte[len], blues[] = new byte[len], alphas[]  = new byte[len];\n+\t\n+\ticm.getAlphas( alphas );\n+\ticm.getReds( reds );\n+\ticm.getGreens( greens );\n+\ticm.getBlues( blues );\n+\n+\tfor( int i = 0; i < len; i++ )\n+\t    {\n+\t\trgb = filterRGB( -1, -1, makeColor ( alphas[i], reds[i], greens[i], blues[i] ) );\n+\t\talphas[i] = (byte)(( 0xff000000 & rgb ) >> 24);\n+\t\treds[i] = (byte)(( 0xff0000 & rgb ) >> 16);\n+\t\tgreens[i] = (byte)(( 0xff00 & rgb ) >> 8);\n+\t\tblues[i] = (byte)(0xff & rgb);\n+\t    }\n+\treturn new IndexColorModel( icm.getPixelSize(), len, reds, greens, blues, alphas );\n+    }\n+\n+    private int makeColor( byte a, byte r, byte g, byte b )\n+    {\n+\treturn ( 0xff000000 & (a << 24) | 0xff0000 & (r << 16) | 0xff00 & (b << 8) | 0xff & g ); \n+    }\n+\n+    /**\n+       This functions filters a set of RGB pixels through filterRGB.\n+\n+       @param x the x coordinate of the rectangle\n+       @param y the y coordinate of the rectangle\n+       @param w the width of the rectangle\n+       @param h the height of the rectangle\n+       @param model the <code>ColorModel</code> used to translate the pixels\n+       @param pixels the array of pixel values\n+       @param offset the index of the first pixels in the <code>pixels</code> array\n+       @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+    */\n+    public void filterRGBPixels(int x,\n+\t\t\t\tint y,\n+\t\t\t\tint w,\n+\t\t\t\tint h,\n+\t\t\t\tint[] pixels,\n+\t\t\t\tint off,\n+\t\t\t\tint scansize)\n+    {\n+\tint xp, yp, i;\n+\n+\tfor( xp = x; xp < ( x + w); xp++ )\n+\t    for( yp = y; yp < (y + h); yp++ )\n+\t\t pixels[ off + yp * scansize + xp ] = filterRGB( xp, yp, pixels[ off + yp * scansize + xp ] );\n+    }\n+\n+\n+    /**\n+     * If the ColorModel is the same ColorModel which as already converted \n+     * then it converts it the converted ColorModel. Otherwise it passes the \n+     * array of pixels through filterRGBpixels.\n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+    {\n+\tif( model == origmodel ) {\n+\t    consumer.setPixels(x, y, w, h, newmodel, pixels, offset, scansize);\n+\t} else {\n+\t    //FIXME\n+\t    //convert to proper CM\n+\t    int pixelsi[] = new int[ pixels.length / 4 ];\n+\t    filterRGBPixels( x, y, w, h, pixelsi, offset, scansize );\n+\t}\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as an <code>int</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+           ColorModel model, int[] pixels, int offset, int scansize)\n+    {\n+\tif( model == origmodel ) {\n+\t    consumer.setPixels(x, y, w, h, newmodel, pixels, offset, scansize);\n+\t} else {\n+\t    convertColorModelToDefault( x, y, w, h, model, pixels, offset, scansize );\n+\t    filterRGBPixels( x, y, w, h, pixels, offset, scansize );\n+\t}\n+    }\n+\n+    private void convertColorModelToDefault( int x, int y, int w, int h, \n+\t    ColorModel model, int pixels[], int offset, int scansize)\n+\t{\n+\tint xp, yp, i;\n+\n+\tfor( xp = x; xp < ( x + w); xp++ )\n+\t    for( yp = y; yp < (y + h); yp++ )\n+\t\t pixels[ offset + yp * scansize + xp ] =  makeColorbyDefaultCM( pixels[ offset + yp * scansize + xp ] );\n+\t    \n+\t}\n+    private int makeColorbyDefaultCM( int rgb ) \n+\t{\n+\t    return makeColor( origmodel.getRed( rgb ), origmodel.getGreen( rgb ), origmodel.getGreen( rgb ), origmodel.getBlue( rgb ) );\n+\t}\n+\n+\n+    private int makeColor( int a, int r, int g, int b )\n+    {\n+\treturn (int)( 0xff000000 & (a << 24) | 0xff0000 & (r << 16) | 0xff00 & (b << 8) | 0xff & g ); \n+    }\n+\n+\n+    /**\n+       Filters a single pixel from the default ColorModel.\n+\n+       @param x x-coordinate\n+       @param y y-coordinate\n+       @param rgb color\n+     */\n+    public abstract int filterRGB(int x,\n+\t\t\t\t  int y,\n+\t\t\t\t  int rgb);\n+}"}, {"sha": "97992e8f2a21ae1c95b8a83e4221a0ce1ce79b5d", "filename": "libjava/java/awt/image/ReplicateScaleFilter.java", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FReplicateScaleFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d4916efac917dd1fc64cc4950e299b54476f0/libjava%2Fjava%2Fawt%2Fimage%2FReplicateScaleFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FReplicateScaleFilter.java?ref=152d4916efac917dd1fc64cc4950e299b54476f0", "patch": "@@ -0,0 +1,163 @@\n+/* ReplicateScaleFilter.java -- Java class for filtering images\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ * This filter should be used for fast scaling of images where the result\n+ * does not need to ensure straight lines are still straight, etc.  The\n+ * exact method is not defined by Sun but some sort of fast Box filter should\n+ * probably be correct.\n+ * <br>\n+ * Currently this filter does nothing and needs to be implemented.\n+ *\n+ * @author C. Brian Jones (cbj@gnu.org) \n+ */\n+public class ReplicateScaleFilter extends ImageFilter\n+{\n+    public ReplicateScaleFilter(int width, int height) {\n+\tdestHeight = height;\n+\tdestWidth = width;\n+    }\n+\n+    /**\n+     * The height of the destination image.\n+     */\n+    protected int destHeight;\n+\n+    /**\n+     * The width of the destination image.\n+     */\n+    protected int destWidth;\n+\n+    /**\n+     * The height of the source image.\n+     */\n+    protected int srcHeight;\n+\n+    /**\n+     * The width of the source image.\n+     */\n+    protected int srcWidth;\n+\n+    /**\n+     *\n+     */\n+    protected int srcrows[];\n+\n+    /**\n+     *\n+     */\n+    protected int srccols[];\n+\n+    /**\n+     *\n+     */\n+    protected Object outpixbuf;\n+\n+    /**\n+     * An <code>ImageProducer</code> indicates the size of the image\n+     * being produced using this method.  A filter can override this \n+     * method to intercept these calls from the producer in order to\n+     * change either the width or the height before in turn calling\n+     * the consumer's <code>setDimensions</code> method.\n+     * \n+     * @param width the width of the image\n+     * @param height the height of the image \n+     */\n+    public void setDimensions(int width, int height)\n+    {\n+\tconsumer.setDimensions(width, height);\n+    }\n+\n+    /**\n+     * An <code>ImageProducer</code> can set a list of properties\n+     * associated with this image by using this method.\n+     *\n+     * @param props the list of properties associated with this image \n+     */\n+    public void setProperties(Hashtable props)\n+    {\n+\tprops.put(\"filters\", \"ReplicateScaleFilter\");\n+\tconsumer.setProperties(props);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as a <code>byte</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+    /**\n+     * This function delivers a rectangle of pixels where any\n+     * pixel(m,n) is stored in the array as an <code>int</code> at\n+     * index (n * scansize + m + offset).  \n+     *\n+     * @param x the x coordinate of the rectangle\n+     * @param y the y coordinate of the rectangle\n+     * @param w the width of the rectangle\n+     * @param h the height of the rectangle\n+     * @param model the <code>ColorModel</code> used to translate the pixels\n+     * @param pixels the array of pixel values\n+     * @param offset the index of the first pixels in the <code>pixels</code> array\n+     * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n+     */\n+    public void setPixels(int x, int y, int w, int h, \n+           ColorModel model, int[] pixels, int offset, int scansize)\n+    {\n+\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+    }\n+\n+}\n+"}]}