{"sha": "fb0e7ec09f246a5211b3490753989a3e5e78c481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwZTdlYzA5ZjI0NmE1MjExYjM0OTA3NTM5ODlhM2U1ZTc4YzQ4MQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2004-05-15T21:36:01Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2004-05-15T21:36:01Z"}, "message": "* doc/cni.sgml: Removed, merged into gcj.texi.\n\nFrom-SVN: r81906", "tree": {"sha": "e976cf1209903ea116897bbb77eb628a83f46f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e976cf1209903ea116897bbb77eb628a83f46f2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb0e7ec09f246a5211b3490753989a3e5e78c481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0e7ec09f246a5211b3490753989a3e5e78c481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0e7ec09f246a5211b3490753989a3e5e78c481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0e7ec09f246a5211b3490753989a3e5e78c481/comments", "author": null, "committer": null, "parents": [{"sha": "909087e0cfa28372c9aca47a86aa51af91b12684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909087e0cfa28372c9aca47a86aa51af91b12684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/909087e0cfa28372c9aca47a86aa51af91b12684"}], "stats": {"total": 1000, "additions": 4, "deletions": 996}, "files": [{"sha": "92ce3f64f7188765d917a902fe98a2c0f26283c2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0e7ec09f246a5211b3490753989a3e5e78c481/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0e7ec09f246a5211b3490753989a3e5e78c481/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fb0e7ec09f246a5211b3490753989a3e5e78c481", "patch": "@@ -1,3 +1,7 @@\n+2004-05-15  Mark Wielaard  <mark@klomp.org>\n+\n+\t* doc/cni.sgml: Removed, merged into gcj.texi.\n+\n 2004-05-15  Mark Wielaard  <mark@klomp.org>\n \n \t* Makefile.am (ordinary_java_source_files): Add new javax.print"}, {"sha": "495e3e9c5a5f4d813e26569ace9d41e7093a9507", "filename": "libjava/doc/cni.sgml", "status": "removed", "additions": 0, "deletions": 996, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909087e0cfa28372c9aca47a86aa51af91b12684/libjava%2Fdoc%2Fcni.sgml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909087e0cfa28372c9aca47a86aa51af91b12684/libjava%2Fdoc%2Fcni.sgml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fcni.sgml?ref=909087e0cfa28372c9aca47a86aa51af91b12684", "patch": "@@ -1,996 +0,0 @@\n-<!DOCTYPE article PUBLIC \"-//Davenport//DTD DocBook V3.0//EN\">\n-<article>\n-<artheader>\n-<title>The Cygnus Native Interface for C++/Java Integration</title>\n-<subtitle>Writing native Java methods in natural C++</subtitle>\n-<authorgroup>\n-<corpauthor>Cygnus Solutions</corpauthor>\n-</authorgroup>\n-<date>March, 2000</date>\n-</artheader>\n-\n-<abstract><para>\n-This documents CNI, the Cygnus Native Interface,\n-which is is a convenient way to write Java native methods using C++.\n-This is a more efficient, more convenient, but less portable\n-alternative to the standard JNI (Java Native Interface).</para>\n-</abstract>\n-\n-<sect1><title>Basic Concepts</title>\n-<para>\n-In terms of languages features, Java is mostly a subset\n-of C++.  Java has a few important extensions, plus a powerful standard\n-class library, but on the whole that does not change the basic similarity.\n-Java is a hybrid object-oriented language, with a few native types,\n-in addition to class types.  It is class-based, where a class may have\n-static as well as per-object fields, and static as well as instance methods.\n-Non-static methods may be virtual, and may be overloaded.  Overloading is\n-resolved at compile time by matching the actual argument types against\n-the parameter types.  Virtual methods are implemented using indirect calls\n-through a dispatch table (virtual function table).  Objects are\n-allocated on the heap, and initialized using a constructor method.\n-Classes are organized in a package hierarchy.\n-</para>\n-<para>\n-All of the listed attributes are also true of C++, though C++ has\n-extra features (for example in C++ objects may be allocated not just\n-on the heap, but also statically or in a local stack frame).  Because\n-<acronym>gcj</acronym> uses the same compiler technology as\n-<acronym>g++</acronym> (the GNU C++ compiler), it is possible\n-to make the intersection of the two languages use the same\n-<acronym>ABI</acronym> (object representation and calling conventions).\n-The key idea in <acronym>CNI</acronym> is that Java objects are C++ objects,\n-and all Java classes are C++ classes (but not the other way around).\n-So the most important task in integrating Java and C++ is to\n-remove gratuitous incompatibilities.\n-</para>\n-<para>\n-You write CNI code as a regular C++ source file.  (You do have to use\n-a Java/CNI-aware C++ compiler, specifically a recent version of G++.)</para>\n-<para>\n-You start with:\n-<programlisting>\n-#include &lt;gcj/cni.h&gt;\n-</programlisting></para>\n-\n-<para>\n-You then include header files for the various Java classes you need\n-to use:\n-<programlisting>\n-#include &lt;java/lang/Character.h&gt;\n-#include &lt;java/util/Date.h&gt;\n-#include &lt;java/lang/IndexOutOfBoundsException.h&gt;\n-</programlisting></para>\n-\n-<para>\n-In general, <acronym>CNI</acronym> functions and macros start with the\n-`<literal>Jv</literal>' prefix, for example the function\n-`<literal>JvNewObjectArray</literal>'.  This convention is used to\n-avoid conflicts with other libraries.\n-Internal functions in <acronym>CNI</acronym> start with the prefix\n-`<literal>_Jv_</literal>'.  You should not call these;\n-if you find a need to, let us know and we will try to come up with an\n-alternate solution.  (This manual lists <literal>_Jv_AllocBytes</literal>\n-as an example;  <acronym>CNI</acronym> should instead provide\n-a <literal>JvAllocBytes</literal> function.)</para>\n-<para>\n-These header files are automatically generated by <command>gcjh</command>.\n-</para>\n-</sect1>\n-\n-<sect1><title>Packages</title>\n-<para>\n-The only global names in Java are class names, and packages.\n-A <firstterm>package</firstterm> can contain zero or more classes, and\n-also zero or more sub-packages.\n-Every class belongs to either an unnamed package or a package that\n-has a hierarchical and globally unique name.\n-</para>\n-<para>\n-A Java package is mapped to a C++ <firstterm>namespace</firstterm>.\n-The Java class <literal>java.lang.String</literal>\n-is in the package <literal>java.lang</literal>, which is a sub-package\n-of <literal>java</literal>.  The C++ equivalent is the\n-class <literal>java::lang::String</literal>,\n-which is in the namespace <literal>java::lang</literal>,\n-which is in the namespace <literal>java</literal>.\n-</para>\n-<para>\n-Here is how you could express this:\n-<programlisting>\n-// Declare the class(es), possibly in a header file:\n-namespace java {\n-  namespace lang {\n-    class Object;\n-    class String;\n-    ...\n-  }\n-}\n-\n-class java::lang::String : public java::lang::Object\n-{\n-  ...\n-};\n-</programlisting>\n-</para>\n-<para>\n-The <literal>gcjh</literal> tool automatically generates the\n-nessary namespace declarations.</para>\n-\n-<sect2><title>Nested classes as a substitute for namespaces</title>\n-<para>\n-<!-- FIXME the next line reads poorly jsm -->\n-It is not that long since g++ got complete namespace support,\n-and it was very recent (end of February 1999) that <literal>libgcj</literal>\n-was changed to uses namespaces.  Releases before then used\n-nested classes, which are the C++ equivalent of Java inner classes.\n-They provide similar (though less convenient) functionality.\n-The old syntax is:\n-<programlisting>\n-class java {\n-  class lang {\n-    class Object;\n-    class String;\n-  };\n-};\n-</programlisting>\n-The obvious difference is the use of <literal>class</literal> instead\n-of <literal>namespace</literal>.  The more important difference is\n-that all the members of a nested class have to be declared inside\n-the parent class definition, while namespaces can be defined in\n-multiple places in the source.  This is more convenient, since it\n-corresponds more closely to how Java packages are defined.\n-The main difference is in the declarations; the syntax for\n-using a nested class is the same as with namespaces:\n-<programlisting>\n-class java::lang::String : public java::lang::Object\n-{ ... }\n-</programlisting>\n-Note that the generated code (including name mangling)\n-using nested classes is the same as that using namespaces.</para>\n-</sect2>\n-\n-<sect2><title>Leaving out package names</title>\n-<para>\n-<!-- FIXME next line reads poorly jsm -->\n-Having to always type the fully-qualified class name is verbose.\n-It also makes it more difficult to change the package containing a class.\n-The Java <literal>package</literal> declaration specifies that the\n-following class declarations are in the named package, without having\n-to explicitly name the full package qualifiers.\n-The <literal>package</literal> declaration can be followed by zero or\n-more <literal>import</literal> declarations, which allows either\n-a single class or all the classes in a package to be named by a simple\n-identifier.  C++ provides something similar\n-with the <literal>using</literal> declaration and directive.\n-</para>\n-<para>\n-A Java simple-type-import declaration:\n-<programlisting>\n-import <replaceable>PackageName</replaceable>.<replaceable>TypeName</replaceable>;\n-</programlisting>\n-allows using <replaceable>TypeName</replaceable> as a shorthand for\n-<literal><replaceable>PackageName</replaceable>.<replaceable>TypeName</replaceable></literal>.\n-The C++ (more-or-less) equivalent is a <literal>using</literal>-declaration:\n-<programlisting>\n-using <replaceable>PackageName</replaceable>::<replaceable>TypeName</replaceable>;\n-</programlisting>\n-</para>\n-<para>\n-A Java import-on-demand declaration:\n-<programlisting>\n-import <replaceable>PackageName</replaceable>.*;\n-</programlisting>\n-allows using <replaceable>TypeName</replaceable> as a shorthand for\n-<literal><replaceable>PackageName</replaceable>.<replaceable>TypeName</replaceable></literal>\n-The C++ (more-or-less) equivalent is a <literal>using</literal>-directive:\n-<programlisting>\n-using namespace <replaceable>PackageName</replaceable>;\n-</programlisting>\n-</para>\n-</sect2>\n-</sect1>\n-\n-<sect1><title>Primitive types</title>\n-<para>\n-Java provides 8 <quote>primitives</quote> types:\n-<literal>byte</literal>, <literal>short</literal>, <literal>int</literal>,\n-<literal>long</literal>, <literal>float</literal>, <literal>double</literal>,\n-<literal>char</literal>, and <literal>boolean</literal>.\n-These are the same as the following C++ <literal>typedef</literal>s\n-(which are defined by <literal>gcj/cni.h</literal>):\n-<literal>jbyte</literal>, <literal>jshort</literal>, <literal>jint</literal>,\n-<literal>jlong</literal>, <literal>jfloat</literal>,\n-<literal>jdouble</literal>,\n-<literal>jchar</literal>, and <literal>jboolean</literal>.\n-You should use the C++ typenames\n-(<ForeignPhrase><Abbrev>e.g.</Abbrev></ForeignPhrase> <literal>jint</literal>),\n-and not the Java types names\n-(<ForeignPhrase><Abbrev>e.g.</Abbrev></ForeignPhrase> <literal>int</literal>),\n-even if they are <quote>the same</quote>.\n-This is because there is no guarantee that the C++ type\n-<literal>int</literal> is a 32-bit type, but <literal>jint</literal>\n-<emphasis>is</emphasis> guaranteed to be a 32-bit type.\n-\n-<informaltable frame=\"all\" colsep=\"1\" rowsep=\"0\">\n-<tgroup cols=\"3\">\n-<thead>\n-<row>\n-<entry>Java type</entry>\n-<entry>C/C++ typename</entry>\n-<entry>Description</entry>\n-</thead>\n-<tbody>\n-<row>\n-<entry>byte</entry>\n-<entry>jbyte</entry>\n-<entry>8-bit signed integer</entry>\n-</row>\n-<row>\n-<entry>short</entry>\n-<entry>jshort</entry>\n-<entry>16-bit signed integer</entry>\n-</row>\n-<row>\n-<entry>int</entry>\n-<entry>jint</entry>\n-<entry>32-bit signed integer</entry>\n-</row>\n-<row>\n-<entry>long</entry>\n-<entry>jlong</entry>\n-<entry>64-bit signed integer</entry>\n-</row>\n-<row>\n-<entry>float</entry>\n-<entry>jfloat</entry>\n-<entry>32-bit IEEE floating-point number</entry>\n-</row>\n-<row>\n-<entry>double</entry>\n-<entry>jdouble</entry>\n-<entry>64-bit IEEE floating-point number</entry>\n-</row>\n-<row>\n-<entry>char</entry>\n-<entry>jchar</entry>\n-<entry>16-bit Unicode character</entry>\n-</row>\n-<row>\n-<entry>boolean</entry>\n-<entry>jboolean</entry>\n-<entry>logical (Boolean) values</entry>\n-</row>\n-<row>\n-<entry>void</entry>\n-<entry>void</entry>\n-<entry>no value</entry>\n-</row>\n-</tbody></tgroup>\n-</informaltable>\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-<funcdef><function>JvPrimClass</function></funcdef>\n-<paramdef><parameter>primtype</parameter></paramdef>\n-</funcsynopsis>\n-This is a macro whose argument should be the name of a primitive\n-type, <ForeignPhrase><Abbrev>e.g.</Abbrev></ForeignPhrase>\n-<literal>byte</literal>.\n-The macro expands to a pointer to the <literal>Class</literal> object\n-corresponding to the primitive type.\n-<ForeignPhrase><Abbrev>E.g.</Abbrev></ForeignPhrase>,\n-<literal>JvPrimClass(void)</literal>\n-has the same value as the Java expression\n-<literal>Void.TYPE</literal> (or <literal>void.class</literal>).\n-</para>\n-\n-</sect1>\n-\n-<sect1><title>Objects and Classes</title>\n-<sect2><title>Classes</title>\n-<para>\n-All Java classes are derived from <literal>java.lang.Object</literal>.\n-C++ does not have a unique <quote>root</quote>class, but we use\n-a C++ <literal>java::lang::Object</literal> as the C++ version\n-of the <literal>java.lang.Object</literal> Java class.  All\n-other Java classes are mapped into corresponding C++ classes\n-derived from <literal>java::lang::Object</literal>.</para>\n-<para>\n-Interface inheritance (the <quote><literal>implements</literal></quote>\n-keyword) is currently not reflected in the C++ mapping.</para>\n-</sect2>\n-<sect2><title>Object references</title>\n-<para>\n-We implement a Java object reference as a pointer to the start\n-of the referenced object.  It maps to a C++ pointer.\n-(We cannot use C++ references for Java references, since\n-once a C++ reference has been initialized, you cannot change it to\n-point to another object.)\n-The <literal>null</literal> Java reference maps to the <literal>NULL</literal>\n-C++ pointer.\n-</para>\n-<para>\n-Note that in some Java implementations an object reference is implemented as\n-a pointer to a two-word <quote>handle</quote>.  One word of the handle\n-points to the fields of the object, while the other points\n-to a method table.  Gcj does not use this extra indirection.\n-</para>\n-</sect2>\n-<sect2><title>Object fields</title>\n-<para>\n-Each object contains an object header, followed by the instance\n-fields of the class, in order.  The object header consists of\n-a single pointer to a dispatch or virtual function table.\n-(There may be extra fields <quote>in front of</quote> the object,\n-for example for\n-memory management, but this is invisible to the application, and\n-the reference to the object points to the dispatch table pointer.)\n-</para>\n-<para>\n-The fields are laid out in the same order, alignment, and size\n-as in C++.  Specifically, 8-bite and 16-bit native types\n-(<literal>byte</literal>, <literal>short</literal>, <literal>char</literal>,\n-and <literal>boolean</literal>) are <emphasis>not</emphasis>\n-widened to 32 bits.\n-Note that the Java VM does extend 8-bit and 16-bit types to 32 bits\n-when on the VM stack or temporary registers.</para>\n-<para>\n-If you include the <literal>gcjh</literal>-generated header for a\n-class, you can access fields of Java classes in the <quote>natural</quote>\n-way.  Given the following Java class:\n-<programlisting>\n-public class Int\n-{\n-  public int i;\n-  public Integer (int i) { this.i = i; }\n-  public static zero = new Integer(0);\n-}\n-</programlisting>\n-you can write:\n-<programlisting>\n-#include &lt;gcj/cni.h&gt;\n-#include &lt;Int.h&gt;\n-Int*\n-mult (Int *p, jint k)\n-{\n-  if (k == 0)\n-    return Int::zero;  // static member access.\n-  return new Int(p->i * k);\n-}\n-</programlisting>\n-</para>\n-<para>\n-<acronym>CNI</acronym> does not strictly enforce the Java access\n-specifiers, because Java permissions cannot be directly mapped\n-into C++ permission.  Private Java fields and methods are mapped\n-to private C++ fields and methods, but other fields and methods\n-are mapped to public fields and methods.\n-</para>\n-</sect2>\n-</sect1>\n-\n-<sect1><title>Arrays</title>\n-<para>\n-While in many ways Java is similar to C and C++,\n-it is quite different in its treatment of arrays.\n-C arrays are based on the idea of pointer arithmetic,\n-which would be incompatible with Java's security requirements.\n-Java arrays are true objects (array types inherit from\n-<literal>java.lang.Object</literal>).  An array-valued variable\n-is one that contains a reference (pointer) to an array object.\n-</para>\n-<para>\n-Referencing a Java array in C++ code is done using the\n-<literal>JArray</literal> template, which as defined as follows:\n-<programlisting>\n-class __JArray : public java::lang::Object\n-{\n-public:\n-  int length;\n-};\n-\n-template&lt;class T&gt;\n-class JArray : public __JArray\n-{\n-  T data[0];\n-public:\n-  T&amp; operator[](jint i) { return data[i]; }\n-};\n-</programlisting></para>\n-<para>\n-<funcsynopsis> \n-   <funcdef>template&lt;class T&gt;  T *<function>elements</function></funcdef>\n-   <paramdef>JArray&lt;T&gt; &amp;<parameter>array</parameter></paramdef>\n-</funcsynopsis>\n-   This template function can be used to get a pointer to the\n-   elements of the <parameter>array</parameter>.\n-   For instance, you can fetch a pointer\n-   to the integers that make up an <literal>int[]</literal> like so:\n-<programlisting>\n-extern jintArray foo;\n-jint *intp = elements (foo);\n-</programlisting>\n-The name of this function may change in the future.</para>\n-<para>\n-There are a number of typedefs which correspond to typedefs from JNI.\n-Each is the type of an array holding objects of the appropriate type:\n-<programlisting>\n-typedef __JArray *jarray;\n-typedef JArray&lt;jobject&gt; *jobjectArray;\n-typedef JArray&lt;jboolean&gt; *jbooleanArray;\n-typedef JArray&lt;jbyte&gt; *jbyteArray;\n-typedef JArray&lt;jchar&gt; *jcharArray;\n-typedef JArray&lt;jshort&gt; *jshortArray;\n-typedef JArray&lt;jint&gt; *jintArray;\n-typedef JArray&lt;jlong&gt; *jlongArray;\n-typedef JArray&lt;jfloat&gt; *jfloatArray;\n-typedef JArray&lt;jdouble&gt; *jdoubleArray;\n-</programlisting>\n-</para>\n-<para>\n- You can create an array of objects using this function:\n-<funcsynopsis> \n-   <funcdef>jobjectArray <function>JvNewObjectArray</function></funcdef>\n-   <paramdef>jint <parameter>length</parameter></paramdef>\n-   <paramdef>jclass <parameter>klass</parameter></paramdef>\n-   <paramdef>jobject <parameter>init</parameter></paramdef>\n-   </funcsynopsis>\n-   Here <parameter>klass</parameter> is the type of elements of the array;\n-   <parameter>init</parameter> is the initial\n-   value to be put into every slot in the array.\n-</para>\n-<para>\n-For each primitive type there is a function which can be used\n-   to create a new array holding that type.  The name of the function\n-   is of the form\n-   `<literal>JvNew&lt;<replaceable>Type</replaceable>&gt;Array</literal>',\n-   where `&lt;<replaceable>Type</replaceable>&gt;' is the name of\n-   the primitive type, with its initial letter in upper-case.  For\n-   instance, `<literal>JvNewBooleanArray</literal>' can be used to create\n-   a new array of booleans.\n-   Each such function follows this example:\n-<funcsynopsis>  \n-   <funcdef>jbooleanArray <function>JvNewBooleanArray</function></funcdef> \n-   <paramdef>jint <parameter>length</parameter></paramdef>\n-</funcsynopsis>\n-</para>\n-<para>\n-<funcsynopsis>\n-   <funcdef>jsize <function>JvGetArrayLength</function></funcdef>\n-   <paramdef>jarray <parameter>array</parameter></paramdef> \n-   </funcsynopsis>\n-   Returns the length of <parameter>array</parameter>.</para>\n-</sect1>\n-\n-<sect1><title>Methods</title>\n-\n-<para>\n-Java methods are mapped directly into C++ methods.\n-The header files generated by <literal>gcjh</literal>\n-include the appropriate method definitions.\n-Basically, the generated methods have the same names and\n-<quote>corresponding</quote> types as the Java methods,\n-and are called in the natural manner.</para>\n-\n-<sect2><title>Overloading</title>\n-<para>\n-Both Java and C++ provide method overloading, where multiple\n-methods in a class have the same name, and the correct one is chosen\n-(at compile time) depending on the argument types.\n-The rules for choosing the correct method are (as expected) more complicated\n-in C++ than in Java, but given a set of overloaded methods\n-generated by <literal>gcjh</literal> the C++ compiler will choose\n-the expected one.</para>\n-<para>\n-Common assemblers and linkers are not aware of C++ overloading,\n-so the standard implementation strategy is to encode the\n-parameter types of a method into its assembly-level name.\n-This encoding is called <firstterm>mangling</firstterm>,\n-and the encoded name is the <firstterm>mangled name</firstterm>.\n-The same mechanism is used to implement Java overloading.\n-For C++/Java interoperability, it is important that both the Java\n-and C++ compilers use the <emphasis>same</emphasis> encoding scheme.\n-</para>\n-</sect2>\n-\n-<sect2><title>Static methods</title>\n-<para>\n-Static Java methods are invoked in <acronym>CNI</acronym> using the standard\n-C++ syntax, using the `<literal>::</literal>' operator rather\n-than the `<literal>.</literal>' operator.  For example:\n-</para>\n-<programlisting>\n-jint i = java::lang::Math::round((jfloat) 2.3);\n-</programlisting>\n-<para>\n-<!-- FIXME this next sentence seems ungammatical jsm -->\n-Defining a static native method uses standard C++ method\n-definition syntax.  For example:\n-<programlisting>\n-#include &lt;java/lang/Integer.h&gt;\n-java::lang::Integer*\n-java::lang::Integer::getInteger(jstring str)\n-{\n-  ...\n-}\n-</programlisting>\n-</sect2>\n-\n-<sect2><title>Object Constructors</title>\n-<para>\n-Constructors are called implicitly as part of object allocation\n-using the <literal>new</literal> operator.  For example:\n-<programlisting> \n-java::lang::Int x = new java::lang::Int(234);\n-</programlisting> \n-</para>\n-<para>\n-<!-- FIXME rewrite needed here, mine may not be good jsm -->\n-Java does not allow a constructor to be a native method.\n-Instead, you could define a private method which\n-you can have the constructor call.\n-</para>\n-</sect2>\n-\n-<sect2><title>Instance methods</title>\n-<para>\n-<!-- FIXME next para week, I would remove a few words from some sentences jsm -->\n-Virtual method dispatch is handled essentially the same way\n-in C++ and Java -- <abbrev>i.e.</abbrev> by doing an\n-indirect call through a function pointer stored in a per-class virtual\n-function table.  C++ is more complicated because it has to support\n-multiple inheritance, but this does not effect Java classes.\n-However, G++ has historically used a different calling convention\n-that is not compatible with the one used by <acronym>gcj</acronym>.\n-During 1999, G++ will switch to a new ABI that is compatible with\n-<acronym>gcj</acronym>.  Some platforms (including Linux) have already\n-changed.  On other platforms, you will have to pass\n-the <literal>-fvtable-thunks</literal> flag to g++ when\n-compiling <acronym>CNI</acronym> code.  Note that you must also compile\n-your C++ source code with <literal>-fno-rtti</literal>.\n-</para>\n-<para>\n-Calling a Java instance method in <acronym>CNI</acronym> is done\n-using the standard C++ syntax.  For example:\n-<programlisting>\n-  java::lang::Number *x;\n-  if (x-&gt;doubleValue() &gt; 0.0) ...\n-</programlisting>\n-</para>\n-<para>\n-Defining a Java native instance method is also done the natural way:\n-<programlisting>\n-#include &lt;java/lang/Integer.h&gt;\n-jdouble\n-java::lang:Integer::doubleValue()\n-{\n-  return (jdouble) value;\n-}\n-</programlisting>\n-</para>\n-</sect2>\n-\n-<sect2><title>Interface method calls</title>\n-<para>\n-In Java you can call a method using an interface reference.\n-This is not yet supported in <acronym>CNI</acronym>.</para>\n-</sect2>\n-</sect1>\n-\n-<sect1><title>Object allocation</title>\n-\n-<para>\n-New Java objects are allocated using a\n-<firstterm>class-instance-creation-expression</firstterm>:\n-<programlisting>\n-new <replaceable>Type</replaceable> ( <replaceable>arguments</replaceable> )\n-</programlisting>\n-The same syntax is used in C++.  The main difference is that\n-C++ objects have to be explicitly deleted; in Java they are\n-automatically deleted by the garbage collector.\n-Using <acronym>CNI</acronym>, you can allocate a new object\n-using standard C++ syntax.  The C++ compiler is smart enough to\n-realize the class is a Java class, and hence it needs to allocate\n-memory from the garbage collector.  If you have overloaded\n-constructors, the compiler will choose the correct one\n-using standard C++ overload resolution rules.  For example:\n-<programlisting>\n-java::util::Hashtable *ht = new java::util::Hashtable(120);\n-</programlisting>\n-</para>\n-<para>\n-<funcsynopsis>\n-  <funcdef>void *<function>_Jv_AllocBytes</function></funcdef>\n-  <paramdef>jsize <parameter>size</parameter></paramdef>\n-</funcsynopsis>\n-   Allocate <parameter>size</parameter> bytes.  This memory is not\n-   scanned by the garbage collector.  However, it will be freed by\n-the GC if no references to it are discovered.\n-</para>\n-</sect1>\n-\n-<sect1><title>Interfaces</title>\n-<para>\n-A Java class can <firstterm>implement</firstterm> zero or more\n-<firstterm>interfaces</firstterm>, in addition to inheriting from\n-a single base class. \n-An interface is a collection of constants and method specifications;\n-it is similar to the <firstterm>signatures</firstterm> available\n-as a G++ extension.  An interface provides a subset of the\n-functionality of C++ abstract virtual base classes, but they\n-are currently implemented differently.\n-CNI does not currently provide any support for interfaces,\n-or calling methods from an interface pointer.\n-This is partly because we are planning to re-do how\n-interfaces are implemented in <acronym>gcj</acronym>.\n-</para>\n-</sect1>\n-\n-<sect1><title>Strings</title>\n-<para>\n-<acronym>CNI</acronym> provides a number of utility functions for\n-working with Java <literal>String</literal> objects.\n-The names and interfaces are analogous to those of <acronym>JNI</acronym>.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-  <funcdef>jstring <function>JvNewString</function></funcdef>\n-  <paramdef>const jchar *<parameter>chars</parameter></paramdef>\n-  <paramdef>jsize <parameter>len</parameter></paramdef>\n-  </funcsynopsis>\n-  Creates a new Java String object, where\n-  <parameter>chars</parameter> are the contents, and\n-  <parameter>len</parameter> is the number of characters.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-  <funcdef>jstring <function>JvNewStringLatin1</function></funcdef>\n-  <paramdef>const char *<parameter>bytes</parameter></paramdef>\n-  <paramdef>jsize <parameter>len</parameter></paramdef>\n- </funcsynopsis>\n-  Creates a new Java String object, where <parameter>bytes</parameter>\n-  are the Latin-1 encoded\n-  characters, and <parameter>len</parameter> is the length of\n-  <parameter>bytes</parameter>, in bytes.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-  <funcdef>jstring <function>JvNewStringLatin1</function></funcdef>\n-  <paramdef>const char *<parameter>bytes</parameter></paramdef>\n-  </funcsynopsis>\n-  Like the first JvNewStringLatin1, but computes <parameter>len</parameter>\n-  using <literal>strlen</literal>.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-  <funcdef>jstring <function>JvNewStringUTF</function></funcdef>\n-  <paramdef>const char *<parameter>bytes</parameter></paramdef>\n-  </funcsynopsis>\n-   Creates a new Java String object, where <parameter>bytes</parameter> are\n-   the UTF-8 encoded characters of the string, terminated by a null byte.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-   <funcdef>jchar *<function>JvGetStringChars</function></funcdef>\n-  <paramdef>jstring <parameter>str</parameter></paramdef>\n-  </funcsynopsis>\n-   Returns a pointer to the array of characters which make up a string.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-   <funcdef> int <function>JvGetStringUTFLength</function></funcdef>\n-  <paramdef>jstring <parameter>str</parameter></paramdef>\n-  </funcsynopsis>\n-   Returns number of bytes required to encode contents\n-   of <parameter>str</parameter> as UTF-8.\n-</para>\n-\n-<para>\n-<funcsynopsis>\n-  <funcdef> jsize <function>JvGetStringUTFRegion</function></funcdef>\n-  <paramdef>jstring <parameter>str</parameter></paramdef>\n-  <paramdef>jsize <parameter>start</parameter></paramdef>\n-  <paramdef>jsize <parameter>len</parameter></paramdef>\n-  <paramdef>char *<parameter>buf</parameter></paramdef>\n-  </funcsynopsis>\n-  This puts the UTF-8 encoding of a region of the\n-  string <parameter>str</parameter> into\n-  the buffer <parameter>buf</parameter>.\n-  The region of the string to fetch is specifued by\n-  <parameter>start</parameter> and <parameter>len</parameter>.\n-   It is assumed that <parameter>buf</parameter> is big enough\n-   to hold the result.  Note\n-   that <parameter>buf</parameter> is <emphasis>not</emphasis> null-terminated.\n-</para>\n-</sect1>\n-\n-<sect1><title>Class Initialization</title>\n-<para>\n-Java requires that each class be automatically initialized at the time \n-of the first active use.  Initializing a class involves \n-initializing the static fields, running code in class initializer \n-methods, and initializing base classes.  There may also be \n-some implementation specific actions, such as allocating \n-<classname>String</classname> objects corresponding to string literals in\n-the code.</para>\n-<para>\n-The Gcj compiler inserts calls to <literal>JvInitClass</literal> (actually\n-<literal>_Jv_InitClass</literal>) at appropriate places to ensure that a\n-class is initialized when required.  The C++ compiler does not\n-insert these calls automatically - it is the programmer's\n-responsibility to make sure classes are initialized.  However,\n-this is fairly painless because of the conventions assumed by the Java\n-system.</para>\n-<para>\n-First, <literal>libgcj</literal> will make sure a class is initialized\n-before an instance of that object is created.  This is one\n-of the responsibilities of the <literal>new</literal> operation.  This is\n-taken care of both in Java code, and in C++ code.  (When the G++\n-compiler sees a <literal>new</literal> of a Java class, it will call\n-a routine in <literal>libgcj</literal> to allocate the object, and that\n-routine will take care of initializing the class.)  It follows that you can\n-access an instance field, or call an instance (non-static)\n-method and be safe in the knowledge that the class and all\n-of its base classes have been initialized.</para>\n-<para>\n-Invoking a static method is also safe.  This is because the\n-Java compiler adds code to the start of a static method to make sure\n-the class is initialized.  However, the C++ compiler does not\n-add this extra code.  Hence, if you write a native static method\n-using CNI, you are responsible for calling <literal>JvInitClass</literal>\n-before doing anything else in the method (unless you are sure\n-it is safe to leave it out).</para>\n-<para>\n-Accessing a static field also requires the class of the\n-field to be initialized.  The Java compiler will generate code\n-to call <literal>_Jv_InitClass</literal> before getting or setting the field.\n-However, the C++ compiler will not generate this extra code,\n-so it is your responsibility to make sure the class is\n-initialized before you access a static field.</para>\n-</sect1>\n-<sect1><title>Exception Handling</title>\n-<para>\n-While C++ and Java share a common exception handling framework,\n-things are not yet perfectly integrated.  The main issue is that the\n-<quote>run-time type information</quote> facilities of the two\n-languages are not integrated.</para>\n-<para>\n-Still, things work fairly well.  You can throw a Java exception from\n-C++ using the ordinary <literal>throw</literal> construct, and this\n-exception can be caught by Java code.  Similarly, you can catch an\n-exception thrown from Java using the C++ <literal>catch</literal>\n-construct.\n-<para>\n-Note that currently you cannot mix C++ catches and Java catches in\n-a single C++ translation unit.  We do intend to fix this eventually.\n-</para>\n-<para>\n-Here is an example:\n-<programlisting>\n-if (i >= count)\n-   throw new java::lang::IndexOutOfBoundsException();\n-</programlisting>\n-</para>\n-<para>\n-Normally, GNU C++ will automatically detect when you are writing C++\n-code that uses Java exceptions, and handle them appropriately.\n-However, if C++ code only needs to execute destructors when Java\n-exceptions are thrown through it, GCC will guess incorrectly.  Sample\n-problematic code:\n-<programlisting>\n-  struct S { ~S(); };\n-  extern void bar();    // is implemented in Java and may throw exceptions\n-  void foo()\n-  {\n-    S s;\n-    bar();\n-  }\n-</programlisting>\n-The usual effect of an incorrect guess is a link failure, complaining of\n-a missing routine called <literal>__gxx_personality_v0</literal>.\n-</para>\n-<para>\n-You can inform the compiler that Java exceptions are to be used in a\n-translation unit, irrespective of what it might think, by writing\n-<literal>#pragma GCC java_exceptions</literal> at the head of the\n-file.  This <literal>#pragma</literal> must appear before any\n-functions that throw or catch exceptions, or run destructors when\n-exceptions are thrown through them.</para>\n-</sect1>\n-\n-<sect1><title>Synchronization</title>\n-<para>\n-Each Java object has an implicit monitor.\n-The Java VM uses the instruction <literal>monitorenter</literal> to acquire\n-and lock a monitor, and <literal>monitorexit</literal> to release it.\n-The JNI has corresponding methods <literal>MonitorEnter</literal>\n-and <literal>MonitorExit</literal>.  The corresponding CNI macros\n-are <literal>JvMonitorEnter</literal> and <literal>JvMonitorExit</literal>.\n-</para>\n-<para>\n-The Java source language does not provide direct access to these primitives.\n-Instead, there is a <literal>synchronized</literal> statement that does an\n-implicit <literal>monitorenter</literal> before entry to the block,\n-and does a <literal>monitorexit</literal> on exit from the block.\n-Note that the lock has to be released even the block is abnormally\n-terminated by an exception, which means there is an implicit\n-<literal>try</literal>-<literal>finally</literal>.\n-</para>\n-<para>\n-From C++, it makes sense to use a destructor to release a lock.\n-CNI defines the following utility class.\n-<programlisting>\n-class JvSynchronize() {\n-  jobject obj;\n-  JvSynchronize(jobject o) { obj = o; JvMonitorEnter(o); }\n-  ~JvSynchronize() { JvMonitorExit(obj); }\n-};\n-</programlisting>\n-The equivalent of Java's:\n-<programlisting>\n-synchronized (OBJ) { CODE; }\n-</programlisting>\n-can be simply expressed:\n-<programlisting>\n-{ JvSynchronize dummy(OBJ); CODE; }\n-</programlisting>\n-</para>\n-<para>\n-Java also has methods with the <literal>synchronized</literal> attribute.\n-This is equivalent to wrapping the entire method body in a\n-<literal>synchronized</literal> statement.\n-(Alternatively, an implementation could require the caller to do\n-the synchronization.  This is not practical for a compiler, because\n-each virtual method call would have to test at run-time if\n-synchronization is needed.)  Since in <literal>gcj</literal>\n-the <literal>synchronized</literal> attribute is handled by the\n-method implementation, it is up to the programmer\n-of a synchronized native method to handle the synchronization\n-(in the C++ implementation of the method).\n-In otherwords, you need to manually add <literal>JvSynchronize</literal>\n-in a <literal>native synchornized</literal> method.</para>\n-</sect1>\n-\n-<sect1><title>Reflection</title>\n-<para>The types <literal>jfieldID</literal> and <literal>jmethodID</literal>\n-are as in JNI.</para>\n-<para>\n-The function <literal>JvFromReflectedField</literal>,\n-<literal>JvFromReflectedMethod</literal>,\n-<literal>JvToReflectedField</literal>, and\n-<literal>JvToFromReflectedMethod</literal> (as in Java 2 JNI)\n-will be added shortly, as will other functions corresponding to JNI.</para>\n-\n-<sect1><title>Using gcjh</title>\n-<para>\n-      The <command>gcjh</command> is used to generate C++ header files from\n-      Java class files.  By default, <command>gcjh</command> generates\n-      a relatively straightforward C++ header file.  However, there\n-      are a few caveats to its use, and a few options which can be\n-      used to change how it operates:\n-</para>\n-<variablelist>\n-<varlistentry>\n-<term><literal>--classpath</literal> <replaceable>path</replaceable></term>\n-<term><literal>--CLASSPATH</literal> <replaceable>path</replaceable></term>\n-<term><literal>-I</literal> <replaceable>dir</replaceable></term>\n-<listitem><para>\n-        These options can be used to set the class path for gcjh.\n-        Gcjh searches the class path the same way the compiler does;\n-\tthese options have their familiar meanings.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry>\n-<term><literal>-d <replaceable>directory</replaceable></literal></term>\n-<listitem><para>\n-Puts the generated <literal>.h</literal> files\n-beneath <replaceable>directory</replaceable>.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry>\n-<term><literal>-o <replaceable>file</replaceable></literal></term>\n-<listitem><para>\n-        Sets the name of the <literal>.h</literal> file to be generated.\n-        By default the <literal>.h</literal> file is named after the class.\n-        This option only really makes sense if just a single class file\n-        is specified.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry>\n-<term><literal>--verbose</literal></term>\n-<listitem><para>\n-        gcjh will print information to stderr as it works.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry>\n-<term><literal>-M</literal></term>\n-<term><literal>-MM</literal></term>\n-<term><literal>-MD</literal></term>\n-<term><literal>-MMD</literal></term>\n-<listitem><para>\n-        These options can be used to generate dependency information\n-        for the generated header file.  They work the same way as the\n-        corresponding compiler options.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry>\n-<term><literal>-prepend <replaceable>text</replaceable></literal></term>\n-<listitem><para>\n-This causes the <replaceable>text</replaceable> to be put into the generated\n-        header just after class declarations (but before declaration\n-        of the current class).  This option should be used with caution.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry> \n-<term><literal>-friend <replaceable>text</replaceable></literal></term>\n-<listitem><para>\n-This causes the <replaceable>text</replaceable> to be put into the class\n-declaration after a <literal>friend</literal> keyword.\n-This can be used to declare some\n-        other class or function to be a friend of this class.\n-        This option should be used with caution.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry>  \n-<term><literal>-add <replaceable>text</replaceable></literal></term>\n-<listitem><para>\n-The <replaceable>text</replaceable> is inserted into the class declaration.\n-This option should be used with caution.</para>\n-</listitem>\n-</varlistentry>\n-\n-<varlistentry> \n-<term><literal>-append <replaceable>text</replaceable></literal></term>\n-<listitem><para>\n-The <replaceable>text</replaceable> is inserted into the header file\n-after the class declaration.  One use for this is to generate\n-inline functions.  This option should be used with caution.\n-</listitem>\n-</varlistentry>\n-</variablelist>\n-<para>\n-All other options not beginning with a <literal>-</literal> are treated\n-as the names of classes for which headers should be generated.</para>\n-<para>\n-gcjh will generate all the required namespace declarations and\n-<literal>#include</literal>'s for the header file.\n-In some situations, gcjh will generate simple inline member\n-functions.  Note that, while gcjh puts <literal>#pragma\n-interface</literal> in the generated header file, you should\n-<emphasis>not</emphasis> put <literal>#pragma implementation</literal>\n-into your C++ source file.  If you do, duplicate definitions of\n-inline functions will sometimes be created, leading to link-time\n-errors.\n-</para>\n-<para>\n-There are a few cases where gcjh will fail to work properly:</para>\n-<para>\n-gcjh assumes that all the methods and fields of a class have ASCII\n-names.  The C++ compiler cannot correctly handle non-ASCII\n-identifiers.  gcjh does not currently diagnose this problem.</para>\n-<para>\n-gcjh also cannot fully handle classes where a field and a method have\n-the same name.  If the field is static, an error will result.\n-Otherwise, the field will be renamed in the generated header; `__'\n-will be appended to the field name.</para>\n-<para>\n-Eventually we hope to change the C++ compiler so that these\n-restrictions can be lifted.</para>\n-</sect1>\n-\n-</article>"}]}