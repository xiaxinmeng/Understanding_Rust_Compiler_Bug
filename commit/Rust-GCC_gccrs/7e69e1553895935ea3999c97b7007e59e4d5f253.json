{"sha": "7e69e1553895935ea3999c97b7007e59e4d5f253", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U2OWUxNTUzODk1OTM1ZWEzOTk5Yzk3YjcwMDdlNTllNGQ1ZjI1Mw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-05-16T23:07:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-05-16T23:07:37Z"}, "message": "Add -mstring support.\n\nFrom-SVN: r9734", "tree": {"sha": "265c83e2bf9599a19e19ce0e1167a64cefe6443d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/265c83e2bf9599a19e19ce0e1167a64cefe6443d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e69e1553895935ea3999c97b7007e59e4d5f253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e69e1553895935ea3999c97b7007e59e4d5f253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e69e1553895935ea3999c97b7007e59e4d5f253", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e69e1553895935ea3999c97b7007e59e4d5f253/comments", "author": null, "committer": null, "parents": [{"sha": "eacd15bccc012018808edb774c0870927c5c1eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eacd15bccc012018808edb774c0870927c5c1eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eacd15bccc012018808edb774c0870927c5c1eb1"}], "stats": {"total": 681, "additions": 621, "deletions": 60}, "files": [{"sha": "c24631e6cc4fc80c1b94d9d8be7b2775cdf1c753", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7e69e1553895935ea3999c97b7007e59e4d5f253", "patch": "@@ -184,6 +184,24 @@ rs6000_override_options ()\n      override with the processor default */\n   if (TARGET_MULTIPLE_SET)\n     target_flags = (target_flags & ~MASK_MULTIPLE) | multiple;\n+\n+  /* Don't allow -mmultiple or -mstring on little endian systems, because the\n+     hardware doesn't support the instructions used in little endian mode */\n+  if (!BYTES_BIG_ENDIAN)\n+    {\n+      if (TARGET_MULTIPLE)\n+\t{\n+\t  target_flags &= ~MASK_MULTIPLE;\n+\t  if (TARGET_MULTIPLE_SET)\n+\t    warning (\"-mmultiple is not supported on little endian systems\");\n+\t}\n+\n+      if (TARGET_STRING)\n+\t{\n+\t  target_flags &= ~MASK_STRING;\n+\t  warning (\"-mstring is not supported on little endian systems\");\n+\t}\n+    }\n }\n \f\n /* Create a CONST_DOUBLE like immed_double_const, except reverse the\n@@ -614,6 +632,142 @@ input_operand (op, mode)\n      for an add will be valid.  */\n   return add_operand (op, mode);\n }\n+\f\n+/* Expand a block move operation, and return 1 if successful.  Return 0\n+   if we should let the compiler generate normal code.\n+\n+   operands[0] is the destination\n+   operands[1] is the source\n+   operands[2] is the length\n+   operands[3] is the alignment */\n+\n+int\n+expand_block_move (operands)\n+     rtx operands[];\n+{\n+  rtx bytes_rtx\t= operands[2];\n+  int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n+  int bytes\t= (constp ? INTVAL (bytes_rtx) : 0);\n+  rtx align_rtx = operands[3];\n+  int align\t= XINT (align_rtx, 0);\n+  rtx src_reg;\n+  rtx dest_reg;\n+  rtx tmp_reg;\n+  int move_bytes;\n+\n+  /* Anything to move? */\n+  if (constp && bytes <= 0)\n+    return 1;\n+\n+  /* If we don't want to use multiple string instructions, quit now and\n+     generate the normal code.  */\n+  if (!TARGET_STRING)\n+    return 0;\n+\n+  /* We don't support variable sized moves at this time or real large moves */\n+  if (!constp || bytes > 64)\n+    return 0;\n+\n+  /* Move the address into scratch registers.  */\n+  dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));\n+  src_reg  = copy_addr_to_reg (XEXP (operands[1], 0));\n+\n+  for ( ; bytes > 0; bytes -= move_bytes)\n+    {\n+      if (bytes > 24\t\t/* move up to 32 bytes at a time */\n+\t  && !fixed_regs[5]\n+\t  && !fixed_regs[6]\n+\t  && !fixed_regs[7]\n+\t  && !fixed_regs[8]\n+\t  && !fixed_regs[9]\n+\t  && !fixed_regs[10]\n+\t  && !fixed_regs[11]\n+\t  && !fixed_regs[12])\n+\t{\n+\t  move_bytes = (bytes > 32) ? 32 : bytes;\n+\t  emit_insn (gen_movstrsi_8reg (dest_reg,\n+\t\t\t\t\tsrc_reg,\n+\t\t\t\t\tGEN_INT ((move_bytes == 32) ? 0 : move_bytes),\n+\t\t\t\t\talign_rtx,\n+\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t}\n+      else if (bytes > 16\t/* move up to 24 bytes at a time */\n+\t  && !fixed_regs[7]\n+\t  && !fixed_regs[8]\n+\t  && !fixed_regs[9]\n+\t  && !fixed_regs[10]\n+\t  && !fixed_regs[11]\n+\t  && !fixed_regs[12])\n+\t{\n+\t  move_bytes = (bytes > 24) ? 24 : bytes;\n+\t  emit_insn (gen_movstrsi_6reg (dest_reg,\n+\t\t\t\t\tsrc_reg,\n+\t\t\t\t\tGEN_INT (move_bytes),\n+\t\t\t\t\talign_rtx,\n+\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t}\n+      else if (bytes > 8\t/* move up to 16 bytes at a time */\n+\t       && !fixed_regs[9]\n+\t       && !fixed_regs[10]\n+\t       && !fixed_regs[11]\n+\t       && !fixed_regs[12])\n+\t{\n+\t  move_bytes = (bytes > 16) ? 16 : bytes;\n+\t  emit_insn (gen_movstrsi_4reg (dest_reg,\n+\t\t\t\t\tsrc_reg,\n+\t\t\t\t\tGEN_INT (move_bytes),\n+\t\t\t\t\talign_rtx,\n+\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t}\n+      else if (bytes > 4 && !TARGET_64BIT)\n+\t{\t\t\t/* move up to 8 bytes at a time */\n+\t  move_bytes = (bytes > 8) ? 8 : bytes;\n+\t  emit_insn (gen_movstrsi_2reg (dest_reg,\n+\t\t\t\t\tsrc_reg,\n+\t\t\t\t\tGEN_INT (move_bytes),\n+\t\t\t\t\talign_rtx,\n+\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t}\n+      else if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n+\t{\t\t\t/* move 4 bytes */\n+\t  move_bytes = 4;\n+\t  tmp_reg = gen_reg_rtx (SImode);\n+\t  emit_move_insn (tmp_reg, gen_rtx (MEM, SImode, src_reg));\n+\t  emit_move_insn (gen_rtx (MEM, SImode, dest_reg), tmp_reg);\n+\t  if (bytes > move_bytes)\n+\t    {\n+\t      emit_insn (gen_addsi3 (src_reg, src_reg, GEN_INT (move_bytes)));\n+\t      emit_insn (gen_addsi3 (dest_reg, dest_reg, GEN_INT (move_bytes)));\n+\t    }\n+\t}\n+      else if (bytes == 2 && (align >= 2 || !STRICT_ALIGNMENT))\n+\t{\t\t\t/* move 2 bytes */\n+\t  move_bytes = 2;\n+\t  tmp_reg = gen_reg_rtx (HImode);\n+\t  emit_move_insn (tmp_reg, gen_rtx (MEM, HImode, src_reg));\n+\t  emit_move_insn (gen_rtx (MEM, HImode, dest_reg), tmp_reg);\n+\t}\n+      else if (bytes == 1)\t/* move 1 byte */\n+\t{\n+\t  move_bytes = 1;\n+\t  tmp_reg = gen_reg_rtx (QImode);\n+\t  emit_move_insn (tmp_reg, gen_rtx (MEM, QImode, src_reg));\n+\t  emit_move_insn (gen_rtx (MEM, QImode, dest_reg), tmp_reg);\n+\t}\n+      else\n+\t{\t\t\t/* move up to 4 bytes at a time */\n+\t  move_bytes = (bytes > 4) ? 4 : bytes;\n+\t  emit_insn (gen_movstrsi_1reg (dest_reg,\n+\t\t\t\t\tsrc_reg,\n+\t\t\t\t\tGEN_INT (move_bytes),\n+\t\t\t\t\talign_rtx,\n+\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n \f\n /* Return 1 if OP is a load multiple operation.  It is known to be a\n    PARALLEL and the first section will be tested.  */"}, {"sha": "4c5103a44b1aae0ebf01faff093bef8eafd0ec25", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=7e69e1553895935ea3999c97b7007e59e4d5f253", "patch": "@@ -153,22 +153,26 @@ extern int target_flags;\n #define\tMASK_MULTIPLE\t\t0x1000\n #define\tMASK_MULTIPLE_SET\t0x2000\n \n-#define TARGET_POWER\t\t\t(target_flags & MASK_POWER)\n-#define TARGET_POWER2\t\t\t(target_flags & MASK_POWER2)\n-#define TARGET_POWERPC\t\t\t(target_flags & MASK_POWERPC)\n-#define TARGET_PPC_GPOPT\t\t(target_flags & MASK_PPC_GPOPT)\n-#define TARGET_PPC_GFXOPT\t\t(target_flags & MASK_PPC_GFXOPT)\n-#define TARGET_POWERPC64\t\t(target_flags & MASK_POWERPC64)\n-#define TARGET_NEW_MNEMONICS\t\t(target_flags & MASK_NEW_MNEMONICS)\n-#define TARGET_NO_FP_IN_TOC\t\t(target_flags & MASK_NO_FP_IN_TOC)\n-#define TARGET_NO_SUM_IN_TOC\t\t(target_flags & MASK_NO_SUM_IN_TOC)\n-#define TARGET_MINIMAL_TOC\t\t(target_flags & MASK_MINIMAL_TOC)\n-#define TARGET_64BIT\t\t\t(target_flags & MASK_64BIT)\n-#define TARGET_SOFT_FLOAT\t\t(target_flags & MASK_SOFT_FLOAT)\n-#define\tTARGET_MULTIPLE\t\t\t(target_flags & MASK_MULTIPLE)\n-#define\tTARGET_MULTIPLE_SET\t\t(target_flags & MASK_MULTIPLE_SET)\n-\n-#define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n+/* Use string instructions for block moves */\n+#define MASK_STRING\t\t0x4000\n+\n+#define TARGET_POWER\t\t(target_flags & MASK_POWER)\n+#define TARGET_POWER2\t\t(target_flags & MASK_POWER2)\n+#define TARGET_POWERPC\t\t(target_flags & MASK_POWERPC)\n+#define TARGET_PPC_GPOPT\t(target_flags & MASK_PPC_GPOPT)\n+#define TARGET_PPC_GFXOPT\t(target_flags & MASK_PPC_GFXOPT)\n+#define TARGET_POWERPC64\t(target_flags & MASK_POWERPC64)\n+#define TARGET_NEW_MNEMONICS\t(target_flags & MASK_NEW_MNEMONICS)\n+#define TARGET_NO_FP_IN_TOC\t(target_flags & MASK_NO_FP_IN_TOC)\n+#define TARGET_NO_SUM_IN_TOC\t(target_flags & MASK_NO_SUM_IN_TOC)\n+#define TARGET_MINIMAL_TOC\t(target_flags & MASK_MINIMAL_TOC)\n+#define TARGET_64BIT\t\t(target_flags & MASK_64BIT)\n+#define TARGET_SOFT_FLOAT\t(target_flags & MASK_SOFT_FLOAT)\n+#define\tTARGET_MULTIPLE\t\t(target_flags & MASK_MULTIPLE)\n+#define\tTARGET_MULTIPLE_SET\t(target_flags & MASK_MULTIPLE_SET)\n+#define TARGET_STRING\t\t(target_flags & MASK_STRING)\n+\n+#define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n \n /* Run-time compilation parameters selecting different hardware subsets.\n \n@@ -211,6 +215,8 @@ extern int target_flags;\n   {\"multiple\",\t\tMASK_MULTIPLE | MASK_MULTIPLE_SET},\t\\\n   {\"no-multiple\",\t- MASK_MULTIPLE},\t\t\t\\\n   {\"no-multiple\",\tMASK_MULTIPLE_SET},\t\t\t\\\n+  {\"string\",\t\tMASK_STRING},\t\t\t\t\\\n+  {\"no-string\",\t\t- MASK_STRING},\t\t\t\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   {\"\",\t\t\tTARGET_DEFAULT}}\n \n@@ -1493,8 +1499,8 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX (TARGET_MULTIPLE ? 16 : (TARGET_POWERPC64 ? 8 : 4))\n-#define MAX_MOVE_MAX 16\n+#define MOVE_MAX (TARGET_POWERPC64 ? 8 : 4)\n+#define MAX_MOVE_MAX 8\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n    Also non-zero if doing byte operations (specifically shifts) in registers\n@@ -2377,6 +2383,7 @@ extern int lwa_operand ();\n extern int call_operand ();\n extern int current_file_function_operand ();\n extern int input_operand ();\n+extern int expand_block_move ();\n extern int load_multiple_operation ();\n extern int store_multiple_operation ();\n extern int branch_comparison_operator ();"}, {"sha": "f44883fb2d37ca0b795d04ec67f10dcfea0b1f5c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 402, "deletions": 29, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=7e69e1553895935ea3999c97b7007e59e4d5f253", "patch": "@@ -754,7 +754,7 @@\n    {cax.|add.} %3,%1,%2\n    {ai.|addic.} %3,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n-   \n+\n (define_insn \"\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x\")\n \t(compare:CC (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n@@ -767,7 +767,7 @@\n    {cax.|add.} %0,%1,%2\n    {ai.|addic.} %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n-   \n+\n ;; Split an add that we can't do in one insn into two insns, each of which\n ;; does one 16-bit part.  This is used by combine.  Note that the low-order\n ;; add should be last in case the result gets used in an address.\n@@ -2068,7 +2068,7 @@\n       else\n \treturn \\\"{andil.|andi.} %4,%1,%3\\\";\n     }\n-  \n+\n   if (start + size >= 32)\n     operands[3] = const0_rtx;\n   else\n@@ -2096,7 +2096,7 @@\n       operands[3] = gen_rtx (CONST_INT, VOIDmode, (1 << (32 - start)) - 1);\n       return \\\"{andil.|andi.} %0,%1,%3\\\";\n     }\n-  \n+\n   if (start + size >= 32)\n     operands[3] = const0_rtx;\n   else\n@@ -3343,7 +3343,7 @@\n   \"\"\n   \"#\"\n   [(set_attr \"length\" \"8\")])\n-  \n+\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=\")\n \t(plus:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n@@ -3452,7 +3452,7 @@\n \t(reg:SI 3))]\n   \"TARGET_HARD_FLOAT\"\n   \"\n-{ \n+{\n   rs6000_trunc_used = 1;\n }\")\n \n@@ -4105,7 +4105,7 @@\n   \"\n { operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n   operands[3] = operand_subword (operands[1], 0, 0, SFmode); }\")\n-  \n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"fp_reg_or_mem_operand\" \"=f,f,m\")\n \t(match_operand:SF 1 \"input_operand\" \"f,m,f\"))]\n@@ -4391,7 +4391,7 @@\n   [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n \t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n \t      (clobber (scratch:SI))])]\n-  \"TARGET_MULTIPLE || TARGET_POWERPC64\"\n+  \"TARGET_STRING || TARGET_POWERPC64\"\n   \"\n {\n   if (GET_CODE (operands[0]) == MEM)\n@@ -4419,7 +4419,7 @@\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,r,Q,m\"))\n    (clobber (match_scratch:SI 2 \"=q,q#X,X,X,X\"))]\n-  \"TARGET_MULTIPLE && TARGET_POWER && ! TARGET_POWERPC64\n+  \"TARGET_STRING && TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n {\n@@ -4473,7 +4473,7 @@\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=m,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,m\"))\n    (clobber (match_scratch:SI 2 \"=X,X,X\"))]\n-  \"TARGET_MULTIPLE && !TARGET_POWER && ! TARGET_POWERPC64\n+  \"TARGET_STRING && !TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n {\n@@ -4552,7 +4552,7 @@\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n \t\t\t  (match_operand:SI 1 \"\" \"\"))\n \t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"TARGET_MULTIPLE\"\n+  \"TARGET_STRING\"\n   \"\n {\n   int regno;\n@@ -4587,7 +4587,7 @@\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=r\")\n \t\t\t (match_operand:SI 2 \"indirect_operand\" \"Q\"))])]\n-  \"TARGET_MULTIPLE\"\n+  \"TARGET_STRING\"\n   \"*\n {\n   /* We have to handle the case where the pseudo used to contain the address\n@@ -4621,7 +4621,7 @@\n \t\t\t  (match_operand:SI 1 \"\" \"\"))\n \t\t     (clobber (scratch:SI))\n \t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"TARGET_MULTIPLE\"\n+  \"TARGET_STRING\"\n   \"\n {\n   int regno;\n@@ -4663,18 +4663,391 @@\n \t\t   [(set (match_operand:SI 1 \"indirect_operand\" \"=Q\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n \t\t    (clobber (match_scratch:SI 3 \"=q\"))])]\n-  \"TARGET_MULTIPLE && TARGET_POWER\"\n+  \"TARGET_STRING && TARGET_POWER\"\n   \"{stsi|stswi} %2,%P1,%O0\")\n \n (define_insn \"\"\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"indirect_operand\" \"=Q\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n \t\t    (clobber (match_scratch:SI 3 \"X\"))])]\n-  \"TARGET_MULTIPLE && !TARGET_POWER\"\n+  \"TARGET_STRING && !TARGET_POWER\"\n   \"{stsi|stswi} %2,%P1,%O0\")\n+\n+\f\n+;; String/block move insn.\n+;; Argument 0 is the destination\n+;; Argument 1 is the source\n+;; Argument 2 is the length\n+;; Argument 3 is the alignment\n+\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (expand_block_move (operands))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+;; Move up to 32 bytes at a time.  The fixed registers are needed because the\n+;; register allocator doesn't have a clue about allocating 8 word registers\n+(define_expand \"movstrsi_8reg\"\n+  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))\n+\t      (set (match_dup 1)\n+\t\t   (plus:SI (match_dup 1)\n+\t\t\t    (match_dup 4)))\n+\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (reg:SI  5))\n+\t      (clobber (reg:SI  6))\n+\t      (clobber (reg:SI  7))\n+\t      (clobber (reg:SI  8))\n+\t      (clobber (reg:SI  9))\n+\t      (clobber (reg:SI 10))\n+\t      (clobber (reg:SI 11))\n+\t      (clobber (reg:SI 12))\n+\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  \"TARGET_STRING\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"r,r\"))\n+   (clobber (reg:SI  6))\n+   (clobber (reg:SI  7))\n+   (clobber (reg:SI  8))\n+   (clobber (reg:SI  9))\n+   (clobber (reg:SI 10))\n+   (clobber (reg:SI 11))\n+   (clobber (reg:SI 12))\n+   (clobber (match_scratch:SI 6 \"=q,q\"))]\n+  \"TARGET_STRING && TARGET_POWER\n+   && ((INTVAL (operands[2]) > 24 && INTVAL (operands[2]) < 32) || INTVAL (operands[2]) == 0)\n+   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 12)\n+   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 12)\n+   && REGNO (operands[5]) == 5\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"r,r\"))\n+   (clobber (reg:SI  6))\n+   (clobber (reg:SI  7))\n+   (clobber (reg:SI  8))\n+   (clobber (reg:SI  9))\n+   (clobber (reg:SI 10))\n+   (clobber (reg:SI 11))\n+   (clobber (reg:SI 12))\n+   (clobber (match_scratch:SI 6 \"X,X\"))]\n+  \"TARGET_STRING && !TARGET_POWER\n+   && ((INTVAL (operands[2]) > 24 && INTVAL (operands[2]) < 32) || INTVAL (operands[2]) == 0)\n+   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 12)\n+   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 12)\n+   && REGNO (operands[5]) == 5\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+;; Move up to 24 bytes at a time.  The fixed registers are needed because the\n+;; register allocator doesn't have a clue about allocating 6 word registers\n+(define_expand \"movstrsi_6reg\"\n+  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))\n+\t      (set (match_dup 1)\n+\t\t   (plus:SI (match_dup 1)\n+\t\t\t    (match_dup 4)))\n+\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (reg:SI  7))\n+\t      (clobber (reg:SI  8))\n+\t      (clobber (reg:SI  9))\n+\t      (clobber (reg:SI 10))\n+\t      (clobber (reg:SI 11))\n+\t      (clobber (reg:SI 12))\n+\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  \"TARGET_STRING\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"r,r\"))\n+   (clobber (reg:SI  8))\n+   (clobber (reg:SI  9))\n+   (clobber (reg:SI 10))\n+   (clobber (reg:SI 11))\n+   (clobber (reg:SI 12))\n+   (clobber (match_scratch:SI 6 \"=q,q\"))]\n+  \"TARGET_STRING && TARGET_POWER\n+   && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24\n+   && (REGNO (operands[0]) < 7 || REGNO (operands[0]) > 12)\n+   && (REGNO (operands[1]) < 7 || REGNO (operands[1]) > 12)\n+   && REGNO (operands[5]) == 7\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"r,r\"))\n+   (clobber (reg:SI  8))\n+   (clobber (reg:SI  9))\n+   (clobber (reg:SI 10))\n+   (clobber (reg:SI 11))\n+   (clobber (reg:SI 12))\n+   (clobber (match_scratch:SI 6 \"X,X\"))]\n+  \"TARGET_STRING && !TARGET_POWER\n+   && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 32\n+   && (REGNO (operands[0]) < 7 || REGNO (operands[0]) > 12)\n+   && (REGNO (operands[1]) < 7 || REGNO (operands[1]) > 12)\n+   && REGNO (operands[5]) == 7\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+;; Move up to 16 bytes at a time, using 4 fixed registers to avoid spill problems\n+;; with TImode\n+(define_expand \"movstrsi_4reg\"\n+  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))\n+\t      (set (match_dup 1)\n+\t\t   (plus:SI (match_dup 1)\n+\t\t\t    (match_dup 4)))\n+\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (reg:SI  9))\n+\t      (clobber (reg:SI 10))\n+\t      (clobber (reg:SI 11))\n+\t      (clobber (reg:SI 12))\n+\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  \"TARGET_STRING\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"r,r\"))\n+   (clobber (reg:SI 10))\n+   (clobber (reg:SI 11))\n+   (clobber (reg:SI 12))\n+   (clobber (match_scratch:SI 6 \"=q,q\"))]\n+  \"TARGET_STRING && TARGET_POWER\n+   && INTVAL (operands[2]) > 8 && INTVAL (operands[2]) <= 16\n+   && (REGNO (operands[0]) < 9 || REGNO (operands[0]) > 12)\n+   && (REGNO (operands[1]) < 9 || REGNO (operands[1]) > 12)\n+   && REGNO (operands[5]) == 9\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"r,r\"))\n+   (clobber (reg:SI 10))\n+   (clobber (reg:SI 11))\n+   (clobber (reg:SI 12))\n+   (clobber (match_scratch:SI 6 \"X,X\"))]\n+  \"TARGET_STRING && !TARGET_POWER\n+   && INTVAL (operands[2]) > 8 && INTVAL (operands[2]) <= 16\n+   && (REGNO (operands[0]) < 9 || REGNO (operands[0]) > 12)\n+   && (REGNO (operands[1]) < 9 || REGNO (operands[1]) > 12)\n+   && REGNO (operands[5]) == 9\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+;; Move up to 8 bytes at a time.\n+(define_expand \"movstrsi_2reg\"\n+  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))\n+\t      (set (match_dup 1)\n+\t\t   (plus:SI (match_dup 1)\n+\t\t\t    (match_dup 4)))\n+\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (match_scratch:DI 5 \"\"))\n+\t      (clobber (match_scratch:SI 6 \"\"))])]\n+  \"TARGET_STRING && !TARGET_64BIT\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_scratch:DI 5 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 6 \"=q,q\"))]\n+  \"TARGET_STRING && TARGET_POWER && !TARGET_64BIT\n+    && INTVAL (operands[2]) > 4 && INTVAL (operands[2]) <= 8\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_scratch:DI 5 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 6 \"X,X\"))]\n+  \"TARGET_STRING && !TARGET_POWER && !TARGET_64BIT\n+   && INTVAL (operands[2]) > 4 && INTVAL (operands[2]) <= 8\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+;; Move up to 4 bytes at a time.\n+(define_expand \"movstrsi_1reg\"\n+  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))\n+\t      (set (match_dup 1)\n+\t\t   (plus:SI (match_dup 1)\n+\t\t\t    (match_dup 4)))\n+\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (match_scratch:SI 5 \"\"))\n+\t      (clobber (match_scratch:SI 6 \"\"))])]\n+  \"TARGET_STRING\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_scratch:SI 5 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 6 \"=q,q\"))]\n+  \"TARGET_STRING && TARGET_POWER\n+   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 4\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+&b,&b\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+&b,&b\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 4 \"immediate_operand\" \"O,i\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 4)))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"i,i\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_scratch:SI 5 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 6 \"X,X\"))]\n+  \"TARGET_STRING && !TARGET_POWER\n+   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 4\"\n+  \"@\n+   {lsi|lswi} %5,%1,%2\\;{stsi|stswi} %5,%0,%2\n+   {lsi|lswi} %5,%1,%2\\;{cal %0,%4(%0)|addi %0,%0,%4}\\;{stsi|stswi} %5,%0,%2\\;{cal %1,%4(%1)|addi %1,%1,%4}\"\n+  [(set_attr \"length\" \"8,16\")])\n+\n \f\n-;; Define insns that do load or store with update.  Some of these we can \n+;; Define insns that do load or store with update.  Some of these we can\n ;; get by using pre-decrement or pre-increment, but the hardware can also\n ;; do cases where the increment is not the size of the object.\n ;;\n@@ -4900,7 +5273,7 @@\n ;; Next come insns related to the calling sequence.\n ;;\n ;; First, an insn to allocate new stack space for dynamic use (e.g., alloca).\n-;; We move the back-chain and decrement the stack pointer.  \n+;; We move the back-chain and decrement the stack pointer.\n \n (define_expand \"allocate_stack\"\n   [(set (reg:SI 1)\n@@ -4957,7 +5330,7 @@\n   emit_move_insn (operand_subword (operands[0], 1, 0, DImode), operands[1]);\n   DONE;\n }\")\n-\t\t  \n+\n (define_expand \"restore_stack_nonlocal\"\n   [(match_operand:SI 0 \"register_operand\" \"\")\n    (match_operand:DI 1 \"memory_operand\" \"\")]\n@@ -4976,7 +5349,7 @@\n ;; A function pointer is a pointer to a data area whose first word contains\n ;; the actual address of the function, whose second word contains a pointer\n ;; to its TOC, and whose third word contains a value to place in the static\n-;; chain register (r11).  Note that if we load the static chain, our \n+;; chain register (r11).  Note that if we load the static chain, our\n ;; \"trampoline\" need not have any executable code.\n ;;\n ;; operands[0] is an SImode pseudo in which we place the address of the\n@@ -5149,7 +5522,7 @@\n   \"\")\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n-;; signed & unsigned, and one type of branch.  \n+;; signed & unsigned, and one type of branch.\n ;;\n ;; Start with the DEFINE_EXPANDs to generate the rtl for compares, scc\n ;; insns, and branches.  We store the operands of compares until we see\n@@ -5540,7 +5913,7 @@\n   \"\"\n   \"#\"\n   [(set_attr \"length\" \"8\")])\n-   \n+\n (define_insn \"\"\n   [(set (match_operand:CCUNS 3 \"cc_reg_operand\" \"=y\")\n \t(compare:CCUNS (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n@@ -5550,7 +5923,7 @@\n   \"\"\n   \"#\"\n   [(set_attr \"length\" \"8\")])\n-   \n+\n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"\")\n \t(compare:CC (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n@@ -5750,7 +6123,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,x,x,x\")\n-\t(compare:CC \n+\t(compare:CC\n \t (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n \t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n \t (const_int 0)))\n@@ -5799,7 +6172,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,x\")\n-\t(compare:CC \n+\t(compare:CC\n \t (plus:SI\n \t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n \t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n@@ -5818,7 +6191,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:CC 5 \"cc_reg_operand\" \"=x,x,x,x,x\")\n-\t(compare:CC \n+\t(compare:CC\n \t (plus:SI\n \t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n \t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n@@ -6805,7 +7178,7 @@\n   \"\"\n   \"{cror 0,0,0|nop}\")\n \f\n-;; Define the subtract-one-and-jump insns, starting with the template \n+;; Define the subtract-one-and-jump insns, starting with the template\n ;; so loop.c knows what to generate.\n \n (define_expand \"decrement_and_branchsi\"\n@@ -6819,7 +7192,7 @@\n \n ;; We need to be able to do this for any operand, including MEM, or we\n ;; will cause reload to blow up since we don't allow output reloads on\n-;; JUMP_INSNs. \n+;; JUMP_INSNs.\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"0,*r,*r\")\n@@ -6842,7 +7215,7 @@\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"*,12,16\")])\n-\t\t\t       \n+\n ;; Similar, but we can use GE since we have a REG_NONNEG.\n (define_insn \"\"\n   [(set (pc)\n@@ -6866,7 +7239,7 @@\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"*,12,16\")])\n-\t\t\t       \n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else (eq (match_operand:SI 1 \"register_operand\" \"0,*r,*r\")"}, {"sha": "4ad60165610d8ace6d9e65f0abcd2c47e854f219", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=7e69e1553895935ea3999c97b7007e59e4d5f253", "patch": "@@ -28,12 +28,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define MASK_LITTLE_ENDIAN\t0x04000000\t/* target is little endian */\n \n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n-#define\tTARGET_BITFIELD_TYPE\t(! TARGET_NO_BITFIELD_TYPE)\n #define TARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n #define TARGET_RELOCATABLE\t(target_flags & MASK_RELOCATABLE)\n #define TARGET_NO_TRACEBACK\t(target_flags & MASK_NO_TRACEBACK)\n-#define\tTARGET_TRACEBACK\t(! TARGET_NO_TRACEBACK)\n #define TARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n+\n+#define\tTARGET_BITFIELD_TYPE\t(! TARGET_NO_BITFIELD_TYPE)\n+#define\tTARGET_TRACEBACK\t(! TARGET_NO_TRACEBACK)\n #define TARGET_BIG_ENDIAN\t(! TARGET_LITTLE_ENDIAN)\n \n #undef\tSUBTARGET_SWITCHES\n@@ -51,17 +52,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n   { \"big-endian\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big\",\t\t-MASK_LITTLE_ENDIAN },\n \n-/* If the user wants little endian support, don't allow -mmultiple */\n-#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_LITTLE_ENDIAN && TARGET_MULTIPLE)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      target_flags &= ~MASK_MULTIPLE;\t\t\t\t\t\\\n-      if (TARGET_MULTIPLE_SET)\t\t\t\t\t\t\\\n-\twarning (\"-mmultiple is not supported on little endian PowerPC systems\"); \\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n #include \"rs6000/powerpc.h\"\n \n /* Override default big endianism */\n@@ -321,6 +311,9 @@ extern int rs6000_pic_labelno;\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n+%{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n+%{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n+%{!mlittle: %{!mlittle-endian: -D_BIG_ENDIAN -Amachine(bigendian)}} \\\n %{!mcpu*: \\\n   %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n   %{mpower2: -D_ARCH_PWR2} \\"}, {"sha": "3ce7796324adba72673965fbf7318bc08a9f2107", "filename": "gcc/config/rs6000/sysv4le.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e69e1553895935ea3999c97b7007e59e4d5f253/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4le.h?ref=7e69e1553895935ea3999c97b7007e59e4d5f253", "patch": "@@ -23,3 +23,37 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_LITTLE_ENDIAN)\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"\\\n+%{posix: -D_POSIX_SOURCE} \\\n+%{mrelocatable: -D_RELOCATABLE} \\\n+%{mbig: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n+%{mbig-endian: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n+%{!mbig: %{!mbig-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)}} \\\n+%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n+  %{mpower2: -D_ARCH_PWR2} \\\n+  %{mpowerpc*: -D_ARCH_PPC} \\\n+  %{mno-powerpc: %{!mpower: %{!mpower2: -D_ARCH_COM}}} \\\n+  %{!mno-powerpc: -D_ARCH_PPC}} \\\n+%{mcpu=common: -D_ARCH_COM} \\\n+%{mcpu=power: -D_ARCH_PWR} \\\n+%{mcpu=powerpc: -D_ARCH_PPC} \\\n+%{mcpu=rios: -D_ARCH_PWR} \\\n+%{mcpu=rios1: -D_ARCH_PWR} \\\n+%{mcpu=rios2: -D_ARCH_PWR2} \\\n+%{mcpu=rsc: -D_ARCH_PWR} \\\n+%{mcpu=rsc1: -D_ARCH_PWR} \\\n+%{mcpu=403: -D_ARCH_PPC} \\\n+%{mcpu=mpc403: -D_ARCH_PPC} \\\n+%{mcpu=ppc403: -D_ARCH_PPC} \\\n+%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=mpc601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=ppc601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=603: -D_ARCH_PPC} \\\n+%{mcpu=mpc603: -D_ARCH_PPC} \\\n+%{mcpu=ppc603: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=mpc604: -D_ARCH_PPC} \\\n+%{mcpu=ppc604: -D_ARCH_PPC}\""}]}