{"sha": "0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU4ZDg1NGViOGJiZmM0NGMxZmQ5ZDJmYTZlMDc1MTRkMjkzMmUwZQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-07-31T18:32:41Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-07-31T18:32:41Z"}, "message": "re PR fortran/42418 (PROCEDURE: Rejects interface which is both specific and generic procedure)\n\n2012-07-31  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42418\n\t* decl.c (match_procedure_interface): Move some checks to\n\t'resolve_procedure_interface'. Set flavor if appropriate.\n\t* expr.c (gfc_check_pointer_assign): Cleanup of 'gfc_is_intrinsic'.\n\t* intrinsic.c (gfc_is_intrinsic): Additional checks for attributes which\n\tidentify a procedure as being non-intrinsic.\n\t* resolve.c (resolve_procedure_interface): Checks moved here from\n\t'match_procedure_interface'. Minor cleanup.\n\t(resolve_formal_arglist,resolve_symbol): Cleanup of\n\t'resolve_procedure_interface'\n\t(resolve_actual_arglist,is_external_proc): Cleanup of\n\t'gfc_is_intrinsic'.\n\n2012-07-31  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42418\n\t* gfortran.dg/proc_decl_29.f90: New.\n\nFrom-SVN: r190017", "tree": {"sha": "9616650ee31fffec962f6770ab78c4b7b3506558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9616650ee31fffec962f6770ab78c4b7b3506558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab6d55ef6209019d4268546aa030928b72f59b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6d55ef6209019d4268546aa030928b72f59b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab6d55ef6209019d4268546aa030928b72f59b49"}], "stats": {"total": 163, "additions": 111, "deletions": 52}, "files": [{"sha": "08dce7f3f5851228d694efbb2490d28fa9bf7929", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -1,3 +1,18 @@\n+2012-07-31  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42418\n+\t* decl.c (match_procedure_interface): Move some checks to\n+\t'resolve_procedure_interface'. Set flavor if appropriate.\n+\t* expr.c (gfc_check_pointer_assign): Cleanup of 'gfc_is_intrinsic'.\n+\t* intrinsic.c (gfc_is_intrinsic): Additional checks for attributes which\n+\tidentify a procedure as being non-intrinsic.\n+\t* resolve.c (resolve_procedure_interface): Checks moved here from\n+\t'match_procedure_interface'. Minor cleanup.\n+\t(resolve_formal_arglist,resolve_symbol): Cleanup of\n+\t'resolve_procedure_interface'\n+\t(resolve_actual_arglist,is_external_proc): Cleanup of\n+\t'gfc_is_intrinsic'.\n+\n 2012-07-31  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/54134"}, {"sha": "083326ed37db9df16d0b1afe42e970028328750d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -4792,41 +4792,20 @@ match_procedure_interface (gfc_symbol **proc_if)\n   gfc_current_ns = old_ns;\n   *proc_if = st->n.sym;\n \n-  /* Various interface checks.  */\n   if (*proc_if)\n     {\n       (*proc_if)->refs++;\n       /* Resolve interface if possible. That way, attr.procedure is only set\n \t if it is declared by a later procedure-declaration-stmt, which is\n-\t invalid per C1212.  */\n+\t invalid per F08:C1216 (cf. resolve_procedure_interface).  */\n       while ((*proc_if)->ts.interface)\n \t*proc_if = (*proc_if)->ts.interface;\n \n-      if ((*proc_if)->generic)\n-\t{\n-\t  gfc_error (\"Interface '%s' at %C may not be generic\",\n-\t\t     (*proc_if)->name);\n-\t  return MATCH_ERROR;\n-\t}\n-      if ((*proc_if)->attr.proc == PROC_ST_FUNCTION)\n-\t{\n-\t  gfc_error (\"Interface '%s' at %C may not be a statement function\",\n-\t\t     (*proc_if)->name);\n-\t  return MATCH_ERROR;\n-\t}\n-      /* Handle intrinsic procedures.  */\n-      if (!((*proc_if)->attr.external || (*proc_if)->attr.use_assoc\n-\t    || (*proc_if)->attr.if_source == IFSRC_IFBODY)\n-\t  && (gfc_is_intrinsic ((*proc_if), 0, gfc_current_locus)\n-\t      || gfc_is_intrinsic ((*proc_if), 1, gfc_current_locus)))\n-\t(*proc_if)->attr.intrinsic = 1;\n-      if ((*proc_if)->attr.intrinsic\n-\t  && !gfc_intrinsic_actual_ok ((*proc_if)->name, 0))\n-\t{\n-\t  gfc_error (\"Intrinsic procedure '%s' not allowed \"\n-\t\t    \"in PROCEDURE statement at %C\", (*proc_if)->name);\n-\t  return MATCH_ERROR;\n-\t}\n+      if ((*proc_if)->attr.flavor == FL_UNKNOWN\n+\t  && (*proc_if)->ts.type == BT_UNKNOWN\n+\t  && gfc_add_flavor (&(*proc_if)->attr, FL_PROCEDURE,\n+\t\t\t      (*proc_if)->name, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n     }\n \n got_ts:"}, {"sha": "3a3ba9a9132b2b5e4bbe8c81cd1d55f85649a284", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -3426,8 +3426,6 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       \t  /* Check for intrinsics.  */\n \t  gfc_symbol *sym = rvalue->symtree->n.sym;\n \t  if (!sym->attr.intrinsic\n-\t      && !(sym->attr.contained || sym->attr.use_assoc\n-\t\t   || sym->attr.external || sym->attr.if_source == IFSRC_IFBODY)\n \t      && (gfc_is_intrinsic (sym, 0, sym->declared_at)\n \t\t  || gfc_is_intrinsic (sym, 1, sym->declared_at)))\n \t    {"}, {"sha": "60c68feb624c03fdbb05311f1c80ae92d45c7738", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -902,9 +902,9 @@ gfc_intrinsic_actual_ok (const char *name, const bool subroutine_flag)\n }\n \n \n-/* Given a symbol, find out if it is (and is to be treated) an intrinsic.  If\n-   it's name refers to an intrinsic but this intrinsic is not included in the\n-   selected standard, this returns FALSE and sets the symbol's external\n+/* Given a symbol, find out if it is (and is to be treated as) an intrinsic.\n+   If its name refers to an intrinsic, but this intrinsic is not included in\n+   the selected standard, this returns FALSE and sets the symbol's external\n    attribute.  */\n \n bool\n@@ -913,10 +913,13 @@ gfc_is_intrinsic (gfc_symbol* sym, int subroutine_flag, locus loc)\n   gfc_intrinsic_sym* isym;\n   const char* symstd;\n \n-  /* If INTRINSIC/EXTERNAL state is already known, return.  */\n+  /* If INTRINSIC attribute is already known, return.  */\n   if (sym->attr.intrinsic)\n     return true;\n-  if (sym->attr.external)\n+\n+  /* Check for attributes which prevent the symbol from being INTRINSIC.  */\n+  if (sym->attr.external || sym->attr.contained\n+      || sym->attr.if_source == IFSRC_IFBODY)\n     return false;\n \n   if (subroutine_flag)"}, {"sha": "a6dd0dacdd0c74aed81a9ba8f2f96d6d8e3a8e61", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -146,24 +146,58 @@ static void resolve_symbol (gfc_symbol *sym);\n static gfc_try\n resolve_procedure_interface (gfc_symbol *sym)\n {\n-  if (sym->ts.interface == sym)\n+  gfc_symbol *ifc = sym->ts.interface;\n+\n+  if (!ifc)\n+    return SUCCESS;\n+\n+  /* Several checks for F08:C1216.  */\n+  if (ifc == sym)\n     {\n       gfc_error (\"PROCEDURE '%s' at %L may not be used as its own interface\",\n \t\t sym->name, &sym->declared_at);\n       return FAILURE;\n     }\n-  if (sym->ts.interface->attr.procedure)\n+  if (ifc->attr.procedure)\n     {\n       gfc_error (\"Interface '%s', used by procedure '%s' at %L, is declared \"\n-\t\t \"in a later PROCEDURE statement\", sym->ts.interface->name,\n+\t\t \"in a later PROCEDURE statement\", ifc->name,\n \t\t sym->name, &sym->declared_at);\n       return FAILURE;\n     }\n+  if (ifc->generic)\n+    {\n+      /* For generic interfaces, check if there is\n+\t a specific procedure with the same name.  */\n+      gfc_interface *gen = ifc->generic;\n+      while (gen && strcmp (gen->sym->name, ifc->name) != 0)\n+\tgen = gen->next;\n+      if (!gen)\n+\t{\n+\t  gfc_error (\"Interface '%s' at %L may not be generic\",\n+\t\t     ifc->name, &sym->declared_at);\n+\t  return FAILURE;\n+\t}\n+    }\n+  if (ifc->attr.proc == PROC_ST_FUNCTION)\n+    {\n+      gfc_error (\"Interface '%s' at %L may not be a statement function\",\n+\t\t ifc->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+  if (gfc_is_intrinsic (ifc, 0, ifc->declared_at)\n+      || gfc_is_intrinsic (ifc, 1, ifc->declared_at))\n+    ifc->attr.intrinsic = 1;\n+  if (ifc->attr.intrinsic && !gfc_intrinsic_actual_ok (ifc->name, 0))\n+    {\n+      gfc_error (\"Intrinsic procedure '%s' not allowed in \"\n+\t\t \"PROCEDURE statement at %L\", ifc->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n \n   /* Get the attributes from the interface (now resolved).  */\n-  if (sym->ts.interface->attr.if_source || sym->ts.interface->attr.intrinsic)\n+  if (ifc->attr.if_source || ifc->attr.intrinsic)\n     {\n-      gfc_symbol *ifc = sym->ts.interface;\n       resolve_symbol (ifc);\n \n       if (ifc->attr.intrinsic)\n@@ -212,10 +246,10 @@ resolve_procedure_interface (gfc_symbol *sym)\n \t    return FAILURE;\n \t}\n     }\n-  else if (sym->ts.interface->name[0] != '\\0')\n+  else if (ifc->name[0] != '\\0')\n     {\n       gfc_error (\"Interface '%s' of procedure '%s' at %L must be explicit\",\n-\t\t sym->ts.interface->name, sym->name, &sym->declared_at);\n+\t\t ifc->name, sym->name, &sym->declared_at);\n       return FAILURE;\n     }\n \n@@ -273,9 +307,9 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t\t       &proc->declared_at);\n \t  continue;\n \t}\n-      else if (sym->attr.procedure && sym->ts.interface\n-\t       && sym->attr.if_source != IFSRC_DECL)\n-\tresolve_procedure_interface (sym);\n+      else if (sym->attr.procedure && sym->attr.if_source != IFSRC_DECL\n+\t       && resolve_procedure_interface (sym) == FAILURE)\n+\treturn;\n \n       if (sym->attr.if_source != IFSRC_UNKNOWN)\n \tresolve_formal_arglist (sym);\n@@ -1672,10 +1706,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \n \t  /* If a procedure is not already determined to be something else\n \t     check if it is intrinsic.  */\n-\t  if (!sym->attr.intrinsic\n-\t      && !(sym->attr.external || sym->attr.use_assoc\n-\t\t   || sym->attr.if_source == IFSRC_IFBODY)\n-\t      && gfc_is_intrinsic (sym, sym->attr.subroutine, e->where))\n+\t  if (gfc_is_intrinsic (sym, sym->attr.subroutine, e->where))\n \t    sym->attr.intrinsic = 1;\n \n \t  if (sym->attr.proc == PROC_ST_FUNCTION)\n@@ -2601,8 +2632,7 @@ static bool\n is_external_proc (gfc_symbol *sym)\n {\n   if (!sym->attr.dummy && !sym->attr.contained\n-\t&& !(sym->attr.intrinsic\n-\t      || gfc_is_intrinsic (sym, sym->attr.subroutine, sym->declared_at))\n+\t&& !gfc_is_intrinsic (sym, sym->attr.subroutine, sym->declared_at)\n \t&& sym->attr.proc != PROC_ST_FUNCTION\n \t&& !sym->attr.proc_pointer\n \t&& !sym->attr.use_assoc\n@@ -12516,8 +12546,7 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->attr.external && sym->ts.type != BT_UNKNOWN && !sym->attr.function)\n     gfc_add_function (&sym->attr, sym->name, &sym->declared_at);\n \n-  if (sym->attr.procedure && sym->ts.interface\n-      && sym->attr.if_source != IFSRC_DECL\n+  if (sym->attr.procedure && sym->attr.if_source != IFSRC_DECL\n       && resolve_procedure_interface (sym) == FAILURE)\n     return;\n "}, {"sha": "e210d005d1fc090af516671f5dad59fb14e80bcc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -1,3 +1,8 @@\n+2012-07-31  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42418\n+\t* gfortran.dg/proc_decl_29.f90: New.\n+\n 2012-07-31  Dehao Chen  <dehao@google.com>\n \n \t* gcc.dg/predict-7.c: New test."}, {"sha": "6a92118409fb2de6c8e80afaa4ee348c07707552", "filename": "gcc/testsuite/gfortran.dg/proc_decl_29.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_29.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_29.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_29.f90?ref=0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+!\n+! PR 42418: PROCEDURE: Rejects interface which is both specific and generic procedure\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+  interface gen\n+    procedure gen\n+  end interface\n+\n+  procedure(gen)  :: p1\n+  procedure(gen2) :: p2  ! { dg-error \"may not be generic\" }\n+  procedure(sf)   :: p3  ! { dg-error \"may not be a statement function\" }\n+  procedure(char) :: p4\n+\n+  interface gen2\n+    procedure char\n+  end interface\n+\n+  sf(x) = x**2  ! { dg-warning \"Obsolescent feature\" }\n+\n+contains\n+\n+  subroutine gen\n+  end subroutine\n+\n+  subroutine char\n+  end subroutine\n+\n+end"}]}