{"sha": "5ca8e6f76b92f52c2a6faa4ff5801469a8868160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNhOGU2Zjc2YjkyZjUyYzJhNmZhYTRmZjU4MDE0NjlhODg2ODE2MA==", "commit": {"author": {"name": "Philip Blundell", "email": "pb@nexus.co.uk", "date": "1999-08-27T07:02:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-27T07:02:37Z"}, "message": "jump.c (duplicate_loop_exit_test): Call reg_scan_update after creating new registers.\n\n        * jump.c (duplicate_loop_exit_test): Call reg_scan_update after\n        creating new registers.\n\nFrom-SVN: r28920", "tree": {"sha": "53e589dce3f5be4a6a85aa6fc23804c84e84a929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53e589dce3f5be4a6a85aa6fc23804c84e84a929"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ca8e6f76b92f52c2a6faa4ff5801469a8868160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca8e6f76b92f52c2a6faa4ff5801469a8868160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca8e6f76b92f52c2a6faa4ff5801469a8868160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca8e6f76b92f52c2a6faa4ff5801469a8868160/comments", "author": null, "committer": null, "parents": [{"sha": "9c23aa47702e0861b41b3fa47ebd4cb21b469334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c23aa47702e0861b41b3fa47ebd4cb21b469334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c23aa47702e0861b41b3fa47ebd4cb21b469334"}], "stats": {"total": 143, "additions": 84, "deletions": 59}, "files": [{"sha": "066ed4192f0d763517572c3dc1a620929b486879", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca8e6f76b92f52c2a6faa4ff5801469a8868160/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca8e6f76b92f52c2a6faa4ff5801469a8868160/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ca8e6f76b92f52c2a6faa4ff5801469a8868160", "patch": "@@ -1,3 +1,8 @@\n+Fri Aug 27 01:01:51 1999  Philip Blundell  <pb@nexus.co.uk>  \n+\n+\t* jump.c (duplicate_loop_exit_test): Call reg_scan_update after\n+\tcreating new registers.\n+\n 1999-08-26 23:09 -0700  Zack Weinberg  <zack@bitmover.com>\n \n \t* i386.h: Declare ix86_cpu_string, ix86_arch_string,"}, {"sha": "7a4caaae13c1f315d785a00b5f37b05c3a5d4d8a", "filename": "gcc/jump.c", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca8e6f76b92f52c2a6faa4ff5801469a8868160/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca8e6f76b92f52c2a6faa4ff5801469a8868160/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=5ca8e6f76b92f52c2a6faa4ff5801469a8868160", "patch": "@@ -2587,7 +2587,7 @@ duplicate_loop_exit_test (loop_start)\n      rtx loop_start;\n {\n   rtx insn, set, reg, p, link;\n-  rtx copy = 0;\n+  rtx copy = 0, first_copy = 0;\n   int num_insns = 0;\n   rtx exitcode = NEXT_INSN (JUMP_LABEL (next_nonnote_insn (loop_start)));\n   rtx lastexit;\n@@ -2700,72 +2700,87 @@ duplicate_loop_exit_test (loop_start)\n \n   /* Now copy each insn.  */\n   for (insn = exitcode; insn != lastexit; insn = NEXT_INSN (insn))\n-    switch (GET_CODE (insn))\n-      {\n-      case BARRIER:\n-\tcopy = emit_barrier_before (loop_start);\n-\tbreak;\n-      case NOTE:\n-\t/* Only copy line-number notes.  */\n-\tif (NOTE_LINE_NUMBER (insn) >= 0)\n-\t  {\n-\t    copy = emit_note_before (NOTE_LINE_NUMBER (insn), loop_start);\n-\t    NOTE_SOURCE_FILE (copy) = NOTE_SOURCE_FILE (insn);\n-\t  }\n-\tbreak;\n-\n-      case INSN:\n-\tcopy = emit_insn_before (copy_rtx (PATTERN (insn)), loop_start);\n-\tif (reg_map)\n-\t  replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n-\n-\tmark_jump_label (PATTERN (copy), copy, 0);\n-\n-\t/* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n-\t   make them.  */\n-\tfor (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t  if (REG_NOTE_KIND (link) != REG_LABEL)\n-\t    REG_NOTES (copy)\n-\t      = copy_rtx (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n-\t\t\t\t\t     XEXP (link, 0),\n-\t\t\t\t\t     REG_NOTES (copy)));\n-\tif (reg_map && REG_NOTES (copy))\n-\t  replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n-\tbreak;\n-\n-      case JUMP_INSN:\n-\tcopy = emit_jump_insn_before (copy_rtx (PATTERN (insn)), loop_start);\n-\tif (reg_map)\n-\t  replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n-\tmark_jump_label (PATTERN (copy), copy, 0);\n-\tif (REG_NOTES (insn))\n-\t  {\n-\t    REG_NOTES (copy) = copy_rtx (REG_NOTES (insn));\n-\t    if (reg_map)\n-\t      replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n-\t  }\n-\t\n-\t/* If this is a simple jump, add it to the jump chain.  */\n-\n-\tif (INSN_UID (copy) < max_jump_chain && JUMP_LABEL (copy)\n-\t    && simplejump_p (copy))\n-\t  {\n-\t    jump_chain[INSN_UID (copy)]\n-\t      = jump_chain[INSN_UID (JUMP_LABEL (copy))];\n-\t    jump_chain[INSN_UID (JUMP_LABEL (copy))] = copy;\n-\t  }\n-\tbreak;\n+    {\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase BARRIER:\n+\t  copy = emit_barrier_before (loop_start);\n+\t  break;\n+\tcase NOTE:\n+\t  /* Only copy line-number notes.  */\n+\t  if (NOTE_LINE_NUMBER (insn) >= 0)\n+\t    {\n+\t      copy = emit_note_before (NOTE_LINE_NUMBER (insn), loop_start);\n+\t      NOTE_SOURCE_FILE (copy) = NOTE_SOURCE_FILE (insn);\n+\t    }\n+\t  break;\n+\t  \n+\tcase INSN:\n+\t  copy = emit_insn_before (copy_rtx (PATTERN (insn)), loop_start);\n+\t  if (reg_map)\n+\t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n+\t  \n+\t  mark_jump_label (PATTERN (copy), copy, 0);\n+\t  \n+\t  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n+\t     make them.  */\n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t    if (REG_NOTE_KIND (link) != REG_LABEL)\n+\t      REG_NOTES (copy)\n+\t\t= copy_rtx (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n+\t\t\t\t\t       XEXP (link, 0),\n+\t\t\t\t\t       REG_NOTES (copy)));\n+\t  if (reg_map && REG_NOTES (copy))\n+\t    replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n+\t  break;\n+\t  \n+\tcase JUMP_INSN:\n+\t  copy = emit_jump_insn_before (copy_rtx (PATTERN (insn)), loop_start);\n+\t  if (reg_map)\n+\t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n+\t  mark_jump_label (PATTERN (copy), copy, 0);\n+\t  if (REG_NOTES (insn))\n+\t    {\n+\t      REG_NOTES (copy) = copy_rtx (REG_NOTES (insn));\n+\t      if (reg_map)\n+\t\treplace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n+\t    }\n+\t  \n+\t  /* If this is a simple jump, add it to the jump chain.  */\n+\t  \n+\t  if (INSN_UID (copy) < max_jump_chain && JUMP_LABEL (copy)\n+\t      && simplejump_p (copy))\n+\t    {\n+\t      jump_chain[INSN_UID (copy)]\n+\t\t= jump_chain[INSN_UID (JUMP_LABEL (copy))];\n+\t      jump_chain[INSN_UID (JUMP_LABEL (copy))] = copy;\n+\t    }\n+\t  break;\n+\t  \n+\tdefault:\n+\t  abort ();\n+\t}\n \n-      default:\n-\tabort ();\n-      }\n+      /* Record the first insn we copied.  We need it so that we can\n+\t scan the copied insns for new pseudo registers.  */\n+      if (! first_copy)\n+\tfirst_copy = copy;\n+    }\n \n   /* Now clean up by emitting a jump to the end label and deleting the jump\n      at the start of the loop.  */\n   if (! copy || GET_CODE (copy) != BARRIER)\n     {\n       copy = emit_jump_insn_before (gen_jump (get_label_after (insn)),\n \t\t\t\t    loop_start);\n+\n+      /* Record the first insn we copied.  We need it so that we can\n+\t scan the copied insns for new pseudo registers.   This may not\n+\t be strictly necessary since we should have copied at least one\n+\t insn above.  But I am going to be safe.  */\n+      if (! first_copy)\n+\tfirst_copy = copy;\n+\n       mark_jump_label (PATTERN (copy), copy, 0);\n       if (INSN_UID (copy) < max_jump_chain\n \t  && INSN_UID (JUMP_LABEL (copy)) < max_jump_chain)\n@@ -2777,6 +2792,11 @@ duplicate_loop_exit_test (loop_start)\n       emit_barrier_before (loop_start);\n     }\n \n+  /* Now scan from the first insn we copied to the last insn we copied\n+     (copy) for new pseudo registers.  Do this after the code to jump to\n+     the end label since that might create a new pseudo too.  */\n+  reg_scan_update (first_copy, copy, max_reg);\n+\n   /* Mark the exit code as the virtual top of the converted loop.  */\n   emit_note_before (NOTE_INSN_LOOP_VTOP, exitcode);\n "}]}