{"sha": "581fd392778f0838be5b7869442564f1d3149c33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxZmQzOTI3NzhmMDgzOGJlNWI3ODY5NDQyNTY0ZjFkMzE0OWMzMw==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2002-07-05T21:31:31Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-07-05T21:31:31Z"}, "message": "m68hc11.md (peephole2): New peephole2 to optimize address computation and memory moves.\n\n\t* config/m68hc11/m68hc11.md (peephole2): New peephole2 to optimize\n\taddress computation and memory moves.\n\nFrom-SVN: r55267", "tree": {"sha": "f7a44e68fa95f1ae945961345c0cf4de7d3e67a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a44e68fa95f1ae945961345c0cf4de7d3e67a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/581fd392778f0838be5b7869442564f1d3149c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581fd392778f0838be5b7869442564f1d3149c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581fd392778f0838be5b7869442564f1d3149c33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581fd392778f0838be5b7869442564f1d3149c33/comments", "author": null, "committer": null, "parents": [{"sha": "0d49ec1158291fa15be03b8a7b89c320212c6e94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d49ec1158291fa15be03b8a7b89c320212c6e94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d49ec1158291fa15be03b8a7b89c320212c6e94"}], "stats": {"total": 140, "additions": 122, "deletions": 18}, "files": [{"sha": "a3086e1a4b46f31a323c0daaed42ff04872fa864", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581fd392778f0838be5b7869442564f1d3149c33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581fd392778f0838be5b7869442564f1d3149c33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=581fd392778f0838be5b7869442564f1d3149c33", "patch": "@@ -1,3 +1,8 @@\n+2002-07-06  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.md (peephole2): New peephole2 to optimize\n+\taddress computation and memory moves.\n+\n 2002-07-03  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/6706"}, {"sha": "7ee9ffa29d3869e3cf7b5269686d07f814155d1c", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 117, "deletions": 18, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581fd392778f0838be5b7869442564f1d3149c33/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581fd392778f0838be5b7869442564f1d3149c33/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=581fd392778f0838be5b7869442564f1d3149c33", "patch": "@@ -6479,29 +6479,35 @@\n ;;--------------------------------------------------------------------\n \n ;;\n-;; Reorganize to optimize address computations.\n+;; Replace \"leas 2,sp\" with a \"pulx\" or a \"puly\".\n+;; On 68HC12, this is one cycle slower but one byte smaller.\n+;; pr target/6899: This peephole is not valid because a register CSE\n+;; pass removes the pulx/puly.\n ;;\n (define_peephole2\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n-\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t         (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"(INTVAL (operands[1]) >= -2 && INTVAL (operands[1]) <= 2)\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n-  \"\")\n+  [(set (reg:HI SP_REGNUM) (plus:HI (reg:HI SP_REGNUM) (const_int 2)))\n+   (match_scratch:HI 0 \"xy\")]\n+  \"0 && TARGET_M6812 && optimize_size\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[1] = gen_rtx (MEM, HImode,\n+\t\t\t  gen_rtx (POST_INC, HImode,\n+\t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\")\n \n ;;\n-;; Reorganize address computation based on stack pointer.\n+;; Optimize memory<->memory moves when the value is also loaded in\n+;; a register.\n ;;\n (define_peephole2\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n-        (match_operand:HI 1 \"const_int_operand\" \"\"))\n-   (set (match_dup 0) (plus:HI (match_dup 0) (reg:HI SP_REGNUM)))]\n-  \"\"\n-  [(set (match_dup 0) (reg:HI SP_REGNUM))\n-   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n+  [(set (match_operand:QI 0 \"memory_operand\" \"\")\n+\t(match_operand:QI 1 \"memory_operand\" \"\"))\n+   (set (reg:QI D_REGNUM)\n+\t(match_operand:QI 2 \"memory_operand\" \"\"))]\n+  \"(rtx_equal_p (operands[0], operands[2]) && !side_effects_p (operands[0]))\n+   || (GET_CODE (XEXP (operands[0], 0)) == REG\n+       && GET_CODE (XEXP (operands[2], 0)) == POST_INC\n+       && rtx_equal_p (XEXP (operands[0], 0), XEXP (XEXP (operands[2], 0), 0)))\"\n+  [(set (reg:QI D_REGNUM) (match_dup 1))\n+   (set (match_dup 2) (reg:QI D_REGNUM))]\n   \"\")\n \n ;;\n@@ -6520,11 +6526,63 @@\n   [(set (cc0) (compare (match_dup 1) (match_dup 2)))]\n   \"\")\n \n+;;\n+;; Optimize loading a constant to memory when that same constant\n+;; is loaded to a hard register.  Switch the two to use the register\n+;; for memory initialization.  In most cases, the constant is 0.\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"memory_operand\" \"\")\n+\t(match_operand:HI 1 \"immediate_operand\" \"\"))\n+   (set (match_operand:HI 2 \"hard_reg_operand\" \"\")\n+        (match_dup 1))]\n+  \"(D_REG_P (operands[2]) || X_REG_P (operands[2]) || Y_REG_P (operands[2]))\n+   && !reg_mentioned_p (operands[2], operands[0])\n+   && GET_MODE (operands[2]) == HImode\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n+;;\n+;; Reorganize to optimize address computations.\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"(INTVAL (operands[1]) >= -2 && INTVAL (operands[1]) <= 2)\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n ;;\n ;; Optimize an address register increment and a compare to use\n-;; a PRE_INC or PRE_DEC addressing mode (disabled on the compare insn\n+;; a PRE_INC or PRE_DEC addressing mode (disabled on the tst insn\n ;; before reload, but can be enabled after).\n ;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (cc0)\n+\t(match_operand:QI 2 \"memory_operand\" \"\"))]\n+  \"TARGET_AUTO_INC_DEC\n+   && (INTVAL (operands[1]) == -1 || INTVAL (operands[1]) == 1)\n+   && reg_mentioned_p (operands[0], operands[2])\"\n+  [(set (cc0) (match_dup 3))]\n+  \"if (INTVAL (operands[1]) == 1)\n+     operands[3] = gen_rtx (MEM, QImode,\n+\t\t\t    gen_rtx (PRE_INC, HImode, operands[0]));\n+   else\n+     operands[3] = gen_rtx (MEM, QImode,\n+\t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n+  \")\n+\n+;;\n+;; Likewise for compare.\n+;;\n (define_peephole2\n   [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n \t(plus:HI (match_dup 0)\n@@ -6563,6 +6621,47 @@\n \t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n   \")\n \n+;;\n+;; Replace a \"ldx #N; addx <sp>\" with a \"ldx <sp>; addx #n\"\n+;; (avoids many temporary moves because we can't add sp to another reg easily)\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+        (match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0) (plus:HI (match_dup 0) (reg:HI SP_REGNUM)))]\n+  \"\"\n+  [(set (match_dup 0) (reg:HI SP_REGNUM))\n+   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n+;;\n+;; Replace \"ldd #N; addd <op>\" with \"ldd <op>; addd #N\".\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"(INTVAL (operands[1]) >= -2 && INTVAL (operands[1]) <= 2)\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n+;;\n+;; Replace a \"ldd <mem>; psha; pshb\" with a \"ldx <mem>; pshx\".\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+        (match_operand:HI 1 \"memory_operand\" \"\"))\n+   (set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (match_dup 0))\n+   (match_scratch:HI 2 \"x\")]\n+  \"TARGET_M6811 && D_REG_P (operands[0]) && peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))]\n+  \"\")\n+\n ;;\n ;; This peephole catches the address computations generated by the reload\n ;; pass. "}]}