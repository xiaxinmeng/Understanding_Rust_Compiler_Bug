{"sha": "a27d5f9a73978f20cfef1796a94f6a1a82438146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI3ZDVmOWE3Mzk3OGYyMGNmZWYxNzk2YTk0ZjZhMWE4MjQzODE0Ng==", "commit": {"author": {"name": "Matt Thomas", "email": "matt@3am-software.com", "date": "2020-12-05T18:26:23Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:23Z"}, "message": "PR target/58901: reload: Handle SUBREG of MEM with a mode-dependent address\n\nFix an ICE with the handling of RTL expressions like:\n\n(subreg:QI (mem/c:SI (plus:SI (plus:SI (mult:SI (reg/v:SI 0 %r0 [orig:67 i ] [67])\n                    (const_int 4 [0x4]))\n                (reg/v/f:SI 7 %r7 [orig:59 doacross ] [59]))\n            (const_int 40 [0x28])) [1 MEM[(unsigned int *)doacross_63 + 40B + i_106 * 4]+0 S4 A32]) 0)\n\nthat causes the compilation of libgomp to fail:\n\nduring RTL pass: reload\n.../libgomp/ordered.c: In function 'GOMP_doacross_wait':\n.../libgomp/ordered.c:507:1: internal compiler error: in change_address_1, at emit-rtl.c:2275\n  507 | }\n      | ^\n0x10a3462b change_address_1\n\t.../gcc/emit-rtl.c:2275\n0x10a353a7 adjust_address_1(rtx_def*, machine_mode, poly_int<1u, long>, int, int, int, poly_int<1u, long>)\n\t.../gcc/emit-rtl.c:2409\n0x10ae2993 alter_subreg(rtx_def**, bool)\n\t.../gcc/final.c:3368\n0x10ae25cf cleanup_subreg_operands(rtx_insn*)\n\t.../gcc/final.c:3322\n0x110922a3 reload(rtx_insn*, int)\n\t.../gcc/reload1.c:1232\n0x10de2bf7 do_reload\n\t.../gcc/ira.c:5812\n0x10de3377 execute\n\t.../gcc/ira.c:5986\n\nin a `vax-netbsdelf' build, where an attempt is made to change the mode\nof the contained memory reference to the mode of the containing SUBREG.\nSuch RTL expressions are produced by the VAX shift and rotate patterns\n(`ashift', `ashiftrt', `rotate', `rotatert') where the count operand\nalways has the QI mode regardless of the mode, either SI or DI, of the\ndatum shifted or rotated.\n\nSuch a mode change cannot work where the memory reference uses the\nindexed addressing mode, where a multiplier is implied that in the VAX\nISA depends on the width of the memory access requested and therefore\nchanging the machine mode would change the address calculation as well.\n\nAvoid the attempt then by forcing the reload of any SUBREGs containing\na mode-dependent memory reference, also fixing these regressions:\n\nFAIL: gcc.c-torture/compile/pr46883.c   -Os  (internal compiler error)\nFAIL: gcc.c-torture/compile/pr46883.c   -Os  (test for excess errors)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O2  (internal compiler error)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O2  (test for excess errors)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O3 -fomit-frame-pointer -funroll-loops -fpeel-loops -ftracer -finline-functions  (internal compiler error)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O3 -fomit-frame-pointer -funroll-loops -fpeel-loops -ftracer -finline-functions  (test for excess errors)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O3 -g  (internal compiler error)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O3 -g  (test for excess errors)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)\nFAIL: gcc.c-torture/execute/20120808-1.c   -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)\nFAIL: gcc.dg/20050629-1.c (internal compiler error)\nFAIL: gcc.dg/20050629-1.c (test for excess errors)\nFAIL: c-c++-common/torture/pr53505.c   -Os  (internal compiler error)\nFAIL: c-c++-common/torture/pr53505.c   -Os  (test for excess errors)\nFAIL: gfortran.dg/coarray_failed_images_1.f08   -Os  (internal compiler error)\nFAIL: gfortran.dg/coarray_stopped_images_1.f08   -Os  (internal compiler error)\n\nWith test case #0 included it causes a reload with:\n\n(insn 15 14 16 4 (set (reg:SI 31)\n        (ashift:SI (const_int 1 [0x1])\n            (subreg:QI (reg:SI 30 [ MEM[(int *)s_8(D) + 4B + _5 * 4] ]) 0))) \"pr58901-0.c\":15:12 94 {ashlsi3}\n     (expr_list:REG_DEAD (reg:SI 30 [ MEM[(int *)s_8(D) + 4B + _5 * 4] ])\n        (nil)))\n\nas follows:\n\nReloads for insn # 15\nReload 0: reload_in (SI) = (reg:SI 30 [ MEM[(int *)s_8(D) + 4B + _5 * 4] ])\n\tALL_REGS, RELOAD_FOR_INPUT (opnum = 2)\n\treload_in_reg: (reg:SI 30 [ MEM[(int *)s_8(D) + 4B + _5 * 4] ])\n\treload_reg_rtx: (reg:SI 5 %r5)\n\nresulting in:\n\n(insn 37 14 15 4 (set (reg:SI 5 %r5)\n        (mem/c:SI (plus:SI (plus:SI (mult:SI (reg/v:SI 1 %r1 [orig:25 i ] [25])\n                        (const_int 4 [0x4]))\n                    (reg/v/f:SI 4 %r4 [orig:29 s ] [29]))\n                (const_int 4 [0x4])) [1 MEM[(int *)s_8(D) + 4B + _5 * 4]+0 S4 A32])) \"pr58901-0.c\":15:12 12 {movsi_2}\n     (nil))\n(insn 15 37 16 4 (set (reg:SI 2 %r2 [31])\n        (ashift:SI (const_int 1 [0x1])\n            (reg:QI 5 %r5))) \"pr58901-0.c\":15:12 94 {ashlsi3}\n     (nil))\n\nand assembly like:\n\n.L3:\n\tmovl 4(%r4)[%r1],%r5\n\tashl %r5,$1,%r2\n\txorl2 %r2,%r0\n\tincl %r1\n\tcmpl %r1,%r3\n\tjneq .L3\n\nproduced for the loop, providing optimization has been enabled.\n\nLikewise with test case #1 the reload of:\n\n(insn 17 16 18 4 (set (reg:SI 34)\n        (and:SI (subreg:SI (reg/v:DI 27 [ t ]) 4)\n            (const_int 1 [0x1]))) \"pr58901-1.c\":18:20 77 {*andsi_const_int}\n     (expr_list:REG_DEAD (reg/v:DI 27 [ t ])\n        (nil)))\n\nis as follows:\n\nReloads for insn # 17\nReload 0: reload_in (DI) = (reg/v:DI 27 [ t ])\n\treload_out (SI) = (reg:SI 2 %r2 [34])\n\tALL_REGS, RELOAD_OTHER (opnum = 0)\n\treload_in_reg: (reg/v:DI 27 [ t ])\n\treload_out_reg: (reg:SI 2 %r2 [34])\n\treload_reg_rtx: (reg:DI 4 %r4)\n\nresulting in:\n\n(insn 40 16 17 4 (set (reg:DI 4 %r4)\n        (mem/c:DI (plus:SI (mult:SI (reg/v:SI 1 %r1 [orig:26 i ] [26])\n                    (const_int 8 [0x8]))\n                (reg/v/f:SI 3 %r3 [orig:30 s ] [30])) [1 MEM[(const struct s *)s_13(D) + _7 * 8]+0 S8 A32])) \"pr58901-1.c\":18:20 11 {movdi}\n     (nil))\n(insn 17 40 41 4 (set (reg:SI 4 %r4)\n        (and:SI (reg:SI 5 %r5 [+4 ])\n            (const_int 1 [0x1]))) \"pr58901-1.c\":18:20 77 {*andsi_const_int}\n     (nil))\n\nand assembly like:\n\n.L3:\n\tmovq (%r3)[%r1],%r4\n\tbicl3 $-2,%r5,%r4\n\taddl2 %r4,%r0\n\tjaoblss %r0,%r1,.L3\n\nFirst posted at: <https://gcc.gnu.org/ml/gcc/2014-06/msg00060.html>.\n\n2020-12-05  Matt Thomas  <matt@3am-software.com>\n\t    Maciej W. Rozycki  <macro@linux-mips.org>\n\n\tgcc/\n\tPR target/58901\n\t* reload.c (push_reload): Also reload the inner expression of a\n\tSUBREG for pseudos associated with a mode-dependent memory\n\treference.\n\t(find_reloads): Force a reload likewise.\n\n2020-12-05  Maciej W. Rozycki  <macro@linux-mips.org>\n\n\tgcc/testsuite/\n\tPR target/58901\n\t* gcc.c-torture/compile/pr58901-0.c: New test.\n\t* gcc.c-torture/compile/pr58901-1.c: New test.", "tree": {"sha": "8e6ae4db43ccb3661b292211f9001497f48b8396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e6ae4db43ccb3661b292211f9001497f48b8396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a27d5f9a73978f20cfef1796a94f6a1a82438146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27d5f9a73978f20cfef1796a94f6a1a82438146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a27d5f9a73978f20cfef1796a94f6a1a82438146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27d5f9a73978f20cfef1796a94f6a1a82438146/comments", "author": null, "committer": null, "parents": [{"sha": "4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb8f93d026eaa1de9b4820337069f3ce3465cd0"}], "stats": {"total": 142, "additions": 106, "deletions": 36}, "files": [{"sha": "b99b72ca05c9b254b8739309c9ad701d0ebaad0a", "filename": "gcc/reload.c", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27d5f9a73978f20cfef1796a94f6a1a82438146/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27d5f9a73978f20cfef1796a94f6a1a82438146/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a27d5f9a73978f20cfef1796a94f6a1a82438146", "patch": "@@ -1043,53 +1043,72 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      Also reload the inner expression if it does not require a secondary\n      reload but the SUBREG does.\n \n-     Finally, reload the inner expression if it is a register that is in\n+     Also reload the inner expression if it is a register that is in\n      the class whose registers cannot be referenced in a different size\n      and M1 is not the same size as M2.  If subreg_lowpart_p is false, we\n      cannot reload just the inside since we might end up with the wrong\n      register class.  But if it is inside a STRICT_LOW_PART, we have\n-     no choice, so we hope we do get the right register class there.  */\n+     no choice, so we hope we do get the right register class there.\n+\n+     Finally, reload the inner expression if it is a pseudo that will\n+     become a MEM and the MEM has a mode-dependent address, as in that\n+     case we obviously cannot change the mode of the MEM to that of the\n+     containing SUBREG as that would change the interpretation of the\n+     address.  */\n \n   scalar_int_mode inner_mode;\n   if (in != 0 && GET_CODE (in) == SUBREG\n-      && (subreg_lowpart_p (in) || strict_low)\n       && targetm.can_change_mode_class (GET_MODE (SUBREG_REG (in)),\n \t\t\t\t\tinmode, rclass)\n       && contains_allocatable_reg_of_mode[rclass][GET_MODE (SUBREG_REG (in))]\n-      && (CONSTANT_P (SUBREG_REG (in))\n-\t  || GET_CODE (SUBREG_REG (in)) == PLUS\n-\t  || strict_low\n-\t  || (((REG_P (SUBREG_REG (in))\n-\t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n-\t       || MEM_P (SUBREG_REG (in)))\n-\t      && (paradoxical_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n-\t\t  || (known_le (GET_MODE_SIZE (inmode), UNITS_PER_WORD)\n-\t\t      && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (in)),\n-\t\t\t\t\t\t &inner_mode)\n-\t\t      && GET_MODE_SIZE (inner_mode) <= UNITS_PER_WORD\n-\t\t      && paradoxical_subreg_p (inmode, inner_mode)\n-\t\t      && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)\n-\t\t  || (WORD_REGISTER_OPERATIONS\n-\t\t      && partial_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n-\t\t      && (known_equal_after_align_down\n-\t\t\t  (GET_MODE_SIZE (inmode) - 1,\n-\t\t\t   GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) - 1,\n-\t\t\t   UNITS_PER_WORD)))))\n-\t  || (REG_P (SUBREG_REG (in))\n-\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-\t      /* The case where out is nonzero\n-\t\t is handled differently in the following statement.  */\n-\t      && (out == 0 || subreg_lowpart_p (in))\n-\t      && (complex_word_subreg_p (inmode, SUBREG_REG (in))\n-\t\t  || !targetm.hard_regno_mode_ok (subreg_regno (in), inmode)))\n-\t  || (secondary_reload_class (1, rclass, inmode, in) != NO_REGS\n-\t      && (secondary_reload_class (1, rclass, GET_MODE (SUBREG_REG (in)),\n-\t\t\t\t\t  SUBREG_REG (in))\n-\t\t  == NO_REGS))\n+      && (strict_low\n+\t  || (subreg_lowpart_p (in)\n+\t      && (CONSTANT_P (SUBREG_REG (in))\n+\t\t  || GET_CODE (SUBREG_REG (in)) == PLUS\n+\t\t  || (((REG_P (SUBREG_REG (in))\n+\t\t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n+\t\t       || MEM_P (SUBREG_REG (in)))\n+\t\t      && (paradoxical_subreg_p (inmode,\n+\t\t\t\t\t\tGET_MODE (SUBREG_REG (in)))\n+\t\t\t  || (known_le (GET_MODE_SIZE (inmode), UNITS_PER_WORD)\n+\t\t\t      && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG\n+\t\t\t\t\t\t\t\t   (in)),\n+\t\t\t\t\t\t\t &inner_mode)\n+\t\t\t      && GET_MODE_SIZE (inner_mode) <= UNITS_PER_WORD\n+\t\t\t      && paradoxical_subreg_p (inmode, inner_mode)\n+\t\t\t      && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)\n+\t\t\t  || (WORD_REGISTER_OPERATIONS\n+\t\t\t      && partial_subreg_p (inmode,\n+\t\t\t\t\t\t   GET_MODE (SUBREG_REG (in)))\n+\t\t\t      && (known_equal_after_align_down\n+\t\t\t\t  (GET_MODE_SIZE (inmode) - 1,\n+\t\t\t\t   GET_MODE_SIZE (GET_MODE (SUBREG_REG\n+\t\t\t\t\t\t\t    (in))) - 1,\n+\t\t\t\t   UNITS_PER_WORD)))))\n+\t\t  || (REG_P (SUBREG_REG (in))\n+\t\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n+\t\t      /* The case where out is nonzero\n+\t\t\t is handled differently in the following statement.  */\n+\t\t      && (out == 0 || subreg_lowpart_p (in))\n+\t\t      && (complex_word_subreg_p (inmode, SUBREG_REG (in))\n+\t\t\t  || !targetm.hard_regno_mode_ok (subreg_regno (in),\n+\t\t\t\t\t\t\t  inmode)))\n+\t\t  || (secondary_reload_class (1, rclass, inmode, in) != NO_REGS\n+\t\t      && (secondary_reload_class (1, rclass,\n+\t\t\t\t\t\t  GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t\t  SUBREG_REG (in))\n+\t\t\t  == NO_REGS))\n+\t\t  || (REG_P (SUBREG_REG (in))\n+\t\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n+\t\t      && !REG_CAN_CHANGE_MODE_P (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t\t GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t\t inmode))))\n \t  || (REG_P (SUBREG_REG (in))\n-\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-\t      && !REG_CAN_CHANGE_MODE_P (REGNO (SUBREG_REG (in)),\n-\t\t\t\t\t GET_MODE (SUBREG_REG (in)), inmode))))\n+\t      && REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER\n+\t      && reg_equiv_mem (REGNO (SUBREG_REG (in)))\n+\t      && (mode_dependent_address_p\n+\t\t  (XEXP (reg_equiv_mem (REGNO (SUBREG_REG (in))), 0),\n+\t\t   MEM_ADDR_SPACE (reg_equiv_mem (REGNO (SUBREG_REG (in)))))))))\n     {\n #ifdef LIMIT_RELOAD_CLASS\n       in_subreg_loc = inloc;\n@@ -3157,6 +3176,19 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t\t\t  && paradoxical_subreg_p (operand_mode[i],\n \t\t\t\t\t\t\t   inner_mode)\n \t\t\t\t  && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)))\n+\t\t      /* We must force a reload of a SUBREG's inner expression\n+\t\t\t if it is a pseudo that will become a MEM and the MEM\n+\t\t\t has a mode-dependent address, as in that case we\n+\t\t\t obviously cannot change the mode of the MEM to that\n+\t\t\t of the containing SUBREG as that would change the\n+\t\t\t interpretation of the address.  */\n+\t\t      || (REG_P (operand)\n+\t\t\t  && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t  && reg_equiv_mem (REGNO (operand))\n+\t\t\t  && (mode_dependent_address_p\n+\t\t\t      (XEXP (reg_equiv_mem (REGNO (operand)), 0),\n+\t\t\t       (MEM_ADDR_SPACE\n+\t\t\t\t(reg_equiv_mem (REGNO (operand)))))))\n \t\t      )\n \t\t    force_reload = 1;\n \t\t}"}, {"sha": "d98e29ef89df7b57d87bb2c31f5e5f67d60f8e7a", "filename": "gcc/testsuite/gcc.c-torture/compile/pr58901-0.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27d5f9a73978f20cfef1796a94f6a1a82438146/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58901-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27d5f9a73978f20cfef1796a94f6a1a82438146/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58901-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58901-0.c?ref=a27d5f9a73978f20cfef1796a94f6a1a82438146", "patch": "@@ -0,0 +1,17 @@\n+typedef int __attribute__ ((mode (SI))) int_t;\n+\n+struct s\n+{\n+  int_t n;\n+  int_t c[];\n+};\n+\n+int_t\n+ashlsi (int_t x, const struct s *s)\n+{\n+  int_t i;\n+\n+  for (i = 0; i < s->n; i++)\n+    x ^= 1 << s->c[i];\n+  return x;\n+}"}, {"sha": "e01dba056bd6f1df6da7272c4f0d53296ee955a4", "filename": "gcc/testsuite/gcc.c-torture/compile/pr58901-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27d5f9a73978f20cfef1796a94f6a1a82438146/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58901-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27d5f9a73978f20cfef1796a94f6a1a82438146/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58901-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58901-1.c?ref=a27d5f9a73978f20cfef1796a94f6a1a82438146", "patch": "@@ -0,0 +1,21 @@\n+typedef signed int __attribute__ ((mode (SI))) int_t;\n+\n+struct s\n+{\n+  int_t n;\n+  int_t m : 1;\n+  int_t l : 31;\n+};\n+\n+int_t\n+movdi (int_t x, const struct s *s)\n+{\n+  int_t i;\n+\n+  for (i = 0; i < x; i++)\n+    {\n+      const struct s t = s[i];\n+      x += t.m ? 1 : 0;\n+    }\n+  return x;\n+}"}]}