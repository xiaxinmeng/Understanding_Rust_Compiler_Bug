{"sha": "4d5438cd3cc48733f76f65aaad34475c06468886", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ1NDM4Y2QzY2M0ODczM2Y3NmY2NWFhYWQzNDQ3NWMwNjQ2ODg4Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-12-08T21:06:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-08T21:06:42Z"}, "message": "nvptx.c (decl_chunk_size, [...]): Replace with ...\n\n\tgcc/\n\t* config/nvptx/nvptx.c (decl_chunk_size, decl_chunk_mode,\n\tdecl_offset, init_part, object_size, object_finished): Replace\n\twith ...\n\t(struct init_frag): ... this new struct variable.\n\t(begin_decl_field, output_decl_chunk): Replace with ...\n\t(output_init_frag): ... this new function.\n\t(nvptx_assemble_value): Reimplement.\n\t(nvptx_assemble_integer, nvptx_output_skip): Adjust.\n\t(nvptx_assemble_decl_begin, nvptx_assemble_decl_end): Adjust.\n\t(nvptx_output_aligned_decl): Call nvptx_assemble_decl_end.\n\n\tgcc/testsuite/\n\t* gcc.target/nvptx/trailing-init.c: New.\n\nFrom-SVN: r231426", "tree": {"sha": "3d11ba1bdd590dbdd7d67612073526bcf864f0da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d11ba1bdd590dbdd7d67612073526bcf864f0da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d5438cd3cc48733f76f65aaad34475c06468886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5438cd3cc48733f76f65aaad34475c06468886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5438cd3cc48733f76f65aaad34475c06468886", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5438cd3cc48733f76f65aaad34475c06468886/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41c60c6c75356bfe5e4ce11184b4bf62a6a86132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c60c6c75356bfe5e4ce11184b4bf62a6a86132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c60c6c75356bfe5e4ce11184b4bf62a6a86132"}], "stats": {"total": 222, "additions": 125, "deletions": 97}, "files": [{"sha": "1668e4edc8ebaf3a796d7c3ab737d48c0485b79f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d5438cd3cc48733f76f65aaad34475c06468886", "patch": "@@ -1,3 +1,16 @@\n+2015-12-08  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (decl_chunk_size, decl_chunk_mode,\n+\tdecl_offset, init_part, object_size, object_finished): Replace\n+\twith ...\n+\t(struct init_frag): ... this new struct variable.\n+\t(begin_decl_field, output_decl_chunk): Replace with ...\n+\t(output_init_frag): ... this new function.\n+\t(nvptx_assemble_value): Reimplement.\n+\t(nvptx_assemble_integer, nvptx_output_skip): Adjust.\n+\t(nvptx_assemble_decl_begin, nvptx_assemble_decl_end): Adjust.\n+\t(nvptx_output_aligned_decl): Call nvptx_assemble_decl_end.\n+\n 2015-12-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/68291"}, {"sha": "d9ccb81a0452b4416cc2a71cb8441ce65417ddc5", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 92, "deletions": 97, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=4d5438cd3cc48733f76f65aaad34475c06468886", "patch": "@@ -1484,73 +1484,70 @@ nvptx_hard_regno_mode_ok (int regno, machine_mode mode)\n   return mode == cfun->machine->ret_reg_mode;\n }\n \f\n-/* Machinery to output constant initializers.  When beginning an initializer,\n-   we decide on a chunk size (which is visible in ptx in the type used), and\n-   then all initializer data is buffered until a chunk is filled and ready to\n-   be written out.  */\n-\n-/* Used when assembling integers to ensure data is emitted in\n-   pieces whose size matches the declaration we printed.  */\n-static unsigned int decl_chunk_size;\n-static machine_mode decl_chunk_mode;\n-/* Used in the same situation, to keep track of the byte offset\n-   into the initializer.  */\n-static unsigned HOST_WIDE_INT decl_offset;\n-/* The initializer part we are currently processing.  */\n-static HOST_WIDE_INT init_part;\n-/* The total size of the object.  */\n-static unsigned HOST_WIDE_INT object_size;\n-/* True if we found a skip extending to the end of the object.  Used to\n-   assert that no data follows.  */\n-static bool object_finished;\n-\n-/* Write the necessary separator string to begin a new initializer value.  */\n+/* Machinery to output constant initializers.  When beginning an\n+   initializer, we decide on a fragment size (which is visible in ptx\n+   in the type used), and then all initializer data is buffered until\n+   a fragment is filled and ready to be written out.  */\n+\n+static struct\n+{\n+  unsigned HOST_WIDE_INT mask; /* Mask for storing fragment.  */\n+  unsigned HOST_WIDE_INT val; /* Current fragment value.  */\n+  unsigned HOST_WIDE_INT remaining; /*  Remaining bytes to be written\n+\t\t\t\t\tout.  */\n+  unsigned size;  /* Fragment size to accumulate.  */\n+  unsigned offset;  /* Offset within current fragment.  */\n+  bool started;   /* Whether we've output any initializer.  */\n+} init_frag;\n+\n+/* The current fragment is full,  write it out.  SYM may provide a\n+   symbolic reference we should output,  in which case the fragment\n+   value is the addend.  */\n \n static void\n-begin_decl_field (void)\n+output_init_frag (rtx sym)\n {\n-  /* We never see decl_offset at zero by the time we get here.  */\n-  if (decl_offset == decl_chunk_size)\n-    fprintf (asm_out_file, \" = { \");\n-  else\n-    fprintf (asm_out_file, \", \");\n-}\n+  fprintf (asm_out_file, init_frag.started ? \", \" : \" = { \");\n+  unsigned HOST_WIDE_INT val = init_frag.val;\n \n-/* Output the currently stored chunk as an initializer value.  */\n+  init_frag.started = true;\n+  init_frag.val = 0;\n+  init_frag.offset = 0;\n+  init_frag.remaining--;\n+  \n+  if (sym)\n+    {\n+      fprintf (asm_out_file, \"generic(\");\n+      output_address (VOIDmode, sym);\n+      fprintf (asm_out_file, val ? \") + \" : \")\");\n+    }\n \n-static void\n-output_decl_chunk (void)\n-{\n-  begin_decl_field ();\n-  output_address (VOIDmode, gen_int_mode (init_part, decl_chunk_mode));\n-  init_part = 0;\n+  if (!sym || val)\n+    fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC, val);\n }\n \n-/* Add value VAL sized SIZE to the data we're emitting, and keep writing\n-   out chunks as they fill up.  */\n+/* Add value VAL of size SIZE to the data we're emitting, and keep\n+   writing out chunks as they fill up.  */\n \n static void\n-nvptx_assemble_value (HOST_WIDE_INT val, unsigned int size)\n+nvptx_assemble_value (unsigned HOST_WIDE_INT val, unsigned size)\n {\n-  unsigned HOST_WIDE_INT chunk_offset = decl_offset % decl_chunk_size;\n-  gcc_assert (!object_finished);\n-  while (size > 0)\n+  val &= ((unsigned  HOST_WIDE_INT)2 << (size * BITS_PER_UNIT - 1)) - 1;\n+\n+  for (unsigned part = 0; size; size -= part)\n     {\n-      int this_part = size;\n-      if (chunk_offset + this_part > decl_chunk_size)\n-\tthis_part = decl_chunk_size - chunk_offset;\n-      HOST_WIDE_INT val_part;\n-      HOST_WIDE_INT mask = 2;\n-      mask <<= this_part * BITS_PER_UNIT - 1;\n-      val_part = val & (mask - 1);\n-      init_part |= val_part << (BITS_PER_UNIT * chunk_offset);\n-      val >>= BITS_PER_UNIT * this_part;\n-      size -= this_part;\n-      decl_offset += this_part;\n-      if (decl_offset % decl_chunk_size == 0)\n-\toutput_decl_chunk ();\n-\n-      chunk_offset = 0;\n+      val >>= part * BITS_PER_UNIT;\n+      part = init_frag.size - init_frag.offset;\n+      if (part > size)\n+\tpart = size;\n+\n+      unsigned HOST_WIDE_INT partial\n+\t= val << (init_frag.offset * BITS_PER_UNIT);\n+      init_frag.val |= partial & init_frag.mask;\n+      init_frag.offset += part;\n+\n+      if (init_frag.offset == init_frag.size)\n+\toutput_init_frag (NULL);\n     }\n }\n \n@@ -1567,8 +1564,7 @@ nvptx_assemble_integer (rtx x, unsigned int size, int ARG_UNUSED (aligned_p))\n       gcc_unreachable ();\n \n     case CONST_INT:\n-      val = INTVAL (x);\n-      nvptx_assemble_value (val, size);\n+      nvptx_assemble_value (INTVAL (x), size);\n       break;\n \n     case CONST:\n@@ -1580,19 +1576,13 @@ nvptx_assemble_integer (rtx x, unsigned int size, int ARG_UNUSED (aligned_p))\n       /* FALLTHROUGH */\n \n     case SYMBOL_REF:\n-      gcc_assert (size = decl_chunk_size);\n-      if (decl_offset % decl_chunk_size != 0)\n+      gcc_assert (size == init_frag.size);\n+      if (init_frag.offset)\n \tsorry (\"cannot emit unaligned pointers in ptx assembly\");\n-      decl_offset += size;\n-      begin_decl_field ();\n \n       nvptx_maybe_record_fnsym (x);\n-      fprintf (asm_out_file, \"generic(\");\n-      output_address (VOIDmode, x);\n-      fprintf (asm_out_file, \")\");\n-\n-      if (val)\n-\tfprintf (asm_out_file, \" + \" HOST_WIDE_INT_PRINT_DEC, val);\n+      init_frag.val = val;\n+      output_init_frag (x);\n       break;\n     }\n \n@@ -1606,21 +1596,28 @@ nvptx_assemble_integer (rtx x, unsigned int size, int ARG_UNUSED (aligned_p))\n void\n nvptx_output_skip (FILE *, unsigned HOST_WIDE_INT size)\n {\n-  if (decl_offset + size >= object_size)\n+  /* Finish the current fragment, if it's started.  */\n+  if (init_frag.offset)\n     {\n-      if (decl_offset % decl_chunk_size != 0)\n-\tnvptx_assemble_value (0, decl_chunk_size);\n-      object_finished = true;\n-      return;\n+      unsigned part = init_frag.size - init_frag.offset;\n+      if (part > size)\n+\tpart = (unsigned) size;\n+      size -= part;\n+      nvptx_assemble_value (0, part);\n     }\n \n-  while (size > decl_chunk_size)\n+  /* If this skip doesn't terminate the initializer, write as many\n+     remaining pieces as possible directly.  */\n+  if (size < init_frag.remaining * init_frag.size)\n     {\n-      nvptx_assemble_value (0, decl_chunk_size);\n-      size -= decl_chunk_size;\n+      while (size >= init_frag.size)\n+\t{\n+\t  size -= init_frag.size;\n+\t  output_init_frag (NULL_RTX);\n+\t}\n+      if (size)\n+\tnvptx_assemble_value (0, size);\n     }\n-  while (size-- > 0)\n-    nvptx_assemble_value (0, 1);\n }\n \n /* Output a string STR with length SIZE.  As in nvptx_output_skip we\n@@ -1662,15 +1659,18 @@ nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,\n \n   elt_size |= GET_MODE_SIZE (elt_mode);\n   elt_size &= -elt_size; /* Extract LSB set.  */\n-  elt_mode = mode_for_size (elt_size * BITS_PER_UNIT, MODE_INT, 0);\n-\n-  decl_chunk_size = elt_size;\n-  decl_chunk_mode = elt_mode;\n-  decl_offset = 0;\n-  init_part = 0;\n \n-  object_size = size;\n-  object_finished = !size;\n+  init_frag.size = elt_size;\n+  /* Avoid undefined shift behaviour by using '2'.  */\n+  init_frag.mask = ((unsigned HOST_WIDE_INT)2\n+\t\t    << (elt_size * BITS_PER_UNIT - 1)) - 1;\n+  init_frag.val = 0;\n+  init_frag.offset = 0;\n+  init_frag.started = false;\n+  /* Size might not be a multiple of elt size, if there's an\n+     initialized trailing struct array with smaller type than\n+     elt_size. */\n+  init_frag.remaining = (size + elt_size - 1) / elt_size;\n \n   fprintf (file, \"%s .align %d .u%d \",\n \t   section, align / BITS_PER_UNIT,\n@@ -1680,8 +1680,7 @@ nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,\n   if (size)\n     /* We make everything an array, to simplify any initialization\n        emission.  */\n-    fprintf (file, \"[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n-\t     (size + elt_size - 1) / elt_size);\n+    fprintf (file, \"[\" HOST_WIDE_INT_PRINT_DEC \"]\", init_frag.remaining);\n }\n \n /* Called when the initializer for a decl has been completely output through\n@@ -1690,14 +1689,10 @@ nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,\n static void\n nvptx_assemble_decl_end (void)\n {\n-  if (decl_offset != 0)\n-    {\n-      if (!object_finished && decl_offset % decl_chunk_size != 0)\n-\tnvptx_assemble_value (0, decl_chunk_size);\n-\n-      fprintf (asm_out_file, \" }\");\n-    }\n-  fprintf (asm_out_file, \";\\n\");\n+  if (init_frag.offset)\n+    /* This can happen with a packed struct with trailing array member.  */\n+    nvptx_assemble_value (0, init_frag.size - init_frag.offset);\n+  fprintf (asm_out_file, init_frag.started ? \" };\\n\" : \";\\n\");\n }\n \n /* Output an uninitialized common or file-scope variable.  */\n@@ -1714,7 +1709,7 @@ nvptx_output_aligned_decl (FILE *file, const char *name,\n \n   nvptx_assemble_decl_begin (file, name, section_for_decl (decl),\n \t\t\t     TREE_TYPE (decl), size, align);\n-  fprintf (file, \";\\n\");\n+  nvptx_assemble_decl_end ();\n }\n \n /* Implement TARGET_ASM_DECLARE_CONSTANT_NAME.  Begin the process of"}, {"sha": "b596b0338470a641c0e0bf9e8d42ec1b33dbbe39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d5438cd3cc48733f76f65aaad34475c06468886", "patch": "@@ -1,5 +1,7 @@\n 2015-12-08  Nathan Sidwell  <nathan@acm.org>\n \n+\t* gcc.target/nvptx/trailing-init.c: New.\n+\n \t* gcc.c-torture/compile/920723-1.c: Remove PTX skip. \n \t* gcc.c-torture/compile/pr33855.c: Likewise.\n \t* gcc.c-torture/execute/981019-1.c: Remove PTX -O2 skip."}, {"sha": "3fa916d0ac215e85f09c1b521359af0d26d4d3c1", "filename": "gcc/testsuite/gcc.target/nvptx/trailing-init.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Ftrailing-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5438cd3cc48733f76f65aaad34475c06468886/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Ftrailing-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Ftrailing-init.c?ref=4d5438cd3cc48733f76f65aaad34475c06468886", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-additional-options \"-Wno-pedantic\" } */\n+\n+struct trailing \n+{\n+  unsigned m;\n+  short ary[];\n+} trailing = \n+  {.ary = {1}};\n+\n+struct packed \n+{\n+  unsigned m;\n+  short ary[];\n+} __attribute__ ((packed)) packed = \n+  {.ary = {2}};\n+\n+/*  { dg-final { scan-assembler \".align 1 .u32 packed\\\\\\[2\\\\\\] = { 0, 2 };\" } } */\n+/*  { dg-final { scan-assembler \".align 4 .u32 trailing\\\\\\[2\\\\\\] = { 0, 1 };\" } } */"}]}