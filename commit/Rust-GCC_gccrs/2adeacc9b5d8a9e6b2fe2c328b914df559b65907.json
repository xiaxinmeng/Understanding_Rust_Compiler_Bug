{"sha": "2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkZWFjYzliNWQ4YTllNmIyZmUyYzMyOGI5MTRkZjU1OWI2NTkwNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-06T18:20:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-06T18:20:27Z"}, "message": "error.c (dump_expr): Handle EXACT_DIV_EXPR.\n\n\t* error.c (dump_expr): Handle EXACT_DIV_EXPR.\n\t(dump_binary_op): Bulletproof.\n\t* lex.c (init_parse): Set opname_tab[EXACT_DIV_EXPR].\n\t* tree.c (search_tree): Don't enumerate all the nodes of classes\n\t`1', `2', and `<'; handle them generically.  Don't be sorry about\n\t\"unrecognized tree codes\"; just abort.\n\t(no_linkage_check): Don't do linkage checks for templates.\n\n\t* tree.c (cp_build_qualified_type_real): Handle\n\tpointer-to-member-function types correctly.\n\nFrom-SVN: r28550", "tree": {"sha": "095df14265db59289275bbcf68dc5206b26f72dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/095df14265db59289275bbcf68dc5206b26f72dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/comments", "author": null, "committer": null, "parents": [{"sha": "e7eacc8e2774b2457c625cb3b86e90d93af42382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7eacc8e2774b2457c625cb3b86e90d93af42382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7eacc8e2774b2457c625cb3b86e90d93af42382"}], "stats": {"total": 149, "additions": 99, "deletions": 50}, "files": [{"sha": "aaa8ecfa2c494a7ecb294b0eb5f1dd92620b8b0f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "patch": "@@ -1,3 +1,16 @@\n+1999-08-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* error.c (dump_expr): Handle EXACT_DIV_EXPR.\n+\t(dump_binary_op): Bulletproof.\n+\t* lex.c (init_parse): Set opname_tab[EXACT_DIV_EXPR].\n+\t* tree.c (search_tree): Don't enumerate all the nodes of classes\n+\t`1', `2', and `<'; handle them generically.  Don't be sorry about\n+\t\"unrecognized tree codes\"; just abort.\n+\t(no_linkage_check): Don't do linkage checks for templates.\n+\t\n+\t* tree.c (cp_build_qualified_type_real): Handle\n+\tpointer-to-member-function types correctly.\n+\n 1999-08-05  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (pushdecl): Only give an error for shadowing a parm "}, {"sha": "c455e812367ecf99d3ab73d82c27a9b316542394", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "patch": "@@ -1521,6 +1521,7 @@ dump_expr (t, nop)\n     case GE_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n+    case EXACT_DIV_EXPR:\n       dump_binary_op (opname_tab[(int) TREE_CODE (t)], t);\n       break;\n \n@@ -1847,7 +1848,10 @@ dump_binary_op (opstring, t)\n   OB_PUTC ('(');\n   dump_expr (TREE_OPERAND (t, 0), 1);\n   OB_PUTC (' ');\n-  OB_PUTCP (opstring);\n+  if (opstring)\n+    OB_PUTCP (opstring);\n+  else\n+    OB_PUTS (\"<unknown operator>\");\n   OB_PUTC (' ');\n   dump_expr (TREE_OPERAND (t, 1), 1);\n   OB_PUTC (')');"}, {"sha": "5afda551edf63071fc905190b5a0f6cbad417e05", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "patch": "@@ -761,6 +761,7 @@ init_parse (filename)\n   opname_tab[(int) CEIL_MOD_EXPR] = \"(ceiling %)\";\n   opname_tab[(int) FLOOR_MOD_EXPR] = \"(floor %)\";\n   opname_tab[(int) ROUND_MOD_EXPR] = \"(round %)\";\n+  opname_tab[(int) EXACT_DIV_EXPR] = \"/\";\n   opname_tab[(int) NEGATE_EXPR] = \"-\";\n   opname_tab[(int) MIN_EXPR] = \"<?\";\n   opname_tab[(int) MAX_EXPR] = \">?\";"}, {"sha": "7b5c16d67de01ac99c2c30d143307b2268caf4fd", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "patch": "@@ -503,6 +503,8 @@ cp_build_qualified_type_real (type, type_quals, complain)\n      int type_quals;\n      int complain;\n {\n+  tree result;\n+\n   if (type == error_mark_node)\n     return type;\n   \n@@ -571,7 +573,32 @@ cp_build_qualified_type_real (type, type_quals, complain)\n \t= TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n       return t;\n     }\n-  return build_qualified_type (type, type_quals);\n+  else if (TYPE_PTRMEMFUNC_P (type))\n+    {\n+      /* For a pointer-to-member type, we can't just return a\n+\t cv-qualified version of the RECORD_TYPE.  If we do, we\n+\t haven't change the field that contains the actual pointer to\n+\t a method, and so TYPE_PTRMEMFUNC_FN_TYPE will be wrong.  */\n+      tree t;\n+\n+      t = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+      t = cp_build_qualified_type_real (t, type_quals, complain);\n+      return build_ptrmemfunc_type (t);\n+    }\n+\n+  /* Retrieve (or create) the appropriately qualified variant.  */\n+  result = build_qualified_type (type, type_quals);\n+\n+  /* If this was a pointer-to-method type, and we just made a copy,\n+     then we need to clear the cached associated\n+     pointer-to-member-function type; it is not valid for the new\n+     type.  */\n+  if (result != type \n+      && TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n+    TYPE_SET_PTRMEMFUNC_TYPE (result, NULL_TREE);\n+\n+  return result;\n }\n \n /* Returns the canonical version of TYPE.  In other words, if TYPE is\n@@ -1540,14 +1567,30 @@ search_tree (t, func)\n #define TRY(ARG) if (tmp=search_tree (ARG, func), tmp != NULL_TREE) return tmp\n \n   tree tmp;\n+  enum tree_code code; \n \n   if (t == NULL_TREE)\n     return t;\n-\n-  if (tmp = func (t), tmp != NULL_TREE)\n+  \n+  tmp = func (t);\n+  if (tmp)\n     return tmp;\n \n-  switch (TREE_CODE (t))\n+  /* Handle some common cases up front.  */\n+  code = TREE_CODE (t);\n+  if (TREE_CODE_CLASS (code) == '1')\n+    {\n+      TRY (TREE_OPERAND (t, 0));\n+      return NULL_TREE;\n+    }\n+  else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n+    {\n+      TRY (TREE_OPERAND (t, 0));\n+      TRY (TREE_OPERAND (t, 1));\n+      return NULL_TREE;\n+    }\n+\n+  switch (code)\n     {\n     case ERROR_MARK:\n       break;\n@@ -1611,35 +1654,8 @@ search_tree (t, func)\n       TRY (TREE_OPERAND (t, 2));\n       break;\n \n-    case MODIFY_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case MIN_EXPR:\n-    case MAX_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case BIT_AND_EXPR:\n-    case BIT_ANDTC_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-    case COMPOUND_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n@@ -1654,28 +1670,16 @@ search_tree (t, func)\n       break;\n \n     case SAVE_EXPR:\n-    case CONVERT_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n-    case NOP_EXPR:\n-    case NON_LVALUE_EXPR:\n     case COMPONENT_REF:\n     case CLEANUP_POINT_EXPR:\n     case LOOKUP_EXPR:\n-    case SIZEOF_EXPR:\n-    case ALIGNOF_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       break;\n \n     case MODOP_EXPR:\n-    case CAST_EXPR:\n-    case REINTERPRET_CAST_EXPR:\n-    case CONST_CAST_EXPR:\n-    case STATIC_CAST_EXPR:\n-    case DYNAMIC_CAST_EXPR:\n     case ARROW_EXPR:\n     case DOTSTAR_EXPR:\n     case TYPEID_EXPR:\n@@ -1738,13 +1742,8 @@ search_tree (t, func)\n \tTRY (TYPE_PTRMEMFUNC_FN_TYPE (t));\n       break;\n       \n-      /*  This list is incomplete, but should suffice for now.\n-\t  It is very important that `sorry' not call\n-\t  `report_error_function'.  That could cause an infinite loop.  */\n     default:\n-      sorry (\"initializer contains unrecognized tree code\");\n-      return error_mark_node;\n-\n+      my_friendly_abort (19990803);\n     }\n \n   return NULL_TREE;\n@@ -1773,6 +1772,11 @@ tree\n no_linkage_check (t)\n      tree t;\n {\n+  /* There's no point in checking linkage on template functions; we\n+     can't know their complete types.  */\n+  if (processing_template_decl)\n+    return NULL_TREE;\n+\n   t = search_tree (t, no_linkage_helper);\n   if (t != error_mark_node)\n     return t;"}, {"sha": "84792c8c4c1d33dff16007177ca8446def429b11", "filename": "gcc/testsuite/g++.old-deja/g++.other/defarg3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg3.C?ref=2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "patch": "@@ -0,0 +1,9 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int* hp;\n+int* jp;\n+\n+void f (int *ip, int kp = hp - jp)\n+{\n+}"}, {"sha": "f6125cdeaf631b10681250344cddccbd1efa1619", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem8.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adeacc9b5d8a9e6b2fe2c328b914df559b65907/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem8.C?ref=2adeacc9b5d8a9e6b2fe2c328b914df559b65907", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+struct S \n+{\n+  void f (const T&);\n+  void f (T&);\n+};\n+\n+class C \n+{\n+};\n+\n+typedef int (C::*cp)();\n+\n+template struct S<cp>;\n+"}]}