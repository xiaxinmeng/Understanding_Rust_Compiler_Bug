{"sha": "9785c68dd55d366c6837b8e647039e8bfcad5fc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4NWM2OGRkNTVkMzY2YzY4MzdiOGU2NDcwMzllOGJmY2FkNWZjOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-27T11:17:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-27T11:17:04Z"}, "message": "flow.c (struct propagate_block_info): Remove new_dead, new_live; add new_set.\n\n        * flow.c (struct propagate_block_info): Remove new_dead, new_live;\n        add new_set.\n        (propagate_one_insn): Clear it.  Don't update reg_live here.\n        (init_propagate_block_info): Update for pbi member changes.\n        (free_propagate_block_info): Likewise.\n        (mark_set_1): Know that zero_extract, sign_extract, and\n        strict_low_part don't kill their argument.  Alter hard subregs.\n        Update new_set for non-CLOBBER sets.  Update reg_live.\n        (find_auto_inc): Update reg_live, not new_dead.\n        (mark_used_reg): Update reg_live, not new_live.  Examine new_set\n        to determine if the reg in question was set this insn.  Only update\n        reg info with PROP_REG_INFO.\n\nFrom-SVN: r33478", "tree": {"sha": "d2046771c7062d52cc4d93e04d2a0841e621096a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2046771c7062d52cc4d93e04d2a0841e621096a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9785c68dd55d366c6837b8e647039e8bfcad5fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9785c68dd55d366c6837b8e647039e8bfcad5fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9785c68dd55d366c6837b8e647039e8bfcad5fc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9785c68dd55d366c6837b8e647039e8bfcad5fc9/comments", "author": null, "committer": null, "parents": [{"sha": "077f1f8e14e1d7239868ac8c72f4c72c0c96bfc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/077f1f8e14e1d7239868ac8c72f4c72c0c96bfc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/077f1f8e14e1d7239868ac8c72f4c72c0c96bfc4"}], "stats": {"total": 205, "additions": 133, "deletions": 72}, "files": [{"sha": "fc50eb959b633da65bf4829444c04905d6e62f60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785c68dd55d366c6837b8e647039e8bfcad5fc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785c68dd55d366c6837b8e647039e8bfcad5fc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9785c68dd55d366c6837b8e647039e8bfcad5fc9", "patch": "@@ -1,3 +1,18 @@\n+2000-04-27  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (struct propagate_block_info): Remove new_dead, new_live;\n+\tadd new_set.\n+\t(propagate_one_insn): Clear it.  Don't update reg_live here.\n+\t(init_propagate_block_info): Update for pbi member changes.\n+\t(free_propagate_block_info): Likewise.\n+\t(mark_set_1): Know that zero_extract, sign_extract, and \n+\tstrict_low_part don't kill their argument.  Alter hard subregs.\n+\tUpdate new_set for non-CLOBBER sets.  Update reg_live.\n+\t(find_auto_inc): Update reg_live, not new_dead.\n+\t(mark_used_reg): Update reg_live, not new_live.  Examine new_set\n+\tto determine if the reg in question was set this insn.  Only update\n+\treg info with PROP_REG_INFO.\n+\n 2000-04-26  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (allocate_reg_life_data): Set max_regno here ..."}, {"sha": "5c8252e843e870266c6196db798e18e18b5ac1a6", "filename": "gcc/flow.c", "status": "modified", "additions": 118, "deletions": 72, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9785c68dd55d366c6837b8e647039e8bfcad5fc9/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9785c68dd55d366c6837b8e647039e8bfcad5fc9/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=9785c68dd55d366c6837b8e647039e8bfcad5fc9", "patch": "@@ -264,11 +264,8 @@ struct propagate_block_info\n   /* Bit N is set if register N is conditionally or unconditionally live.  */\n   regset reg_live;\n \n-  /* Bit N is set if register N is unconditionally dead this insn.  */\n-  regset new_dead;\n-\n-  /* Bit N is set if register N is live this insn.  */\n-  regset new_live;\n+  /* Bit N is set if register N is set this insn.  */\n+  regset new_set;\n \n   /* Element N is the next insn that uses (hard or pseudo) register N\n      within the current basic block; or zero, if there is no such insn.  */\n@@ -3376,8 +3373,7 @@ propagate_one_insn (pbi, insn)\n   }\n #endif /* AUTO_INC_DEC */\n \n-  CLEAR_REG_SET (pbi->new_live);\n-  CLEAR_REG_SET (pbi->new_dead);\n+  CLEAR_REG_SET (pbi->new_set);\n \n   /* If this is not the final pass, and this insn is copying the value of\n      a library call and it's dead, don't scan the insns that perform the\n@@ -3490,10 +3486,6 @@ propagate_one_insn (pbi, insn)\n \t}\n     }\n \n-  /* Update reg_live for the registers killed and used.  */\n-  AND_COMPL_REG_SET (pbi->reg_live, pbi->new_dead);\n-  IOR_REG_SET (pbi->reg_live, pbi->new_live);\n-\n   /* On final pass, update counts of how many insns in which each reg\n      is live.  */\n   if (flags & PROP_REG_INFO)\n@@ -3528,8 +3520,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n   else\n     pbi->reg_next_use = NULL;\n \n-  pbi->new_live = BITMAP_XMALLOC ();\n-  pbi->new_dead = BITMAP_XMALLOC ();\n+  pbi->new_set = BITMAP_XMALLOC ();\n \n   return pbi;\n }\n@@ -3542,8 +3533,7 @@ free_propagate_block_info (pbi)\n {\n   free_EXPR_LIST_list (&pbi->mem_set_list);\n \n-  BITMAP_XFREE (pbi->new_live);\n-  BITMAP_XFREE (pbi->new_dead);\n+  BITMAP_XFREE (pbi->new_set);\n \n   if (pbi->reg_next_use)\n     free (pbi->reg_next_use);\n@@ -3980,6 +3970,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n      int flags;\n {\n   int regno_first = -1, regno_last = -1;\n+  int not_dead = 0;\n   int i;\n \n   /* Some targets place small structures in registers for\n@@ -3995,24 +3986,80 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \n   /* Modifying just one hardware register of a multi-reg value or just a\n      byte field of a register does not mean the value from before this insn\n-     is now dead.  But it does mean liveness of that register at the end of\n-     the block is significant.\n+     is now dead.  Of course, if it was dead after it's unused now.  */\n+\n+  switch (GET_CODE (reg))\n+    {\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+    case STRICT_LOW_PART:\n+      /* ??? Assumes STRICT_LOW_PART not used on multi-word registers.  */\n+      do\n+\treg = XEXP (reg, 0);\n+      while (GET_CODE (reg) == SUBREG\n+\t     || GET_CODE (reg) == ZERO_EXTRACT\n+\t     || GET_CODE (reg) == SIGN_EXTRACT\n+\t     || GET_CODE (reg) == STRICT_LOW_PART);\n+      not_dead = REGNO_REG_SET_P (pbi->reg_live, REGNO (reg));\n+      /* FALLTHRU */\n \n-     Within mark_set_1, however, we treat it as if the register is indeed\n-     modified.  mark_used_regs will, however, also treat this register as\n-     being used.  Thus, we treat these insns as setting a new value for the\n-     register as a function of its old value.  This cases LOG_LINKS to be\n-     made appropriately and this will help combine. \n+    case REG:\n+      regno_last = regno_first = REGNO (reg);\n+      if (regno_first < FIRST_PSEUDO_REGISTER)\n+\tregno_last += HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1;\n+      break;\n \n-     ??? This is all done incorrectly.  We should not be setting bits in\n-     new_dead for these registers, since, as we just explained, they are\n-     not dead.  We should be setting bits in local_set, and updating\n-     LOG_LINKS, but that is different.  */\n+    case SUBREG:\n+      if (GET_CODE (SUBREG_REG (reg)) == REG)\n+\t{\n+\t  enum machine_mode outer_mode = GET_MODE (reg);\n+\t  enum machine_mode inner_mode = GET_MODE (SUBREG_REG (reg));\n+\n+\t  /* Identify the range of registers affected.  This is moderately\n+\t     tricky for hard registers.  See alter_subreg.  */\n \n-  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n-\t || GET_CODE (reg) == SIGN_EXTRACT\n-\t || GET_CODE (reg) == STRICT_LOW_PART)\n-    reg = XEXP (reg, 0);\n+\t  regno_last = regno_first = REGNO (SUBREG_REG (reg));\n+\t  if (regno_first < FIRST_PSEUDO_REGISTER)\n+\t    {\n+#ifdef ALTER_HARD_SUBREG\n+\t      regno_first = ALTER_HARD_SUBREG (outer_mode, SUBREG_WORD (reg),\n+\t\t\t\t\t       inner_mode, regno_first);\n+#else\n+\t      regno_first += SUBREG_WORD (reg);\n+#endif\n+\t      regno_last = (regno_first\n+\t\t\t    + HARD_REGNO_NREGS (regno_first, outer_mode) - 1);\n+\n+\t      /* Since we've just adjusted the register number ranges, make\n+\t\t sure REG matches.  Otherwise some_was_live will be clear\n+\t\t when it shouldn't have been, and we'll create incorrect\n+\t\t REG_UNUSED notes.  */\n+\t      reg = gen_rtx_REG (outer_mode, regno_first);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If the number of words in the subreg is less than the number\n+\t\t of words in the full register, we have a well-defined partial\n+\t\t set.  Otherwise the high bits are undefined.\n+\n+\t\t This is only really applicable to pseudos, since we just took\n+\t\t care of multi-word hard registers.  */\n+\t      if (((GET_MODE_SIZE (outer_mode)\n+\t\t    + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\t\t  < ((GET_MODE_SIZE (inner_mode)\n+\t\t      + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\t\tnot_dead = REGNO_REG_SET_P (pbi->reg_live, regno_first);\n+\n+\t      reg = SUBREG_REG (reg);\n+\t    }\n+\t}\n+      else\n+\treg = SUBREG_REG (reg);\n+      break;\n+\n+    default:\n+      break;\n+    }\n \n   /* If this set is a MEM, then it kills any aliased writes. \n      If this set is a REG, then it kills any MEMs which use the reg.  */\n@@ -4063,9 +4110,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n     }\n \n   if (GET_CODE (reg) == REG\n-      && (regno_first = REGNO (reg),\n-\t  ! (regno_first == FRAME_POINTER_REGNUM\n-\t     && (! reload_completed || frame_pointer_needed)))\n+      && ! (regno_first == FRAME_POINTER_REGNUM\n+\t    && (! reload_completed || frame_pointer_needed))\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n       && ! (regno_first == HARD_FRAME_POINTER_REGNUM\n \t    && (! reload_completed || frame_pointer_needed))\n@@ -4077,17 +4123,13 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n     {\n       int some_was_live = 0, some_was_dead = 0;\n \n-      if (regno_first < FIRST_PSEUDO_REGISTER)\n-\tregno_last = (regno_first\n-\t\t      + HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1);\n-      else\n-        regno_last = regno_first;\n-\n       for (i = regno_first; i <= regno_last; ++i)\n \t{\n \t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, i);\n \t  if (pbi->local_set)\n \t    SET_REGNO_REG_SET (pbi->local_set, i);\n+\t  if (code != CLOBBER)\n+\t    SET_REGNO_REG_SET (pbi->new_set, i);\n \n \t  some_was_live |= needed_regno;\n \t  some_was_dead |= ! needed_regno;\n@@ -4162,6 +4204,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t\t    LOG_LINKS (y) = alloc_INSN_LIST (insn, LOG_LINKS (y));\n \t\t}\n \t    }\n+\t  else if (not_dead)\n+\t    ;\n \t  else if (! some_was_live)\n \t    {\n \t      if (flags & PROP_REG_INFO)\n@@ -4207,7 +4251,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t  && regno_first != STACK_POINTER_REGNUM)\n \t{\n \t  for (i = regno_first; i <= regno_last; ++i)\n-\t    SET_REGNO_REG_SET (pbi->new_dead, i);\n+\t    CLEAR_REGNO_REG_SET (pbi->reg_live, i);\n \t}\n     }\n   else if (GET_CODE (reg) == REG)\n@@ -4389,7 +4433,7 @@ find_auto_inc (pbi, x, insn)\n \t      /* If the original source was dead, it's dead now.  */\n \t      rtx note = find_reg_note (incr, REG_DEAD, NULL_RTX);\n \t      if (note && XEXP (note, 0) != addr)\n-\t\tSET_REGNO_REG_SET (pbi->new_dead, REGNO (XEXP (note, 0)));\n+\t\tCLEAR_REGNO_REG_SET (pbi->reg_live, REGNO (XEXP (note, 0)));\n \t      \n \t      PUT_CODE (incr, NOTE);\n \t      NOTE_LINE_NUMBER (incr) = NOTE_INSN_DELETED;\n@@ -4422,20 +4466,17 @@ mark_used_reg (pbi, reg, cond, insn)\n   int regno = REGNO (reg);\n   int some_was_live = REGNO_REG_SET_P (pbi->reg_live, regno);\n   int some_was_dead = ! some_was_live;\n-\n-  SET_REGNO_REG_SET (pbi->new_live, regno);\n+  int some_not_set;\n+  int n;\n \n   /* A hard reg in a wide mode may really be multiple registers.\n      If so, mark all of them just like the first.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (--n > 0)\n \t{\n-\t  int regno_n = regno + n;\n-\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno_n);\n-\n-\t  SET_REGNO_REG_SET (pbi->new_live, regno_n);\n+\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno + n);\n \t  some_was_live |= needed_regno;\n \t  some_was_dead |= ! needed_regno;\n \t}\n@@ -4489,47 +4530,44 @@ mark_used_reg (pbi, reg, cond, insn)\n \t}\n     }\n \n+  /* Find out if any of the register was set this insn.  */\n+  some_not_set = ! REGNO_REG_SET_P (pbi->new_set, regno);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (--n > 0)\n+\tsome_not_set |= ! REGNO_REG_SET_P (pbi->new_set, regno + n);\n+    }\n+\n   /* Record and count the insns in which a reg dies.  If it is used in\n      this insn and was dead below the insn then it dies in this insn.\n      If it was set in this insn, we do not make a REG_DEAD note;\n-     likewise if we already made such a note. \n-\n-     ??? This could be done better.  In new_dead we have a record of \n-     which registers are set or clobbered this insn (which in itself is\n-     slightly incorrect, see the commentary near strict_low_part in\n-     mark_set_1), which should be the set of registers that we do not\n-     wish to create death notes for under the above rule.  Note that\n-     we have not yet processed the call-clobbered/call-used registers,\n-     and they do not quite follow the above rule, since we do want death\n-     notes for call-clobbered register arguments.  Which begs the whole\n-     question of whether we should in fact have death notes for registers\n-     used and clobbered (but not set) in the same insn.  The only useful\n-     thing we ought to be getting from dead_or_set_p is detection of\n-     duplicate death notes.  */\n-\n-  if ((pbi->flags & PROP_DEATH_NOTES)\n+     likewise if we already made such a note.  */\n+  if ((pbi->flags & (PROP_DEATH_NOTES | PROP_REG_INFO))\n       && some_was_dead\n-      && ! dead_or_set_p (insn, reg))\n+      && some_not_set)\n     {\n-      int n;\n-\n       /* Check for the case where the register dying partially\n \t overlaps the register set by this insn.  */\n       if (regno < FIRST_PSEUDO_REGISTER\n \t  && HARD_REGNO_NREGS (regno, GET_MODE (reg)) > 1)\n \t{\n \t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \t  while (--n >= 0)\n-\t    some_was_live |= dead_or_set_regno_p (insn, regno + n);\n+\t    some_was_live |= REGNO_REG_SET_P (pbi->new_set, regno + n);\n \t}\n \n       /* If none of the words in X is needed, make a REG_DEAD note.\n \t Otherwise, we must make partial REG_DEAD notes.  */\n       if (! some_was_live)\n \t{\n-\t  REG_NOTES (insn)\n-\t    = alloc_EXPR_LIST (REG_DEAD, reg, REG_NOTES (insn));\n-\t  REG_N_DEATHS (regno)++;\n+\t  if ((pbi->flags & PROP_DEATH_NOTES)\n+\t      && ! find_regno_note (insn, REG_DEAD, regno))\n+\t    REG_NOTES (insn)\n+\t      = alloc_EXPR_LIST (REG_DEAD, reg, REG_NOTES (insn));\n+\n+\t  if (pbi->flags & PROP_REG_INFO)\n+\t    REG_N_DEATHS (regno)++;\n \t}\n       else\n \t{\n@@ -4538,14 +4576,22 @@ mark_used_reg (pbi, reg, cond, insn)\n \n \t  n = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n \t  for (; n >= regno; n--)\n-\t    if (!REGNO_REG_SET_P (pbi->reg_live, n)\n+\t    if (! REGNO_REG_SET_P (pbi->reg_live, n)\n \t\t&& ! dead_or_set_regno_p (insn, n))\n \t      REG_NOTES (insn)\n \t\t= alloc_EXPR_LIST (REG_DEAD,\n \t\t\t\t   gen_rtx_REG (reg_raw_mode[n], n),\n \t\t\t\t   REG_NOTES (insn));\n \t}\n     }\n+\n+  SET_REGNO_REG_SET (pbi->reg_live, regno);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (--n > 0)\n+\tSET_REGNO_REG_SET (pbi->reg_live, regno + n);\n+    }\n }\n \n /* Scan expression X and store a 1-bit in NEW_LIVE for each reg it uses."}]}