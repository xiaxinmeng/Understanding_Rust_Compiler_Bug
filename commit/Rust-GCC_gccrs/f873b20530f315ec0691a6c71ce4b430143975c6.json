{"sha": "f873b20530f315ec0691a6c71ce4b430143975c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg3M2IyMDUzMGYzMTVlYzA2OTFhNmM3MWNlNGI0MzAxNDM5NzVjNg==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2010-04-22T12:42:15Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2010-04-22T12:42:15Z"}, "message": "tree-parloops.c (loop_parallel_p): New argument parloop_obstack.\n\n2010-04-22  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* tree-parloops.c (loop_parallel_p): New argument\n\tparloop_obstack.  Pass it down.\n\t(parallelize_loops): New variable parloop_obstack.  Initialize it,\n\tpass it down, free it.\n\n\t* tree-loop-linear.c (linear_transform_loops): Pass down\n\tlambda_obstack.\n\n\t* tree-data-ref.h (lambda_compute_access_matrices): New argument\n\tof type struct obstack *.\n\n\t* tree-data-ref.c (analyze_subscript_affine_affine): New variable\n\tscratch_obstack.  Initialize it, pass down, free it.\n\n\t* lambda.h (lambda_loop_new): Remove.\n\t(lambda_matrix_new, lambda_matrix_inverse)\n\t(lambda_trans_matrix_new, lambda_trans_matrix_inverse): New\n\targument of type struct obstack *.\n\n\t* lambda-trans.c (lambda_trans_matrix_new): New argument\n\tlambda_obstack.  Pass it down, use obstack allocation for ret.\n\t(lambda_trans_matrix_inverse): New argument lambda_obstack.  Pass\n\tit down.\n\n\t* lambda-mat.c (lambda_matrix_get_column)\n\t(lambda_matrix_project_to_null): Remove.\n\t(lambda_matrix_new): New argument lambda_obstack.  Use obstack\n\tallocation for mat.\n\t(lambda_matrix_inverse_hard, lambda_matrix_inverse): New argument\n\tlambda_obstack.\n\n\t* lambda-code.c (lambda_loop_new): New function.\n\t(lambda_lattice_new, compute_nest_using_fourier_motzkin)\n\t(lambda_compute_auxillary_space, lambda_compute_target_space)\n\t(lambda_loopnest_transform, gcc_loop_to_lambda_loop)\n\t(lambda_loopnest_to_gcc_loopnest): Pass down lambda_obstack.\n\t(build_access_matrix): New argument lambda_obstack.  Use obstack\n\tallocation for am.\n\t(lambda_compute_step_signs, lambda_compute_access_matrices): New\n\targument lambda_obstack.  Pass it down.\n\nFrom-SVN: r158644", "tree": {"sha": "378620453122ae49e7bf7e0d9a64259baa14bbcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/378620453122ae49e7bf7e0d9a64259baa14bbcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f873b20530f315ec0691a6c71ce4b430143975c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f873b20530f315ec0691a6c71ce4b430143975c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f873b20530f315ec0691a6c71ce4b430143975c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f873b20530f315ec0691a6c71ce4b430143975c6/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b99279f36bd0bd5865cce14d6bb93db25101a5d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99279f36bd0bd5865cce14d6bb93db25101a5d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99279f36bd0bd5865cce14d6bb93db25101a5d4"}], "stats": {"total": 258, "additions": 143, "deletions": 115}, "files": [{"sha": "3c765004350eeb185351c052a4f57127136295ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -1,3 +1,46 @@\n+2010-04-22  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* tree-parloops.c (loop_parallel_p): New argument\n+\tparloop_obstack.  Pass it down.\n+\t(parallelize_loops): New variable parloop_obstack.  Initialize it,\n+\tpass it down, free it.\n+\n+\t* tree-loop-linear.c (linear_transform_loops): Pass down\n+\tlambda_obstack.\n+\n+\t* tree-data-ref.h (lambda_compute_access_matrices): New argument\n+\tof type struct obstack *.\n+\n+\t* tree-data-ref.c (analyze_subscript_affine_affine): New variable\n+\tscratch_obstack.  Initialize it, pass down, free it.\n+\n+\t* lambda.h (lambda_loop_new): Remove.\n+\t(lambda_matrix_new, lambda_matrix_inverse)\n+\t(lambda_trans_matrix_new, lambda_trans_matrix_inverse): New\n+\targument of type struct obstack *.\n+\n+\t* lambda-trans.c (lambda_trans_matrix_new): New argument\n+\tlambda_obstack.  Pass it down, use obstack allocation for ret.\n+\t(lambda_trans_matrix_inverse): New argument lambda_obstack.  Pass\n+\tit down.\n+\n+\t* lambda-mat.c (lambda_matrix_get_column)\n+\t(lambda_matrix_project_to_null): Remove.\n+\t(lambda_matrix_new): New argument lambda_obstack.  Use obstack\n+\tallocation for mat.\n+\t(lambda_matrix_inverse_hard, lambda_matrix_inverse): New argument\n+\tlambda_obstack.\n+\n+\t* lambda-code.c (lambda_loop_new): New function.\n+\t(lambda_lattice_new, compute_nest_using_fourier_motzkin)\n+\t(lambda_compute_auxillary_space, lambda_compute_target_space)\n+\t(lambda_loopnest_transform, gcc_loop_to_lambda_loop)\n+\t(lambda_loopnest_to_gcc_loopnest): Pass down lambda_obstack.\n+\t(build_access_matrix): New argument lambda_obstack.  Use obstack\n+\tallocation for am.\n+\t(lambda_compute_step_signs, lambda_compute_access_matrices): New\n+\targument lambda_obstack.  Pass it down.\n+\n 2010-04-22  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* optabs.h (expand_widening_mult): Declare."}, {"sha": "fff6ff800f358c5f51a31492abfc066ae6b0e8fa", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -150,14 +150,26 @@ static lambda_lattice lambda_lattice_compute_base (lambda_loopnest,\n \n static bool can_convert_to_perfect_nest (struct loop *);\n \n+/* Create a new lambda loop in LAMBDA_OBSTACK.  */\n+\n+static lambda_loop\n+lambda_loop_new (struct obstack * lambda_obstack)\n+{\n+  lambda_loop result = (lambda_loop)\n+    obstack_alloc (lambda_obstack, sizeof (struct lambda_loop_s));\n+  memset (result, 0, sizeof (struct lambda_loop_s));\n+  return result;\n+}\n+\n /* Create a new lambda body vector.  */\n \n lambda_body_vector\n lambda_body_vector_new (int size, struct obstack * lambda_obstack)\n {\n   lambda_body_vector ret;\n \n-  ret = (lambda_body_vector)obstack_alloc (lambda_obstack, sizeof (*ret));\n+  ret = (lambda_body_vector) obstack_alloc (lambda_obstack,\n+\t\t\t\t\t    sizeof (*ret));\n   LBV_COEFFICIENTS (ret) = lambda_vector_new (size);\n   LBV_SIZE (ret) = size;\n   LBV_DENOMINATOR (ret) = 1;\n@@ -367,9 +379,10 @@ lambda_lattice_new (int depth, int invariants, struct obstack * lambda_obstack)\n {\n   lambda_lattice ret\n       = (lambda_lattice)obstack_alloc (lambda_obstack, sizeof (*ret));\n-  LATTICE_BASE (ret) = lambda_matrix_new (depth, depth);\n+  LATTICE_BASE (ret) = lambda_matrix_new (depth, depth, lambda_obstack);\n   LATTICE_ORIGIN (ret) = lambda_vector_new (depth);\n-  LATTICE_ORIGIN_INVARIANTS (ret) = lambda_matrix_new (depth, invariants);\n+  LATTICE_ORIGIN_INVARIANTS (ret) = lambda_matrix_new (depth, invariants,\n+\t\t\t\t\t\t       lambda_obstack);\n   LATTICE_DIMENSION (ret) = depth;\n   LATTICE_INVARIANTS (ret) = invariants;\n   return ret;\n@@ -500,15 +513,15 @@ compute_nest_using_fourier_motzkin (int size,\n   lambda_vector swapvector, a1;\n   int newsize;\n \n-  A1 = lambda_matrix_new (128, depth);\n-  B1 = lambda_matrix_new (128, invariants);\n+  A1 = lambda_matrix_new (128, depth, lambda_obstack);\n+  B1 = lambda_matrix_new (128, invariants, lambda_obstack);\n   a1 = lambda_vector_new (128);\n \n   auxillary_nest = lambda_loopnest_new (depth, invariants, lambda_obstack);\n \n   for (i = depth - 1; i >= 0; i--)\n     {\n-      loop = lambda_loop_new ();\n+      loop = lambda_loop_new (lambda_obstack);\n       LN_LOOPS (auxillary_nest)[i] = loop;\n       LL_STEP (loop) = 1;\n \n@@ -654,12 +667,12 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n   /* Unfortunately, we can't know the number of constraints we'll have\n      ahead of time, but this should be enough even in ridiculous loop nest\n      cases. We must not go over this limit.  */\n-  A = lambda_matrix_new (128, depth);\n-  B = lambda_matrix_new (128, invariants);\n+  A = lambda_matrix_new (128, depth, lambda_obstack);\n+  B = lambda_matrix_new (128, invariants, lambda_obstack);\n   a = lambda_vector_new (128);\n \n-  A1 = lambda_matrix_new (128, depth);\n-  B1 = lambda_matrix_new (128, invariants);\n+  A1 = lambda_matrix_new (128, depth, lambda_obstack);\n+  B1 = lambda_matrix_new (128, invariants, lambda_obstack);\n   a1 = lambda_vector_new (128);\n \n   /* Store the bounds in the equation matrix A, constant vector a, and\n@@ -754,11 +767,11 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n   /* Now compute the auxiliary space bounds by first inverting U, multiplying\n      it by A1, then performing Fourier-Motzkin.  */\n \n-  invertedtrans = lambda_matrix_new (depth, depth);\n+  invertedtrans = lambda_matrix_new (depth, depth, lambda_obstack);\n \n   /* Compute the inverse of U.  */\n   lambda_matrix_inverse (LTM_MATRIX (trans),\n-\t\t\t invertedtrans, depth);\n+\t\t\t invertedtrans, depth, lambda_obstack);\n \n   /* A = A1 inv(U).  */\n   lambda_matrix_mult (A1, invertedtrans, A, size, depth, depth);\n@@ -795,18 +808,19 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n   depth = LN_DEPTH (auxillary_nest);\n   invariants = LN_INVARIANTS (auxillary_nest);\n \n-  inverse = lambda_matrix_new (depth, depth);\n-  determinant = lambda_matrix_inverse (LTM_MATRIX (H), inverse, depth);\n+  inverse = lambda_matrix_new (depth, depth, lambda_obstack);\n+  determinant = lambda_matrix_inverse (LTM_MATRIX (H), inverse, depth,\n+\t\t\t\t       lambda_obstack);\n \n   /* H1 is H excluding its diagonal.  */\n-  H1 = lambda_matrix_new (depth, depth);\n+  H1 = lambda_matrix_new (depth, depth, lambda_obstack);\n   lambda_matrix_copy (LTM_MATRIX (H), H1, depth, depth);\n \n   for (i = 0; i < depth; i++)\n     H1[i][i] = 0;\n \n   /* Computes the linear offsets of the loop bounds.  */\n-  target = lambda_matrix_new (depth, depth);\n+  target = lambda_matrix_new (depth, depth, lambda_obstack);\n   lambda_matrix_mult (H1, inverse, target, depth, depth, depth);\n \n   target_nest = lambda_loopnest_new (depth, invariants, lambda_obstack);\n@@ -815,7 +829,7 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n     {\n \n       /* Get a new loop structure.  */\n-      target_loop = lambda_loop_new ();\n+      target_loop = lambda_loop_new (lambda_obstack);\n       LN_LOOPS (target_nest)[i] = target_loop;\n \n       /* Computes the gcd of the coefficients of the linear part.  */\n@@ -982,7 +996,9 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n    result.  */\n \n static lambda_vector\n-lambda_compute_step_signs (lambda_trans_matrix trans, lambda_vector stepsigns)\n+lambda_compute_step_signs (lambda_trans_matrix trans,\n+                           lambda_vector stepsigns,\n+                           struct obstack * lambda_obstack)\n {\n   lambda_matrix matrix, H;\n   int size;\n@@ -992,7 +1008,7 @@ lambda_compute_step_signs (lambda_trans_matrix trans, lambda_vector stepsigns)\n \n   matrix = LTM_MATRIX (trans);\n   size = LTM_ROWSIZE (trans);\n-  H = lambda_matrix_new (size, size);\n+  H = lambda_matrix_new (size, size, lambda_obstack);\n \n   newsteps = lambda_vector_new (size);\n   lambda_vector_copy (stepsigns, newsteps, size);\n@@ -1067,33 +1083,35 @@ lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans,\n \n   /* Compute the lattice base.  */\n   lattice = lambda_lattice_compute_base (nest, lambda_obstack);\n-  trans1 = lambda_trans_matrix_new (depth, depth);\n+  trans1 = lambda_trans_matrix_new (depth, depth, lambda_obstack);\n \n   /* Multiply the transformation matrix by the lattice base.  */\n \n   lambda_matrix_mult (LTM_MATRIX (trans), LATTICE_BASE (lattice),\n \t\t      LTM_MATRIX (trans1), depth, depth, depth);\n \n   /* Compute the Hermite normal form for the new transformation matrix.  */\n-  H = lambda_trans_matrix_new (depth, depth);\n-  U = lambda_trans_matrix_new (depth, depth);\n+  H = lambda_trans_matrix_new (depth, depth, lambda_obstack);\n+  U = lambda_trans_matrix_new (depth, depth, lambda_obstack);\n   lambda_matrix_hermite (LTM_MATRIX (trans1), depth, LTM_MATRIX (H),\n \t\t\t LTM_MATRIX (U));\n \n   /* Compute the auxiliary loop nest's space from the unimodular\n      portion.  */\n-  auxillary_nest = lambda_compute_auxillary_space (nest, U, lambda_obstack);\n+  auxillary_nest = lambda_compute_auxillary_space (nest, U,\n+\t\t\t\t\t\t   lambda_obstack);\n \n   /* Compute the loop step signs from the old step signs and the\n      transformation matrix.  */\n-  stepsigns = lambda_compute_step_signs (trans1, stepsigns);\n+  stepsigns = lambda_compute_step_signs (trans1, stepsigns,\n+\t\t\t\t\t lambda_obstack);\n \n   /* Compute the target loop nest space from the auxiliary nest and\n      the lower triangular matrix H.  */\n   target_nest = lambda_compute_target_space (auxillary_nest, H, stepsigns,\n                                              lambda_obstack);\n   origin = lambda_vector_new (depth);\n-  origin_invariants = lambda_matrix_new (depth, invariants);\n+  origin_invariants = lambda_matrix_new (depth, invariants, lambda_obstack);\n   lambda_matrix_vector_mult (LTM_MATRIX (trans), depth, depth,\n \t\t\t     LATTICE_ORIGIN (lattice), origin);\n   lambda_matrix_mult (LTM_MATRIX (trans), LATTICE_ORIGIN_INVARIANTS (lattice),\n@@ -1424,7 +1442,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n       return NULL;\n     }\n \n-  lloop = lambda_loop_new ();\n+  lloop = lambda_loop_new (lambda_obstack);\n   LL_STEP (lloop) = stepint;\n   LL_LOWER_BOUND (lloop) = lbound;\n   LL_UPPER_BOUND (lloop) = ubound;\n@@ -1702,7 +1720,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n   tree oldiv;\n   gimple_stmt_iterator bsi;\n \n-  transform = lambda_trans_matrix_inverse (transform);\n+  transform = lambda_trans_matrix_inverse (transform, lambda_obstack);\n \n   if (dump_file)\n     {\n@@ -2801,9 +2819,12 @@ av_for_af (tree access_fun, lambda_vector cy, struct access_matrix *am)\n \n static bool\n build_access_matrix (data_reference_p data_reference,\n-\t\t     VEC (tree, heap) *parameters, VEC (loop_p, heap) *nest)\n+\t\t     VEC (tree, heap) *parameters,\n+\t\t     VEC (loop_p, heap) *nest,\n+\t\t     struct obstack * lambda_obstack)\n {\n-  struct access_matrix *am = GGC_NEW (struct access_matrix);\n+  struct access_matrix *am = (struct access_matrix *)\n+    obstack_alloc(lambda_obstack, sizeof (struct access_matrix));\n   unsigned i, ndim = DR_NUM_DIMENSIONS (data_reference);\n   unsigned nivs = VEC_length (loop_p, nest);\n   unsigned lambda_nb_columns;\n@@ -2835,13 +2856,14 @@ build_access_matrix (data_reference_p data_reference,\n bool\n lambda_compute_access_matrices (VEC (data_reference_p, heap) *datarefs,\n \t\t\t\tVEC (tree, heap) *parameters,\n-\t\t\t\tVEC (loop_p, heap) *nest)\n+\t\t\t\tVEC (loop_p, heap) *nest,\n+\t\t\t\tstruct obstack * lambda_obstack)\n {\n   data_reference_p dataref;\n   unsigned ix;\n \n   for (ix = 0; VEC_iterate (data_reference_p, datarefs, ix, dataref); ix++)\n-    if (!build_access_matrix (dataref, parameters, nest))\n+    if (!build_access_matrix (dataref, parameters, nest, lambda_obstack))\n       return false;\n \n   return true;"}, {"sha": "50fdb69992515187c717ee16b69cb86eaa76fbda", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 11, "deletions": 62, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -27,18 +27,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"lambda.h\"\n \n-static void lambda_matrix_get_column (lambda_matrix, int, int,\n-\t\t\t\t      lambda_vector);\n-\n /* Allocate a matrix of M rows x  N cols.  */\n \n lambda_matrix\n-lambda_matrix_new (int m, int n)\n+lambda_matrix_new (int m, int n, struct obstack * lambda_obstack)\n {\n   lambda_matrix mat;\n   int i;\n \n-  mat = GGC_NEWVEC (lambda_vector, m);\n+  mat = (lambda_matrix) obstack_alloc (lambda_obstack,\n+\t\t\t\t       sizeof (lambda_vector *) * m);\n \n   for (i = 0; i < m; i++)\n     mat[i] = lambda_vector_new (n);\n@@ -165,19 +163,6 @@ lambda_matrix_mult (lambda_matrix mat1, lambda_matrix mat2,\n     }\n }\n \n-/* Get column COL from the matrix MAT and store it in VEC.  MAT has\n-   N rows, so the length of VEC must be N.  */\n-\n-static void\n-lambda_matrix_get_column (lambda_matrix mat, int n, int col,\n-\t\t\t  lambda_vector vec)\n-{\n-  int i;\n-\n-  for (i = 0; i < n; i++)\n-    vec[i] = mat[i][col];\n-}\n-\n /* Delete rows r1 to r2 (not including r2).  */\n \n void\n@@ -307,10 +292,12 @@ lambda_matrix_col_mc (lambda_matrix mat, int m, int c1, int const1)\n    When MAT is a 2 x 2 matrix, we don't go through the whole process, because\n    it is easily inverted by inspection and it is a very common case.  */\n \n-static int lambda_matrix_inverse_hard (lambda_matrix, lambda_matrix, int);\n+static int lambda_matrix_inverse_hard (lambda_matrix, lambda_matrix, int,\n+\t\t\t\t       struct obstack *);\n \n int\n-lambda_matrix_inverse (lambda_matrix mat, lambda_matrix inv, int n)\n+lambda_matrix_inverse (lambda_matrix mat, lambda_matrix inv, int n,\n+\t\t       struct obstack * lambda_obstack)\n {\n   if (n == 2)\n     {\n@@ -335,20 +322,21 @@ lambda_matrix_inverse (lambda_matrix mat, lambda_matrix inv, int n)\n       return det;\n     }\n   else\n-    return lambda_matrix_inverse_hard (mat, inv, n);\n+    return lambda_matrix_inverse_hard (mat, inv, n, lambda_obstack);\n }\n \n /* If MAT is not a special case, invert it the hard way.  */\n \n static int\n-lambda_matrix_inverse_hard (lambda_matrix mat, lambda_matrix inv, int n)\n+lambda_matrix_inverse_hard (lambda_matrix mat, lambda_matrix inv, int n,\n+\t\t\t    struct obstack * lambda_obstack)\n {\n   lambda_vector row;\n   lambda_matrix temp;\n   int i, j;\n   int determinant;\n \n-  temp = lambda_matrix_new (n, n);\n+  temp = lambda_matrix_new (n, n, lambda_obstack);\n   lambda_matrix_copy (mat, temp, n, n);\n   lambda_matrix_id (inv, n);\n \n@@ -592,45 +580,6 @@ lambda_matrix_first_nz_vec (lambda_matrix mat, int rowsize, int colsize,\n   return rowsize;\n }\n \n-/* Calculate the projection of E sub k to the null space of B.  */\n-\n-void\n-lambda_matrix_project_to_null (lambda_matrix B, int rowsize,\n-\t\t\t       int colsize, int k, lambda_vector x)\n-{\n-  lambda_matrix M1, M2, M3, I;\n-  int determinant;\n-\n-  /* Compute c(I-B^T inv(B B^T) B) e sub k.  */\n-\n-  /* M1 is the transpose of B.  */\n-  M1 = lambda_matrix_new (colsize, colsize);\n-  lambda_matrix_transpose (B, M1, rowsize, colsize);\n-\n-  /* M2 = B * B^T */\n-  M2 = lambda_matrix_new (colsize, colsize);\n-  lambda_matrix_mult (B, M1, M2, rowsize, colsize, rowsize);\n-\n-  /* M3 = inv(M2) */\n-  M3 = lambda_matrix_new (colsize, colsize);\n-  determinant = lambda_matrix_inverse (M2, M3, rowsize);\n-\n-  /* M2 = B^T (inv(B B^T)) */\n-  lambda_matrix_mult (M1, M3, M2, colsize, rowsize, rowsize);\n-\n-  /* M1 = B^T (inv(B B^T)) B */\n-  lambda_matrix_mult (M2, B, M1, colsize, rowsize, colsize);\n-  lambda_matrix_negate (M1, M1, colsize, colsize);\n-\n-  I = lambda_matrix_new (colsize, colsize);\n-  lambda_matrix_id (I, colsize);\n-\n-  lambda_matrix_add_mc (I, determinant, M1, 1, M2, colsize, colsize);\n-\n-  lambda_matrix_get_column (M2, colsize, k - 1, x);\n-\n-}\n-\n /* Multiply a vector VEC by a matrix MAT.\n    MAT is an M*N matrix, and VEC is a vector with length N.  The result\n    is stored in DEST which must be a vector of length M.  */"}, {"sha": "0cf1db96fa63b9ef437aa6c241bccae9dccb3ebc", "filename": "gcc/lambda-trans.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -31,12 +31,14 @@ along with GCC; see the file COPYING3.  If not see\n /* Allocate a new transformation matrix.  */\n \n lambda_trans_matrix\n-lambda_trans_matrix_new (int colsize, int rowsize)\n+lambda_trans_matrix_new (int colsize, int rowsize,\n+\t\t\t struct obstack * lambda_obstack)\n {\n   lambda_trans_matrix ret;\n \n-  ret = GGC_NEW (struct lambda_trans_matrix_s);\n-  LTM_MATRIX (ret) = lambda_matrix_new (rowsize, colsize);\n+  ret = (lambda_trans_matrix)\n+    obstack_alloc (lambda_obstack, sizeof (struct lambda_trans_matrix_s));\n+  LTM_MATRIX (ret) = lambda_matrix_new (rowsize, colsize, lambda_obstack);\n   LTM_ROWSIZE (ret) = rowsize;\n   LTM_COLSIZE (ret) = colsize;\n   LTM_DENOMINATOR (ret) = 1;\n@@ -57,14 +59,16 @@ lambda_trans_matrix_id_p (lambda_trans_matrix mat)\n /* Compute the inverse of the transformation matrix MAT.  */\n \n lambda_trans_matrix\n-lambda_trans_matrix_inverse (lambda_trans_matrix mat)\n+lambda_trans_matrix_inverse (lambda_trans_matrix mat,\n+\t\t\t     struct obstack * lambda_obstack)\n {\n   lambda_trans_matrix inverse;\n   int determinant;\n \n-  inverse = lambda_trans_matrix_new (LTM_ROWSIZE (mat), LTM_COLSIZE (mat));\n+  inverse = lambda_trans_matrix_new (LTM_ROWSIZE (mat), LTM_COLSIZE (mat),\n+\t\t\t\t     lambda_obstack);\n   determinant = lambda_matrix_inverse (LTM_MATRIX (mat), LTM_MATRIX (inverse),\n-\t\t\t\t       LTM_ROWSIZE (mat));\n+\t\t\t\t       LTM_ROWSIZE (mat), lambda_obstack);\n   LTM_DENOMINATOR (inverse) = determinant;\n   return inverse;\n }"}, {"sha": "c819027f5826b34596b8a6911e61cbe3327afeef", "filename": "gcc/lambda.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -156,11 +156,9 @@ struct loop;\n bool perfect_nest_p (struct loop *);\n void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n \n-#define lambda_loop_new() (lambda_loop) ggc_alloc_cleared (sizeof (struct lambda_loop_s))\n-\n void print_lambda_loop (FILE *, lambda_loop, int, int, char);\n \n-lambda_matrix lambda_matrix_new (int, int);\n+lambda_matrix lambda_matrix_new (int, int, struct obstack *);\n \n void lambda_matrix_id (lambda_matrix, int);\n bool lambda_matrix_id_p (lambda_matrix, int);\n@@ -182,7 +180,7 @@ void lambda_matrix_col_exchange (lambda_matrix, int, int, int);\n void lambda_matrix_col_add (lambda_matrix, int, int, int, int);\n void lambda_matrix_col_negate (lambda_matrix, int, int);\n void lambda_matrix_col_mc (lambda_matrix, int, int, int);\n-int lambda_matrix_inverse (lambda_matrix, lambda_matrix, int);\n+int lambda_matrix_inverse (lambda_matrix, lambda_matrix, int, struct obstack *);\n void lambda_matrix_hermite (lambda_matrix, int, lambda_matrix, lambda_matrix);\n void lambda_matrix_left_hermite (lambda_matrix, int, int, lambda_matrix, lambda_matrix);\n void lambda_matrix_right_hermite (lambda_matrix, int, int, lambda_matrix, lambda_matrix);\n@@ -191,13 +189,14 @@ void lambda_matrix_project_to_null (lambda_matrix, int, int, int,\n \t\t\t\t    lambda_vector);\n void print_lambda_matrix (FILE *, lambda_matrix, int, int);\n \n-lambda_trans_matrix lambda_trans_matrix_new (int, int);\n+lambda_trans_matrix lambda_trans_matrix_new (int, int, struct obstack *);\n bool lambda_trans_matrix_nonsingular_p (lambda_trans_matrix);\n bool lambda_trans_matrix_fullrank_p (lambda_trans_matrix);\n int lambda_trans_matrix_rank (lambda_trans_matrix);\n lambda_trans_matrix lambda_trans_matrix_basis (lambda_trans_matrix);\n lambda_trans_matrix lambda_trans_matrix_padding (lambda_trans_matrix);\n-lambda_trans_matrix lambda_trans_matrix_inverse (lambda_trans_matrix);\n+lambda_trans_matrix lambda_trans_matrix_inverse (lambda_trans_matrix,\n+\t\t\t\t\t\t struct obstack *);\n void print_lambda_trans_matrix (FILE *, lambda_trans_matrix);\n void lambda_matrix_vector_mult (lambda_matrix, int, int, lambda_vector,\n \t\t\t\tlambda_vector);"}, {"sha": "9abb2a8422eae5c53b67eaed631cb3eacb9109e1", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -2176,6 +2176,7 @@ analyze_subscript_affine_affine (tree chrec_a,\n   unsigned nb_vars_a, nb_vars_b, dim;\n   HOST_WIDE_INT init_a, init_b, gamma, gcd_alpha_beta;\n   lambda_matrix A, U, S;\n+  struct obstack scratch_obstack;\n \n   if (eq_evolutions_p (chrec_a, chrec_b))\n     {\n@@ -2203,10 +2204,12 @@ analyze_subscript_affine_affine (tree chrec_a,\n   nb_vars_a = nb_vars_in_chrec (chrec_a);\n   nb_vars_b = nb_vars_in_chrec (chrec_b);\n \n+  gcc_obstack_init (&scratch_obstack);\n+\n   dim = nb_vars_a + nb_vars_b;\n-  U = lambda_matrix_new (dim, dim);\n-  A = lambda_matrix_new (dim, 1);\n-  S = lambda_matrix_new (dim, 1);\n+  U = lambda_matrix_new (dim, dim, &scratch_obstack);\n+  A = lambda_matrix_new (dim, 1, &scratch_obstack);\n+  S = lambda_matrix_new (dim, 1, &scratch_obstack);\n \n   init_a = int_cst_value (initialize_matrix_A (A, chrec_a, 0, 1));\n   init_b = int_cst_value (initialize_matrix_A (A, chrec_b, nb_vars_a, -1));\n@@ -2420,6 +2423,7 @@ analyze_subscript_affine_affine (tree chrec_a,\n     }\n \n end_analyze_subs_aa:\n+  obstack_free (&scratch_obstack, NULL);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  (overlaps_a = \");"}, {"sha": "eff534831161fb77ac83f89a8a291d029c1a685d", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -584,7 +584,9 @@ bool lambda_transform_legal_p (lambda_trans_matrix, int,\n void lambda_collect_parameters (VEC (data_reference_p, heap) *,\n \t\t\t\tVEC (tree, heap) **);\n bool lambda_compute_access_matrices (VEC (data_reference_p, heap) *,\n-\t\t\t\t     VEC (tree, heap) *, VEC (loop_p, heap) *);\n+\t\t\t\t     VEC (tree, heap) *,\n+\t\t\t\t     VEC (loop_p, heap) *,\n+\t\t\t\t     struct obstack *);\n \n /* In tree-data-ref.c  */\n void split_constant_offset (tree , tree *, tree *);"}, {"sha": "047389c6e6a5d5a5fd4efcbe799a22a670fc0596", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -358,14 +358,15 @@ linear_transform_loops (void)\n \tgoto free_and_continue;\n \n       lambda_collect_parameters (datarefs, &lambda_parameters);\n-      if (!lambda_compute_access_matrices (datarefs, lambda_parameters, nest))\n+      if (!lambda_compute_access_matrices (datarefs, lambda_parameters,\n+\t\t\t\t\t   nest, &lambda_obstack))\n \tgoto free_and_continue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tdump_ddrs (dump_file, dependence_relations);\n \n       /* Build the transformation matrix.  */\n-      trans = lambda_trans_matrix_new (depth, depth);\n+      trans = lambda_trans_matrix_new (depth, depth, &lambda_obstack);\n       lambda_matrix_id (LTM_MATRIX (trans), depth);\n       trans = try_interchange_loops (trans, depth, dependence_relations,\n \t\t\t\t     datarefs, loop_nest);"}, {"sha": "69a0b659616d57f6be5fac1adceccce300e6494a", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f873b20530f315ec0691a6c71ce4b430143975c6/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=f873b20530f315ec0691a6c71ce4b430143975c6", "patch": "@@ -248,7 +248,7 @@ name_to_copy_elt_hash (const void *aa)\n    in parallel).  */\n \n static bool\n-loop_parallel_p (struct loop *loop)\n+loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)\n {\n   VEC (ddr_p, heap) * dependence_relations;\n   VEC (data_reference_p, heap) *datarefs;\n@@ -273,7 +273,7 @@ loop_parallel_p (struct loop *loop)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_data_dependence_relations (dump_file, dependence_relations);\n \n-  trans = lambda_trans_matrix_new (1, 1);\n+  trans = lambda_trans_matrix_new (1, 1, parloop_obstack);\n   LTM_MATRIX (trans)[0][0] = -1;\n \n   if (lambda_transform_legal_p (trans, 1, dependence_relations))\n@@ -1884,15 +1884,17 @@ parallelize_loops (void)\n   struct tree_niter_desc niter_desc;\n   loop_iterator li;\n   htab_t reduction_list;\n+  struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n   LOC loop_loc;\n-  \n+\n   /* Do not parallelize loops in the functions created by parallelization.  */\n   if (parallelized_function_p (cfun->decl))\n     return false;\n   if (cfun->has_nonlocal_label)\n     return false;\n \n+  gcc_obstack_init (&parloop_obstack);\n   reduction_list = htab_create (10, reduction_info_hash,\n \t\t\t\t     reduction_info_eq, free);\n   init_stmt_vec_info_vec ();\n@@ -1950,7 +1952,8 @@ parallelize_loops (void)\n       if (!try_create_reduction_list (loop, reduction_list))\n \tcontinue;\n \n-      if (!flag_loop_parallelize_all && !loop_parallel_p (loop))\n+      if (!flag_loop_parallelize_all\n+\t  && !loop_parallel_p (loop, &parloop_obstack))\n \tcontinue;\n \n       changed = true;\n@@ -1975,6 +1978,7 @@ parallelize_loops (void)\n \n   free_stmt_vec_info_vec ();\n   htab_delete (reduction_list);\n+  obstack_free (&parloop_obstack, NULL);\n \n   /* Parallelization will cause new function calls to be inserted through\n      which local variables will escape.  Reset the points-to solution"}]}