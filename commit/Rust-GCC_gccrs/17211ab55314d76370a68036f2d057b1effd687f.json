{"sha": "17211ab55314d76370a68036f2d057b1effd687f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcyMTFhYjU1MzE0ZDc2MzcwYTY4MDM2ZjJkMDU3YjFlZmZkNjg3Zg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-01-10T02:22:34Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-01-10T02:22:34Z"}, "message": "Merge from pch-branch.\n\nFrom-SVN: r61136", "tree": {"sha": "a3ff2e89f1924fd7ea1d99358736bc8491352747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3ff2e89f1924fd7ea1d99358736bc8491352747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17211ab55314d76370a68036f2d057b1effd687f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17211ab55314d76370a68036f2d057b1effd687f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17211ab55314d76370a68036f2d057b1effd687f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17211ab55314d76370a68036f2d057b1effd687f/comments", "author": null, "committer": null, "parents": [{"sha": "5f7c78d8a4df096dacfa2d9de367a6174dd631ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f7c78d8a4df096dacfa2d9de367a6174dd631ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f7c78d8a4df096dacfa2d9de367a6174dd631ba"}], "stats": {"total": 7067, "additions": 5507, "deletions": 1560}, "files": [{"sha": "2e2e1b2ac32b81e4e2f04b8fbf1c4ef00d6d9f21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 518, "deletions": 2, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,3 +1,519 @@\n+2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tMerge from pch-branch:\n+\n+\t2003-01-06  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* ggc-page.c (ggc_pch_read): Update the statistics after a PCH\n+\tload.\n+\n+\t2002-12-24  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* cpplib.c (count_registered_pragmas): New function.\n+\t(save_registered_pragmas): New function.\n+\t(_cpp_save_pragma_names): New function.\n+\t(restore_registered_pragmas): New function.\n+\t(_cpp_restore_pragma_names): New function.\n+\t* cpphash.h (_cpp_save_pragma_names): Prototype.\n+\t(_cpp_restore_pragma_names): Likewise.\n+\t* cpppch.c (struct save_macro_item): Split from save_macro_data.\n+\t(struct save_macro_data): New field 'saved_pragmas'.\n+\t(save_macros): Update for changes to struct save_macro_data.\n+\t(cpp_prepare_state): Call _cpp_save_pragma_names, update\n+\tfor changes to struct save_macro_data.\n+\t(cpp_read_state): Call _cpp_restore_pragma_names, update\n+\tfor changes to struct save_macro_data.\n+\n+\t* cpppch.c (cpp_read_state): Restore the hashtable references\n+\tin the cpp_reader.\n+\t\n+\t* tree.h (built_in_decls): Mark for PCH.\n+\n+\t* dbxout.c (lastfile): Don't mark for PCH.\n+\n+\t* ggc.h: Document PCH calls into memory managers.\n+\n+\t2002-12-18  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* doc/invoke.texi (Precompiled Headers): Document the\n+\tdirectory form of PCH.\n+\t* cppfiles.c (validate_pch): New function.\n+\t(open_file_pch): Search suitably-named directories for PCH files.\n+\n+\t2002-12-14  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* doc/gty.texi (GTY Options): Document chain_next, chain_prev,\n+\treorder options.\n+\t(Type Information): Mention that the information is also\n+\tused to implement PCH.\n+\t* doc/passes.texi (Passes): Improve documentation of\n+\tlanguage-specific files.\n+\n+\t2002-12-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gengtype.c (struct write_types_data): Add reorder_note_routine field.\n+\t(struct walk_type_data): Add reorder_fn field.\n+\t(walk_type): Process 'reorder' option.\n+\t(write_types_process_field): Reorder parameters to gt_pch_note_object,\n+\tcall reorder_note_routine.\n+\t(write_func_for_structure): Reorder parameters to gt_pch_note_object.\n+\t(ggc_wtd): Update for change to struct write_types_data.\n+\t(pch_wtd): Likewise.\n+\t* ggc.h (gt_pch_note_object): Reorder parameters.\n+\t(gt_handle_reorder): New definition.\n+\t(gt_pch_note_reorder): New prototype.\n+\t* ggc-common.c (struct ptr_data): Add reorder_fn.\n+\t(gt_pch_note_object): Reorder parameters.\n+\t(gt_pch_note_reorder): New.\n+\t(gt_pch_save): Call reorder_fn.\n+\t* stringpool.c (gt_pch_n_S): Update for change to gt_pch_note_object.\n+\n+\t* dbxout.c (cwd): Don't mark for PCH.\n+\n+\t2002-12-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gengtype.c (finish_root_table): Fix some warnings.\n+\t(write_root): Handle TYPE_STRING.\n+\t* ggc.h (gt_ggc_m_S): Add prototype.\n+\t* stringpool.c (gt_ggc_m_S): New function.\n+\n+\t2002-11-30  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* dwarf2out.c (dw2_string_counter): New.\n+\t(AT_string_form): Use it.\n+\t(same_dw_val_p): Update for removal of hashtable.h hash tables.\n+\n+\t2002-11-22  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* dbxout.c: Include gt-dbxout.h.\n+\t(lastfile): Mark for PCH/GGC.\n+\t(cwd): Likewise.\n+\t(struct typeinfo): Likewise.\n+\t(typevec): Likewise.\n+\t(typevec_len): Likewise.\n+\t(next_type_number): Likewise.\n+\t(struct dbx_file): Likewise.\n+\t(current_file): Likewise.\n+\t(next_file_number): Likewise.\n+\t(dbxout_init): Allocate typevec, struct dbx_file with GGC.\n+\t(dbxout_start_source_file): Allocate struct dbx_file with GGC.\n+\t(dbxout_end_source_file): Don't free struct dbx_file.\n+\t(dbxout_type): Use GGC to allocate typevec.\n+\t* Makefile.in (dbxout.o): Depend on gt-dbxout.h, $(GGC_H).\n+\t(GTFILES): Add dbxout.c.\n+\t(gt-dbxout.h): New rule.\n+\t\n+\t* Makefile.in (c-pch.o): Add debug.h as dependency.\n+\t* c-pch.c: Include debug.h.\n+\t(pch_init): Call start_source_file to keep nesting right.\n+\t(c_common_read_pch): Add orig_name parameter.  Call\n+\tstart_source_file debug hook.  Call end_source_file debug hook.\n+\t* c-common.h (c_common_read_pch): Update prototype.\n+\t* cpplib.h (struct cpp_callbacks): Add fourth field to read_pch\n+\tcallback.\n+\t* cppfiles.c (struct include_file): Add new field `header_name'.\n+\t(find_or_create_entry): Default it to `name'.\n+\t(open_file_pch): Set it to the original header file searched for.\n+\t(stack_include_file): Don't stack an empty buffer, just handle\n+\tPCH files immediately.  Pass header_name field to read_pch callback.\n+\n+\t2002-11-19  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* function.c (funcdef_no): Mark to be saved in a PCH.\n+\n+\t2002-11-15  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* ggc-page.c (ggc_pch_read): Remove unused 'bmap_size'.\n+\n+\t* cpppch.c (cpp_read_state): Correct size reallocated for 'defn'.\n+\n+\t2002-11-14  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* optabs.h (code_to_optab): Add GTY marker.\n+\n+\t2002-11-13  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* Makefile.in (GTFILES): Add cpplib.h.\n+\t* c-common.h (struct c_common_identifier): Don't skip 'node' field.\n+\t* c-decl.c (build_compound_literal): Don't use var_labelno.\n+\t* cpplib.h (struct cpp_hashnode): Use gengtype to mark.\n+\t* dwarf2asm.c (dw2_force_const_mem): Don't use const_labelno.\n+\t* varasm.c (const_labelno): Use gengtype to mark.\n+\t(var_labelno): Likewise.\n+\t(in_section): Likewise.\n+\t(in_named_name): Likewise.\n+\t(struct in_named_entry): Likewise.\n+\t(in_named_htab): Likewise.\n+\t(set_named_section_flags): Use GGC to allocate struct in_named_entry.\n+\t(init_varasm_once): Use GGC to allocate in_named_htab.\n+\t* config/darwin.c (current_pic_label_num): Mark for PCH.\n+\n+\t2002-11-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* ggc-simple.c (init_ggc_pch): New stub procedure.\n+\t(ggc_pch_count_object): Likewise.\n+\t(ggc_pch_total_size): Likewise.\n+\t(ggc_pch_this_base): Likewise.\n+\t(ggc_pch_alloc_object): Likewise.\n+\t(ggc_pch_prepare_write): Likewise.\n+\t(ggc_pch_write_object): Likewise\n+\t(ggc_pch_finish): Likewise.\n+\t(ggc_pch_read): Likewise.\n+\n+\t2002-11-08  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* c-pch.c (c_common_write_pch): Write the macro definitions after\n+\tthe GCed data.\n+\t(c_common_read_pch): Call cpp_prepare_state.  Restore the macro\n+\tdefinitions after the GCed data.\n+\t* cpplib.c (save_macros): New.\n+\t(reset_ht): New.\n+\t(cpp_write_pch_deps): Split out of cpp_write_pch.\n+\t(cpp_write_pch_state): Split out of cpp_write_pch.\n+\t(cpp_write_pch): Delete.\n+\t(struct save_macro_data): Delete.\n+\t(cpp_prepare_state): New.\n+\t(cpp_read_state): Erase and restore initial macro definitions.\n+\t* cpplib.h (struct save_macro_data): Forward-declare.\n+\t(cpp_write_pch_deps): Prototype.\n+\t(cpp_write_pch_state): Prototype.\n+\t(cpp_write_pch): Delete prototype.\n+\t(cpp_prepare_state): Prototype.\n+\t(cpp_read_state): Add fourth argument.\n+\n+\t2002-11-04  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gengtype.c (adjust_field_rtx_def): Don't use skip on valid fields.\n+\t(write_array): Remove warning.\n+\n+\t* gengtype.c (contains_scalar_p): New.\n+\t(finish_root_table): Add the table to all languages, even if it's\n+\tempty.\n+\t(write_roots): Output gt_pch_scalar_rtab.\n+\t* ggc-common.c (gt_pch_save): Write out scalars.\n+\t(gt_pch_restore): Read scalars back.\n+\n+\t* ggc-page.c (OBJECTS_IN_PAGE): New macro.\n+\t(struct page_entry): Delete pch_page field.\n+\t(ggc_recalculate_in_use_p): Use OBJECTS_IN_PAGE.\n+\t(clear_marks): Likewise.\n+\t(sweep_pages): Likewise.\n+\t(poison_pages): Likewise.\n+\t(ggc_print_statistics): Likewise.\n+\t(ggc_pch_read): Don't free objects read from a PCH.\n+\tProperly set up in_use_p and page_tails.\n+\n+\t2002-10-25  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gengtype.c (struct write_types_data): New.\n+\t(struct walk_type_data): Make `cookie' const; add extra\n+\tprev_val item; add `orig_s' field.\n+\t(walk_type): Update prev_val[3].\n+\t(write_types_process_field): New.\n+\t(write_func_for_structure): Take write_types_data structure.\n+\t(write_types): New.\n+\t(ggc_wtd): New.\n+\t(pch_wtd): New.\n+\t(write_types_local_process_field): New.\n+\t(gc_mark_process_field): Delete.\n+\t(write_local_func_for_structure): New.\n+\t(gc_mark_func_name): Delete.\n+\t(write_gc_types): Delete.\n+\t(write_local): New.\n+\t(finish_root_table): Don't include 'ggc_' in PFX.\n+\t(write_root): Rename from write_root.  Fill pchw field of structures.\n+\t(write_array): New.\n+\t(write_roots): Rename from write_gc_roots.  Split out to write_array.\n+\tUpdate to changes to other routines.  Write gt_pch_cache_rtab table.\n+\t(main): Write PCH walking routines.\n+\t* ggc-common.c: Include toplev.h, sys/mman.h.\n+\t(ggc_mark_roots): For cache hashtables, also mark the hash table\n+\tand the array of entries.\n+\t(saving_htab): New.\n+\t(struct ptr_data): New.\n+\t(POINTER_HASH): New.\n+\t(gt_pch_note_object): New.\n+\t(saving_htab_hash): New.\n+\t(saving_htab_eq): New.\n+\t(struct traversal_state): New.\n+\t(call_count): New.\n+\t(call_alloc): New.\n+\t(compare_ptr_data): New.\n+\t(relocate_ptrs): New.\n+\t(write_pch_globals): New.\n+\t(struct mmap_info): New.\n+\t(gt_pch_save): New.\n+\t(gt_pch_restore): New.\n+\t* ggc-page.c (ROUND_UP_VALUE): New.\n+\t(ROUND_UP): New.\n+\t(struct page_entry): Add field `pch_page'.\n+\t(init_ggc): Use ROUND_UP.\n+\t(struct ggc_pch_data): Declare.\n+\t(init_ggc_pch): New.\n+\t(ggc_pch_count_object): New.\n+\t(ggc_pch_total_size): New.\n+\t(ggc_pch_this_base): New.\n+\t(ggc_pch_alloc_object): New.\n+\t(ggc_pch_prepare_write): New.\n+\t(ggc_pch_write_object): New.\n+\t(ggc_pch_finish): New.\n+\t(ggc_pch_read): New.\n+\t* ggc.h (gt_pointer_operator): New.\n+\t(gt_note_pointers): New.\n+\t(gt_pch_note_object): New prototype.\n+\t(gt_pointer_walker): New.\n+\t(struct ggc_root_tab): Use gt_pointer_walker, add `pchw' field.\n+\t(LAST_GGC_ROOT_TAB): Update.\n+\t(gt_pch_cache_rtab): Declare.\n+\t(gt_pch_scalar_rtab): Declare.\n+\t(struct ggc_cache_tab): Use gt_pointer_walker, add `pchw' field.\n+\t(LAST_GGC_CACHE_TAB): Update.\n+\t(gt_pch_save_stringpool): Declare.\n+\t(gt_pch_restore_stringpool): Declare.\n+\t(gt_pch_p_S): Declare.\n+\t(gt_pch_n_S): Declare.\n+\t(struct ggc_pch_data): Forward-declare.\n+\t(init_ggc_pch): Declare.\n+\t(ggc_pch_count_object): Declare.\n+\t(ggc_pch_total_size): Declare.\n+\t(ggc_pch_this_base): Declare.\n+\t(ggc_pch_alloc_object): Declare.\n+\t(ggc_pch_prepare_write): Declare.\n+\t(ggc_pch_write_object): Declare.\n+\t(ggc_pch_finish): Declare.\n+\t(ggc_pch_read): Declare.\n+\t(gt_pch_save): Declare.\n+\t(gt_pch_restore): Declare.\n+\t* fold-const.c (size_int_type_wide): Allocate size_htab using GGC.\n+\t* emit-rtl.c (init_emit_once): Allocate const_int_htab,\n+\tconst_double_htab, mem_attrs_htab using GGC.\n+\t* c-pch.c: Include ggc.h.\n+\t(pch_init): Allow reading PCH file back.\n+\t(c_common_write_pch): Call gt_pch_save.\n+\t(c_common_read_pch): Call gt_pch_restore.\n+\t* c-parse.in (init_reswords): Delete now-untrue comment.\n+\tAllocate ridpointers using GGC.\n+\t* c-objc-common.c (c_objc_common_finish_file): Write PCH before\n+\tcalling expand_deferred_fns.\n+\t* c-common.h (ridpointers): Mark for GTY machinery.\n+\t* Makefile.in (stringpool.o): Update dependencies.\n+\t(c-pch.o): Update dependencies.\n+\t(ggc-common.o): Update dependencies.\n+\t* stringpool.c: Include gt-stringpool.h.\n+\t(gt_pch_p_S): New.\n+\t(gt_pch_n_S): New.\n+\t(struct string_pool_data): New.\n+\t(spd): New.\n+\t(gt_pch_save_stringpool): New.\n+\t(gt_pch_restore_stringpool): New.\n+\t* tree.c (init_ttree): Make type_hash_table allocated using GC.\n+\t\n+\t2002-10-04  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gengtype.c (adjust_field_rtx_def): Don't pass size_t to printf.\n+\t(output_mangled_typename): Don't pass size_t to printf.\n+\n+\t* tree.h (union tree_type_symtab): Add tag to `address' field.\n+\t(union tree_decl_u2): Add tag to 'i' field.\n+\t* varasm.c (union rtx_const_un): Add tags to all fields.\n+\t* gengtype.c (struct walk_type_data): New.\n+\t(output_escaped_param): Take struct walk_type_data parameter.\n+\t(write_gc_structure_fields): Delete.\n+\t(walk_type): New.\n+\t(write_gc_marker_routine_for_structure): Delete.\n+\t(write_func_for_structure): New.\n+\t(gc_mark_process_field): New.\n+\t(gc_mark_func_name): New.\n+\t(gc_counter): Delete.\n+\t(write_gc_types): Use write_func_for_structure.\n+\t(write_gc_roots): Use walk_type.\n+\n+\t2002-10-02  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* ggc-common.c (ggc_mark_roots): Delete 'x'.\n+\t(ggc_splay_dont_free): Fix warning about unused 'x'.\n+\t(ggc_print_common_statistics): Remove warnings.\n+\n+\t2002-10-01  Mike Stump  <mrs@apple.com>\n+\n+        * ggc-common.c (ggc_splay_alloc): Actually return the allocated area.\n+        * gengtype.c (write_gc_structure_fields): Handle param[digit]_is.\n+\n+\t2002-09-01  Geoffrey Keating  <geoffk@redhat.com>\n+\t    Catherine Moore  <clm@redhat.com>\n+\n+\t* Makefile (c-pch.o): Update dependencies.\n+\t(LIBCPP_OBJS): Add cpppch.o.\n+\t(cpppch.o): New.\n+\t* c-common.c (c_common_init): Don't call pch_init here.\n+\t* c-common.h (c_common_read_pch): Update prototype.\n+\t* c-lex.c (c_common_parse_file): Call pch_init here.\n+\t* c-opts.c (COMMAND_LINE_OPTIONS): Add -Winvalid-pch, -fpch-deps.\n+\t(c_common_decode_option): Handle them.\n+\t* c-pch.c: Include c-pragma.h.\n+\t(save_asm_offset): Delete.\n+\t(pch_init): Move contents of save_asm_offset into here, call\n+\tcpp_save_state.\n+\t(c_common_write_pch): Call cpp_write_pch.\n+\t(c_common_valid_pch): Warn only when -Winvalid-pch.  Call\n+\tcpp_valid_state.\n+\t(c_common_read_pch): Add NAME parameter.  Call cpp_read_state.\n+\t* cppfiles.c (stack_include_file): Update for change to \n+\tparameters of cb.read_pch.\n+\t* cpphash.h (struct cpp_reader): Add `savedstate' field.\n+\t* cpplib.h (struct cpp_options): Add `warn_invalid_pch' and\n+\t`restore_pch_deps' fields.\n+\t(struct cpp_callbacks): Add NAME parameter to `read_pch'.\n+\t(cpp_save_state): Prototype.\n+\t(cpp_write_pch): Prototype.\n+\t(cpp_valid_state): Prototype.\n+\t(cpp_read_state): Prototype.\n+\t* cpppch.c: New file.\n+\t* flags.h (version_flag): Remove prototype.\n+\t* mkdeps.c (deps_save): New.\n+\t(deps_restore): New.\n+\t* mkdeps.h (deps_save): Prototype.\n+\t(deps_restore): Prototype.\n+\t* toplev.c (late_init_hook): Delete.\n+\t(version_flag): Make static again.\n+\t(compile_file): Don't call late_init_hook.\n+\t* toplev.h (late_init_hook): Delete.\n+\t* doc/cppopts.texi: Document -fpch-deps.\n+\t* doc/invoke.texi (Warning Options): Document -Winvalid-pch.\n+\n+\t2002-08-27  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* c-pch.c (c_common_write_pch): Rename from c_write_pch, change\n+\tcallers.\n+\t(c_common_valid_pch): Rename from c_valid_pch, change callers.\n+\t(c_common_read_pch): Rename from c_read_pch, change callers.\n+\n+\t* c-opts.c (COMMAND_LINE_OPTIONS): Allow -output-pch= to have\n+\ta space between it and its argument.\n+\n+\t2002-08-24  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* c-pch.c: New file.\n+\t* toplev.h (late_init_hook): Declare.\n+\t* toplev.c (late_init_hook): Define.\n+\t(version_flag): Make globally visible.\n+\t(compile_file): Call late_init_hook.\n+\t(init_asm_output): Make output file seekable.\n+\t* gcc.c (default_compilers): Update c-header rule.\n+\t* flags.h (version_flag): Declare.\n+\t* cpplib.h (struct cpp_callbacks): Add 'valid_pch' and 'read_pch'\n+\tfields.\n+\t* cppfiles.c (struct include_file): Add 'pch' field.\n+\t(INCLUDE_PCH_P): New.\n+\t(open_file_pch): New.\n+\t(stack_include_file): Handle PCH files specially.\n+\t(find_include_file): Call open_file_pch instead of open_file.\n+\t(_cpp_read_file): Explain why open_file is used instead of\n+\topen_file_pch.\n+\t* c-opts.c (c_common_decode_option): Correct OPT__output_pch case.\n+\t* c-objc-common.c (c_objc_common_finish_file): Call c_write_pch.\n+\t* c-lex.c (init_c_lex): Set valid_pch and read_pch fields\n+\tin cpplib callbacks.\n+\t* c-common.c (pch_file): Correct comment.\n+\t(allow_pch): Define.\n+\t(c_common_init): Call pch_init.\n+\t* c-common.h (allow_pch): Declare.\n+\t(pch_init): Declare.\n+\t(c_valid_pch): Declare.\n+\t(c_read_pch): Declare.\n+\t(c_write_pch): Declare.\n+\t* Makefile.in (c-pch.o): New.\n+\t(C_AND_OBJC_OBJS): Add c-pch.o.\n+\t* doc/invoke.texi (Precompiled Headers): Add index entries,\n+\tcomplete truncated paragraph.\n+\n+\t2002-08-17  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* c-common.c: (pch_file): Define.\n+\t* c-common.h (pch_file): Declare.\n+\t* c-opts.c (COMMAND_LINE_OPTIONS): Add --output-pch=.\n+\t(missing_arg): Require --output-pch= to have an argument.\n+\t(c_common_decode_option): Handle --output-pch=.\n+\t* gcc.c: Document new %V.\n+\t(default_compilers): Handle compiling C header files.\n+\t(do_spec_1): Implement %V.\n+\t(main): Handle \"gcc foo.h\" without trying to run linker.\n+\t* doc/invoke.texi (Invoking GCC): Add new menu item for PCH.\n+\t(Overall Options): Document what the driver does with header files,\n+\tdocument new -x option possibilities.\n+\t(Invoking G++): More documentation for PCH.\n+\t(Precompiled Headers): New.\n+\n+\t2002-08-09  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* ggc.h: Don't include varray.h.  Rearrange functions to be more\n+\torganized.\n+\t(ggc_add_root): Delete.\n+\t(ggc_mark_rtx): Delete.\n+\t(ggc_mark_tree): Delete.\n+\t(struct ggc_statistics): Remove contents.\n+\t* ggc-common.c: Remove unneeded includes.\n+\t(struct ggc_root): Delete.\n+\t(roots): Delete.\n+\t(ggc_add_root): Delete.\n+\t(ggc_mark_roots): Don't mark `roots'.  Call ggc_mark_stringpool.\n+\t(ggc_print_common_statistics): Remove most of the contents.\n+\t* Makefile.in (GGC_H): No longer uses varray.h.\n+\t(ggc-common.o): Update dependencies.\n+\t(c-parse.o): Add varray.h to dependencies.\n+\t(c-common.o): Add varray.h.\n+\t* stringpool.c (mark_ident): Use mangled name for tree marker routine.\n+\t(mark_ident_hash): Rename to ggc_mark_stringpool.\n+\t(init_stringpool): Don't use ggc_add_root.\n+\t* c-parse.in: Include varray.h.\n+\t* c-common.c: Include varray.h.\n+\t* objc/Make-lang.in (objc-act.o): Add varray.h.\n+\t* objc/objc-act.c: Include varray.h.\n+\n+\t2002-07-25  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* dwarf2out.c (dw_cfi_oprnd2_desc): Fix ISO-only function definition.\n+\t(dw_cfi_oprnd1_desc): Likewise.\n+\n+\t2002-07-17  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* config/alpha/alpha.c (struct alpha_links): Use gengtype to mark;\n+\tmove out of ifdef.\n+\t(alpha_links): Use gengtype to mark; move out of ifdef.\n+\t(mark_alpha_links_node): Delete.\n+\t(mark_alpha_links): Delete.\n+\t(alpha_need_linkage): Use GGC to allocate splay tree, struct\n+\talpha_links, strings.  Don't use ggc_add_root.\n+\t* ggc-common.c (ggc_splay_alloc): New.\n+\t(ggc_splay_dont_free): New.\n+\t* ggc.h (ggc_mark_rtx): Update for changed name mangling.\n+\t(ggc_mark_tree): Likewise.\n+\t(splay_tree_new_ggc): New.\n+\t(ggc_splay_alloc): Declare.\n+\t(ggc_splay_dont_free): Declare.\n+\t* dwarf2asm.c: Include gt-dwarf2asm.h.\n+\t(mark_indirect_pool_entry): Delete.\n+\t(mark_indirect_pool): Delete.\n+\t(indirect_pool): Use gengtype to mark.\n+\t(dw2_force_const_mem): Don't use ggc_add_root.\n+\t* Makefile.in (dwarf2asm.o): Depend on gt-dwarf2asm.h.\n+\t(GTFILES): Add SPLAY_TREE_H, dwarf2asm.c.\n+\t(gt-dwarf2asm.h): Depend on s-gtype.\n+\n+\t2002-07-08  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* tree.h (union tree_type_symtab): Mark `die' field.\n+\t* Makefile.in (dwarf2out.o): Update dependencies.\n+\t* dwarf2out.c: Use GGC to allocate all structures.  Convert to htab_t\n+\thash tables.\n+\t(dw_cfi_oprnd1_desc): New function.\n+\t(dw_cfi_oprnd2_desc): New function.\n+\t(indirect_string_alloc): Delete.\n+\t(debug_str_do_hash): New function.\n+\t(debug_str_eq): New function.\n+\t(mark_limbo_die_list): Delete.\n+\t(dwarf2out_init): Don't call ggc_add_root.\n+\n 2003-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tThe following changes are merged from itanium-sched-branch:\n@@ -438,10 +954,10 @@\n \tthe generated code.\n \t(write_automata): Call the new function.\n \t\n-\n Thu Jan  9 22:47:38 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n-\t* i386.md (unit, prefix_0f, memory attributes): Hanlde sseicvt correctly.\n+\t* i386.md (unit, prefix_0f, memory attributes): Hanlde sseicvt\n+\tcorrectly.\n \n 2003-01-09  Paolo Carlini  <pcarlini@unitus.it>\n "}, {"sha": "c48d41cc3a2d43818f729dd062006cf557306f12", "filename": "gcc/Makefile.in", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -587,7 +587,7 @@ REGS_H = regs.h varray.h $(MACHMODE_H)\n INTEGRATE_H = integrate.h varray.h\n LOOP_H = loop.h varray.h bitmap.h\n GCC_H = gcc.h version.h\n-GGC_H = ggc.h varray.h gtype-desc.h\n+GGC_H = ggc.h gtype-desc.h\n TIMEVAR_H = timevar.h timevar.def\n INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h\n C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H)\n@@ -739,7 +739,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n-  c-objc-common.o c-dump.o libcpp.a $(C_TARGET_OBJS)\n+  c-objc-common.o c-dump.o c-pch.o libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n@@ -1175,7 +1175,7 @@ c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) flags.h diagnostic.h $(TM_P_H)\n c-parse.o : $(srcdir)/c-parse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(GGC_H) intl.h $(C_TREE_H) input.h flags.h toplev.h output.h $(CPPLIB_H) \\\n-    gt-c-parse.h\n+    varray.h gt-c-parse.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t       -c $(srcdir)/c-parse.c $(OUTPUT_OPTION)\n \n@@ -1246,7 +1246,7 @@ tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h\n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) \\\n \t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \\\n-\tdiagnostic.h except.h gt-c-common.h real.h langhooks.h\n+\tdiagnostic.h except.h gt-c-common.h real.h langhooks.h varray.h\n c-pretty-print.o : c-pretty-print.c c-pretty-print.h pretty-print.h \\\n \t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h\n \n@@ -1270,6 +1270,9 @@ c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE\n c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(C_TREE_H) tree-dump.h\n \n+c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \\\n+\tc-common.h output.h toplev.h c-pragma.h $(GGC_H) debug.h\n+\n # Language-independent files.\n \n DRIVER_DEFINES = \\\n@@ -1349,18 +1352,17 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h\n \tlibfuncs.h debug.h $(GGC_H) bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n \tssa.h cselib.h insn-addr.h\n \n-ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-\tflags.h $(GGC_H) varray.h $(HASHTAB_H) $(TM_P_H) langhooks.h \\\n-\t$(PARAMS_H)\n+ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n+\t$(HASHTAB_H) toplev.h\n \n ggc-simple.o: ggc-simple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n \tflags.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)\n \n ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-\tflags.h toplev.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H)\n+\tflags.h toplev.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)\n \n-stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-\t$(OBSTACK_H) flags.h toplev.h $(GGC_H)\n+stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+\t$(TREE_H) $(GGC_H) gt-stringpool.h\n \n hashtable.o: hashtable.c hashtable.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H)\n \n@@ -1466,11 +1468,12 @@ optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n    toplev.h $(GGC_H) real.h $(TM_P_H) except.h gt-optabs.h $(BASIC_BLOCK_H)\n dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n    flags.h $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) function.h langhooks.h \\\n-   insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h toplev.h\n+   insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h toplev.h \\\n+   $(GGC_H) gt-dbxout.h\n debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n    flags.h function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) real.h \\\n-   insn-config.h xcoffout.h c-pragma.h ggc.h $(TARGET_H) \\\n+   insn-config.h xcoffout.h c-pragma.h $(GGC_H) $(TARGET_H) \\\n    sdbout.h toplev.h $(TM_P_H) except.h debug.h langhooks.h gt-sdbout.h\n dwarfout.o : dwarfout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) dwarf.h flags.h insn-config.h reload.h output.h toplev.h $(TM_P_H) \\\n@@ -1480,7 +1483,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n    hard-reg-set.h $(REGS_H) $(EXPR_H) libfuncs.h toplev.h dwarf2out.h varray.h \\\n    $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) flags.h $(RTL_H) \\\n-   $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H)\n+   $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) gt-dwarf2asm.h\n vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) flags.h output.h vmsdbg.h debug.h langhooks.h function.h $(TARGET_H)\n xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n@@ -1862,22 +1865,22 @@ s-preds: genpreds$(build_exeext) $(srcdir)/move-if-change\n \t$(SHELL) $(srcdir)/move-if-change tmp-preds.h tm-preds.h\n \t$(STAMP) s-preds\n \n-GTFILES = $(srcdir)/location.h $(srcdir)/coretypes.h \\\n-  $(host_xm_file_list) $(tm_file_list) $(HASHTAB_H) \\\n+GTFILES = $(srcdir)/location.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n+  $(host_xm_file_list) $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) \\\n   $(srcdir)/bitmap.h $(srcdir)/function.h  $(srcdir)/rtl.h $(srcdir)/optabs.h \\\n   $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h $(srcdir)/real.h \\\n   $(srcdir)/varray.h $(srcdir)/ssa.h $(srcdir)/insn-addr.h $(srcdir)/cselib.h \\\n+  $(srcdir)/basic-block.h $(srcdir)/location.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n-  $(srcdir)/basic-block.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c \\\n-  $(srcdir)/dwarf2out.c $(srcdir)/emit-rtl.c \\\n-  $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n+  $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n+  $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/fold-const.c $(srcdir)/function.c \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n   $(srcdir)/profile.c $(srcdir)/ra-build.c $(srcdir)/regclass.c \\\n   $(srcdir)/reg-stack.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \\\n-  $(srcdir)/tree.c $(srcdir)/varasm.c \\\n+  $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(out_file) \\\n   @all_gtfiles@\n \n@@ -1891,9 +1894,9 @@ gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h gt-emit-rtl.h : s-gtype; @true\n gt-explow.h gt-stor-layout.h gt-regclass.h gt-lists.h : s-gtype; @true\n gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h gt-profile.h : s-gtype; @true\n gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dwarf2out.h : s-gtype ; @true\n-gt-ra-build.h gt-reg-stack.h : s-gtype ; @true\n+gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h gt-dbxout.h : s-gtype ; @true\n gt-c-common.h gt-c-decl.h gt-c-parse.h gt-c-pragma.h : s-gtype; @true\n-gt-c-objc-common.h gtype-c.h gt-location.h : s-gtype ; @true\n+gt-c-objc-common.h gtype-c.h gt-location.h gt-stringpool.h : s-gtype ; @true\n \n gtyp-gen.h: Makefile\n \techo \"/* This file is machine generated.  Do not edit.  */\" > tmp-gtyp.h\n@@ -2215,7 +2218,7 @@ PREPROCESSOR_DEFINES = \\\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n \t\tcpphash.o cpperror.o cppinit.o cppdefault.o cppmain.o \\\n-\t\thashtable.o line-map.o mkdeps.o prefix.o mbchar.o\n+\t\thashtable.o line-map.o mkdeps.o prefix.o mbchar.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n \t\t$(OBSTACK_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n@@ -2238,6 +2241,7 @@ cpphash.o:  cpphash.c  $(LIBCPP_DEPS)\n cpptrad.o:  cpptrad.c  $(LIBCPP_DEPS)\n cppfiles.o: cppfiles.c $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n cppinit.o:  cppinit.c  $(LIBCPP_DEPS) cppdefault.h mkdeps.h prefix.h\n+cpppch.o:   cpppch.c   $(LIBCPP_DEPS) mkdeps.h\n \n cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) cppdefault.h \\\n \tMakefile"}, {"sha": "0d06e9c725ae5027e17b110145f6e6a087d37891", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,3 +1,9 @@\n+2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gnat_rm.texi: Remove RCS version number.\n+\n+\t* ada-tree.h (union lang_tree_node): Add chain_next option.\n+\n 2003-01-09  Christian Cornelssen  <ccorn@cs.tu-berlin.de>\n \n \t* Make-lang.in (ada.install-info, ada.install-common,"}, {"sha": "b1904a4284d4db519e167a01b32d9ae33f0b0fd5", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -43,7 +43,8 @@ struct tree_loop_id GTY(())\n \n /* The language-specific tree.  */\n union lang_tree_node \n-  GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\")))\n+  GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\"),\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n {\n   union tree_node GTY ((tag (\"0\"), \n \t\t\tdesc (\"tree_node_structure (&%h)\"))) "}, {"sha": "f9c78ce515e0197114747045a0ef2d5bf537c1c2", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -8,8 +8,6 @@\n @c                                                                            o\n @c                              G N A T _ RM                                  o\n @c                                                                            o\n-@c                            $Revision: 1.9 $\n-@c                                                                            o\n @c              Copyright (C) 1995-2002 Free Software Foundation              o\n @c                                                                            o\n @c                                                                            o"}, {"sha": "84166c98da3e002e6a4eb26da0ac489e73bf6eee", "filename": "gcc/c-common.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-pragma.h\"\n #include \"rtl.h\"\n #include \"ggc.h\"\n+#include \"varray.h\"\n #include \"expr.h\"\n #include \"c-common.h\"\n #include \"diagnostic.h\"\n@@ -190,11 +191,20 @@ enum c_language_kind c_language;\n \n tree c_global_trees[CTI_MAX];\n \n+/* Nonzero if we can read a PCH file now.  */\n+\n+int allow_pch = 1;\n+\f\n /* Switches common to the C front ends.  */\n \n /* Nonzero if prepreprocessing only.  */\n int flag_preprocess_only;\n \n+/* The file name to which we should write a precompiled header, or\n+   NULL if no header will be written in this compile.  */\n+\n+const char *pch_file;\n+\n /* Nonzero if an ISO standard was selected.  It rejects macros in the\n    user's namespace.  */\n int flag_iso;"}, {"sha": "3e976621711c49821860c24ac47502732c3e0b6d", "filename": "gcc/c-common.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -121,7 +121,7 @@ enum rid\n \n /* The elements of `ridpointers' are identifier nodes for the reserved\n    type names and storage classes.  It is indexed by a RID_... value.  */\n-extern tree *ridpointers;\n+extern GTY ((length (\"(int)RID_MAX\"))) tree *ridpointers;\n \n /* Standard named or nameless data types of the C compiler.  */\n \n@@ -177,7 +177,7 @@ enum c_tree_index\n struct c_common_identifier GTY(())\n {\n   struct tree_common common;\n-  struct cpp_hashnode GTY ((skip (\"\"))) node;\n+  struct cpp_hashnode node;\n };\n \n #define wchar_type_node\t\t\tc_global_trees[CTI_WCHAR_TYPE]\n@@ -360,20 +360,32 @@ struct c_lang_decl GTY(()) {\n \n extern c_language_kind c_language;\n \n+/* Nonzero if we can read a PCH file now.  */\n+\n+extern int allow_pch;\n+\f\n /* Switches common to the C front ends.  */\n \n /* Nonzero if prepreprocessing only.  */\n+\n extern int flag_preprocess_only;\n \n+/* The file name to which we should write a precompiled header, or\n+   NULL if no header will be written in this compile.  */\n+\n+extern const char *pch_file;\n+\n /* Nonzero if an ISO standard was selected.  It rejects macros in the\n    user's namespace.  */\n+\n extern int flag_iso;\n \n /* Nonzero whenever Objective-C functionality is being used.  */\n extern int flag_objc;\n \n /* Nonzero if -undef was given.  It suppresses target built-in macros\n    and assertions.  */\n+\n extern int flag_undef;\n \n /* Nonzero means don't recognize the non-ANSI builtin functions.  */\n@@ -1253,4 +1265,14 @@ extern void dump_time_statistics\t\tPARAMS ((void));\n \n extern int c_dump_tree\t\t\t\tPARAMS ((void *, tree));\n \n+extern void pch_init\t\t\t\tPARAMS ((void));\n+extern int c_common_valid_pch\t\t\tPARAMS ((cpp_reader *pfile,\n+\t\t\t\t\t\t\t const char *name,\n+\t\t\t\t\t\t\t int fd));\n+extern void c_common_read_pch\t\t\tPARAMS ((cpp_reader *pfile,\n+\t\t\t\t\t\t\t const char *name,\n+\t\t\t\t\t\t\t int fd,\n+\t\t\t\t\t\t\t const char *orig));\n+extern void c_common_write_pch\t\t\tPARAMS ((void));\n+\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "e3d07aab96daee75d781e175d4c0240ab0c27bb0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -3226,6 +3226,8 @@ clear_parm_order ()\n   current_binding_level->parm_order = NULL_TREE;\n }\n \f\n+static GTY(()) int compound_literal_number;\n+\n /* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound\n    literal, which may be an incomplete array type completed by the\n    initializer; INIT is a CONSTRUCTOR that initializes the compound\n@@ -3273,10 +3275,10 @@ build_compound_literal (type, init)\n       /* This decl needs a name for the assembler output.  We also need\n \t a unique suffix to be added to the name.  */\n       char *name;\n-      extern int var_labelno;\n \n-      ASM_FORMAT_PRIVATE_NAME (name, \"__compound_literal\", var_labelno);\n-      var_labelno++;\n+      ASM_FORMAT_PRIVATE_NAME (name, \"__compound_literal\", \n+\t\t\t       compound_literal_number);\n+      compound_literal_number++;\n       DECL_NAME (decl) = get_identifier (name);\n       DECL_DEFER_OUTPUT (decl) = 1;\n       DECL_COMDAT (decl) = 1;"}, {"sha": "a689ccab004ee3e1bd903b60be61ff8fc9e6c605", "filename": "gcc/c-lex.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -124,6 +124,8 @@ init_c_lex (filename)\n   cb->ident = cb_ident;\n   cb->file_change = cb_file_change;\n   cb->def_pragma = cb_def_pragma;\n+  cb->valid_pch = c_common_valid_pch;\n+  cb->read_pch = c_common_read_pch;\n \n   /* Set the debug callbacks if we can use them.  */\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n@@ -158,6 +160,8 @@ c_common_parse_file (set_yydebug)\n   (*debug_hooks->start_source_file) (lineno, input_filename);\n   cpp_finish_options (parse_in);\n \n+  pch_init();\n+  \n   yyparse ();\n   free_parser_stacks ();\n }"}, {"sha": "c91e635b4102d1f37361874bccdd438d93909e1f", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n /* Some code common to C and ObjC front ends.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -358,6 +358,9 @@ finish_cdtor (body)\n void\n c_objc_common_finish_file ()\n {\n+  if (pch_file)\n+    c_common_write_pch ();\n+\n   expand_deferred_fns ();\n \n   if (static_ctors)"}, {"sha": "5270d625a20654fad4588798cecbba7cd44da446", "filename": "gcc/c-opts.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -112,6 +112,7 @@ static void sanitize_cpp_opts PARAMS ((void));\n \n #define COMMAND_LINE_OPTIONS\t\t\t\t\t\t     \\\n   OPT(\"-help\",                  CL_ALL,   OPT__help)\t\t\t     \\\n+  OPT(\"-output-pch=\",\t\tCL_ALL | CL_ARG, OPT__output_pch)\t     \\\n   OPT(\"C\",                      CL_ALL,   OPT_C)\t\t\t     \\\n   OPT(\"CC\",                     CL_ALL,   OPT_CC)\t\t\t     \\\n   OPT(\"E\",\t\t\tCL_ALL,   OPT_E)\t\t\t     \\\n@@ -154,6 +155,7 @@ static void sanitize_cpp_opts PARAMS ((void));\n   OPT(\"Wimplicit-function-declaration\",\tCL_C, OPT_Wimplicit_function_decl)   \\\n   OPT(\"Wimplicit-int\",\t\tCL_C,\t  OPT_Wimplicit_int)\t\t     \\\n   OPT(\"Wimport\",                CL_ALL,   OPT_Wimport)\t\t\t     \\\n+  OPT(\"Winvalid-pch\",           CL_ALL,   OPT_Winvalid_pch)\t\t     \\\n   OPT(\"Wlong-long\",\t\tCL_ALL,   OPT_Wlong_long)\t\t     \\\n   OPT(\"Wmain\",\t\t\tCL_C,     OPT_Wmain)\t\t\t     \\\n   OPT(\"Wmissing-braces\",\tCL_ALL,   OPT_Wmissing_braces)\t\t     \\\n@@ -231,6 +233,7 @@ static void sanitize_cpp_opts PARAMS ((void));\n   OPT(\"fnonnull-objects\",\tCL_CXX,   OPT_fnonnull_objects)\t\t     \\\n   OPT(\"foperator-names\",\tCL_CXX,   OPT_foperator_names)\t\t     \\\n   OPT(\"foptional-diags\",\tCL_CXX,   OPT_foptional_diags)\t\t     \\\n+  OPT(\"fpch-deps\",\t\tCL_ALL,\t  OPT_fpch_deps)\t\t     \\\n   OPT(\"fpermissive\",\t\tCL_CXX,   OPT_fpermissive)\t\t     \\\n   OPT(\"fpreprocessed\",\t\tCL_ALL,   OPT_fpreprocessed)\t\t     \\\n   OPT(\"frepo\",\t\t\tCL_CXX,   OPT_frepo)\t\t\t     \\\n@@ -343,6 +346,7 @@ missing_arg (opt_index)\n \n   switch (cl_options[opt_index].opt_code)\n     {\n+    case OPT__output_pch:\n     case OPT_Wformat_eq:\n     case OPT_d:\n     case OPT_fabi_version:\n@@ -627,6 +631,10 @@ c_common_decode_option (argc, argv)\n       print_help ();\n       break;\n \n+    case OPT__output_pch:\n+      pch_file = arg;\n+      break;\n+\n     case OPT_C:\n       cpp_opts->discard_comments = 0;\n       break;\n@@ -832,6 +840,10 @@ c_common_decode_option (argc, argv)\n       cpp_opts->warn_import = on;\n       break;\n \n+    case OPT_Winvalid_pch:\n+      cpp_opts->warn_invalid_pch = on;\n+      break;\n+\n     case OPT_Wlong_long:\n       warn_long_long = on;\n       break;\n@@ -1178,6 +1190,10 @@ c_common_decode_option (argc, argv)\n       flag_optional_diags = on;\n       break;\n \n+    case OPT_fpch_deps:\n+      cpp_opts->restore_pch_deps = on;\n+      break;\n+\n     case OPT_fpermissive:\n       flag_permissive = on;\n       break;"}, {"sha": "72ca4fe287bc2fd156a53b5056af3a0443591859", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -48,6 +48,7 @@ end ifc\n #include \"c-pragma.h\"\t\t/* For YYDEBUG definition, and parse_in.  */\n #include \"c-tree.h\"\n #include \"flags.h\"\n+#include \"varray.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n@@ -3555,10 +3556,7 @@ init_reswords ()\n   if (!flag_objc)\n      mask |= D_OBJC;\n \n-  /* It is not necessary to register ridpointers as a GC root, because\n-     all the trees it points to are permanently interned in the\n-     get_identifier hash anyway.  */\n-  ridpointers = (tree *) xcalloc ((int) RID_MAX, sizeof (tree));\n+  ridpointers = (tree *) ggc_calloc ((int) RID_MAX, sizeof (tree));\n   for (i = 0; i < N_reswords; i++)\n     {\n       /* If a keyword is disabled, do not enter it into the table"}, {"sha": "616e002a8284cbeb9d4a35f1255f8c6255ddc095", "filename": "gcc/c-pch.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,226 @@\n+/* Precompiled header implementation for the C languages.\n+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+#include \"output.h\"\n+#include \"toplev.h\"\n+#include \"debug.h\"\n+#include \"c-pragma.h\"\n+#include \"ggc.h\"\n+\n+struct c_pch_header \n+{\n+  unsigned long asm_size;\n+};\n+\n+static const char pch_ident[8] = \"gpchC010\";\n+\n+static FILE *pch_outfile;\n+\n+extern char *asm_file_name;\n+static off_t asm_file_startpos;\n+\n+void\n+pch_init ()\n+{\n+  FILE *f;\n+  \n+  if (pch_file)\n+    {\n+      /* We're precompiling a header file, so when it's actually used,\n+\t it'll be at least one level deep.  */\n+      (*debug_hooks->start_source_file) (lineno, input_filename);\n+\n+      f = fopen (pch_file, \"w+b\");\n+      if (f == NULL)\n+\tfatal_io_error (\"can't open %s\", pch_file);\n+      pch_outfile = f;\n+      \n+      if (fwrite (pch_ident, sizeof (pch_ident), 1, f) != 1)\n+\tfatal_io_error (\"can't write to %s\", pch_file);\n+\n+      /* We need to be able to re-read the output.  */\n+      /* The driver always provides a valid -o option.  */\n+      if (asm_file_name == NULL\n+\t  || strcmp (asm_file_name, \"-\") == 0)\n+\tfatal_error (\"`%s' is not a valid output file\", asm_file_name);\n+\n+      asm_file_startpos = ftello (asm_out_file);\n+      \n+      cpp_save_state (parse_in, f);\n+    }\n+}\n+\n+void\n+c_common_write_pch ()\n+{\n+  char *buf;\n+  off_t asm_file_end;\n+  off_t written;\n+  struct c_pch_header h;\n+\n+  cpp_write_pch_deps (parse_in, pch_outfile);\n+\n+  asm_file_end = ftello (asm_out_file);\n+  h.asm_size = asm_file_end - asm_file_startpos;\n+  \n+  if (fwrite (&h, sizeof (h), 1, pch_outfile) != 1)\n+    fatal_io_error (\"can't write %s\", pch_file);\n+  \n+  buf = xmalloc (16384);\n+  fflush (asm_out_file);\n+\n+  if (fseeko (asm_out_file, asm_file_startpos, SEEK_SET) != 0)\n+    fatal_io_error (\"can't seek in %s\", asm_file_name);\n+\n+  for (written = asm_file_startpos; written < asm_file_end; )\n+    {\n+      off_t size = asm_file_end - written;\n+      if (size > 16384)\n+\tsize = 16384;\n+      if (fread (buf, size, 1, asm_out_file) != 1)\n+\tfatal_io_error (\"can't read %s\", asm_file_name);\n+      if (fwrite (buf, size, 1, pch_outfile) != 1)\n+\tfatal_io_error (\"can't write %s\", pch_file);\n+      written += size;\n+    }\n+  free (buf);\n+\n+  gt_pch_save (pch_outfile);\n+  cpp_write_pch_state (parse_in, pch_outfile);\n+\n+  fclose (pch_outfile);\n+}\n+\n+int\n+c_common_valid_pch (pfile, name, fd)\n+     cpp_reader *pfile;\n+     const char *name;\n+     int fd;\n+{\n+  int sizeread;\n+  int result;\n+  char ident[sizeof (pch_ident)];\n+\n+  if (! allow_pch)\n+    return 2;\n+\n+  /* Perform a quick test of whether this is a valid\n+     precompiled header for C.  */\n+\n+  sizeread = read (fd, ident, sizeof (pch_ident));\n+  if (sizeread == -1)\n+    {\n+      fatal_io_error (\"can't read %s\", name);\n+      return 2;\n+    }\n+  else if (sizeread != sizeof (pch_ident))\n+    return 2;\n+  \n+  if (memcmp (ident, pch_ident, sizeof (pch_ident)) != 0)\n+    {\n+      if (cpp_get_options (pfile)->warn_invalid_pch)\n+\t{\n+\t  if (memcmp (ident, pch_ident, 5) == 0)\n+\t    /* It's a PCH, for the right language, but has the wrong version.\n+\t     */\n+\t    cpp_error (pfile, DL_WARNING, \n+\t\t       \"%s: not compatible with this GCC version\", name);\n+\t  else if (memcmp (ident, pch_ident, 4) == 0)\n+\t    /* It's a PCH for the wrong language.  */\n+\t    cpp_error (pfile, DL_WARNING, \"%s: not for C language\", name);\n+\t  else \n+\t    /* Not any kind of PCH.  */\n+\t    cpp_error (pfile, DL_WARNING, \"%s: not a PCH file\", name);\n+\t}\n+      return 2;\n+    }\n+\n+  /* Check the preprocessor macros are the same as when the PCH was\n+     generated.  */\n+  \n+  result = cpp_valid_state (pfile, name, fd);\n+  if (result == -1)\n+    return 2;\n+  else\n+    return result == 0;\n+}\n+\n+void\n+c_common_read_pch (pfile, name, fd, orig_name)\n+     cpp_reader *pfile;\n+     const char *name;\n+     int fd;\n+     const char *orig_name;\n+{\n+  FILE *f;\n+  struct c_pch_header h;\n+  char *buf;\n+  unsigned long written;\n+  struct save_macro_data *smd;\n+  \n+  /* Before we wrote the file, we started a source file, so we have to start\n+     one here to match.  */\n+  (*debug_hooks->start_source_file) (lineno, orig_name);\n+  \n+  f = fdopen (fd, \"rb\");\n+  if (f == NULL)\n+    {\n+      cpp_errno (pfile, DL_ERROR, \"calling fdopen\");\n+      return;\n+    }\n+\n+  allow_pch = 0;\n+\n+  if (fread (&h, sizeof (h), 1, f) != 1)\n+    {\n+      cpp_errno (pfile, DL_ERROR, \"reading\");\n+      return;\n+    }\n+\n+  buf = xmalloc (16384);\n+  for (written = 0; written < h.asm_size; )\n+    {\n+      off_t size = h.asm_size - written;\n+      if (size > 16384)\n+\tsize = 16384;\n+      if (fread (buf, size, 1, f) != 1\n+\t  || fwrite (buf, size, 1, asm_out_file) != 1)\n+\tcpp_errno (pfile, DL_ERROR, \"reading\");\n+      written += size;\n+    }\n+  free (buf);\n+\n+  cpp_prepare_state (pfile, &smd);\n+\n+  gt_pch_restore (f);\n+\n+  if (cpp_read_state (pfile, name, f, smd) != 0)\n+    return;\n+\n+  fclose (f);\n+\n+  (*debug_hooks->end_source_file) (lineno);\n+}"}, {"sha": "dbbf1103deadcbd44e4c86cd7dbdf3592d40f963", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -50,6 +50,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"debug.h\"\n #include \"langhooks.h\"\n+#include <splay-tree.h>\n \n /* Specify which cpu to schedule for.  */\n \n@@ -9023,6 +9024,20 @@ alpha_elf_select_rtx_section (mode, x, align)\n \n #endif /* OBJECT_FORMAT_ELF */\n \f\n+/* Structure to collect function names for final output\n+   in link section.  */\n+\n+enum links_kind {KIND_UNUSED, KIND_LOCAL, KIND_EXTERN};\n+\n+struct alpha_links GTY(())\n+{\n+  rtx linkage;\n+  enum links_kind kind;\n+};\n+\n+static GTY ((param1_is (char *), param2_is (struct alpha_links *)))\n+  splay_tree alpha_links;\n+\n #if TARGET_ABI_OPEN_VMS\n \n /* Return the VMS argument type corresponding to MODE.  */\n@@ -9058,26 +9073,6 @@ alpha_arg_info_reg_val (cum)\n   return GEN_INT (regval);\n }\n \f\n-/* Protect alpha_links from garbage collection.  */\n-\n-static int\n-mark_alpha_links_node (node, data)\n-     splay_tree_node node;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  struct alpha_links *links = (struct alpha_links *) node->value;\n-  ggc_mark_rtx (links->linkage);\n-  return 0;\n-}\n-\n-static void\n-mark_alpha_links (ptr)\n-     void *ptr;\n-{\n-  splay_tree tree = *(splay_tree *) ptr;\n-  splay_tree_foreach (tree, mark_alpha_links_node, NULL);\n-}\n-\n /* Make (or fake) .linkage entry for function call.\n \n    IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.\n@@ -9139,16 +9134,11 @@ alpha_need_linkage (name, is_local)\n     }\n   else\n     {\n-      alpha_links_tree = splay_tree_new\n-\t((splay_tree_compare_fn) strcmp, \n-\t (splay_tree_delete_key_fn) free,\n-\t (splay_tree_delete_key_fn) free);\n-\n-      ggc_add_root (&alpha_links_tree, 1, 1, mark_alpha_links);\n+      alpha_links = splay_tree_new_ggc ((splay_tree_compare_fn) strcmp);\n     }\n \n-  al = (struct alpha_links *) xmalloc (sizeof (struct alpha_links));\n-  name = xstrdup (name);\n+  al = (struct alpha_links *) ggc_alloc (sizeof (struct alpha_links));\n+  name = ggc_strdup (name);\n \n   /* Assume external if no definition.  */\n   al->lkind = (is_local ? KIND_UNUSED : KIND_EXTERN);"}, {"sha": "bce6d11e132c87b6e686d262cefbe512b6d8677e", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -223,7 +223,7 @@ machopic_define_name (name)\n \n static char function_base[32];\n \n-static int current_pic_label_num;\n+static GTY(()) int current_pic_label_num;\n \n const char *\n machopic_function_base_name ()"}, {"sha": "7880cd5c9f887ecab6b6efd7413842eb020cb056", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 23, "deletions": 65, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -168,7 +168,6 @@ struct builtin_description\n };\n \n static bool rs6000_function_ok_for_sibcall PARAMS ((tree, tree));\n-static void rs6000_add_gc_roots PARAMS ((void));\n static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n static void validate_condition_mode \n   PARAMS ((enum rtx_code, enum machine_mode));\n@@ -183,8 +182,6 @@ static void rs6000_emit_allocate_stack PARAMS ((HOST_WIDE_INT, int));\n static unsigned rs6000_hash_constant PARAMS ((rtx));\n static unsigned toc_hash_function PARAMS ((const void *));\n static int toc_hash_eq PARAMS ((const void *, const void *));\n-static int toc_hash_mark_entry PARAMS ((void **, void *));\n-static void toc_hash_mark_table PARAMS ((void *));\n static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n static struct machine_function * rs6000_init_machine_status PARAMS ((void));\n static bool rs6000_assemble_integer PARAMS ((rtx, unsigned int, int));\n@@ -267,6 +264,19 @@ static void is_altivec_return_reg PARAMS ((rtx, void *));\n static rtx generate_set_vrsave PARAMS ((rtx, rs6000_stack_t *, int));\n static void altivec_frame_fixup PARAMS ((rtx, rtx, HOST_WIDE_INT));\n static int easy_vector_constant PARAMS ((rtx));\n+\n+/* Hash table stuff for keeping track of TOC entries.  */\n+\n+struct toc_hash_struct GTY(())\n+{\n+  /* `key' will satisfy CONSTANT_P; in fact, it will satisfy\n+     ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */\n+  rtx key;\n+  enum machine_mode key_mode;\n+  int labelno;\n+};\n+\n+static GTY ((param_is (struct toc_hash_struct))) htab_t toc_hash_table;\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -708,9 +718,6 @@ rs6000_override_options (default_cpu)\n       && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN))\n     real_format_for_mode[TFmode - QFmode] = &ibm_extended_format;\n \n-  /* Register global variables with the garbage collector.  */\n-  rs6000_add_gc_roots ();\n-\n   /* Allocate an alias set for register saves & restores from stack.  */\n   rs6000_sr_alias_set = new_alias_set ();\n \n@@ -11457,19 +11464,6 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n \n */\n \n-/* Hash table stuff for keeping track of TOC entries.  */\n-\n-struct toc_hash_struct \n-{\n-  /* `key' will satisfy CONSTANT_P; in fact, it will satisfy\n-     ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */\n-  rtx key;\n-  enum machine_mode key_mode;\n-  int labelno;\n-};\n-\n-static htab_t toc_hash_table;\n-\n /* Hash functions for the hash table.  */\n \n static unsigned\n@@ -11570,39 +11564,6 @@ toc_hash_eq (h1, h2)\n   return rtx_equal_p (r1, r2);\n }\n \n-/* Mark the hash table-entry HASH_ENTRY.  */\n-\n-static int\n-toc_hash_mark_entry (hash_slot, unused)\n-     void ** hash_slot;\n-     void * unused ATTRIBUTE_UNUSED;\n-{\n-  const struct toc_hash_struct * hash_entry = \n-    *(const struct toc_hash_struct **) hash_slot;\n-  rtx r = hash_entry->key;\n-  ggc_set_mark (hash_entry);\n-  /* For CODE_LABELS, we don't want to drag in the whole insn chain...  */\n-  if (GET_CODE (r) == LABEL_REF)\n-    {\n-      ggc_set_mark (r);\n-      ggc_set_mark (XEXP (r, 0));\n-    }\n-  else\n-    ggc_mark_rtx (r);\n-  return 1;\n-}\n-\n-/* Mark all the elements of the TOC hash-table *HT.  */\n-\n-static void\n-toc_hash_mark_table (vht)\n-     void *vht;\n-{\n-  htab_t *ht = vht;\n-  \n-  htab_traverse (*ht, toc_hash_mark_entry, (void *)0);\n-}\n-\n /* These are the names given by the C++ front-end to vtables, and\n    vtable-like objects.  Ideally, this logic should not be here;\n    instead, there should be some programmatic way of inquiring as\n@@ -11656,12 +11617,19 @@ output_toc (file, x, labelno, mode)\n \n   /* When the linker won't eliminate them, don't output duplicate\n      TOC entries (this happens on AIX if there is any kind of TOC,\n-     and on SVR4 under -fPIC or -mrelocatable).  */\n-  if (TARGET_TOC)\n+     and on SVR4 under -fPIC or -mrelocatable).  Don't do this for\n+     CODE_LABELs.  */\n+  if (TARGET_TOC && GET_CODE (x) != LABEL_REF)\n     {\n       struct toc_hash_struct *h;\n       void * * found;\n       \n+      /* Create toc_hash_table.  This can't be done at OVERRIDE_OPTIONS\n+         time because GGC is not initialised at that point.  */\n+      if (toc_hash_table == NULL)\n+\ttoc_hash_table = htab_create_ggc (1021, toc_hash_function, \n+\t\t\t\t\t  toc_hash_eq, NULL);\n+\n       h = ggc_alloc (sizeof (*h));\n       h->key = x;\n       h->key_mode = mode;\n@@ -12685,17 +12653,6 @@ rs6000_fatal_bad_address (op)\n   fatal_insn (\"bad address\", op);\n }\n \n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-rs6000_add_gc_roots ()\n-{\n-  toc_hash_table = htab_create (1021, toc_hash_function, toc_hash_eq, NULL);\n-  ggc_add_root (&toc_hash_table, 1, sizeof (toc_hash_table), \n-\t\ttoc_hash_mark_table);\n-}\n-\n #if TARGET_MACHO\n \n #if 0\n@@ -13312,3 +13269,4 @@ rs6000_memory_move_cost (mode, class, in)\n     return 4 + rs6000_register_move_cost (mode, class, GENERAL_REGS);\n }\n \n+#include \"gt-rs6000.h\""}, {"sha": "c2a7848711b450ec547393a2efa38af26af6c24a", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,14 +1,17 @@\n # General rules that all rs6000/ targets must have.\n \n+gt-rs6000.h: s-gtype ; @true\n+\n rs6000.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RTL_H) $(REGS_H) hard-reg-set.h \\\n   real.h insn-config.h conditions.h insn-attr.h flags.h $(RECOG_H) \\\n   $(OBSTACK_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) except.h function.h \\\n   output.h $(BASIC_BLOCK_H) $(INTEGRATE_H) toplev.h $(GGC_H) $(HASHTAB_H) \\\n-  $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h\n+  $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h gt-rs6000.h\n \n rs6000-c.o: $(srcdir)/config/rs6000/rs6000-c.c \\\n     $(srcdir)/config/rs6000/rs6000-protos.h \\\n     $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(CPPLIB_H) \\\n     $(TM_P_H) c-pragma.h errors.h coretypes.h $(TM_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/rs6000/rs6000-c.c\n+"}, {"sha": "fb53043402770e648007fe9942f43790e9c2b7ec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,3 +1,93 @@\n+2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tMerge from pch-branch:\n+\n+\t2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tMerge to tag pch-merge-20030102:\n+\t\n+\t* semantics.c (finish_translation_unit): Don't call finish_file.\n+\t* parser.c: Don't include ggc.h.\n+\t(cp_lexer_new_main): Rename from cp_lexer_new, only create main lexer,\n+\tread first token here.  Don't allow PCH files after the first\n+\ttoken is read.\n+\t(cp_lexer_new_from_tokens): Duplicate functionality from cp_lexer_new.\n+\t(cp_lexer_get_preprocessor_token): Allow LEXER to be NULL.\n+\t(cp_parser_new): Call cp_lexer_new_main before allocating GCed memory.\n+\t(cp_parser_late_parsing_for_member): Don't duplicate call to\n+\tcp_lexer_set_source_position_from_token.\n+\t(cp_parser_late_parsing_default_args): Likewise.\n+\t(yyparse): Call finish_file after clearing the_parser.\n+\n+\t2002-12-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* Make-lang.in: Remove $(GGC_H) from all dependencies.\n+\t(CXX_TREE_H): Add $(GGC_H).\n+\t* class.c: Don't include ggc.h. \n+\t(field_decl_cmp): Make parameters be 'const void *' to match qsort.\n+\t(method_name_cmp): Likewise.\n+\t(resort_data): New variable.\n+\t(resort_field_decl_cmp): New.\n+\t(resort_method_name_cmp): New.\n+\t(resort_sorted_fields): New.\n+\t(resort_type_method_vec): New.\n+\t(finish_struct_methods): Delete cast.\n+\t(finish_struct_1): Delete cast.\n+\t* cp-tree.h: Include ggc.h.\n+\t(struct lang_type_class): Add reorder attribute to field `methods'.\n+\t(union lang_decl_u3): Add reorder attribute to field `sorted_fields'.\n+\t(resort_sorted_fields): New prototype.\n+\t(resort_type_method_vec): New prototype.\n+\t* call.c: Don't include ggc.h.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* init.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* method.c: Likewise.\n+\t* optimize.c: Likewise.\n+\t* parse.y: Likewise.\n+\t* pt.c: Likewise.\n+\t* repo.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* spew.c: Likewise.\n+\t* tree.c: Likewise.\n+\n+\t* lang-specs.h: Remove comment.\n+\n+\t2002-12-03  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* cp-tree.h (struct operator_name_info_t): Mark for GTY machinery.\n+\t(operator_name_info): Mark to be saved for PCH, specify size.\n+\t(assignment_operator_name_info): Likewise.\n+\n+\t2002-11-19  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* decl.c (anon_cnt): Mark to be saved for PCH.\n+\n+\t2002-10-25  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* lex.c  (init_reswords): Delete now-untrue comment.\n+\tAllocate ridpointers using GGC.\n+\n+\t2002-10-04  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* cp-tree.h (union lang_decl_u2): Add tags to all fields.\n+\n+\t* g++spec.c (lang_specific_driver): Don't include standard\n+\tlibraries in `added'.\n+\n+\t2002-08-27  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* decl2.c (finish_file): Call c_common_write_pch.\n+\t* Make-lang.in (CXX_C_OBJS): Add c-pch.o.\n+\n+\t2002-08-17  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* g++spec.c (lang_specific_driver): Treat .h files as C++ header\n+\tfiles when using g++.\n+\t* lang-specs.h: Handle compiling C++ header files.\n+\n 2003-01-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl.c (start_decl): Only check DECL_THREAD_LOCAL for VAR_DECLs."}, {"sha": "347b71a906a85b6d9ac12465af8ba7a57ca0dc7e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n # Top level -*- makefile -*- fragment for GNU C++.\n-#   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002\n+#   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n #   Free Software Foundation, Inc.\n \n #This file is part of GCC.\n@@ -79,7 +79,7 @@ g++-cross$(exeext): g++$(exeext)\n # The compiler itself.\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n-\tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o\n+\tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n@@ -210,34 +210,35 @@ c++.stage4: stage4-start\n # .o: .h dependencies.\n CXX_TREE_H = $(TREE_H) cp/cp-tree.h c-common.h cp/cp-tree.def c-common.def \\\n \tfunction.h varray.h $(SYSTEM_H) coretypes.h $(CONFIG_H) $(TARGET_H) \\\n+\t$(GGC_H) \\\n \t$(srcdir)/../include/hashtab.h $(srcdir)/../include/splay-tree.h\n \n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h \\\n-  c-pragma.h toplev.h output.h mbchar.h $(GGC_H) input.h diagnostic.h \\\n+  c-pragma.h toplev.h output.h mbchar.h input.h diagnostic.h \\\n   cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) c-common.h\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h stack.h \\\n-  output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(GGC_H) $(RTL_H) \\\n+  output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n   debug.h gt-cp-decl.h gtype-cp.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n-  output.h except.h toplev.h $(GGC_H) $(RTL_H) c-common.h gt-cp-decl2.h\n+  output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n    diagnostic.h\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n    diagnostic.h\n cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(TARGET_H)\n cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(EXPR_H) \\\n-     $(GGC_H) diagnostic.h gt-cp-call.h\n+     diagnostic.h gt-cp-call.h\n cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) toplev.h $(EXPR_H)\n cp/init.o: cp/init.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n-  $(GGC_H) except.h\n-cp/method.o: cp/method.c $(CXX_TREE_H) $(TM_H) toplev.h $(GGC_H) $(RTL_H) $(EXPR_H) \\\n+  except.h\n+cp/method.o: cp/method.c $(CXX_TREE_H) $(TM_H) toplev.h $(RTL_H) $(EXPR_H) \\\n   $(TM_P_H) $(TARGET_H)\n cp/cvt.o: cp/cvt.c $(CXX_TREE_H) $(TM_H) cp/decl.h flags.h toplev.h convert.h\n cp/search.o: cp/search.c $(CXX_TREE_H) $(TM_H) stack.h flags.h toplev.h $(RTL_H)\n-cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(GGC_H) $(RTL_H) \\\n+cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n   insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h $(TARGET_H)\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h\n@@ -246,13 +247,13 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h toplev.\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/lex.h \\\n-  toplev.h $(GGC_H) $(RTL_H) except.h tree-inline.h gt-cp-pt.h\n+  toplev.h $(RTL_H) except.h tree-inline.h gt-cp-pt.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h flags.h real.h \\\n   $(LANGHOOKS_DEF_H)\n-cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h $(GGC_H) diagnostic.h \\\n+cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h \\\n   gt-cp-repo.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) cp/lex.h except.h toplev.h \\\n-  flags.h $(GGC_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n+  flags.h debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n   tree-inline.h\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) tree-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h integrate.h insn-config.h \\"}, {"sha": "cd93f7bbe4bbc8938331670496bab1db73fef8a9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -35,7 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"toplev.h\"\n #include \"expr.h\"\n-#include \"ggc.h\"\n #include \"diagnostic.h\"\n \n extern int inhibit_warnings;"}, {"sha": "bace3f4d7c942d09465e4441a7ad31330486801c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 123, "deletions": 10, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n #include \"lex.h\"\n #include \"target.h\"\n \n@@ -125,8 +124,10 @@ static tree modify_all_vtables PARAMS ((tree, tree));\n static void determine_primary_base PARAMS ((tree));\n static void finish_struct_methods PARAMS ((tree));\n static void maybe_warn_about_overly_private_class PARAMS ((tree));\n-static int field_decl_cmp PARAMS ((const tree *, const tree *));\n-static int method_name_cmp PARAMS ((const tree *, const tree *));\n+static int field_decl_cmp PARAMS ((const void *, const void *));\n+static int resort_field_decl_cmp PARAMS ((const void *, const void *));\n+static int method_name_cmp PARAMS ((const void *, const void *));\n+static int resort_method_name_cmp PARAMS ((const void *, const void *));\n static void add_implicitly_declared_members PARAMS ((tree, int, int, int));\n static tree fixed_type_or_null PARAMS ((tree, int *, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n@@ -1449,7 +1450,8 @@ mark_primary_virtual_base (base_binfo, type)\n    base, then BINFO has no primary base in this graph.  Called from\n    mark_primary_bases.  DATA is the most derived type.  */\n \n-static tree dfs_unshared_virtual_bases (binfo, data)\n+static tree\n+dfs_unshared_virtual_bases (binfo, data)\n      tree binfo;\n      void *data;\n {\n@@ -1923,9 +1925,11 @@ maybe_warn_about_overly_private_class (t)\n /* Function to help qsort sort FIELD_DECLs by name order.  */\n \n static int\n-field_decl_cmp (x, y)\n-     const tree *x, *y;\n+field_decl_cmp (x_p, y_p)\n+     const void *x_p, *y_p;\n {\n+  const tree *const x = x_p;\n+  const tree *const y = y_p;\n   if (DECL_NAME (*x) == DECL_NAME (*y))\n     /* A nontype is \"greater\" than a type.  */\n     return DECL_DECLARES_TYPE_P (*y) - DECL_DECLARES_TYPE_P (*x);\n@@ -1938,12 +1942,64 @@ field_decl_cmp (x, y)\n   return 1;\n }\n \n+static struct {\n+  gt_pointer_operator new_value;\n+  void *cookie;\n+} resort_data;\n+\n+/* This routine compares two fields like field_decl_cmp but using the\n+   pointer operator in resort_data.  */\n+\n+static int\n+resort_field_decl_cmp (x_p, y_p)\n+     const void *x_p, *y_p;\n+{\n+  const tree *const x = x_p;\n+  const tree *const y = y_p;\n+\n+  if (DECL_NAME (*x) == DECL_NAME (*y))\n+    /* A nontype is \"greater\" than a type.  */\n+    return DECL_DECLARES_TYPE_P (*y) - DECL_DECLARES_TYPE_P (*x);\n+  if (DECL_NAME (*x) == NULL_TREE)\n+    return -1;\n+  if (DECL_NAME (*y) == NULL_TREE)\n+    return 1;\n+  {\n+    tree d1 = DECL_NAME (*x);\n+    tree d2 = DECL_NAME (*y);\n+    resort_data.new_value (&d1, resort_data.cookie);\n+    resort_data.new_value (&d2, resort_data.cookie);\n+    if (d1 < d2)\n+      return -1;\n+  }\n+  return 1;\n+}\n+\n+/* Resort DECL_SORTED_FIELDS because pointers have been reordered.  */\n+\n+void \n+resort_sorted_fields (obj, orig_obj, new_value, cookie)\n+     void *obj;\n+     void *orig_obj;\n+     gt_pointer_operator new_value;\n+     void *cookie;\n+{\n+  tree sf = obj;\n+  resort_data.new_value = new_value;\n+  resort_data.cookie = cookie;\n+  qsort (&TREE_VEC_ELT (sf, 0), TREE_VEC_LENGTH (sf), sizeof (tree),\n+\t resort_field_decl_cmp);\n+}\n+\n /* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */\n \n static int\n-method_name_cmp (m1, m2)\n-     const tree *m1, *m2;\n+method_name_cmp (m1_p, m2_p)\n+     const void *m1_p, *m2_p;\n {\n+  const tree *const m1 = m1_p;\n+  const tree *const m2 = m2_p;\n+  \n   if (*m1 == NULL_TREE && *m2 == NULL_TREE)\n     return 0;\n   if (*m1 == NULL_TREE)\n@@ -1955,6 +2011,63 @@ method_name_cmp (m1, m2)\n   return 1;\n }\n \n+/* This routine compares two fields like method_name_cmp but using the\n+   pointer operator in resort_field_decl_data.  */\n+\n+static int\n+resort_method_name_cmp (m1_p, m2_p)\n+     const void *m1_p, *m2_p;\n+{\n+  const tree *const m1 = m1_p;\n+  const tree *const m2 = m2_p;\n+  if (*m1 == NULL_TREE && *m2 == NULL_TREE)\n+    return 0;\n+  if (*m1 == NULL_TREE)\n+    return -1;\n+  if (*m2 == NULL_TREE)\n+    return 1;\n+  {\n+    tree d1 = DECL_NAME (OVL_CURRENT (*m1));\n+    tree d2 = DECL_NAME (OVL_CURRENT (*m2));\n+    resort_data.new_value (&d1, resort_data.cookie);\n+    resort_data.new_value (&d2, resort_data.cookie);\n+    if (d1 < d2)\n+      return -1;\n+  }\n+  return 1;\n+}\n+\n+/* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n+\n+void \n+resort_type_method_vec (obj, orig_obj, new_value, cookie)\n+     void *obj;\n+     void *orig_obj;\n+     gt_pointer_operator new_value;\n+     void *cookie;\n+{\n+  tree method_vec = obj;\n+  int len = TREE_VEC_LENGTH (method_vec);\n+  int slot;\n+\n+  /* The type conversion ops have to live at the front of the vec, so we\n+     can't sort them.  */\n+  for (slot = 2; slot < len; ++slot)\n+    {\n+      tree fn = TREE_VEC_ELT (method_vec, slot);\n+  \n+      if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+\tbreak;\n+    }\n+  if (len - slot > 1)\n+    {\n+      resort_data.new_value = new_value;\n+      resort_data.cookie = cookie;\n+      qsort (&TREE_VEC_ELT (method_vec, slot), len - slot, sizeof (tree),\n+\t     resort_method_name_cmp);\n+    }\n+}\n+\n /* Warn about duplicate methods in fn_fields.  Also compact method\n    lists so that lookup can be made faster.\n \n@@ -2025,7 +2138,7 @@ finish_struct_methods (t)\n     }\n   if (len - slot > 1)\n     qsort (&TREE_VEC_ELT (method_vec, slot), len-slot, sizeof (tree),\n-\t   (int (*)(const void *, const void *))method_name_cmp);\n+\t   method_name_cmp);\n }\n \n /* Emit error when a duplicate definition of a type is seen.  Patch up.  */\n@@ -5418,7 +5531,7 @@ finish_struct_1 (t)\n       tree field_vec = make_tree_vec (n_fields);\n       add_fields_to_vec (TYPE_FIELDS (t), field_vec, 0);\n       qsort (&TREE_VEC_ELT (field_vec, 0), n_fields, sizeof (tree),\n-\t     (int (*)(const void *, const void *))field_decl_cmp);\n+\t     field_decl_cmp);\n       if (! DECL_LANG_SPECIFIC (TYPE_MAIN_DECL (t)))\n \tretrofit_lang_decl (TYPE_MAIN_DECL (t));\n       DECL_SORTED_FIELDS (TYPE_MAIN_DECL (t)) = field_vec;"}, {"sha": "aad82c019b2d5c6c12ecc4c6d5701ba3dd7d50cd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C++ parsing and type checking.\n-   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2003,\n    2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_CP_TREE_H\n #define GCC_CP_TREE_H\n \n+#include \"ggc.h\"\n #include \"function.h\"\n #include \"hashtab.h\"\n #include \"splay-tree.h\"\n@@ -1182,7 +1183,7 @@ struct lang_type_class GTY(())\n   tree as_base;\n   tree pure_virtuals;\n   tree friend_classes;\n-  tree methods;\n+  tree GTY ((reorder (\"resort_type_method_vec\"))) methods;\n   tree key_method;\n   tree decl_list;\n   tree template_info;\n@@ -1782,14 +1783,17 @@ struct lang_decl_flags GTY(())\n     tree GTY ((tag (\"0\"))) access;\n \n     /* For VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n-    int discriminator;\n+    int GTY ((tag (\"1\"))) discriminator;\n \n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n        THUNK_VIRTUAL_OFFSET.  */\n     tree GTY((tag (\"2\"))) virtual_offset;\n   } GTY ((desc (\"%1.u2sel\"))) u2;\n };\n \n+/* sorted_fields is sorted based on a pointer, so we need to be able\n+   to resort it if pointers get rearranged.  */\n+\n struct lang_decl GTY(())\n {\n   struct lang_decl_flags decl_flags;\n@@ -1827,7 +1831,8 @@ struct lang_decl GTY(())\n \t\n \tunion lang_decl_u3\n \t{\n-\t  tree GTY ((tag (\"0\"))) sorted_fields;\n+\t  tree GTY ((tag (\"0\"), reorder (\"resort_sorted_fields\"))) \n+\t       sorted_fields;\n  \t  struct cp_token_cache * GTY ((tag (\"2\"))) pending_inline_info;\n \t  struct language_function * GTY ((tag (\"1\"))) \n \t       saved_language_function;\n@@ -3555,7 +3560,7 @@ extern void init_reswords PARAMS ((void));\n    opname_tab[(int) MINUS_EXPR] == \"-\".  */\n extern const char **opname_tab, **assignop_tab;\n \n-typedef struct operator_name_info_t\n+typedef struct operator_name_info_t GTY(())\n {\n   /* The IDENTIFIER_NODE for the operator.  */\n   tree identifier;\n@@ -3568,9 +3573,11 @@ typedef struct operator_name_info_t\n } operator_name_info_t;\n \n /* A mapping from tree codes to operator name information.  */\n-extern operator_name_info_t operator_name_info[];\n+extern GTY(()) operator_name_info_t operator_name_info\n+  [(int) LAST_CPLUS_TREE_CODE];\n /* Similar, but for assignment operators.  */\n-extern operator_name_info_t assignment_operator_name_info[];\n+extern GTY(()) operator_name_info_t assignment_operator_name_info\n+  [(int) LAST_CPLUS_TREE_CODE];\n \n /* in call.c */\n extern bool check_dtor_name (tree, tree);\n@@ -3611,10 +3618,14 @@ extern tree in_charge_arg_for_name (tree);\n \n /* in class.c */\n extern tree build_base_path\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n-extern tree convert_to_base                     (tree, tree, bool);\n+extern tree convert_to_base                     PARAMS ((tree, tree, bool));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n extern tree build_vfn_ref\t\t\tPARAMS ((tree, tree));\n extern tree get_vtable_decl                     PARAMS ((tree, int));\n+extern void resort_sorted_fields \n+  PARAMS ((void *, void *, gt_pointer_operator, void *));\n+extern void resort_type_method_vec\n+  PARAMS ((void *, void *, gt_pointer_operator, void *));\n extern void add_method\t\t\t\tPARAMS ((tree, tree, int));\n extern int currently_open_class\t\t\tPARAMS ((tree));\n extern tree currently_open_derived_class\tPARAMS ((tree));"}, {"sha": "29a7a7fb93b02e99c886e90c7b729d4b789d1072", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -44,7 +44,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"hashtab.h\"\n-#include \"ggc.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"c-common.h\"\n@@ -2731,7 +2730,7 @@ pushtag (tree name, tree type, int globalize)\n \n /* Counter used to create anonymous type names.  */\n \n-static int anon_cnt = 0;\n+static GTY(()) int anon_cnt;\n \n /* Return an IDENTIFIER which can be used as a name for\n    anonymous structs and unions.  */"}, {"sha": "2491c8a397949e461599728ecd4ce5a5d06fdab6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -42,7 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n #include \"timevar.h\"\n #include \"cpplib.h\"\n #include \"target.h\"\n@@ -2589,6 +2588,9 @@ finish_file ()\n   if (! global_bindings_p () || current_class_type || decl_namespace_list)\n     return;\n \n+  if (pch_file)\n+    c_common_write_pch ();\n+\n   /* Otherwise, GDB can get confused, because in only knows\n      about source for LINENO-1 lines.  */\n   lineno -= 1;"}, {"sha": "75a1d7c28a40a04d4afd9e7a67a62b613b846bf8", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 63, "deletions": 33, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -60,14 +60,16 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   /* If nonzero, the user gave us the `-v' flag.  */\n   int saw_verbose_flag = 0;\n \n-  /* This will be 0 if we encounter a situation where we should not\n-     link in libstdc++.  */\n-  int library = 1;\n+  /* This is a tristate:\n+     -1 means we should not link in libstdc++\n+     0  means we should link in libstdc++ if it is needed\n+     1  means libstdc++ is needed and should be linked in.  */\n+  int library = 0;\n \n   /* The number of arguments being added to what's in argv, other than\n      libraries.  We use this to track the number of times we've inserted\n      -xc++/-xnone.  */\n-  int added = 2;\n+  int added = 0;\n \n   /* Used to track options that take arguments, so we don't go wrapping\n      those with -xc++/-xnone.  */\n@@ -131,10 +133,10 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n       if (argv[i][0] == '-')\n \t{\n-\t  if (library != 0 && (strcmp (argv[i], \"-nostdlib\") == 0\n-\t\t\t       || strcmp (argv[i], \"-nodefaultlibs\") == 0))\n+\t  if (strcmp (argv[i], \"-nostdlib\") == 0\n+\t      || strcmp (argv[i], \"-nodefaultlibs\") == 0)\n \t    {\n-\t      library = 0;\n+\t      library = -1;\n \t    }\n \t  else if (strcmp (argv[i], \"-lm\") == 0\n \t\t   || strcmp (argv[i], \"-lmath\") == 0\n@@ -152,31 +154,37 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t  else if (strcmp (argv[i], \"-pg\") == 0 || strcmp (argv[i], \"-p\") == 0)\n \t    saw_profile_flag++;\n \t  else if (strcmp (argv[i], \"-v\") == 0)\n+\t    saw_verbose_flag = 1;\n+\t  else if (strncmp (argv[i], \"-x\", 2) == 0)\n \t    {\n-\t      saw_verbose_flag = 1;\n-\t      if (argc == 2)\n+\t      if (library == 0)\n \t\t{\n-\t\t  /* If they only gave us `-v', don't try to link\n-\t\t     in libg++.  */ \n-\t\t  library = 0;\n+\t\t  const char * arg;\n+\t\t  if (argv[i][2] != '\\0')\n+\t\t    arg = argv[i]+2;\n+\t\t  else if (argv[i+1] != NULL)\n+\t\t    arg = argv[i+1];\n+\t\t  else  /* Error condition, message will be printed later.  */\n+\t\t    arg = \"\";\n+\t\t  if (strcmp (arg, \"c++\") == 0\n+\t\t      || strcmp (arg, \"c++-cpp-output\") == 0)\n+\t\t    library = 1;\n \t\t}\n+\t      saw_speclang = 1;\n \t    }\n-\t  else if (strncmp (argv[i], \"-x\", 2) == 0)\n-\t    saw_speclang = 1;\n \t  else if (((argv[i][2] == '\\0'\n \t\t     && (char *)strchr (\"bBVDUoeTuIYmLiA\", argv[i][1]) != NULL)\n \t\t    || strcmp (argv[i], \"-Xlinker\") == 0\n \t\t    || strcmp (argv[i], \"-Tdata\") == 0))\n \t    quote = argv[i];\n-\t  else if (library != 0 && ((argv[i][2] == '\\0'\n-\t\t     && (char *) strchr (\"cSEM\", argv[i][1]) != NULL)\n-\t\t    || strcmp (argv[i], \"-MM\") == 0\n-\t\t    || strcmp (argv[i], \"-fsyntax-only\") == 0))\n+\t  else if ((argv[i][2] == '\\0'\n+\t\t    && (char *) strchr (\"cSEM\", argv[i][1]) != NULL)\n+\t\t   || strcmp (argv[i], \"-MM\") == 0\n+\t\t   || strcmp (argv[i], \"-fsyntax-only\") == 0)\n \t    {\n \t      /* Don't specify libraries if we won't link, since that would\n \t\t cause a warning.  */\n-\t      library = 0;\n-\t      added -= 2;\n+\t      library = -1;\n \t    }\n \t  else if (strcmp (argv[i], \"-static-libgcc\") == 0 \n \t\t   || strcmp (argv[i], \"-static\") == 0)\n@@ -195,24 +203,36 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t      continue;\n \t    }\n \n-\t  /* If the filename ends in .c or .i, put options around it.\n+\t  /* If the filename ends in .[chi], put options around it.\n \t     But not if a specified -x option is currently active.  */\n \t  len = strlen (argv[i]);\n \t  if (len > 2\n-\t      && (argv[i][len - 1] == 'c' || argv[i][len - 1] == 'i')\n+\t      && (argv[i][len - 1] == 'c' \n+\t\t  || argv[i][len - 1] == 'i'\n+\t\t  || argv[i][len - 1] == 'h')\n \t      && argv[i][len - 2] == '.')\n \t    {\n \t      args[i] |= LANGSPEC;\n \t      added += 2;\n \t    }\n+\t  \n+\t  /* If we don't know that this is a header file, we might\n+\t     need to be linking in the libraries.  */\n+\t  if (library == 0)\n+\t    {\n+\t      if ((len <= 2 || strcmp (argv[i] + (len - 2), \".H\") != 0)\n+\t\t  && (len <= 2 || strcmp (argv[i] + (len - 2), \".h\") != 0)\n+\t\t  && (len <= 3 || strcmp (argv[i] + (len - 3), \".hh\") != 0))\n+\t\tlibrary = 1;\n+\t    }\n \t}\n     }\n \n   if (quote)\n     fatal (\"argument to `%s' missing\\n\", quote);\n \n   /* If we know we don't have to do anything, bail now.  */\n-  if (! added && ! library)\n+  if (! added && library <= 0)\n     {\n       free (args);\n       return;\n@@ -225,7 +245,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n #endif\n \n   /* Make sure to have room for the trailing NULL argument.  */\n-  num_args = argc + added + need_math + shared_libgcc + 1;\n+  num_args = argc + added + need_math + shared_libgcc + (library > 0) + 1;\n   arglist = (const char **) xmalloc (num_args * sizeof (char *));\n \n   i = 0;\n@@ -241,27 +261,37 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n       /* Make sure -lstdc++ is before the math library, since libstdc++\n \t itself uses those math routines.  */\n-      if (!saw_math && (args[i] & MATHLIB) && library)\n+      if (!saw_math && (args[i] & MATHLIB) && library > 0)\n \t{\n \t  --j;\n \t  saw_math = argv[i];\n \t}\n \n-      if (!saw_libc && (args[i] & WITHLIBC) && library)\n+      if (!saw_libc && (args[i] & WITHLIBC) && library > 0)\n \t{\n \t  --j;\n \t  saw_libc = argv[i];\n \t}\n \n-      /* Wrap foo.c and foo.i files in a language specification to\n+      /* Wrap foo.[chi] files in a language specification to\n \t force the gcc compiler driver to run cc1plus on them.  */\n       if (args[i] & LANGSPEC)\n \t{\n \t  int len = strlen (argv[i]);\n-\t  if (argv[i][len - 1] == 'i')\n-\t    arglist[j++] = \"-xc++-cpp-output\";\n-\t  else\n-\t    arglist[j++] = \"-xc++\";\n+\t  switch (argv[i][len - 1])\n+\t    {\n+\t    case 'c':\n+\t      arglist[j++] = \"-xc++\";\n+\t      break;\n+\t    case 'i':\n+\t      arglist[j++] = \"-xc++-cpp-output\";\n+\t      break;\n+\t    case 'h':\n+\t      arglist[j++] = \"-xc++-header\";\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n \t  arglist[j++] = argv[i];\n \t  arglist[j] = \"-xnone\";\n \t}\n@@ -271,7 +301,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n     }\n \n   /* Add `-lstdc++' if we haven't already done so.  */\n-  if (library)\n+  if (library > 0)\n     {\n       arglist[j++] = saw_profile_flag ? LIBSTDCXX_PROFILE : LIBSTDCXX;\n       added_libraries++;\n@@ -285,7 +315,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n     }\n   if (saw_math)\n     arglist[j++] = saw_math;\n-  else if (library && need_math)\n+  else if (library > 0 && need_math)\n     {\n       arglist[j++] = saw_profile_flag ? MATH_LIBRARY_PROFILE : MATH_LIBRARY;\n       added_libraries++;"}, {"sha": "964ee1e0c128a78ee0d9808d93b2840cee9d6012", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n \n static void construct_virtual_base (tree, tree);\n static void expand_aggr_init_1 PARAMS ((tree, tree, tree, tree, int));"}, {"sha": "cf4ca4cee36005ff2d1d101de61c080f647b97d6", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -33,6 +33,19 @@ Boston, MA 02111-1307, USA.  */\n   {\".c++\", \"@c++\", 0},\n   {\".C\",   \"@c++\", 0},\n   {\".CPP\", \"@c++\", 0},\n+  {\".H\",   \"@c++-header\", 0},\n+  {\".hh\",  \"@c++-header\", 0},\n+  {\"@c++-header\",\n+    \"%{E|M|MM:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n+       %(cpp_options) %2 %(cpp_debug_options)}\\\n+     %{!E:%{!M:%{!MM:\\\n+       %{save-temps:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n+\t\t%(cpp_options) %2 %b.ii \\n}\\\n+      cc1plus %{save-temps:-fpreprocessed %b.ii}\\\n+\t      %{!save-temps:%(cpp_unique_options) %{!no-gcc:-D__GNUG__=%v1}}\\\n+\t%(cc1_options) %2 %{+e1*}\\\n+        -o %g.s %{!o*:--output-pch=%i.pch} %W{o*:--output-pch=%*}%V}}}\",\n+     CPLUSPLUS_CPP_SPEC},\n   {\"@c++\",\n     \"%{E|M|MM:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n        %(cpp_options) %2 %(cpp_debug_options)}\\"}, {"sha": "5749fc463b7ffaa26ab2cb760080e28d02c6d18a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -36,7 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-pragma.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n-#include \"ggc.h\"\n #include \"tm_p.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n@@ -380,10 +379,7 @@ init_reswords ()\n   int mask = ((flag_no_asm ? D_ASM : 0)\n \t      | (flag_no_gnu_keywords ? D_EXT : 0));\n \n-  /* It is not necessary to register ridpointers as a GC root, because\n-     all the trees it points to are permanently interned in the\n-     get_identifier hash anyway.  */\n-  ridpointers = (tree *) xcalloc ((int) RID_MAX, sizeof (tree));\n+  ridpointers = (tree *) ggc_calloc ((int) RID_MAX, sizeof (tree));\n   for (i = 0; i < ARRAY_SIZE (reswords); i++)\n     {\n       id = get_identifier (reswords[i].word);"}, {"sha": "883a81f73fd72114a1e91bddb43e95089377b42a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,7 +1,7 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n-   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n "}, {"sha": "8f08c9ac22b006a7526f87ae484c597d3ae12226", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -31,7 +31,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"integrate.h\"\n #include \"toplev.h\"\n #include \"varray.h\"\n-#include \"ggc.h\"\n #include \"params.h\"\n #include \"hashtab.h\"\n #include \"debug.h\""}, {"sha": "629ba5d81780d88ee5241a83f085c2d7385c559f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -32,7 +32,6 @@\n #include \"decl.h\"\n #include \"flags.h\"\n #include \"diagnostic.h\"\n-#include \"ggc.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n \n@@ -213,8 +212,8 @@ typedef struct cp_lexer GTY (())\n \n /* Prototypes.  */\n \n-static cp_lexer *cp_lexer_new\n-  PARAMS ((bool));\n+static cp_lexer *cp_lexer_new_main\n+  PARAMS ((void));\n static cp_lexer *cp_lexer_new_from_tokens\n   PARAMS ((struct cp_token_cache *));\n static int cp_lexer_saving_tokens\n@@ -292,29 +291,37 @@ static void cp_lexer_stop_debugging\n /* The stream to which debugging output should be written.  */\n static FILE *cp_lexer_debug_stream;\n \n-/* Create a new C++ lexer.  If MAIN_LEXER_P is true the new lexer is\n-   the main lexer -- i.e, the lexer that gets tokens from the\n-   preprocessor.  Otherwise, it is a lexer that uses a cache of stored\n-   tokens.  */\n+/* Create a new main C++ lexer, the lexer that gets tokens from the\n+   preprocessor.  */\n \n static cp_lexer *\n-cp_lexer_new (bool main_lexer_p)\n+cp_lexer_new_main (void)\n {\n   cp_lexer *lexer;\n+  cp_token first_token;\n+\n+  /* It's possible that lexing the first token will load a PCH file,\n+     which is a GC collection point.  So we have to grab the first\n+     token before allocating any memory.  */\n+  cp_lexer_get_preprocessor_token (NULL, &first_token);\n+  cpp_get_callbacks (parse_in)->valid_pch = NULL;\n \n   /* Allocate the memory.  */\n   lexer = (cp_lexer *) ggc_alloc_cleared (sizeof (cp_lexer));\n \n   /* Create the circular buffer.  */\n   lexer->buffer = ((cp_token *) \n-\t\t   ggc_alloc (CP_TOKEN_BUFFER_SIZE * sizeof (cp_token)));\n+\t\t   ggc_calloc (CP_TOKEN_BUFFER_SIZE, sizeof (cp_token)));\n   lexer->buffer_end = lexer->buffer + CP_TOKEN_BUFFER_SIZE;\n \n-  /* There are no tokens in the buffer.  */\n-  lexer->last_token = lexer->buffer;\n+  /* There is one token in the buffer.  */\n+  lexer->last_token = lexer->buffer + 1;\n+  lexer->first_token = lexer->buffer;\n+  lexer->next_token = lexer->buffer;\n+  memcpy (lexer->buffer, &first_token, sizeof (cp_token));\n \n   /* This lexer obtains more tokens by calling c_lex.  */\n-  lexer->main_lexer_p = main_lexer_p;\n+  lexer->main_lexer_p = true;\n \n   /* Create the SAVED_TOKENS stack.  */\n   VARRAY_INT_INIT (lexer->saved_tokens, CP_SAVED_TOKENS_SIZE, \"saved_tokens\");\n@@ -339,15 +346,14 @@ cp_lexer_new_from_tokens (cp_token_cache *tokens)\n   cp_token_block *block;\n   ptrdiff_t num_tokens;\n \n-  /* Create the lexer.  */\n-  lexer = cp_lexer_new (/*main_lexer_p=*/false);\n+  /* Allocate the memory.  */\n+  lexer = (cp_lexer *) ggc_alloc_cleared (sizeof (cp_lexer));\n \n   /* Create a new buffer, appropriately sized.  */\n   num_tokens = 0;\n   for (block = tokens->first; block != NULL; block = block->next)\n     num_tokens += block->num_tokens;\n-  lexer->buffer = ((cp_token *) \n-\t\t   ggc_alloc (num_tokens * sizeof (cp_token)));\n+  lexer->buffer = ((cp_token *) ggc_alloc (num_tokens * sizeof (cp_token)));\n   lexer->buffer_end = lexer->buffer + num_tokens;\n   \n   /* Install the tokens.  */\n@@ -365,6 +371,18 @@ cp_lexer_new_from_tokens (cp_token_cache *tokens)\n   /* The buffer is full.  */\n   lexer->last_token = lexer->first_token;\n \n+  /* This lexer doesn't obtain more tokens.  */\n+  lexer->main_lexer_p = false;\n+\n+  /* Create the SAVED_TOKENS stack.  */\n+  VARRAY_INT_INIT (lexer->saved_tokens, CP_SAVED_TOKENS_SIZE, \"saved_tokens\");\n+  \n+  /* Create the STRINGS array.  */\n+  VARRAY_TREE_INIT (lexer->string_tokens, 32, \"strings\");\n+\n+  /* Assume we are not debugging.  */\n+  lexer->debugging_p = false;\n+\n   return lexer;\n }\n \n@@ -610,7 +628,7 @@ cp_lexer_get_preprocessor_token (lexer, token)\n   bool done;\n \n   /* If this not the main lexer, return a terminating CPP_EOF token.  */\n-  if (!lexer->main_lexer_p)\n+  if (lexer != NULL && !lexer->main_lexer_p)\n     {\n       token->type = CPP_EOF;\n       token->line_number = 0;\n@@ -2472,9 +2490,14 @@ static cp_parser *\n cp_parser_new ()\n {\n   cp_parser *parser;\n+  cp_lexer *lexer;\n+\n+  /* cp_lexer_new_main is called before calling ggc_alloc because\n+     cp_lexer_new_main might load a PCH file.  */\n+  lexer = cp_lexer_new_main ();\n \n   parser = (cp_parser *) ggc_alloc_cleared (sizeof (cp_parser));\n-  parser->lexer = cp_lexer_new (/*main_lexer_p=*/true);\n+  parser->lexer = lexer;\n   parser->context = cp_parser_context_new (NULL);\n \n   /* For now, we always accept GNU extensions.  */\n@@ -14422,9 +14445,7 @@ cp_parser_late_parsing_for_member (parser, member_function)\n       \n       /* Set the current source position to be the location of the first\n \t token in the saved inline body.  */\n-      cp_lexer_set_source_position_from_token \n-\t(parser->lexer,\n-\t cp_lexer_peek_token (parser->lexer));\n+      (void) cp_lexer_peek_token (parser->lexer);\n       \n       /* Let the front end know that we going to be defining this\n \t function.  */\n@@ -14477,8 +14498,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \n        /* Set the current source position to be the location of the\n      \t  first token in the default argument.  */\n-      cp_lexer_set_source_position_from_token \n-\t(parser->lexer, cp_lexer_peek_token (parser->lexer));\n+      (void) cp_lexer_peek_token (parser->lexer);\n \n        /* Local variable names (and the `this' keyword) may not appear\n      \t  in a default argument.  */\n@@ -14996,6 +15016,8 @@ yyparse ()\n   the_parser = cp_parser_new ();\n   error_occurred = cp_parser_translation_unit (the_parser);\n   the_parser = NULL;\n+  \n+  finish_file ();\n \n   return error_occurred;\n }"}, {"sha": "e7486afca258743372a7bb919dbaa816c8c15764", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"rtl.h\"\n-#include \"ggc.h\"\n #include \"timevar.h\"\n \n /* The type of functions taking a tree, and some additional data, and"}, {"sha": "603b04eef06d45a005c1f2c945c0a72dbf5045af", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -35,7 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"input.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n #include \"diagnostic.h\"\n \n static tree repo_get_id (tree);"}, {"sha": "5e9b3955ad4792f2e20cbf5a7b63e9695c854e17", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"output.h\"\n-#include \"ggc.h\"\n #include \"toplev.h\"\n #include \"stack.h\"\n "}, {"sha": "3ed9f2e20a3d7db7874c8df10e3bf7f265d96f5b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -3,7 +3,7 @@\n    building RTL.  These routines are used both during actual parsing\n    and during the instantiation of template functions. \n \n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Written by Mark Mitchell (mmitchell@usa.net) based on code found\n    formerly in parse.y and pt.c.  \n \n@@ -35,7 +35,6 @@\n #include \"lex.h\"\n #include \"toplev.h\"\n #include \"flags.h\"\n-#include \"ggc.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n #include \"output.h\"\n@@ -1628,8 +1627,6 @@ finish_translation_unit ()\n \n   /* Do file scope __FUNCTION__ et al.  */\n   finish_fname_decls ();\n-  \n-  finish_file ();\n }\n \n /* Finish a template type parameter, specified as AGGR IDENTIFIER."}, {"sha": "a3b6ff14a4f4bab988cb84004e4ec4d94107aede", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"rtl.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n #include \"insn-config.h\"\n #include \"integrate.h\"\n #include \"tree-inline.h\""}, {"sha": "203619f30b8c89dffe59c6057bbc97ce1153775c", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 113, "deletions": 2, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -22,6 +22,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include <dirent.h>\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"cpplib.h\"\n@@ -87,6 +88,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n /* This structure is used for the table of all includes.  */\n struct include_file {\n   const char *name;\t\t/* actual path name of file */\n+  const char *header_name;\t/* the original header found */\n   const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n   const struct search_path *foundhere;\n \t\t\t\t/* location in search path where file was\n@@ -98,6 +100,13 @@ struct include_file {\n   unsigned short include_count;\t/* number of times file has been read */\n   unsigned short refcnt;\t/* number of stacked buffers using this file */\n   unsigned char mapped;\t\t/* file buffer is mmapped */\n+  unsigned char pch;\t\t/* 0: file not known to be a PCH.\n+\t\t\t\t   1: file is a PCH \n+\t\t\t\t      (on return from find_include_file).\n+\t\t\t\t   2: file is not and never will be a valid\n+\t\t\t\t      precompiled header.\n+\t\t\t\t   3: file is always a valid precompiled\n+\t\t\t\t      header.  */\n };\n \n /* Variable length record files on VMS will have a stat size that includes\n@@ -118,6 +127,7 @@ struct include_file {\n ((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n \t\t   || (inc)->cmacro->type == NT_MACRO))\n #define NO_INCLUDE_PATH ((struct include_file *) -1)\n+#define INCLUDE_PCH_P(F) (((F)->pch & 1) != 0)\n \n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n@@ -130,6 +140,11 @@ static struct include_file *\n \tfind_include_file PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t   enum include_type));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n+static struct include_file *validate_pch PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t  const char *,\n+\t\t\t\t\t\t  const char *));\n+static struct include_file *open_file_pch PARAMS ((cpp_reader *, \n+\t\t\t\t\t\t   const char *));\n static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static bool stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void purge_cache \tPARAMS ((struct include_file *));\n@@ -212,6 +227,7 @@ find_or_create_entry (pfile, fname)\n     {\n       file = xcnew (struct include_file);\n       file->name = name;\n+      file->header_name = name;\n       file->err_no = errno;\n       node = splay_tree_insert (pfile->all_include_files,\n \t\t\t\t(splay_tree_key) file->name,\n@@ -306,6 +322,89 @@ open_file (pfile, filename)\n   return 0;\n }\n \n+static struct include_file *\n+validate_pch (pfile, filename, pchname)\n+     cpp_reader *pfile;\n+     const char *filename;\n+     const char *pchname;\n+{\n+  struct include_file * file;\n+  \n+  file = open_file (pfile, pchname);\n+  if (file == NULL)\n+    return NULL;\n+  if ((file->pch & 2) == 0)\n+    file->pch = pfile->cb.valid_pch (pfile, pchname, file->fd);\n+  if (INCLUDE_PCH_P (file))\n+    {\n+      file->header_name = _cpp_simplify_pathname (xstrdup (filename));\n+      return file;\n+    }\n+  close (file->fd);\n+  file->fd = -1;\n+  return NULL;\n+}\n+\n+\n+/* Like open_file, but also look for a precompiled header if (a) one exists\n+   and (b) it is valid.  */\n+static struct include_file *\n+open_file_pch (pfile, filename)\n+     cpp_reader *pfile;\n+     const char *filename;\n+{\n+  if (filename[0] != '\\0'\n+      && pfile->cb.valid_pch != NULL)\n+    {\n+      size_t namelen = strlen (filename);\n+      char *pchname = alloca (namelen + 5);\n+      struct include_file * file;\n+      splay_tree_node nd;\n+      \n+      memcpy (pchname, filename, namelen);\n+      memcpy (pchname + namelen, \".pch\", 5);\n+\n+      nd = find_or_create_entry (pfile, pchname);\n+      file = (struct include_file *) nd->value;\n+\n+      if (file != NULL)\n+\t{\n+\t  if (stat (file->name, &file->st) == 0 && S_ISDIR (file->st.st_mode))\n+\t    {\n+\t      DIR * thedir;\n+\t      struct dirent *d;\n+\t      size_t subname_len = namelen + 64;\n+\t      char *subname = xmalloc (subname_len);\n+\t      \n+\t      thedir = opendir (pchname);\n+\t      if (thedir == NULL)\n+\t\treturn NULL;\n+\t      memcpy (subname, pchname, namelen + 4);\n+\t      subname[namelen+4] = '/';\n+\t      while ((d = readdir (thedir)) != NULL)\n+\t\t{\n+\t\t  if (strlen (d->d_name) + namelen + 7 > subname_len)\n+\t\t    {\n+\t\t      subname_len = strlen (d->d_name) + namelen + 64;\n+\t\t      subname = xrealloc (subname, subname_len);\n+\t\t    }\n+\t\t  strcpy (subname + namelen + 5, d->d_name);\n+\t\t  file = validate_pch (pfile, filename, subname);\n+\t\t  if (file)\n+\t\t    break;\n+\t\t}\n+\t      closedir (thedir);\n+\t      free (subname);\n+\t    }\n+\t  else\n+\t    file = validate_pch (pfile, filename, pchname);\n+\t  if (file)\n+\t    return file;\n+\t}\n+    }\n+  return open_file (pfile, filename);\n+}\n+\n /* Place the file referenced by INC into a new buffer on the buffer\n    stack, unless there are errors, or the file is not re-included\n    because of e.g. multiple-include guards.  Returns true if a buffer\n@@ -332,6 +431,15 @@ stack_include_file (pfile, inc)\n \tdeps_add_dep (pfile->deps, inc->name);\n     }\n \n+  /* PCH files get dealt with immediately.  */\n+  if (INCLUDE_PCH_P (inc))\n+    {\n+      pfile->cb.read_pch (pfile, inc->name, inc->fd, inc->header_name);\n+      close (inc->fd);\n+      inc->fd = -1;\n+      return false;\n+    }\n+\n   /* Not in cache?  */\n   if (! inc->buffer)\n     {\n@@ -579,7 +687,7 @@ find_include_file (pfile, header, type)\n   char *name, *n;\n \n   if (IS_ABSOLUTE_PATHNAME (fname))\n-    return open_file (pfile, fname);\n+    return open_file_pch (pfile, fname);\n \n   /* For #include_next, skip in the search path past the dir in which\n      the current file was found, but if it was found via an absolute\n@@ -615,7 +723,7 @@ find_include_file (pfile, header, type)\n       else\n \tn = name;\n \n-      file = open_file (pfile, n);\n+      file = open_file_pch (pfile, n);\n       if (file)\n \t{\n \t  file->foundhere = path;\n@@ -757,6 +865,9 @@ _cpp_read_file (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n+  /* This uses open_file, because we don't allow a PCH to be used as\n+     the toplevel compilation (that would prevent re-compiling an\n+     existing PCH without deleting it first).  */\n   struct include_file *f = open_file (pfile, fname);\n \n   if (f == NULL)"}, {"sha": "d5a0b5d155aad615f21b9b03b0495d5bf600c28a", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -449,6 +449,10 @@ struct cpp_reader\n   /* Used to save the original line number during traditional\n      preprocessing.  */\n   unsigned int saved_line;\n+\n+  /* A saved list of the defined macros, for dependency checking\n+     of precompiled headers.  */\n+  struct cpp_savedstate *savedstate;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n@@ -542,6 +546,8 @@ extern void _cpp_maybe_push_include_file PARAMS ((cpp_reader *));\n extern int _cpp_test_assertion PARAMS ((cpp_reader *, unsigned int *));\n extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\n extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n+extern char ** _cpp_save_pragma_names PARAMS ((cpp_reader *));\n+extern void _cpp_restore_pragma_names PARAMS ((cpp_reader *, char **));\n extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_directives PARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));"}, {"sha": "1019a2a9713c1eb2e8e5ce8b0d373deb256fba6b", "filename": "gcc/cpplib.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -121,6 +121,11 @@ static struct pragma_entry *lookup_pragma_entry\n static struct pragma_entry *insert_pragma_entry\n   PARAMS ((cpp_reader *, struct pragma_entry **, const cpp_hashnode *,\n \t   pragma_cb));\n+static int count_registered_pragmas\tPARAMS ((struct pragma_entry *));\n+static char ** save_registered_pragmas \n+  PARAMS ((struct pragma_entry *, char **));\n+static char ** restore_registered_pragmas \n+  PARAMS ((cpp_reader *, struct pragma_entry *, char **));\n static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n@@ -1085,6 +1090,85 @@ _cpp_init_internal_pragmas (pfile)\n   cpp_register_pragma (pfile, \"GCC\", \"dependency\", do_pragma_dependency);\n }\n \n+/* Return the number of registered pragmas in PE.  */\n+\n+static int\n+count_registered_pragmas (pe)\n+     struct pragma_entry *pe;\n+{\n+  int ct = 0;\n+  for (; pe != NULL; pe = pe->next)\n+    {\n+      if (pe->is_nspace)\n+\tct += count_registered_pragmas (pe->u.space);\n+      ct++;\n+    }\n+  return ct;\n+}\n+\n+/* Save into SD the names of the registered pragmas referenced by PE,\n+   and return a pointer to the next free space in SD.  */\n+\n+static char **\n+save_registered_pragmas (pe, sd)\n+     struct pragma_entry *pe;\n+     char **sd;\n+{\n+  for (; pe != NULL; pe = pe->next)\n+    {\n+      if (pe->is_nspace)\n+\tsd = save_registered_pragmas (pe->u.space, sd);\n+      *sd++ = xmemdup (HT_STR (&pe->pragma->ident),\n+\t\t       HT_LEN (&pe->pragma->ident),\n+\t\t       HT_LEN (&pe->pragma->ident) + 1);\n+    }\n+  return sd;\n+}\n+\n+/* Return a newly-allocated array which saves the names of the\n+   registered pragmas.  */\n+\n+char **\n+_cpp_save_pragma_names (pfile)\n+     cpp_reader *pfile;\n+{\n+  int ct = count_registered_pragmas (pfile->pragmas);\n+  char **result = xnewvec (char *, ct);\n+  (void) save_registered_pragmas (pfile->pragmas, result);\n+  return result;\n+}\n+\n+/* Restore from SD the names of the registered pragmas referenced by PE,\n+   and return a pointer to the next unused name in SD.  */\n+\n+static char **\n+restore_registered_pragmas (pfile, pe, sd)\n+     cpp_reader *pfile;\n+     struct pragma_entry *pe;\n+     char **sd;\n+{\n+  for (; pe != NULL; pe = pe->next)\n+    {\n+      if (pe->is_nspace)\n+\tsd = restore_registered_pragmas (pfile, pe->u.space, sd);\n+      pe->pragma = cpp_lookup (pfile, U *sd, strlen (*sd));\n+      free (*sd);\n+      sd++;\n+    }\n+  return sd;\n+}\n+\n+/* Restore the names of the registered pragmas from SAVED.  */\n+\n+void\n+_cpp_restore_pragma_names (pfile, saved)\n+     cpp_reader *pfile;\n+     char **saved;\n+{\n+  (void) restore_registered_pragmas (pfile, pfile->pragmas, saved);\n+  free (saved);\n+}\n+\n /* Pragmata handling.  We handle some, and pass the rest on to the\n    front end.  C99 defines three pragmas and says that no macro\n    expansion is to be performed on them; whether or not macro"}, {"sha": "bccfecf86beec2bc7d43237b195cc898a7451044", "filename": "gcc/cpplib.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -400,6 +400,12 @@ struct cpp_options\n \n   /* Nonzero means __STDC__ should have the value 0 in system headers.  */\n   unsigned char stdc_0_in_system_headers;\n+\n+  /* True to warn about precompiled header files we couldn't use.  */\n+  bool warn_invalid_pch;\n+\n+  /* True if dependencies should be restored from a precompiled header.  */\n+  bool restore_pch_deps;\n };\n \n /* Call backs.  */\n@@ -417,6 +423,8 @@ struct cpp_callbacks\n   /* Called when the client has a chance to properly register\n      built-ins with cpp_define() and cpp_assert().  */\n   void (*register_builtins) PARAMS ((cpp_reader *));\n+  int (*valid_pch) PARAMS ((cpp_reader *, const char *, int));\n+  void (*read_pch) PARAMS ((cpp_reader *, const char *, int, const char *));\n };\n \n /* Name under which this program was invoked.  */\n@@ -472,7 +480,7 @@ enum builtin_type\n /* The common part of an identifier node shared amongst all 3 C front\n    ends.  Also used to store CPP identifiers, which are a superset of\n    identifiers in the grammatical sense.  */\n-struct cpp_hashnode\n+struct cpp_hashnode GTY(())\n {\n   struct ht_identifier ident;\n   unsigned int is_directive : 1;\n@@ -485,11 +493,15 @@ struct cpp_hashnode\n \n   union _cpp_hashnode_value\n   {\n-    cpp_macro *macro;\t\t\t/* If a macro.  */\n-    struct answer *answers;\t\t/* Answers to an assertion.  */\n-    enum builtin_type builtin;\t\t/* Code for a builtin macro.  */\n-    unsigned short arg_index;\t\t/* Macro argument index.  */\n-  } value;\n+    /* If a macro.  */\n+    cpp_macro * GTY((skip (\"\"))) macro;\n+    /* Answers to an assertion.  */\n+    struct answer * GTY ((skip (\"\"))) answers;\n+    /* Code for a builtin macro.  */\n+    enum builtin_type GTY ((tag (\"1\"))) builtin;\n+    /* Macro argument index.  */\n+    unsigned short GTY ((tag (\"0\"))) arg_index;\n+  } GTY ((desc (\"0\"))) value;\n };\n \n /* Call this first to get a handle to pass to other functions.  */\n@@ -722,6 +734,17 @@ extern unsigned char *cpp_quote_string\tPARAMS ((unsigned char *,\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n extern void cpp_make_system_header PARAMS ((cpp_reader *, int, int));\n \n+/* In cpppch.c */\n+struct save_macro_data;\n+extern int cpp_save_state PARAMS ((cpp_reader *, FILE *));\n+extern int cpp_write_pch_deps PARAMS ((cpp_reader *, FILE *));\n+extern int cpp_write_pch_state PARAMS ((cpp_reader *, FILE *));\n+extern int cpp_valid_state PARAMS ((cpp_reader *, const char *, int));\n+extern void cpp_prepare_state PARAMS ((cpp_reader *, \n+\t\t\t\t       struct save_macro_data **));\n+extern int cpp_read_state PARAMS ((cpp_reader *, const char *, FILE *,\n+\t\t\t\t   struct save_macro_data *));\n+\n /* In cppmain.c */\n extern void cpp_preprocess_file PARAMS ((cpp_reader *, const char *, FILE *));\n "}, {"sha": "e7f0c91adfdcd2e863a2a6d2d3ab245dfb45f97e", "filename": "gcc/cpppch.c", "status": "added", "additions": 684, "deletions": 0, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,684 @@\n+/* Part of CPP library.  (Precompiled header reading/writing.)\n+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+#include \"intl.h\"\n+#include \"hashtab.h\"\n+#include \"mkdeps.h\"\n+\n+static int write_macdef PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static int save_idents PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static hashval_t hashmem PARAMS ((const void *, size_t));\n+static hashval_t cpp_string_hash PARAMS ((const void *));\n+static int cpp_string_eq PARAMS ((const void *, const void *));\n+static int count_defs PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static int write_defs PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static int save_macros PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static int reset_ht PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+\n+/* This structure represents a macro definition on disk.  */\n+struct macrodef_struct \n+{\n+  unsigned int definition_length;\n+  unsigned short name_length;\n+  unsigned short flags;\n+};\n+\n+/* This is how we write out a macro definition.  \n+   Suitable for being called by cpp_forall_identifiers.  */\n+\n+static int\n+write_macdef (pfile, hn, file_p)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hn;\n+     void *file_p;\n+{\n+  FILE *f = (FILE *) file_p;\n+  switch (hn->type)\n+    {\n+    case NT_VOID:\n+      if (! (hn->flags & NODE_POISONED))\n+\treturn 1;\n+      \n+    case NT_MACRO:\n+      if ((hn->flags & NODE_BUILTIN))\n+\treturn 1;\n+\n+      {\n+\tstruct macrodef_struct s;\n+\tconst unsigned char *defn;\n+\n+\ts.name_length = NODE_LEN (hn);\n+\ts.flags = hn->flags & NODE_POISONED;\n+\n+\tif (hn->type == NT_MACRO)\n+\t  {\n+\t    defn = cpp_macro_definition (pfile, hn);\n+\t    s.definition_length = ustrlen (defn);\n+\t  }\n+\telse\n+\t  {\n+\t    defn = NODE_NAME (hn);\n+\t    s.definition_length = s.name_length;\n+\t  }\n+\t\n+\tif (fwrite (&s, sizeof (s), 1, f) != 1\n+\t    || fwrite (defn, 1, s.definition_length, f) != s.definition_length)\n+\t  {\n+\t    cpp_errno (pfile, DL_ERROR, \"while writing precompiled header\");\n+\t    return 0;\n+\t  }\n+      }\n+      return 1;\n+      \n+    case NT_ASSERTION:\n+      /* Not currently implemented.  */\n+      return 1;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* This structure records the names of the defined macros.\n+   It's also used as a callback structure for size_initial_idents\n+   and save_idents.  */\n+\n+struct cpp_savedstate\n+{\n+  /* A hash table of the defined identifiers.  */\n+  htab_t definedhash;\n+  /* The size of the definitions of those identifiers (the size of\n+     'definedstrs').  */\n+  size_t hashsize;\n+  /* Space for the next definition.  Definitions are null-terminated\n+     strings.  */\n+  unsigned char *definedstrs;\n+};\n+\n+/* Save this identifier into the state: put it in the hash table,\n+   put the definition in 'definedstrs'.  */\n+\n+static int\n+save_idents (pfile, hn, ss_p)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_hashnode *hn;\n+     void *ss_p;\n+{\n+  struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n+  \n+  if (hn->type != NT_VOID)\n+    {\n+      struct cpp_string news;\n+      void **slot;\n+\n+      news.len = NODE_LEN (hn);\n+      news.text= NODE_NAME (hn);\n+      slot = htab_find_slot (ss->definedhash, &news, INSERT);\n+      if (*slot == NULL)\n+\t{\n+\t  struct cpp_string *sp;\n+\t  unsigned char *text;\n+\t  \n+\t  sp = xmalloc (sizeof (struct cpp_string));\n+\t  *slot = sp;\n+\n+\t  sp->len = NODE_LEN (hn);\n+\t  sp->text = text = xmalloc (NODE_LEN (hn));\n+\t  memcpy (text, NODE_NAME (hn), NODE_LEN (hn));\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+/* Hash some memory in a generic way.  */\n+\n+static hashval_t\n+hashmem (p_p, sz)\n+     const void *p_p;\n+     size_t sz;\n+{\n+  const unsigned char *p = (const unsigned char *)p_p;\n+  size_t i;\n+  hashval_t h;\n+  \n+  h = 0;\n+  for (i = 0; i < sz; i++)\n+    h = h * 67 - (*p++ - 113);\n+  return h;\n+}\n+\n+/* Hash a cpp string for the hashtable machinery.  */\n+\n+static hashval_t\n+cpp_string_hash (a_p)\n+     const void *a_p;\n+{\n+  const struct cpp_string *a = (const struct cpp_string *) a_p;\n+  return hashmem (a->text, a->len);\n+}\n+\n+/* Compare two cpp strings for the hashtable machinery.  */\n+\n+static int\n+cpp_string_eq (a_p, b_p)\n+     const void *a_p;\n+     const void *b_p;\n+{\n+  const struct cpp_string *a = (const struct cpp_string *) a_p;\n+  const struct cpp_string *b = (const struct cpp_string *) b_p;\n+  return (a->len == b->len\n+\t  && memcmp (a->text, b->text, a->len) == 0);\n+}\n+\n+/* Save the current definitions of the cpp_reader for dependency\n+   checking purposes.  When writing a precompiled header, this should\n+   be called at the same point in the compilation as cpp_valid_state\n+   would be called when reading the precompiled header back in.  */\n+\n+int\n+cpp_save_state (r, f)\n+     cpp_reader *r;\n+     FILE *f;\n+{\n+  /* Save the list of non-void identifiers for the dependency checking.  */\n+  r->savedstate = xmalloc (sizeof (struct cpp_savedstate));\n+  r->savedstate->definedhash = htab_create (100, cpp_string_hash, \n+\t\t\t\t\t    cpp_string_eq, NULL);\n+  cpp_forall_identifiers (r, save_idents, r->savedstate);\n+  \n+  /* Write out the list of defined identifiers.  */\n+  cpp_forall_identifiers (r, write_macdef, f);\n+\n+  return 0;\n+}\n+\n+/* Calculate the 'hashsize' field of the saved state.  */\n+\n+static int\n+count_defs (pfile, hn, ss_p)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_hashnode *hn;\n+     void *ss_p;\n+{\n+  struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n+  \n+  switch (hn->type)\n+    {\n+    case NT_MACRO:\n+      if (hn->flags & NODE_BUILTIN)\n+\treturn 1;\n+      \n+      /* else fall through.  */\n+\n+    case NT_VOID:\n+      {\n+\tstruct cpp_string news;\n+\tvoid **slot;\n+\t\n+\tnews.len = NODE_LEN (hn);\n+\tnews.text = NODE_NAME (hn);\n+\tslot = htab_find (ss->definedhash, &news);\n+\tif (slot == NULL)\n+\t  ss->hashsize += NODE_LEN (hn) + 1;\n+      }\n+      return 1;\n+\n+    case NT_ASSERTION:\n+      /* Not currently implemented.  */\n+      return 1;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Write the identifiers into 'definedstrs' of the state.  */\n+\n+static int\n+write_defs (pfile, hn, ss_p)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_hashnode *hn;\n+     void *ss_p;\n+{\n+  struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n+  \n+  switch (hn->type)\n+    {\n+    case NT_MACRO:\n+      if (hn->flags & NODE_BUILTIN)\n+\treturn 1;\n+      \n+      /* else fall through.  */\n+\n+    case NT_VOID:\n+      {\n+\tstruct cpp_string news;\n+\tvoid **slot;\n+\t\n+\tnews.len = NODE_LEN (hn);\n+\tnews.text = NODE_NAME (hn);\n+\tslot = htab_find (ss->definedhash, &news);\n+\tif (slot == NULL)\n+\t  {\n+\t    memcpy (ss->definedstrs, NODE_NAME (hn), NODE_LEN (hn));\n+\t    ss->definedstrs[NODE_LEN (hn)] = 0;\n+\t    ss->definedstrs += NODE_LEN (hn) + 1;\n+\t  }\n+      }\n+      return 1;\n+\n+    case NT_ASSERTION:\n+      /* Not currently implemented.  */\n+      return 1;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Write out the remainder of the dependency information.  This should be\n+   called after the PCH is ready to be saved.  */\n+\n+int\n+cpp_write_pch_deps (r, f)\n+     cpp_reader *r;\n+     FILE *f;\n+{\n+  struct macrodef_struct z;\n+  struct cpp_savedstate *const ss = r->savedstate;\n+  unsigned char *definedstrs;\n+  \n+  ss->hashsize = 0;\n+  \n+  /* Write out the list of identifiers which have been seen and\n+     weren't defined to anything previously.  */\n+  cpp_forall_identifiers (r, count_defs, ss);\n+  definedstrs = ss->definedstrs = xmalloc (ss->hashsize);\n+  cpp_forall_identifiers (r, write_defs, ss);\n+  memset (&z, 0, sizeof (z));\n+  z.definition_length = ss->hashsize;\n+  if (fwrite (&z, sizeof (z), 1, f) != 1\n+      || fwrite (definedstrs, ss->hashsize, 1, f) != 1)\n+    {\n+      cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n+      return -1;\n+    }\n+  free (definedstrs);\n+\n+  /* Free the saved state.  */\n+  free (ss);\n+  r->savedstate = NULL;\n+  return 0;\n+}\n+\n+/* Write out the definitions of the preprocessor, in a form suitable for\n+   cpp_read_state.  */\n+\n+int\n+cpp_write_pch_state (r, f)\n+     cpp_reader *r;\n+     FILE *f;\n+{\n+  struct macrodef_struct z;\n+\n+  /* Write out the list of defined identifiers.  */\n+  cpp_forall_identifiers (r, write_macdef, f);\n+  memset (&z, 0, sizeof (z));\n+  if (fwrite (&z, sizeof (z), 1, f) != 1)\n+    {\n+      cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n+      return -1;\n+    }\n+\n+  if (!r->deps)\n+    r->deps = deps_init ();\n+\n+  if (deps_save (r->deps, f) != 0)\n+    {\n+      cpp_errno (r, DL_ERROR, \"while writing precompiled header\");\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if FD is a precompiled header which is consistent\n+   with the preprocessor's current definitions.  It will be consistent\n+   when:\n+\n+   - anything that was defined just before the PCH was generated \n+     is defined the same way now; and\n+   - anything that was not defined then, but is defined now, was not\n+     used by the PCH.\n+\n+   NAME is used to print warnings if `warn_invalid_pch' is set in the\n+   reader's flags.\n+*/\n+\n+int\n+cpp_valid_state (r, name, fd)\n+     cpp_reader *r;\n+     const char *name;\n+     int fd;\n+{\n+  struct macrodef_struct m;\n+  size_t namebufsz = 256;\n+  unsigned char *namebuf = xmalloc (namebufsz);\n+  unsigned char *undeftab = NULL;\n+  unsigned int i;\n+  \n+  /* Read in the list of identifiers that must be defined\n+     Check that they are defined in the same way.  */\n+  for (;;)\n+    {\n+      cpp_hashnode *h;\n+      const unsigned char *newdefn;\n+      \n+      if (read (fd, &m, sizeof (m)) != sizeof (m))\n+\tgoto error;\n+      \n+      if (m.name_length == 0)\n+\tbreak;\n+\n+      if (m.definition_length > namebufsz)\n+\t{\n+\t  free (namebuf);\n+\t  namebufsz = m.definition_length + 256;\n+\t  namebuf = xmalloc (namebufsz);\n+\t}\n+      \n+      if ((size_t)read (fd, namebuf, m.definition_length) \n+\t  != m.definition_length)\n+\tgoto error;\n+      \n+      h = cpp_lookup (r, namebuf, m.name_length);\n+      if (m.flags & NODE_POISONED\n+\t  || h->type != NT_MACRO\n+\t  || h->flags & NODE_POISONED)\n+\t{\n+\t  if (CPP_OPTION (r, warn_invalid_pch))\n+\t    cpp_error (r, DL_WARNING,\n+\t\t       \"%s: not used because `%.*s' not defined\",\n+\t\t       name, m.name_length, namebuf);\n+\t  goto fail;\n+\t}\n+\n+      newdefn = cpp_macro_definition (r, h);\n+      \n+      if (m.definition_length != ustrlen (newdefn)\n+\t  || memcmp (namebuf, newdefn, m.definition_length) != 0)\n+\t{\n+\t  if (CPP_OPTION (r, warn_invalid_pch))\n+\t    cpp_error (r, DL_WARNING, \n+\t       \"%s: not used because `%.*s' defined as `%s' not `%.*s'\",\n+\t\t       name, m.name_length, namebuf, newdefn + m.name_length,\n+\t\t       m.definition_length - m.name_length,\n+\t\t       namebuf +  m.name_length);\n+\t  goto fail;\n+\t}\n+    }\n+  free (namebuf);\n+  namebuf = NULL;\n+\n+  /* Read in the list of identifiers that must not be defined.\n+     Check that they really aren't.  */\n+  undeftab = xmalloc (m.definition_length);\n+  if ((size_t) read (fd, undeftab, m.definition_length) != m.definition_length)\n+    goto error;\n+  for (i = 0; i < m.definition_length; )\n+    {\n+      int l = ustrlen (undeftab + i);\n+      cpp_hashnode *h;\n+      h = cpp_lookup (r, undeftab + i, l);\n+      if (h->type != NT_VOID\n+\t  || h->flags & NODE_POISONED)\n+\t{\n+\t  if (CPP_OPTION (r, warn_invalid_pch))\n+\t    cpp_error (r, DL_WARNING, \"%s: not used because `%s' is defined\",\n+\t\t       name, undeftab + i);\n+\t  goto fail;\n+\t}\n+      i += l + 1;\n+    }\n+  free (undeftab);\n+\n+  /* We win!  */\n+  return 0;\n+\n+ error:\n+  cpp_errno (r, DL_ERROR, \"while reading precompiled header\");\n+  return -1;\n+\n+ fail:\n+  if (namebuf != NULL)\n+    free (namebuf);\n+  if (undeftab != NULL)\n+    free (undeftab);\n+  return 1;\n+}\n+\n+/* Save all the existing macros and assertions.  \n+   This code assumes that there might be hundreds, but not thousands of\n+   existing definitions.  */\n+\n+struct save_macro_item {\n+  struct save_macro_item *next;\n+  struct cpp_hashnode macs[64];\n+};\n+\n+struct save_macro_data \n+{\n+  struct save_macro_item *macros;\n+  size_t count;\n+  char **saved_pragmas;\n+};\n+\n+/* Save the definition of a single macro, so that it will persist across\n+   a PCH restore.  */\n+\n+static int \n+save_macros (r, h, data_p)\n+     cpp_reader *r ATTRIBUTE_UNUSED;\n+     cpp_hashnode *h;\n+     void *data_p;\n+{\n+  struct save_macro_data *data = (struct save_macro_data *)data_p;\n+  if (h->type != NT_VOID\n+      && (h->flags & NODE_BUILTIN) == 0)\n+    {\n+      cpp_hashnode *save;\n+      if (data->count == ARRAY_SIZE (data->macros->macs))\n+\t{\n+\t  struct save_macro_item *d = data->macros;\n+\t  data->macros = xmalloc (sizeof (struct save_macro_item));\n+\t  data->macros->next = d;\n+\t  data->count = 0;\n+\t}\n+      save = data->macros->macs + data->count;\n+      data->count++;\n+      memcpy (save, h, sizeof (struct cpp_hashnode));\n+      HT_STR (&save->ident) = xmemdup (HT_STR (HT_NODE (save)),\n+\t\t\t\t       HT_LEN (HT_NODE (save)),\n+\t\t\t\t       HT_LEN (HT_NODE (save)) + 1);\n+    }\n+  return 1;\n+}\n+\n+/* Prepare to restore the state, by saving the currently-defined\n+   macros in 'data'.  */\n+\n+void\n+cpp_prepare_state (r, data)\n+     cpp_reader *r;\n+     struct save_macro_data **data;\n+{\n+  struct save_macro_data *d = xmalloc (sizeof (struct save_macro_data));\n+  \n+  d->macros = NULL;\n+  d->count = ARRAY_SIZE (d->macros->macs);\n+  cpp_forall_identifiers (r, save_macros, d);\n+  d->saved_pragmas = _cpp_save_pragma_names (r);\n+  *data = d;\n+}\n+\n+/* Erase all the existing macros and assertions.  */\n+\n+static int \n+reset_ht (r, h, unused)\n+     cpp_reader *r ATTRIBUTE_UNUSED;\n+     cpp_hashnode *h;\n+     void *unused ATTRIBUTE_UNUSED;\n+{\n+  if (h->type != NT_VOID\n+      && (h->flags & NODE_BUILTIN) == 0)\n+    {\n+      h->type = NT_VOID;\n+      memset (&h->value, 0, sizeof (h->value));\n+    }\n+  return 1;\n+}\n+\n+/* Given a precompiled header that was previously determined to be valid,\n+   apply all its definitions (and undefinitions) to the current state. \n+   DEPNAME is passed to deps_restore.  */\n+\n+int\n+cpp_read_state (r, name, f, data)\n+     cpp_reader *r;\n+     const char *name;\n+     FILE *f;\n+     struct save_macro_data *data;\n+{\n+  struct macrodef_struct m;\n+  size_t defnlen = 256;\n+  unsigned char *defn = xmalloc (defnlen);\n+  struct lexer_state old_state;\n+  struct save_macro_item *d;\n+  size_t i, mac_count;\n+  int saved_line = r->line;\n+\n+  /* Erase all the existing hashtable entries for macros.  At this\n+     point, they're all from the PCH file, and their pointers won't be\n+     valid.  */\n+  cpp_forall_identifiers (r, reset_ht, NULL);\n+\n+  /* Restore spec_nodes, which will be full of references to the old \n+     hashtable entries and so will now be invalid.  */\n+  {\n+    struct spec_nodes *s = &r->spec_nodes;\n+    s->n_defined\t= cpp_lookup (r, DSC(\"defined\"));\n+    s->n_true\t\t= cpp_lookup (r, DSC(\"true\"));\n+    s->n_false\t\t= cpp_lookup (r, DSC(\"false\"));\n+    s->n__VA_ARGS__     = cpp_lookup (r, DSC(\"__VA_ARGS__\"));\n+  }\n+\n+  /* Run through the carefully-saved macros, insert them.  */\n+  d = data->macros;\n+  mac_count = data->count;\n+  while (d)\n+    {\n+      struct save_macro_item *nextd;\n+      for (i = 0; i < mac_count; i++)\n+\t{\n+\t  cpp_hashnode *h;\n+\t  \n+\t  h = cpp_lookup (r, HT_STR (HT_NODE (&d->macs[i])), \n+\t\t\t  HT_LEN (HT_NODE (&d->macs[i])));\n+\t  h->type = d->macs[i].type;\n+\t  h->flags = d->macs[i].flags;\n+\t  h->value = d->macs[i].value;\n+\t  free ((void *)HT_STR (HT_NODE (&d->macs[i])));\n+\t}\n+      nextd = d->next;\n+      free (d);\n+      d = nextd;\n+      mac_count = ARRAY_SIZE (d->macs);\n+    }\n+\n+  _cpp_restore_pragma_names (r, data->saved_pragmas);\n+\n+  free (data);\n+\n+  old_state = r->state;\n+\n+  r->state.in_directive = 1;\n+  r->state.prevent_expansion = 1;\n+  r->state.angled_headers = 0;\n+\n+  /* Read in the identifiers that must be defined.  */\n+  for (;;)\n+    {\n+      cpp_hashnode *h;\n+      \n+      if (fread (&m, sizeof (m), 1, f) != 1)\n+\tgoto error;\n+      \n+      if (m.name_length == 0)\n+\tbreak;\n+\n+      if (defnlen < m.definition_length + 1)\n+\t{\n+\t  defnlen = m.definition_length + 256;\n+\t  defn = xrealloc (defn, defnlen);\n+\t}\n+\n+      if (fread (defn, 1, m.definition_length, f) != m.definition_length)\n+\tgoto error;\n+      defn[m.definition_length] = '\\0';\n+      \n+      h = cpp_lookup (r, defn, m.name_length);\n+\n+      if (h->type == NT_MACRO)\n+\t_cpp_free_definition (h);\n+      if (m.flags & NODE_POISONED)\n+\th->flags |= NODE_POISONED | NODE_DIAGNOSTIC;\n+      else if (m.name_length != m.definition_length)\n+\t{\n+\t  if (cpp_push_buffer (r, defn + m.name_length, \n+\t\t\t       m.definition_length - m.name_length, \n+\t\t\t       true, 1) != NULL)\n+\t    {\n+\t      if (!_cpp_create_definition (r, h))\n+\t\tabort ();\n+\t      _cpp_pop_buffer (r);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+\n+  r->state = old_state;\n+  r->line = saved_line;\n+  free (defn);\n+  defn = NULL;\n+\n+  if (deps_restore (r->deps, f, CPP_OPTION (r, restore_pch_deps) ? name : NULL)\n+      != 0)\n+    goto error;\n+\n+  return 0;\n+  \n+ error:\n+  cpp_errno (r, DL_ERROR, \"while reading precompiled header\");\n+  return -1;\n+}"}, {"sha": "480ef821b70c48d855f88ef448672a9d0eb26937", "filename": "gcc/dbxout.c", "status": "modified", "additions": 66, "deletions": 73, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -137,57 +137,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define STABS_GCC_MARKER \"gcc2_compiled.\"\n #endif\n \n-/* Typical USG systems don't have stab.h, and they also have\n-   no use for DBX-format debugging info.  */\n-\n-#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n-\n-/* Nonzero if we have actually used any of the GDB extensions\n-   to the debugging format.  The idea is that we use them for the\n-   first time only if there's a strong reason, but once we have done that,\n-   we use them whenever convenient.  */\n-\n-static int have_used_extensions = 0;\n-\n-/* Number for the next N_SOL filename stabs label.  The number 0 is reserved\n-   for the N_SO filename stabs label.  */\n-\n-#if defined (DBX_DEBUGGING_INFO) && !defined (DBX_OUTPUT_SOURCE_FILENAME)\n-static int source_label_number = 1;\n-#endif\n-\n-#ifdef DEBUG_SYMS_TEXT\n-#define FORCE_TEXT function_section (current_function_decl);\n-#else\n-#define FORCE_TEXT\n-#endif\n-\n-#include \"gstab.h\"\n-\n-#define STAB_CODE_TYPE enum __stab_debug_code\n-\n-/* 1 if PARM is passed to this function in memory.  */\n-\n-#define PARM_PASSED_IN_MEMORY(PARM) \\\n- (GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)\n-\n-/* A C expression for the integer offset value of an automatic variable\n-   (N_LSYM) having address X (an RTX).  */\n-#ifndef DEBUGGER_AUTO_OFFSET\n-#define DEBUGGER_AUTO_OFFSET(X) \\\n-  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n-#endif\n-\n-/* A C expression for the integer offset value of an argument (N_PSYM)\n-   having address X (an RTX).  The nominal offset is OFFSET.  */\n-#ifndef DEBUGGER_ARG_OFFSET\n-#define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n-#endif\n-\n-/* Stream for writing to assembler file.  */\n-\n-static FILE *asmfile;\n-\n /* Last source file name mentioned in a NOTE insn.  */\n \n static const char *lastfile;\n@@ -205,39 +154,35 @@ enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};\n    The file_number and type_number elements are used if DBX_USE_BINCL\n    is defined.  */\n \n-struct typeinfo\n+struct typeinfo GTY(())\n {\n   enum typestatus status;\n-#ifdef DBX_USE_BINCL\n   int file_number;\n   int type_number;\n-#endif\n };\n \n /* Vector recording information about C data types.\n    When we first notice a data type (a tree node),\n    we assign it a number using next_type_number.\n    That is its index in this vector.  */\n \n-struct typeinfo *typevec;\n+static GTY ((length (\"typevec_len\"))) struct typeinfo *typevec;\n \n /* Number of elements of space allocated in `typevec'.  */\n \n-static int typevec_len;\n+static GTY(()) int typevec_len;\n \n /* In dbx output, each type gets a unique number.\n    This is the number for the next type output.\n    The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */\n \n-static int next_type_number;\n-\n-#ifdef DBX_USE_BINCL\n+static GTY(()) int next_type_number;\n \n /* When using N_BINCL in dbx output, each type number is actually a\n    pair of the file number and the type number within the file.\n    This is a stack of input files.  */\n \n-struct dbx_file\n+struct dbx_file GTY(())\n {\n   struct dbx_file *next;\n   int file_number;\n@@ -246,13 +191,62 @@ struct dbx_file\n \n /* This is the top of the stack.  */\n \n-static struct dbx_file *current_file;\n+static GTY(()) struct dbx_file *current_file;\n \n /* This is the next file number to use.  */\n \n-static int next_file_number;\n+static GTY(()) int next_file_number;\n+\n+/* Typical USG systems don't have stab.h, and they also have\n+   no use for DBX-format debugging info.  */\n+\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+\n+/* Nonzero if we have actually used any of the GDB extensions\n+   to the debugging format.  The idea is that we use them for the\n+   first time only if there's a strong reason, but once we have done that,\n+   we use them whenever convenient.  */\n+\n+static int have_used_extensions = 0;\n+\n+/* Number for the next N_SOL filename stabs label.  The number 0 is reserved\n+   for the N_SO filename stabs label.  */\n+\n+#if defined (DBX_DEBUGGING_INFO) && !defined (DBX_OUTPUT_SOURCE_FILENAME)\n+static int source_label_number = 1;\n+#endif\n+\n+#ifdef DEBUG_SYMS_TEXT\n+#define FORCE_TEXT function_section (current_function_decl);\n+#else\n+#define FORCE_TEXT\n+#endif\n+\n+#include \"gstab.h\"\n+\n+#define STAB_CODE_TYPE enum __stab_debug_code\n+\n+/* 1 if PARM is passed to this function in memory.  */\n+\n+#define PARM_PASSED_IN_MEMORY(PARM) \\\n+ (GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)\n \n-#endif /* DBX_USE_BINCL */\n+/* A C expression for the integer offset value of an automatic variable\n+   (N_LSYM) having address X (an RTX).  */\n+#ifndef DEBUGGER_AUTO_OFFSET\n+#define DEBUGGER_AUTO_OFFSET(X) \\\n+  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n+#endif\n+\n+/* A C expression for the integer offset value of an argument (N_PSYM)\n+   having address X (an RTX).  The nominal offset is OFFSET.  */\n+#ifndef DEBUGGER_ARG_OFFSET\n+#define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n+#endif\n+\n+/* Stream for writing to assembler file.  */\n+\n+static FILE *asmfile;\n \n /* These variables are for dbxout_symbol to communicate to\n    dbxout_finish_symbol.\n@@ -425,7 +419,7 @@ dbxout_init (input_file_name)\n   asmfile = asm_out_file;\n \n   typevec_len = 100;\n-  typevec = (struct typeinfo *) xcalloc (typevec_len, sizeof typevec[0]);\n+  typevec = (struct typeinfo *) ggc_calloc (typevec_len, sizeof typevec[0]);\n \n   /* Convert Ltext into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n@@ -484,7 +478,7 @@ dbxout_init (input_file_name)\n   next_type_number = 1;\n \n #ifdef DBX_USE_BINCL\n-  current_file = (struct dbx_file *) xmalloc (sizeof *current_file);\n+  current_file = (struct dbx_file *) ggc_alloc (sizeof *current_file);\n   current_file->next = NULL;\n   current_file->file_number = 0;\n   current_file->next_type_number = 1;\n@@ -541,7 +535,7 @@ dbxout_start_source_file (line, filename)\n      const char *filename ATTRIBUTE_UNUSED;\n {\n #ifdef DBX_USE_BINCL\n-  struct dbx_file *n = (struct dbx_file *) xmalloc (sizeof *n);\n+  struct dbx_file *n = (struct dbx_file *) ggc_alloc (sizeof *n);\n \n   n->next = current_file;\n   n->file_number = next_file_number++;\n@@ -560,12 +554,8 @@ dbxout_end_source_file (line)\n      unsigned int line ATTRIBUTE_UNUSED;\n {\n #ifdef DBX_USE_BINCL\n-  struct dbx_file *next;\n-\n   fprintf (asmfile, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n-  next = current_file->next;\n-  free (current_file);\n-  current_file = next;\n+  current_file = current_file->next;\n #endif\n }\n \n@@ -1149,8 +1139,9 @@ dbxout_type (type, full)\n       if (next_type_number == typevec_len)\n \t{\n \t  typevec\n-\t    = (struct typeinfo *) xrealloc (typevec,\n-\t\t\t\t\t    typevec_len * 2 * sizeof typevec[0]);\n+\t    = (struct typeinfo *) ggc_realloc (typevec,\n+\t\t\t\t\t       (typevec_len * 2 \n+\t\t\t\t\t\t* sizeof typevec[0]));\n \t  memset ((char *) (typevec + typevec_len), 0,\n \t\t typevec_len * sizeof typevec[0]);\n \t  typevec_len *= 2;\n@@ -3008,3 +2999,5 @@ dbxout_begin_function (decl)\n #endif /* DBX_DEBUGGING_INFO */\n \n #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n+\n+#include \"gt-dbxout.h\""}, {"sha": "95311a86d4e7b1d2c2d8d397a7da3cc7544f86e0", "filename": "gcc/doc/cppopts.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Fcppopts.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Fcppopts.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppopts.texi?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -301,6 +301,17 @@ a dependency output file as a side-effect of the compilation process.\n Like @option{-MD} except mention only user header files, not system\n -header files.\n \n+@ifclear cppmanual\n+@item -fpch-deps\n+@opindex fpch-deps\n+When using precompiled headers (@pxref{Precompiled Headers}), this flag\n+will cause the dependency-output flags to also list the files from the\n+precompiled header's dependencies.  If not specified only the\n+precompiled header would be listed and not the files that were used to\n+create it because those files are not consulted when a precompiled\n+header is used.\n+\n+@end ifclear\n @item -x c\n @itemx -x c++\n @itemx -x objective-c"}, {"sha": "ed7d3d2c1a13d88655032a9552491d978e1cf829", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -10,7 +10,8 @@\n \n GCC uses some fairly sophisticated memory management techniques, which\n involve determining information about GCC's data structures from GCC's\n-source code and using this information to perform garbage collection.\n+source code and using this information to perform garbage collection and\n+implement precompiled headers.\n \n A full C parser would be too overcomplicated for this task, so a limited\n subset of C is interpreted and special markers are used to determine\n@@ -227,6 +228,39 @@ this field is always @code{NULL}.  This is used to avoid requiring\n backends to define certain optional structures.  It doesn't work with\n language frontends.\n \n+@findex chain_next\n+@findex chain_prev\n+@item chain_next\n+@itemx chain_prev\n+\n+It's helpful for the type machinery to know if objects are often\n+chained together in long lists; this lets it generate code that uses\n+less stack space by iterating along the list instead of recursing down\n+it.  @code{chain_next} is an expression for the next item in the list,\n+@code{chain_prev} is an expression for the previous item.  The\n+machinery requires that taking the next item of the previous item\n+gives the original item.\n+\n+@findex reorder\n+@item reorder\n+\n+Some data structures depend on the relative ordering of pointers.  If\n+the type machinery needs to change that ordering, it will call the\n+function referenced by the @code{reorder} option, before changing the\n+pointers in the object that's pointed to by the field the option\n+applies to.  The function must be of the type @code{void ()(void *,\n+void *, gt_pointer_operator, void *)}.  The second parameter is the\n+pointed-to object; the third parameter is a routine that, given a\n+pointer, can update it to its new value.  The fourth parameter is a\n+cookie to be passed to the third parameter.  The first parameter is\n+the structure that contains the object, or the object itself if it is\n+a structure.\n+\n+No data structure may depend on the absolute value of pointers.  Even\n+relying on relative orderings and using @code{reorder} functions can\n+be expensive.  It is better to depend on properties of the data, like\n+an ID number or the hash of a string instead.\n+\n @findex special\n @item special\n "}, {"sha": "bfbdd3ebbc2cefbd79eadfa145b8476968776f02", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 122, "deletions": 12, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -141,6 +141,7 @@ only one of these two forms, whichever one is not the default.\n * Code Gen Options::    Specifying conventions for function calls, data layout\n                         and register usage.\n * Environment Variables:: Env vars that affect GCC.\n+* Precompiled Headers:: Compiling a header once, and using it many times.\n * Running Protoize::    Automatically adding or removing function prototypes.\n @end menu\n \n@@ -220,7 +221,7 @@ in the following sections.\n -Wimplicit  -Wimplicit-int  @gol\n -Wimplicit-function-declaration @gol\n -Werror-implicit-function-declaration @gol\n--Wimport  -Winline -Wno-endif-labels @gol\n+-Wimport  -Winline  -Winvalid-pch  -Wno-endif-labels @gol\n -Wlarger-than-@var{len}  -Wlong-long @gol\n -Wmain  -Wmissing-braces @gol\n -Wmissing-format-attribute  -Wmissing-noreturn @gol\n@@ -767,7 +768,7 @@ Objective-C source code.  Note that you must link with the library\n Objective-C source code which should not be preprocessed.\n \n @item @var{file}.h\n-C header file (not to be compiled or linked).\n+C or C++ header file to be turned into a precompiled header.\n \n @item @var{file}.cc\n @itemx @var{file}.cp\n@@ -780,6 +781,10 @@ C++ source code which must be preprocessed.  Note that in @samp{.cxx},\n the last two letters must both be literally @samp{x}.  Likewise,\n @samp{.C} refers to a literal capital C@.\n \n+@item @var{file}.hh\n+@itemx @var{file}.H\n+C++ header file to be turned into a precompiled header.\n+\n @item @var{file}.f\n @itemx @var{file}.for\n @itemx @var{file}.FOR\n@@ -843,7 +848,7 @@ name suffix).  This option applies to all following input files until\n the next @option{-x} option.  Possible values for @var{language} are:\n @example\n c  c-header  cpp-output\n-c++  c++-cpp-output\n+c++  c++-header  c++-cpp-output\n objective-c  objc-cpp-output\n assembler  assembler-with-cpp\n ada\n@@ -965,22 +970,24 @@ Display the version number and copyrights of the invoked GCC.\n @cindex suffixes for C++ source\n @cindex C++ source file suffixes\n C++ source files conventionally use one of the suffixes @samp{.C},\n-@samp{.cc}, @samp{.cpp}, @samp{.CPP}, @samp{.c++}, @samp{.cp}, or @samp{.cxx};\n+@samp{.cc}, @samp{.cpp}, @samp{.CPP}, @samp{.c++}, @samp{.cp}, or\n+@samp{.cxx}; C++ header files often use @samp{.hh} or @samp{.H}; and\n preprocessed C++ files use the suffix @samp{.ii}.  GCC recognizes\n files with these names and compiles them as C++ programs even if you\n-call the compiler the same way as for compiling C programs (usually with\n-the name @command{gcc}).\n+call the compiler the same way as for compiling C programs (usually\n+with the name @command{gcc}).\n \n @findex g++\n @findex c++\n However, C++ programs often require class libraries as well as a\n compiler that understands the C++ language---and under some\n-circumstances, you might want to compile programs from standard input,\n-or otherwise without a suffix that flags them as C++ programs.\n-@command{g++} is a program that calls GCC with the default language\n-set to C++, and automatically specifies linking against the C++\n-library.  On many systems, @command{g++} is also\n-installed with the name @command{c++}.\n+circumstances, you might want to compile programs or header files from\n+standard input, or otherwise without a suffix that flags them as C++\n+programs.  You might also like to precompile a C header file with a\n+@samp{.h} extension to be used in C++ compilations.  @command{g++} is a\n+program that calls GCC with the default language set to C++, and\n+automatically specifies linking against the C++ library.  On many\n+systems, @command{g++} is also installed with the name @command{c++}.\n \n @cindex invoking @command{g++}\n When you compile C++ programs, you may specify many of the same\n@@ -2800,6 +2807,11 @@ code is to provide behavior which is selectable at compile-time.\n @opindex Winline\n Warn if a function can not be inlined and it was declared as inline.\n \n+@item -Winvalid-pch\n+@opindex Winvalid-pch\n+Warn if a precompiled header (@pxref{Precompiled Headers}) is found in\n+the search path but can't be used.\n+\n @item -Wlong-long\n @opindex Wlong-long\n @opindex Wno-long-long\n@@ -10924,6 +10936,104 @@ preprocessor.\n \n @c man end\n \n+@node Precompiled Headers\n+@section Using Precompiled Headers\n+@cindex precompiled headers\n+@cindex speed of compilation\n+\n+Often large projects have many header files that are included in every\n+source file.  The time the compiler takes to process these header files\n+over and over again can account for nearly all of the time required to\n+build the project.  To make builds faster, GCC allows users to\n+`precompile' a header file; then, if builds can use the precompiled\n+header file they will be much faster.\n+\n+To create a precompiled header file, simply compile it as you would any\n+other file, if necessary using the @option{-x} option to make the driver\n+treat it as a C or C++ header file.  You will probably want to use a\n+tool like @command{make} to keep the precompiled header up-to-date when\n+the headers it contains change.\n+\n+A precompiled header file will be searched for when @code{#include} is\n+seen in the compilation.  As it searches for the included file\n+(@pxref{Search Path,,Search Path,cpp.info,The C Preprocessor}) the\n+compiler looks for a precompiled header in each directory just before it\n+looks for the include file in that directory.  The name searched for is\n+the name specified in the @code{#include} with @samp{.pch} appended.  If\n+the precompiled header file can't be used, it is ignored.\n+\n+For instance, if you have @code{#include \"all.h\"}, and you have\n+@file{all.h.pch} in the same directory as @file{all.h}, then the\n+precompiled header file will be used if possible, and the original\n+header will be used otherwise.\n+\n+Alternatively, you might decide to put the precompiled header file in a\n+directory and use @option{-I} to ensure that directory is searched\n+before (or instead of) the directory containing the original header.\n+Then, if you want to check that the precompiled header file is always\n+used, you can put a file of the same name as the original header in this\n+directory containing an @code{#error} command.\n+\n+This also works with @option{-include}.  So yet another way to use\n+precompiled headers, good for projects not designed with precompiled\n+header files in mind, is to simply take most of the header files used by\n+a project, include them from another header file, precompile that header\n+file, and @option{-include} the precompiled header.  If the header files\n+have guards against multiple inclusion, they will be skipped because\n+they've already been included (in the precompiled header).\n+\n+If you need to precompile the same header file for different\n+languages, targets, or compiler options, you can instead make a\n+@emph{directory} named like @file{all.h.pch}, and put each precompiled\n+header in the directory.  (It doesn't matter what you call the files\n+in the directory, every precompiled header in the directory will be\n+considered.)  The first precompiled header encountered in the\n+directory that is valid for this compilation will be used; they're\n+searched in no particular order.\n+\n+There are many other possibilities, limited only by your imagination,\n+good sense, and the constraints of your build system.\n+\n+A precompiled header file can be used only when these conditions apply:\n+\n+@itemize\n+@item\n+Only one precompiled header can be used in a particular compilation.\n+@item\n+A precompiled header can't be used once the first C token is seen.  You\n+can have preprocessor directives before a precompiled header; you can\n+even include a precompiled header from inside another header, so long as\n+there are no C tokens before the @code{#include}.\n+@item\n+The precompiled header file must be produced for the same language as\n+the current compilation.  You can't use a C precompiled header for a C++\n+compilation.\n+@item\n+The precompiled header file must be produced by the same compiler\n+version and configuration as the current compilation is using.\n+The easiest way to guarantee this is to use the same compiler binary\n+for creating and using precompiled headers.\n+@item\n+Any macros defined before the precompiled header (including with\n+@option{-D}) must either be defined in the same way as when the\n+precompiled header was generated, or must not affect the precompiled\n+header, which usually means that the they don't appear in the\n+precompiled header at all.\n+@item\n+Certain command-line options must be defined in the same way as when the\n+precompiled header was generated.  At present, it's not clear which\n+options are safe to change and which are not; the safest choice is to\n+use exactly the same options when generating and using the precompiled\n+header.\n+@end itemize\n+\n+For all of these but the last, the compiler will automatically ignore\n+the precompiled header if the conditions aren't met.  For the last item,\n+some option changes will cause the precompiled header to be rejected,\n+but not all incompatible option combinations have yet been found.  If\n+you find a new incompatible combination, please consider filing a bug\n+report, see @ref{Bugs}.\n+\n @node Running Protoize\n @section Running Protoize\n "}, {"sha": "8a96a6924619534505e5b08377690062ba24f330", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2002,\n @c 1999, 2000, 2001 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -73,54 +73,22 @@ performed by cpplib, which is covered in separate documentation.  In\n particular, the internals are covered in @xref{Top, ,Cpplib internals,\n cppinternals, Cpplib Internals}.\n \n-@c Avoiding overfull is tricky here.\n-The source files to parse C are\n-@file{c-convert.c},\n-@file{c-decl.c},\n-@file{c-errors.c},\n-@file{c-lang.c},\n-@file{c-objc-common.c},\n-@file{c-parse.in},\n-@file{c-aux-info.c},\n-and\n-@file{c-typeck.c},\n-along with a header file\n-@file{c-tree.h}\n-and some files shared with Objective-C and C++.\n-\n-The source files for parsing C++ are in @file{cp/}.\n-They are @file{parse.y},\n-@file{class.c},\n-@file{cvt.c}, @file{decl.c}, @file{decl2.c},\n-@file{except.c},\n-@file{expr.c}, @file{init.c}, @file{lex.c},\n-@file{method.c}, @file{ptree.c},\n-@file{search.c}, @file{spew.c},\n-@file{semantics.c}, @file{tree.c},\n-@file{typeck2.c}, and\n-@file{typeck.c}, along with header files @file{cp-tree.def},\n-@file{cp-tree.h}, and @file{decl.h}.\n-\n-The special source files for parsing Objective-C are in @file{objc/}.\n-They are @file{objc-act.c}, @file{objc-tree.def}, and @file{objc-act.h}.\n-Certain C-specific files are used for this as well.\n-\n-The files\n-@file{c-common.c},\n+The source files to parse C are found in the toplevel directory, and\n+by convention are named @file{c-*}.  Some of these are also used by\n+the other C-like languages: @file{c-common.c},\n @file{c-common.def},\n @file{c-format.c},\n @file{c-opts.c},\n @file{c-pragma.c},\n @file{c-semantics.c},\n-and\n @file{c-lex.c},\n-along with header files\n @file{c-common.h},\n @file{c-dump.h},\n and\n @file{c-pragma.h},\n-are also used for all of the above languages.\n \n+Files specific to each language are in subdirectories named after the\n+language in question, like @file{ada}, @file{objc}, @file{cp} (for C++).\n \n @cindex Tree optimization\n @item"}, {"sha": "396c2cdd3557f33455fe46aac992d9a390b300f8", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -688,39 +688,19 @@ dw2_asm_output_delta_sleb128 VPARAMS ((const char *lab1 ATTRIBUTE_UNUSED,\n   VA_CLOSE (ap);\n }\n \f\n-static int mark_indirect_pool_entry PARAMS ((splay_tree_node, void *));\n-static void mark_indirect_pool PARAMS ((PTR arg));\n static rtx dw2_force_const_mem PARAMS ((rtx));\n static int dw2_output_indirect_constant_1 PARAMS ((splay_tree_node, void *));\n \n-static splay_tree indirect_pool;\n+static GTY((param1_is (char *), param2_is (tree))) splay_tree indirect_pool;\n+\n+static GTY(()) int dw2_const_labelno;\n \n #if defined(HAVE_GAS_HIDDEN) && defined(SUPPORTS_ONE_ONLY)\n # define USE_LINKONCE_INDIRECT 1\n #else\n # define USE_LINKONCE_INDIRECT 0\n #endif\n \n-/* Mark all indirect constants for GC.  */\n-\n-static int\n-mark_indirect_pool_entry (node, data)\n-     splay_tree_node node;\n-     void* data ATTRIBUTE_UNUSED;\n-{\n-  ggc_mark_tree ((tree) node->value);\n-  return 0;\n-}\n-\n-/* Mark all indirect constants for GC.  */\n-\n-static void\n-mark_indirect_pool (arg)\n-     PTR arg ATTRIBUTE_UNUSED;\n-{\n-  splay_tree_foreach (indirect_pool, mark_indirect_pool_entry, NULL);\n-}\n-\n /* Put X, a SYMBOL_REF, in memory.  Return a SYMBOL_REF to the allocated\n    memory.  Differs from force_const_mem in that a single pool is used for\n    the entire unit of translation, and the memory is not guaranteed to be\n@@ -735,10 +715,7 @@ dw2_force_const_mem (x)\n   tree decl;\n \n   if (! indirect_pool)\n-    {\n-      indirect_pool = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n-      ggc_add_root (&indirect_pool, 1, sizeof indirect_pool, mark_indirect_pool);\n-    }\n+    indirect_pool = splay_tree_new_ggc (splay_tree_compare_pointers);\n \n   if (GET_CODE (x) != SYMBOL_REF)\n     abort ();\n@@ -765,11 +742,10 @@ dw2_force_const_mem (x)\n \t}\n       else\n \t{\n-\t  extern int const_labelno;\n \t  char label[32];\n \n-\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n-\t  ++const_labelno;\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LDFCM\", dw2_const_labelno);\n+\t  ++dw2_const_labelno;\n \t  id = get_identifier (label);\n \t  decl = build_decl (VAR_DECL, id, ptr_type_node);\n \t  DECL_ARTIFICIAL (decl) = 1;\n@@ -906,3 +882,5 @@ dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n \n   VA_CLOSE (ap);\n }\n+\n+#include \"gt-dwarf2asm.h\""}, {"sha": "38d340025330ff32db0e35c270ae83da1f7fa60f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 281, "deletions": 207, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -63,7 +63,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"debug.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n-#include \"hashtable.h\"\n #include \"hashtab.h\"\n \n #ifdef DWARF2_DEBUGGING_INFO\n@@ -163,8 +162,6 @@ static GTY(()) varray_type incomplete_types;\n    define type declaration DIE's.  */\n static GTY(()) varray_type decl_scope_table;\n \n-#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n-\n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n #define ASM_COMMENT_START \";#\"\n@@ -179,21 +176,31 @@ typedef union  dw_cfi_oprnd_struct *dw_cfi_oprnd_ref;\n    and address fields are provided as possible operands;\n    their use is selected by the opcode field.  */\n \n-typedef union dw_cfi_oprnd_struct\n+enum dw_cfi_oprnd_type {\n+  dw_cfi_oprnd_unused,\n+  dw_cfi_oprnd_reg_num,\n+  dw_cfi_oprnd_offset,\n+  dw_cfi_oprnd_addr,\n+  dw_cfi_oprnd_loc\n+};\n+\n+typedef union dw_cfi_oprnd_struct GTY(())\n {\n-  unsigned long dw_cfi_reg_num;\n-  long int dw_cfi_offset;\n-  const char *dw_cfi_addr;\n-  struct dw_loc_descr_struct *dw_cfi_loc;\n+  unsigned long GTY ((tag (\"dw_cfi_oprnd_reg_num\"))) dw_cfi_reg_num;\n+  long int GTY ((tag (\"dw_cfi_oprnd_offset\"))) dw_cfi_offset;\n+  const char * GTY ((tag (\"dw_cfi_oprnd_addr\"))) dw_cfi_addr;\n+  struct dw_loc_descr_struct * GTY ((tag (\"dw_cfi_oprnd_loc\"))) dw_cfi_loc;\n }\n dw_cfi_oprnd;\n \n-typedef struct dw_cfi_struct\n+typedef struct dw_cfi_struct GTY(())\n {\n   dw_cfi_ref dw_cfi_next;\n   enum dwarf_call_frame_info dw_cfi_opc;\n-  dw_cfi_oprnd dw_cfi_oprnd1;\n-  dw_cfi_oprnd dw_cfi_oprnd2;\n+  dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd1_desc (%1.dw_cfi_opc)\"))) \n+    dw_cfi_oprnd1;\n+  dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd2_desc (%1.dw_cfi_opc)\"))) \n+    dw_cfi_oprnd2;\n }\n dw_cfi_node;\n \n@@ -202,7 +209,7 @@ dw_cfi_node;\n    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n    Instead of passing around REG and OFFSET, we pass a copy\n    of this structure.  */\n-typedef struct cfa_loc\n+typedef struct cfa_loc GTY(())\n {\n   unsigned long reg;\n   long offset;\n@@ -216,7 +223,7 @@ typedef struct cfa_loc\n    CIE obviates the need to keep track of multiple CIE's\n    in the DWARF generation routines below.  */\n \n-typedef struct dw_fde_struct\n+typedef struct dw_fde_struct GTY(())\n {\n   const char *dw_fde_begin;\n   const char *dw_fde_current_label;\n@@ -267,7 +274,7 @@ dw_fde_node;\n \n /* A pointer to the base of a table that contains frame description\n    information for each routine.  */\n-static dw_fde_ref fde_table;\n+static GTY((length (\"fde_table_allocated\"))) dw_fde_ref fde_table;\n \n /* Number of elements currently allocated for fde_table.  */\n static unsigned fde_table_allocated;\n@@ -280,24 +287,28 @@ static unsigned fde_table_in_use;\n #define FDE_TABLE_INCREMENT 256\n \n /* A list of call frame insns for the CIE.  */\n-static dw_cfi_ref cie_cfi_head;\n+static GTY(()) dw_cfi_ref cie_cfi_head;\n \n /* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram\n    attribute that accelerates the lookup of the FDE associated\n    with the subprogram.  This variable holds the table index of the FDE\n    associated with the current function (body) definition.  */\n static unsigned current_funcdef_fde;\n \n-struct ht *debug_str_hash;\n-\n-struct indirect_string_node\n+struct indirect_string_node GTY(())\n {\n-  struct ht_identifier id;\n+  const char *str;\n   unsigned int refcount;\n   unsigned int form;\n   char *label;\n };\n \n+static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;\n+\n+static GTY(()) int dw2_string_counter;\n+\n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n+\n /* Forward declarations for functions defined in this file.  */\n \n static char *stripattributes\t\tPARAMS ((const char *));\n@@ -313,6 +324,10 @@ static void reg_save\t\t\tPARAMS ((const char *, unsigned,\n static void initial_return_save\t\tPARAMS ((rtx));\n static long stack_adjust_offset\t\tPARAMS ((rtx));\n static void output_cfi\t\t\tPARAMS ((dw_cfi_ref, dw_fde_ref, int));\n+static enum dw_cfi_oprnd_type dw_cfi_oprnd1_desc \n+   PARAMS ((enum dwarf_call_frame_info cfi));\n+static enum dw_cfi_oprnd_type dw_cfi_oprnd2_desc \n+   PARAMS ((enum dwarf_call_frame_info cfi));\n static void output_call_frame_info\tPARAMS ((int));\n static void dwarf2out_stack_adjust\tPARAMS ((rtx));\n static void queue_reg_save\t\tPARAMS ((const char *, rtx, long));\n@@ -515,7 +530,7 @@ dwarf_cfi_name (cfi_opc)\n static inline dw_cfi_ref\n new_cfi ()\n {\n-  dw_cfi_ref cfi = (dw_cfi_ref) xmalloc (sizeof (dw_cfi_node));\n+  dw_cfi_ref cfi = (dw_cfi_ref) ggc_alloc (sizeof (dw_cfi_node));\n \n   cfi->dw_cfi_next = NULL;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n@@ -1086,18 +1101,22 @@ dwarf2out_stack_adjust (insn)\n   dwarf2out_args_size (label, args_size);\n }\n \n+#endif\n+\n /* We delay emitting a register save until either (a) we reach the end\n    of the prologue or (b) the register is clobbered.  This clusters\n    register saves so that there are fewer pc advances.  */\n \n-struct queued_reg_save\n+struct queued_reg_save GTY(())\n {\n   struct queued_reg_save *next;\n   rtx reg;\n   long cfa_offset;\n };\n \n-static struct queued_reg_save *queued_reg_saves;\n+static GTY(()) struct queued_reg_save *queued_reg_saves;\n+\n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n static const char *last_reg_save_label;\n \n static void\n@@ -1106,7 +1125,7 @@ queue_reg_save (label, reg, offset)\n      rtx reg;\n      long offset;\n {\n-  struct queued_reg_save *q = (struct queued_reg_save *) xmalloc (sizeof (*q));\n+  struct queued_reg_save *q = ggc_alloc (sizeof (*q));\n \n   q->next = queued_reg_saves;\n   q->reg = reg;\n@@ -1125,7 +1144,6 @@ flush_queued_reg_saves ()\n     {\n       dwarf2out_reg_save (last_reg_save_label, REGNO (q->reg), q->cfa_offset);\n       next = q->next;\n-      free (q);\n     }\n \n   queued_reg_saves = NULL;\n@@ -1678,6 +1696,78 @@ dwarf2out_frame_debug (insn)\n   dwarf2out_frame_debug_expr (insn, label);\n }\n \n+#endif\n+\n+/* Describe for the GTY machinery what parts of dw_cfi_oprnd1 are used.  */\n+\n+static enum dw_cfi_oprnd_type\n+dw_cfi_oprnd1_desc (cfi)\n+     enum dwarf_call_frame_info cfi;\n+{\n+  switch (cfi)\n+    {\n+    case DW_CFA_nop:\n+    case DW_CFA_GNU_window_save:\n+      return dw_cfi_oprnd_unused;\n+\n+    case DW_CFA_set_loc:\n+    case DW_CFA_advance_loc1:\n+    case DW_CFA_advance_loc2:\n+    case DW_CFA_advance_loc4:\n+    case DW_CFA_MIPS_advance_loc8:\n+      return dw_cfi_oprnd_addr;\n+\n+    case DW_CFA_offset:\n+    case DW_CFA_offset_extended:\n+    case DW_CFA_def_cfa:\n+    case DW_CFA_offset_extended_sf:\n+    case DW_CFA_def_cfa_sf:\n+    case DW_CFA_restore_extended:\n+    case DW_CFA_undefined:\n+    case DW_CFA_same_value:\n+    case DW_CFA_def_cfa_register:\n+    case DW_CFA_register:\n+      return dw_cfi_oprnd_reg_num;\n+\n+    case DW_CFA_def_cfa_offset:\n+    case DW_CFA_GNU_args_size:\n+    case DW_CFA_def_cfa_offset_sf:\n+      return dw_cfi_oprnd_offset;\n+      \n+    case DW_CFA_def_cfa_expression:\n+    case DW_CFA_expression:\n+      return dw_cfi_oprnd_loc;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Describe for the GTY machinery what parts of dw_cfi_oprnd2 are used.  */\n+\n+static enum dw_cfi_oprnd_type\n+dw_cfi_oprnd2_desc (cfi)\n+     enum dwarf_call_frame_info cfi;\n+{\n+  switch (cfi)\n+    {\n+    case DW_CFA_def_cfa:\n+    case DW_CFA_def_cfa_sf:\n+    case DW_CFA_offset:\n+    case DW_CFA_offset_extended_sf:\n+    case DW_CFA_offset_extended:\n+      return dw_cfi_oprnd_offset;\n+\n+    case DW_CFA_register:\n+      return dw_cfi_oprnd_reg_num;\n+\n+    default:\n+      return dw_cfi_oprnd_unused;\n+    }\n+}\n+\n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n+\n /* Output a Call Frame Information opcode and its operand(s).  */\n \n static void\n@@ -2118,9 +2208,10 @@ dwarf2out_begin_prologue (line, file)\n   if (fde_table_in_use == fde_table_allocated)\n     {\n       fde_table_allocated += FDE_TABLE_INCREMENT;\n-      fde_table\n-\t= (dw_fde_ref) xrealloc (fde_table,\n-\t\t\t\t fde_table_allocated * sizeof (dw_fde_node));\n+      fde_table = ggc_realloc (fde_table,\n+\t\t\t       fde_table_allocated * sizeof (dw_fde_node));\n+      memset (fde_table + fde_table_in_use, 0,\n+\t      FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n     }\n \n   /* Record the FDE associated with this function.  */\n@@ -2172,7 +2263,8 @@ void\n dwarf2out_frame_init ()\n {\n   /* Allocate the initial hunk of the fde_table.  */\n-  fde_table = (dw_fde_ref) xcalloc (FDE_TABLE_INCREMENT, sizeof (dw_fde_node));\n+  fde_table = (dw_fde_ref) ggc_alloc_cleared (FDE_TABLE_INCREMENT\n+\t\t\t\t\t      * sizeof (dw_fde_node));\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n \n@@ -2196,6 +2288,7 @@ dwarf2out_frame_finish ()\n   if (! USING_SJLJ_EXCEPTIONS && (flag_unwind_tables || flag_exceptions))\n     output_call_frame_info (1);\n }\n+#endif\n \f\n /* And now, the subset of the debugging information support code necessary\n    for emitting location expressions.  */\n@@ -2214,7 +2307,7 @@ typedef struct dw_loc_list_struct *dw_loc_list_ref;\n    can take on several forms.  The forms that are used in this\n    implementation are listed below.  */\n \n-typedef enum\n+enum dw_val_class\n {\n   dw_val_class_addr,\n   dw_val_class_offset,\n@@ -2231,13 +2324,12 @@ typedef enum\n   dw_val_class_lbl_id,\n   dw_val_class_lbl_offset,\n   dw_val_class_str\n-}\n-dw_val_class;\n+};\n \n /* Describe a double word constant value.  */\n /* ??? Every instance of long_long in the code really means CONST_DOUBLE.  */\n \n-typedef struct dw_long_long_struct\n+typedef struct dw_long_long_struct GTY(())\n {\n   unsigned long hi;\n   unsigned long low;\n@@ -2246,47 +2338,47 @@ dw_long_long_const;\n \n /* Describe a floating point constant value.  */\n \n-typedef struct dw_fp_struct\n+typedef struct dw_fp_struct GTY(())\n {\n-  long *array;\n+  long * GTY((length (\"%h.length\"))) array;\n   unsigned length;\n }\n dw_float_const;\n \n /* The dw_val_node describes an attribute's value, as it is\n    represented internally.  */\n \n-typedef struct dw_val_struct\n+typedef struct dw_val_struct GTY(())\n {\n-  dw_val_class val_class;\n-  union\n+  enum dw_val_class val_class;\n+  union dw_val_struct_union\n     {\n-      rtx val_addr;\n-      long unsigned val_offset;\n-      dw_loc_list_ref  val_loc_list;\n-      dw_loc_descr_ref val_loc;\n-      long int val_int;\n-      long unsigned val_unsigned;\n-      dw_long_long_const val_long_long;\n-      dw_float_const val_float;\n-      struct\n+      rtx GTY ((tag (\"dw_val_class_addr\"))) val_addr;\n+      long unsigned GTY ((tag (\"dw_val_class_offset\"))) val_offset;\n+      dw_loc_list_ref GTY ((tag (\"dw_val_class_loc_list\"))) val_loc_list;\n+      dw_loc_descr_ref GTY ((tag (\"dw_val_class_loc\"))) val_loc;\n+      long int GTY ((default (\"\"))) val_int;\n+      long unsigned GTY ((tag (\"dw_val_class_unsigned_const\"))) val_unsigned;\n+      dw_long_long_const GTY ((tag (\"dw_val_class_long_long\"))) val_long_long;\n+      dw_float_const GTY ((tag (\"dw_val_class_float\"))) val_float;\n+      struct dw_val_die_union\n \t{\n \t  dw_die_ref die;\n \t  int external;\n-\t} val_die_ref;\n-      unsigned val_fde_index;\n-      struct indirect_string_node *val_str;\n-      char *val_lbl_id;\n-      unsigned char val_flag;\n+\t} GTY ((tag (\"dw_val_class_die_ref\"))) val_die_ref;\n+      unsigned GTY ((tag (\"dw_val_class_fde_ref\"))) val_fde_index;\n+      struct indirect_string_node * GTY ((tag (\"dw_val_class_str\"))) val_str;\n+      char * GTY ((tag (\"dw_val_class_lbl_id\"))) val_lbl_id;\n+      unsigned char GTY ((tag (\"dw_val_class_flag\"))) val_flag;\n     }\n-  v;\n+  GTY ((desc (\"%1.val_class\"))) v;\n }\n dw_val_node;\n \n /* Locations in memory are described using a sequence of stack machine\n    operations.  */\n \n-typedef struct dw_loc_descr_struct\n+typedef struct dw_loc_descr_struct GTY(())\n {\n   dw_loc_descr_ref dw_loc_next;\n   enum dwarf_location_atom dw_loc_opc;\n@@ -2299,7 +2391,7 @@ dw_loc_descr_node;\n /* Location lists are ranges + location descriptions for that range,\n    so you can track variables that are in different places over\n    their entire life.  */\n-typedef struct dw_loc_list_struct\n+typedef struct dw_loc_list_struct GTY(())\n {\n   dw_loc_list_ref dw_loc_next;\n   const char *begin; /* Label for begin address of range */\n@@ -2310,6 +2402,8 @@ typedef struct dw_loc_list_struct\n   dw_loc_descr_ref expr;\n } dw_loc_list_node;\n \n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n+\n static const char *dwarf_stack_op_name\tPARAMS ((unsigned));\n static dw_loc_descr_ref new_loc_descr\tPARAMS ((enum dwarf_location_atom,\n \t\t\t\t\t\t unsigned long,\n@@ -2645,10 +2739,8 @@ new_loc_descr (op, oprnd1, oprnd2)\n      unsigned long oprnd1;\n      unsigned long oprnd2;\n {\n-  /* Use xcalloc here so we clear out all of the long_long constant in\n-     the union.  */\n   dw_loc_descr_ref descr\n-    = (dw_loc_descr_ref) xcalloc (1, sizeof (dw_loc_descr_node));\n+    = (dw_loc_descr_ref) ggc_alloc_cleared (sizeof (dw_loc_descr_node));\n \n   descr->dw_loc_opc = op;\n   descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;\n@@ -3134,10 +3226,7 @@ get_cfa_from_loc_descr (cfa, loc)\n #ifdef DWARF2_DEBUGGING_INFO\n \n /* .debug_str support.  */\n-static hashnode indirect_string_alloc\tPARAMS ((hash_table *));\n-static int output_indirect_string\tPARAMS ((struct cpp_reader *,\n-                                                 hashnode, const PTR));\n-\n+static int output_indirect_string\tPARAMS ((void **, void *));\n \n static void dwarf2out_init \t\tPARAMS ((const char *));\n static void dwarf2out_finish\t\tPARAMS ((const char *));\n@@ -3179,6 +3268,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   dwarf2out_abstract_function,\t/* outlining_inline_function */\n   debug_nothing_rtx\t\t/* label */\n };\n+#endif\n \f\n /* NOTE: In the comments in this file, many references are made to\n    \"Debugging Information Entries\".  This term is abbreviated as `DIE'\n@@ -3207,7 +3297,7 @@ typedef struct dw_ranges_struct *dw_ranges_ref;\n    entry.  The label gives the PC value associated with\n    the line number entry.  */\n \n-typedef struct dw_line_info_struct\n+typedef struct dw_line_info_struct GTY(())\n {\n   unsigned long dw_file_num;\n   unsigned long dw_line_num;\n@@ -3216,7 +3306,7 @@ dw_line_info_entry;\n \n /* Line information for functions in separate sections; each one gets its\n    own sequence.  */\n-typedef struct dw_separate_line_info_struct\n+typedef struct dw_separate_line_info_struct GTY(())\n {\n   unsigned long dw_file_num;\n   unsigned long dw_line_num;\n@@ -3228,7 +3318,7 @@ dw_separate_line_info_entry;\n    a link to the next attribute in the chain, and an attribute value.\n    Attributes are typically linked below the DIE they modify.  */\n \n-typedef struct dw_attr_struct\n+typedef struct dw_attr_struct GTY(())\n {\n   enum dwarf_attribute dw_attr;\n   dw_attr_ref dw_attr_next;\n@@ -3238,7 +3328,7 @@ dw_attr_node;\n \n /* The Debugging Information Entry (DIE) structure */\n \n-typedef struct die_struct\n+typedef struct die_struct GTY(())\n {\n   enum dwarf_tag die_tag;\n   char *die_symbol;\n@@ -3254,20 +3344,20 @@ die_node;\n \n /* The pubname structure */\n \n-typedef struct pubname_struct\n+typedef struct pubname_struct GTY(())\n {\n   dw_die_ref die;\n   char *name;\n }\n pubname_entry;\n \n-struct dw_ranges_struct\n+struct dw_ranges_struct GTY(())\n {\n   int block_num;\n };\n \n /* The limbo die list structure.  */\n-typedef struct limbo_die_struct\n+typedef struct limbo_die_struct GTY(())\n {\n   dw_die_ref die;\n   tree created_for;\n@@ -3351,14 +3441,14 @@ limbo_die_node;\n static unsigned long next_die_offset;\n \n /* Record the root of the DIE's built for the current compilation unit.  */\n-static dw_die_ref comp_unit_die;\n+static GTY(()) dw_die_ref comp_unit_die;\n \n /* We need special handling in dwarf2out_start_source_file if it is\n    first one.  */\n static int is_main_source;\n \n /* A list of DIEs with a NULL parent waiting to be relocated.  */\n-static limbo_die_node *limbo_die_list = 0;\n+static GTY(()) limbo_die_node *limbo_die_list;\n \n /* Structure used by lookup_filename to manage sets of filenames.  */\n struct file_table\n@@ -3379,7 +3469,7 @@ static struct file_table file_table;\n /* A pointer to the base of a table of references to DIE's that describe\n    declarations.  The table is indexed by DECL_UID() which is a unique\n    number identifying each decl.  */\n-static dw_die_ref *decl_die_table;\n+static GTY((length (\"decl_die_table_allocated\"))) dw_die_ref *decl_die_table;\n \n /* Number of elements currently allocated for the decl_die_table.  */\n static unsigned decl_die_table_allocated;\n@@ -3394,7 +3484,8 @@ static unsigned decl_die_table_in_use;\n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n    children DIE's, and list of attribute/value pairs.  */\n-static dw_die_ref *abbrev_die_table;\n+static GTY((length (\"abbrev_die_table_allocated\"))) \n+  dw_die_ref *abbrev_die_table;\n \n /* Number of elements currently allocated for abbrev_die_table.  */\n static unsigned abbrev_die_table_allocated;\n@@ -3408,31 +3499,33 @@ static unsigned abbrev_die_table_in_use;\n \n /* A pointer to the base of a table that contains line information\n    for each source code line in .text in the compilation unit.  */\n-static dw_line_info_ref line_info_table;\n+static GTY((length (\"line_info_table_allocated\"))) \n+     dw_line_info_ref line_info_table;\n \n /* Number of elements currently allocated for line_info_table.  */\n static unsigned line_info_table_allocated;\n \n-/* Number of elements in separate_line_info_table currently in use.  */\n-static unsigned separate_line_info_table_in_use;\n+/* Number of elements in line_info_table currently in use.  */\n+static unsigned line_info_table_in_use;\n \n /* A pointer to the base of a table that contains line information\n    for each source code line outside of .text in the compilation unit.  */\n-static dw_separate_line_info_ref separate_line_info_table;\n+static GTY ((length (\"separate_line_info_table_allocated\")))\n+     dw_separate_line_info_ref separate_line_info_table;\n \n /* Number of elements currently allocated for separate_line_info_table.  */\n static unsigned separate_line_info_table_allocated;\n \n-/* Number of elements in line_info_table currently in use.  */\n-static unsigned line_info_table_in_use;\n+/* Number of elements in separate_line_info_table currently in use.  */\n+static unsigned separate_line_info_table_in_use;\n \n /* Size (in elements) of increments by which we may expand the\n    line_info_table.  */\n #define LINE_INFO_TABLE_INCREMENT 1024\n \n /* A pointer to the base of a table that contains a list of publicly\n    accessible names.  */\n-static pubname_ref pubname_table;\n+static GTY ((length (\"pubname_table_allocated\"))) pubname_ref pubname_table;\n \n /* Number of elements currently allocated for pubname_table.  */\n static unsigned pubname_table_allocated;\n@@ -3445,7 +3538,7 @@ static unsigned pubname_table_in_use;\n #define PUBNAME_TABLE_INCREMENT 64\n \n /* Array of dies for which we should generate .debug_arange info.  */\n-static dw_die_ref *arange_table;\n+static GTY((length (\"arange_table_allocated\"))) dw_die_ref *arange_table;\n \n /* Number of elements currently allocated for arange_table.  */\n static unsigned arange_table_allocated;\n@@ -3458,7 +3551,7 @@ static unsigned arange_table_in_use;\n #define ARANGE_TABLE_INCREMENT 64\n \n /* Array of dies for which we should generate .debug_ranges info.  */\n-static dw_ranges_ref ranges_table;\n+static GTY ((length (\"ranges_table_allocated\"))) dw_ranges_ref ranges_table;\n \n /* Number of elements currently allocated for ranges_table.  */\n static unsigned ranges_table_allocated;\n@@ -3479,6 +3572,8 @@ static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n #endif\n \n+#ifdef DWARF2_DEBUGGING_INFO\n+\n /* Forward declarations for functions defined in this file.  */\n \n static int is_pseudo_reg\t\tPARAMS ((rtx));\n@@ -3494,7 +3589,7 @@ static tree decl_ultimate_origin\tPARAMS ((tree));\n static tree block_ultimate_origin\tPARAMS ((tree));\n static tree decl_class_context\t\tPARAMS ((tree));\n static void add_dwarf_attr\t\tPARAMS ((dw_die_ref, dw_attr_ref));\n-static inline dw_val_class AT_class\tPARAMS ((dw_attr_ref));\n+static inline enum dw_val_class AT_class\tPARAMS ((dw_attr_ref));\n static void add_AT_flag\t\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t unsigned));\n@@ -3513,6 +3608,8 @@ static void add_AT_long_long\t\tPARAMS ((dw_die_ref,\n static void add_AT_float\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t unsigned, long *));\n+static hashval_t debug_str_do_hash\tPARAMS ((const void *));\n+static int debug_str_eq\t\t\tPARAMS ((const void *, const void *));\n static void add_AT_string\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t const char *));\n@@ -3737,7 +3834,6 @@ static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n \t\t\t\t\t\t const char *, const char *, const char *));\n static void output_loc_list\t\tPARAMS ((dw_loc_list_ref));\n static char *gen_internal_sym \t\tPARAMS ((const char *));\n-static void mark_limbo_die_list\t\tPARAMS ((void *));\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -4404,7 +4500,7 @@ add_dwarf_attr (die, attr)\n     }\n }\n \n-static inline dw_val_class\n+static inline enum dw_val_class\n AT_class (a)\n      dw_attr_ref a;\n {\n@@ -4419,7 +4515,7 @@ add_AT_flag (die, attr_kind, flag)\n      enum dwarf_attribute attr_kind;\n      unsigned flag;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4446,7 +4542,7 @@ add_AT_int (die, attr_kind, int_val)\n      enum dwarf_attribute attr_kind;\n      long int int_val;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4473,7 +4569,7 @@ add_AT_unsigned (die, attr_kind, unsigned_val)\n      enum dwarf_attribute attr_kind;\n      unsigned long unsigned_val;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4501,7 +4597,7 @@ add_AT_long_long (die, attr_kind, val_hi, val_low)\n      unsigned long val_hi;\n      unsigned long val_low;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4520,7 +4616,7 @@ add_AT_float (die, attr_kind, length, array)\n      unsigned length;\n      long *array;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4530,6 +4626,24 @@ add_AT_float (die, attr_kind, length, array)\n   add_dwarf_attr (die, attr);\n }\n \n+/* Hash and equality functions for debug_str_hash.  */\n+\n+static hashval_t\n+debug_str_do_hash (x)\n+     const void * x;\n+{\n+  return htab_hash_string (((const struct indirect_string_node *)x)->str);\n+}\n+\n+static int\n+debug_str_eq (x1, x2)\n+     const void * x1;\n+     const void * x2;\n+{\n+  return strcmp ((((const struct indirect_string_node *)x1)->str),\n+\t\t (const char *)x2) == 0;\n+}\n+\n /* Add a string attribute value to a DIE.  */\n \n static inline void\n@@ -4538,18 +4652,20 @@ add_AT_string (die, attr_kind, str)\n      enum dwarf_attribute attr_kind;\n      const char *str;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n   struct indirect_string_node *node;\n+  PTR *slot;\n \n   if (! debug_str_hash)\n-    {\n-      debug_str_hash = ht_create (10);\n-      debug_str_hash->alloc_node = indirect_string_alloc;\n-    }\n-\n-  node = (struct indirect_string_node *)\n-\t ht_lookup (debug_str_hash, (const unsigned char *) str,\n-\t\t    strlen (str), HT_ALLOC);\n+    debug_str_hash = htab_create_ggc (10, debug_str_do_hash, \n+\t\t\t\t      debug_str_eq, NULL);\n+\n+  slot = htab_find_slot_with_hash (debug_str_hash, str,\n+\t\t\t\t   htab_hash_string (str), INSERT);\n+  if (*slot == NULL)\n+    *slot = ggc_alloc_cleared (sizeof (struct indirect_string_node));\n+  node = (struct indirect_string_node *) *slot;\n+  node->str = ggc_alloc_string (str, -1);\n   node->refcount++;\n \n   attr->dw_attr_next = NULL;\n@@ -4564,7 +4680,7 @@ AT_string (a)\n      dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_str)\n-    return (const char *) HT_STR (&a->dw_attr_val.v.val_str->id);\n+    return a->dw_attr_val.v.val_str->str;\n \n   abort ();\n }\n@@ -4580,14 +4696,13 @@ AT_string_form (a)\n     {\n       struct indirect_string_node *node;\n       unsigned int len;\n-      extern int const_labelno;\n       char label[32];\n \n       node = a->dw_attr_val.v.val_str;\n       if (node->form)\n \treturn node->form;\n \n-      len = HT_LEN (&node->id) + 1;\n+      len = strlen (node->str) + 1;\n \n       /* If the string is shorter or equal to the size of the reference, it is\n \t always better to put it inline.  */\n@@ -4601,8 +4716,8 @@ AT_string_form (a)\n \t  && (len - DWARF_OFFSET_SIZE) * node->refcount <= len)\n \treturn node->form = DW_FORM_string;\n \n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n-      ++const_labelno;\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n+      ++dw2_string_counter;\n       node->label = xstrdup (label);\n \n       return node->form = DW_FORM_strp;\n@@ -4619,7 +4734,7 @@ add_AT_die_ref (die, attr_kind, targ_die)\n      enum dwarf_attribute attr_kind;\n      dw_die_ref targ_die;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4668,7 +4783,7 @@ add_AT_fde_ref (die, attr_kind, targ_fde)\n      enum dwarf_attribute attr_kind;\n      unsigned targ_fde;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4685,7 +4800,7 @@ add_AT_loc (die, attr_kind, loc)\n      enum dwarf_attribute attr_kind;\n      dw_loc_descr_ref loc;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4710,7 +4825,7 @@ add_AT_loc_list (die, attr_kind, loc_list)\n      enum dwarf_attribute attr_kind;\n      dw_loc_list_ref loc_list;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4738,7 +4853,7 @@ add_AT_addr (die, attr_kind, addr)\n      enum dwarf_attribute attr_kind;\n      rtx addr;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4765,7 +4880,7 @@ add_AT_lbl_id (die, attr_kind, lbl_id)\n      enum dwarf_attribute attr_kind;\n      const char *lbl_id;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4782,7 +4897,7 @@ add_AT_lbl_offset (die, attr_kind, label)\n      enum dwarf_attribute attr_kind;\n      const char *label;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4799,7 +4914,7 @@ add_AT_offset (die, attr_kind, offset)\n      enum dwarf_attribute attr_kind;\n      unsigned long offset;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4816,7 +4931,7 @@ add_AT_range_list (die, attr_kind, offset)\n      enum dwarf_attribute attr_kind;\n      unsigned long offset;\n {\n-  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4976,27 +5091,9 @@ static inline void\n free_AT (a)\n      dw_attr_ref a;\n {\n-  switch (AT_class (a))\n-    {\n-    case dw_val_class_str:\n-      if (a->dw_attr_val.v.val_str->refcount)\n-\ta->dw_attr_val.v.val_str->refcount--;\n-      break;\n-\n-    case dw_val_class_lbl_id:\n-    case dw_val_class_lbl_offset:\n-      free (a->dw_attr_val.v.val_lbl_id);\n-      break;\n-\n-    case dw_val_class_float:\n-      free (a->dw_attr_val.v.val_float.array);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  free (a);\n+  if (AT_class (a) == dw_val_class_str)\n+    if (a->dw_attr_val.v.val_str->refcount)\n+      a->dw_attr_val.v.val_str->refcount--;\n }\n \n /* Remove the specified attribute if present.  */\n@@ -5031,7 +5128,6 @@ free_die (die)\n      dw_die_ref die;\n {\n   remove_children (die);\n-  free (die);\n }\n \n /* Discard the children of this DIE.  */\n@@ -5124,7 +5220,7 @@ new_die (tag_value, parent_die, t)\n      dw_die_ref parent_die;\n      tree t;\n {\n-  dw_die_ref die = (dw_die_ref) xcalloc (1, sizeof (die_node));\n+  dw_die_ref die = (dw_die_ref) ggc_alloc_cleared (sizeof (die_node));\n \n   die->die_tag = tag_value;\n \n@@ -5134,7 +5230,7 @@ new_die (tag_value, parent_die, t)\n     {\n       limbo_die_node *limbo_node;\n \n-      limbo_node = (limbo_die_node *) xmalloc (sizeof (limbo_die_node));\n+      limbo_node = ggc_alloc_cleared (sizeof (limbo_die_node));\n       limbo_node->die = die;\n       limbo_node->created_for = t;\n       limbo_node->next = limbo_die_list;\n@@ -5191,9 +5287,8 @@ equate_decl_number_to_die (decl, decl_die)\n \t   / DECL_DIE_TABLE_INCREMENT)\n \t  * DECL_DIE_TABLE_INCREMENT;\n \n-      decl_die_table\n-\t= (dw_die_ref *) xrealloc (decl_die_table,\n-\t\t\t\t   sizeof (dw_die_ref) * num_allocated);\n+      decl_die_table = ggc_realloc (decl_die_table,\n+\t\t\t\t    sizeof (dw_die_ref) * num_allocated);\n \n       memset ((char *) &decl_die_table[decl_die_table_allocated], 0,\n \t     (num_allocated - decl_die_table_allocated) * sizeof (dw_die_ref));\n@@ -5605,8 +5700,7 @@ same_dw_val_p (v1, v2, mark)\n     case dw_val_class_flag:\n       return v1->v.val_flag == v2->v.val_flag;\n     case dw_val_class_str:\n-      return !strcmp((const char *) HT_STR (&v1->v.val_str->id),\n-\t\t     (const char *) HT_STR (&v2->v.val_str->id));\n+      return !strcmp(v1->v.val_str->str, v2->v.val_str->str);\n \n     case dw_val_class_addr:\n       r1 = v1->v.val_addr;\n@@ -6145,9 +6239,8 @@ build_abbrev_table (die)\n       if (abbrev_die_table_in_use >= abbrev_die_table_allocated)\n \t{\n \t  n_alloc = abbrev_die_table_allocated + ABBREV_DIE_TABLE_INCREMENT;\n-\t  abbrev_die_table\n-\t    = (dw_die_ref *) xrealloc (abbrev_die_table,\n-\t\t\t\t       sizeof (dw_die_ref) * n_alloc);\n+\t  abbrev_die_table = ggc_realloc (abbrev_die_table,\n+\t\t\t\t\t  sizeof (dw_die_ref) * n_alloc);\n \n \t  memset ((char *) &abbrev_die_table[abbrev_die_table_allocated], 0,\n \t\t (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n@@ -6249,7 +6342,7 @@ size_of_die (die)\n \t  if (AT_string_form (a) == DW_FORM_strp)\n \t    size += DWARF_OFFSET_SIZE;\n \t  else\n-\t    size += HT_LEN (&a->dw_attr_val.v.val_str->id) + 1;\n+\t    size += strlen (a->dw_attr_val.v.val_str->str) + 1;\n \t  break;\n \tdefault:\n \t  abort ();\n@@ -6529,8 +6622,7 @@ new_loc_list (expr, begin, end, section, gensym)\n      const char *section;\n      unsigned gensym;\n {\n-  dw_loc_list_ref retlist\n-    = (dw_loc_list_ref) xcalloc (1, sizeof (dw_loc_list_node));\n+  dw_loc_list_ref retlist = ggc_alloc_cleared (sizeof (dw_loc_list_node));\n \n   retlist->begin = begin;\n   retlist->end = end;\n@@ -6884,9 +6976,11 @@ add_pubname (decl, die)\n     {\n       pubname_table_allocated += PUBNAME_TABLE_INCREMENT;\n       pubname_table\n-\t= (pubname_ref) xrealloc (pubname_table,\n-\t\t\t\t  (pubname_table_allocated\n-\t\t\t\t   * sizeof (pubname_entry)));\n+\t= (pubname_ref) ggc_realloc (pubname_table,\n+\t\t\t\t     (pubname_table_allocated\n+\t\t\t\t      * sizeof (pubname_entry)));\n+      memset (pubname_table + pubname_table_in_use, 0,\n+\t      PUBNAME_TABLE_INCREMENT * sizeof (pubname_entry));\n     }\n \n   p = &pubname_table[pubname_table_in_use++];\n@@ -6942,8 +7036,11 @@ add_arange (decl, die)\n   if (arange_table_in_use == arange_table_allocated)\n     {\n       arange_table_allocated += ARANGE_TABLE_INCREMENT;\n-      arange_table = (dw_die_ref *)\n-\txrealloc (arange_table, arange_table_allocated * sizeof (dw_die_ref));\n+      arange_table = ggc_realloc (arange_table, \n+\t\t\t\t  (arange_table_allocated \n+\t\t\t\t   * sizeof (dw_die_ref)));\n+      memset (arange_table + arange_table_in_use, 0,\n+\t      ARANGE_TABLE_INCREMENT * sizeof (dw_die_ref));\n     }\n \n   arange_table[arange_table_in_use++] = die;\n@@ -7038,8 +7135,10 @@ add_ranges (block)\n     {\n       ranges_table_allocated += RANGES_TABLE_INCREMENT;\n       ranges_table = (dw_ranges_ref)\n-\txrealloc (ranges_table, (ranges_table_allocated\n-\t\t\t\t * sizeof (struct dw_ranges_struct)));\n+\tggc_realloc (ranges_table, (ranges_table_allocated\n+\t\t\t\t    * sizeof (struct dw_ranges_struct)));\n+      memset (ranges_table + ranges_table_in_use, 0,\n+\t      RANGES_TABLE_INCREMENT * sizeof (struct dw_ranges_struct));\n     }\n \n   ranges_table[in_use].block_num = (block ? BLOCK_NUMBER (block) : 0);\n@@ -9090,7 +9189,7 @@ add_const_value_attribute (die, rtl)\n \tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t  {\n \t    unsigned length = GET_MODE_SIZE (mode) / 4;\n-\t    long *array = (long *) xmalloc (sizeof (long) * length);\n+\t    long *array = (long *) ggc_alloc (sizeof (long) * length);\n \t    REAL_VALUE_TYPE rv;\n \n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, rtl);\n@@ -11974,15 +12073,6 @@ gen_decl_die (decl, context_die)\n       abort ();\n     }\n }\n-\n-static void\n-mark_limbo_die_list (ptr)\n-     void *ptr ATTRIBUTE_UNUSED;\n-{\n-  limbo_die_node *node;\n-  for (node = limbo_die_list; node; node = node->next)\n-    ggc_mark_tree (node->created_for);\n-}\n \f\n /* Add Ada \"use\" clause information for SGI Workshop debugger.  */\n \n@@ -12225,6 +12315,8 @@ lookup_filename (file_name)\n       file_table.allocated = i + FILE_TABLE_INCREMENT;\n       file_table.table = (char **)\n \txrealloc (file_table.table, file_table.allocated * sizeof (char *));\n+      memset (file_table.table + i, 0,\n+\t      FILE_TABLE_INCREMENT * sizeof (char *));\n     }\n \n   /* Add the new entry to the end of the filename table.  */\n@@ -12299,9 +12391,14 @@ dwarf2out_source_line (line, filename)\n \t      separate_line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n \t      separate_line_info_table\n \t\t= (dw_separate_line_info_ref)\n-\t\t  xrealloc (separate_line_info_table,\n-\t\t\t    separate_line_info_table_allocated\n-\t\t\t    * sizeof (dw_separate_line_info_entry));\n+\t\t  ggc_realloc (separate_line_info_table,\n+\t\t\t       separate_line_info_table_allocated\n+\t\t\t       * sizeof (dw_separate_line_info_entry));\n+\t      memset ((separate_line_info_table \n+\t\t       + separate_line_info_table_in_use), \n+\t\t      0,\n+\t\t      (LINE_INFO_TABLE_INCREMENT \n+\t\t       * sizeof (dw_separate_line_info_entry)));\n \t    }\n \n \t  /* Add the new entry at the end of the line_info_table.  */\n@@ -12323,10 +12420,11 @@ dwarf2out_source_line (line, filename)\n \t    {\n \t      line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n \t      line_info_table\n-\t\t= (dw_line_info_ref)\n-\t\t  xrealloc (line_info_table,\n-\t\t\t    (line_info_table_allocated\n-\t\t\t     * sizeof (dw_line_info_entry)));\n+\t\t= ggc_realloc (line_info_table,\n+\t\t\t       (line_info_table_allocated\n+\t\t\t\t* sizeof (dw_line_info_entry)));\n+\t      memset (line_info_table + line_info_table_in_use, 0,\n+\t\t      LINE_INFO_TABLE_INCREMENT * sizeof (dw_line_info_entry));\n \t    }\n \n \t  /* Add the new entry at the end of the line_info_table.  */\n@@ -12433,26 +12531,24 @@ dwarf2out_init (main_input_filename)\n   lookup_filename (main_input_filename);\n \n   /* Allocate the initial hunk of the decl_die_table.  */\n-  decl_die_table\n-    = (dw_die_ref *) xcalloc (DECL_DIE_TABLE_INCREMENT, sizeof (dw_die_ref));\n+  decl_die_table = ggc_alloc_cleared (DECL_DIE_TABLE_INCREMENT \n+\t\t\t\t      * sizeof (dw_die_ref));\n   decl_die_table_allocated = DECL_DIE_TABLE_INCREMENT;\n   decl_die_table_in_use = 0;\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n   VARRAY_TREE_INIT (decl_scope_table, 256, \"decl_scope_table\");\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n-  abbrev_die_table\n-    = (dw_die_ref *) xcalloc (ABBREV_DIE_TABLE_INCREMENT,\n-\t\t\t      sizeof (dw_die_ref));\n+  abbrev_die_table = ggc_alloc_cleared (ABBREV_DIE_TABLE_INCREMENT\n+\t\t\t\t\t* sizeof (dw_die_ref));\n   abbrev_die_table_allocated = ABBREV_DIE_TABLE_INCREMENT;\n   /* Zero-th entry is allocated, but unused */\n   abbrev_die_table_in_use = 1;\n \n   /* Allocate the initial hunk of the line_info_table.  */\n-  line_info_table\n-    = (dw_line_info_ref) xcalloc (LINE_INFO_TABLE_INCREMENT,\n-\t\t\t\t  sizeof (dw_line_info_entry));\n+  line_info_table = ggc_alloc_cleared (LINE_INFO_TABLE_INCREMENT\n+\t\t\t\t       * sizeof (dw_line_info_entry));\n   line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n \n   /* Zero-th entry is allocated, but unused */\n@@ -12470,8 +12566,6 @@ dwarf2out_init (main_input_filename)\n \n   VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n \n-  ggc_add_root (&limbo_die_list, 1, 1, mark_limbo_die_list);\n-\n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,\n \t\t\t       DEBUG_ABBREV_SECTION_LABEL, 0);\n@@ -12508,39 +12602,21 @@ dwarf2out_init (main_input_filename)\n     }\n }\n \n-/* Allocate a string in .debug_str hash table.  */\n-\n-static hashnode\n-indirect_string_alloc (tab)\n-     hash_table *tab ATTRIBUTE_UNUSED;\n-{\n-  struct indirect_string_node *node;\n-\n-  node = xmalloc (sizeof (struct indirect_string_node));\n-  node->refcount = 0;\n-  node->form = 0;\n-  node->label = NULL;\n-\n-  return (hashnode) node;\n-}\n-\n /* A helper function for dwarf2out_finish called through\n    ht_forall.  Emit one queued .debug_str string.  */\n \n static int\n-output_indirect_string (pfile, h, v)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     hashnode h;\n-     const PTR v ATTRIBUTE_UNUSED;\n+output_indirect_string (h, v)\n+     void **h;\n+     void *v ATTRIBUTE_UNUSED;\n {\n-  struct indirect_string_node *node = (struct indirect_string_node *) h;\n+  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n \n   if (node->form == DW_FORM_strp)\n     {\n       named_section_flags (DEBUG_STR_SECTION, DEBUG_STR_SECTION_FLAGS);\n       ASM_OUTPUT_LABEL (asm_out_file, node->label);\n-      assemble_string ((const char *) HT_STR (&node->id),\n-\t\t       HT_LEN (&node->id) + 1);\n+      assemble_string (node->str, strlen (node->str) + 1);\n     }\n \n   return 1;\n@@ -12607,8 +12683,6 @@ dwarf2out_finish (input_filename)\n \t  else\n \t    abort ();\n \t}\n-\n-      free (node);\n     }\n \n   limbo_die_list = NULL;\n@@ -12724,7 +12798,7 @@ dwarf2out_finish (input_filename)\n   /* If we emitted any DW_FORM_strp form attribute, output the string\n      table too.  */\n   if (debug_str_hash)\n-    ht_forall (debug_str_hash, output_indirect_string, NULL);\n+    htab_traverse (debug_str_hash, output_indirect_string, NULL);\n }\n #else\n "}, {"sha": "eb1814acc787fdd0c2f063bf1b27ba418112879e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -5315,14 +5315,14 @@ init_emit_once (line_numbers)\n \n   /* Initialize the CONST_INT, CONST_DOUBLE, and memory attribute hash\n      tables.  */\n-  const_int_htab = htab_create (37, const_int_htab_hash,\n-\t\t\t\tconst_int_htab_eq, NULL);\n+  const_int_htab = htab_create_ggc (37, const_int_htab_hash,\n+\t\t\t\t    const_int_htab_eq, NULL);\n \n-  const_double_htab = htab_create (37, const_double_htab_hash,\n-\t\t\t\t   const_double_htab_eq, NULL);\n+  const_double_htab = htab_create_ggc (37, const_double_htab_hash,\n+\t\t\t\t       const_double_htab_eq, NULL);\n \n-  mem_attrs_htab = htab_create (37, mem_attrs_htab_hash,\n-\t\t\t\tmem_attrs_htab_eq, NULL);\n+  mem_attrs_htab = htab_create_ggc (37, mem_attrs_htab_hash,\n+\t\t\t\t    mem_attrs_htab_eq, NULL);\n \n   no_line_numbers = ! line_numbers;\n "}, {"sha": "3847fc00041aac624376fa49d766f0f2415815bf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1395,7 +1395,7 @@ size_int_type_wide (number, type)\n \n   if (size_htab == 0)\n     {\n-      size_htab = htab_create (1024, size_htab_hash, size_htab_eq, NULL);\n+      size_htab = htab_create_ggc (1024, size_htab_hash, size_htab_eq, NULL);\n       new_const = make_node (INTEGER_CST);\n     }\n "}, {"sha": "1c972d2cff47fef301766ee44c2ce5e5062f41b6", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -125,7 +125,7 @@ int current_function_uses_only_leaf_regs;\n int virtuals_instantiated;\n \n /* Assign unique numbers to labels generated for profiling, debugging, etc.  */\n-static int funcdef_no;\n+static GTY(()) int funcdef_no;\n \n /* These variables hold pointers to functions to create and destroy\n    target specific, per-function data structures.  */"}, {"sha": "8b27a0ac5793e5e0e13bea541f48688dbab8d964", "filename": "gcc/gcc.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -421,6 +421,7 @@ or with constant text in a single argument.\n  %w\tmarks the argument containing or following the %w as the\n \t\"output file\" of this compilation.  This puts the argument\n \tinto the sequence of arguments that %o will substitute later.\n+ %V\tindicates that this compilation produces no \"output file\".\n  %W{...}\n \tlike %{...} but mark last argument supplied within\n \tas a file to be deleted on failure.\n@@ -914,9 +915,19 @@ static const struct compiler default_compilers[] =\n     %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)\", 0},\n   {\".h\", \"@c-header\", 0},\n   {\"@c-header\",\n-   \"%{!E:%ecompilation of header file requested} \\\n-    %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)\",\n-   0},\n+   /* cc1 has an integrated ISO C preprocessor.  We should invoke the\n+      external preprocessor if -save-temps is given.  */\n+     \"%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}\\\n+      %{!E:%{!M:%{!MM:\\\n+\t  %{save-temps|traditional-cpp:%(trad_capable_cpp) \\\n+\t\t%(cpp_options) %b.i \\n\\\n+\t\t    cc1 -fpreprocessed %b.i %(cc1_options)\\\n+                        -o %g.s %{!o*:--output-pch=%i.pch}\\\n+                        %W{o*:--output-pch=%*}%V}\\\n+\t  %{!save-temps:%{!traditional-cpp:\\\n+\t\tcc1 %(cpp_unique_options) %(cc1_options)\\\n+                    -o %g.s %{!o*:--output-pch=%i.pch}\\\n+                    %W{o*:--output-pch=%*}%V}}}}}\", 0},\n   {\".i\", \"@cpp-output\", 0},\n   {\"@cpp-output\",\n    \"%{!M:%{!MM:%{!E:cc1 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}\", 0},\n@@ -4765,6 +4776,10 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    this_is_library_file = 1;\n \t    break;\n \n+\t  case 'V':\n+\t    outfiles[input_file_number] = NULL;\n+\t    break;\n+\n \t  case 'w':\n \t    this_is_output_file = 1;\n \t    break;\n@@ -6079,6 +6094,7 @@ main (argc, argv)\n   size_t i;\n   int value;\n   int linker_was_run = 0;\n+  int num_linker_inputs = 0;\n   char *explicit_link_files;\n   char *specs_file;\n   const char *p;\n@@ -6516,9 +6532,15 @@ main (argc, argv)\n \terror_count++;\n     }\n \n+  /* Determine if there are any linker input files.  */\n+  num_linker_inputs = 0;\n+  for (i = 0; (int) i < n_infiles; i++)\n+    if (explicit_link_files[i] || outfiles[i] != NULL)\n+      num_linker_inputs++;\n+\n   /* Run ld to link all the compiler output files.  */\n \n-  if (error_count == 0)\n+  if (num_linker_inputs > 0 && error_count == 0)\n     {\n       int tmp = execution_count;\n "}, {"sha": "b279263b548850ae953e267399db855ec570475f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 951, "deletions": 549, "changes": 1500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -603,14 +603,6 @@ adjust_field_rtx_def (t, opt)\n \t      subfields->opt->name = \"skip\";\n \t      subfields->opt->info = NULL;\n \t    }\n-\t  else if ((size_t) rtx_next[i] == aindex)\n-\t    {\n-\t      /* The 'next' field will be marked by the chain_next option.  */\n-\t      subfields->opt = xmalloc (sizeof (*subfields->opt));\n-\t      subfields->opt->next = nodot;\n-\t      subfields->opt->name = \"skip\";\n-\t      subfields->opt->info = NULL;\n-\t    }\n \t  else\n \t    subfields->opt = nodot;\n \t}\n@@ -1364,70 +1356,78 @@ struct flist {\n   outf_p f;\n };\n \n-static void output_escaped_param PARAMS ((outf_p , const char *, const char *,\n-\t\t\t\t\t  const char *, const char *,\n-\t\t\t\t\t  struct fileloc *));\n+struct walk_type_data;\n+\n+/* For scalars and strings, given the item in 'val'.\n+   For structures, given a pointer to the item in 'val'.\n+   For misc. pointers, given the item in 'val'.\n+*/\n+typedef void (*process_field_fn) \n+     PARAMS ((type_p f, const struct walk_type_data *p));\n+typedef void (*func_name_fn)\n+     PARAMS ((type_p s, const struct walk_type_data *p));\n+\n+/* Parameters for write_types.  */\n+\n+struct write_types_data \n+{\n+  const char *prefix;\n+  const char *param_prefix;\n+  const char *subfield_marker_routine;\n+  const char *marker_routine;\n+  const char *reorder_note_routine;\n+  const char *comment;\n+};\n+\n+static void output_escaped_param PARAMS ((struct walk_type_data *d, \n+\t\t\t\t\t  const char *, const char *));\n static void output_mangled_typename PARAMS ((outf_p, type_p));\n-static void write_gc_structure_fields \n-  PARAMS ((outf_p , type_p, const char *, const char *, options_p, \n-\t   int, struct fileloc *, lang_bitmap, type_p *));\n-static void write_gc_marker_routine_for_structure PARAMS ((type_p, type_p, \n-\t\t\t\t\t\t\t   type_p *));\n-static void write_gc_types PARAMS ((type_p structures, type_p param_structs));\n+static void walk_type PARAMS ((type_p t, struct walk_type_data *d));\n+static void write_func_for_structure\n+     PARAMS ((type_p orig_s, type_p s, type_p * param,\n+\t      const struct write_types_data *wtd));\n+static void write_types_process_field \n+     PARAMS ((type_p f, const struct walk_type_data *d));\n+static void write_types PARAMS ((type_p structures, \n+\t\t\t\t type_p param_structs,\n+\t\t\t\t const struct write_types_data *wtd));\n+static void write_types_local_process_field\n+     PARAMS ((type_p f, const struct walk_type_data *d));\n+static void write_local_func_for_structure\n+     PARAMS ((type_p orig_s, type_p s, type_p * param));\n+static void write_local PARAMS ((type_p structures, \n+\t\t\t\t type_p param_structs));\n static void write_enum_defn PARAMS ((type_p structures, type_p param_structs));\n+static int contains_scalar_p PARAMS ((type_p t));\n static void put_mangled_filename PARAMS ((outf_p , const char *));\n static void finish_root_table PARAMS ((struct flist *flp, const char *pfx, \n \t\t\t\t       const char *tname, const char *lastname,\n \t\t\t\t       const char *name));\n-static void write_gc_root PARAMS ((outf_p , pair_p, type_p, const char *, int,\n+static void write_root PARAMS ((outf_p , pair_p, type_p, const char *, int,\n \t\t\t\t   struct fileloc *, const char *));\n-static void write_gc_roots PARAMS ((pair_p));\n+static void write_array PARAMS ((outf_p f, pair_p v,\n+\t\t\t\t const struct write_types_data *wtd));\n+static void write_roots PARAMS ((pair_p));\n \n-static int gc_counter;\n+/* Parameters for walk_type.  */\n \n-/* Print PARAM to OF processing escapes.  VAL references the current object,\n-   PREV_VAL the object containing the current object, ONAME is the name\n-   of the option and LINE is used to print error messages.  */\n-\n-static void\n-output_escaped_param (of, param, val, prev_val, oname, line)\n-     outf_p of;\n-     const char *param;\n-     const char *val;\n-     const char *prev_val;\n-     const char *oname;\n-     struct fileloc *line;\n+struct walk_type_data\n {\n-  const char *p;\n-  \n-  for (p = param; *p; p++)\n-    if (*p != '%')\n-      oprintf (of, \"%c\", *p);\n-    else switch (*++p)\n-      {\n-      case 'h':\n-\toprintf (of, \"(%s)\", val);\n-\tbreak;\n-      case '0':\n-\toprintf (of, \"(*x)\");\n-\tbreak;\n-      case '1':\n-\toprintf (of, \"(%s)\", prev_val);\n-\tbreak;\n-      case 'a':\n-\t{\n-\t  const char *pp = val + strlen (val);\n-\t  while (pp[-1] == ']')\n-\t    while (*pp != '[')\n-\t      pp--;\n-\t  oprintf (of, \"%s\", pp);\n-\t}\n-\tbreak;\n-      default:\n-\terror_at_line (line, \"`%s' option contains bad escape %c%c\",\n-\t\t       oname, '%', *p);\n-      }\n-}\n+  process_field_fn process_field;\n+  const void *cookie;\n+  outf_p of;\n+  options_p opt;\n+  const char *val;\n+  const char *prev_val[4];\n+  int indent;\n+  int counter;\n+  struct fileloc *line;\n+  lang_bitmap bitmap;\n+  type_p *param;\n+  int used_length;\n+  type_p orig_s;\n+  const char *reorder_fn;\n+};\n \n /* Print a mangled name representing T to OF.  */\n \n@@ -1469,431 +1469,500 @@ output_mangled_typename (of, t)\n     }\n }\n \n-/* Write out code to OF which marks the fields of S.  VAL references\n-   the current object, PREV_VAL the object containing the current\n-   object, OPTS is a list of options to apply, INDENT is the current\n-   indentation level, LINE is used to print error messages, BITMAP\n-   indicates which languages to print the structure for, and PARAM is\n-   the current parameter (from an enclosing param_is option).  */\n+/* Print PARAM to D->OF processing escapes.  D->VAL references the\n+   current object, D->PREV_VAL the object containing the current\n+   object, ONAME is the name of the option and D->LINE is used to\n+   print error messages.  */\n \n static void\n-write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n-\t\t\t   param)\n-     outf_p of;\n-     type_p s;\n-     const char *val;\n-     const char *prev_val;\n-     options_p opts;\n-     int indent;\n-     struct fileloc *line;\n-     lang_bitmap bitmap;\n-     type_p * param;\n+output_escaped_param (d, param, oname)\n+     struct walk_type_data *d;\n+     const char *param;\n+     const char *oname;\n {\n-  pair_p f;\n-  int seen_default = 0;\n-\n-  if (! s->u.s.line.file)\n-    error_at_line (line, \"incomplete structure `%s'\", s->u.s.tag);\n-  else if ((s->u.s.bitmap & bitmap) != bitmap)\n-    {\n-      error_at_line (line, \"structure defined for mismatching languages\");\n-      error_at_line (&s->u.s.line, \"one structure defined here\");\n-    }\n+  const char *p;\n   \n-  if (s->kind == TYPE_UNION)\n-    {\n-      const char *tagexpr = NULL;\n-      options_p oo;\n-      \n-      for (oo = opts; oo; oo = oo->next)\n-\tif (strcmp (oo->name, \"desc\") == 0)\n-\t  tagexpr = (const char *)oo->info;\n-      if (tagexpr == NULL)\n+  for (p = param; *p; p++)\n+    if (*p != '%')\n+      oprintf (d->of, \"%c\", *p);\n+    else switch (*++p)\n+      {\n+      case 'h':\n+\toprintf (d->of, \"(%s)\", d->prev_val[2]);\n+\tbreak;\n+      case '0':\n+\toprintf (d->of, \"(%s)\", d->prev_val[0]);\n+\tbreak;\n+      case '1':\n+\toprintf (d->of, \"(%s)\", d->prev_val[1]);\n+\tbreak;\n+      case 'a':\n \t{\n-\t  tagexpr = \"1\";\n-\t  error_at_line (line, \"missing `desc' option\");\n+\t  const char *pp = d->val + strlen (d->val);\n+\t  while (pp[-1] == ']')\n+\t    while (*pp != '[')\n+\t      pp--;\n+\t  oprintf (d->of, \"%s\", pp);\n \t}\n+\tbreak;\n+      default:\n+\terror_at_line (d->line, \"`%s' option contains bad escape %c%c\",\n+\t\t       oname, '%', *p);\n+      }\n+}\n \n-      oprintf (of, \"%*sswitch (\", indent, \"\");\n-      output_escaped_param (of, tagexpr, val, prev_val, \"desc\", line);\n-      oprintf (of, \")\\n\");\n-      indent += 2;\n-      oprintf (of, \"%*s{\\n\", indent, \"\");\n-    }\n-  \n-  for (f = s->u.s.fields; f; f = f->next)\n-    {\n-      const char *tagid = NULL;\n-      const char *length = NULL;\n-      int skip_p = 0;\n-      int default_p = 0;\n-      int maybe_undef_p = 0;\n-      int use_param_num = -1;\n-      int use_params_p = 0;\n-      int needs_cast_p = 0;\n-      options_p oo;\n-      type_p t = f->type;\n-      const char *dot = \".\";\n-      \n-      for (oo = f->opt; oo; oo = oo->next)\n-\tif (strcmp (oo->name, \"length\") == 0)\n-\t  length = (const char *)oo->info;\n-\telse if (strcmp (oo->name, \"maybe_undef\") == 0)\n-\t  maybe_undef_p = 1;\n-\telse if (strcmp (oo->name, \"tag\") == 0)\n-\t  tagid = (const char *)oo->info;\n-\telse if (strcmp (oo->name, \"special\") == 0)\n-\t  ;\n-\telse if (strcmp (oo->name, \"skip\") == 0)\n-\t  skip_p = 1;\n-\telse if (strcmp (oo->name, \"default\") == 0)\n-\t  default_p = 1;\n-\telse if (strcmp (oo->name, \"desc\") == 0)\n-\t  ;\n- \telse if (strcmp (oo->name, \"descbits\") == 0)\n-\t  ;\n- \telse if (strcmp (oo->name, \"param_is\") == 0)\n-\t  ;\n-\telse if (strncmp (oo->name, \"use_param\", 9) == 0\n-\t\t && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n-\t  use_param_num = oo->name[9] == '\\0' ? 0 : oo->name[9] - '0';\n-\telse if (strcmp (oo->name, \"use_params\") == 0)\n-\t  use_params_p = 1;\n-\telse if (strcmp (oo->name, \"dot\") == 0)\n-\t  dot = (const char *)oo->info;\n-\telse\n-\t  error_at_line (&f->line, \"unknown field option `%s'\\n\", oo->name);\n+/* Call D->PROCESS_FIELD for every field (or subfield) of D->VAL,\n+   which is of type T.  Write code to D->OF to constrain execution (at\n+   the point that D->PROCESS_FIELD is called) to the appropriate\n+   cases.  D->PREV_VAL lists the objects containing the current object,\n+   D->OPT is a list of options to apply, D->INDENT is the current\n+   indentation level, D->LINE is used to print error messages,\n+   D->BITMAP indicates which languages to print the structure for, and\n+   D->PARAM is the current parameter (from an enclosing param_is\n+   option).  */\n \n-      if (skip_p)\n-\tcontinue;\n+static void\n+walk_type (t, d)\n+     type_p t;\n+     struct walk_type_data *d;\n+{\n+  const char *length = NULL;\n+  const char *desc = NULL;\n+  int maybe_undef_p = 0;\n+  int use_param_num = -1;\n+  int use_params_p = 0;\n+  int needs_cast_p = 0;\n+  options_p oo;\n+  \n+  for (oo = d->opt; oo; oo = oo->next)\n+    if (strcmp (oo->name, \"length\") == 0)\n+      length = (const char *)oo->info;\n+    else if (strcmp (oo->name, \"maybe_undef\") == 0)\n+      maybe_undef_p = 1;\n+    else if (strncmp (oo->name, \"use_param\", 9) == 0\n+\t     && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n+      use_param_num = oo->name[9] == '\\0' ? 0 : oo->name[9] - '0';\n+    else if (strcmp (oo->name, \"use_params\") == 0)\n+      use_params_p = 1;\n+    else if (strcmp (oo->name, \"desc\") == 0)\n+      desc = (const char *)oo->info;\n+    else if (strcmp (oo->name, \"dot\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"tag\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"special\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"skip\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"default\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"descbits\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"param_is\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"chain_next\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"chain_prev\") == 0)\n+      ;\n+    else if (strcmp (oo->name, \"reorder\") == 0)\n+      ;\n+    else\n+      error_at_line (d->line, \"unknown option `%s'\\n\", oo->name);\n \n-      if (use_params_p)\n-\t{\n-\t  int pointer_p = t->kind == TYPE_POINTER;\n+  if (d->used_length)\n+    length = NULL;\n \n-\t  if (pointer_p)\n-\t    t = t->u.p;\n-\t  t = find_param_structure (t, param);\n-\t  if (pointer_p)\n-\t    t = create_pointer (t);\n-\t}\n+  if (use_params_p)\n+    {\n+      int pointer_p = t->kind == TYPE_POINTER;\n       \n-      if (use_param_num != -1)\n-\t{\n-\t  if (param != NULL && param[use_param_num] != NULL)\n-\t    {\n-\t      type_p nt = param[use_param_num];\n-\t      \n-\t      if (t->kind == TYPE_ARRAY)\n-\t\tnt = create_array (nt, t->u.a.len);\n-\t      else if (length != NULL && t->kind == TYPE_POINTER)\n-\t\tnt = create_pointer (nt);\n-\t      needs_cast_p = (t->kind != TYPE_POINTER\n-\t\t\t      && nt->kind == TYPE_POINTER);\n-\t      t = nt;\n-\t    }\n-\t  else if (s->kind != TYPE_UNION)\n-\t    error_at_line (&f->line, \"no parameter defined\");\n-\t}\n-\n-      if (t->kind == TYPE_SCALAR\n-\t  || (t->kind == TYPE_ARRAY \n-\t      && t->u.a.p->kind == TYPE_SCALAR))\n-\tcontinue;\n+      if (pointer_p)\n+\tt = t->u.p;\n+      if (! UNION_OR_STRUCT_P (t))\n+\terror_at_line (d->line, \"`use_params' option on unimplemented type\");\n+      else \n+\tt = find_param_structure (t, d->param);\n+      if (pointer_p)\n+\tt = create_pointer (t);\n+    }\n       \n-      seen_default |= default_p;\n-\n-      if (maybe_undef_p\n-\t  && (t->kind != TYPE_POINTER\n-\t      || t->u.p->kind != TYPE_STRUCT))\n-\terror_at_line (&f->line, \n-\t\t       \"field `%s' has invalid option `maybe_undef_p'\\n\",\n-\t\t       f->name);\n-      if (s->kind == TYPE_UNION)\n+  if (use_param_num != -1)\n+    {\n+      if (d->param != NULL && d->param[use_param_num] != NULL)\n \t{\n-\t  if (tagid)\n-\t    {\n-\t      oprintf (of, \"%*scase %s:\\n\", indent, \"\", tagid);\n-\n-\t    }\n-\t  else if (default_p)\n-\t    {\n-\t      oprintf (of, \"%*sdefault:\\n\", indent, \"\");\n-\t    }\n-\t  else\n-\t    {\n-\t      error_at_line (&f->line, \"field `%s' has no tag\", f->name);\n-\t      continue;\n-\t    }\n-\t  indent += 2;\n+\t  type_p nt = d->param[use_param_num];\n+\t  \n+\t  if (t->kind == TYPE_ARRAY)\n+\t    nt = create_array (nt, t->u.a.len);\n+\t  else if (length != NULL && t->kind == TYPE_POINTER)\n+\t    nt = create_pointer (nt);\n+\t  needs_cast_p = (t->kind != TYPE_POINTER\n+\t\t\t  && nt->kind == TYPE_POINTER);\n+\t  t = nt;\n \t}\n+      else\n+\terror_at_line (d->line, \"no parameter defined for `%s'\",\n+\t\t       d->val);\n+    }\n+  \n+  if (maybe_undef_p \n+      && (t->kind != TYPE_POINTER || ! UNION_OR_STRUCT_P (t->u.p)))\n+    {\n+      error_at_line (d->line, \n+\t\t     \"field `%s' has invalid option `maybe_undef_p'\\n\",\n+\t\t     d->val);\n+      return;\n+    }\n+  \n+  switch (t->kind)\n+    {\n+    case TYPE_SCALAR:\n+    case TYPE_STRING:\n+      d->process_field (t, d);\n+      break;\n       \n-      switch (t->kind)\n-\t{\n-\tcase TYPE_STRING:\n-\t  /* Do nothing; strings go in the string pool.  */\n-\t  break;\n+    case TYPE_POINTER:\n+      {\n+\tif (maybe_undef_p\n+\t    && t->u.p->u.s.line.file == NULL)\n+\t  {\n+\t    oprintf (d->of, \"%*sif (%s) abort();\\n\", d->indent, \"\", d->val);\n+\t    break;\n+\t  }\n \n-\tcase TYPE_LANG_STRUCT:\n+\tif (! length)\n \t  {\n-\t    type_p ti;\n-\t    for (ti = t->u.s.lang_struct; ti; ti = ti->next)\n-\t      if (ti->u.s.bitmap & bitmap)\n-\t\t{\n-\t\t  t = ti;\n-\t\t  break;\n-\t\t}\n-\t    if (ti == NULL)\n+\t    if (! UNION_OR_STRUCT_P (t->u.p)\n+\t\t&& t->u.p->kind != TYPE_PARAM_STRUCT)\n \t      {\n-\t\terror_at_line (&f->line, \n-\t\t\t       \"structure not defined for this language\");\n+\t\terror_at_line (d->line, \n+\t\t\t       \"field `%s' is pointer to unimplemented type\",\n+\t\t\t       d->val);\n \t\tbreak;\n \t      }\n+\t    \n+\t    d->process_field (t->u.p, d);\n \t  }\n-\t  /* Fall through...  */\n-\tcase TYPE_STRUCT:\n-\tcase TYPE_UNION:\n+\telse \n \t  {\n+\t    int loopcounter = d->counter++;\n+\t    const char *oldval = d->val;\n+\t    const char *oldprevval3 = d->prev_val[3];\n \t    char *newval;\n \n-\t    newval = xasprintf (\"%s%s%s\", val, dot, f->name);\n-\t    write_gc_structure_fields (of, t, newval, val, f->opt, indent, \n-\t\t\t\t       &f->line, bitmap, param);\n+\t    oprintf (d->of, \"%*sif (%s != NULL) {\\n\", d->indent, \"\", d->val);\n+\t    d->indent += 2;\n+\t    oprintf (d->of, \"%*ssize_t i%d;\\n\", d->indent, \"\", loopcounter);\n+\t    d->process_field(t, d);\n+\t    oprintf (d->of, \"%*sfor (i%d = 0; i%d < (size_t)(\", d->indent, \"\", \n+\t\t     loopcounter, loopcounter);\n+\t    output_escaped_param (d, length, \"length\");\n+\t    oprintf (d->of, \"); i%d++) {\\n\", loopcounter);\n+\t    d->indent += 2;\n+\t    d->val = newval = xasprintf (\"%s[i%d]\", oldval, loopcounter);\n+\t    d->used_length = 1;\n+\t    d->prev_val[3] = oldval;\n+\t    walk_type (t->u.p, d);\n \t    free (newval);\n-\t    break;\n+\t    d->val = oldval;\n+\t    d->prev_val[3] = oldprevval3;\n+\t    d->used_length = 0;\n+\t    d->indent -= 2;\n+\t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\t    d->indent -= 2;\n+\t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n \t  }\n+      }\n+      break;\n \n-\tcase TYPE_POINTER:\n-\t  if (! length)\n-\t    {\n-\t      if (maybe_undef_p\n-\t\t  && t->u.p->u.s.line.file == NULL)\n-\t\toprintf (of, \"%*sif (%s%s%s) abort();\\n\", indent, \"\",\n-\t\t\t val, dot, f->name);\n-\t      else if (UNION_OR_STRUCT_P (t->u.p)\n-\t\t       || t->u.p->kind == TYPE_PARAM_STRUCT)\n-\t\t{\n-\t\t  oprintf (of, \"%*sgt_ggc_m_\", indent, \"\");\n-\t\t  output_mangled_typename (of, t->u.p);\n-\t\t  oprintf (of, \" (\");\n-\t\t  if (needs_cast_p)\n-\t\t    oprintf (of, \"(%s %s *)\", \n-\t\t\t     UNION_P (t->u.p) ? \"union\" : \"struct\",\n-\t\t\t     t->u.p->u.s.tag);\n-\t\t  oprintf (of, \"%s%s%s);\\n\", val, dot, f->name);\n-\t\t}\n-\t      else\n-\t\terror_at_line (&f->line, \"field `%s' is pointer to scalar\",\n-\t\t\t       f->name);\n-\t      break;\n-\t    }\n-\t  else if (t->u.p->kind == TYPE_SCALAR\n-\t\t   || t->u.p->kind == TYPE_STRING)\n-\t    oprintf (of, \"%*sggc_mark (%s%s%s);\\n\", indent, \"\", \n-\t\t     val, dot, f->name);\n-\t  else\n-\t    {\n-\t      int loopcounter = ++gc_counter;\n-\t      \n-\t      oprintf (of, \"%*sif (%s%s%s != NULL) {\\n\", indent, \"\",\n-\t\t       val, dot, f->name);\n-\t      indent += 2;\n-\t      oprintf (of, \"%*ssize_t i%d;\\n\", indent, \"\", loopcounter);\n-\t      oprintf (of, \"%*sggc_set_mark (%s%s%s);\\n\", indent, \"\", \n-\t\t       val, dot, f->name);\n-\t      oprintf (of, \"%*sfor (i%d = 0; i%d < (size_t)(\", indent, \"\", \n-\t\t       loopcounter, loopcounter);\n-\t      output_escaped_param (of, length, val, prev_val, \"length\", line);\n-\t      oprintf (of, \"); i%d++) {\\n\", loopcounter);\n-\t      indent += 2;\n-\t      switch (t->u.p->kind)\n-\t\t{\n-\t\tcase TYPE_STRUCT:\n-\t\tcase TYPE_UNION:\n-\t\t  {\n-\t\t    char *newval;\n-\t\t    \n-\t\t    newval = xasprintf (\"%s%s%s[i%d]\", val, dot, f->name, \n-\t\t\t\t\tloopcounter);\n-\t\t    write_gc_structure_fields (of, t->u.p, newval, val,\n-\t\t\t\t\t       f->opt, indent, &f->line,\n-\t\t\t\t\t       bitmap, param);\n-\t\t    free (newval);\n-\t\t    break;\n-\t\t  }\n-\t\tcase TYPE_POINTER:\n-\t\t  if (UNION_OR_STRUCT_P (t->u.p->u.p)\n-\t\t      || t->u.p->u.p->kind == TYPE_PARAM_STRUCT)\n-\t\t    {\n-\t\t      oprintf (of, \"%*sgt_ggc_m_\", indent, \"\");\n-\t\t      output_mangled_typename (of, t->u.p->u.p);\n-\t\t      oprintf (of, \" (%s%s%s[i%d]);\\n\", val, dot, f->name,\n-\t\t\t       loopcounter);\n-\t\t    }\n-\t\t  else\n-\t\t    error_at_line (&f->line, \n-\t\t\t\t   \"field `%s' is array of pointer to scalar\",\n-\t\t\t\t   f->name);\n-\t\t  break;\n-\t\tdefault:\n-\t\t  error_at_line (&f->line, \n-\t\t\t\t \"field `%s' is array of unimplemented type\",\n-\t\t\t\t f->name);\n-\t\t  break;\n-\t\t}\n-\t      indent -= 2;\n-\t      oprintf (of, \"%*s}\\n\", indent, \"\");\n-\t      indent -= 2;\n-\t      oprintf (of, \"%*s}\\n\", indent, \"\");\n-\t    }\n+    case TYPE_ARRAY:\n+      {\n+\tint loopcounter = d->counter++;\n+\tconst char *oldval = d->val;\n+\tchar *newval;\n+\n+\t/* If it's an array of scalars, we optimise by not generating\n+\t   any code.  */\n+\tif (t->u.a.p->kind == TYPE_SCALAR)\n \t  break;\n+\t\n+\toprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n+\td->indent += 2;\n+\toprintf (d->of, \"%*ssize_t i%d;\\n\", d->indent, \"\", loopcounter);\n+\toprintf (d->of, \"%*sfor (i%d = 0; i%d < (size_t)(\", d->indent, \"\", \n+\t\t loopcounter, loopcounter);\n+\tif (length)\n+\t  output_escaped_param (d, length, \"length\");\n+\telse\n+\t  oprintf (d->of, \"%s\", t->u.a.len);\n+\toprintf (d->of, \"); i%d++) {\\n\", loopcounter);\n+\td->indent += 2;\n+\td->val = newval = xasprintf (\"%s[i%d]\", oldval, loopcounter);\n+\td->used_length = 1;\n+\twalk_type (t->u.a.p, d);\n+\tfree (newval);\n+\td->used_length = 0;\n+\td->val = oldval;\n+\td->indent -= 2;\n+\toprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\td->indent -= 2;\n+\toprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+      }\n+      break;\n+      \n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+      {\n+\tpair_p f;\n+\tconst char *oldval = d->val;\n+\tconst char *oldprevval1 = d->prev_val[1];\n+\tconst char *oldprevval2 = d->prev_val[2];\n+\tconst int union_p = t->kind == TYPE_UNION;\n+\tint seen_default_p = 0;\n+\toptions_p o;\n+\n+\tif (! t->u.s.line.file)\n+\t  error_at_line (d->line, \"incomplete structure `%s'\", t->u.s.tag);\n \n-\tcase TYPE_ARRAY:\n+\tif ((d->bitmap & t->u.s.bitmap) != d->bitmap)\n \t  {\n-\t    int loopcounter = ++gc_counter;\n-\t    type_p ta;\n-\t    int i;\n-\n-\t    if (! length &&\n-\t\t(strcmp (t->u.a.len, \"0\") == 0\n-\t\t || strcmp (t->u.a.len, \"1\") == 0))\n-\t      error_at_line (&f->line, \n-\t\t\t     \"field `%s' is array of size %s\",\n-\t\t\t     f->name, t->u.a.len);\n-\t    \n-\t    /* Arrays of scalars can be ignored.  */\n-\t    for (ta = t; ta->kind == TYPE_ARRAY; ta = ta->u.a.p)\n-\t      ;\n-\t    if (ta->kind == TYPE_SCALAR\n-\t\t|| ta->kind == TYPE_STRING)\n-\t      break;\n+\t    error_at_line (d->line,\n+\t\t\t   \"structure `%s' defined for mismatching languages\",\n+\t\t\t   t->u.s.tag);\n+\t    error_at_line (&t->u.s.line, \"one structure defined here\");\n+\t  }\n \n-\t    oprintf (of, \"%*s{\\n\", indent, \"\");\n-\t    indent += 2;\n+\t/* Some things may also be defined in the structure's options.  */\n+\tfor (o = t->u.s.opt; o; o = o->next)\n+\t  if (! desc && strcmp (o->name, \"desc\") == 0)\n+\t    desc = (const char *)o->info;\n \n-\t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n+\td->prev_val[2] = oldval;\n+\td->prev_val[1] = oldprevval2;\n+\tif (union_p)\n+\t  {\n+\t    if (desc == NULL)\n \t      {\n-\t\toprintf (of, \"%*ssize_t i%d_%d;\\n\", \n-\t\t\t indent, \"\", loopcounter, i);\n-\t\toprintf (of, \"%*sconst size_t ilimit%d_%d = (\",\n-\t\t\t indent, \"\", loopcounter, i);\n-\t\tif (i == 0 && length != NULL)\n-\t\t  output_escaped_param (of, length, val, prev_val, \n-\t\t\t\t\t\"length\", line);\n-\t\telse\n-\t\t  oprintf (of, \"%s\", ta->u.a.len);\n-\t\toprintf (of, \");\\n\");\n+\t\terror_at_line (d->line, \"missing `desc' option for union `%s'\",\n+\t\t\t       t->u.s.tag);\n+\t\tdesc = \"1\";\n \t      }\n-\t\t\n-\t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n+\t    oprintf (d->of, \"%*sswitch (\", d->indent, \"\");\n+\t    output_escaped_param (d, desc, \"desc\");\n+\t    oprintf (d->of, \")\\n\");\n+\t    d->indent += 2;\n+\t    oprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n+\t  }\n+\tfor (f = t->u.s.fields; f; f = f->next)\n+\t  {\n+\t    options_p oo;\n+\t    const char *dot = \".\";\n+\t    const char *tagid = NULL;\n+\t    int skip_p = 0;\n+\t    int default_p = 0;\n+\t    int use_param_p = 0;\n+\t    char *newval;\n+\n+\t    d->reorder_fn = NULL;\n+\t    for (oo = f->opt; oo; oo = oo->next)\n+\t      if (strcmp (oo->name, \"dot\") == 0)\n+\t\tdot = (const char *)oo->info;\n+\t      else if (strcmp (oo->name, \"tag\") == 0)\n+\t\ttagid = (const char *)oo->info;\n+\t      else if (strcmp (oo->name, \"skip\") == 0)\n+\t\tskip_p = 1;\n+\t      else if (strcmp (oo->name, \"default\") == 0)\n+\t\tdefault_p = 1;\n+\t      else if (strcmp (oo->name, \"reorder\") == 0)\n+\t\td->reorder_fn = (const char *)oo->info;\n+\t      else if (strncmp (oo->name, \"use_param\", 9) == 0\n+\t\t       && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n+\t\tuse_param_p = 1;\n+\n+\t    if (skip_p)\n+\t      continue;\n+\n+\t    if (union_p && tagid)\n \t      {\n-\t\toprintf (of, \n-\t\t \"%*sfor (i%d_%d = 0; i%d_%d < ilimit%d_%d; i%d_%d++) {\\n\",\n-\t\t\t indent, \"\", loopcounter, i, loopcounter, i,\n-\t\t\t loopcounter, i, loopcounter, i);\n-\t\tindent += 2;\n+\t\toprintf (d->of, \"%*scase %s:\\n\", d->indent, \"\", tagid);\n+\t\td->indent += 2;\n \t      }\n-\n-\t    if (ta->kind == TYPE_POINTER\n-\t\t&& (UNION_OR_STRUCT_P (ta->u.p)\n-\t\t    || ta->u.p->kind == TYPE_PARAM_STRUCT))\n+\t    else if (union_p && default_p)\n \t      {\n-\t\toprintf (of, \"%*sgt_ggc_m_\", indent, \"\");\n-\t\toutput_mangled_typename (of, ta->u.p);\n-\t\toprintf (of, \" (%s%s%s\", val, dot, f->name);\n-\t\tfor (ta = t, i = 0; \n-\t\t     ta->kind == TYPE_ARRAY; \n-\t\t     ta = ta->u.a.p, i++)\n-\t\t  oprintf (of, \"[i%d_%d]\", loopcounter, i);\n-\t\toprintf (of, \");\\n\");\n+\t\toprintf (d->of, \"%*sdefault:\\n\", d->indent, \"\");\n+\t\td->indent += 2;\n+\t\tseen_default_p = 1;\n \t      }\n-\t    else if (ta->kind == TYPE_STRUCT || ta->kind == TYPE_UNION)\n+\t    else if (! union_p && (default_p || tagid))\n+\t      error_at_line (d->line, \n+\t\t\t     \"can't use `%s' outside a union on field `%s'\",\n+\t\t\t     default_p ? \"default\" : \"tag\", f->name);\n+\t    else if (union_p && ! (default_p || tagid)\n+\t\t     && f->type->kind == TYPE_SCALAR)\n \t      {\n-\t\tchar *newval;\n-\t\tint len;\n-\t\t\n-\t\tlen = strlen (val) + strlen (f->name) + 2;\n-\t\tfor (ta = t; ta->kind == TYPE_ARRAY; ta = ta->u.a.p)\n-\t\t  len += sizeof (\"[i_]\") + 2*6;\n-\t\t\n-\t\tnewval = xmalloc (len);\n-\t\tsprintf (newval, \"%s%s%s\", val, dot, f->name);\n-\t\tfor (ta = t, i = 0; \n-\t\t     ta->kind == TYPE_ARRAY; \n-\t\t     ta = ta->u.a.p, i++)\n-\t\t  sprintf (newval + strlen (newval), \"[i%d_%d]\", \n-\t\t\t   loopcounter, i);\n-\t\twrite_gc_structure_fields (of, t->u.p, newval, val,\n-\t\t\t\t\t   f->opt, indent, &f->line, bitmap,\n-\t\t\t\t\t   param);\n-\t\tfree (newval);\n+\t\tfprintf (stderr,\n+\t\"%s:%d: warning: field `%s' is missing `tag' or `default' option\\n\",\n+\t\t\t d->line->file, d->line->line, f->name);\n+\t\tcontinue;\n \t      }\n-\t    else if (ta->kind == TYPE_POINTER && ta->u.p->kind == TYPE_SCALAR\n-\t\t     && use_param_num != -1 && param == NULL)\n-\t      oprintf (of, \"%*sabort();\\n\", indent, \"\");\n-\t    else\n-\t      error_at_line (&f->line, \n-\t\t\t     \"field `%s' is array of unimplemented type\",\n+\t    else if (union_p && ! (default_p || tagid))\n+\t      error_at_line (d->line, \n+\t\t\t     \"field `%s' is missing `tag' or `default' option\",\n \t\t\t     f->name);\n-\t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n+\t    \n+\t    d->line = &f->line;\n+\t    d->val = newval = xasprintf (\"%s%s%s\", oldval, dot, f->name);\n+\t    d->opt = f->opt;\n+\n+\t    if (union_p && use_param_p && d->param == NULL)\n+\t      oprintf (d->of, \"%*sabort();\\n\", d->indent, \"\");\n+\t    else\n+\t      walk_type (f->type, d);\n+\n+\t    free (newval);\n+\n+\t    if (union_p)\n \t      {\n-\t\tindent -= 2;\n-\t\toprintf (of, \"%*s}\\n\", indent, \"\");\n+\t\toprintf (d->of, \"%*sbreak;\\n\", d->indent, \"\");\n+\t\td->indent -= 2;\n \t      }\n+\t  }\n+\td->reorder_fn = NULL;\n \n-\t    indent -= 2;\n-\t    oprintf (of, \"%*s}\\n\", indent, \"\");\n-\t    break;\n+\td->val = oldval;\n+\td->prev_val[1] = oldprevval1;\n+\td->prev_val[2] = oldprevval2;\n+\n+\tif (union_p && ! seen_default_p)\n+\t  {\n+\t    oprintf (d->of, \"%*sdefault:\\n\", d->indent, \"\");\n+\t    oprintf (d->of, \"%*s  break;\\n\", d->indent, \"\");\n+\t  }\n+\tif (union_p)\n+\t  {\n+\t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\t    d->indent -= 2;\n \t  }\n+      }\n+      break;\n \n-\tdefault:\n-\t  error_at_line (&f->line, \n-\t\t\t \"field `%s' is unimplemented type\",\n-\t\t\t f->name);\n-\t  break;\n-\t}\n+    case TYPE_LANG_STRUCT:\n+      {\n+\ttype_p nt;\n+\tfor (nt = t->u.s.lang_struct; nt; nt = nt->next)\n+\t  if ((d->bitmap & nt->u.s.bitmap) == d->bitmap)\n+\t    break;\n+\tif (nt == NULL)\n+\t  error_at_line (d->line, \"structure `%s' differs between languages\",\n+\t\t\t t->u.s.tag);\n+\telse\n+\t  walk_type (nt, d);\n+      }\n+      break;\n+\n+    case TYPE_PARAM_STRUCT:\n+      {\n+\ttype_p *oldparam = d->param;\n+\t\n+\td->param = t->u.param_struct.param;\n+\twalk_type (t->u.param_struct.stru, d);\n+\td->param = oldparam;\n+      }\n+      break;\n       \n-      if (s->kind == TYPE_UNION)\n-\t{\n-\t  oprintf (of, \"%*sbreak;\\n\", indent, \"\");\n-\t  indent -= 2;\n-\t}\n+    default:\n+      abort ();\n     }\n-  if (s->kind == TYPE_UNION)\n+}\n+\n+/* process_field routine for marking routines.  */\n+\n+static void\n+write_types_process_field (f, d)\n+     type_p f;\n+     const struct walk_type_data *d;\n+{\n+  const struct write_types_data *wtd;\n+  wtd = (const struct write_types_data *) d->cookie;\n+  \n+  switch (f->kind)\n     {\n-      if (! seen_default)\n+    case TYPE_POINTER:\n+      oprintf (d->of, \"%*s%s (%s\", d->indent, \"\", \n+\t       wtd->subfield_marker_routine, d->val);\n+      if (wtd->param_prefix)\n \t{\n-\t  oprintf (of, \"%*sdefault:\\n\", indent, \"\");\n-\t  oprintf (of, \"%*s  break;\\n\", indent, \"\");\n+\t  oprintf (d->of, \", %s\", d->prev_val[3]);\n+\t  if (d->orig_s)\n+\t    {\n+\t      oprintf (d->of, \", gt_%s_\", wtd->param_prefix);\n+\t      output_mangled_typename (d->of, d->orig_s);\n+\t    }\n+\t  else\n+\t    oprintf (d->of, \", gt_%sa_%s\", wtd->param_prefix, d->prev_val[0]);\n \t}\n-      oprintf (of, \"%*s}\\n\", indent, \"\");\n-      indent -= 2;\n+      oprintf (d->of, \");\\n\");\n+      if (d->reorder_fn && wtd->reorder_note_routine)\n+\toprintf (d->of, \"%*s%s (%s, %s, %s);\\n\", d->indent, \"\", \n+\t\t wtd->reorder_note_routine, d->val,\n+\t\t d->prev_val[3], d->reorder_fn);\n+      break;\n+\n+    case TYPE_STRING:\n+      if (wtd->param_prefix == NULL)\n+\tbreak;\n+\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+    case TYPE_PARAM_STRUCT:\n+      oprintf (d->of, \"%*sgt_%s_\", d->indent, \"\", wtd->prefix);\n+      output_mangled_typename (d->of, f);\n+      oprintf (d->of, \" (%s);\\n\", d->val);\n+      if (d->reorder_fn && wtd->reorder_note_routine)\n+\toprintf (d->of, \"%*s%s (%s, %s, %s);\\n\", d->indent, \"\", \n+\t\t wtd->reorder_note_routine, d->val, d->val,\n+\t\t d->reorder_fn);\n+      break;\n+\n+    case TYPE_SCALAR:\n+      break;\n+      \n+    default:\n+      abort ();\n     }\n }\n \n-/* Write out a marker routine for S.  PARAM is the parameter from an\n-   enclosing PARAM_IS option.  */\n+/* For S, a structure that's part of ORIG_S, and using parameters\n+   PARAM, write out a routine that:\n+   - Takes a parameter, a void * but actually of type *S\n+   - If SEEN_ROUTINE returns nonzero, calls write_types_process_field on each\n+     field of S or its substructures and (in some cases) things\n+     that are pointed to by S.\n+*/\n \n static void\n-write_gc_marker_routine_for_structure (orig_s, s, param)\n+write_func_for_structure (orig_s, s, param, wtd)\n      type_p orig_s;\n      type_p s;\n      type_p * param;\n+     const struct write_types_data *wtd;\n {\n-  outf_p f;\n   const char *fn = s->u.s.line.file;\n   int i;\n   const char *chain_next = NULL;\n   const char *chain_prev = NULL;\n   options_p opt;\n+  struct walk_type_data d;\n   \n   /* This is a hack, and not the good kind either.  */\n   for (i = NUM_PARAM - 1; i >= 0; i--)\n     if (param && param[i] && param[i]->kind == TYPE_POINTER \n \t&& UNION_OR_STRUCT_P (param[i]->u.p))\n       fn = param[i]->u.p->u.s.line.file;\n   \n-  f = get_output_file_with_visibility (fn);\n+  memset (&d, 0, sizeof (d));\n+  d.of = get_output_file_with_visibility (fn);\n   \n   for (opt = s->u.s.opt; opt; opt = opt->next)\n     if (strcmp (opt->name, \"chain_next\") == 0)\n@@ -1904,80 +1973,113 @@ write_gc_marker_routine_for_structure (orig_s, s, param)\n   if (chain_prev != NULL && chain_next == NULL)\n     error_at_line (&s->u.s.line, \"chain_prev without chain_next\");\n \n-  oprintf (f, \"\\n\");\n-  oprintf (f, \"void\\n\");\n+  d.process_field = write_types_process_field;\n+  d.cookie = wtd;\n+  d.orig_s = orig_s;\n+  d.opt = s->u.s.opt;\n+  d.line = &s->u.s.line;\n+  d.bitmap = s->u.s.bitmap;\n+  d.param = param;\n+  d.prev_val[0] = \"*x\";\n+  d.prev_val[1] = \"not valid postage\";  /* guarantee an error */\n+  d.prev_val[3] = \"x\";\n+  d.val = \"(*x)\";\n+\n+  oprintf (d.of, \"\\n\");\n+  oprintf (d.of, \"void\\n\");\n   if (param == NULL)\n-    oprintf (f, \"gt_ggc_mx_%s\", s->u.s.tag);\n+    oprintf (d.of, \"gt_%sx_%s\", wtd->prefix, orig_s->u.s.tag);\n   else\n     {\n-      oprintf (f, \"gt_ggc_m_\");\n-      output_mangled_typename (f, orig_s);\n+      oprintf (d.of, \"gt_%s_\", wtd->prefix);\n+      output_mangled_typename (d.of, orig_s);\n     }\n-  oprintf (f, \" (x_p)\\n\");\n-  oprintf (f, \"      void *x_p;\\n\");\n-  oprintf (f, \"{\\n\");\n-  oprintf (f, \"  %s %s * %sx = (%s %s *)x_p;\\n\",\n+  oprintf (d.of, \" (x_p)\\n\");\n+  oprintf (d.of, \"      void *x_p;\\n\");\n+  oprintf (d.of, \"{\\n\");\n+  oprintf (d.of, \"  %s %s * %sx = (%s %s *)x_p;\\n\",\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n \t   chain_next == NULL ? \"const \" : \"\",\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n   if (chain_next != NULL)\n-    oprintf (f, \"  %s %s * xlimit = x;\\n\",\n+    oprintf (d.of, \"  %s %s * xlimit = x;\\n\",\n \t     s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n   if (chain_next == NULL)\n-    oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n+    {\n+      oprintf (d.of, \"  if (%s (x\", wtd->marker_routine);\n+      if (wtd->param_prefix)\n+\t{\n+\t  oprintf (d.of, \", x, gt_%s_\", wtd->param_prefix);\n+\t  output_mangled_typename (d.of, orig_s);\n+\t}\n+      oprintf (d.of, \"))\\n\");\n+    }\n   else\n     {\n-      oprintf (f, \"  while (ggc_test_and_set_mark (xlimit))\\n\");\n-      oprintf (f, \"   xlimit = (\");\n-      output_escaped_param (f, chain_next, \"*xlimit\", \"*xlimit\", \n-\t\t\t    \"chain_next\", &s->u.s.line);\n-      oprintf (f, \");\\n\");\n+      oprintf (d.of, \"  while (%s (xlimit\", wtd->marker_routine);\n+      if (wtd->param_prefix)\n+\t{\n+\t  oprintf (d.of, \", xlimit, gt_%s_\", wtd->param_prefix);\n+\t  output_mangled_typename (d.of, orig_s);\n+\t}\n+      oprintf (d.of, \"))\\n\");\n+      oprintf (d.of, \"   xlimit = (\");\n+      d.prev_val[2] = \"*xlimit\";\n+      output_escaped_param (&d, chain_next, \"chain_next\");\n+      oprintf (d.of, \");\\n\");\n       if (chain_prev != NULL)\n \t{\n-\t  oprintf (f, \"  if (x != xlimit)\\n\");\n-\t  oprintf (f, \"    for (;;)\\n\");\n-\t  oprintf (f, \"      {\\n\");\n-\t  oprintf (f, \"        %s %s * const xprev = (\",\n+\t  oprintf (d.of, \"  if (x != xlimit)\\n\");\n+\t  oprintf (d.of, \"    for (;;)\\n\");\n+\t  oprintf (d.of, \"      {\\n\");\n+\t  oprintf (d.of, \"        %s %s * const xprev = (\",\n \t\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-\t  output_escaped_param (f, chain_prev, \"*x\", \"*x\",\n-\t\t\t\t\"chain_prev\", &s->u.s.line);\n-\t  oprintf (f, \");\\n\");\n-\t  oprintf (f, \"        if (xprev == NULL) break;\\n\");\n-\t  oprintf (f, \"        x = xprev;\\n\");\n-\t  oprintf (f, \"        ggc_set_mark (xprev);\\n\");\n-\t  oprintf (f, \"      }\\n\");\n+\t  \n+\t  d.prev_val[2] = \"*x\";\n+\t  output_escaped_param (&d, chain_prev, \"chain_prev\");\n+\t  oprintf (d.of, \");\\n\");\n+\t  oprintf (d.of, \"        if (xprev == NULL) break;\\n\");\n+\t  oprintf (d.of, \"        x = xprev;\\n\");\n+\t  oprintf (d.of, \"        (void) %s (xprev\", \n+\t\t   wtd->marker_routine);\n+\t  if (wtd->param_prefix)\n+\t    {\n+\t      oprintf (d.of, \", xprev, gt_%s_\", wtd->param_prefix);\n+\t      output_mangled_typename (d.of, orig_s);\n+\t    }\n+\t  oprintf (d.of, \");\\n\");\n+\t  oprintf (d.of, \"      }\\n\");\n \t}\n-      oprintf (f, \"  while (x != xlimit)\\n\");\n+      oprintf (d.of, \"  while (x != xlimit)\\n\");\n     }\n-  oprintf (f, \"    {\\n\");\n+  oprintf (d.of, \"    {\\n\");\n   \n-  gc_counter = 0;\n-  write_gc_structure_fields (f, s, \"(*x)\", \"not valid postage\",\n-\t\t\t     s->u.s.opt, 6, &s->u.s.line, s->u.s.bitmap,\n-\t\t\t     param);\n+  d.prev_val[2] = \"*x\";\n+  d.indent = 6;\n+  walk_type (s, &d);\n   \n   if (chain_next != NULL)\n     {\n-      oprintf (f, \"      x = (\");\n-      output_escaped_param (f, chain_next, \"*x\", \"*x\",\n-\t\t\t    \"chain_next\", &s->u.s.line);\n-      oprintf (f, \");\\n\");\n+      oprintf (d.of, \"      x = (\");\n+      output_escaped_param (&d, chain_next, \"chain_next\");\n+      oprintf (d.of, \");\\n\");\n     }\n \n-  oprintf (f, \"  }\\n\");\n-  oprintf (f, \"}\\n\");\n+  oprintf (d.of, \"    }\\n\");\n+  oprintf (d.of, \"}\\n\");\n }\n \n /* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n-write_gc_types (structures, param_structs)\n+write_types (structures, param_structs, wtd)\n      type_p structures;\n      type_p param_structs;\n+     const struct write_types_data *wtd;\n {\n   type_p s;\n   \n-  oprintf (header_file, \"\\n/* GC marker procedures.  */\\n\");\n+  oprintf (header_file, \"\\n/* %s*/\\n\", wtd->comment);\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO\n \t|| s->gc_used == GC_MAYBE_POINTED_TO)\n@@ -1988,11 +2090,12 @@ write_gc_types (structures, param_structs)\n \t    && s->u.s.line.file == NULL)\n \t  continue;\n \n-\toprintf (header_file, \"#define gt_ggc_m_\");\n+\toprintf (header_file, \"#define gt_%s_\", wtd->prefix);\n \toutput_mangled_typename (header_file, s);\n \toprintf (header_file, \"(X) do { \\\\\\n\");\n \toprintf (header_file,\n-\t\t \"  if (X != NULL) gt_ggc_mx_%s (X);\\\\\\n\", s->u.s.tag);\n+\t\t \"  if (X != NULL) gt_%sx_%s (X);\\\\\\n\", wtd->prefix, \n+\t\t s->u.s.tag);\n \toprintf (header_file,\n \t\t \"  } while (0)\\n\");\n \t\n@@ -2004,8 +2107,8 @@ write_gc_types (structures, param_structs)\n \t\t  || t->kind == TYPE_UNION\n \t\t  || t->kind == TYPE_LANG_STRUCT)\n \t\toprintf (header_file,\n-\t\t\t \"#define gt_ggc_mx_%s gt_ggc_mx_%s\\n\",\n-\t\t\t s->u.s.tag, t->u.s.tag);\n+\t\t\t \"#define gt_%sx_%s gt_%sx_%s\\n\",\n+\t\t\t wtd->prefix, s->u.s.tag, wtd->prefix, t->u.s.tag);\n \t      else\n \t\terror_at_line (&s->u.s.line, \n \t\t\t       \"structure alias is not a structure\");\n@@ -2016,8 +2119,8 @@ write_gc_types (structures, param_structs)\n \n \t/* Declare the marker procedure only once.  */\n \toprintf (header_file, \n-\t\t \"extern void gt_ggc_mx_%s PARAMS ((void *));\\n\",\n-\t\t s->u.s.tag);\n+\t\t \"extern void gt_%sx_%s PARAMS ((void *));\\n\",\n+\t\t wtd->prefix, s->u.s.tag);\n   \n \tif (s->u.s.line.file == NULL)\n \t  {\n@@ -2030,10 +2133,10 @@ write_gc_types (structures, param_structs)\n \t  {\n \t    type_p ss;\n \t    for (ss = s->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_gc_marker_routine_for_structure (s, ss, NULL);\n+\t      write_func_for_structure (s, ss, NULL, wtd);\n \t  }\n \telse\n-\t  write_gc_marker_routine_for_structure (s, s, NULL);\n+\t  write_func_for_structure (s, s, NULL, wtd);\n       }\n \n   for (s = param_structs; s; s = s->next)\n@@ -2043,7 +2146,7 @@ write_gc_types (structures, param_structs)\n \ttype_p stru = s->u.param_struct.stru;\n \n \t/* Declare the marker procedure.  */\n-\toprintf (header_file, \"extern void gt_ggc_m_\");\n+\toprintf (header_file, \"extern void gt_%s_\", wtd->prefix);\n \toutput_mangled_typename (header_file, s);\n \toprintf (header_file, \" PARAMS ((void *));\\n\");\n   \n@@ -2058,10 +2161,193 @@ write_gc_types (structures, param_structs)\n \t  {\n \t    type_p ss;\n \t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_gc_marker_routine_for_structure (s, ss, param);\n+\t      write_func_for_structure (s, ss, param, wtd);\n+\t  }\n+\telse\n+\t  write_func_for_structure (s, stru, param, wtd);\n+      }\n+}\n+\n+static const struct write_types_data ggc_wtd =\n+{\n+  \"ggc_m\", NULL, \"ggc_mark\", \"ggc_test_and_set_mark\", NULL,\n+  \"GC marker procedures.  \"\n+};\n+\n+static const struct write_types_data pch_wtd =\n+{\n+  \"pch_n\", \"pch_p\", \"gt_pch_note_object\", \"gt_pch_note_object\",\n+  \"gt_pch_note_reorder\",\n+  \"PCH type-walking procedures.  \"\n+};\n+\n+/* Write out the local pointer-walking routines.  */\n+\n+/* process_field routine for local pointer-walking.  */\n+\n+static void\n+write_types_local_process_field (f, d)\n+     type_p f;\n+     const struct walk_type_data *d;\n+{\n+  switch (f->kind)\n+    {\n+    case TYPE_POINTER:\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+    case TYPE_PARAM_STRUCT:\n+    case TYPE_STRING:\n+      oprintf (d->of, \"%*sif ((void *)(%s) == this_obj)\\n\", d->indent, \"\",\n+\t       d->prev_val[3]);\n+      oprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+      break;\n+\n+    case TYPE_SCALAR:\n+      break;\n+      \n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* For S, a structure that's part of ORIG_S, and using parameters\n+   PARAM, write out a routine that:\n+   - Is of type gt_note_pointers\n+   - If calls PROCESS_FIELD on each field of S or its substructures.\n+*/\n+\n+static void\n+write_local_func_for_structure (orig_s, s, param)\n+     type_p orig_s;\n+     type_p s;\n+     type_p * param;\n+{\n+  const char *fn = s->u.s.line.file;\n+  int i;\n+  struct walk_type_data d;\n+  \n+  /* This is a hack, and not the good kind either.  */\n+  for (i = NUM_PARAM - 1; i >= 0; i--)\n+    if (param && param[i] && param[i]->kind == TYPE_POINTER \n+\t&& UNION_OR_STRUCT_P (param[i]->u.p))\n+      fn = param[i]->u.p->u.s.line.file;\n+  \n+  memset (&d, 0, sizeof (d));\n+  d.of = get_output_file_with_visibility (fn);\n+  \n+  d.process_field = write_types_local_process_field;\n+  d.opt = s->u.s.opt;\n+  d.line = &s->u.s.line;\n+  d.bitmap = s->u.s.bitmap;\n+  d.param = param;\n+  d.prev_val[0] = d.prev_val[2] = \"*x\";\n+  d.prev_val[1] = \"not valid postage\";  /* guarantee an error */\n+  d.prev_val[3] = \"x\";\n+  d.val = \"(*x)\";\n+\n+  oprintf (d.of, \"\\n\");\n+  oprintf (d.of, \"void\\n\");\n+  oprintf (d.of, \"gt_pch_p_\");\n+  output_mangled_typename (d.of, orig_s);\n+  oprintf (d.of, \" (this_obj, x_p, op, cookie)\\n\");\n+  oprintf (d.of, \"      void *this_obj ATTRIBUTE_UNUSED;\\n\");\n+  oprintf (d.of, \"      void *x_p;\\n\");\n+  oprintf (d.of, \"      gt_pointer_operator op ATTRIBUTE_UNUSED;\\n\");\n+  oprintf (d.of, \"      void *cookie ATTRIBUTE_UNUSED;\\n\");\n+  oprintf (d.of, \"{\\n\");\n+  oprintf (d.of, \"  %s %s * const x ATTRIBUTE_UNUSED = (%s %s *)x_p;\\n\",\n+\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n+\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+  d.indent = 2;\n+  walk_type (s, &d);\n+  oprintf (d.of, \"}\\n\");\n+}\n+\n+/* Write out local marker routines for STRUCTURES and PARAM_STRUCTS.  */\n+\n+static void\n+write_local (structures, param_structs)\n+     type_p structures;\n+     type_p param_structs;\n+{\n+  type_p s;\n+  \n+  oprintf (header_file, \"\\n/* Local pointer-walking routines.  */\\n\");\n+  for (s = structures; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO\n+\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+      {\n+\toptions_p opt;\n+\t\n+\tif (s->u.s.line.file == NULL)\n+\t  continue;\n+\n+\tfor (opt = s->u.s.opt; opt; opt = opt->next)\n+\t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n+\t    {\n+\t      type_p t = (type_p) opt->info;\n+\t      if (t->kind == TYPE_STRUCT \n+\t\t  || t->kind == TYPE_UNION\n+\t\t  || t->kind == TYPE_LANG_STRUCT)\n+\t\t{\n+\t\t  oprintf (header_file, \"#define gt_pch_p_\");\n+\t\t  output_mangled_typename (header_file, s);\n+\t\t  oprintf (header_file, \" gt_pch_p_\");\n+\t\t  output_mangled_typename (header_file, t);\n+\t\t  oprintf (header_file, \"\\n\");\n+\t\t}\n+\t      else\n+\t\terror_at_line (&s->u.s.line, \n+\t\t\t       \"structure alias is not a structure\");\n+\t      break;\n+\t    }\n+\tif (opt)\n+\t  continue;\n+\n+\t/* Declare the marker procedure only once.  */\n+\toprintf (header_file, \"extern void gt_pch_p_\");\n+\toutput_mangled_typename (header_file, s);\n+\toprintf (header_file, \n+\t \"\\n    PARAMS ((void *, void *, gt_pointer_operator, void *));\\n\");\n+  \n+\tif (s->kind == TYPE_LANG_STRUCT)\n+\t  {\n+\t    type_p ss;\n+\t    for (ss = s->u.s.lang_struct; ss; ss = ss->next)\n+\t      write_local_func_for_structure (s, ss, NULL);\n+\t  }\n+\telse\n+\t  write_local_func_for_structure (s, s, NULL);\n+      }\n+\n+  for (s = param_structs; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO)\n+      {\n+\ttype_p * param = s->u.param_struct.param;\n+\ttype_p stru = s->u.param_struct.stru;\n+\n+\t/* Declare the marker procedure.  */\n+\toprintf (header_file, \"extern void gt_pch_p_\");\n+\toutput_mangled_typename (header_file, s);\n+\toprintf (header_file, \n+\t \"\\n    PARAMS ((void *, void *, gt_pointer_operator, void *));\\n\");\n+  \n+\tif (stru->u.s.line.file == NULL)\n+\t  {\n+\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\", \n+\t\t     s->u.s.tag);\n+\t    continue;\n+\t  }\n+  \n+\tif (stru->kind == TYPE_LANG_STRUCT)\n+\t  {\n+\t    type_p ss;\n+\t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n+\t      write_local_func_for_structure (s, ss, param);\n \t  }\n \telse\n-\t  write_gc_marker_routine_for_structure (s, stru, param);\n+\t  write_local_func_for_structure (s, stru, param);\n       }\n }\n \n@@ -2099,6 +2385,25 @@ write_enum_defn (structures, param_structs)\n   oprintf (header_file, \"};\\n\");\n }\n \n+/* Might T contain any non-pointer elements?  */\n+\n+static int\n+contains_scalar_p (t)\n+     type_p t;\n+{\n+  switch (t->kind)\n+    {\n+    case TYPE_STRING:\n+    case TYPE_POINTER:\n+      return 0;\n+    case TYPE_ARRAY:\n+      return contains_scalar_p (t->u.a.p);\n+    default:\n+      /* Could also check for structures that have no non-pointer\n+\t fields, but there aren't enough of those to worry about.  */\n+      return 1;\n+    }\n+}\n \n /* Mangle FN and print it to F.  */\n \n@@ -2128,7 +2433,6 @@ finish_root_table (flp, pfx, lastname, tname, name)\n      const char *name;\n {\n   struct flist *fli2;\n-  unsigned started_bitmap = 0;\n   \n   for (fli2 = flp; fli2; fli2 = fli2->next)\n     if (fli2->started_p)\n@@ -2147,12 +2451,21 @@ finish_root_table (flp, pfx, lastname, tname, name)\n \t  if (bitmap & 1)\n \t    {\n \t      oprintf (base_files[fnum],\n-\t\t       \"extern const struct %s gt_ggc_%s_\",\n+\t\t       \"extern const struct %s gt_%s_\",\n \t\t       tname, pfx);\n \t      put_mangled_filename (base_files[fnum], fli2->name);\n \t      oprintf (base_files[fnum], \"[];\\n\");\n \t    }\n       }\n+  \n+  {\n+    size_t fnum;\n+    for (fnum = 0; fnum < NUM_BASE_FILES; fnum++)\n+      oprintf (base_files [fnum],\n+\t       \"const struct %s * const %s[] = {\\n\",\n+\t       tname, name);\n+  }\n+  \n \n   for (fli2 = flp; fli2; fli2 = fli2->next)\n     if (fli2->started_p)\n@@ -2165,29 +2478,19 @@ finish_root_table (flp, pfx, lastname, tname, name)\n \tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n \t  if (bitmap & 1)\n \t    {\n-\t      if (! (started_bitmap & (1 << fnum)))\n-\t\t{\n-\t\t  oprintf (base_files [fnum],\n-\t\t\t   \"const struct %s * const %s[] = {\\n\",\n-\t\t\t   tname, name);\n-\t\t  started_bitmap |= 1 << fnum;\n-\t\t}\n-\t      oprintf (base_files[fnum], \"  gt_ggc_%s_\", pfx);\n+\t      oprintf (base_files[fnum], \"  gt_%s_\", pfx);\n \t      put_mangled_filename (base_files[fnum], fli2->name);\n \t      oprintf (base_files[fnum], \",\\n\");\n \t    }\n       }\n \n   {\n-    unsigned bitmap;\n-    int fnum;\n-    \n-    for (bitmap = started_bitmap, fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n-      if (bitmap & 1)\n-\t{\n-\t  oprintf (base_files[fnum], \"  NULL\\n\");\n-\t  oprintf (base_files[fnum], \"};\\n\");\n-\t}\n+    size_t fnum;\n+    for (fnum = 0; fnum < NUM_BASE_FILES; fnum++)\n+      {\n+\toprintf (base_files[fnum], \"  NULL\\n\");\n+\toprintf (base_files[fnum], \"};\\n\");\n+      }\n   }\n }\n \n@@ -2197,7 +2500,7 @@ finish_root_table (flp, pfx, lastname, tname, name)\n    is nonzero iff we are building the root table for hash table caches.  */\n \n static void\n-write_gc_root (f, v, type, name, has_length, line, if_marked)\n+write_root (f, v, type, name, has_length, line, if_marked)\n      outf_p f;\n      pair_p v;\n      type_p type;\n@@ -2257,8 +2560,8 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t\t    char *newname;\n \t\t    newname = xasprintf (\"%s.%s.%s\", \n \t\t\t\t\t name, fld->name, validf->name);\n-\t\t    write_gc_root (f, v, validf->type, newname, 0, line,\n-\t\t\t\t   if_marked);\n+\t\t    write_root (f, v, validf->type, newname, 0, line,\n+\t\t\t\tif_marked);\n \t\t    free (newname);\n \t\t  }\n \t      }\n@@ -2270,7 +2573,7 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t      {\n \t\tchar *newname;\n \t\tnewname = xasprintf (\"%s.%s\", name, fld->name);\n-\t\twrite_gc_root (f, v, fld->type, newname, 0, line, if_marked);\n+\t\twrite_root (f, v, fld->type, newname, 0, line, if_marked);\n \t\tfree (newname);\n \t      }\n \t  }\n@@ -2281,7 +2584,7 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n       {\n \tchar *newname;\n \tnewname = xasprintf (\"%s[0]\", name);\n-\twrite_gc_root (f, v, type->u.a.p, newname, has_length, line, if_marked);\n+\twrite_root (f, v, type->u.a.p, newname, has_length, line, if_marked);\n \tfree (newname);\n       }\n       break;\n@@ -2309,17 +2612,21 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t\n \tif (! has_length && UNION_OR_STRUCT_P (tp))\n \t  {\n-\t    oprintf (f, \"    &gt_ggc_mx_%s\\n\", tp->u.s.tag);\n+\t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", tp->u.s.tag);\n+\t    oprintf (f, \"    &gt_pch_nx_%s\", tp->u.s.tag);\n \t  }\n \telse if (! has_length && tp->kind == TYPE_PARAM_STRUCT)\n \t  {\n \t    oprintf (f, \"    &gt_ggc_m_\");\n \t    output_mangled_typename (f, tp);\n+\t    oprintf (f, \",\\n    &gt_pch_n_\");\n+\t    output_mangled_typename (f, tp);\n \t  }\n \telse if (has_length\n \t\t && (tp->kind == TYPE_POINTER || UNION_OR_STRUCT_P (tp)))\n \t  {\n-\t    oprintf (f, \"    &gt_ggc_ma_%s\", name);\n+\t    oprintf (f, \"    &gt_ggc_ma_%s,\\n\", name);\n+\t    oprintf (f, \"    &gt_pch_na_%s\", name);\n \t  }\n \telse\n \t  {\n@@ -2333,8 +2640,19 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n       }\n       break;\n \n-    case TYPE_SCALAR:\n     case TYPE_STRING:\n+      {\n+\toprintf (f, \"  {\\n\");\n+\toprintf (f, \"    &%s,\\n\", name);\n+\toprintf (f, \"    1, \\n\");\n+\toprintf (f, \"    sizeof (%s),\\n\", v->name);\n+\toprintf (f, \"    &gt_ggc_m_S,\\n\");\n+\toprintf (f, \"    &gt_pch_n_S\\n\");\n+\toprintf (f, \"  },\\n\");\n+      }\n+      break;\n+\t\n+    case TYPE_SCALAR:\n       break;\n       \n     default:\n@@ -2344,10 +2662,64 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n     }\n }\n \n+/* This generates a routine to walk an array.  */\n+\n+static void\n+write_array (f, v, wtd)\n+     outf_p f;\n+     pair_p v;\n+     const struct write_types_data *wtd;\n+{\n+  struct walk_type_data d;\n+  char *prevval3;\n+  \n+  memset (&d, 0, sizeof (d));\n+  d.of = f;\n+  d.cookie = wtd;\n+  d.indent = 2;\n+  d.line = &v->line;\n+  d.opt = v->opt;\n+  d.bitmap = get_base_file_bitmap (v->line.file);\n+  d.param = NULL;\n+\n+  d.prev_val[3] = prevval3 = xasprintf (\"&%s\", v->name);\n+\n+  if (wtd->param_prefix)\n+    {\n+      oprintf (f, \"static void gt_%sa_%s\\n\", wtd->param_prefix, v->name);\n+      oprintf (f, \n+       \"    PARAMS ((void *, void *, gt_pointer_operator, void *));\\n\");\n+      oprintf (f, \"static void gt_%sa_%s (this_obj, x_p, op, cookie)\\n\", \n+\t       wtd->param_prefix, v->name);\n+      oprintf (d.of, \"      void *this_obj ATTRIBUTE_UNUSED;\\n\");\n+      oprintf (d.of, \"      void *x_p ATTRIBUTE_UNUSED;\\n\");\n+      oprintf (d.of, \"      gt_pointer_operator op ATTRIBUTE_UNUSED;\\n\");\n+      oprintf (d.of, \"      void *cookie ATTRIBUTE_UNUSED;\\n\");\n+      oprintf (d.of, \"{\\n\");\n+      d.prev_val[0] = d.prev_val[1] = d.prev_val[2] = d.val = v->name;\n+      d.process_field = write_types_local_process_field;\n+      walk_type (v->type, &d);\n+      oprintf (f, \"}\\n\\n\");\n+    }\n+\n+  d.opt = v->opt;\n+  oprintf (f, \"static void gt_%sa_%s PARAMS ((void *));\\n\",\n+\t   wtd->prefix, v->name);\n+  oprintf (f, \"static void\\ngt_%sa_%s (x_p)\\n\",\n+\t   wtd->prefix, v->name);\n+  oprintf (f, \"      void *x_p ATTRIBUTE_UNUSED;\\n\");\n+  oprintf (f, \"{\\n\");\n+  d.prev_val[0] = d.prev_val[1] = d.prev_val[2] = d.val = v->name;\n+  d.process_field = write_types_process_field;\n+  walk_type (v->type, &d);\n+  free (prevval3);\n+  oprintf (f, \"}\\n\\n\");\n+}\n+\n /* Output a table describing the locations and types of VARIABLES.  */\n \n static void\n-write_gc_roots (variables)\n+write_roots (variables)\n      pair_p variables;\n {\n   pair_p v;\n@@ -2400,52 +2772,8 @@ write_gc_roots (variables)\n \t  && (v->type->u.p->kind == TYPE_POINTER\n \t      || v->type->u.p->kind == TYPE_STRUCT))\n \t{\n-\t  oprintf (f, \"static void gt_ggc_ma_%s PARAMS ((void *));\\n\",\n-\t\t   v->name);\n-\t  oprintf (f, \"static void\\ngt_ggc_ma_%s (x_p)\\n      void *x_p;\\n\",\n-\t\t   v->name);\n-\t  oprintf (f, \"{\\n\");\n-\t  oprintf (f, \"  size_t i;\\n\");\n-\n-\t  if (v->type->u.p->kind == TYPE_POINTER)\n-\t    {\n-\t      type_p s = v->type->u.p->u.p;\n-\n-\t      oprintf (f, \"  %s %s ** const x = (%s %s **)x_p;\\n\",\n-\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n-\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-\t      oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n-\t      oprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n-\t      if (! UNION_OR_STRUCT_P (s)\n-\t\t  && ! s->kind == TYPE_PARAM_STRUCT)\n-\t\t{\n-\t\t  error_at_line (&v->line, \n-\t\t\t\t \"global `%s' has unsupported ** type\",\n-\t\t\t\t v->name);\n-\t\t  continue;\n-\t\t}\n-\n-\t      oprintf (f, \"      gt_ggc_m_\");\n-\t      output_mangled_typename (f, s);\n-\t      oprintf (f, \" (x[i]);\\n\");\n-\t    }\n-\t  else\n-\t    {\n-\t      type_p s = v->type->u.p;\n-\n-\t      oprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n-\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n-\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-\t      oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n-\t      oprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n-\t      oprintf (f, \"      {\\n\");\n-\t      write_gc_structure_fields (f, s, \"x[i]\", \"x[i]\",\n-\t\t\t\t\t v->opt, 8, &v->line, s->u.s.bitmap,\n-\t\t\t\t\t NULL);\n-\t      oprintf (f, \"      }\\n\");\n-\t    }\n-\n-\t  oprintf (f, \"}\\n\\n\");\n+\t  write_array (f, v, &ggc_wtd);\n+\t  write_array (f, v, &pch_wtd);\n \t}\n     }\n \n@@ -2479,10 +2807,10 @@ write_gc_roots (variables)\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n \n-      write_gc_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n+      write_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n     }\n \n-  finish_root_table (flp, \"r\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\", \n+  finish_root_table (flp, \"ggc_r\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\", \n \t\t     \"gt_ggc_rtab\");\n \n   for (v = variables; v; v = v->next)\n@@ -2513,11 +2841,11 @@ write_gc_roots (variables)\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n       \n-      oprintf (f, \"  { &%s, 1, sizeof (%s), NULL },\\n\",\n+      oprintf (f, \"  { &%s, 1, sizeof (%s), NULL, NULL },\\n\",\n \t       v->name, v->name);\n     }\n   \n-  finish_root_table (flp, \"rd\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n+  finish_root_table (flp, \"ggc_rd\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_ggc_deletable_rtab\");\n \n   for (v = variables; v; v = v->next)\n@@ -2557,12 +2885,84 @@ write_gc_roots (variables)\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n       \n-      write_gc_root (f, v, v->type->u.p->u.param_struct.param[0],\n+      write_root (f, v, v->type->u.p->u.param_struct.param[0],\n \t\t     v->name, length_p, &v->line, if_marked);\n     }\n   \n-  finish_root_table (flp, \"rc\", \"LAST_GGC_CACHE_TAB\", \"ggc_cache_tab\",\n+  finish_root_table (flp, \"ggc_rc\", \"LAST_GGC_CACHE_TAB\", \"ggc_cache_tab\",\n \t\t     \"gt_ggc_cache_rtab\");\n+\n+  for (v = variables; v; v = v->next)\n+    {\n+      outf_p f = get_output_file_with_visibility (v->line.file);\n+      struct flist *fli;\n+      int length_p = 0;\n+      int if_marked_p = 0;\n+      options_p o;\n+      \n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"length\") == 0)\n+\t  length_p = 1;\n+\telse if (strcmp (o->name, \"if_marked\") == 0)\n+\t  if_marked_p = 1;\n+\n+      if (! if_marked_p)\n+\tcontinue;\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (! fli->started_p)\n+\t{\n+\t  fli->started_p = 1;\n+\n+\t  oprintf (f, \"const struct ggc_root_tab gt_pch_rc_\");\n+\t  put_mangled_filename (f, v->line.file);\n+\t  oprintf (f, \"[] = {\\n\");\n+\t}\n+\n+      write_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n+    }\n+  \n+  finish_root_table (flp, \"pch_rc\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n+\t\t     \"gt_pch_cache_rtab\");\n+\n+  for (v = variables; v; v = v->next)\n+    {\n+      outf_p f = get_output_file_with_visibility (v->line.file);\n+      struct flist *fli;\n+      int skip_p = 0;\n+      options_p o;\n+\n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"deletable\") == 0\n+\t    || strcmp (o->name, \"if_marked\") == 0)\n+\t  skip_p = 1;\n+\n+      if (skip_p)\n+\tcontinue;\n+\n+      if (! contains_scalar_p (v->type))\n+\tcontinue;\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (! fli->started_p)\n+\t{\n+\t  fli->started_p = 1;\n+\n+\t  oprintf (f, \"const struct ggc_root_tab gt_pch_rs_\");\n+\t  put_mangled_filename (f, v->line.file);\n+\t  oprintf (f, \"[] = {\\n\");\n+\t}\n+      \n+      oprintf (f, \"  { &%s, 1, sizeof (%s), NULL, NULL },\\n\",\n+\t       v->name, v->name);\n+    }\n+  \n+  finish_root_table (flp, \"pch_rs\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n+\t\t     \"gt_pch_scalar_rtab\");\n }\n \n \f\n@@ -2616,8 +3016,10 @@ main(argc, argv)\n \n   open_base_files ();\n   write_enum_defn (structures, param_structs);\n-  write_gc_types (structures, param_structs);\n-  write_gc_roots (variables);\n+  write_types (structures, param_structs, &ggc_wtd);\n+  write_types (structures, param_structs, &pch_wtd);\n+  write_local (structures, param_structs);\n+  write_roots (variables);\n   write_rtx_next ();\n   close_output_files ();\n "}, {"sha": "ed6d3b45a851313dc914cb0adf2b37bde3a0e385", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 448, "deletions": 105, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -24,14 +24,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"tm_p.h\"\n #include \"hashtab.h\"\n-#include \"varray.h\"\n #include \"ggc.h\"\n-#include \"langhooks.h\"\n+#include \"toplev.h\"\n+\n+#ifdef HAVE_MMAP_FILE\n+# include <sys/mman.h>\n+#endif\n+\n #ifdef ENABLE_VALGRIND_CHECKING\n #include <valgrind.h>\n #else\n@@ -42,46 +42,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n \n+struct traversal_state;\n+\n static int ggc_htab_delete PARAMS ((void **, void *));\n+static hashval_t saving_htab_hash PARAMS ((const PTR));\n+static int saving_htab_eq PARAMS ((const PTR, const PTR));\n+static int call_count PARAMS ((void **, void *));\n+static int call_alloc PARAMS ((void **, void *));\n+static int compare_ptr_data PARAMS ((const void *, const void *));\n+static void relocate_ptrs PARAMS ((void *, void *));\n+static void write_pch_globals PARAMS ((const struct ggc_root_tab * const *tab,\n+\t\t\t\t       struct traversal_state *state));\n \n /* Maintain global roots that are preserved during GC.  */\n \n-/* Global roots that are preserved during calls to gc.  */\n-\n-struct ggc_root\n-{\n-  struct ggc_root *next;\n-  void *base;\n-  int nelt;\n-  int size;\n-  void (*cb) PARAMS ((void *));\n-};\n-\n-static struct ggc_root *roots;\n-\n-/* Add BASE as a new garbage collection root.  It is an array of\n-   length NELT with each element SIZE bytes long.  CB is a\n-   function that will be called with a pointer to each element\n-   of the array; it is the intention that CB call the appropriate\n-   routine to mark gc-able memory for that element.  */\n-\n-void\n-ggc_add_root (base, nelt, size, cb)\n-     void *base;\n-     int nelt, size;\n-     void (*cb) PARAMS ((void *));\n-{\n-  struct ggc_root *x = (struct ggc_root *) xmalloc (sizeof (*x));\n-\n-  x->next = roots;\n-  x->base = base;\n-  x->nelt = nelt;\n-  x->size = size;\n-  x->cb = cb;\n-\n-  roots = x;\n-}\n-\n /* Process a slot of an htab by deleting it if it has not been marked.  */\n \n static int\n@@ -104,7 +78,6 @@ ggc_htab_delete (slot, info)\n void\n ggc_mark_roots ()\n {\n-  struct ggc_root *x;\n   const struct ggc_root_tab *const *rt;\n   const struct ggc_root_tab *rti;\n   const struct ggc_cache_tab *const *ct;\n@@ -120,23 +93,18 @@ ggc_mark_roots ()\n       for (i = 0; i < rti->nelt; i++)\n \t(*rti->cb)(*(void **)((char *)rti->base + rti->stride * i));\n \n-  for (x = roots; x != NULL; x = x->next)\n-    {\n-      char *elt = x->base;\n-      int s = x->size, n = x->nelt;\n-      void (*cb) PARAMS ((void *)) = x->cb;\n-      int i;\n-\n-      for (i = 0; i < n; ++i, elt += s)\n-\t(*cb)(elt);\n-    }\n+  ggc_mark_stringpool ();\n \n   /* Now scan all hash tables that have objects which are to be deleted if\n      they are not already marked.  */\n   for (ct = gt_ggc_cache_rtab; *ct; ct++)\n     for (cti = *ct; cti->base != NULL; cti++)\n       if (*cti->base)\n-\thtab_traverse (*cti->base, ggc_htab_delete, (PTR) cti);\n+\t{\n+\t  ggc_set_mark (*cti->base);\n+\t  htab_traverse (*cti->base, ggc_htab_delete, (PTR) cti);\n+\t  ggc_set_mark ((*cti->base)->entries);\n+\t}\n }\n \n /* Allocate a block of memory, then clear it.  */\n@@ -204,6 +172,26 @@ ggc_calloc (s1, s2)\n   return ggc_alloc_cleared (s1 * s2);\n }\n \n+/* These are for splay_tree_new_ggc.  */\n+PTR \n+ggc_splay_alloc (sz, nl)\n+     int sz;\n+     PTR nl;\n+{\n+  if (nl != NULL)\n+    abort ();\n+  return ggc_alloc (sz);\n+}\n+\n+void\n+ggc_splay_dont_free (x, nl)\n+     PTR x ATTRIBUTE_UNUSED;\n+     PTR nl;\n+{\n+  if (nl != NULL)\n+    abort ();\n+}\n+\n /* Print statistics that are independent of the collector in use.  */\n #define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n \t\t  ? (x) \\\n@@ -214,70 +202,425 @@ ggc_calloc (s1, s2)\n \n void\n ggc_print_common_statistics (stream, stats)\n-     FILE *stream;\n+     FILE *stream ATTRIBUTE_UNUSED;\n      ggc_statistics *stats;\n {\n-  int code;\n-\n   /* Set the pointer so that during collection we will actually gather\n      the statistics.  */\n   ggc_stats = stats;\n \n   /* Then do one collection to fill in the statistics.  */\n   ggc_collect ();\n \n-  /* Total the statistics.  */\n-  for (code = 0; code < MAX_TREE_CODES; ++code)\n+  /* At present, we don't really gather any interesting statistics.  */\n+\n+  /* Don't gather statistics any more.  */\n+  ggc_stats = NULL;\n+}\n+\f\n+/* Functions for saving and restoring GCable memory to disk.  */\n+\n+static htab_t saving_htab;\n+\n+struct ptr_data \n+{\n+  void *obj;\n+  void *note_ptr_cookie;\n+  gt_note_pointers note_ptr_fn;\n+  gt_handle_reorder reorder_fn;\n+  size_t size;\n+  void *new_addr;\n+};\n+\n+#define POINTER_HASH(x) (hashval_t)((long)x >> 3)\n+\n+/* Register an object in the hash table.  */\n+\n+int\n+gt_pch_note_object (obj, note_ptr_cookie, note_ptr_fn)\n+     void *obj;\n+     void *note_ptr_cookie;\n+     gt_note_pointers note_ptr_fn;\n+{\n+  struct ptr_data **slot;\n+  \n+  if (obj == NULL || obj == (void *) 1)\n+    return 0;\n+\n+  slot = (struct ptr_data **)\n+    htab_find_slot_with_hash (saving_htab, obj, POINTER_HASH (obj),\n+\t\t\t      INSERT);\n+  if (*slot != NULL)\n+    {\n+      if ((*slot)->note_ptr_fn != note_ptr_fn\n+\t  || (*slot)->note_ptr_cookie != note_ptr_cookie)\n+\tabort ();\n+      return 0;\n+    }\n+  \n+  *slot = xcalloc (sizeof (struct ptr_data), 1);\n+  (*slot)->obj = obj;\n+  (*slot)->note_ptr_fn = note_ptr_fn;\n+  (*slot)->note_ptr_cookie = note_ptr_cookie;\n+  if (note_ptr_fn == gt_pch_p_S)\n+    (*slot)->size = strlen (obj) + 1;\n+  else\n+    (*slot)->size = ggc_get_size (obj);\n+  return 1;\n+}\n+\n+/* Register an object in the hash table.  */\n+\n+void\n+gt_pch_note_reorder (obj, note_ptr_cookie, reorder_fn)\n+     void *obj;\n+     void *note_ptr_cookie;\n+     gt_handle_reorder reorder_fn;\n+{\n+  struct ptr_data *data;\n+  \n+  if (obj == NULL || obj == (void *) 1)\n+    return;\n+\n+  data = htab_find_with_hash (saving_htab, obj, POINTER_HASH (obj));\n+  if (data == NULL\n+      || data->note_ptr_cookie != note_ptr_cookie)\n+    abort ();\n+  \n+  data->reorder_fn = reorder_fn;\n+}\n+\n+/* Hash and equality functions for saving_htab, callbacks for htab_create.  */\n+\n+static hashval_t\n+saving_htab_hash (p)\n+     const PTR p;\n+{\n+  return POINTER_HASH (((struct ptr_data *)p)->obj);\n+}\n+\n+static int\n+saving_htab_eq (p1, p2)\n+     const PTR p1;\n+     const PTR p2;\n+{\n+  return ((struct ptr_data *)p1)->obj == p2;\n+}\n+\n+/* Handy state for the traversal functions.  */\n+\n+struct traversal_state \n+{\n+  FILE *f;\n+  struct ggc_pch_data *d;\n+  size_t count;\n+  struct ptr_data **ptrs;\n+  size_t ptrs_i;\n+};\n+\n+/* Callbacks for htab_traverse.  */\n+\n+static int\n+call_count (slot, state_p)\n+     void **slot;\n+     void *state_p;\n+{\n+  struct ptr_data *d = (struct ptr_data *)*slot;\n+  struct traversal_state *state = (struct traversal_state *)state_p;\n+  \n+  ggc_pch_count_object (state->d, d->obj, d->size);\n+  state->count++;\n+  return 1;\n+}\n+\n+static int\n+call_alloc (slot, state_p)\n+     void **slot;\n+     void *state_p;\n+{\n+  struct ptr_data *d = (struct ptr_data *)*slot;\n+  struct traversal_state *state = (struct traversal_state *)state_p;\n+  \n+  d->new_addr = ggc_pch_alloc_object (state->d, d->obj, d->size);\n+  state->ptrs[state->ptrs_i++] = d;\n+  return 1;\n+}\n+\n+/* Callback for qsort.  */\n+\n+static int\n+compare_ptr_data (p1_p, p2_p)\n+     const void *p1_p;\n+     const void *p2_p;\n+{\n+  struct ptr_data *p1 = *(struct ptr_data *const *)p1_p;\n+  struct ptr_data *p2 = *(struct ptr_data *const *)p2_p;\n+  return (((size_t)p1->new_addr > (size_t)p2->new_addr)\n+\t  - ((size_t)p1->new_addr < (size_t)p2->new_addr));\n+}\n+\n+/* Callbacks for note_ptr_fn.  */\n+\n+static void\n+relocate_ptrs (ptr_p, state_p)\n+     void *ptr_p;\n+     void *state_p;\n+{\n+  void **ptr = (void **)ptr_p;\n+  struct traversal_state *state ATTRIBUTE_UNUSED \n+    = (struct traversal_state *)state_p;\n+  struct ptr_data *result;\n+\n+  if (*ptr == NULL || *ptr == (void *)1)\n+    return;\n+  \n+  result = htab_find_with_hash (saving_htab, *ptr, POINTER_HASH (*ptr));\n+  if (result == NULL)\n+    abort ();\n+  *ptr = result->new_addr;\n+}\n+\n+/* Write out, after relocation, the pointers in TAB.  */\n+static void\n+write_pch_globals (tab, state)\n+     const struct ggc_root_tab * const *tab;\n+     struct traversal_state *state;\n+{\n+  const struct ggc_root_tab *const *rt;\n+  const struct ggc_root_tab *rti;\n+  size_t i;\n+\n+  for (rt = tab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\t{\n+\t  void *ptr = *(void **)((char *)rti->base + rti->stride * i);\n+\t  struct ptr_data *new_ptr;\n+\t  if (ptr == NULL || ptr == (void *)1)\n+\t    {\n+\t      if (fwrite (&ptr, sizeof (void *), 1, state->f) \n+\t\t  != 1)\n+\t\tfatal_io_error (\"can't write PCH file\");\n+\t    }\n+\t  else\n+\t    {\n+\t      new_ptr = htab_find_with_hash (saving_htab, ptr, \n+\t\t\t\t\t     POINTER_HASH (ptr));\n+\t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f) \n+\t\t  != 1)\n+\t\tfatal_io_error (\"can't write PCH file\");\n+\t    }\n+\t}\n+}\n+\n+/* Hold the information we need to mmap the file back in.  */\n+\n+struct mmap_info \n+{\n+  size_t offset;\n+  size_t size;\n+  void *preferred_base;\n+};\n+\n+/* Write out the state of the compiler to F.  */\n+\n+void\n+gt_pch_save (f)\n+     FILE *f;\n+{\n+  const struct ggc_root_tab *const *rt;\n+  const struct ggc_root_tab *rti;\n+  size_t i;\n+  struct traversal_state state;\n+  char *this_object = NULL;\n+  size_t this_object_size = 0;\n+  struct mmap_info mmi;\n+  size_t page_size = getpagesize();\n+\n+  gt_pch_save_stringpool ();\n+\n+  saving_htab = htab_create (50000, saving_htab_hash, saving_htab_eq, free);\n+\n+  for (rt = gt_ggc_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\t(*rti->pchw)(*(void **)((char *)rti->base + rti->stride * i));\n+\n+  for (rt = gt_pch_cache_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\t(*rti->pchw)(*(void **)((char *)rti->base + rti->stride * i));\n+\n+  /* Prepare the objects for writing, determine addresses and such.  */\n+  state.f = f;\n+  state.d = init_ggc_pch();\n+  state.count = 0;\n+  htab_traverse (saving_htab, call_count, &state);\n+\n+  mmi.size = ggc_pch_total_size (state.d);\n+\n+  /* Try to arrange things so that no relocation is necessary,\n+     but don't try very hard.  On most platforms, this will always work,\n+     and on the rest it's a lot of work to do better.  */\n+#if HAVE_MMAP_FILE\n+  mmi.preferred_base = mmap (NULL, mmi.size, \n+\t\t\t     PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t\t\t     fileno (state.f), 0);\n+  if (mmi.preferred_base == (void *)-1)\n+    mmi.preferred_base = NULL;\n+  else\n+    munmap (mmi.preferred_base, mmi.size);\n+#else /* HAVE_MMAP_FILE */\n+  mmi.preferred_base = NULL;\n+#endif /* HAVE_MMAP_FILE */\n+\n+  ggc_pch_this_base (state.d, mmi.preferred_base);\n+\n+  state.ptrs = xmalloc (state.count * sizeof (*state.ptrs));\n+  state.ptrs_i = 0;\n+  htab_traverse (saving_htab, call_alloc, &state);\n+  qsort (state.ptrs, state.count, sizeof (*state.ptrs), compare_ptr_data);\n+\n+  /* Write out all the scalar variables.  */\n+  for (rt = gt_pch_scalar_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      if (fwrite (rti->base, rti->stride, 1, f) != 1)\n+\tfatal_io_error (\"can't write PCH file\");\n+\n+  /* Write out all the global pointers, after translation.  */\n+  write_pch_globals (gt_ggc_rtab, &state);\n+  write_pch_globals (gt_pch_cache_rtab, &state);\n+\n+  ggc_pch_prepare_write (state.d, state.f);\n+  \n+  /* Pad the PCH file so that the mmaped area starts on a page boundary.  */\n+  {\n+    off_t o;\n+    o = ftello (state.f) + sizeof (mmi);\n+    if (o == (off_t) -1)\n+      fatal_io_error (\"can't get position in PCH file\");\n+    mmi.offset = page_size - o % page_size;\n+    if (mmi.offset == page_size)\n+      mmi.offset = 0;\n+    mmi.offset += o;\n+  }\n+  if (fwrite (&mmi, sizeof (mmi), 1, state.f) != 1)\n+    fatal_io_error (\"can't write PCH file\");\n+  if (mmi.offset != 0\n+      && fseek (state.f, mmi.offset, SEEK_SET) != 0)\n+    fatal_io_error (\"can't write padding to PCH file\");\n+\n+  /* Actually write out the objects.  */\n+  for (i = 0; i < state.count; i++)\n     {\n-      stats->total_num_trees += stats->num_trees[code];\n-      stats->total_size_trees += stats->size_trees[code];\n+      if (this_object_size < state.ptrs[i]->size)\n+\t{\n+\t  this_object_size = state.ptrs[i]->size;\n+\t  this_object = xrealloc (this_object, this_object_size);\n+\t}\n+      memcpy (this_object, state.ptrs[i]->obj, state.ptrs[i]->size);\n+      if (state.ptrs[i]->reorder_fn != NULL)\n+\tstate.ptrs[i]->reorder_fn (state.ptrs[i]->obj, \n+\t\t\t\t   state.ptrs[i]->note_ptr_cookie,\n+\t\t\t\t   relocate_ptrs, &state);\n+      state.ptrs[i]->note_ptr_fn (state.ptrs[i]->obj, \n+\t\t\t\t  state.ptrs[i]->note_ptr_cookie,\n+\t\t\t\t  relocate_ptrs, &state);\n+      ggc_pch_write_object (state.d, state.f, state.ptrs[i]->obj,\n+\t\t\t    state.ptrs[i]->new_addr, state.ptrs[i]->size);\n+      if (state.ptrs[i]->note_ptr_fn != gt_pch_p_S)\n+\tmemcpy (state.ptrs[i]->obj, this_object, state.ptrs[i]->size);\n     }\n-  for (code = 0; code < NUM_RTX_CODE; ++code)\n+  ggc_pch_finish (state.d, state.f);\n+\n+  free (state.ptrs);\n+  htab_delete (saving_htab);\n+}\n+\n+/* Read the state of the compiler back in from F.  */\n+\n+void\n+gt_pch_restore (f)\n+     FILE *f;\n+{\n+  const struct ggc_root_tab *const *rt;\n+  const struct ggc_root_tab *rti;\n+  size_t i;\n+  struct mmap_info mmi;\n+  void *addr;\n+\n+  /* Delete any deletable objects.  This makes ggc_pch_read much\n+     faster, as it can be sure that no GCable objects remain other\n+     than the ones just read in.  */\n+  for (rt = gt_ggc_deletable_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      memset (rti->base, 0, rti->stride);\n+\n+  /* Read in all the scalar variables.  */\n+  for (rt = gt_pch_scalar_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      if (fread (rti->base, rti->stride, 1, f) != 1)\n+\tfatal_io_error (\"can't read PCH file\");\n+\n+  /* Read in all the global pointers, in 6 easy loops.  */\n+  for (rt = gt_ggc_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\tif (fread ((char *)rti->base + rti->stride * i,\n+\t\t   sizeof (void *), 1, f) != 1)\n+\t  fatal_io_error (\"can't read PCH file\");\n+\n+  for (rt = gt_pch_cache_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\tif (fread ((char *)rti->base + rti->stride * i,\n+\t\t   sizeof (void *), 1, f) != 1)\n+\t  fatal_io_error (\"can't read PCH file\");\n+\n+  if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n+    fatal_io_error (\"can't read PCH file\");\n+  \n+#if HAVE_MMAP_FILE\n+  addr = mmap (mmi.preferred_base, mmi.size, \n+\t       PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t       fileno (f), mmi.offset);\n+#else\n+  addr = (void *)-1;\n+#endif\n+  if (addr == (void *)-1)\n     {\n-      stats->total_num_rtxs += stats->num_rtxs[code];\n-      stats->total_size_rtxs += stats->size_rtxs[code];\n+      addr = xmalloc (mmi.size);\n+      if (fseek (f, mmi.offset, SEEK_SET) != 0\n+\t  || fread (&mmi, mmi.size, 1, f) != 1)\n+\tfatal_io_error (\"can't read PCH file\");\n     }\n+  else if (fseek (f, mmi.offset + mmi.size, SEEK_SET) != 0)\n+    fatal_io_error (\"can't read PCH file\");\n \n-  /* Print the statistics for trees.  */\n-  fprintf (stream, \"\\n%-17s%10s %16s %10s\\n\", \"Tree\",\n-\t   \"Number\", \"Bytes\", \"% Total\");\n-  for (code = 0; code < MAX_TREE_CODES; ++code)\n-    if (ggc_stats->num_trees[code])\n-      {\n-\tfprintf (stream, \"%-17s%10u%16ld%c %10.3f\\n\",\n-\t\t tree_code_name[code],\n-\t\t ggc_stats->num_trees[code],\n-\t\t SCALE (ggc_stats->size_trees[code]),\n-\t\t LABEL (ggc_stats->size_trees[code]),\n-\t\t (100 * ((double) ggc_stats->size_trees[code])\n-\t\t  / ggc_stats->total_size_trees));\n-      }\n-  fprintf (stream,\n-\t   \"%-17s%10u%16ld%c\\n\", \"Total\",\n-\t   ggc_stats->total_num_trees,\n-\t   SCALE (ggc_stats->total_size_trees),\n-\t   LABEL (ggc_stats->total_size_trees));\n-\n-  /* Print the statistics for RTL.  */\n-  fprintf (stream, \"\\n%-17s%10s %16s %10s\\n\", \"RTX\",\n-\t   \"Number\", \"Bytes\", \"% Total\");\n-  for (code = 0; code < NUM_RTX_CODE; ++code)\n-    if (ggc_stats->num_rtxs[code])\n-      {\n-\tfprintf (stream, \"%-17s%10u%16ld%c %10.3f\\n\",\n-\t\t rtx_name[code],\n-\t\t ggc_stats->num_rtxs[code],\n-\t\t SCALE (ggc_stats->size_rtxs[code]),\n-\t\t LABEL (ggc_stats->size_rtxs[code]),\n-\t\t (100 * ((double) ggc_stats->size_rtxs[code])\n-\t\t  / ggc_stats->total_size_rtxs));\n-      }\n-  fprintf (stream,\n-\t   \"%-17s%10u%16ld%c\\n\", \"Total\",\n-\t   ggc_stats->total_num_rtxs,\n-\t   SCALE (ggc_stats->total_size_rtxs),\n-\t   LABEL (ggc_stats->total_size_rtxs));\n+  ggc_pch_read (f, addr);\n \n-  /* Don't gather statistics any more.  */\n-  ggc_stats = NULL;\n+  if (addr != mmi.preferred_base)\n+    {\n+      for (rt = gt_ggc_rtab; *rt; rt++)\n+\tfor (rti = *rt; rti->base != NULL; rti++)\n+\t  for (i = 0; i < rti->nelt; i++)\n+\t    {\n+\t      char **ptr = (char **)((char *)rti->base + rti->stride * i);\n+\t      if (*ptr != NULL)\n+\t\t*ptr += (size_t)addr - (size_t)mmi.preferred_base;\n+\t    }\n+      \n+      for (rt = gt_pch_cache_rtab; *rt; rt++)\n+\tfor (rti = *rt; rti->base != NULL; rti++)\n+\t  for (i = 0; i < rti->nelt; i++)\n+\t    {\n+\t      char **ptr = (char **)((char *)rti->base + rti->stride * i);\n+\t      if (*ptr != NULL)\n+\t\t*ptr += (size_t)addr - (size_t)mmi.preferred_base;\n+\t    }\n+\n+      sorry (\"had to relocate PCH\");\n+    }\n+\n+  gt_pch_restore_stringpool ();\n }"}, {"sha": "a150c5a88e651657d7fc1406b91b3440e7c164a2", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 248, "deletions": 10, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n /* \"Bag-of-pages\" garbage collector for the GNU compiler.\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -147,6 +147,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the indicated ORDER.  */\n #define OBJECTS_PER_PAGE(ORDER) objects_per_page_table[ORDER]\n \n+/* The number of objects in P.  */\n+#define OBJECTS_IN_PAGE(P) ((P)->bytes / OBJECT_SIZE ((P)->order))\n+\n /* The size of an object on a page of the indicated ORDER.  */\n #define OBJECT_SIZE(ORDER) object_size_table[ORDER]\n \n@@ -202,6 +205,15 @@ struct max_alignment {\n \n #define MAX_ALIGNMENT (offsetof (struct max_alignment, u))\n \n+/* Compute the smallest nonnegative number which when added to X gives\n+   a multiple of F.  */\n+\n+#define ROUND_UP_VALUE(x, f) ((f) - 1 - ((f) - 1 + (x)) % (f))\n+\n+/* Compute the smallest multiple of F that is >= X.  */\n+\n+#define ROUND_UP(x, f) (CEIL (x, f) * (f))\n+\n /* The Ith entry is the number of objects on a page or order I.  */\n \n static unsigned objects_per_page_table[NUM_ORDERS];\n@@ -1172,7 +1184,7 @@ init_ggc ()\n \n       /* If S is not a multiple of the MAX_ALIGNMENT, then round it up\n \t so that we're sure of getting aligned memory.  */\n-      s = CEIL (s, MAX_ALIGNMENT) * MAX_ALIGNMENT;\n+      s = ROUND_UP (s, MAX_ALIGNMENT);\n       object_size_table[order] = s;\n     }\n \n@@ -1225,7 +1237,7 @@ ggc_recalculate_in_use_p (p)\n \n   /* Because the past-the-end bit in in_use_p is always set, we\n      pretend there is one additional object.  */\n-  num_objects = OBJECTS_PER_PAGE (p->order) + 1;\n+  num_objects = OBJECTS_IN_PAGE (p) + 1;\n \n   /* Reset the free object count.  */\n   p->num_free_objects = num_objects;\n@@ -1294,12 +1306,13 @@ clear_marks ()\n \n   for (order = 2; order < NUM_ORDERS; order++)\n     {\n-      size_t num_objects = OBJECTS_PER_PAGE (order);\n-      size_t bitmap_size = BITMAP_SIZE (num_objects + 1);\n       page_entry *p;\n \n       for (p = G.pages[order]; p != NULL; p = p->next)\n \t{\n+\t  size_t num_objects = OBJECTS_IN_PAGE (p);\n+\t  size_t bitmap_size = BITMAP_SIZE (num_objects + 1);\n+\n #ifdef ENABLE_CHECKING\n \t  /* The data should be page-aligned.  */\n \t  if ((size_t) p->page & (G.pagesize - 1))\n@@ -1342,7 +1355,7 @@ sweep_pages ()\n \t placed at the end of the list.  */\n       page_entry * const last = G.page_tails[order];\n \n-      size_t num_objects = OBJECTS_PER_PAGE (order);\n+      size_t num_objects;\n       size_t live_objects;\n       page_entry *p, *previous;\n       int done;\n@@ -1358,6 +1371,8 @@ sweep_pages ()\n \n \t  /* Loop until all entries have been examined.  */\n \t  done = (p == last);\n+\t  \n+\t  num_objects = OBJECTS_IN_PAGE (p);\n \n \t  /* Add all live objects on this page to the count of\n              allocated memory.  */\n@@ -1445,12 +1460,12 @@ poison_pages ()\n \n   for (order = 2; order < NUM_ORDERS; order++)\n     {\n-      size_t num_objects = OBJECTS_PER_PAGE (order);\n       size_t size = OBJECT_SIZE (order);\n       page_entry *p;\n \n       for (p = G.pages[order]; p != NULL; p = p->next)\n \t{\n+\t  size_t num_objects;\n \t  size_t i;\n \n \t  if (p->context_depth != G.context_depth)\n@@ -1460,6 +1475,7 @@ poison_pages ()\n \t       contexts.  */\n \t    continue;\n \n+\t  num_objects = OBJECTS_IN_PAGE (p);\n \t  for (i = 0; i < num_objects; i++)\n \t    {\n \t      size_t word, bit;\n@@ -1581,11 +1597,11 @@ ggc_print_statistics ()\n       for (p = G.pages[i]; p; p = p->next)\n \t{\n \t  allocated += p->bytes;\n-\t  in_use +=\n-\t    (OBJECTS_PER_PAGE (i) - p->num_free_objects) * OBJECT_SIZE (i);\n+\t  in_use += \n+\t    (OBJECTS_IN_PAGE (p) - p->num_free_objects) * OBJECT_SIZE (i);\n \n \t  overhead += (sizeof (page_entry) - sizeof (long)\n-\t\t       + BITMAP_SIZE (OBJECTS_PER_PAGE (i) + 1));\n+\t\t       + BITMAP_SIZE (OBJECTS_IN_PAGE (p) + 1));\n \t}\n       fprintf (stderr, \"%-5lu %10lu%c %10lu%c %10lu%c\\n\",\n \t       (unsigned long) OBJECT_SIZE (i),\n@@ -1599,3 +1615,225 @@ ggc_print_statistics ()\n \t   SCALE (G.allocated), LABEL(G.allocated),\n \t   SCALE (total_overhead), LABEL (total_overhead));\n }\n+\f\n+struct ggc_pch_data\n+{\n+  struct ggc_pch_ondisk \n+  {\n+    unsigned totals[NUM_ORDERS];\n+  } d;\n+  size_t base[NUM_ORDERS];\n+  size_t written[NUM_ORDERS];\n+};\n+\n+struct ggc_pch_data *\n+init_ggc_pch ()\n+{\n+  return xcalloc (sizeof (struct ggc_pch_data), 1);\n+}\n+\n+void \n+ggc_pch_count_object (d, x, size)\n+     struct ggc_pch_data *d;\n+     void *x ATTRIBUTE_UNUSED;\n+     size_t size;\n+{\n+  unsigned order;\n+\n+  if (size <= 256)\n+    order = size_lookup[size];\n+  else\n+    {\n+      order = 9;\n+      while (size > OBJECT_SIZE (order))\n+\torder++;\n+    }\n+  \n+  d->d.totals[order]++;\n+}\n+     \n+size_t\n+ggc_pch_total_size (d)\n+     struct ggc_pch_data *d;\n+{\n+  size_t a = 0;\n+  unsigned i;\n+\n+  for (i = 0; i < NUM_ORDERS; i++)\n+    a += ROUND_UP (d->d.totals[i] * OBJECT_SIZE (i), G.pagesize);\n+  return a;\n+}\n+\n+void\n+ggc_pch_this_base (d, base)\n+     struct ggc_pch_data *d;\n+     void *base;\n+{\n+  size_t a = (size_t) base;\n+  unsigned i;\n+  \n+  for (i = 0; i < NUM_ORDERS; i++)\n+    {\n+      d->base[i] = a;\n+      a += ROUND_UP (d->d.totals[i] * OBJECT_SIZE (i), G.pagesize);\n+    }\n+}\n+\n+\n+char *\n+ggc_pch_alloc_object (d, x, size)\n+     struct ggc_pch_data *d;\n+     void *x ATTRIBUTE_UNUSED;\n+     size_t size;\n+{\n+  unsigned order;\n+  char *result;\n+  \n+  if (size <= 256)\n+    order = size_lookup[size];\n+  else\n+    {\n+      order = 9;\n+      while (size > OBJECT_SIZE (order))\n+\torder++;\n+    }\n+\n+  result = (char *) d->base[order];\n+  d->base[order] += OBJECT_SIZE (order);\n+  return result;\n+}\n+\n+void \n+ggc_pch_prepare_write (d, f)\n+     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n+     FILE * f ATTRIBUTE_UNUSED;\n+{\n+  /* Nothing to do.  */\n+}\n+\n+void\n+ggc_pch_write_object (d, f, x, newx, size)\n+     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n+     FILE *f;\n+     void *x;\n+     void *newx ATTRIBUTE_UNUSED;\n+     size_t size;\n+{\n+  unsigned order;\n+\n+  if (size <= 256)\n+    order = size_lookup[size];\n+  else\n+    {\n+      order = 9;\n+      while (size > OBJECT_SIZE (order))\n+\torder++;\n+    }\n+  \n+  if (fwrite (x, size, 1, f) != 1)\n+    fatal_io_error (\"can't write PCH file\");\n+\n+  /* In the current implementation, SIZE is always equal to\n+     OBJECT_SIZE (order) and so the fseek is never executed.  */\n+  if (size != OBJECT_SIZE (order)\n+      && fseek (f, OBJECT_SIZE (order) - size, SEEK_CUR) != 0)\n+    fatal_io_error (\"can't write PCH file\");\n+\n+  d->written[order]++;\n+  if (d->written[order] == d->d.totals[order]\n+      && fseek (f, ROUND_UP_VALUE (d->d.totals[order] * OBJECT_SIZE (order),\n+\t\t\t\t   G.pagesize),\n+\t\tSEEK_CUR) != 0)\n+    fatal_io_error (\"can't write PCH file\");\n+}\n+\n+void\n+ggc_pch_finish (d, f)\n+     struct ggc_pch_data * d;\n+     FILE *f;\n+{\n+  if (fwrite (&d->d, sizeof (d->d), 1, f) != 1)\n+    fatal_io_error (\"can't write PCH file\");\n+  free (d);\n+}\n+\n+void\n+ggc_pch_read (f, addr)\n+     FILE *f;\n+     void *addr;\n+{\n+  struct ggc_pch_ondisk d;\n+  unsigned i;\n+  char *offs = addr;\n+  \n+  /* We've just read in a PCH file.  So, every object that used to be allocated\n+     is now free.  */\n+  clear_marks ();\n+#ifdef GGC_POISON\n+  poison_pages ();\n+#endif\n+\n+  /* No object read from a PCH file should ever be freed.  So, set the\n+     context depth to 1, and set the depth of all the currently-allocated\n+     pages to be 1 too.  PCH pages will have depth 0.  */\n+  if (G.context_depth != 0)\n+    abort ();\n+  G.context_depth = 1;\n+  for (i = 0; i < NUM_ORDERS; i++)\n+    {\n+      page_entry *p;\n+      for (p = G.pages[i]; p != NULL; p = p->next)\n+\tp->context_depth = G.context_depth;\n+    }\n+\n+  /* Allocate the appropriate page-table entries for the pages read from\n+     the PCH file.  */\n+  if (fread (&d, sizeof (d), 1, f) != 1)\n+    fatal_io_error (\"can't read PCH file\");\n+  \n+  for (i = 0; i < NUM_ORDERS; i++)\n+    {\n+      struct page_entry *entry;\n+      char *pte;\n+      size_t bytes;\n+      size_t num_objs;\n+      size_t j;\n+      \n+      if (d.totals[i] == 0)\n+\tcontinue;\n+      \n+      bytes = ROUND_UP (d.totals[i] * OBJECT_SIZE (i), G.pagesize);\n+      num_objs = bytes / OBJECT_SIZE (i);\n+      entry = xcalloc (1, (sizeof (struct page_entry) \n+\t\t\t   - sizeof (long)\n+\t\t\t   + BITMAP_SIZE (num_objs + 1)));\n+      entry->bytes = bytes;\n+      entry->page = offs;\n+      entry->context_depth = 0;\n+      offs += bytes;\n+      entry->num_free_objects = 0;\n+      entry->order = i;\n+\n+      for (j = 0; \n+\t   j + HOST_BITS_PER_LONG <= num_objs + 1;\n+\t   j += HOST_BITS_PER_LONG)\n+\tentry->in_use_p[j / HOST_BITS_PER_LONG] = -1;\n+      for (; j < num_objs + 1; j++)\n+\tentry->in_use_p[j / HOST_BITS_PER_LONG] \n+\t  |= 1L << (j % HOST_BITS_PER_LONG);\n+\n+      for (pte = entry->page; \n+\t   pte < entry->page + entry->bytes; \n+\t   pte += G.pagesize)\n+\tset_page_table_entry (pte, entry);\n+\n+      if (G.page_tails[i] != NULL)\n+\tG.page_tails[i]->next = entry;\n+      else\n+\tG.pages[i] = entry;\n+      G.page_tails[i] = entry;\n+    }\n+\n+  /* Update the statistics.  */\n+  G.allocated = G.allocated_last_gc = offs - (char *)addr;\n+}"}, {"sha": "65bc1b64839ce70a513b45d2afebd438ab1f14d9", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n /* Simple garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -28,6 +28,7 @@\n #include \"flags.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n+#include \"toplev.h\"\n #include \"timevar.h\"\n #include \"params.h\"\n \n@@ -490,16 +491,90 @@ ggc_print_statistics ()\n \n   fprintf (stderr, \"\\n\\\n Total internal data (bytes)\\t%ld%c\\n\\\n-Number of leaves in tree\\t%d\\n\\\n+Number of leaves in tree\\t%lu\\n\\\n Average leaf depth\\t\\t%.1f\\n\",\n \t   SCALE(G.objects * offsetof (struct ggc_mem, u)),\n \t   LABEL(G.objects * offsetof (struct ggc_mem, u)),\n-\t   nleaf, (double)sumdepth / (double)nleaf);\n+\t   (unsigned long)nleaf, (double)sumdepth / (double)nleaf);\n \n   /* Report overall memory usage.  */\n   fprintf (stderr, \"\\n\\\n-Total objects allocated\\t\\t%d\\n\\\n+Total objects allocated\\t\\t%ld\\n\\\n Total memory in GC arena\\t%ld%c\\n\",\n-\t   G.objects,\n+\t   (unsigned long)G.objects,\n \t   SCALE(G.allocated), LABEL(G.allocated));\n }\n+\f\n+struct ggc_pch_data *\n+init_ggc_pch ()\n+{\n+  sorry (\"Generating PCH files is not supported when using ggc-simple.c\");\n+  /* It could be supported, but the code is not yet written.  */\n+  return NULL;\n+}\n+\n+void \n+ggc_pch_count_object (d, x, size)\n+     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n+     void *x ATTRIBUTE_UNUSED;\n+     size_t size ATTRIBUTE_UNUSED;\n+{\n+}\n+     \n+size_t\n+ggc_pch_total_size (d)\n+     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+void\n+ggc_pch_this_base (d, base)\n+     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n+     void *base ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+\n+char *\n+ggc_pch_alloc_object (d, x, size)\n+     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n+     void *x ATTRIBUTE_UNUSED;\n+     size_t size ATTRIBUTE_UNUSED;\n+{\n+  return NULL;\n+}\n+\n+void \n+ggc_pch_prepare_write (d, f)\n+     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n+     FILE * f ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+void\n+ggc_pch_write_object (d, f, x, newx, size)\n+     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n+     FILE *f ATTRIBUTE_UNUSED;\n+     void *x ATTRIBUTE_UNUSED;\n+     void *newx ATTRIBUTE_UNUSED;\n+     size_t size ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+void\n+ggc_pch_finish (d, f)\n+     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n+     FILE *f ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+void\n+ggc_pch_read (f, addr)\n+     FILE *f ATTRIBUTE_UNUSED;\n+     void *addr ATTRIBUTE_UNUSED;\n+{\n+  /* This should be impossible, since we won't generate any valid PCH\n+     files for this configuration.  */\n+  abort ();\n+}"}, {"sha": "86ae60a7d994c2639f109b63cec06d77759e637c", "filename": "gcc/ggc.h", "status": "modified", "additions": 135, "deletions": 49, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -18,9 +18,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-#include \"varray.h\"\n-#include \"gtype-desc.h\"\n-\n /* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n    an external gc library that might be linked in.  */\n \n@@ -29,59 +26,121 @@ extern const char empty_string[];\t/* empty string */\n extern const char digit_vector[];\t/* \"0\" .. \"9\" */\n #define digit_string(d) (digit_vector + ((d) * 2))\n \n-/* Manipulate global roots that are needed between calls to gc.  \n-   THIS ROUTINE IS OBSOLETE, do not use it for new code.  */\n-extern void ggc_add_root\t\tPARAMS ((void *base, int nelt,\n-\t\t\t\t\t\t int size, void (*)(void *)));\n+/* Internal functions and data structures used by the GTY\n+   machinery.  */\n+\n+/* The first parameter is a pointer to a pointer, the second a cookie.  */\n+typedef void (*gt_pointer_operator) PARAMS ((void *, void *));\n+\n+#include \"gtype-desc.h\"\n+\n+/* One of these applies its third parameter (with cookie in the fourth\n+   parameter) to each pointer in the object pointed to by the first\n+   parameter, using the second parameter.  */\n+typedef void (*gt_note_pointers) \n+     PARAMS ((void *, void *, gt_pointer_operator, void *));\n+\n+/* One of these is called before objects are re-ordered in memory.\n+   The first parameter is the original object, the second is the\n+   subobject that has had its pointers reordered, the third parameter\n+   can compute the new values of a pointer when given the cookie in\n+   the fourth parameter.  */\n+typedef void (*gt_handle_reorder)\n+     PARAMS ((void *, void *, gt_pointer_operator, void *));\n+\n+/* Used by the gt_pch_n_* routines.  Register an object in the hash table.  */\n+extern int gt_pch_note_object \n+     PARAMS ((void *, void *, gt_note_pointers));\n+\n+/* Used by the gt_pch_n_* routines.  Register that an object has a reorder \n+   function.  */\n+extern void gt_pch_note_reorder\n+     PARAMS ((void *, void *, gt_handle_reorder));\n+\n+/* Mark the object in the first parameter and anything it points to.  */\n+typedef void (*gt_pointer_walker) PARAMS ((void *));\n \n /* Structures for the easy way to mark roots.\n    In an array, terminated by having base == NULL.*/\n struct ggc_root_tab {\n   void *base;\n   size_t nelt;\n   size_t stride;\n-  void (*cb) PARAMS ((void *));\n+  gt_pointer_walker cb;\n+  gt_pointer_walker pchw;\n };\n-#define LAST_GGC_ROOT_TAB { NULL, 0, 0, NULL }\n+#define LAST_GGC_ROOT_TAB { NULL, 0, 0, NULL, NULL }\n /* Pointers to arrays of ggc_root_tab, terminated by NULL.  */\n extern const struct ggc_root_tab * const gt_ggc_rtab[];\n extern const struct ggc_root_tab * const gt_ggc_deletable_rtab[];\n+extern const struct ggc_root_tab * const gt_pch_cache_rtab[];\n+extern const struct ggc_root_tab * const gt_pch_scalar_rtab[];\n \n /* Structure for hash table cache marking.  */\n struct htab;\n struct ggc_cache_tab {\n   struct htab * *base;\n   size_t nelt;\n   size_t stride;\n-  void (*cb) PARAMS ((void *));\n+  gt_pointer_walker cb;\n+  gt_pointer_walker pchw;\n   int (*marked_p) PARAMS ((const void *));\n };\n-#define LAST_GGC_CACHE_TAB { NULL, 0, 0, NULL, NULL }\n+#define LAST_GGC_CACHE_TAB { NULL, 0, 0, NULL, NULL, NULL }\n /* Pointers to arrays of ggc_cache_tab, terminated by NULL.  */\n extern const struct ggc_cache_tab * const gt_ggc_cache_rtab[];\n \n-extern void ggc_mark_roots\t\tPARAMS ((void));\n-\n /* If EXPR is not NULL and previously unmarked, mark it and evaluate\n    to true.  Otherwise evaluate to false.  */\n #define ggc_test_and_set_mark(EXPR) \\\n   ((EXPR) != NULL && ((void *) (EXPR)) != (void *) 1 && ! ggc_set_mark (EXPR))\n \n-#define ggc_mark_rtx gt_ggc_m_7rtx_def\n-#define ggc_mark_tree gt_ggc_m_9tree_node\n-\n #define ggc_mark(EXPR)\t\t\t\t\\\n   do {\t\t\t\t\t\t\\\n     const void *const a__ = (EXPR);\t\t\\\n     if (a__ != NULL && a__ != (void *) 1)\t\\\n       ggc_set_mark (a__);\t\t\t\\\n   } while (0)\n \n-/* A GC implementation must provide these functions.  */\n+/* Actually set the mark on a particular region of memory, but don't\n+   follow pointers.  This function is called by ggc_mark_*.  It\n+   returns zero if the object was not previously marked; non-zero if\n+   the object was already marked, or if, for any other reason,\n+   pointers in this data structure should not be traversed.  */\n+extern int ggc_set_mark\t\t\tPARAMS ((const void *));\n+\n+/* Return 1 if P has been marked, zero otherwise.\n+   P must have been allocated by the GC allocator; it mustn't point to\n+   static objects, stack variables, or memory allocated with malloc.  */\n+extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n+\n+/* Mark the entries in the string pool.  */\n+extern void ggc_mark_stringpool\t\tPARAMS ((void));\n+\n+/* Call ggc_set_mark on all the roots.  */\n+\n+extern void ggc_mark_roots\t\tPARAMS ((void));\n+\n+/* Save and restore the string pool entries for PCH.  */\n+\n+extern void gt_pch_save_stringpool\tPARAMS ((void));\n+extern void gt_pch_restore_stringpool\tPARAMS ((void));\n+\n+/* PCH and GGC handling for strings, mostly trivial.  */\n+\n+extern void gt_pch_p_S\t\t\tPARAMS ((void *, void *,\n+\t\t\t\t\t\t gt_pointer_operator, void *));\n+extern void gt_pch_n_S\t\t\tPARAMS ((const void *));\n+extern void gt_ggc_m_S\t\t\tPARAMS ((void *));\n+\n+/* Initialise the string pool.  */\n+extern void init_stringpool\tPARAMS ((void));\n+\n+/* A GC implementation must provide these functions.  They are internal\n+   to the GC system.  */\n \n /* Initialize the garbage collector.  */\n extern void init_ggc\t\tPARAMS ((void));\n-extern void init_stringpool\tPARAMS ((void));\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n@@ -91,6 +150,48 @@ extern void ggc_push_context\tPARAMS ((void));\n    will be merged with the old context.  */\n extern void ggc_pop_context \tPARAMS ((void));\n \n+struct ggc_pch_data;\n+\n+/* Return a new ggc_pch_data structure.  */\n+extern struct ggc_pch_data *init_ggc_pch PARAMS ((void));\n+\n+/* The second parameter and third parameters give the address and size\n+   of an object.  Update the ggc_pch_data structure with as much of\n+   that information as is necessary.  */\n+extern void ggc_pch_count_object\tPARAMS ((struct ggc_pch_data *,\n+\t\t\t\t\t\t void *, size_t));\n+\n+/* Return the total size of the data to be written to hold all \n+   the objects previously passed to ggc_pch_count_object.  */\n+extern size_t ggc_pch_total_size\tPARAMS ((struct ggc_pch_data *));\n+\n+/* The objects, when read, will most likely be at the address\n+   in the second parameter.  */\n+extern void ggc_pch_this_base\t\tPARAMS ((struct ggc_pch_data *,\n+\t\t\t\t\t\t void *));\n+\n+/* Assuming that the objects really do end up at the address\n+   passed to ggc_pch_this_base, return the address of this object.  */\n+extern char *ggc_pch_alloc_object\tPARAMS ((struct ggc_pch_data *,\n+\t\t\t\t\t\t void *, size_t));\n+\n+/* Write out any initial information required.  */\n+extern void ggc_pch_prepare_write\tPARAMS ((struct ggc_pch_data *,\n+\t\t\t\t\t\t FILE *));\n+/* Write out this object, including any padding.  */\n+extern void ggc_pch_write_object\tPARAMS ((struct ggc_pch_data *,\n+\t\t\t\t\t\t FILE *, void *, void *,\n+\t\t\t\t\t\t size_t));\n+/* All objects have been written, write out any final information\n+   required.  */\n+extern void ggc_pch_finish\t\tPARAMS ((struct ggc_pch_data *,\n+\t\t\t\t\t\t FILE *));\n+\n+/* A PCH file has just been read in at the address specified second\n+   parameter.  Set up the GC implementation for the new objects.  */\n+extern void ggc_pch_read PARAMS ((FILE *, void *));\n+\n+\f\n /* Allocation.  */\n \n /* The internal primitive.  */\n@@ -115,6 +216,13 @@ extern void *ggc_calloc\t\tPARAMS ((size_t, size_t));\n #define htab_create_ggc(SIZE, HASH, EQ, DEL) \\\n   htab_create_alloc (SIZE, HASH, EQ, DEL, ggc_calloc, NULL)\n \n+#define splay_tree_new_ggc(COMPARE)\t\t\t\t\t \\\n+  splay_tree_new_with_allocator (COMPARE, NULL, NULL,\t\t\t \\\n+                                 &ggc_splay_alloc, &ggc_splay_dont_free, \\\n+\t\t\t\t NULL)\n+extern PTR ggc_splay_alloc PARAMS ((int, void *));\n+extern void ggc_splay_dont_free PARAMS ((void *, void *));\n+\n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n    null-terminated string and the memory sized accordingly.  */\n@@ -128,47 +236,25 @@ extern const char *ggc_alloc_string\tPARAMS ((const char *contents,\n    function is called, not during allocations.  */\n extern void ggc_collect\t\t\tPARAMS ((void));\n \n-/* Actually set the mark on a particular region of memory, but don't\n-   follow pointers.  This function is called by ggc_mark_*.  It\n-   returns zero if the object was not previously marked; nonzero if\n-   the object was already marked, or if, for any other reason,\n-   pointers in this data structure should not be traversed.  */\n-extern int ggc_set_mark\t\t\tPARAMS ((const void *));\n+/* Return the number of bytes allocated at the indicated address.  */\n+extern size_t ggc_get_size\t\tPARAMS ((const void *));\n \n-/* Return 1 if P has been marked, zero otherwise.\n-   P must have been allocated by the GC allocator; it mustn't point to\n-   static objects, stack variables, or memory allocated with malloc.  */\n-extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n+/* Write out all GCed objects to F.  */\n+extern void gt_pch_save\t\t\tPARAMS ((FILE *f));\n \n+/* Read objects previously saved with gt_pch_save from F.  */\n+extern void gt_pch_restore\t\tPARAMS ((FILE *f));\n+\f\n /* Statistics.  */\n \n /* This structure contains the statistics common to all collectors.\n    Particular collectors can extend this structure.  */\n typedef struct ggc_statistics\n {\n-  /* The Ith element is the number of nodes allocated with code I.  */\n-  unsigned num_trees[256];\n-  /* The Ith element is the number of bytes allocated by nodes with\n-     code I.  */\n-  size_t size_trees[256];\n-  /* The Ith element is the number of nodes allocated with code I.  */\n-  unsigned num_rtxs[256];\n-  /* The Ith element is the number of bytes allocated by nodes with\n-     code I.  */\n-  size_t size_rtxs[256];\n-  /* The total size of the tree nodes allocated.  */\n-  size_t total_size_trees;\n-  /* The total size of the RTL nodes allocated.  */\n-  size_t total_size_rtxs;\n-  /* The total number of tree nodes allocated.  */\n-  unsigned total_num_trees;\n-  /* The total number of RTL nodes allocated.  */\n-  unsigned total_num_rtxs;\n+  /* At present, we don't really gather any interesting statistics.  */\n+  int unused;\n } ggc_statistics;\n \n-/* Return the number of bytes allocated at the indicated address.  */\n-extern size_t ggc_get_size\t\tPARAMS ((const void *));\n-\n /* Used by the various collectors to gather and print statistics that\n    do not depend on the collector in use.  */\n extern void ggc_print_common_statistics PARAMS ((FILE *, ggc_statistics *));"}, {"sha": "00b5e50a9fb0910feb7e513004182fa68a606793", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,3 +1,77 @@\n+2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tMerge from pch-branch:\n+\n+\t2002-12-02  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* Make-lang.in (java/gjavah.o): Update dependencies.\n+\t* gjavah.c: Include ggc.h.\n+\n+\t2002-08-16  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* Make-lang.in (GCJH_OBJS): Add ggc-none.o.\n+\t(JCFDUMP_OBJS): Add ggc-none.o.\n+\t(java/jcf-dump.o): Depend on GGC_H.\n+\t* jcf-reader.c (jcf_parse_constant_pool): Use ggc_alloc to allocate\n+\tCPool substructures.\n+\t* jcf-parse.c (process_zip_dir): Use ggc_alloc to allocate JCFs.\n+\t* jcf-dump.c: Include ggc.h.\n+\n+\t2002-08-08  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* jcf.h (union cpool_entry): New.\n+\t(struct CPool): Use gengtype to mark.  Change field 'data' to be\n+\tan array of unions.\n+\t(struct JCF): Use gengtype to mark.\n+\t(CPOOL_UINT): Update for new cpool_entry type.\n+\t(CPOOL_USHORT1): Likewise.\n+\t(CPOOL_USHORT2): Likewise.\n+\t(CPOOL_FINISH): Use GC to free cpool subfields.\n+\t* parse.h (struct parser_ctxt): Mark field current_jcf.\n+\t* lex.c (java_init_lex): Use GC to allocate struct JCF.\n+\t* jcf-parse.c (HANDLE_CONSTANT_Utf8): Update for new cpool_entry type.\n+\t(main_jcf): Use gengtype to mark.\n+\t(ggc_mark_jcf): Delete.\n+\t(get_constant): Update for new cpool_entry type.\n+\t(give_name_to_class): Likewise.\n+\t(get_class_constant): Likewise.\n+\t(init_outgoing_cpool): Use GGC to allocate struct CPool.\n+\t(java_parse_file): Use GGC to allocate struct JCF.\n+\t(init_jcf_parse): Don't call ggc_add_root.\n+\t* jcf-reader.c (jcf_parse_constant_pool): Update for new\n+\tcpool_entry type.\n+\t* java-tree.h (current_jcf): Use gengtype to mark.\n+\t(CPOOL_UTF): Update for new cpool_entry type.\n+\t(outgoing_cpool): Use gengtype to mark.\n+\t(struct lang_type): GC struct JCF and struct CPool.\n+\t* config-lang.in (gtfiles): Add jcf.h.\n+\t* constants.c (find_tree_constant): New.\n+\t(set_constant_entry): Allocate cpool subfields using GGC.  Update\n+\tfor new cpool_entry type.\n+\t(find_constant1): Update for new cpool_entry type.\n+\t(find_constant2): Likewise.\n+\t(find_utf8_constant): Use find_tree_constant.\n+\t(find_class_or_string_constant): Remove unnecessary cast to jword.\n+\tUpdate for new cpool_entry type.\n+\t(count_constant_pool_bytes): Update for new cpool_entry type.\n+\t(write_constant_pool): Likewise.\n+\t(alloc_name_constant): Use find_tree_constant.\n+\t(build_constants_constructor): Update for new cpool_entry type.\n+\n+\t2002-08-08  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* parse.y (mark_parser_ctxt): Delete.\n+\t(goal): Don't use ggc_add_root.\n+\t(create_new_parser_context): Use GC to allocate struct parser_ctxt.\n+\t(java_pop_parser_context): Let GC free parser_ctxt.\n+\t(java_parser_context_resume): Likewise.\n+\t* parse.h (struct parser_ctxt): Use gengtype to mark.\n+\t(ctxp): Likewise.\n+\t(ctxp_for_generation): Likewise.\n+\t* lex.h (struct java_lc_s): Mark for gengtype.\n+\t(java_lexer): Rearrange for gengtype.\n+\t* config-lang.in (gtfiles): Add lex.h, parse.h.\n+\n 2003-01-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* All Files: Remove PARAMS macro."}, {"sha": "bd839d6a3548fcdb09cbc75a1f3ca80247891951", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -113,12 +113,12 @@ JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n   java/jcf-path.o java/xref.o java/boehm.o java/java-tree-inline.o mkdeps.o\n \n GCJH_OBJS = java/gjavah.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n-  java/zextract.o version.o mkdeps.o errors.o\n+  java/zextract.o version.o mkdeps.o errors.o ggc-none.o\n \n JVSCAN_OBJS = java/parse-scan.o java/jv-scan.o version.o\n \n JCFDUMP_OBJS = java/jcf-dump.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n-\t\tjava/zextract.o errors.o version.o mkdeps.o\n+\t\tjava/zextract.o errors.o version.o mkdeps.o ggc-none.o\n \n JVGENMAIN_OBJS = java/jvgenmain.o java/mangle_name.o errors.o\n \n@@ -267,9 +267,9 @@ java/parse.o: java/parse.c java/jcf-reader.c $(CONFIG_H) $(SYSTEM_H) \\\n   java/lex.h $(GGC_H) debug.h gt-java-parse.h gtype-java.h\n java/jcf-dump.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(JAVA_TREE_H) \\\n   java/jcf-dump.c java/jcf-reader.c java/jcf.h java/javaop.h java/javaop.def \\\n-  version.h\n+  version.h $(GGC_H)\n java/gjavah.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(JAVA_TREE_H) \\\n-  java/gjavah.c java/jcf-reader.c java/jcf.h java/javaop.h version.h\n+  java/gjavah.c java/jcf-reader.c java/jcf.h java/javaop.h version.h $(GGC_H)\n java/boehm.o: java/boehm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(TREE_H) $(JAVA_TREE_H) java/parse.h toplev.h\n java/buffer.o: java/buffer.c $(CONFIG_H) java/buffer.h $(SYSTEM_H) coretypes.h \\"}, {"sha": "05a6fdff7e791547c736f884e4635161725ca065", "filename": "gcc/java/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconfig-lang.in?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -36,7 +36,7 @@ compilers=\"jc1\\$(exeext) jvgenmain\\$(exeext)\"\n \n stagestuff=\"jc1\\$(exeext) gcj\\$(exeext) jvgenmain\\$(exeext) gcjh\\$(exeext) jv-scan\\$(exeext) jcf-dump\\$(exeext)\"\n \n-gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/jcf-write.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/parse.y\"\n+gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/jcf.h \\$(srcdir)/java/lex.h \\$(srcdir)/java/parse.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/jcf-write.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/parse.y\"\n \n target_libs=${libgcj_saved}\n lang_dirs=\"zlib fastjar\""}, {"sha": "a1872387f18dc4961388a119ab694ca409137af8", "filename": "gcc/java/constants.c", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -32,6 +32,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"ggc.h\"\n \n static void set_constant_entry (CPool *, int, int, jword);\n+static int find_tree_constant (CPool *, int, tree);\n static int find_class_or_string_constant (CPool *, int, tree);\n static int find_name_and_type_constant (CPool *, tree, tree);\n static tree get_tag_node (int);\n@@ -49,22 +50,24 @@ set_constant_entry (cpool, index, tag, value)\n   if (cpool->data == NULL)\n     {\n       cpool->capacity = 100;\n-      cpool->tags = xmalloc (sizeof(uint8) * cpool->capacity);\n-      cpool->data = xmalloc (sizeof(jword) * cpool->capacity);\n+      cpool->tags = ggc_alloc (sizeof(uint8) * cpool->capacity);\n+      cpool->data = ggc_alloc (sizeof(union cpool_entry) * cpool->capacity);\n       cpool->count = 1;\n     }\n   if (index >= cpool->capacity)\n     {\n       cpool->capacity *= 2;\n       if (index >= cpool->capacity)\n \tcpool->capacity = index + 10;\n-      cpool->tags = xrealloc (cpool->tags, sizeof(uint8) * cpool->capacity);\n-      cpool->data = xrealloc (cpool->data, sizeof(jword) * cpool->capacity);\n+      cpool->tags = ggc_realloc (cpool->tags, \n+\t\t\t\t sizeof(uint8) * cpool->capacity);\n+      cpool->data = ggc_realloc (cpool->data,\n+\t\t\t\t sizeof(union cpool_entry) * cpool->capacity);\n     }\n   if (index >= cpool->count)\n     cpool->count = index + 1;\n   cpool->tags[index] = tag;\n-  cpool->data[index] = value;\n+  cpool->data[index].w = value;\n }\n \n /* Find (or create) a constant pool entry matching TAG and VALUE. */\n@@ -78,7 +81,7 @@ find_constant1 (cpool, tag, value)\n   int i;\n   for (i = cpool->count;  --i > 0; )\n     {\n-      if (cpool->tags[i] == tag && cpool->data[i] == value)\n+      if (cpool->tags[i] == tag && cpool->data[i].w == value)\n \treturn i;\n     }\n   i = cpool->count == 0 ? 1 : cpool->count;\n@@ -98,8 +101,8 @@ find_constant2 (cpool, tag, word1, word2)\n   for (i = cpool->count - 1;  --i > 0; )\n     {\n       if (cpool->tags[i] == tag\n-\t  && cpool->data[i] == word1\n-\t  && cpool->data[i+1] == word2)\n+\t  && cpool->data[i].w == word1\n+\t  && cpool->data[i+1].w == word2)\n \treturn i;\n     }\n   i = cpool->count == 0 ? 1 : cpool->count;\n@@ -108,14 +111,33 @@ find_constant2 (cpool, tag, word1, word2)\n   return i;\n }\n \n+static int\n+find_tree_constant (cpool, tag, value)\n+     CPool *cpool;\n+     int tag;\n+     tree value;\n+{\n+  int i;\n+  for (i = cpool->count;  --i > 0; )\n+    {\n+      if (cpool->tags[i] == tag && cpool->data[i].t == value)\n+\treturn i;\n+    }\n+  i = cpool->count == 0 ? 1 : cpool->count;\n+  set_constant_entry (cpool, i, tag, 0);\n+  cpool->data[i].t = value;\n+  return i;\n+}\n+\n+\n int\n find_utf8_constant (cpool, name)\n      CPool *cpool;\n      tree name;\n {\n   if (name == NULL_TREE)\n     return 0;\n-  return find_constant1 (cpool, CONSTANT_Utf8, (jword) name);\n+  return find_tree_constant (cpool, CONSTANT_Utf8, name);\n }\n \n static int\n@@ -124,15 +146,15 @@ find_class_or_string_constant (cpool, tag, name)\n      int tag;\n      tree name;\n {\n-  int j = find_utf8_constant (cpool, name);\n+  jword j = find_utf8_constant (cpool, name);\n   int i;\n   for (i = cpool->count;  --i > 0; )\n     {\n-      if (cpool->tags[i] == tag && cpool->data[i] == (jword) j)\n+      if (cpool->tags[i] == tag && cpool->data[i].w == j)\n \treturn i;\n     }\n   i = cpool->count;\n-  set_constant_entry (cpool, i, tag, (jword) j);\n+  set_constant_entry (cpool, i, tag, j);\n   return i;\n }\n \n@@ -255,7 +277,7 @@ count_constant_pool_bytes (cpool)\n \t  break;\n \tcase CONSTANT_Utf8:\n \t  {\n-\t    tree t = (tree) cpool->data[i];\n+\t    tree t = cpool->data[i].t;\n \t    int len = IDENTIFIER_LENGTH (t);\n \t    size += len + 2;\n \t  }\n@@ -279,7 +301,7 @@ write_constant_pool (cpool, buffer, length)\n {\n   unsigned char *ptr = buffer;\n   int i = 1;\n-  jword *datap = &cpool->data[1];\n+  union cpool_entry *datap = &cpool->data[1];\n   PUT2 (cpool->count);\n   for ( ;  i < cpool->count;  i++, datap++)\n     {\n@@ -293,23 +315,23 @@ write_constant_pool (cpool, buffer, length)\n \tcase CONSTANT_InterfaceMethodref:\n \tcase CONSTANT_Float:\n \tcase CONSTANT_Integer:\n-\t  PUT4 (*datap);\n+\t  PUT4 (datap->w);\n \t  break;\n \tcase CONSTANT_Class:\n \tcase CONSTANT_String:\n-\t  PUT2 (*datap);\n+\t  PUT2 (datap->w);\n \t  break;\n \t  break;\n \tcase CONSTANT_Long:\n \tcase CONSTANT_Double:\n-\t  PUT4(*datap);\n+\t  PUT4(datap->w);\n \t  i++;\n \t  datap++;\n-\t  PUT4 (*datap);\n+\t  PUT4 (datap->w);\n \t  break;\n \tcase CONSTANT_Utf8:\n \t  {\n-\t    tree t = (tree) *datap;\n+\t    tree t = datap->t;\n \t    int len = IDENTIFIER_LENGTH (t);\n \t    PUT2 (len);\n \t    PUTN (IDENTIFIER_POINTER (t), len);\n@@ -347,7 +369,7 @@ alloc_name_constant (tag, name)\n      int tag;\n      tree name;\n {\n-  return find_constant1 (outgoing_cpool, tag, (jword) name);\n+  return find_tree_constant (outgoing_cpool, tag, name);\n }\n \n /* Build an identifier for the internal name of reference type TYPE. */\n@@ -438,7 +460,7 @@ build_constants_constructor ()\n \t= tree_cons (NULL_TREE, get_tag_node (outgoing_cpool->tags[i]),\n \t\t     tags_list);\n       data_list\n-\t= tree_cons (NULL_TREE, build_utf8_ref ((tree)outgoing_cpool->data[i]),\n+\t= tree_cons (NULL_TREE, build_utf8_ref (outgoing_cpool->data[i].t),\n \t\t     data_list);\n     }\n   if (outgoing_cpool->count > 0)"}, {"sha": "0c333137c56dd79a8a3e6b44bca917bd1ccb1c67", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -38,6 +38,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"javaop.h\"\n #include \"java-tree.h\"\n #include \"java-opcodes.h\"\n+#include \"ggc.h\"\n #include \"hashtab.h\"\n \n #include <getopt.h>"}, {"sha": "9a79f3e36b45e0bf1f9d915619bbb7fb2e5f984b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -229,7 +229,7 @@ extern int flag_store_check;\n extern const char *current_encoding;\n \n /* The Java .class file that provides main_class;  the main input file. */\n-extern struct JCF *current_jcf;\n+extern GTY(()) struct JCF * current_jcf;\n \n typedef struct CPool constant_pool;\n \n@@ -241,7 +241,7 @@ typedef struct CPool constant_pool;\n /* The cpool->data[i] for a ResolvedClass points to a RECORD_TYPE. */\n #define CONSTANT_ResolvedClass     (CONSTANT_Class+CONSTANT_ResolvedFlag)\n \n-#define CPOOL_UTF(CPOOL, INDEX) ((tree) (CPOOL)->data[INDEX])\n+#define CPOOL_UTF(CPOOL, INDEX) ((CPOOL)->data[INDEX].t)\n \n /* A NameAndType constant is represented as a TREE_LIST.\n    The type is the signature string (as an IDENTIFIER_NODE).  */\n@@ -686,7 +686,7 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n #define nativecode_ptr_type_node ptr_type_node\n \n /* They need to be reset before processing each class */\n-extern struct CPool *outgoing_cpool; \n+extern GTY(()) struct CPool *outgoing_cpool; \n \n #define wfl_operator \\\n   java_global_trees[JTI_WFL_OPERATOR]\n@@ -1066,8 +1066,8 @@ struct lang_decl GTY(())\n struct lang_type GTY(())\n {\n   tree signature;\n-  struct JCF * GTY ((skip (\"\"))) jcf;\n-  struct CPool * GTY ((skip (\"\"))) cpool;\n+  struct JCF * jcf;\n+  struct CPool * cpool;\n   tree cpool_data_ref;\t\t/* Cached */\n   tree finit_stmt_list;\t\t/* List of statements finit$ will use */\n   tree clinit_stmt_list;\t/* List of statements <clinit> will use  */"}, {"sha": "a5de5c57cb55fc81c370ccb23abd756c1873827b", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -53,6 +53,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"ggc.h\"\n \n #include \"jcf.h\"\n #include \"tree.h\""}, {"sha": "cd2c1cf819f75a94a3778ace8b5b63589c2a3101", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -62,7 +62,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n     text = (JCF)->read_ptr; \\\n     save = text[LENGTH]; \\\n     text[LENGTH] = 0; \\\n-    (JCF)->cpool.data[INDEX] = (jword) get_identifier (text); \\\n+    (JCF)->cpool.data[INDEX].t = get_identifier (text); \\\n     text[LENGTH] = save; \\\n     JCF_SKIP (JCF, LENGTH); } while (0)\n \n@@ -86,7 +86,7 @@ static GTY(()) tree parse_roots[3];\n #define current_file_list parse_roots[2]\n \n /* The Java archive that provides main_class;  the main input file. */\n-static struct JCF main_jcf[1];\n+static GTY(()) struct JCF * main_jcf;\n \n static struct ZipFile *localToFile;\n \n@@ -100,33 +100,9 @@ static void parse_source_file_2 (void);\n static void parse_source_file_3 (void);\n static void parse_class_file (void);\n static void set_source_filename (JCF *, int);\n-static void ggc_mark_jcf (void**);\n static void jcf_parse (struct JCF*);\n static void load_inner_classes (tree);\n \n-/* Mark (for garbage collection) all the tree nodes that are\n-   referenced from JCF's constant pool table. Do that only if the JCF\n-   hasn't been marked finished.  */\n-\n-static void\n-ggc_mark_jcf (elt)\n-     void **elt;\n-{\n-  JCF *jcf = *(JCF**) elt;\n-  if (jcf != NULL && !jcf->finished)\n-    {\n-      CPool *cpool = &jcf->cpool;\n-      int size = CPOOL_COUNT(cpool);\n-      int index;\n-      for (index = 1; index < size;  index++)\n-\t{\n-\t  int tag = JPOOL_TAG (jcf, index);\n-\t  if ((tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8)\n-\t    ggc_mark_tree ((tree) cpool->data[index]);\n-\t}\n-    }\n-}\n-\n /* Handle \"SourceFile\" attribute. */\n \n static void\n@@ -270,7 +246,7 @@ get_constant (jcf, index)\n     goto bad;\n   tag = JPOOL_TAG (jcf, index);\n   if ((tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8)\n-    return (tree) jcf->cpool.data[index];\n+    return jcf->cpool.data[index].t;\n   switch (tag)\n     {\n     case CONSTANT_Integer:\n@@ -352,7 +328,7 @@ get_constant (jcf, index)\n       goto bad;\n     }\n   JPOOL_TAG (jcf, index) = tag | CONSTANT_ResolvedFlag;\n-  jcf->cpool.data [index] = (jword) value;\n+  jcf->cpool.data[index].t = value;\n   return value;\n  bad:\n   internal_error (\"bad value constant type %d, index %d\", \n@@ -435,7 +411,7 @@ give_name_to_class (jcf, i)\n       if (main_input_filename == NULL && jcf == main_jcf)\n \tmain_input_filename = input_filename;\n \n-      jcf->cpool.data[i] = (jword) this_class;\n+      jcf->cpool.data[i].t = this_class;\n       JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n       return this_class;\n     }\n@@ -465,11 +441,11 @@ get_class_constant (JCF *jcf , int i)\n           tree cname = unmangle_classname (name, nlength);\n           type = lookup_class (cname);\n \t}\n-      jcf->cpool.data[i] = (jword) type;\n+      jcf->cpool.data[i].t = type;\n       JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n     }\n   else\n-    type = (tree) jcf->cpool.data[i];\n+    type = jcf->cpool.data[i].t;\n   return type;\n }\n \n@@ -709,8 +685,7 @@ load_inner_classes (cur_class)\n void\n init_outgoing_cpool ()\n {\n-  outgoing_cpool = xmalloc (sizeof (struct CPool));\n-  memset (outgoing_cpool, 0, sizeof (struct CPool));\n+  outgoing_cpool = ggc_alloc_cleared (sizeof (struct CPool));\n }\n \n static void\n@@ -1074,7 +1049,7 @@ java_parse_file (set_yydebug)\n       if (magic == 0xcafebabe)\n \t{\n \t  CLASS_FILE_P (node) = 1;\n-\t  current_jcf = ALLOC (sizeof (JCF));\n+\t  current_jcf = ggc_alloc (sizeof (JCF));\n \t  JCF_ZERO (current_jcf);\n \t  current_jcf->read_state = finput;\n \t  current_jcf->filbuf = jcf_filbuf_from_stdio;\n@@ -1086,6 +1061,7 @@ java_parse_file (set_yydebug)\n       else if (magic == (JCF_u4)ZIPMAGIC)\n \t{\n \t  ZIP_FILE_P (node) = 1;\n+\t  main_jcf = ggc_alloc (sizeof (JCF));\n \t  JCF_ZERO (main_jcf);\n \t  main_jcf->read_state = finput;\n \t  main_jcf->filbuf = jcf_filbuf_from_stdio;\n@@ -1223,7 +1199,7 @@ process_zip_dir (FILE *finput)\n \n       class_name = ALLOC (zdir->filename_length+1-6);\n       file_name  = ALLOC (zdir->filename_length+1);\n-      jcf = ALLOC (sizeof (JCF));\n+      jcf = ggc_alloc (sizeof (JCF));\n       JCF_ZERO (jcf);\n \n       strncpy (class_name, class_name_in_zip_dir, zdir->filename_length-6);\n@@ -1255,9 +1231,6 @@ process_zip_dir (FILE *finput)\n void\n init_jcf_parse ()\n {\n-  /* Register roots with the garbage collector.  */\n-  ggc_add_root (&current_jcf, 1, sizeof (JCF), (void (*)(void *))ggc_mark_jcf);\n-\n   init_src_parse ();\n }\n "}, {"sha": "da45cc92ee61592f3129ce1e252a454adf0ae6a6", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -264,8 +264,8 @@ jcf_parse_constant_pool (JCF* jcf)\n {\n   int i, n;\n   JPOOL_SIZE (jcf) = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n-  jcf->cpool.tags = ALLOC (JPOOL_SIZE (jcf));\n-  jcf->cpool.data = ALLOC (sizeof (jword) * JPOOL_SIZE (jcf));\n+  jcf->cpool.tags = ggc_alloc (JPOOL_SIZE (jcf));\n+  jcf->cpool.data = ggc_alloc (sizeof (jword) * JPOOL_SIZE (jcf));\n   jcf->cpool.tags[0] = 0;\n #ifdef HANDLE_START_CONSTANT_POOL\n   HANDLE_START_CONSTANT_POOL (JPOOL_SIZE (jcf));\n@@ -285,33 +285,33 @@ jcf_parse_constant_pool (JCF* jcf)\n \t{\n \tcase CONSTANT_String:\n \tcase CONSTANT_Class:\n-\t  jcf->cpool.data[i] = JCF_readu2 (jcf);\n+\t  jcf->cpool.data[i].w = JCF_readu2 (jcf);\n \t  break;\n \tcase CONSTANT_Fieldref:\n \tcase CONSTANT_Methodref:\n \tcase CONSTANT_InterfaceMethodref:\n \tcase CONSTANT_NameAndType:\n-\t  jcf->cpool.data[i] = JCF_readu2 (jcf);\n-\t  jcf->cpool.data[i] |= JCF_readu2 (jcf) << 16;\n+\t  jcf->cpool.data[i].w = JCF_readu2 (jcf);\n+\t  jcf->cpool.data[i].w |= JCF_readu2 (jcf) << 16;\n \t  break;\n \tcase CONSTANT_Integer:\n \tcase CONSTANT_Float:\n-\t  jcf->cpool.data[i] = JCF_readu4 (jcf);\n+\t  jcf->cpool.data[i].w = JCF_readu4 (jcf);\n \t  break;\n \tcase CONSTANT_Long:\n \tcase CONSTANT_Double:\n-\t  jcf->cpool.data[i] = JCF_readu4 (jcf);\n+\t  jcf->cpool.data[i].w = JCF_readu4 (jcf);\n \t  i++; /* These take up two spots in the constant pool */\n \t  jcf->cpool.tags[i] = 0;\n-\t  jcf->cpool.data[i] = JCF_readu4 (jcf);\n+\t  jcf->cpool.data[i].w = JCF_readu4 (jcf);\n \t  break;\n \tcase CONSTANT_Utf8:\n \t  n = JCF_readu2 (jcf);\n \t  JCF_FILL (jcf, n);\n #ifdef HANDLE_CONSTANT_Utf8\n \t  HANDLE_CONSTANT_Utf8(jcf, i, n);\n #else\n-\t  jcf->cpool.data[i] = JCF_TELL(jcf) - 2;\n+\t  jcf->cpool.data[i].w = JCF_TELL(jcf) - 2;\n \t  JCF_SKIP (jcf, n);\n #endif\n \t  break;"}, {"sha": "c8e6aa7a602ec75cd719171c7ee2e7905f866918", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -55,39 +55,51 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #endif \n \n struct JCF;\n-typedef int (*jcf_filbuf_t) (struct JCF*, int needed);\n+typedef int (*jcf_filbuf_t) PARAMS ((struct JCF*, int needed));\n \n-typedef struct CPool {\n+union cpool_entry GTY(()) {\n+  jword GTY ((tag (\"0\"))) w;\n+  tree GTY ((tag (\"1\"))) t;\n+};\n+\n+#define cpool_entry_is_tree(tag) \\\n+  (tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8\n+\n+typedef struct CPool GTY(()) {\n   /* Available number of elements in the constants array, before it\n      must be re-allocated. */\n   int capacity;\n \n   /* The constant_pool_count. */\n   int\t\tcount;\n \n-  uint8*\ttags;\n+  uint8* GTY((length (\"%h.count\")))\ttags;\n \n-  jword*\tdata;\n+  union cpool_entry * GTY((length (\"%h.count\"),\n+\t\t\t   desc (\"cpool_entry_is_tree (%1.tags%a)\")))\tdata;\n } CPool;\n \n struct ZipDirectory;\n \n /* JCF encapsulates the state of reading a Java Class File. */\n \n-typedef struct JCF {\n-  unsigned char *buffer;\n-  unsigned char *buffer_end;\n-  unsigned char *read_ptr;\n-  unsigned char *read_end;\n+typedef struct JCF GTY(()) {\n+  unsigned char * GTY ((skip (\"\"))) buffer;\n+  unsigned char * GTY ((skip (\"\"))) buffer_end;\n+  unsigned char * GTY ((skip (\"\"))) read_ptr;\n+  unsigned char * GTY ((skip (\"\"))) read_end;\n   int java_source : 1;\n   int right_zip : 1;\n   int finished : 1;\n   jcf_filbuf_t filbuf;\n-  void *read_state;\n+  PTR GTY ((skip (\"\"))) read_state;\n   const char *filename;\n   const char *classname;\n-  struct ZipDirectory *zipd;\t/* Directory entry where it was found */\n-  JCF_u2 access_flags, this_class, super_class;\n+  /* Directory entry where it was found.  */\n+  struct ZipDirectory * GTY ((skip (\"\"))) zipd;\n+  JCF_u2 access_flags;\n+  JCF_u2 this_class;\n+  JCF_u2 super_class;\n   CPool cpool;\n } JCF;\n /*typedef JCF*  JCF_FILE;*/\n@@ -102,13 +114,13 @@ typedef struct JCF {\n #define JPOOL_SIZE(JCF) CPOOL_COUNT(&(JCF)->cpool)\n #define JPOOL_TAG(JCF, INDEX) ((JCF)->cpool.tags[INDEX])\n /* The INDEX'th constant pool entry as a JCF_u4. */\n-#define CPOOL_UINT(CPOOL, INDEX) ((CPOOL)->data[INDEX])\n+#define CPOOL_UINT(CPOOL, INDEX) ((CPOOL)->data[INDEX].w)\n #define JPOOL_UINT(JCF, INDEX) CPOOL_UINT(&(JCF)->cpool, INDEX) /*deprecated*/\n /* The first uint16 of the INDEX'th constant pool entry. */\n-#define CPOOL_USHORT1(CPOOL, INDEX) ((CPOOL)->data[INDEX] & 0xFFFF)\n+#define CPOOL_USHORT1(CPOOL, INDEX) ((CPOOL)->data[INDEX].w & 0xFFFF)\n #define JPOOL_USHORT1(JCF, INDEX) CPOOL_USHORT1(&(JCF)->cpool, INDEX)\n /* The second uint16 of the INDEX'th constant pool entry. */\n-#define CPOOL_USHORT2(CPOOL, INDEX) ((CPOOL)->data[INDEX] >> 16)\n+#define CPOOL_USHORT2(CPOOL, INDEX) ((CPOOL)->data[INDEX].w >> 16)\n #define JPOOL_USHORT2(JCF, INDEX) CPOOL_USHORT2(&(JCF)->cpool, INDEX)\n #define JPOOL_LONG(JCF, INDEX) \\\n   WORDS_TO_LONG (JPOOL_UINT(JCF, INDEX), JPOOL_UINT(JCF, (INDEX)+1))\n@@ -128,9 +140,10 @@ typedef struct JCF {\n #define CPOOL_INDEX_IN_RANGE(CPOOL, INDEX) \\\n  ((INDEX) > 0 && (INDEX) < CPOOL_COUNT(CPOOL))\n \n-#define CPOOL_FINISH(CPOOL) { \\\n-  if ((CPOOL)->tags) FREE ((CPOOL)->tags); \\\n-  if ((CPOOL)->data) FREE ((CPOOL)->data); }\n+#define CPOOL_FINISH(CPOOL) {\t\t\t\\\n+    (CPOOL)->tags = 0;\t\t\t\t\\\n+    (CPOOL)->data = 0;\t\t\t\t\\\n+  }\n \n #define JCF_FINISH(JCF) { \\\n   CPOOL_FINISH(&(JCF)->cpool); \\"}, {"sha": "976d0cf08afc924479c023dcbabf77c0405eba18", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -125,7 +125,7 @@ java_init_lex (finput, encoding)\n     CPC_INSTANCE_INITIALIZER_LIST (ctxp) = NULL_TREE;\n \n   memset (ctxp->modifier_ctx, 0, sizeof (ctxp->modifier_ctx));\n-  memset (current_jcf, 0, sizeof (JCF));\n+  current_jcf = ggc_alloc_cleared (sizeof (JCF));\n   ctxp->current_parsed_class = NULL;\n   ctxp->package = NULL_TREE;\n #endif"}, {"sha": "aa9a2beea34ae1357ba4664cd43ac58023a343d1", "filename": "gcc/java/lex.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -96,13 +96,13 @@ struct java_error {\n   int error;\n };\n \n-typedef struct _java_lc {\n+typedef struct java_lc_s GTY(()) {\n   int line;\n   int prev_col;\n   int col;\n } java_lc;\n \n-typedef struct java_lexer\n+struct java_lexer\n {\n   /* The file from which we're reading.  */\n   FILE *finput;\n@@ -155,7 +155,8 @@ typedef struct java_lexer\n   int out_last;\n \n #endif /* HAVE_ICONV */\n-} java_lexer;\n+};\n+typedef struct java_lexer java_lexer;\n \n /* Destroy a lexer object.  */\n extern void java_destroy_lexer (java_lexer *);"}, {"sha": "a6681afd6f062acf16617ebe94026a043358a10c", "filename": "gcc/java/parse.h", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -427,9 +427,6 @@ enum {\n   INVOKE_VIRTUAL\n };\n \n-/* We need the resolution stuff only if we compile jc1 */\n-#ifndef JC1_LITE\n-\n /* Unresolved type identifiers handling. When we process the source\n    code, we blindly accept an unknown type identifier and try to\n    resolve it later. When an unknown type identifier is encountered\n@@ -509,13 +506,12 @@ typedef struct _jdep {\n #define JDEP_RESOLVED_P(J)    \\\n \t(!(J)->solv || TREE_CODE ((J)->solv) != POINTER_TYPE)\n \n-typedef struct _jdeplist {\n+struct jdeplist_s {\n   jdep *first;\n   jdep *last;\n-  struct _jdeplist *next;\n-} jdeplist;\n-\n-#endif /* JC1_LITE */\n+  struct jdeplist_s *next;\n+};\n+typedef struct jdeplist_s jdeplist;\n \n #define CLASSD_FIRST(CD) ((CD)->first)\n #define CLASSD_LAST(CD)  ((CD)->last)\n@@ -727,22 +723,23 @@ typedef struct _jdeplist {\n #define DECL_INHERITED_SOURCE_LINE(DECL) (DECL_CHECK (DECL)->decl.u2.i)\n      \n /* Parser context data structure. */\n-struct parser_ctxt {\n+struct parser_ctxt GTY(()) {\n \n   const char *filename;\t\t    /* Current filename */\n   struct parser_ctxt *next;\n \n-  java_lexer *lexer;\t\t     /* Current lexer state */\n+  java_lexer * GTY((skip (\"\"))) lexer; /* Current lexer state */\n   char marker_begining;\t\t     /* Marker. Should be a sub-struct */\n-  struct java_line *p_line, *c_line; /* Previous and current line */\n+  struct java_line * GTY ((skip (\"\"))) p_line; /* Previous line */\n+  struct java_line * GTY ((skip (\"\"))) c_line; /* Current line */\n   java_lc elc;\t\t\t     /* Error's line column info */\n   int ccb_indent;\t\t     /* Keep track of {} indent, lexer */\n   int first_ccb_indent1;\t     /* First { at ident level 1 */\n   int last_ccb_indent1;\t\t     /* Last } at ident level 1 */\n   int parser_ccb_indent;\t     /* Keep track of {} indent, parser */\n   int osb_depth;\t\t     /* Current depth of [ in an expression */\n   int osb_limit;\t\t     /* Limit of this depth */\n-  int *osb_number;\t\t     /* Keep track of ['s */\n+  int * GTY ((skip (\"\"))) osb_number; /* Keep track of ['s */\n   int lineno;\t\t\t     /* Current lineno */\n   char marker_end;\t\t     /* End marker. Should be a sub-struct */\n \n@@ -761,13 +758,12 @@ struct parser_ctxt {\n   /* Flag to report certain errors (fix this documentation. FIXME) */\n   unsigned class_err:1;\n \n-  /* This section is defined only if we compile jc1 */\n-#ifndef JC1_LITE\n+  /* This section is used only if we compile jc1 */\n   tree modifier_ctx [12];\t    /* WFL of modifiers */\n   tree class_type;\t\t    /* Current class */\n   tree function_decl;\t            /* Current function decl, save/restore */\n \n-  struct JCF *current_jcf;\t    /* CU jcf */\n+  struct JCF * current_jcf;\t    /* CU jcf */\n \n   int prevent_ese;\t            /* Prevent expression statement error */\n \n@@ -778,7 +774,7 @@ struct parser_ctxt {\n \n   /* These two lists won't survive file traversal */\n   tree  class_list;\t\t    /* List of classes in a CU */\n-  jdeplist *classd_list;\t    /* Classe dependencies in a CU */\n+  jdeplist * GTY((skip (\"\"))) classd_list; /* Classe dependencies in a CU */\n   \n   tree  current_parsed_class;\t    /* Class currently parsed */\n   tree  current_parsed_class_un;    /* Curr. parsed class unqualified name */\n@@ -801,7 +797,6 @@ struct parser_ctxt {\n \t\t\t\t       constructor. This flag is used to trap\n \t\t\t\t       illegal argument usage during an\n \t\t\t\t       explicit constructor invocation. */\n-#endif /* JC1_LITE */\n };\n \n /* A set of macros to push/pop/access the currently parsed class.  */\n@@ -947,7 +942,7 @@ ATTRIBUTE_NORETURN\n ;\n extern void java_expand_classes (void);\n \n-extern struct parser_ctxt *ctxp;\n-extern struct parser_ctxt *ctxp_for_generation;\n+extern GTY(()) struct parser_ctxt *ctxp;\n+extern GTY(()) struct parser_ctxt *ctxp_for_generation;\n \n #endif /* ! GCC_JAVA_PARSE_H */"}, {"sha": "c67a42e11f65aa908c95a1543351b945410aa3bd", "filename": "gcc/java/parse.y", "status": "modified", "additions": 12, "deletions": 64, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -304,13 +304,16 @@ static tree maybe_build_thisn_access_method (tree);\n \n static tree build_outer_field_access (tree, tree);\n static tree build_outer_field_access_methods (tree);\n-static tree build_outer_field_access_expr (int, tree, tree, tree, tree);\n+static tree build_outer_field_access_expr (int, tree, tree,\n+\t\t\t\t\t\t  tree, tree);\n static tree build_outer_method_access_method (tree);\n static tree build_new_access_id (void);\n-static tree build_outer_field_access_method (tree, tree, tree, tree, tree);\n+static tree build_outer_field_access_method (tree, tree, tree,\n+\t\t\t\t\t\t    tree, tree);\n \n static int outer_field_access_p (tree, tree);\n-static int outer_field_expanded_access_p (tree, tree *, tree *, tree *);\n+static int outer_field_expanded_access_p (tree, tree *,\n+\t\t\t\t\t\t tree *, tree *);\n static tree outer_field_access_fix (tree, tree, tree);\n static tree build_incomplete_class_ref (int, tree);\n static tree patch_incomplete_class_ref (tree);\n@@ -321,7 +324,6 @@ static void add_inner_class_fields (tree, tree);\n static tree build_dot_class_method (tree);\n static tree build_dot_class_method_invocation (tree);\n static void create_new_parser_context (int);\n-static void mark_parser_ctxt (void *);\n static tree maybe_build_class_init_for_field (tree, tree);\n \n static int attach_init_test_initialization_flags (PTR *, PTR);\n@@ -594,18 +596,7 @@ static GTY(()) tree src_parse_roots[1];\n \n %%\n /* 19.2 Production from 2.3: The Syntactic Grammar  */\n-goal:\n-                {\n-\t\t  /* Register static variables with the garbage\n-\t\t     collector.  */\n-\t\t  ggc_add_root (&ctxp, 1,\n-\t\t\t\tsizeof (struct parser_ctxt *),\n-\t\t\t\tmark_parser_ctxt);\n-\t\t  ggc_add_root (&ctxp_for_generation, 1,\n-\t\t\t\tsizeof (struct parser_ctxt *),\n-\t\t\t\tmark_parser_ctxt);\n-\t\t}\n-\tcompilation_unit\n+goal:  compilation_unit\n \t\t{}\n ;\n \n@@ -2669,7 +2660,7 @@ create_new_parser_context (copy_from_previous)\n {\n   struct parser_ctxt *new;\n \n-  new =  (struct parser_ctxt *)xmalloc(sizeof (struct parser_ctxt));\n+  new =  (struct parser_ctxt *) ggc_alloc (sizeof (struct parser_ctxt));\n   if (copy_from_previous)\n     {\n       memcpy ((PTR)new, (PTR)ctxp, sizeof (struct parser_ctxt));\n@@ -2730,8 +2721,6 @@ java_pop_parser_context (generate)\n       toFree->next = ctxp_for_generation;\n       ctxp_for_generation = toFree;\n     }\n-  else\n-    free (toFree);\n }\n \n /* Create a parser context for the use of saving some global\n@@ -2830,10 +2819,6 @@ java_parser_context_resume ()\n   /* Re-installed the data for the parsing to carry on */\n   memcpy (&ctxp->marker_begining, &old->marker_begining,\n \t  (size_t)(&ctxp->marker_end - &ctxp->marker_begining));\n-\n-  /* Buffer context can now be discarded */\n-  free (saver);\n-  free (old);\n }\n \n /* Add a new anchor node to which all statement(s) initializing static\n@@ -6732,10 +6717,9 @@ process_imports ()\n       tree to_be_found = EXPR_WFL_NODE (TREE_PURPOSE (import));\n       char *original_name;\n \n-      obstack_grow0 (&temporary_obstack,\n-\t\t     IDENTIFIER_POINTER (to_be_found),\n-\t\t     IDENTIFIER_LENGTH (to_be_found));\n-      original_name = obstack_finish (&temporary_obstack);\n+      original_name = xmemdup (IDENTIFIER_POINTER (to_be_found),\n+\t\t\t       IDENTIFIER_LENGTH (to_be_found),\n+\t\t\t       IDENTIFIER_LENGTH (to_be_found) + 1);\n \n       /* Don't load twice something already defined. */\n       if (IDENTIFIER_CLASS_VALUE (to_be_found))\n@@ -6771,7 +6755,7 @@ process_imports ()\n \t  error_found = 1;\n \t}\n \n-      obstack_free (&temporary_obstack, original_name);\n+      free (original_name);\n       if (error_found)\n \treturn 1;\n     }\n@@ -16190,42 +16174,6 @@ resolve_qualified_name (name, context)\n }\n #endif\n \n-/* Mark P, which is really a `struct parser_ctxt **' for GC.  */\n-\n-static void\n-mark_parser_ctxt (p)\n-     void *p;\n-{\n-  struct parser_ctxt *pc = *((struct parser_ctxt **) p);\n-#ifndef JC1_LITE\n-  size_t i;\n-#endif\n-\n-  if (!pc)\n-    return;\n-\n-#ifndef JC1_LITE\n-  for (i = 0; i < ARRAY_SIZE (pc->modifier_ctx); ++i)\n-    ggc_mark_tree (pc->modifier_ctx[i]);\n-  ggc_mark_tree (pc->class_type);\n-  ggc_mark_tree (pc->function_decl);\n-  ggc_mark_tree (pc->package);\n-  ggc_mark_tree (pc->class_list);\n-  ggc_mark_tree (pc->current_parsed_class);\n-  ggc_mark_tree (pc->current_parsed_class_un);\n-  ggc_mark_tree (pc->non_static_initialized);\n-  ggc_mark_tree (pc->static_initialized);\n-  ggc_mark_tree (pc->instance_initializers);\n-  ggc_mark_tree (pc->import_list);\n-  ggc_mark_tree (pc->import_demand_list);\n-  ggc_mark_tree (pc->current_loop);\n-  ggc_mark_tree (pc->current_labeled_block);\n-#endif /* JC1_LITE */\n-\n-  if (pc->next)\n-    mark_parser_ctxt (&pc->next);\n-}\n-\n void\n init_src_parse ()\n {"}, {"sha": "0c573cd4d8290246e1157fe728dfaea2b60ac145", "filename": "gcc/mkdeps.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -291,3 +291,77 @@ deps_phony_targets (d, fp)\n       putc ('\\n', fp);\n     }\n }\n+\n+/* Write out a deps buffer to a file, in a form that can be read back\n+   with deps_restore.  Returns nonzero on error, in which case the\n+   error number will be in errno.  */\n+\n+int\n+deps_save (deps, f)\n+     struct deps *deps;\n+     FILE *f;\n+{\n+  unsigned int i;\n+\n+  /* The cppreader structure contains makefile dependences.  Write out this\n+     structure.  */\n+\n+  /* The number of dependences.  */\n+  if (fwrite (&deps->ndeps, sizeof (deps->ndeps), 1, f) != 1)\n+      return -1;\n+  /* The length of each dependence followed by the string.  */\n+  for (i = 0; i < deps->ndeps; i++)\n+    {\n+      size_t num_to_write = strlen (deps->depv[i]);\n+      if (fwrite (&num_to_write, sizeof (size_t), 1, f) != 1)\n+          return -1;\n+      if (fwrite (deps->depv[i], num_to_write, 1, f) != 1)\n+          return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Read back dependency information written with deps_save into\n+   the deps buffer.  The third argument may be NULL, in which case\n+   the dependency information is just skipped, or it may be a filename,\n+   in which case that filename is skipped.  */\n+\n+int\n+deps_restore (deps, fd, self)\n+     struct deps *deps;\n+     FILE *fd;\n+     const char *self;\n+{\n+  unsigned int i, count;\n+  size_t num_to_read;\n+  size_t buf_size = 512;\n+  char *buf = (char *) xmalloc (buf_size);\n+\n+  /* Number of dependences.  */\n+  if (fread (&count, 1, sizeof (count), fd) != sizeof (count))\n+    return -1;\n+\n+  /* The length of each dependence string, followed by the string.  */\n+  for (i = 0; i < count; i++)\n+    {\n+      /* Read in # bytes in string.  */\n+      if (fread (&num_to_read, 1, sizeof (size_t), fd) != sizeof (size_t))\n+\treturn -1;\n+      if (buf_size < num_to_read + 1)\n+\t{\n+\t  buf_size = num_to_read + 1 + 127;\n+\t  buf = xrealloc (buf, buf_size);\n+\t}\n+      if (fread (buf, 1, num_to_read, fd) != num_to_read)\n+\treturn -1;\n+      buf[num_to_read] = '\\0';\n+\n+      /* Generate makefile dependencies from .pch if -nopch-deps.  */ \n+      if (self != NULL && strcmp (buf, self) != 0)\n+        deps_add_dep (deps, buf);\n+    }\n+\n+  free (buf);\n+  return 0;\n+}"}, {"sha": "2be8f81a99cc89f00c21c1cef303b494834dc56c", "filename": "gcc/mkdeps.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fmkdeps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fmkdeps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -53,6 +53,17 @@ extern void deps_add_dep\tPARAMS ((struct deps *, const char *));\n extern void deps_write\t\tPARAMS ((const struct deps *, FILE *,\n \t\t\t\t\t unsigned int));\n \n+/* Write out a deps buffer to a file, in a form that can be read back\n+   with deps_restore.  Returns nonzero on error, in which case the\n+   error number will be in errno.  */\n+extern int deps_save\t\tPARAMS ((struct deps *, FILE *));\n+\n+/* Read back dependency information written with deps_save into\n+   the deps buffer.  The third argument may be NULL, in which case\n+   the dependency information is just skipped, or it may be a filename,\n+   in which case that filename is skipped.  */\n+extern int deps_restore\t\tPARAMS ((struct deps *, FILE *, const char *));\n+\n /* For each dependency *except the first*, emit a dummy rule for that\n    file, causing it to depend on nothing.  This is used to work around\n    the intermediate-file deletion misfeature in Make, in some"}, {"sha": "3a5de01b2db9bbf3e98585ea6158bb014fd69ec8", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -56,6 +56,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"varray.h\"\n #include \"debug.h\"\n #include \"target.h\"\n #include \"diagnostic.h\""}, {"sha": "2ff8fec62dd44c66343a8f9b1c002130f5c0e4b0", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -246,7 +246,7 @@ extern enum insn_code reload_in_optab[NUM_MACHINE_MODES];\n extern enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n \n /* Contains the optab used for each rtx code.  */\n-extern optab code_to_optab[NUM_RTX_CODE + 1];\n+extern GTY(()) optab code_to_optab[NUM_RTX_CODE + 1];\n \n \f\n typedef rtx (*rtxfun) PARAMS ((rtx));"}, {"sha": "1edb46f66a6086bfd44858f96ea10b5f58b9ccaa", "filename": "gcc/stringpool.c", "status": "modified", "additions": 85, "deletions": 8, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,5 +1,5 @@\n /* String pool for GCC.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -50,7 +50,6 @@ static struct obstack string_stack;\n \n static hashnode alloc_node PARAMS ((hash_table *));\n static int mark_ident PARAMS ((struct cpp_reader *, hashnode, const PTR));\n-static void mark_ident_hash PARAMS ((void *));\n \n /* Initialize the string pool.  */\n void\n@@ -60,7 +59,6 @@ init_stringpool ()\n   ident_hash = ht_create (14);\n   ident_hash->alloc_node = alloc_node;\n   gcc_obstack_init (&string_stack);\n-  ggc_add_root (&ident_hash, 1, sizeof ident_hash, mark_ident_hash);\n }\n \n /* Allocate a hash node.  */\n@@ -160,15 +158,94 @@ mark_ident (pfile, h, v)\n      hashnode h;\n      const PTR v ATTRIBUTE_UNUSED;\n {\n-  ggc_mark_tree (HT_IDENT_TO_GCC_IDENT (h));\n+  gt_ggc_m_9tree_node (HT_IDENT_TO_GCC_IDENT (h));\n   return 1;\n }\n \n-/* Mark all identifiers for GC.  */\n+/* Mark the trees hanging off the identifier node for GGC.  These are\n+   handled specially (not using gengtype) because of the special\n+   treatment for strings.  */\n \n-static void\n-mark_ident_hash (arg)\n-     PTR arg ATTRIBUTE_UNUSED;\n+void\n+ggc_mark_stringpool ()\n {\n   ht_forall (ident_hash, mark_ident, NULL);\n }\n+\n+/* Strings are _not_ GCed, but this routine exists so that a separate\n+   roots table isn't needed for the few global variables that refer\n+   to strings.  */\n+\n+void\n+gt_ggc_m_S (x)\n+     void *x ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+/* Pointer-walking routine for strings (not very interesting, since\n+   strings don't contain pointers).  */\n+\n+void\n+gt_pch_p_S (obj, x, op, cookie)\n+     void *obj ATTRIBUTE_UNUSED;\n+     void *x ATTRIBUTE_UNUSED;\n+     gt_pointer_operator op ATTRIBUTE_UNUSED;\n+     void *cookie ATTRIBUTE_UNUSED;\n+{\n+}\n+\n+/* PCH pointer-walking routine for strings.  */\n+\n+void\n+gt_pch_n_S (x)\n+     const void *x;\n+{\n+  gt_pch_note_object ((void *)x, (void *)x, &gt_pch_p_S);\n+}\n+\n+/* Handle saving and restoring the string pool for PCH.  */\n+\n+struct string_pool_data GTY(())\n+{\n+  tree * GTY((length (\"%h.nslots\"))) entries;\n+  unsigned int nslots;\n+  unsigned int nelements;\n+};\n+\n+static GTY(()) struct string_pool_data * spd;\n+\n+void\n+gt_pch_save_stringpool ()\n+{\n+  unsigned int i;\n+  \n+  spd = ggc_alloc (sizeof (*spd));\n+  spd->nslots = ident_hash->nslots;\n+  spd->nelements = ident_hash->nelements;\n+  spd->entries = ggc_alloc (sizeof (tree *) * spd->nslots);\n+  for (i = 0; i < spd->nslots; i++)\n+    if (ident_hash->entries[i] != NULL)\n+      spd->entries[i] = HT_IDENT_TO_GCC_IDENT (ident_hash->entries[i]);\n+    else\n+      spd->entries[i] = NULL;\n+}\n+\n+void\n+gt_pch_restore_stringpool ()\n+{\n+  unsigned int i;\n+  \n+  ident_hash->nslots = spd->nslots;\n+  ident_hash->nelements = spd->nelements;\n+  ident_hash->entries = xrealloc (ident_hash->entries,\n+\t\t\t\t  sizeof (hashnode) * spd->nslots);\n+  for (i = 0; i < spd->nslots; i++)\n+    if (spd->entries[i] != NULL)\n+      ident_hash->entries[i] = GCC_IDENT_TO_HT_IDENT (spd->entries[i]);\n+    else\n+      ident_hash->entries[i] = NULL;\n+\n+  spd = NULL;\n+}\n+\n+#include \"gt-stringpool.h\""}, {"sha": "e1c6e0287aec031c6977f40c678e178b87d6f4fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,3 +1,87 @@\n+2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tMerge from pch-branch:\n+\n+\t2002-12-23  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/cpp-1.h: New.\n+\t* gcc.dg/pch/cpp-1.c: New.\n+\t* gcc.dg/pch/cpp-2.h: New.\n+\t* gcc.dg/pch/cpp-2.c: New.\n+\n+\t2002-11-19  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/except-1.h: New.\n+\t* gcc.dg/pch/except-1.c: New.\n+\n+\t2002-11-13  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/pch.exp: Ensure that <test>.hp doesn't exist before\n+\trunning test.\n+\t* gcc.dg/pch: Include *.hp not *.h.\n+\t* gcc.dg/pch/system-1.h: New.\n+\t* gcc.dg/pch/system-1.c: New.\n+\n+\t2002-11-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/pch.exp: Compare .s files with/without PCH,\n+\trather than trying to build and run a program using PCH.\n+\t* gcc.dg/pch: Remove dg-do commands from test files.\n+\t\n+\t2002-11-08  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/macro-3.c: New.\n+\t* gcc.dg/pch/macro-3.h: New.\n+\n+\t2002-11-04  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/common-1.c: New.\n+\t* gcc.dg/pch/common-1.h: New.\n+\t* gcc.dg/pch/decl-1.c: New.\n+\t* gcc.dg/pch/decl-1.h: New.\n+\t* gcc.dg/pch/decl-2.c: New.\n+\t* gcc.dg/pch/decl-2.h: New.\n+\t* gcc.dg/pch/decl-3.c: New.\n+\t* gcc.dg/pch/decl-3.h: New.\n+\t* gcc.dg/pch/decl-4.c: New.\n+\t* gcc.dg/pch/decl-4.h: New.\n+\t* gcc.dg/pch/decl-5.c: New.\n+\t* gcc.dg/pch/decl-5.h: New.\n+\t* gcc.dg/pch/global-1.c: New.\n+\t* gcc.dg/pch/global-1.h: New.\n+\t* gcc.dg/pch/inline-1.c: New.\n+\t* gcc.dg/pch/inline-1.h: New.\n+\t* gcc.dg/pch/inline-2.c: New.\n+\t* gcc.dg/pch/inline-2.h: New.\n+\t* gcc.dg/pch/static-1.c: New.\n+\t* gcc.dg/pch/static-1.h: New.\n+\t* gcc.dg/pch/static-2.c: New.\n+\t* gcc.dg/pch/static-2.h: New.\n+\n+\t2002-09-01  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* g++.dg/pch/pch.exp: Better handle failing testcases.\n+\t* gcc.dg/pch/pch.exp: Likewise.\n+\t* gcc.dg/pch/macro-1.c: New.\n+\t* gcc.dg/pch/macro-1.h: New.\n+\t* gcc.dg/pch/macro-2.c: New.\n+\t* gcc.dg/pch/macro-2.h: New.\n+\n+\t2002-08-27  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* g++.dg/dg.exp: Treat files in pch/ specially.\n+\t* g++.dg/pch/pch.exp: New file.\n+\t* g++.dg/pch/empty.H: New file.\n+\t* g++.dg/pch/empty.C: New file.\n+\t* lib/g++-dg.exp (g++-dg-test): Add case for when $do_what is\n+\t\"precompile\".\n+\n+\t* gcc.dg/pch/pch.exp: New file.\n+\t* gcc.dg/pch/empty.h: New file.\n+\t* gcc.dg/pch/empty.c: New file.\n+\t* lib/gcc-dg.exp (gcc-dg-test): Add case for when $do_what is\n+\t\"precompile\".\n+\n 2003-01-09  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* g++.dg/template/friend14.C: New test."}, {"sha": "d9839608733179e36981d43f6c1e075c5ae282d0", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -35,6 +35,7 @@ set tests [prune $tests $srcdir/$subdir/bprob/*]\n set tests [prune $tests $srcdir/$subdir/compat/*]\n set tests [prune $tests $srcdir/$subdir/debug/*]\n set tests [prune $tests $srcdir/$subdir/gcov/*]\n+set tests [prune $tests $srcdir/$subdir/pch/*]\n set tests [prune $tests $srcdir/$subdir/special/*]\n set tests [prune $tests $srcdir/$subdir/tls/*]\n "}, {"sha": "7aef099f3ef6cf316248d2b22e4777ffa29a15db", "filename": "gcc/testsuite/g++.dg/pch/empty.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fempty.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fempty.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fempty.C?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,5 @@\n+#include \"empty.Hp\"\n+int main() \n+{\n+  return 0;\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/g++.dg/pch/empty.H", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fempty.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fempty.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fempty.H?ref=17211ab55314d76370a68036f2d057b1effd687f"}, {"sha": "8507e355f5387163e9c7b79d2979e7cfb2edacbd", "filename": "gcc/testsuite/g++.dg/pch/pch.exp", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpch.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpch.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpch.exp?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,100 @@\n+#   Copyright (C) 1997, 2002 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# GCC testsuite for precompiled header interaction,\n+# that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib \"g++-dg.exp\"\n+\n+# Initialize `dg'.\n+dg-init\n+\n+set old_dg_do_what_default \"${dg-do-what-default}\"\n+\n+# Main loop.\n+foreach test [lsort [glob -nocomplain $srcdir/$subdir/*.C]] {\n+    global runtests dg-do-what-default\n+\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $test] {\n+\tcontinue\n+    }\n+    set nshort [file tail [file dirname $test]]/[file tail $test]\n+    set bname \"[file rootname [file tail $test]]\"\n+\n+    catch { file delete \"$bname.Hp.pch\" }\n+    catch { file delete \"$bname.H.pch\" }\n+    catch { file delete \"$bname.s\" }\n+    catch { file delete \"$bname.s-pch\" }\n+    catch { file delete \"$bname.Hp\" }\n+\n+    # We don't try to use the loop-optimizing options, since they are highly\n+    # unlikely to make any difference to PCH.\n+    foreach flags { \"-g\" \"-O2 -g\" \"-O2\" } {\n+\tverbose \"Testing $nshort, $flags\" 1\n+\n+\t# For the header files, the default is to precompile.\n+\tset dg-do-what-default precompile\n+\tdg-test -keep-output \"[file rootname $test].H\" $flags \"\"\n+\n+\t# For the rest, the default is to compile to .s.\n+\tset dg-do-what-default compile\n+\n+\tif { [ file exists \"$bname.H.pch\" ] } {\n+\t    # To ensure that the PCH is used, not the original header,\n+\t    # the actual PCH file is renamed to \"<foo>.Hp.pch\".\n+\t    file rename \"$bname.H.pch\" \"$bname.Hp.pch\"\n+\t    if { [ is_remote host ] } {\n+\t\tremote_download host \"$bname.Hp.pch\"\n+\t    }\n+\n+\t    dg-test -keep-output $test $flags \"-I.\"\n+\t    file delete \"$bname.Hp.pch\"\n+\t    if { [ file exists \"$bname.s\" ] } {\n+\t\tfile rename \"$bname.s\" \"$bname.s-pch\"\n+\t\tif { [ is_remote host ] } {\n+\t\t    remote_upload host \"[file rootname $test].H\" \"$bname.Hp\"\n+\t\t} else {\n+\t\t    file copy \"[file rootname $test].H\" \"$bname.Hp\"\n+\t\t}\n+\t\tdg-test -keep-output $test $flags \"-I.\"\n+\t\tremote_file host delete \"$bname.Hp\"\n+\t\tset tmp [ diff \"$bname.s\" \"$bname.s-pch\" ]\n+\t\tif { $tmp == 0 } {\n+\t\t    untested \"$nshort $flags assembly comparison\"\n+\t\t} elseif { $tmp == 1 } {\n+\t\t    pass \"$nshort $flags assembly comparison\"\n+\t\t} else {\n+\t\t    fail \"$nshort $flags assembly comparison\"\n+\t\t}\n+\t\tfile delete \"$bname.s\"\n+\t\tfile delete \"$bname.s-pch\"\n+\t    } else {\n+\t\tuntested \"$nshort $flags assembly comparison\"\n+\t    }\n+\n+\t} else {\n+\t    untested $nshort\n+\t    untested \"$nshort $flags assembly comparison\"\n+\t}\n+    }\n+}\n+\n+set dg-do-what-default \"$old_dg_do_what_default\"\n+\n+# All done.\n+dg-finish"}, {"sha": "a0444bc5941f7fc2c500cfb060dd7bd74a5758b9", "filename": "gcc/testsuite/g++.dg/pch/system-1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fsystem-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fsystem-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fsystem-1.C?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,7 @@\n+#include \"system-1.Hp\"\n+\n+int main() \n+{\n+  std::cout << \"hello world!\" << '\\n';\n+  return 0;\n+}"}, {"sha": "604782e4dc7e82af0bf7ae4bc04dd2ae4588a715", "filename": "gcc/testsuite/g++.dg/pch/system-1.H", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fsystem-1.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fsystem-1.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fsystem-1.H?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1 @@\n+#include <iostream>"}, {"sha": "dcf148a2a722f5c312b9994bbc4052310d3545a6", "filename": "gcc/testsuite/gcc.dg/pch/common-1.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcommon-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcommon-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcommon-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,3 @@\n+#include \"common-1.hp\"\n+int foo2 = 3;\n+int zz = 2;"}, {"sha": "971e1996a24a1d60e0c4db4e4076ce1c1f4cb722", "filename": "gcc/testsuite/gcc.dg/pch/common-1.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcommon-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcommon-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcommon-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,3 @@\n+static int foo1 = 9;\n+int foo2;\n+extern int zz;"}, {"sha": "43256cad5455d5fa27b5165769aba95cb210aefc", "filename": "gcc/testsuite/gcc.dg/pch/cpp-1.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,4 @@\n+#include \"cpp-1.hp\"\n+#if !defined(__GNUC__)\n+panic! panic!\n+#endif"}, {"sha": "6e25b021ab50d9b5863c60a5d9cb68ccaae31a4b", "filename": "gcc/testsuite/gcc.dg/pch/cpp-1.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1 @@\n+/* Empty.  */"}, {"sha": "b76c22cdb04bf4d598213da5aa0080dff32a5a79", "filename": "gcc/testsuite/gcc.dg/pch/cpp-2.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-2.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-options \"-Wunknown-pragmas -I.\" } */\n+#include \"cpp-2.hp\"\n+#pragma GCC poison not_used\n+"}, {"sha": "6e25b021ab50d9b5863c60a5d9cb68ccaae31a4b", "filename": "gcc/testsuite/gcc.dg/pch/cpp-2.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fcpp-2.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1 @@\n+/* Empty.  */"}, {"sha": "e4120704d9bb49ec2d81c221d25bac2c23ebe3bb", "filename": "gcc/testsuite/gcc.dg/pch/decl-1.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#include \"decl-1.hp\"\n+int main(void) { return foo; }"}, {"sha": "399f5d3e7f4ba1a117372c5fcc672e7161a23e06", "filename": "gcc/testsuite/gcc.dg/pch/decl-1.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1 @@\n+extern int foo;"}, {"sha": "c374a17e3f77a354fa38fde514b81040fdadaa5f", "filename": "gcc/testsuite/gcc.dg/pch/decl-2.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-2.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#include \"decl-2.hp\"\n+int main(void) { return fun (1, 2); }"}, {"sha": "99c3726909754d611e85b417997258433b89c238", "filename": "gcc/testsuite/gcc.dg/pch/decl-2.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-2.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,3 @@\n+extern int fun (int a, int b);\n+\n+"}, {"sha": "9c95b9ad08efeaada04834978fddd7d2854225af", "filename": "gcc/testsuite/gcc.dg/pch/decl-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-3.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,11 @@\n+#include \"decl-3.hp\"\n+\n+foo_p bar (void) \n+{\n+  return foop;\n+}\n+\n+struct foo *bar2 (void) \n+{\n+  return foop;\n+}"}, {"sha": "787d480f208e4331cfb4e663583d3b08288391e5", "filename": "gcc/testsuite/gcc.dg/pch/decl-3.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-3.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,3 @@\n+struct foo;\n+typedef struct foo *foo_p;\n+extern foo_p foop;"}, {"sha": "3efe3829ffcd722bbdb284f48b228a29f3f1a42e", "filename": "gcc/testsuite/gcc.dg/pch/decl-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-4.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,9 @@\n+#include \"decl-4.hp\"\n+\n+int bar (foo_p f)\n+{\n+  if (f->a + foop->a)\n+    return f->c->b + foop->b;\n+  else\n+    return foop->c->b + f->a;\n+}"}, {"sha": "3fb220032e048189ef4801e426fe2129cddc443d", "filename": "gcc/testsuite/gcc.dg/pch/decl-4.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-4.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,7 @@\n+typedef struct foo {\n+  int a;\n+  char b;\n+  struct foo *c;\n+} foo_s;\n+typedef struct foo *foo_p;\n+extern foo_p foop;"}, {"sha": "f94b33a1363b00dbdd6ba8fb39c09be163f2ed55", "filename": "gcc/testsuite/gcc.dg/pch/decl-5.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-5.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#include \"decl-5.hp\"\n+static int (*t)(void) = foo;"}, {"sha": "914983c49636c2c114b24d1e69989621637a5d4e", "filename": "gcc/testsuite/gcc.dg/pch/decl-5.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fdecl-5.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1 @@\n+extern int foo(void);"}, {"sha": "330876cc7c7558336e855e98bb440153a4220b9d", "filename": "gcc/testsuite/gcc.dg/pch/empty.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fempty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fempty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fempty.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,8 @@\n+/* Yes, it's called \"empty\" because it has no contents at all.  \n+   Even this comment goes here, rather than in empty.h.  */\n+#include \"empty.hp\"\n+\n+int main(void) \n+{\n+  return 0;\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/pch/empty.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fempty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fempty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fempty.h?ref=17211ab55314d76370a68036f2d057b1effd687f"}, {"sha": "0332609de2da039facec4d94850f38130b3b68fb", "filename": "gcc/testsuite/gcc.dg/pch/except-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fexcept-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fexcept-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fexcept-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-fexceptions -I.\" } */\n+#include \"except-1.hp\"\n+\n+int main(void) \n+{\n+  return foo(1);\n+}"}, {"sha": "33a893d1533500d8bfed831bd4724240d1e37408", "filename": "gcc/testsuite/gcc.dg/pch/except-1.h", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fexcept-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fexcept-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fexcept-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-options \"-fexceptions\" } */\n+extern inline int\n+foo(int a)\n+{\n+  return a + 1;\n+}"}, {"sha": "4cab062345e3ea070570f118656b478af1be7d5e", "filename": "gcc/testsuite/gcc.dg/pch/global-1.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fglobal-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fglobal-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fglobal-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#include \"global-1.hp\"\n+const int bar = 3;"}, {"sha": "26efffcb2bbd5eba1aa9794904ab8cbb81803385", "filename": "gcc/testsuite/gcc.dg/pch/global-1.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fglobal-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fglobal-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fglobal-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1 @@\n+const int foo = 2;"}, {"sha": "7fc32d7f7663f1bb4aaf7d87b4b93a2e057d5057", "filename": "gcc/testsuite/gcc.dg/pch/inline-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,10 @@\n+#include \"inline-1.hp\"\n+int bar(int a, int b)\n+{\n+  return foo(a) + b;\n+}\n+\n+int baz(void)\n+{\n+  return foo(3);\n+}"}, {"sha": "e8f1d6f138fb8957559699ab2c3ffeaf1aac2308", "filename": "gcc/testsuite/gcc.dg/pch/inline-1.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,5 @@\n+extern inline int\n+foo(int a)\n+{\n+  return a * 2 + 1;\n+}"}, {"sha": "7792c828b929963910add10a51f65c6a4b53fd23", "filename": "gcc/testsuite/gcc.dg/pch/inline-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-2.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,12 @@\n+#include \"inline-2.hp\"\n+extern inline char\n+bar(int a)\n+{\n+  return foo(a)[0];\n+}\n+\n+extern inline char\n+baz(void)\n+{\n+  return foo(0)[0];\n+}"}, {"sha": "7d90c63deb929a4e8307fa513455a24c65782620", "filename": "gcc/testsuite/gcc.dg/pch/inline-2.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Finline-2.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,5 @@\n+extern inline const char *\n+foo(int a)\n+{\n+  return \"abcdefgh\"+a;\n+}"}, {"sha": "3775004a77b5dfcf5886774abf9e49bc4e43ff55", "filename": "gcc/testsuite/gcc.dg/pch/macro-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,6 @@\n+#include \"macro-1.hp\"\n+\n+int main(void) \n+{\n+  return DEFINED_VALUE + 1 - DEFINED_PARAM (3);\n+}"}, {"sha": "5d5b3f4ca657e4990c86eef470387a4dfe12cbce", "filename": "gcc/testsuite/gcc.dg/pch/macro-1.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#define DEFINED_VALUE 3\n+#define DEFINED_PARAM(x) (x+1)"}, {"sha": "d058e2bb8698ebfa29f9dc5f191ebbefc47bf6dc", "filename": "gcc/testsuite/gcc.dg/pch/macro-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-2.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,8 @@\n+#define DEFINED_VALUE_2 3\n+\n+#include \"macro-2.hp\"\n+\n+int main(void) \n+{\n+  return DEFINED_VALUE - DEFINED_VALUE_2;\n+}"}, {"sha": "6152a84a877438de6790a44b2eab7cfcb2cbc9c4", "filename": "gcc/testsuite/gcc.dg/pch/macro-2.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-2.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#define DEFINED_VALUE 3\n+"}, {"sha": "40ee46e4f3aa05f10f1c1b944b3c14b4e8d4cc4a", "filename": "gcc/testsuite/gcc.dg/pch/macro-3.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-3.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,8 @@\n+#define DEFINED_FUNC_2(x) (3 + (x))\n+\n+#include \"macro-3.hp\"\n+\n+int main(void) \n+{\n+  return DEFINED_FUNC (1) - DEFINED_FUNC_2 (-1);\n+}"}, {"sha": "d394792a342270194077ff989a0fcb0489150b2c", "filename": "gcc/testsuite/gcc.dg/pch/macro-3.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-3.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#define DEFINED_FUNC(x) 3 - (x)\n+"}, {"sha": "69422ca3ef04fa391c8943f6b6e64c9f0864f605", "filename": "gcc/testsuite/gcc.dg/pch/pch.exp", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpch.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpch.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fpch.exp?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,100 @@\n+#   Copyright (C) 1997, 2002 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# GCC testsuite for precompiled header interaction,\n+# that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+set old_dg_do_what_default \"${dg-do-what-default}\"\n+\n+# Main loop.\n+foreach test [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {\n+    global runtests torture_without_loops dg-do-what-default\n+\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $test] {\n+\tcontinue\n+    }\n+    set nshort [file tail [file dirname $test]]/[file tail $test]\n+    set bname \"[file rootname [file tail $test]]\"\n+\n+    catch { file delete \"$bname.hp.pch\" }\n+    catch { file delete \"$bname.h.pch\" }\n+    catch { file delete \"$bname.s\" }\n+    catch { file delete \"$bname.s-pch\" }\n+    catch { file delete \"$bname.hp\" }\n+\n+    # We don't try to use the loop-optimizing options, since they are highly\n+    # unlikely to make any difference to PCH.\n+    foreach flags $torture_without_loops {\n+\tverbose \"Testing $nshort, $flags\" 1\n+\n+\t# For the header files, the default is to precompile.\n+\tset dg-do-what-default precompile\n+\tdg-test -keep-output \"[file rootname $test].h\" $flags \"\"\n+\n+\t# For the rest, the default is to compile to .s.\n+\tset dg-do-what-default compile\n+\n+\tif { [ file exists \"$bname.h.pch\" ] } {\n+\t    # To ensure that the PCH is used, not the original header,\n+\t    # the actual PCH file is renamed to \"<foo>.hp.pch\".\n+\t    file rename \"$bname.h.pch\" \"$bname.hp.pch\"\n+\t    if { [ is_remote host ] } {\n+\t\tremote_download host \"$bname.hp.pch\"\n+\t    }\n+\n+\t    dg-test -keep-output $test $flags \"-I.\"\n+\t    file delete \"$bname.hp.pch\"\n+\t    if { [ file exists \"$bname.s\" ] } {\n+\t\tfile rename \"$bname.s\" \"$bname.s-pch\"\n+\t\tif { [ is_remote host ] } {\n+\t\t    remote_upload host \"[file rootname $test].h\" \"$bname.hp\"\n+\t\t} else {\n+\t\t    file copy \"[file rootname $test].h\" \"$bname.hp\"\n+\t\t}\n+\t\tdg-test -keep-output $test $flags \"-I.\"\n+\t\tremote_file host delete \"$bname.hp\"\n+\t\tset tmp [ diff \"$bname.s\" \"$bname.s-pch\" ]\n+\t\tif { $tmp == 0 } {\n+\t\t    untested \"$nshort $flags assembly comparison\"\n+\t\t} elseif { $tmp == 1 } {\n+\t\t    pass \"$nshort $flags assembly comparison\"\n+\t\t} else {\n+\t\t    fail \"$nshort $flags assembly comparison\"\n+\t\t}\n+\t\tfile delete \"$bname.s\"\n+\t\tfile delete \"$bname.s-pch\"\n+\t    } else {\n+\t\tuntested \"$nshort $flags assembly comparison\"\n+\t    }\n+\n+\t} else {\n+\t    untested $nshort\n+\t    untested \"$nshort $flags assembly comparison\"\n+\t}\n+    }\n+}\n+\n+set dg-do-what-default \"$old_dg_do_what_default\"\n+\n+# All done.\n+dg-finish"}, {"sha": "c1816e949b4cf68c55de29b2cb6f25be14ab8113", "filename": "gcc/testsuite/gcc.dg/pch/static-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,6 @@\n+#include \"static-1.hp\"\n+static int bar(void)\n+{\n+  static int counter;\n+  return counter++;\n+}"}, {"sha": "08cc4395d0e0145b2bd54ecc2b216053d80e3be8", "filename": "gcc/testsuite/gcc.dg/pch/static-1.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,5 @@\n+static int foo(void)\n+{\n+  static int counter;\n+  return counter++;\n+}"}, {"sha": "afda874e279f9cbf2319cbdf2db6af8be7b4bbc1", "filename": "gcc/testsuite/gcc.dg/pch/static-2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-2.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,6 @@\n+#include \"static-2.hp\"\n+int bar(void)\n+{\n+  static int counter;\n+  return counter++;\n+}"}, {"sha": "08cc4395d0e0145b2bd54ecc2b216053d80e3be8", "filename": "gcc/testsuite/gcc.dg/pch/static-2.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fstatic-2.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,5 @@\n+static int foo(void)\n+{\n+  static int counter;\n+  return counter++;\n+}"}, {"sha": "096fe593e06baf5d64bd0acd36ccd19c13dbc288", "filename": "gcc/testsuite/gcc.dg/pch/system-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fsystem-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fsystem-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fsystem-1.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,6 @@\n+#include \"system-1.hp\"\n+int main(void)\n+{\n+  puts (\"hello world!\");\n+  exit (0);\n+}"}, {"sha": "fbfff34edb0a7b24cdf69c9d68262db45b4c2305", "filename": "gcc/testsuite/gcc.dg/pch/system-1.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fsystem-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fsystem-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fsystem-1.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -0,0 +1,2 @@\n+#include <stdio.h>\n+#include <stdlib.h>"}, {"sha": "2fad5d1f7f81d0166ae555abaca51cf8fb5ca8f4", "filename": "gcc/testsuite/lib/g++-dg.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Flib%2Fg%2B%2B-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Flib%2Fg%2B%2B-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg%2B%2B-dg.exp?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -37,6 +37,10 @@ proc g++-dg-test { prog do_what extra_tool_flags } {\n \t    set compile_type \"object\"\n \t    set output_file \"[file rootname [file tail $prog]].o\"\n \t}\n+\t\"precompile\" {\n+\t    set compile_type \"precompiled_header\"\n+\t    set output_file \"[file tail $prog].pch\"\n+\t}\n \t\"link\" {\n \t    set compile_type \"executable\"\n \t    set output_file \"[file rootname [file tail $prog]].exe\""}, {"sha": "dd130b9c37efa4ba34e8332f74bd571b18f6f4db", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -69,6 +69,10 @@ proc gcc-dg-test { prog do_what extra_tool_flags } {\n \t    set compile_type \"object\"\n \t    set output_file \"[file rootname [file tail $prog]].o\"\n \t}\n+\t\"precompile\" {\n+\t    set compile_type \"precompiled_header\"\n+\t    set output_file \"[file tail $prog].pch\"\n+\t}\n \t\"link\" {\n \t    set compile_type \"executable\"\n \t    set output_file \"[file rootname [file tail $prog]].exe\""}, {"sha": "f98fc366d4a1bf59268424d17a1bac53e86b7957", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -4666,7 +4666,7 @@ init_asm_output (name)\n       if (!strcmp (asm_file_name, \"-\"))\n \tasm_out_file = stdout;\n       else\n-\tasm_out_file = fopen (asm_file_name, \"w\");\n+\tasm_out_file = fopen (asm_file_name, \"w+\");\n       if (asm_out_file == 0)\n \tfatal_io_error (\"can't open %s for writing\", asm_file_name);\n     }"}, {"sha": "f1549ab89db20404fc35767ebdbcc743fa397e6c", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -136,8 +136,8 @@ void\n init_ttree ()\n {\n   /* Initialize the hash table of types.  */\n-  type_hash_table = htab_create (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n-\t\t\t\t type_hash_eq, 0);\n+  type_hash_table = htab_create_ggc (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n+\t\t\t\t     type_hash_eq, 0);\n }\n \n \f"}, {"sha": "d8bc1a8c72a4078ae2a7eee26564c8d5a0657344", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -98,7 +98,7 @@ enum built_in_function\n extern const char *const built_in_names[(int) END_BUILTINS];\n \n /* An array of _DECL trees for the above.  */\n-extern tree built_in_decls[(int) END_BUILTINS];\n+extern GTY(()) tree built_in_decls[(int) END_BUILTINS];\n \f\n /* The definition of tree nodes fills the next several pages.  */\n \n@@ -1273,9 +1273,9 @@ struct tree_type GTY(())\n   tree pointer_to;\n   tree reference_to;\n   union tree_type_symtab {\n-    int address; \n+    int GTY ((tag (\"0\"))) address; \n     char * GTY ((tag (\"1\"))) pointer; \n-    struct die_struct * GTY ((tag (\"2\"), skip (\"\"))) die;\n+    struct die_struct * GTY ((tag (\"2\"))) die;\n   } GTY ((desc (\"debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0\"), \n \t  descbits (\"2\"))) symtab;\n   tree name;\n@@ -1881,7 +1881,7 @@ struct tree_decl GTY(())\n     struct function * GTY ((tag (\"FUNCTION_DECL\"))) f;\n     rtx GTY ((tag (\"PARM_DECL\"))) r;\n     tree GTY ((tag (\"FIELD_DECL\"))) t;\n-    int i;\n+    int GTY ((tag (\"VAR_DECL\"))) i;\n   } GTY ((desc (\"TREE_CODE((tree) &(%0))\"))) u2;\n \n   /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */"}, {"sha": "673030d5527c11c2c046ee5c656a3b914e9fb1c7", "filename": "gcc/varasm.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -107,12 +107,12 @@ struct varasm_status GTY(())\n /* Number for making the label on the next\n    constant that is stored in memory.  */\n \n-int const_labelno;\n+static GTY(()) int const_labelno;\n \n /* Number for making the label on the next\n    static variable internal to a function.  */\n \n-int var_labelno;\n+static GTY(()) int var_labelno;\n \n /* Carry information from ASM_DECLARE_OBJECT_NAME\n    to ASM_FINISH_DECLARE_OBJECT.  */\n@@ -179,7 +179,7 @@ static bool asm_emit_uninitialised\tPARAMS ((tree, const char*, int, int));\n static void resolve_unique_section\tPARAMS ((tree, int, int));\n static void mark_weak                   PARAMS ((tree));\n \f\n-static enum in_section { no_section, in_text, in_data, in_named\n+enum in_section { no_section, in_text, in_data, in_named\n #ifdef BSS_SECTION_ASM_OP\n   , in_bss\n #endif\n@@ -195,7 +195,8 @@ static enum in_section { no_section, in_text, in_data, in_named\n #ifdef EXTRA_SECTIONS\n   , EXTRA_SECTIONS\n #endif\n-} in_section = no_section;\n+};\n+static GTY(()) enum in_section in_section = no_section;\n \n /* Return a nonzero value if DECL has a section attribute.  */\n #ifndef IN_NAMED_SECTION\n@@ -205,18 +206,18 @@ static enum in_section { no_section, in_text, in_data, in_named\n #endif\n \n /* Text of section name when in_section == in_named.  */\n-static const char *in_named_name;\n+static GTY(()) const char *in_named_name;\n \n /* Hash table of flags that have been used for a particular named section.  */\n \n-struct in_named_entry\n+struct in_named_entry GTY(())\n {\n   const char *name;\n   unsigned int flags;\n   bool declared;\n };\n \n-static htab_t in_named_htab;\n+static GTY((param_is (struct in_named_entry))) htab_t in_named_htab;\n \n /* Define functions like text_section for any extra sections.  */\n #ifdef EXTRA_SECTION_FUNCTIONS\n@@ -379,7 +380,7 @@ set_named_section_flags (section, flags)\n \n   if (!entry)\n     {\n-      entry = (struct in_named_entry *) xmalloc (sizeof (*entry));\n+      entry = (struct in_named_entry *) ggc_alloc (sizeof (*entry));\n       *slot = entry;\n       entry->name = ggc_strdup (section);\n       entry->flags = flags;\n@@ -2119,7 +2120,7 @@ struct rtx_const GTY(())\n   ENUM_BITFIELD(kind) kind : 16;\n   ENUM_BITFIELD(machine_mode) mode : 16;\n   union rtx_const_un {\n-    REAL_VALUE_TYPE du;\n+    REAL_VALUE_TYPE GTY ((tag (\"4\"))) du;\n     struct addr_const GTY ((tag (\"1\"))) addr;\n     struct rtx_const_u_di {\n       HOST_WIDE_INT high;\n@@ -4703,8 +4704,8 @@ init_varasm_once ()\n {\n   const_str_htab = htab_create_ggc (128, const_str_htab_hash,\n \t\t\t\t    const_str_htab_eq, NULL);\n-  in_named_htab = htab_create (31, in_named_entry_hash,\n-\t\t\t       in_named_entry_eq, NULL);\n+  in_named_htab = htab_create_ggc (31, in_named_entry_hash,\n+\t\t\t\t   in_named_entry_eq, NULL);\n \n   const_alias_set = new_alias_set ();\n }"}, {"sha": "9318821f203e14e06a0e38e9d09bd53e86dc2950", "filename": "include/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -1,3 +1,11 @@\n+2002-07-17  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* splay-tree.h (GTY): Define if undefined.\n+\t(splay_tree_allocate_fn): Return PTR for compatibility, not void *.\n+\t(struct splay_tree_node_s): Support gengtype.\n+\t(struct splay_tree_s): Likewise.  Make allocate_data a PTR,\n+\tnot a void *.\n+\n 2002-11-23  Simon Burge  <simonb@wasabisystems.com>\n \n \t* libiberty.h (basename): Add NetBSD to the list."}, {"sha": "86707fc1d2fff4a3927e39142dc0b7690c396b51", "filename": "include/splay-tree.h", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17211ab55314d76370a68036f2d057b1effd687f/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17211ab55314d76370a68036f2d057b1effd687f/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=17211ab55314d76370a68036f2d057b1effd687f", "patch": "@@ -36,6 +36,10 @@ extern \"C\" {\n \n #include \"ansidecl.h\"\n \n+#ifndef GTY\n+#define GTY(X)\n+#endif\n+\n /* Use typedefs for the key and data types to facilitate changing\n    these types, if necessary.  These types should be sufficiently wide\n    that any pointer or scalar can be cast to these types, and then\n@@ -65,7 +69,7 @@ typedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n    node structures.  The first argument is the number of bytes needed;\n    the second is a data pointer the splay tree functions pass through\n    to the allocator.  This function must never return zero.  */\n-typedef void *(*splay_tree_allocate_fn) PARAMS((int, void *));\n+typedef PTR (*splay_tree_allocate_fn) PARAMS((int, void *));\n \n /* The type of a function used to free memory allocated using the\n    corresponding splay_tree_allocate_fn.  The first argument is the\n@@ -74,24 +78,24 @@ typedef void *(*splay_tree_allocate_fn) PARAMS((int, void *));\n typedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n \n /* The nodes in the splay tree.  */\n-struct splay_tree_node_s\n+struct splay_tree_node_s GTY(())\n {\n   /* The key.  */\n-  splay_tree_key key;\n+  splay_tree_key GTY ((use_param1 (\"\"))) key;\n \n   /* The value.  */\n-  splay_tree_value value;\n+  splay_tree_value GTY ((use_param2 (\"\"))) value;\n \n   /* The left and right children, respectively.  */\n-  splay_tree_node left;\n-  splay_tree_node right;\n+  splay_tree_node GTY ((use_params (\"\"))) left;\n+  splay_tree_node GTY ((use_params (\"\"))) right;\n };\n \n /* The splay tree itself.  */\n-typedef struct splay_tree_s\n+struct splay_tree_s GTY(())\n {\n   /* The root of the tree.  */\n-  splay_tree_node root;\n+  splay_tree_node GTY ((use_params (\"\"))) root;\n \n   /* The comparision function.  */\n   splay_tree_compare_fn comp;\n@@ -105,9 +109,10 @@ typedef struct splay_tree_s\n   /* Allocate/free functions, and a data pointer to pass to them.  */\n   splay_tree_allocate_fn allocate;\n   splay_tree_deallocate_fn deallocate;\n-  void *allocate_data;\n+  PTR GTY((skip (\"\"))) allocate_data;\n \n-} *splay_tree;\n+};\n+typedef struct splay_tree_s *splay_tree;\n \n extern splay_tree splay_tree_new        PARAMS((splay_tree_compare_fn,\n \t\t\t\t\t        splay_tree_delete_key_fn,"}]}