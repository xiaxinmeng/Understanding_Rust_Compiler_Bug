{"sha": "ea6da7f50fe2adc3a09fc10a3f437902c40ebff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE2ZGE3ZjUwZmUyYWRjM2EwOWZjMTBhM2Y0Mzc5MDJjNDBlYmZmOQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-05T15:36:13Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-05T17:51:36Z"}, "message": "Cleanup legacy_union and legacy intersect in value_range.\n\nThese are cleanups so that multi-range union/intersect doesn't\nhave to deal with legacy code.  Instead, these should be done in\nlegacy mode.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (irange::legacy_intersect): Only handle\n\tlegacy ranges.\n\t(irange::legacy_union): Same.\n\t(irange::union_): When unioning legacy with non-legacy,\n\tfirst convert to legacy and do everything in legacy mode.\n\t(irange::intersect): Same, but for intersect.\n\t* range-op.cc (range_tests): Adjust for above changes.", "tree": {"sha": "9cdf2c422cb3bf145fd43b138b734bcd4b2a2dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cdf2c422cb3bf145fd43b138b734bcd4b2a2dd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd431d26de02180d7fac1a794e2b9d3aaa4df34d"}], "stats": {"total": 88, "additions": 48, "deletions": 40}, "files": [{"sha": "87c6d82f2ac1bbdeb9f79f9780cad67871721d72", "filename": "gcc/range-op.cc", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=ea6da7f50fe2adc3a09fc10a3f437902c40ebff9", "patch": "@@ -3901,6 +3901,27 @@ range_tests ()\n   r0.invert ();\n   ASSERT_TRUE (r0.nonzero_p ());\n \n+  // test legacy interaction\n+  // r0 = ~[1,1]\n+  r0 = int_range<1> (UINT (1), UINT (1), VR_ANTI_RANGE);\n+  // r1 = ~[3,3]\n+  r1 = int_range<1> (UINT (3), UINT (3), VR_ANTI_RANGE);\n+\n+  // vv = [0,0][2,2][4, MAX]\n+  int_range<3> vv = r0;\n+  vv.intersect (r1);\n+\n+  ASSERT_TRUE (vv.contains_p (UINT (2)));\n+  ASSERT_TRUE (vv.num_pairs () == 3);\n+\n+  // create r0 as legacy [1,1]\n+  r0 = int_range<1> (UINT (1), UINT (1));\n+  // And union it with  [0,0][2,2][4,MAX] multi range\n+  r0.union_ (vv);\n+  // The result should be [0,2][4,MAX], or ~[3,3]  but it must contain 2\n+  ASSERT_TRUE (r0.contains_p (UINT (2)));\n+\n+\n   multi_precision_range_tests ();\n   int_range_max_tests ();\n   operator_tests ();"}, {"sha": "cdcc6c65594d8ee39c9f982e606ead17ee7d5a29", "filename": "gcc/value-range.cc", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea6da7f50fe2adc3a09fc10a3f437902c40ebff9/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=ea6da7f50fe2adc3a09fc10a3f437902c40ebff9", "patch": "@@ -1093,19 +1093,14 @@ intersect_ranges (enum value_range_kind *vr0type,\n void\n irange::legacy_intersect (irange *vr0, const irange *vr1)\n {\n+  gcc_checking_assert (vr0->legacy_mode_p ());\n+  gcc_checking_assert (vr1->legacy_mode_p ());\n   /* If either range is VR_VARYING the other one wins.  */\n   if (vr1->varying_p ())\n     return;\n   if (vr0->varying_p ())\n     {\n-      /* Avoid the full copy if we already know both sides are simple\n-\t and can be trivially copied.  */\n-      if (vr1->legacy_mode_p ())\n-\t{\n-\t  vr0->set (vr1->min (), vr1->max (), vr1->kind ());\n-\t  return;\n-\t}\n-      *vr0 = *vr1;\n+      vr0->set (vr1->min (), vr1->max (), vr1->kind ());\n       return;\n     }\n \n@@ -1122,17 +1117,9 @@ irange::legacy_intersect (irange *vr0, const irange *vr1)\n   value_range_kind vr0kind = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n-  /* Handle multi-ranges that can be represented as anti-ranges.  */\n-  if (!vr1->legacy_mode_p () && vr1->maybe_anti_range ())\n-    {\n-      int_range<3> tmp (*vr1);\n-      tmp.invert ();\n-      intersect_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\t\tVR_ANTI_RANGE, tmp.min (), tmp.max ());\n-    }\n-  else\n-    intersect_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\t      vr1->kind (), vr1->min (), vr1->max ());\n+\n+  intersect_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\t    vr1->kind (), vr1->min (), vr1->max ());\n \n   /* Make sure to canonicalize the result though as the inversion of a\n      VR_RANGE can still be a VR_RANGE.  */\n@@ -1427,6 +1414,9 @@ union_ranges (enum value_range_kind *vr0type,\n void\n irange::legacy_union (irange *vr0, const irange *vr1)\n {\n+  gcc_checking_assert (vr0->legacy_mode_p ());\n+  gcc_checking_assert (vr1->legacy_mode_p ());\n+\n   /* VR0 has the resulting range if VR1 is undefined or VR0 is varying.  */\n   if (vr1->undefined_p ()\n       || vr0->varying_p ())\n@@ -1435,16 +1425,10 @@ irange::legacy_union (irange *vr0, const irange *vr1)\n   /* VR1 has the resulting range if VR0 is undefined or VR1 is varying.  */\n   if (vr0->undefined_p ())\n     {\n-      /* Avoid the full copy if we already know both sides are simple\n-\t and can be trivially copied.  */\n-      if (vr1->legacy_mode_p ())\n-\t{\n-\t  vr0->set (vr1->min (), vr1->max (), vr1->kind ());\n-\t  return;\n-\t}\n-      *vr0 = *vr1;\n+      vr0->set (vr1->min (), vr1->max (), vr1->kind ());\n       return;\n     }\n+\n   if (vr1->varying_p ())\n     {\n       vr0->set_varying (vr1->type ());\n@@ -1454,17 +1438,9 @@ irange::legacy_union (irange *vr0, const irange *vr1)\n   value_range_kind vr0kind = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n-  /* Handle multi-ranges that can be represented as anti-ranges.  */\n-  if (!vr1->legacy_mode_p () && vr1->maybe_anti_range ())\n-    {\n-      int_range<3> tmp (*vr1);\n-      tmp.invert ();\n-      union_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\t    VR_ANTI_RANGE, tmp.min (), tmp.max ());\n-    }\n-  else\n-    union_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\t  vr1->kind (), vr1->min (), vr1->max ());\n+\n+  union_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\tvr1->kind (), vr1->min (), vr1->max ());\n \n   if (vr0kind == VR_UNDEFINED)\n     vr0->set_undefined ();\n@@ -1492,6 +1468,12 @@ irange::union_ (const irange *other)\n {\n   if (legacy_mode_p ())\n     {\n+      if (!other->legacy_mode_p ())\n+\t{\n+\t  int_range<1> tmp = *other;\n+\t  legacy_union (this, &tmp);\n+\t  return;\n+\t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Meeting\\n  \");\n@@ -1514,8 +1496,7 @@ irange::union_ (const irange *other)\n \n   if (other->legacy_mode_p ())\n     {\n-      int_range<2> wider;\n-      wider = *other;\n+      int_range<2> wider = *other;\n       irange_union (wider);\n     }\n   else\n@@ -1527,6 +1508,12 @@ irange::intersect (const irange *other)\n {\n   if (legacy_mode_p ())\n     {\n+      if (!other->legacy_mode_p ())\n+\t{\n+\t  int_range<1> tmp = *other;\n+\t  legacy_intersect (this, &tmp);\n+\t  return;\n+\t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Intersecting\\n  \");"}]}