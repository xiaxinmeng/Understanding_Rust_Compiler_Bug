{"sha": "ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4", "node_id": "C_kwDOANBUbNoAKGZmMmI5MmRlMTNmOWIwYTU0MWVkNDRiOGQzNmYyZjc5ZmI5MzA2ZjQ", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-14T12:02:49Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-14T12:03:06Z"}, "message": "ipa-cp: Propagation boost for recursion generated values\n\nRecursive call graph edges, even when they are hot and important for\nthe compiled program, can never have frequency bigger than one, even\nwhen the actual time savings in the next recursion call are not\nrealized just once but depend on the depth of recursion.  The current\nIPA-CP effect propagation code did not take that into account and just\nused the frequency, thus severely underestimating the effect.\n\nThis patch artificially boosts values taking part in such calls.  If a\nvalue feeds into itself through a recursive call, the frequency of the\nedge is multiplied by a parameter with default value of 6, basically\nassuming that the recursion will take place 6 times.  This value can\nof course be subject to change.\n\nMoreover, values which do not feed into themselves but which were\ngenerated for a self-recursive call with an arithmetic\npass-function (aka the 548.exchange \"hack\" which however is generally\napplicable for recursive functions which count the recursion depth in\na parameter) have the edge frequency multiplied as many times as there\nare generated values in the chain.  In essence, we will assume they\nare all useful.\n\nThis patch partially fixes the current situation when we fail to\noptimize 548.exchange with PGO.  In the benchmark one recursive edge\ncount overwhelmingly dominates all other counts in the program and so\nwe fail to perform the first cloning (for the nonrecursive entry call)\nbecause it looks totally insignificant.\n\ngcc/ChangeLog:\n\n2021-07-16  Martin Jambor  <mjambor@suse.cz>\n\n\t* params.opt (ipa-cp-recursive-freq-factor): New.\n\t* ipa-cp.c (ipcp_value): Switch to inline initialization.  New members\n\tscc_no, self_recursion_generated_level, same_scc and\n\tself_recursion_generated_p.\n\t(ipcp_lattice::add_value): Replaced parameter unlimited with\n\tsame_lat_gen_level, usit it determine limit of values and store it to\n\tthe value.\n\t(ipcp_lattice<valtype>::print): Dump the new fileds.\n\t(allocate_and_init_ipcp_value): Take same_lat_gen_level as a new\n\tparameter and store it to the new value.\n\t(self_recursively_generated_p): Removed.\n\t(propagate_vals_across_arith_jfunc): Use self_recursion_generated_p\n\tinstead of self_recursively_generated_p, store self generation level\n\tto such values.\n\t(value_topo_info<valtype>::add_val): Set scc_no.\n\t(value_topo_info<valtype>::propagate_effects): Multiply frequencies of\n\trecursively feeding values and self generated values by appropriate\n\tnew factors.", "tree": {"sha": "c932ee7fe52280d9ce8fad4d0b20a4309d1b97dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c932ee7fe52280d9ce8fad4d0b20a4309d1b97dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmFoHHoACgkQv2PBvD+k\nNUApHw/+I/E43VeAJ+t3NQR9fzZsg2s9NylG3iUT7mbF/4O6fHlKFxrNfplyB+Z7\nUxOVQre9j1KNV3Ic1XajabwSoiEGhC3q4sMhwiUC4Sjg0HkGIDTJHuuDRvvVcnHl\nSu5gYkH4EI1zFzQMLQ44GIEzc8xHCOzgFifMPmH0LnahDOEAR8x6yfXj0eJ3mehi\nA8aDMGKVjzBEqCLGf2yO0SuKjksMCJed30T69uFz4ikJMAa8pl1JtyDeJWrMJPZd\nITYbQInPwClQ1U9bOgWKiaDspBOsLq9tnssF8qSD4DUhRC8hyFGmY9WOuBb9DRFS\n81rEAisn5EGf1D5xcMquILSYevqDyjRrYSdSWa49kP3XA6rDAPMYCK+y3oe3jZU3\nh3jqQOnL13+/R1ySdOguZuGrq6agm5irt7j9gXV9pDE+3qrg+5tPS7aSYAQmC8Lr\n3BzfswFFmyIC2CE1LjLTbcuiKuFR5mkQvquDu+y1zQsQTdbalmNVjFRAAp/DawAO\nxGIVJF2114S4v9UpiBsjxxdTg+ju+2Sxfza5tNMqzF7c6KKjXrAgaJ99n6/i11q3\nzdLpUetxkAcDCX9ibOiZ7JLMdSMbRSPWF/yfil6zEKzxGwlJy6Qo+x1sF04aDlRl\neh6aJcWhQ1HOo2yZB21ta01G4f2b+ga98V4xuxV2HQFYH/ZE4bE=\n=eL6Q\n-----END PGP SIGNATURE-----", "payload": "tree c932ee7fe52280d9ce8fad4d0b20a4309d1b97dd\nparent f837785cc430f1924ec2842bf559fe602d76e5e3\nauthor Martin Jambor <mjambor@suse.cz> 1634212969 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1634212986 +0200\n\nipa-cp: Propagation boost for recursion generated values\n\nRecursive call graph edges, even when they are hot and important for\nthe compiled program, can never have frequency bigger than one, even\nwhen the actual time savings in the next recursion call are not\nrealized just once but depend on the depth of recursion.  The current\nIPA-CP effect propagation code did not take that into account and just\nused the frequency, thus severely underestimating the effect.\n\nThis patch artificially boosts values taking part in such calls.  If a\nvalue feeds into itself through a recursive call, the frequency of the\nedge is multiplied by a parameter with default value of 6, basically\nassuming that the recursion will take place 6 times.  This value can\nof course be subject to change.\n\nMoreover, values which do not feed into themselves but which were\ngenerated for a self-recursive call with an arithmetic\npass-function (aka the 548.exchange \"hack\" which however is generally\napplicable for recursive functions which count the recursion depth in\na parameter) have the edge frequency multiplied as many times as there\nare generated values in the chain.  In essence, we will assume they\nare all useful.\n\nThis patch partially fixes the current situation when we fail to\noptimize 548.exchange with PGO.  In the benchmark one recursive edge\ncount overwhelmingly dominates all other counts in the program and so\nwe fail to perform the first cloning (for the nonrecursive entry call)\nbecause it looks totally insignificant.\n\ngcc/ChangeLog:\n\n2021-07-16  Martin Jambor  <mjambor@suse.cz>\n\n\t* params.opt (ipa-cp-recursive-freq-factor): New.\n\t* ipa-cp.c (ipcp_value): Switch to inline initialization.  New members\n\tscc_no, self_recursion_generated_level, same_scc and\n\tself_recursion_generated_p.\n\t(ipcp_lattice::add_value): Replaced parameter unlimited with\n\tsame_lat_gen_level, usit it determine limit of values and store it to\n\tthe value.\n\t(ipcp_lattice<valtype>::print): Dump the new fileds.\n\t(allocate_and_init_ipcp_value): Take same_lat_gen_level as a new\n\tparameter and store it to the new value.\n\t(self_recursively_generated_p): Removed.\n\t(propagate_vals_across_arith_jfunc): Use self_recursion_generated_p\n\tinstead of self_recursively_generated_p, store self generation level\n\tto such values.\n\t(value_topo_info<valtype>::add_val): Set scc_no.\n\t(value_topo_info<valtype>::propagate_effects): Multiply frequencies of\n\trecursively feeding values and self generated values by appropriate\n\tnew factors.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f837785cc430f1924ec2842bf559fe602d76e5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f837785cc430f1924ec2842bf559fe602d76e5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f837785cc430f1924ec2842bf559fe602d76e5e3"}], "stats": {"total": 165, "additions": 84, "deletions": 81}, "files": [{"sha": "b987d975793392903e6e06649305092acdddde14", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4", "patch": "@@ -184,30 +184,52 @@ class ipcp_value : public ipcp_value_base\n   /* The actual value for the given parameter.  */\n   valtype value;\n   /* The list of sources from which this value originates.  */\n-  ipcp_value_source <valtype> *sources;\n+  ipcp_value_source <valtype> *sources = nullptr;\n   /* Next pointers in a linked list of all values in a lattice.  */\n-  ipcp_value *next;\n+  ipcp_value *next = nullptr;\n   /* Next pointers in a linked list of values in a strongly connected component\n      of values. */\n-  ipcp_value *scc_next;\n+  ipcp_value *scc_next = nullptr;\n   /* Next pointers in a linked list of SCCs of values sorted topologically\n      according their sources.  */\n-  ipcp_value  *topo_next;\n+  ipcp_value  *topo_next = nullptr;\n   /* A specialized node created for this value, NULL if none has been (so far)\n      created.  */\n-  cgraph_node *spec_node;\n+  cgraph_node *spec_node = nullptr;\n   /* Depth first search number and low link for topological sorting of\n      values.  */\n-  int dfs, low_link;\n+  int dfs = 0;\n+  int low_link = 0;\n+  /* SCC number to identify values which recursively feed into each other.\n+     Values in the same SCC have the same SCC number.  */\n+  int scc_no = 0;\n+  /* Non zero if the value is generated from another value in the same lattice\n+     for a self-recursive call, the actual number is how many times the\n+     operation has been performed.  In the unlikely event of the value being\n+     present in two chains fo self-recursive value generation chains, it is the\n+     maximum.  */\n+  unsigned self_recursion_generated_level = 0;\n   /* True if this value is currently on the topo-sort stack.  */\n-  bool on_stack;\n-\n-  ipcp_value()\n-    : sources (0), next (0), scc_next (0), topo_next (0),\n-      spec_node (0), dfs (0), low_link (0), on_stack (false) {}\n+  bool on_stack = false;\n \n   void add_source (cgraph_edge *cs, ipcp_value *src_val, int src_idx,\n \t\t   HOST_WIDE_INT offset);\n+\n+  /* Return true if both THIS value and O feed into each other.  */\n+\n+  bool same_scc (const ipcp_value<valtype> *o)\n+  {\n+    return o->scc_no == scc_no;\n+  }\n+\n+/* Return true, if a this value has been generated for a self-recursive call as\n+   a result of an arithmetic pass-through jump-function acting on a value in\n+   the same lattice function.  */\n+\n+  bool self_recursion_generated_p ()\n+  {\n+    return self_recursion_generated_level > 0;\n+  }\n };\n \n /* Lattice describing potential values of a formal parameter of a function, or\n@@ -239,7 +261,7 @@ struct ipcp_lattice\n \t\t  ipcp_value<valtype> *src_val = NULL,\n \t\t  int src_idx = 0, HOST_WIDE_INT offset = -1,\n \t\t  ipcp_value<valtype> **val_p = NULL,\n-\t\t  bool unlimited = false);\n+\t\t  unsigned same_lat_gen_level = 0);\n   void print (FILE * f, bool dump_sources, bool dump_benefits);\n };\n \n@@ -498,7 +520,11 @@ ipcp_lattice<valtype>::print (FILE * f, bool dump_sources, bool dump_benefits)\n \t{\n \t  ipcp_value_source<valtype> *s;\n \n-\t  fprintf (f, \" [from:\");\n+\t  if (val->self_recursion_generated_p ())\n+\t    fprintf (f, \" [self_gen(%i), from:\",\n+\t\t     val->self_recursion_generated_level);\n+\t  else\n+\t    fprintf (f, \" [scc: %i, from:\", val->scc_no);\n \t  for (s = val->sources; s; s = s->next)\n \t    fprintf (f, \" %i(%f)\", s->cs->caller->order,\n \t\t     s->cs->sreal_frequency ().to_double ());\n@@ -1837,44 +1863,50 @@ ipcp_value<valtype>::add_source (cgraph_edge *cs, ipcp_value *src_val,\n    SOURCE and clear all other fields.  */\n \n static ipcp_value<tree> *\n-allocate_and_init_ipcp_value (tree source)\n+allocate_and_init_ipcp_value (tree cst, unsigned same_lat_gen_level)\n {\n   ipcp_value<tree> *val;\n \n   val = new (ipcp_cst_values_pool.allocate ()) ipcp_value<tree>();\n-  val->value = source;\n+  val->value = cst;\n+  val->self_recursion_generated_level = same_lat_gen_level;\n   return val;\n }\n \n /* Allocate a new ipcp_value holding a polymorphic context, initialize its\n    value to SOURCE and clear all other fields.  */\n \n static ipcp_value<ipa_polymorphic_call_context> *\n-allocate_and_init_ipcp_value (ipa_polymorphic_call_context source)\n+allocate_and_init_ipcp_value (ipa_polymorphic_call_context ctx,\n+\t\t\t      unsigned same_lat_gen_level)\n {\n   ipcp_value<ipa_polymorphic_call_context> *val;\n \n-  // TODO\n   val = new (ipcp_poly_ctx_values_pool.allocate ())\n     ipcp_value<ipa_polymorphic_call_context>();\n-  val->value = source;\n+  val->value = ctx;\n+  val->self_recursion_generated_level = same_lat_gen_level;\n   return val;\n }\n \n /* Try to add NEWVAL to LAT, potentially creating a new ipcp_value for it.  CS,\n    SRC_VAL SRC_INDEX and OFFSET are meant for add_source and have the same\n    meaning.  OFFSET -1 means the source is scalar and not a part of an\n    aggregate.  If non-NULL, VAL_P records address of existing or newly added\n-   ipcp_value.  UNLIMITED means whether value count should not exceed the limit\n-   given by PARAM_IPA_CP_VALUE_LIST_SIZE.  */\n+   ipcp_value.\n+\n+   If the value is generated for a self-recursive call as a result of an\n+   arithmetic pass-through jump-function acting on a value in the same lattice,\n+   SAME_LAT_GEN_LEVEL must be the length of such chain, otherwise it must be\n+   zero.  If it is non-zero, PARAM_IPA_CP_VALUE_LIST_SIZE limit is ignored.  */\n \n template <typename valtype>\n bool\n ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \t\t\t\t  ipcp_value<valtype> *src_val,\n \t\t\t\t  int src_idx, HOST_WIDE_INT offset,\n \t\t\t\t  ipcp_value<valtype> **val_p,\n-\t\t\t\t  bool unlimited)\n+\t\t\t\t  unsigned same_lat_gen_level)\n {\n   ipcp_value<valtype> *val, *last_val = NULL;\n \n@@ -1890,6 +1922,9 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \tif (val_p)\n \t  *val_p = val;\n \n+\tif (val->self_recursion_generated_level < same_lat_gen_level)\n+\t  val->self_recursion_generated_level = same_lat_gen_level;\n+\n \tif (ipa_edge_within_scc (cs))\n \t  {\n \t    ipcp_value_source<valtype> *s;\n@@ -1904,7 +1939,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \treturn false;\n       }\n \n-  if (!unlimited && values_count == opt_for_fn (cs->caller->decl,\n+  if (!same_lat_gen_level && values_count == opt_for_fn (cs->caller->decl,\n \t\t\t\t\t\tparam_ipa_cp_value_list_size))\n     {\n       /* We can only free sources, not the values themselves, because sources\n@@ -1923,7 +1958,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n     }\n \n   values_count++;\n-  val = allocate_and_init_ipcp_value (newval);\n+  val = allocate_and_init_ipcp_value (newval, same_lat_gen_level);\n   val->add_source (cs, src_val, src_idx, offset);\n   val->next = NULL;\n \n@@ -1940,60 +1975,6 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n   return true;\n }\n \n-/* Return true, if a ipcp_value VAL is orginated from parameter value of\n-   self-feeding recursive function via some kind of pass-through jump\n-   function.  */\n-\n-static bool\n-self_recursively_generated_p (ipcp_value<tree> *val)\n-{\n-  class ipa_node_params *info = NULL;\n-\n-  for (ipcp_value_source<tree> *src = val->sources; src; src = src->next)\n-    {\n-      cgraph_edge *cs = src->cs;\n-\n-      if (!src->val || cs->caller != cs->callee->function_symbol ())\n-\treturn false;\n-\n-      if (src->val == val)\n-\tcontinue;\n-\n-      if (!info)\n-\tinfo = ipa_node_params_sum->get (cs->caller);\n-\n-      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info,\n-\t\t\t\t\t\t\t\tsrc->index);\n-      ipcp_lattice<tree> *src_lat;\n-      ipcp_value<tree> *src_val;\n-\n-      if (src->offset == -1)\n-\tsrc_lat = &plats->itself;\n-      else\n-\t{\n-\t  struct ipcp_agg_lattice *src_aglat;\n-\n-\t  for (src_aglat = plats->aggs; src_aglat; src_aglat = src_aglat->next)\n-\t    if (src_aglat->offset == src->offset)\n-\t      break;\n-\n-\t  if (!src_aglat)\n-\t    return false;\n-\n-\t  src_lat = src_aglat;\n-\t}\n-\n-      for (src_val = src_lat->values; src_val; src_val = src_val->next)\n-\tif (src_val == val)\n-\t  break;\n-\n-      if (!src_val)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n /* A helper function that returns result of operation specified by OPCODE on\n    the value of SRC_VAL.  If non-NULL, OPND1_TYPE is expected type for the\n    value of SRC_VAL.  If the operation is binary, OPND2 is a constant value\n@@ -2068,7 +2049,7 @@ propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n \t     source, this is absolutely conservative, but could avoid explosion\n \t     of lattice's value space, especially when one recursive function\n \t     calls another recursive.  */\n-\t  if (self_recursively_generated_p (src_val))\n+\t  if (src_val->self_recursion_generated_p ())\n \t    {\n \t      ipcp_value_source<tree> *s;\n \n@@ -2096,7 +2077,7 @@ propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n \t\tbreak;\n \n \t      ret |= dest_lat->add_value (cstval, cs, src_val, src_idx,\n-\t\t\t\t\t  src_offset, &src_val, true);\n+\t\t\t\t\t  src_offset, &src_val, j);\n \t      gcc_checking_assert (src_val);\n \t    }\n \t}\n@@ -2108,7 +2089,7 @@ propagate_vals_across_arith_jfunc (cgraph_edge *cs,\n \t/* Now we do not use self-recursively generated value as propagation\n \t   source, otherwise it is easy to make value space of normal lattice\n \t   overflow.  */\n-\tif (self_recursively_generated_p (src_val))\n+\tif (src_val->self_recursion_generated_p ())\n \t  {\n \t    ret |= dest_lat->set_contains_variable ();\n \t    continue;\n@@ -3732,6 +3713,7 @@ value_topo_info<valtype>::add_val (ipcp_value<valtype> *cur_val)\n \t  v = stack;\n \t  stack = v->topo_next;\n \t  v->on_stack = false;\n+\t  v->scc_no = cur_val->dfs;\n \n \t  v->scc_next = scc_list;\n \t  scc_list = v;\n@@ -3905,8 +3887,25 @@ value_topo_info<valtype>::propagate_effects ()\n \t\t    else\n \t\t      continue;\n \t\t  }\n+\n+\t\tint special_factor = 1;\n+\t\tif (val->same_scc (src->val))\n+\t\t  special_factor\n+\t\t    = opt_for_fn(src->cs->caller->decl,\n+\t\t\t\t param_ipa_cp_recursive_freq_factor);\n+\t\telse if (val->self_recursion_generated_p ()\n+\t\t\t && (src->cs->callee->function_symbol ()\n+\t\t\t     == src->cs->caller))\n+\t\t  {\n+\t\t    int max_recur_gen_depth\n+\t\t      = opt_for_fn(src->cs->caller->decl,\n+\t\t\t\t   param_ipa_cp_max_recursive_depth);\n+\t\t    special_factor = max_recur_gen_depth\n+\t\t      - val->self_recursion_generated_level + 1;\n+\t\t  }\n+\n \t\tsrc->val->prop_time_benefit\n-\t\t  += time * src->cs->sreal_frequency ();\n+\t\t  += time * special_factor * src->cs->sreal_frequency ();\n \t      }\n \n \t  if (size < INT_MAX)"}, {"sha": "84d642d72c5bd53d95831ad4cefa0d7e44c0be44", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=ff2b92de13f9b0a541ed44b8d36f2f79fb9306f4", "patch": "@@ -273,6 +273,10 @@ Maximum depth of recursive cloning for self-recursive function.\n Common Joined UInteger Var(param_ipa_cp_min_recursive_probability) Init(2) Param Optimization\n Recursive cloning only when the probability of call being executed exceeds the parameter.\n \n+-param=ipa-cp-recursive-freq-factor=\n+Common Joined UInteger Var(param_ipa_cp_recursive_freq_factor) Init(6) Param Optimization\n+When propagating IPA-CP effect estimates, multiply frequencies of recursive edges that that bring back an unchanged value by this factor.\n+\n -param=ipa-cp-recursion-penalty=\n Common Joined UInteger Var(param_ipa_cp_recursion_penalty) Init(40) IntegerRange(0, 100) Param Optimization\n Percentage penalty the recursive functions will receive when they are evaluated for cloning."}]}