{"sha": "2c089640279614e34b8712bfb318a9d4fc8ac8fe", "node_id": "C_kwDOANBUbNoAKDJjMDg5NjQwMjc5NjE0ZTM0Yjg3MTJiZmIzMThhOWQ0ZmM4YWM4ZmU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-01T08:29:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-01T08:29:23Z"}, "message": "i386: Improve *concat<mode><dwi>3_{1,2,3,4} patterns [PR107627]\n\nOn the first testcase we've regressed since 12 at -O2:\n-       movq    8(%rsi), %rax\n-       movq    %rdi, %r8\n-       movq    (%rsi), %rdi\n+       movq    (%rsi), %rax\n+       movq    8(%rsi), %r8\n        movl    %edx, %ecx\n-       shrdq   %rdi, %rax\n-       movq    %rax, (%r8)\n+       xorl    %r9d, %r9d\n+       movq    %rax, %rdx\n+       xorl    %eax, %eax\n+       orq     %r8, %rax\n+       orq     %r9, %rdx\n+       shrdq   %rdx, %rax\n+       movq    %rax, (%rdi)\nOn the second testcase we've emitted such terrible code\nwith the useless xors and ors for a long time.\nFor PR91681 the *concat<mode><dwi>3_{1,2,3,4} patterns have been added\nbut they allow just register inputs and register or memory offsettable\noutput.\nThe following patch fixes this by allowing also memory inputs on those\npatterns, because the pattern is then split to 0-2 emit_move_insns or\none xchg and those can handle loads from memory too just fine.\nSo that we don't narrow memory loads (source has 128-bit (or for ia32\n64-bit) load and we would make 64-bit (or for ia32 32-bit) load out of it),\nregister_operand -> nonmemory_operand change is done only for operands\nin zero_extend arguments.  o <- m, m or o <- m, r or o <- r, m alternatives\naren't used, we'd lack registers to perform the moves.  But what is\nin addition to the current ro <- r, r supported are r <- m, r and r <- r, m\n(in that case we just need to be careful about corner cases, see what\nemit_move_insn we'd call and if we wouldn't clobber registers used in m's\naddress before loading - split_double_concat handles that now) and\n&r <- m, m (in that case I think the early clobber is the easiest solution).\n\nThe first testcase then on 12 -> patched trunk at -O2 changes:\n-       movq    8(%rsi), %rax\n-       movq    %rdi, %r8\n-       movq    (%rsi), %rdi\n+       movq    8(%rsi), %r9\n+       movq    (%rsi), %r10\n        movl    %edx, %ecx\n-       shrdq   %rdi, %rax\n-       movq    %rax, (%r8)\n+       movq    %r9, %rax\n+       shrdq   %r10, %rax\n+       movq    %rax, (%rdi)\nso same amount of instructions and second testcase 12 -> patched trunk\nat -O2 -m32:\n-       pushl   %edi\n-       xorl    %edi, %edi\n        pushl   %esi\n-       movl    16(%esp), %esi\n+       pushl   %ebx\n+       movl    16(%esp), %eax\n        movl    20(%esp), %ecx\n-       movl    (%esi), %eax\n-       movl    4(%esi), %esi\n-       movl    %eax, %edx\n-       movl    $0, %eax\n-       orl     %edi, %edx\n-       orl     %esi, %eax\n-       shrdl   %edx, %eax\n        movl    12(%esp), %edx\n+       movl    4(%eax), %ebx\n+       movl    (%eax), %esi\n+       movl    %ebx, %eax\n+       shrdl   %esi, %eax\n        movl    %eax, (%edx)\n+       popl    %ebx\n        popl    %esi\n-       popl    %edi\n\nBTW, I wonder if we couldn't add additional patterns which would catch\nthe case where one of the operands is constant and how does this interact\nwith the stv pass in 32-bit mode where I think stv is right after combine,\nso if we match these patterns, perhaps it would be nice to handle them\nin stv (unless they are handled there already).\n\n2022-12-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/107627\n\t* config/i386/i386.md (*concat<mode><dwi>3_1, *concat<mode><dwi>3_2):\n\tFor operands which are zero_extend arguments allow memory if\n\toutput operand is a register.\n\t(*concat<mode><dwi>3_3, *concat<mode><dwi>3_4): Likewise.  If\n\tboth input operands are memory, use early clobber on output operand.\n\t* config/i386/i386-expand.cc (split_double_concat): Deal with corner\n\tcases where one input is memory and the other is not and the address\n\tof the memory input uses a register we'd overwrite before loading\n\tthe memory into a register.\n\n\t* gcc.target/i386/pr107627-1.c: New test.\n\t* gcc.target/i386/pr107627-2.c: New test.", "tree": {"sha": "5d026d4cf3491635a3b4b0bcbe0ab08d8e87cd40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d026d4cf3491635a3b4b0bcbe0ab08d8e87cd40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c089640279614e34b8712bfb318a9d4fc8ac8fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c089640279614e34b8712bfb318a9d4fc8ac8fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c089640279614e34b8712bfb318a9d4fc8ac8fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c089640279614e34b8712bfb318a9d4fc8ac8fe/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "125f294e851b2282ee3bc88a6e5957cc90f013bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125f294e851b2282ee3bc88a6e5957cc90f013bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/125f294e851b2282ee3bc88a6e5957cc90f013bd"}], "stats": {"total": 101, "additions": 89, "deletions": 12}, "files": [{"sha": "f20bf81f39367517b25fe7ecabf835d4ca82794a", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=2c089640279614e34b8712bfb318a9d4fc8ac8fe", "patch": "@@ -173,6 +173,33 @@ split_double_concat (machine_mode mode, rtx dst, rtx lo, rtx hi)\n   rtx dlo, dhi;\n   int deleted_move_count = 0;\n   split_double_mode (mode, &dst, 1, &dlo, &dhi);\n+  /* Constraints ensure that if both lo and hi are MEMs, then\n+     dst has early-clobber and thus addresses of MEMs don't use\n+     dlo/dhi registers.  Otherwise if at least one of li and hi are MEMs,\n+     dlo/dhi are registers.  */\n+  if (MEM_P (lo)\n+      && rtx_equal_p (dlo, hi)\n+      && reg_overlap_mentioned_p (dhi, lo))\n+    {\n+      /* If dlo is same as hi and lo's address uses dhi register,\n+\t code below would first emit_move_insn (dhi, hi)\n+\t and then emit_move_insn (dlo, lo).  But the former\n+\t would invalidate lo's address.  Load into dhi first,\n+\t then swap.  */\n+      emit_move_insn (dhi, lo);\n+      lo = dhi;\n+    }\n+  else if (MEM_P (hi)\n+\t   && !MEM_P (lo)\n+\t   && !rtx_equal_p (dlo, lo)\n+\t   && reg_overlap_mentioned_p (dlo, hi))\n+    {\n+      /* In this case, code below would first emit_move_insn (dlo, lo)\n+\t and then emit_move_insn (dhi, hi).  But the former would\n+\t invalidate hi's address.  Load into dhi first.  */\n+      emit_move_insn (dhi, hi);\n+      hi = dhi;\n+    }\n   if (!rtx_equal_p (dlo, hi))\n     {\n       if (!rtx_equal_p (dlo, lo))"}, {"sha": "e9ca7f3f1adc955e9efd440dd3bf2c2c2f1260e7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2c089640279614e34b8712bfb318a9d4fc8ac8fe", "patch": "@@ -11396,11 +11396,12 @@\n ;; Split DST = (HI<<32)|LO early to minimize register usage.\n (define_code_iterator any_or_plus [plus ior xor])\n (define_insn_and_split \"*concat<mode><dwi>3_1\"\n-  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro\")\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r\")\n \t(any_or_plus:<DWI>\n-\t  (ashift:<DWI> (match_operand:<DWI> 1 \"register_operand\" \"r\")\n+\t  (ashift:<DWI> (match_operand:<DWI> 1 \"register_operand\" \"r,r\")\n \t\t\t(match_operand:<DWI> 2 \"const_int_operand\"))\n-\t  (zero_extend:<DWI> (match_operand:DWIH 3 \"register_operand\" \"r\"))))]\n+\t  (zero_extend:<DWI>\n+\t    (match_operand:DWIH 3 \"nonimmediate_operand\" \"r,m\"))))]\n   \"INTVAL (operands[2]) == <MODE_SIZE> * BITS_PER_UNIT\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -11412,10 +11413,11 @@\n })\n \n (define_insn_and_split \"*concat<mode><dwi>3_2\"\n-  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro\")\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r\")\n \t(any_or_plus:<DWI>\n-\t  (zero_extend:<DWI> (match_operand:DWIH 1 \"register_operand\" \"r\"))\n-\t  (ashift:<DWI> (match_operand:<DWI> 2 \"register_operand\" \"r\")\n+\t  (zero_extend:<DWI>\n+\t    (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,m\"))\n+\t  (ashift:<DWI> (match_operand:<DWI> 2 \"register_operand\" \"r,r\")\n \t\t\t(match_operand:<DWI> 3 \"const_int_operand\"))))]\n   \"INTVAL (operands[3]) == <MODE_SIZE> * BITS_PER_UNIT\"\n   \"#\"\n@@ -11428,12 +11430,14 @@\n })\n \n (define_insn_and_split \"*concat<mode><dwi>3_3\"\n-  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro\")\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r,r,&r\")\n \t(any_or_plus:<DWI>\n \t  (ashift:<DWI>\n-\t    (zero_extend:<DWI> (match_operand:DWIH 1 \"register_operand\" \"r\"))\n+\t    (zero_extend:<DWI>\n+\t      (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,m,r,m\"))\n \t    (match_operand:<DWI> 2 \"const_int_operand\"))\n-\t  (zero_extend:<DWI> (match_operand:DWIH 3 \"register_operand\" \"r\"))))]\n+\t  (zero_extend:<DWI>\n+\t    (match_operand:DWIH 3 \"nonimmediate_operand\" \"r,r,m,m\"))))]\n   \"INTVAL (operands[2]) == <MODE_SIZE> * BITS_PER_UNIT\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -11444,11 +11448,13 @@\n })\n \n (define_insn_and_split \"*concat<mode><dwi>3_4\"\n-  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro\")\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=ro,r,r,&r\")\n \t(any_or_plus:<DWI>\n-\t  (zero_extend:<DWI> (match_operand:DWIH 1 \"register_operand\" \"r\"))\n+\t  (zero_extend:<DWI>\n+\t    (match_operand:DWIH 1 \"nonimmediate_operand\" \"r,m,r,m\"))\n \t  (ashift:<DWI>\n-\t    (zero_extend:<DWI> (match_operand:DWIH 2 \"register_operand\" \"r\"))\n+\t    (zero_extend:<DWI>\n+\t      (match_operand:DWIH 2 \"nonimmediate_operand\" \"r,r,m,m\"))\n \t    (match_operand:<DWI> 3 \"const_int_operand\"))))]\n   \"INTVAL (operands[3]) == <MODE_SIZE> * BITS_PER_UNIT\"\n   \"#\""}, {"sha": "60ec87bdf941d2d1b4d715c664fcde4d3e9a7f65", "filename": "gcc/testsuite/gcc.target/i386/pr107627-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107627-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107627-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107627-1.c?ref=2c089640279614e34b8712bfb318a9d4fc8ac8fe", "patch": "@@ -0,0 +1,22 @@\n+/* PR target/107627 */\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-final { scan-assembler-not \"\\torq\\t\" } } */\n+\n+static inline unsigned __int128\n+foo (unsigned long long x, unsigned long long y)\n+{\n+  return ((unsigned __int128) x << 64) | y;\n+}\n+\n+static inline unsigned long long\n+bar (unsigned long long x, unsigned long long y, unsigned z)\n+{\n+  return foo (x, y) >> (z % 64);\n+}\n+\n+void\n+baz (unsigned long long *x, const unsigned long long *y, unsigned z)\n+{\n+  x[0] = bar (y[0], y[1], z);\n+}"}, {"sha": "7f96613e846bd131170f386b07c3bbe1316ec727", "filename": "gcc/testsuite/gcc.target/i386/pr107627-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107627-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c089640279614e34b8712bfb318a9d4fc8ac8fe/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107627-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr107627-2.c?ref=2c089640279614e34b8712bfb318a9d4fc8ac8fe", "patch": "@@ -0,0 +1,22 @@\n+/* PR target/107627 */\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -masm=att\" } */\n+/* { dg-final { scan-assembler-not \"\\torl\\t\" } } */\n+\n+static inline unsigned long long\n+qux (unsigned int x, unsigned int y)\n+{\n+  return ((unsigned long long) x << 32) | y;\n+}\n+\n+static inline unsigned int\n+corge (unsigned int x, unsigned int y, unsigned z)\n+{\n+  return qux (x, y) >> (z % 32);\n+}\n+\n+void\n+garply (unsigned int *x, const unsigned int *y, unsigned z)\n+{\n+  x[0] = corge (y[0], y[1], z);\n+}"}]}