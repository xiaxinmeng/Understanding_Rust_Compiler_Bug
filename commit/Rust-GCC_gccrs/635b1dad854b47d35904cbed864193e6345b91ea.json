{"sha": "635b1dad854b47d35904cbed864193e6345b91ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1YjFkYWQ4NTRiNDdkMzU5MDRjYmVkODY0MTkzZTYzNDViOTFlYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-22T18:26:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-22T18:26:01Z"}, "message": "(build_component_ref): For a field in an anonymous union,\n\nmake two nested COMPONENT_REFs.\n(lookup_field): Additional arg INDIRECT.\n\nFrom-SVN: r5400", "tree": {"sha": "a7c4017a6c649fef79ef4c0c162159ad5157ed12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7c4017a6c649fef79ef4c0c162159ad5157ed12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/635b1dad854b47d35904cbed864193e6345b91ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635b1dad854b47d35904cbed864193e6345b91ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635b1dad854b47d35904cbed864193e6345b91ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635b1dad854b47d35904cbed864193e6345b91ea/comments", "author": null, "committer": null, "parents": [{"sha": "214a36e8508ab10a3ef23f682a0469a2e5255bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214a36e8508ab10a3ef23f682a0469a2e5255bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214a36e8508ab10a3ef23f682a0469a2e5255bd3"}], "stats": {"total": 45, "additions": 37, "deletions": 8}, "files": [{"sha": "9ce2929750c8e72dc8ad149e830b0b8743e5fd83", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635b1dad854b47d35904cbed864193e6345b91ea/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635b1dad854b47d35904cbed864193e6345b91ea/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=635b1dad854b47d35904cbed864193e6345b91ea", "patch": "@@ -1033,11 +1033,16 @@ default_conversion (exp)\n   return exp;\n }\n \f\n-/* Look up component name in the structure type definition.  */\n+/* Look up component name in the structure type definition.\n+\n+   If this component name is found indirectly within an anonymous union,\n+   store in *INDIRECT the component which directly contains\n+   that anonymous union.  Otherwise, set *INDIRECT to 0.  */\n      \n static tree\n-lookup_field (type, component)\n+lookup_field (type, component, indirect)\n      tree type, component;\n+     tree *indirect;\n {\n   tree field;\n \n@@ -1066,11 +1071,15 @@ lookup_field (type, component)\n \t      /* Step through all anon unions in linear fashion.  */\n \t      while (DECL_NAME (field_array[bot]) == NULL_TREE)\n \t\t{\n-\t\t  tree anon;\n+\t\t  tree anon, junk;\n+\n \t\t  field = field_array[bot++];\n-\t\t  anon = lookup_field (TREE_TYPE (field), component);\n+\t\t  anon = lookup_field (TREE_TYPE (field), component, &junk);\n \t\t  if (anon != NULL_TREE)\n-\t\t    return anon;\n+\t\t    {\n+\t\t      *indirect = field;\n+\t\t      return anon;\n+\t\t    }\n \t\t}\n \n \t      /* Entire record is only anon unions.  */\n@@ -1101,16 +1110,21 @@ lookup_field (type, component)\n \t{\n \t  if (DECL_NAME (field) == NULL_TREE)\n \t    {\n-\t      tree anon = lookup_field (TREE_TYPE (field), component);\n+\t      tree junk;\n+\t      tree anon = lookup_field (TREE_TYPE (field), component, &junk);\n \t      if (anon != NULL_TREE)\n-\t\treturn anon;\n+\t\t{\n+\t\t  *indirect = field;\n+\t\t  return anon;\n+\t\t}\n \t    }\n \n \t  if (DECL_NAME (field) == component)\n \t    break;\n \t}\n     }\n \n+  *indirect = NULL_TREE;\n   return field;\n }\n \n@@ -1147,13 +1161,15 @@ build_component_ref (datum, component)\n \n   if (code == RECORD_TYPE || code == UNION_TYPE)\n     {\n+      tree indirect = 0;\n+\n       if (TYPE_SIZE (type) == 0)\n \t{\n \t  incomplete_type_error (NULL_TREE, type);\n \t  return error_mark_node;\n \t}\n \n-      field = lookup_field (type, component);\n+      field = lookup_field (type, component, &indirect);\n \n       if (!field)\n \t{\n@@ -1166,6 +1182,19 @@ build_component_ref (datum, component)\n       if (TREE_TYPE (field) == error_mark_node)\n \treturn error_mark_node;\n \n+      /* If FIELD was found buried within an anonymous union,\n+\t make one COMPONENT_REF to get that anonymous union,\n+\t then fall thru to make a second COMPONENT_REF to get FIELD.  */\n+      if (indirect != 0)\n+\t{\n+\t  ref = build (COMPONENT_REF, TREE_TYPE (indirect), datum, indirect);\n+\t  if (TREE_READONLY (datum) || TREE_READONLY (indirect))\n+\t    TREE_READONLY (ref) = 1;\n+\t  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (indirect))\n+\t    TREE_THIS_VOLATILE (ref) = 1;\n+\t  datum = ref;\n+\t}\n+\n       ref = build (COMPONENT_REF, TREE_TYPE (field), datum, field);\n \n       if (TREE_READONLY (datum) || TREE_READONLY (field))"}]}