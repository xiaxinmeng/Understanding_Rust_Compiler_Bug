{"sha": "d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYzMDI0NWY5ZDQ1ODRiZDNlY2IyMTkyZjhlMmJhMDVlMWRiNzdiYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-09-07T10:23:06Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-09-07T10:23:06Z"}, "message": "bitmap.c (bitmap_last_set_bit): Rewrite to return the correct bit.\n\n\t* bitmap.c (bitmap_last_set_bit): Rewrite to return the correct bit.\n\n\t* graphite.c (print_global_statistics): Use EDGE_COUNT instead\n\tof VEC_length.\n\t(print_graphite_scop_statistics): Likewise.\n\t* graphite-scop-detection.c (get_bb_type): Use single_succ_p.\n\t(print_graphite_scop_statistics): Use EDGE_COUNT, not VEC_length.\n\t(canonicalize_loop_closed_ssa): Use single_pred_p.\n\n\t* alias.c (reg_seen): Make this an sbitmap.\n\t(record_set, init_alias_analysis): Update.\n\n\t* tree-ssa-coalesce.c (ssa_conflicts_dump): Fix dumping.\n\nFrom-SVN: r191063", "tree": {"sha": "6bacff29f54b81215a23625852fb1d19f6ee22c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bacff29f54b81215a23625852fb1d19f6ee22c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/comments", "author": null, "committer": null, "parents": [{"sha": "183c7727f2fb0d7b3e8e0673da1436d11e8535cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183c7727f2fb0d7b3e8e0673da1436d11e8535cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/183c7727f2fb0d7b3e8e0673da1436d11e8535cd"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "b6456048a7d4a91523c69cf3fc5e44698f7db93f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "patch": "@@ -1,3 +1,19 @@\n+2012-09-07  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* bitmap.c (bitmap_last_set_bit): Rewrite to return the correct bit.\n+\n+\t* graphite.c (print_global_statistics): Use EDGE_COUNT instead\n+\tof VEC_length.\n+\t(print_graphite_scop_statistics): Likewise.\n+\t* graphite-scop-detection.c (get_bb_type): Use single_succ_p.\n+\t(print_graphite_scop_statistics): Use EDGE_COUNT, not VEC_length.\n+\t(canonicalize_loop_closed_ssa): Use single_pred_p.\n+\n+\t* alias.c (reg_seen): Make this an sbitmap.\n+\t(record_set, init_alias_analysis): Update.\n+\n+\t* tree-ssa-coalesce.c (ssa_conflicts_dump): Fix dumping.\n+\n 2012-09-07  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/53986"}, {"sha": "1df3529e94261629d799e337880a2adeba3a2ae8", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "patch": "@@ -1220,7 +1220,7 @@ find_base_value (rtx src)\n \n /* While scanning insns to find base values, reg_seen[N] is nonzero if\n    register N has been set in this function.  */\n-static char *reg_seen;\n+static sbitmap reg_seen;\n \n static void\n record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n@@ -1246,7 +1246,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n     {\n       while (--n >= 0)\n \t{\n-\t  reg_seen[regno + n] = 1;\n+\t  SET_BIT (reg_seen, regno + n);\n \t  new_reg_base_value[regno + n] = 0;\n \t}\n       return;\n@@ -1267,12 +1267,12 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n   else\n     {\n       /* There's a REG_NOALIAS note against DEST.  */\n-      if (reg_seen[regno])\n+      if (TEST_BIT (reg_seen, regno))\n \t{\n \t  new_reg_base_value[regno] = 0;\n \t  return;\n \t}\n-      reg_seen[regno] = 1;\n+      SET_BIT (reg_seen, regno);\n       new_reg_base_value[regno] = unique_base_value (unique_id++);\n       return;\n     }\n@@ -1328,10 +1328,10 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n       }\n   /* If this is the first set of a register, record the value.  */\n   else if ((regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])\n-\t   && ! reg_seen[regno] && new_reg_base_value[regno] == 0)\n+\t   && ! TEST_BIT (reg_seen, regno) && new_reg_base_value[regno] == 0)\n     new_reg_base_value[regno] = find_base_value (src);\n \n-  reg_seen[regno] = 1;\n+  SET_BIT (reg_seen, regno);\n }\n \n /* Return REG_BASE_VALUE for REGNO.  Selective scheduler uses this to avoid\n@@ -2789,7 +2789,7 @@ init_alias_analysis (void)\n   VEC_safe_grow_cleared (rtx, gc, reg_base_value, maxreg);\n \n   new_reg_base_value = XNEWVEC (rtx, maxreg);\n-  reg_seen = XNEWVEC (char, maxreg);\n+  reg_seen = sbitmap_alloc (maxreg);\n \n   /* The basic idea is that each pass through this loop will use the\n      \"constant\" information from the previous pass to propagate alias\n@@ -2834,7 +2834,7 @@ init_alias_analysis (void)\n       memset (new_reg_base_value, 0, maxreg * sizeof (rtx));\n \n       /* Wipe the reg_seen array clean.  */\n-      memset (reg_seen, 0, maxreg);\n+      sbitmap_zero (reg_seen);\n \n       /* Mark all hard registers which may contain an address.\n \t The stack, frame and argument pointers may contain an address.\n@@ -2957,7 +2957,7 @@ init_alias_analysis (void)\n   /* Clean up.  */\n   free (new_reg_base_value);\n   new_reg_base_value = 0;\n-  free (reg_seen);\n+  sbitmap_free (reg_seen);\n   reg_seen = 0;\n   timevar_pop (TV_ALIAS_ANALYSIS);\n }"}, {"sha": "63f0e099a055cc2c74072df5152d31b1404e9699", "filename": "gcc/bitmap.c", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "patch": "@@ -837,33 +837,24 @@ bitmap_last_set_bit (const_bitmap a)\n   gcc_unreachable ();\n  found_bit:\n   bit_no += ix * BITMAP_WORD_BITS;\n-\n-  /* Binary search for the last set bit.  */\n #if GCC_VERSION >= 3004\n   gcc_assert (sizeof(long) == sizeof (word));\n-  bit_no += sizeof (long) * 8 - __builtin_ctzl (word);\n+  bit_no += BITMAP_WORD_BITS - __builtin_clzl (word) - 1;\n #else\n-#if BITMAP_WORD_BITS > 64\n-#error \"Fill out the table.\"\n-#endif\n+  /* Hopefully this is a twos-complement host...  */\n+  BITMAP_WORD x = word;\n+  x |= (x >> 1);\n+  x |= (x >> 2);\n+  x |= (x >> 4);\n+  x |= (x >> 8);\n+  x |= (x >> 16);\n #if BITMAP_WORD_BITS > 32\n-  if ((word & 0xffffffff00000000))\n-    word >>= 32, bit_no += 32;\n+  x |= (x >> 32);\n #endif\n-  if (word & 0xffff0000)\n-    word >>= 16, bit_no += 16;\n-  if (!(word & 0xff00))\n-    word >>= 8, bit_no += 8;\n-  if (!(word & 0xf0))\n-    word >>= 4, bit_no += 4;\n-  if (!(word & 12))\n-    word >>= 2, bit_no += 2;\n-  if (!(word & 2))\n-    word >>= 1, bit_no += 1;\n+  bit_no += bitmap_popcount (x) - 1;\n #endif\n \n- gcc_checking_assert (word & 1);\n- return bit_no;\n+  return bit_no;\n }\n \f\n "}, {"sha": "48bbae94dce7d2c05190c12dd4ee3746969f9f3e", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "patch": "@@ -67,7 +67,7 @@ static gbb_type\n get_bb_type (basic_block bb, struct loop *last_loop)\n {\n   VEC (basic_block, heap) *dom;\n-  int nb_dom, nb_suc;\n+  int nb_dom;\n   struct loop *loop = bb->loop_father;\n \n   /* Check, if we entry into a new loop. */\n@@ -88,9 +88,7 @@ get_bb_type (basic_block bb, struct loop *last_loop)\n   if (nb_dom == 0)\n     return GBB_LAST;\n \n-  nb_suc = VEC_length (edge, bb->succs);\n-\n-  if (nb_dom == 1 && nb_suc == 1)\n+  if (nb_dom == 1 && single_succ_p (bb))\n     return GBB_SIMPLE;\n \n   return GBB_COND_HEADER;\n@@ -1114,7 +1112,7 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n       n_bbs++;\n       n_p_bbs += bb->count;\n \n-      if (VEC_length (edge, bb->succs) > 1)\n+      if (EDGE_COUNT (bb->succs) > 1)\n \t{\n \t  n_conditions++;\n \t  n_p_conditions += bb->count;\n@@ -1299,7 +1297,7 @@ canonicalize_loop_closed_ssa (loop_p loop)\n \n   bb = e->dest;\n \n-  if (VEC_length (edge, bb->preds) == 1)\n+  if (single_pred_p (bb))\n     {\n       e = split_block_after_labels (bb);\n       make_close_phi_nodes_unique (e->src);"}, {"sha": "0eb1ca191d5ee39639a5969dc055d1a893821d71", "filename": "gcc/graphite.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "patch": "@@ -97,7 +97,7 @@ print_global_statistics (FILE* file)\n \t  n_p_loops += bb->count;\n \t}\n \n-      if (VEC_length (edge, bb->succs) > 1)\n+      if (EDGE_COUNT (bb->succs) > 1)\n \t{\n \t  n_conditions++;\n \t  n_p_conditions += bb->count;\n@@ -149,7 +149,7 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n       n_bbs++;\n       n_p_bbs += bb->count;\n \n-      if (VEC_length (edge, bb->succs) > 1)\n+      if (EDGE_COUNT (bb->succs) > 1)\n \t{\n \t  n_conditions++;\n \t  n_p_conditions += bb->count;"}, {"sha": "6217825d1a6e607eb20ea22a5194e63f0c92e0a4", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d630245f9d4584bd3ecb2192f8e2ba05e1db77ba/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=d630245f9d4584bd3ecb2192f8e2ba05e1db77ba", "patch": "@@ -626,10 +626,10 @@ ssa_conflicts_dump (FILE *file, ssa_conflicts_p ptr)\n \n   fprintf (file, \"\\nConflict graph:\\n\");\n \n-  FOR_EACH_VEC_ELT (bitmap, ptr->conflicts, x, b);\n+  FOR_EACH_VEC_ELT (bitmap, ptr->conflicts, x, b)\n     if (b)\n       {\n-\tfprintf (dump_file, \"%d: \", x);\n+\tfprintf (file, \"%d: \", x);\n \tdump_bitmap (file, b);\n       }\n }"}]}