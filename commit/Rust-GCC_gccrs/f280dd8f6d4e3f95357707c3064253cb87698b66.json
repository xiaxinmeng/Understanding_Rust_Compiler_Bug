{"sha": "f280dd8f6d4e3f95357707c3064253cb87698b66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI4MGRkOGY2ZDRlM2Y5NTM1NzcwN2MzMDY0MjUzY2I4NzY5OGI2Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-05-22T12:53:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T12:53:21Z"}, "message": "exp_ch5.adb, [...]: This is a general change that deals with the fact that most of the special...\n\n2015-05-22  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch5.adb, layout.adb, einfo.adb, einfo.ads, sem_prag.adb,\n\tfreeze.adb, freeze.ads, sem_util.adb, sem_util.ads, exp_ch2.adb,\n\texp_ch4.adb, errout.adb, exp_aggr.adb, sem_ch13.adb: This is a general\n\tchange that deals with the fact that most of the special coding for\n\tAtomic should also apply to the case of Volatile_Full_Access.\n\tA new attribute Is_Atomic_Or_VFA is introduced, and many of the\n\treferences to Is_Atomic now use this new attribute.\n\nFrom-SVN: r223560", "tree": {"sha": "b66b44d98a027fc0c33dc1f86e1a61404d3d06d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b66b44d98a027fc0c33dc1f86e1a61404d3d06d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f280dd8f6d4e3f95357707c3064253cb87698b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f280dd8f6d4e3f95357707c3064253cb87698b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f280dd8f6d4e3f95357707c3064253cb87698b66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f280dd8f6d4e3f95357707c3064253cb87698b66/comments", "author": null, "committer": null, "parents": [{"sha": "878e58c85ed67d4090e7e04d27695e892bc78580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878e58c85ed67d4090e7e04d27695e892bc78580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878e58c85ed67d4090e7e04d27695e892bc78580"}], "stats": {"total": 239, "additions": 173, "deletions": 66}, "files": [{"sha": "569402443fc708558f4ac08d5f204bada61ee7e7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -1,3 +1,13 @@\n+2015-05-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch5.adb, layout.adb, einfo.adb, einfo.ads, sem_prag.adb,\n+\tfreeze.adb, freeze.ads, sem_util.adb, sem_util.ads, exp_ch2.adb,\n+\texp_ch4.adb, errout.adb, exp_aggr.adb, sem_ch13.adb: This is a general\n+\tchange that deals with the fact that most of the special coding for\n+\tAtomic should also apply to the case of Volatile_Full_Access.\n+\tA new attribute Is_Atomic_Or_VFA is introduced, and many of the\n+\treferences to Is_Atomic now use this new attribute.\n+\n 2015-05-22  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Op_Eq): Introduce 'Machine for 'Result"}, {"sha": "9de5ce9c25912ff5f21465201ba3d18cbb8af5c1", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -7329,6 +7329,15 @@ package body Einfo is\n       end if;\n    end Invariant_Procedure;\n \n+   ----------------------\n+   -- Is_Atomic_Or_VFA --\n+   ----------------------\n+\n+   function Is_Atomic_Or_VFA (Id : E) return B is\n+   begin\n+      return Is_Atomic (Id) or else Has_Volatile_Full_Access (Id);\n+   end Is_Atomic_Or_VFA;\n+\n    ------------------\n    -- Is_Base_Type --\n    ------------------"}, {"sha": "38a6c16cad8397eb7db7c5d9bba9b8c14d649e7b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -2218,6 +2218,14 @@ package Einfo is\n --       In the case of private and incomplete types, this flag is set in\n --       both the partial view and the full view.\n \n+--    Is_Atomic_Or_VFA (synth)\n+--       Defined in all type entities, and also in constants, components and\n+--       variables. Set if a pragma Atomic or Shared or Volatile_Full_Access\n+--       applies to the entity. For many purposes VFA objects should be treated\n+--       the same as Atomic objects, and this predicate is intended for that\n+--       usage. In the case of private and incomplete types, the predicate\n+--       applies to both the partial view and the full view.\n+\n --    Is_Array_Type (synthesized)\n --       Applies to all entities, true for array types and subtypes\n \n@@ -5476,6 +5484,7 @@ package Einfo is\n    --    Implementation_Base_Type            (synth)\n    --    Invariant_Procedure                 (synth)\n    --    Is_Access_Protected_Subprogram_Type (synth)\n+   --    Is_Atomic_Or_VFA                    (synth)\n    --    Predicate_Function                  (synth)\n    --    Predicate_Function_M                (synth)\n    --    Root_Type                           (synth)\n@@ -5628,6 +5637,7 @@ package Einfo is\n    --    Is_Tag                              (Flag78)\n    --    Is_Volatile                         (Flag16)\n    --    Treat_As_Volatile                   (Flag41)\n+   --    Is_Atomic_Or_VFA                    (synth)\n    --    Next_Component                      (synth)\n    --    Next_Component_Or_Discriminant      (synth)\n \n@@ -5676,6 +5686,7 @@ package Einfo is\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n+   --    Is_Atomic_Or_VFA                    (synth)\n    --    Size_Clause                         (synth)\n \n    --  E_Decimal_Fixed_Point_Type\n@@ -6413,6 +6424,7 @@ package Einfo is\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n+   --    Is_Atomic_Or_VFA                    (synth)\n    --    Size_Clause                         (synth)\n \n    --  E_Void\n@@ -6869,6 +6881,7 @@ package Einfo is\n    function Is_Aliased                          (Id : E) return B;\n    function Is_Asynchronous                     (Id : E) return B;\n    function Is_Atomic                           (Id : E) return B;\n+   function Is_Atomic_Or_VFA                    (Id : E) return B;\n    function Is_Bit_Packed_Array                 (Id : E) return B;\n    function Is_Called                           (Id : E) return B;\n    function Is_Character_Type                   (Id : E) return B;\n@@ -9041,6 +9054,7 @@ package Einfo is\n    --  be handled by xeinfo.\n \n    pragma Inline (Base_Type);\n+   pragma Inline (Is_Atomic_Or_VFA);\n    pragma Inline (Is_Base_Type);\n    pragma Inline (Is_Package_Or_Generic_Package);\n    pragma Inline (Is_Packed_Array);"}, {"sha": "9ad887c013084c73338eae44593cd13c796d2264", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -3159,6 +3159,16 @@ package body Errout is\n             return True;\n          end if;\n \n+      --  Similar processing for \"volatile full access cannot be guaranteed\"\n+\n+      elsif Msg = \"volatile full access to & cannot be guaranteed\" then\n+         if Is_Type (E)\n+           and then Has_Volatile_Full_Access (E)\n+           and then No (Get_Rep_Pragma (E, Name_Volatile_Full_Access))\n+         then\n+            return True;\n+         end if;\n+\n       --  Processing for \"Size too small\" messages\n \n       elsif Msg = \"size for& too small, minimum allowed is ^\" then"}, {"sha": "70f49688b8694866cff43076c8b148893147b603", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -4175,7 +4175,7 @@ package body Exp_Aggr is\n \n             Ctyp := Component_Type (Ctyp);\n \n-            if Is_Atomic (Ctyp) then\n+            if Is_Atomic_Or_VFA (Ctyp) then\n                return False;\n             end if;\n          end loop;\n@@ -5935,15 +5935,15 @@ package body Exp_Aggr is\n    --  Start of processing for Expand_Record_Aggregate\n \n    begin\n-      --  If the aggregate is to be assigned to an atomic variable, we have\n+      --  If the aggregate is to be assigned to an atomic/VFA variable, we have\n       --  to prevent a piecemeal assignment even if the aggregate is to be\n       --  expanded. We create a temporary for the aggregate, and assign the\n       --  temporary instead, so that the back end can generate an atomic move\n       --  for it.\n \n-      if Is_Atomic (Typ)\n+      if Is_Atomic_Or_VFA (Typ)\n         and then Comes_From_Source (Parent (N))\n-        and then Is_Atomic_Aggregate (N, Typ)\n+        and then Is_Atomic_VFA_Aggregate (N, Typ)\n       then\n          return;\n "}, {"sha": "b926e102d3bf5cb09d5229b97ae3227b121694c7", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -396,7 +396,8 @@ package body Exp_Ch2 is\n          Write_Eol;\n       end if;\n \n-      --  Set Atomic_Sync_Required if necessary for atomic variable\n+      --  Set Atomic_Sync_Required if necessary for atomic variable. Note that\n+      --  this processing does NOT apply to Volatile_Full_Access variables.\n \n       if Nkind_In (N, N_Identifier, N_Expanded_Name)\n         and then Ekind (E) = E_Variable"}, {"sha": "0ef690b0f9313a6cc05e4ec44858d2487c840960", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -7313,12 +7313,12 @@ package body Exp_Ch4 is\n          --  Where the component type is elementary we can use a block bit\n          --  comparison (if supported on the target) exception in the case\n          --  of floating-point (negative zero issues require element by\n-         --  element comparison), and atomic types (where we must be sure\n+         --  element comparison), and atomic/VFA types (where we must be sure\n          --  to load elements independently) and possibly unaligned arrays.\n \n          elsif Is_Elementary_Type (Component_Type (Typl))\n            and then not Is_Floating_Point_Type (Component_Type (Typl))\n-           and then not Is_Atomic (Component_Type (Typl))\n+           and then not Is_Atomic_Or_VFA (Component_Type (Typl))\n            and then not Is_Possibly_Unaligned_Object (Lhs)\n            and then not Is_Possibly_Unaligned_Object (Rhs)\n            and then Support_Composite_Compare_On_Target"}, {"sha": "145da2cf977a9d33cb5e3a794fd7f2db37b415ba", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -429,11 +429,11 @@ package body Exp_Ch5 is\n       elsif Has_Controlled_Component (L_Type) then\n          Loop_Required := True;\n \n-      --  If object is atomic, we cannot tolerate a loop\n+      --  If object is atomic/VFA, we cannot tolerate a loop\n \n-      elsif Is_Atomic_Object (Act_Lhs)\n+      elsif Is_Atomic_Or_VFA_Object (Act_Lhs)\n               or else\n-            Is_Atomic_Object (Act_Rhs)\n+            Is_Atomic_Or_VFA_Object (Act_Rhs)\n       then\n          return;\n \n@@ -442,8 +442,8 @@ package body Exp_Ch5 is\n \n       elsif Has_Atomic_Components (L_Type)\n         or else Has_Atomic_Components (R_Type)\n-        or else Is_Atomic (Component_Type (L_Type))\n-        or else Is_Atomic (Component_Type (R_Type))\n+        or else Is_Atomic_Or_VFA (Component_Type (L_Type))\n+        or else Is_Atomic_Or_VFA (Component_Type (R_Type))\n       then\n          Loop_Required := True;\n \n@@ -3395,7 +3395,7 @@ package body Exp_Ch5 is\n                         Next_Elmt (Prim);\n                      end loop;\n \n-                     --  default iterator must exist.\n+                     --  Default iterator must exist\n \n                      pragma Assert (False);\n "}, {"sha": "ec37b4f0b8ad246dfd66b5f836d37587461bbfd7", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -942,13 +942,13 @@ package body Freeze is\n                      Packed_Size_Known := False;\n                   end if;\n \n-                  --  We do not know the packed size if we have an atomic type\n+                  --  We do not know the packed size for an atomic/VFA type\n                   --  or component, or an independent type or component, or a\n                   --  by reference type or aliased component (because packing\n                   --  does not touch these).\n \n-                  if Is_Atomic (Ctyp)\n-                    or else Is_Atomic (Comp)\n+                  if        Is_Atomic_Or_VFA (Ctyp)\n+                    or else Is_Atomic_Or_VFA (Comp)\n                     or else Is_Independent (Ctyp)\n                     or else Is_Independent (Comp)\n                     or else Is_By_Reference_Type (Ctyp)\n@@ -1036,11 +1036,11 @@ package body Freeze is\n                                  and then Is_Modular_Integer_Type\n                                             (Packed_Array_Impl_Type (Ctyp)))\n                      then\n-                        --  Packed size unknown if we have an atomic type\n-                        --  or a by reference type, since the back end\n-                        --  knows how these are layed out.\n+                        --  Packed size unknown if we have an atomic/VFA type\n+                        --  or a by reference type, since the back end knows\n+                        --  how these are layed out.\n \n-                        if Is_Atomic (Ctyp)\n+                        if Is_Atomic_Or_VFA (Ctyp)\n                           or else Is_By_Reference_Type (Ctyp)\n                         then\n                            Packed_Size_Known := False;\n@@ -1455,11 +1455,11 @@ package body Freeze is\n       end loop;\n    end Check_Unsigned_Type;\n \n-   -------------------------\n-   -- Is_Atomic_Aggregate --\n-   -------------------------\n+   -----------------------------\n+   -- Is_Atomic_VFA_Aggregate --\n+   -----------------------------\n \n-   function  Is_Atomic_Aggregate\n+   function Is_Atomic_VFA_Aggregate\n      (E   : Entity_Id;\n       Typ : Entity_Id) return Boolean\n    is\n@@ -1495,7 +1495,7 @@ package body Freeze is\n       else\n          return False;\n       end if;\n-   end Is_Atomic_Aggregate;\n+   end Is_Atomic_VFA_Aggregate;\n \n    -----------------------------------------------\n    -- Explode_Initialization_Compound_Statement --\n@@ -2423,21 +2423,21 @@ package body Freeze is\n                end if;\n             end;\n \n-            --  Check for Aliased or Atomic_Components/Atomic with unsuitable\n-            --  packing or explicit component size clause given.\n+            --  Check for Aliased or Atomic_Components/Atomic/VFA with\n+            --  unsuitable packing or explicit component size clause given.\n \n             if (Has_Aliased_Components (Arr)\n                  or else Has_Atomic_Components (Arr)\n-                 or else Is_Atomic (Ctyp))\n+                 or else Is_Atomic_Or_VFA (Ctyp))\n               and then\n                 (Has_Component_Size_Clause (Arr) or else Is_Packed (Arr))\n             then\n                Alias_Atomic_Check : declare\n \n                   procedure Complain_CS (T : String);\n                   --  Outputs error messages for incorrect CS clause or pragma\n-                  --  Pack for aliased or atomic components (T is \"aliased\" or\n-                  --  \"atomic\");\n+                  --  Pack for aliased or atomic/VFA components (T is \"aliased\"\n+                  --  or \"atomic/vfa\");\n \n                   -----------------\n                   -- Complain_CS --\n@@ -2498,9 +2498,13 @@ package body Freeze is\n                   elsif Has_Aliased_Components (Arr) then\n                      Complain_CS (\"aliased\");\n \n-                  elsif Has_Atomic_Components (Arr) or else Is_Atomic (Ctyp)\n+                  elsif Has_Atomic_Components (Arr)\n+                    or else Is_Atomic (Ctyp)\n                   then\n                      Complain_CS (\"atomic\");\n+\n+                  elsif Has_Volatile_Full_Access (Ctyp) then\n+                     Complain_CS (\"volatile full access\");\n                   end if;\n                end Alias_Atomic_Check;\n             end if;\n@@ -2509,8 +2513,8 @@ package body Freeze is\n             --  packing or explicit component size clause given.\n \n             if (Has_Independent_Components (Arr) or else Is_Independent (Ctyp))\n-              and then\n-                (Has_Component_Size_Clause (Arr) or else Is_Packed (Arr))\n+                  and then\n+               (Has_Component_Size_Clause  (Arr) or else Is_Packed (Arr))\n             then\n                begin\n                   --  If object size of component type isn't known, we cannot\n@@ -2772,15 +2776,15 @@ package body Freeze is\n \n          --  For non-packed arrays set the alignment of the array to the\n          --  alignment of the component type if it is unknown. Skip this\n-         --  in atomic case (atomic arrays may need larger alignments).\n+         --  in atomic/VFA case (atomic/VFA arrays may need larger alignments).\n \n          if not Is_Packed (Arr)\n            and then Unknown_Alignment (Arr)\n            and then Known_Alignment (Ctyp)\n            and then Known_Static_Component_Size (Arr)\n            and then Known_Static_Esize (Ctyp)\n            and then Esize (Ctyp) = Component_Size (Arr)\n-           and then not Is_Atomic (Arr)\n+           and then not Is_Atomic_Or_VFA (Arr)\n          then\n             Set_Alignment (Arr, Alignment (Component_Type (Arr)));\n          end if;\n@@ -4813,11 +4817,12 @@ package body Freeze is\n          --  than component-wise (the assignment to the temp may be done\n          --  component-wise, but that is harmless).\n \n-         elsif Is_Atomic (E)\n+         elsif Is_Atomic_Or_VFA (E)\n            and then Nkind (Parent (E)) = N_Object_Declaration\n            and then Present (Expression (Parent (E)))\n            and then Nkind (Expression (Parent (E))) = N_Aggregate\n-           and then Is_Atomic_Aggregate (Expression (Parent (E)), Etype (E))\n+           and then\n+             Is_Atomic_VFA_Aggregate (Expression (Parent (E)), Etype (E))\n          then\n             null;\n          end if;"}, {"sha": "3179e4b141252ba652f745498b1a2ee4a55a0536", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -174,12 +174,11 @@ package Freeze is\n    --  do not allow a size clause if the size would not otherwise be known at\n    --  compile time in any case.\n \n-   function Is_Atomic_Aggregate\n+   function Is_Atomic_VFA_Aggregate\n      (E   : Entity_Id;\n       Typ : Entity_Id) return Boolean;\n-\n-   --  If an atomic object is initialized with an aggregate or is assigned an\n-   --  aggregate, we have to prevent a piecemeal access or assignment to the\n+   --  If an atomic/VFA object is initialized with an aggregate or is assigned\n+   --  an aggregate, we have to prevent a piecemeal access or assignment to the\n    --  object, even if the aggregate is to be expanded. We create a temporary\n    --  for the aggregate, and assign the temporary instead, so that the back\n    --  end can generate an atomic move for it. This is only done in the context"}, {"sha": "c44941667ba16e4a5c395391b5fd4ebba50c8d41", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2684,11 +2684,11 @@ package body Layout is\n \n          elsif Is_Array_Type (E) then\n \n-            --  For arrays that are required to be atomic, we do the same\n+            --  For arrays that are required to be atomic/VFA, we do the same\n             --  processing as described above for short records, since we\n             --  really need to have the alignment set for the whole array.\n \n-            if Is_Atomic (E) and then not Debug_Flag_Q then\n+            if Is_Atomic_Or_VFA (E) and then not Debug_Flag_Q then\n                Set_Composite_Alignment (E);\n             end if;\n \n@@ -2903,11 +2903,19 @@ package body Layout is\n         and then Is_Record_Type (E)\n         and then Is_Packed (E)\n       then\n-         --  No effect for record with atomic components\n+         --  No effect for record with atomic/VFA components\n \n-         if Is_Atomic (E) then\n+         if Is_Atomic_Or_VFA (E) then\n             Error_Msg_N (\"Optimize_Alignment has no effect for &??\", E);\n-            Error_Msg_N (\"\\pragma ignored for atomic record??\", E);\n+\n+            if Is_Atomic (E) then\n+               Error_Msg_N\n+                 (\"\\pragma ignored for atomic record??\", E);\n+            else\n+               Error_Msg_N\n+                 (\"\\pragma ignored for bolatile full access record??\", E);\n+            end if;\n+\n             return;\n          end if;\n \n@@ -2920,20 +2928,30 @@ package body Layout is\n             return;\n          end if;\n \n-         --  No effect if any component is atomic or is a by reference type\n+         --  No effect if any component is atomic/VFA or is a by reference type\n \n          declare\n             Ent : Entity_Id;\n+\n          begin\n             Ent := First_Component_Or_Discriminant (E);\n             while Present (Ent) loop\n                if Is_By_Reference_Type (Etype (Ent))\n-                 or else Is_Atomic (Etype (Ent))\n-                 or else Is_Atomic (Ent)\n+                 or else Is_Atomic_Or_VFA (Etype (Ent))\n+                 or else Is_Atomic_Or_VFA (Ent)\n                then\n                   Error_Msg_N (\"Optimize_Alignment has no effect for &??\", E);\n-                  Error_Msg_N\n-                    (\"\\pragma is ignored if atomic components present??\", E);\n+\n+                  if Is_Atomic (Etype (Ent)) or else Is_Atomic (Ent) then\n+                     Error_Msg_N\n+                       (\"\\pragma is ignored if atomic \"\n+                        & \"components present??\", E);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\pragma is ignored if bolatile full access \"\n+                        & \"components present??\", E);\n+                  end if;\n+\n                   return;\n                else\n                   Next_Component_Or_Discriminant (Ent);\n@@ -3026,9 +3044,9 @@ package body Layout is\n \n       --  Further processing for record types only to reduce the alignment\n       --  set by the above processing in some specific cases. We do not\n-      --  do this for atomic records, since we need max alignment there,\n+      --  do this for atomic/VFA records, since we need max alignment there,\n \n-      if Is_Record_Type (E) and then not Is_Atomic (E) then\n+      if Is_Record_Type (E) and then not Is_Atomic_Or_VFA (E) then\n \n          --  For records, there is generally no point in setting alignment\n          --  higher than word size since we cannot do better than move by"}, {"sha": "1afdd4d6992631e5f29a674d1448410ecd2ec2d3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -965,6 +965,13 @@ package body Sem_Ch13 is\n                            Set_Is_Volatile (E);\n                         end if;\n \n+                     --  Volatile_Full_Access\n+\n+                     when Aspect_Volatile_Full_Access =>\n+                        if Has_Volatile_Full_Access (P) then\n+                           Set_Has_Volatile_Full_Access (E);\n+                        end if;\n+\n                      --  Volatile_Components\n \n                      when Aspect_Volatile_Components =>\n@@ -1057,6 +1064,11 @@ package body Sem_Ch13 is\n                      return;\n                   end if;\n \n+               when Aspect_Volatile_Full_Access =>\n+                  if not Has_Volatile_Full_Access (Par) then\n+                     return;\n+                  end if;\n+\n                when others =>\n                   return;\n             end case;\n@@ -1066,7 +1078,6 @@ package body Sem_Ch13 is\n             Error_Msg_Name_1 := A_Name;\n             Error_Msg_NE\n               (\"derived type& inherits aspect%, cannot cancel\", Expr, E);\n-\n          end Check_False_Aspect_For_Derived_Type;\n \n       --  Start of processing for Make_Pragma_From_Boolean_Aspect\n@@ -11164,6 +11175,18 @@ package body Sem_Ch13 is\n          Set_Is_Volatile (Typ);\n       end if;\n \n+      --  Volatile_Full_Access\n+\n+      if not Has_Rep_Item (Typ, Name_Volatile_Full_Access, False)\n+        and then Has_Rep_Pragma (Typ, Name_Volatile_Full_Access)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Volatile_Full_Access))\n+      then\n+         Set_Has_Volatile_Full_Access (Typ);\n+         Set_Treat_As_Volatile (Typ);\n+         Set_Is_Volatile (Typ);\n+      end if;\n+\n       --  Inheritance for derived types only\n \n       if Is_Derived_Type (Typ) then"}, {"sha": "375d1d99a55844ac1bbcd3df00ff8f7556e2a7d4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -5842,17 +5842,17 @@ package body Sem_Prag is\n          K    : Node_Kind;\n          Utyp : Entity_Id;\n \n-         procedure Set_Atomic_Full (E : Entity_Id);\n+         procedure Set_Atomic_VFA (E : Entity_Id);\n          --  Set given type as Is_Atomic or Has_Volatile_Full_Access. Also, if\n          --  no explicit alignment was given, set alignment to unknown, since\n          --  back end knows what the alignment requirements are for atomic and\n          --  full access arrays. Note: this is necessary for derived types.\n \n-         ---------------------\n-         -- Set_Atomic_Full --\n-         ---------------------\n+         --------------------\n+         -- Set_Atomic_VFA --\n+         --------------------\n \n-         procedure Set_Atomic_Full (E : Entity_Id) is\n+         procedure Set_Atomic_VFA (E : Entity_Id) is\n          begin\n             if Prag_Id = Pragma_Volatile_Full_Access then\n                Set_Has_Volatile_Full_Access (E);\n@@ -5863,7 +5863,7 @@ package body Sem_Prag is\n             if not Has_Alignment_Clause (E) then\n                Set_Alignment (E, Uint_0);\n             end if;\n-         end Set_Atomic_Full;\n+         end Set_Atomic_VFA;\n \n       --  Start of processing for Process_Atomic_Independent_Shared_Volatile\n \n@@ -5956,9 +5956,9 @@ package body Sem_Prag is\n                  or else\n                Prag_Id = Pragma_Volatile_Full_Access\n             then\n-               Set_Atomic_Full (E);\n-               Set_Atomic_Full (Base_Type (E));\n-               Set_Atomic_Full (Underlying_Type (E));\n+               Set_Atomic_VFA (E);\n+               Set_Atomic_VFA (Base_Type (E));\n+               Set_Atomic_VFA (Underlying_Type (E));\n             end if;\n \n             --  Atomic/Shared/Volatile_Full_Access imply Independent"}, {"sha": "13882676443334e392426a6a4867cabc0fe9352a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -10276,6 +10276,20 @@ package body Sem_Util is\n       end if;\n    end Is_Atomic_Object;\n \n+   -----------------------------\n+   -- Is_Atomic_Or_VFA_Object --\n+   -----------------------------\n+\n+   function Is_Atomic_Or_VFA_Object (N : Node_Id) return Boolean is\n+   begin\n+      return Is_Atomic_Object (N)\n+        or else (Is_Object_Reference (N)\n+                   and then Is_Entity_Name (N)\n+                   and then (Has_Volatile_Full_Access (Entity (N))\n+                                or else\n+                             Has_Volatile_Full_Access (Etype (Entity (N)))));\n+   end Is_Atomic_Or_VFA_Object;\n+\n    -------------------------\n    -- Is_Attribute_Result --\n    -------------------------"}, {"sha": "bb537edf4cb975b220b3a7f13421e8e5896fab40", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f280dd8f6d4e3f95357707c3064253cb87698b66/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f280dd8f6d4e3f95357707c3064253cb87698b66", "patch": "@@ -1168,6 +1168,10 @@ package Sem_Util is\n    --  Determines if the given node denotes an atomic object in the sense of\n    --  the legality checks described in RM C.6(12).\n \n+   function Is_Atomic_Or_VFA_Object (N : Node_Id) return Boolean;\n+   --  Determines if the given node is an atomic object (Is_Atomic_Object true)\n+   --  or else is an object for which  VFA is present.\n+\n    function Is_Attribute_Result (N : Node_Id) return Boolean;\n    --  Determine whether node N denotes attribute 'Result\n "}]}