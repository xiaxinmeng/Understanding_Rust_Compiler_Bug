{"sha": "ac6929b5677230de8f6d3a3223a46bcce3f47144", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2OTI5YjU2NzcyMzBkZThmNmQzYTMyMjNhNDZiY2NlM2Y0NzE0NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-04-05T14:25:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-04-05T14:25:35Z"}, "message": "dse.c (struct store_info): Remove alias_set member.\n\n2016-04-05  Richard Biener  <rguenther@suse.de>\n\n\t* dse.c (struct store_info): Remove alias_set member.\n\t(struct read_info_type): Likewise.\n\t(clear_alias_group, clear_alias_mode_table, clear_alias_mode_holder,\n\tspill_deleted, clear_alias_set_lookup): Remove.\n\t(get_group_info): Remove dead base == NULL_RTX case.\n\t(dse_step0): Remove initialization of removed variables.\n\t(delete_dead_store_insn): Reomve alias set dumping.\n\t(free_read_records): Remove alias_set handling.\n\t(canon_address): Remove alias_set_out parameter.\n\t(record_store): Remove spill_alias_set, it's always zero.\n\t(check_mem_read_rtx): Likewise.\n\t(dse_step2): Rename from ...\n\t(dse_step2_nospill): ... this.  Adjust.\n\t(scan_stores): Rename from ...\n\t(scan_stores_nospill): ... this.\n\t(scan_reads): Rename from ...\n\t(scan_reads_nospill): ... this.\n\t(scan_stores_spill, scan_reads_spill): Remove.\n\t(dse_step3_scan): Remove for_spills argument which is always false.\n\t(dse_step3): Likewise.\n\t(dse_step5): Rename from ...\n\t(dse_step5_nospill): ... this.  Remove alias_set handling.\n\t(rest_of_handle_dse): Adjust.\n\nFrom-SVN: r234748", "tree": {"sha": "7bae2853b5fa3b387cb684f96be00f3b4805d77a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bae2853b5fa3b387cb684f96be00f3b4805d77a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac6929b5677230de8f6d3a3223a46bcce3f47144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6929b5677230de8f6d3a3223a46bcce3f47144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6929b5677230de8f6d3a3223a46bcce3f47144", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6929b5677230de8f6d3a3223a46bcce3f47144/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87cec93ee063f694b517bb276da4a06b73658a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87cec93ee063f694b517bb276da4a06b73658a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87cec93ee063f694b517bb276da4a06b73658a1d"}], "stats": {"total": 407, "additions": 94, "deletions": 313}, "files": [{"sha": "abd195dc4df00c2b6a7720a44c5584009f1dfc2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6929b5677230de8f6d3a3223a46bcce3f47144/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6929b5677230de8f6d3a3223a46bcce3f47144/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac6929b5677230de8f6d3a3223a46bcce3f47144", "patch": "@@ -1,3 +1,29 @@\n+2016-04-05  Richard Biener  <rguenther@suse.de>\n+\n+\t* dse.c (struct store_info): Remove alias_set member.\n+\t(struct read_info_type): Likewise.\n+\t(clear_alias_group, clear_alias_mode_table, clear_alias_mode_holder,\n+\tspill_deleted, clear_alias_set_lookup): Remove.\n+\t(get_group_info): Remove dead base == NULL_RTX case.\n+\t(dse_step0): Remove initialization of removed variables.\n+\t(delete_dead_store_insn): Reomve alias set dumping.\n+\t(free_read_records): Remove alias_set handling.\n+\t(canon_address): Remove alias_set_out parameter.\n+\t(record_store): Remove spill_alias_set, it's always zero.\n+\t(check_mem_read_rtx): Likewise.\n+\t(dse_step2): Rename from ...\n+\t(dse_step2_nospill): ... this.  Adjust.\n+\t(scan_stores): Rename from ...\n+\t(scan_stores_nospill): ... this.\n+\t(scan_reads): Rename from ...\n+\t(scan_reads_nospill): ... this.\n+\t(scan_stores_spill, scan_reads_spill): Remove.\n+\t(dse_step3_scan): Remove for_spills argument which is always false.\n+\t(dse_step3): Likewise.\n+\t(dse_step5): Rename from ...\n+\t(dse_step5_nospill): ... this.  Remove alias_set handling.\n+\t(rest_of_handle_dse): Adjust.\n+\n 2016-04-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/70525"}, {"sha": "b03616102b5137138966becb851c8058d358f42a", "filename": "gcc/dse.c", "status": "modified", "additions": 68, "deletions": 313, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6929b5677230de8f6d3a3223a46bcce3f47144/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6929b5677230de8f6d3a3223a46bcce3f47144/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=ac6929b5677230de8f6d3a3223a46bcce3f47144", "patch": "@@ -242,9 +242,6 @@ struct store_info\n   /* Canonized MEM address for use by canon_true_dependence.  */\n   rtx mem_addr;\n \n-  /* If this is non-zero, it is the alias set of a spill location.  */\n-  alias_set_type alias_set;\n-\n   /* The offset of the first and byte before the last byte associated\n      with the operation.  */\n   HOST_WIDE_INT begin, end;\n@@ -306,9 +303,6 @@ struct read_info_type\n   /* The id of the mem group of the base address.  */\n   int group_id;\n \n-  /* If this is non-zero, it is the alias set of a spill location.  */\n-  alias_set_type alias_set;\n-\n   /* The offset of the first and byte after the last byte associated\n      with the operation.  If begin == end == 0, the read did not have\n      a constant offset.  */\n@@ -576,27 +570,13 @@ static object_allocator<deferred_change> deferred_change_pool\n \n static deferred_change *deferred_change_list = NULL;\n \n-/* The group that holds all of the clear_alias_sets.  */\n-static group_info *clear_alias_group;\n-\n-/* The modes of the clear_alias_sets.  */\n-static htab_t clear_alias_mode_table;\n-\n-/* Hash table element to look up the mode for an alias set.  */\n-struct clear_alias_mode_holder\n-{\n-  alias_set_type alias_set;\n-  machine_mode mode;\n-};\n-\n /* This is true except if cfun->stdarg -- i.e. we cannot do\n    this for vararg functions because they play games with the frame.  */\n static bool stores_off_frame_dead_at_return;\n \n /* Counter for stats.  */\n static int globally_deleted;\n static int locally_deleted;\n-static int spill_deleted;\n \n static bitmap all_blocks;\n \n@@ -613,22 +593,6 @@ static unsigned int current_position;\n ----------------------------------------------------------------------------*/\n \n \n-/* Find the entry associated with ALIAS_SET.  */\n-\n-static struct clear_alias_mode_holder *\n-clear_alias_set_lookup (alias_set_type alias_set)\n-{\n-  struct clear_alias_mode_holder tmp_holder;\n-  void **slot;\n-\n-  tmp_holder.alias_set = alias_set;\n-  slot = htab_find_slot (clear_alias_mode_table, &tmp_holder, NO_INSERT);\n-  gcc_assert (*slot);\n-\n-  return (struct clear_alias_mode_holder *) *slot;\n-}\n-\n-\n /* Hashtable callbacks for maintaining the \"bases\" field of\n    store_group_info, given that the addresses are function invariants.  */\n \n@@ -665,37 +629,13 @@ get_group_info (rtx base)\n   group_info *gi;\n   group_info **slot;\n \n-  if (base)\n-    {\n-      /* Find the store_base_info structure for BASE, creating a new one\n-\t if necessary.  */\n-      tmp_gi.rtx_base = base;\n-      slot = rtx_group_table->find_slot (&tmp_gi, INSERT);\n-      gi = *slot;\n-    }\n-  else\n-    {\n-      if (!clear_alias_group)\n-\t{\n-\t  clear_alias_group = gi = group_info_pool.allocate ();\n-\t  memset (gi, 0, sizeof (struct group_info));\n-\t  gi->id = rtx_group_next_id++;\n-\t  gi->store1_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->store1_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->store2_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->store2_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->escaped_p = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->escaped_n = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->group_kill = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t  gi->process_globally = false;\n-\t  gi->offset_map_size_n = 0;\n-\t  gi->offset_map_size_p = 0;\n-\t  gi->offset_map_n = NULL;\n-\t  gi->offset_map_p = NULL;\n-\t  rtx_group_vec.safe_push (gi);\n-\t}\n-      return clear_alias_group;\n-    }\n+  gcc_assert (base != NULL_RTX);\n+\n+  /* Find the store_base_info structure for BASE, creating a new one\n+     if necessary.  */\n+  tmp_gi.rtx_base = base;\n+  slot = rtx_group_table->find_slot (&tmp_gi, INSERT);\n+  gi = *slot;\n \n   if (gi == NULL)\n     {\n@@ -732,7 +672,6 @@ dse_step0 (void)\n {\n   locally_deleted = 0;\n   globally_deleted = 0;\n-  spill_deleted = 0;\n \n   bitmap_obstack_initialize (&dse_bitmap_obstack);\n   gcc_obstack_init (&dse_obstack);\n@@ -749,8 +688,6 @@ dse_step0 (void)\n   stores_off_frame_dead_at_return = !cfun->stdarg;\n \n   init_alias_analysis ();\n-\n-  clear_alias_group = NULL;\n }\n \n \n@@ -919,15 +856,8 @@ delete_dead_store_insn (insn_info_t insn_info)\n   if (!check_for_inc_dec_1 (insn_info))\n     return;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Locally deleting insn %d \",\n-\t       INSN_UID (insn_info->insn));\n-      if (insn_info->store_rec->alias_set)\n-\tfprintf (dump_file, \"alias set %d\\n\",\n-\t\t (int) insn_info->store_rec->alias_set);\n-      else\n-\tfprintf (dump_file, \"\\n\");\n-    }\n+    fprintf (dump_file, \"Locally deleting insn %d\\n\",\n+\t     INSN_UID (insn_info->insn));\n \n   free_store_info (insn_info);\n   read_info = insn_info->read_rec;\n@@ -1057,13 +987,8 @@ free_read_records (bb_info_t bb_info)\n   while (*ptr)\n     {\n       read_info_t next = (*ptr)->next;\n-      if ((*ptr)->alias_set == 0)\n-        {\n-\t  read_info_type_pool.remove (*ptr);\n-          *ptr = next;\n-        }\n-      else\n-        ptr = &(*ptr)->next;\n+      read_info_type_pool.remove (*ptr);\n+      *ptr = next;\n     }\n }\n \n@@ -1137,7 +1062,6 @@ const_or_frame_p (rtx x)\n \n static bool\n canon_address (rtx mem,\n-\t       alias_set_type *alias_set_out,\n \t       int *group_id,\n \t       HOST_WIDE_INT *offset,\n \t       cselib_val **base)\n@@ -1147,8 +1071,6 @@ canon_address (rtx mem,\n   rtx expanded_address, address;\n   int expanded;\n \n-  *alias_set_out = 0;\n-\n   cselib_lookup (mem_address, address_mode, 1, GET_MODE (mem));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1347,7 +1269,6 @@ record_store (rtx body, bb_info_t bb_info)\n   rtx mem, rhs, const_rhs, mem_addr;\n   HOST_WIDE_INT offset = 0;\n   HOST_WIDE_INT width = 0;\n-  alias_set_type spill_alias_set;\n   insn_info_t insn_info = bb_info->last_insn;\n   store_info *store_info = NULL;\n   int group_id;\n@@ -1410,7 +1331,7 @@ record_store (rtx body, bb_info_t bb_info)\n   if (MEM_VOLATILE_P (mem))\n     insn_info->cannot_delete = true;\n \n-  if (!canon_address (mem, &spill_alias_set, &group_id, &offset, &base))\n+  if (!canon_address (mem, &group_id, &offset, &base))\n     {\n       clear_rhs_from_active_local_stores ();\n       return 0;\n@@ -1421,26 +1342,7 @@ record_store (rtx body, bb_info_t bb_info)\n   else\n     width = GET_MODE_SIZE (GET_MODE (mem));\n \n-  if (spill_alias_set)\n-    {\n-      bitmap store1 = clear_alias_group->store1_p;\n-      bitmap store2 = clear_alias_group->store2_p;\n-\n-      gcc_assert (GET_MODE (mem) != BLKmode);\n-\n-      if (!bitmap_set_bit (store1, spill_alias_set))\n-\tbitmap_set_bit (store2, spill_alias_set);\n-\n-      if (clear_alias_group->offset_map_size_p < spill_alias_set)\n-\tclear_alias_group->offset_map_size_p = spill_alias_set;\n-\n-      store_info = rtx_store_info_pool.allocate ();\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \" processing spill store %d(%s)\\n\",\n-\t\t (int) spill_alias_set, GET_MODE_NAME (GET_MODE (mem)));\n-    }\n-  else if (group_id >= 0)\n+  if (group_id >= 0)\n     {\n       /* In the restrictive case where the base is a constant or the\n \t frame pointer we can do global analysis.  */\n@@ -1506,21 +1408,16 @@ record_store (rtx body, bb_info_t bb_info)\n   last = NULL;\n   redundant_reason = NULL;\n   mem = canon_rtx (mem);\n-  /* For alias_set != 0 canon_true_dependence should be never called.  */\n-  if (spill_alias_set)\n-    mem_addr = NULL_RTX;\n+\n+  if (group_id < 0)\n+    mem_addr = base->val_rtx;\n   else\n     {\n-      if (group_id < 0)\n-\tmem_addr = base->val_rtx;\n-      else\n-\t{\n-\t  group_info *group = rtx_group_vec[group_id];\n-\t  mem_addr = group->canon_base_addr;\n-\t}\n-      if (offset)\n-\tmem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);\n+      group_info *group = rtx_group_vec[group_id];\n+      mem_addr = group->canon_base_addr;\n     }\n+  if (offset)\n+    mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);\n \n   while (ptr)\n     {\n@@ -1534,29 +1431,7 @@ record_store (rtx body, bb_info_t bb_info)\n       while (!s_info->is_set)\n \ts_info = s_info->next;\n \n-      if (s_info->alias_set != spill_alias_set)\n-\tdel = false;\n-      else if (s_info->alias_set)\n-\t{\n-\t  struct clear_alias_mode_holder *entry\n-\t    = clear_alias_set_lookup (s_info->alias_set);\n-\t  /* Generally, spills cannot be processed if and of the\n-\t     references to the slot have a different mode.  But if\n-\t     we are in the same block and mode is exactly the same\n-\t     between this store and one before in the same block,\n-\t     we can still delete it.  */\n-\t  if ((GET_MODE (mem) == GET_MODE (s_info->mem))\n-\t      && (GET_MODE (mem) == entry->mode))\n-\t    {\n-\t      del = true;\n-\t      set_all_positions_unneeded (s_info);\n-\t    }\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"    trying spill store in insn=%d alias_set=%d\\n\",\n-\t\t     INSN_UID (ptr->insn), (int) s_info->alias_set);\n-\t}\n-      else if ((s_info->group_id == group_id)\n-\t       && (s_info->cse_base == base))\n+      if (s_info->group_id == group_id && s_info->cse_base == base)\n \t{\n \t  HOST_WIDE_INT i;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1646,7 +1521,6 @@ record_store (rtx body, bb_info_t bb_info)\n   store_info->next = insn_info->store_rec;\n   insn_info->store_rec = store_info;\n   store_info->mem = mem;\n-  store_info->alias_set = spill_alias_set;\n   store_info->mem_addr = mem_addr;\n   store_info->cse_base = base;\n   if (width > HOST_BITS_PER_WIDE_INT)\n@@ -2070,7 +1944,6 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n   insn_info_t insn_info;\n   HOST_WIDE_INT offset = 0;\n   HOST_WIDE_INT width = 0;\n-  alias_set_type spill_alias_set = 0;\n   cselib_val *base = NULL;\n   int group_id;\n   read_info_t read_info;\n@@ -2092,7 +1965,7 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n   if (MEM_READONLY_P (mem))\n     return;\n \n-  if (!canon_address (mem, &spill_alias_set, &group_id, &offset, &base))\n+  if (!canon_address (mem, &group_id, &offset, &base))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \" adding wild read, canon_address failure.\\n\");\n@@ -2108,64 +1981,21 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n   read_info = read_info_type_pool.allocate ();\n   read_info->group_id = group_id;\n   read_info->mem = mem;\n-  read_info->alias_set = spill_alias_set;\n   read_info->begin = offset;\n   read_info->end = offset + width;\n   read_info->next = insn_info->read_rec;\n   insn_info->read_rec = read_info;\n-  /* For alias_set != 0 canon_true_dependence should be never called.  */\n-  if (spill_alias_set)\n-    mem_addr = NULL_RTX;\n+  if (group_id < 0)\n+    mem_addr = base->val_rtx;\n   else\n     {\n-      if (group_id < 0)\n-\tmem_addr = base->val_rtx;\n-      else\n-\t{\n-\t  group_info *group = rtx_group_vec[group_id];\n-\t  mem_addr = group->canon_base_addr;\n-\t}\n-      if (offset)\n-\tmem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);\n+      group_info *group = rtx_group_vec[group_id];\n+      mem_addr = group->canon_base_addr;\n     }\n+  if (offset)\n+    mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);\n \n-  /* We ignore the clobbers in store_info.  The is mildly aggressive,\n-     but there really should not be a clobber followed by a read.  */\n-\n-  if (spill_alias_set)\n-    {\n-      insn_info_t i_ptr = active_local_stores;\n-      insn_info_t last = NULL;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \" processing spill load %d\\n\",\n-\t\t (int) spill_alias_set);\n-\n-      while (i_ptr)\n-\t{\n-\t  store_info *store_info = i_ptr->store_rec;\n-\n-\t  /* Skip the clobbers.  */\n-\t  while (!store_info->is_set)\n-\t    store_info = store_info->next;\n-\n-\t  if (store_info->alias_set == spill_alias_set)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tdump_insn_info (\"removing from active\", i_ptr);\n-\n-\t      active_local_stores_len--;\n-\t      if (last)\n-\t\tlast->next_local_store = i_ptr->next_local_store;\n-\t      else\n-\t\tactive_local_stores = i_ptr->next_local_store;\n-\t    }\n-\t  else\n-\t    last = i_ptr;\n-\t  i_ptr = i_ptr->next_local_store;\n-\t}\n-    }\n-  else if (group_id >= 0)\n+  if (group_id >= 0)\n     {\n       /* This is the restricted case where the base is a constant or\n \t the frame pointer and offset is a constant.  */\n@@ -2293,11 +2123,10 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n \t\t\t       bb_info->regs_live))\n \t    return;\n \n-\t  if (!store_info->alias_set)\n-\t    remove = canon_true_dependence (store_info->mem,\n-\t\t\t\t\t    GET_MODE (store_info->mem),\n-\t\t\t\t\t    store_info->mem_addr,\n-\t\t\t\t\t    mem, mem_addr);\n+\t  remove = canon_true_dependence (store_info->mem,\n+\t\t\t\t\t  GET_MODE (store_info->mem),\n+\t\t\t\t\t  store_info->mem_addr,\n+\t\t\t\t\t  mem, mem_addr);\n \n \t  if (remove)\n \t    {\n@@ -2730,16 +2559,12 @@ dse_step1 (void)\n \t\t  /* Skip the clobbers.  */\n \t\t  while (!store_info->is_set)\n \t\t    store_info = store_info->next;\n-\t\t  if (store_info->alias_set && !i_ptr->cannot_delete)\n-\t\t    delete_dead_store_insn (i_ptr);\n-\t\t  else\n-\t\t    if (store_info->group_id >= 0)\n-\t\t      {\n-\t\t\tgroup_info *group\n-\t\t\t  = rtx_group_vec[store_info->group_id];\n-\t\t\tif (group->frame_related && !i_ptr->cannot_delete)\n-\t\t\t  delete_dead_store_insn (i_ptr);\n-\t\t      }\n+\t\t  if (store_info->group_id >= 0)\n+\t\t    {\n+\t\t      group_info *group = rtx_group_vec[store_info->group_id];\n+\t\t      if (group->frame_related && !i_ptr->cannot_delete)\n+\t\t\tdelete_dead_store_insn (i_ptr);\n+\t\t    }\n \n \t\t  i_ptr = i_ptr->next_local_store;\n \t\t}\n@@ -2868,10 +2693,10 @@ dse_step2_init (void)\n }\n \n \n-/* Init the offset tables for the normal case.  */\n+/* Init the offset tables.  */\n \n static bool\n-dse_step2_nospill (void)\n+dse_step2 (void)\n {\n   unsigned int i;\n   group_info *group;\n@@ -2883,9 +2708,6 @@ dse_step2_nospill (void)\n       bitmap_iterator bi;\n       unsigned int j;\n \n-      if (group == clear_alias_group)\n-\tcontinue;\n-\n       memset (group->offset_map_n, 0, sizeof (int) * group->offset_map_size_n);\n       memset (group->offset_map_p, 0, sizeof (int) * group->offset_map_size_p);\n       bitmap_clear (group->group_kill);\n@@ -2945,7 +2767,7 @@ get_bitmap_index (group_info *group_info, HOST_WIDE_INT offset)\n    may be NULL. */\n \n static void\n-scan_stores_nospill (store_info *store_info, bitmap gen, bitmap kill)\n+scan_stores (store_info *store_info, bitmap gen, bitmap kill)\n {\n   while (store_info)\n     {\n@@ -2968,35 +2790,11 @@ scan_stores_nospill (store_info *store_info, bitmap gen, bitmap kill)\n }\n \n \n-/* Process the STORE_INFOs into the bitmaps into GEN and KILL.  KILL\n-   may be NULL. */\n-\n-static void\n-scan_stores_spill (store_info *store_info, bitmap gen, bitmap kill)\n-{\n-  while (store_info)\n-    {\n-      if (store_info->alias_set)\n-\t{\n-\t  int index = get_bitmap_index (clear_alias_group,\n-\t\t\t\t\tstore_info->alias_set);\n-\t  if (index != 0)\n-\t    {\n-\t      bitmap_set_bit (gen, index);\n-\t      if (kill)\n-\t\tbitmap_clear_bit (kill, index);\n-\t    }\n-\t}\n-      store_info = store_info->next;\n-    }\n-}\n-\n-\n /* Process the READ_INFOs into the bitmaps into GEN and KILL.  KILL\n    may be NULL.  */\n \n static void\n-scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n+scan_reads (insn_info_t insn_info, bitmap gen, bitmap kill)\n {\n   read_info_t read_info = insn_info->read_rec;\n   int i;\n@@ -3086,30 +2884,6 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n     }\n }\n \n-/* Process the READ_INFOs into the bitmaps into GEN and KILL.  KILL\n-   may be NULL.  */\n-\n-static void\n-scan_reads_spill (read_info_t read_info, bitmap gen, bitmap kill)\n-{\n-  while (read_info)\n-    {\n-      if (read_info->alias_set)\n-\t{\n-\t  int index = get_bitmap_index (clear_alias_group,\n-\t\t\t\t\tread_info->alias_set);\n-\t  if (index != 0)\n-\t    {\n-\t      if (kill)\n-\t\tbitmap_set_bit (kill, index);\n-\t      bitmap_clear_bit (gen, index);\n-\t    }\n-\t}\n-\n-      read_info = read_info->next;\n-    }\n-}\n-\n \n /* Return the insn in BB_INFO before the first wild read or if there\n    are no wild reads in the block, return the last insn.  */\n@@ -3148,16 +2922,12 @@ find_insn_before_first_wild_read (bb_info_t bb_info)\n    anything that happens is hidden by the wild read.  */\n \n static void\n-dse_step3_scan (bool for_spills, basic_block bb)\n+dse_step3_scan (basic_block bb)\n {\n   bb_info_t bb_info = bb_table[bb->index];\n   insn_info_t insn_info;\n \n-  if (for_spills)\n-    /* There are no wild reads in the spill case.  */\n-    insn_info = bb_info->last_insn;\n-  else\n-    insn_info = find_insn_before_first_wild_read (bb_info);\n+  insn_info = find_insn_before_first_wild_read (bb_info);\n \n   /* In the spill case or in the no_spill case if there is no wild\n      read in the block, we will need a kill set.  */\n@@ -3178,17 +2948,8 @@ dse_step3_scan (bool for_spills, basic_block bb)\n \t this phase.  */\n       if (insn_info->insn && INSN_P (insn_info->insn))\n \t{\n-\t  /* Process the read(s) last.  */\n-\t  if (for_spills)\n-\t    {\n-\t      scan_stores_spill (insn_info->store_rec, bb_info->gen, bb_info->kill);\n-\t      scan_reads_spill (insn_info->read_rec, bb_info->gen, bb_info->kill);\n-\t    }\n-\t  else\n-\t    {\n-\t      scan_stores_nospill (insn_info->store_rec, bb_info->gen, bb_info->kill);\n-\t      scan_reads_nospill (insn_info, bb_info->gen, bb_info->kill);\n-\t    }\n+\t  scan_stores (insn_info->store_rec, bb_info->gen, bb_info->kill);\n+\t  scan_reads (insn_info, bb_info->gen, bb_info->kill);\n \t}\n \n       insn_info = insn_info->prev_insn;\n@@ -3243,7 +3004,7 @@ mark_reachable_blocks (sbitmap unreachable_blocks, basic_block bb)\n /* Build the transfer functions for the function.  */\n \n static void\n-dse_step3 (bool for_spills)\n+dse_step3 ()\n {\n   basic_block bb;\n   sbitmap unreachable_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n@@ -3266,7 +3027,7 @@ dse_step3 (bool for_spills)\n       else if (bb->index == EXIT_BLOCK)\n \tdse_step3_exit_block_scan (bb_info);\n       else\n-\tdse_step3_scan (for_spills, bb);\n+\tdse_step3_scan (bb);\n       if (EDGE_COUNT (bb->succs) == 0)\n \tmark_reachable_blocks (unreachable_blocks, bb);\n \n@@ -3467,7 +3228,7 @@ dse_step4 (void)\n \n \n static void\n-dse_step5_nospill (void)\n+dse_step5 (void)\n {\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -3502,27 +3263,21 @@ dse_step5_nospill (void)\n \t      while (!store_info->is_set)\n \t\tstore_info = store_info->next;\n \n-\t      if (store_info->alias_set)\n-\t\tdeleted = false;\n-\t      else\n+\t      HOST_WIDE_INT i;\n+\t      group_info *group_info = rtx_group_vec[store_info->group_id];\n+\n+\t      for (i = store_info->begin; i < store_info->end; i++)\n \t\t{\n-\t\t  HOST_WIDE_INT i;\n-\t\t  group_info *group_info\n-\t\t    = rtx_group_vec[store_info->group_id];\n+\t\t  int index = get_bitmap_index (group_info, i);\n \n-\t\t  for (i = store_info->begin; i < store_info->end; i++)\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"i = %d, index = %d\\n\", (int)i, index);\n+\t\t  if (index == 0 || !bitmap_bit_p (v, index))\n \t\t    {\n-\t\t      int index = get_bitmap_index (group_info, i);\n-\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"i = %d, index = %d\\n\", (int)i, index);\n-\t\t      if (index == 0 || !bitmap_bit_p (v, index))\n-\t\t\t{\n-\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t    fprintf (dump_file, \"failing at i = %d\\n\", (int)i);\n-\t\t\t  deleted = false;\n-\t\t\t  break;\n-\t\t\t}\n+\t\t\tfprintf (dump_file, \"failing at i = %d\\n\", (int)i);\n+\t\t      deleted = false;\n+\t\t      break;\n \t\t    }\n \t\t}\n \t      if (deleted)\n@@ -3543,7 +3298,7 @@ dse_step5_nospill (void)\n \t      && INSN_P (insn_info->insn)\n \t      && (!deleted))\n \t    {\n-\t      scan_stores_nospill (insn_info->store_rec, v, NULL);\n+\t      scan_stores (insn_info->store_rec, v, NULL);\n \t      if (insn_info->wild_read)\n \t\t{\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3557,7 +3312,7 @@ dse_step5_nospill (void)\n \t\t    fprintf (dump_file, \"regular read\\n\");\n                   else if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"non-frame wild read\\n\");\n-\t\t  scan_reads_nospill (insn_info, v, NULL);\n+\t\t  scan_reads (insn_info, v, NULL);\n \t\t}\n \t    }\n \n@@ -3666,23 +3421,23 @@ rest_of_handle_dse (void)\n   dse_step0 ();\n   dse_step1 ();\n   dse_step2_init ();\n-  if (dse_step2_nospill ())\n+  if (dse_step2 ())\n     {\n       df_set_flags (DF_LR_RUN_DCE);\n       df_analyze ();\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"doing global processing\\n\");\n-      dse_step3 (false);\n+      dse_step3 ();\n       dse_step4 ();\n-      dse_step5_nospill ();\n+      dse_step5 ();\n     }\n \n   dse_step6 ();\n   dse_step7 ();\n \n   if (dump_file)\n-    fprintf (dump_file, \"dse: local deletions = %d, global deletions = %d, spill deletions = %d\\n\",\n-\t     locally_deleted, globally_deleted, spill_deleted);\n+    fprintf (dump_file, \"dse: local deletions = %d, global deletions = %d\\n\",\n+\t     locally_deleted, globally_deleted);\n \n   /* DSE can eliminate potentially-trapping MEMs.\n      Remove any EH edges associated with them.  */"}]}