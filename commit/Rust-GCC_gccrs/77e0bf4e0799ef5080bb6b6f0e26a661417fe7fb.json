{"sha": "77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdlMGJmNGUwNzk5ZWY1MDgwYmI2YjZmMGUyNmE2NjE0MTdmZTdmYg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "francois.cppdevs@free.fr", "date": "2011-07-19T19:39:45Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-07-19T19:39:45Z"}, "message": "safe_unordered_base.h, [...]: New, support for unordered sequence safe local iterators.\n\n2011-07-19  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n\n        * include/debug/safe_unordered_base.h, safe_unordered_sequence.h,\n        safe_unordered_sequence.tcc, safe_local_iterator.h,\n        safe_local_iterator.tcc: New, support for unordered sequence safe\n        local iterators.\n        * include/Makefile.am: Add previous files.\n        * include/Makefile.in: Regenerate.\n        * include/debug/unordered_map, unordered_set: Implement\n        _Safe_unordered_sequence and expose _Safe_local_iterator.\n        * include/debug/safe_iterator.h, safe_iterator.tcc: Refactor\n        _Safe_iterator::_M_get_distance static method to expose it as\n        __get_distance function and use it in _Safe_local_iterator type.\n        * include/debug/formatter.h: Add __msg_local_iter_compare_bad\n        _Debug_msg_id enum entry to notify invalid comparison between local\n        iterators from different buckets. Add _Parameter constructor from\n        _Safe_local_iterator.\n        * include/debug/functions.h: Add __valid_range overload for\n        _Safe_local_iterator.\n        * src/debug.cc: Add _Safe_unordered_sequence_base and\n        _Safe_local_iterator_base methods implementations.\n        * config/abi/pre/gnu.ver: Add export of some\n        _Safe_unordered_sequence_base and _Safe_local_iterator_base methods.\n        * testsuite/util/debug/checks.h: Add use_invalid_iterator function to\n        simulate use of a singular iterator.\n        * testsuite/util/debug/unordered_checks.h: New, several functions\n        to simulate classic invalid usage of unordered sequence local\n        iterators.\n        * testsuite/23_containers/unordered_map/debug/\n        use_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n        use_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n        invalid_local_iterator_compare_neg.cc: New.\n        * testsuite/23_containers/unordered_multimap/debug/\n        use_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n        use_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n        invalid_local_iterator_compare_neg.cc: New.\n        * testsuite/23_containers/unordered_set/debug/\n        use_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n        use_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n        invalid_local_iterator_compare_neg.cc: New.\n        * testsuite/23_containers/unordered_multiset/debug/\n        use_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n        use_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n        invalid_local_iterator_compare_neg.cc: New.\n\nFrom-SVN: r176487", "tree": {"sha": "926f16c5943ea256d7196a0439c3b6482434002d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/926f16c5943ea256d7196a0439c3b6482434002d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/comments", "author": null, "committer": null, "parents": [{"sha": "78767fd9cf5581827603c154235fd36ecf075e31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78767fd9cf5581827603c154235fd36ecf075e31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78767fd9cf5581827603c154235fd36ecf075e31"}], "stats": {"total": 2709, "additions": 2519, "deletions": 190}, "files": [{"sha": "b848ce6ba358ac5f4b40819e6fd1696d15c60e07", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1,3 +1,48 @@\n+2011-07-19  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n+\n+\t* include/debug/safe_unordered_base.h, safe_unordered_sequence.h,\n+\tsafe_unordered_sequence.tcc, safe_local_iterator.h,\n+\tsafe_local_iterator.tcc: New, support for unordered sequence safe\n+\tlocal iterators.\n+\t* include/Makefile.am: Add previous files.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/debug/unordered_map, unordered_set: Implement\n+\t_Safe_unordered_sequence and expose _Safe_local_iterator.\n+\t* include/debug/safe_iterator.h, safe_iterator.tcc: Refactor\n+\t_Safe_iterator::_M_get_distance static method to expose it as\n+\t__get_distance function and use it in _Safe_local_iterator type.\n+\t* include/debug/formatter.h: Add __msg_local_iter_compare_bad\n+\t_Debug_msg_id enum entry to notify invalid comparison between local\n+\titerators from different buckets. Add _Parameter constructor from\n+\t_Safe_local_iterator.\n+\t* include/debug/functions.h: Add __valid_range overload for\n+\t_Safe_local_iterator.\n+\t* src/debug.cc: Add _Safe_unordered_sequence_base and\n+\t_Safe_local_iterator_base methods implementations.\n+\t* config/abi/pre/gnu.ver: Add export of some\n+\t_Safe_unordered_sequence_base and _Safe_local_iterator_base methods.\n+\t* testsuite/util/debug/checks.h: Add use_invalid_iterator function to\n+\tsimulate use of a singular iterator.\n+\t* testsuite/util/debug/unordered_checks.h: New, several functions\n+\tto simulate classic invalid usage of unordered sequence local\n+\titerators.\n+\t* testsuite/23_containers/unordered_map/debug/\n+\tuse_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n+\tuse_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n+\tinvalid_local_iterator_compare_neg.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/debug/\n+\tuse_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n+\tuse_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n+\tinvalid_local_iterator_compare_neg.cc: New.\n+\t* testsuite/23_containers/unordered_set/debug/\n+\tuse_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n+\tuse_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n+\tinvalid_local_iterator_compare_neg.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/debug/\n+\tuse_erased_local_iterator_neg.cc, invalid_local_iterator_range_neg.cc,\n+\tuse_invalid_local_iterator_neg.cc, use_invalid_iterator_neg.cc,\n+\tinvalid_local_iterator_compare_neg.cc: New.\n+\n 2011-07-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/48430"}, {"sha": "6c07e61fe1c9435117dc4ebc91ce336734f7f829", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1284,6 +1284,11 @@ GLIBCXX_3.4.17 {\n     # std::thread::hardware_concurrency\n     _ZNSt6thread20hardware_concurrencyEv;\n \n+    # __gnu_debug::_Safe_unordered_sequence_base and _Safe_local_iterator_base\n+    _ZN11__gnu_debug29_Safe_unordered_sequence_base7_M_swapERS0_;\n+    _ZN11__gnu_debug29_Safe_unordered_sequence_base13_M_detach_allEv;\n+    _ZN11__gnu_debug25_Safe_local_iterator_base9_M_attachEPNS_19_Safe_sequence_baseEb;\n+    _ZN11__gnu_debug25_Safe_local_iterator_base9_M_detachEv;\n } GLIBCXX_3.4.16;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "52e94cc0c42f66ad4c82f29a173770e998073179", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -701,8 +701,13 @@ debug_headers = \\\n \t${debug_srcdir}/safe_base.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n+\t${debug_srcdir}/safe_local_iterator.h \\\n+\t${debug_srcdir}/safe_local_iterator.tcc \\\n \t${debug_srcdir}/safe_sequence.h \\\n \t${debug_srcdir}/safe_sequence.tcc \\\n+\t${debug_srcdir}/safe_unordered_base.h \\\n+\t${debug_srcdir}/safe_unordered_sequence.h \\\n+\t${debug_srcdir}/safe_unordered_sequence.tcc \\\n \t${debug_srcdir}/set \\\n \t${debug_srcdir}/set.h \\\n \t${debug_srcdir}/string \\"}, {"sha": "76d4123da966c64ffd1a3ecc5dfb10122eb0cfc3", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -946,8 +946,13 @@ debug_headers = \\\n \t${debug_srcdir}/safe_base.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n+\t${debug_srcdir}/safe_local_iterator.h \\\n+\t${debug_srcdir}/safe_local_iterator.tcc \\\n \t${debug_srcdir}/safe_sequence.h \\\n \t${debug_srcdir}/safe_sequence.tcc \\\n+\t${debug_srcdir}/safe_unordered_base.h \\\n+\t${debug_srcdir}/safe_unordered_sequence.h \\\n+\t${debug_srcdir}/safe_unordered_sequence.tcc \\\n \t${debug_srcdir}/set \\\n \t${debug_srcdir}/set.h \\\n \t${debug_srcdir}/string \\"}, {"sha": "8da171972eb3fe2759ebacc9f4d9c84c03d48304", "filename": "libstdc++-v3/include/debug/formatter.h", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1,6 +1,6 @@\n // Debug-mode error formatting implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -46,6 +46,9 @@ namespace __gnu_debug\n   template<typename _Iterator, typename _Sequence>\n     class _Safe_iterator;\n \n+  template<typename _Iterator, typename _Sequence>\n+    class _Safe_local_iterator;\n+\n   template<typename _Sequence>\n     class _Safe_sequence;\n \n@@ -103,7 +106,9 @@ namespace __gnu_debug\n     // forward_list\n     __msg_insert_after_end,\n     __msg_erase_after_bad,\n-    __msg_valid_range2\n+    __msg_valid_range2,\n+    // unordered sequence local iterators\n+    __msg_local_iter_compare_bad\n   };\n \n   class _Error_formatter\n@@ -236,6 +241,42 @@ namespace __gnu_debug\n \t    }\n \t}\n \n+      template<typename _Iterator, typename _Sequence>\n+\t_Parameter(const _Safe_local_iterator<_Iterator, _Sequence>& __it,\n+\t\t   const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator),  _M_variant()\n+\t{\n+\t  _M_variant._M_iterator._M_name = __name;\n+\t  _M_variant._M_iterator._M_address = &__it;\n+#ifdef __GXX_RTTI\n+\t  _M_variant._M_iterator._M_type = &typeid(__it);\n+#else\n+\t  _M_variant._M_iterator._M_type = 0;\n+#endif\n+\t  _M_variant._M_iterator._M_constness =\n+\t    std::__are_same<_Safe_local_iterator<_Iterator, _Sequence>,\n+\t                    typename _Sequence::local_iterator>::\n+\t      __value ? __mutable_iterator : __const_iterator;\n+\t  _M_variant._M_iterator._M_sequence = __it._M_get_sequence();\n+#ifdef __GXX_RTTI\n+\t  _M_variant._M_iterator._M_seq_type = &typeid(_Sequence);\n+#else\n+\t  _M_variant._M_iterator._M_seq_type = 0;\n+#endif\n+\n+\t  if (__it._M_singular())\n+\t    _M_variant._M_iterator._M_state = __singular;\n+\t  else\n+\t    {\n+\t      if (__it._M_is_end())\n+\t\t_M_variant._M_iterator._M_state = __end;\n+\t      else if (__it._M_is_begin())\n+\t\t_M_variant._M_iterator._M_state = __begin;\n+\t      else\n+\t\t_M_variant._M_iterator._M_state = __middle;\n+\t    }\n+\t}\n+\n       template<typename _Type>\n         _Parameter(const _Type*& __it, const char* __name, _Is_iterator)\n         : _M_kind(__iterator), _M_variant()"}, {"sha": "ea12589e3c04061ec49ee5ceefdb5ba24c4b7928", "filename": "libstdc++-v3/include/debug/functions.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1,6 +1,6 @@\n // Debugging support implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -144,6 +144,13 @@ namespace __gnu_debug\n \t\t  const _Safe_iterator<_Iterator, _Sequence>& __last)\n     { return __first._M_valid_range(__last); }\n \n+  /** Safe local iterators know how to check if they form a valid range. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __valid_range(const _Safe_local_iterator<_Iterator, _Sequence>& __first,\n+\t\t  const _Safe_local_iterator<_Iterator, _Sequence>& __last)\n+    { return __first._M_valid_range(__last); }\n+\n   /* Checks that [first, last) is a valid range, and then returns\n    * __first. This routine is useful when we can't use a separate\n    * assertion statement because, e.g., we are in a constructor."}, {"sha": "016ec7b9418ca52f1cecaf7ca8a3594b21edd20e", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -62,6 +62,43 @@ namespace __gnu_debug\n   __check_singular_aux(const _Safe_iterator_base* __x)\n   { return __x->_M_singular(); }\n \n+  /** The precision to which we can calculate the distance between\n+   *  two iterators.\n+   */\n+  enum _Distance_precision\n+    {\n+      __dp_equality, //< Can compare iterator equality, only\n+      __dp_sign,     //< Can determine equality and ordering\n+      __dp_exact     //< Can determine distance precisely\n+    };\n+\n+  /** Determine the distance between two iterators with some known\n+   *\tprecision.\n+  */\n+  template<typename _Iterator1, typename _Iterator2>\n+    inline std::pair<typename std::iterator_traits<_Iterator1>::difference_type,\n+\t\t     _Distance_precision>\n+    __get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n+\t\t   std::random_access_iterator_tag)\n+    { return std::make_pair(__rhs - __lhs, __dp_exact); }\n+\n+  template<typename _Iterator1, typename _Iterator2>\n+    inline std::pair<typename std::iterator_traits<_Iterator1>::difference_type,\n+\t\t     _Distance_precision>\n+    __get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n+\t\t   std::forward_iterator_tag)\n+    { return std::make_pair(__lhs == __rhs? 0 : 1, __dp_equality); }\n+\n+  template<typename _Iterator1, typename _Iterator2>\n+    inline std::pair<typename std::iterator_traits<_Iterator1>::difference_type,\n+\t\t     _Distance_precision>\n+    __get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs)\n+    {\n+      typedef typename std::iterator_traits<_Iterator1>::iterator_category\n+\t  _Category;\n+      return __get_distance(__lhs, __rhs, _Category());\n+    }\n+\n   /** \\brief Safe iterator wrapper.\n    *\n    *  The class template %_Safe_iterator is a wrapper around an\n@@ -78,16 +115,6 @@ namespace __gnu_debug\n     {\n       typedef _Safe_iterator _Self;\n \n-      /** The precision to which we can calculate the distance between\n-       *  two iterators.\n-       */\n-      enum _Distance_precision\n-\t{\n-\t  __dp_equality, //< Can compare iterator equality, only\n-\t  __dp_sign,     //< Can determine equality and ordering\n-\t  __dp_exact     //< Can determine distance precisely\n-\t};\n-\n       /// The underlying iterator\n       _Iterator _M_current;\n \n@@ -380,30 +407,6 @@ namespace __gnu_debug\n       _M_get_sequence() const\n       { return static_cast<const _Sequence*>(_M_sequence); }\n \n-    /** Determine the distance between two iterators with some known\n-     *\tprecision.\n-    */\n-    template<typename _Iterator1, typename _Iterator2>\n-      static std::pair<difference_type, _Distance_precision>\n-      _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs)\n-      {\n-        typedef typename std::iterator_traits<_Iterator1>::iterator_category\n-\t  _Category;\n-        return _M_get_distance(__lhs, __rhs, _Category());\n-      }\n-\n-    template<typename _Iterator1, typename _Iterator2>\n-      static std::pair<difference_type, _Distance_precision>\n-      _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n-\t\t      std::random_access_iterator_tag)\n-      { return std::make_pair(__rhs - __lhs, __dp_exact); }\n-\n-    template<typename _Iterator1, typename _Iterator2>\n-      static std::pair<difference_type, _Distance_precision>\n-      _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n-\t\t    std::forward_iterator_tag)\n-      { return std::make_pair(__lhs == __rhs? 0 : 1, __dp_equality); }\n-\n       /// Is this iterator equal to the sequence's begin() iterator?\n       bool _M_is_begin() const\n       { return base() == _M_get_sequence()->_M_base().begin(); }"}, {"sha": "777a707e7f398d48db3b9ddd019d061ae0888af4", "filename": "libstdc++-v3/include/debug/safe_iterator.tcc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1,6 +1,6 @@\n // Debugging iterator implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009, 2010\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -48,7 +48,7 @@ namespace __gnu_debug\n \t{\n \t  const_iterator __begin = _M_get_sequence()->_M_base().begin();\n \t  std::pair<difference_type, _Distance_precision> __dist =\n-\t    this->_M_get_distance(__begin, base());\n+\t    __get_distance(__begin, base());\n \t  bool __ok =  ((__dist.second == __dp_exact && __dist.first >= -__n)\n \t\t\t|| (__dist.second != __dp_exact && __dist.first > 0));\n \t  return __ok;\n@@ -57,7 +57,7 @@ namespace __gnu_debug\n \t{\n \t  const_iterator __end = _M_get_sequence()->_M_base().end();\n \t  std::pair<difference_type, _Distance_precision> __dist =\n-\t    this->_M_get_distance(base(), __end);\n+\t    __get_distance(base(), __end);\n \t  bool __ok = ((__dist.second == __dp_exact && __dist.first >= __n)\n \t\t       || (__dist.second != __dp_exact && __dist.first > 0));\n \t  return __ok;\n@@ -76,7 +76,7 @@ namespace __gnu_debug\n \t/* Determine if we can order the iterators without the help of\n \t   the container */\n \tstd::pair<difference_type, _Distance_precision> __dist =\n-\t  this->_M_get_distance(base(), __rhs.base());\n+\t  __get_distance(base(), __rhs.base());\n \tswitch (__dist.second) {\n \tcase __dp_equality:\n \t  if (__dist.first == 0)"}, {"sha": "a204f28cf7fc8962e2d3f005c07149b9ae34f58f", "filename": "libstdc++-v3/include/debug/safe_local_iterator.h", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,369 @@\n+// Safe iterator implementation  -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_local_iterator.h\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_LOCAL_ITERATOR_H\n+#define _GLIBCXX_DEBUG_SAFE_LOCAL_ITERATOR_H 1\n+\n+#include <debug/debug.h>\n+#include <debug/macros.h>\n+#include <debug/functions.h>\n+#include <debug/safe_unordered_base.h>\n+#include <ext/type_traits.h>\n+\n+namespace __gnu_debug\n+{\n+  /** \\brief Safe iterator wrapper.\n+   *\n+   *  The class template %_Safe_local_iterator is a wrapper around an\n+   *  iterator that tracks the iterator's movement among sequences and\n+   *  checks that operations performed on the \"safe\" iterator are\n+   *  legal. In additional to the basic iterator operations (which are\n+   *  validated, and then passed to the underlying iterator),\n+   *  %_Safe_local_iterator has member functions for iterator invalidation,\n+   *  attaching/detaching the iterator from sequences, and querying\n+   *  the iterator's state.\n+   */\n+  template<typename _Iterator, typename _Sequence>\n+    class _Safe_local_iterator : public _Safe_local_iterator_base\n+    {\n+      typedef _Safe_local_iterator _Self;\n+      typedef typename _Sequence::size_type size_type;\n+\n+      /// The underlying iterator\n+      _Iterator _M_current;\n+\n+      /// The bucket this local iterator belongs to \n+      size_type _M_bucket;\n+\n+      /// Determine if this is a constant iterator.\n+      bool\n+      _M_constant() const\n+      {\n+\ttypedef typename _Sequence::const_local_iterator const_iterator;\n+\treturn std::__are_same<const_iterator, _Safe_local_iterator>::__value;\n+      }\n+\n+      typedef std::iterator_traits<_Iterator> _Traits;\n+\n+    public:\n+      typedef _Iterator                           iterator_type;\n+      typedef typename _Traits::iterator_category iterator_category;\n+      typedef typename _Traits::value_type        value_type;\n+      typedef typename _Traits::difference_type   difference_type;\n+      typedef typename _Traits::reference         reference;\n+      typedef typename _Traits::pointer           pointer;\n+\n+      /// @post the iterator is singular and unattached\n+      _Safe_local_iterator() : _M_current() { }\n+\n+      /**\n+       * @brief Safe iterator construction from an unsafe iterator and\n+       * its sequence.\n+       *\n+       * @pre @p seq is not NULL\n+       * @post this is not singular\n+       */\n+      _Safe_local_iterator(const _Iterator& __i, size_t __bucket,\n+\t\t\t   const _Sequence* __seq)\n+      : _Safe_local_iterator_base(__seq, _M_constant()), _M_current(__i),\n+\t_M_bucket(__bucket)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(!this->_M_singular(),\n+\t\t\t      _M_message(__msg_init_singular)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+      }\n+\n+      /**\n+       * @brief Copy construction.\n+       */\n+      _Safe_local_iterator(const _Safe_local_iterator& __x)\n+      : _Safe_local_iterator_base(__x, _M_constant()),\n+\t_M_current(__x._M_current), _M_bucket(__x._M_bucket)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// DR 408. Is vector<reverse_iterator<char*> > forbidden?\n+\t_GLIBCXX_DEBUG_VERIFY(!__x._M_singular()\n+\t\t\t      || __x._M_current == _Iterator(),\n+\t\t\t      _M_message(__msg_init_copy_singular)\n+\t\t\t      ._M_iterator(*this, \"this\")\n+\t\t\t      ._M_iterator(__x, \"other\"));\n+      }\n+\n+      /**\n+       *  @brief Converting constructor from a mutable iterator to a\n+       *  constant iterator.\n+      */\n+      template<typename _MutableIterator>\n+\t_Safe_local_iterator(\n+\t  const _Safe_local_iterator<_MutableIterator,\n+\t  typename __gnu_cxx::__enable_if<std::__are_same<\n+\t      _MutableIterator,\n+\t      typename _Sequence::local_iterator::iterator_type>::__value,\n+\t\t\t\t\t  _Sequence>::__type>& __x)\n+\t: _Safe_local_iterator_base(__x, _M_constant()),\n+\t  _M_current(__x.base()), _M_bucket(__x._M_bucket)\n+\t{\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // DR 408. Is vector<reverse_iterator<char*> > forbidden?\n+\t  _GLIBCXX_DEBUG_VERIFY(!__x._M_singular()\n+\t\t\t\t|| __x.base() == _Iterator(),\n+\t\t\t\t_M_message(__msg_init_const_singular)\n+\t\t\t\t._M_iterator(*this, \"this\")\n+\t\t\t\t._M_iterator(__x, \"other\"));\n+\t}\n+\n+      /**\n+       * @brief Copy assignment.\n+       */\n+      _Safe_local_iterator&\n+      operator=(const _Safe_local_iterator& __x)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// DR 408. Is vector<reverse_iterator<char*> > forbidden?\n+\t_GLIBCXX_DEBUG_VERIFY(!__x._M_singular()\n+\t\t\t      || __x._M_current == _Iterator(),\n+\t\t\t      _M_message(__msg_copy_singular)\n+\t\t\t      ._M_iterator(*this, \"this\")\n+\t\t\t      ._M_iterator(__x, \"other\"));\n+\t_M_current = __x._M_current;\n+\t_M_bucket = __x._M_bucket;\n+\tthis->_M_attach(__x._M_sequence);\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Iterator dereference.\n+       *  @pre iterator is dereferenceable\n+       */\n+      reference\n+      operator*() const\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_dereferenceable(),\n+\t\t\t      _M_message(__msg_bad_deref)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\treturn *_M_current;\n+      }\n+\n+      /**\n+       *  @brief Iterator dereference.\n+       *  @pre iterator is dereferenceable\n+       *  @todo Make this correct w.r.t. iterators that return proxies\n+       *  @todo Use addressof() instead of & operator\n+       */\n+      pointer\n+      operator->() const\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_dereferenceable(),\n+\t\t\t      _M_message(__msg_bad_deref)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\treturn &*_M_current;\n+      }\n+\n+      // ------ Input iterator requirements ------\n+      /**\n+       *  @brief Iterator preincrement\n+       *  @pre iterator is incrementable\n+       */\n+      _Safe_local_iterator&\n+      operator++()\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_incrementable(),\n+\t\t\t      _M_message(__msg_bad_inc)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\t++_M_current;\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Iterator postincrement\n+       *  @pre iterator is incrementable\n+       */\n+      _Safe_local_iterator\n+      operator++(int)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_incrementable(),\n+\t\t\t      _M_message(__msg_bad_inc)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\t_Safe_local_iterator __tmp(*this);\n+\t++_M_current;\n+\treturn __tmp;\n+      }\n+\n+      // ------ Utilities ------\n+      /**\n+       * @brief Return the underlying iterator\n+       */\n+      _Iterator\n+      base() const { return _M_current; }\n+\n+      /**\n+       * @brief Return the bucket\n+       */\n+      size_type\n+      bucket() const { return _M_bucket; }\n+\n+      /**\n+       * @brief Conversion to underlying non-debug iterator to allow\n+       * better interaction with non-debug containers.\n+       */\n+      operator _Iterator() const { return _M_current; }\n+\n+      /** Attach iterator to the given sequence. */\n+      void\n+      _M_attach(_Safe_sequence_base* __seq)\n+      { _Safe_iterator_base::_M_attach(__seq, _M_constant()); }\n+\n+      /** Likewise, but not thread-safe. */\n+      void\n+      _M_attach_single(_Safe_sequence_base* __seq)\n+      { _Safe_iterator_base::_M_attach_single(__seq, _M_constant()); }\n+\n+      /// Is the iterator dereferenceable?\n+      bool\n+      _M_dereferenceable() const\n+      { return !this->_M_singular() && !_M_is_end(); }\n+\n+      /// Is the iterator incrementable?\n+      bool\n+      _M_incrementable() const\n+      { return !this->_M_singular() && !_M_is_end(); }\n+\n+      // Is the iterator range [*this, __rhs) valid?\n+      template<typename _Other>\n+\tbool\n+\t_M_valid_range(const _Safe_local_iterator<_Other,\n+\t\t\t\t\t\t  _Sequence>& __rhs) const;\n+\n+      // The sequence this iterator references.\n+      const _Sequence*\n+      _M_get_sequence() const\n+      { return static_cast<const _Sequence*>(_M_sequence); }\n+\n+      /// Is this iterator equal to the sequence's begin() iterator?\n+      bool _M_is_begin() const\n+      { return base() == _M_get_sequence()->_M_base().begin(_M_bucket); }\n+\n+      /// Is this iterator equal to the sequence's end() iterator?\n+      bool _M_is_end() const\n+      { return base() == _M_get_sequence()->_M_base().end(_M_bucket); }\n+\n+      /// Is this iterator part of the same bucket as the other one?\n+      template <typename _Other>\n+\tbool _M_in_same_bucket(const _Safe_local_iterator<_Other,\n+\t\t\t\t\t\t_Sequence>& __other) const\n+\t{ return _M_bucket == __other.bucket(); }\n+    };\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator==(const _Safe_local_iterator<_IteratorL, _Sequence>& __lhs,\n+\t       const _Safe_local_iterator<_IteratorR, _Sequence>& __rhs)\n+    {\n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_in_same_bucket(__rhs),\n+\t\t\t    _M_message(__msg_local_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() == __rhs.base();\n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator==(const _Safe_local_iterator<_Iterator, _Sequence>& __lhs,\n+\t       const _Safe_local_iterator<_Iterator, _Sequence>& __rhs)\n+    {\n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_in_same_bucket(__rhs),\n+\t\t\t    _M_message(__msg_local_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() == __rhs.base();\n+    }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator!=(const _Safe_local_iterator<_IteratorL, _Sequence>& __lhs,\n+\t       const _Safe_local_iterator<_IteratorR, _Sequence>& __rhs)\n+    {\n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_in_same_bucket(__rhs),\n+\t\t\t    _M_message(__msg_local_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() != __rhs.base();\n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator!=(const _Safe_local_iterator<_Iterator, _Sequence>& __lhs,\n+\t       const _Safe_local_iterator<_Iterator, _Sequence>& __rhs)\n+    {\n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_in_same_bucket(__rhs),\n+\t\t\t    _M_message(__msg_local_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() != __rhs.base();\n+    }\n+} // namespace __gnu_debug\n+\n+#include <debug/safe_local_iterator.tcc>\n+\n+#endif"}, {"sha": "e91e6bfbf08b9f0cda86a1f1ffffc00e160e4f7e", "filename": "libstdc++-v3/include/debug/safe_local_iterator.tcc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_local_iterator.tcc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,75 @@\n+// Debugging iterator implementation (out of line) -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_locale_iterator.tcc\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_LOCAL_ITERATOR_TCC\n+#define _GLIBCXX_DEBUG_SAFE_LOCAL_ITERATOR_TCC 1\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Iterator, typename _Sequence>\n+    template<typename _Other>\n+      bool\n+      _Safe_local_iterator<_Iterator, _Sequence>::\n+      _M_valid_range(const _Safe_local_iterator<_Other, _Sequence>& __rhs) const\n+      {\n+\tif (!_M_can_compare(__rhs))\n+\t  return false;\n+\tif (_M_bucket != __rhs._M_bucket)\n+\t  return false;\n+\n+\t/* Determine if we can order the iterators without the help of\n+\t   the container */\n+\tstd::pair<difference_type, _Distance_precision> __dist =\n+\t  __get_distance(base(), __rhs.base());\n+\tswitch (__dist.second)\n+\t{\n+\tcase __dp_equality:\n+\t  if (__dist.first == 0)\n+\t    return true;\n+\t  break;\n+\n+\tcase __dp_sign:\n+\tcase __dp_exact:\n+\t  return __dist.first >= 0;\n+\t}\n+\n+\t/* We can only test for equality, but check if one of the\n+\t   iterators is at an extreme. */\n+\t/* Optim for classic [begin, it) or [it, end) ranges, limit checks\n+\t * when code is valid. */\n+\tif (_M_is_begin() || __rhs._M_is_end())\n+\t  return true;\n+\tif (_M_is_end() || __rhs._M_is_begin())\n+\t  return false;\n+\n+\t// Assume that this is a valid range; we can't check anything else\n+\treturn true;\n+      }\n+} // namespace __gnu_debug\n+\n+#endif"}, {"sha": "14d83bc49fb4ebee1827dc55eac97f98d67f4c92", "filename": "libstdc++-v3/include/debug/safe_unordered_base.h", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_base.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,175 @@\n+// Safe sequence/iterator base implementation  -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_unordered_base.h\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_UNORDERED_BASE_H\n+#define _GLIBCXX_DEBUG_SAFE_UNORDERED_BASE_H 1\n+\n+#include <debug/safe_base.h>\n+\n+namespace __gnu_debug\n+{\n+  class _Safe_unordered_sequence_base;\n+\n+  /** \\brief Basic functionality for a @a safe iterator.\n+   *\n+   *  The %_Safe_local_iterator_base base class implements the functionality\n+   *  of a safe local iterator that is not specific to a particular iterator\n+   *  type. It contains a pointer back to the sequence it references\n+   *  along with iterator version information and pointers to form a\n+   *  doubly-linked list of local iterators referenced by the container.\n+   *\n+   *  This class must not perform any operations that can throw an\n+   *  exception, or the exception guarantees of derived iterators will\n+   *  be broken.\n+   */\n+  class _Safe_local_iterator_base : public _Safe_iterator_base\n+  {\n+  protected:\n+    /** Initializes the iterator and makes it singular. */\n+    _Safe_local_iterator_base()\n+    { }\n+\n+    /** Initialize the iterator to reference the sequence pointed to\n+     *  by @p__seq. @p __constant is true when we are initializing a\n+     *  constant local iterator, and false if it is a mutable local iterator.\n+     *  Note that @p __seq may be NULL, in which case the iterator will be\n+     *  singular. Otherwise, the iterator will reference @p __seq and\n+     *  be nonsingular.\n+     */\n+    _Safe_local_iterator_base(const _Safe_sequence_base* __seq, bool __constant)\n+    { this->_M_attach(const_cast<_Safe_sequence_base*>(__seq), __constant); }\n+\n+    /** Initializes the iterator to reference the same sequence that\n+\t@p __x does. @p __constant is true if this is a constant\n+\titerator, and false if it is mutable. */\n+    _Safe_local_iterator_base(const _Safe_local_iterator_base& __x,\n+\t\t\t      bool __constant)\n+    { this->_M_attach(__x._M_sequence, __constant); }\n+\n+    _Safe_local_iterator_base&\n+    operator=(const _Safe_local_iterator_base&);\n+\n+    explicit\n+    _Safe_local_iterator_base(const _Safe_local_iterator_base&);\n+\n+    ~_Safe_local_iterator_base() { this->_M_detach(); }\n+\n+    _Safe_unordered_sequence_base*\n+    _M_get_sequence() const _GLIBCXX_NOEXCEPT;\n+\n+  public:\n+    /** Attaches this iterator to the given sequence, detaching it\n+     *\tfrom whatever sequence it was attached to originally. If the\n+     *\tnew sequence is the NULL pointer, the iterator is left\n+     *\tunattached.\n+     */\n+    void _M_attach(_Safe_sequence_base* __seq, bool __constant);\n+\n+    /** Likewise, but not thread-safe. */\n+    void _M_attach_single(_Safe_sequence_base* __seq, bool __constant) throw ();\n+\n+    /** Detach the iterator for whatever sequence it is attached to,\n+     *\tif any.\n+    */\n+    void _M_detach();\n+\n+    /** Likewise, but not thread-safe. */\n+    void _M_detach_single() throw ();\n+  };\n+\n+  /**\n+   * @brief Base class that supports tracking of local iterators that\n+   * reference an unordered sequence.\n+   *\n+   * The %_Safe_unordered_sequence_base class provides basic support for\n+   * tracking iterators into an unordered sequence. Sequences that track\n+   * iterators must derived from %_Safe_sequence_base publicly, so\n+   * that safe iterators (which inherit _Safe_iterator_base) can\n+   * attach to them. This class contains four linked lists of\n+   * iterators, one for constant iterators, one for mutable\n+   * iterators, one for constant local iterators, one for mutable local\n+   * iterator and a version number that allows very fast\n+   * invalidation of all iterators that reference the container.\n+   *\n+   * This class must ensure that no operation on it may throw an\n+   * exception, otherwise @a safe sequences may fail to provide the\n+   * exception-safety guarantees required by the C++ standard.\n+   */\n+  class _Safe_unordered_sequence_base : public _Safe_sequence_base\n+  {\n+    typedef _Safe_sequence_base _Base;\n+  public:\n+    /// The list of mutable local iterators that reference this container\n+    _Safe_iterator_base* _M_local_iterators;\n+\n+    /// The list of constant local iterators that reference this container\n+    _Safe_iterator_base* _M_const_local_iterators;\n+\n+  protected:\n+    // Initialize with a version number of 1 and no iterators\n+    _Safe_unordered_sequence_base()\n+    : _M_local_iterators(0), _M_const_local_iterators(0)\n+    { }\n+\n+    /** Notify all iterators that reference this sequence that the\n+\tsequence is being destroyed. */\n+    ~_Safe_unordered_sequence_base()\n+    { this->_M_detach_all(); }\n+\n+    /** Detach all iterators, leaving them singular. */\n+    void\n+    _M_detach_all();\n+\n+    /** Swap this sequence with the given sequence. This operation\n+     *  also swaps ownership of the iterators, so that when the\n+     *  operation is complete all iterators that originally referenced\n+     *  one container now reference the other container.\n+     */\n+    void\n+    _M_swap(_Safe_unordered_sequence_base& __x);\n+\n+  public:\n+    /** Attach an iterator to this sequence. */\n+    void\n+    _M_attach_local(_Safe_iterator_base* __it, bool __constant);\n+\n+    /** Likewise but not thread safe. */\n+    void\n+    _M_attach_local_single(_Safe_iterator_base* __it, bool __constant) throw ();\n+\n+    /** Detach an iterator from this sequence */\n+    void\n+    _M_detach_local(_Safe_iterator_base* __it);\n+\n+    /** Likewise but not thread safe. */\n+    void\n+    _M_detach_local_single(_Safe_iterator_base* __it) throw ();\n+  };\n+} // namespace __gnu_debug\n+\n+#endif"}, {"sha": "f32b9113e6f7732ecf5e7b3bad1c7981303e4811", "filename": "libstdc++-v3/include/debug/safe_unordered_sequence.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_sequence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_sequence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_sequence.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,75 @@\n+// Safe sequence implementation  -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_unordered_sequence.h\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_UNORDERED_SEQUENCE_H\n+#define _GLIBCXX_DEBUG_SAFE_UNORDERED_SEQUENCE_H 1\n+\n+#include <debug/debug.h>\n+#include <debug/macros.h>\n+#include <debug/functions.h>\n+#include <debug/safe_unordered_base.h>\n+\n+namespace __gnu_debug\n+{\n+  /**\n+   * @brief Base class for constructing a @a safe unordered sequence type\n+   * that tracks iterators that reference it.\n+   *\n+   * The class template %_Safe_unordered_sequence simplifies the\n+   * construction of @a safe unordered sequences that track the iterators\n+   * that reference the sequence, so that the iterators are notified of\n+   * changes in the sequence that may affect their operation, e.g., if\n+   * the container invalidates its iterators or is destructed. This class\n+   * template may only be used by deriving from it and passing the name\n+   * of the derived class as its template parameter via the curiously\n+   * recurring template pattern. The derived class must have @c\n+   * iterator and @const_iterator types that are instantiations of\n+   * class template _Safe_iterator for this sequence. Iterators will\n+   * then be tracked automatically.\n+   */\n+  template<typename _Sequence>\n+    class _Safe_unordered_sequence : public _Safe_unordered_sequence_base\n+    {\n+    public:\n+      /** Invalidates all iterators @c x that reference this sequence,\n+\t  are not singular, and for which @c pred(x) returns @c\n+\t  true. @c pred will be invoked with the normal iterators nested\n+\t  in the safe ones. */\n+      template<typename _Predicate>\n+\tvoid\n+\t_M_invalidate_if(_Predicate __pred);\n+\n+      template<typename _Predicate>\n+\tvoid\n+\t_M_invalidate_local_if(_Predicate __pred);\n+    };\n+} // namespace __gnu_debug\n+\n+#include <debug/safe_unordered_sequence.tcc>\n+\n+#endif"}, {"sha": "88907e8839de2f1467bbe93828271a83cffcd82e", "filename": "libstdc++-v3/include/debug/safe_unordered_sequence.tcc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_sequence.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_sequence.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_sequence.tcc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,100 @@\n+// Safe sequence implementation  -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_unordered_sequence.tcc\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_UNORDERED_SEQUENCE_TCC\n+#define _GLIBCXX_DEBUG_SAFE_UNORDERED_SEQUENCE_TCC 1\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Sequence>\n+    template<typename _Predicate>\n+      void\n+      _Safe_unordered_sequence<_Sequence>::\n+      _M_invalidate_if(_Predicate __pred)\n+      {\n+\ttypedef typename _Sequence::iterator iterator;\n+\ttypedef typename _Sequence::const_iterator const_iterator;\n+\n+\t__gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n+\tfor (_Safe_iterator_base* __iter = _M_iterators; __iter;)\n+\t  {\n+\t    iterator* __victim = static_cast<iterator*>(__iter);\n+\t    __iter = __iter->_M_next;\n+\t    if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t      {\n+\t\t__victim->_M_invalidate();\n+\t      }\n+\t  }\n+\n+\tfor (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n+\t  {\n+\t    const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n+\t    __iter2 = __iter2->_M_next;\n+\t    if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t      {\n+\t\t__victim->_M_invalidate();\n+\t      }\n+\t  }\n+      }\n+\n+\n+  template<typename _Sequence>\n+    template<typename _Predicate>\n+      void\n+      _Safe_unordered_sequence<_Sequence>::\n+      _M_invalidate_local_if(_Predicate __pred)\n+      {\n+\ttypedef typename _Sequence::local_iterator local_iterator;\n+\ttypedef typename _Sequence::const_local_iterator const_local_iterator;\n+\n+\t__gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n+\tfor (_Safe_iterator_base* __iter = _M_local_iterators; __iter;)\n+\t  {\n+\t    local_iterator* __victim = static_cast<local_iterator*>(__iter);\n+\t    __iter = __iter->_M_next;\n+\t    if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t      {\n+\t\t__victim->_M_invalidate();\n+\t      }\n+\t  }\n+\n+\tfor (_Safe_iterator_base* __iter2 = _M_const_local_iterators; __iter2;)\n+\t  {\n+\t    const_local_iterator* __victim =\n+\t      static_cast<const_local_iterator*>(__iter2);\n+\t    __iter2 = __iter2->_M_next;\n+\t    if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t      {\n+\t\t__victim->_M_invalidate();\n+\t      }\n+\t  }\n+      }\n+\n+} // namespace __gnu_debug\n+\n+#endif"}, {"sha": "93ce517b1f7e35114282ba287731261a884c77b3", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 240, "deletions": 60, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -35,8 +35,9 @@\n #else\n # include <unordered_map>\n \n-#include <debug/safe_sequence.h>\n+#include <debug/safe_unordered_sequence.h>\n #include <debug/safe_iterator.h>\n+#include <debug/safe_local_iterator.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -49,15 +50,16 @@ namespace __debug\n \t   typename _Alloc = std::allocator<_Key> >\n     class unordered_map\n     : public _GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<unordered_map<_Key, _Tp, _Hash,\n-\t\t\t\t\t\t       _Pred, _Alloc> >\n+      public __gnu_debug::_Safe_unordered_sequence<unordered_map<_Key, _Tp,\n+\t\t\t\t\t\t\t_Hash, _Pred, _Alloc> >\n     {\n       typedef _GLIBCXX_STD_C::unordered_map<_Key, _Tp, _Hash,\n \t\t\t\t\t    _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_sequence<unordered_map> _Safe_base;\n+      typedef __gnu_debug::_Safe_unordered_sequence<unordered_map> _Safe_base;\n       typedef typename _Base::const_iterator _Base_const_iterator;\n       typedef typename _Base::iterator _Base_iterator;\n-      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n+      typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n+      typedef typename _Base::local_iterator _Base_local_iterator;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -72,6 +74,10 @@ namespace __debug\n \t\t\t\t\t  unordered_map> iterator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_map> const_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<_Base_local_iterator,\n+\t\t\t\t\t  unordered_map> local_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<_Base_const_local_iterator,\n+\t\t\t\t\t  unordered_map> const_local_iterator;\n \n       explicit\n       unordered_map(size_type __n = 10,\n@@ -81,7 +87,7 @@ namespace __debug\n       : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-        unordered_map(_InputIterator __first, _InputIterator __last, \n+\tunordered_map(_InputIterator __first, _InputIterator __last, \n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(), \n \t\t      const key_equal& __eql = key_equal(), \n@@ -176,59 +182,93 @@ namespace __debug\n       { return const_iterator(_Base::end(), this); }\n \n       // local versions\n-      using _Base::begin;\n-      using _Base::end;\n-      using _Base::cbegin;\n-      using _Base::cend;\n+      local_iterator\n+      begin(size_type __b)\n+      { return local_iterator(_Base::begin(__b), __b, this); }\n+\n+      local_iterator\n+      end(size_type __b)\n+      { return local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      begin(size_type __b) const\n+      { return const_local_iterator(_Base::begin(__b), __b, this); }\n+\n+      const_local_iterator\n+      end(size_type __b) const\n+      { return const_local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      cbegin(size_type __b) const\n+      { return const_local_iterator(_Base::cbegin(__b), __b, this); }\n+\n+      const_local_iterator\n+      cend(size_type __b) const\n+      { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n+\tsize_type __bucket_count = this->bucket_count();\n \tstd::pair<_Base_iterator, bool> __res = _Base::insert(__obj);\n+\t_M_check_rehashed(__bucket_count);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), __obj), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__hint.base(), __obj); \n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n       }\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_convertible<_Pair,\n \t\t\t\t\t\t  value_type>::value>::type>\n-        std::pair<iterator, bool>\n-        insert(_Pair&& __obj)\n-        {\n+\tstd::pair<iterator, bool>\n+\tinsert(_Pair&& __obj)\n+\t{\n+\t  size_type __bucket_count = this->bucket_count();\n \t  std::pair<_Base_iterator, bool> __res =\n \t    _Base::insert(std::forward<_Pair>(__obj));\n+\t  _M_check_rehashed(__bucket_count);\n \t  return std::make_pair(iterator(__res.first, this), __res.second);\n \t}\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_convertible<_Pair,\n \t\t\t\t\t\t  value_type>::value>::type>\n-        iterator\n-        insert(const_iterator __hint, _Pair&& __obj)\n-        {\n+\titerator\n+\tinsert(const_iterator __hint, _Pair&& __obj)\n+\t{\n \t  __glibcxx_check_insert(__hint);\n-\t  return iterator(_Base::insert(__hint.base(),\n-\t\t\t\t\tstd::forward<_Pair>(__obj)),\n-\t\t\t  this);\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it =\n+\t    _Base::insert(__hint.base(), std::forward<_Pair>(__obj));\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n \t}\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { _Base::insert(__l); }\n+      {\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base::insert(__l);\n+\t_M_check_rehashed(__bucket_count);\n+      }\n \n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n+\t  size_type __bucket_count = this->bucket_count();\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n+\t  _M_check_rehashed(__bucket_count);\n \t}\n \n       iterator\n@@ -264,8 +304,15 @@ namespace __debug\n \t_Base_iterator __victim(_Base::find(__key));\n \tif (__victim != _Base::end())\n \t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t\t\t    { return __it == __victim; });\n+\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_victim; });\n+\t    size_type __bucket_count = this->bucket_count();\n \t    _Base::erase(__victim);\n+\t    _M_check_rehashed(__bucket_count);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -275,8 +322,17 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\tthis->_M_invalidate_if(_Equal(__it.base()));\n-\treturn iterator(_Base::erase(__it.base()), this);\n+\t_Base_const_iterator __victim = __it.base();\n+\tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t\t\t{ return __it == __victim; });\n+\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it == __local_victim; });\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__it.base()); \n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__next, this);\n       }\n \n       iterator\n@@ -290,10 +346,17 @@ namespace __debug\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n+\t\t\t    { return __it == __tmp; });\n+\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_tmp; });\n \t  }\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__first.base(), __last.base());\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__next, this);\n       }\n \n       _Base&\n@@ -303,12 +366,38 @@ namespace __debug\n       _M_base() const noexcept { return *this; }\n \n     private:\n+      void\n+      _M_invalidate_locals()\n+      {\n+\t_Base_local_iterator __local_end = _Base::end(0);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_end](_Base_const_local_iterator __it)\n+\t\t\t{ return __it != __local_end; });\n+      }\n+\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n+\t_Base_iterator __end = _Base::end();\n+\tthis->_M_invalidate_if([__end](_Base_const_iterator __it)\n+\t\t\t{ return __it != __end; });\n+\t_M_invalidate_locals();\n       }\n+\n+      void\n+      _M_check_rehashed(size_type __prev_count)\n+      {\n+\tif (__prev_count != this->bucket_count())\n+\t  _M_invalidate_locals();\n+      }\n+\n+      static _Base_local_iterator\n+      _S_to_local(_Base_iterator __it)\n+      { return _Base_local_iterator(__it._M_cur_node); }\n+\n+      static _Base_const_local_iterator\n+      _S_to_local(_Base_const_iterator __it)\n+      { return _Base_const_local_iterator(__it._M_cur_node); }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,\n@@ -341,15 +430,17 @@ namespace __debug\n     class unordered_multimap\n     : public _GLIBCXX_STD_C::unordered_multimap<_Key, _Tp, _Hash,\n \t\t\t\t\t\t_Pred, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<unordered_multimap<_Key, _Tp, _Hash,\n-\t\t\t\t\t\t\t    _Pred, _Alloc> >\n+      public __gnu_debug::_Safe_unordered_sequence<unordered_multimap<_Key,\n+\t\t\t\t\t\t_Tp, _Hash, _Pred, _Alloc> >\n     {\n       typedef _GLIBCXX_STD_C::unordered_multimap<_Key, _Tp, _Hash,\n \t\t\t\t\t\t _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_sequence<unordered_multimap> _Safe_base;\n+      typedef __gnu_debug::_Safe_unordered_sequence<unordered_multimap>\n+\t_Safe_base;\n       typedef typename _Base::const_iterator _Base_const_iterator;\n       typedef typename _Base::iterator _Base_iterator;\n-      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n+      typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n+      typedef typename _Base::local_iterator _Base_local_iterator;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -364,6 +455,10 @@ namespace __debug\n \t\t\t\t\t  unordered_multimap> iterator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_multimap> const_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_local_iterator, unordered_multimap> local_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_const_local_iterator, unordered_multimap> const_local_iterator;\n \n       explicit\n       unordered_multimap(size_type __n = 10,\n@@ -373,7 +468,7 @@ namespace __debug\n       : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-        unordered_multimap(_InputIterator __first, _InputIterator __last, \n+\tunordered_multimap(_InputIterator __first, _InputIterator __last, \n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(), \n \t\t\t   const key_equal& __eql = key_equal(), \n@@ -468,28 +563,60 @@ namespace __debug\n       { return const_iterator(_Base::end(), this); }\n \n       // local versions\n-      using _Base::begin;\n-      using _Base::end;\n-      using _Base::cbegin;\n-      using _Base::cend;\n+      local_iterator\n+      begin(size_type __b)\n+      { return local_iterator(_Base::begin(__b), __b, this); }\n+\n+      local_iterator\n+      end(size_type __b)\n+      { return local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      begin(size_type __b) const\n+      { return const_local_iterator(_Base::begin(__b), __b, this); }\n+\n+      const_local_iterator\n+      end(size_type __b) const\n+      { return const_local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      cbegin(size_type __b) const\n+      { return const_local_iterator(_Base::cbegin(__b), __b, this); }\n+\n+      const_local_iterator\n+      cend(size_type __b) const\n+      { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n       iterator\n       insert(const value_type& __obj)\n-      { return iterator(_Base::insert(__obj), this); }\n+      {\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__obj);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n+      }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), __obj), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n       }\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_convertible<_Pair,\n \t\t\t\t\t\t  value_type>::value>::type>\n-        iterator\n-        insert(_Pair&& __obj)\n-        { return iterator(_Base::insert(std::forward<_Pair>(__obj)), this); }\n+\titerator\n+\tinsert(_Pair&& __obj)\n+\t{\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it = _Base::insert(std::forward<_Pair>(__obj));\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_convertible<_Pair,\n@@ -498,22 +625,26 @@ namespace __debug\n \tinsert(const_iterator __hint, _Pair&& __obj)\n \t{\n \t  __glibcxx_check_insert(__hint);\n-\t  return iterator(_Base::insert(__hint.base(),\n-\t\t\t\t\tstd::forward<_Pair>(__obj)),\n-\t\t\t  this);\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it =\n+\t    _Base::insert(__hint.base(), std::forward<_Pair>(__obj));\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n \t}\n \n       void\n       insert(std::initializer_list<value_type> __l)\n       { _Base::insert(__l); }\n \n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n+\t  size_type __bucket_count = this->bucket_count();\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n+\t  _M_check_rehashed(__bucket_count);\n \t}\n \n       iterator\n@@ -546,23 +677,39 @@ namespace __debug\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n+\tsize_type __bucket_count = this->bucket_count();\n \tstd::pair<_Base_iterator, _Base_iterator> __pair =\n \t  _Base::equal_range(__key);\n \tfor (_Base_iterator __victim = __pair.first; __victim != __pair.second;)\n \t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t\t\t    { return __it == __victim; });\n+\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_victim; });\n \t    _Base::erase(__victim++);\n \t    ++__ret;\n \t  }\n+\t_M_check_rehashed(__bucket_count);\n \treturn __ret;\n       }\n \n       iterator\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\tthis->_M_invalidate_if(_Equal(__it.base()));\n-\treturn iterator(_Base::erase(__it.base()), this);\n+\t_Base_const_iterator __victim = __it.base();\n+\tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t\t\t{ return __it == __victim; });\n+\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it == __local_victim; });\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__it.base());\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__next, this);\n       }\n \n       iterator\n@@ -576,10 +723,17 @@ namespace __debug\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n+\t\t\t    { return __it == __tmp; });\n+\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_tmp; });\n \t  }\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__first.base(), __last.base());\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__next, this);\n       }\n \n       _Base&\n@@ -589,12 +743,38 @@ namespace __debug\n       _M_base() const noexcept { return *this; }\n \n     private:\n+      void\n+      _M_invalidate_locals()\n+      {\n+\t_Base_local_iterator __local_end = _Base::end(0);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_end](_Base_const_local_iterator __it)\n+\t\t\t{ return __it != __local_end; });\n+      }\n+\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n+\t_Base_iterator __end = _Base::end();\n+\tthis->_M_invalidate_if([__end](_Base_const_iterator __it)\n+\t\t\t{ return __it != __end; });\n+\t_M_invalidate_locals();\n       }\n+\n+      void\n+      _M_check_rehashed(size_type __prev_count)\n+      {\n+\tif (__prev_count != this->bucket_count())\n+\t  _M_invalidate_locals();\n+      }\n+\n+      static _Base_local_iterator\n+      _S_to_local(_Base_iterator __it)\n+      { return _Base_local_iterator(__it._M_cur_node); }\n+\n+      static _Base_const_local_iterator\n+      _S_to_local(_Base_const_iterator __it)\n+      { return _Base_const_local_iterator(__it._M_cur_node); }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,"}, {"sha": "981db4a83e6914965b693dcc6e63f853fb54acd8", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 229, "deletions": 45, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -35,8 +35,9 @@\n #else\n # include <unordered_set>\n \n-#include <debug/safe_sequence.h>\n+#include <debug/safe_unordered_sequence.h>\n #include <debug/safe_iterator.h>\n+#include <debug/safe_local_iterator.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -49,15 +50,16 @@ namespace __debug\n \t   typename _Alloc = std::allocator<_Value> >\n     class unordered_set\n     : public _GLIBCXX_STD_C::unordered_set<_Value, _Hash, _Pred, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<unordered_set<_Value, _Hash,\n+      public __gnu_debug::_Safe_unordered_sequence<unordered_set<_Value, _Hash,\n \t\t\t\t\t\t       _Pred, _Alloc> >\n     {\n       typedef _GLIBCXX_STD_C::unordered_set<_Value, _Hash,\n \t\t\t\t\t    _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_sequence<unordered_set> _Safe_base;\n+      typedef __gnu_debug::_Safe_unordered_sequence<unordered_set> _Safe_base;\n       typedef typename _Base::const_iterator _Base_const_iterator;\n       typedef typename _Base::iterator _Base_iterator;\n-      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n+      typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n+      typedef typename _Base::local_iterator _Base_local_iterator;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -72,6 +74,10 @@ namespace __debug\n \t\t\t\t\t  unordered_set> iterator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_set> const_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<_Base_local_iterator,\n+\t\t\t\t\t  unordered_set> local_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<_Base_const_local_iterator,\n+\t\t\t\t\t  unordered_set> const_local_iterator;\n \n       explicit\n       unordered_set(size_type __n = 10,\n@@ -176,52 +182,87 @@ namespace __debug\n       { return const_iterator(_Base::end(), this); }\n \n       // local versions\n-      using _Base::begin;\n-      using _Base::end;\n-      using _Base::cbegin;\n-      using _Base::cend;\n+      local_iterator\n+      begin(size_type __b)\n+      { return local_iterator(_Base::begin(__b), __b, this); }\n+\n+      local_iterator\n+      end(size_type __b)\n+      { return local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      begin(size_type __b) const\n+      { return const_local_iterator(_Base::begin(__b), __b, this); }\n+\n+      const_local_iterator\n+      end(size_type __b) const\n+      { return const_local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      cbegin(size_type __b) const\n+      { return const_local_iterator(_Base::cbegin(__b), __b, this); }\n+\n+      const_local_iterator\n+      cend(size_type __b) const\n+      { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n+\tsize_type __bucket_count = this->bucket_count();\n \ttypedef std::pair<_Base_iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(__obj);\n+\t  __pair_type __res = _Base::insert(__obj);\n+\t_M_check_rehashed(__bucket_count);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), __obj), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n       }\n \n       std::pair<iterator, bool>\n       insert(value_type&& __obj)\n       {\n+\tsize_type __bucket_count = this->bucket_count();\n \ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(std::move(__obj));\n+\t  __pair_type __res = _Base::insert(std::move(__obj));\n+\t_M_check_rehashed(__bucket_count);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n \n       iterator\n       insert(const_iterator __hint, value_type&& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), std::move(__obj)), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__hint.base(), std::move(__obj));\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n       }\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { _Base::insert(__l); }\n+      {\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base::insert(__l);\n+\t_M_check_rehashed(__bucket_count);\n+      }\n \n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n+\t  size_type __bucket_count = this->bucket_count();\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n+\t  _M_check_rehashed(__bucket_count);\n \t}\n \n       iterator\n@@ -257,8 +298,16 @@ namespace __debug\n \t_Base_iterator __victim(_Base::find(__key));\n \tif (__victim != _Base::end())\n \t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    this->_M_invalidate_if(\n+\t\t\t    [__victim](_Base_const_iterator __it)\n+\t\t\t    { return __it == __victim; });\n+\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_victim; });\n+\t    size_type __bucket_count = this->bucket_count();\n \t    _Base::erase(__victim);\n+\t    _M_check_rehashed(__bucket_count);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -268,8 +317,18 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\tthis->_M_invalidate_if(_Equal(__it.base()));\n-\treturn iterator(_Base::erase(__it.base()), this);\n+\t_Base_const_iterator __victim = __it.base();\n+\tthis->_M_invalidate_if(\n+\t\t\t[__victim](_Base_const_iterator __it)\n+\t\t\t{ return __it == __victim; });\n+\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it == __local_victim; });\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__it.base());\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__next, this);\n       }\n \n       iterator\n@@ -283,10 +342,19 @@ namespace __debug\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t    this->_M_invalidate_if(\n+\t\t\t    [__tmp](_Base_const_iterator __it)\n+\t\t\t    { return __it == __tmp; });\n+\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_tmp; });\n \t  }\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__first.base(),\n+\t\t\t\t\t     __last.base());\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__next, this);\n       }\n \n       _Base&\n@@ -296,12 +364,39 @@ namespace __debug\n       _M_base() const noexcept { return *this; }\n \n     private:\n+      void\n+      _M_invalidate_locals()\n+      {\n+\t_Base_local_iterator __local_end = _Base::end(0);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_end](_Base_const_local_iterator __it)\n+\t\t\t{ return __it != __local_end; });\n+      }\n+\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n+\t_Base_iterator __end = _Base::end();\n+\tthis->_M_invalidate_if(\n+\t\t\t[__end](_Base_const_iterator __it)\n+\t\t\t{ return __it != __end; });\n+\t_M_invalidate_locals();\n+      }\n+\n+      void\n+      _M_check_rehashed(size_type __prev_count)\n+      {\n+\tif (__prev_count != this->bucket_count())\n+\t  _M_invalidate_locals();\n       }\n+\n+      static _Base_local_iterator\n+      _S_to_local(_Base_iterator __it)\n+      { return _Base_local_iterator(__it._M_cur_node); }\n+\n+      static _Base_const_local_iterator\n+      _S_to_local(_Base_const_iterator __it)\n+      { return _Base_const_local_iterator(__it._M_cur_node); }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n@@ -330,15 +425,17 @@ namespace __debug\n \t   typename _Alloc = std::allocator<_Value> >\n     class unordered_multiset\n     : public _GLIBCXX_STD_C::unordered_multiset<_Value, _Hash, _Pred, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<unordered_multiset<_Value, _Hash,\n-\t\t\t\t\t\t\t    _Pred, _Alloc> >\n+      public __gnu_debug::_Safe_unordered_sequence<\n+\t\tunordered_multiset<_Value, _Hash, _Pred, _Alloc> >\n     {\n       typedef _GLIBCXX_STD_C::unordered_multiset<_Value, _Hash,\n \t\t\t\t\t\t _Pred, _Alloc> _Base;\n-      typedef __gnu_debug::_Safe_sequence<unordered_multiset> _Safe_base;\n+      typedef __gnu_debug::_Safe_unordered_sequence<unordered_multiset>\n+\t\t_Safe_base;\n       typedef typename _Base::const_iterator _Base_const_iterator;\n       typedef typename _Base::iterator _Base_iterator;\n-      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n+      typedef typename _Base::const_local_iterator _Base_const_local_iterator;\n+      typedef typename _Base::local_iterator _Base_local_iterator;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -353,6 +450,10 @@ namespace __debug\n \t\t\t\t\t  unordered_multiset> iterator;\n       typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_multiset> const_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_local_iterator, unordered_multiset> local_iterator;\n+      typedef __gnu_debug::_Safe_local_iterator<\n+\t_Base_const_local_iterator, unordered_multiset> const_local_iterator;\n \n       explicit\n       unordered_multiset(size_type __n = 10,\n@@ -457,44 +558,85 @@ namespace __debug\n       { return const_iterator(_Base::end(), this); }\n \n       // local versions\n-      using _Base::begin;\n-      using _Base::end;\n-      using _Base::cbegin;\n-      using _Base::cend;\n+      local_iterator\n+      begin(size_type __b)\n+      { return local_iterator(_Base::begin(__b), __b, this); }\n+\n+      local_iterator\n+      end(size_type __b)\n+      { return local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      begin(size_type __b) const\n+      { return const_local_iterator(_Base::begin(__b), __b, this); }\n+\n+      const_local_iterator\n+      end(size_type __b) const\n+      { return const_local_iterator(_Base::end(__b), __b, this); }\n+\n+      const_local_iterator\n+      cbegin(size_type __b) const\n+      { return const_local_iterator(_Base::cbegin(__b), __b, this); }\n+\n+      const_local_iterator\n+      cend(size_type __b) const\n+      { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n       iterator\n       insert(const value_type& __obj)\n-      { return iterator(_Base::insert(__obj), this); }\n+      {\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__obj);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n+      }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), __obj), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__hint.base(), __obj); \n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n       }\n \n       iterator\n       insert(value_type&& __obj)\n-      { return iterator(_Base::insert(std::move(__obj)), this); }\n+      {\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(std::move(__obj)); \n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n+      }\n \n       iterator\n       insert(const_iterator __hint, value_type&& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), std::move(__obj)), this);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __it = _Base::insert(__hint.base(), std::move(__obj)); \n+\t_M_check_rehashed(__bucket_count);\n+\treturn iterator(__it, this);\n       }\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { _Base::insert(__l); }\n+      {\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base::insert(__l);\n+\t_M_check_rehashed(__bucket_count);\n+      }\n \n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  __glibcxx_check_valid_range(__first, __last);\n+\t  size_type __bucket_count = this->bucket_count();\n \t  _Base::insert(__gnu_debug::__base(__first),\n \t\t\t__gnu_debug::__base(__last));\n+\t  _M_check_rehashed(__bucket_count);\n \t}\n \n       iterator\n@@ -531,7 +673,12 @@ namespace __debug\n \t  _Base::equal_range(__key);\n \tfor (_Base_iterator __victim = __pair.first; __victim != __pair.second;)\n \t  {\n-\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t\t\t    { return __it == __victim; });\n+\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_victim; });\n \t    _Base::erase(__victim++);\n \t    ++__ret;\n \t  }\n@@ -542,7 +689,13 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\tthis->_M_invalidate_if(_Equal(__it.base()));\n+\t_Base_const_iterator __victim = __it.base();\n+\tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t\t\t{ return __it == __victim; });\n+\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it == __local_victim; });\n \treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n@@ -557,7 +710,12 @@ namespace __debug\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n+\t\t\t    { return __it == __tmp; });\n+\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n+\t    this->_M_invalidate_local_if(\n+\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it == __local_tmp; });\n \t  }\n \treturn iterator(_Base::erase(__first.base(),\n \t\t\t\t     __last.base()), this);\n@@ -570,12 +728,38 @@ namespace __debug\n       _M_base() const noexcept { return *this; }\n \n     private:\n+      void\n+      _M_invalidate_locals()\n+      {\n+\t_Base_local_iterator __local_end = _Base::end(0);\n+\tthis->_M_invalidate_local_if(\n+\t\t\t[__local_end](_Base_const_local_iterator __it)\n+\t\t\t{ return __it != __local_end; });\n+      }\n+\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n+\t_Base_iterator __end = _Base::end();\n+\tthis->_M_invalidate_if([__end](_Base_const_iterator __it)\n+\t\t\t{ return __it != __end; });\n+\t_M_invalidate_locals();\n+      }\n+\n+      void\n+      _M_check_rehashed(size_type __prev_count)\n+      {\n+\tif (__prev_count != this->bucket_count())\n+\t  _M_invalidate_locals();\n       }\n+\n+      static _Base_local_iterator\n+      _S_to_local(_Base_iterator __it)\n+      { return _Base_local_iterator(__it._M_cur_node); }\n+\n+      static _Base_const_local_iterator\n+      _S_to_local(_Base_const_iterator __it)\n+      { return _Base_const_local_iterator(__it._M_cur_node); }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>"}, {"sha": "1144c697e0d3634279ebfec2f9da4c165adcd41c", "filename": "libstdc++-v3/src/debug.cc", "status": "modified", "additions": 197, "deletions": 32, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1,7 +1,7 @@\n // Debugging mode support code -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+// 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -25,7 +25,9 @@\n \n #include <debug/debug.h>\n #include <debug/safe_sequence.h>\n+#include <debug/safe_unordered_sequence.h>\n #include <debug/safe_iterator.h>\n+#include <debug/safe_local_iterator.h>\n #include <algorithm>\n #include <cassert>\n #include <cstring>\n@@ -51,28 +53,58 @@ namespace\n   }\n \n   void\n-  swap_seq(__gnu_debug::_Safe_sequence_base& __lhs,\n-\t   __gnu_debug::_Safe_sequence_base& __rhs)\n+  swap_its(__gnu_debug::_Safe_sequence_base& __lhs,\n+\t   __gnu_debug::_Safe_iterator_base*& __lhs_its,\n+\t   __gnu_debug::_Safe_sequence_base& __rhs,\n+\t   __gnu_debug::_Safe_iterator_base*& __rhs_its)\n   {\n-    swap(__lhs._M_iterators, __rhs._M_iterators);\n-    swap(__lhs._M_const_iterators, __rhs._M_const_iterators);\n-    swap(__lhs._M_version, __rhs._M_version);\n+    swap(__lhs_its, __rhs_its);\n     __gnu_debug::_Safe_iterator_base* __iter;\n-    for (__iter = __rhs._M_iterators; __iter; __iter = __iter->_M_next)\n-      __iter->_M_sequence = &__rhs;\n-    for (__iter = __lhs._M_iterators; __iter; __iter = __iter->_M_next)\n-      __iter->_M_sequence = &__lhs;\n-    for (__iter = __rhs._M_const_iterators; __iter; __iter = __iter->_M_next)\n+    for (__iter = __rhs_its; __iter; __iter = __iter->_M_next)\n       __iter->_M_sequence = &__rhs;\n-    for (__iter = __lhs._M_const_iterators; __iter; __iter = __iter->_M_next)\n+    for (__iter = __lhs_its; __iter; __iter = __iter->_M_next)\n       __iter->_M_sequence = &__lhs;\n   }\n+\n+  void\n+  swap_seq(__gnu_debug::_Safe_sequence_base& __lhs,\n+\t   __gnu_debug::_Safe_sequence_base& __rhs)\n+  {\n+    swap(__lhs._M_version, __rhs._M_version);\n+    swap_its(__lhs, __lhs._M_iterators,\n+\t     __rhs, __rhs._M_iterators);\n+    swap_its(__lhs, __lhs._M_const_iterators,\n+\t     __rhs, __rhs._M_const_iterators);\n+  }\n+\n+  void\n+  swap_useq(__gnu_debug::_Safe_unordered_sequence_base& __lhs,\n+\t    __gnu_debug::_Safe_unordered_sequence_base& __rhs)\n+  {\n+    swap_seq(__lhs, __rhs);\n+    swap_its(__lhs, __lhs._M_local_iterators,\n+\t     __rhs, __rhs._M_local_iterators);\n+    swap_its(__lhs, __lhs._M_const_local_iterators,\n+\t     __rhs, __rhs._M_const_local_iterators);\n+  }\n+\n+  void\n+  detach_all(__gnu_debug::_Safe_iterator_base* __iter)\n+  {\n+    for (; __iter;)\n+      {\n+\t__gnu_debug::_Safe_iterator_base* __old = __iter;\n+\t__iter = __iter->_M_next;\n+\t__old->_M_reset();\n+      }\n+  }\n } // anonymous namespace\n \n namespace __gnu_debug\n {\n   const char* _S_debug_messages[] = \n   {\n+    // General Checks\n     \"function requires a valid iterator range [%1.name;, %2.name;)\",\n     \"attempt to insert into container with a singular iterator\",\n     \"attempt to insert into container with an iterator\"\n@@ -93,15 +125,18 @@ namespace __gnu_debug\n     \"elements in iterator range [%1.name;, %2.name;) do not form a heap\",\n     \"elements in iterator range [%1.name;, %2.name;)\"\n     \" do not form a heap with respect to the predicate %3;\",\n+    // std::bitset checks\n     \"attempt to write through a singular bitset reference\",\n     \"attempt to read from a singular bitset reference\",\n     \"attempt to flip a singular bitset reference\",\n+    // std::list checks\n     \"attempt to splice a list into itself\",\n     \"attempt to splice lists with inequal allocators\",\n     \"attempt to splice elements referenced by a %1.state; iterator\",\n     \"attempt to splice an iterator from a different container\",\n     \"splice destination %1.name;\"\n     \" occurs within source range [%2.name;, %3.name;)\",\n+    // iterator checks\n     \"attempt to initialize an iterator that will immediately become singular\",\n     \"attempt to copy-construct an iterator from a singular iterator\",\n     \"attempt to construct a constant iterator\"\n@@ -124,38 +159,35 @@ namespace __gnu_debug\n     \" iterator to a %2.state; iterator\",\n     \"attempt to compute the different between two iterators\"\n     \" from different sequences\",\n+    // istream_iterator\n     \"attempt to dereference an end-of-stream istream_iterator\",\n     \"attempt to increment an end-of-stream istream_iterator\",\n+    // ostream_iterator\n     \"attempt to output via an ostream_iterator with no associated stream\",\n+    // istreambuf_iterator\n     \"attempt to dereference an end-of-stream istreambuf_iterator\"\n     \" (this is a GNU extension)\",\n     \"attempt to increment an end-of-stream istreambuf_iterator\",\n+    // std::forward_list\n     \"attempt to insert into container after an end iterator\",\n     \"attempt to erase from container after a %2.state; iterator not followed\"\n     \" by a dereferenceable one\",\n     \"function requires a valid iterator range (%2.name;, %3.name;)\"\n-    \", \\\"%2.name;\\\" shall be before and not equal to \\\"%3.name;\\\"\"\n+    \", \\\"%2.name;\\\" shall be before and not equal to \\\"%3.name;\\\"\",\n+    // std::unordered_sequence::local_iterator\n+    \"attempt to compare local iterators from different unordered sequence\"\n+    \" buckets\"\n   };\n \n   void\n   _Safe_sequence_base::\n   _M_detach_all()\n   {\n     __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n-    for (_Safe_iterator_base* __iter = _M_iterators; __iter;)\n-      {\n-\t_Safe_iterator_base* __old = __iter;\n-\t__iter = __iter->_M_next;\n-\t__old->_M_reset();\n-      }\n+    detach_all(_M_iterators);\n     _M_iterators = 0;\n     \n-    for (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n-      {\n-\t_Safe_iterator_base* __old = __iter2;\n-\t__iter2 = __iter2->_M_next;\n-\t__old->_M_reset();\n-      }\n+    detach_all(_M_const_iterators);\n     _M_const_iterators = 0;\n   }\n \n@@ -299,9 +331,7 @@ namespace __gnu_debug\n   _M_detach()\n   {\n     if (_M_sequence)\n-      {\n-\t_M_sequence->_M_detach(this);\n-      }\n+      _M_sequence->_M_detach(this);\n \n     _M_reset();\n   }\n@@ -311,9 +341,7 @@ namespace __gnu_debug\n   _M_detach_single() throw ()\n   {\n     if (_M_sequence)\n-      {\n-\t_M_sequence->_M_detach_single(this);\n-      }\n+      _M_sequence->_M_detach_single(this);\n \n     _M_reset();\n   }\n@@ -346,6 +374,143 @@ namespace __gnu_debug\n   _M_get_mutex() throw ()\n   { return get_safe_base_mutex(_M_sequence); }\n \n+  _Safe_unordered_sequence_base*\n+  _Safe_local_iterator_base::\n+  _M_get_sequence() const _GLIBCXX_NOEXCEPT\n+  { return static_cast<_Safe_unordered_sequence_base*>(_M_sequence); }\n+\n+  void\n+  _Safe_local_iterator_base::\n+  _M_attach(_Safe_sequence_base* __seq, bool __constant)\n+  {\n+    _M_detach();\n+    \n+    // Attach to the new sequence (if there is one)\n+    if (__seq)\n+      {\n+\t_M_sequence = __seq;\n+\t_M_version = _M_sequence->_M_version;\n+\t_M_get_sequence()->_M_attach_local(this, __constant);\n+      }\n+  }\n+  \n+  void\n+  _Safe_local_iterator_base::\n+  _M_attach_single(_Safe_sequence_base* __seq, bool __constant) throw ()\n+  {\n+    _M_detach_single();\n+    \n+    // Attach to the new sequence (if there is one)\n+    if (__seq)\n+      {\n+\t_M_sequence = __seq;\n+\t_M_version = _M_sequence->_M_version;\n+\t_M_get_sequence()->_M_attach_local_single(this, __constant);\n+      }\n+  }\n+\n+  void\n+  _Safe_local_iterator_base::\n+  _M_detach()\n+  {\n+    if (_M_sequence)\n+      _M_get_sequence()->_M_detach_local(this);\n+\n+    _M_reset();\n+  }\n+\n+  void\n+  _Safe_local_iterator_base::\n+  _M_detach_single() throw ()\n+  {\n+    if (_M_sequence)\n+      _M_get_sequence()->_M_detach_local_single(this);\n+\n+    _M_reset();\n+  }\n+\n+  void\n+  _Safe_unordered_sequence_base::\n+  _M_detach_all()\n+  {\n+    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n+    detach_all(_M_iterators);\n+    _M_iterators = 0;\n+    \n+    detach_all(_M_const_iterators);\n+    _M_const_iterators = 0;\n+\n+    detach_all(_M_local_iterators);\n+    _M_local_iterators = 0;\n+\n+    detach_all(_M_const_local_iterators);\n+    _M_const_local_iterators = 0;\n+  }\n+\n+  void\n+  _Safe_unordered_sequence_base::\n+  _M_swap(_Safe_unordered_sequence_base& __x)\n+  {\n+    // We need to lock both sequences to swap\n+    using namespace __gnu_cxx;\n+    __mutex *__this_mutex = &_M_get_mutex();\n+    __mutex *__x_mutex = &__x._M_get_mutex();\n+    if (__this_mutex == __x_mutex)\n+      {\n+\t__scoped_lock __lock(*__this_mutex);\n+\tswap_useq(*this, __x);\n+      }\n+    else\n+      {\n+\t__scoped_lock __l1(__this_mutex < __x_mutex\n+\t\t\t     ? *__this_mutex : *__x_mutex);\n+\t__scoped_lock __l2(__this_mutex < __x_mutex\n+\t\t\t     ? *__x_mutex : *__this_mutex);\n+\tswap_useq(*this, __x);\n+      }\n+  }\n+\n+  void\n+  _Safe_unordered_sequence_base::\n+  _M_attach_local(_Safe_iterator_base* __it, bool __constant)\n+  {\n+    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n+    _M_attach_local_single(__it, __constant);\n+  }\n+\n+  void\n+  _Safe_unordered_sequence_base::\n+  _M_attach_local_single(_Safe_iterator_base* __it, bool __constant) throw ()\n+  {\n+    _Safe_iterator_base*& __its =\n+      __constant ? _M_const_local_iterators : _M_local_iterators;\n+    __it->_M_next = __its;\n+    if (__it->_M_next)\n+      __it->_M_next->_M_prior = __it;\n+    __its = __it;\n+  }\n+\n+  void\n+  _Safe_unordered_sequence_base::\n+  _M_detach_local(_Safe_iterator_base* __it)\n+  {\n+    // Remove __it from this sequence's list\n+    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n+    _M_detach_local_single(__it);\n+  }\n+\n+  void\n+  _Safe_unordered_sequence_base::\n+  _M_detach_local_single(_Safe_iterator_base* __it) throw ()\n+  {\n+    // Remove __it from this sequence's list\n+    __it->_M_unlink();\n+    if (_M_const_local_iterators == __it)\n+      _M_const_local_iterators = __it->_M_next;\n+    if (_M_local_iterators == __it)\n+      _M_local_iterators = __it->_M_next;\n+  }\n+\n   void\n   _Error_formatter::_Parameter::\n   _M_print_field(const _Error_formatter* __formatter, const char* __name) const"}, {"sha": "72611d3cdf6b001ffc7bdff691c573b9be411126", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/invalid_local_iterator_compare_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Finvalid_local_iterator_compare_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::invalid_local_iterator_compare<std::unordered_map<int, int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1e45e626cdf9a9991a3cc074a976587fc0f8a6ed", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/invalid_local_iterator_range_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Finvalid_local_iterator_range_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::invalid_local_iterator_range<std::unordered_map<int, int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ce70ef28586a93762853425446c457bc429c59d8", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/use_erased_local_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_erased_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_erased_local_iterator<std::unordered_map<int, int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3d9f219d02e258b813da619b879dc7427b0b13b6", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/use_invalid_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_invalid_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_invalid_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_invalid_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_invalid_iterator<std::unordered_map<int, int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "70cda4756e6ba6f62c15a32228476f98d8047ee1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/debug/use_invalid_local_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fdebug%2Fuse_invalid_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_invalid_local_iterator<std::unordered_map<int, int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4ee44a4b4b1d453634a95450d8a9da86a31b906c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/invalid_local_iterator_compare_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Finvalid_local_iterator_compare_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<int, int> cont_type;\n+  __gnu_test::invalid_local_iterator_compare<cont_type>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d70225e5870b9b0418a684a077b8624a2fed00a3", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/invalid_local_iterator_range_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Finvalid_local_iterator_range_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<int, int> cont_type;\n+  __gnu_test::invalid_local_iterator_range<cont_type>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2d404e6eca7e0fdc1ebe366665b3cbf2fa0316e8", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/use_erased_local_iterator_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_erased_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<int, int> cont_type;\n+  __gnu_test::use_erased_local_iterator<cont_type>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6f7c250bd14997763f4edb7e5daef23b6ded7895", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/use_invalid_iterator_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_invalid_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_invalid_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_invalid_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<int, int> cont_type;\n+  __gnu_test::use_invalid_iterator<cont_type>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e47838f624e43fb40618b642d5d3afc8b6e5ab63", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/debug/use_invalid_local_iterator_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fdebug%2Fuse_invalid_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_map>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<int, int> cont_type;\n+  __gnu_test::use_invalid_local_iterator<cont_type>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "03fa0b6618a9bc0e8e1dd1b50e590be94f6d57ee", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/invalid_local_iterator_compare_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Finvalid_local_iterator_compare_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::invalid_local_iterator_compare<std::unordered_multiset<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f2f2571c0bcd9075947fc77be004c526624251fc", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/invalid_local_iterator_range_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Finvalid_local_iterator_range_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::invalid_local_iterator_range<std::unordered_multiset<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "08b4e868e67a7b1f6ee4973b6689ea70324f48d4", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/use_erased_local_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_erased_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_erased_local_iterator<std::unordered_multiset<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b4202f9bb787bdc8d885f34db5c254f143140fdb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/use_invalid_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_invalid_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_invalid_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_invalid_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_invalid_iterator<std::unordered_multiset<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9e47220ea54c64883135b581e903bb97486563a6", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/debug/use_invalid_local_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fdebug%2Fuse_invalid_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_invalid_local_iterator<std::unordered_multiset<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "bef8e7ba689bb62d7a7a93c8a65a79b5dcaa19e7", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/invalid_local_iterator_compare_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Finvalid_local_iterator_compare_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Finvalid_local_iterator_compare_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::invalid_local_iterator_compare<std::unordered_set<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e4cb8c1d4cfcc3794ac9f431076dfd112505ebaf", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/invalid_local_iterator_range_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Finvalid_local_iterator_range_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Finvalid_local_iterator_range_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::invalid_local_iterator_range<std::unordered_set<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1807005ea9b55187bee89e448e831f21a1c59a77", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/use_erased_local_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_erased_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_erased_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_erased_local_iterator<std::unordered_set<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c29889ee252a634b8c90f0ec40ac29a85aeb164f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/use_invalid_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_invalid_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_invalid_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_invalid_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_invalid_iterator<std::unordered_set<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "28444ec6e8432f2d2af59188268a99057237f7ea", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/debug/use_invalid_local_iterator_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_invalid_local_iterator_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fdebug%2Fuse_invalid_local_iterator_neg.cc?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-require-debug-mode \"\" }\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+#include <unordered_set>\n+#include <debug/unordered_checks.h>\n+\n+void test01()\n+{\n+  __gnu_test::use_invalid_local_iterator<std::unordered_set<int>>();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "dbf6d40b1489a3eaef9a3f02ddbbb23be76c1b6b", "filename": "libstdc++-v3/testsuite/util/debug/checks.h", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Fchecks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Fchecks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Fchecks.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -45,7 +45,7 @@ namespace __gnu_test\n     {\n       typedef _Tp value_type;\n \n-      operator value_type()\n+      value_type build()\n       {\n \tstatic value_type _S_;\n \t++_S_;\n@@ -60,7 +60,7 @@ namespace __gnu_test\n       typedef _Tp2 second_type;\n       typedef std::pair<_Tp1, _Tp2> pair_type;\n       \n-      operator pair_type()\n+      pair_type build()\n       {\n \tstatic first_type _S_1;\n \tstatic second_type _S_2;\n@@ -86,7 +86,7 @@ namespace __gnu_test\n \n       vector_type v;\n       for (int i = 0; i != 5; ++i)\n-        v.push_back(gu);\n+        v.push_back(gu.build());\n       VERIFY(v.size() == 5);\n \n       const val_type* first = &v.front() + 1;\n@@ -116,7 +116,7 @@ namespace __gnu_test\n \n       vector_type v;\n       for (int i = 0; i != 5; ++i)\n-        v.push_back(gu);\n+        v.push_back(gu.build());\n       VERIFY(v.size() == 5);\n \n       typename vector_type::iterator first = v.begin() + 1;\n@@ -145,7 +145,7 @@ namespace __gnu_test\n \n       list_type l;\n       for (int i = 0; i != 5; ++i)\n-        l.push_back(gu);\n+        l.push_back(gu.build());\n       VERIFY(l.size() == 5);\n \n       typename list_type::iterator first = l.begin(); ++first;\n@@ -174,7 +174,7 @@ namespace __gnu_test\n \n       vector_type v;\n       for (int i = 0; i != 5; ++i)\n-        v.push_back(gu);\n+        v.push_back(gu.build());\n       VERIFY(v.size() == 5);\n \n       val_type *first = &v.front() + 1;\n@@ -201,7 +201,7 @@ namespace __gnu_test\n \n       vector_type v;\n       for (int i = 0; i != 5; ++i)\n-        v.push_back(gu);\n+        v.push_back(gu.build());\n       VERIFY(v.size() == 5);\n \n       typename vector_type::iterator first = v.begin() + 1;\n@@ -228,7 +228,7 @@ namespace __gnu_test\n \n       list_type l;\n       for (int i = 0; i != 5; ++i)\n-        l.push_back(gu);\n+        l.push_back(gu.build());\n       VERIFY(l.size() == 5);\n \n       typename list_type::iterator first = l.begin(); ++first;\n@@ -304,7 +304,7 @@ namespace __gnu_test\n \n       vector_type v;\n       for (int i = 0; i != 5; ++i)\n-        v.push_back(gu);\n+        v.push_back(gu.build());\n       VERIFY(v.size() == 5);\n \n       const val_type* first = &v.front() + 1;\n@@ -333,7 +333,7 @@ namespace __gnu_test\n \n       vector_type v;\n       for (int i = 0; i != 5; ++i)\n-        v.push_back(gu);\n+        v.push_back(gu.build());\n       VERIFY(v.size() == 5);\n \n       typename vector_type::iterator first = v.begin() + 1;\n@@ -362,7 +362,7 @@ namespace __gnu_test\n \n       list_type l;\n       for (int i = 0; i != 5; ++i)\n-        l.push_back(gu);\n+        l.push_back(gu.build());\n       VERIFY(l.size() == 5);\n \n       typename list_type::iterator first = l.begin(); ++first;\n@@ -375,5 +375,25 @@ namespace __gnu_test\n       cont_type c2;\n       InsertRangeHelper<cont_type>::Insert(c2, last, first); // Expected failure\n     }\n+\n+  template<typename _Tp>\n+    void use_invalid_iterator()\n+    {\n+      bool test __attribute__((unused)) = true;\n+\n+      typedef _Tp cont_type;\n+      typedef typename cont_type::value_type cont_val_type;\n+      typedef typename CopyableValueType<cont_val_type>::value_type val_type;\n+      generate_unique<val_type> gu;\n+\n+      cont_type c;\n+      for (size_t i = 0; i != 5; ++i)\n+\tc.insert(gu.build());\n+\n+      typename cont_type::iterator it = c.begin();\n+      cont_val_type val = *it;\n+      c.clear();\n+      VERIFY( *it == val );\n+    }\n }\n "}, {"sha": "66841508fccb6a39e750f689e69a958e6080baea", "filename": "libstdc++-v3/testsuite/util/debug/unordered_checks.h", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Funordered_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Funordered_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fdebug%2Funordered_checks.h?ref=77e0bf4e0799ef5080bb6b6f0e26a661417fe7fb", "patch": "@@ -0,0 +1,190 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+#include <testsuite_hooks.h>\n+\n+namespace __gnu_test\n+{\n+  template<typename _Tp>\n+    struct CopyableValueType\n+    {\n+      typedef _Tp value_type;\n+    };\n+\n+  template<typename _Tp1, typename _Tp2>\n+    struct CopyableValueType<std::pair<const _Tp1, _Tp2> >\n+    {\n+      typedef std::pair<_Tp1, _Tp2> value_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct generate_unique\n+    {\n+      typedef _Tp value_type;\n+\n+      value_type build()\n+      {\n+\tstatic value_type _S_;\n+\t++_S_;\n+\treturn _S_;\n+      }\n+    };\n+\n+  template<typename _Tp1, typename _Tp2>\n+    struct generate_unique<std::pair<_Tp1, _Tp2> >\n+    {\n+      typedef _Tp1 first_type;\n+      typedef _Tp2 second_type;\n+      typedef std::pair<_Tp1, _Tp2> pair_type;\n+      \n+      pair_type build()\n+      {\n+\tstatic first_type _S_1;\n+\tstatic second_type _S_2;\n+\t++_S_1;\n+\t++_S_2;\n+\treturn pair_type(_S_1, _S_2);\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct KeyExtractor\n+    {\n+      static _Tp get_key(const _Tp& val)\n+      { return val; }\n+    };\n+\n+  template<typename _Tp1, typename _Tp2>\n+    struct KeyExtractor<std::pair<const _Tp1, _Tp2>>\n+    {\n+      static _Tp1 get_key(const std::pair<const _Tp1, _Tp2>& val)\n+      { return val.first; }\n+    };\n+\n+  template<typename _Tp>\n+    void use_erased_local_iterator()\n+    {\n+      bool test __attribute__((unused)) = true;\n+\n+      typedef _Tp cont_type;\n+      typedef typename cont_type::value_type cont_val_type;\n+      typedef typename CopyableValueType<cont_val_type>::value_type val_type;\n+      generate_unique<val_type> gu;\n+\n+      cont_type c;\n+      for (size_t i = 0; i != 5; ++i)\n+\tc.insert(gu.build());\n+\n+      typename cont_type::local_iterator it, end;\n+      for (size_t i = 0; i != c.bucket_count(); ++i)\n+      {\n+\tit = c.begin(i);\n+\tend = c.end(i);\n+\tif (it != end)\n+\t  break;\n+      }\n+      typename cont_type::key_type key = KeyExtractor<cont_val_type>::get_key(*it);\n+      c.erase(key);\n+      VERIFY( it != end );\n+  }\n+\n+  template<typename _Tp>\n+    void use_invalid_local_iterator()\n+    {\n+      bool test __attribute__((unused)) = true;\n+\n+      typedef _Tp cont_type;\n+      typedef typename cont_type::value_type cont_val_type;\n+      typedef typename CopyableValueType<cont_val_type>::value_type val_type;\n+      generate_unique<val_type> gu;\n+\n+      cont_type c;\n+      for (size_t i = 0; i != 5; ++i)\n+\tc.insert(gu.build());\n+\n+      typename cont_type::local_iterator it;\n+      for (size_t i = 0; i != c.bucket_count(); ++i)\n+      {\n+\tit = c.begin(i);\n+\tif (it != c.end(i))\n+\t  break;\n+      }\n+      cont_val_type val = *it;\n+      c.clear();\n+      VERIFY( *it == val );\n+    }\n+\n+  template<typename _Tp>\n+    void invalid_local_iterator_compare()\n+    {\n+      bool test __attribute__((unused)) = true;\n+\n+      typedef _Tp cont_type;\n+      typedef typename cont_type::value_type cont_val_type;\n+      typedef typename CopyableValueType<cont_val_type>::value_type val_type;\n+      generate_unique<val_type> gu;\n+\n+      cont_type c;\n+      for (size_t i = 0; i != 5; ++i)\n+\tc.insert(gu.build());\n+\n+      typename cont_type::local_iterator it1, it2;\n+      size_t i;\n+      for (i = 0; i != c.bucket_count(); ++i)\n+      {\n+\tit1 = c.begin(i);\n+\tif (it1 != c.end(i))\n+\t  break;\n+      }\n+      VERIFY( i != c.bucket_count() );\n+      for (++i; i != c.bucket_count(); ++i)\n+      {\n+\tit2 = c.begin(i);\n+\tif (it2 != c.end(i))\n+\t  break;\n+      }\n+\n+      VERIFY( it1 != it2 );\n+    }\n+\n+  template<typename _Tp>\n+    void invalid_local_iterator_range()\n+    {\n+      bool test __attribute__((unused)) = true;\n+\n+      typedef _Tp cont_type;\n+      typedef typename cont_type::value_type cont_val_type;\n+      typedef typename CopyableValueType<cont_val_type>::value_type val_type;\n+      generate_unique<val_type> gu;\n+\n+      cont_type c;\n+      for (size_t i = 0; i != 5; ++i)\n+\tc.insert(gu.build());\n+\n+      typename cont_type::local_iterator it, end;\n+      for (size_t i = 0; i != c.bucket_count(); ++i)\n+      {\n+\tit = c.begin(i);\n+\tend = c.end(i);\n+\tif (it != end)\n+\t  break;\n+      }\n+      c.insert(end, it);\n+    }\n+}\n+"}]}