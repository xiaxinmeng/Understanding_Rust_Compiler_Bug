{"sha": "a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVmYmMyZjM2YTI5MWNiZTgwYzQzOTM5NTBkNmRiOWI1NmEzNGIwNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-11-01T19:36:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-11-01T19:36:08Z"}, "message": "re PR fortran/40196 ([F03] [F08] Type parameter inquiry (str%len, a%kind) and Complex parts (z%re, z%im))\n\n2018-11-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40196\n\t* dependency.c (are_identical_variables): Return false if the\n\tinquiry refs are not the same.\n\t(gfc_ref_needs_temporary_p): Break on an inquiry ref.\n\t* dump_parse_tree.c (show_ref): Show the inquiry ref type.\n\t* expr.c (gfc_free_ref_list): Break on an inquiry ref.\n\t(gfc_copy_ref): Copy the inquiry ref types.\n\t(find_inquiry_ref): New function.\n\t(simplify_const_ref, simplify_ref_chain): Call it. Add new arg\n\tto simplify_ref_chain.\n\t(gfc_simplify_expr): Use the new arg in call to\n\tsimplify_ref_chain.\n\t(gfc_get_full_arrayspec_from_expr, gfc_is_coarray): Break on\n\tinquiry ref.\n\t(gfc_traverse_expr): Return true for inquiry ref.\n\t* frontend-passes.c (gfc_expr_walker): Break on inquiry ref.\n\t* gfortran.h : Add enums and union member in gfc_ref to\n\timplement inquiry refs.\n\t* intrinsic.c : Fix white nois.\n\t* match.c (gfc_match_assignment): A constant lavlue is an\n\terror.\n\t* module.c : Add DECL_MIO_NAME for inquiry_type and the mstring\n\tfor inquiry_types.\n\t(mio_ref): Handle inquiry refs.\n\t* primary.c (is_inquiry_ref): New function.\n\t(gfc_match_varspec): Handle inquiry refs calling new function.\n\t(gfc_variable_attr): Detect inquiry ref for disambiguation\n\twith components.\n\t(caf_variable_attr): Treat inquiry and substring refs in the\n\tsame way.\n\t* resolve.c (find_array_spec): ditto.\n\t(gfc_resolve_substring_charlen): If there is neither a charlen\n\tref not an inquiry ref, return.\n\t(resolve_ref): Handle inqiry refs as appropriate.\n\t(resolve_allocate_expr): Entities with an inquiry ref cannot be\n\tallocated.\n\t* simplify.c (simplify_bound, simplify_cobound): Punt on\n\tinquiry refs.\n\t* trans-array.c (get_array_ctor_var_strlen): Break on inquiry\n\tref.\n\t*trans-expr.c (conv_inquiry): New function.\n\t(gfc_conv_variable): Retain the last typespec to pass to\n\tconv_inquiry on detecting an inquiry ref.\n\n\n2018-11-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40196\n\t* gfortran.dg/inquiry_part_ref_1.f08: New test.\n\t* gfortran.dg/inquiry_part_ref_2.f90: New test.\n\t* gfortran.dg/inquiry_part_ref_3.f90: New test.\n\nFrom-SVN: r265729", "tree": {"sha": "b9094c6275286c27845032522ee7339951259b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9094c6275286c27845032522ee7339951259b3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/comments", "author": null, "committer": null, "parents": [{"sha": "da06a0e93f5067d32144beb67b3453e865b9394d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da06a0e93f5067d32144beb67b3453e865b9394d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da06a0e93f5067d32144beb67b3453e865b9394d"}], "stats": {"total": 627, "additions": 589, "deletions": 38}, "files": [{"sha": "31e3fdd12eca71f36450d208e1f62bd77355c381", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -1,3 +1,49 @@\n+2018-11-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40196\n+\t* dependency.c (are_identical_variables): Return false if the\n+\tinquiry refs are not the same.\n+\t(gfc_ref_needs_temporary_p): Break on an inquiry ref.\n+\t* dump_parse_tree.c (show_ref): Show the inquiry ref type.\n+\t* expr.c (gfc_free_ref_list): Break on an inquiry ref.\n+\t(gfc_copy_ref): Copy the inquiry ref types.\n+\t(find_inquiry_ref): New function.\n+\t(simplify_const_ref, simplify_ref_chain): Call it. Add new arg\n+\tto simplify_ref_chain.\n+\t(gfc_simplify_expr): Use the new arg in call to\n+\tsimplify_ref_chain.\n+\t(gfc_get_full_arrayspec_from_expr, gfc_is_coarray): Break on\n+\tinquiry ref.\n+\t(gfc_traverse_expr): Return true for inquiry ref.\n+\t* frontend-passes.c (gfc_expr_walker): Break on inquiry ref.\n+\t* gfortran.h : Add enums and union member in gfc_ref to\n+\timplement inquiry refs.\n+\t* intrinsic.c : Fix white nois.\n+\t* match.c (gfc_match_assignment): A constant lavlue is an\n+\terror.\n+\t* module.c : Add DECL_MIO_NAME for inquiry_type and the mstring\n+\tfor inquiry_types.\n+\t(mio_ref): Handle inquiry refs.\n+\t* primary.c (is_inquiry_ref): New function.\n+\t(gfc_match_varspec): Handle inquiry refs calling new function.\n+\t(gfc_variable_attr): Detect inquiry ref for disambiguation\n+\twith components.\n+\t(caf_variable_attr): Treat inquiry and substring refs in the\n+\tsame way.\n+\t* resolve.c (find_array_spec): ditto.\n+\t(gfc_resolve_substring_charlen): If there is neither a charlen\n+\tref not an inquiry ref, return.\n+\t(resolve_ref): Handle inqiry refs as appropriate.\n+\t(resolve_allocate_expr): Entities with an inquiry ref cannot be\n+\tallocated.\n+\t* simplify.c (simplify_bound, simplify_cobound): Punt on\n+\tinquiry refs.\n+\t* trans-array.c (get_array_ctor_var_strlen): Break on inquiry\n+\tref.\n+\t*trans-expr.c (conv_inquiry): New function.\n+\t(gfc_conv_variable): Retain the last typespec to pass to\n+\tconv_inquiry on detecting an inquiry ref.\n+\n 2018-11-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/46020"}, {"sha": "b78c138c48396aa89a06eebe94415bc42fa95193", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -189,6 +189,11 @@ are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n \n \t  break;\n \n+\tcase REF_INQUIRY:\n+\t  if (r1->u.i != r2->u.i)\n+\t    return false;\n+\t  break;\n+\n \tdefault:\n \t  gfc_internal_error (\"are_identical_variables: Bad type\");\n \t}\n@@ -905,6 +910,7 @@ gfc_ref_needs_temporary_p (gfc_ref *ref)\n \treturn subarray_p;\n \n       case REF_COMPONENT:\n+      case REF_INQUIRY:\n \tbreak;\n       }\n "}, {"sha": "af64588786ab99073fd3940fb70820f3ba55b895", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -308,6 +308,23 @@ show_ref (gfc_ref *p)\n \tfputc (')', dumpfile);\n \tbreak;\n \n+      case REF_INQUIRY:\n+\tswitch (p->u.i)\n+\t{\n+\t  case INQUIRY_KIND:\n+\t    fprintf (dumpfile, \" INQUIRY_KIND \");\n+\t    break;\n+\t  case INQUIRY_LEN:\n+\t    fprintf (dumpfile, \" INQUIRY_LEN \");\n+\t    break;\n+\t  case INQUIRY_RE:\n+\t    fprintf (dumpfile, \" INQUIRY_RE \");\n+\t    break;\n+\t  case INQUIRY_IM:\n+\t    fprintf (dumpfile, \" INQUIRY_IM \");\n+\t}\n+\tbreak;\n+\n       default:\n \tgfc_internal_error (\"show_ref(): Bad component code\");\n       }\n@@ -3167,7 +3184,7 @@ write_decl (gfc_typespec *ts, gfc_array_spec *as, const char *sym_name,\n \n   fputs (sym_name, dumpfile);\n   fputs (post, dumpfile);\n-    \n+\n   if (rok == T_WARN)\n     fprintf (dumpfile,\" /* WARNING: Converting '%s' to interoperable type */\",\n \t     gfc_typename (ts));"}, {"sha": "1d1d48d0b813d096e5f3eb7117460334f83b4142", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 155, "deletions": 12, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -599,6 +599,7 @@ gfc_free_ref_list (gfc_ref *p)\n \t  break;\n \n \tcase REF_COMPONENT:\n+\tcase REF_INQUIRY:\n \t  break;\n \t}\n \n@@ -756,6 +757,10 @@ gfc_copy_ref (gfc_ref *src)\n       dest->u.c = src->u.c;\n       break;\n \n+    case REF_INQUIRY:\n+      dest->u.i = src->u.i;\n+      break;\n+\n     case REF_SUBSTRING:\n       dest->u.ss = src->u.ss;\n       dest->u.ss.start = gfc_copy_expr (src->u.ss.start);\n@@ -1691,6 +1696,109 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n }\n \n \n+/* Pull an inquiry result out of an expression.  */\n+\n+static bool\n+find_inquiry_ref (gfc_expr *p, gfc_expr **newp)\n+{\n+  gfc_ref *ref;\n+  gfc_ref *inquiry = NULL;\n+  gfc_expr *tmp;\n+\n+  tmp = gfc_copy_expr (p);\n+\n+  if (tmp->ref && tmp->ref->type == REF_INQUIRY)\n+    {\n+      inquiry = tmp->ref;\n+      tmp->ref = NULL;\n+    }\n+  else\n+    {\n+      for (ref = tmp->ref; ref; ref = ref->next)\n+\tif (ref->next && ref->next->type == REF_INQUIRY)\n+\t  {\n+\t    inquiry = ref->next;\n+\t    ref->next = NULL;\n+\t  }\n+    }\n+\n+  if (!inquiry)\n+    {\n+      gfc_free_expr (tmp);\n+      return false;\n+    }\n+\n+  gfc_resolve_expr (tmp);\n+\n+  switch (inquiry->u.i)\n+    {\n+    case INQUIRY_LEN:\n+      if (tmp->ts.type != BT_CHARACTER)\n+\tgoto cleanup;\n+\n+      if (!gfc_notify_std (GFC_STD_F2003, \"LEN part_ref at %C\"))\n+\tgoto cleanup;\n+\n+      if (!tmp->ts.u.cl->length\n+\t  || tmp->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n+\tgoto cleanup;\n+\n+      *newp = gfc_copy_expr (tmp->ts.u.cl->length);\n+      break;\n+\n+    case INQUIRY_KIND:\n+      if (tmp->ts.type == BT_DERIVED || tmp->ts.type == BT_CLASS)\n+\tgoto cleanup;\n+\n+      if (!gfc_notify_std (GFC_STD_F2003, \"KIND part_ref at %C\"))\n+\tgoto cleanup;\n+\n+      *newp = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\tNULL, tmp->ts.kind);\n+      break;\n+\n+    case INQUIRY_RE:\n+      if (tmp->ts.type != BT_COMPLEX || tmp->expr_type != EXPR_CONSTANT)\n+\tgoto cleanup;\n+\n+      if (!gfc_notify_std (GFC_STD_F2008, \"RE part_ref at %C\"))\n+\tgoto cleanup;\n+\n+      *newp = gfc_get_constant_expr (BT_REAL, tmp->ts.kind, &tmp->where);\n+      mpfr_set ((*newp)->value.real,\n+\t\tmpc_realref (p->value.complex), GFC_RND_MODE);\n+      break;\n+\n+    case INQUIRY_IM:\n+      if (tmp->ts.type != BT_COMPLEX || tmp->expr_type != EXPR_CONSTANT)\n+\tgoto cleanup;\n+\n+      if (!gfc_notify_std (GFC_STD_F2008, \"IM part_ref at %C\"))\n+\tgoto cleanup;\n+\n+      *newp = gfc_get_constant_expr (BT_REAL, tmp->ts.kind, &tmp->where);\n+      mpfr_set ((*newp)->value.real,\n+\t\tmpc_imagref (p->value.complex), GFC_RND_MODE);\n+      break;\n+    }\n+\n+  if (!(*newp))\n+    goto cleanup;\n+  else if ((*newp)->expr_type != EXPR_CONSTANT)\n+    {\n+      gfc_free_expr (*newp);\n+      goto cleanup;\n+    }\n+\n+  gfc_free_expr (tmp);\n+  return true;\n+\n+cleanup:\n+  gfc_free_expr (tmp);\n+  return false;\n+}\n+\n+\n \n /* Simplify a subobject reference of a constructor.  This occurs when\n    parameter variable values are substituted.  */\n@@ -1699,7 +1807,7 @@ static bool\n simplify_const_ref (gfc_expr *p)\n {\n   gfc_constructor *cons, *c;\n-  gfc_expr *newp;\n+  gfc_expr *newp = NULL;\n   gfc_ref *last_ref;\n \n   while (p->ref)\n@@ -1800,8 +1908,17 @@ simplify_const_ref (gfc_expr *p)\n \t  remove_subobject_ref (p, cons);\n \t  break;\n \n+\tcase REF_INQUIRY:\n+\t  if (!find_inquiry_ref (p, &newp))\n+\t    return false;\n+\n+\t  gfc_replace_expr (p, newp);\n+\t  gfc_free_ref_list (p->ref);\n+\t  p->ref = NULL;\n+\t  break;\n+\n \tcase REF_SUBSTRING:\n-  \t  if (!find_substring_ref (p, &newp))\n+\t  if (!find_substring_ref (p, &newp))\n \t    return false;\n \n \t  gfc_replace_expr (p, newp);\n@@ -1818,9 +1935,10 @@ simplify_const_ref (gfc_expr *p)\n /* Simplify a chain of references.  */\n \n static bool\n-simplify_ref_chain (gfc_ref *ref, int type)\n+simplify_ref_chain (gfc_ref *ref, int type, gfc_expr **p)\n {\n   int n;\n+  gfc_expr *newp;\n \n   for (; ref; ref = ref->next)\n     {\n@@ -1845,6 +1963,15 @@ simplify_ref_chain (gfc_ref *ref, int type)\n \t    return false;\n \t  break;\n \n+\tcase REF_INQUIRY:\n+\t  if (!find_inquiry_ref (*p, &newp))\n+\t    return false;\n+\n+\t  gfc_replace_expr (*p, newp);\n+\t  gfc_free_ref_list ((*p)->ref);\n+\t  (*p)->ref = NULL;\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -1933,6 +2060,9 @@ gfc_simplify_expr (gfc_expr *p, int type)\n   switch (p->expr_type)\n     {\n     case EXPR_CONSTANT:\n+      if (p->ref && p->ref->type == REF_INQUIRY)\n+\tsimplify_ref_chain (p->ref, type, &p);\n+      break;\n     case EXPR_NULL:\n       break;\n \n@@ -1969,7 +2099,7 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       break;\n \n     case EXPR_SUBSTRING:\n-      if (!simplify_ref_chain (p->ref, type))\n+      if (!simplify_ref_chain (p->ref, type, &p))\n \treturn false;\n \n       if (gfc_is_constant_expr (p))\n@@ -2031,14 +2161,14 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t}\n \n       /* Simplify subcomponent references.  */\n-      if (!simplify_ref_chain (p->ref, type))\n+      if (!simplify_ref_chain (p->ref, type, &p))\n \treturn false;\n \n       break;\n \n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n-      if (!simplify_ref_chain (p->ref, type))\n+      if (!simplify_ref_chain (p->ref, type, &p))\n \treturn false;\n \n       if (!simplify_constructor (p->value.constructor, type))\n@@ -3306,14 +3436,22 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,\n \n   sym = lvalue->symtree->n.sym;\n \n-  /* See if this is the component or subcomponent of a pointer.  */\n+  /* See if this is the component or subcomponent of a pointer and guard\n+     against assignment to LEN or KIND part-refs.  */\n   has_pointer = sym->attr.pointer;\n   for (ref = lvalue->ref; ref; ref = ref->next)\n-    if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n-      {\n-\thas_pointer = 1;\n-\tbreak;\n-      }\n+    {\n+      if (!has_pointer && ref->type == REF_COMPONENT\n+\t  && ref->u.c.component->attr.pointer)\n+        has_pointer = 1;\n+      else if (ref->type == REF_INQUIRY\n+\t       && (ref->u.i == INQUIRY_LEN || ref->u.i == INQUIRY_KIND))\n+\t{\n+\t  gfc_error (\"Assignment to a LEN or KIND part_ref at %L is not \"\n+\t\t     \"allowed\", &lvalue->where);\n+\t  return false;\n+\t}\n+    }\n \n   /* 12.5.2.2, Note 12.26: The result variable is very similar to any other\n      variable local to a function subprogram.  Its existence begins when\n@@ -4791,6 +4929,7 @@ gfc_get_full_arrayspec_from_expr (gfc_expr *expr)\n \t      continue;\n \n \t    case REF_SUBSTRING:\n+\t    case REF_INQUIRY:\n \t      continue;\n \n \t    case REF_ARRAY:\n@@ -4943,6 +5082,9 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n \t      }\n \t  break;\n \n+\tcase REF_INQUIRY:\n+\t  return true;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -5297,6 +5439,7 @@ gfc_is_coarray (gfc_expr *e)\n \tbreak;\n \n      case REF_SUBSTRING:\n+     case REF_INQUIRY:\n \tbreak;\n     }\n "}, {"sha": "2c095cb8d5e51df6a692e3ac4e9c4580b5ea79e5", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -5037,6 +5037,7 @@ gfc_expr_walker (gfc_expr **e, walk_expr_fn_t exprfn, void *data)\n \t\t    break;\n \n \t\t  case REF_COMPONENT:\n+\t\t  case REF_INQUIRY:\n \t\t    break;\n \t\t  }\n \t      }"}, {"sha": "d8ef35d9d6ce727edfe851794a44dfe4f27fe0f4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -1937,7 +1937,10 @@ gfc_array_ref;\n    before the component component.  */\n \n enum ref_type\n-  { REF_ARRAY, REF_COMPONENT, REF_SUBSTRING };\n+  { REF_ARRAY, REF_COMPONENT, REF_SUBSTRING, REF_INQUIRY };\n+\n+enum inquiry_type\n+  { INQUIRY_RE, INQUIRY_IM, INQUIRY_KIND, INQUIRY_LEN };\n \n typedef struct gfc_ref\n {\n@@ -1961,6 +1964,8 @@ typedef struct gfc_ref\n     }\n     ss;\n \n+    inquiry_type i;\n+\n   }\n   u;\n "}, {"sha": "8c18706958dd38ea7468e2be360b50bf56a3ad01", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -3367,7 +3367,7 @@ add_subroutines (void)\n     *st = \"status\", *stat = \"stat\", *sz = \"size\", *t = \"to\",\n     *tm = \"time\", *tp = \"topos\", *trim_name = \"trim_name\", *ut = \"unit\",\n     *val = \"value\", *vl = \"values\", *whence = \"whence\", *zn = \"zone\";\n- \n+\n   int di, dr, dc, dl, ii;\n \n   di = gfc_default_integer_kind;"}, {"sha": "f22241da60ba2253b8ea0756819f0fa200192432", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -1350,6 +1350,14 @@ gfc_match_assignment (void)\n \n   rvalue = NULL;\n   m = gfc_match (\" %e%t\", &rvalue);\n+\n+  if (lvalue->expr_type == EXPR_CONSTANT)\n+    {\n+      /* This clobbers %len and %kind.  */\n+      m = MATCH_ERROR;\n+      gfc_error (\"Assignment to a constant expression at %C\");\n+    }\n+\n   if (m != MATCH_YES)\n     {\n       gfc_current_locus = old_loc;"}, {"sha": "d42ab4789eb37a36fce05fe90f6237219d63dbc5", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -2125,6 +2125,7 @@ DECL_MIO_NAME (procedure_type)\n DECL_MIO_NAME (ref_type)\n DECL_MIO_NAME (sym_flavor)\n DECL_MIO_NAME (sym_intent)\n+DECL_MIO_NAME (inquiry_type)\n #undef DECL_MIO_NAME\n \n /* Symbol attributes are stored in list with the first three elements\n@@ -3140,6 +3141,15 @@ static const mstring ref_types[] = {\n     minit (\"ARRAY\", REF_ARRAY),\n     minit (\"COMPONENT\", REF_COMPONENT),\n     minit (\"SUBSTRING\", REF_SUBSTRING),\n+    minit (\"INQUIRY\", REF_INQUIRY),\n+    minit (NULL, -1)\n+};\n+\n+static const mstring inquiry_types[] = {\n+    minit (\"RE\", INQUIRY_RE),\n+    minit (\"IM\", INQUIRY_IM),\n+    minit (\"KIND\", INQUIRY_KIND),\n+    minit (\"LEN\", INQUIRY_LEN),\n     minit (NULL, -1)\n };\n \n@@ -3170,6 +3180,10 @@ mio_ref (gfc_ref **rp)\n       mio_expr (&r->u.ss.end);\n       mio_charlen (&r->u.ss.length);\n       break;\n+\n+    case REF_INQUIRY:\n+      r->u.i = MIO_NAME (inquiry_type) (r->u.i, inquiry_types);\n+      break;\n     }\n \n   mio_rparen ();"}, {"sha": "d94a5c48adfe30790ef5b761821e0490c33513f9", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 170, "deletions": 19, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -1249,7 +1249,7 @@ match_sym_complex_part (gfc_expr **result)\n   if (sym->attr.flavor != FL_PARAMETER)\n     {\n       /* Give the matcher for implied do-loops a chance to run.  This yields\n-\t a much saner error message for \"write(*,*) (i, i=1, 6\" where the \n+\t a much saner error message for \"write(*,*) (i, i=1, 6\" where the\n \t right parenthesis is missing.  */\n       char c;\n       gfc_gobble_whitespace ();\n@@ -1936,6 +1936,40 @@ extend_ref (gfc_expr *primary, gfc_ref *tail)\n }\n \n \n+/* Used by gfc_match_varspec() to match an inquiry reference.  */\n+\n+static bool\n+is_inquiry_ref (const char *name, gfc_ref **ref)\n+{\n+  inquiry_type type;\n+\n+  if (name == NULL)\n+    return false;\n+\n+  if (ref) *ref = NULL;\n+\n+  if (strcmp (name, \"re\") == 0)\n+    type = INQUIRY_RE;\n+  else if (strcmp (name, \"im\") == 0)\n+    type = INQUIRY_IM;\n+  else if (strcmp (name, \"kind\") == 0)\n+    type = INQUIRY_KIND;\n+  else if (strcmp (name, \"len\") == 0)\n+    type = INQUIRY_LEN;\n+  else\n+    return false;\n+\n+  if (ref)\n+    {\n+      *ref = gfc_get_ref ();\n+      (*ref)->type = REF_INQUIRY;\n+      (*ref)->u.i = type;\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Match any additional specifications associated with the current\n    variable like member references or substrings.  If equiv_flag is\n    set we only match stuff that is allowed inside an EQUIVALENCE\n@@ -1955,6 +1989,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   gfc_expr *tgt_expr = NULL;\n   match m;\n   bool unknown;\n+  bool inquiry;\n+  locus old_loc;\n   char sep;\n \n   tail = NULL;\n@@ -2087,6 +2123,19 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   if (m == MATCH_ERROR)\n     return MATCH_ERROR;\n \n+  inquiry = false;\n+  if (m == MATCH_YES && sep == '%'\n+      && primary->ts.type != BT_CLASS\n+      && primary->ts.type != BT_DERIVED)\n+    {\n+      match mm;\n+      old_loc = gfc_current_locus;\n+      mm = gfc_match_name (name);\n+      if (mm == MATCH_YES && is_inquiry_ref (name, &tmp))\n+\tinquiry = true;\n+      gfc_current_locus = old_loc;\n+    }\n+\n   if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES\n       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n     gfc_set_default_type (sym, 0, sym->ns);\n@@ -2118,18 +2167,21 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t}\n     }\n   else if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)\n-           && m == MATCH_YES)\n+           && m == MATCH_YES && !inquiry)\n     {\n       gfc_error (\"Unexpected %<%c%> for nonderived-type variable %qs at %C\",\n \t\t sep, sym->name);\n       return MATCH_ERROR;\n     }\n \n-  if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)\n+  if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS && !inquiry)\n       || m != MATCH_YES)\n     goto check_substring;\n \n-  sym = sym->ts.u.derived;\n+  if (!inquiry)\n+    sym = sym->ts.u.derived;\n+  else\n+    sym = NULL;\n \n   for (;;)\n     {\n@@ -2142,6 +2194,15 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n+      if (primary->ts.type != BT_CLASS && primary->ts.type != BT_DERIVED)\n+\t{\n+\t  inquiry = is_inquiry_ref (name, &tmp);\n+\t  if (inquiry)\n+\t    sym = NULL;\n+\t}\n+      else\n+\tinquiry = false;\n+\n       if (sym && sym->f2k_derived)\n \ttbp = gfc_find_typebound_proc (sym, &t, name, false, &gfc_current_locus);\n       else\n@@ -2197,24 +2258,89 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  break;\n \t}\n \n-      component = gfc_find_component (sym, name, false, false, &tmp);\n-      if (component == NULL)\n+      if (!inquiry)\n+\tcomponent = gfc_find_component (sym, name, false, false, &tmp);\n+      else\n+\tcomponent = NULL;\n+\n+      if (component == NULL && !inquiry)\n \treturn MATCH_ERROR;\n \n-      /* Extend the reference chain determined by gfc_find_component.  */\n+      /* Extend the reference chain determined by gfc_find_component or\n+\t is_inquiry_ref.  */\n       if (primary->ref == NULL)\n-        primary->ref = tmp;\n+\tprimary->ref = tmp;\n       else\n-        {\n-          /* Set by the for loop below for the last component ref.  */\n-          gcc_assert (tail != NULL);\n-          tail->next = tmp;\n-        }\n+\t{\n+\t  /* Set by the for loop below for the last component ref.  */\n+\t  gcc_assert (tail != NULL);\n+\t  tail->next = tmp;\n+\t}\n \n       /* The reference chain may be longer than one hop for union\n-         subcomponents; find the new tail.  */\n+\t subcomponents; find the new tail.  */\n       for (tail = tmp; tail->next; tail = tail->next)\n-        ;\n+\t;\n+\n+      if (tmp && tmp->type == REF_INQUIRY)\n+\t{\n+\t  gfc_simplify_expr (primary, 0);\n+\n+\t  if (primary->expr_type == EXPR_CONSTANT)\n+\t    goto check_done;\n+\n+\t  switch (tmp->u.i)\n+\t    {\n+\t    case INQUIRY_RE:\n+\t    case INQUIRY_IM:\n+\t      if (!gfc_notify_std (GFC_STD_F2008, \"RE or IM part_ref at %C\"))\n+\t\treturn MATCH_ERROR;\n+\n+\t      if (primary->ts.type != BT_COMPLEX)\n+\t\t{\n+\t\t  gfc_error (\"The RE or IM part_ref at %C must be \"\n+\t\t\t     \"applied to a COMPLEX expression\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t      primary->ts.type = BT_REAL;\n+\t      break;\n+\n+\t    case INQUIRY_LEN:\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"LEN part_ref at %C\"))\n+\t\treturn MATCH_ERROR;\n+\n+\t      if (primary->ts.type != BT_CHARACTER)\n+\t\t{\n+\t\t  gfc_error (\"The LEN part_ref at %C must be applied \"\n+\t\t\t     \"to a CHARACTER expression\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t      primary->ts.u.cl = NULL;\n+\t      primary->ts.type = BT_INTEGER;\n+\t      primary->ts.kind = gfc_default_integer_kind;\n+\t      break;\n+\n+\t    case INQUIRY_KIND:\n+\t      if (!gfc_notify_std (GFC_STD_F2003, \"KIND part_ref at %C\"))\n+\t\treturn MATCH_ERROR;\n+\n+\t      if (primary->ts.type == BT_CLASS\n+\t\t  || primary->ts.type == BT_DERIVED)\n+\t\t{\n+\t\t  gfc_error (\"The KIND part_ref at %C must be applied \"\n+\t\t\t     \"to an expression of intrinsic type\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t      primary->ts.type = BT_INTEGER;\n+\t      primary->ts.kind = gfc_default_integer_kind;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  goto check_done;\n+\t}\n \n       primary->ts = component->ts;\n \n@@ -2263,11 +2389,25 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t    return m;\n \t}\n \n+check_done:\n+      /* In principle, we could have eg. expr%re%kind so we must allow for\n+\t this possibility.  */\n+      if (gfc_match_char ('%') == MATCH_YES)\n+\t{\n+\t  if (component && (component->ts.type == BT_DERIVED\n+\t\t\t    || component->ts.type == BT_CLASS))\n+\t    sym = component->ts.u.derived;\n+\t  continue;\n+\t}\n+      else if (inquiry)\n+\tbreak;\n+\n       if ((component->ts.type != BT_DERIVED && component->ts.type != BT_CLASS)\n-\t  || gfc_match_member_sep (component->ts.u.derived) != MATCH_YES)\n+  \t  || gfc_match_member_sep (component->ts.u.derived) != MATCH_YES)\n \tbreak;\n \n-      sym = component->ts.u.derived;\n+      if (component->ts.type == BT_DERIVED || component->ts.type == BT_CLASS)\n+\tsym = component->ts.u.derived;\n     }\n \n check_substring:\n@@ -2358,6 +2498,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   gfc_ref *ref;\n   gfc_symbol *sym;\n   gfc_component *comp;\n+  bool has_inquiry_part;\n \n   if (expr->expr_type != EXPR_VARIABLE && expr->expr_type != EXPR_FUNCTION)\n     gfc_internal_error (\"gfc_variable_attr(): Expression isn't a variable\");\n@@ -2387,6 +2528,14 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   if (ts != NULL && expr->ts.type == BT_UNKNOWN)\n     *ts = sym->ts;\n \n+  has_inquiry_part = false;\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    if (ref->type == REF_INQUIRY)\n+      {\n+\thas_inquiry_part = true;\n+\tbreak;\n+      }\n+\n   for (ref = expr->ref; ref; ref = ref->next)\n     switch (ref->type)\n       {\n@@ -2423,7 +2572,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n       case REF_COMPONENT:\n \tcomp = ref->u.c.component;\n \tattr = comp->attr;\n-\tif (ts != NULL)\n+\tif (ts != NULL && !has_inquiry_part)\n \t  {\n \t    *ts = comp->ts;\n \t    /* Don't set the string length if a substring reference\n@@ -2450,6 +2599,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \n \tbreak;\n \n+      case REF_INQUIRY:\n       case REF_SUBSTRING:\n \tallocatable = pointer = 0;\n \tbreak;\n@@ -2630,6 +2780,7 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n \tbreak;\n \n       case REF_SUBSTRING:\n+      case REF_INQUIRY:\n \tallocatable = pointer = 0;\n \tbreak;\n       }\n@@ -2914,7 +3065,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n \t      to = e < c ? e : c;\n \t      for (i = 0; i < to; i++)\n \t\tdest[i] = actual->expr->value.character.string[i];\n-\t      \n+\n \t      for (i = e; i < c; i++)\n \t\tdest[i] = ' ';\n "}, {"sha": "ba9623497d2f6f99697fcc3893858acd4731f04b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -4740,6 +4740,7 @@ find_array_spec (gfc_expr *e)\n \tbreak;\n \n       case REF_SUBSTRING:\n+      case REF_INQUIRY:\n \tbreak;\n       }\n \n@@ -4962,13 +4963,13 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n \n   for (char_ref = e->ref; char_ref; char_ref = char_ref->next)\n     {\n-      if (char_ref->type == REF_SUBSTRING)\n-      \tbreak;\n+      if (char_ref->type == REF_SUBSTRING || char_ref->type == REF_INQUIRY)\n+\tbreak;\n       if (char_ref->type == REF_COMPONENT)\n \tts = &char_ref->u.c.component->ts;\n     }\n \n-  if (!char_ref)\n+  if (!char_ref || char_ref->type == REF_INQUIRY)\n     return;\n \n   gcc_assert (char_ref->next == NULL);\n@@ -5056,6 +5057,7 @@ resolve_ref (gfc_expr *expr)\n \tbreak;\n \n       case REF_COMPONENT:\n+      case REF_INQUIRY:\n \tbreak;\n \n       case REF_SUBSTRING:\n@@ -5129,6 +5131,7 @@ resolve_ref (gfc_expr *expr)\n \t  break;\n \n \tcase REF_SUBSTRING:\n+\tcase REF_INQUIRY:\n \t  break;\n \t}\n \n@@ -7233,6 +7236,7 @@ resolve_deallocate_expr (gfc_expr *e)\n \t  break;\n \n \tcase REF_SUBSTRING:\n+\tcase REF_INQUIRY:\n \t  allocatable = 0;\n \t  break;\n \t}\n@@ -7525,6 +7529,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n \t\tbreak;\n \n \t      case REF_SUBSTRING:\n+\t      case REF_INQUIRY:\n \t\tallocatable = 0;\n \t\tpointer = 0;\n \t\tbreak;"}, {"sha": "cdf748e4990d9c3a0d79bd67f77e0183ae83cd38", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -4182,6 +4182,7 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t  continue;\n \n \tcase REF_SUBSTRING:\n+\tcase REF_INQUIRY:\n \t  continue;\n \t}\n     }\n@@ -4324,6 +4325,7 @@ simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t  continue;\n \n \tcase REF_SUBSTRING:\n+\tcase REF_INQUIRY:\n \t  continue;\n \t}\n     }\n@@ -5395,7 +5397,7 @@ gfc_simplify_minmaxloc (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n \n       back_val = back->value.logical;\n     }\n-  \n+\n   if (sign < 0)\n     init_val = INT_MAX;\n   else if (sign > 0)"}, {"sha": "04fb4262b243e0b3f60b4042334a790f397a3b84", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -2078,6 +2078,9 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n \t  mpz_clear (char_len);\n \t  return;\n \n+\tcase REF_INQUIRY:\n+\t  break;\n+\n \tdefault:\n \t gcc_unreachable ();\n \t}"}, {"sha": "64bda4c1e69e568a3b99d4b3f2add0e91e6ed272", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -2510,6 +2510,40 @@ conv_parent_component_references (gfc_se * se, gfc_ref * ref)\n   conv_parent_component_references (se, &parent);\n }\n \n+\n+static void\n+conv_inquiry (gfc_se * se, gfc_ref * ref, gfc_expr *expr, gfc_typespec *ts)\n+{\n+  tree res = se->expr;\n+\n+  switch (ref->u.i)\n+    {\n+    case INQUIRY_RE:\n+      res = fold_build1_loc (input_location, REALPART_EXPR,\n+\t\t\t     TREE_TYPE (TREE_TYPE (res)), res);\n+      break;\n+\n+    case INQUIRY_IM:\n+      res = fold_build1_loc (input_location, IMAGPART_EXPR,\n+\t\t\t     TREE_TYPE (TREE_TYPE (res)), res);\n+      break;\n+\n+    case INQUIRY_KIND:\n+      res = build_int_cst (gfc_typenode_for_spec (&expr->ts),\n+\t\t\t   ts->kind);\n+      break;\n+\n+    case INQUIRY_LEN:\n+      res = fold_convert (gfc_typenode_for_spec (&expr->ts),\n+\t\t\t  se->string_length);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  se->expr = res;\n+}\n+\n /* Return the contents of a variable. Also handles reference/pointer\n    variables (all Fortran pointer references are implicit).  */\n \n@@ -2720,6 +2754,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       gcc_assert (se->string_length);\n     }\n \n+  gfc_typespec *ts = &sym->ts;\n   while (ref)\n     {\n       switch (ref->type)\n@@ -2740,6 +2775,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tcase REF_COMPONENT:\n+\t  ts = &ref->u.c.component->ts;\n \t  if (first_time && is_classarray && sym->attr.dummy\n \t      && se->descriptor_only\n \t      && !CLASS_DATA (sym)->attr.allocatable\n@@ -2767,6 +2803,10 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t\t\t      expr->symtree->name, &expr->where);\n \t  break;\n \n+\tcase REF_INQUIRY:\n+\t  conv_inquiry (se, ref, expr, ts);\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t  break;\n@@ -4135,6 +4175,7 @@ gfc_apply_interface_mapping_to_ref (gfc_interface_mapping * mapping,\n \tbreak;\n \n       case REF_COMPONENT:\n+      case REF_INQUIRY:\n \tbreak;\n \n       case REF_SUBSTRING:"}, {"sha": "4f1076169a10b76569c2628f49fa75ba55f638e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -1,3 +1,10 @@\n+2018-11-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40196\n+\t* gfortran.dg/inquiry_part_ref_1.f08: New test.\n+\t* gfortran.dg/inquiry_part_ref_2.f90: New test.\n+\t* gfortran.dg/inquiry_part_ref_3.f90: New test.\n+\n 2018-11-01  Paul Koning  <ni1d@arrl.net>\n \n \t* gcc.c-torture/execute/20010904-1.c: Align 2 if pdp11."}, {"sha": "5ef3b480a49fe6f7f7c34c47b89d04d37193281b", "filename": "gcc/testsuite/gfortran.dg/inquiry_type_ref_1.f08", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_1.f08?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+!\n+! Test the implementation of inquiry part references (PR40196).\n+! \"Type parameter inquiry (str%len, a%kind) and Complex parts (z%re, z%im)\"\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module m\n+  complex, target :: z\n+  character (:), allocatable :: str\n+  real, pointer :: r => z%re\n+  real, pointer :: i => z%im\n+  type :: mytype\n+    complex :: z = ( 10.0, 11.0 )\n+    character(6) :: str\n+  end type\n+end module\n+\n+  use m\n+\n+  type(mytype) :: der\n+  integer :: j\n+  character (len=der%str%len) :: str1\n+  complex, parameter :: zc = ( 99.0, 199.0 )\n+  REAL, parameter :: rc = zc%re\n+  REAL, parameter :: ic = zc%im\n+\n+  z = (2.0,4.0)\n+  str = \"abcd\"\n+\n+! Check the pointer initializations\n+  if (r .ne. real (z)) stop 1\n+  if (i .ne. imag (z)) stop 2\n+\n+! Check the use of inquiry part_refs on lvalues and rvalues.\n+  z%im = 4.0 * z%re\n+\n+! Check that the result is OK.\n+  if (z%re .ne. real (z)) stop 3\n+  if (abs (z*im - 4.0 * real (z)) .lt. 1e-6) stop 4\n+\n+! Check a double inquiry part_ref.\n+  if (z%im%kind .ne. kind (z)) stop 5\n+\n+! Test on deferred character length.\n+  if (str%kind .ne. kind (str)) stop 6\n+  if (str%len .ne. len (str)) stop 7\n+\n+! Check the use in specification expressions.\n+  if (len (der%str) .ne. LEN (str1)) stop 8\n+  if (rc .ne. real (zc)) stop 9\n+  if (ic .ne. aimag (zc)) stop 10\n+\n+end\n+"}, {"sha": "3c33dcca6d13f1cf1a624b6338bc6ee019d022e4", "filename": "gcc/testsuite/gfortran.dg/inquiry_type_ref_2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_2.f90?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! Test the implementation of inquiry part references (PR40196):\n+! Check the standards are correctly adhered to.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+program main\n+   character(4) :: a\n+   complex :: z\n+   integer :: i\n+   a%len = 2       ! { dg-error \"Fortran 2003: LEN part_ref\" }\n+   i = a%kind      ! { dg-error \"Fortran 2003: KIND part_ref\" }\n+   print *, z%re   ! { dg-error \"Fortran 2008: RE or IM part_ref\" }\n+   print *, z%im   ! { dg-error \"Fortran 2008: RE or IM part_ref\" }\n+end"}, {"sha": "4e8d8a07b4e6ec5874507ed0f720f38e24b22375", "filename": "gcc/testsuite/gfortran.dg/inquiry_type_ref_3.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5fbc2f36a291cbe80c4393950d6db9b56a34b05/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finquiry_type_ref_3.f90?ref=a5fbc2f36a291cbe80c4393950d6db9b56a34b05", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+!\n+! Test the implementation of inquiry part references (PR40196):\n+! Check errors on invalid code.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+program main\n+   type :: t\n+     complex :: z\n+     character(6) :: a\n+   end type\n+   character(4) :: a\n+   character(:), allocatable :: b\n+   real :: z\n+   integer :: i\n+   type(t) :: s\n+   b = \"abcdefg\"\n+   a%kind = 2        ! { dg-error \"Assignment to a constant expression\" }\n+   b%len = 2         ! { dg-error \"Assignment to a LEN or KIND part_ref\" }\n+   i = a%kind        ! OK\n+   i = b%len         ! OK\n+   print *, z%re     ! { dg-error \"must be applied to a COMPLEX expression\" }\n+   print *, z%im     ! { dg-error \"must be applied to a COMPLEX expression\" }\n+   i%re = 2.0        ! { dg-error \"must be applied to a COMPLEX expression\" }\n+   print *, i%len    ! { dg-error \"must be applied to a CHARACTER expression\" }\n+   print *, s%kind   ! { dg-error \"is not a member\" }\n+   print *, s%z%kind ! OK\n+   print *, s%a%len  ! OK\n+end"}]}