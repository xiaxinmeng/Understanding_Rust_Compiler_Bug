{"sha": "b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhYjdmYzg0NDljNDVlZDEwNWVmMzZlNjQwYmE0M2U2ZjZhZjZiNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-23T19:17:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-23T19:17:35Z"}, "message": "expmed.c (store_split_bit_field): Update the calls to extract_fixed_bit_field.\n\ngcc/\n\t* expmed.c (store_split_bit_field): Update the calls to\n\textract_fixed_bit_field.  In the big-endian case, always\n\tuse the mode of OP0 to count the number of significant bits.\n\t(extract_bit_field_1): Remove unit, offset, bitpos and\n\tbyte_offset from the outermost scope.  Express conditions in terms\n\tof bitnum rather than offset, bitpos and byte_offset.  Move the\n\tcomputation of MODE1 to the block that needs it.  Use MODE unless\n\tthe TMODE-based mode_for_size calculation succeeds.  Split the\n\tplain move cases into two, one for memory accesses and one for\n\tregister accesses.  Generalize the memory case, freeing it from\n\tthe old register-based endian checks.  Move the INT_MODE calculation\n\tabove the code that needs it.  Use simplify_gen_subreg to handle\n\tmultiword OP0s.  If the field still spans several words, pass it\n\tdirectly to extract_split_bit_field.  Assume after that point\n\tthat both targets and register sources fit within a word.\n\tReplace x-prefixed variables with non-prefixed forms.\n\tCompute the bitpos for ext(z)v register operands directly in the\n\tchosen unit size, rather than going through an intermediate\n\tBITS_PER_WORD unit size.  Simplify the containment check\n\tused when forcing OP0 into a register.  Update the call to\n\textract_fixed_bit_field.\n\t(extract_fixed_bit_field): Replace the bitpos and offset parameters\n\twith a single bitnum parameter, of the same form as extract_bit_field.\n\tAssume that OP0 contains the full field.  Simplify the memory offset\n\tcalculation and containment check for volatile bitfields.  Make the\n\toffset explicit when volatile bitfields force a misaligned access.\n\tRemove WARNED and fix long lines.  Assert that the processed OP0\n\thas an integral mode.\n\t(store_split_bit_field): Update the call to store_fixed_bit_field.\n\nFrom-SVN: r192741", "tree": {"sha": "c8c8d433853cf42b50b757be0c2e322949cf4672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8c8d433853cf42b50b757be0c2e322949cf4672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bebf0797d84922ef5afe9553ba9c1c0837a4888c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebf0797d84922ef5afe9553ba9c1c0837a4888c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebf0797d84922ef5afe9553ba9c1c0837a4888c"}], "stats": {"total": 397, "additions": 183, "deletions": 214}, "files": [{"sha": "66f3034831256bbc0484be6e3bb53442856491d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4", "patch": "@@ -1,3 +1,35 @@\n+2012-10-23  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* expmed.c (store_split_bit_field): Update the calls to\n+\textract_fixed_bit_field.  In the big-endian case, always\n+\tuse the mode of OP0 to count the number of significant bits.\n+\t(extract_bit_field_1): Remove unit, offset, bitpos and\n+\tbyte_offset from the outermost scope.  Express conditions in terms\n+\tof bitnum rather than offset, bitpos and byte_offset.  Move the\n+\tcomputation of MODE1 to the block that needs it.  Use MODE unless\n+\tthe TMODE-based mode_for_size calculation succeeds.  Split the\n+\tplain move cases into two, one for memory accesses and one for\n+\tregister accesses.  Generalize the memory case, freeing it from\n+\tthe old register-based endian checks.  Move the INT_MODE calculation\n+\tabove the code that needs it.  Use simplify_gen_subreg to handle\n+\tmultiword OP0s.  If the field still spans several words, pass it\n+\tdirectly to extract_split_bit_field.  Assume after that point\n+\tthat both targets and register sources fit within a word.\n+\tReplace x-prefixed variables with non-prefixed forms.\n+\tCompute the bitpos for ext(z)v register operands directly in the\n+\tchosen unit size, rather than going through an intermediate\n+\tBITS_PER_WORD unit size.  Simplify the containment check\n+\tused when forcing OP0 into a register.  Update the call to\n+\textract_fixed_bit_field.\n+\t(extract_fixed_bit_field): Replace the bitpos and offset parameters\n+\twith a single bitnum parameter, of the same form as extract_bit_field.\n+\tAssume that OP0 contains the full field.  Simplify the memory offset\n+\tcalculation and containment check for volatile bitfields.  Make the\n+\toffset explicit when volatile bitfields force a misaligned access.\n+\tRemove WARNED and fix long lines.  Assert that the processed OP0\n+\thas an integral mode.\n+\t(store_split_bit_field): Update the call to store_fixed_bit_field.\n+\n 2012-10-23  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* expmed.c (lowpart_bit_field_p): New function."}, {"sha": "1708f57f0be6744ab6539152684c1b3864216b4f", "filename": "gcc/expmed.c", "status": "modified", "additions": 151, "deletions": 214, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b8ab7fc8449c45ed105ef36e640ba43e6f6af6b4", "patch": "@@ -56,7 +56,6 @@ static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   rtx);\n static rtx extract_fixed_bit_field (enum machine_mode, rtx,\n-\t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n static rtx mask_rtx (enum machine_mode, int, int, int);\n@@ -1128,28 +1127,21 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n       if (BYTES_BIG_ENDIAN)\n \t{\n-\t  int total_bits;\n-\n-\t  /* We must do an endian conversion exactly the same way as it is\n-\t     done in extract_bit_field, so that the two calls to\n-\t     extract_fixed_bit_field will have comparable arguments.  */\n-\t  if (!MEM_P (value) || GET_MODE (value) == BLKmode)\n-\t    total_bits = BITS_PER_WORD;\n-\t  else\n-\t    total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n-\n \t  /* Fetch successively less significant portions.  */\n \t  if (CONST_INT_P (value))\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> (bitsize - bitsdone - thissize))\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n \t  else\n-\t    /* The args are chosen so that the last part includes the\n-\t       lsb.  Give extract_bit_field the value it needs (with\n-\t       endianness compensation) to fetch the piece we want.  */\n-\t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n-\t\t\t\t\t    total_bits - bitsize + bitsdone,\n-\t\t\t\t\t    NULL_RTX, 1, false);\n+\t    {\n+\t      int total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n+\t      /* The args are chosen so that the last part includes the\n+\t\t lsb.  Give extract_bit_field the value it needs (with\n+\t\t endianness compensation) to fetch the piece we want.  */\n+\t      part = extract_fixed_bit_field (word_mode, value, thissize,\n+\t\t\t\t\t      total_bits - bitsize + bitsdone,\n+\t\t\t\t\t      NULL_RTX, 1, false);\n+\t    }\n \t}\n       else\n \t{\n@@ -1159,7 +1151,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t     >> bitsdone)\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n \t  else\n-\t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n+\t    part = extract_fixed_bit_field (word_mode, value, thissize,\n \t\t\t\t\t    bitsdone, NULL_RTX, 1, false);\n \t}\n \n@@ -1240,14 +1232,10 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t     enum machine_mode mode, enum machine_mode tmode,\n \t\t     bool fallback_p)\n {\n-  unsigned int unit\n-    = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n-  unsigned HOST_WIDE_INT offset, bitpos;\n   rtx op0 = str_rtx;\n   enum machine_mode int_mode;\n   enum machine_mode ext_mode;\n   enum machine_mode mode1;\n-  int byte_offset;\n \n   if (tmode == VOIDmode)\n     tmode = mode;\n@@ -1365,37 +1353,10 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       }\n   }\n \n-  /* Extraction of a full-word or multi-word value from a structure\n-     in a register or aligned memory can be done with just a SUBREG.\n-     A subword value in the least significant part of a register\n-     can also be extracted with a SUBREG.  For this, we need the\n-     byte offset of the value in op0.  */\n-\n-  bitpos = bitnum % unit;\n-  offset = bitnum / unit;\n-  byte_offset = bitpos / BITS_PER_UNIT + offset * UNITS_PER_WORD;\n-\n-  /* If OP0 is a register, BITPOS must count within a word.\n-     But as we have it, it counts within whatever size OP0 now has.\n-     On a bigendian machine, these are not the same, so convert.  */\n-  if (BYTES_BIG_ENDIAN\n-      && !MEM_P (op0)\n-      && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n-    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-\n   /* ??? We currently assume TARGET is at least as big as BITSIZE.\n      If that's wrong, the solution is to test for it and set TARGET to 0\n      if needed.  */\n \n-  /* Only scalar integer modes can be converted via subregs.  There is an\n-     additional problem for FP modes here in that they can have a precision\n-     which is different from the size.  mode_for_size uses precision, but\n-     we want a mode based on the size, so we must avoid calling it for FP\n-     modes.  */\n-  mode1  = (SCALAR_INT_MODE_P (tmode)\n-\t    ? mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0)\n-\t    : mode);\n-\n   /* If the bitfield is volatile, we need to make sure the access\n      remains on a type-aligned boundary.  */\n   if (GET_CODE (op0) == MEM\n@@ -1404,39 +1365,48 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       && flag_strict_volatile_bitfields > 0)\n     goto no_subreg_mode_swap;\n \n-  if (((bitsize >= BITS_PER_WORD && bitsize == GET_MODE_BITSIZE (mode)\n-\t&& bitpos % BITS_PER_WORD == 0)\n-       || (mode1 != BLKmode\n-\t   /* ??? The big endian test here is wrong.  This is correct\n-\t      if the value is in a register, and if mode_for_size is not\n-\t      the same mode as op0.  This causes us to get unnecessarily\n-\t      inefficient code from the Thumb port when -mbig-endian.  */\n-\t   && (BYTES_BIG_ENDIAN\n-\t       ? bitpos + bitsize == BITS_PER_WORD\n-\t       : bitpos == 0)))\n-      && ((!MEM_P (op0)\n-\t   && TRULY_NOOP_TRUNCATION_MODES_P (mode1, GET_MODE (op0))\n-\t   && GET_MODE_SIZE (mode1) != 0\n-\t   && byte_offset % GET_MODE_SIZE (mode1) == 0)\n-\t  || (MEM_P (op0)\n-\t      && (! SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (op0))\n-\t\t  || (offset * BITS_PER_UNIT % bitsize == 0\n-\t\t      && MEM_ALIGN (op0) % bitsize == 0)))))\n+  /* Only scalar integer modes can be converted via subregs.  There is an\n+     additional problem for FP modes here in that they can have a precision\n+     which is different from the size.  mode_for_size uses precision, but\n+     we want a mode based on the size, so we must avoid calling it for FP\n+     modes.  */\n+  mode1 = mode;\n+  if (SCALAR_INT_MODE_P (tmode))\n     {\n-      if (MEM_P (op0))\n-\top0 = adjust_bitfield_address (op0, mode1, offset);\n-      else if (mode1 != GET_MODE (op0))\n-\t{\n-\t  rtx sub = simplify_gen_subreg (mode1, op0, GET_MODE (op0),\n-\t\t\t\t\t byte_offset);\n-\t  if (sub == NULL)\n-\t    goto no_subreg_mode_swap;\n-\t  op0 = sub;\n-\t}\n-      if (mode1 != mode)\n-\treturn convert_to_mode (tmode, op0, unsignedp);\n-      return op0;\n+      enum machine_mode try_mode = mode_for_size (bitsize,\n+\t\t\t\t\t\t  GET_MODE_CLASS (tmode), 0);\n+      if (try_mode != BLKmode)\n+\tmode1 = try_mode;\n+    }\n+  gcc_assert (mode1 != BLKmode);\n+\n+  /* Extraction of a full MODE1 value can be done with a subreg as long\n+     as the least significant bit of the value is the least significant\n+     bit of either OP0 or a word of OP0.  */\n+  if (!MEM_P (op0)\n+      && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n+      && bitsize == GET_MODE_BITSIZE (mode1)\n+      && TRULY_NOOP_TRUNCATION_MODES_P (mode1, GET_MODE (op0)))\n+    {\n+      rtx sub = simplify_gen_subreg (mode1, op0, GET_MODE (op0),\n+\t\t\t\t     bitnum / BITS_PER_UNIT);\n+      if (sub)\n+\treturn convert_extracted_bit_field (sub, mode, tmode, unsignedp);\n+    }\n+\n+  /* Extraction of a full MODE1 value can be done with a load as long as\n+     the field is on a byte boundary and is sufficiently aligned.  */\n+  if (MEM_P (op0)\n+      && bitnum % BITS_PER_UNIT == 0\n+      && bitsize == GET_MODE_BITSIZE (mode1)\n+      && (!SLOW_UNALIGNED_ACCESS (mode1, MEM_ALIGN (op0))\n+\t  || (bitnum % bitsize == 0\n+\t      && MEM_ALIGN (op0) % bitsize == 0)))\n+    {\n+      op0 = adjust_bitfield_address (op0, mode1, bitnum / BITS_PER_UNIT);\n+      return convert_extracted_bit_field (op0, mode, tmode, unsignedp);\n     }\n+\n  no_subreg_mode_swap:\n \n   /* Handle fields bigger than a word.  */\n@@ -1517,35 +1487,25 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t   GET_MODE_BITSIZE (mode) - bitsize, NULL_RTX, 0);\n     }\n \n-  /* From here on we know the desired field is smaller than a word.  */\n-\n-  /* Check if there is a correspondingly-sized integer field, so we can\n-     safely extract it as one size of integer, if necessary; then\n-     truncate or extend to the size that is wanted; then use SUBREGs or\n-     convert_to_mode to get one of the modes we really wanted.  */\n-\n-  int_mode = int_mode_for_mode (tmode);\n-  if (int_mode == BLKmode)\n-    int_mode = int_mode_for_mode (mode);\n-  /* Should probably push op0 out to memory and then do a load.  */\n-  gcc_assert (int_mode != BLKmode);\n-\n-  /* OFFSET is the number of words or bytes (UNIT says which)\n-     from STR_RTX to the first word or byte containing part of the field.  */\n-  if (!MEM_P (op0))\n+  /* If OP0 is a multi-word register, narrow it to the affected word.\n+     If the region spans two words, defer to extract_split_bit_field.  */\n+  if (!MEM_P (op0) && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n     {\n-      if (offset != 0\n-\t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n+      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n+\t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n+      bitnum %= BITS_PER_WORD;\n+      if (bitnum + bitsize > BITS_PER_WORD)\n \t{\n-\t  if (!REG_P (op0))\n-\t    op0 = copy_to_reg (op0);\n-\t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n-\t\t                op0, (offset * UNITS_PER_WORD));\n+\t  if (!fallback_p)\n+\t    return NULL_RTX;\n+\t  target = extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n+\t  return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n \t}\n-      offset = 0;\n     }\n \n-  /* Now OFFSET is nonzero only for memory operands.  */\n+  /* From here on we know the desired field is smaller than a word.\n+     If OP0 is a register, it too fits within a word.  */\n+\n   ext_mode = mode_for_extraction (unsignedp ? EP_extzv : EP_extv, 0);\n   if (ext_mode != MAX_MACHINE_MODE\n       && bitsize > 0\n@@ -1556,38 +1516,42 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t   && flag_strict_volatile_bitfields > 0)\n       /* If op0 is a register, we need it in EXT_MODE to make it\n \t acceptable to the format of ext(z)v.  */\n-      && !(GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode)\n-      && !((REG_P (op0) || GET_CODE (op0) == SUBREG)\n-\t   && (bitsize + bitpos > GET_MODE_BITSIZE (ext_mode))))\n+      && !(GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode))\n     {\n       struct expand_operand ops[4];\n-      unsigned HOST_WIDE_INT xbitpos = bitpos, xoffset = offset;\n+      unsigned HOST_WIDE_INT bitpos = bitnum;\n       rtx xop0 = op0;\n       rtx xtarget = target;\n       rtx xspec_target = target;\n       rtx xspec_target_subreg = 0;\n+      unsigned unit = GET_MODE_BITSIZE (ext_mode);\n \n       /* If op0 is a register, we need it in EXT_MODE to make it\n \t acceptable to the format of ext(z)v.  */\n       if (REG_P (xop0) && GET_MODE (xop0) != ext_mode)\n \txop0 = gen_lowpart_SUBREG (ext_mode, xop0);\n-      if (MEM_P (xop0))\n-\t/* Get ref to first byte containing part of the field.  */\n-\txop0 = adjust_bitfield_address (xop0, byte_mode, xoffset);\n \n-      /* Now convert from counting within UNIT to counting in EXT_MODE.  */\n-      if (BYTES_BIG_ENDIAN && !MEM_P (xop0))\n-\txbitpos += GET_MODE_BITSIZE (ext_mode) - unit;\n-\n-      unit = GET_MODE_BITSIZE (ext_mode);\n+      if (MEM_P (xop0))\n+\t{\n+\t  /* Get a reference to the first byte of the field.  */\n+\t  xop0 = adjust_bitfield_address (xop0, byte_mode,\n+\t\t\t\t\t  bitpos / BITS_PER_UNIT);\n+\t  bitpos %= BITS_PER_UNIT;\n+\t}\n+      else\n+\t{\n+\t  /* Convert from counting within OP0 to counting in EXT_MODE.  */\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\t}\n \n       /* If BITS_BIG_ENDIAN is zero on a BYTES_BIG_ENDIAN machine, we count\n          \"backwards\" from the size of the unit we are extracting from.\n \t Otherwise, we count bits from the most significant on a\n \t BYTES/BITS_BIG_ENDIAN machine.  */\n \n       if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\txbitpos = unit - bitsize - xbitpos;\n+\tbitpos = unit - bitsize - bitpos;\n \n       if (xtarget == 0)\n \txtarget = xspec_target = gen_reg_rtx (tmode);\n@@ -1613,7 +1577,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       create_output_operand (&ops[0], xtarget, ext_mode);\n       create_fixed_operand (&ops[1], xop0);\n       create_integer_operand (&ops[2], bitsize);\n-      create_integer_operand (&ops[3], xbitpos);\n+      create_integer_operand (&ops[3], bitpos);\n       if (maybe_expand_insn (unsignedp ? CODE_FOR_extzv : CODE_FOR_extv,\n \t\t\t     4, ops))\n \t{\n@@ -1652,26 +1616,25 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  && !(SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n \t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n \t{\n-\t  unsigned HOST_WIDE_INT xoffset, xbitpos;\n+\t  unsigned HOST_WIDE_INT offset, bitpos;\n \n \t  /* Compute the offset as a multiple of this unit,\n \t     counting in bytes.  */\n-\t  unit = GET_MODE_BITSIZE (bestmode);\n-\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t  xbitpos = bitnum % unit;\n+\t  unsigned int unit = GET_MODE_BITSIZE (bestmode);\n+\t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n+\t  bitpos = bitnum % unit;\n \n \t  /* Make sure the register is big enough for the whole field.  */\n-\t  if (xoffset * BITS_PER_UNIT + unit\n-\t      >= offset * BITS_PER_UNIT + bitsize)\n+\t  if (bitpos + bitsize <= unit)\n \t    {\n \t      rtx last, result, xop0;\n \n \t      last = get_last_insn ();\n \n \t      /* Fetch it to a register in that size.  */\n-\t      xop0 = adjust_bitfield_address (op0, bestmode, xoffset);\n+\t      xop0 = adjust_bitfield_address (op0, bestmode, offset);\n \t      xop0 = force_reg (bestmode, xop0);\n-\t      result = extract_bit_field_1 (xop0, bitsize, xbitpos,\n+\t      result = extract_bit_field_1 (xop0, bitsize, bitpos,\n \t\t\t\t\t    unsignedp, packedp, target,\n \t\t\t\t\t    mode, tmode, false);\n \t      if (result)\n@@ -1685,8 +1648,16 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!fallback_p)\n     return NULL;\n \n-  target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n-\t\t\t\t    bitpos, target, unsignedp, packedp);\n+  /* Find a correspondingly-sized integer field, so we can apply\n+     shifts and masks to it.  */\n+  int_mode = int_mode_for_mode (tmode);\n+  if (int_mode == BLKmode)\n+    int_mode = int_mode_for_mode (mode);\n+  /* Should probably push op0 out to memory and then do a load.  */\n+  gcc_assert (int_mode != BLKmode);\n+\n+  target = extract_fixed_bit_field (int_mode, op0, bitsize, bitnum,\n+\t\t\t\t    target, unsignedp, packedp);\n   return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n }\n \n@@ -1716,16 +1687,8 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t      target, mode, tmode, true);\n }\n \f\n-/* Extract a bit field using shifts and boolean operations\n-   Returns an rtx to represent the value.\n-   OP0 addresses a register (word) or memory (byte).\n-   BITPOS says which bit within the word or byte the bit field starts in.\n-   OFFSET says how many bytes farther the bit field starts;\n-    it is 0 if OP0 is a register.\n-   BITSIZE says how many bits long the bit field is.\n-    (If OP0 is a register, it may be narrower than a full word,\n-     but BITPOS still counts within a full word,\n-     which is significant on bigendian machines.)\n+/* Use shifts and boolean operations to extract a field of BITSIZE bits\n+   from bit BITNUM of OP0.\n \n    UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).\n    PACKEDP is true if the field has the packed attribute.\n@@ -1736,21 +1699,13 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n static rtx\n extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n-\t\t\t unsigned HOST_WIDE_INT offset,\n \t\t\t unsigned HOST_WIDE_INT bitsize,\n-\t\t\t unsigned HOST_WIDE_INT bitpos, rtx target,\n+\t\t\t unsigned HOST_WIDE_INT bitnum, rtx target,\n \t\t\t int unsignedp, bool packedp)\n {\n-  unsigned int total_bits = BITS_PER_WORD;\n   enum machine_mode mode;\n \n-  if (GET_CODE (op0) == SUBREG || REG_P (op0))\n-    {\n-      /* Special treatment for a bit field split across two registers.  */\n-      if (bitsize + bitpos > BITS_PER_WORD)\n-\treturn extract_split_bit_field (op0, bitsize, bitpos, unsignedp);\n-    }\n-  else\n+  if (MEM_P (op0))\n     {\n       /* Get the proper mode to use for this field.  We want a mode that\n \t includes the entire field.  If such a mode would be larger than\n@@ -1767,113 +1722,97 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t    mode = tmode;\n \t}\n       else\n-\tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT, 0, 0,\n+\tmode = get_best_mode (bitsize, bitnum, 0, 0,\n \t\t\t      MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t/* The only way this should occur is if the field spans word\n \t   boundaries.  */\n-\treturn extract_split_bit_field (op0, bitsize,\n-\t\t\t\t\tbitpos + offset * BITS_PER_UNIT,\n-\t\t\t\t\tunsignedp);\n-\n-      total_bits = GET_MODE_BITSIZE (mode);\n+\treturn extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n \n-      /* Make sure bitpos is valid for the chosen mode.  Adjust BITPOS to\n-\t be in the range 0 to total_bits-1, and put any excess bytes in\n-\t OFFSET.  */\n-      if (bitpos >= total_bits)\n-\t{\n-\t  offset += (bitpos / total_bits) * (total_bits / BITS_PER_UNIT);\n-\t  bitpos -= ((bitpos / total_bits) * (total_bits / BITS_PER_UNIT)\n-\t\t     * BITS_PER_UNIT);\n-\t}\n+      unsigned int total_bits = GET_MODE_BITSIZE (mode);\n+      HOST_WIDE_INT bit_offset = bitnum - bitnum % total_bits;\n \n-      /* If we're accessing a volatile MEM, we can't do the next\n-\t alignment step if it results in a multi-word access where we\n-\t otherwise wouldn't have one.  So, check for that case\n-\t here.  */\n+      /* If we're accessing a volatile MEM, we can't apply BIT_OFFSET\n+\t if it results in a multi-word access where we otherwise wouldn't\n+\t have one.  So, check for that case here.  */\n       if (MEM_P (op0)\n \t  && MEM_VOLATILE_P (op0)\n \t  && flag_strict_volatile_bitfields > 0\n-\t  && bitpos + bitsize <= total_bits\n-\t  && bitpos + bitsize + (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT > total_bits)\n+\t  && bitnum % BITS_PER_UNIT + bitsize <= total_bits\n+\t  && bitnum % GET_MODE_BITSIZE (mode) + bitsize > total_bits)\n \t{\n \t  if (STRICT_ALIGNMENT)\n \t    {\n \t      static bool informed_about_misalignment = false;\n-\t      bool warned;\n \n \t      if (packedp)\n \t\t{\n \t\t  if (bitsize == total_bits)\n-\t\t    warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t\t\t \"multiple accesses to volatile structure member\"\n-\t\t\t\t\t \" because of packed attribute\");\n+\t\t    warning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t\t\"multiple accesses to volatile structure\"\n+\t\t\t\t\" member because of packed attribute\");\n \t\t  else\n-\t\t    warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t\t\t \"multiple accesses to volatile structure bitfield\"\n-\t\t\t\t\t \" because of packed attribute\");\n+\t\t    warning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t\t\"multiple accesses to volatile structure\"\n+\t\t\t\t\" bitfield because of packed attribute\");\n \n-\t\t  return extract_split_bit_field (op0, bitsize,\n-\t\t\t\t\t\t  bitpos + offset * BITS_PER_UNIT,\n+\t\t  return extract_split_bit_field (op0, bitsize, bitnum,\n \t\t\t\t\t\t  unsignedp);\n \t\t}\n \n \t      if (bitsize == total_bits)\n-\t\twarned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t\t     \"mis-aligned access used for structure member\");\n+\t\twarning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t    \"mis-aligned access used for structure member\");\n \t      else\n-\t\twarned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t\t     \"mis-aligned access used for structure bitfield\");\n+\t\twarning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t    \"mis-aligned access used for structure bitfield\");\n \n-\t      if (! informed_about_misalignment && warned)\n+\t      if (! informed_about_misalignment)\n \t\t{\n \t\t  informed_about_misalignment = true;\n \t\t  inform (input_location,\n-\t\t\t  \"when a volatile object spans multiple type-sized locations,\"\n-\t\t\t  \" the compiler must choose between using a single mis-aligned access to\"\n-\t\t\t  \" preserve the volatility, or using multiple aligned accesses to avoid\"\n-\t\t\t  \" runtime faults; this code may fail at runtime if the hardware does\"\n-\t\t\t  \" not allow this access\");\n+\t\t\t  \"when a volatile object spans multiple type-sized\"\n+\t\t\t  \" locations, the compiler must choose between using\"\n+\t\t\t  \" a single mis-aligned access to preserve the\"\n+\t\t\t  \" volatility, or using multiple aligned accesses\"\n+\t\t\t  \" to avoid runtime faults; this code may fail at\"\n+\t\t\t  \" runtime if the hardware does not allow this\"\n+\t\t\t  \" access\");\n \t\t}\n \t    }\n+\t  bit_offset = bitnum - bitnum % BITS_PER_UNIT;\n \t}\n-      else\n-\t{\n-\n-\t  /* Get ref to an aligned byte, halfword, or word containing the field.\n-\t     Adjust BITPOS to be position within a word,\n-\t     and OFFSET to be the offset of that word.\n-\t     Then alter OP0 to refer to that word.  */\n-\t  bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n-\t  offset -= (offset % (total_bits / BITS_PER_UNIT));\n-\t}\n-\n-      op0 = adjust_bitfield_address (op0, mode, offset);\n+      op0 = adjust_bitfield_address (op0, mode, bit_offset / BITS_PER_UNIT);\n+      bitnum -= bit_offset;\n     }\n \n   mode = GET_MODE (op0);\n+  gcc_assert (SCALAR_INT_MODE_P (mode));\n+\n+  /* Note that bitsize + bitnum can be greater than GET_MODE_BITSIZE (mode)\n+     for invalid input, such as extract equivalent of f5 from\n+     gcc.dg/pr48335-2.c.  */\n \n   if (BYTES_BIG_ENDIAN)\n-    /* BITPOS is the distance between our msb and that of OP0.\n+    /* BITNUM is the distance between our msb and that of OP0.\n        Convert it to the distance from the lsb.  */\n-    bitpos = total_bits - bitsize - bitpos;\n+    bitnum = GET_MODE_BITSIZE (mode) - bitsize - bitnum;\n \n-  /* Now BITPOS is always the distance between the field's lsb and that of OP0.\n+  /* Now BITNUM is always the distance between the field's lsb and that of OP0.\n      We have reduced the big-endian case to the little-endian case.  */\n \n   if (unsignedp)\n     {\n-      if (bitpos)\n+      if (bitnum)\n \t{\n \t  /* If the field does not already start at the lsb,\n \t     shift it so it does.  */\n \t  /* Maybe propagate the target for the shift.  */\n \t  rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n \t  if (tmode != mode)\n \t    subtarget = 0;\n-\t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, bitpos, subtarget, 1);\n+\t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, bitnum, subtarget, 1);\n \t}\n       /* Convert the value to the desired mode.  */\n       if (mode != tmode)\n@@ -1882,7 +1821,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n       /* Unless the msb of the field used to be the msb when we shifted,\n \t mask out the upper bits.  */\n \n-      if (GET_MODE_BITSIZE (mode) != bitpos + bitsize)\n+      if (GET_MODE_BITSIZE (mode) != bitnum + bitsize)\n \treturn expand_binop (GET_MODE (op0), and_optab, op0,\n \t\t\t     mask_rtx (GET_MODE (op0), 0, bitsize, 0),\n \t\t\t     target, 1, OPTAB_LIB_WIDEN);\n@@ -1897,7 +1836,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_BITSIZE (mode) >= bitsize + bitpos)\n+    if (GET_MODE_BITSIZE (mode) >= bitsize + bitnum)\n       {\n \top0 = convert_to_mode (mode, op0, 0);\n \tbreak;\n@@ -1906,9 +1845,9 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n   if (mode != tmode)\n     target = 0;\n \n-  if (GET_MODE_BITSIZE (mode) != (bitsize + bitpos))\n+  if (GET_MODE_BITSIZE (mode) != (bitsize + bitnum))\n     {\n-      int amount = GET_MODE_BITSIZE (mode) - (bitsize + bitpos);\n+      int amount = GET_MODE_BITSIZE (mode) - (bitsize + bitnum);\n       /* Maybe propagate the target for the shift.  */\n       rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n       op0 = expand_shift (LSHIFT_EXPR, mode, op0, amount, subtarget, 1);\n@@ -2014,11 +1953,9 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n       /* Extract the parts in bit-counting order,\n \t whose meaning is determined by BYTES_PER_UNIT.\n-\t OFFSET is in UNITs, and UNIT is in bits.\n-\t extract_fixed_bit_field wants offset in bytes.  */\n-      part = extract_fixed_bit_field (word_mode, word,\n-\t\t\t\t      offset * unit / BITS_PER_UNIT,\n-\t\t\t\t      thissize, thispos, 0, 1, false);\n+\t OFFSET is in UNITs, and UNIT is in bits.  */\n+      part = extract_fixed_bit_field (word_mode, word, thissize,\n+\t\t\t\t      offset * unit + thispos, 0, 1, false);\n       bitsdone += thissize;\n \n       /* Shift this part into place for the result.  */"}]}