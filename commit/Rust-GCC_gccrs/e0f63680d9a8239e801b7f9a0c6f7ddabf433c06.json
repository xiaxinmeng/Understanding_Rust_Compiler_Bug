{"sha": "e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBmNjM2ODBkOWE4MjM5ZTgwMWI3ZjlhMGM2ZjdkZGFiZjQzM2MwNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T10:25:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T10:25:53Z"}, "message": "[multiple changes]\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_Min_Max_Attribute): New procedure\n\t(Expand_N_Attribute_Reference): Use this procedure for Min and Max.\n\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Remove object\n\tdeclarations from list of actions.\n\t* output.ads, output.adb (Delete_Last_Char): New procedure.\n\t* sinfo.ads: Document handling of Mod and expression with actions\n\tin Modify_Tree_For_C mode.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch9.adb (P_Task): Add a null statement to produce a\n\twell-formed task body when due to a previous syntax error the\n\tstatement list is empty.\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Check_Dependency_Clause): Account\n\tfor the case where a state with a non-null refinement matches a\n\tnull output list. Comment reformatting.\n\t(Inputs_Match): Copy a solitary input to avoid an assertion failure\n\twhen trying to match the same input in multiple clauses.\n\n2014-02-19  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_attr.adb: Minor typo fix.\n\nFrom-SVN: r207880", "tree": {"sha": "81beccc9022d393327bfc13b482c3b472b676ace", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81beccc9022d393327bfc13b482c3b472b676ace"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/comments", "author": null, "committer": null, "parents": [{"sha": "4df65a859021297d34af56094b2baa6502b59ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df65a859021297d34af56094b2baa6502b59ddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df65a859021297d34af56094b2baa6502b59ddf"}], "stats": {"total": 368, "additions": 282, "deletions": 86}, "files": [{"sha": "d456c84c91354fab49f388568e85c24dd6e16dee", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -1,3 +1,31 @@\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Min_Max_Attribute): New procedure\n+\t(Expand_N_Attribute_Reference): Use this procedure for Min and Max.\n+\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Remove object\n+\tdeclarations from list of actions.\n+\t* output.ads, output.adb (Delete_Last_Char): New procedure.\n+\t* sinfo.ads: Document handling of Mod and expression with actions\n+\tin Modify_Tree_For_C mode.\n+\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch9.adb (P_Task): Add a null statement to produce a\n+\twell-formed task body when due to a previous syntax error the\n+\tstatement list is empty.\n+\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Check_Dependency_Clause): Account\n+\tfor the case where a state with a non-null refinement matches a\n+\tnull output list. Comment reformatting.\n+\t(Inputs_Match): Copy a solitary input to avoid an assertion failure\n+\twhen trying to match the same input in multiple clauses.\n+\n+2014-02-19  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_attr.adb: Minor typo fix.\n+\n 2014-02-18  Robert Dewar  <dewar@adacore.com>\n \n \t* cstand.adb (Build_Signed_Integer_Type): Minor change of formal"}, {"sha": "503a1ae3a21b35fdaafcf2d95b1d966be792e534", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 117, "deletions": 65, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -140,6 +140,10 @@ package body Exp_Attr is\n    --  Handle the expansion of attribute 'Loop_Entry. As a result, the related\n    --  loop may be converted into a conditional block. See body for details.\n \n+   procedure Expand_Min_Max_Attribute (N : Node_Id);\n+   --  Handle the expansion of attributes 'Max and 'Min, including expanding\n+   --  then out if we are in Modify_Tree_For_C mode.\n+\n    procedure Expand_Pred_Succ_Attribute (N : Node_Id);\n    --  Handles expansion of Pred or Succ attributes for case of non-real\n    --  operand with overflow checking required.\n@@ -1035,6 +1039,116 @@ package body Exp_Attr is\n       end if;\n    end Expand_Loop_Entry_Attribute;\n \n+   ------------------------------\n+   -- Expand_Min_Max_Attribute --\n+   ------------------------------\n+\n+   procedure Expand_Min_Max_Attribute (N : Node_Id) is\n+   begin\n+      --  Min and Max are handled by the back end (except that static cases\n+      --  have already been evaluated during semantic processing, although the\n+      --  back end should not count on this). The one bit of special processing\n+      --  required in the normal case is that these two attributes typically\n+      --  generate conditionals in the code, so check the relevant restriction.\n+\n+      Check_Restriction (No_Implicit_Conditionals, N);\n+\n+      --  In Modify_Tree_For_C mode, we rewrite as an if expression\n+\n+      if Modify_Tree_For_C then\n+         declare\n+            Loc   : constant Source_Ptr := Sloc (N);\n+            Typ   : constant Entity_Id  := Etype (N);\n+            Expr  : constant Node_Id    := First (Expressions (N));\n+            Left  : constant Node_Id    := Relocate_Node (Expr);\n+            Right : constant Node_Id    := Relocate_Node (Next (Expr));\n+            Ltyp  : constant Entity_Id  := Etype (Left);\n+            Rtyp  : constant Entity_Id  := Etype (Right);\n+\n+            function Make_Compare (Left, Right : Node_Id) return Node_Id;\n+            --  Returns Left >= Right for Max, Left <= Right for Min\n+\n+            ------------------\n+            -- Make_Compare --\n+            ------------------\n+\n+            function Make_Compare (Left, Right : Node_Id) return Node_Id is\n+            begin\n+               if Attribute_Name (N) = Name_Max then\n+                  return\n+                    Make_Op_Ge (Loc,\n+                      Left_Opnd  => Left,\n+                      Right_Opnd => Right);\n+               else\n+                  return\n+                    Make_Op_Le (Loc,\n+                      Left_Opnd  => Left,\n+                      Right_Opnd => Right);\n+               end if;\n+            end Make_Compare;\n+\n+         --  Start of processing for Min_Max\n+\n+         begin\n+            --  If both Left and Right are simple entity names, then we can\n+            --  just use Duplicate_Expr to duplicate the references and return\n+\n+            --    (if Left >=|<= Right then Left else Right)\n+\n+            if Is_Entity_Name (Left) and then Is_Entity_Name (Right) then\n+               Rewrite (N,\n+                 Make_If_Expression (Loc,\n+                   Expressions => New_List (\n+                     Make_Compare (Left, Right),\n+                     Duplicate_Subexpr_No_Checks (Left),\n+                     Duplicate_Subexpr_No_Checks (Right))));\n+\n+            --  Otherwise we wrap things in an expression with actions. You\n+            --  might think we could just use the approach above, but there\n+            --  are problems, in particular with escaped discriminants. In\n+            --  this case we generate:\n+\n+            --    do\n+            --      T1 : constant typ := Left;\n+            --      T2 : constant typ := Right;\n+            --    in\n+            --      (if T1 >=|<= T2 then T1 else T2)\n+            --    end;\n+\n+            else\n+               declare\n+                  T1 : constant Entity_Id := Make_Temporary (Loc, 'T', Left);\n+                  T2 : constant Entity_Id := Make_Temporary (Loc, 'T', Left);\n+\n+               begin\n+                  Rewrite (N,\n+                    Make_Expression_With_Actions (Loc,\n+                      Actions => New_List (\n+                        Make_Object_Declaration (Loc,\n+                          Defining_Identifier => T1,\n+                          Object_Definition   => New_Occurrence_Of (Ltyp, Loc),\n+                          Expression          => Left),\n+                        Make_Object_Declaration (Loc,\n+                          Defining_Identifier => T2,\n+                          Object_Definition   => New_Occurrence_Of (Rtyp, Loc),\n+                          Expression          => Right)),\n+\n+                      Expression =>\n+                        Make_If_Expression (Loc,\n+                          Expressions => New_List (\n+                            Make_Compare\n+                              (New_Occurrence_Of (T1, Loc),\n+                               New_Occurrence_Of (T2, Loc)),\n+                            New_Occurrence_Of (T1, Loc),\n+                            New_Occurrence_Of (T2, Loc)))));\n+               end;\n+            end if;\n+\n+            Analyze_And_Resolve (N, Typ);\n+         end;\n+      end if;\n+   end Expand_Min_Max_Attribute;\n+\n    ----------------------------------\n    -- Expand_N_Attribute_Reference --\n    ----------------------------------\n@@ -3621,38 +3735,7 @@ package body Exp_Attr is\n       ---------\n \n       when Attribute_Max =>\n-\n-         --  Max is handled by the back end (except that static cases have\n-         --  already been evaluated during semantic processing, but anyway\n-         --  the back end should not count on this). The one bit of special\n-         --  processing required in the normal case is that this attribute\n-         --  typically generates conditionals in the code, so we must check\n-         --  the relevant restriction.\n-\n-         Check_Restriction (No_Implicit_Conditionals, N);\n-\n-         --  In Modify_Tree_For_C mode, we rewrite as an if expression\n-\n-         if Modify_Tree_For_C then\n-            declare\n-               Loc   : constant Source_Ptr := Sloc (N);\n-               Typ   : constant Entity_Id  := Etype (N);\n-               Expr  : constant Node_Id    := First (Expressions (N));\n-               Left  : constant Node_Id    := Relocate_Node (Expr);\n-               Right : constant Node_Id    := Relocate_Node (Next (Expr));\n-\n-            begin\n-               Rewrite (N,\n-                 Make_If_Expression (Loc,\n-                   Expressions => New_List (\n-                     Make_Op_Ge (Loc,\n-                       Left_Opnd  => Left,\n-                       Right_Opnd => Right),\n-                     Duplicate_Subexpr_No_Checks (Left),\n-                     Duplicate_Subexpr_No_Checks (Right))));\n-               Analyze_And_Resolve (N, Typ);\n-            end;\n-         end if;\n+         Expand_Min_Max_Attribute (N);\n \n       ----------------------------------\n       -- Max_Size_In_Storage_Elements --\n@@ -3733,7 +3816,7 @@ package body Exp_Attr is\n \n       when Attribute_Mechanism_Code =>\n \n-         --  We must replace the prefix in the renamed case\n+         --  We must replace the prefix i the renamed case\n \n          if Is_Entity_Name (Pref)\n            and then Present (Alias (Entity (Pref)))\n@@ -3746,38 +3829,7 @@ package body Exp_Attr is\n       ---------\n \n       when Attribute_Min =>\n-\n-         --  Min is handled by the back end (except that static cases have\n-         --  already been evaluated during semantic processing, but anyway\n-         --  the back end should not count on this). The one bit of special\n-         --  processing required in the normal case is that this attribute\n-         --  typically generates conditionals in the code, so we must check\n-         --  the relevant restriction.\n-\n-         Check_Restriction (No_Implicit_Conditionals, N);\n-\n-         --  In Modify_Tree_For_C mode, we rewrite as an if expression\n-\n-         if Modify_Tree_For_C then\n-            declare\n-               Loc   : constant Source_Ptr := Sloc (N);\n-               Typ   : constant Entity_Id  := Etype (N);\n-               Expr  : constant Node_Id    := First (Expressions (N));\n-               Left  : constant Node_Id    := Relocate_Node (Expr);\n-               Right : constant Node_Id    := Relocate_Node (Next (Expr));\n-\n-            begin\n-               Rewrite (N,\n-                 Make_If_Expression (Loc,\n-                   Expressions => New_List (\n-                     Make_Op_Le (Loc,\n-                       Left_Opnd  => Left,\n-                       Right_Opnd => Right),\n-                     Duplicate_Subexpr_No_Checks (Left),\n-                     Duplicate_Subexpr_No_Checks (Right))));\n-               Analyze_And_Resolve (N, Typ);\n-            end;\n-         end if;\n+         Expand_Min_Max_Attribute (N);\n \n       ---------\n       -- Mod --"}, {"sha": "43dc9916ed66caa1d71a527f66358fdd1f845cc4", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -5105,12 +5105,64 @@ package body Exp_Ch4 is\n \n       --  Local variables\n \n+      Loc : Source_Ptr;\n       Act : Node_Id;\n+      Def : Entity_Id;\n+      Exp : Node_Id;\n+      Nxt : Node_Id;\n \n    --  Start of processing for Expand_N_Expression_With_Actions\n \n    begin\n+      --  Process the actions as described above\n+\n       Act := First (Actions (N));\n+      while Present (Act) loop\n+         Process_Single_Action (Act);\n+         Next (Act);\n+      end loop;\n+\n+      --  In Modify_Tree_For_C, we have trouble in C with object declarations\n+      --  in the actions list (expressions are fine). So if we have an object\n+      --  declaration, insert it higher in the tree, if necessary replacing it\n+      --  with an assignment to capture initialization.\n+\n+      if Modify_Tree_For_C then\n+         Act := First (Actions (N));\n+         while Present (Act) loop\n+            if Nkind (Act) = N_Object_Declaration then\n+               Def := Defining_Identifier (Act);\n+               Exp := Expression (Act);\n+               Set_Constant_Present (Act, False);\n+               Set_Expression (Act, Empty);\n+               Insert_Action (N, Relocate_Node (Act));\n+\n+               Loc := Sloc (Act);\n+\n+               --  Expression present, rewrite as assignment, get next action\n+\n+               if Present (Exp) then\n+                  Rewrite (Act,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Def, Loc),\n+                      Expression => Exp));\n+                  Next (Act);\n+\n+               --  No expression, remove action and move to next\n+\n+               else\n+                  Nxt := Next (Act);\n+                  Remove (Act);\n+                  Act := Nxt;\n+               end if;\n+\n+            --  Not an object declaration, move to next action\n+\n+            else\n+               Next (Act);\n+            end if;\n+         end loop;\n+      end if;\n \n       --  Deal with case where there are no actions. In this case we simply\n       --  rewrite the node with its expression since we don't need the actions\n@@ -5121,17 +5173,8 @@ package body Exp_Ch4 is\n       --  tree in cases like this. This raises a whole lot of issues of whether\n       --  we have problems elsewhere, which will be addressed in the future???\n \n-      if No (Act) then\n+      if Is_Empty_List (Actions (N)) then\n          Rewrite (N, Relocate_Node (Expression (N)));\n-\n-      --  Otherwise process the actions as described above\n-\n-      else\n-         loop\n-            Process_Single_Action (Act);\n-            Next (Act);\n-            exit when No (Act);\n-         end loop;\n       end if;\n    end Expand_N_Expression_With_Actions;\n "}, {"sha": "0a739370ae0d511334bd77d072239fb1864ed5fd", "filename": "gcc/ada/output.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Foutput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Foutput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.adb?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -75,6 +75,17 @@ package body Output is\n       return Pos (Next_Col);\n    end Column;\n \n+   ----------------------\n+   -- Delete_Last_Char --\n+   ----------------------\n+\n+   procedure Delete_Last_Char is\n+   begin\n+      if Next_Col /= 1 then\n+         Next_Col := Next_Col - 1;\n+      end if;\n+   end Delete_Last_Char;\n+\n    ------------------\n    -- Flush_Buffer --\n    ------------------"}, {"sha": "e4137c2add633f57819cec4aa2b6feacab79856d", "filename": "gcc/ada/output.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Foutput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Foutput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.ads?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -141,6 +141,10 @@ package Output is\n    --  Returns last character written on the current line, or null if the\n    --  current line is (so far) empty.\n \n+   procedure Delete_Last_Char;\n+   --  Deletes last character written on the current line, no effect if the\n+   --  current line is (so far) empty.\n+\n    function Column return Pos;\n    pragma Inline (Column);\n    --  Returns the number of the column about to be written (e.g. a value of 1"}, {"sha": "da7d76d573a3e7fe43d149ae3e3c5a6fa031e2b0", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -144,6 +144,17 @@ package body Ch9 is\n             end if;\n \n             Parse_Decls_Begin_End (Task_Node);\n+\n+            --  The statement list of a task body needs to include at least a\n+            --  null statement, so if a parsing error produces an empty list,\n+            --  patch it now.\n+\n+            if\n+              No (First (Statements (Handled_Statement_Sequence (Task_Node))))\n+            then\n+               Set_Statements (Handled_Statement_Sequence (Task_Node),\n+                   New_List (Make_Null_Statement (Token_Ptr)));\n+            end if;\n          end if;\n \n          return Task_Node;"}, {"sha": "6bebed6a89dfd7d5979cc1e71829bc2a73e7628a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -4418,7 +4418,7 @@ package body Sem_Attr is\n \n                --  Entities mentioned within the prefix of attribute 'Old must\n                --  be global to the related postcondition. If this is not the\n-               --  case, then the scope of the local entity is be nested within\n+               --  case, then the scope of the local entity is nested within\n                --  that of the subprogram.\n \n                elsif Nkind (Nod) = N_Identifier"}, {"sha": "42c70764eb7325c80240ac9e31cb734dee8aceba", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -21434,15 +21434,37 @@ package body Sem_Prag is\n                   elsif Has_Non_Null_Refinement (Dep_Id) then\n                      Has_Refined_State := True;\n \n-                     if Is_Entity_Name (Ref_Output) then\n-                        Ref_Id := Entity_Of (Ref_Output);\n+                     --  Account for the case where a state with a non-null\n+                     --  refinement matches a null output list:\n+\n+                     --    Refined_State   => (State_1 => (C1, C2),\n+                     --                        State_2 => (C3, C4))\n+                     --    Depends         => (State_1 => State_2)\n+                     --    Refined_Depends => (null    => C3)\n+\n+                     if Nkind (Ref_Output) = N_Null\n+                       and then Inputs_Match\n+                                  (Dep_Clause  => Dep_Clause,\n+                                   Ref_Clause  => Ref_Clause,\n+                                   Post_Errors => False)\n+                     then\n+                        Has_Constituent := True;\n \n-                        --  The output of the refinement clause is a valid\n-                        --  constituent of the state. Remove the clause from\n-                        --  the pool of candidates if both input lists match.\n-                        --  Note that the search continues because one clause\n-                        --  may have been normalized into multiple clauses as\n-                        --  per the example above.\n+                        --  Note that the search continues after the clause is\n+                        --  removed from the pool of candidates because it may\n+                        --  have been normalized into multiple simple clauses.\n+\n+                        Remove (Ref_Clause);\n+\n+                     --  Otherwise the output of the refinement clause must be\n+                     --  a valid constituent of the state:\n+\n+                     --    Refined_State   => (State => (C1, C2))\n+                     --    Depends         => (State => <input>)\n+                     --    Refined_Depends => (C1    => <input>)\n+\n+                     elsif Is_Entity_Name (Ref_Output) then\n+                        Ref_Id := Entity_Of (Ref_Output);\n \n                         if Ekind_In (Ref_Id, E_Abstract_State, E_Variable)\n                           and then Present (Encapsulating_State (Ref_Id))\n@@ -21453,6 +21475,12 @@ package body Sem_Prag is\n                                       Post_Errors => False)\n                         then\n                            Has_Constituent := True;\n+\n+                           --  Note that the search continues after the clause\n+                           --  is removed from the pool of candidates because\n+                           --  it may have been normalized into multiple simple\n+                           --  clauses.\n+\n                            Remove (Ref_Clause);\n                         end if;\n                      end if;\n@@ -21819,12 +21847,13 @@ package body Sem_Prag is\n       begin\n          --  Construct a list of all refinement inputs. Note that the input\n          --  list is copied because the algorithm modifies its contents and\n-         --  this should not be visible in Refined_Depends.\n+         --  this should not be visible in Refined_Depends. The same applies\n+         --  for a solitary input.\n \n          if Nkind (Inputs) = N_Aggregate then\n             Ref_Inputs := New_Copy_List (Expressions (Inputs));\n          else\n-            Ref_Inputs := New_List (Inputs);\n+            Ref_Inputs := New_List (New_Copy (Inputs));\n          end if;\n \n          --  Depending on whether the original dependency clause mentions"}, {"sha": "4feed599c5d06f1fa501565314254e8975d108c0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "patch": "@@ -642,6 +642,13 @@ package Sinfo is\n    --    Min and Max attributes are expanded into equivalent if expressions,\n    --    dealing properly with side effect issues.\n \n+   --    Mod for signed integer types is expanded into equivalent expressions\n+   --    using Rem (which is % in C) and other C-available operators.\n+\n+   --    The Actions list of an Expression_With_Actions node has any object\n+   --    declarations removed, so that it is composed only of expressions\n+   --    (so that DO X,... Y IN Z can be represented as (X, .. Y, Z) in C).\n+\n    ------------------------------------\n    -- Description of Semantic Fields --\n    ------------------------------------\n@@ -4127,6 +4134,11 @@ package Sinfo is\n       --  and we are running in ELIMINATED mode, the operator node will be\n       --  changed to be a call to the appropriate routine in System.Bignums.\n \n+      --  Note: In Modify_Tree_For_C mode, we do not generate an N_Op_Mod node\n+      --  for signed integer types (since there is no equivalent operator in\n+      --  C). Instead we rewrite such an operation in terms of REM (which is\n+      --  % in C) and other C-available operators.\n+\n       ------------------------------------\n       -- 4.5.7  Conditional Expressions --\n       ------------------------------------\n@@ -7406,6 +7418,12 @@ package Sinfo is\n       --  not a proper expression), and in the long term all cases of this\n       --  idiom should instead use a new node kind N_Compound_Statement.\n \n+      --  Note: In Modify_Tree_For_C, we eliminate declarations from the list\n+      --  of actions, inserting them at the outer level. If we move an object\n+      --  declaration with an initialization expression in this manner, then\n+      --  the action is replaced by an appropriate assignment, otherwise it is\n+      --  removed from the list of actions.\n+\n       --------------------\n       -- Free Statement --\n       --------------------"}]}