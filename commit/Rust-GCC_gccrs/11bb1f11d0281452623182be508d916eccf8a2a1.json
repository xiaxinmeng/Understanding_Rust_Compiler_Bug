{"sha": "11bb1f11d0281452623182be508d916eccf8a2a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFiYjFmMTFkMDI4MTQ1MjYyMzE4MmJlNTA4ZDkxNmVjY2Y4YTJhMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-12-11T21:22:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-12-11T21:22:57Z"}, "message": "Initial revision\n\nFrom-SVN: r13280", "tree": {"sha": "443c43320bbe43c98989e583ed61325c4f25369c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/443c43320bbe43c98989e583ed61325c4f25369c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11bb1f11d0281452623182be508d916eccf8a2a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11bb1f11d0281452623182be508d916eccf8a2a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11bb1f11d0281452623182be508d916eccf8a2a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11bb1f11d0281452623182be508d916eccf8a2a1/comments", "author": null, "committer": null, "parents": [{"sha": "7d41c4114a3cb45123e2944500787aa3736df8cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d41c4114a3cb45123e2944500787aa3736df8cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d41c4114a3cb45123e2944500787aa3736df8cb"}], "stats": {"total": 1996, "additions": 1996, "deletions": 0}, "files": [{"sha": "9218584baf0cf71889e11938244d96c6a8bc0a50", "filename": "gcc/config/mn10300/mn10300.c", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=11bb1f11d0281452623182be508d916eccf8a2a1", "patch": "@@ -0,0 +1,361 @@\n+/* Subroutines for insn-output.c for Matsushita MN10300 series\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"tree.h\"\n+#include \"obstack.h\"\n+\n+void\n+asm_file_start (file)\n+     FILE *file;\n+{\n+  fprintf (file, \"#\\tGCC For the Matsushita MN10300\\n\");\n+  if (optimize)\n+    fprintf (file, \"# -O%d\\n\", optimize);\n+  else\n+    fprintf (file, \"\\n\\n\");\n+  output_file_directive (file, main_input_filename);\n+}\n+\f\n+\n+int\n+const_costs (r, c)\n+     rtx r;\n+     enum rtx_code c;\n+{\n+  switch (c)\n+    {\n+    case CONST_INT:\n+      if (INT_8_BITS (INTVAL (r)))\n+\treturn 0;\n+      else if (INT_16_BITS (INTVAL (r)))\n+\treturn 1;\n+      else\n+\treturn 2;\n+    case CONST_DOUBLE:\n+      return 8;\n+    default:\n+      return 4;\n+    }\n+}\n+\f\n+/* Print operand X using operand code CODE to assembly language output file\n+   FILE.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+      case 'b':\n+      case 'B':\n+\t/* These are normal and reversed branches.  */\n+\tswitch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n+\t  {\n+\t  case NE:\n+\t    fprintf (file, \"ne\");\n+\t    break;\n+\t  case EQ:\n+\t    fprintf (file, \"eq\");\n+\t    break;\n+\t  case GE:\n+\t    fprintf (file, \"ge\");\n+\t    break;\n+\t  case GT:\n+\t    fprintf (file, \"gt\");\n+\t    break;\n+\t  case LE:\n+\t    fprintf (file, \"le\");\n+\t    break;\n+\t  case LT:\n+\t    fprintf (file, \"lt\");\n+\t    break;\n+\t  case GEU:\n+\t    fprintf (file, \"cc\");\n+\t    break;\n+\t  case GTU:\n+\t    fprintf (file, \"hi\");\n+\t    break;\n+\t  case LEU:\n+\t    fprintf (file, \"ls\");\n+\t    break;\n+\t  case LTU:\n+\t    fprintf (file, \"cs\");\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+      case 'C':\n+\t/* This is used for the operand to a call instruction;\n+\t   if it's a REG, enclose it in parens, else output\n+\t   the operand normally.  */\n+\tif (GET_CODE (x) == REG)\n+\t  {\n+\t    fputc ('(', file);\n+\t    print_operand (file, x, 0);\n+\t    fputc (')', file);\n+\t  }\n+\telse\n+\t  print_operand (file, x, 0);\n+\tbreak;\n+     \n+      default:\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t    break;\n+\n+\t  case SUBREG:\n+\t    fprintf (file, \"%s\",\n+\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    break;\n+\n+\t  case CONST_INT:\n+\t  case SYMBOL_REF:\n+\t  case CONST:\n+\t  case LABEL_REF:\n+\t  case CODE_LABEL:\n+\t    print_operand_address (file, x);\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+   }\n+}\n+\n+/* Output assembly language output for the address ADDR to FILE.  */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      if (addr == stack_pointer_rtx)\n+\tprint_operand_address (file, gen_rtx (PLUS, SImode,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      GEN_INT (0)));\n+      else\n+\tprint_operand (file, addr, 0);\n+      break;\n+    case PLUS:\n+      {\n+\trtx base, index;\n+\tif (REG_P (XEXP (addr, 0))\n+\t    && REG_OK_FOR_BASE_P (XEXP (addr, 0)))\n+\t  base = XEXP (addr, 0), index = XEXP (addr, 1);\n+\telse if (REG_P (XEXP (addr, 1))\n+\t    && REG_OK_FOR_BASE_P (XEXP (addr, 1)))\n+\t  base = XEXP (addr, 1), index = XEXP (addr, 0);\n+      \telse\n+\t  abort ();\n+\tprint_operand (file, index, 0);\n+\tfputc (',', file);\n+\tprint_operand (file, base, 0);;\n+\tbreak;\n+      }\n+    case SYMBOL_REF:\n+      output_addr_const (file, addr);\n+      break;\n+    default:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+void\n+expand_prologue ()\n+{\n+  unsigned int size = get_frame_size ();\n+\n+  /* For simplicity, we just movm all the callee saved registers to\n+     the stack with one instruction, then set up the frame pointer\n+     (if needed), and finally allocate the new stack.  */\n+  emit_insn (gen_store_movm ());\n+\n+  if (frame_pointer_needed)\n+    {\n+      emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+      emit_insn (gen_addsi3 (frame_pointer_rtx,\n+\t\t\t     frame_pointer_rtx,\n+\t\t\t     GEN_INT (20)));\n+    }\n+\n+  if (size)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   GEN_INT (-size)));\n+}\n+\n+void\n+expand_epilogue ()\n+{\n+  unsigned int size = get_frame_size ();\n+\n+  /* Cut back the stack.  */\n+  if (frame_pointer_needed)\n+    {\n+      emit_insn (gen_addsi3 (frame_pointer_rtx,\n+\t\t\t     frame_pointer_rtx,\n+\t\t\t     GEN_INT (-20)));\n+      emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+    }\n+  else if (size)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   GEN_INT (size)));\n+\n+  /* And restore the registers.  */\n+  emit_insn (gen_load_movm ());\n+\n+  /* And return.  */\n+  emit_jump_insn (gen_return_internal ());\n+}\n+\n+/* Update the condition code from the insn.  */\n+\n+void\n+notice_update_cc (body, insn)\n+     rtx body;\n+     rtx insn;\n+{\n+#if 0\n+  switch (get_attr_cc (insn))\n+    {\n+    case CC_NONE:\n+      /* Insn does not affect CC at all.  */\n+      break;\n+\n+    case CC_NONE_0HIT:\n+      /* Insn does not change CC, but the 0'th operand has been changed.  */\n+      if (cc_status.value1 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\tcc_status.value1 = 0;\n+      break;\n+\n+    case CC_SET_ZN_C0:\n+      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+\t V is always set to 0.  C may or may not be set to 0 but that's ok\n+\t because alter_cond will change tests to use EQ/NE.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_NO_OVERFLOW;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+    case CC_SET:\n+    case CC_COMPARE:\n+      /* The insn is a compare instruction.  */\n+      CC_STATUS_INIT;\n+      cc_status.value1 = SET_SRC (body);\n+      break;\n+\n+    case CC_CLOBBER:\n+      /* Insn doesn't leave CC in a usable state.  */\n+      CC_STATUS_INIT;\n+      break;\n+    }\n+#endif\n+  CC_STATUS_INIT;\n+}\n+\n+/* Return true if OP is a valid call operand.  */\n+\n+int\n+call_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n+}\n+\n+/* What (if any) secondary registers are needed to move IN with mode\n+   MODE into a register from in register class CLASS. \n+\n+   We might be able to simplify this.  */\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno;\n+\n+  /* Memory loads less than a full word wide can't have an\n+     address or stack pointer destination.  They must use\n+     a data register as an intermediate register.  */\n+  if (GET_CODE (in) == MEM\n+      && (mode == QImode || mode == HImode)\n+      && (class == ADDRESS_REGS || class == SP_REGS))\n+    return DATA_REGS;\n+\n+  /* We can't directly load sp + const_int into a data register;\n+     we must use an address register as an intermediate.  */\n+  if (class == DATA_REGS\n+      && (in == stack_pointer_rtx\n+\t  || (GET_CODE (in) == PLUS\n+ \t      && XEXP (in, 0) == stack_pointer_rtx)))\n+    return ADDRESS_REGS;\n+\n+  /* Get the true register.  */\n+  if (GET_CODE (in) == REG)\n+    {\n+      regno = REGNO (in);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+        regno = true_regnum (in);\n+    }\n+\n+  /* We can't copy directly from a data register into the stack\n+     pointer.  */\n+  if (class == SP_REGS\n+      && GET_CODE (in) == REG\n+      && regno < 4)\n+    return ADDRESS_REGS;\n+\n+  /* Otherwise assume no secondary reloads are needed.  */\n+  return NO_REGS;\n+}"}, {"sha": "b8b416b99af7df7088cb165b6e9dba6fad951a07", "filename": "gcc/config/mn10300/mn10300.h", "status": "added", "additions": 900, "deletions": 0, "changes": 900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=11bb1f11d0281452623182be508d916eccf8a2a1", "patch": "@@ -0,0 +1,900 @@\n+/* Definitions of target machine for GNU compiler. \n+   Matsushita MN10300 series\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"svr4.h\"\n+\n+#undef ASM_SPEC\n+#undef ASM_FINAL_SPEC\n+#undef LIB_SPEC\n+#undef ENDFILE_SPEC\n+#undef LINK_SPEC\n+#undef STARTFILE_SPEC\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-D__mn10300__ -D__MN10300__\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  {{ \"\", TARGET_DEFAULT}}\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (MN10300)\");\n+\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the Matsushita MN1003.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* This is not true on the Matsushita MN10300.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.\n+   This is not true on the Matsushita MN10300.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD\t\t32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD\t\t4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE \t\t32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY\t\t32\n+\n+/* The stack goes in 32 bit lumps.  */\n+#define STACK_BOUNDARY \t\t32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.\n+   8 is the minimum boundary; it's unclear if bigger alignments\n+   would improve performance.  */\n+#define FUNCTION_BOUNDARY 8\n+\n+/* No data type wants to be aligned rounder than this.   */\n+#define BIGGEST_ALIGNMENT\t32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 9\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS \\\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you\n+   like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+  { 1, 1, 0, 0, 1, 1, 0, 0, 1}\n+\n+#define REG_ALLOC_ORDER \\\n+  { 0, 1, 4, 5, 2, 3, 6, 7, 8}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+ (REGNO_REG_CLASS (REGNO) == DATA_REGS \t\t\t\\\n+  ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4\t\\\n+  : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) == 4)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  (MODE1 == MODE2 || GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4)\n+\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+enum reg_class {\n+  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS, DATA_OR_ADDRESS_REGS, DATA_OR_SP_REGS, SP_OR_ADDRESS_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n+  \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"DATA_OR_SP_REGS\", \\\n+  \"SP_OR_ADDRESS_REGS\",\t\"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS  \t\t\t\\\n+{      0,\t\t/* No regs      */\t\\\n+   0x00f,\t\t/* DATA_REGS */\t\t\\\n+   0x0f0,\t\t/* ADDRESS_REGS */\t\\\n+   0x100,\t\t/* SP_REGS */\t\t\\\n+   0x0ff,\t\t/* DATA_OR_ADDRESS_REGS */\\\n+   0x00f,\t\t/* DATA_OR_SP_REGS */\t\\\n+   0x0f0,\t\t/* SP_OR_ADDRESS_REGS */\\\n+   0x0ff,\t\t/* GENERAL_REGS */    \t\\\n+   0x0ff,\t\t/* ALL_REGS \t*/\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) < 4 ? DATA_REGS : \\\n+   (REGNO) < 8 ? ADDRESS_REGS : \\\n+    (REGNO) == 8 ? SP_REGS: 0)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS DATA_REGS\n+#define BASE_REG_CLASS  SP_OR_ADDRESS_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'd' ? DATA_REGS : \\\n+   (C) == 'a' ? ADDRESS_REGS : \\\n+   (C) == 'x' ? SP_REGS : NO_REGS)\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+ \n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+  (((regno) > 3 && regno < FIRST_PSEUDO_REGISTER)\t\\\n+   || (reg_renumber[regno] > 3 && reg_renumber[regno] < FIRST_PSEUDO_REGISTER))\n+\n+#define REGNO_OK_FOR_INDEX_P(regno) \\\n+  (((regno) >= 0 && regno < 4)\t\\\n+   || (reg_renumber[regno] >= 0 && reg_renumber[regno] < 4))\n+\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+  (X == stack_pointer_rtx && CLASS != SP_REGS ? ADDRESS_REGS : CLASS)\n+\n+#define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n+  ((MODE == QImode || MODE == HImode) ? DATA_REGS : CLASS)\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class(CLASS,MODE,IN)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n+#define INT_16_BITS(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n+\n+#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n+#define CONST_OK_FOR_J(VALUE) ((VALUE) == 1)\n+#define CONST_OK_FOR_K(VALUE) ((VALUE) == 2)\n+#define CONST_OK_FOR_L(VALUE) ((VALUE) == 4)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n+   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n+   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n+   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : 0)\n+\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself. \n+     \n+  `G' is a floating-point zero.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET -20\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+/* Is equal to the size of the saved fp + pc, even if an fp isn't\n+   saved since the value is used before we know.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 8\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 7\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 7\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 5\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c. \n+\n+   Currently we always need a frame pointer.  In the future we'd like\n+   to be able to eliminate it.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0\n+\n+/* A guess for the MN10300.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the MN10300, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the MN10300, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the MN10300, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the MN10300 all args are pushed.  */   \n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+\f\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+ \n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.   */\n+   \n+#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, 0)\n+\n+/* 1 if N is a possible register number for a function value.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* Return values > 8 bytes in length in memory.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+#define RETURN_IN_MEMORY(TYPE)  \\\n+  (int_size_in_bytes (TYPE) > 8 || TYPE_MODE (TYPE) == BLKmode)\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  On the MN10300 it's passed as\n+   the first parameter.  */\n+\n+#define STRUCT_VALUE 0\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) ;\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tadd -4,sp\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0x0004fffa\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tadd 4,sp\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tmov mdr,d0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov d0,a0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (15,a0),a1\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (19,a0),a0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tjmp (a0)\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 0x1d\n+\n+#define TRAMPOLINE_ALIGNMENT 32\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x16)),\t\\\n+ \t\t (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 0x1a)),\t\\\n+\t\t (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+\f\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)   CONSTANT_P (X)\n+\n+/* Extra constraints.  */\n+ \n+#define EXTRA_CONSTRAINT(OP, C) \\\n+ ((C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : 0)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X)  \\\n+  ((REGNO (X) >= 0 && REGNO(X) <= 3) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+  ((REGNO (X) >= 4 && REGNO(X) <= 8) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+#else\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#endif\n+\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually\n+   machine-independent.  */\n+\n+/* Accept either REG or SUBREG where a register is valid.  */\n+  \n+#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\\\n+  ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))\t\t\\\n+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)    \t\\\n+{\t\t\t\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      rtx base = 0, index = 0;\t\t\t\t\\\n+      if (REG_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n+\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\\\n+      if (REG_P (XEXP (X, 1))\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n+\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n+      if (base != 0 && index != 0)\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (index) == CONST_INT)\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t  if (GET_CODE (index) == REG\t\t\t\\\n+\t      && REG_OK_FOR_INDEX_P (index))\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.   */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT) \\\n+\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the vax.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  default: { int _zxy= const_costs(RTX, CODE);\t\\\n+\t     if(_zxy) return _zxy; break;}\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)  3\n+\n+/* A crude cut at RTX_COSTS for the MN10300.  */\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+\n+   There aren't DImode MOD, DIV or MULT operations, so call them\n+   very expensive.  Everything else is pretty much a costant cost.  */\n+\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case MOD:\t\t\\\n+  case DIV:\t\t\\\n+    return 60;\t\t\\\n+  case MULT:\t\t\\\n+    return 20;\n+\n+/* Nonzero if access to memory by bytes or half words is no faster\n+   than accessing full words.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* According expr.c, a value of around 6 should minimize code size, and\n+   for the MN10300 series, that's our primary concern.  */\n+#define MOVE_RATIO 6\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP \"\\t.section .data\"\n+#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n+\n+/* Output at beginning/end of assembler file.  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) asm_file_start(FILE)\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   It is .dfloat or .gfloat, depending.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* This says how to output the assembler to define a global\n+   uninitialized but not common symbol.\n+   Try to use asm_output_bss to implement this macro.  */\n+\n+#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED) \\\n+  asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED))\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\\\n+  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t          \\\n+  do {                                            \\\n+  char* real_name;                                \\\n+  STRIP_NAME_ENCODING (real_name, (NAME));        \\\n+  fprintf (FILE, \"_%s\", real_name);               \\\n+  } while (0)           \n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* This is how we tell the assembler that two symbols have the same value.  */\n+\n+#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \\\n+  do { assemble_name(FILE, NAME1); \t \\\n+       fputs(\" = \", FILE);\t\t \\\n+       assemble_name(FILE, NAME2);\t \\\n+       fputc('\\n', FILE); } while (0)\n+\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"sp\" }\n+\n+/* Print an instruction operand X on file FILE.\n+   look in mn10300.c for details */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in output-vax.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  asm_fprintf (FILE, \"\\t%s .L%d\\n\", \".long\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+/* We don't have to worry about dbx compatability for the mn10300.  */\n+#define DEFAULT_GDB_EXTENSIONS 1\n+\n+/* Use stabs debugging info by default.  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#define DBX_REGISTER_NUMBER(REGNO) REGNO\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+#define CASE_DROPS_THROUGH\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX\t4\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* The assembler op to get a word.  */\n+\n+#define FILE_ASM_OP \"\\t.file\\n\"\n+\n+extern void asm_file_start ();\n+extern int const_costs ();\n+extern void print_operand ();\n+extern void print_operand_address ();\n+extern void expand_prologue ();\n+extern void expand_epilogue ();\n+extern void notice_update_cc ();\n+extern int call_address_operand ();\n+extern enum reg_class secondary_reload_class ();"}, {"sha": "c33063867825f7492c676acefb002372f7ff12e8", "filename": "gcc/config/mn10300/mn10300.md", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=11bb1f11d0281452623182be508d916eccf8a2a1", "patch": "@@ -0,0 +1,675 @@\n+;; GCC machine description for Matsushita MN10300\n+;; Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+;;   Contributed by Jeff Law (law@cygnus.com).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The original PO technology requires these to be ordered by speed,\n+;; so that assigner will pick the fastest.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; Condition code settings.\n+;; none - insn does not affect cc\n+;; none_0hit - insn does not affect cc but it does modify operand 0\n+;;\tThis attribute is used to keep track of when operand 0 changes.\n+;; \tSee the description of NOTICE_UPDATE_CC for more info.\n+;; set - insn sets flags z,n.  v,c are set to 0.\n+;;\t(c may not really be set to 0 but that's ok, we don't need it anyway).\n+;; set_zn_c0 - insn sets z,n to usable values.  v is unknown.  c may or may not\n+;;\tbe known (if it isn't that's ok, we don't need it anyway).\n+;; compare - compare instruction\n+;; clobber - value of cc is unknown\n+(define_attr \"cc\" \"none,none_0hit,set,set_zn_c0,compare,clobber\"\n+  (const_string \"clobber\"))\n+\f\n+;; ----------------------------------------------------------------------\n+;; MOVE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; movqi\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand0, QImode)\n+      && !register_operand (operand1, QImode))\n+    operands[1] = copy_to_mode_reg (QImode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,a,d,d,a,d,a,d,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"0,0,I,a,d,di,ia,m,d\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+  nop\n+  nop\n+  clr %0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  movbu %1,%0\n+  movbu %1,%0\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+;; movhi\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, HImode)\n+      && !register_operand (operand0, HImode))\n+    operands[1] = copy_to_mode_reg (HImode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,a,d,d,a,d,a,d,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"0,0,I,a,d,di,ia,m,d\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"@\n+  nop\n+  nop\n+  clr %0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  movhu %1,%0\n+  movhu %1,%0\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+;; movsi and helpers\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, SImode)\n+      && !register_operand (operand0, SImode))\n+    operands[1] = copy_to_mode_reg (SImode, operand1);\n+}\")\n+\n+;; We could improve loading of some constants with a little work.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a,a,x\")\n+\t(match_operand:SI 1 \"general_operand\" \"0,0,I,d,a,d,a,dim,aim,dim,aim,x,a\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+  nop\n+  nop\n+  clr %0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, SFmode)\n+      && !register_operand (operand0, SFmode))\n+    operands[1] = copy_to_mode_reg (SFmode, operand1);\n+}\")\n+\n+;; We could improve loading of some constants with a little work.\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=d,a,d,dam,da\")\n+\t(match_operand:SF 1 \"general_operand\" \"0,0,G,da,daim\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n+  \"@\n+  nop\n+  nop\n+  clr %0\n+  mov %1,%0\n+  mov %1,%0\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; TEST INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Go ahead and define tstsi so we can eliminate redundant tst insns\n+;; when we start trying to optimize this port.\n+(define_insn \"tstsi\"\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"da\"))]\n+  \"\"\n+  \"cmp 0,%0\"\n+  [(set_attr \"cc\" \"set\")])\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare:SI (match_operand:SI 0 \"register_operand\" \"da\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"dai\")))]\n+  \"\"\n+  \"cmp %1,%0\"\n+  [(set_attr \"cc\" \"compare\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; ADD INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da,a,da,x\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,L,dai,i\")))]\n+  \"\"\n+  \"\n+{\n+  /* We can't add a variable amount directly to the stack pointer;\n+     so do so via a temporary register.  */\n+  if (operands[0] == stack_pointer_rtx\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[2]) != CONST_INT)\n+   {\n+     rtx temp = gen_reg_rtx (SImode);\n+     emit_move_insn (temp, gen_rtx (PLUS, SImode, operands[1], operands[2]));\n+     emit_move_insn (operands[0], temp);\n+     DONE;\n+   }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da,a,da,x\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,L,dai,i\")))]\n+  \"\"\n+  \"@\n+  inc %0\n+  inc4 %0\n+  add %2,%0\n+  add %2,%0\"\n+  [(set_attr \"cc\" \"none_0hit,none_0hit,set,none_0hit\")])\n+\n+;; ----------------------------------------------------------------------\n+;; SUBTRACT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"dai\")))]\n+  \"\"\n+  \"sub %2,%0\"\n+  [(set_attr \"cc\" \"set\")])\n+\n+(define_expand \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx target = gen_reg_rtx (SImode);\n+\n+  emit_move_insn (target, GEN_INT (0));\n+  emit_insn (gen_subsi3 (target, target, operands[1]));\n+  emit_move_insn (operands[0], target);\n+  DONE;\n+}\")\n+\n+\n+;; ----------------------------------------------------------------------\n+;; MULTIPLY INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"mul %2,%0\"\n+  [(set_attr \"cc\" \"set\")])\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"ext %0\\;div %2,%0\"\n+  [(set_attr \"cc\" \"set\")])\n+\n+(define_expand \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+  emit_move_insn (reg, GEN_INT (0));\n+  emit_insn (gen_clear_mdr (reg));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"divu %2,%0\"\n+  [(set_attr \"cc\" \"set\")])\n+\n+(define_insn \"clear_mdr\"\n+  [(unspec_volatile [(const_int 2)] 0)\n+   (use (match_operand:SI 0 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"mov %0,mdr\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; AND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"and %2,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+;; ----------------------------------------------------------------------\n+;; OR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"or %2,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+;; ----------------------------------------------------------------------\n+;; XOR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"xor %2,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+;; ----------------------------------------------------------------------\n+;; NOT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"not %0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\f\n+;; -----------------------------------------------------------------\n+;; BIT FIELDS\n+;; -----------------------------------------------------------------\n+;; Is it worth defining insv and extv for the MN10300 series?!?\n+;; probably so.\n+\n+;; -----------------------------------------------------------------\n+;; Scc INSTRUCTIONS\n+;; -----------------------------------------------------------------\n+;; It's probably worth the time to define setcc type insns too\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; JUMP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Conditional jump instructions\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"b%B1 0f\\\\n\\\\tjmp %0\\\\n0:\"\n+ [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"b%b1 0f\\\\n\\\\tjmp %0\\\\n0:\"\n+ [(set_attr \"cc\" \"none\")])\n+\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp %l0\"\n+ [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"jmp (%0)\"\n+  [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp  (%0)\"\n+  [(set_attr \"cc\" \"none\")])\n+\n+;; Call subroutine with no return value.\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\" \"\")\n+\t (match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t stack_pointer_rtx,\n+\t\t\t GEN_INT (-4)));\n+  if (! call_address_operand (XEXP (operands[0], 0)))\n+    XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));\n+  emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n+  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t stack_pointer_rtx,\n+\t\t\t GEN_INT (4)));\n+  DONE;\n+}\")\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_address_operand\" \"aS\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"calls %C0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"general_operand\" \"\")\n+\t      (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t stack_pointer_rtx,\n+\t\t\t GEN_INT (-4)));\n+  if (! call_address_operand (XEXP (operands[1], 0)))\n+    XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));\n+  emit_call_insn (gen_call_value_internal (operands[0],\n+\t\t\t\t\t   XEXP (operands[1], 0),\n+\t\t\t\t\t   operands[2]));\n+  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t stack_pointer_rtx,\n+\t\t\t GEN_INT (4)));\n+  DONE;\n+}\")\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"\" \"=d\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"aS\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"calls %C1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"cc\" \"none\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; EXTEND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"exthu %0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extbu %0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+;;- sign extension instructions\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"exth %0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"extb %0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; SHIFTS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ashift:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"K,di\")))]\n+  \"\"\n+  \"@\n+  asl2 %0\n+  asl %2,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"lsr %2,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"asr %2,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+;; ----------------------------------------------------------------------\n+;; PROLOGUE/EPILOGUE\n+;; ----------------------------------------------------------------------\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"expand_prologue (); DONE;\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  expand_epilogue ();\n+  DONE;\n+}\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"0\"\n+  \"rets\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"return_internal\"\n+  [(const_int 0)\n+   (return)]\n+  \"\"\n+  \"rets\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"store_movm\"\n+  [(const_int 1)]\n+  \"\"\n+  \"movm [d2,d3,a2,a3],(sp)\"\n+  [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"load_movm\"\n+  [(const_int 2)]\n+  \"\"\n+  \"movm (sp),[d2,d3,a2,a3]\"\n+  [(set_attr \"cc\" \"none\")])"}, {"sha": "379b90fca7fd4b42e74b0c03e8e9fe07e8195a12", "filename": "gcc/config/mn10300/t-mn10300", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Ft-mn10300?ref=11bb1f11d0281452623182be508d916eccf8a2a1", "patch": "@@ -0,0 +1,20 @@\n+LIBGCC1=libgcc1.null\n+CROSS_LIBGCC1=libgcc1.null\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>dp-bit.c\n+\techo '#endif' \t\t>> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n+\techo '#endif' \t\t>> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c"}, {"sha": "4ea1bc8d6ccb5b9a514777e3919c6c4293e74ab7", "filename": "gcc/config/mn10300/xm-mn10300.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fxm-mn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11bb1f11d0281452623182be508d916eccf8a2a1/gcc%2Fconfig%2Fmn10300%2Fxm-mn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fxm-mn10300.h?ref=11bb1f11d0281452623182be508d916eccf8a2a1", "patch": "@@ -0,0 +1,40 @@\n+/* Configuration for Matsushita MN10300. \n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+\n+#include \"tm.h\""}]}