{"sha": "4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRiMzg0Yzk1MGVjODVjYTk2ZTRiY2FmN2IwMGMzNmYyZjZjY2JkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-09T22:39:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-09T22:39:25Z"}, "message": "predict.def: New file.\n\n\t* predict.def: New file.\n\t* predict.h: New file.\n\t* predict.c: Include predict.h.\n\t(predictor_info): New structure and array.\n\t(predict_edge, predict_insn): Rewrite; make global.\n\t(predict_edge_def, predict_insn_def): New global functions.\n\t(dump_prediction, combine_predictions_for_insns): New\n\tstatic functions.\n\t(estimate_probability): Change calls to predict_edge\n\tto predict_edge_def and calls to predict_insn to predict_insn_def;\n\tcombine probabilities.\n\t(expected_value_to_br_prob): Behave as predictor.\n\t* rtl.h (REG_BR_PRED): Update coment.\n\t(invert_br_probabilities): New.\n\t* jump.c: Include predict.h\n\t(duplicate_loop_exit_test): Drop branch prediction notes.\n\t(invert_jump): Use invert_br_probabilities.\n\t* Makefile.in: Add dependancy on predict.h for jump and predict pass.\n\t* ifcvt.c (dead_or_predicable): Use invert_br_probabilities.\n\t* combine.c (distribute_notes): Handle BR_PRED.\n\nFrom-SVN: r43115", "tree": {"sha": "c28f4818b4bed04584e0f35d196aab217d30a449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c28f4818b4bed04584e0f35d196aab217d30a449"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/comments", "author": null, "committer": null, "parents": [{"sha": "5bb8dd28b87e7894d3dd5e03eacb09b975bbf0ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb8dd28b87e7894d3dd5e03eacb09b975bbf0ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb8dd28b87e7894d3dd5e03eacb09b975bbf0ca"}], "stats": {"total": 380, "additions": 325, "deletions": 55}, "files": [{"sha": "d38b78a5d0a79ac733a83208d265eb9a6f711429", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -1,3 +1,26 @@\n+Sun Jun 10 00:35:37 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.def: New file.\n+\t* predict.h: New file.\n+\t* predict.c: Include predict.h.\n+\t(predictor_info): New structure and array.\n+\t(predict_edge, predict_insn): Rewrite; make global.\n+\t(predict_edge_def, predict_insn_def): New global functions.\n+\t(dump_prediction, combine_predictions_for_insns): New\n+\tstatic functions.\n+\t(estimate_probability): Change calls to predict_edge\n+\tto predict_edge_def and calls to predict_insn to predict_insn_def;\n+\tcombine probabilities.\n+\t(expected_value_to_br_prob): Behave as predictor.\n+\t* rtl.h (REG_BR_PRED): Update coment.\n+\t(invert_br_probabilities): New.\n+\t* jump.c: Include predict.h\n+\t(duplicate_loop_exit_test): Drop branch prediction notes.\n+\t(invert_jump): Use invert_br_probabilities.\n+\t* Makefile.in: Add dependancy on predict.h for jump and predict pass.\n+\t* ifcvt.c (dead_or_predicable): Use invert_br_probabilities.\n+\t* combine.c (distribute_notes): Handle BR_PRED.\n+\n Sat Jun  9 23:29:41 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (predict_insn, predict_edge): New static functions."}, {"sha": "c3ff71399946f62634cb8b567f2a329569e44d0f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -572,6 +572,7 @@ INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h\n C_COMMON_H = c-common.h $(SPLAY_TREE_H)\n C_TREE_H = c-tree.h $(C_COMMON_H)\n SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h\n+PREDICT_H = predict.h predict.def\n \n # sed inserts variable overrides after the following line.\n ####target overrides\n@@ -1403,7 +1404,7 @@ integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    params.h $(TM_P_H)\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n-   toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h\n+   toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H)\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n@@ -1509,7 +1510,7 @@ reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(RECOG_H)\n    varray.h function.h $(TM_P_H)\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n-   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H)\n+   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H)\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\"}, {"sha": "a9ad710b8fd193c7f3a946290e9ede91b73f1fe7", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -11952,6 +11952,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n       switch (REG_NOTE_KIND (note))\n \t{\n \tcase REG_BR_PROB:\n+\tcase REG_BR_PRED:\n \tcase REG_EXEC_COUNT:\n \t  /* Doesn't matter much where we put this, as long as it's somewhere.\n \t     It is preferable to keep these notes on branches, which is most"}, {"sha": "4e3c43ec5df6906d77b8adfe4f42daa47563fbe4", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -2410,11 +2410,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n   JUMP_LABEL (jump) = new_dest;\n \n   if (reversep)\n-    {\n-      rtx note = find_reg_note (jump, REG_BR_PROB, NULL_RTX);\n-      if (note)\n-\tXEXP (note, 0) = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (note, 0)));\n-    }\n+    invert_br_probabilities (jump);\n \n   /* Move the insns out of MERGE_BB to before the branch.  */\n   if (head != NULL)"}, {"sha": "067b7aafcdc01eee3bd2ae0b73e9af3cb27bfb55", "filename": "gcc/jump.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -67,6 +67,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"reload.h\"\n+#include \"predict.h\"\n \n /* ??? Eventually must record somehow the labels used by jumps\n    from nested functions.  */\n@@ -1248,6 +1249,23 @@ duplicate_loop_exit_test (loop_start)\n \t\treplace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \t    }\n \n+\t  /* Predict conditional jump that do make loop looping as taken.\n+\t     Other jumps are probably exit conditions, so predict\n+\t     them as untaken.  */\n+\t  if (any_condjump_p (copy))\n+\t    {\n+\t      rtx label = JUMP_LABEL (copy);\n+\t      if (label)\n+\t\t{\n+\t\t  if (PREV_INSN (label)\n+\t\t      && GET_CODE (PREV_INSN (label)) == NOTE\n+\t\t      && (NOTE_LINE_NUMBER (PREV_INSN (label))\n+\t\t\t  == NOTE_INSN_LOOP_CONT))\n+\t\t    predict_insn_def (copy, PRED_LOOP_HEADER, TAKEN);\n+\t\t  else\n+\t\t    predict_insn_def (copy, PRED_LOOP_HEADER, NOT_TAKEN);\n+\t\t}\n+\t    }\n \t  /* If this is a simple jump, add it to the jump chain.  */\n \n \t  if (INSN_UID (copy) < max_jump_chain && JUMP_LABEL (copy)\n@@ -3351,13 +3369,7 @@ invert_jump (jump, nlabel, delete_unused)\n \n   if (redirect_jump (jump, nlabel, delete_unused))\n     {\n-      /* An inverted jump means that a probability taken becomes a\n-\t probability not taken.  Subtract the branch probability from the\n-\t probability base to convert it back to a taken probability.  */\n-\n-      rtx note = find_reg_note (jump, REG_BR_PROB, NULL_RTX);\n-      if (note)\n-\tXEXP (note, 0) = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (note, 0)));\n+      invert_br_probabilities (jump);\n \n       return 1;\n     }"}, {"sha": "d4210e030cb969fcf615e32464becd0efc022be2", "filename": "gcc/predict.c", "status": "modified", "additions": 174, "deletions": 34, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -46,7 +46,7 @@\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"expr.h\"\n-\n+#include \"predict.h\"\n \n /* Random guesstimation given names.  */\n #define PROB_NEVER\t\t(0)\n@@ -57,34 +57,63 @@\n #define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n-static void predict_insn\tPARAMS ((rtx, int));\n-static void predict_edge\tPARAMS ((edge, int));\n+static void combine_predictions_for_insn PARAMS ((rtx, basic_block));\n+static void dump_prediction\t\t PARAMS ((enum br_predictor, int,\n+\t\t\t\t\t\t  basic_block));\n \n-static void\n-predict_insn (insn, probability)\n-     rtx insn;\n-     int probability;\n+/* Information we hold about each branch predictor.\n+   Filled using information from predict.def.  */\n+struct predictor_info\n {\n-  rtx note = find_reg_note (insn, REG_BR_PROB, 0);\n+  const char *name;\t/* Name used in the debugging dumps.  */\n+  int hitrate;\t\t/* Expected hitrate used by\n+\t\t\t   predict_insn_def call.  */\n+};\n \n-  /* Implement \"first match\" heruistics.  In case we already predicted\n-     insn somehow, keep it predicted that way.  In future we would like\n-     to rather store all predictions and then combine them.  */\n-  if (note)\n-    return;\n+#define DEF_PREDICTOR(ENUM, NAME, HITRATE) {NAME, HITRATE},\n+struct predictor_info predictor_info[] = {\n+#include \"predict.def\"\n+\n+  /* Upper bound on non-language-specific builtins. */\n+  {NULL, 0}\n+};\n+#undef DEF_PREDICTOR\n \n+void\n+predict_insn (insn, predictor, probability)\n+     rtx insn;\n+     int probability;\n+     enum br_predictor predictor;\n+{\n   if (!any_condjump_p (insn))\n     abort ();\n   REG_NOTES (insn)\n-    = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t GEN_INT (probability), REG_NOTES (insn));\n+    = gen_rtx_EXPR_LIST (REG_BR_PRED,\n+\t\t\t gen_rtx_CONCAT (VOIDmode,\n+\t\t\t\t\t GEN_INT ((int) predictor),\n+\t\t\t\t\t GEN_INT ((int) probability)),\n+\t\t\t REG_NOTES (insn));\n+}\n+\n+/* Predict insn by given predictor.  */\n+void\n+predict_insn_def (insn, predictor, taken)\n+     rtx insn;\n+     enum br_predictor predictor;\n+     enum prediction taken;\n+{\n+   int probability = predictor_info[(int) predictor].hitrate;\n+   if (taken != TAKEN)\n+     probability = REG_BR_PROB_BASE - probability;\n+   predict_insn (insn, predictor, probability);\n }\n \n /* Predict edge E with given probability if possible.  */\n-static void\n-predict_edge (e, probability)\n+void\n+predict_edge (e, predictor, probability)\n      edge e;\n      int probability;\n+     enum br_predictor predictor;\n {\n   rtx last_insn;\n   last_insn = e->src->end;\n@@ -98,7 +127,107 @@ predict_edge (e, probability)\n   if (e->flags & EDGE_FALLTHRU)\n     probability = REG_BR_PROB_BASE - probability;\n \n-  predict_insn (last_insn, probability);\n+  predict_insn (last_insn, predictor, probability);\n+}\n+\n+/* Predict edge E by given predictor if possible.  */\n+void\n+predict_edge_def (e, predictor, taken)\n+     edge e;\n+     enum br_predictor predictor;\n+     enum prediction taken;\n+{\n+   int probability = predictor_info[(int) predictor].hitrate;\n+\n+   if (taken != TAKEN)\n+     probability = REG_BR_PROB_BASE - probability;\n+   predict_edge (e, predictor, probability);\n+}\n+\n+/* Invert all branch predictions or probability notes in the INSN.  This needs\n+   to be done each time we invert the condition used by the jump.  */\n+void\n+invert_br_probabilities (insn)\n+     rtx insn;\n+{\n+  rtx note = REG_NOTES (insn);\n+\n+  while (note)\n+    {\n+      if (REG_NOTE_KIND (note) == REG_BR_PROB)\n+\tXEXP (note, 0) = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (note, 0)));\n+      else if (REG_NOTE_KIND (note) == REG_BR_PRED)\n+\tXEXP (XEXP (note, 0), 1)\n+\t  = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (XEXP (note, 0), 1)));\n+      note = XEXP (note, 1);\n+    }\n+}\n+\n+/* Dump information about the branch prediction to the output file.  */\n+static void\n+dump_prediction (predictor, probability, bb)\n+     enum br_predictor predictor;\n+     int probability;\n+     basic_block bb;\n+{\n+  edge e = bb->succ;\n+\n+  if (!rtl_dump_file)\n+    return;\n+\n+  while (e->flags & EDGE_FALLTHRU)\n+    e = e->succ_next;\n+\n+  fprintf (rtl_dump_file, \"  %s heuristics: %.1f%%\",\n+\t   predictor_info[predictor].name,\n+\t   probability * 100.0 / REG_BR_PROB_BASE);\n+\n+  if (bb->count)\n+    fprintf (rtl_dump_file, \"  exec %i hit %i (%.1f%%)\",\n+\t     bb->count, e->count, e->count * 100.0 / bb->count);\n+  fprintf (rtl_dump_file, \"\\n\");\n+}\n+\n+/* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB\n+   note if not already present.  Remove now useless REG_BR_PRED notes.  */\n+static void\n+combine_predictions_for_insn (insn, bb)\n+     rtx insn;\n+     basic_block bb;\n+{\n+  rtx prob_note = find_reg_note (insn, REG_BR_PROB, 0);\n+  rtx *pnote = &REG_NOTES (insn);\n+  int best_probability = PROB_EVEN;\n+  int best_predictor = END_PREDICTORS;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Predictions for insn %i\\n\", INSN_UID (insn));\n+\n+  /* We implement \"first match\" heuristics and use probability guessed\n+     by predictor with smallest index.  In future we will use better\n+     probability combination techniques.  */\n+  while (*pnote)\n+    {\n+      rtx *next_pnote = &XEXP (*pnote, 1);\n+      if (REG_NOTE_KIND (*pnote) == REG_BR_PRED)\n+\t{\n+\t  int predictor = INTVAL (XEXP (XEXP (*pnote, 0), 0));\n+\t  int probability = INTVAL (XEXP (XEXP (*pnote, 0), 1));\n+\n+\t  dump_prediction (predictor, probability, bb);\n+\t  if (best_predictor > predictor)\n+\t    best_probability = probability, best_predictor = predictor;\n+\t  *pnote = XEXP (*pnote, 1);\n+\t}\n+      pnote = next_pnote;\n+    }\n+  dump_prediction (PRED_FIRST_MATCH, best_probability, bb);\n+  if (!prob_note)\n+    {\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t     GEN_INT (best_probability), REG_NOTES (insn));\n+    }\n }\n \n /* Statically estimate the probability that a branch will be taken.\n@@ -134,15 +263,15 @@ estimate_probability (loops_info)\n \t\tif (e->dest == loops_info->array[i].header)\n \t\t  {\n \t\t    header_found = 1;\n-\t\t    predict_edge (e, PROB_VERY_LIKELY);\n+\t\t    predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n \t\t  }\n \t      /* Loop exit heruistics - predict as not taken an edge exiting\n \t         the loop if the conditinal has no loop header successors  */\n \t      if (!header_found)\n \t\tfor (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n \t\t  if (e->dest->index <= 0\n \t\t      || !TEST_BIT (loops_info->array[i].nodes, e->dest->index))\n-\t\t    predict_edge (e, PROB_UNLIKELY);\n+\t\t    predict_edge_def (e, PRED_LOOP_EXIT, NOT_TAKEN);\n \t    }\n \t}\n     }\n@@ -169,7 +298,7 @@ estimate_probability (loops_info)\n       /* ??? Ought to do the same for any subgraph with no exit.  */\n       for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n \tif (e->dest->succ == NULL)\n-\t  predict_edge (e, PROB_NEVER);\n+\t  predict_edge_def (e, PRED_NORETURN, NOT_TAKEN);\n \n       cond = get_condition (last_insn, &earliest);\n       if (! cond)\n@@ -187,15 +316,15 @@ estimate_probability (loops_info)\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n \t\t      && REG_POINTER (XEXP (cond, 1)))))\n \t    \n-\t    predict_insn (last_insn, PROB_UNLIKELY);\n+\t    predict_insn_def (last_insn, PRED_POINTER, NOT_TAKEN);\n \t  break;\n \tcase NE:\n \t  if (GET_CODE (XEXP (cond, 0)) == REG\n \t      && REG_POINTER (XEXP (cond, 0))\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n \t\t      && REG_POINTER (XEXP (cond, 1)))))\n-\t    predict_insn (last_insn, PROB_LIKELY);\n+\t    predict_insn_def (last_insn, PRED_POINTER, TAKEN);\n \t  break;\n \n \tdefault:\n@@ -210,41 +339,52 @@ estimate_probability (loops_info)\n \t{\n \tcase CONST_INT:\n \t  /* Unconditional branch.  */\n-\t  predict_insn (last_insn,\n-\t\t\tcond == const0_rtx ? PROB_NEVER : PROB_ALWAYS);\n+\t  predict_insn_def (last_insn, PRED_UNCONDITIONAL,\n+\t\t\t    cond == const0_rtx ? NOT_TAKEN : TAKEN);\n \t  break;\n \n \tcase EQ:\n \tcase UNEQ:\n-\t  predict_insn (last_insn, PROB_UNLIKELY);\n+\t  predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n \t  break;\n \tcase NE:\n \tcase LTGT:\n-\t  predict_insn (last_insn, PROB_LIKELY);\n+\t  predict_insn_def (last_insn, PRED_OPCODE, TAKEN);\n \t  break;\n \tcase ORDERED:\n-\t  predict_insn (last_insn, PROB_LIKELY);\n+\t  predict_insn_def (last_insn, PRED_OPCODE, TAKEN);\n \t  break;\n \tcase UNORDERED:\n-\t  predict_insn (last_insn, PROB_UNLIKELY);\n+\t  predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n \t  break;\n \tcase LE:\n \tcase LT:\n \t  if (XEXP (cond, 1) == const0_rtx)\n-\t    predict_insn (last_insn, PROB_UNLIKELY);\n+\t    predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n \t  break;\n \tcase GE:\n \tcase GT:\n \t  if (XEXP (cond, 1) == const0_rtx\n \t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n \t\t  && INTVAL (XEXP (cond, 1)) == -1))\n-\t    predict_insn (last_insn, PROB_LIKELY);\n+\t    predict_insn_def (last_insn, PRED_OPCODE, TAKEN);\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n     }\n+\n+  /* Attach the combined probability to each conditional jump.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      rtx last_insn = BLOCK_END (i);\n+\n+      if (GET_CODE (last_insn) != JUMP_INSN\n+\t  || ! any_condjump_p (last_insn))\n+\tcontinue;\n+      combine_predictions_for_insn (last_insn, BASIC_BLOCK (i));\n+    }\n }\n \f\n /* __builtin_expect dropped tokens into the insn stream describing\n@@ -285,7 +425,7 @@ expected_value_to_br_prob ()\n \t     expected value yet, no point going further.  */\n \t  if (GET_CODE (insn) != JUMP_INSN || ev == NULL_RTX)\n \t    continue;\n-\t  if (! condjump_p (insn) || simplejump_p (insn))\n+\t  if (! any_condjump_p (insn))\n \t    continue;\n \t  break;\n \t}\n@@ -316,7 +456,7 @@ expected_value_to_br_prob ()\n       /* Turn the condition into a scaled branch probability.  */\n       if (cond != const1_rtx && cond != const0_rtx)\n \tabort ();\n-      predict_insn (insn,\n-\t\t    cond == const1_rtx ? PROB_VERY_LIKELY : PROB_VERY_UNLIKELY);\n+      predict_insn_def (insn, PRED_BUILTIN_EXPECT,\n+\t\t        cond == const1_rtx ? TAKEN : NOT_TAKEN);\n     }\n }"}, {"sha": "ce0fbbdf7733ba3a3149733b5146f425151235ba", "filename": "gcc/predict.def", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -0,0 +1,47 @@\n+/* This file contains the definitions and documentation for the\n+   builtins used in the GNU compiler.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Before including this file, you should define a macro:\n+\n+     DEF_PREDICTOR (ENUM, NAME, HITRATE)\n+\n+   This macro will be called once for each predictor.  The ENUM will\n+   be of type `enum predictor', and will enumerate all supported\n+   predictors.  The order of DEF_PREDICTOR calls is important, as\n+   in the first match combining heuristics, the predictor appearing\n+   first in this file will win.\n+\n+   NAME is used in the debugging output to determine predictor type.\n+\n+   HITRATE is the probability that edge predicted by predictor as taken\n+   will be really taken (so it should be always above\n+   REG_BR_PROB_BASE / 2).  */\n+   \n+\n+DEF_PREDICTOR (PRED_FIRST_MATCH, \"first match\", PROB_ALWAYS)\n+DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS)\n+DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY)\n+DEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", PROB_ALWAYS)\n+DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", PROB_VERY_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_POINTER, \"pointer\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_OPCODE, \"opcode\", PROB_LIKELY)"}, {"sha": "3cc52deb0a58f562d6f33dea8cd27f82b3bea715", "filename": "gcc/predict.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -0,0 +1,46 @@\n+/* This file contains the definitions and documentation for the\n+   builtins used in the GNU compiler.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define DEF_PREDICTOR(ENUM, NAME, HITRATE) ENUM,\n+enum br_predictor\n+{\n+#include \"predict.def\"\n+\n+  /* Upper bound on non-language-specific builtins. */\n+  END_PREDICTORS\n+};\n+#undef DEF_PREDICTOR\n+enum prediction\n+{\n+   NOT_TAKEN,\n+   TAKEN\n+};\n+\n+extern void predict_insn_def\tPARAMS ((rtx, enum br_predictor,\n+\t\t\t\t\t enum prediction));\n+extern void predict_insn\tPARAMS ((rtx, enum br_predictor, int));\n+\n+/* Avoid unneeded dependancy on basic_block.h  */\n+#ifdef BASIC_BLOCK\n+extern void predict_edge\tPARAMS ((edge, enum br_predictor, int));\n+extern void predict_edge_def\tPARAMS ((edge, enum br_predictor,\n+\t\t\t\t\t enum prediction));\n+#endif"}, {"sha": "32c22ecbe2c4fa1ee498b23f11a946149124b38a", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4db384c950ec85ca96e4bcaf7b00c36f2f6ccbd5", "patch": "@@ -497,10 +497,10 @@ enum reg_note\n      flow, are represented by a 0 reg note kind.  */\n   REG_DEP_ANTI, REG_DEP_OUTPUT,\n \n-  /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs when the flag\n-     -fbranch-probabilities is given.  It has an integer value.  For jumps,\n-     it is the probability that this is a taken branch.  For calls, it is\n-     the probability that this call won't return.  */\n+  /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs.\n+     It has an integer value.  For jumps, it is the probability that this is a\n+     taken branch.  For calls, it is the probability that this call won't\n+     return.  */\n   REG_BR_PROB,\n \n   /* REG_EXEC_COUNT is attached to the first insn of each basic block, and\n@@ -516,8 +516,10 @@ enum reg_note\n      where SETJMP_VIA_SAVE_AREA is true.  */\n   REG_SAVE_AREA,\n \n-  /* Attached to JUMP_INSNs only, it holds the branch prediction flags\n-     computed by get_jump_flags() after dbr scheduling is complete.  */\n+  /* REG_BR_PRED is attached to JUMP_INSNs and CALL_INSNSs.  It contains\n+     CONCAT of two integer value.  First specifies the branch predictor\n+     that added the note, second specifies the predicted hitrate of branch\n+     in the same format as REG_BR_PROB note uses.  */\n   REG_BR_PRED,\n \n   /* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n@@ -2020,7 +2022,9 @@ extern rtx stack_limit_rtx;\n /* In regrename.c */\n extern void regrename_optimize\t\tPARAMS ((void));\n \n-/* In condexec.c */\n+/* In ifcvt.c */\n extern void if_convert\t\t\tPARAMS ((int));\n \n+/* In predict.c */\n+extern void invert_br_probabilities\tPARAMS ((rtx));\n #endif /* ! GCC_RTL_H */"}]}