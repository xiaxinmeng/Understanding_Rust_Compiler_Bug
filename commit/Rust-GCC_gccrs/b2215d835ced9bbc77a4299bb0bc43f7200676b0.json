{"sha": "b2215d835ced9bbc77a4299bb0bc43f7200676b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIyMTVkODM1Y2VkOWJiYzc3YTQyOTliYjBiYzQzZjcyMDA2NzZiMA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-01T20:55:32Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-01T20:55:32Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1378", "tree": {"sha": "df086b7d43ff599bdf1d65102ae336503c53cb4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df086b7d43ff599bdf1d65102ae336503c53cb4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2215d835ced9bbc77a4299bb0bc43f7200676b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2215d835ced9bbc77a4299bb0bc43f7200676b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2215d835ced9bbc77a4299bb0bc43f7200676b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2215d835ced9bbc77a4299bb0bc43f7200676b0/comments", "author": null, "committer": null, "parents": [{"sha": "ac075f04b2a30b5ebb818c4eb4c05b6bff065b60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac075f04b2a30b5ebb818c4eb4c05b6bff065b60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac075f04b2a30b5ebb818c4eb4c05b6bff065b60"}], "stats": {"total": 144, "additions": 106, "deletions": 38}, "files": [{"sha": "c56104dd07ae98e09b8d46ec50cf4f0b10518325", "filename": "gcc/fold-const.c", "status": "modified", "additions": 106, "deletions": 38, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2215d835ced9bbc77a4299bb0bc43f7200676b0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2215d835ced9bbc77a4299bb0bc43f7200676b0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b2215d835ced9bbc77a4299bb0bc43f7200676b0", "patch": "@@ -2215,7 +2215,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \t\trhs);\n }\n \f\n-/* Subroutine for the following routine: decode a field reference.\n+/* Subroutine for fold_truthop: decode a field reference.\n \n    If EXP is a comparison reference, we return the innermost reference.\n \n@@ -2303,14 +2303,39 @@ all_ones_mask_p (mask, size)\n \t\t\t\t\t       size_int (precision - size)),\n \t\t\t\t  size_int (precision - size)), 0);\n }\n+\n+/* Subroutine for fold_truthop: determine if an operand is simple enough\n+   to be evaluated unconditionally.  */\n+\n+#ifdef __GNUC__\n+__inline\n+#endif\n+static int \n+simple_operand_p (exp)\n+     tree exp;\n+{\n+  /* Strip any conversions that don't change the machine mode.  */\n+  while ((TREE_CODE (exp) == NOP_EXPR\n+\t  || TREE_CODE (exp) == CONVERT_EXPR)\n+\t && (TYPE_MODE (TREE_TYPE (exp))\n+\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  return (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c'\n+\t  || (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n+\t      && ! TREE_ADDRESSABLE (exp)\n+\t      && ! TREE_THIS_VOLATILE (exp)\n+\t      && ! TREE_NONLOCAL (exp)));\n+}\n \f\n-/* Try to optimize a range test.\n+/* Subroutine for fold_truthop: try to optimize a range test.\n \n    For example, \"i >= 2 && i =< 9\" can be done as \"(unsigned) (i - 2) <= 7\".\n \n-   JCODE is the logical combination of the two terms.  It can be\n-   TRUTH_ANDIF_EXPR, TRUTH_AND_EXPR, TRUTH_ORIF_EXPR, or TRUTH_OR_EXPR.\n-   TYPE is the type of the result.\n+   JCODE is the logical combination of the two terms.  It is BIT_AND_EXPR\n+   (representing TRUTH_ANDIF_EXPR and TRUTH_AND_EXPR) or BIT_IOR_EXPR\n+   (representing TRUTH_ORIF_EXPR and TRUTH_OR_EXPR).  TYPE is the type of\n+   the result.\n \n    VAR is the value being tested.  LO_CODE and HI_CODE are the comparison\n    operators comparing VAR to LO_CST and HI_CST.  LO_CST is known to be no\n@@ -2328,7 +2353,7 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \n   /* See if this is a range test and normalize the constant terms.  */\n \n-  if (jcode == TRUTH_ANDIF_EXPR || jcode == TRUTH_AND_EXPR)\n+  if (jcode == BIT_AND_EXPR)\n     {\n       switch (lo_code)\n \t{\n@@ -2426,8 +2451,11 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n \t\t\t       const_binop (MINUS_EXPR, hi_cst, lo_cst))));\n }\n \f\n-/* Try to merge two comparisons to the same innermost item.\n-   Also look for range tests like \"ch >= '0' && ch <= '9'\".\n+/* Find ways of folding logical expressions of LHS and RHS:\n+   Try to merge two comparisons to the same innermost item.\n+   Look for range tests like \"ch >= '0' && ch <= '9'\".\n+   Look for combinations of simple terms on machines with expensive branches\n+   and evaluate the RHS unconditionally.\n \n    For example, if we have p->a == 2 && p->b == 4 and we can make an\n    object large enough to span both A and B, we can do this with a comparison\n@@ -2448,7 +2476,7 @@ range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n    We return the simplified tree or 0 if no optimization is possible.  */\n \n static tree\n-merge_component_references (code, truth_type, lhs, rhs)\n+fold_truthop (code, truth_type, lhs, rhs)\n      enum tree_code code;\n      tree truth_type, lhs, rhs;\n {\n@@ -2461,9 +2489,9 @@ merge_component_references (code, truth_type, lhs, rhs)\n      convert EQ_EXPR to NE_EXPR so we need not reject the \"wrong\"\n      comparison for one-bit fields.  */\n \n-  enum tree_code wanted_code\n-    = (code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR) ? EQ_EXPR : NE_EXPR;\n+  enum tree_code wanted_code;\n   enum tree_code lcode, rcode;\n+  tree ll_arg, lr_arg, rl_arg, rr_arg;\n   tree ll_inner, lr_inner, rl_inner, rr_inner;\n   int ll_bitsize, ll_bitpos, lr_bitsize, lr_bitpos;\n   int rl_bitsize, rl_bitpos, rr_bitsize, rr_bitpos;\n@@ -2473,61 +2501,97 @@ merge_component_references (code, truth_type, lhs, rhs)\n   enum machine_mode ll_mode, lr_mode, rl_mode, rr_mode;\n   enum machine_mode lnmode, rnmode;\n   tree ll_mask, lr_mask, rl_mask, rr_mask;\n-  tree l_const = 0, r_const = 0;\n+  tree l_const, r_const;\n   tree type, result;\n   int first_bit, end_bit;\n-  int volatilep = 0;\n+  int volatilep;\n \n   /* Start by getting the comparison codes and seeing if this looks like\n      a range test.  Fail if anything is volatile.  */\n \n+  if (TREE_SIDE_EFFECTS (lhs)\n+      || TREE_SIDE_EFFECTS (rhs))\n+    return 0;\n+\n   lcode = TREE_CODE (lhs);\n   rcode = TREE_CODE (rhs);\n \n-  if (TREE_SIDE_EFFECTS (lhs)\n-      || TREE_SIDE_EFFECTS (rhs)\n-      || TREE_CODE_CLASS (lcode) != '<'\n+  if (TREE_CODE_CLASS (lcode) != '<'\n       || TREE_CODE_CLASS (rcode) != '<')\n     return 0;\n \n-  if (TREE_CODE (TREE_OPERAND (lhs, 1)) == INTEGER_CST\n-      && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n-      && operand_equal_p (TREE_OPERAND (lhs, 0),\n-\t\t\t  TREE_OPERAND (rhs, 0), 0))\n+  code = ((code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR)\n+\t  ? BIT_AND_EXPR : BIT_IOR_EXPR);\n+\n+  ll_arg = TREE_OPERAND (lhs, 0);\n+  lr_arg = TREE_OPERAND (lhs, 1);\n+  rl_arg = TREE_OPERAND (rhs, 0);\n+  rr_arg = TREE_OPERAND (rhs, 1);\n+  \n+  if (TREE_CODE (lr_arg) == INTEGER_CST\n+      && TREE_CODE (rr_arg) == INTEGER_CST\n+      && operand_equal_p (ll_arg, rl_arg, 0))\n     {\n-      if (tree_int_cst_lt (TREE_OPERAND (lhs, 1), TREE_OPERAND (rhs, 1)))\n+      if (tree_int_cst_lt (lr_arg, rr_arg))\n \tresult = range_test (code, truth_type, lcode, rcode,\n-\t\t\t     TREE_OPERAND (lhs, 0),\n-\t\t\t     TREE_OPERAND (lhs, 1),\n-\t\t\t     TREE_OPERAND (rhs, 1));\n+\t\t\t     ll_arg, lr_arg, rr_arg);\n       else\n \tresult = range_test (code, truth_type, rcode, lcode,\n-\t\t\t     TREE_OPERAND (lhs, 0),\n-\t\t\t     TREE_OPERAND (rhs, 1),\n-\t\t\t     TREE_OPERAND (lhs, 1));\n+\t\t\t     ll_arg, rr_arg, lr_arg);\n \n       /* If this isn't a range test, it also isn't a comparison that\n-\t can be merged.  */\n+\t can be merged.  However, it wins to evaluate the RHS unconditionally\n+\t on machines with expensive branches.   */\n+\n+      if (result == 0 && BRANCH_COST >= 2)\n+\t{\n+\t  if (TREE_CODE (ll_arg) != VAR_DECL\n+\t      && TREE_CODE (ll_arg) != PARM_DECL)\n+\t    {\n+\t      /* Avoid evaluating the variable part twice.  */\n+\t      ll_arg = save_expr (ll_arg);\n+\t      lhs = build (lcode, TREE_TYPE (lhs), ll_arg, lr_arg);\n+\t      rhs = build (rcode, TREE_TYPE (rhs), ll_arg, rr_arg);\n+\t    }\n+\t  return build (code, truth_type, lhs, rhs);\n+\t}\n       return result;\n     }\n \n+  /* If the RHS can be evaluated unconditionally and all operands are\n+     simple, it wins to evaluate the RHS unconditionally on machines\n+     with expensive branches.  In this case, this isn't a comparison\n+     that can be merged.  */\n+\n+  /* @@ I'm not sure it wins on the m88110 to do this if the comparisons\n+     are with zero (tmw).  */\n+\n+  if (BRANCH_COST >= 2\n+      && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE\n+      && simple_operand_p (rl_arg)\n+      && simple_operand_p (ll_arg)\n+      && simple_operand_p (rr_arg)\n+      && simple_operand_p (lr_arg))\n+    return build (code, truth_type, lhs, rhs);\n+\n   /* See if the comparisons can be merged.  Then get all the parameters for\n      each side.  */\n \n   if ((lcode != EQ_EXPR && lcode != NE_EXPR)\n       || (rcode != EQ_EXPR && rcode != NE_EXPR))\n     return 0;\n \n-  ll_inner = decode_field_reference (TREE_OPERAND (lhs, 0),\n+  volatilep = 0;\n+  ll_inner = decode_field_reference (ll_arg,\n \t\t\t\t     &ll_bitsize, &ll_bitpos, &ll_mode,\n \t\t\t\t     &ll_unsignedp, &volatilep, &ll_mask);\n-  lr_inner = decode_field_reference (TREE_OPERAND (lhs, 1),\n+  lr_inner = decode_field_reference (lr_arg,\n \t\t\t\t     &lr_bitsize, &lr_bitpos, &lr_mode,\n \t\t\t\t     &lr_unsignedp, &volatilep, &lr_mask);\n-  rl_inner = decode_field_reference (TREE_OPERAND (rhs, 0),\n+  rl_inner = decode_field_reference (rl_arg,\n \t\t\t\t     &rl_bitsize, &rl_bitpos, &rl_mode,\n \t\t\t\t     &rl_unsignedp, &volatilep, &rl_mask);\n-  rr_inner = decode_field_reference (TREE_OPERAND (rhs, 1),\n+  rr_inner = decode_field_reference (rr_arg,\n \t\t\t\t     &rr_bitsize, &rr_bitpos, &rr_mode,\n \t\t\t\t     &rr_unsignedp, &volatilep, &rr_mask);\n \n@@ -2539,16 +2603,20 @@ merge_component_references (code, truth_type, lhs, rhs)\n       || ! operand_equal_p (ll_inner, rl_inner, 0))\n     return 0;\n \n-  if (TREE_CODE (TREE_OPERAND (lhs, 1)) == INTEGER_CST\n-      && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n-    l_const = TREE_OPERAND (lhs, 1), r_const = TREE_OPERAND (rhs, 1);\n+  if (TREE_CODE (lr_arg) == INTEGER_CST\n+      && TREE_CODE (rr_arg) == INTEGER_CST)\n+    l_const = lr_arg, r_const = rr_arg;\n   else if (lr_inner == 0 || rr_inner == 0\n \t   || ! operand_equal_p (lr_inner, rr_inner, 0))\n     return 0;\n+  else\n+    l_const = r_const = 0;\n \n   /* If either comparison code is not correct for our logical operation,\n      fail.  However, we can convert a one-bit comparison against zero into\n      the opposite comparison against that bit being set in the field.  */\n+\n+  wanted_code = (code == BIT_AND_EXPR ? EQ_EXPR : NE_EXPR);\n   if (lcode != wanted_code)\n     {\n       if (l_const && integer_zerop (l_const) && integer_pow2p (ll_mask))\n@@ -3456,13 +3524,13 @@ fold (expr)\n \t{\n \t  if (TREE_CODE (arg0) == code)\n \t    {\n-\t      tem = merge_component_references (code, type,\n-\t\t\t\t\t\tTREE_OPERAND (arg0, 1), arg1);\n+\t      tem = fold_truthop (code, type,\n+\t\t\t\t  TREE_OPERAND (arg0, 1), arg1);\n \t      if (tem)\n \t\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n \t    }\n \n-\t  tem = merge_component_references (code, type, arg0, arg1);\n+\t  tem = fold_truthop (code, type, arg0, arg1);\n \t  if (tem)\n \t    return tem;\n \t}"}]}