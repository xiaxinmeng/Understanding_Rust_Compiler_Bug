{"sha": "301375fdd557a3ae056580ee3f692ce2bbcc67ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAxMzc1ZmRkNTU3YTNhZTA1NjU4MGVlM2Y2OTJjZTJiYmNjNjdhZA==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2014-12-10T15:29:19Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2014-12-10T15:29:19Z"}, "message": "re PR fortran/60718 (Test case gfortran.dg/select_type_4.f90 fails on ARM)\n\n2014-12-10  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n\tPR fortran/60718\n\t* trans-expr.c (gfc_conv_procedure_call): Fix a strict aliasing\n\tviolation when passing a class object to a formal parameter which has\n\tdifferent pointer or allocatable attributes.\n\ntestsuite:\n2014-12-10  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n\tPR fortran/60718\n\t* gfortran.dg/class_alias.f90: New.\n\nFrom-SVN: r218584", "tree": {"sha": "9846d76a16419247ccbfb3e90de4017076721789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9846d76a16419247ccbfb3e90de4017076721789"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/301375fdd557a3ae056580ee3f692ce2bbcc67ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301375fdd557a3ae056580ee3f692ce2bbcc67ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/301375fdd557a3ae056580ee3f692ce2bbcc67ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301375fdd557a3ae056580ee3f692ce2bbcc67ad/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d7290d1cf47c1b910823af3d42075a76b46b0c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7290d1cf47c1b910823af3d42075a76b46b0c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7290d1cf47c1b910823af3d42075a76b46b0c31"}], "stats": {"total": 156, "additions": 156, "deletions": 0}, "files": [{"sha": "cce403611ae4ccc1f52a9d05a0cb1082f0d76fbc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=301375fdd557a3ae056580ee3f692ce2bbcc67ad", "patch": "@@ -1,3 +1,10 @@\n+2014-12-10  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR fortran/60718\n+\t* trans-expr.c (gfc_conv_procedure_call): Fix a strict aliasing\n+\tviolation when passing a class object to a formal parameter which has\n+\tdifferent pointer or allocatable attributes.\n+\n 2014-12-06  Tobias Burnus  <burnus@net-b.de>\n \n \t* error.c (gfc_error_check): Use bool not int."}, {"sha": "a82203cca45c9ec0870791f1f37793570d9275e6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=301375fdd557a3ae056580ee3f692ce2bbcc67ad", "patch": "@@ -4430,6 +4430,55 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t     fsym->attr.optional\n \t\t\t\t     && e->expr_type == EXPR_VARIABLE);\n \t\t    }\n+\t\t  else if (e->ts.type == BT_CLASS && fsym\n+\t\t\t   && fsym->ts.type == BT_CLASS\n+\t\t\t   && !CLASS_DATA (fsym)->as\n+\t\t\t   && !CLASS_DATA (e)->as\n+\t\t\t   && (CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t       != CLASS_DATA (e)->attr.class_pointer\n+\t\t\t       || CLASS_DATA (fsym)->attr.allocatable\n+\t\t\t\t  != CLASS_DATA (e)->attr.allocatable))\n+\t\t    {\n+\t\t      type = gfc_typenode_for_spec (&fsym->ts);\n+\t\t      var = gfc_create_var (type, fsym->name);\n+\t\t      gfc_conv_expr (&parmse, e);\n+\t\t      if (fsym->attr.optional\n+\t\t\t  && e->expr_type == EXPR_VARIABLE\n+\t\t\t  && e->symtree->n.sym->attr.optional)\n+\t\t\t{\n+\t\t\t  stmtblock_t block;\n+\t\t\t  tree cond;\n+\t\t\t  tmp = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n+\t\t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t\t  boolean_type_node, tmp,\n+\t\t\t\t\t\t  fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t\t    null_pointer_node));\n+\t\t\t  gfc_start_block (&block);\n+\t\t\t  gfc_add_modify (&block, var,\n+\t\t\t\t\t  fold_build1_loc (input_location,\n+\t\t\t\t\t\t\t   VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t   type, parmse.expr));\n+\t\t\t  gfc_add_expr_to_block (&parmse.pre,\n+\t\t\t\t fold_build3_loc (input_location,\n+\t\t\t\t\t COND_EXPR, void_type_node,\n+\t\t\t\t\t cond, gfc_finish_block (&block),\n+\t\t\t\t\t build_empty_stmt (input_location)));\n+\t\t\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, var);\n+\t\t\t  parmse.expr = build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t TREE_TYPE (parmse.expr),\n+\t\t\t\t\t cond, parmse.expr,\n+\t\t\t\t\t fold_convert (TREE_TYPE (parmse.expr),\n+\t\t\t\t\t\t       null_pointer_node));\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  gfc_add_modify (&parmse.pre, var,\n+\t\t\t\t\t  fold_build1_loc (input_location,\n+\t\t\t\t\t\t\t   VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t   type, parmse.expr));\n+\t\t\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, var);\n+\t\t\t}\n+\t\t    }\n \t\t  else\n \t\t    gfc_conv_expr_reference (&parmse, e);\n "}, {"sha": "df70bb316a84936fb417ff8c0d47acbf3a51c346", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=301375fdd557a3ae056580ee3f692ce2bbcc67ad", "patch": "@@ -1,3 +1,8 @@\n+2014-12-10  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR fortran/60718\n+\t* gfortran.dg/class_alias.f90: New.\n+\n 2014-12-10  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/forwprop-29.c: Add -fno-ipa-icf."}, {"sha": "961514eb7d48c13455455e2814a60cd549edf814", "filename": "gcc/testsuite/gfortran.dg/class_alias.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_alias.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301375fdd557a3ae056580ee3f692ce2bbcc67ad/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_alias.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_alias.f90?ref=301375fdd557a3ae056580ee3f692ce2bbcc67ad", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! test for aliasing violations when converting class objects with\n+! different target and pointer attributes.\n+!\n+module test_module\n+\n+  implicit none\n+\n+  type, public :: test\n+    integer :: x\n+  end type test\n+\n+contains\n+\n+  subroutine do_it6 (par2_t)\n+    class (test), target :: par2_t\n+    par2_t%x = par2_t%x + 1\n+  end subroutine do_it6\n+   \n+  subroutine do_it5 (par1_p)\n+    class (test), pointer, intent(in) :: par1_p\n+    ! pointer -> target\n+    ! { dg-final { scan-tree-dump \"par2_t\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*par1_p\" \"original\" } }\n+    call do_it6 (par1_p)\n+  end subroutine do_it5\n+\n+  subroutine do_it4 (par_p)\n+    class (test), pointer, intent(in) :: par_p\n+    ! pointer -> pointer\n+    ! { dg-final { scan-tree-dump-not \"par1_p\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*par_p\" \"original\" } }\n+    call do_it5 (par_p)\n+  end subroutine do_it4\n+\n+  subroutine do_it3 (par1_t)\n+    class (test), target :: par1_t\n+    ! target -> pointer\n+    ! { dg-final { scan-tree-dump \"par_p\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*par1_t\" \"original\" } }\n+    call do_it4 (par1_t)\n+  end subroutine do_it3\n+\n+  subroutine do_it2 (par_t)\n+    class (test), target :: par_t\n+    ! target -> target\n+    ! { dg-final { scan-tree-dump-not \"par1_t\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*par_t\" \"original\" } }\n+    call do_it3 (par_t)\n+  end subroutine do_it2\n+\n+  subroutine do_it1 (par1_a)\n+    class (test), allocatable :: par1_a\n+    ! allocatable -> target\n+    ! { dg-final { scan-tree-dump \"par_t\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*par1_a\" \"original\" } }\n+    call do_it2 (par1_a)\n+  end subroutine do_it1\n+\n+  subroutine do_it (par_a)\n+    class (test), allocatable :: par_a\n+    ! allocatable -> allocatable\n+    ! { dg-final { scan-tree-dump-not \"par1_a\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*par_a\" \"original\" } }\n+    call do_it1 (par_a)\n+  end subroutine do_it\n+\n+end module test_module\n+\n+use test_module\n+\n+  implicit none\n+  class (test), allocatable :: var_a\n+  class (test), pointer :: var_p\n+\n+\n+  allocate (var_a)\n+  allocate (var_p)\n+  var_a%x = 0\n+  var_p%x = 0\n+  \n+  ! allocatable -> allocatable\n+  ! { dg-final { scan-tree-dump-not \"par_a\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*var_a\" \"original\" } }\n+  call do_it (var_a)\n+  ! allocatable -> target\n+  ! { dg-final { scan-tree-dump \"par_t\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*var_a\" \"original\" } }\n+  call do_it2 (var_a)\n+  ! pointer -> target\n+  ! { dg-final { scan-tree-dump \"par_t\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*var_p\" \"original\" } }\n+  call do_it2 (var_p)\n+  ! pointer -> pointer\n+  ! { dg-final { scan-tree-dump-not \"par_p\\[^\\n]*VIEW_CONVERT_EXPR\\[^\\n]*var_p\" \"original\" } }\n+  call do_it4 (var_p)\n+  if (var_a%x .ne. 2) call abort()\n+  if (var_p%x .ne. 2) call abort()\n+  deallocate (var_a)\n+  deallocate (var_p)\n+end\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}