{"sha": "cc335f4371177761ce88a58a7d5e710f202635fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MzMzVmNDM3MTE3Nzc2MWNlODhhNThhN2Q1ZTcxMGYyMDI2MzVmYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-06-14T13:19:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-06-14T13:19:14Z"}, "message": "[multiple changes]\n\n2004-06-14  Pascal Obry  <obry@gnat.com>\n\n\t* gnat_ugn.texi: Document relocatable vs. dynamic Library_Kind on\n\tWindows.  Fix minor typo.\n\n\t* mlib-tgt-mingw.adb: New implementation using the GCC -shared option\n\twhich is now supported on Windows. With this implementation using the\n\tLibrary Project feature is no different on Windows than on UNIX.\n\n2004-06-14  Vincent Celier  <celier@gnat.com>\n\n\t* makegpr.adb (Compile_Sources): Nothing to do when there are no\n\tnon-Ada sources.\n\n\t* mlib-tgt-vxworks.adb (Library_Exists_For): Remove incorrect comment\n\n\t* prj-part.adb (Parse_Single_Project): When a duplicate project name is\n\tfound, show the project name and the path of the previously parsed\n\tproject file.\n\n2004-06-14  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_ch6.adb (Add_Call_By_Copy_Code): For an out-parameter that is an\n\tarray, avoid copying the actual before the call.\n\n2004-06-14  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* g-debpoo.adb: Remove alignment assumptions from GNAT.Debug_Pools.\n\tInstead, allocate memory on worst-case alignment assumptions, and then\n\treturn an aligned address within the allocated zone.\n\n2004-06-14  Robert Dewar  <dewar@gnat.com>\n\n\t* bindgen.adb (Gen_Adainit_Ada): Do not generate external references to\n\telab entities in predefined units in No_Run_Time_Mode.\n\t(Gen_Adainit_C): Same fix\n\t(Gen_Elab_Calls_Ada): Do not generate calls to elaborate predefined\n\tunits in No_Run_Time_Mode\n\t(Gen_Elab_Calls_C): Same fix\n\n\t* symbols-vms-alpha.adb: Minor reformatting\n\n\t* g-debpoo.ads: Minor reformatting\n\n\t* lib.adb (In_Same_Extended_Unit): Version working on node id's\n\n\t* lib.ads (In_Same_Extended_Unit): Version working on node id's\n\n\t* lib-xref.adb: Minor cleanup, use new version of In_Same_Extended_Unit\n\tworking on nodes.\n\n\t* make.adb: Minor reformatting\n\n\t* par-ch12.adb: Minor reformatting\n\n\t* par-prag.adb: Add dummy entry for pragma Profile_Warnings\n\n\t* prj-strt.adb: Minor reformatting\n\n\t* restrict.ads, restrict.adb: Redo handling of profile restrictions to\n\tbe more general.\n\n\t* sem_attr.adb: Minor reformatting\n\n\t* sem_ch7.adb: Minor reformatting\n\n\t* sem_elab.adb (Check_A_Call): Deal with problem of calling init proc\n\tfor type in the same unit as the object declaration.\n\n\t* sem_prag.adb (Check_Arg_Is_External_Name): New procedure, allows\n\tstatic string expressions and not just string literals.\n\tMinor reformatting\n\t(Set_Warning): Reset restriction warning flag for restriction pragma\n\tImplement pragma Profile_Warnings\n\tImplement pragma Profile (Restricted)\n\tGive obolescent messages for old restrictions and pragmas\n\n\t* snames.h, snames.ads, snames.adb: Add new entry for pragma\n\tProfile_Warnings.\n\n\t* s-rident.ads: Add declarations for restrictions required by profile\n\tRestricted and profile Ravenscar.\n\n\t* targparm.ads, targparm.adb: Allow pragma Profile in system.ads\n\n\t* gnat_ugn.texi: Correct some missing entries in the list of GNAT\n\tconfiguration pragmas.\n\nFrom-SVN: r83099", "tree": {"sha": "266a6f41571fc8312848e6fb01e822f77dd66135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/266a6f41571fc8312848e6fb01e822f77dd66135"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc335f4371177761ce88a58a7d5e710f202635fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc335f4371177761ce88a58a7d5e710f202635fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc335f4371177761ce88a58a7d5e710f202635fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc335f4371177761ce88a58a7d5e710f202635fb/comments", "author": null, "committer": null, "parents": [{"sha": "14ba6d00aaf750cc165764cf09a66c53d2a005a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ba6d00aaf750cc165764cf09a66c53d2a005a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14ba6d00aaf750cc165764cf09a66c53d2a005a5"}], "stats": {"total": 2356, "additions": 1445, "deletions": 911}, "files": [{"sha": "8cb9164d8480d9e4801eb1f35ff08ac904de8b83", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -1,3 +1,91 @@\n+2004-06-14  Pascal Obry  <obry@gnat.com>\n+\n+\t* gnat_ugn.texi: Document relocatable vs. dynamic Library_Kind on\n+\tWindows.  Fix minor typo.\n+\n+\t* mlib-tgt-mingw.adb: New implementation using the GCC -shared option\n+\twhich is now supported on Windows. With this implementation using the\n+\tLibrary Project feature is no different on Windows than on UNIX.\n+\n+2004-06-14  Vincent Celier  <celier@gnat.com>\n+\n+\t* makegpr.adb (Compile_Sources): Nothing to do when there are no\n+\tnon-Ada sources.\n+\n+\t* mlib-tgt-vxworks.adb (Library_Exists_For): Remove incorrect comment\n+\n+\t* prj-part.adb (Parse_Single_Project): When a duplicate project name is\n+\tfound, show the project name and the path of the previously parsed\n+\tproject file.\n+\n+2004-06-14  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* exp_ch6.adb (Add_Call_By_Copy_Code): For an out-parameter that is an\n+\tarray, avoid copying the actual before the call.\n+\n+2004-06-14  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* g-debpoo.adb: Remove alignment assumptions from GNAT.Debug_Pools.\n+\tInstead, allocate memory on worst-case alignment assumptions, and then\n+\treturn an aligned address within the allocated zone.\n+\n+2004-06-14  Robert Dewar  <dewar@gnat.com>\n+\n+\t* bindgen.adb (Gen_Adainit_Ada): Do not generate external references to\n+\telab entities in predefined units in No_Run_Time_Mode.\n+\t(Gen_Adainit_C): Same fix\n+\t(Gen_Elab_Calls_Ada): Do not generate calls to elaborate predefined\n+\tunits in No_Run_Time_Mode\n+\t(Gen_Elab_Calls_C): Same fix\n+\n+\t* symbols-vms-alpha.adb: Minor reformatting\n+\n+\t* g-debpoo.ads: Minor reformatting\n+\n+\t* lib.adb (In_Same_Extended_Unit): Version working on node id's\n+\n+\t* lib.ads (In_Same_Extended_Unit): Version working on node id's\n+\n+\t* lib-xref.adb: Minor cleanup, use new version of In_Same_Extended_Unit\n+\tworking on nodes.\n+\n+\t* make.adb: Minor reformatting\n+\n+\t* par-ch12.adb: Minor reformatting\n+\n+\t* par-prag.adb: Add dummy entry for pragma Profile_Warnings\n+\n+\t* prj-strt.adb: Minor reformatting\n+\n+\t* restrict.ads, restrict.adb: Redo handling of profile restrictions to\n+\tbe more general.\n+\n+\t* sem_attr.adb: Minor reformatting\n+\n+\t* sem_ch7.adb: Minor reformatting\n+\n+\t* sem_elab.adb (Check_A_Call): Deal with problem of calling init proc\n+\tfor type in the same unit as the object declaration.\n+\n+\t* sem_prag.adb (Check_Arg_Is_External_Name): New procedure, allows\n+\tstatic string expressions and not just string literals.\n+\tMinor reformatting\n+\t(Set_Warning): Reset restriction warning flag for restriction pragma\n+\tImplement pragma Profile_Warnings\n+\tImplement pragma Profile (Restricted)\n+\tGive obolescent messages for old restrictions and pragmas\n+\n+\t* snames.h, snames.ads, snames.adb: Add new entry for pragma\n+\tProfile_Warnings.\n+\n+\t* s-rident.ads: Add declarations for restrictions required by profile\n+\tRestricted and profile Ravenscar.\n+\n+\t* targparm.ads, targparm.adb: Allow pragma Profile in system.ads\n+\n+\t* gnat_ugn.texi: Correct some missing entries in the list of GNAT\n+\tconfiguration pragmas.\n+\n 2004-06-11  Vincent Celier  <celier@gnat.com>\n \n \t* mlib-tgt-vms-alpha.adb (Build_Dynamic_Library): Issue switch -R to"}, {"sha": "76626a8fc5d9fbdf1a03ebb6b145d280bf0bf942", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -371,7 +371,21 @@ package body Bindgen is\n             U    : Unit_Record renames Units.Table (Unum);\n \n          begin\n-            if U.Set_Elab_Entity and then not U.Interface then\n+            --  Check for Elab_Entity to be set for this unit\n+\n+            if U.Set_Elab_Entity\n+\n+            --  Don't generate reference for stand alone library\n+\n+              and then not U.Interface\n+\n+            --  Don't generate reference for predefined file in No_Run_Time\n+            --  mode, since we don't include the object files in this case\n+\n+              and then not\n+                (No_Run_Time_Mode\n+                   and then Is_Predefined_File_Name (U.Sfile))\n+            then\n                Set_String (\"      \");\n                Set_String (\"E\");\n                Set_Unit_Number (Unum);\n@@ -667,8 +681,23 @@ package body Bindgen is\n          declare\n             Unum : constant Unit_Id := Elab_Order.Table (E);\n             U    : Unit_Record renames Units.Table (Unum);\n+\n          begin\n-            if U.Set_Elab_Entity and then not U.Interface then\n+            --  Check for Elab entity to be set for this unit\n+\n+            if U.Set_Elab_Entity\n+\n+            --  Don't generate reference for stand alone library\n+\n+              and then not U.Interface\n+\n+            --  Don't generate reference for predefined file in No_Run_Time\n+            --  mode, since we don't include the object files in this case\n+\n+              and then not\n+                (No_Run_Time_Mode\n+                   and then Is_Predefined_File_Name (U.Sfile))\n+            then\n                Set_String (\"   extern char \");\n                Get_Name_String (U.Uname);\n                Set_Unit_Name;\n@@ -894,9 +923,14 @@ package body Bindgen is\n                Unum_Spec := Unum;\n             end if;\n \n+            --  Nothing to do if predefined unit in no run time mode\n+\n+            if No_Run_Time_Mode and then Is_Predefined_File_Name (U.Sfile) then\n+               null;\n+\n             --  Case of no elaboration code\n \n-            if U.No_Elab then\n+            elsif U.No_Elab then\n \n                --  The only case in which we have to do something is if\n                --  this is a body, with a separate spec, where the separate\n@@ -989,7 +1023,6 @@ package body Bindgen is\n \n    procedure Gen_Elab_Calls_C is\n    begin\n-\n       for E in Elab_Order.First .. Elab_Order.Last loop\n          declare\n             Unum : constant Unit_Id := Elab_Order.Table (E);\n@@ -1008,9 +1041,14 @@ package body Bindgen is\n                Unum_Spec := Unum;\n             end if;\n \n+            --  Nothing to do if predefined unit in no run time mode\n+\n+            if No_Run_Time_Mode and then Is_Predefined_File_Name (U.Sfile) then\n+               null;\n+\n             --  Case of no elaboration code\n \n-            if U.No_Elab then\n+            elsif U.No_Elab then\n \n                --  The only case in which we have to do something is if\n                --  this is a body, with a separate spec, where the separate\n@@ -1867,6 +1905,7 @@ package body Bindgen is\n               or else GNAT.OS_Lib.Is_Regular_File (Name_Buffer (1 .. Name_Len))\n             then\n                Write_Info_Ada_C (\"   --   \", \"\", Name_Buffer (1 .. Name_Len));\n+\n                if Output_Object_List then\n                   Write_Str (Name_Buffer (1 .. Name_Len));\n                   Write_Eol;"}, {"sha": "951d272f54ac6d3c1e026bee5cb1dac429d9c9eb", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -529,12 +529,13 @@ package body Exp_Ch6 is\n       ---------------------------\n \n       procedure Add_Call_By_Copy_Code is\n-         Expr    : Node_Id;\n-         Init    : Node_Id;\n-         Temp    : Entity_Id;\n-         Var     : Entity_Id;\n-         V_Typ   : Entity_Id;\n-         Crep    : Boolean;\n+         Expr  : Node_Id;\n+         Init  : Node_Id;\n+         Temp  : Entity_Id;\n+         Indic : Node_Id := New_Occurrence_Of (Etype (Formal), Loc);\n+         Var   : Entity_Id;\n+         V_Typ : Entity_Id;\n+         Crep  : Boolean;\n \n       begin\n          Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n@@ -560,10 +561,14 @@ package body Exp_Ch6 is\n          --  parameter where the formal is an unconstrained array (in the\n          --  latter case, we have to pass in an object with bounds).\n \n+         --  If this is an out parameter, the initial copy is wasteful, so as\n+         --  an optimization for the one-dimensional case we extract the\n+         --  bounds of the actual and build an uninitialized temporary of the\n+         --  right size.\n+\n          if Ekind (Formal) = E_In_Out_Parameter\n            or else (Is_Array_Type (Etype (Formal))\n-                     and then\n-                    not Is_Constrained (Etype (Formal)))\n+                     and then not Is_Constrained (Etype (Formal)))\n          then\n             if Nkind (Actual) = N_Type_Conversion then\n                if Conversion_OK (Actual) then\n@@ -573,6 +578,33 @@ package body Exp_Ch6 is\n                   Init := Convert_To\n                             (Etype (Formal), New_Occurrence_Of (Var, Loc));\n                end if;\n+\n+            elsif Ekind (Formal) = E_Out_Parameter\n+              and then Number_Dimensions (Etype (Formal)) = 1\n+              and then not Has_Non_Null_Base_Init_Proc (Etype (Formal))\n+            then\n+               --  Actual is a one-dimensional array or slice, and the type\n+               --  requires no initialization. Create a temporary of the\n+               --  right size, but do copy actual into it (optimization).\n+\n+               Init := Empty;\n+               Indic :=\n+                 Make_Subtype_Indication (Loc,\n+                   Subtype_Mark =>\n+                     New_Occurrence_Of (Etype (Formal), Loc),\n+                   Constraint   =>\n+                     Make_Index_Or_Discriminant_Constraint (Loc,\n+                       Constraints => New_List (\n+                         Make_Range (Loc,\n+                           Low_Bound  =>\n+                             Make_Attribute_Reference (Loc,\n+                               Prefix => New_Occurrence_Of (Var, Loc),\n+                               Attribute_name => Name_First),\n+                           High_Bound =>\n+                             Make_Attribute_Reference (Loc,\n+                               Prefix => New_Occurrence_Of (Var, Loc),\n+                               Attribute_Name => Name_Last)))));\n+\n             else\n                Init := New_Occurrence_Of (Var, Loc);\n             end if;\n@@ -607,8 +639,7 @@ package body Exp_Ch6 is\n          N_Node :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp,\n-             Object_Definition   =>\n-               New_Occurrence_Of (Etype (Formal), Loc),\n+             Object_Definition   => Indic,\n              Expression => Init);\n          Set_Assignment_OK (N_Node);\n          Insert_Action (N, N_Node);\n@@ -2527,9 +2558,12 @@ package body Exp_Ch6 is\n          --  In this case, for optimization purposes, we do not need to\n          --  continue the traversal once more than one use is encountered.\n \n+         ----------------\n+         -- Count_Uses --\n+         ----------------\n+\n          function Count_Uses (N : Node_Id) return Traverse_Result is\n          begin\n-\n             --  The original node is an identifier\n \n             if Nkind (N) = N_Identifier\n@@ -2565,10 +2599,8 @@ package body Exp_Ch6 is\n       --  Start of processing for Formal_Is_Used_Once\n \n       begin\n-\n          Count_Formal_Uses (Orig_Bod);\n          return Use_Counter = 1;\n-\n       end Formal_Is_Used_Once;\n \n    --  Start of processing for Expand_Inlined_Call"}, {"sha": "51846185b3621c29b58bf5b683493f03c18b3643", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -146,15 +146,18 @@ package body GNAT.Debug_Pools is\n    --  Traceback_Htable_Elem_Ptr.\n \n    type Allocation_Header is record\n-      Block_Size : Storage_Offset;\n+      Allocation_Address : System.Address;\n+      --  Address of the block returned by malloc, possibly unaligned.\n+\n+      Block_Size    : Storage_Offset;\n       --  Needed only for advanced freeing algorithms (traverse all allocated\n       --  blocks for potential references). This value is negated when the\n       --  chunk of memory has been logically freed by the application. This\n       --  chunk has not been physically released yet.\n \n       Alloc_Traceback   : Traceback_Htable_Elem_Ptr;\n       Dealloc_Traceback : Traceback_Ptr_Or_Address;\n-      --  Pointer to the traceback for the allocation (if the memory chunck is\n+      --  Pointer to the traceback for the allocation (if the memory chunk is\n       --  still valid), or to the first deallocation otherwise. Make sure this\n       --  is a thin pointer to save space.\n       --\n@@ -183,21 +186,23 @@ package body GNAT.Debug_Pools is\n    function To_Traceback is new Ada.Unchecked_Conversion\n      (Traceback_Htable_Elem_Ptr, Traceback_Ptr_Or_Address);\n \n+   Header_Offset : constant Storage_Count\n+     := Default_Alignment *\n+     ((Allocation_Header'Size / System.Storage_Unit + Default_Alignment - 1)\n+      / Default_Alignment);\n+   --  Offset of user data after allocation header.\n+\n    Minimum_Allocation : constant Storage_Count :=\n-                          Default_Alignment *\n-                            (Allocation_Header'Size /\n-                               System.Storage_Unit /\n-                                 Default_Alignment) +\n-                                   Default_Alignment;\n-   --  Extra bytes to allocate to store the header. The header needs to be\n-   --  correctly aligned as well, so we have to allocate multiples of the\n-   --  alignment.\n+     Default_Alignment - 1\n+     + Header_Offset;\n+   --  Minimal allocation: size of allocation_header rounded up to next\n+   --  multiple of default alignment + worst-case padding.\n \n    -----------------------\n    -- Allocations table --\n    -----------------------\n \n-   --  This table is indexed on addresses modulo Minimum_Allocation, and\n+   --  This table is indexed on addresses modulo Default_Alignment, and\n    --  for each index it indicates whether that memory block is valid.\n    --  Its behavior is similar to GNAT.Table, except that we need to pack\n    --  the table to save space, so we cannot reuse GNAT.Table as is.\n@@ -249,7 +254,7 @@ package body GNAT.Debug_Pools is\n    Edata  : System.Address := System.Null_Address;\n    --  Address in memory that matches the index 0 in Valid_Blocks. It is named\n    --  after the symbol _edata, which, on most systems, indicate the lowest\n-   --  possible address returned by malloc (). Unfortunately, this symbol\n+   --  possible address returned by malloc. Unfortunately, this symbol\n    --  doesn't exist on windows, so we cannot use it instead of this variable.\n \n    -----------------------\n@@ -341,7 +346,7 @@ package body GNAT.Debug_Pools is\n       function Convert is new Ada.Unchecked_Conversion\n         (System.Address, Allocation_Header_Access);\n    begin\n-      return Convert (Address - Minimum_Allocation);\n+      return Convert (Address - Header_Offset);\n    end Header_Of;\n \n    --------------\n@@ -670,8 +675,6 @@ package body GNAT.Debug_Pools is\n \n       type Local_Storage_Array is new Storage_Array\n         (1 .. Size_In_Storage_Elements + Minimum_Allocation);\n-      for Local_Storage_Array'Alignment use Standard'Maximum_Alignment;\n-      --  For performance reasons, make sure the alignment is maximized.\n \n       type Ptr is access Local_Storage_Array;\n       --  On some systems, we might want to physically protect pages\n@@ -716,7 +719,14 @@ package body GNAT.Debug_Pools is\n             P := new Local_Storage_Array;\n       end;\n \n-      Storage_Address := P.all'Address + Minimum_Allocation;\n+      Storage_Address := System.Null_Address + Default_Alignment\n+        * (((P.all'Address + Default_Alignment - 1) - System.Null_Address)\n+           / Default_Alignment)\n+        + Header_Offset;\n+      pragma Assert ((Storage_Address - System.Null_Address)\n+                     mod Default_Alignment = 0);\n+      pragma Assert (Storage_Address + Size_In_Storage_Elements\n+                     <= P.all'Address + P'Length);\n \n       Trace := Find_Or_Create_Traceback\n         (Pool, Alloc, Size_In_Storage_Elements,\n@@ -728,10 +738,11 @@ package body GNAT.Debug_Pools is\n       --  Default_Alignment.\n \n       Header_Of (Storage_Address).all :=\n-        (Alloc_Traceback   => Trace,\n-         Dealloc_Traceback => To_Traceback (null),\n-         Next              => Pool.First_Used_Block,\n-         Block_Size        => Size_In_Storage_Elements);\n+        (Allocation_Address => P.all'Address,\n+         Alloc_Traceback    => Trace,\n+         Dealloc_Traceback  => To_Traceback (null),\n+         Next               => Pool.First_Used_Block,\n+         Block_Size         => Size_In_Storage_Elements);\n \n       pragma Warnings (On);\n \n@@ -928,7 +939,7 @@ package body GNAT.Debug_Pools is\n                end;\n \n                Next := Header.Next;\n-               System.Memory.Free (Header.all'Address);\n+               System.Memory.Free (Header.Allocation_Address);\n                Set_Valid (Tmp, False);\n \n                --  Remove this block from the list.\n@@ -1141,15 +1152,16 @@ package body GNAT.Debug_Pools is\n          --  Update the header\n \n          Header.all :=\n-           (Alloc_Traceback   => Header.Alloc_Traceback,\n-            Dealloc_Traceback => To_Traceback\n-                                   (Find_Or_Create_Traceback\n-                                      (Pool, Dealloc,\n-                                       Size_In_Storage_Elements,\n-                                       Deallocate_Label'Address,\n-                                       Code_Address_For_Deallocate_End)),\n-            Next              => System.Null_Address,\n-            Block_Size        => -Size_In_Storage_Elements);\n+           (Allocation_Address => Header.Allocation_Address,\n+            Alloc_Traceback    => Header.Alloc_Traceback,\n+            Dealloc_Traceback  => To_Traceback\n+                                    (Find_Or_Create_Traceback\n+                                       (Pool, Dealloc,\n+                                        Size_In_Storage_Elements,\n+                                        Deallocate_Label'Address,\n+                                        Code_Address_For_Deallocate_End)),\n+            Next               => System.Null_Address,\n+            Block_Size         => -Size_In_Storage_Elements);\n \n          if Pool.Reset_Content_On_Free then\n             Set_Dead_Beef (Storage_Address, Size_In_Storage_Elements);"}, {"sha": "0d458f49b0dbe6b97e570c3f789626d810d36238", "filename": "gcc/ada/g-debpoo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fg-debpoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fg-debpoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.ads?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -260,8 +260,8 @@ private\n       Alignment                : Storage_Count);\n    --  Mark a block of memory as invalid. It might not be physically removed\n    --  immediately, depending on the setup of the debug pool, so that checks\n-   --  are still possible.\n-   --  The parameters have the same semantics as defined in the ARM95.\n+   --  are still possible. The parameters have the same semantics as defined\n+   --  in the RM.\n \n    function Storage_Size (Pool : Debug_Pool) return SSC;\n    --  Return the maximal size of data that can be allocated through Pool."}, {"sha": "2b5ff0801f3438347a38a7b8ade5c72febce388c", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -9996,10 +9996,13 @@ recognized by @code{GNAT}:\n    Normalize_Scalars\n    Polling\n    Profile\n+   Profile_Warnings\n    Propagate_Exceptions\n    Queuing_Policy\n+   Ravenscar\n    Restricted_Run_Time\n    Restrictions\n+   Restrictions_Warnings\n    Reviewable\n    Source_File_Name\n    Style_Checks\n@@ -12452,6 +12455,12 @@ Depending on the operating system, there may or may not be a distinction\n between dynamic and relocatable libraries. For Unix and VMS Unix there is no\n such distinction.\n \n+@ifset unw\n+On Windows @code{\"relocatable\"} will build a relocatable @code{DLL}\n+and @code{\"dynamic\"} will build a non-relocatable @code{DLL}.\n+@pxref{Introduction to Dynamic Link Libraries (DLLs)}.\n+@end ifset\n+\n If you need to build both a static and a dynamic library, you should use two\n different object directories, since in some cases some extra code needs to\n be generated for the latter. For such cases, it is recommended to either use\n@@ -13155,7 +13164,7 @@ When a library project file is specified, switches ^-b^/ACTION=BIND^ and\n ^-l^/ACTION=LINK^ have special meanings.\n \n @itemize @bullet\n-@item ^-b^/ACTION=BIND^ is only allwed for stand-alone libraries. It indicates\n+@item ^-b^/ACTION=BIND^ is only allowed for stand-alone libraries. It indicates\n to @command{gnatmake} that @command{gnatbind} should be invoked for the\n library.\n "}, {"sha": "f34dd8a297cba311edc8c92709695d6bc01e5d0d", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -357,7 +357,7 @@ package body Lib.Xref is\n          --  this source unit (occasion for possible warning to be issued)\n \n          if Has_Pragma_Unreferenced (E)\n-           and then In_Same_Extended_Unit (Sloc (E), Sloc (N))\n+           and then In_Same_Extended_Unit (E, N)\n          then\n             --  A reference as a named parameter in a call does not count\n             --  as a violation of pragma Unreferenced for this purpose."}, {"sha": "722f5630c35b91c8703a0c33f20dcd13a8d6c3b4", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -640,7 +640,7 @@ package body Lib is\n \n       else\n          return\n-           In_Same_Extended_Unit (Sloc (N), Sloc (Cunit (Main_Unit)));\n+           In_Same_Extended_Unit (N, Cunit (Main_Unit));\n       end if;\n    end In_Extended_Main_Code_Unit;\n \n@@ -765,6 +765,13 @@ package body Lib is\n    -- In_Same_Extended_Unit --\n    ---------------------------\n \n+   function In_Same_Extended_Unit\n+     (N1, N2 : Node_Or_Entity_Id) return Boolean\n+   is\n+   begin\n+      return Check_Same_Extended_Unit (Sloc (N1), Sloc (N2)) /= No;\n+   end In_Same_Extended_Unit;\n+\n    function In_Same_Extended_Unit (S1, S2 : Source_Ptr) return Boolean is\n    begin\n       return Check_Same_Extended_Unit (S1, S2) /= No;"}, {"sha": "f0f09ef09443d1a5f40649c16916dcc85906b5af", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -454,10 +454,19 @@ package Lib is\n    --  code unit, the criterion being that Get_Code_Unit yields the same\n    --  value for each argument.\n \n+   function In_Same_Extended_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n+   pragma Inline (In_Same_Extended_Unit);\n+   --  Determines if two nodes or entities N1 and N2 are in the same\n+   --  extended unit, where an extended unit is defined as a unit and all\n+   --  its subunits (considered recursively, i.e. subunits of subunits are\n+   --  included). Returns true if S1 and S2 are in the same extended unit\n+   --  and False otherwise.\n+\n    function In_Same_Extended_Unit (S1, S2 : Source_Ptr) return Boolean;\n+   pragma Inline (In_Same_Extended_Unit);\n    --  Determines if the two source locations S1 and S2 are in the same\n    --  extended unit, where an extended unit is defined as a unit and all\n-   --  its subunits (considered recursively, i.e. subunits or subunits are\n+   --  its subunits (considered recursively, i.e. subunits of subunits are\n    --  included). Returns true if S1 and S2 are in the same extended unit\n    --  and False otherwise.\n "}, {"sha": "7035854e0cd8d82b9fb74a288d22b11e761d13cc", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -5587,14 +5587,19 @@ package body Make is\n       if not OpenVMS then\n          declare\n             Command : constant String := Command_Name;\n+\n          begin\n             for Index in reverse Command'Range loop\n                if Command (Index) = Directory_Separator then\n                   declare\n                      Absolute_Dir : constant String :=\n-                       Normalize_Pathname (Command (Command'First .. Index));\n+                                      Normalize_Pathname\n+                                        (Command (Command'First .. Index));\n+\n                      PATH : constant String :=\n-                       Absolute_Dir & Path_Separator & Getenv (\"PATH\").all;\n+                                      Absolute_Dir &\n+                                      Path_Separator &\n+                                      Getenv (\"PATH\").all;\n \n                   begin\n                      Setenv (\"PATH\", PATH);"}, {"sha": "5947f19825dc608bfd0f895c842bc29e718514ed", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -2139,7 +2139,9 @@ package body Makegpr is\n          Local_Errors := False;\n          Data := Projects.Table (Project);\n \n-         if not Data.Virtual then\n+         --  Nothing to do when no sources of language other than Ada\n+\n+         if (not Data.Virtual) and then Data.Sources_Present then\n \n             --  If the imported directory switches are unknown, compute them\n \n@@ -2149,51 +2151,47 @@ package body Makegpr is\n                Projects.Table (Project) := Data;\n             end if;\n \n-            --  Nothing to do when no sources of language other than Ada\n+            Need_To_Rebuild_Archive := Force_Compilations;\n \n-            if Data.Sources_Present then\n-               Need_To_Rebuild_Archive := Force_Compilations;\n+            --  Compilation will occur in the object directory\n \n-               --  Compilation will occur in the object directory\n+            Change_Dir (Get_Name_String (Data.Object_Directory));\n \n-               Change_Dir (Get_Name_String (Data.Object_Directory));\n+            Source_Id := Data.First_Other_Source;\n \n-               Source_Id := Data.First_Other_Source;\n+            --  Process each source one by one\n \n-               --  Process each source one by one\n+            while Source_Id /= No_Other_Source loop\n+               Source := Other_Sources.Table (Source_Id);\n+               Need_To_Compile := Force_Compilations;\n \n-               while Source_Id /= No_Other_Source loop\n-                  Source := Other_Sources.Table (Source_Id);\n-                  Need_To_Compile := Force_Compilations;\n+               --  Check if compilation is needed\n \n-                  --  Check if compilation is needed\n-\n-                  if not Need_To_Compile then\n-                     Check_Compilation_Needed (Source, Need_To_Compile);\n-                  end if;\n+               if not Need_To_Compile then\n+                  Check_Compilation_Needed (Source, Need_To_Compile);\n+               end if;\n \n-                  --  Proceed, if compilation is needed\n+               --  Proceed, if compilation is needed\n \n-                  if Need_To_Compile then\n+               if Need_To_Compile then\n \n-                     --  If a source is compiled/recompiled, of course the\n-                     --  archive will need to be built/rebuilt.\n+                  --  If a source is compiled/recompiled, of course the\n+                  --  archive will need to be built/rebuilt.\n \n-                     Need_To_Rebuild_Archive := True;\n-                     Compile (Source_Id, Data, Local_Errors);\n-                  end if;\n+                  Need_To_Rebuild_Archive := True;\n+                  Compile (Source_Id, Data, Local_Errors);\n+               end if;\n \n-                  --  Next source, if any\n+               --  Next source, if any\n \n-                  Source_Id := Source.Next;\n-               end loop;\n+               Source_Id := Source.Next;\n+            end loop;\n \n-               --  If there was no compilation error, build/rebuild the archive\n-               --  if necessary.\n+            --  If there was no compilation error, build/rebuild the archive\n+            --  if necessary.\n \n-               if not Local_Errors then\n-                  Build_Archive (Project, Need_To_Rebuild_Archive);\n-               end if;\n+            if not Local_Errors then\n+               Build_Archive (Project, Need_To_Rebuild_Archive);\n             end if;\n          end if;\n       end loop;"}, {"sha": "a47ff42c136c12b5181d3f9056705ac0d45fd919", "filename": "gcc/ada/mlib-tgt-mingw.adb", "status": "modified", "additions": 110, "deletions": 69, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmlib-tgt-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmlib-tgt-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-mingw.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2002-2004, Ada Core Technologies, Inc.           --\n+--          Copyright (C) 2002-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,7 +28,8 @@\n --  This package provides a set of target dependent routines to build\n --  static, dynamic and shared libraries.\n \n---  This is the Windows version of the body.\n+--  This is the Windows version of the body. Works only with GCC versions\n+--  supporting the \"-shared\" option.\n \n with Namet;  use Namet;\n with Opt;\n@@ -37,12 +38,14 @@ with Prj.Com;\n \n with GNAT.OS_Lib; use GNAT.OS_Lib;\n \n-with MDLL;\n-with MDLL.Utl;\n with MLib.Fil;\n+with MLib.Utl;\n \n package body MLib.Tgt is\n \n+   package Files renames MLib.Fil;\n+   package Tools renames MLib.Utl;\n+\n    ---------------------\n    -- Archive_Builder --\n    ---------------------\n@@ -98,73 +101,121 @@ package body MLib.Tgt is\n       Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n-      pragma Unreferenced (Ofiles);\n-      pragma Unreferenced (Interfaces);\n+      pragma Unreferenced (Foreign);\n+      pragma Unreferenced (Afiles);\n+      pragma Unreferenced (Auto_Init);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Driver_Name);\n+      pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Auto_Init);\n \n-      Imp_File : constant String :=\n-                   \"lib\" & MLib.Fil.Ext_To (Lib_Filename, Archive_Ext);\n-      --  Name of the import library\n+      Strip_Name  : constant String := \"strip\";\n+      Strip_Exec  : String_Access;\n \n-      DLL_File : constant String := MLib.Fil.Ext_To (Lib_Filename, DLL_Ext);\n-      --  Name of the DLL file\n+      procedure Strip_Reloc (Lib_File : String);\n+      --  Strip .reloc section to build a non relocatable DLL\n \n-      Lib_File : constant String := Lib_Dir & Directory_Separator & DLL_File;\n-      --  Full path of the DLL file\n+      -----------------\n+      -- Strip_Reloc --\n+      -----------------\n \n-      Success : Boolean;\n+      procedure Strip_Reloc (Lib_File : String) is\n+         Arguments   : Argument_List (1 .. 3);\n+         Success     : Boolean;\n+         Line_Length : Natural;\n \n-   begin\n-      if Opt.Verbose_Mode then\n-         if Relocatable then\n-            Write_Str (\"building relocatable shared library \");\n-         else\n-            Write_Str (\"building non-relocatable shared library \");\n+      begin\n+         --  Look for strip executable\n+\n+         Strip_Exec := Locate_Exec_On_Path (Strip_Name);\n+\n+         if Strip_Exec = null then\n+            Fail (Strip_Name, \" not found in path\");\n+\n+         elsif Opt.Verbose_Mode then\n+            Write_Str  (\"found \");\n+            Write_Line (Strip_Exec.all);\n          end if;\n \n-         Write_Line (Lib_File);\n-      end if;\n+         --  Call it: strip -R .reloc <dll>\n \n-      MDLL.Verbose := Opt.Verbose_Mode;\n-      MDLL.Quiet   := not MDLL.Verbose;\n+         Arguments (1) := new String'(\"-R\");\n+         Arguments (2) := new String'(\".reloc\");\n+         Arguments (3) := new String'(Lib_File);\n \n-      MDLL.Utl.Locate;\n+         if not Opt.Quiet_Output then\n+            Write_Str (Strip_Exec.all);\n+            Line_Length := Strip_Exec'Length;\n \n-      MDLL.Build_Dynamic_Library\n-        (Foreign, Afiles,\n-         MDLL.Null_Argument_List, MDLL.Null_Argument_List, Options,\n-         Lib_Filename, Lib_Filename & \".def\",\n-         Lib_Address, True, Relocatable);\n+            for K in Arguments'Range loop\n \n-      --  Move the DLL and import library in the lib directory\n+               --  Make sure the Output buffer does not overflow\n \n-      Copy_File (DLL_File, Lib_Dir, Success, Mode => Overwrite);\n+               if Line_Length + 1 + Arguments (K)'Length >\n+                 Integer (Opt.Max_Line_Length)\n+               then\n+                  Write_Eol;\n+                  Line_Length := 0;\n+               end if;\n \n-      if not Success then\n-         Fail (\"could not copy DLL to library dir\");\n-      end if;\n+               Write_Char (' ');\n+               Write_Str  (Arguments (K).all);\n+               Line_Length := Line_Length + 1 + Arguments (K)'Length;\n+            end loop;\n \n-      Copy_File (Imp_File, Lib_Dir, Success, Mode => Overwrite);\n+            Write_Eol;\n+         end if;\n \n-      if not Success then\n-         Fail (\"could not copy import library to library dir\");\n-      end if;\n+         Spawn (Strip_Exec.all, Arguments, Success);\n+\n+         if not Success then\n+            Fail (Strip_Name, \" execution error.\");\n+         end if;\n+\n+         for K in Arguments'Range loop\n+            Free (Arguments (K));\n+         end loop;\n+      end Strip_Reloc;\n+\n+      Lib_File : constant String :=\n+        Lib_Dir & Directory_Separator & \"lib\" &\n+        Files.Ext_To (Lib_Filename, DLL_Ext);\n+\n+      I_Base    : aliased String := \"-Wl,--image-base,\" & Lib_Address;\n+\n+      Options_2 : Argument_List (1 .. 1);\n+      O_Index   : Natural := 0;\n+\n+   --  Start of processing for Build_Dynamic_Library\n+\n+   begin\n+      if Opt.Verbose_Mode then\n+         Write_Str (\"building \");\n \n-      --  Delete files\n+         if not Relocatable then\n+            Write_Str (\"non-\");\n+         end if;\n \n-      Delete_File (DLL_File, Success);\n+         Write_Str (\"relocatable shared library \");\n+         Write_Line (Lib_File);\n+      end if;\n \n-      if not Success then\n-         Fail (\"could not delete DLL from build dir\");\n+      if not Relocatable then\n+         O_Index := O_Index + 1;\n+         Options_2 (O_Index) := I_Base'Unchecked_Access;\n       end if;\n \n-      Delete_File (Imp_File, Success);\n+      Tools.Gcc\n+        (Output_File => Lib_File,\n+         Objects     => Ofiles,\n+         Options     => Options,\n+         Driver_Name => Driver_Name,\n+         Options_2   => Options_2 (1 .. O_Index));\n+\n+      if not Relocatable then\n \n-      if not Success then\n-         Fail (\"could not delete import library from build dir\");\n+         --  Strip reloc symbols from the DLL\n+\n+         Strip_Reloc (Lib_File);\n       end if;\n    end Build_Dynamic_Library;\n \n@@ -192,7 +243,7 @@ package body MLib.Tgt is\n \n    function Dynamic_Option return String is\n    begin\n-      return \"\";\n+      return \"-shared\";\n    end Dynamic_Option;\n \n    -------------------\n@@ -219,7 +270,7 @@ package body MLib.Tgt is\n \n    function Is_Archive_Ext (Ext : String) return Boolean is\n    begin\n-      return Ext = \".a\";\n+      return Ext = \".a\" or else Ext = \".dll\";\n    end Is_Archive_Ext;\n \n    -------------\n@@ -245,24 +296,21 @@ package body MLib.Tgt is\n       else\n          declare\n             Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+                        Get_Name_String\n+                          (Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+                         Get_Name_String\n+                           (Projects.Table (Project).Library_Name);\n \n          begin\n             if Projects.Table (Project).Library_Kind = Static then\n-\n-               --  Static libraries are named : lib<name>.a\n-\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   MLib.Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else\n-               --  Shared libraries are named : <name>.dll\n-\n                return Is_Regular_File\n-                 (Lib_Dir & Directory_Separator &\n+                 (Lib_Dir & Directory_Separator & \"lib\" &\n                   MLib.Fil.Ext_To (Lib_Name, DLL_Ext));\n             end if;\n          end;\n@@ -283,23 +331,16 @@ package body MLib.Tgt is\n       else\n          declare\n             Lib_Name : constant String :=\n-                         Get_Name_String\n-                           (Projects.Table (Project).Library_Name);\n+              Get_Name_String (Projects.Table (Project).Library_Name);\n \n          begin\n-            if Projects.Table (Project).Library_Kind = Static then\n-\n-               --  Static libraries are named : lib<name>.a\n-\n-               Name_Len := 3;\n-               Name_Buffer (1 .. Name_Len) := \"lib\";\n+            Name_Len := 3;\n+            Name_Buffer (1 .. Name_Len) := \"lib\";\n \n+            if Projects.Table (Project).Library_Kind = Static then\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, Archive_Ext));\n \n             else\n-               --  Shared libraries are named : <name>.dll\n-\n-               Name_Len := 0;\n                Add_Str_To_Name_Buffer (Fil.Ext_To (Lib_Name, DLL_Ext));\n             end if;\n "}, {"sha": "9fa24c5646daa3c7d6b3cafe218c1662d9db670b", "filename": "gcc/ada/mlib-tgt-vxworks.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmlib-tgt-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fmlib-tgt-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vxworks.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -222,7 +222,7 @@ package body MLib.Tgt is\n       if not Projects.Table (Project).Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n-         return False; --  To avoid warning;\n+         return False;\n \n       else\n          declare"}, {"sha": "e9fe553713636fca1d69b91fecd38260d2606125", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -203,8 +203,8 @@ package body Ch12 is\n \n          Set_Specification (Gen_Decl, P_Subprogram_Specification);\n \n-         if Nkind (Defining_Unit_Name (Specification (Gen_Decl)))\n-           = N_Defining_Program_Unit_Name\n+         if Nkind (Defining_Unit_Name (Specification (Gen_Decl))) =\n+                                             N_Defining_Program_Unit_Name\n            and then Scope.Last > 0\n          then\n             Error_Msg_SP (\"child unit allowed only at library level\");"}, {"sha": "112170b200ccc86aefe4464e9f42e652b384e348", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -994,6 +994,7 @@ begin\n            Pragma_Preelaborate                 |\n            Pragma_Priority                     |\n            Pragma_Profile                      |\n+           Pragma_Profile_Warnings             |\n            Pragma_Propagate_Exceptions         |\n            Pragma_Psect_Object                 |\n            Pragma_Pure                         |"}, {"sha": "8c89aae9af57d87880a5c24e63faeab08f9718ba", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -1164,22 +1164,27 @@ package body Prj.Part is\n          end;\n \n          declare\n-            Project_Name : Name_Id :=\n-                             Tree_Private_Part.Projects_Htable.Get_First.Name;\n+            Name_And_Node : Tree_Private_Part.Project_Name_And_Node :=\n+                              Tree_Private_Part.Projects_Htable.Get_First;\n+            Project_Name : Name_Id := Name_And_Node.Name;\n \n          begin\n             --  Check if we already have a project with this name\n \n             while Project_Name /= No_Name\n               and then Project_Name /= Name_Of_Project\n             loop\n-               Project_Name := Tree_Private_Part.Projects_Htable.Get_Next.Name;\n+               Name_And_Node := Tree_Private_Part.Projects_Htable.Get_Next;\n+               Project_Name := Name_And_Node.Name;\n             end loop;\n \n             --  Report an error if we already have a project with this name\n \n             if Project_Name /= No_Name then\n-               Error_Msg (\"duplicate project name\", Token_Ptr);\n+               Error_Msg_Name_1 := Project_Name;\n+               Error_Msg (\"duplicate project name {\", Location_Of (Project));\n+               Error_Msg_Name_1 := Path_Name_Of (Name_And_Node.Node);\n+               Error_Msg (\"\\already in {\", Location_Of (Project));\n \n             else\n                --  Otherwise, add the name of the project to the hash table, so"}, {"sha": "d6a2efa30824f9d8c99d64618185a466e2965fc3", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -282,6 +282,7 @@ package body Prj.Strt is\n          end loop;\n \n          --  If only one is not used, report a single warning for this value\n+\n          if Non_Used = 1 then\n             Error_Msg_Name_1 := Choices.Table (First_Non_Used).The_String;\n             Error_Msg (\"?value { is not used as label\", Case_Location);"}, {"sha": "d35a9ecd8cb94238edab0a9593b130538d5a3762", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 95, "deletions": 74, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -31,12 +31,24 @@ with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Lib;      use Lib;\n with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Uname;    use Uname;\n \n package body Restrict is\n \n+   Restricted_Profile_Result : Boolean := False;\n+   --  This switch memoizes the result of Restricted_Profile function\n+   --  calls for improved efficiency. Its setting is valid only if\n+   --  Restricted_Profile_Cached is True. Note that if this switch\n+   --  is ever set True, it need never be turned off again.\n+\n+   Restricted_Profile_Cached : Boolean := False;\n+   --  This flag is set to True if the Restricted_Profile_Result\n+   --  contains the correct cached result of Restricted_Profile calls.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -361,57 +373,75 @@ package body Restrict is\n    --  Note: body of this function must be coordinated with list of\n    --  renaming declarations in System.Rident.\n \n-   function Process_Restriction_Synonyms (Id : Name_Id) return Name_Id is\n+   function Process_Restriction_Synonyms (N : Node_Id) return Name_Id\n+   is\n+      Old_Name : constant Name_Id := Chars (N);\n+      New_Name : Name_Id;\n+\n    begin\n-      case Id is\n+      case Old_Name is\n          when Name_Boolean_Entry_Barriers =>\n-            return Name_Simple_Barriers;\n+            New_Name := Name_Simple_Barriers;\n \n          when Name_Max_Entry_Queue_Depth =>\n-            return Name_Max_Entry_Queue_Length;\n+            New_Name := Name_Max_Entry_Queue_Length;\n \n          when Name_No_Dynamic_Interrupts =>\n-            return Name_No_Dynamic_Attachment;\n+            New_Name := Name_No_Dynamic_Attachment;\n \n          when Name_No_Requeue =>\n-            return Name_No_Requeue_Statements;\n+            New_Name := Name_No_Requeue_Statements;\n \n          when Name_No_Task_Attributes =>\n-            return Name_No_Task_Attributes_Package;\n+            New_Name := Name_No_Task_Attributes_Package;\n \n          when others =>\n-            return Id;\n+            return Old_Name;\n       end case;\n+\n+      if Warn_On_Obsolescent_Feature then\n+         Error_Msg_Name_1 := Old_Name;\n+         Error_Msg_N (\"restriction identifier % is obsolescent?\", N);\n+         Error_Msg_Name_1 := New_Name;\n+         Error_Msg_N (\"|use restriction identifier % instead\", N);\n+      end if;\n+\n+      return New_Name;\n    end Process_Restriction_Synonyms;\n \n    ------------------------\n    -- Restricted_Profile --\n    ------------------------\n \n-   --  This implementation must be coordinated with Set_Restricted_Profile\n-\n    function Restricted_Profile return Boolean is\n    begin\n-      return     Restrictions.Set (No_Abort_Statements)\n-        and then Restrictions.Set (No_Asynchronous_Control)\n-        and then Restrictions.Set (No_Entry_Queue)\n-        and then Restrictions.Set (No_Task_Hierarchy)\n-        and then Restrictions.Set (No_Task_Allocators)\n-        and then Restrictions.Set (No_Dynamic_Priorities)\n-        and then Restrictions.Set (No_Terminate_Alternatives)\n-        and then Restrictions.Set (No_Dynamic_Attachment)\n-        and then Restrictions.Set (No_Protected_Type_Allocators)\n-        and then Restrictions.Set (No_Local_Protected_Objects)\n-        and then Restrictions.Set (No_Requeue_Statements)\n-        and then Restrictions.Set (No_Task_Attributes_Package)\n-        and then Restrictions.Set (Max_Asynchronous_Select_Nesting)\n-        and then Restrictions.Set (Max_Task_Entries)\n-        and then Restrictions.Set (Max_Protected_Entries)\n-        and then Restrictions.Set (Max_Select_Alternatives)\n-        and then Restrictions.Value (Max_Asynchronous_Select_Nesting) =  0\n-        and then Restrictions.Value (Max_Task_Entries)                =  0\n-        and then Restrictions.Value (Max_Protected_Entries)           <= 1\n-        and then Restrictions.Value (Max_Select_Alternatives)         =  0;\n+      if Restricted_Profile_Cached then\n+         return Restricted_Profile_Result;\n+\n+      else\n+         Restricted_Profile_Result := True;\n+         Restricted_Profile_Cached := True;\n+\n+         declare\n+            R : Restriction_Flags  renames Profile_Info (Restricted).Set;\n+            V : Restriction_Values renames Profile_Info (Restricted).Value;\n+         begin\n+            for J in R'Range loop\n+               if R (J)\n+                 and then (Restrictions.Set (J) = False\n+                             or else Restriction_Warnings (J)\n+                             or else\n+                               (J in All_Parameter_Restrictions\n+                                  and then Restrictions.Value (J) > V (J)))\n+               then\n+                  Restricted_Profile_Result := False;\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            return Restricted_Profile_Result;\n+         end;\n+      end if;\n    end Restricted_Profile;\n \n    ------------------------\n@@ -466,52 +496,31 @@ package body Restrict is\n       Error_Msg_N (B (1 .. P), N);\n    end Restriction_Msg;\n \n-   -------------------\n-   -- Set_Ravenscar --\n-   -------------------\n+   ------------------------------\n+   -- Set_Profile_Restrictions --\n+   ------------------------------\n+\n+   procedure Set_Profile_Restrictions\n+     (P    : Profile_Name;\n+      N    : Node_Id;\n+      Warn : Boolean)\n+   is\n+      R : Restriction_Flags  renames Profile_Info (P).Set;\n+      V : Restriction_Values renames Profile_Info (P).Value;\n \n-   procedure Set_Ravenscar (N : Node_Id) is\n-   begin\n-      Set_Restricted_Profile (N);\n-      Set_Restriction (Simple_Barriers,              N);\n-      Set_Restriction (No_Select_Statements,         N);\n-      Set_Restriction (No_Calendar,                  N);\n-      Set_Restriction (No_Entry_Queue,               N);\n-      Set_Restriction (No_Relative_Delay,            N);\n-      Set_Restriction (No_Task_Termination,          N);\n-      Set_Restriction (No_Implicit_Heap_Allocations, N);\n-   end Set_Ravenscar;\n-\n-   ----------------------------\n-   -- Set_Restricted_Profile --\n-   ----------------------------\n-\n-   --  This must be coordinated with Restricted_Profile\n-\n-   procedure Set_Restricted_Profile (N : Node_Id) is\n    begin\n-      --  Set Boolean restrictions for Restricted Profile\n-\n-      Set_Restriction (No_Abort_Statements,          N);\n-      Set_Restriction (No_Asynchronous_Control,      N);\n-      Set_Restriction (No_Entry_Queue,               N);\n-      Set_Restriction (No_Task_Hierarchy,            N);\n-      Set_Restriction (No_Task_Allocators,           N);\n-      Set_Restriction (No_Dynamic_Priorities,        N);\n-      Set_Restriction (No_Terminate_Alternatives,    N);\n-      Set_Restriction (No_Dynamic_Attachment,        N);\n-      Set_Restriction (No_Protected_Type_Allocators, N);\n-      Set_Restriction (No_Local_Protected_Objects,   N);\n-      Set_Restriction (No_Requeue_Statements,        N);\n-      Set_Restriction (No_Task_Attributes_Package,   N);\n-\n-      --  Set parameter restrictions\n-\n-      Set_Restriction (Max_Asynchronous_Select_Nesting, N, 0);\n-      Set_Restriction (Max_Task_Entries,                N, 0);\n-      Set_Restriction (Max_Select_Alternatives,         N, 0);\n-      Set_Restriction (Max_Protected_Entries,           N, 1);\n-   end Set_Restricted_Profile;\n+      for J in R'Range loop\n+         if R (J) then\n+            if J in All_Boolean_Restrictions then\n+               Set_Restriction (J, N);\n+            else\n+               Set_Restriction (J, N, V (J));\n+            end if;\n+\n+            Restriction_Warnings (J) := Warn;\n+         end if;\n+      end loop;\n+   end Set_Profile_Restrictions;\n \n    ---------------------\n    -- Set_Restriction --\n@@ -526,6 +535,12 @@ package body Restrict is\n    begin\n       Restrictions.Set (R) := True;\n \n+      if Restricted_Profile_Cached and Restricted_Profile_Result then\n+         null;\n+      else\n+         Restricted_Profile_Cached := False;\n+      end if;\n+\n       --  Set location, but preserve location of system\n       --  restriction for nice error msg with run time name\n \n@@ -557,6 +572,12 @@ package body Restrict is\n       V : Integer)\n    is\n    begin\n+      if Restricted_Profile_Cached and Restricted_Profile_Result then\n+         null;\n+      else\n+         Restricted_Profile_Cached := False;\n+      end if;\n+\n       if Restrictions.Set (R) then\n          if V < Restrictions.Value (R) then\n             Restrictions.Value (R) := V;"}, {"sha": "b2658d03331c1f11d967533a9e7f104122912eab", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -200,11 +200,11 @@ package Restrict is\n    --  handlers are present. This function is called by Gigi when it needs to\n    --  expand an AT END clean up identifier with no exception handler.\n \n-   function Process_Restriction_Synonyms (Id : Name_Id) return Name_Id;\n-   --  Id is the name of a restriction. If it is one of synonyms that we\n-   --  allow for historical purposes (for list see System.Rident), then\n-   --  the proper official name is returned. Otherwise the argument is\n-   --  returned unchanged.\n+   function Process_Restriction_Synonyms (N : Node_Id) return Name_Id;\n+   --  Id is a node whose Chars field contains the name of a restriction.\n+   --  If it is one of synonyms that we allow for historical purposes (for\n+   --  list see System.Rident), then the proper official name is returned.\n+   --  Otherwise the Chars field of the argument is returned unchanged.\n \n    function Restriction_Active (R : All_Restrictions) return Boolean;\n    pragma Inline (Restriction_Active);\n@@ -213,13 +213,20 @@ package Restrict is\n    --  active. Always use Check_Restriction to record a violation.\n \n    function Restricted_Profile return Boolean;\n-   --  Tests to see if tasking operations follow the GNAT restricted run time\n-   --  profile.\n-\n-   procedure Set_Ravenscar (N : Node_Id);\n-   --  Enables the set of restrictions for Ravenscar. N is the corresponding\n-   --  pragma node, which is used for error messages on any constructs that\n-   --  violate the profile.\n+   --  Tests if set of restrictions corresponding to Profile (Restricted) is\n+   --  currently in effect (set by pragma Profile, or by an appropriate set\n+   --  of individual Restrictions pragms). Returns True only if all the\n+   --  required restrictions are set.\n+\n+   procedure Set_Profile_Restrictions\n+     (P    : Profile_Name;\n+      N    : Node_Id;\n+      Warn : Boolean);\n+   --  Sets the set of restrictions associated with the given profile\n+   --  name. N is the node of the construct to which error messages\n+   --  are to be attached as required. Warn is set True for the case\n+   --  of Profile_Warnings where the restrictions are set as warnings\n+   --  rather than legality requirements.\n \n    procedure Set_Restriction\n      (R : All_Boolean_Restrictions;\n@@ -235,11 +242,6 @@ package Restrict is\n    --  Similar to the above, except that this is used for the case of a\n    --  parameter restriction, and the corresponding value V is given.\n \n-   procedure Set_Restricted_Profile (N : Node_Id);\n-   --  Enables the set of restrictions for pragma Restricted_Run_Time. N is\n-   --  the corresponding pragma node, which is used for error messages on\n-   --  constructs that violate the profile.\n-\n    function Tasking_Allowed return Boolean;\n    pragma Inline (Tasking_Allowed);\n    --  Tests to see if tasking operations are allowed by the current"}, {"sha": "f0fbc4935726af789b98c9fdc2ae4c1199978706", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -283,4 +283,112 @@ package System.Rident is\n       --  that the actual violation count is at least 3 but might be higher.\n    end record;\n \n+   ----------------------------------\n+   -- Profile Definitions and Data --\n+   ----------------------------------\n+\n+   type Profile_Name is (Ravenscar, Restricted);\n+   --  Names of recognized pfofiles\n+\n+   type Profile_Data is record\n+      Set : Restriction_Flags;\n+      --  Set to True if given restriction must be set for the profile,\n+      --  and False if it need not be set (False does not mean that it\n+      --  must not be set, just that it need not be set). If the flag\n+      --  is True for a parameter restriction, then the Value array\n+      --  gives the maximum value permitted by the profile.\n+\n+      Value : Restriction_Values;\n+      --  An entry in this array is meaningful only if the corresponding\n+      --  flag in Set is True. In that case, the value in this array is\n+      --  the maximum value of the parameter permitted by the profile.\n+   end record;\n+\n+   Profile_Info : array (Profile_Name) of Profile_Data :=\n+\n+                     --  Restricted Profile\n+\n+                    (Restricted =>\n+\n+                        --  Restrictions for Restricted profile\n+\n+                       (Set   =>\n+                          (No_Abort_Statements             => True,\n+                           No_Asynchronous_Control         => True,\n+                           No_Dynamic_Attachment           => True,\n+                           No_Dynamic_Priorities           => True,\n+                           No_Entry_Queue                  => True,\n+                           No_Local_Protected_Objects      => True,\n+                           No_Protected_Type_Allocators    => True,\n+                           No_Requeue_Statements           => True,\n+                           No_Task_Allocators              => True,\n+                           No_Task_Attributes_Package      => True,\n+                           No_Task_Hierarchy               => True,\n+                           No_Terminate_Alternatives       => True,\n+                           Max_Asynchronous_Select_Nesting => True,\n+                           Max_Protected_Entries           => True,\n+                           Max_Select_Alternatives         => True,\n+                           Max_Task_Entries                => True,\n+                           others                          => False),\n+\n+                        --  Value settings for Restricted profile\n+\n+                        Value =>\n+                          (Max_Asynchronous_Select_Nesting => 0,\n+                           Max_Protected_Entries           => 1,\n+                           Max_Select_Alternatives         => 0,\n+                           Max_Task_Entries                => 0,\n+                           others                          => 0)),\n+\n+                     --  Ravenscar Profile\n+\n+                     --  Note: the table entries here only represent the\n+                     --  required restriction profile for Ravenscar. The\n+                     --  full Ravenscar profile also requires:\n+\n+                     --    pragma Dispatching_Policy (FIFO_Within_Priorities);\n+                     --    pragma Locking_Policy (Ceiling_Locking);\n+                     --    pragma Detect_Blocking_Mode ???\n+\n+                     Ravenscar  =>\n+\n+                     --  Restrictions for Ravenscar = Restricted profile ..\n+\n+                       (Set   =>\n+                          (No_Abort_Statements             => True,\n+                           No_Asynchronous_Control         => True,\n+                           No_Dynamic_Attachment           => True,\n+                           No_Dynamic_Priorities           => True,\n+                           No_Entry_Queue                  => True,\n+                           No_Local_Protected_Objects      => True,\n+                           No_Protected_Type_Allocators    => True,\n+                           No_Requeue_Statements           => True,\n+                           No_Task_Allocators              => True,\n+                           No_Task_Attributes_Package      => True,\n+                           No_Task_Hierarchy               => True,\n+                           No_Terminate_Alternatives       => True,\n+                           Max_Asynchronous_Select_Nesting => True,\n+                           Max_Protected_Entries           => True,\n+                           Max_Select_Alternatives         => True,\n+                           Max_Task_Entries                => True,\n+\n+                           --  plus these additional restrictions:\n+\n+                           No_Calendar                     => True,\n+                           No_Implicit_Heap_Allocations    => True,\n+                           No_Relative_Delay               => True,\n+                           No_Select_Statements            => True,\n+                           No_Task_Termination             => True,\n+                           Simple_Barriers                 => True,\n+                           others                          => False),\n+\n+                        --  Value settings for Ravenscar (same as Restricted)\n+\n+                        Value =>\n+                          (Max_Asynchronous_Select_Nesting => 0,\n+                           Max_Protected_Entries           => 1,\n+                           Max_Select_Alternatives         => 0,\n+                           Max_Task_Entries                => 0,\n+                           others                          => 0)));\n+\n end System.Rident;"}, {"sha": "f7aa92ba548c10bc2d0160e628c797471f46aa49", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -862,6 +862,7 @@ package body Sem_Attr is\n          --  Case of an expression\n \n          Resolve (P);\n+\n          if Is_Access_Type (P_Type) then\n \n             --  If there is an implicit dereference, then we must freeze"}, {"sha": "2331802c62c23aefae955227f164142ddff355e5", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -805,8 +805,8 @@ package body Sem_Ch7 is\n \n       procedure Inspect_Deferred_Constant_Completion is\n          Decl   : Node_Id;\n-      begin\n \n+      begin\n          Decl := First (Priv_Decls);\n          while Present (Decl) loop\n \n@@ -828,7 +828,6 @@ package body Sem_Ch7 is\n                Error_Msg_N\n                  (\"constant declaration requires initialization expression\",\n                  Defining_Identifier (Decl));\n-\n             end if;\n \n             Decl := Next (Decl);\n@@ -929,8 +928,7 @@ package body Sem_Ch7 is\n \n          Analyze_Declarations (Priv_Decls);\n \n-         --  Check the private declarations for incomplete deferred\n-         --  constants.\n+         --  Check the private declarations for incomplete deferred constants\n \n          Inspect_Deferred_Constant_Completion;\n "}, {"sha": "4248544666ab79431b465c2e9f9ffc61f6aa13c0", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -359,7 +359,7 @@ package body Sem_Elab is\n             return;\n          end if;\n \n-         --  Nothing to do for imported entities,\n+         --  Nothing to do for imported entities\n \n          if Is_Imported (Ent) then\n             return;\n@@ -426,8 +426,8 @@ package body Sem_Elab is\n \n       --  If the generic entity is within a deeper instance than we are, then\n       --  either the instantiation to which we refer itself caused an ABE, in\n-      --  which case that will be handled separately. Otherwise, we know that\n-      --  the body we need appears as needed at the point of the instantiation.\n+      --  which case that will be handled separately, or else we know that the\n+      --  body we need appears as needed at the point of the instantiation.\n       --  However, this assumption is only valid if we are in static mode.\n \n       if not Dynamic_Elaboration_Checks\n@@ -638,11 +638,13 @@ package body Sem_Elab is\n          --  Find top level scope for called entity (not following renamings\n          --  or derivations). This is where the Elaborate_All will go if it\n          --  is needed. We start with the called entity, except in the case\n-         --  of initialization procedures, where the init proc is in the root\n-         --  package, where we start fromn the entity of the name in the call.\n+         --  of an initialization procedure outside the current package, where\n+         --  the init proc is in the root package, and we start from the entity\n+         --  of the name in the call.\n \n          if Is_Entity_Name (Name (N))\n            and then Is_Init_Proc (Entity (Name (N)))\n+           and then not In_Same_Extended_Unit (N, Entity (Name (N)))\n          then\n             W_Scope := Scope (Entity (Name (N)));\n          else\n@@ -810,7 +812,7 @@ package body Sem_Elab is\n       --  current declarative part\n \n       if not Same_Elaboration_Scope (Current_Scope, Scope (Ent))\n-        or else not In_Same_Extended_Unit (Sloc (N), Sloc (Ent))\n+        or else not In_Same_Extended_Unit (N, Ent)\n       then\n          return;\n       end if;"}, {"sha": "0d8c1e1861e4806459ee0e89b6516f6bbd705a1c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 121, "deletions": 21, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -244,6 +244,12 @@ package body Sem_Prag is\n       --  in which case the check is applied to the expression of the\n       --  association or an expression directly.\n \n+      procedure Check_Arg_Is_External_Name (Arg : Node_Id);\n+      --  Check that an argument has the right form for an EXTERNAL_NAME\n+      --  parameter of an extended import/export pragma. The rule is that\n+      --  the name must be an identifier or string literal (in Ada 83 mode)\n+      --  or a static string expression (in Ada 95 mode).\n+\n       procedure Check_Arg_Is_Identifier (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it is an\n       --  identifier. If not give error and raise Pragma_Exit.\n@@ -589,13 +595,61 @@ package body Sem_Prag is\n          end if;\n       end Check_Arg_Count;\n \n+      --------------------------------\n+      -- Check_Arg_Is_External_Name --\n+      --------------------------------\n+\n+      procedure Check_Arg_Is_External_Name (Arg : Node_Id) is\n+         Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n+\n+      begin\n+         if Nkind (Argx) = N_Identifier then\n+            return;\n+\n+         else\n+            Analyze_And_Resolve (Argx, Standard_String);\n+\n+            if Is_OK_Static_Expression (Argx) then\n+               return;\n+\n+            elsif Etype (Argx) = Any_Type then\n+               raise Pragma_Exit;\n+\n+            --  An interesting special case, if we have a string literal and\n+            --  we are in Ada 83 mode, then we allow it even though it will\n+            --  not be flagged as static. This allows expected Ada 83 mode\n+            --  use of external names which are string literals, even though\n+            --  technically these are not static in Ada 83.\n+\n+            elsif Ada_Version = Ada_83\n+              and then Nkind (Argx) = N_String_Literal\n+            then\n+               return;\n+\n+            --  Static expression that raises Constraint_Error. This has\n+            --  already been flagged, so just exit from pragma processing.\n+\n+            elsif Is_Static_Expression (Argx) then\n+               raise Pragma_Exit;\n+\n+            --  Here we have a real error (non-static expression)\n+\n+            else\n+               Error_Msg_Name_1 := Chars (N);\n+               Flag_Non_Static_Expr\n+                 (\"argument for pragma% must be a identifier or \" &\n+                  \"static string expression!\", Argx);\n+               raise Pragma_Exit;\n+            end if;\n+         end if;\n+      end Check_Arg_Is_External_Name;\n+\n       -----------------------------\n       -- Check_Arg_Is_Identifier --\n       -----------------------------\n \n       procedure Check_Arg_Is_Identifier (Arg : Node_Id) is\n          Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n-\n       begin\n          if Nkind (Argx) /= N_Identifier then\n             Error_Pragma_Arg\n@@ -609,7 +663,6 @@ package body Sem_Prag is\n \n       procedure Check_Arg_Is_Integer_Literal (Arg : Node_Id) is\n          Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n-\n       begin\n          if Nkind (Argx) /= N_Integer_Literal then\n             Error_Pragma_Arg\n@@ -2084,13 +2137,8 @@ package body Sem_Prag is\n \n          Set_Extended_Import_Export_External_Name (Def_Id, Arg_External);\n \n-         if Present (Arg_Size)\n-           and then Nkind (Arg_Size) /= N_Identifier\n-           and then Nkind (Arg_Size) /= N_String_Literal\n-         then\n-            Error_Pragma_Arg\n-              (\"pragma% Size argument must be identifier or string literal\",\n-               Arg_Size);\n+         if Present (Arg_Size) then\n+            Check_Arg_Is_External_Name (Arg_Size);\n          end if;\n \n          --  Export_Object case\n@@ -3271,7 +3319,8 @@ package body Sem_Prag is\n          Val   : Uint;\n \n          procedure Set_Warning (R : All_Restrictions);\n-         --  If this is a Restriction_Warnings pragma, set warning flag\n+         --  If this is a Restriction_Warnings pragma, set warning flag,\n+         --  otherwise reset the flag.\n \n          -----------------\n          -- Set_Warning --\n@@ -3281,6 +3330,8 @@ package body Sem_Prag is\n          begin\n             if Prag_Id = Pragma_Restriction_Warnings then\n                Restriction_Warnings (R) := True;\n+            else\n+               Restriction_Warnings (R) := False;\n             end if;\n          end Set_Warning;\n \n@@ -3306,7 +3357,7 @@ package body Sem_Prag is\n \n                R_Id :=\n                  Get_Restriction_Id\n-                   (Process_Restriction_Synonyms (Chars (Expr)));\n+                   (Process_Restriction_Synonyms (Expr));\n \n                if R_Id not in All_Boolean_Restrictions then\n                   Error_Pragma_Arg\n@@ -3334,7 +3385,7 @@ package body Sem_Prag is\n             --  Case of restriction identifier present\n \n             else\n-               R_Id := Get_Restriction_Id (Process_Restriction_Synonyms (Id));\n+               R_Id := Get_Restriction_Id (Process_Restriction_Synonyms (Arg));\n                Analyze_And_Resolve (Expr, Any_Integer);\n \n                if R_Id not in All_Parameter_Restrictions then\n@@ -3609,8 +3660,11 @@ package body Sem_Prag is\n       begin\n          if No (Arg_External) then\n             return;\n+         end if;\n+\n+         Check_Arg_Is_External_Name (Arg_External);\n \n-         elsif Nkind (Arg_External) = N_String_Literal then\n+         if Nkind (Arg_External) = N_String_Literal then\n             if String_Length (Strval (Arg_External)) = 0 then\n                return;\n             else\n@@ -3620,10 +3674,12 @@ package body Sem_Prag is\n          elsif Nkind (Arg_External) = N_Identifier then\n             New_Name := Get_Default_External_Name (Arg_External);\n \n+         --  Check_Arg_Is_External_Name should let through only\n+         --  identifiers and string literals or static string\n+         --  expressions (which are folded to string literals).\n+\n          else\n-            Error_Pragma_Arg\n-              (\"incorrect form for External parameter for pragma%\",\n-               Arg_External);\n+            raise Program_Error;\n          end if;\n \n          --  If we already have an external name set (by a prior normal\n@@ -3848,7 +3904,7 @@ package body Sem_Prag is\n \n       --    Set Detect_Blocking mode ???\n \n-      --    Set required restrictions (see Restrict.Set_Ravenscar for details)\n+      --    Set required restrictions (see System.Rident for detailed list)\n \n       procedure Set_Ravenscar_Profile (N : Node_Id) is\n       begin\n@@ -3896,7 +3952,7 @@ package body Sem_Prag is\n \n          --  Set the corresponding restrictions\n \n-         Set_Ravenscar (N);\n+         Set_Profile_Restrictions (Ravenscar, N, Warn => False);\n       end Set_Ravenscar_Profile;\n \n    --  Start of processing for Analyze_Pragma\n@@ -8095,10 +8151,9 @@ package body Sem_Prag is\n \n          --  pragma Profile (profile_IDENTIFIER);\n \n-         --  profile_IDENTIFIER => Ravenscar\n+         --  profile_IDENTIFIER => Protected | Ravenscar\n \n          when Pragma_Profile =>\n-            GNAT_Pragma;\n             Check_Arg_Count (1);\n             Check_Valid_Configuration_Pragma;\n             Check_No_Identifiers;\n@@ -8108,6 +8163,36 @@ package body Sem_Prag is\n             begin\n                if Chars (Argx) = Name_Ravenscar then\n                   Set_Ravenscar_Profile (N);\n+\n+               elsif Chars (Argx) = Name_Restricted then\n+                  Set_Profile_Restrictions (Restricted, N, Warn => False);\n+               else\n+                  Error_Pragma_Arg (\"& is not a valid profile\", Argx);\n+               end if;\n+            end;\n+\n+         ----------------------\n+         -- Profile_Warnings --\n+         ----------------------\n+\n+         --  pragma Profile_Warnings (profile_IDENTIFIER);\n+\n+         --  profile_IDENTIFIER => Protected | Ravenscar\n+\n+         when Pragma_Profile_Warnings =>\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Check_Valid_Configuration_Pragma;\n+            Check_No_Identifiers;\n+\n+            declare\n+               Argx : constant Node_Id := Get_Pragma_Arg (Arg1);\n+            begin\n+               if Chars (Argx) = Name_Ravenscar then\n+                  Set_Profile_Restrictions (Ravenscar, N, Warn => True);\n+\n+               elsif Chars (Argx) = Name_Restricted then\n+                  Set_Profile_Restrictions (Restricted, N, Warn => True);\n                else\n                   Error_Pragma_Arg (\"& is not a valid profile\", Argx);\n                end if;\n@@ -8579,6 +8664,13 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Set_Ravenscar_Profile (N);\n \n+            if Warn_On_Obsolescent_Feature then\n+               Error_Msg_N\n+                 (\"pragma Ravenscar is an obsolescent feature?\", N);\n+               Error_Msg_N\n+                 (\"|use pragma Profile (Ravenscar) instead\", N);\n+            end if;\n+\n          -------------------------\n          -- Restricted_Run_Time --\n          -------------------------\n@@ -8589,7 +8681,14 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Check_Arg_Count (0);\n             Check_Valid_Configuration_Pragma;\n-            Set_Restricted_Profile (N);\n+            Set_Profile_Restrictions (Restricted, N, Warn => False);\n+\n+            if Warn_On_Obsolescent_Feature then\n+               Error_Msg_N\n+                 (\"pragma Restricted_Run_Time is an obsolescent feature?\", N);\n+               Error_Msg_N\n+                 (\"|use pragma Profile (Restricted) instead\", N);\n+            end if;\n \n          ------------------\n          -- Restrictions --\n@@ -10158,6 +10257,7 @@ package body Sem_Prag is\n       Pragma_Preelaborate                 => -1,\n       Pragma_Priority                     => -1,\n       Pragma_Profile                      =>  0,\n+      Pragma_Profile_Warnings             =>  0,\n       Pragma_Propagate_Exceptions         => -1,\n       Pragma_Psect_Object                 => -1,\n       Pragma_Pure                         =>  0,"}, {"sha": "272801b35b184180d8b9aa7642c59f9c72074073", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -191,6 +191,7 @@ package body Snames is\n      \"persistent_data#\" &\n      \"persistent_object#\" &\n      \"profile#\" &\n+     \"profile_warnings#\" &\n      \"propagate_exceptions#\" &\n      \"queuing_policy#\" &\n      \"ravenscar#\" &"}, {"sha": "153ea275fc6bb4e926e371fb010df2452ea88357", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 510, "deletions": 508, "changes": 1018, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -301,8 +301,8 @@ package Snames is\n    --  of these implementation dependent pragmas may be found in the\n    --  appropriate section in unit Sem_Prag in file sem-prag.adb.\n \n-   --  The entries marked Ada0Y are technically implementation dependent\n-   --  pragmas, but they correspond to standard proposals for Ada 0Y.\n+   --  The entries marked Ada05 are technically implementation dependent\n+   --  pragmas, but they correspond to standard proposals for Ada 2005.\n \n    --  The entries marked VMS are VMS specific pragmas that are recognized\n    --  only in OpenVMS versions of GNAT. They are ignored in other versions\n@@ -342,111 +342,112 @@ package Snames is\n    Name_Polling                        : constant Name_Id := N + 130; -- GNAT\n    Name_Persistent_Data                : constant Name_Id := N + 131; -- GNAT\n    Name_Persistent_Object              : constant Name_Id := N + 132; -- GNAT\n-   Name_Profile                        : constant Name_Id := N + 133; -- Ada0Y\n-   Name_Propagate_Exceptions           : constant Name_Id := N + 134; -- GNAT\n-   Name_Queuing_Policy                 : constant Name_Id := N + 135;\n-   Name_Ravenscar                      : constant Name_Id := N + 136;\n-   Name_Restricted_Run_Time            : constant Name_Id := N + 137;\n-   Name_Restrictions                   : constant Name_Id := N + 138;\n-   Name_Restriction_Warnings           : constant Name_Id := N + 139; -- GNAT\n-   Name_Reviewable                     : constant Name_Id := N + 140;\n-   Name_Source_File_Name               : constant Name_Id := N + 141; -- GNAT\n-   Name_Source_File_Name_Project       : constant Name_Id := N + 142; -- GNAT\n-   Name_Style_Checks                   : constant Name_Id := N + 143; -- GNAT\n-   Name_Suppress                       : constant Name_Id := N + 144;\n-   Name_Suppress_Exception_Locations   : constant Name_Id := N + 145; -- GNAT\n-   Name_Task_Dispatching_Policy        : constant Name_Id := N + 146;\n-   Name_Universal_Data                 : constant Name_Id := N + 147; -- AAMP\n-   Name_Unsuppress                     : constant Name_Id := N + 148; -- GNAT\n-   Name_Use_VADS_Size                  : constant Name_Id := N + 149; -- GNAT\n-   Name_Validity_Checks                : constant Name_Id := N + 150; -- GNAT\n-   Name_Warnings                       : constant Name_Id := N + 151; -- GNAT\n-   Last_Configuration_Pragma_Name      : constant Name_Id := N + 151;\n+   Name_Profile                        : constant Name_Id := N + 133; -- Ada05\n+   Name_Profile_Warnings               : constant Name_Id := N + 134; -- GNAT\n+   Name_Propagate_Exceptions           : constant Name_Id := N + 135; -- GNAT\n+   Name_Queuing_Policy                 : constant Name_Id := N + 136;\n+   Name_Ravenscar                      : constant Name_Id := N + 137;\n+   Name_Restricted_Run_Time            : constant Name_Id := N + 138;\n+   Name_Restrictions                   : constant Name_Id := N + 139;\n+   Name_Restriction_Warnings           : constant Name_Id := N + 140; -- GNAT\n+   Name_Reviewable                     : constant Name_Id := N + 141;\n+   Name_Source_File_Name               : constant Name_Id := N + 142; -- GNAT\n+   Name_Source_File_Name_Project       : constant Name_Id := N + 143; -- GNAT\n+   Name_Style_Checks                   : constant Name_Id := N + 144; -- GNAT\n+   Name_Suppress                       : constant Name_Id := N + 145;\n+   Name_Suppress_Exception_Locations   : constant Name_Id := N + 146; -- GNAT\n+   Name_Task_Dispatching_Policy        : constant Name_Id := N + 147;\n+   Name_Universal_Data                 : constant Name_Id := N + 148; -- AAMP\n+   Name_Unsuppress                     : constant Name_Id := N + 149; -- GNAT\n+   Name_Use_VADS_Size                  : constant Name_Id := N + 150; -- GNAT\n+   Name_Validity_Checks                : constant Name_Id := N + 151; -- GNAT\n+   Name_Warnings                       : constant Name_Id := N + 152; -- GNAT\n+   Last_Configuration_Pragma_Name      : constant Name_Id := N + 152;\n \n    --  Remaining pragma names\n \n-   Name_Abort_Defer                    : constant Name_Id := N + 152; -- GNAT\n-   Name_All_Calls_Remote               : constant Name_Id := N + 153;\n-   Name_Annotate                       : constant Name_Id := N + 154; -- GNAT\n+   Name_Abort_Defer                    : constant Name_Id := N + 153; -- GNAT\n+   Name_All_Calls_Remote               : constant Name_Id := N + 154;\n+   Name_Annotate                       : constant Name_Id := N + 155; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Attribute_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Name_AST_Entry.\n    --  AST_Entry is a VMS specific pragma.\n \n-   Name_Assert                         : constant Name_Id := N + 155; -- GNAT\n-   Name_Asynchronous                   : constant Name_Id := N + 156;\n-   Name_Atomic                         : constant Name_Id := N + 157;\n-   Name_Atomic_Components              : constant Name_Id := N + 158;\n-   Name_Attach_Handler                 : constant Name_Id := N + 159;\n-   Name_Comment                        : constant Name_Id := N + 160; -- GNAT\n-   Name_Common_Object                  : constant Name_Id := N + 161; -- GNAT\n-   Name_Complex_Representation         : constant Name_Id := N + 162; -- GNAT\n-   Name_Controlled                     : constant Name_Id := N + 163;\n-   Name_Convention                     : constant Name_Id := N + 164;\n-   Name_CPP_Class                      : constant Name_Id := N + 165; -- GNAT\n-   Name_CPP_Constructor                : constant Name_Id := N + 166; -- GNAT\n-   Name_CPP_Virtual                    : constant Name_Id := N + 167; -- GNAT\n-   Name_CPP_Vtable                     : constant Name_Id := N + 168; -- GNAT\n-   Name_Debug                          : constant Name_Id := N + 169; -- GNAT\n-   Name_Elaborate                      : constant Name_Id := N + 170; -- Ada 83\n-   Name_Elaborate_All                  : constant Name_Id := N + 171;\n-   Name_Elaborate_Body                 : constant Name_Id := N + 172;\n-   Name_Export                         : constant Name_Id := N + 173;\n-   Name_Export_Exception               : constant Name_Id := N + 174; -- VMS\n-   Name_Export_Function                : constant Name_Id := N + 175; -- GNAT\n-   Name_Export_Object                  : constant Name_Id := N + 176; -- GNAT\n-   Name_Export_Procedure               : constant Name_Id := N + 177; -- GNAT\n-   Name_Export_Value                   : constant Name_Id := N + 178; -- GNAT\n-   Name_Export_Valued_Procedure        : constant Name_Id := N + 179; -- GNAT\n-   Name_External                       : constant Name_Id := N + 180; -- GNAT\n-   Name_Finalize_Storage_Only          : constant Name_Id := N + 181; -- GNAT\n-   Name_Ident                          : constant Name_Id := N + 182; -- VMS\n-   Name_Import                         : constant Name_Id := N + 183;\n-   Name_Import_Exception               : constant Name_Id := N + 184; -- VMS\n-   Name_Import_Function                : constant Name_Id := N + 185; -- GNAT\n-   Name_Import_Object                  : constant Name_Id := N + 186; -- GNAT\n-   Name_Import_Procedure               : constant Name_Id := N + 187; -- GNAT\n-   Name_Import_Valued_Procedure        : constant Name_Id := N + 188; -- GNAT\n-   Name_Inline                         : constant Name_Id := N + 189;\n-   Name_Inline_Always                  : constant Name_Id := N + 190; -- GNAT\n-   Name_Inline_Generic                 : constant Name_Id := N + 191; -- GNAT\n-   Name_Inspection_Point               : constant Name_Id := N + 192;\n-   Name_Interface                      : constant Name_Id := N + 193; -- Ada 83\n-   Name_Interface_Name                 : constant Name_Id := N + 194; -- GNAT\n-   Name_Interrupt_Handler              : constant Name_Id := N + 195;\n-   Name_Interrupt_Priority             : constant Name_Id := N + 196;\n-   Name_Java_Constructor               : constant Name_Id := N + 197; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + 198; -- GNAT\n-   Name_Keep_Names                     : constant Name_Id := N + 199; -- GNAT\n-   Name_Link_With                      : constant Name_Id := N + 200; -- GNAT\n-   Name_Linker_Alias                   : constant Name_Id := N + 201; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 202;\n-   Name_Linker_Section                 : constant Name_Id := N + 203; -- GNAT\n-   Name_List                           : constant Name_Id := N + 204;\n-   Name_Machine_Attribute              : constant Name_Id := N + 205; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 206; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 207; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 208; -- Ada 83\n-   Name_No_Return                      : constant Name_Id := N + 209; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 210; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 211;\n-   Name_Optional_Overriding            : constant Name_Id := N + 212;\n-   Name_Overriding                     : constant Name_Id := N + 213;\n-   Name_Pack                           : constant Name_Id := N + 214;\n-   Name_Page                           : constant Name_Id := N + 215;\n-   Name_Passive                        : constant Name_Id := N + 216; -- GNAT\n-   Name_Preelaborate                   : constant Name_Id := N + 217;\n-   Name_Priority                       : constant Name_Id := N + 218;\n-   Name_Psect_Object                   : constant Name_Id := N + 219; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 220;\n-   Name_Pure_Function                  : constant Name_Id := N + 221; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 222;\n-   Name_Remote_Types                   : constant Name_Id := N + 223;\n-   Name_Share_Generic                  : constant Name_Id := N + 224; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 225; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 226;\n+   Name_Assert                         : constant Name_Id := N + 156; -- GNAT\n+   Name_Asynchronous                   : constant Name_Id := N + 157;\n+   Name_Atomic                         : constant Name_Id := N + 158;\n+   Name_Atomic_Components              : constant Name_Id := N + 159;\n+   Name_Attach_Handler                 : constant Name_Id := N + 160;\n+   Name_Comment                        : constant Name_Id := N + 161; -- GNAT\n+   Name_Common_Object                  : constant Name_Id := N + 162; -- GNAT\n+   Name_Complex_Representation         : constant Name_Id := N + 163; -- GNAT\n+   Name_Controlled                     : constant Name_Id := N + 164;\n+   Name_Convention                     : constant Name_Id := N + 165;\n+   Name_CPP_Class                      : constant Name_Id := N + 166; -- GNAT\n+   Name_CPP_Constructor                : constant Name_Id := N + 167; -- GNAT\n+   Name_CPP_Virtual                    : constant Name_Id := N + 168; -- GNAT\n+   Name_CPP_Vtable                     : constant Name_Id := N + 169; -- GNAT\n+   Name_Debug                          : constant Name_Id := N + 170; -- GNAT\n+   Name_Elaborate                      : constant Name_Id := N + 171; -- Ada 83\n+   Name_Elaborate_All                  : constant Name_Id := N + 172;\n+   Name_Elaborate_Body                 : constant Name_Id := N + 173;\n+   Name_Export                         : constant Name_Id := N + 174;\n+   Name_Export_Exception               : constant Name_Id := N + 175; -- VMS\n+   Name_Export_Function                : constant Name_Id := N + 176; -- GNAT\n+   Name_Export_Object                  : constant Name_Id := N + 177; -- GNAT\n+   Name_Export_Procedure               : constant Name_Id := N + 178; -- GNAT\n+   Name_Export_Value                   : constant Name_Id := N + 179; -- GNAT\n+   Name_Export_Valued_Procedure        : constant Name_Id := N + 180; -- GNAT\n+   Name_External                       : constant Name_Id := N + 181; -- GNAT\n+   Name_Finalize_Storage_Only          : constant Name_Id := N + 182; -- GNAT\n+   Name_Ident                          : constant Name_Id := N + 183; -- VMS\n+   Name_Import                         : constant Name_Id := N + 184;\n+   Name_Import_Exception               : constant Name_Id := N + 185; -- VMS\n+   Name_Import_Function                : constant Name_Id := N + 186; -- GNAT\n+   Name_Import_Object                  : constant Name_Id := N + 187; -- GNAT\n+   Name_Import_Procedure               : constant Name_Id := N + 188; -- GNAT\n+   Name_Import_Valued_Procedure        : constant Name_Id := N + 189; -- GNAT\n+   Name_Inline                         : constant Name_Id := N + 190;\n+   Name_Inline_Always                  : constant Name_Id := N + 191; -- GNAT\n+   Name_Inline_Generic                 : constant Name_Id := N + 192; -- GNAT\n+   Name_Inspection_Point               : constant Name_Id := N + 193;\n+   Name_Interface                      : constant Name_Id := N + 194; -- Ada 83\n+   Name_Interface_Name                 : constant Name_Id := N + 195; -- GNAT\n+   Name_Interrupt_Handler              : constant Name_Id := N + 196;\n+   Name_Interrupt_Priority             : constant Name_Id := N + 197;\n+   Name_Java_Constructor               : constant Name_Id := N + 198; -- GNAT\n+   Name_Java_Interface                 : constant Name_Id := N + 199; -- GNAT\n+   Name_Keep_Names                     : constant Name_Id := N + 200; -- GNAT\n+   Name_Link_With                      : constant Name_Id := N + 201; -- GNAT\n+   Name_Linker_Alias                   : constant Name_Id := N + 202; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 203;\n+   Name_Linker_Section                 : constant Name_Id := N + 204; -- GNAT\n+   Name_List                           : constant Name_Id := N + 205;\n+   Name_Machine_Attribute              : constant Name_Id := N + 206; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 207; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 208; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 209; -- Ada 83\n+   Name_No_Return                      : constant Name_Id := N + 210; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 211; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 212;\n+   Name_Optional_Overriding            : constant Name_Id := N + 213;\n+   Name_Overriding                     : constant Name_Id := N + 214;\n+   Name_Pack                           : constant Name_Id := N + 215;\n+   Name_Page                           : constant Name_Id := N + 216;\n+   Name_Passive                        : constant Name_Id := N + 217; -- GNAT\n+   Name_Preelaborate                   : constant Name_Id := N + 218;\n+   Name_Priority                       : constant Name_Id := N + 219;\n+   Name_Psect_Object                   : constant Name_Id := N + 220; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 221;\n+   Name_Pure_Function                  : constant Name_Id := N + 222; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 223;\n+   Name_Remote_Types                   : constant Name_Id := N + 224;\n+   Name_Share_Generic                  : constant Name_Id := N + 225; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 226; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 227;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -456,27 +457,27 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 227; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 228; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 229; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 230; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 231; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 232; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 233; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 234; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 235; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 236; -- VMS\n-   Name_Thread_Body                    : constant Name_Id := N + 237; -- GNAT\n-   Name_Time_Slice                     : constant Name_Id := N + 238; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 239; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 240; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 241; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 242; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 243; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 244;\n-   Name_Volatile_Components            : constant Name_Id := N + 245;\n-   Name_Weak_External                  : constant Name_Id := N + 246; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 246;\n+   Name_Source_Reference               : constant Name_Id := N + 228; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 229; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 230; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 231; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 232; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 233; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 234; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 235; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 236; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 237; -- VMS\n+   Name_Thread_Body                    : constant Name_Id := N + 238; -- GNAT\n+   Name_Time_Slice                     : constant Name_Id := N + 239; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 240; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 241; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 242; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 243; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 244; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 245;\n+   Name_Volatile_Components            : constant Name_Id := N + 246;\n+   Name_Weak_External                  : constant Name_Id := N + 247; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 247;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -487,105 +488,105 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 247;\n-   Name_Ada                            : constant Name_Id := N + 247;\n-   Name_Assembler                      : constant Name_Id := N + 248;\n-   Name_COBOL                          : constant Name_Id := N + 249;\n-   Name_CPP                            : constant Name_Id := N + 250;\n-   Name_Fortran                        : constant Name_Id := N + 251;\n-   Name_Intrinsic                      : constant Name_Id := N + 252;\n-   Name_Java                           : constant Name_Id := N + 253;\n-   Name_Stdcall                        : constant Name_Id := N + 254;\n-   Name_Stubbed                        : constant Name_Id := N + 255;\n-   Last_Convention_Name                : constant Name_Id := N + 255;\n+   First_Convention_Name               : constant Name_Id := N + 248;\n+   Name_Ada                            : constant Name_Id := N + 248;\n+   Name_Assembler                      : constant Name_Id := N + 249;\n+   Name_COBOL                          : constant Name_Id := N + 250;\n+   Name_CPP                            : constant Name_Id := N + 251;\n+   Name_Fortran                        : constant Name_Id := N + 252;\n+   Name_Intrinsic                      : constant Name_Id := N + 253;\n+   Name_Java                           : constant Name_Id := N + 254;\n+   Name_Stdcall                        : constant Name_Id := N + 255;\n+   Name_Stubbed                        : constant Name_Id := N + 256;\n+   Last_Convention_Name                : constant Name_Id := N + 256;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 256;\n-   Name_Assembly                       : constant Name_Id := N + 257;\n+   Name_Asm                            : constant Name_Id := N + 257;\n+   Name_Assembly                       : constant Name_Id := N + 258;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 258;\n+   Name_Default                        : constant Name_Id := N + 259;\n    --  Name_Exernal (previously defined as pragma)\n \n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 259;\n-   Name_Win32                          : constant Name_Id := N + 260;\n+   Name_DLL                            : constant Name_Id := N + 260;\n+   Name_Win32                          : constant Name_Id := N + 261;\n \n    --  Other special names used in processing pragmas\n \n-   Name_As_Is                          : constant Name_Id := N + 261;\n-   Name_Body_File_Name                 : constant Name_Id := N + 262;\n-   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 263;\n-   Name_Casing                         : constant Name_Id := N + 264;\n-   Name_Code                           : constant Name_Id := N + 265;\n-   Name_Component                      : constant Name_Id := N + 266;\n-   Name_Component_Size_4               : constant Name_Id := N + 267;\n-   Name_Copy                           : constant Name_Id := N + 268;\n-   Name_D_Float                        : constant Name_Id := N + 269;\n-   Name_Descriptor                     : constant Name_Id := N + 270;\n-   Name_Dot_Replacement                : constant Name_Id := N + 271;\n-   Name_Dynamic                        : constant Name_Id := N + 272;\n-   Name_Entity                         : constant Name_Id := N + 273;\n-   Name_External_Name                  : constant Name_Id := N + 274;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 275;\n-   Name_Form                           : constant Name_Id := N + 276;\n-   Name_G_Float                        : constant Name_Id := N + 277;\n-   Name_Gcc                            : constant Name_Id := N + 278;\n-   Name_Gnat                           : constant Name_Id := N + 279;\n-   Name_GPL                            : constant Name_Id := N + 280;\n-   Name_IEEE_Float                     : constant Name_Id := N + 281;\n-   Name_Internal                       : constant Name_Id := N + 282;\n-   Name_Link_Name                      : constant Name_Id := N + 283;\n-   Name_Lowercase                      : constant Name_Id := N + 284;\n-   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 285;\n-   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 286;\n-   Name_Max_Size                       : constant Name_Id := N + 287;\n-   Name_Mechanism                      : constant Name_Id := N + 288;\n-   Name_Mixedcase                      : constant Name_Id := N + 289;\n-   Name_Modified_GPL                   : constant Name_Id := N + 290;\n-   Name_Name                           : constant Name_Id := N + 291;\n-   Name_NCA                            : constant Name_Id := N + 292;\n-   Name_No                             : constant Name_Id := N + 293;\n-   Name_On                             : constant Name_Id := N + 294;\n-   Name_Parameter_Types                : constant Name_Id := N + 295;\n-   Name_Reference                      : constant Name_Id := N + 296;\n-   Name_No_Dynamic_Attachment          : constant Name_Id := N + 297;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 298;\n-   Name_No_Requeue                     : constant Name_Id := N + 299;\n-   Name_No_Requeue_Statements          : constant Name_Id := N + 300;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 301;\n-   Name_No_Task_Attributes_Package     : constant Name_Id := N + 302;\n-   Name_Restricted                     : constant Name_Id := N + 303;\n-   Name_Result_Mechanism               : constant Name_Id := N + 304;\n-   Name_Result_Type                    : constant Name_Id := N + 305;\n-   Name_Runtime                        : constant Name_Id := N + 306;\n-   Name_SB                             : constant Name_Id := N + 307;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 308;\n-   Name_Section                        : constant Name_Id := N + 309;\n-   Name_Semaphore                      : constant Name_Id := N + 310;\n-   Name_Simple_Barriers                : constant Name_Id := N + 311;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 312;\n-   Name_Static                         : constant Name_Id := N + 313;\n-   Name_Stack_Size                     : constant Name_Id := N + 314;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 315;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 316;\n-   Name_Task_Type                      : constant Name_Id := N + 317;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 318;\n-   Name_Top_Guard                      : constant Name_Id := N + 319;\n-   Name_UBA                            : constant Name_Id := N + 320;\n-   Name_UBS                            : constant Name_Id := N + 321;\n-   Name_UBSB                           : constant Name_Id := N + 322;\n-   Name_Unit_Name                      : constant Name_Id := N + 323;\n-   Name_Unknown                        : constant Name_Id := N + 324;\n-   Name_Unrestricted                   : constant Name_Id := N + 325;\n-   Name_Uppercase                      : constant Name_Id := N + 326;\n-   Name_User                           : constant Name_Id := N + 327;\n-   Name_VAX_Float                      : constant Name_Id := N + 328;\n-   Name_VMS                            : constant Name_Id := N + 329;\n-   Name_Working_Storage                : constant Name_Id := N + 330;\n+   Name_As_Is                          : constant Name_Id := N + 262;\n+   Name_Body_File_Name                 : constant Name_Id := N + 263;\n+   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 264;\n+   Name_Casing                         : constant Name_Id := N + 265;\n+   Name_Code                           : constant Name_Id := N + 266;\n+   Name_Component                      : constant Name_Id := N + 267;\n+   Name_Component_Size_4               : constant Name_Id := N + 268;\n+   Name_Copy                           : constant Name_Id := N + 269;\n+   Name_D_Float                        : constant Name_Id := N + 270;\n+   Name_Descriptor                     : constant Name_Id := N + 271;\n+   Name_Dot_Replacement                : constant Name_Id := N + 272;\n+   Name_Dynamic                        : constant Name_Id := N + 273;\n+   Name_Entity                         : constant Name_Id := N + 274;\n+   Name_External_Name                  : constant Name_Id := N + 275;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 276;\n+   Name_Form                           : constant Name_Id := N + 277;\n+   Name_G_Float                        : constant Name_Id := N + 278;\n+   Name_Gcc                            : constant Name_Id := N + 279;\n+   Name_Gnat                           : constant Name_Id := N + 280;\n+   Name_GPL                            : constant Name_Id := N + 281;\n+   Name_IEEE_Float                     : constant Name_Id := N + 282;\n+   Name_Internal                       : constant Name_Id := N + 283;\n+   Name_Link_Name                      : constant Name_Id := N + 284;\n+   Name_Lowercase                      : constant Name_Id := N + 285;\n+   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 286;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 287;\n+   Name_Max_Size                       : constant Name_Id := N + 288;\n+   Name_Mechanism                      : constant Name_Id := N + 289;\n+   Name_Mixedcase                      : constant Name_Id := N + 290;\n+   Name_Modified_GPL                   : constant Name_Id := N + 291;\n+   Name_Name                           : constant Name_Id := N + 292;\n+   Name_NCA                            : constant Name_Id := N + 293;\n+   Name_No                             : constant Name_Id := N + 294;\n+   Name_On                             : constant Name_Id := N + 295;\n+   Name_Parameter_Types                : constant Name_Id := N + 296;\n+   Name_Reference                      : constant Name_Id := N + 297;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 298;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 299;\n+   Name_No_Requeue                     : constant Name_Id := N + 300;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 301;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 302;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 303;\n+   Name_Restricted                     : constant Name_Id := N + 304;\n+   Name_Result_Mechanism               : constant Name_Id := N + 305;\n+   Name_Result_Type                    : constant Name_Id := N + 306;\n+   Name_Runtime                        : constant Name_Id := N + 307;\n+   Name_SB                             : constant Name_Id := N + 308;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 309;\n+   Name_Section                        : constant Name_Id := N + 310;\n+   Name_Semaphore                      : constant Name_Id := N + 311;\n+   Name_Simple_Barriers                : constant Name_Id := N + 312;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 313;\n+   Name_Static                         : constant Name_Id := N + 314;\n+   Name_Stack_Size                     : constant Name_Id := N + 315;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 316;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 317;\n+   Name_Task_Type                      : constant Name_Id := N + 318;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 319;\n+   Name_Top_Guard                      : constant Name_Id := N + 320;\n+   Name_UBA                            : constant Name_Id := N + 321;\n+   Name_UBS                            : constant Name_Id := N + 322;\n+   Name_UBSB                           : constant Name_Id := N + 323;\n+   Name_Unit_Name                      : constant Name_Id := N + 324;\n+   Name_Unknown                        : constant Name_Id := N + 325;\n+   Name_Unrestricted                   : constant Name_Id := N + 326;\n+   Name_Uppercase                      : constant Name_Id := N + 327;\n+   Name_User                           : constant Name_Id := N + 328;\n+   Name_VAX_Float                      : constant Name_Id := N + 329;\n+   Name_VMS                            : constant Name_Id := N + 330;\n+   Name_Working_Storage                : constant Name_Id := N + 331;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -599,375 +600,375 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 331;\n-   Name_Abort_Signal                   : constant Name_Id := N + 331;  -- GNAT\n-   Name_Access                         : constant Name_Id := N + 332;\n-   Name_Address                        : constant Name_Id := N + 333;\n-   Name_Address_Size                   : constant Name_Id := N + 334;  -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 335;\n-   Name_Alignment                      : constant Name_Id := N + 336;\n-   Name_Asm_Input                      : constant Name_Id := N + 337;  -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 338;  -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 339;  -- VMS\n-   Name_Bit                            : constant Name_Id := N + 340;  -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 341;\n-   Name_Bit_Position                   : constant Name_Id := N + 342;  -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 343;\n-   Name_Callable                       : constant Name_Id := N + 344;\n-   Name_Caller                         : constant Name_Id := N + 345;\n-   Name_Code_Address                   : constant Name_Id := N + 346;  -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 347;\n-   Name_Compose                        : constant Name_Id := N + 348;\n-   Name_Constrained                    : constant Name_Id := N + 349;\n-   Name_Count                          : constant Name_Id := N + 350;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 351; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 352;\n-   Name_Delta                          : constant Name_Id := N + 353;\n-   Name_Denorm                         : constant Name_Id := N + 354;\n-   Name_Digits                         : constant Name_Id := N + 355;\n-   Name_Elaborated                     : constant Name_Id := N + 356; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 357; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 358; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 359; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 360;\n-   Name_External_Tag                   : constant Name_Id := N + 361;\n-   Name_First                          : constant Name_Id := N + 362;\n-   Name_First_Bit                      : constant Name_Id := N + 363;\n-   Name_Fixed_Value                    : constant Name_Id := N + 364; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 365;\n-   Name_Has_Discriminants              : constant Name_Id := N + 366; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 367;\n-   Name_Img                            : constant Name_Id := N + 368; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 369; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 370; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 371;\n-   Name_Last_Bit                       : constant Name_Id := N + 372;\n-   Name_Leading_Part                   : constant Name_Id := N + 373;\n-   Name_Length                         : constant Name_Id := N + 374;\n-   Name_Machine_Emax                   : constant Name_Id := N + 375;\n-   Name_Machine_Emin                   : constant Name_Id := N + 376;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 377;\n-   Name_Machine_Overflows              : constant Name_Id := N + 378;\n-   Name_Machine_Radix                  : constant Name_Id := N + 379;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 380;\n-   Name_Machine_Size                   : constant Name_Id := N + 381; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 382; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 383;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 384; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 385; -- GNAT\n-   Name_Model_Emin                     : constant Name_Id := N + 386;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 387;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 388;\n-   Name_Model_Small                    : constant Name_Id := N + 389;\n-   Name_Modulus                        : constant Name_Id := N + 390;\n-   Name_Null_Parameter                 : constant Name_Id := N + 391; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 392; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 393;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 394; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 395;\n-   Name_Pos                            : constant Name_Id := N + 396;\n-   Name_Position                       : constant Name_Id := N + 397;\n-   Name_Range                          : constant Name_Id := N + 398;\n-   Name_Range_Length                   : constant Name_Id := N + 399; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 400;\n-   Name_Safe_Emax                      : constant Name_Id := N + 401; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 402;\n-   Name_Safe_Large                     : constant Name_Id := N + 403; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 404;\n-   Name_Safe_Small                     : constant Name_Id := N + 405; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 406;\n-   Name_Scaling                        : constant Name_Id := N + 407;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 408;\n-   Name_Size                           : constant Name_Id := N + 409;\n-   Name_Small                          : constant Name_Id := N + 410;\n-   Name_Storage_Size                   : constant Name_Id := N + 411;\n-   Name_Storage_Unit                   : constant Name_Id := N + 412; -- GNAT\n-   Name_Tag                            : constant Name_Id := N + 413;\n-   Name_Target_Name                    : constant Name_Id := N + 414; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 415;\n-   Name_To_Address                     : constant Name_Id := N + 416; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 417; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 418; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 419;\n-   Name_Unchecked_Access               : constant Name_Id := N + 420;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 421;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 422; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 423; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 424; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 425;\n-   Name_Valid                          : constant Name_Id := N + 426;\n-   Name_Value_Size                     : constant Name_Id := N + 427; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 428;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 429; -- GNAT\n-   Name_Wide_Width                     : constant Name_Id := N + 430;\n-   Name_Width                          : constant Name_Id := N + 431;\n-   Name_Word_Size                      : constant Name_Id := N + 432; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 332;\n+   Name_Abort_Signal                   : constant Name_Id := N + 332;  -- GNAT\n+   Name_Access                         : constant Name_Id := N + 333;\n+   Name_Address                        : constant Name_Id := N + 334;\n+   Name_Address_Size                   : constant Name_Id := N + 335;  -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 336;\n+   Name_Alignment                      : constant Name_Id := N + 337;\n+   Name_Asm_Input                      : constant Name_Id := N + 338;  -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 339;  -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 340;  -- VMS\n+   Name_Bit                            : constant Name_Id := N + 341;  -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 342;\n+   Name_Bit_Position                   : constant Name_Id := N + 343;  -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 344;\n+   Name_Callable                       : constant Name_Id := N + 345;\n+   Name_Caller                         : constant Name_Id := N + 346;\n+   Name_Code_Address                   : constant Name_Id := N + 347;  -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 348;\n+   Name_Compose                        : constant Name_Id := N + 349;\n+   Name_Constrained                    : constant Name_Id := N + 350;\n+   Name_Count                          : constant Name_Id := N + 351;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 352; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 353;\n+   Name_Delta                          : constant Name_Id := N + 354;\n+   Name_Denorm                         : constant Name_Id := N + 355;\n+   Name_Digits                         : constant Name_Id := N + 356;\n+   Name_Elaborated                     : constant Name_Id := N + 357; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 358; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 359; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 360; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 361;\n+   Name_External_Tag                   : constant Name_Id := N + 362;\n+   Name_First                          : constant Name_Id := N + 363;\n+   Name_First_Bit                      : constant Name_Id := N + 364;\n+   Name_Fixed_Value                    : constant Name_Id := N + 365; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 366;\n+   Name_Has_Discriminants              : constant Name_Id := N + 367; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 368;\n+   Name_Img                            : constant Name_Id := N + 369; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 370; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 371; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 372;\n+   Name_Last_Bit                       : constant Name_Id := N + 373;\n+   Name_Leading_Part                   : constant Name_Id := N + 374;\n+   Name_Length                         : constant Name_Id := N + 375;\n+   Name_Machine_Emax                   : constant Name_Id := N + 376;\n+   Name_Machine_Emin                   : constant Name_Id := N + 377;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 378;\n+   Name_Machine_Overflows              : constant Name_Id := N + 379;\n+   Name_Machine_Radix                  : constant Name_Id := N + 380;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 381;\n+   Name_Machine_Size                   : constant Name_Id := N + 382; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 383; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 384;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 385; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 386; -- GNAT\n+   Name_Model_Emin                     : constant Name_Id := N + 387;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 388;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 389;\n+   Name_Model_Small                    : constant Name_Id := N + 390;\n+   Name_Modulus                        : constant Name_Id := N + 391;\n+   Name_Null_Parameter                 : constant Name_Id := N + 392; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 393; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 394;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 395; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 396;\n+   Name_Pos                            : constant Name_Id := N + 397;\n+   Name_Position                       : constant Name_Id := N + 398;\n+   Name_Range                          : constant Name_Id := N + 399;\n+   Name_Range_Length                   : constant Name_Id := N + 400; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 401;\n+   Name_Safe_Emax                      : constant Name_Id := N + 402; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 403;\n+   Name_Safe_Large                     : constant Name_Id := N + 404; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 405;\n+   Name_Safe_Small                     : constant Name_Id := N + 406; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 407;\n+   Name_Scaling                        : constant Name_Id := N + 408;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 409;\n+   Name_Size                           : constant Name_Id := N + 410;\n+   Name_Small                          : constant Name_Id := N + 411;\n+   Name_Storage_Size                   : constant Name_Id := N + 412;\n+   Name_Storage_Unit                   : constant Name_Id := N + 413; -- GNAT\n+   Name_Tag                            : constant Name_Id := N + 414;\n+   Name_Target_Name                    : constant Name_Id := N + 415; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 416;\n+   Name_To_Address                     : constant Name_Id := N + 417; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 418; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 419; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 420;\n+   Name_Unchecked_Access               : constant Name_Id := N + 421;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 422;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 423; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 424; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 425; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 426;\n+   Name_Valid                          : constant Name_Id := N + 427;\n+   Name_Value_Size                     : constant Name_Id := N + 428; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 429;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 430; -- GNAT\n+   Name_Wide_Width                     : constant Name_Id := N + 431;\n+   Name_Width                          : constant Name_Id := N + 432;\n+   Name_Word_Size                      : constant Name_Id := N + 433; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 433;\n-   Name_Adjacent                       : constant Name_Id := N + 433;\n-   Name_Ceiling                        : constant Name_Id := N + 434;\n-   Name_Copy_Sign                      : constant Name_Id := N + 435;\n-   Name_Floor                          : constant Name_Id := N + 436;\n-   Name_Fraction                       : constant Name_Id := N + 437;\n-   Name_Image                          : constant Name_Id := N + 438;\n-   Name_Input                          : constant Name_Id := N + 439;\n-   Name_Machine                        : constant Name_Id := N + 440;\n-   Name_Max                            : constant Name_Id := N + 441;\n-   Name_Min                            : constant Name_Id := N + 442;\n-   Name_Model                          : constant Name_Id := N + 443;\n-   Name_Pred                           : constant Name_Id := N + 444;\n-   Name_Remainder                      : constant Name_Id := N + 445;\n-   Name_Rounding                       : constant Name_Id := N + 446;\n-   Name_Succ                           : constant Name_Id := N + 447;\n-   Name_Truncation                     : constant Name_Id := N + 448;\n-   Name_Value                          : constant Name_Id := N + 449;\n-   Name_Wide_Image                     : constant Name_Id := N + 450;\n-   Name_Wide_Value                     : constant Name_Id := N + 451;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 451;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 434;\n+   Name_Adjacent                       : constant Name_Id := N + 434;\n+   Name_Ceiling                        : constant Name_Id := N + 435;\n+   Name_Copy_Sign                      : constant Name_Id := N + 436;\n+   Name_Floor                          : constant Name_Id := N + 437;\n+   Name_Fraction                       : constant Name_Id := N + 438;\n+   Name_Image                          : constant Name_Id := N + 439;\n+   Name_Input                          : constant Name_Id := N + 440;\n+   Name_Machine                        : constant Name_Id := N + 441;\n+   Name_Max                            : constant Name_Id := N + 442;\n+   Name_Min                            : constant Name_Id := N + 443;\n+   Name_Model                          : constant Name_Id := N + 444;\n+   Name_Pred                           : constant Name_Id := N + 445;\n+   Name_Remainder                      : constant Name_Id := N + 446;\n+   Name_Rounding                       : constant Name_Id := N + 447;\n+   Name_Succ                           : constant Name_Id := N + 448;\n+   Name_Truncation                     : constant Name_Id := N + 449;\n+   Name_Value                          : constant Name_Id := N + 450;\n+   Name_Wide_Image                     : constant Name_Id := N + 451;\n+   Name_Wide_Value                     : constant Name_Id := N + 452;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 452;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 452;\n-   Name_Output                         : constant Name_Id := N + 452;\n-   Name_Read                           : constant Name_Id := N + 453;\n-   Name_Write                          : constant Name_Id := N + 454;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 454;\n+   First_Procedure_Attribute           : constant Name_Id := N + 453;\n+   Name_Output                         : constant Name_Id := N + 453;\n+   Name_Read                           : constant Name_Id := N + 454;\n+   Name_Write                          : constant Name_Id := N + 455;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 455;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 455;\n-   Name_Elab_Body                      : constant Name_Id := N + 455; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 456; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 457;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 456;\n+   Name_Elab_Body                      : constant Name_Id := N + 456; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 457; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 458;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 458;\n-   Name_Base                           : constant Name_Id := N + 458;\n-   Name_Class                          : constant Name_Id := N + 459;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 459;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 459;\n-   Last_Attribute_Name                 : constant Name_Id := N + 459;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 459;\n+   Name_Base                           : constant Name_Id := N + 459;\n+   Name_Class                          : constant Name_Id := N + 460;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 460;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 460;\n+   Last_Attribute_Name                 : constant Name_Id := N + 460;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 460;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 460;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 461;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 461;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 461;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 461;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 462;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 462;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 462;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 462;\n-   Name_Priority_Queuing               : constant Name_Id := N + 463;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 463;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 463;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 463;\n+   Name_Priority_Queuing               : constant Name_Id := N + 464;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 464;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 464;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 464;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 464;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 465;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 465;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 465;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 465;\n-   Name_Access_Check                   : constant Name_Id := N + 465;\n-   Name_Accessibility_Check            : constant Name_Id := N + 466;\n-   Name_Discriminant_Check             : constant Name_Id := N + 467;\n-   Name_Division_Check                 : constant Name_Id := N + 468;\n-   Name_Elaboration_Check              : constant Name_Id := N + 469;\n-   Name_Index_Check                    : constant Name_Id := N + 470;\n-   Name_Length_Check                   : constant Name_Id := N + 471;\n-   Name_Overflow_Check                 : constant Name_Id := N + 472;\n-   Name_Range_Check                    : constant Name_Id := N + 473;\n-   Name_Storage_Check                  : constant Name_Id := N + 474;\n-   Name_Tag_Check                      : constant Name_Id := N + 475;\n-   Name_All_Checks                     : constant Name_Id := N + 476;\n-   Last_Check_Name                     : constant Name_Id := N + 476;\n+   First_Check_Name                    : constant Name_Id := N + 466;\n+   Name_Access_Check                   : constant Name_Id := N + 466;\n+   Name_Accessibility_Check            : constant Name_Id := N + 467;\n+   Name_Discriminant_Check             : constant Name_Id := N + 468;\n+   Name_Division_Check                 : constant Name_Id := N + 469;\n+   Name_Elaboration_Check              : constant Name_Id := N + 470;\n+   Name_Index_Check                    : constant Name_Id := N + 471;\n+   Name_Length_Check                   : constant Name_Id := N + 472;\n+   Name_Overflow_Check                 : constant Name_Id := N + 473;\n+   Name_Range_Check                    : constant Name_Id := N + 474;\n+   Name_Storage_Check                  : constant Name_Id := N + 475;\n+   Name_Tag_Check                      : constant Name_Id := N + 476;\n+   Name_All_Checks                     : constant Name_Id := N + 477;\n+   Last_Check_Name                     : constant Name_Id := N + 477;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 477;\n-   Name_Abs                            : constant Name_Id := N + 478;\n-   Name_Accept                         : constant Name_Id := N + 479;\n-   Name_And                            : constant Name_Id := N + 480;\n-   Name_All                            : constant Name_Id := N + 481;\n-   Name_Array                          : constant Name_Id := N + 482;\n-   Name_At                             : constant Name_Id := N + 483;\n-   Name_Begin                          : constant Name_Id := N + 484;\n-   Name_Body                           : constant Name_Id := N + 485;\n-   Name_Case                           : constant Name_Id := N + 486;\n-   Name_Constant                       : constant Name_Id := N + 487;\n-   Name_Declare                        : constant Name_Id := N + 488;\n-   Name_Delay                          : constant Name_Id := N + 489;\n-   Name_Do                             : constant Name_Id := N + 490;\n-   Name_Else                           : constant Name_Id := N + 491;\n-   Name_Elsif                          : constant Name_Id := N + 492;\n-   Name_End                            : constant Name_Id := N + 493;\n-   Name_Entry                          : constant Name_Id := N + 494;\n-   Name_Exception                      : constant Name_Id := N + 495;\n-   Name_Exit                           : constant Name_Id := N + 496;\n-   Name_For                            : constant Name_Id := N + 497;\n-   Name_Function                       : constant Name_Id := N + 498;\n-   Name_Generic                        : constant Name_Id := N + 499;\n-   Name_Goto                           : constant Name_Id := N + 500;\n-   Name_If                             : constant Name_Id := N + 501;\n-   Name_In                             : constant Name_Id := N + 502;\n-   Name_Is                             : constant Name_Id := N + 503;\n-   Name_Limited                        : constant Name_Id := N + 504;\n-   Name_Loop                           : constant Name_Id := N + 505;\n-   Name_Mod                            : constant Name_Id := N + 506;\n-   Name_New                            : constant Name_Id := N + 507;\n-   Name_Not                            : constant Name_Id := N + 508;\n-   Name_Null                           : constant Name_Id := N + 509;\n-   Name_Of                             : constant Name_Id := N + 510;\n-   Name_Or                             : constant Name_Id := N + 511;\n-   Name_Others                         : constant Name_Id := N + 512;\n-   Name_Out                            : constant Name_Id := N + 513;\n-   Name_Package                        : constant Name_Id := N + 514;\n-   Name_Pragma                         : constant Name_Id := N + 515;\n-   Name_Private                        : constant Name_Id := N + 516;\n-   Name_Procedure                      : constant Name_Id := N + 517;\n-   Name_Raise                          : constant Name_Id := N + 518;\n-   Name_Record                         : constant Name_Id := N + 519;\n-   Name_Rem                            : constant Name_Id := N + 520;\n-   Name_Renames                        : constant Name_Id := N + 521;\n-   Name_Return                         : constant Name_Id := N + 522;\n-   Name_Reverse                        : constant Name_Id := N + 523;\n-   Name_Select                         : constant Name_Id := N + 524;\n-   Name_Separate                       : constant Name_Id := N + 525;\n-   Name_Subtype                        : constant Name_Id := N + 526;\n-   Name_Task                           : constant Name_Id := N + 527;\n-   Name_Terminate                      : constant Name_Id := N + 528;\n-   Name_Then                           : constant Name_Id := N + 529;\n-   Name_Type                           : constant Name_Id := N + 530;\n-   Name_Use                            : constant Name_Id := N + 531;\n-   Name_When                           : constant Name_Id := N + 532;\n-   Name_While                          : constant Name_Id := N + 533;\n-   Name_With                           : constant Name_Id := N + 534;\n-   Name_Xor                            : constant Name_Id := N + 535;\n+   Name_Abort                          : constant Name_Id := N + 478;\n+   Name_Abs                            : constant Name_Id := N + 479;\n+   Name_Accept                         : constant Name_Id := N + 480;\n+   Name_And                            : constant Name_Id := N + 481;\n+   Name_All                            : constant Name_Id := N + 482;\n+   Name_Array                          : constant Name_Id := N + 483;\n+   Name_At                             : constant Name_Id := N + 484;\n+   Name_Begin                          : constant Name_Id := N + 485;\n+   Name_Body                           : constant Name_Id := N + 486;\n+   Name_Case                           : constant Name_Id := N + 487;\n+   Name_Constant                       : constant Name_Id := N + 488;\n+   Name_Declare                        : constant Name_Id := N + 489;\n+   Name_Delay                          : constant Name_Id := N + 490;\n+   Name_Do                             : constant Name_Id := N + 491;\n+   Name_Else                           : constant Name_Id := N + 492;\n+   Name_Elsif                          : constant Name_Id := N + 493;\n+   Name_End                            : constant Name_Id := N + 494;\n+   Name_Entry                          : constant Name_Id := N + 495;\n+   Name_Exception                      : constant Name_Id := N + 496;\n+   Name_Exit                           : constant Name_Id := N + 497;\n+   Name_For                            : constant Name_Id := N + 498;\n+   Name_Function                       : constant Name_Id := N + 499;\n+   Name_Generic                        : constant Name_Id := N + 500;\n+   Name_Goto                           : constant Name_Id := N + 501;\n+   Name_If                             : constant Name_Id := N + 502;\n+   Name_In                             : constant Name_Id := N + 503;\n+   Name_Is                             : constant Name_Id := N + 504;\n+   Name_Limited                        : constant Name_Id := N + 505;\n+   Name_Loop                           : constant Name_Id := N + 506;\n+   Name_Mod                            : constant Name_Id := N + 507;\n+   Name_New                            : constant Name_Id := N + 508;\n+   Name_Not                            : constant Name_Id := N + 509;\n+   Name_Null                           : constant Name_Id := N + 510;\n+   Name_Of                             : constant Name_Id := N + 511;\n+   Name_Or                             : constant Name_Id := N + 512;\n+   Name_Others                         : constant Name_Id := N + 513;\n+   Name_Out                            : constant Name_Id := N + 514;\n+   Name_Package                        : constant Name_Id := N + 515;\n+   Name_Pragma                         : constant Name_Id := N + 516;\n+   Name_Private                        : constant Name_Id := N + 517;\n+   Name_Procedure                      : constant Name_Id := N + 518;\n+   Name_Raise                          : constant Name_Id := N + 519;\n+   Name_Record                         : constant Name_Id := N + 520;\n+   Name_Rem                            : constant Name_Id := N + 521;\n+   Name_Renames                        : constant Name_Id := N + 522;\n+   Name_Return                         : constant Name_Id := N + 523;\n+   Name_Reverse                        : constant Name_Id := N + 524;\n+   Name_Select                         : constant Name_Id := N + 525;\n+   Name_Separate                       : constant Name_Id := N + 526;\n+   Name_Subtype                        : constant Name_Id := N + 527;\n+   Name_Task                           : constant Name_Id := N + 528;\n+   Name_Terminate                      : constant Name_Id := N + 529;\n+   Name_Then                           : constant Name_Id := N + 530;\n+   Name_Type                           : constant Name_Id := N + 531;\n+   Name_Use                            : constant Name_Id := N + 532;\n+   Name_When                           : constant Name_Id := N + 533;\n+   Name_While                          : constant Name_Id := N + 534;\n+   Name_With                           : constant Name_Id := N + 535;\n+   Name_Xor                            : constant Name_Id := N + 536;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                : constant Name_Id := N + 536;\n-   Name_Divide                         : constant Name_Id := N + 536;\n-   Name_Enclosing_Entity               : constant Name_Id := N + 537;\n-   Name_Exception_Information          : constant Name_Id := N + 538;\n-   Name_Exception_Message              : constant Name_Id := N + 539;\n-   Name_Exception_Name                 : constant Name_Id := N + 540;\n-   Name_File                           : constant Name_Id := N + 541;\n-   Name_Import_Address                 : constant Name_Id := N + 542;\n-   Name_Import_Largest_Value           : constant Name_Id := N + 543;\n-   Name_Import_Value                   : constant Name_Id := N + 544;\n-   Name_Is_Negative                    : constant Name_Id := N + 545;\n-   Name_Line                           : constant Name_Id := N + 546;\n-   Name_Rotate_Left                    : constant Name_Id := N + 547;\n-   Name_Rotate_Right                   : constant Name_Id := N + 548;\n-   Name_Shift_Left                     : constant Name_Id := N + 549;\n-   Name_Shift_Right                    : constant Name_Id := N + 550;\n-   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 551;\n-   Name_Source_Location                : constant Name_Id := N + 552;\n-   Name_Unchecked_Conversion           : constant Name_Id := N + 553;\n-   Name_Unchecked_Deallocation         : constant Name_Id := N + 554;\n-   Name_To_Pointer                     : constant Name_Id := N + 555;\n-   Last_Intrinsic_Name                 : constant Name_Id := N + 555;\n+   First_Intrinsic_Name                : constant Name_Id := N + 537;\n+   Name_Divide                         : constant Name_Id := N + 537;\n+   Name_Enclosing_Entity               : constant Name_Id := N + 538;\n+   Name_Exception_Information          : constant Name_Id := N + 539;\n+   Name_Exception_Message              : constant Name_Id := N + 540;\n+   Name_Exception_Name                 : constant Name_Id := N + 541;\n+   Name_File                           : constant Name_Id := N + 542;\n+   Name_Import_Address                 : constant Name_Id := N + 543;\n+   Name_Import_Largest_Value           : constant Name_Id := N + 544;\n+   Name_Import_Value                   : constant Name_Id := N + 545;\n+   Name_Is_Negative                    : constant Name_Id := N + 546;\n+   Name_Line                           : constant Name_Id := N + 547;\n+   Name_Rotate_Left                    : constant Name_Id := N + 548;\n+   Name_Rotate_Right                   : constant Name_Id := N + 549;\n+   Name_Shift_Left                     : constant Name_Id := N + 550;\n+   Name_Shift_Right                    : constant Name_Id := N + 551;\n+   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 552;\n+   Name_Source_Location                : constant Name_Id := N + 553;\n+   Name_Unchecked_Conversion           : constant Name_Id := N + 554;\n+   Name_Unchecked_Deallocation         : constant Name_Id := N + 555;\n+   Name_To_Pointer                     : constant Name_Id := N + 556;\n+   Last_Intrinsic_Name                 : constant Name_Id := N + 556;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 556;\n-   Name_Abstract                       : constant Name_Id := N + 556;\n-   Name_Aliased                        : constant Name_Id := N + 557;\n-   Name_Protected                      : constant Name_Id := N + 558;\n-   Name_Until                          : constant Name_Id := N + 559;\n-   Name_Requeue                        : constant Name_Id := N + 560;\n-   Name_Tagged                         : constant Name_Id := N + 561;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 561;\n+   First_95_Reserved_Word              : constant Name_Id := N + 557;\n+   Name_Abstract                       : constant Name_Id := N + 557;\n+   Name_Aliased                        : constant Name_Id := N + 558;\n+   Name_Protected                      : constant Name_Id := N + 559;\n+   Name_Until                          : constant Name_Id := N + 560;\n+   Name_Requeue                        : constant Name_Id := N + 561;\n+   Name_Tagged                         : constant Name_Id := N + 562;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 562;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 562;\n+   Name_Raise_Exception                : constant Name_Id := N + 563;\n \n    --  Additional reserved words in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Binder                         : constant Name_Id := N + 563;\n-   Name_Body_Suffix                    : constant Name_Id := N + 564;\n-   Name_Builder                        : constant Name_Id := N + 565;\n-   Name_Compiler                       : constant Name_Id := N + 566;\n-   Name_Cross_Reference                : constant Name_Id := N + 567;\n-   Name_Default_Switches               : constant Name_Id := N + 568;\n-   Name_Exec_Dir                       : constant Name_Id := N + 569;\n-   Name_Executable                     : constant Name_Id := N + 570;\n-   Name_Executable_Suffix              : constant Name_Id := N + 571;\n-   Name_Extends                        : constant Name_Id := N + 572;\n-   Name_Finder                         : constant Name_Id := N + 573;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 574;\n-   Name_Gnatls                         : constant Name_Id := N + 575;\n-   Name_Gnatstub                       : constant Name_Id := N + 576;\n-   Name_Implementation                 : constant Name_Id := N + 577;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 578;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 579;\n-   Name_Languages                      : constant Name_Id := N + 580;\n-   Name_Library_Dir                    : constant Name_Id := N + 581;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 582;\n-   Name_Library_GCC                    : constant Name_Id := N + 583;\n-   Name_Library_Interface              : constant Name_Id := N + 584;\n-   Name_Library_Kind                   : constant Name_Id := N + 585;\n-   Name_Library_Name                   : constant Name_Id := N + 586;\n-   Name_Library_Options                : constant Name_Id := N + 587;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 588;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 589;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 590;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 591;\n-   Name_Library_Version                : constant Name_Id := N + 592;\n-   Name_Linker                         : constant Name_Id := N + 593;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 594;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 595;\n-   Name_Metrics                        : constant Name_Id := N + 596;\n-   Name_Naming                         : constant Name_Id := N + 597;\n-   Name_Object_Dir                     : constant Name_Id := N + 598;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 599;\n-   Name_Project                        : constant Name_Id := N + 600;\n-   Name_Separate_Suffix                : constant Name_Id := N + 601;\n-   Name_Source_Dirs                    : constant Name_Id := N + 602;\n-   Name_Source_Files                   : constant Name_Id := N + 603;\n-   Name_Source_List_File               : constant Name_Id := N + 604;\n-   Name_Spec                           : constant Name_Id := N + 605;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 606;\n-   Name_Specification                  : constant Name_Id := N + 607;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 608;\n-   Name_Specification_Suffix           : constant Name_Id := N + 609;\n-   Name_Switches                       : constant Name_Id := N + 610;\n+   Name_Binder                         : constant Name_Id := N + 564;\n+   Name_Body_Suffix                    : constant Name_Id := N + 565;\n+   Name_Builder                        : constant Name_Id := N + 566;\n+   Name_Compiler                       : constant Name_Id := N + 567;\n+   Name_Cross_Reference                : constant Name_Id := N + 568;\n+   Name_Default_Switches               : constant Name_Id := N + 569;\n+   Name_Exec_Dir                       : constant Name_Id := N + 570;\n+   Name_Executable                     : constant Name_Id := N + 571;\n+   Name_Executable_Suffix              : constant Name_Id := N + 572;\n+   Name_Extends                        : constant Name_Id := N + 573;\n+   Name_Finder                         : constant Name_Id := N + 574;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 575;\n+   Name_Gnatls                         : constant Name_Id := N + 576;\n+   Name_Gnatstub                       : constant Name_Id := N + 577;\n+   Name_Implementation                 : constant Name_Id := N + 578;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 579;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 580;\n+   Name_Languages                      : constant Name_Id := N + 581;\n+   Name_Library_Dir                    : constant Name_Id := N + 582;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 583;\n+   Name_Library_GCC                    : constant Name_Id := N + 584;\n+   Name_Library_Interface              : constant Name_Id := N + 585;\n+   Name_Library_Kind                   : constant Name_Id := N + 586;\n+   Name_Library_Name                   : constant Name_Id := N + 587;\n+   Name_Library_Options                : constant Name_Id := N + 588;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 589;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 590;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 591;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 592;\n+   Name_Library_Version                : constant Name_Id := N + 593;\n+   Name_Linker                         : constant Name_Id := N + 594;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 595;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 596;\n+   Name_Metrics                        : constant Name_Id := N + 597;\n+   Name_Naming                         : constant Name_Id := N + 598;\n+   Name_Object_Dir                     : constant Name_Id := N + 599;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 600;\n+   Name_Project                        : constant Name_Id := N + 601;\n+   Name_Separate_Suffix                : constant Name_Id := N + 602;\n+   Name_Source_Dirs                    : constant Name_Id := N + 603;\n+   Name_Source_Files                   : constant Name_Id := N + 604;\n+   Name_Source_List_File               : constant Name_Id := N + 605;\n+   Name_Spec                           : constant Name_Id := N + 606;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 607;\n+   Name_Specification                  : constant Name_Id := N + 608;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 609;\n+   Name_Specification_Suffix           : constant Name_Id := N + 610;\n+   Name_Switches                       : constant Name_Id := N + 611;\n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 611;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 612;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 611;\n+   Last_Predefined_Name                : constant Name_Id := N + 612;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;\n@@ -1197,6 +1198,7 @@ package Snames is\n       Pragma_Persistent_Data,\n       Pragma_Persistent_Object,\n       Pragma_Profile,\n+      Pragma_Profile_Warnings,\n       Pragma_Propagate_Exceptions,\n       Pragma_Queuing_Policy,\n       Pragma_Ravenscar,"}, {"sha": "29caf0e28b168f01154ed8ed00e0d8d3cae0cc08", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 117, "deletions": 116, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -223,128 +223,129 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Persistent_Data              24\n #define  Pragma_Persistent_Object            25\n #define  Pragma_Profile                      26\n-#define  Pragma_Propagate_Exceptions         27\n-#define  Pragma_Queuing_Policy               28\n-#define  Pragma_Ravenscar                    29\n-#define  Pragma_Restricted_Run_Time          30\n-#define  Pragma_Restrictions                 31\n-#define  Pragma_Restriction_Warnings         32\n-#define  Pragma_Reviewable                   33\n-#define  Pragma_Source_File_Name             34\n-#define  Pragma_Source_File_Name_Project     35\n-#define  Pragma_Style_Checks                 36\n-#define  Pragma_Suppress                     37\n-#define  Pragma_Suppress_Exception_Locations 38\n-#define  Pragma_Task_Dispatching_Policy      39\n-#define  Pragma_Universal_Data               40\n-#define  Pragma_Unsuppress                   41\n-#define  Pragma_Use_VADS_Size                42\n-#define  Pragma_Validity_Checks              43\n-#define  Pragma_Warnings                     44\n+#define  Pragma_Profile_Warnings             27\n+#define  Pragma_Propagate_Exceptions         28\n+#define  Pragma_Queuing_Policy               29\n+#define  Pragma_Ravenscar                    30\n+#define  Pragma_Restricted_Run_Time          31\n+#define  Pragma_Restrictions                 32\n+#define  Pragma_Restriction_Warnings         33\n+#define  Pragma_Reviewable                   34\n+#define  Pragma_Source_File_Name             35\n+#define  Pragma_Source_File_Name_Project     36\n+#define  Pragma_Style_Checks                 37\n+#define  Pragma_Suppress                     38\n+#define  Pragma_Suppress_Exception_Locations 39\n+#define  Pragma_Task_Dispatching_Policy      40\n+#define  Pragma_Universal_Data               41\n+#define  Pragma_Unsuppress                   42\n+#define  Pragma_Use_VADS_Size                43\n+#define  Pragma_Validity_Checks              44\n+#define  Pragma_Warnings                     45\n \n /* Remaining pragmas */\n \n-#define  Pragma_Abort_Defer                  45\n-#define  Pragma_All_Calls_Remote             46\n-#define  Pragma_Annotate                     47\n-#define  Pragma_Assert                       48\n-#define  Pragma_Asynchronous                 49\n-#define  Pragma_Atomic                       50\n-#define  Pragma_Atomic_Components            51\n-#define  Pragma_Attach_Handler               52\n-#define  Pragma_Comment                      53\n-#define  Pragma_Common_Object                54\n-#define  Pragma_Complex_Representation       55\n-#define  Pragma_Controlled                   56\n-#define  Pragma_Convention                   57\n-#define  Pragma_CPP_Class                    58\n-#define  Pragma_CPP_Constructor              59\n-#define  Pragma_CPP_Virtual                  60\n-#define  Pragma_CPP_Vtable                   61\n-#define  Pragma_Debug                        62\n-#define  Pragma_Elaborate                    63\n-#define  Pragma_Elaborate_All                64\n-#define  Pragma_Elaborate_Body               65\n-#define  Pragma_Export                       66\n-#define  Pragma_Export_Exception             67\n-#define  Pragma_Export_Function              68\n-#define  Pragma_Export_Object                69\n-#define  Pragma_Export_Procedure             70\n-#define  Pragma_Export_Value                 71\n-#define  Pragma_Export_Valued_Procedure      72\n-#define  Pragma_External                     73\n-#define  Pragma_Finalize_Storage_Only        74\n-#define  Pragma_Ident                        75\n-#define  Pragma_Import                       76\n-#define  Pragma_Import_Exception             77\n-#define  Pragma_Import_Function              78\n-#define  Pragma_Import_Object                79\n-#define  Pragma_Import_Procedure             80\n-#define  Pragma_Import_Valued_Procedure      81\n-#define  Pragma_Inline                       82\n-#define  Pragma_Inline_Always                83\n-#define  Pragma_Inline_Generic               84\n-#define  Pragma_Inspection_Point             85\n-#define  Pragma_Interface                    86\n-#define  Pragma_Interface_Name               87\n-#define  Pragma_Interrupt_Handler            88\n-#define  Pragma_Interrupt_Priority           89\n-#define  Pragma_Java_Constructor             90\n-#define  Pragma_Java_Interface               91\n-#define  Pragma_Keep_Names                   92\n-#define  Pragma_Link_With                    93\n-#define  Pragma_Linker_Alias                 94\n-#define  Pragma_Linker_Options               95\n-#define  Pragma_Linker_Section               96\n-#define  Pragma_List                         97\n-#define  Pragma_Machine_Attribute            98\n-#define  Pragma_Main                         99\n-#define  Pragma_Main_Storage                100\n-#define  Pragma_Memory_Size                 101\n-#define  Pragma_No_Return                   102\n-#define  Pragma_Obsolescent                 103\n-#define  Pragma_Optimize                    104\n-#define  Pragma_Optional_Overriding         105\n-#define  Pragma_Overriding                  106\n-#define  Pragma_Pack                        107\n-#define  Pragma_Page                        108\n-#define  Pragma_Passive                     109\n-#define  Pragma_Preelaborate                110\n-#define  Pragma_Priority                    111\n-#define  Pragma_Psect_Object                112\n-#define  Pragma_Pure                        113\n-#define  Pragma_Pure_Function               114\n-#define  Pragma_Remote_Call_Interface       115\n-#define  Pragma_Remote_Types                116\n-#define  Pragma_Share_Generic               117\n-#define  Pragma_Shared                      118\n-#define  Pragma_Shared_Passive              119\n-#define  Pragma_Source_Reference            120\n-#define  Pragma_Stream_Convert              121\n-#define  Pragma_Subtitle                    122\n-#define  Pragma_Suppress_All                123\n-#define  Pragma_Suppress_Debug_Info         124\n-#define  Pragma_Suppress_Initialization     125\n-#define  Pragma_System_Name                 126\n-#define  Pragma_Task_Info                   127\n-#define  Pragma_Task_Name                   128\n-#define  Pragma_Task_Storage                129\n-#define  Pragma_Thread_Body                 130\n-#define  Pragma_Time_Slice                  131\n-#define  Pragma_Title                       132\n-#define  Pragma_Unchecked_Union             133\n-#define  Pragma_Unimplemented_Unit          134\n-#define  Pragma_Unreferenced                135\n-#define  Pragma_Unreserve_All_Interrupts    136\n-#define  Pragma_Volatile                    137\n-#define  Pragma_Volatile_Components         138\n-#define  Pragma_Weak_External               139\n+#define  Pragma_Abort_Defer                  46\n+#define  Pragma_All_Calls_Remote             47\n+#define  Pragma_Annotate                     48\n+#define  Pragma_Assert                       49\n+#define  Pragma_Asynchronous                 50\n+#define  Pragma_Atomic                       51\n+#define  Pragma_Atomic_Components            52\n+#define  Pragma_Attach_Handler               53\n+#define  Pragma_Comment                      54\n+#define  Pragma_Common_Object                55\n+#define  Pragma_Complex_Representation       56\n+#define  Pragma_Controlled                   57\n+#define  Pragma_Convention                   58\n+#define  Pragma_CPP_Class                    59\n+#define  Pragma_CPP_Constructor              60\n+#define  Pragma_CPP_Virtual                  61\n+#define  Pragma_CPP_Vtable                   62\n+#define  Pragma_Debug                        63\n+#define  Pragma_Elaborate                    64\n+#define  Pragma_Elaborate_All                65\n+#define  Pragma_Elaborate_Body               66\n+#define  Pragma_Export                       67\n+#define  Pragma_Export_Exception             68\n+#define  Pragma_Export_Function              69\n+#define  Pragma_Export_Object                70\n+#define  Pragma_Export_Procedure             71\n+#define  Pragma_Export_Value                 72\n+#define  Pragma_Export_Valued_Procedure      73\n+#define  Pragma_External                     74\n+#define  Pragma_Finalize_Storage_Only        75\n+#define  Pragma_Ident                        76\n+#define  Pragma_Import                       77\n+#define  Pragma_Import_Exception             78\n+#define  Pragma_Import_Function              79\n+#define  Pragma_Import_Object                80\n+#define  Pragma_Import_Procedure             81\n+#define  Pragma_Import_Valued_Procedure      82\n+#define  Pragma_Inline                       83\n+#define  Pragma_Inline_Always                84\n+#define  Pragma_Inline_Generic               85\n+#define  Pragma_Inspection_Point             86\n+#define  Pragma_Interface                    87\n+#define  Pragma_Interface_Name               88\n+#define  Pragma_Interrupt_Handler            89\n+#define  Pragma_Interrupt_Priority           90\n+#define  Pragma_Java_Constructor             91\n+#define  Pragma_Java_Interface               92\n+#define  Pragma_Keep_Names                   93\n+#define  Pragma_Link_With                    94\n+#define  Pragma_Linker_Alias                 95\n+#define  Pragma_Linker_Options               96\n+#define  Pragma_Linker_Section               97\n+#define  Pragma_List                         98\n+#define  Pragma_Machine_Attribute            99\n+#define  Pragma_Main                        100\n+#define  Pragma_Main_Storage                101\n+#define  Pragma_Memory_Size                 102\n+#define  Pragma_No_Return                   103\n+#define  Pragma_Obsolescent                 104\n+#define  Pragma_Optimize                    105\n+#define  Pragma_Optional_Overriding         106\n+#define  Pragma_Overriding                  107\n+#define  Pragma_Pack                        108\n+#define  Pragma_Page                        109\n+#define  Pragma_Passive                     110\n+#define  Pragma_Preelaborate                111\n+#define  Pragma_Priority                    112\n+#define  Pragma_Psect_Object                113\n+#define  Pragma_Pure                        114\n+#define  Pragma_Pure_Function               115\n+#define  Pragma_Remote_Call_Interface       116\n+#define  Pragma_Remote_Types                117\n+#define  Pragma_Share_Generic               118\n+#define  Pragma_Shared                      119\n+#define  Pragma_Shared_Passive              120\n+#define  Pragma_Source_Reference            121\n+#define  Pragma_Stream_Convert              122\n+#define  Pragma_Subtitle                    123\n+#define  Pragma_Suppress_All                124\n+#define  Pragma_Suppress_Debug_Info         125\n+#define  Pragma_Suppress_Initialization     126\n+#define  Pragma_System_Name                 127\n+#define  Pragma_Task_Info                   128\n+#define  Pragma_Task_Name                   129\n+#define  Pragma_Task_Storage                130\n+#define  Pragma_Thread_Body                 131\n+#define  Pragma_Time_Slice                  132\n+#define  Pragma_Title                       133\n+#define  Pragma_Unchecked_Union             134\n+#define  Pragma_Unimplemented_Unit          135\n+#define  Pragma_Unreferenced                136\n+#define  Pragma_Unreserve_All_Interrupts    137\n+#define  Pragma_Volatile                    138\n+#define  Pragma_Volatile_Components         139\n+#define  Pragma_Weak_External               140\n \n /* The following are deliberately out of alphabetical order, see Snames */\n \n-#define  Pragma_AST_Entry                   140\n-#define  Pragma_Storage_Size                141\n-#define  Pragma_Storage_Unit                142\n+#define  Pragma_AST_Entry                   141\n+#define  Pragma_Storage_Size                142\n+#define  Pragma_Storage_Unit                143\n \n /* Define the numeric values for the conventions.  */\n "}, {"sha": "2151706bc432ff7daff881be3c0a63d03ca8f676", "filename": "gcc/ada/symbols-vms-alpha.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsymbols-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Fsymbols-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-vms-alpha.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -718,8 +718,7 @@ package body Symbols is\n             Put (File, Case_Sensitive);\n             Put_Line (File, \"yes\");\n \n-            --  Put a line in the symbol file for each symbol in the symbol\n-            --  table.\n+            --  Put a line in the symbol file for each symbol in symbol table\n \n             for Index in 1 .. Symbol_Table.Last (Original_Symbols) loop\n                if Original_Symbols.Table (Index).Present then"}, {"sha": "6918d990c3ba9e9c856af9a27970fae0ed36aa02", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -152,6 +152,33 @@ package body Targparm is\n       HIM_Str'Access,\n       LSI_Str'Access);\n \n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Set_Profile_Restrictions (P : Profile_Name);\n+   --  Set Restrictions_On_Target for the given profile\n+\n+   ------------------------------\n+   -- Set_Profile_Restrictions --\n+   ------------------------------\n+\n+   procedure Set_Profile_Restrictions (P : Profile_Name) is\n+      R : Restriction_Flags  renames Profile_Info (P).Set;\n+      V : Restriction_Values renames Profile_Info (P).Value;\n+\n+   begin\n+      for J in R'Range loop\n+         if R (J) then\n+            Restrictions_On_Target.Set (J) := True;\n+\n+            if J in All_Parameter_Restrictions then\n+               Restrictions_On_Target.Value (J) := V (J);\n+            end if;\n+         end if;\n+      end loop;\n+   end Set_Profile_Restrictions;\n+\n    ---------------------------\n    -- Get_Target_Parameters --\n    ---------------------------\n@@ -215,6 +242,26 @@ package body Targparm is\n          if System_Text (P) = '-' then\n             goto Line_Loop_Continue;\n \n+         --  Test for pragma Profile (Ravenscar);\n+\n+         elsif System_Text (P .. P + 26) =\n+                 \"pragma Profile (Ravenscar);\"\n+         then\n+            Set_Profile_Restrictions (Ravenscar);\n+            Opt.Task_Dispatching_Policy := 'F';\n+            Opt.Locking_Policy     := 'C';\n+            P := P + 27;\n+            goto Line_Loop_Continue;\n+\n+         --  Test for pragma Profile (Restricted);\n+\n+         elsif System_Text (P .. P + 27) =\n+                 \"pragma Profile (Restricted);\"\n+         then\n+            Set_Profile_Restrictions (Restricted);\n+            P := P + 28;\n+            goto Line_Loop_Continue;\n+\n          --  Test for pragma Restrictions\n \n          elsif System_Text (P .. P + 20) = \"pragma Restrictions (\" then"}, {"sha": "48c1469b25d2bf139fc355349692c98a838f5880", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc335f4371177761ce88a58a7d5e710f202635fb/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=cc335f4371177761ce88a58a7d5e710f202635fb", "patch": "@@ -104,6 +104,9 @@ package Targparm is\n    --  if a pragma Suppress_Exception_Locations appears, then the flag\n    --  Opt.Exception_Locations_Suppressed is set to True.\n \n+   --  If a pragma Profile with a valid profile argument appears, then\n+   --  the appropriate restrictions and policy flags are set.\n+\n    --  The only other pragma allowed is a pragma Restrictions that specifies\n    --  a restriction that will be imposed on all units in the partition. Note\n    --  that in this context, only one restriction can be specified in a single\n@@ -112,6 +115,8 @@ package Targparm is\n    Restrictions_On_Target : Restrictions_Info;\n    --  Records restrictions specified by system.ads. Only the Set and Value\n    --  members are modified. The Violated and Count fields are never modified.\n+   --  Note that entries can be set either by a pragma Restrictions or by\n+   --  a pragma Profile.\n \n    -------------------\n    -- Run Time Name --"}]}