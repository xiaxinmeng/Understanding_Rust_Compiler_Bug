{"sha": "c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg4OGM5M2IyOTBhZWIzZjdlYjU1NmJkNWI3ZWQ0Zjc1NjRjODIyYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-01-19T06:55:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-01-19T06:55:53Z"}, "message": "re PR c++/25836 (G++ does not allow a conversion of templated types)\n\n\tPR c++/25836\n\t* cp-tree.h (push_class_stack): New function.\n\t(pop_class_stack): Likewise.\n\t* class.c (class_stack_node): Add hidden field.\n\t(pushclass): Clear it.\n\t(push_class_stack): New function.\n\t(pop_class_stack): Likewise.\n\t(currently_open_class): Ignore hidden classes.\n\t(currently_open_derived_class): Likewise.\n\t* name-lookup.c (push_to_top_level): Call push_class_stack.\n\t(pop_from_top_level): Call pop_class_stack.\n\tPR c++/25836\n\t* g++.dg/template/init6.C: New test.\n\nFrom-SVN: r109945", "tree": {"sha": "7783dc30a654ed3f4012aa97244eb51ffd2fa604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7783dc30a654ed3f4012aa97244eb51ffd2fa604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/comments", "author": null, "committer": null, "parents": [{"sha": "e79b9d54a17db3d8676ae30c1f04e90e90691cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79b9d54a17db3d8676ae30c1f04e90e90691cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79b9d54a17db3d8676ae30c1f04e90e90691cec"}], "stats": {"total": 108, "additions": 98, "deletions": 10}, "files": [{"sha": "b386ef4e66fd7682fb3487d958af474db7fb27e2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "patch": "@@ -1,3 +1,17 @@\n+2006-01-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25836\n+\t* cp-tree.h (push_class_stack): New function.\n+\t(pop_class_stack): Likewise.\n+\t* class.c (class_stack_node): Add hidden field.\n+\t(pushclass): Clear it.\n+\t(push_class_stack): New function.\n+\t(pop_class_stack): Likewise.\n+\t(currently_open_class): Ignore hidden classes.\n+\t(currently_open_derived_class): Likewise.\n+\t* name-lookup.c (push_to_top_level): Call push_class_stack.\n+\t(pop_from_top_level): Call pop_class_stack.\n+\n 2006-01-18  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree.c (find_tree_t, find_tree): Remove."}, {"sha": "bd89b558abda430f7c24b7dc2f5cebdc3d59d906", "filename": "gcc/cp/class.c", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "patch": "@@ -60,6 +60,10 @@ typedef struct class_stack_node {\n \n   /* If were defining TYPE, the names used in this class.  */\n   splay_tree names_used;\n+\n+  /* Nonzero if this class is no longer open, because of a call to\n+     push_to_top_level.  */\n+  size_t hidden;\n }* class_stack_node_t;\n \n typedef struct vtbl_init_data_s\n@@ -5387,6 +5391,8 @@ restore_class_cache (void)\n void\n pushclass (tree type)\n {\n+  class_stack_node_t csn;\n+\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* Make sure there is enough room for the new entry on the stack.  */\n@@ -5399,10 +5405,12 @@ pushclass (tree type)\n     }\n \n   /* Insert a new entry on the class stack.  */\n-  current_class_stack[current_class_depth].name = current_class_name;\n-  current_class_stack[current_class_depth].type = current_class_type;\n-  current_class_stack[current_class_depth].access = current_access_specifier;\n-  current_class_stack[current_class_depth].names_used = 0;\n+  csn = current_class_stack + current_class_depth;\n+  csn->name = current_class_name;\n+  csn->type = current_class_type;\n+  csn->access = current_access_specifier;\n+  csn->names_used = 0;\n+  csn->hidden = 0;\n   current_class_depth++;\n \n   /* Now set up the new type.  */\n@@ -5459,6 +5467,24 @@ popclass (void)\n     splay_tree_delete (current_class_stack[current_class_depth].names_used);\n }\n \n+/* Mark the top of the class stack as hidden.  */\n+\n+void\n+push_class_stack (void)\n+{\n+  if (current_class_depth)\n+    ++current_class_stack[current_class_depth - 1].hidden;\n+}\n+\n+/* Mark the top of the class stack as un-hidden.  */\n+\n+void\n+pop_class_stack (void)\n+{\n+  if (current_class_depth)\n+    --current_class_stack[current_class_depth - 1].hidden;\n+}\n+\n /* Returns 1 if current_class_type is either T or a nested type of T.\n    We start looking from 1 because entry 0 is from global scope, and has\n    no type.  */\n@@ -5469,10 +5495,14 @@ currently_open_class (tree t)\n   int i;\n   if (current_class_type && same_type_p (t, current_class_type))\n     return 1;\n-  for (i = 1; i < current_class_depth; ++i)\n-    if (current_class_stack[i].type\n-\t&& same_type_p (current_class_stack [i].type, t))\n-      return 1;\n+  for (i = current_class_depth - 1; i > 0; --i)\n+    {\n+      if (current_class_stack[i].hidden)\n+\tbreak;\n+      if (current_class_stack[i].type\n+\t  && same_type_p (current_class_stack [i].type, t))\n+\treturn 1;\n+    }\n   return 0;\n }\n \n@@ -5496,8 +5526,12 @@ currently_open_derived_class (tree t)\n     return current_class_type;\n \n   for (i = current_class_depth - 1; i > 0; --i)\n-    if (DERIVED_FROM_P (t, current_class_stack[i].type))\n-      return current_class_stack[i].type;\n+    {\n+      if (current_class_stack[i].hidden)\n+\tbreak;\n+      if (DERIVED_FROM_P (t, current_class_stack[i].type))\n+\treturn current_class_stack[i].type;\n+    }\n \n   return NULL_TREE;\n }"}, {"sha": "1c66e11aedc784870b3a47f9538f80856f2f3466", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "patch": "@@ -3748,6 +3748,8 @@ extern tree cp_fold_obj_type_ref\t\t(tree, tree);\n extern void set_linkage_according_to_type\t(tree, tree);\n extern void determine_key_method\t\t(tree);\n extern void check_for_override\t\t\t(tree, tree);\n+extern void push_class_stack                    (void);\n+extern void pop_class_stack                     (void);\n \n /* in cvt.c */\n extern tree convert_to_reference\t\t(tree, tree, int, int, tree);"}, {"sha": "02fc27277a310912c9aad7a8c20b129b434b6d3d", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "patch": "@@ -4938,6 +4938,7 @@ push_to_top_level (void)\n   current_lang_base = VEC_alloc (tree, gc, 10);\n   current_lang_name = lang_name_cplusplus;\n   current_namespace = global_namespace;\n+  push_class_stack ();\n   skip_evaluation = 0;\n   timevar_pop (TV_NAME_LOOKUP);\n }\n@@ -4953,6 +4954,7 @@ pop_from_top_level (void)\n   /* Clear out class-level bindings cache.  */\n   if (previous_class_level)\n     invalidate_class_lookup_cache ();\n+  pop_class_stack ();\n \n   current_lang_base = 0;\n "}, {"sha": "62deedaff30ae00b544737fe262328c7ca15e1ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "patch": "@@ -1,3 +1,8 @@\n+2006-01-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25836\n+\t* g++.dg/template/init6.C: New test.\n+\n 2006-01-18  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* gcc.dg/tree-ssa/pr24287.c: New test"}, {"sha": "143746642fcb1df1e85dff50f28dd9d8100d6f35", "filename": "gcc/testsuite/g++.dg/template/init6.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finit6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c888c93b290aeb3f7eb556bd5b7ed4f7564c822a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finit6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finit6.C?ref=c888c93b290aeb3f7eb556bd5b7ed4f7564c822a", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/25836\n+\n+template <class T>\n+class Iter {};\n+\n+template <class T>\n+class SubIter : public Iter<T> {\n+  void insert(T);\n+};\n+\n+class GraphBase {\n+public:\n+  class Node;\n+};\n+\n+template<class T>\n+class Graph : public GraphBase {\n+  class Inner {\n+    Iter<typename Graph<T>::Node*> *get();\n+  };\n+};\n+\n+template<class T>\n+Iter<typename Graph<T>::Node*> *Graph<T>::Inner::get() {\n+  SubIter<typename Graph<T>::Node*> *iter;\n+  iter->insert(0);\n+}\n+\n+int main() {\n+  Iter<Graph<int>::Node*> *n2_iter = new SubIter<Graph<int>::Node*>();\n+}"}]}