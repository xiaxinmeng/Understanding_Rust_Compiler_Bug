{"sha": "40b178f44696219fb4781f1f555eb7962fbcd401", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiMTc4ZjQ0Njk2MjE5ZmI0NzgxZjFmNTU1ZWI3OTYyZmJjZDQwMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-09-12T14:46:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-09-12T14:46:22Z"}, "message": "re PR tree-optimization/54489 (tree FRE uses an excessive amount of memory)\n\n2012-09-12  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/54489\n\t* tree-ssa-pre.c: Include domwalk.h.\n\t(in_fre): Remove.\n\t(sccvn_valnum_from_value_id): New function.\n\t(debug_bitmap_sets_for): Simplify.\n\t(get_representative_for): Properly initialize the SCCVN valnum.\n\t(create_expression_by_pieces): Likewise.\n\t(insert_into_preds_of_block): Likewise.\n\t(can_PRE_operation): Remove.\n\t(make_values_for_phi): Simplify.\n\t(compute_avail): Likewise.\n\t(do_SCCVN_insertion): Remove.\n\t(eliminate_avail, eliminate_push_avail, eliminate_insert):\n\tNew functions.\n\t(eliminate): Split and perform a domwalk.\n\t(eliminate_bb): Former eliminate part that is now dom-enter.\n\t(eliminate_leave_block): New function.\n\t(fini_eliminate): Likewise.\n\t(init_pre): Simplify.\n\t(fini_pre): Likewise.\n\t(execute_pre): Fold into do_pre and do_fre.\n\t(do_pre): Consume execute_pre.\n\t(do_fre): Likewise.\n\t* Makefile.in (tree-ssa-pre.o): Add domwalk.h dependency.\n\nFrom-SVN: r191225", "tree": {"sha": "75f427c396cf952039512fc27fcfae7107035c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75f427c396cf952039512fc27fcfae7107035c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40b178f44696219fb4781f1f555eb7962fbcd401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b178f44696219fb4781f1f555eb7962fbcd401", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b178f44696219fb4781f1f555eb7962fbcd401", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b178f44696219fb4781f1f555eb7962fbcd401/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0dadc27181235760099ae5c87a48b46b22b65d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dadc27181235760099ae5c87a48b46b22b65d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dadc27181235760099ae5c87a48b46b22b65d8b"}], "stats": {"total": 1045, "additions": 565, "deletions": 480}, "files": [{"sha": "fe066e7aa6a34a6714568793185b101754f9a4fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b178f44696219fb4781f1f555eb7962fbcd401/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b178f44696219fb4781f1f555eb7962fbcd401/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40b178f44696219fb4781f1f555eb7962fbcd401", "patch": "@@ -1,3 +1,30 @@\n+2012-09-12  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/54489\n+\t* tree-ssa-pre.c: Include domwalk.h.\n+\t(in_fre): Remove.\n+\t(sccvn_valnum_from_value_id): New function.\n+\t(debug_bitmap_sets_for): Simplify.\n+\t(get_representative_for): Properly initialize the SCCVN valnum.\n+\t(create_expression_by_pieces): Likewise.\n+\t(insert_into_preds_of_block): Likewise.\n+\t(can_PRE_operation): Remove.\n+\t(make_values_for_phi): Simplify.\n+\t(compute_avail): Likewise.\n+\t(do_SCCVN_insertion): Remove.\n+\t(eliminate_avail, eliminate_push_avail, eliminate_insert):\n+\tNew functions.\n+\t(eliminate): Split and perform a domwalk.\n+\t(eliminate_bb): Former eliminate part that is now dom-enter.\n+\t(eliminate_leave_block): New function.\n+\t(fini_eliminate): Likewise.\n+\t(init_pre): Simplify.\n+\t(fini_pre): Likewise.\n+\t(execute_pre): Fold into do_pre and do_fre.\n+\t(do_pre): Consume execute_pre.\n+\t(do_fre): Likewise.\n+\t* Makefile.in (tree-ssa-pre.o): Add domwalk.h dependency.\n+\n 2012-09-12  Diego Novillo  <dnovillo@google.com>\n \n \t* vec.h: Remove compatibility notes for previous distinction"}, {"sha": "fc9a37d5e77826a1fb3c0fd83e21b4adc5a6b725", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b178f44696219fb4781f1f555eb7962fbcd401/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b178f44696219fb4781f1f555eb7962fbcd401/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=40b178f44696219fb4781f1f555eb7962fbcd401", "patch": "@@ -2317,7 +2317,7 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(FLAGS_H) langhooks.h \\\n    $(CFGLOOP_H) alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASH_TABLE_H) \\\n    $(GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \\\n-   $(DBGCNT_H) tree-scalar-evolution.h $(GIMPLE_PRETTY_PRINT_H)\n+   $(DBGCNT_H) tree-scalar-evolution.h $(GIMPLE_PRETTY_PRINT_H) domwalk.h\n tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n    $(TM_H) coretypes.h dumpfile.h $(FLAGS_H) $(CFGLOOP_H) \\"}, {"sha": "64dedb16842f4aaa9e23b1dc315d9f0dcf4fec8f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 537, "deletions": 479, "changes": 1016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b178f44696219fb4781f1f555eb7962fbcd401/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b178f44696219fb4781f1f555eb7962fbcd401/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=40b178f44696219fb4781f1f555eb7962fbcd401", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"params.h\"\n #include \"dbgcnt.h\"\n+#include \"domwalk.h\"\n \n /* TODO:\n \n@@ -351,8 +352,6 @@ get_or_alloc_expr_for_name (tree name)\n   return result;\n }\n \n-static bool in_fre = false;\n-\n /* An unordered bitmap set.  One bitmap tracks values, the other,\n    expressions.  */\n typedef struct bitmap_set\n@@ -637,6 +636,25 @@ get_expr_value_id (pre_expr expr)\n     }\n }\n \n+/* Return a SCCVN valnum (SSA name or constant) for the PRE value-id VAL.  */\n+\n+static tree\n+sccvn_valnum_from_value_id (unsigned int val)\n+{\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  bitmap exprset = VEC_index (bitmap, value_expressions, val);\n+  EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n+    {\n+      pre_expr vexpr = expression_for_id (i);\n+      if (vexpr->kind == NAME)\n+\treturn VN_INFO (PRE_EXPR_NAME (vexpr))->valnum;\n+      else if (vexpr->kind == CONSTANT)\n+\treturn PRE_EXPR_CONSTANT (vexpr);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Remove an expression EXPR from a bitmapped set.  */\n \n static void\n@@ -1022,16 +1040,13 @@ DEBUG_FUNCTION void\n debug_bitmap_sets_for (basic_block bb)\n {\n   print_bitmap_set (stderr, AVAIL_OUT (bb), \"avail_out\", bb->index);\n-  if (!in_fre)\n-    {\n-      print_bitmap_set (stderr, EXP_GEN (bb), \"exp_gen\", bb->index);\n-      print_bitmap_set (stderr, PHI_GEN (bb), \"phi_gen\", bb->index);\n-      print_bitmap_set (stderr, TMP_GEN (bb), \"tmp_gen\", bb->index);\n-      print_bitmap_set (stderr, ANTIC_IN (bb), \"antic_in\", bb->index);\n-      if (do_partial_partial)\n-\tprint_bitmap_set (stderr, PA_IN (bb), \"pa_in\", bb->index);\n-      print_bitmap_set (stderr, NEW_SETS (bb), \"new_sets\", bb->index);\n-    }\n+  print_bitmap_set (stderr, EXP_GEN (bb), \"exp_gen\", bb->index);\n+  print_bitmap_set (stderr, PHI_GEN (bb), \"phi_gen\", bb->index);\n+  print_bitmap_set (stderr, TMP_GEN (bb), \"tmp_gen\", bb->index);\n+  print_bitmap_set (stderr, ANTIC_IN (bb), \"antic_in\", bb->index);\n+  if (do_partial_partial)\n+    print_bitmap_set (stderr, PA_IN (bb), \"pa_in\", bb->index);\n+  print_bitmap_set (stderr, NEW_SETS (bb), \"new_sets\", bb->index);\n }\n \n /* Print out the expressions that have VAL to OUTFILE.  */\n@@ -1402,11 +1417,9 @@ get_representative_for (const pre_expr e)\n      that we will return.  */\n   name = make_temp_ssa_name (get_expr_type (e), gimple_build_nop (), \"pretmp\");\n   VN_INFO_GET (name)->value_id = value_id;\n-  if (e->kind == CONSTANT)\n-    VN_INFO (name)->valnum = PRE_EXPR_CONSTANT (e);\n-  else\n+  VN_INFO (name)->valnum = sccvn_valnum_from_value_id (value_id);\n+  if (VN_INFO (name)->valnum == NULL_TREE)\n     VN_INFO (name)->valnum = name;\n-\n   add_to_value (value_id, get_or_alloc_expr_for_name (name));\n   if (dump_file)\n     {\n@@ -2563,23 +2576,6 @@ compute_antic (void)\n   sbitmap_free (changed_blocks);\n }\n \n-/* Return true if OP is a tree which we can perform PRE on.\n-   This may not match the operations we can value number, but in\n-   a perfect world would.  */\n-\n-static bool\n-can_PRE_operation (tree op)\n-{\n-  return UNARY_CLASS_P (op)\n-    || BINARY_CLASS_P (op)\n-    || COMPARISON_CLASS_P (op)\n-    || TREE_CODE (op) == MEM_REF \n-    || TREE_CODE (op) == COMPONENT_REF\n-    || TREE_CODE (op) == VIEW_CONVERT_EXPR\n-    || TREE_CODE (op) == CALL_EXPR\n-    || TREE_CODE (op) == ARRAY_REF;\n-}\n-\n \n /* Inserted expressions are placed onto this worklist, which is used\n    for performing quick dead code elimination of insertions we made\n@@ -3072,8 +3068,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t      VN_INFO (forcedname)->value_id = get_next_value_id ();\n \t      nameexpr = get_or_alloc_expr_for_name (forcedname);\n \t      add_to_value (VN_INFO (forcedname)->value_id, nameexpr);\n-\t      if (!in_fre)\n-\t\tbitmap_value_replace_in_set (NEW_SETS (block), nameexpr);\n+\t      bitmap_value_replace_in_set (NEW_SETS (block), nameexpr);\n \t      bitmap_value_replace_in_set (AVAIL_OUT (block), nameexpr);\n \t    }\n \t}\n@@ -3097,9 +3092,12 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n      we are creating the expression by pieces, and this particular piece of\n      the expression may have been represented.  There is no harm in replacing\n      here.  */\n-  VN_INFO_GET (name)->valnum = name;\n   value_id = get_expr_value_id (expr);\n-  VN_INFO (name)->value_id = value_id;\n+  VN_INFO_GET (name)->value_id = value_id;\n+  VN_INFO (name)->valnum = sccvn_valnum_from_value_id (value_id);\n+  if (VN_INFO (name)->valnum == NULL_TREE)\n+    VN_INFO (name)->valnum = name;\n+  gcc_assert (VN_INFO (name)->valnum != NULL_TREE);\n   nameexpr = get_or_alloc_expr_for_name (name);\n   add_to_value (value_id, nameexpr);\n   if (NEW_SETS (block))\n@@ -3339,9 +3337,11 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   phi = create_phi_node (temp, block);\n \n   gimple_set_plf (phi, NECESSARY, false);\n-  VN_INFO_GET (gimple_phi_result (phi))->valnum = gimple_phi_result (phi);\n-  VN_INFO (gimple_phi_result (phi))->value_id = val;\n-  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (gimple_phi_result (phi)));\n+  VN_INFO_GET (temp)->value_id = val;\n+  VN_INFO (temp)->valnum = sccvn_valnum_from_value_id (val);\n+  if (VN_INFO (temp)->valnum == NULL_TREE)\n+    VN_INFO (temp)->valnum = temp;\n+  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (temp));\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     {\n       pre_expr ae = VEC_index (pre_expr, avail, pred->dest_idx);\n@@ -3353,7 +3353,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \tadd_phi_arg (phi, PRE_EXPR_NAME (ae), pred, UNKNOWN_LOCATION);\n     }\n \n-  newphi = get_or_alloc_expr_for_name (gimple_phi_result (phi));\n+  newphi = get_or_alloc_expr_for_name (temp);\n   add_to_value (val, newphi);\n \n   /* The value should *not* exist in PHI_GEN, or else we wouldn't be doing\n@@ -3782,8 +3782,6 @@ add_to_exp_gen (basic_block block, tree op)\n {\n   pre_expr result;\n \n-  gcc_checking_assert (!in_fre);\n-\n   if (TREE_CODE (op) == SSA_NAME && ssa_undefined_value_p (op))\n     return;\n \n@@ -3797,6 +3795,7 @@ static void\n make_values_for_phi (gimple phi, basic_block block)\n {\n   tree result = gimple_phi_result (phi);\n+  unsigned i;\n \n   /* We have no need for virtual phis, as they don't represent\n      actual computations.  */\n@@ -3806,18 +3805,14 @@ make_values_for_phi (gimple phi, basic_block block)\n   pre_expr e = get_or_alloc_expr_for_name (result);\n   add_to_value (get_expr_value_id (e), e);\n   bitmap_value_insert_into_set (AVAIL_OUT (block), e);\n-  if (!in_fre)\n+  bitmap_insert_into_set (PHI_GEN (block), e);\n+  for (i = 0; i < gimple_phi_num_args (phi); ++i)\n     {\n-      unsigned i;\n-      bitmap_insert_into_set (PHI_GEN (block), e);\n-      for (i = 0; i < gimple_phi_num_args (phi); ++i)\n+      tree arg = gimple_phi_arg_def (phi, i);\n+      if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  tree arg = gimple_phi_arg_def (phi, i);\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      e = get_or_alloc_expr_for_name (arg);\n-\t      add_to_value (get_expr_value_id (e), e);\n-\t    }\n+\t  e = get_or_alloc_expr_for_name (arg);\n+\t  add_to_value (get_expr_value_id (e), e);\n \t}\n     }\n }\n@@ -3855,8 +3850,7 @@ compute_avail (void)\n \n       e = get_or_alloc_expr_for_name (name);\n       add_to_value (get_expr_value_id (e), e);\n-      if (!in_fre)\n-\tbitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), e);\n+      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), e);\n       bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), e);\n     }\n \n@@ -3924,15 +3918,10 @@ compute_avail (void)\n \t      pre_expr e = get_or_alloc_expr_for_name (op);\n \n \t      add_to_value (get_expr_value_id (e), e);\n-\t      if (!in_fre)\n-\t\tbitmap_insert_into_set (TMP_GEN (block), e);\n+\t      bitmap_insert_into_set (TMP_GEN (block), e);\n \t      bitmap_value_insert_into_set (AVAIL_OUT (block), e);\n \t    }\n \n-\t  /* That's all we need to do when doing FRE.  */\n-\t  if (in_fre)\n-\t    continue;\n-\n \t  if (gimple_has_side_effects (stmt) || stmt_could_throw_p (stmt))\n \t    continue;\n \n@@ -4123,407 +4112,471 @@ compute_avail (void)\n   free (worklist);\n }\n \n-/* Insert the expression for SSA_VN that SCCVN thought would be simpler\n-   than the available expressions for it.  The insertion point is\n-   right before the first use in STMT.  Returns the SSA_NAME that should\n-   be used for replacement.  */\n+\n+/* Local state for the eliminate domwalk.  */\n+static VEC (gimple, heap) *el_to_remove;\n+static VEC (gimple, heap) *el_to_update;\n+static unsigned int el_todo;\n+static VEC (tree, heap) *el_avail;\n+static VEC (tree, heap) *el_avail_stack;\n+\n+/* Return a leader for OP that is available at the current point of the\n+   eliminate domwalk.  */\n \n static tree\n-do_SCCVN_insertion (gimple stmt, tree ssa_vn)\n+eliminate_avail (tree op)\n {\n-  basic_block bb = gimple_bb (stmt);\n-  gimple_stmt_iterator gsi;\n-  gimple_seq stmts = NULL;\n-  tree expr;\n-  pre_expr e;\n+  tree valnum = VN_INFO (op)->valnum;\n+  if (TREE_CODE (valnum) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IS_DEFAULT_DEF (valnum))\n+\treturn valnum;\n+      if (VEC_length (tree, el_avail) > SSA_NAME_VERSION (valnum))\n+\treturn VEC_index (tree, el_avail, SSA_NAME_VERSION (valnum));\n+    }\n+  else if (is_gimple_min_invariant (valnum))\n+    return valnum;\n+  return NULL_TREE;\n+}\n+\n+/* At the current point of the eliminate domwalk make OP available.  */\n \n-  /* First create a value expression from the expression we want\n-     to insert and associate it with the value handle for SSA_VN.  */\n-  e = get_or_alloc_expr_for (vn_get_expr_for (ssa_vn));\n-  if (e == NULL)\n+static void\n+eliminate_push_avail (tree op)\n+{\n+  tree valnum = VN_INFO (op)->valnum;\n+  if (TREE_CODE (valnum) == SSA_NAME)\n+    {\n+      if (VEC_length (tree, el_avail) <= SSA_NAME_VERSION (valnum))\n+\tVEC_safe_grow_cleared (tree, heap,\n+\t\t\t       el_avail, SSA_NAME_VERSION (valnum) + 1);\n+      VEC_replace (tree, el_avail, SSA_NAME_VERSION (valnum), op);\n+      VEC_safe_push (tree, heap, el_avail_stack, op);\n+    }\n+}\n+\n+/* Insert the expression recorded by SCCVN for VAL at *GSI.  Returns\n+   the leader for the expression if insertion was successful.  */\n+\n+static tree\n+eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n+{\n+  tree expr = vn_get_expr_for (val);\n+  if (!CONVERT_EXPR_P (expr)\n+      && TREE_CODE (expr) != VIEW_CONVERT_EXPR)\n     return NULL_TREE;\n \n-  /* Then use create_expression_by_pieces to generate a valid\n-     expression to insert at this point of the IL stream.  */\n-  expr = create_expression_by_pieces (bb, e, &stmts, stmt, NULL);\n-  if (expr == NULL_TREE)\n+  tree op = TREE_OPERAND (expr, 0);\n+  tree leader = TREE_CODE (op) == SSA_NAME ? eliminate_avail (op) : op;\n+  if (!leader)\n     return NULL_TREE;\n-  gsi = gsi_for_stmt (stmt);\n-  gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n \n-  return expr;\n+  tree res = make_temp_ssa_name (TREE_TYPE (val), NULL, \"pretmp\");\n+  gimple tem = gimple_build_assign (res,\n+\t\t\t\t    build1 (TREE_CODE (expr),\n+\t\t\t\t\t    TREE_TYPE (expr), leader));\n+  gsi_insert_before (gsi, tem, GSI_SAME_STMT);\n+  VN_INFO_GET (res)->valnum = val;\n+\n+  if (TREE_CODE (leader) == SSA_NAME)\n+    gimple_set_plf (SSA_NAME_DEF_STMT (leader), NECESSARY, true);\n+\n+  pre_stats.insertions++;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Inserted \");\n+      print_gimple_stmt (dump_file, tem, 0, 0);\n+    }\n+\n+  return res;\n }\n \n-/* Eliminate fully redundant computations.  */\n+/* Perform elimination for the basic-block B during the domwalk.  */\n \n-static unsigned int\n-eliminate (void)\n+static void\n+eliminate_bb (dom_walk_data *, basic_block b)\n {\n-  VEC (gimple, heap) *to_remove = NULL;\n-  VEC (gimple, heap) *to_update = NULL;\n-  basic_block b;\n-  unsigned int todo = 0;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n-  unsigned i;\n \n-  FOR_EACH_BB (b)\n+  /* Mark new bb.  */\n+  VEC_safe_push (tree, heap, el_avail_stack, NULL_TREE);\n+\n+  for (gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n     {\n-      for (gsi = gsi_start_bb (b); !gsi_end_p (gsi); gsi_next (&gsi))\n+      gimple stmt, phi = gsi_stmt (gsi);\n+      tree sprime = NULL_TREE, res = PHI_RESULT (phi);\n+      gimple_stmt_iterator gsi2;\n+\n+      /* We want to perform redundant PHI elimination.  Do so by\n+\t replacing the PHI with a single copy if possible.\n+\t Do not touch inserted, single-argument or virtual PHIs.  */\n+      if (gimple_phi_num_args (phi) == 1\n+\t  || virtual_operand_p (res))\n \t{\n-\t  tree lhs = NULL_TREE;\n-\t  tree rhs = NULL_TREE;\n-\n-\t  stmt = gsi_stmt (gsi);\n-\n-\t  if (gimple_has_lhs (stmt))\n-\t    lhs = gimple_get_lhs (stmt);\n-\n-\t  if (gimple_assign_single_p (stmt))\n-\t    rhs = gimple_assign_rhs1 (stmt);\n-\n-\t  /* Lookup the RHS of the expression, see if we have an\n-\t     available computation for it.  If so, replace the RHS with\n-\t     the available computation.\n-\n-\t     See PR43491.\n-\t     We don't replace global register variable when it is a the RHS of\n-\t     a single assign. We do replace local register variable since gcc\n-\t     does not guarantee local variable will be allocated in register.  */\n-\t  if (gimple_has_lhs (stmt)\n-\t      && TREE_CODE (lhs) == SSA_NAME\n-\t      && !gimple_assign_ssa_name_copy_p (stmt)\n-\t      && (!gimple_assign_single_p (stmt)\n-\t\t  || (!is_gimple_min_invariant (rhs)\n-                      && (gimple_assign_rhs_code (stmt) != VAR_DECL\n-                          || !is_global_var (rhs)\n-                          || !DECL_HARD_REGISTER (rhs))))\n-\t      && !gimple_has_volatile_ops  (stmt)\n-\t      && !has_zero_uses (lhs))\n-\t    {\n-\t      tree sprime = NULL;\n-\t      pre_expr lhsexpr = get_or_alloc_expr_for_name (lhs);\n-\t      pre_expr sprimeexpr;\n-\t      gimple orig_stmt = stmt;\n+\t  gsi_next (&gsi);\n+\t  continue;\n+\t}\n \n-\t      sprimeexpr = bitmap_find_leader (AVAIL_OUT (b),\n-\t\t\t\t\t       get_expr_value_id (lhsexpr),\n-\t\t\t\t\t       NULL);\n+      sprime = eliminate_avail (res);\n+      if (!sprime\n+\t  || sprime == res)\n+\t{\n+\t  eliminate_push_avail (res);\n+\t  gsi_next (&gsi);\n+\t  continue;\n+\t}\n+      else if (is_gimple_min_invariant (sprime))\n+\t{\n+\t  if (!useless_type_conversion_p (TREE_TYPE (res),\n+\t\t\t\t\t  TREE_TYPE (sprime)))\n+\t    sprime = fold_convert (TREE_TYPE (res), sprime);\n+\t}\n \n-\t      if (sprimeexpr)\n-\t\t{\n-\t\t  if (sprimeexpr->kind == CONSTANT)\n-\t\t    sprime = PRE_EXPR_CONSTANT (sprimeexpr);\n-\t\t  else if (sprimeexpr->kind == NAME)\n-\t\t    sprime = PRE_EXPR_NAME (sprimeexpr);\n-\t\t  else\n-\t\t    gcc_unreachable ();\n-\t\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Replaced redundant PHI node defining \");\n+\t  print_generic_expr (dump_file, res, 0);\n+\t  fprintf (dump_file, \" with \");\n+\t  print_generic_expr (dump_file, sprime, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n \n-\t      /* If there is no existing leader but SCCVN knows this\n-\t\t value is constant, use that constant.  */\n-\t      if (!sprime && is_gimple_min_invariant (VN_INFO (lhs)->valnum))\n-\t\t{\n-\t\t  sprime = VN_INFO (lhs)->valnum;\n-\t\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n-\t\t\t\t\t\t  TREE_TYPE (sprime)))\n-\t\t    sprime = fold_convert (TREE_TYPE (lhs), sprime);\n+      remove_phi_node (&gsi, false);\n+\n+      if (inserted_exprs\n+\t  && !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res))\n+\t  && TREE_CODE (sprime) == SSA_NAME)\n+\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n+\n+      if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n+\tsprime = fold_convert (TREE_TYPE (res), sprime);\n+      stmt = gimple_build_assign (res, sprime);\n+      SSA_NAME_DEF_STMT (res) = stmt;\n+      gimple_set_plf (stmt, NECESSARY, gimple_plf (phi, NECESSARY));\n+\n+      gsi2 = gsi_after_labels (b);\n+      gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n+      /* Queue the copy for eventual removal.  */\n+      VEC_safe_push (gimple, heap, el_to_remove, stmt);\n+      /* If we inserted this PHI node ourself, it's not an elimination.  */\n+      if (inserted_exprs\n+\t  && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n+\tpre_stats.phis--;\n+      else\n+\tpre_stats.eliminations++;\n+    }\n \n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Replaced \");\n-\t\t      print_gimple_expr (dump_file, stmt, 0, 0);\n-\t\t      fprintf (dump_file, \" with \");\n-\t\t      print_generic_expr (dump_file, sprime, 0);\n-\t\t      fprintf (dump_file, \" in \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t    }\n-\t\t  pre_stats.eliminations++;\n-\t\t  propagate_tree_value_into_stmt (&gsi, sprime);\n-\t\t  stmt = gsi_stmt (gsi);\n-\t\t  update_stmt (stmt);\n-\n-\t\t  /* If we removed EH side-effects from the statement, clean\n-\t\t     its EH information.  */\n-\t\t  if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n-\t\t    {\n-\t\t      bitmap_set_bit (need_eh_cleanup,\n-\t\t\t\t      gimple_bb (stmt)->index);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"  Removed EH side-effects.\\n\");\n-\t\t    }\n-\t\t  continue;\n-\t\t}\n+  for (gsi = gsi_start_bb (b); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      tree lhs = NULL_TREE;\n+      tree rhs = NULL_TREE;\n+\n+      stmt = gsi_stmt (gsi);\n+\n+      if (gimple_has_lhs (stmt))\n+\tlhs = gimple_get_lhs (stmt);\n+\n+      if (gimple_assign_single_p (stmt))\n+\trhs = gimple_assign_rhs1 (stmt);\n+\n+      /* Lookup the RHS of the expression, see if we have an\n+\t available computation for it.  If so, replace the RHS with\n+\t the available computation.\n+\n+\t See PR43491.\n+\t We don't replace global register variable when it is a the RHS of\n+\t a single assign. We do replace local register variable since gcc\n+\t does not guarantee local variable will be allocated in register.  */\n+      if (gimple_has_lhs (stmt)\n+\t  && TREE_CODE (lhs) == SSA_NAME\n+\t  && !gimple_assign_ssa_name_copy_p (stmt)\n+\t  && (!gimple_assign_single_p (stmt)\n+\t      || (!is_gimple_min_invariant (rhs)\n+\t\t  && (gimple_assign_rhs_code (stmt) != VAR_DECL\n+\t\t      || !is_global_var (rhs)\n+\t\t      || !DECL_HARD_REGISTER (rhs))))\n+\t  && !gimple_has_volatile_ops  (stmt))\n+\t{\n+\t  tree sprime;\n+\t  gimple orig_stmt = stmt;\n \n+\t  sprime = eliminate_avail (lhs);\n+\t  if (!sprime)\n+\t    {\n \t      /* If there is no existing usable leader but SCCVN thinks\n \t\t it has an expression it wants to use as replacement,\n \t\t insert that.  */\n-\t      if (!sprime || sprime == lhs)\n+\t      tree val = VN_INFO (lhs)->valnum;\n+\t      if (val != VN_TOP\n+\t\t  && TREE_CODE (val) == SSA_NAME\n+\t\t  && VN_INFO (val)->needs_insertion\n+\t\t  && (sprime = eliminate_insert (&gsi, val)) != NULL_TREE)\n+\t\teliminate_push_avail (sprime);\n+\t    }\n+\t  else if (is_gimple_min_invariant (sprime))\n+\t    {\n+\t      /* If there is no existing leader but SCCVN knows this\n+\t\t value is constant, use that constant.  */\n+\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t      TREE_TYPE (sprime)))\n+\t\tsprime = fold_convert (TREE_TYPE (lhs), sprime);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n-\t\t  tree val = VN_INFO (lhs)->valnum;\n-\t\t  if (val != VN_TOP\n-\t\t      && TREE_CODE (val) == SSA_NAME\n-\t\t      && VN_INFO (val)->needs_insertion\n-\t\t      && can_PRE_operation (vn_get_expr_for (val)))\n-\t\t    sprime = do_SCCVN_insertion (stmt, val);\n+\t\t  fprintf (dump_file, \"Replaced \");\n+\t\t  print_gimple_expr (dump_file, stmt, 0, 0);\n+\t\t  fprintf (dump_file, \" with \");\n+\t\t  print_generic_expr (dump_file, sprime, 0);\n+\t\t  fprintf (dump_file, \" in \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t}\n-\t      if (sprime\n-\t\t  && sprime != lhs\n-\t\t  && (rhs == NULL_TREE\n-\t\t      || TREE_CODE (rhs) != SSA_NAME\n-\t\t      || may_propagate_copy (rhs, sprime)))\n+\t      pre_stats.eliminations++;\n+\t      propagate_tree_value_into_stmt (&gsi, sprime);\n+\t      stmt = gsi_stmt (gsi);\n+\t      update_stmt (stmt);\n+\n+\t      /* If we removed EH side-effects from the statement, clean\n+\t\t its EH information.  */\n+\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n \t\t{\n-\t\t  bool can_make_abnormal_goto\n-\t\t    = is_gimple_call (stmt)\n-\t\t      && stmt_can_make_abnormal_goto (stmt);\n+\t\t  bitmap_set_bit (need_eh_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n \n-\t\t  gcc_assert (sprime != rhs);\n+\t  /* If there is no usable leader mark lhs as leader for its value.  */\n+\t  if (!sprime)\n+\t    eliminate_push_avail (lhs);\n \n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Replaced \");\n-\t\t      print_gimple_expr (dump_file, stmt, 0, 0);\n-\t\t      fprintf (dump_file, \" with \");\n-\t\t      print_generic_expr (dump_file, sprime, 0);\n-\t\t      fprintf (dump_file, \" in \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t    }\n+\t  if (sprime\n+\t      && sprime != lhs\n+\t      && (rhs == NULL_TREE\n+\t\t  || TREE_CODE (rhs) != SSA_NAME\n+\t\t  || may_propagate_copy (rhs, sprime)))\n+\t    {\n+\t      bool can_make_abnormal_goto\n+\t\t  = is_gimple_call (stmt)\n+\t\t  && stmt_can_make_abnormal_goto (stmt);\n \n-\t\t  if (TREE_CODE (sprime) == SSA_NAME)\n-\t\t    gimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n-\t\t\t\t    NECESSARY, true);\n-\t\t  /* We need to make sure the new and old types actually match,\n-\t\t     which may require adding a simple cast, which fold_convert\n-\t\t     will do for us.  */\n-\t\t  if ((!rhs || TREE_CODE (rhs) != SSA_NAME)\n-\t\t      && !useless_type_conversion_p (gimple_expr_type (stmt),\n-\t\t\t\t\t\t     TREE_TYPE (sprime)))\n-\t\t    sprime = fold_convert (gimple_expr_type (stmt), sprime);\n-\n-\t\t  pre_stats.eliminations++;\n-\t\t  propagate_tree_value_into_stmt (&gsi, sprime);\n-\t\t  stmt = gsi_stmt (gsi);\n-\t\t  update_stmt (stmt);\n-\n-\t\t  /* If we removed EH side-effects from the statement, clean\n-\t\t     its EH information.  */\n-\t\t  if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n-\t\t    {\n-\t\t      bitmap_set_bit (need_eh_cleanup,\n-\t\t\t\t      gimple_bb (stmt)->index);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"  Removed EH side-effects.\\n\");\n-\t\t    }\n+\t      gcc_assert (sprime != rhs);\n \n-\t\t  /* Likewise for AB side-effects.  */\n-\t\t  if (can_make_abnormal_goto\n-\t\t      && !stmt_can_make_abnormal_goto (stmt))\n-\t\t    {\n-\t\t      bitmap_set_bit (need_ab_cleanup,\n-\t\t\t\t      gimple_bb (stmt)->index);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"  Removed AB side-effects.\\n\");\n-\t\t    }\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Replaced \");\n+\t\t  print_gimple_expr (dump_file, stmt, 0, 0);\n+\t\t  fprintf (dump_file, \" with \");\n+\t\t  print_generic_expr (dump_file, sprime, 0);\n+\t\t  fprintf (dump_file, \" in \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t}\n-\t    }\n-\t  /* If the statement is a scalar store, see if the expression\n-\t     has the same value number as its rhs.  If so, the store is\n-\t     dead.  */\n-\t  else if (gimple_assign_single_p (stmt)\n-\t\t   && !gimple_has_volatile_ops (stmt)\n-\t\t   && !is_gimple_reg (gimple_assign_lhs (stmt))\n-\t\t   && (TREE_CODE (rhs) == SSA_NAME\n-\t\t       || is_gimple_min_invariant (rhs)))\n-\t    {\n-\t      tree val;\n-\t      val = vn_reference_lookup (gimple_assign_lhs (stmt),\n-\t\t\t\t\t gimple_vuse (stmt), VN_WALK, NULL);\n-\t      if (TREE_CODE (rhs) == SSA_NAME)\n-\t\trhs = VN_INFO (rhs)->valnum;\n-\t      if (val\n-\t\t  && operand_equal_p (val, rhs, 0))\n+\n+\t      if (TREE_CODE (sprime) == SSA_NAME)\n+\t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n+\t\t\t\tNECESSARY, true);\n+\t      /* We need to make sure the new and old types actually match,\n+\t\t which may require adding a simple cast, which fold_convert\n+\t\t will do for us.  */\n+\t      if ((!rhs || TREE_CODE (rhs) != SSA_NAME)\n+\t\t  && !useless_type_conversion_p (gimple_expr_type (stmt),\n+\t\t\t\t\t\t TREE_TYPE (sprime)))\n+\t\tsprime = fold_convert (gimple_expr_type (stmt), sprime);\n+\n+\t      pre_stats.eliminations++;\n+\t      propagate_tree_value_into_stmt (&gsi, sprime);\n+\t      stmt = gsi_stmt (gsi);\n+\t      update_stmt (stmt);\n+\n+\t      /* If we removed EH side-effects from the statement, clean\n+\t\t its EH information.  */\n+\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n \t\t{\n+\t\t  bitmap_set_bit (need_eh_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Deleted redundant store \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t    }\n+\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t\t}\n \n-\t\t  /* Queue stmt for removal.  */\n-\t\t  VEC_safe_push (gimple, heap, to_remove, stmt);\n+\t      /* Likewise for AB side-effects.  */\n+\t      if (can_make_abnormal_goto\n+\t\t  && !stmt_can_make_abnormal_goto (stmt))\n+\t\t{\n+\t\t  bitmap_set_bit (need_ab_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  Removed AB side-effects.\\n\");\n \t\t}\n \t    }\n-\t  /* Visit COND_EXPRs and fold the comparison with the\n-\t     available value-numbers.  */\n-\t  else if (gimple_code (stmt) == GIMPLE_COND)\n+\t}\n+      /* If the statement is a scalar store, see if the expression\n+\t has the same value number as its rhs.  If so, the store is\n+\t dead.  */\n+      else if (gimple_assign_single_p (stmt)\n+\t       && !gimple_has_volatile_ops (stmt)\n+\t       && !is_gimple_reg (gimple_assign_lhs (stmt))\n+\t       && (TREE_CODE (rhs) == SSA_NAME\n+\t\t   || is_gimple_min_invariant (rhs)))\n+\t{\n+\t  tree val;\n+\t  val = vn_reference_lookup (gimple_assign_lhs (stmt),\n+\t\t\t\t     gimple_vuse (stmt), VN_WALK, NULL);\n+\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t    rhs = VN_INFO (rhs)->valnum;\n+\t  if (val\n+\t      && operand_equal_p (val, rhs, 0))\n \t    {\n-\t      tree op0 = gimple_cond_lhs (stmt);\n-\t      tree op1 = gimple_cond_rhs (stmt);\n-\t      tree result;\n-\n-\t      if (TREE_CODE (op0) == SSA_NAME)\n-\t\top0 = VN_INFO (op0)->valnum;\n-\t      if (TREE_CODE (op1) == SSA_NAME)\n-\t\top1 = VN_INFO (op1)->valnum;\n-\t      result = fold_binary (gimple_cond_code (stmt), boolean_type_node,\n-\t\t\t\t    op0, op1);\n-\t      if (result && TREE_CODE (result) == INTEGER_CST)\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n-\t\t  if (integer_zerop (result))\n-\t\t    gimple_cond_make_false (stmt);\n-\t\t  else\n-\t\t    gimple_cond_make_true (stmt);\n-\t\t  update_stmt (stmt);\n-\t\t  todo = TODO_cleanup_cfg;\n+\t\t  fprintf (dump_file, \"Deleted redundant store \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t}\n+\n+\t      /* Queue stmt for removal.  */\n+\t      VEC_safe_push (gimple, heap, el_to_remove, stmt);\n \t    }\n-\t  /* Visit indirect calls and turn them into direct calls if\n-\t     possible.  */\n-\t  if (is_gimple_call (stmt))\n+\t}\n+      /* Visit COND_EXPRs and fold the comparison with the\n+\t available value-numbers.  */\n+      else if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  tree op0 = gimple_cond_lhs (stmt);\n+\t  tree op1 = gimple_cond_rhs (stmt);\n+\t  tree result;\n+\n+\t  if (TREE_CODE (op0) == SSA_NAME)\n+\t    op0 = VN_INFO (op0)->valnum;\n+\t  if (TREE_CODE (op1) == SSA_NAME)\n+\t    op1 = VN_INFO (op1)->valnum;\n+\t  result = fold_binary (gimple_cond_code (stmt), boolean_type_node,\n+\t\t\t\top0, op1);\n+\t  if (result && TREE_CODE (result) == INTEGER_CST)\n \t    {\n-\t      tree orig_fn = gimple_call_fn (stmt);\n-\t      tree fn;\n-\t      if (!orig_fn)\n-\t\tcontinue;\n-\t      if (TREE_CODE (orig_fn) == SSA_NAME)\n-\t\tfn = VN_INFO (orig_fn)->valnum;\n-\t      else if (TREE_CODE (orig_fn) == OBJ_TYPE_REF\n-\t\t       && TREE_CODE (OBJ_TYPE_REF_EXPR (orig_fn)) == SSA_NAME)\n-\t\tfn = VN_INFO (OBJ_TYPE_REF_EXPR (orig_fn))->valnum;\n+\t      if (integer_zerop (result))\n+\t\tgimple_cond_make_false (stmt);\n \t      else\n-\t\tcontinue;\n-\t      if (gimple_call_addr_fndecl (fn) != NULL_TREE\n-\t\t  && useless_type_conversion_p (TREE_TYPE (orig_fn),\n-\t\t\t\t\t\tTREE_TYPE (fn)))\n-\t\t{\n-\t\t  bool can_make_abnormal_goto\n-\t\t    = stmt_can_make_abnormal_goto (stmt);\n-\t\t  bool was_noreturn = gimple_call_noreturn_p (stmt);\n-\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Replacing call target with \");\n-\t\t      print_generic_expr (dump_file, fn, 0);\n-\t\t      fprintf (dump_file, \" in \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t    }\n+\t\tgimple_cond_make_true (stmt);\n+\t      update_stmt (stmt);\n+\t      el_todo = TODO_cleanup_cfg;\n+\t    }\n+\t}\n+      /* Visit indirect calls and turn them into direct calls if\n+\t possible.  */\n+      if (is_gimple_call (stmt))\n+\t{\n+\t  tree orig_fn = gimple_call_fn (stmt);\n+\t  tree fn;\n+\t  if (!orig_fn)\n+\t    continue;\n+\t  if (TREE_CODE (orig_fn) == SSA_NAME)\n+\t    fn = VN_INFO (orig_fn)->valnum;\n+\t  else if (TREE_CODE (orig_fn) == OBJ_TYPE_REF\n+\t\t   && TREE_CODE (OBJ_TYPE_REF_EXPR (orig_fn)) == SSA_NAME)\n+\t    fn = VN_INFO (OBJ_TYPE_REF_EXPR (orig_fn))->valnum;\n+\t  else\n+\t    continue;\n+\t  if (gimple_call_addr_fndecl (fn) != NULL_TREE\n+\t      && useless_type_conversion_p (TREE_TYPE (orig_fn),\n+\t\t\t\t\t    TREE_TYPE (fn)))\n+\t    {\n+\t      bool can_make_abnormal_goto\n+\t\t  = stmt_can_make_abnormal_goto (stmt);\n+\t      bool was_noreturn = gimple_call_noreturn_p (stmt);\n \n-\t\t  gimple_call_set_fn (stmt, fn);\n-\t\t  VEC_safe_push (gimple, heap, to_update, stmt);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Replacing call target with \");\n+\t\t  print_generic_expr (dump_file, fn, 0);\n+\t\t  fprintf (dump_file, \" in \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t}\n \n-\t\t  /* When changing a call into a noreturn call, cfg cleanup\n-\t\t     is needed to fix up the noreturn call.  */\n-\t\t  if (!was_noreturn && gimple_call_noreturn_p (stmt))\n-\t\t    todo |= TODO_cleanup_cfg;\n+\t      gimple_call_set_fn (stmt, fn);\n+\t      VEC_safe_push (gimple, heap, el_to_update, stmt);\n \n-\t\t  /* If we removed EH side-effects from the statement, clean\n-\t\t     its EH information.  */\n-\t\t  if (maybe_clean_or_replace_eh_stmt (stmt, stmt))\n-\t\t    {\n-\t\t      bitmap_set_bit (need_eh_cleanup,\n-\t\t\t\t      gimple_bb (stmt)->index);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"  Removed EH side-effects.\\n\");\n-\t\t    }\n+\t      /* When changing a call into a noreturn call, cfg cleanup\n+\t\t is needed to fix up the noreturn call.  */\n+\t      if (!was_noreturn && gimple_call_noreturn_p (stmt))\n+\t\tel_todo |= TODO_cleanup_cfg;\n \n-\t\t  /* Likewise for AB side-effects.  */\n-\t\t  if (can_make_abnormal_goto\n-\t\t      && !stmt_can_make_abnormal_goto (stmt))\n-\t\t    {\n-\t\t      bitmap_set_bit (need_ab_cleanup,\n-\t\t\t\t      gimple_bb (stmt)->index);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \"  Removed AB side-effects.\\n\");\n-\t\t    }\n+\t      /* If we removed EH side-effects from the statement, clean\n+\t\t its EH information.  */\n+\t      if (maybe_clean_or_replace_eh_stmt (stmt, stmt))\n+\t\t{\n+\t\t  bitmap_set_bit (need_eh_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t\t}\n \n-\t\t  /* Changing an indirect call to a direct call may\n-\t\t     have exposed different semantics.  This may\n-\t\t     require an SSA update.  */\n-\t\t  todo |= TODO_update_ssa_only_virtuals;\n+\t      /* Likewise for AB side-effects.  */\n+\t      if (can_make_abnormal_goto\n+\t\t  && !stmt_can_make_abnormal_goto (stmt))\n+\t\t{\n+\t\t  bitmap_set_bit (need_ab_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  Removed AB side-effects.\\n\");\n \t\t}\n+\n+\t      /* Changing an indirect call to a direct call may\n+\t\t have exposed different semantics.  This may\n+\t\t require an SSA update.  */\n+\t      el_todo |= TODO_update_ssa_only_virtuals;\n \t    }\n \t}\n+    }\n+}\n \n-      for (gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n-\t{\n-\t  gimple stmt, phi = gsi_stmt (gsi);\n-\t  tree sprime = NULL_TREE, res = PHI_RESULT (phi);\n-\t  pre_expr sprimeexpr, resexpr;\n-\t  gimple_stmt_iterator gsi2;\n-\n-\t  /* We want to perform redundant PHI elimination.  Do so by\n-\t     replacing the PHI with a single copy if possible.\n-\t     Do not touch inserted, single-argument or virtual PHIs.  */\n-\t  if (gimple_phi_num_args (phi) == 1\n-\t      || virtual_operand_p (res))\n-\t    {\n-\t      gsi_next (&gsi);\n-\t      continue;\n-\t    }\n+/* Make no longer available leaders no longer available.  */\n \n-\t  resexpr = get_or_alloc_expr_for_name (res);\n-\t  sprimeexpr = bitmap_find_leader (AVAIL_OUT (b),\n-\t\t\t\t\t   get_expr_value_id (resexpr), NULL);\n-\t  if (sprimeexpr)\n-\t    {\n-\t      if (sprimeexpr->kind == CONSTANT)\n-\t\tsprime = PRE_EXPR_CONSTANT (sprimeexpr);\n-\t      else if (sprimeexpr->kind == NAME)\n-\t\tsprime = PRE_EXPR_NAME (sprimeexpr);\n-\t      else\n-\t\tgcc_unreachable ();\n-\t    }\n-\t  if (!sprime && is_gimple_min_invariant (VN_INFO (res)->valnum))\n-\t    {\n-\t      sprime = VN_INFO (res)->valnum;\n-\t      if (!useless_type_conversion_p (TREE_TYPE (res),\n-\t\t\t\t\t      TREE_TYPE (sprime)))\n-\t\tsprime = fold_convert (TREE_TYPE (res), sprime);\n-\t    }\n-\t  if (!sprime\n-\t      || sprime == res)\n-\t    {\n-\t      gsi_next (&gsi);\n-\t      continue;\n-\t    }\n+static void\n+eliminate_leave_block (dom_walk_data *, basic_block)\n+{\n+  tree entry;\n+  while ((entry = VEC_pop (tree, el_avail_stack)) != NULL_TREE)\n+    VEC_replace (tree, el_avail,\n+\t\t SSA_NAME_VERSION (VN_INFO (entry)->valnum), NULL_TREE);\n+}\n \n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Replaced redundant PHI node defining \");\n-\t      print_generic_expr (dump_file, res, 0);\n-\t      fprintf (dump_file, \" with \");\n-\t      print_generic_expr (dump_file, sprime, 0);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n+/* Eliminate fully redundant computations.  */\n \n-\t  remove_phi_node (&gsi, false);\n+static unsigned int\n+eliminate (void)\n+{\n+  struct dom_walk_data walk_data;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  unsigned i;\n \n-\t  if (!bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res))\n-\t      && TREE_CODE (sprime) == SSA_NAME)\n-\t    gimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n+  need_eh_cleanup = BITMAP_ALLOC (NULL);\n+  need_ab_cleanup = BITMAP_ALLOC (NULL);\n \n-\t  if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n-\t    sprime = fold_convert (TREE_TYPE (res), sprime);\n-\t  stmt = gimple_build_assign (res, sprime);\n-\t  SSA_NAME_DEF_STMT (res) = stmt;\n-\t  gimple_set_plf (stmt, NECESSARY, gimple_plf (phi, NECESSARY));\n-\n-\t  gsi2 = gsi_after_labels (b);\n-\t  gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n-\t  /* Queue the copy for eventual removal.  */\n-\t  VEC_safe_push (gimple, heap, to_remove, stmt);\n-\t  /* If we inserted this PHI node ourself, it's not an elimination.  */\n-\t  if (bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n-\t    pre_stats.phis--;\n-\t  else\n-\t    pre_stats.eliminations++;\n-\t}\n-    }\n+  el_to_remove = NULL;\n+  el_to_update = NULL;\n+  el_todo = 0;\n+  el_avail = NULL;\n+  el_avail_stack = NULL;\n+\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children = eliminate_bb;\n+  walk_data.after_dom_children = eliminate_leave_block;\n+  walk_data.global_data = NULL;\n+  walk_data.block_local_data_size = 0;\n+  init_walk_dominator_tree (&walk_data);\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  VEC_free (tree, heap, el_avail);\n+  VEC_free (tree, heap, el_avail_stack);\n \n   /* We cannot remove stmts during BB walk, especially not release SSA\n      names there as this confuses the VN machinery.  The stmts ending\n-     up in to_remove are either stores or simple copies.  */\n-  FOR_EACH_VEC_ELT (gimple, to_remove, i, stmt)\n+     up in el_to_remove are either stores or simple copies.  */\n+  FOR_EACH_VEC_ELT (gimple, el_to_remove, i, stmt)\n     {\n       tree lhs = gimple_assign_lhs (stmt);\n       tree rhs = gimple_assign_rhs1 (stmt);\n@@ -4539,7 +4592,8 @@ eliminate (void)\n \t{\n \t  SET_USE (use_p, rhs);\n \t  update_stmt (use_stmt);\n-\t  if (bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (lhs))\n+\t  if (inserted_exprs\n+\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (lhs))\n \t      && TREE_CODE (rhs) == SSA_NAME)\n \t    gimple_set_plf (SSA_NAME_DEF_STMT (rhs), NECESSARY, true);\n \t}\n@@ -4553,21 +4607,43 @@ eliminate (void)\n \t  unlink_stmt_vdef (stmt);\n \t  if (gsi_remove (&gsi, true))\n \t    bitmap_set_bit (need_eh_cleanup, bb->index);\n-\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t  if (inserted_exprs\n+\t      && TREE_CODE (lhs) == SSA_NAME)\n \t    bitmap_clear_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n \t  release_defs (stmt);\n \t}\n     }\n-  VEC_free (gimple, heap, to_remove);\n+  VEC_free (gimple, heap, el_to_remove);\n \n   /* We cannot update call statements with virtual operands during\n      SSA walk.  This might remove them which in turn makes our\n      VN lattice invalid.  */\n-  FOR_EACH_VEC_ELT (gimple, to_update, i, stmt)\n+  FOR_EACH_VEC_ELT (gimple, el_to_update, i, stmt)\n     update_stmt (stmt);\n-  VEC_free (gimple, heap, to_update);\n+  VEC_free (gimple, heap, el_to_update);\n \n-  return todo;\n+  return el_todo;\n+}\n+\n+/* Perform CFG cleanups made necessary by elimination.  */\n+\n+static void\n+fini_eliminate (void)\n+{\n+  bool do_eh_cleanup = !bitmap_empty_p (need_eh_cleanup);\n+  bool do_ab_cleanup = !bitmap_empty_p (need_ab_cleanup);\n+\n+  if (do_eh_cleanup)\n+    gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n+\n+  if (do_ab_cleanup)\n+    gimple_purge_all_dead_abnormal_call_edges (need_ab_cleanup);\n+\n+  BITMAP_FREE (need_eh_cleanup);\n+  BITMAP_FREE (need_ab_cleanup);\n+\n+  if (do_eh_cleanup || do_ab_cleanup)\n+    cleanup_tree_cfg ();\n }\n \n /* Borrow a bit of tree-ssa-dce.c for the moment.\n@@ -4767,7 +4843,7 @@ my_rev_post_order_compute (int *post_order, bool include_entry_exit)\n /* Initialize data structures used by PRE.  */\n \n static void\n-init_pre (bool do_fre)\n+init_pre (void)\n {\n   basic_block bb;\n \n@@ -4779,8 +4855,6 @@ init_pre (bool do_fre)\n \t\t\t get_max_value_id() + 1);\n   name_to_id = NULL;\n \n-  in_fre = do_fre;\n-\n   inserted_exprs = BITMAP_ALLOC (NULL);\n \n   connect_infinite_loops_to_exit ();\n@@ -4804,28 +4878,19 @@ init_pre (bool do_fre)\n \t\t\t\t     sizeof (struct pre_expr_d), 30);\n   FOR_ALL_BB (bb)\n     {\n-      if (!do_fre)\n-\t{\n-\t  EXP_GEN (bb) = bitmap_set_new ();\n-\t  PHI_GEN (bb) = bitmap_set_new ();\n-\t  TMP_GEN (bb) = bitmap_set_new ();\n-\t}\n+      EXP_GEN (bb) = bitmap_set_new ();\n+      PHI_GEN (bb) = bitmap_set_new ();\n+      TMP_GEN (bb) = bitmap_set_new ();\n       AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n-\n-  need_eh_cleanup = BITMAP_ALLOC (NULL);\n-  need_ab_cleanup = BITMAP_ALLOC (NULL);\n }\n \n \n /* Deallocate data structures used by PRE.  */\n \n static void\n-fini_pre (bool do_fre)\n+fini_pre ()\n {\n-  bool do_eh_cleanup = !bitmap_empty_p (need_eh_cleanup);\n-  bool do_ab_cleanup = !bitmap_empty_p (need_ab_cleanup);\n-\n   free (postorder);\n   VEC_free (bitmap, heap, value_expressions);\n   BITMAP_FREE (inserted_exprs);\n@@ -4839,28 +4904,12 @@ fini_pre (bool do_fre)\n   free_aux_for_blocks ();\n \n   free_dominance_info (CDI_POST_DOMINATORS);\n-\n-  if (do_eh_cleanup)\n-    gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n-\n-  if (do_ab_cleanup)\n-    gimple_purge_all_dead_abnormal_call_edges (need_ab_cleanup);\n-\n-  BITMAP_FREE (need_eh_cleanup);\n-  BITMAP_FREE (need_ab_cleanup);\n-\n-  if (do_eh_cleanup || do_ab_cleanup)\n-    cleanup_tree_cfg ();\n-\n-  if (!do_fre)\n-    loop_optimizer_finalize ();\n }\n \n-/* Main entry point to the SSA-PRE pass.  DO_FRE is true if the caller\n-   only wants to do full redundancy elimination.  */\n+/* Gate and execute functions for PRE.  */\n \n static unsigned int\n-execute_pre (bool do_fre)\n+do_pre (void)\n {\n   unsigned int todo = 0;\n \n@@ -4869,18 +4918,15 @@ execute_pre (bool do_fre)\n \n   /* This has to happen before SCCVN runs because\n      loop_optimizer_init may create new phis, etc.  */\n-  if (!do_fre)\n-    loop_optimizer_init (LOOPS_NORMAL);\n+  loop_optimizer_init (LOOPS_NORMAL);\n \n-  if (!run_scc_vn (do_fre ? VN_WALKREWRITE : VN_WALK))\n+  if (!run_scc_vn (VN_WALK))\n     {\n-      if (!do_fre)\n-\tloop_optimizer_finalize ();\n-\n+      loop_optimizer_finalize ();\n       return 0;\n     }\n \n-  init_pre (do_fre);\n+  init_pre ();\n   scev_initialize ();\n \n   /* Collect and value number expressions computed in each basic block.  */\n@@ -4889,13 +4935,16 @@ execute_pre (bool do_fre)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       basic_block bb;\n-\n       FOR_ALL_BB (bb)\n \t{\n-\t  print_bitmap_set (dump_file, EXP_GEN (bb), \"exp_gen\", bb->index);\n-\t  print_bitmap_set (dump_file, PHI_GEN (bb), \"phi_gen\", bb->index);\n-\t  print_bitmap_set (dump_file, TMP_GEN (bb), \"tmp_gen\", bb->index);\n-\t  print_bitmap_set (dump_file, AVAIL_OUT (bb), \"avail_out\", bb->index);\n+\t  print_bitmap_set (dump_file, EXP_GEN (bb),\n+\t\t\t    \"exp_gen\", bb->index);\n+\t  print_bitmap_set (dump_file, PHI_GEN (bb),\n+\t\t\t    \"phi_gen\", bb->index);\n+\t  print_bitmap_set (dump_file, TMP_GEN (bb),\n+\t\t\t    \"tmp_gen\", bb->index);\n+\t  print_bitmap_set (dump_file, AVAIL_OUT (bb),\n+\t\t\t    \"avail_out\", bb->index);\n \t}\n     }\n \n@@ -4904,7 +4953,7 @@ execute_pre (bool do_fre)\n      fixed, don't run it when he have an incredibly large number of\n      bb's.  If we aren't going to run insert, there is no point in\n      computing ANTIC, either, even though it's plenty fast.  */\n-  if (!do_fre && n_basic_blocks < 4000)\n+  if (n_basic_blocks < 4000)\n     {\n       compute_antic ();\n       insert ();\n@@ -4926,37 +4975,28 @@ execute_pre (bool do_fre)\n   statistics_counter_event (cfun, \"Constified\", pre_stats.constified);\n \n   clear_expression_ids ();\n-  if (!do_fre)\n-    {\n-      remove_dead_inserted_code ();\n-      todo |= TODO_verify_flow;\n-    }\n+  remove_dead_inserted_code ();\n+  todo |= TODO_verify_flow;\n \n   scev_finalize ();\n-  fini_pre (do_fre);\n-\n-  if (!do_fre)\n-    /* TODO: tail_merge_optimize may merge all predecessors of a block, in which\n-       case we can merge the block with the remaining predecessor of the block.\n-       It should either:\n-       - call merge_blocks after each tail merge iteration\n-       - call merge_blocks after all tail merge iterations\n-       - mark TODO_cleanup_cfg when necessary\n-       - share the cfg cleanup with fini_pre.  */\n-    todo |= tail_merge_optimize (todo);\n+  fini_pre ();\n+  fini_eliminate ();\n+  loop_optimizer_finalize ();\n+\n+  /* TODO: tail_merge_optimize may merge all predecessors of a block, in which\n+     case we can merge the block with the remaining predecessor of the block.\n+     It should either:\n+     - call merge_blocks after each tail merge iteration\n+     - call merge_blocks after all tail merge iterations\n+     - mark TODO_cleanup_cfg when necessary\n+     - share the cfg cleanup with fini_pre.  */\n+  todo |= tail_merge_optimize (todo);\n+\n   free_scc_vn ();\n \n   return todo;\n }\n \n-/* Gate and execute functions for PRE.  */\n-\n-static unsigned int\n-do_pre (void)\n-{\n-  return execute_pre (false);\n-}\n-\n static bool\n gate_pre (void)\n {\n@@ -4990,7 +5030,25 @@ struct gimple_opt_pass pass_pre =\n static unsigned int\n execute_fre (void)\n {\n-  return execute_pre (true);\n+  unsigned int todo = 0;\n+\n+  if (!run_scc_vn (VN_WALKREWRITE))\n+    return 0;\n+\n+  memset (&pre_stats, 0, sizeof (pre_stats));\n+\n+  /* Remove all the redundant expressions.  */\n+  todo |= eliminate ();\n+\n+  fini_eliminate ();\n+\n+  free_scc_vn ();\n+\n+  statistics_counter_event (cfun, \"Insertions\", pre_stats.insertions);\n+  statistics_counter_event (cfun, \"Eliminated\", pre_stats.eliminations);\n+  statistics_counter_event (cfun, \"Constified\", pre_stats.constified);\n+\n+  return todo;\n }\n \n static bool"}]}