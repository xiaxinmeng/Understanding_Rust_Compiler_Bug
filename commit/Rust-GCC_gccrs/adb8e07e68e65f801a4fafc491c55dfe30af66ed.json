{"sha": "adb8e07e68e65f801a4fafc491c55dfe30af66ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiOGUwN2U2OGU2NWY4MDFhNGZhZmM0OTFjNTVkZmUzMGFmNjZlZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-19T12:45:44Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-19T12:45:44Z"}, "message": "fold-const.c (tree_expr_nonzero_p): Add function prototype.\n\n\n\t* fold-const.c (tree_expr_nonzero_p): Add function prototype.\n\t(fold) <EQ_EXPR>: Move tree_expr_nonzero_p optimization from\n\tfold_relational_const to here, i.e. \"(x | 5) == 0\" -> false.\n\t(fold) (UNEQ_EXPR>: Add optimizations for unordered comparisons\n\tof the form \"x op x\" where op is UNLE, UNGE, UNEQ or LTGT.\n\t(fold_relational_const): Tidy up handling of floating point\n\tcomparisons by calling real_compare.  Remove tree_expr_nonzero_p\n\ttransformation; fold_relational_const assumes constant operands.\n\nFrom-SVN: r84916", "tree": {"sha": "2f13610dabbc475f272664de4371618b18cd0cda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f13610dabbc475f272664de4371618b18cd0cda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adb8e07e68e65f801a4fafc491c55dfe30af66ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb8e07e68e65f801a4fafc491c55dfe30af66ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb8e07e68e65f801a4fafc491c55dfe30af66ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb8e07e68e65f801a4fafc491c55dfe30af66ed/comments", "author": null, "committer": null, "parents": [{"sha": "3c95eb0ebf6acc1de5ae0d37967103effd787071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c95eb0ebf6acc1de5ae0d37967103effd787071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c95eb0ebf6acc1de5ae0d37967103effd787071"}], "stats": {"total": 84, "additions": 34, "deletions": 50}, "files": [{"sha": "12667fd13394f6924df257a50a21fdaec47e3049", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb8e07e68e65f801a4fafc491c55dfe30af66ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb8e07e68e65f801a4fafc491c55dfe30af66ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adb8e07e68e65f801a4fafc491c55dfe30af66ed", "patch": "@@ -1,3 +1,14 @@\n+2004-07-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (tree_expr_nonzero_p): Add function prototype.\n+\t(fold) <EQ_EXPR>: Move tree_expr_nonzero_p optimization from\n+\tfold_relational_const to here, i.e. \"(x | 5) == 0\" -> false.\n+\t(fold) (UNEQ_EXPR>: Add optimizations for unordered comparisons\n+\tof the form \"x op x\" where op is UNLE, UNGE, UNEQ or LTGT.\n+\t(fold_relational_const): Tidy up handling of floating point\n+\tcomparisons by calling real_compare.  Remove tree_expr_nonzero_p\n+\ttransformation; fold_relational_const assumes constant operands.\n+\n 2004-07-19  Gabriel Dos Reis  <gdr@integrable-solution.net>\n \n \t* doc/sourcebuild.texi: Add libcpp, now that CPP has its own"}, {"sha": "7c6b66533e6a29875f7bf9d040eafb5be747d4ba", "filename": "gcc/fold-const.c", "status": "modified", "additions": 23, "deletions": 50, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb8e07e68e65f801a4fafc491c55dfe30af66ed/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb8e07e68e65f801a4fafc491c55dfe30af66ed/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=adb8e07e68e65f801a4fafc491c55dfe30af66ed", "patch": "@@ -137,6 +137,7 @@ static tree fold_not_const (tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n static tree fold_relational_hi_lo (enum tree_code *, const tree,\n                                    tree *, tree *);\n+static bool tree_expr_nonzero_p (tree);\n \n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n@@ -8638,9 +8639,14 @@ fold (tree expr)\n \t    return t1;\n \t}\n \n-      /* Both ARG0 and ARG1 are known to be constants at this point.  */\n+      if ((code == EQ_EXPR || code == NE_EXPR)\n+\t  && !TREE_SIDE_EFFECTS (arg0)\n+\t  && integer_zerop (arg1)\n+\t  && tree_expr_nonzero_p (arg0))\n+\treturn constant_boolean_node (code==NE_EXPR, type);\n+\n       t1 = fold_relational_const (code, type, arg0, arg1);\n-      return (t1 == NULL_TREE ? t : t1);\n+      return t1 == NULL_TREE ? t : t1;\n \n     case UNORDERED_EXPR:\n     case ORDERED_EXPR:\n@@ -8679,6 +8685,16 @@ fold (tree expr)\n \t  return omit_one_operand (type, t1, arg0);\n \t}\n \n+      /* Simplify unordered comparison of something with itself.  */\n+      if ((code == UNLE_EXPR || code == UNGE_EXPR || code == UNEQ_EXPR)\n+\t  && operand_equal_p (arg0, arg1, 0))\n+\treturn constant_boolean_node (1, type);\n+\n+      if (code == LTGT_EXPR\n+\t  && !flag_trapping_math\n+\t  && operand_equal_p (arg0, arg1, 0))\n+\treturn constant_boolean_node (0, type);\n+\n       /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n       {\n \ttree targ0 = strip_float_extensions (arg0);\n@@ -10394,9 +10410,11 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \n   if (TREE_CODE (op0) == REAL_CST && TREE_CODE (op1) == REAL_CST)\n     {\n+      const REAL_VALUE_TYPE *c0 = TREE_REAL_CST_PTR (op0);\n+      const REAL_VALUE_TYPE *c1 = TREE_REAL_CST_PTR (op1);\n+\n       /* Handle the cases where either operand is a NaN.  */\n-      if (REAL_VALUE_ISNAN (TREE_REAL_CST (op0))\n-          || REAL_VALUE_ISNAN (TREE_REAL_CST (op1)))\n+      if (real_isnan (c0) || real_isnan (c1))\n \t{\n \t  switch (code)\n \t    {\n@@ -10432,37 +10450,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t  return constant_boolean_node (result, type);\n \t}\n \n-      /* From here on we're sure there are no NaNs.  */\n-      switch (code)\n-\t{\n-\tcase ORDERED_EXPR:\n-\t  return constant_boolean_node (true, type);\n-\n-\tcase UNORDERED_EXPR:\n-\t  return constant_boolean_node (false, type);\n-\n-\tcase UNLT_EXPR:\n-\t  code = LT_EXPR;\n-\t  break;\n-\tcase UNLE_EXPR:\n-\t  code = LE_EXPR;\n-\t  break;\n-\tcase UNGT_EXPR:\n-\t  code = GT_EXPR;\n-\t  break;\n-\tcase UNGE_EXPR:\n-\t  code = GE_EXPR;\n-\t  break;\n-\tcase UNEQ_EXPR:\n-\t  code = EQ_EXPR;\n-\t  break;\n-\tcase LTGT_EXPR:\n-\t  code = NE_EXPR;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n+      return constant_boolean_node (real_compare (code, c0, c1), type);\n     }\n \n   /* From here on we only handle LT, LE, GT, GE, EQ and NE.\n@@ -10503,21 +10491,6 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n       else\n \tresult = INT_CST_LT (op0, op1);\n     }\n-\n-  else if (code == EQ_EXPR && !TREE_SIDE_EFFECTS (op0)\n-           && integer_zerop (op1) && tree_expr_nonzero_p (op0))\n-    result = 0;\n-\n-  /* Two real constants can be compared explicitly.  */\n-  else if (TREE_CODE (op0) == REAL_CST && TREE_CODE (op1) == REAL_CST)\n-    {\n-      if (code == EQ_EXPR)\n-\tresult = REAL_VALUES_EQUAL (TREE_REAL_CST (op0),\n-\t\t\t\t    TREE_REAL_CST (op1));\n-      else\n-\tresult = REAL_VALUES_LESS (TREE_REAL_CST (op0),\n-\t\t\t\t   TREE_REAL_CST (op1));\n-    }\n   else\n     return NULL_TREE;\n "}]}