{"sha": "054632e8ab08921f7da62bdd84ec5270f0da8191", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0NjMyZThhYjA4OTIxZjdkYTYyYmRkODRlYzUyNzBmMGRhODE5MQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-04-16T01:59:11Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-04-16T01:59:11Z"}, "message": "fold-const.c (fold_relational_hi_lo): Delete function and prototype.\n\n\n\t* fold-const.c (fold_relational_hi_lo): Delete function and prototype.\n\t(fold_binary): Update comment mentioning fold_relational_hi_lo.\n\t(fold_binary_to_constant): Simplify using fold_binary.\n\t(fold_unary_to_constant): Likewise, simplify using fold_unary.\n\nFrom-SVN: r98220", "tree": {"sha": "4792ab2bbc6fbc6f6cdb0fd46462e9b4cadc9bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4792ab2bbc6fbc6f6cdb0fd46462e9b4cadc9bc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/054632e8ab08921f7da62bdd84ec5270f0da8191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054632e8ab08921f7da62bdd84ec5270f0da8191", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054632e8ab08921f7da62bdd84ec5270f0da8191", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054632e8ab08921f7da62bdd84ec5270f0da8191/comments", "author": null, "committer": null, "parents": [{"sha": "3c60ae5ab5a37eb374787aebaca0575f6bb76cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c60ae5ab5a37eb374787aebaca0575f6bb76cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c60ae5ab5a37eb374787aebaca0575f6bb76cb8"}], "stats": {"total": 508, "additions": 12, "deletions": 496}, "files": [{"sha": "f3ba578fd78b001c47c5917860ed5a2317d6aae1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054632e8ab08921f7da62bdd84ec5270f0da8191/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054632e8ab08921f7da62bdd84ec5270f0da8191/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=054632e8ab08921f7da62bdd84ec5270f0da8191", "patch": "@@ -1,3 +1,10 @@\n+2005-04-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_relational_hi_lo): Delete function and prototype.\n+\t(fold_binary): Update comment mentioning fold_relational_hi_lo.\n+\t(fold_binary_to_constant): Simplify using fold_binary.\n+\t(fold_unary_to_constant): Likewise, simplify using fold_unary.\n+\n 2005-04-15  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* gthr-posix.c (pthread_cancel): Define."}, {"sha": "e9b0e219e0a807421258634c62b3375c08b1b592", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 496, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054632e8ab08921f7da62bdd84ec5270f0da8191/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054632e8ab08921f7da62bdd84ec5270f0da8191/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=054632e8ab08921f7da62bdd84ec5270f0da8191", "patch": "@@ -133,8 +133,6 @@ static bool reorder_operands_p (tree, tree);\n static tree fold_negate_const (tree, tree);\n static tree fold_not_const (tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n-static tree fold_relational_hi_lo (enum tree_code *, const tree,\n-                                   tree *, tree *);\n static bool tree_expr_nonzero_p (tree);\n \n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n@@ -9033,10 +9031,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t}\n \n       /* Comparisons with the highest or lowest possible integer of\n-\t the specified size will have known values.\n-\n-\t This is quite similar to fold_relational_hi_lo, however,\n-\t attempts to share the code have been nothing but trouble.  */\n+\t the specified size will have known values.  */\n       {\n \tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n \n@@ -10793,155 +10788,6 @@ tree_expr_nonzero_p (tree t)\n   return false;\n }\n \n-/* See if we are applying CODE, a relational to the highest or lowest\n-   possible integer of TYPE.  If so, then the result is a compile\n-   time constant.  */\n-\n-static tree\n-fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n-\t\t       tree *op1_p)\n-{\n-  tree op0 = *op0_p;\n-  tree op1 = *op1_p;\n-  enum tree_code code = *code_p;\n-  int width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (op1)));\n-\n-  if (TREE_CODE (op1) == INTEGER_CST\n-      && ! TREE_CONSTANT_OVERFLOW (op1)\n-      && width <= HOST_BITS_PER_WIDE_INT\n-      && (INTEGRAL_TYPE_P (TREE_TYPE (op1))\n-\t  || POINTER_TYPE_P (TREE_TYPE (op1))))\n-    {\n-      unsigned HOST_WIDE_INT signed_max;\n-      unsigned HOST_WIDE_INT max, min;\n-\n-      signed_max = ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1;\n-\n-      if (TYPE_UNSIGNED (TREE_TYPE (op1)))\n-        {\n-          max = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n-\t  min = 0;\n-\t}\n-      else\n-        {\n-          max = signed_max;\n-\t  min = ((unsigned HOST_WIDE_INT) -1 << (width - 1));\n-\t}\n-\n-      if (TREE_INT_CST_HIGH (op1) == 0\n-\t  && TREE_INT_CST_LOW (op1) == max)\n-\tswitch (code)\n-\t  {\n-\t  case GT_EXPR:\n-\t    return omit_one_operand (type, integer_zero_node, op0);\n-\n-\t  case GE_EXPR:\n-\t    *code_p = EQ_EXPR;\n-\t    break;\n-\t  case LE_EXPR:\n-\t    return omit_one_operand (type, integer_one_node, op0);\n-\n-\t  case LT_EXPR:\n-\t    *code_p = NE_EXPR;\n-\t    break;\n-\n-\t  /* The GE_EXPR and LT_EXPR cases above are not normally\n-\t     reached because of  previous transformations.  */\n-\n-\t  default:\n-\t    break;\n-\t  }\n-      else if (TREE_INT_CST_HIGH (op1) == 0\n-\t       && TREE_INT_CST_LOW (op1) == max - 1)\n-\tswitch (code)\n-\t  {\n-\t  case GT_EXPR:\n-\t    *code_p = EQ_EXPR;\n-\t    *op1_p = const_binop (PLUS_EXPR, op1, integer_one_node, 0);\n-\t    break;\n-\t  case LE_EXPR:\n-\t    *code_p = NE_EXPR;\n-\t    *op1_p = const_binop (PLUS_EXPR, op1, integer_one_node, 0);\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-      else if (TREE_INT_CST_HIGH (op1) == (min ? -1 : 0)\n-\t       && TREE_INT_CST_LOW (op1) == min)\n-       switch (code)\n-\t  {\n-\t  case LT_EXPR:\n-\t    return omit_one_operand (type, integer_zero_node, op0);\n-\n-\t  case LE_EXPR:\n-\t    *code_p = EQ_EXPR;\n-\t    break;\n-\n-\t  case GE_EXPR:\n-\t    return omit_one_operand (type, integer_one_node, op0);\n-\n-\t  case GT_EXPR:\n-\t    *code_p = NE_EXPR;\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-      else if (TREE_INT_CST_HIGH (op1) == (min ? -1 : 0)\n-\t       && TREE_INT_CST_LOW (op1) == min + 1)\n-\tswitch (code)\n-\t  {\n-\t  case GE_EXPR:\n-\t    *code_p = NE_EXPR;\n-\t    *op1_p = const_binop (MINUS_EXPR, op1, integer_one_node, 0);\n-\t    break;\n-\t  case LT_EXPR:\n-\t    *code_p = EQ_EXPR;\n-\t    *op1_p = const_binop (MINUS_EXPR, op1, integer_one_node, 0);\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-\n-      else if (TREE_INT_CST_HIGH (op1) == 0\n-\t       && TREE_INT_CST_LOW (op1) == signed_max\n-\t       && TYPE_UNSIGNED (TREE_TYPE (op1))\n-\t       /* signed_type does not work on pointer types.  */\n-\t       && INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n-\t{\n-\t  /* The following case also applies to X < signed_max+1\n-\t     and X >= signed_max+1 because previous transformations.  */\n-\t  if (code == LE_EXPR || code == GT_EXPR)\n-\t    {\n-\t      tree st0, st1, exp, retval;\n-\t      st0 = lang_hooks.types.signed_type (TREE_TYPE (op0));\n-\t      st1 = lang_hooks.types.signed_type (TREE_TYPE (op1));\n-\n-\t      exp = build2 (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t    type,\n-\t\t\t    fold_convert (st0, op0),\n-\t\t\t    fold_convert (st1, integer_zero_node));\n-\n-\t      retval = fold_binary_to_constant (TREE_CODE (exp),\n-\t\t\t\t\t\tTREE_TYPE (exp),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 0),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 1));\n-\n-\t      /* If we are in gimple form, then returning EXP would create\n-\t\t non-gimple expressions.  Clearing it is safe and insures\n-\t\t we do not allow a non-gimple expression to escape.  */\n-\t      if (in_gimple_form)\n-\t\texp = NULL;\n-\n-\t      return (retval ? retval : exp);\n-\t    }\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\n /* Given the components of a binary expression CODE, TYPE, OP0 and OP1,\n    attempt to fold the expression to a constant without modifying TYPE,\n    OP0 or OP1.\n@@ -10958,282 +10804,8 @@ fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n tree\n fold_binary_to_constant (enum tree_code code, tree type, tree op0, tree op1)\n {\n-  int wins = 1;\n-  tree subop0;\n-  tree subop1;\n-  tree tem;\n-\n-  /* If this is a commutative operation, and ARG0 is a constant, move it\n-     to ARG1 to reduce the number of tests below.  */\n-  if (commutative_tree_code (code)\n-      && (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST))\n-    {\n-      tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n-    }\n-\n-  /* If either operand is a complex type, extract its real component.  */\n-  if (TREE_CODE (op0) == COMPLEX_CST)\n-    subop0 = TREE_REALPART (op0);\n-  else\n-    subop0 = op0;\n-\n-  if (TREE_CODE (op1) == COMPLEX_CST)\n-    subop1 = TREE_REALPART (op1);\n-  else\n-    subop1 = op1;\n-\n-  /* Note if either argument is not a real or integer constant.\n-     With a few exceptions, simplification is limited to cases\n-     where both arguments are constants.  */\n-  if ((TREE_CODE (subop0) != INTEGER_CST\n-       && TREE_CODE (subop0) != REAL_CST)\n-      || (TREE_CODE (subop1) != INTEGER_CST\n-\t  && TREE_CODE (subop1) != REAL_CST))\n-    wins = 0;\n-\n-  switch (code)\n-    {\n-    case PLUS_EXPR:\n-      /* (plus (address) (const_int)) is a constant.  */\n-      if (TREE_CODE (op0) == PLUS_EXPR\n-\t  && TREE_CODE (op1) == INTEGER_CST\n-\t  && (TREE_CODE (TREE_OPERAND (op0, 0)) == ADDR_EXPR\n-\t      || (TREE_CODE (TREE_OPERAND (op0, 0)) == NOP_EXPR\n-\t\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (op0, 0), 0))\n-\t\t      == ADDR_EXPR)))\n-\t  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST)\n-\t{\n-          return build2 (PLUS_EXPR, type, TREE_OPERAND (op0, 0),\n-\t\t\t const_binop (PLUS_EXPR, op1,\n-\t\t\t\t      TREE_OPERAND (op0, 1), 0));\n-\t}\n-    case BIT_XOR_EXPR:\n-\n-    binary:\n-      if (!wins)\n-\treturn NULL_TREE;\n-\n-      /* Both arguments are constants.  Simplify.  */\n-      tem = const_binop (code, op0, op1, 0);\n-      if (tem != NULL_TREE)\n-\t{\n-\t  /* The return value should always have the same type as\n-\t     the original expression.  */\n-\t  if (TREE_TYPE (tem) != type)\n-\t    tem = fold_convert (type, tem);\n-\n-\t  return tem;\n-\t}\n-      return NULL_TREE;\n-\n-    case MINUS_EXPR:\n-      /* Fold &x - &x.  This can happen from &x.foo - &x.\n-         This is unsafe for certain floats even in non-IEEE formats.\n-         In IEEE, it is unsafe because it does wrong for NaNs.\n-         Also note that operand_equal_p is always false if an\n-         operand is volatile.  */\n-      if (! FLOAT_TYPE_P (type) && operand_equal_p (op0, op1, 0))\n-\treturn fold_convert (type, integer_zero_node);\n-\n-      goto binary;\n-\n-    case MULT_EXPR:\n-    case BIT_AND_EXPR:\n-      /* Special case multiplication or bitwise AND where one argument\n-\t is zero.  */\n-      if (! FLOAT_TYPE_P (type) && integer_zerop (op1))\n-\treturn omit_one_operand (type, op1, op0);\n-      else\n-        if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (op0)))\n-\t    && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op0)))\n-\t    && real_zerop (op1))\n-\t  return omit_one_operand (type, op1, op0);\n-\n-      goto binary;\n-\n-    case BIT_IOR_EXPR:\n-      /* Special case when we know the result will be all ones.  */\n-      if (integer_all_onesp (op1))\n-\treturn omit_one_operand (type, op1, op0);\n-\n-      goto binary;\n-\n-    case TRUNC_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case RDIV_EXPR:\n-      /* Division by zero is undefined.  */\n-      if (integer_zerop (op1))\n-      \treturn NULL_TREE;\n-\n-      if (TREE_CODE (op1) == REAL_CST\n-\t  && !MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (op1)))\n-\t  && real_zerop (op1))\n-\treturn NULL_TREE;\n-\n-      goto binary;\n-\n-    case MIN_EXPR:\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && operand_equal_p (op1, TYPE_MIN_VALUE (type), OEP_ONLY_CONST))\n-\treturn omit_one_operand (type, op1, op0);\n-\n-      goto binary;\n-\n-    case MAX_EXPR:\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && TYPE_MAX_VALUE (type)\n-\t  && operand_equal_p (op1, TYPE_MAX_VALUE (type), OEP_ONLY_CONST))\n-\treturn omit_one_operand (type, op1, op0);\n-\n-      goto binary;\n-\n-    case RSHIFT_EXPR:\n-      /* Optimize -1 >> x for arithmetic right shifts.  */\n-      if (integer_all_onesp (op0) && ! TYPE_UNSIGNED (type))\n-\treturn omit_one_operand (type, op0, op1);\n-      /* ... fall through ...  */\n-\n-    case LSHIFT_EXPR:\n-      if (integer_zerop (op0))\n-\treturn omit_one_operand (type, op0, op1);\n-\n-      /* Since negative shift count is not well-defined, don't\n-\t try to compute it in the compiler.  */\n-      if (TREE_CODE (op1) == INTEGER_CST && tree_int_cst_sgn (op1) < 0)\n-\treturn NULL_TREE;\n-\n-      goto binary;\n-\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-      /* -1 rotated either direction by any amount is still -1.  */\n-      if (integer_all_onesp (op0))\n-\treturn omit_one_operand (type, op0, op1);\n-\n-      /* 0 rotated either direction by any amount is still zero.  */\n-      if (integer_zerop (op0))\n-\treturn omit_one_operand (type, op0, op1);\n-\n-      goto binary;\n-\n-    case COMPLEX_EXPR:\n-      if (wins)\n-\treturn build_complex (type, op0, op1);\n-      return NULL_TREE;\n-\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      /* If one arg is a real or integer constant, put it last.  */\n-      if ((TREE_CODE (op0) == INTEGER_CST\n-\t   && TREE_CODE (op1) != INTEGER_CST)\n-\t  || (TREE_CODE (op0) == REAL_CST\n-\t      && TREE_CODE (op0) != REAL_CST))\n-\t{\n-\t  tree temp;\n-\n-\t  temp = op0;\n-\t  op0 = op1;\n-\t  op1 = temp;\n-\t  code = swap_tree_comparison (code);\n-\t}\n-\n-      /* Change X >= C to X > (C - 1) and X < C to X <= (C - 1) if C > 0.\n-\t This transformation affects the cases which are handled in later\n-\t optimizations involving comparisons with non-negative constants.  */\n-      if (TREE_CODE (op1) == INTEGER_CST\n-\t  && TREE_CODE (op0) != INTEGER_CST\n-\t  && tree_int_cst_sgn (op1) > 0)\n-\t{\n-\t  switch (code)\n-\t    {\n-\t    case GE_EXPR:\n-\t      code = GT_EXPR;\n-\t      op1 = const_binop (MINUS_EXPR, op1, integer_one_node, 0);\n-\t      break;\n-\n-\t    case LT_EXPR:\n-\t      code = LE_EXPR;\n-\t      op1 = const_binop (MINUS_EXPR, op1, integer_one_node, 0);\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n-      tem = fold_relational_hi_lo (&code, type, &op0, &op1);\n-      if (tem)\n-\treturn tem;\n-\n-      /* Fall through.  */\n-\n-    case ORDERED_EXPR:\n-    case UNORDERED_EXPR:\n-    case UNLT_EXPR:\n-    case UNLE_EXPR:\n-    case UNGT_EXPR:\n-    case UNGE_EXPR:\n-    case UNEQ_EXPR:\n-    case LTGT_EXPR:\n-      if (!wins)\n-\treturn NULL_TREE;\n-\n-      return fold_relational_const (code, type, op0, op1);\n-\n-    case RANGE_EXPR:\n-      /* This could probably be handled.  */\n-      return NULL_TREE;\n-\n-    case TRUTH_AND_EXPR:\n-      /* If second arg is constant zero, result is zero, but first arg\n-\t must be evaluated.  */\n-      if (integer_zerop (op1))\n-\treturn omit_one_operand (type, op1, op0);\n-      /* Likewise for first arg, but note that only the TRUTH_AND_EXPR\n-\t case will be handled here.  */\n-      if (integer_zerop (op0))\n-\treturn omit_one_operand (type, op0, op1);\n-      if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n-\treturn constant_boolean_node (true, type);\n-      return NULL_TREE;\n-\n-    case TRUTH_OR_EXPR:\n-      /* If second arg is constant true, result is true, but we must\n-\t evaluate first arg.  */\n-      if (TREE_CODE (op1) == INTEGER_CST && ! integer_zerop (op1))\n-\treturn omit_one_operand (type, op1, op0);\n-      /* Likewise for first arg, but note this only occurs here for\n-\t TRUTH_OR_EXPR.  */\n-      if (TREE_CODE (op0) == INTEGER_CST && ! integer_zerop (op0))\n-\treturn omit_one_operand (type, op0, op1);\n-      if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n-\treturn constant_boolean_node (false, type);\n-      return NULL_TREE;\n-\n-    case TRUTH_XOR_EXPR:\n-      if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n-\t{\n-\t  int x = ! integer_zerop (op0) ^ ! integer_zerop (op1);\n-\t  return constant_boolean_node (x, type);\n-\t}\n-      return NULL_TREE;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n+  tree tem = fold_binary (code, type, op0, op1);\n+  return (tem && TREE_CONSTANT (tem)) ? tem : NULL_TREE;\n }\n \n /* Given the components of a unary expression CODE, TYPE and OP0,\n@@ -11252,71 +10824,8 @@ fold_binary_to_constant (enum tree_code code, tree type, tree op0, tree op1)\n tree\n fold_unary_to_constant (enum tree_code code, tree type, tree op0)\n {\n-  /* Make sure we have a suitable constant argument.  */\n-  if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n-    {\n-      tree subop;\n-\n-      if (TREE_CODE (op0) == COMPLEX_CST)\n-\tsubop = TREE_REALPART (op0);\n-      else\n-\tsubop = op0;\n-\n-      if (TREE_CODE (subop) != INTEGER_CST && TREE_CODE (subop) != REAL_CST)\n-\treturn NULL_TREE;\n-    }\n-\n-  switch (code)\n-    {\n-    case NOP_EXPR:\n-    case FLOAT_EXPR:\n-    case CONVERT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_CEIL_EXPR:\n-    case FIX_ROUND_EXPR:\n-      return fold_convert_const (code, type, op0);\n-\n-    case NEGATE_EXPR:\n-      if (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST)\n-\treturn fold_negate_const (op0, type);\n-      else\n-\treturn NULL_TREE;\n-\n-    case ABS_EXPR:\n-      if (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST)\n-\treturn fold_abs_const (op0, type);\n-      else\n-\treturn NULL_TREE;\n-\n-    case BIT_NOT_EXPR:\n-      if (TREE_CODE (op0) == INTEGER_CST)\n-\treturn fold_not_const (op0, type);\n-      else\n-\treturn NULL_TREE;\n-\n-    case REALPART_EXPR:\n-      if (TREE_CODE (op0) == COMPLEX_CST)\n-\treturn TREE_REALPART (op0);\n-      else\n-\treturn NULL_TREE;\n-\n-    case IMAGPART_EXPR:\n-      if (TREE_CODE (op0) == COMPLEX_CST)\n-\treturn TREE_IMAGPART (op0);\n-      else\n-\treturn NULL_TREE;\n-\n-    case CONJ_EXPR:\n-      if (TREE_CODE (op0) == COMPLEX_CST\n-\t  && TREE_CODE (TREE_TYPE (op0)) == COMPLEX_TYPE)\n-\treturn build_complex (type, TREE_REALPART (op0),\n-\t\t\t      negate_expr (TREE_IMAGPART (op0)));\n-      return NULL_TREE;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n+  tree tem = fold_unary (code, type, op0);\n+  return (tem && TREE_CONSTANT (tem)) ? tem : NULL_TREE;\n }\n \n /* If EXP represents referencing an element in a constant string"}]}