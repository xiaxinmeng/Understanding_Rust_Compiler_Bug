{"sha": "0812b84e77d5b5d187ea4c75841e4569f016612f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgxMmI4NGU3N2Q1YjVkMTg3ZWE0Yzc1ODQxZTQ1NjlmMDE2NjEyZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:28:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:28:45Z"}, "message": "[multiple changes]\n\n2013-04-25  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Remove d.X and d.Y entries and documentation.\n\t* exp_ch4.adb (Expand_N_If_Expression): Remove special code used\n\tif expression with actions not available (now always available).\n\t(Expand_Short_Circuit_Operator): Same change.\n\t* gnat1drv.adb (Adjust_Global_Switches) Remove setting\n\tUse_Expression_With_Actions flag, since this is now obsolete.\n\t* opt.ads (Use_Expression_Actions): Removed (always True now).\n\t* sinfo.ads: Minor comment updates.\n\n2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Check_Generic_Actuals): If an actual is an array\n\tsubtype whose base type is currently private, install full view\n\twhen compiling instance body.\n\n2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_disp.adb (Check_Dispatching_Operation): Refine checks for\n\tAI05-0125: the check for a hidden primitive that may be overridden\n\tby the new declaration is only performed if the declaration comes\n\tfrom source, and it must carry an explicit overriding indicator.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Abstract_States): The attribute now applies to\n\tgeneric packages.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Check whether an\n\tobject declaration introduces an illegal hidden state.\n\t* sem_prag.adb (Analyze_Abstract_State): Check whether a state\n\tdeclaration introduces an illegal hidden state.\n\t* sem_util.ads, sem_util.adb (Check_No_Hidden_State): New routine.\n\n2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Is_Build_In_Place_Function_Call): The call may\n\tbe to a protected function, in which case the name in the call\n\tis a selected component.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Quantified_Expression):\n\tWarn on a suspicious use of quantifier \"some\" when \"all\" was meant.\n\t(No_Else_Or_Trivial_True): New routine.\n\nFrom-SVN: r198287", "tree": {"sha": "1709a49cd2beccc5cb64451b8470a07e5801ea9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1709a49cd2beccc5cb64451b8470a07e5801ea9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0812b84e77d5b5d187ea4c75841e4569f016612f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0812b84e77d5b5d187ea4c75841e4569f016612f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0812b84e77d5b5d187ea4c75841e4569f016612f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0812b84e77d5b5d187ea4c75841e4569f016612f/comments", "author": null, "committer": null, "parents": [{"sha": "1355d3738f0cabb2029899b905305e728d75674a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1355d3738f0cabb2029899b905305e728d75674a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1355d3738f0cabb2029899b905305e728d75674a"}], "stats": {"total": 476, "additions": 261, "deletions": 215}, "files": [{"sha": "d40d2eb067833bd6454578b069785e07f4d084b4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -1,3 +1,49 @@\n+2013-04-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Remove d.X and d.Y entries and documentation.\n+\t* exp_ch4.adb (Expand_N_If_Expression): Remove special code used\n+\tif expression with actions not available (now always available).\n+\t(Expand_Short_Circuit_Operator): Same change.\n+\t* gnat1drv.adb (Adjust_Global_Switches) Remove setting\n+\tUse_Expression_With_Actions flag, since this is now obsolete.\n+\t* opt.ads (Use_Expression_Actions): Removed (always True now).\n+\t* sinfo.ads: Minor comment updates.\n+\n+2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Check_Generic_Actuals): If an actual is an array\n+\tsubtype whose base type is currently private, install full view\n+\twhen compiling instance body.\n+\n+2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_disp.adb (Check_Dispatching_Operation): Refine checks for\n+\tAI05-0125: the check for a hidden primitive that may be overridden\n+\tby the new declaration is only performed if the declaration comes\n+\tfrom source, and it must carry an explicit overriding indicator.\n+\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Abstract_States): The attribute now applies to\n+\tgeneric packages.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Check whether an\n+\tobject declaration introduces an illegal hidden state.\n+\t* sem_prag.adb (Analyze_Abstract_State): Check whether a state\n+\tdeclaration introduces an illegal hidden state.\n+\t* sem_util.ads, sem_util.adb (Check_No_Hidden_State): New routine.\n+\n+2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Is_Build_In_Place_Function_Call): The call may\n+\tbe to a protected function, in which case the name in the call\n+\tis a selected component.\n+\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Quantified_Expression):\n+\tWarn on a suspicious use of quantifier \"some\" when \"all\" was meant.\n+\t(No_Else_Or_Trivial_True): New routine.\n+\n 2013-04-25  Robert Dewar  <dewar@adacore.com>\n \n \t* einfo.ads, einfo.adb: Put back with/use for Namet."}, {"sha": "01624792c61a808d8c6f73c8ffd1a11dbfdb16ca", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -141,8 +141,8 @@ package body Debug is\n    --  d.U  Ignore indirect calls for static elaboration\n    --  d.V  Extensions for formal verification\n    --  d.W  Print out debugging information for Walk_Library_Items\n-   --  d.X  Use Expression_With_Actions\n-   --  d.Y  Do not use Expression_With_Actions\n+   --  d.X\n+   --  d.Y\n    --  d.Z  Dump flow analysis graphs, for debugging purposes (gnat2why)\n \n    --  d1   Error msgs have node numbers where possible\n@@ -675,14 +675,6 @@ package body Debug is\n    --       the order in which units are walked. This is primarily for use in\n    --       debugging CodePeer mode.\n \n-   --  d.X  By default, the compiler uses an elaborate rewriting framework for\n-   --       short-circuited forms where the right hand condition generates\n-   --       actions to be inserted. With the gcc backend, we now use the new\n-   --       N_Expression_With_Actions node for this expansion, but we still use\n-   --       the old method for other backends and in SCIL mode. This debug flag\n-   --       forces use of the new N_Expression_With_Actions node in these other\n-   --       cases and is intended for transitional use.\n-\n    --  d.Z  In gnat2why, in Flow analysis mode (-gnatd.Q), dump the different\n    --       graphs (control flow, control dependence) for debugging purposes.\n    --       This debug flag will be removed when flow analysis is sufficiently"}, {"sha": "c018363eae2e258df15f4e250c94431d8e255851", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -666,7 +666,7 @@ package body Einfo is\n \n    function Abstract_States (Id : E) return L is\n    begin\n-      pragma Assert (Ekind (Id) = E_Package);\n+      pragma Assert (Ekind_In (Id, E_Generic_Package, E_Package));\n       return Elist25 (Id);\n    end Abstract_States;\n "}, {"sha": "70dfce97e1d8d0284343d7d000f793387bbd4d9e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 27, "deletions": 164, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -5469,20 +5469,11 @@ package body Exp_Ch4 is\n          Remove (Expr);\n \n          if Present (Actions) then\n-\n-            --  If we are not allowed to use Expression_With_Actions, just skip\n-            --  the optimization, it is not critical for correctness.\n-\n-            if not Use_Expression_With_Actions then\n-               goto Skip_Optimization;\n-            end if;\n-\n             Rewrite (N,\n               Make_Expression_With_Actions (Loc,\n                 Expression => Relocate_Node (Expr),\n                 Actions    => Actions));\n             Analyze_And_Resolve (N, Typ);\n-\n          else\n             Rewrite (N, Relocate_Node (Expr));\n          end if;\n@@ -5494,8 +5485,6 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      <<Skip_Optimization>>\n-\n       --  If the type is limited or unconstrained, we expand as follows to\n       --  avoid any possibility of improper copies.\n \n@@ -5590,73 +5579,28 @@ package body Exp_Ch4 is\n \n       elsif Present (Then_Actions (N)) or else Present (Else_Actions (N)) then\n \n-         --  We have two approaches to handling this. If we are allowed to use\n-         --  N_Expression_With_Actions, then we can just wrap the actions into\n-         --  the appropriate expression.\n-\n-         if Use_Expression_With_Actions then\n-            if Present (Then_Actions (N)) then\n-               Rewrite (Thenx,\n-                 Make_Expression_With_Actions (Sloc (Thenx),\n-                   Actions    => Then_Actions (N),\n-                   Expression => Relocate_Node (Thenx)));\n-               Set_Then_Actions (N, No_List);\n-               Analyze_And_Resolve (Thenx, Typ);\n-            end if;\n-\n-            if Present (Else_Actions (N)) then\n-               Rewrite (Elsex,\n-                 Make_Expression_With_Actions (Sloc (Elsex),\n-                   Actions    => Else_Actions (N),\n-                   Expression => Relocate_Node (Elsex)));\n-               Set_Else_Actions (N, No_List);\n-               Analyze_And_Resolve (Elsex, Typ);\n-            end if;\n-\n-            return;\n-\n-            --  if we can't use N_Expression_With_Actions nodes, then we insert\n-            --  the following sequence of actions (using Insert_Actions):\n+         --  We now wrap the actions into the appropriate expression\n \n-            --      Cnn : typ;\n-            --      if cond then\n-            --         <<then actions>>\n-            --         Cnn := then-expr;\n-            --      else\n-            --         <<else actions>>\n-            --         Cnn := else-expr\n-            --      end if;\n-\n-            --  and replace the if expression by a reference to Cnn\n-\n-         else\n-            Cnn := Make_Temporary (Loc, 'C', N);\n-\n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Cnn,\n-                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n-\n-            New_If :=\n-              Make_Implicit_If_Statement (N,\n-                Condition       => Relocate_Node (Cond),\n-\n-                Then_Statements => New_List (\n-                  Make_Assignment_Statement (Sloc (Thenx),\n-                    Name       => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n-                    Expression => Relocate_Node (Thenx))),\n-\n-                Else_Statements => New_List (\n-                  Make_Assignment_Statement (Sloc (Elsex),\n-                    Name       => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n-                    Expression => Relocate_Node (Elsex))));\n-\n-            Set_Assignment_OK (Name (First (Then_Statements (New_If))));\n-            Set_Assignment_OK (Name (First (Else_Statements (New_If))));\n+         if Present (Then_Actions (N)) then\n+            Rewrite (Thenx,\n+                     Make_Expression_With_Actions (Sloc (Thenx),\n+                       Actions    => Then_Actions (N),\n+                       Expression => Relocate_Node (Thenx)));\n+            Set_Then_Actions (N, No_List);\n+            Analyze_And_Resolve (Thenx, Typ);\n+         end if;\n \n-            New_N := New_Occurrence_Of (Cnn, Loc);\n+         if Present (Else_Actions (N)) then\n+            Rewrite (Elsex,\n+                     Make_Expression_With_Actions (Sloc (Elsex),\n+                       Actions    => Else_Actions (N),\n+                       Expression => Relocate_Node (Elsex)));\n+            Set_Else_Actions (N, No_List);\n+            Analyze_And_Resolve (Elsex, Typ);\n          end if;\n \n+         return;\n+\n          --  If no actions then no expansion needed, gigi will handle it using\n          --  the same approach as a C conditional expression.\n \n@@ -11098,29 +11042,6 @@ package body Exp_Ch4 is\n       Shortcut_Ent   : constant Entity_Id := Boolean_Literals (Shortcut_Value);\n       --  If Left = Shortcut_Value then Right need not be evaluated\n \n-      function Make_Test_Expr (Opnd : Node_Id) return Node_Id;\n-      --  For Opnd a boolean expression, return a Boolean expression equivalent\n-      --  to Opnd /= Shortcut_Value.\n-\n-      --------------------\n-      -- Make_Test_Expr --\n-      --------------------\n-\n-      function Make_Test_Expr (Opnd : Node_Id) return Node_Id is\n-      begin\n-         if Shortcut_Value then\n-            return Make_Op_Not (Sloc (Opnd), Opnd);\n-         else\n-            return Opnd;\n-         end if;\n-      end Make_Test_Expr;\n-\n-      Op_Var : Entity_Id;\n-      --  Entity for a temporary variable holding the value of the operator,\n-      --  used for expansion in the case where actions are present.\n-\n-   --  Start of processing for Expand_Short_Circuit_Operator\n-\n    begin\n       --  Deal with non-standard booleans\n \n@@ -11172,77 +11093,19 @@ package body Exp_Ch4 is\n       --  must only be executed if the right operand of the short circuit is\n       --  executed and not otherwise.\n \n-      --  the temporary variable C.\n-\n       if Present (Actions (N)) then\n          Actlist := Actions (N);\n \n-         --  The old approach is to expand:\n-\n-         --     left AND THEN right\n-\n-         --  into\n-\n-         --     C : Boolean := False;\n-         --     IF left THEN\n-         --        Actions;\n-         --        IF right THEN\n-         --           C := True;\n-         --        END IF;\n-         --     END IF;\n-\n-         --  and finally rewrite the operator into a reference to C. Similarly\n-         --  for left OR ELSE right, with negated values. Note that this\n-         --  rewrite causes some difficulties for coverage analysis because\n-         --  of the introduction of the new variable C, which obscures the\n-         --  structure of the test.\n-\n-         --  We use this \"old approach\" if use of N_Expression_With_Actions\n-         --  is False (see description in Opt of when this is or is not set).\n+         --  We now use an Expression_With_Actions node for the right operand\n+         --  of the short-circuit form. Note that this solves the traceability\n+         --  problems for coverage analysis.\n \n-         if not Use_Expression_With_Actions then\n-            Op_Var := Make_Temporary (Loc, 'C', Related_Node => N);\n-\n-            Insert_Action (N,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier =>\n-                  Op_Var,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (Standard_Boolean, Loc),\n-                Expression          =>\n-                  New_Occurrence_Of (Shortcut_Ent, Loc)));\n-\n-            Append_To (Actlist,\n-              Make_Implicit_If_Statement (Right,\n-                Condition       => Make_Test_Expr (Right),\n-                Then_Statements => New_List (\n-                  Make_Assignment_Statement (LocR,\n-                    Name       => New_Occurrence_Of (Op_Var, LocR),\n-                    Expression =>\n-                      New_Occurrence_Of\n-                        (Boolean_Literals (not Shortcut_Value), LocR)))));\n-\n-            Insert_Action (N,\n-              Make_Implicit_If_Statement (Left,\n-                Condition       => Make_Test_Expr (Left),\n-                Then_Statements => Actlist));\n-\n-            Rewrite (N, New_Occurrence_Of (Op_Var, Loc));\n-            Analyze_And_Resolve (N, Standard_Boolean);\n-\n-         --  The new approach, activated for now by the use of debug flag\n-         --  -gnatd.X is to use the new Expression_With_Actions node for the\n-         --  right operand of the short-circuit form. This should solve the\n-         --  traceability problems for coverage analysis.\n-\n-         else\n-            Rewrite (Right,\n-              Make_Expression_With_Actions (LocR,\n-                Expression => Relocate_Node (Right),\n-                Actions    => Actlist));\n-            Set_Actions (N, No_List);\n-            Analyze_And_Resolve (Right, Standard_Boolean);\n-         end if;\n+         Rewrite (Right,\n+                  Make_Expression_With_Actions (LocR,\n+                    Expression => Relocate_Node (Right),\n+                    Actions    => Actlist));\n+         Set_Actions (N, No_List);\n+         Analyze_And_Resolve (Right, Standard_Boolean);\n \n          Adjust_Result_Type (N, Typ);\n          return;"}, {"sha": "cfcbb69982060bc29b81713636e3c8d71dc6da7b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -8110,6 +8110,11 @@ package body Exp_Ch6 is\n          elsif Nkind (Name (Exp_Node)) = N_Explicit_Dereference then\n             Function_Id := Etype (Name (Exp_Node));\n \n+         --  This may be a call to a protected function.\n+\n+         elsif Nkind (Name (Exp_Node)) = N_Selected_Component then\n+            Function_Id := Etype (Entity (Selector_Name (Name (Exp_Node))));\n+\n          else\n             raise Program_Error;\n          end if;"}, {"sha": "fa959df74074529ee65a07397fae913e52e79f3f", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -536,24 +536,6 @@ procedure Gnat1drv is\n       Suppress_Options.Suppress (Atomic_Synchronization) :=\n         not Atomic_Sync_Default_On_Target;\n \n-      --  Set switch indicating if we can use N_Expression_With_Actions\n-\n-      --  Debug flag -gnatd.X decisively sets usage on\n-\n-      if Debug_Flag_Dot_XX then\n-         Use_Expression_With_Actions := True;\n-\n-      --  Debug flag -gnatd.Y decisively sets usage off\n-\n-      elsif Debug_Flag_Dot_YY then\n-         Use_Expression_With_Actions := False;\n-\n-      --  Otherwise this feature is implemented, so we allow its use\n-\n-      else\n-         Use_Expression_With_Actions := True;\n-      end if;\n-\n       --  Set switch indicating if back end can handle limited types, and\n       --  guarantee that no incorrect copies are made (e.g. in the context\n       --  of an if or case expression)."}, {"sha": "01cbad1fc9a07bdb99c697a4ad02dcb96cea22e1", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -1460,13 +1460,6 @@ package Opt is\n    --  Set to True if -h (-gnath for the compiler) switch encountered\n    --  requesting usage information\n \n-   Use_Expression_With_Actions : Boolean;\n-   --  The N_Expression_With_Actions node has been introduced relatively\n-   --  recently, and not all back ends are prepared to handle it yet. So\n-   --  we use this flag to suppress its use during a transitional period.\n-   --  Currently the default is False for all cases (set in gnat1drv).\n-   --  The default can be modified using -gnatd.X/-gnatd.Y.\n-\n    Use_Pragma_Linker_Constructor : Boolean := False;\n    --  GNATBIND\n    --  True if pragma Linker_Constructor applies to adainit"}, {"sha": "29162bd40a820680f08d6e7db395a0dea3999a96", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -5468,7 +5468,9 @@ package body Sem_Ch12 is\n       --  previous formal in the same unit. The privacy status of the component\n       --  type will have been examined earlier in the traversal of the\n       --  corresponding actuals, and this status should not be modified for the\n-      --  array type itself.\n+      --  array (sub)type itself. However, if the base type of the array\n+      --  (sub)type is private, its full view must be restored in the body to\n+      --  be consistent with subsequent index subtypes, etc.\n       --\n       --  To detect this case we have to rescan the list of formals, which\n       --  is usually short enough to ignore the resulting inefficiency.\n@@ -5512,6 +5514,7 @@ package body Sem_Ch12 is\n            and then Is_Entity_Name (Subtype_Indication (Parent (E)))\n          then\n             if Is_Array_Type (E)\n+              and then not Is_Private_Type (Etype (E))\n               and then Denotes_Previous_Actual (Component_Type (E))\n             then\n                null;"}, {"sha": "bd0a51901a634b37d92dae1fb3879256ed93239a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -3720,6 +3720,13 @@ package body Sem_Ch3 is\n       end if;\n \n       Analyze_Dimension (N);\n+\n+      --  Verify whether the object declaration introduces an illegal hidden\n+      --  state within a package subject to a null abstract state.\n+\n+      if Formal_Extensions and then Ekind (Id) = E_Variable then\n+         Check_No_Hidden_State (Id);\n+      end if;\n    end Analyze_Object_Declaration;\n \n    ---------------------------"}, {"sha": "2fa9c5a9c38b9b17a716c57e1119c6c90c16a15a", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -3501,13 +3501,15 @@ package body Sem_Ch4 is\n    -----------------------------------\n \n    procedure Analyze_Quantified_Expression (N : Node_Id) is\n-      QE_Scop : Entity_Id;\n-\n       function Is_Empty_Range (Typ : Entity_Id) return Boolean;\n       --  If the iterator is part of a quantified expression, and the range is\n       --  known to be statically empty, emit a warning and replace expression\n       --  with its static value. Returns True if the replacement occurs.\n \n+      function No_Else_Or_Trivial_True (If_Expr : Node_Id) return Boolean;\n+      --  Determine whether if expression If_Expr lacks an else part or if it\n+      --  has one, it evaluates to True.\n+\n       --------------------\n       -- Is_Empty_Range --\n       --------------------\n@@ -3545,6 +3547,25 @@ package body Sem_Ch4 is\n          end if;\n       end Is_Empty_Range;\n \n+      -----------------------------\n+      -- No_Else_Or_Trivial_True --\n+      -----------------------------\n+\n+      function No_Else_Or_Trivial_True (If_Expr : Node_Id) return Boolean is\n+         Else_Expr : constant Node_Id :=\n+                       Next (Next (First (Expressions (If_Expr))));\n+      begin\n+         return\n+           No (Else_Expr)\n+             or else (Compile_Time_Known_Value (Else_Expr)\n+                       and then Is_True (Expr_Value (Else_Expr)));\n+      end No_Else_Or_Trivial_True;\n+\n+      --  Local variables\n+\n+      Cond    : constant Node_Id := Condition (N);\n+      QE_Scop : Entity_Id;\n+\n    --  Start of processing for Analyze_Quantified_Expression\n \n    begin\n@@ -3579,11 +3600,29 @@ package body Sem_Ch4 is\n          Preanalyze (Loop_Parameter_Specification (N));\n       end if;\n \n-      Preanalyze_And_Resolve (Condition (N), Standard_Boolean);\n+      Preanalyze_And_Resolve (Cond, Standard_Boolean);\n \n       End_Scope;\n \n       Set_Etype (N, Standard_Boolean);\n+\n+      --  Diagnose a possible misuse of the \"some\" existential quantifier. When\n+      --  we have a quantified expression of the form\n+      --\n+      --    for some X => (if P then Q [else True])\n+      --\n+      --  the if expression will not hold and render the quantified expression\n+      --  trivially True.\n+\n+      if Formal_Extensions\n+        and then not All_Present (N)\n+        and then Nkind (Cond) = N_If_Expression\n+        and then No_Else_Or_Trivial_True (Cond)\n+      then\n+         Error_Msg_N (\"?suspicious expression\", N);\n+         Error_Msg_N (\"\\\\did you mean (for all X ='> (if P then Q))\", N);\n+         Error_Msg_N (\"\\\\or (for some X ='> P and then Q) instead'?\", N);\n+      end if;\n    end Analyze_Quantified_Expression;\n \n    -------------------"}, {"sha": "8d779b27a8441f263fd9ea5a0d001a7ef5863218", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -1196,12 +1196,25 @@ package body Sem_Disp is\n       Ovr_Subp := Old_Subp;\n \n       --  [Ada 2012:AI-0125]: Search for inherited hidden primitive that may be\n-      --  overridden by Subp\n+      --  overridden by Subp. This only applies to source subprograms, and\n+      --  their declaration must carry an explicit overriding indicator.\n \n       if No (Ovr_Subp)\n         and then Ada_Version >= Ada_2012\n+        and then Comes_From_Source (Subp)\n+        and then\n+          Nkind (Unit_Declaration_Node (Subp)) = N_Subprogram_Declaration\n       then\n          Ovr_Subp := Find_Hidden_Overridden_Primitive (Subp);\n+\n+         --  Verify that the proper overriding indicator has been supplied.\n+\n+         if Present (Ovr_Subp)\n+           and then\n+             not Must_Override (Specification (Unit_Declaration_Node (Subp)))\n+         then\n+            Error_Msg_NE (\"missing overriding indicator for&\", Subp, Subp);\n+         end if;\n       end if;\n \n       --  Now it should be a correct primitive operation, put it in the list"}, {"sha": "01297f4e07014fc3f736f5cf578f3024a3053d45", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -8518,6 +8518,13 @@ package body Sem_Prag is\n                   Pop_Scope;\n                end if;\n \n+               --  Verify whether the state introduces an illegal hidden state\n+               --  within a package subject to a null abstract state.\n+\n+               if Formal_Extensions then\n+                  Check_No_Hidden_State (Id);\n+               end if;\n+\n                --  Associate the state with its related package\n \n                if No (Abstract_States (Pack_Id)) then"}, {"sha": "bf032fd7c6fea59a46d194882233b1c91b1f54e7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -2125,6 +2125,98 @@ package body Sem_Util is\n       end if;\n    end Check_Nested_Access;\n \n+   ---------------------------\n+   -- Check_No_Hidden_State --\n+   ---------------------------\n+\n+   procedure Check_No_Hidden_State (Id : Entity_Id) is\n+      function Has_Null_Abstract_State (Pkg : Entity_Id) return Boolean;\n+      --  Determine whether the entity of a package denoted by Pkg has a null\n+      --  abstract state.\n+\n+      -----------------------------\n+      -- Has_Null_Abstract_State --\n+      -----------------------------\n+\n+      function Has_Null_Abstract_State (Pkg : Entity_Id) return Boolean is\n+         States : constant Elist_Id := Abstract_States (Pkg);\n+\n+      begin\n+         --  Check the first available state of the related package. A null\n+         --  abstract state always appears as the sole element of the state\n+         --  list.\n+\n+         return\n+           Present (States)\n+             and then Is_Null_State (Node (First_Elmt (States)));\n+      end Has_Null_Abstract_State;\n+\n+      --  Local variables\n+\n+      Context     : Entity_Id := Empty;\n+      Not_Visible : Boolean   := False;\n+      Scop        : Entity_Id;\n+\n+   --  Start of processing for Check_No_Hidden_State\n+\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+\n+      --  Find the proper context where the object or state appears\n+\n+      Scop := Scope (Id);\n+      while Present (Scop) loop\n+         Context := Scop;\n+\n+         --  Keep track of the context's visibility\n+\n+         Not_Visible := Not_Visible or else In_Private_Part (Context);\n+\n+         --  Prevent the search from going too far\n+\n+         if Context = Standard_Standard then\n+            return;\n+\n+         --  Objects and states that appear immediately within a subprogram or\n+         --  inside a construct nested within a subprogram do not introduce a\n+         --  hidden state. They behave as local variable declarations.\n+\n+         elsif Is_Subprogram (Context) then\n+            return;\n+\n+         --  When examining a package body, use the entity of the spec as it\n+         --  carries the abstract state declarations.\n+\n+         elsif Ekind (Context) = E_Package_Body then\n+            Context := Spec_Entity (Context);\n+         end if;\n+\n+         --  Stop the traversal when a package subject to a null abstract state\n+         --  has been found.\n+\n+         if Ekind_In (Context, E_Generic_Package, E_Package)\n+           and then Has_Null_Abstract_State (Context)\n+         then\n+            exit;\n+         end if;\n+\n+         Scop := Scope (Scop);\n+      end loop;\n+\n+      --  At this point we know that there is at least one package with a null\n+      --  abstract state in visibility. Emit an error message unconditionally\n+      --  if the entity being processed is a state because the placement of the\n+      --  related package is irrelevant. This is not the case for objects as\n+      --  the intermediate context matters.\n+\n+      if Present (Context)\n+        and then (Ekind (Id) = E_Abstract_State or else Not_Visible)\n+      then\n+         Error_Msg_N (\"cannot introduce hidden state &\", Id);\n+         Error_Msg_NE (\"\\package & has null abstract state\", Id, Context);\n+      end if;\n+   end Check_No_Hidden_State;\n+\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------"}, {"sha": "fd9b9406b18b1eb776e65d7f69aec260fedf8d96", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -168,14 +168,14 @@ package Sem_Util is\n    --  the compilation unit, and install it in the Elaboration_Entity field\n    --  of Spec_Id, the entity for the compilation unit.\n \n-      procedure Build_Explicit_Dereference\n-        (Expr : Node_Id;\n-         Disc : Entity_Id);\n-      --  AI05-139: Names with implicit dereference. If the expression N is a\n-      --  reference type and the context imposes the corresponding designated\n-      --  type, convert N into N.Disc.all. Such expressions are always over-\n-      --  loaded with both interpretations, and the dereference interpretation\n-      --  carries the name of the reference discriminant.\n+   procedure Build_Explicit_Dereference\n+     (Expr : Node_Id;\n+      Disc : Entity_Id);\n+   --  AI05-139: Names with implicit dereference. If the expression N is a\n+   --  reference type and the context imposes the corresponding designated\n+   --  type, convert N into N.Disc.all. Such expressions are always over-\n+   --  loaded with both interpretations, and the dereference interpretation\n+   --  carries the name of the reference discriminant.\n \n    function Cannot_Raise_Constraint_Error (Expr : Node_Id) return Boolean;\n    --  Returns True if the expression cannot possibly raise Constraint_Error.\n@@ -231,6 +231,10 @@ package Sem_Util is\n    --  is accessed inside a nested procedure, and set Has_Up_Level_Access flag\n    --  accordingly. This is currently only enabled for VM_Target /= No_VM.\n \n+   procedure Check_No_Hidden_State (Id : Entity_Id);\n+   --  Determine whether object or state Id introduces a hidden state. If this\n+   --  is the case, emit an error.\n+\n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning."}, {"sha": "10b6e81062a2b8ba055ee64d640ebb0f4ba69aff", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0812b84e77d5b5d187ea4c75841e4569f016612f/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=0812b84e77d5b5d187ea4c75841e4569f016612f", "patch": "@@ -7121,8 +7121,8 @@ package Sinfo is\n       --  Expression (Node3)\n       --  plus fields for expression\n \n-      --  Note: the actions list is always non-null, since we would\n-      --  never have created this node if there weren't some actions.\n+      --  Note: the actions list is always non-null, since we would never have\n+      --  created this node if there weren't some actions.\n \n       --  Note: Expression may be a Null_Statement, in which case the\n       --  N_Expression_With_Actions has type Standard_Void_Type. However some"}]}