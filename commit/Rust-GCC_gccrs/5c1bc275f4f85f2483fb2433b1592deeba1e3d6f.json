{"sha": "5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMxYmMyNzVmNGY4NWYyNDgzZmIyNDMzYjE1OTJkZWViYTFlM2Q2Zg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2014-05-27T20:14:22Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-05-27T20:14:22Z"}, "message": "re PR c/56724 (sub-optimal location in error)\n\n\tPR c/56724\n\t* c-typeck.c (convert_arguments): Get location of a parameter.  Change\n\terror and warning calls to error_at and warning_at.  Pass location of\n\ta parameter to it.  Call warning_at with OPT_Wtraditional_conversion.\n\t(convert_for_assignment): Add parameter to WARN_FOR_ASSIGNMENT and\n\tWARN_FOR_QUALIFIERS.  Pass expr_loc to those.\n\n\t* gcc.dg/pr56724-1.c: New test.\n\t* gcc.dg/pr56724-2.c: New test.\n\t* gcc.dg/wtr-conversion-1.c: Use -Wtraditional-conversion instead of\n\t-Wtraditional.\n\t* gcc.dg/dfp/wtr-conversion-1.c: Likewise.\n\nFrom-SVN: r210980", "tree": {"sha": "45476b7f5627549943012d37331a2c5e9342711c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45476b7f5627549943012d37331a2c5e9342711c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c"}], "stats": {"total": 232, "additions": 164, "deletions": 68}, "files": [{"sha": "8e2ad465001c9611b8832c386f740184b59486d2", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -1,3 +1,12 @@\n+2014-05-27  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/56724\n+\t* c-typeck.c (convert_arguments): Get location of a parameter.  Change\n+\terror and warning calls to error_at and warning_at.  Pass location of\n+\ta parameter to it.  Call warning_at with OPT_Wtraditional_conversion.\n+\t(convert_for_assignment): Add parameter to WARN_FOR_ASSIGNMENT and\n+\tWARN_FOR_QUALIFIERS.  Pass expr_loc to those.\n+\n 2014-05-26  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR c/61191"}, {"sha": "6ca584bf38c665b619ab6892e4954d7e06e32b6e", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 80, "deletions": 66, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -3072,6 +3072,12 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n       bool excess_precision = false;\n       bool npc;\n       tree parmval;\n+      /* Some __atomic_* builtins have additional hidden argument at\n+\t position 0.  */\n+      location_t ploc\n+\t= !arg_loc.is_empty () && values->length () == arg_loc.length ()\n+\t  ? expansion_point_location_if_in_system_header (arg_loc[parmnum])\n+\t  : input_location;\n \n       if (type == void_type_node)\n \t{\n@@ -3114,7 +3120,8 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \n \t  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n \t    {\n-\t      error (\"type of formal parameter %d is incomplete\", parmnum + 1);\n+\t      error_at (ploc, \"type of formal parameter %d is incomplete\",\n+\t\t\tparmnum + 1);\n \t      parmval = val;\n \t    }\n \t  else\n@@ -3129,34 +3136,40 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \n \t\t  if (INTEGRAL_TYPE_P (type)\n \t\t      && TREE_CODE (valtype) == REAL_TYPE)\n-\t\t    warning (0, \"passing argument %d of %qE as integer \"\n-\t\t\t     \"rather than floating due to prototype\",\n-\t\t\t     argnum, rname);\n+\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t\"passing argument %d of %qE as integer rather \"\n+\t\t\t\t\"than floating due to prototype\",\n+\t\t\t\targnum, rname);\n \t\t  if (INTEGRAL_TYPE_P (type)\n \t\t      && TREE_CODE (valtype) == COMPLEX_TYPE)\n-\t\t    warning (0, \"passing argument %d of %qE as integer \"\n-\t\t\t     \"rather than complex due to prototype\",\n-\t\t\t     argnum, rname);\n+\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t\"passing argument %d of %qE as integer rather \"\n+\t\t\t\t\"than complex due to prototype\",\n+\t\t\t\targnum, rname);\n \t\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n \t\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n-\t\t    warning (0, \"passing argument %d of %qE as complex \"\n-\t\t\t     \"rather than floating due to prototype\",\n-\t\t\t     argnum, rname);\n+\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t\"passing argument %d of %qE as complex rather \"\n+\t\t\t\t\"than floating due to prototype\",\n+\t\t\t\targnum, rname);\n \t\t  else if (TREE_CODE (type) == REAL_TYPE\n \t\t\t   && INTEGRAL_TYPE_P (valtype))\n-\t\t    warning (0, \"passing argument %d of %qE as floating \"\n-\t\t\t     \"rather than integer due to prototype\",\n-\t\t\t     argnum, rname);\n+\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t\"passing argument %d of %qE as floating rather \"\n+\t\t\t\t\"than integer due to prototype\",\n+\t\t\t\targnum, rname);\n \t\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n \t\t\t   && INTEGRAL_TYPE_P (valtype))\n-\t\t    warning (0, \"passing argument %d of %qE as complex \"\n-\t\t\t     \"rather than integer due to prototype\",\n-\t\t\t     argnum, rname);\n+\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t\"passing argument %d of %qE as complex rather \"\n+\t\t\t\t\"than integer due to prototype\",\n+\t\t\t\targnum, rname);\n \t\t  else if (TREE_CODE (type) == REAL_TYPE\n \t\t\t   && TREE_CODE (valtype) == COMPLEX_TYPE)\n-\t\t    warning (0, \"passing argument %d of %qE as floating \"\n-\t\t\t     \"rather than complex due to prototype\",\n-\t\t\t     argnum, rname);\n+\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t\"passing argument %d of %qE as floating rather \"\n+\t\t\t\t\"than complex due to prototype\",\n+\t\t\t\targnum, rname);\n \t\t  /* ??? At some point, messages should be written about\n \t\t     conversions between complex types, but that's too messy\n \t\t     to do now.  */\n@@ -3167,9 +3180,10 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\t\t since without a prototype it would be `double'.  */\n \t\t      if (formal_prec == TYPE_PRECISION (float_type_node)\n \t\t\t  && type != dfloat32_type_node)\n-\t\t\twarning (0, \"passing argument %d of %qE as %<float%> \"\n-\t\t\t\t \"rather than %<double%> due to prototype\",\n-\t\t\t\t argnum, rname);\n+\t\t\twarning_at (ploc, 0,\n+\t\t\t\t    \"passing argument %d of %qE as %<float%> \"\n+\t\t\t\t    \"rather than %<double%> due to prototype\",\n+\t\t\t\t    argnum, rname);\n \n \t\t      /* Warn if mismatch between argument and prototype\n \t\t\t for decimal float types.  Warn of conversions with\n@@ -3192,9 +3206,10 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\t\t\t   || (type == dfloat64_type_node\n \t\t\t\t       && (valtype\n \t\t\t\t\t   != dfloat32_type_node))))\n-\t\t\twarning (0, \"passing argument %d of %qE as %qT \"\n-\t\t\t\t \"rather than %qT due to prototype\",\n-\t\t\t\t argnum, rname, type, valtype);\n+\t\t\twarning_at (ploc, 0,\n+\t\t\t\t    \"passing argument %d of %qE as %qT \"\n+\t\t\t\t    \"rather than %qT due to prototype\",\n+\t\t\t\t    argnum, rname, type, valtype);\n \n \t\t    }\n \t\t  /* Detect integer changing in width or signedness.\n@@ -3213,10 +3228,10 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\t\t   and the actual arg is that enum type.  */\n \t\t\t;\n \t\t      else if (formal_prec != TYPE_PRECISION (type1))\n-\t\t\twarning (OPT_Wtraditional_conversion,\n-\t\t\t\t \"passing argument %d of %qE \"\n-\t\t\t\t \"with different width due to prototype\",\n-\t\t\t\t argnum, rname);\n+\t\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t    \"passing argument %d of %qE \"\n+\t\t\t\t    \"with different width due to prototype\",\n+\t\t\t\t    argnum, rname);\n \t\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n \t\t\t;\n \t\t      /* Don't complain if the formal parameter type\n@@ -3237,14 +3252,15 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\t\t       && TYPE_UNSIGNED (valtype))\n \t\t\t;\n \t\t      else if (TYPE_UNSIGNED (type))\n-\t\t\twarning (OPT_Wtraditional_conversion,\n-\t\t\t\t \"passing argument %d of %qE \"\n-\t\t\t\t \"as unsigned due to prototype\",\n-\t\t\t\t argnum, rname);\n+\t\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t    \"passing argument %d of %qE \"\n+\t\t\t\t    \"as unsigned due to prototype\",\n+\t\t\t\t    argnum, rname);\n \t\t      else\n-\t\t\twarning (OPT_Wtraditional_conversion,\n-\t\t\t\t \"passing argument %d of %qE \"\n-\t\t\t\t \"as signed due to prototype\", argnum, rname);\n+\t\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\t    \"passing argument %d of %qE \"\n+\t\t\t\t    \"as signed due to prototype\",\n+\t\t\t\t    argnum, rname);\n \t\t    }\n \t\t}\n \n@@ -3253,13 +3269,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t      if (excess_precision)\n \t\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n \t      origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n-\t      bool arg_loc_ok = !arg_loc.is_empty ()\n-\t\t\t\t/* Some __atomic_* builtins have additional\n-\t\t\t\t   hidden argument at position 0.  */\n-\t\t\t\t&& values->length () == arg_loc.length ();\n-\t      parmval = convert_for_assignment (loc,\n-\t\t\t\t\t\targ_loc_ok ? arg_loc[parmnum]\n-\t\t\t\t\t\t: UNKNOWN_LOCATION, type,\n+\t      parmval = convert_for_assignment (loc, ploc, type,\n \t\t\t\t\t\tval, origtype, ic_argpass,\n \t\t\t\t\t\tnpc, fundecl, function,\n \t\t\t\t\t\tparmnum + 1);\n@@ -3283,10 +3293,10 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t    {\n \t      /* Convert `float' to `double'.  */\n \t      if (warn_double_promotion && !c_inhibit_evaluation_warnings)\n-\t\twarning_at (arg_loc[parmnum], OPT_Wdouble_promotion,\n-\t\t\t \"implicit conversion from %qT to %qT when passing \"\n-\t\t\t \"argument to function\",\n-\t\t\t valtype, double_type_node);\n+\t\twarning_at (ploc, OPT_Wdouble_promotion,\n+\t\t\t    \"implicit conversion from %qT to %qT when passing \"\n+\t\t\t    \"argument to function\",\n+\t\t\t    valtype, double_type_node);\n \t      parmval = convert (double_type_node, val);\n \t    }\n \t}\n@@ -5657,14 +5667,14 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n      compile time.  */\n-#define WARN_FOR_ASSIGNMENT(LOCATION, OPT, AR, AS, IN, RE)\t\t \\\n+#define WARN_FOR_ASSIGNMENT(LOCATION, PLOC, OPT, AR, AS, IN, RE)\t \\\n   do {                                                                   \\\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n-        if (pedwarn (LOCATION, OPT, AR, parmnum, rname))                 \\\n+        if (pedwarn (PLOC, OPT, AR, parmnum, rname))\t\t\t \\\n           inform ((fundecl && !DECL_IS_BUILTIN (fundecl))\t         \\\n-\t\t  ? DECL_SOURCE_LOCATION (fundecl) : LOCATION,\t\t \\\n+\t\t  ? DECL_SOURCE_LOCATION (fundecl) : PLOC,\t\t \\\n                   \"expected %qT but argument is of type %qT\",            \\\n                   type, rhstype);                                        \\\n         break;                                                           \\\n@@ -5687,25 +5697,25 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n      compile time.  It is the same as WARN_FOR_ASSIGNMENT but with an\n      extra parameter to enumerate qualifiers.  */\n \n-#define WARN_FOR_QUALIFIERS(LOCATION, OPT, AR, AS, IN, RE, QUALS)        \\\n+#define WARN_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS)  \\\n   do {                                                                   \\\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n-        if (pedwarn (LOCATION, OPT, AR, parmnum, rname, QUALS))          \\\n+        if (pedwarn (PLOC, OPT, AR, parmnum, rname, QUALS))\t\t \\\n           inform ((fundecl && !DECL_IS_BUILTIN (fundecl))\t         \\\n-\t      \t  ? DECL_SOURCE_LOCATION (fundecl) : LOCATION,\t\t \\\n+\t\t  ? DECL_SOURCE_LOCATION (fundecl) : PLOC,\t\t \\\n                   \"expected %qT but argument is of type %qT\",            \\\n                   type, rhstype);                                        \\\n         break;                                                           \\\n       case ic_assign:                                                    \\\n-        pedwarn (LOCATION, OPT, AS, QUALS);                          \\\n+        pedwarn (LOCATION, OPT, AS, QUALS);\t\t\t\t \\\n         break;                                                           \\\n       case ic_init:                                                      \\\n-        pedwarn (LOCATION, OPT, IN, QUALS);                          \\\n+        pedwarn (LOCATION, OPT, IN, QUALS);\t\t\t\t \\\n         break;                                                           \\\n       case ic_return:                                                    \\\n-        pedwarn (LOCATION, OPT, RE, QUALS);                        \t \\\n+        pedwarn (LOCATION, OPT, RE, QUALS);\t\t\t\t \\\n         break;                                                           \\\n       default:                                                           \\\n         gcc_unreachable ();                                              \\\n@@ -5754,7 +5764,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n \t  && TYPE_MAIN_VARIANT (checktype) != TYPE_MAIN_VARIANT (type))\n \t{\n-\t  WARN_FOR_ASSIGNMENT (location, OPT_Wc___compat,\n+\t  WARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wc___compat,\n \t\t\t       G_(\"enum conversion when passing argument \"\n \t\t\t\t  \"%d of %qE is invalid in C++\"),\n \t\t\t       G_(\"enum conversion in assignment is \"\n@@ -5917,7 +5927,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t     vice-versa.  */\n \t\t  if (TYPE_QUALS_NO_ADDR_SPACE (ttl)\n \t\t      & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))\n-\t\t    WARN_FOR_QUALIFIERS (location, OPT_Wdiscarded_qualifiers,\n+\t\t    WARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t\t OPT_Wdiscarded_qualifiers,\n \t\t\t\t\t G_(\"passing argument %d of %qE \"\n \t\t\t\t\t    \"makes %q#v qualified function \"\n \t\t\t\t\t    \"pointer from unqualified\"),\n@@ -5933,7 +5944,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t}\n \t      else if (TYPE_QUALS_NO_ADDR_SPACE (ttr)\n \t\t       & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))\n-\t\tWARN_FOR_QUALIFIERS (location, OPT_Wdiscarded_qualifiers,\n+\t\tWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t     OPT_Wdiscarded_qualifiers,\n \t\t\t\t     G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t\"%qv qualifier from pointer target type\"),\n \t\t\t\t     G_(\"assignment discards %qv qualifier \"\n@@ -6095,7 +6107,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t  (VOID_TYPE_P (ttr)\n \t\t   && !null_pointer_constant\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    WARN_FOR_ASSIGNMENT (location, OPT_Wpedantic,\n+\t    WARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpedantic,\n \t\t\t\t G_(\"ISO C forbids passing argument %d of \"\n \t\t\t\t    \"%qE between function pointer \"\n \t\t\t\t    \"and %<void *%>\"),\n@@ -6114,7 +6126,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n \t\t  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))\n \t\t{\n-\t\t  WARN_FOR_QUALIFIERS (location, OPT_Wdiscarded_qualifiers,\n+\t\t  WARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t       OPT_Wdiscarded_qualifiers,\n \t\t\t\t       G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t  \"%qv qualifier from pointer target type\"),\n \t\t\t\t       G_(\"assignment discards %qv qualifier \"\n@@ -6132,7 +6145,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t;\n \t      /* If there is a mismatch, do warn.  */\n \t      else if (warn_pointer_sign)\n-\t\tWARN_FOR_ASSIGNMENT (location, OPT_Wpointer_sign,\n+\t\tWARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpointer_sign,\n \t\t\t\t     G_(\"pointer targets in passing argument \"\n \t\t\t\t\t\"%d of %qE differ in signedness\"),\n \t\t\t\t     G_(\"pointer targets in assignment \"\n@@ -6151,7 +6164,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_QUALS_NO_ADDR_SPACE (ttl)\n \t\t  & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))\n-\t\tWARN_FOR_QUALIFIERS (location, OPT_Wdiscarded_qualifiers,\n+\t\tWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t     OPT_Wdiscarded_qualifiers,\n \t\t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\t\"%q#v qualified function pointer \"\n \t\t\t\t\t\"from unqualified\"),\n@@ -6167,7 +6181,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n       else\n \t/* Avoid warning about the volatile ObjC EH puts on decls.  */\n \tif (!objc_ok)\n-\t  WARN_FOR_ASSIGNMENT (location, 0,\n+\t  WARN_FOR_ASSIGNMENT (location, expr_loc, 0,\n \t\t\t       G_(\"passing argument %d of %qE from \"\n \t\t\t\t  \"incompatible pointer type\"),\n \t\t\t       G_(\"assignment from incompatible pointer type\"),\n@@ -6190,7 +6204,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n       if (!null_pointer_constant)\n-\tWARN_FOR_ASSIGNMENT (location, 0,\n+\tWARN_FOR_ASSIGNMENT (location, expr_loc, 0,\n \t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\"pointer from integer without a cast\"),\n \t\t\t     G_(\"assignment makes pointer from integer \"\n@@ -6204,7 +6218,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n-      WARN_FOR_ASSIGNMENT (location, 0,\n+      WARN_FOR_ASSIGNMENT (location, expr_loc, 0,\n \t\t\t   G_(\"passing argument %d of %qE makes integer \"\n \t\t\t      \"from pointer without a cast\"),\n \t\t\t   G_(\"assignment makes integer from pointer \""}, {"sha": "cb8577a35609f712388961d68c0864313626eb7b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -1,3 +1,12 @@\n+2014-05-27  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/56724\n+\t* gcc.dg/pr56724-1.c: New test.\n+\t* gcc.dg/pr56724-2.c: New test.\n+\t* gcc.dg/wtr-conversion-1.c: Use -Wtraditional-conversion instead of\n+\t-Wtraditional.\n+\t* gcc.dg/dfp/wtr-conversion-1.c: Likewise.\n+\n 2014-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/fold-compare-8.c: New test."}, {"sha": "b85ff3e7c7d674b4ff75993bb248555d6f4c02ed", "filename": "gcc/testsuite/gcc.dg/dfp/wtr-conversion-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fwtr-conversion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fwtr-conversion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fwtr-conversion-1.c?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -3,7 +3,7 @@\n    Based on gcc.dg/wtr-conversion-1.c  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-Wtraditional\" } */\n+/* { dg-options \"-Wtraditional-conversion\" } */\n \n extern void foo_i (int);\n extern void foo_f (float);"}, {"sha": "4276c3f154beb7d6fdfef14b2490b01c65fe17e3", "filename": "gcc/testsuite/gcc.dg/pr56724-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56724-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56724-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56724-1.c?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -0,0 +1,33 @@\n+/* PR c/56724 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wtraditional-conversion\" } */\n+\n+extern void foo (int p[2][]); /* { dg-error \"array type has incomplete element type\" } */\n+extern void foo_i (int, int);\n+extern void foo_u (unsigned int);\n+extern void foo_f (int, float);\n+extern void foo_ll (long long);\n+extern void foo_cd (int, int, __complex__ double);\n+extern signed char sc;\n+extern int i;\n+extern unsigned int u;\n+extern float f;\n+extern double d;\n+extern __complex__ double cd;\n+\n+void\n+fn ()\n+{\n+  int p[1][1];\n+  foo (p); /* { dg-error \"8:type of formal parameter\" } */\n+  foo_i (1, f); /* { dg-warning \"13:passing argument\" } */\n+  foo_i (1, cd); /* { dg-warning \"13:passing argument\" } */\n+  foo_cd (1, 2, f); /* { dg-warning \"17:passing argument\" } */\n+  foo_f (9, i); /* { dg-warning \"13:passing argument\" } */\n+  foo_cd (2, 2, i); /* { dg-warning \"17:passing argument\" } */\n+  foo_f (2, cd); /* { dg-warning \"13:passing argument\" } */\n+  foo_f (2, d); /* { dg-warning \"13:passing argument\" } */\n+  foo_ll (sc); /* { dg-warning \"11:passing argument\" } */\n+  foo_u (i); /* { dg-warning \"10:passing argument\" } */\n+  foo_i (1, u); /* { dg-warning \"13:passing argument\" } */\n+}"}, {"sha": "4abb7d899e72fdc7f0e509a7cfcef7dec384aa62", "filename": "gcc/testsuite/gcc.dg/pr56724-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56724-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56724-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56724-2.c?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -0,0 +1,31 @@\n+/* PR c/56724 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat -Wpedantic\" } */\n+\n+enum E1 { A };\n+enum E2 { B };\n+extern void foo_E (enum E1);\n+extern void foo_v (void *p);\n+extern void foo_sc (int, int, signed char *);\n+extern unsigned char *uc;\n+extern signed char sc;\n+extern const signed char *csc;\n+extern float *f;\n+\n+void\n+foo (void)\n+{\n+  void (*fp)(void);\n+  const void (*ffp)(void);\n+  foo_v (fp); /* { dg-warning \"10:ISO C forbids passing argument\" } */\n+  foo_E (B); /* { dg-warning \"10:enum conversion when passing argument\" } */\n+  foo_sc (1, 2, uc); /* { dg-warning \"17:pointer targets in passing argument\" } */\n+  foo_sc (1, 2, f); /* { dg-warning \"17:passing argument\" } */\n+  foo_sc (1, 2, sc); /* { dg-warning \"17:passing argument\" } */\n+  foo_sc (uc, 2, &sc); /* { dg-warning \"11:passing argument\" } */\n+  foo_sc (1, 2, csc); /* { dg-warning \"17:passing argument\" } */\n+}\n+\n+typedef void (*fp)(void);\n+typedef void (*nrfp)(void) __attribute__((noreturn));\n+void f1 (nrfp); void f2 (fp x) { f1 (x); } extern int e; /* { dg-warning \"38:passing argument\" } */"}, {"sha": "9d2cd9999398f029da19b66c9062c9c05567368d", "filename": "gcc/testsuite/gcc.dg/wtr-conversion-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-conversion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1bc275f4f85f2483fb2433b1592deeba1e3d6f/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-conversion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-conversion-1.c?ref=5c1bc275f4f85f2483fb2433b1592deeba1e3d6f", "patch": "@@ -2,7 +2,7 @@\n    Note, gcc should omit these warnings in system header files.\n    By Kaveh R. Ghazi <ghazi@caip.rutgers.edu> 4/09/2001.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wtraditional\" } */\n+/* { dg-options \"-Wtraditional-conversion\" } */\n \n extern void foo_i (int);\n extern void foo_f (float);"}]}