{"sha": "52dd234b210c06bea54ef726995e1fce035329be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJkZDIzNGIyMTBjMDZiZWE1NGVmNzI2OTk1ZTFmY2UwMzUzMjliZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-10-12T23:34:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-10-12T23:34:09Z"}, "message": "re PR c/24255 (__transparent_union__ mishandled)\n\n        PR c/24255\n        * tree.h (DECL_TRANSPARENT_UNION): Remove.\n        * function.c (assign_parm_find_data_types): Don't support it.\n        * print-tree.c (print_node): Likewise.\n        * c-common.c (handle_transparent_union_attribute): Likewise.\n        Use build_duplicate_type.\n        * tree-inline.c (remap_type_1): Split out of remap_type;\n        properly remap aggregate fields.\n        (build_duplicate_type): New.\n        * doc/extend.texi (Variable Attributes): Remove documentation\n        for transparent_union.\n\nFrom-SVN: r105338", "tree": {"sha": "e0ba09b20b9401b57ddfd7bb96ac65cafde86a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ba09b20b9401b57ddfd7bb96ac65cafde86a0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52dd234b210c06bea54ef726995e1fce035329be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52dd234b210c06bea54ef726995e1fce035329be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52dd234b210c06bea54ef726995e1fce035329be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52dd234b210c06bea54ef726995e1fce035329be/comments", "author": null, "committer": null, "parents": [{"sha": "6deb03391308dcffb9bb4a4155cd27d7e60329f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6deb03391308dcffb9bb4a4155cd27d7e60329f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6deb03391308dcffb9bb4a4155cd27d7e60329f9"}], "stats": {"total": 166, "additions": 102, "deletions": 64}, "files": [{"sha": "308be618a8b9621af596c5e4079d5d70f49b7e1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -1,3 +1,17 @@\n+2005-10-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/24255\n+\t* tree.h (DECL_TRANSPARENT_UNION): Remove.\n+\t* function.c (assign_parm_find_data_types): Don't support it.\n+\t* print-tree.c (print_node): Likewise.\n+\t* c-common.c (handle_transparent_union_attribute): Likewise.\n+\tUse build_duplicate_type.\n+\t* tree-inline.c (remap_type_1): Split out of remap_type;\n+\tproperly remap aggregate fields.\n+\t(build_duplicate_type): New.\n+\t* doc/extend.texi (Variable Attributes): Remove documentation\n+\tfor transparent_union.\n+\n 2005-10-12  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/24284"}, {"sha": "c5b409e77c0ff172219562be3b5684134c93236b", "filename": "gcc/c-common.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -4309,39 +4309,43 @@ handle_transparent_union_attribute (tree *node, tree name,\n \t\t\t\t    tree ARG_UNUSED (args), int flags,\n \t\t\t\t    bool *no_add_attrs)\n {\n-  tree decl = NULL_TREE;\n-  tree *type = NULL;\n-  int is_type = 0;\n+  tree type = NULL;\n+\n+  *no_add_attrs = true;\n \n   if (DECL_P (*node))\n     {\n-      decl = *node;\n-      type = &TREE_TYPE (decl);\n-      is_type = TREE_CODE (*node) == TYPE_DECL;\n+      if (TREE_CODE (*node) != TYPE_DECL)\n+\tgoto ignored;\n+      node = &TREE_TYPE (*node);\n+      type = *node;\n     }\n   else if (TYPE_P (*node))\n-    type = node, is_type = 1;\n+    type = *node;\n+  else\n+    goto ignored;\n \n-  if (is_type\n-      && TREE_CODE (*type) == UNION_TYPE\n-      && (decl == 0\n-\t  || (TYPE_FIELDS (*type) != 0\n-\t      && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))))\n+  if (TREE_CODE (type) == UNION_TYPE)\n     {\n+      /* When IN_PLACE is set, leave the check for FIELDS and MODE to\n+\t the code in finish_struct.  */\n       if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_variant_type_copy (*type);\n-      TYPE_TRANSPARENT_UNION (*type) = 1;\n-    }\n-  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n-\t   && TREE_CODE (*type) == UNION_TYPE\n-\t   && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))\n-    DECL_TRANSPARENT_UNION (decl) = 1;\n-  else\n-    {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n-      *no_add_attrs = true;\n+\t{\n+\t  if (TYPE_FIELDS (type) == NULL_TREE\n+\t      || TYPE_MODE (type) != DECL_MODE (TYPE_FIELDS (type)))\n+\t    goto ignored;\n+\n+\t  /* A type variant isn't good enough, since we don't a cast\n+\t     to such a type removed as a no-op.  */\n+\t  *node = type = build_duplicate_type (type);\n+\t}\n+\n+      TYPE_TRANSPARENT_UNION (type) = 1;\n+      return NULL_TREE;\n     }\n \n+ ignored:\n+  warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n   return NULL_TREE;\n }\n "}, {"sha": "52a8cc271421b686404a643e8a9a7407766c2de5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -3019,14 +3019,6 @@ The @var{tls_model} argument should be one of @code{global-dynamic},\n \n Not all targets support this attribute.\n \n-@item transparent_union\n-This attribute, attached to a function parameter which is a union, means\n-that the corresponding argument may have the type of any union member,\n-but the argument is passed as if its type were that of the first union\n-member.  For more details see @xref{Type Attributes}.  You can also use\n-this attribute on a @code{typedef} for a union data type; then it\n-applies to all function parameters with that type.\n-\n @item unused\n This attribute, attached to a variable, means that the variable is meant\n to be possibly unused.  GCC will not produce a warning for this"}, {"sha": "7cff2a0d1dc6257cc784dea66ac179af30da7317", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -2013,9 +2013,8 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n   /* If the parm is to be passed as a transparent union, use the type of\n      the first field for the tests below.  We have already verified that\n      the modes are the same.  */\n-  if (DECL_TRANSPARENT_UNION (parm)\n-      || (TREE_CODE (passed_type) == UNION_TYPE\n-\t  && TYPE_TRANSPARENT_UNION (passed_type)))\n+  if (TREE_CODE (passed_type) == UNION_TYPE\n+      && TYPE_TRANSPARENT_UNION (passed_type))\n     passed_type = TREE_TYPE (TYPE_FIELDS (passed_type));\n \n   /* See if this arg was passed by invisible reference.  */"}, {"sha": "9a8a5bb742aff77be44afc92d5aac7cfc3594ce5", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -385,9 +385,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t    }\n \t}\n \n-      if (TREE_CODE (node) == PARM_DECL && DECL_TRANSPARENT_UNION (node))\n-\tfputs (\" transparent-union\", file);\n-\n       if (DECL_VIRTUAL_P (node))\n \tfputs (\" virtual\", file);\n       if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS)  && DECL_DEFER_OUTPUT (node))"}, {"sha": "0f7ea978b7221c0624d8de39fd58e90d2259bb6c", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -257,26 +257,10 @@ remap_decl (tree decl, inline_data *id)\n }\n \n static tree\n-remap_type (tree type, inline_data *id)\n+remap_type_1 (tree type, inline_data *id)\n {\n-  splay_tree_node node;\n   tree new, t;\n \n-  if (type == NULL)\n-    return type;\n-\n-  /* See if we have remapped this type.  */\n-  node = splay_tree_lookup (id->decl_map, (splay_tree_key) type);\n-  if (node)\n-    return (tree) node->value;\n-\n-  /* The type only needs remapping if it's variably modified.  */\n-  if (! variably_modified_type_p (type, id->callee))\n-    {\n-      insert_decl_map (id, type, type);\n-      return type;\n-    }\n-\n   /* We do need a copy.  build and register it now.  If this is a pointer or\n      reference type, remap the designated type and make a new pointer or\n      reference type.  */\n@@ -353,7 +337,18 @@ remap_type (tree type, inline_data *id)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      walk_tree (&TYPE_FIELDS (new), copy_body_r, id, NULL);\n+      {\n+\ttree f, nf = NULL;\n+\n+\tfor (f = TYPE_FIELDS (new); f ; f = TREE_CHAIN (f))\n+\t  {\n+\t    t = remap_decl (f, id);\n+\t    DECL_CONTEXT (t) = new;\n+\t    TREE_CHAIN (t) = nf;\n+\t    nf = t;\n+\t  }\n+\tTYPE_FIELDS (new) = nreverse (nf);\n+      }\n       break;\n \n     case OFFSET_TYPE:\n@@ -368,6 +363,29 @@ remap_type (tree type, inline_data *id)\n   return new;\n }\n \n+static tree\n+remap_type (tree type, inline_data *id)\n+{\n+  splay_tree_node node;\n+\n+  if (type == NULL)\n+    return type;\n+\n+  /* See if we have remapped this type.  */\n+  node = splay_tree_lookup (id->decl_map, (splay_tree_key) type);\n+  if (node)\n+    return (tree) node->value;\n+\n+  /* The type only needs remapping if it's variably modified.  */\n+  if (! variably_modified_type_p (type, id->callee))\n+    {\n+      insert_decl_map (id, type, type);\n+      return type;\n+    }\n+\n+  return remap_type_1 (type, id);\n+}\n+\n static tree\n remap_decls (tree decls, inline_data *id)\n {\n@@ -2959,3 +2977,23 @@ inlining_p (inline_data * id)\n {\n   return (!id->saving_p && !id->cloning_p && !id->versioning_p);\n }\n+\n+/* Duplicate a type, fields and all.  */\n+\n+tree\n+build_duplicate_type (tree type)\n+{\n+  inline_data id;\n+\n+  memset (&id, 0, sizeof (id));\n+  id.callee = current_function_decl;\n+  id.caller = current_function_decl;\n+  id.callee_cfun = cfun;\n+  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+\n+  type = remap_type_1 (type, &id);\n+\n+  splay_tree_delete (id.decl_map);\n+\n+  return type;\n+}"}, {"sha": "f54f6d34977f39509b118209df100d8d12531dd9", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52dd234b210c06bea54ef726995e1fce035329be/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=52dd234b210c06bea54ef726995e1fce035329be", "patch": "@@ -2199,12 +2199,11 @@ struct tree_decl_common GTY(())\n   /* In LABEL_DECL, this is DECL_ERROR_ISSUED.\n      In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */\n   unsigned decl_flag_0 : 1;\n-  /* In FIELD_DECL, this is DECL_PACKED\n-     In PARM_DECL, this is DECL_TRANSPARENT_UNION.  */\n+  /* In FIELD_DECL, this is DECL_PACKED.  */\n   unsigned decl_flag_1 : 1;\n   /* In FIELD_DECL, this is DECL_BIT_FIELD\n      In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL. \n-     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG*/  \n+     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG.  */  \n   unsigned decl_flag_2 : 1;  \n   /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P\n      In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR.  */\n@@ -2386,12 +2385,6 @@ struct tree_const_decl GTY(())\n    where the data was actually passed.  */\n #define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->parm_decl.incoming_rtl)\n \n-/* Used in PARM_DECLs whose type are unions to indicate that the\n-   argument should be passed in the same way that the first union\n-   alternative would be passed.  */\n-#define DECL_TRANSPARENT_UNION(NODE) \\\n-  (PARM_DECL_CHECK (NODE)->decl_common.decl_flag_1)\n-\n struct tree_parm_decl GTY(())\n {\n   struct tree_decl_with_rtl common;\n@@ -3989,6 +3982,7 @@ extern bool debug_find_tree (tree, tree);\n /* This is in tree-inline.c since the routine uses\n    data structures from the inliner.  */\n extern tree unsave_expr_now (tree);\n+extern tree build_duplicate_type (tree);\n \n /* In emit-rtl.c */\n extern rtx emit_line_note (location_t);"}]}