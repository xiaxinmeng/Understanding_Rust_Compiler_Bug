{"sha": "af29617a50b430ad3e9f2842fe31335d4488d1d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyOTYxN2E1MGI0MzBhZDNlOWYyODQyZmUzMTMzNWQ0NDg4ZDFkMw==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2015-10-23T12:40:33Z"}, "committer": {"name": "Alan Hayward", "email": "alahay01@gcc.gnu.org", "date": "2015-10-23T12:40:33Z"}, "message": "Support for vectorizing conditional expressions\n\n2015-10-23  Alan Hayward <alan.hayward@arm.com>\n\ngcc/\n\tPR tree-optimization/65947\n\t* tree-vect-loop.c\n\t(vect_is_simple_reduction_1): Find condition reductions.\n\t(vect_model_reduction_cost): Add condition reduction costs.\n\t(get_initial_def_for_reduction): Add condition reduction initial var.\n\t(vect_create_epilog_for_reduction): Add condition reduction epilog.\n\t(vectorizable_reduction): Condition reduction support.\n\t* tree-vect-stmts.c (vectorizable_condition): Add vect reduction arg\n\t* doc/sourcebuild.texi (Vector-specific attributes): Document\n\tvect_max_reduc\n\ngcc/testsuite\n\tPR tree-optimization/65947\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_max_reduc): Add.\n\t* gcc.dg/vect/pr65947-1.c: New test.\n\t* gcc.dg/vect/pr65947-2.c: New test.\n\t* gcc.dg/vect/pr65947-3.c: New test.\n\t* gcc.dg/vect/pr65947-4.c: New test.\n\t* gcc.dg/vect/pr65947-5.c: New test.\n\t* gcc.dg/vect/pr65947-6.c: New test.\n\t* gcc.dg/vect/pr65947-7.c: New test.\n\t* gcc.dg/vect/pr65947-8.c: New test.\n\t* gcc.dg/vect/pr65947-9.c: New test.\n\t* gcc.dg/vect/pr65947-10.c: New test.\n\t* gcc.dg/vect/pr65947-11.c: New test.\n\nFrom-SVN: r229245", "tree": {"sha": "ec11a15022b2040f90b22b7cbb903f7113eb29ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec11a15022b2040f90b22b7cbb903f7113eb29ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af29617a50b430ad3e9f2842fe31335d4488d1d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af29617a50b430ad3e9f2842fe31335d4488d1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af29617a50b430ad3e9f2842fe31335d4488d1d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af29617a50b430ad3e9f2842fe31335d4488d1d3/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3bf0d9a5805754b9cc449b8d8d5c64d9e98361a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bf0d9a5805754b9cc449b8d8d5c64d9e98361a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3bf0d9a5805754b9cc449b8d8d5c64d9e98361a"}], "stats": {"total": 1069, "additions": 964, "deletions": 105}, "files": [{"sha": "52dca17a557534c2b86bec9d3096e47838c470b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -1,3 +1,16 @@\n+2015-10-23  Alan Hayward <alan.hayward@arm.com>\n+\n+\tPR tree-optimization/65947\n+\t* tree-vect-loop.c\n+\t(vect_is_simple_reduction_1): Find condition reductions.\n+\t(vect_model_reduction_cost): Add condition reduction costs.\n+\t(get_initial_def_for_reduction): Add condition reduction initial var.\n+\t(vect_create_epilog_for_reduction): Add condition reduction epilog.\n+\t(vectorizable_reduction): Condition reduction support.\n+\t* tree-vect-stmts.c (vectorizable_condition): Add vect reduction arg\n+\t* doc/sourcebuild.texi (Vector-specific attributes): Document\n+\tvect_max_reduc\n+\n 2015-10-23  Richard Biener  <rguenther@suse.de>\n \n \t* Makefile.in (build/genmatch.o): Properly depend on is-a.h, tree.def"}, {"sha": "61de4a566dd0e28a8cac77dc6c21a89be0234b4f", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -1466,6 +1466,9 @@ Target supports conversion from @code{float} to @code{signed int}.\n \n @item vect_floatuint_cvt\n Target supports conversion from @code{float} to @code{unsigned int}.\n+\n+@item vect_max_reduc\n+Target supports max reduction for vectors.\n @end table\n \n @subsubsection Thread Local Storage attributes"}, {"sha": "f13e8dcfbf749046d867234be44252319a623ae4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -1,3 +1,20 @@\n+2015-10-23  Alan Hayward <alan.hayward@arm.com>\n+\n+\tPR tree-optimization/65947\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_max_reduc): Add.\n+\t* gcc.dg/vect/pr65947-1.c: New test.\n+\t* gcc.dg/vect/pr65947-2.c: New test.\n+\t* gcc.dg/vect/pr65947-3.c: New test.\n+\t* gcc.dg/vect/pr65947-4.c: New test.\n+\t* gcc.dg/vect/pr65947-5.c: New test.\n+\t* gcc.dg/vect/pr65947-6.c: New test.\n+\t* gcc.dg/vect/pr65947-7.c: New test.\n+\t* gcc.dg/vect/pr65947-8.c: New test.\n+\t* gcc.dg/vect/pr65947-9.c: New test.\n+\t* gcc.dg/vect/pr65947-10.c: New test.\n+\t* gcc.dg/vect/pr65947-11.c: New test.\n+\n 2015-10-23  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.c-torture/execute/20030125-1.c (floor, floorf, sin, sinf):"}, {"sha": "7933f5c861201a7720ca77d84671898586516914", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 32\n+\n+/* Simple condition reduction.  */\n+\n+int\n+condition_reduction (int *a, int min_v)\n+{\n+  int last = -1;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int a[N] = {\n+  11, -12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, -3, 4, 5, 6, 7, -8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+\n+  int ret = condition_reduction (a, 16);\n+\n+  if (ret != 19)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "9a43a6059fabc1ca527dd6305bf6482f2103fab4", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-10.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 32\n+\n+/* Non-integer data types.  */\n+\n+float\n+condition_reduction (float *a, float min_v)\n+{\n+  float last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  float a[N] = {\n+  11.5, 12.2, 13.22, 14.1, 15.2, 16.3, 17, 18.7, 19, 20,\n+  1, 2, 3.3, 4.3333, 5.5, 6.23, 7, 8.63, 9, 10.6,\n+  21, 22.12, 23.55, 24.76, 25, 26, 27.34, 28.765, 29, 30,\n+  31.111, 32.322\n+  };\n+\n+  float ret = condition_reduction (a, 16.7);\n+\n+  if (ret != (float)10.6)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+"}, {"sha": "6deff001bd0e0c7229f6187c2e617c554dfb9f6b", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-11.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-11.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 37\n+\n+/* Re-use the result of the condition inside the loop.  Will fail to\n+   vectorize.  */\n+\n+unsigned int\n+condition_reduction (unsigned int *a, unsigned int min_v, unsigned int *b)\n+{\n+  unsigned int last = N + 65;\n+\n+  for (unsigned int i = 0; i < N; i++)\n+    {\n+      if (b[i] < min_v)\n+\tlast = i;\n+      a[i] = last;\n+    }\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned int a[N] = {\n+  31, 32, 33, 34, 35, 36, 37,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n+  };\n+  unsigned int b[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  31, 32, 33, 34, 35, 36, 37\n+  };\n+\n+  unsigned int ret = condition_reduction (a, 16, b);\n+\n+  if (ret != 29)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "9c627d9d7d5c1c42f285a29a1a601b3bc60b8a5a", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 254\n+\n+/* Non-simple condition reduction.  */\n+\n+unsigned char\n+condition_reduction (unsigned char *a, unsigned char min_v)\n+{\n+  unsigned char last = 65;\n+\n+  for (unsigned char i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned char a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+  __builtin_memset (a+32, 43, N-32);\n+\n+  unsigned char ret = condition_reduction (a, 16);\n+\n+  if (ret != 10)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "e115de2a28259307e4eaa9cbbe2fa93663c22873", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-3.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 37\n+\n+/* Non-simple condition reduction with additional variable and unsigned\n+   types.  */\n+\n+unsigned int\n+condition_reduction (unsigned int *a, unsigned int min_v, unsigned int *b)\n+{\n+  unsigned int last = N + 65;\n+  unsigned int aval;\n+\n+  for (unsigned int i = 0; i < N; i++)\n+    {\n+      aval = a[i];\n+      if (b[i] < min_v)\n+\tlast = aval;\n+    }\n+  return last;\n+}\n+\n+\n+int\n+main (void)\n+{\n+  unsigned int a[N] = {\n+  31, 32, 33, 34, 35, 36, 37,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n+  };\n+  unsigned int b[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  31, 32, 33, 34, 35, 36, 37\n+  };\n+\n+  unsigned int ret = condition_reduction (a, 16, b);\n+\n+  if (ret != 13)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "76a0567aa5450e00de2d700123ffc930b4028486", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+\n+/* Condition reduction with no valid matches at runtime.  */\n+\n+int\n+condition_reduction (int *a, int min_v)\n+{\n+  int last = N + 96;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] > min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27\n+  };\n+\n+  int ret = condition_reduction (a, 46);\n+\n+  /* loop should never have found a value.  */\n+  if (ret != N + 96)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+"}, {"sha": "360e3b51ee15ecea3b5d590c93d524e143f0ffca", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-5.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 32\n+\n+/* Condition reduction where loop size is not known at compile time.  Will fail\n+   to vectorize.  Version inlined into main loop will vectorize.  */\n+\n+unsigned char\n+condition_reduction (unsigned char *a, unsigned char min_v, int count)\n+{\n+  unsigned char last = 65;\n+\n+  for (int i = 0; i < count; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned char a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+\n+  unsigned char ret = condition_reduction (a, 16, N);\n+\n+  if (ret != 10)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "4997ef79cae83585758436874ac109ca368a1fc1", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-6.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 30\n+\n+/* Condition reduction where loop type is different than the data type.  */\n+\n+int\n+condition_reduction (int *a, int min_v)\n+{\n+  int last = N + 65;\n+\n+  for (char i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+\n+int\n+main (void)\n+{\n+  int a[N] = {\n+  67, 32, 45, 43, 21, -11, 12, 3, 4, 5,\n+  6, 76, -32, 56, -32, -1, 4, 5, 6, 99,\n+  43, 22, -3, 22, 16, 34, 55, 31, 87, 324\n+  };\n+\n+  int ret = condition_reduction (a, 16);\n+\n+  if (ret != -3)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "1044119145477d4508930624c65df61592f82d88", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-7.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-7.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 43\n+\n+/* Condition reduction with comparison is a different type to the data.  Will\n+   fail to vectorize.  */\n+\n+int\n+condition_reduction (short *a, int min_v, int *b)\n+{\n+  int last = N + 65;\n+  short aval;\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      aval = a[i];\n+      if (b[i] < min_v)\n+\tlast = aval;\n+    }\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  short a[N] = {\n+  31, -32, 133, 324, 335, 36, 37, 45, 11, 65,\n+  1, -28, 3, 48, 5, -68, 7, 88, 89, 180,\n+  121, -122, 123, 124, -125, 126, 127, 128, 129, 130,\n+  11, 12, 13, 14, -15, -16, 17, 18, 19, 20,\n+  33, 27, 99\n+  };\n+  int b[N] = {\n+  11, -12, -13, 14, 15, 16, 17, 18, 19, 20,\n+  21, -22, 23, 24, -25, 26, 27, 28, 29, 30,\n+  1, 62, 3, 14, -15, 6, 37, 48, 99, 10,\n+  31, -32, 33, 34, -35, 36, 37, 56, 54, 22,\n+  73, 2, 87\n+  };\n+\n+  int ret = condition_reduction (a, 16, b);\n+\n+  if (ret != 27)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "5cdbbe0529c4aa2da2684d8cc780b5533d85767d", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-8.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-8.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+\n+/* Condition reduction with multiple types in the comparison.  Will fail to\n+   vectorize.  */\n+\n+int\n+condition_reduction (char *a, int min_v)\n+{\n+  int last = N + 65;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+\n+int\n+main (void)\n+{\n+  char a[N] = {\n+  1, 28, 3, 48, 5, 68, 7, -88, 89, 180,\n+  121, 122, -123, 124, 12, -12, 12, 67, 84, 122,\n+  67, 55, 112, 22, 45, 23, 111\n+  };\n+\n+  int ret = condition_reduction (a, 16);\n+\n+  if (ret != 12)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"multiple types in double reduction or condition reduction\" \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "d0da13f26b86b972fec961c6ebfdc62ade3ad900", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-9.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-9.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 255\n+\n+/* Condition reduction with maximum possible loop size.  Will fail to\n+   vectorize because the vectorisation requires a slot for default values.  */\n+\n+char\n+condition_reduction (char *a, char min_v)\n+{\n+  char last = -72;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = a[i];\n+\n+  return last;\n+}\n+\n+char\n+main (void)\n+{\n+  char a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+  __builtin_memset (a+32, 43, N-32);\n+\n+  char ret = condition_reduction (a, 16);\n+\n+  if (ret != 10)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "b5435194676f06fe82199576c46ffc45d53ecd68", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -6485,3 +6485,12 @@ proc check_effective_target_builtin_eh_return { } {\n \t}\n     } \"\" ]\n }\n+\n+# Return 1 if the target supports max reduction for vectors.\n+\n+proc check_effective_target_vect_max_reduc { } {\n+    if { [istarget aarch64*-*-*] || [istarget arm*-*-*] } {\n+\treturn 1\n+    }\n+    return 0\n+}"}, {"sha": "0ce774d401d07c3f78c1fe7d80c9fe76c3bc6f46", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 421, "deletions": 90, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -2244,6 +2244,11 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n      inner loop (def of a3)\n      a2 = phi < a3 >\n \n+   (4) Detect condition expressions, ie:\n+     for (int i = 0; i < N; i++)\n+       if (a[i] < val)\n+\tret_val = a[i];\n+\n    If MODIFY is true it tries also to rework the code in-place to enable\n    detection of more reduction patterns.  For the time being we rewrite\n    \"res -= RHS\" into \"rhs += -RHS\" when it seems worthwhile.\n@@ -2252,7 +2257,8 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n static gimple *\n vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n \t\t\t    bool check_reduction, bool *double_reduc,\n-\t\t\t    bool modify, bool need_wrapping_integral_overflow)\n+\t\t\t    bool modify, bool need_wrapping_integral_overflow,\n+\t\t\t    enum vect_reduction_type *v_reduc_type)\n {\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n@@ -2269,6 +2275,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n   bool phi_def;\n \n   *double_reduc = false;\n+  *v_reduc_type = TREE_CODE_REDUCTION;\n \n   /* If CHECK_REDUCTION is true, we assume inner-most loop vectorization,\n      otherwise, we assume outer loop vectorization.  */\n@@ -2414,13 +2421,17 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n       && SSA_NAME_DEF_STMT (op1) == phi)\n     code = PLUS_EXPR;\n \n-  if (check_reduction\n-      && (!commutative_tree_code (code) || !associative_tree_code (code)))\n+  if (check_reduction)\n     {\n-      if (dump_enabled_p ())\n-        report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\"reduction: not commutative/associative: \");\n-      return NULL;\n+      if (code == COND_EXPR)\n+\t*v_reduc_type = COND_REDUCTION;\n+      else if (!commutative_tree_code (code) || !associative_tree_code (code))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t    \"reduction: not commutative/associative: \");\n+\t  return NULL;\n+\t}\n     }\n \n   if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS)\n@@ -2516,47 +2527,50 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n      and therefore vectorizing reductions in the inner-loop during\n      outer-loop vectorization is safe.  */\n \n-  /* CHECKME: check for !flag_finite_math_only too?  */\n-  if (SCALAR_FLOAT_TYPE_P (type) && !flag_associative_math\n-      && check_reduction)\n-    {\n-      /* Changing the order of operations changes the semantics.  */\n-      if (dump_enabled_p ())\n-\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\"reduction: unsafe fp math optimization: \");\n-      return NULL;\n-    }\n-  else if (INTEGRAL_TYPE_P (type) && check_reduction)\n+  if (*v_reduc_type != COND_REDUCTION)\n     {\n-      if (!operation_no_trapping_overflow (type, code))\n+      /* CHECKME: check for !flag_finite_math_only too?  */\n+      if (SCALAR_FLOAT_TYPE_P (type) && !flag_associative_math\n+\t  && check_reduction)\n \t{\n \t  /* Changing the order of operations changes the semantics.  */\n \t  if (dump_enabled_p ())\n \t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"reduction: unsafe int math optimization\"\n-\t\t\t    \" (overflow traps): \");\n+\t\t\t\"reduction: unsafe fp math optimization: \");\n \t  return NULL;\n \t}\n-      if (need_wrapping_integral_overflow\n-\t  && !TYPE_OVERFLOW_WRAPS (type)\n-\t  && operation_can_overflow (code))\n+      else if (INTEGRAL_TYPE_P (type) && check_reduction)\n+\t{\n+\t  if (!operation_no_trapping_overflow (type, code))\n+\t    {\n+\t      /* Changing the order of operations changes the semantics.  */\n+\t      if (dump_enabled_p ())\n+\t\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\t\"reduction: unsafe int math optimization\"\n+\t\t\t\t\" (overflow traps): \");\n+\t      return NULL;\n+\t    }\n+\t  if (need_wrapping_integral_overflow\n+\t      && !TYPE_OVERFLOW_WRAPS (type)\n+\t      && operation_can_overflow (code))\n+\t    {\n+\t      /* Changing the order of operations changes the semantics.  */\n+\t      if (dump_enabled_p ())\n+\t\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\t\"reduction: unsafe int math optimization\"\n+\t\t\t\t\" (overflow doesn't wrap): \");\n+\t      return NULL;\n+\t    }\n+\t}\n+      else if (SAT_FIXED_POINT_TYPE_P (type) && check_reduction)\n \t{\n \t  /* Changing the order of operations changes the semantics.  */\n \t  if (dump_enabled_p ())\n-\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"reduction: unsafe int math optimization\"\n-\t\t\t    \" (overflow doesn't wrap): \");\n+\t  report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t  \"reduction: unsafe fixed-point math optimization: \");\n \t  return NULL;\n \t}\n     }\n-  else if (SAT_FIXED_POINT_TYPE_P (type) && check_reduction)\n-    {\n-      /* Changing the order of operations changes the semantics.  */\n-      if (dump_enabled_p ())\n-\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\"reduction: unsafe fixed-point math optimization: \");\n-      return NULL;\n-    }\n \n   /* If we detected \"res -= x[i]\" earlier, rewrite it into\n      \"res += -x[i]\" now.  If this turns out to be useless reassoc\n@@ -2632,6 +2646,16 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n     {\n       if (check_reduction)\n         {\n+\t  if (code == COND_EXPR)\n+\t    {\n+\t      /* No current known use where this case would be useful.  */\n+\t      if (dump_enabled_p ())\n+\t\treport_vect_op (MSG_NOTE, def_stmt,\n+\t\t\t\t\"detected reduction: cannot currently swap \"\n+\t\t\t\t\"operands for cond_expr\");\n+\t      return NULL;\n+\t    }\n+\n           /* Swap operands (just for simplicity - so that the rest of the code\n \t     can assume that the reduction variable is always the last (second)\n \t     argument).  */\n@@ -2655,7 +2679,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n     }\n \n   /* Try to find SLP reduction chain.  */\n-  if (check_reduction && vect_is_slp_reduction (loop_info, phi, def_stmt))\n+  if (check_reduction && code != COND_EXPR\n+      && vect_is_slp_reduction (loop_info, phi, def_stmt))\n     {\n       if (dump_enabled_p ())\n         report_vect_op (MSG_NOTE, def_stmt,\n@@ -2677,11 +2702,13 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n static gimple *\n vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n \t\t\t  bool check_reduction, bool *double_reduc,\n-\t\t\t  bool need_wrapping_integral_overflow)\n+\t\t\t  bool need_wrapping_integral_overflow,\n+\t\t\t  enum vect_reduction_type *v_reduc_type)\n {\n   return vect_is_simple_reduction_1 (loop_info, phi, check_reduction,\n \t\t\t\t     double_reduc, false,\n-\t\t\t\t     need_wrapping_integral_overflow);\n+\t\t\t\t     need_wrapping_integral_overflow,\n+\t\t\t\t     v_reduc_type);\n }\n \n /* Wrapper around vect_is_simple_reduction_1, which will modify code\n@@ -2693,9 +2720,11 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple *phi,\n \t\t\t     bool check_reduction, bool *double_reduc,\n \t\t\t     bool need_wrapping_integral_overflow)\n {\n+  enum vect_reduction_type v_reduc_type;\n   return vect_is_simple_reduction_1 (loop_info, phi, check_reduction,\n \t\t\t\t     double_reduc, true,\n-\t\t\t\t     need_wrapping_integral_overflow);\n+\t\t\t\t     need_wrapping_integral_overflow,\n+\t\t\t\t     &v_reduc_type);\n }\n \n /* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n@@ -3200,6 +3229,10 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   else\n     target_cost_data = BB_VINFO_TARGET_COST_DATA (STMT_VINFO_BB_VINFO (stmt_info));\n \n+  /* Condition reductions generate two reductions in the loop.  */\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+    ncopies *= 2;\n+\n   /* Cost of reduction op inside loop.  */\n   unsigned inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n \t\t\t\t\tstmt_info, 0, vect_body);\n@@ -3229,9 +3262,14 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n   code = gimple_assign_rhs_code (orig_stmt);\n \n-  /* Add in cost for initial definition.  */\n-  prologue_cost += add_stmt_cost (target_cost_data, 1, scalar_to_vec,\n-\t\t\t\t  stmt_info, 0, vect_prologue);\n+  /* Add in cost for initial definition.\n+     For cond reduction we have four vectors: initial index, step, initial\n+     result of the data reduction, initial value of the index reduction.  */\n+  int prologue_stmts = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t       == COND_REDUCTION ? 4 : 1;\n+  prologue_cost += add_stmt_cost (target_cost_data, prologue_stmts,\n+\t\t\t\t  scalar_to_vec, stmt_info, 0,\n+\t\t\t\t  vect_prologue);\n \n   /* Determine cost of epilogue code.\n \n@@ -3242,10 +3280,30 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n     {\n       if (reduc_code != ERROR_MARK)\n \t{\n-\t  epilogue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n-\t\t\t\t\t  stmt_info, 0, vect_epilogue);\n-\t  epilogue_cost += add_stmt_cost (target_cost_data, 1, vec_to_scalar,\n-\t\t\t\t\t  stmt_info, 0, vect_epilogue);\n+\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+\t    {\n+\t      /* An EQ stmt and an COND_EXPR stmt.  */\n+\t      epilogue_cost += add_stmt_cost (target_cost_data, 2,\n+\t\t\t\t\t      vector_stmt, stmt_info, 0,\n+\t\t\t\t\t      vect_epilogue);\n+\t      /* Reduction of the max index and a reduction of the found\n+\t\t values.  */\n+\t      epilogue_cost += add_stmt_cost (target_cost_data, 2,\n+\t\t\t\t\t      vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t      vect_epilogue);\n+\t      /* A broadcast of the max value.  */\n+\t      epilogue_cost += add_stmt_cost (target_cost_data, 1,\n+\t\t\t\t\t      scalar_to_vec, stmt_info, 0,\n+\t\t\t\t\t      vect_epilogue);\n+\t    }\n+\t  else\n+\t    {\n+\t      epilogue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n+\t\t\t\t\t      stmt_info, 0, vect_epilogue);\n+\t      epilogue_cost += add_stmt_cost (target_cost_data, 1,\n+\t\t\t\t\t      vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t      vect_epilogue);\n+\t    }\n \t}\n       else\n \t{\n@@ -3831,15 +3889,17 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n       case MIN_EXPR:\n       case MAX_EXPR:\n       case COND_EXPR:\n-        if (adjustment_def)\n+\tif (adjustment_def)\n           {\n-            *adjustment_def = NULL_TREE;\n-            init_def = vect_get_vec_def_for_operand (init_val, stmt);\n-            break;\n-          }\n-\n+\t    *adjustment_def = NULL_TREE;\n+\t    if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_vinfo) != COND_REDUCTION)\n+\t      {\n+\t\tinit_def = vect_get_vec_def_for_operand (init_val, stmt);\n+\t\tbreak;\n+\t      }\n+\t  }\n \tinit_def = build_vector_from_val (vectype, init_value);\n-        break;\n+\tbreak;\n \n       default:\n         gcc_unreachable ();\n@@ -3869,6 +3929,8 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n    DOUBLE_REDUC is TRUE if double reduction phi nodes should be handled.\n    SLP_NODE is an SLP node containing a group of reduction statements. The \n      first one in this group is STMT.\n+   INDUCTION_INDEX is the index of the loop for condition reductions.\n+     Otherwise it is undefined.\n \n    This function:\n    1. Creates the reduction def-use cycles: sets the arguments for \n@@ -3914,7 +3976,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  int ncopies, enum tree_code reduc_code,\n \t\t\t\t  vec<gimple *> reduction_phis,\n                                   int reduc_index, bool double_reduc, \n-                                  slp_tree slp_node)\n+\t\t\t\t  slp_tree slp_node, tree induction_index)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n@@ -4214,11 +4276,123 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     }\n   else\n     new_phi_result = PHI_RESULT (new_phis[0]);\n- \n+\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+    {\n+      /* For condition reductions, we have a vector (NEW_PHI_RESULT) containing\n+\t various data values where the condition matched and another vector\n+\t (INDUCTION_INDEX) containing all the indexes of those matches.  We\n+\t need to extract the last matching index (which will be the index with\n+\t highest value) and use this to index into the data vector.\n+\t For the case where there were no matches, the data vector will contain\n+\t all default values and the index vector will be all zeros.  */\n+\n+      /* Get various versions of the type of the vector of indexes.  */\n+      tree index_vec_type = TREE_TYPE (induction_index);\n+      gcc_checking_assert (TYPE_UNSIGNED (index_vec_type));\n+      tree index_vec_type_signed = signed_type_for (index_vec_type);\n+      tree index_scalar_type = TREE_TYPE (index_vec_type);\n+\n+      /* Get an unsigned integer version of the type of the data vector.  */\n+      int scalar_precision = GET_MODE_PRECISION (TYPE_MODE (scalar_type));\n+      tree scalar_type_unsigned = make_unsigned_type (scalar_precision);\n+      tree vectype_unsigned = build_vector_type\n+\t(scalar_type_unsigned, TYPE_VECTOR_SUBPARTS (vectype));\n+\n+      /* First we need to create a vector (ZERO_VEC) of zeros and another\n+\t vector (MAX_INDEX_VEC) filled with the last matching index, which we\n+\t can create using a MAX reduction and then expanding.\n+\t In the case where the loop never made any matches, the max index will\n+\t be zero.  */\n+\n+      /* Vector of {0, 0, 0,...}.  */\n+      tree zero_vec = make_ssa_name (vectype);\n+      tree zero_vec_rhs = build_zero_cst (vectype);\n+      gimple *zero_vec_stmt = gimple_build_assign (zero_vec, zero_vec_rhs);\n+      gsi_insert_before (&exit_gsi, zero_vec_stmt, GSI_SAME_STMT);\n+\n+      /* Find maximum value from the vector of found indexes.  */\n+      tree max_index = make_ssa_name (index_scalar_type);\n+      gimple *max_index_stmt = gimple_build_assign (max_index, REDUC_MAX_EXPR,\n+\t\t\t\t\t\t    induction_index);\n+      gsi_insert_before (&exit_gsi, max_index_stmt, GSI_SAME_STMT);\n+\n+      /* Vector of {max_index, max_index, max_index,...}.  */\n+      tree max_index_vec = make_ssa_name (index_vec_type);\n+      tree max_index_vec_rhs = build_vector_from_val (index_vec_type,\n+\t\t\t\t\t\t      max_index);\n+      gimple *max_index_vec_stmt = gimple_build_assign (max_index_vec,\n+\t\t\t\t\t\t\tmax_index_vec_rhs);\n+      gsi_insert_before (&exit_gsi, max_index_vec_stmt, GSI_SAME_STMT);\n+\n+      /* Next we compare the new vector (MAX_INDEX_VEC) full of max indexes\n+\t with the vector (INDUCTION_INDEX) of found indexes, choosing values\n+\t from the data vector (NEW_PHI_RESULT) for matches, 0 (ZERO_VEC)\n+\t otherwise.  Only one value should match, resulting in a vector\n+\t (VEC_COND) with one data value and the rest zeros.\n+\t In the case where the loop never made any matches, every index will\n+\t match, resulting in a vector with all data values (which will all be\n+\t the default value).  */\n+\n+      /* Compare the max index vector to the vector of found indexes to find\n+\t the position of the max value.  */\n+      tree vec_compare = make_ssa_name (index_vec_type_signed);\n+      gimple *vec_compare_stmt = gimple_build_assign (vec_compare, EQ_EXPR,\n+\t\t\t\t\t\t      induction_index,\n+\t\t\t\t\t\t      max_index_vec);\n+      gsi_insert_before (&exit_gsi, vec_compare_stmt, GSI_SAME_STMT);\n+\n+      /* Use the compare to choose either values from the data vector or\n+\t zero.  */\n+      tree vec_cond = make_ssa_name (vectype);\n+      gimple *vec_cond_stmt = gimple_build_assign (vec_cond, VEC_COND_EXPR,\n+\t\t\t\t\t\t   vec_compare, new_phi_result,\n+\t\t\t\t\t\t   zero_vec);\n+      gsi_insert_before (&exit_gsi, vec_cond_stmt, GSI_SAME_STMT);\n+\n+      /* Finally we need to extract the data value from the vector (VEC_COND)\n+\t into a scalar (MATCHED_DATA_REDUC).  Logically we want to do a OR\n+\t reduction, but because this doesn't exist, we can use a MAX reduction\n+\t instead.  The data value might be signed or a float so we need to cast\n+\t it first.\n+\t In the case where the loop never made any matches, the data values are\n+\t all identical, and so will reduce down correctly.  */\n+\n+      /* Make the matched data values unsigned.  */\n+      tree vec_cond_cast = make_ssa_name (vectype_unsigned);\n+      tree vec_cond_cast_rhs = build1 (VIEW_CONVERT_EXPR, vectype_unsigned,\n+\t\t\t\t       vec_cond);\n+      gimple *vec_cond_cast_stmt = gimple_build_assign (vec_cond_cast,\n+\t\t\t\t\t\t\tVIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\tvec_cond_cast_rhs);\n+      gsi_insert_before (&exit_gsi, vec_cond_cast_stmt, GSI_SAME_STMT);\n+\n+      /* Reduce down to a scalar value.  */\n+      tree data_reduc = make_ssa_name (scalar_type_unsigned);\n+      optab ot = optab_for_tree_code (REDUC_MAX_EXPR, vectype_unsigned,\n+\t\t\t\t      optab_default);\n+      gcc_assert (optab_handler (ot, TYPE_MODE (vectype_unsigned))\n+\t\t  != CODE_FOR_nothing);\n+      gimple *data_reduc_stmt = gimple_build_assign (data_reduc,\n+\t\t\t\t\t\t     REDUC_MAX_EXPR,\n+\t\t\t\t\t\t     vec_cond_cast);\n+      gsi_insert_before (&exit_gsi, data_reduc_stmt, GSI_SAME_STMT);\n+\n+      /* Convert the reduced value back to the result type and set as the\n+\t result.  */\n+      tree data_reduc_cast = build1 (VIEW_CONVERT_EXPR, scalar_type,\n+\t\t\t\t     data_reduc);\n+      epilog_stmt = gimple_build_assign (new_scalar_dest, data_reduc_cast);\n+      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n+      gimple_assign_set_lhs (epilog_stmt, new_temp);\n+      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+      scalar_results.safe_push (new_temp);\n+    }\n+\n   /* 2.3 Create the reduction code, using one of the three schemes described\n          above. In SLP we simply need to extract all the elements from the \n          vector (without reducing them), so we use scalar shifts.  */\n-  if (reduc_code != ERROR_MARK && !slp_reduc)\n+  else if (reduc_code != ERROR_MARK && !slp_reduc)\n     {\n       tree tmp;\n       tree vec_elem_type;\n@@ -4739,6 +4913,15 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n    and it's STMT_VINFO_RELATED_STMT points to the last stmt in the original\n    sequence that had been detected and replaced by the pattern-stmt (STMT).\n \n+   This function also handles reduction of condition expressions, for example:\n+     for (int i = 0; i < N; i++)\n+       if (a[i] < value)\n+\t last = a[i];\n+   This is handled by vectorising the loop and creating an additional vector\n+   containing the loop indexes for which \"a[i] < value\" was true.  In the\n+   function epilogue this is reduced to a single max value and then used to\n+   index into the vector of results.\n+\n    In some cases of reduction patterns, the type of the reduction variable X is\n    different than the type of the other arguments of STMT.\n    In such cases, the vectype that is used when transforming STMT into a vector\n@@ -4813,6 +4996,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   int vec_num;\n   tree def0, def1, tem, op0, op1 = NULL_TREE;\n   bool first_p = true;\n+  tree cr_index_scalar_type = NULL_TREE, cr_index_vector_type = NULL_TREE;\n \n   /* In case of reduction chain we switch to the first stmt in the chain, but\n      we don't update STMT_INFO, since only the last stmt is marked as reduction\n@@ -4981,8 +5165,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  gimple *tmp = vect_is_simple_reduction (loop_vinfo, reduc_def_stmt,\n-\t\t\t\t\t  !nested_cycle, &dummy, false);\n+  gimple *tmp = vect_is_simple_reduction\n+\t\t  (loop_vinfo, reduc_def_stmt,\n+\t\t  !nested_cycle, &dummy, false,\n+\t\t  &STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info));\n   if (orig_stmt)\n     gcc_assert (tmp == orig_stmt\n \t\t|| GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == orig_stmt);\n@@ -5007,12 +5193,14 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (code == COND_EXPR)\n     {\n-      if (!vectorizable_condition (stmt, gsi, NULL, ops[reduc_index], 0, NULL))\n+      /* Only call during the analysis stage, otherwise we'll lose\n+\t STMT_VINFO_TYPE.  */\n+      if (!vec_stmt && !vectorizable_condition (stmt, gsi, NULL,\n+\t\t\t\t\t\tops[reduc_index], 0, NULL))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"unsupported condition in reduction\\n\");\n-\n \t  return false;\n         }\n     }\n@@ -5136,49 +5324,74 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   epilog_reduc_code = ERROR_MARK;\n-  if (reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n+\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == TREE_CODE_REDUCTION)\n     {\n-      reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype_out,\n+      if (reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n+\t{\n+\t  reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype_out,\n                                          optab_default);\n-      if (!reduc_optab)\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no optab for reduction.\\n\");\n-\n-          epilog_reduc_code = ERROR_MARK;\n-        }\n-      else if (optab_handler (reduc_optab, vec_mode) == CODE_FOR_nothing)\n-        {\n-          optab = scalar_reduc_to_vector (reduc_optab, vectype_out);\n-          if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n-            {\n-              if (dump_enabled_p ())\n-\t        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"reduc op not supported by target.\\n\");\n+\t  if (!reduc_optab)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"no optab for reduction.\\n\");\n \n \t      epilog_reduc_code = ERROR_MARK;\n \t    }\n-        }\n+\t  else if (optab_handler (reduc_optab, vec_mode) == CODE_FOR_nothing)\n+\t    {\n+\t      optab = scalar_reduc_to_vector (reduc_optab, vectype_out);\n+\t      if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"reduc op not supported by target.\\n\");\n+\n+\t\t  epilog_reduc_code = ERROR_MARK;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (!nested_cycle || double_reduc)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"no reduc code for scalar code.\\n\");\n+\n+\t      return false;\n+\t    }\n+\t}\n     }\n   else\n     {\n-      if (!nested_cycle || double_reduc)\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no reduc code for scalar code.\\n\");\n+      int scalar_precision = GET_MODE_PRECISION (TYPE_MODE (scalar_type));\n+      cr_index_scalar_type = make_unsigned_type (scalar_precision);\n+      cr_index_vector_type = build_vector_type\n+\t(cr_index_scalar_type, TYPE_VECTOR_SUBPARTS (vectype_out));\n \n-          return false;\n-        }\n+      epilog_reduc_code = REDUC_MAX_EXPR;\n+      optab = optab_for_tree_code (REDUC_MAX_EXPR, cr_index_vector_type,\n+\t\t\t\t   optab_default);\n+      if (optab_handler (optab, TYPE_MODE (cr_index_vector_type))\n+\t  == CODE_FOR_nothing)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"reduc max op not supported by target.\\n\");\n+\t  return false;\n+\t}\n     }\n \n-  if (double_reduc && ncopies > 1)\n+  if ((double_reduc\n+       || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+      && ncopies > 1)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"multiple types in double reduction\\n\");\n-\n+\t\t\t \"multiple types in double reduction or condition \"\n+\t\t\t \"reduction.\\n\");\n       return false;\n     }\n \n@@ -5202,6 +5415,34 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         }\n     }\n \n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+    {\n+      widest_int ni;\n+\n+      if (! max_loop_iterations (loop, &ni))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"loop count not known, cannot create cond \"\n+\t\t\t     \"reduction.\\n\");\n+\t  return false;\n+\t}\n+      /* Convert backedges to iterations.  */\n+      ni += 1;\n+\n+      /* The additional index will be the same type as the condition.  Check\n+\t that the loop can fit into this less one (because we'll use up the\n+\t zero slot for when there are no matches).  */\n+      tree max_index = TYPE_MAX_VALUE (cr_index_scalar_type);\n+      if (wi::geu_p (ni, wi::to_widest (max_index)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"loop size is greater than data size.\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       if (first_p\n@@ -5414,17 +5655,107 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       prev_phi_info = vinfo_for_stmt (new_phi);\n     }\n \n+  tree indx_before_incr, indx_after_incr, cond_name = NULL;\n+\n   /* Finalize the reduction-phi (set its arguments) and create the\n      epilog reduction code.  */\n   if ((!single_defuse_cycle || code == COND_EXPR) && !slp_node)\n     {\n       new_temp = gimple_assign_lhs (*vec_stmt);\n       vect_defs[0] = new_temp;\n+\n+      /* For cond reductions we want to create a new vector (INDEX_COND_EXPR)\n+\t which is updated with the current index of the loop for every match of\n+\t the original loop's cond_expr (VEC_STMT).  This results in a vector\n+\t containing the last time the condition passed for that vector lane.\n+\t The first match will be a 1 to allow 0 to be used for non-matching\n+\t indexes.  If there are no matches at all then the vector will be all\n+\t zeroes.  */\n+      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+\t{\n+\t  int nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+\t  int k;\n+\n+\t  gcc_assert (gimple_assign_rhs_code (*vec_stmt) == VEC_COND_EXPR);\n+\n+\t  /* First we create a simple vector induction variable which starts\n+\t     with the values {1,2,3,...} (SERIES_VECT) and increments by the\n+\t     vector size (STEP).  */\n+\n+\t  /* Create a {1,2,3,...} vector.  */\n+\t  tree *vtemp = XALLOCAVEC (tree, nunits_out);\n+\t  for (k = 0; k < nunits_out; ++k)\n+\t    vtemp[k] = build_int_cst (cr_index_scalar_type, k + 1);\n+\t  tree series_vect = build_vector (cr_index_vector_type, vtemp);\n+\n+\t  /* Create a vector of the step value.  */\n+\t  tree step = build_int_cst (cr_index_scalar_type, nunits_out);\n+\t  tree vec_step = build_vector_from_val (cr_index_vector_type, step);\n+\n+\t  /* Create an induction variable.  */\n+\t  gimple_stmt_iterator incr_gsi;\n+\t  bool insert_after;\n+\t  standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n+\t  create_iv (series_vect, vec_step, NULL_TREE, loop, &incr_gsi,\n+\t\t     insert_after, &indx_before_incr, &indx_after_incr);\n+\n+\t  /* Next create a new phi node vector (NEW_PHI_TREE) which starts\n+\t     filled with zeros (VEC_ZERO).  */\n+\n+\t  /* Create a vector of 0s.  */\n+\t  tree zero = build_zero_cst (cr_index_scalar_type);\n+\t  tree vec_zero = build_vector_from_val (cr_index_vector_type, zero);\n+\n+\t  /* Create a vector phi node.  */\n+\t  tree new_phi_tree = make_ssa_name (cr_index_vector_type);\n+\t  new_phi = create_phi_node (new_phi_tree, loop->header);\n+\t  set_vinfo_for_stmt (new_phi,\n+\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo));\n+\t  add_phi_arg (new_phi, vec_zero, loop_preheader_edge (loop),\n+\t\t       UNKNOWN_LOCATION);\n+\n+\t  /* Now take the condition from the loops original cond_expr\n+\t     (VEC_STMT) and produce a new cond_expr (INDEX_COND_EXPR) which for\n+\t     every match uses values from the induction variable\n+\t     (INDEX_BEFORE_INCR) otherwise uses values from the phi node\n+\t     (NEW_PHI_TREE).\n+\t     Finally, we update the phi (NEW_PHI_TREE) to take the value of\n+\t     the new cond_expr (INDEX_COND_EXPR).  */\n+\n+\t  /* Turn the condition from vec_stmt into an ssa name.  */\n+\t  gimple_stmt_iterator vec_stmt_gsi = gsi_for_stmt (*vec_stmt);\n+\t  tree ccompare = gimple_assign_rhs1 (*vec_stmt);\n+\t  tree ccompare_name = make_ssa_name (TREE_TYPE (ccompare));\n+\t  gimple *ccompare_stmt = gimple_build_assign (ccompare_name,\n+\t\t\t\t\t\t       ccompare);\n+\t  gsi_insert_before (&vec_stmt_gsi, ccompare_stmt, GSI_SAME_STMT);\n+\t  gimple_assign_set_rhs1 (*vec_stmt, ccompare_name);\n+\t  update_stmt (*vec_stmt);\n+\n+\t  /* Create a conditional, where the condition is taken from vec_stmt\n+\t     (CCOMPARE_NAME), then is the induction index (INDEX_BEFORE_INCR)\n+\t     and else is the phi (NEW_PHI_TREE).  */\n+\t  tree index_cond_expr = build3 (VEC_COND_EXPR, cr_index_vector_type,\n+\t\t\t\t\t ccompare_name, indx_before_incr,\n+\t\t\t\t\t new_phi_tree);\n+\t  cond_name = make_ssa_name (cr_index_vector_type);\n+\t  gimple *index_condition = gimple_build_assign (cond_name,\n+\t\t\t\t\t\t\t index_cond_expr);\n+\t  gsi_insert_before (&incr_gsi, index_condition, GSI_SAME_STMT);\n+\t  stmt_vec_info index_vec_info = new_stmt_vec_info (index_condition,\n+\t\t\t\t\t\t\t    loop_vinfo);\n+\t  STMT_VINFO_VECTYPE (index_vec_info) = cr_index_vector_type;\n+\t  set_vinfo_for_stmt (index_condition, index_vec_info);\n+\n+\t  /* Update the phi with the vec cond.  */\n+\t  add_phi_arg (new_phi, cond_name, loop_latch_edge (loop),\n+\t\t       UNKNOWN_LOCATION);\n+\t}\n     }\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, epilog_copies,\n                                     epilog_reduc_code, phis, reduc_index,\n-                                    double_reduc, slp_node);\n+\t\t\t\t    double_reduc, slp_node, cond_name);\n \n   return true;\n }"}, {"sha": "82fca0c7425f613b0fa3caca9b3c560f4d0f7c8a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -7202,21 +7202,24 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (reduc_index && STMT_SLP_TYPE (stmt_info))\n     return false;\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n-    return false;\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == TREE_CODE_REDUCTION)\n+    {\n+      if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n+\treturn false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n-      && !(STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n-           && reduc_def))\n-    return false;\n+      if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n+\t  && !(STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n+\t       && reduc_def))\n+\treturn false;\n \n-  /* FORNOW: not yet supported.  */\n-  if (STMT_VINFO_LIVE_P (stmt_info))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"value used after loop.\\n\");\n-      return false;\n+      /* FORNOW: not yet supported.  */\n+      if (STMT_VINFO_LIVE_P (stmt_info))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"value used after loop.\\n\");\n+\t  return false;\n+\t}\n     }\n \n   /* Is vectorizable conditional operation?  */\n@@ -7865,6 +7868,7 @@ new_stmt_vec_info (gimple *stmt, vec_info *vinfo)\n   STMT_VINFO_RELATED_STMT (res) = NULL;\n   STMT_VINFO_PATTERN_DEF_SEQ (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n+  STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n \n   STMT_VINFO_DR_BASE_ADDRESS (res) = NULL;\n   STMT_VINFO_DR_OFFSET (res) = NULL;\n@@ -8118,8 +8122,8 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n   if (TREE_CODE (operand) != SSA_NAME)\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not ssa-name.\\n\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not ssa-name.\\n\");\n       return false;\n     }\n "}, {"sha": "bf01deda4c5ef3a94fd2ed2485b8aa992d44783b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af29617a50b430ad3e9f2842fe31335d4488d1d3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=af29617a50b430ad3e9f2842fe31335d4488d1d3", "patch": "@@ -60,6 +60,12 @@ enum vect_def_type {\n   vect_unknown_def_type\n };\n \n+/* Define type of reduction.  */\n+enum vect_reduction_type {\n+  TREE_CODE_REDUCTION,\n+  COND_REDUCTION\n+};\n+\n #define VECTORIZABLE_CYCLE_DEF(D) (((D) == vect_reduction_def)           \\\n                                    || ((D) == vect_double_reduction_def) \\\n                                    || ((D) == vect_nested_cycle))\n@@ -581,6 +587,10 @@ typedef struct _stmt_vec_info {\n \n   /* For both loads and stores.  */\n   bool simd_lane_access_p;\n+\n+  /* For reduction loops, this is the type of reduction.  */\n+  enum vect_reduction_type v_reduc_type;\n+\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -609,6 +619,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_GATHER_SCATTER_P(S)\t   (S)->gather_scatter_p\n #define STMT_VINFO_STRIDED_P(S)\t   \t   (S)->strided_p\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n+#define STMT_VINFO_VEC_REDUCTION_TYPE(S)   (S)->v_reduc_type\n \n #define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address\n #define STMT_VINFO_DR_INIT(S)              (S)->dr_init"}]}