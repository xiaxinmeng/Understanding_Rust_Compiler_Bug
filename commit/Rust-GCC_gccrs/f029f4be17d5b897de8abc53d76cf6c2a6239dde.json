{"sha": "f029f4be17d5b897de8abc53d76cf6c2a6239dde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAyOWY0YmUxN2Q1Yjg5N2RlOGFiYzUzZDc2Y2Y2YzJhNjIzOWRkZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-11-01T16:14:42Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-11-01T16:14:42Z"}, "message": "Makefile.am (libquadmath_la_SOURCES): Add new math/* files.\n\n2012-11-01  Tobias Burnus  <burnus@net-b.de>\n\n        * Makefile.am (libquadmath_la_SOURCES): Add new math/* files.\n        * Makefile.in: Regenerated.\n        * math/acoshq.c: Update comment.\n        * math/acosq.c: Ditto.\n        * math/asinhq.c: Ditto.\n        * math/asinq.c: Ditto.\n        * math/atan2q.c: Ditto.\n        * math/atanhq.c: Ditto.\n        * math/ceilq.c: Ditto.\n        * math/copysignq.c: Ditto.\n        * math/cosq.c: Ditto.\n        * math/coshq.c: Ditto.\n        * math/erfq.c: Ditto.\n        * math/fabsq.c: Ditto.\n        * math/finiteq.c: Ditto.\n        * math/floorq.c: Ditto.\n        * math/fmodq.c: Ditto.\n        * math/frexpq.c: Ditto.\n        * math/isnanq.c: Ditto.\n        * math/j0q.c: Ditto.\n        * math/j1q.c: Ditto.\n        * math/ldexpq.c: Ditto.\n        * math/llroundq.c: Ditto.\n        * math/log10q.c: Ditto.\n        * math/log1pq.c: Ditto.\n        * math/log2q.c: Ditto.\n        * math/logq.c: Ditto.\n        * math/lroundq.c: Ditto.\n        * math/modfq.c: Ditto.\n        * math/nextafterq.c: Ditto.\n        * math/powq.c: Ditto.\n        * math/rem_pio2q.c: Ditto.\n        * math/remainderq.c: Ditto.\n        * math/rintq.c: Ditto.\n        * math/roundq.c: Ditto.\n        * math/scalblnq.c: Ditto.\n        * math/scalbnq.c: Ditto.\n        * math/sincosq_kernel.c: Ditto.\n        * math/sinq.c: Ditto.\n        * math/tanq.c: Ditto.\n        * math/expq.c: Ditto.\n        (__expq_table, expq): Renamed local array from __expl_table.\n        * math/cosq_kernel.c (__quadmath_kernel_cosq): Fix sign\n        * handling.\n        * math/cacoshq.c: Changes from GLIBC; fix returned sign.\n        * math/casinhq.c: Changes from GLIBC to fix special-case.\n        * math/cbrtq.c: Use modified GLIBC version.\n        * math/complex.c (ccoshd, cexpq, clog10q, clogq, csinhq, csinq,\n        ctanhq, ctanq): Moved to separates files.\n        (mult_c128, div_c128): Removed no longer needed functions.\n        (cexpiq): Call sincosq instead of sinq and cosq.\n        (cosq): Call cosh(-re,im) instead of cosq/sinq/sinh/cosh.\n        * math/ccoshq.c (ccoshq): New file, moved from complex.c and\n        modified based on GLIBC.\n        * math/cexpq.c (cexp): Ditto.\n        * math/clog10q.c (clog10q): Ditto.\n        * math/clogq.c (clogq): Ditto.\n        * math/csinhq.c: Ditto.\n        * math/csinq.c: Ditto.\n        * math/csqrtq.c: Ditto.\n        * math/ctanhq.c: Ditto.\n        * math/ctanq.c: Ditto.\n        * math/fmaq.c (fmaq): Port TININESS_AFTER_ROUNDING handling\n        from GLIBC.\n        * math/ilogbq.c (ilogbq): Add errno = EDOM handling.\n        * math/isinf_nsq.c (__quadmath_isinf_nsq): New file, ported\n        from GLIBC.\n        * math/lgammaq.c (lgammaq): Add signgam handling.\n        * math/sinhq.c (sinhq): Fix sign handling.\n        * math/sinq_kernel.c (__quadmath_kernel_sinq): Ditto.\n        * math/tgammaq.c (tgammaq): Ditto.\n        * math/x2y2m1q.c: New file.\n        * quadmath-imp.h (TININESS_AFTER_ROUNDING): New define.\n        (__quadmath_x2y2m1q, __quadmath_isinf_nsq): New prototypes.\n\nFrom-SVN: r193063", "tree": {"sha": "2afc010e7cab7a1e26bbcd9d5626478574f67e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2afc010e7cab7a1e26bbcd9d5626478574f67e38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f029f4be17d5b897de8abc53d76cf6c2a6239dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f029f4be17d5b897de8abc53d76cf6c2a6239dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f029f4be17d5b897de8abc53d76cf6c2a6239dde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f029f4be17d5b897de8abc53d76cf6c2a6239dde/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "621cf8af1d1f118d2e2bffb9b753d28ab9777479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621cf8af1d1f118d2e2bffb9b753d28ab9777479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621cf8af1d1f118d2e2bffb9b753d28ab9777479"}], "stats": {"total": 2208, "additions": 1843, "deletions": 365}, "files": [{"sha": "efb95d179d24fa974681a11fa3162eb59c6388d1", "filename": "libquadmath/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FChangeLog?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,3 +1,79 @@\n+2012-11-01  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* Makefile.am (libquadmath_la_SOURCES): Add new math/* files.\n+\t* Makefile.in: Regenerated.\n+\t* math/acoshq.c: Update comment.\n+\t* math/acosq.c: Ditto.\n+\t* math/asinhq.c: Ditto.\n+\t* math/asinq.c: Ditto.\n+\t* math/atan2q.c: Ditto.\n+\t* math/atanhq.c: Ditto.\n+\t* math/ceilq.c: Ditto.\n+\t* math/copysignq.c: Ditto.\n+\t* math/cosq.c: Ditto.\n+\t* math/coshq.c: Ditto.\n+\t* math/erfq.c: Ditto.\n+\t* math/fabsq.c: Ditto.\n+\t* math/finiteq.c: Ditto.\n+\t* math/floorq.c: Ditto.\n+\t* math/fmodq.c: Ditto.\n+\t* math/frexpq.c: Ditto.\n+\t* math/isnanq.c: Ditto.\n+\t* math/j0q.c: Ditto.\n+\t* math/j1q.c: Ditto.\n+\t* math/ldexpq.c: Ditto.\n+\t* math/llroundq.c: Ditto.\n+\t* math/log10q.c: Ditto.\n+\t* math/log1pq.c: Ditto.\n+\t* math/log2q.c: Ditto.\n+\t* math/logq.c: Ditto.\n+\t* math/lroundq.c: Ditto.\n+\t* math/modfq.c: Ditto.\n+\t* math/nextafterq.c: Ditto.\n+\t* math/powq.c: Ditto.\n+\t* math/rem_pio2q.c: Ditto.\n+\t* math/remainderq.c: Ditto.\n+\t* math/rintq.c: Ditto.\n+\t* math/roundq.c: Ditto.\n+\t* math/scalblnq.c: Ditto.\n+\t* math/scalbnq.c: Ditto.\n+\t* math/sincosq_kernel.c: Ditto.\n+\t* math/sinq.c: Ditto.\n+\t* math/tanq.c: Ditto.\n+\t* math/expq.c: Ditto.\n+\t(__expq_table, expq): Renamed local array from __expl_table.\n+\t* math/cosq_kernel.c (__quadmath_kernel_cosq): Fix sign handling.\n+\t* math/cacoshq.c: Changes from GLIBC; fix returned sign.\n+\t* math/casinhq.c: Changes from GLIBC to fix special-case.\n+\t* math/cbrtq.c: Use modified GLIBC version.\n+\t* math/complex.c (ccoshd, cexpq, clog10q, clogq, csinhq, csinq,\n+\tctanhq, ctanq): Moved to separates files.\n+\t(mult_c128, div_c128): Removed no longer needed functions.\n+\t(cexpiq): Call sincosq instead of sinq and cosq.\n+\t(cosq): Call cosh(-re,im) instead of cosq/sinq/sinh/cosh.\n+\t* math/ccoshq.c (ccoshq): New file, moved from complex.c and\n+\tmodified based on GLIBC.\n+\t* math/cexpq.c (cexp): Ditto.\n+\t* math/clog10q.c (clog10q): Ditto.\n+\t* math/clogq.c (clogq): Ditto.\n+\t* math/csinhq.c: Ditto.\n+\t* math/csinq.c: Ditto.\n+\t* math/csqrtq.c: Ditto.\n+\t* math/ctanhq.c: Ditto.\n+\t* math/ctanq.c: Ditto.\n+\t* math/fmaq.c (fmaq): Port TININESS_AFTER_ROUNDING handling\n+\tfrom GLIBC.\n+\t* math/ilogbq.c (ilogbq): Add errno = EDOM handling.\n+\t* math/isinf_nsq.c (__quadmath_isinf_nsq): New file, ported\n+\tfrom GLIBC.\n+\t* math/lgammaq.c (lgammaq): Add signgam handling.\n+\t* math/sinhq.c (sinhq): Fix sign handling.\n+\t* math/sinq_kernel.c (__quadmath_kernel_sinq): Ditto.\n+\t* math/tgammaq.c (tgammaq): Ditto.\n+\t* math/x2y2m1q.c: New file.\n+\t* quadmath-imp.h (TININESS_AFTER_ROUNDING): New define.\n+\t(__quadmath_x2y2m1q, __quadmath_isinf_nsq): New prototypes.\n+\n 2012-10-31  Tobias Burnus  <burnus@net-b.de>\n \t    Joseph Myers <joseph@codesourcery.com>\n \t    David S. Miller <davem@davemloft.net>"}, {"sha": "6c97ee81c5cfa98d8c4650e1b496bcb76b3793ef", "filename": "libquadmath/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FMakefile.am?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -43,7 +43,8 @@ nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h\n libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n \n libquadmath_la_SOURCES = \\\n-  math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \\\n+  math/x2y2m1q.c math/isinf_nsq.c math/acoshq.c math/fmodq.c \\\n+  math/acosq.c math/frexpq.c \\\n   math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \\\n   math/asinq.c math/rintq.c math/atan2q.c math/isinfq.c \\\n   math/roundq.c math/atanhq.c math/isnanq.c math/scalblnq.c math/atanq.c \\\n@@ -60,6 +61,8 @@ libquadmath_la_SOURCES = \\\n   math/catanhq.c math/catanq.c math/cimagq.c math/conjq.c math/cprojq.c \\\n   math/crealq.c math/fdimq.c math/fmaxq.c math/fminq.c math/ilogbq.c \\\n   math/llrintq.c math/log2q.c math/lrintq.c math/nearbyintq.c math/remquoq.c \\\n+  math/ccoshq.c math/cexpq.c math/clog10q.c math/clogq.c math/csinq.c \\\n+  math/csinhq.c math/csqrtq.c math/ctanq.c math/ctanhq.c \\\n   printf/addmul_1.c printf/add_n.c printf/cmp.c printf/divrem.c \\\n   printf/flt1282mpn.c printf/fpioconst.c printf/lshift.c printf/mul_1.c \\\n   printf/mul_n.c printf/mul.c printf/printf_fphex.c printf/printf_fp.c \\"}, {"sha": "92c5d256d5aff860c7d235ffd9a503e424ad3c40", "filename": "libquadmath/Makefile.in", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FMakefile.in?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -87,7 +87,8 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n \t\"$(DESTDIR)$(libsubincludedir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__dirstamp = $(am__leading_dot)dirstamp\n-@BUILD_LIBQUADMATH_TRUE@am_libquadmath_la_OBJECTS = math/acoshq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@am_libquadmath_la_OBJECTS = math/x2y2m1q.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/isinf_nsq.lo math/acoshq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/fmodq.lo math/acosq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/frexpq.lo math/rem_pio2q.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/asinhq.lo math/hypotq.lo \\\n@@ -126,9 +127,13 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @BUILD_LIBQUADMATH_TRUE@\tmath/ilogbq.lo math/llrintq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/log2q.lo math/lrintq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/nearbyintq.lo math/remquoq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tprintf/addmul_1.lo printf/add_n.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tprintf/cmp.lo printf/divrem.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tprintf/flt1282mpn.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/ccoshq.lo math/cexpq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/clog10q.lo math/clogq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/csinq.lo math/csinhq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/csqrtq.lo math/ctanq.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tmath/ctanhq.lo printf/addmul_1.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/add_n.lo printf/cmp.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/divrem.lo printf/flt1282mpn.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/fpioconst.lo printf/lshift.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/mul_1.lo printf/mul_n.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tprintf/mul.lo printf/printf_fphex.lo \\\n@@ -321,7 +326,8 @@ AUTOMAKE_OPTIONS = 1.8 foreign\n @BUILD_LIBQUADMATH_TRUE@nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h\n @BUILD_LIBQUADMATH_TRUE@libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n @BUILD_LIBQUADMATH_TRUE@libquadmath_la_SOURCES = \\\n-@BUILD_LIBQUADMATH_TRUE@  math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \\\n+@BUILD_LIBQUADMATH_TRUE@  math/x2y2m1q.c math/isinf_nsq.c math/acoshq.c math/fmodq.c \\\n+@BUILD_LIBQUADMATH_TRUE@  math/acosq.c math/frexpq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/asinq.c math/rintq.c math/atan2q.c math/isinfq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/roundq.c math/atanhq.c math/isnanq.c math/scalblnq.c math/atanq.c \\\n@@ -338,6 +344,8 @@ AUTOMAKE_OPTIONS = 1.8 foreign\n @BUILD_LIBQUADMATH_TRUE@  math/catanhq.c math/catanq.c math/cimagq.c math/conjq.c math/cprojq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/crealq.c math/fdimq.c math/fmaxq.c math/fminq.c math/ilogbq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/llrintq.c math/log2q.c math/lrintq.c math/nearbyintq.c math/remquoq.c \\\n+@BUILD_LIBQUADMATH_TRUE@  math/ccoshq.c math/cexpq.c math/clog10q.c math/clogq.c math/csinq.c \\\n+@BUILD_LIBQUADMATH_TRUE@  math/csinhq.c math/csqrtq.c math/ctanq.c math/ctanhq.c \\\n @BUILD_LIBQUADMATH_TRUE@  printf/addmul_1.c printf/add_n.c printf/cmp.c printf/divrem.c \\\n @BUILD_LIBQUADMATH_TRUE@  printf/flt1282mpn.c printf/fpioconst.c printf/lshift.c printf/mul_1.c \\\n @BUILD_LIBQUADMATH_TRUE@  printf/mul_n.c printf/mul.c printf/printf_fphex.c printf/printf_fp.c \\\n@@ -504,6 +512,8 @@ math/$(am__dirstamp):\n math/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) math/$(DEPDIR)\n \t@: > math/$(DEPDIR)/$(am__dirstamp)\n+math/x2y2m1q.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/isinf_nsq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n math/acoshq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n math/fmodq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n math/acosq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n@@ -588,6 +598,15 @@ math/lrintq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n math/nearbyintq.lo: math/$(am__dirstamp) \\\n \tmath/$(DEPDIR)/$(am__dirstamp)\n math/remquoq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/ccoshq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/cexpq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/clog10q.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/clogq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/csinq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/csinhq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/csqrtq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/ctanq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+math/ctanhq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n printf/$(am__dirstamp):\n \t@$(MKDIR_P) printf\n \t@: > printf/$(am__dirstamp)\n@@ -669,10 +688,18 @@ mostlyclean-compile:\n \t-rm -f math/catanq.lo\n \t-rm -f math/cbrtq.$(OBJEXT)\n \t-rm -f math/cbrtq.lo\n+\t-rm -f math/ccoshq.$(OBJEXT)\n+\t-rm -f math/ccoshq.lo\n \t-rm -f math/ceilq.$(OBJEXT)\n \t-rm -f math/ceilq.lo\n+\t-rm -f math/cexpq.$(OBJEXT)\n+\t-rm -f math/cexpq.lo\n \t-rm -f math/cimagq.$(OBJEXT)\n \t-rm -f math/cimagq.lo\n+\t-rm -f math/clog10q.$(OBJEXT)\n+\t-rm -f math/clog10q.lo\n+\t-rm -f math/clogq.$(OBJEXT)\n+\t-rm -f math/clogq.lo\n \t-rm -f math/complex.$(OBJEXT)\n \t-rm -f math/complex.lo\n \t-rm -f math/conjq.$(OBJEXT)\n@@ -689,6 +716,16 @@ mostlyclean-compile:\n \t-rm -f math/cprojq.lo\n \t-rm -f math/crealq.$(OBJEXT)\n \t-rm -f math/crealq.lo\n+\t-rm -f math/csinhq.$(OBJEXT)\n+\t-rm -f math/csinhq.lo\n+\t-rm -f math/csinq.$(OBJEXT)\n+\t-rm -f math/csinq.lo\n+\t-rm -f math/csqrtq.$(OBJEXT)\n+\t-rm -f math/csqrtq.lo\n+\t-rm -f math/ctanhq.$(OBJEXT)\n+\t-rm -f math/ctanhq.lo\n+\t-rm -f math/ctanq.$(OBJEXT)\n+\t-rm -f math/ctanq.lo\n \t-rm -f math/erfq.$(OBJEXT)\n \t-rm -f math/erfq.lo\n \t-rm -f math/expm1q.$(OBJEXT)\n@@ -717,6 +754,8 @@ mostlyclean-compile:\n \t-rm -f math/hypotq.lo\n \t-rm -f math/ilogbq.$(OBJEXT)\n \t-rm -f math/ilogbq.lo\n+\t-rm -f math/isinf_nsq.$(OBJEXT)\n+\t-rm -f math/isinf_nsq.lo\n \t-rm -f math/isinfq.$(OBJEXT)\n \t-rm -f math/isinfq.lo\n \t-rm -f math/isnanq.$(OBJEXT)\n@@ -795,6 +834,8 @@ mostlyclean-compile:\n \t-rm -f math/tgammaq.lo\n \t-rm -f math/truncq.$(OBJEXT)\n \t-rm -f math/truncq.lo\n+\t-rm -f math/x2y2m1q.$(OBJEXT)\n+\t-rm -f math/x2y2m1q.lo\n \t-rm -f printf/add_n.$(OBJEXT)\n \t-rm -f printf/add_n.lo\n \t-rm -f printf/addmul_1.$(OBJEXT)\n@@ -851,8 +892,12 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/catanhq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/catanq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/cbrtq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/ccoshq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/ceilq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/cexpq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/cimagq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/clog10q.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/clogq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/complex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/conjq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/copysignq.Plo@am__quote@\n@@ -861,6 +906,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/cosq_kernel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/cprojq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/crealq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/csinhq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/csinq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/csqrtq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/ctanhq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/ctanq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/erfq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/expm1q.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/expq.Plo@am__quote@\n@@ -875,6 +925,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/frexpq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/hypotq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/ilogbq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/isinf_nsq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/isinfq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/isnanq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/j0q.Plo@am__quote@\n@@ -914,6 +965,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/tanq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/tgammaq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/truncq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/x2y2m1q.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/add_n.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/addmul_1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/cmp.Plo@am__quote@"}, {"sha": "9845a8e364c45a967ef14c4ebbb0bd6956bc9573", "filename": "libquadmath/math/acoshq.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Facoshq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Facoshq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Facoshq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* e_acoshl.c -- long double version of e_acosh.c.\n+/* acoshq.c -- __float128 version of e_acosh.c.\n  * Conversion to long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n \n@@ -13,7 +13,7 @@\n  * ====================================================\n  */\n \n-/* __ieee754_acoshl(x)\n+/* acoshq(x)\n  * Method :\n  *\tBased on\n  *\t\tacoshl(x) = logl [ x + sqrtl(x*x-1) ]"}, {"sha": "7ef794746511709c96edafda8d689ba08bf51ba0", "filename": "libquadmath/math/acosq.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Facosq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Facosq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Facosq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -31,7 +31,7 @@\n     License along with this library; if not, write to the Free Software\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n-/* __ieee754_acosl(x)\n+/* acosq(x)\n  * Method :\n  *      acos(x)  = pi/2 - asin(x)\n  *      acos(-x) = pi/2 + asin(x)\n@@ -51,7 +51,7 @@\n  *      if x is NaN, return x itself;\n  *      if |x|>1, return NaN with invalid signal.\n  *\n- * Functions needed: __ieee754_sqrtl.\n+ * Functions needed: sqrtq.\n  */\n \n #include \"quadmath-imp.h\""}, {"sha": "9be0aa1f05326ac30e136dc55796ca0a58376c08", "filename": "libquadmath/math/asinhq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fasinhq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fasinhq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fasinhq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_asinhl.c -- long double version of s_asinh.c.\n+/* asinhq.c -- __float128 version of s_asinh.c.\n  * Conversion to long double by Ulrich Drepper,\n  * Cygnus Support, drepper@cygnus.com.\n  */"}, {"sha": "7bd4d768c978ac97c2b1960d81bd911907513538", "filename": "libquadmath/math/asinq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fasinq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fasinq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fasinq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -31,7 +31,7 @@\n     License along with this library; if not, write to the Free Software\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n-/* __ieee754_asin(x)\n+/* asinq(x)\n  * Method :\n  *\tSince  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...\n  *\twe approximate asin(x) on [0,0.5] by"}, {"sha": "daa303efba328e2d4a8928cec926f1d3a6bf543a", "filename": "libquadmath/math/atan2q.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fatan2q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fatan2q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fatan2q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* e_atan2l.c -- long double version of e_atan2.c.\n+/* atan2q.c -- __float128 version of e_atan2.c.\n  * Conversion to long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "b34036715d7486700c6679262c690c455fd34f35", "filename": "libquadmath/math/atanhq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fatanhq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fatanhq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fatanhq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -14,7 +14,7 @@\n  * ====================================================\n  */\n \n-/* __ieee754_atanhl(x)\n+/* atanhq(x)\n  * Method :\n  *    1.Reduced x to positive by atanh(-x) = -atanh(x)\n  *    2.For x>=0.5"}, {"sha": "263e03d0c1126c2902b680b7bcd2521f1bed5dab", "filename": "libquadmath/math/cacoshq.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcacoshq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcacoshq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcacoshq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -63,6 +63,16 @@ cacoshq (__complex128 x)\n       __real__ res = 0.0;\n       __imag__ res = copysignq (M_PI_2q, __imag__ x);\n     }\n+  /* The factor 16 is just a guess.  */\n+  else if (16.0Q * fabsq (__imag__ x) < fabsq (__real__ x))\n+    {\n+      /* Kahan's formula which avoid cancellation through subtraction in\n+\t some cases.  */\n+      res = 2.0Q * clogq (csqrtq ((x + 1.0Q) / 2.0Q)\n+\t\t\t    + csqrtq ((x - 1.0Q) / 2.0Q));\n+      if (signbit (__real__ res))\n+\t__real__ res = 0.0Q;\n+    }\n   else\n     {\n       __complex128 y;\n@@ -72,17 +82,13 @@ cacoshq (__complex128 x)\n \n       y = csqrtq (y);\n \n-      if (__real__ x < 0.0)\n+      if (signbitq (x))\n \ty = -y;\n \n       __real__ y += __real__ x;\n       __imag__ y += __imag__ x;\n \n       res = clogq (y);\n-\n-      /* We have to use the positive branch.  */\n-      if (__real__ res < 0.0)\n-\tres = -res;\n     }\n \n   return res;"}, {"sha": "11487b967fcf9393d5d5cc3b0f6efa3a15793226", "filename": "libquadmath/math/casinhq.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcasinhq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcasinhq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcasinhq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -72,6 +72,11 @@ casinhq (__complex128 x)\n       __imag__ y += __imag__ x;\n \n       res = clogq (y);\n+\n+      /* Ensure zeros have correct sign and results are correct if\n+\t very close to branch cuts.  */\n+      __real__ res = copysignq (__real__ res, __real__ x);\n+      __imag__ res = copysignq (__imag__ res, __imag__ x);\n     }\n \n   return res;"}, {"sha": "f1f05cac78900b8413579e4bd175f0356d4141a8", "filename": "libquadmath/math/cbrtq.c", "status": "modified", "additions": 125, "deletions": 57, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcbrtq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcbrtq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcbrtq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,64 +1,132 @@\n+/*\t\t\t\t\t\t\tcbrtq.c\n+ *\n+ *\tCube root, __float128 precision\n+ *\n+ *\n+ *\n+ * SYNOPSIS:\n+ *\n+ * __float128 x, y, cbrtq();\n+ *\n+ * y = cbrtq( x );\n+ *\n+ *\n+ *\n+ * DESCRIPTION:\n+ *\n+ * Returns the cube root of the argument, which may be negative.\n+ *\n+ * Range reduction involves determining the power of 2 of\n+ * the argument.  A polynomial of degree 2 applied to the\n+ * mantissa, and multiplication by the cube root of 1, 2, or 4\n+ * approximates the root to within about 0.1%.  Then Newton's\n+ * iteration is used three times to converge to an accurate\n+ * result.\n+ *\n+ *\n+ *\n+ * ACCURACY:\n+ *\n+ *                      Relative error:\n+ * arithmetic   domain     # trials      peak         rms\n+ *    IEEE       -8,8       100000      1.3e-34     3.9e-35\n+ *    IEEE    exp(+-707)    100000      1.3e-34     4.3e-35\n+ *\n+ */\n+\n+/*\n+Cephes Math Library Release 2.2: January, 1991\n+Copyright 1984, 1991 by Stephen L. Moshier\n+Adapted for glibc October, 2001.\n+\n+    This library is free software; you can redistribute it and/or\n+    modify it under the terms of the GNU Lesser General Public\n+    License as published by the Free Software Foundation; either\n+    version 2.1 of the License, or (at your option) any later version.\n+\n+    This library is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+    Lesser General Public License for more details.\n+\n+    You should have received a copy of the GNU Lesser General Public\n+    License along with this library; if not, see\n+    <http://www.gnu.org/licenses/>.  */\n+\n+\n #include \"quadmath-imp.h\"\n-#include <math.h>\n-#include <float.h>\n+\n+static const long double CBRT2 = 1.259921049894873164767210607278228350570251Q;\n+static const long double CBRT4 = 1.587401051968199474751705639272308260391493Q;\n+static const long double CBRT2I = 0.7937005259840997373758528196361541301957467Q;\n+static const long double CBRT4I = 0.6299605249474365823836053036391141752851257Q;\n+\n \n __float128\n-cbrtq (const __float128 x)\n+cbrtq ( __float128 x)\n {\n-  __float128 y;\n-  int exp, i;\n+  int e, rem, sign;\n+  __float128 z;\n+\n+  if (!finiteq (x))\n+    return x + x;\n \n   if (x == 0)\n-    return x;\n-\n-  if (isnanq (x))\n-    return x;\n-\n-  if (x <= DBL_MAX && x >= DBL_MIN)\n-  {\n-    /* Use double result as starting point.  */\n-    y = cbrt ((double) x);\n-\n-    /* Two Newton iterations.  */\n-    y -= 0.333333333333333333333333333333333333333333333333333Q\n-\t  * (y - x / (y * y));\n-    y -= 0.333333333333333333333333333333333333333333333333333Q\n-\t  * (y - x / (y * y));\n-    return y;\n-  }\n-\n-#ifdef HAVE_CBRTL\n-  if (x <= LDBL_MAX && x >= LDBL_MIN)\n-  {\n-    /* Use long double result as starting point.  */\n-    y = cbrtl ((long double) x);\n-\n-    /* One Newton iteration.  */\n-    y -= 0.333333333333333333333333333333333333333333333333333Q\n-\t  * (y - x / (y * y));\n-    return y;\n-  }\n-#endif\n-\n-  /* If we're outside of the range of C types, we have to compute\n-     the initial guess the hard way.  */\n-  y = frexpq (x, &exp);\n-\n-  i = exp % 3;\n-  y = (i >= 0 ? i : -i);\n-  if (i == 1)\n-    y *= 2, exp--;\n-  else if (i == 2)\n-    y *= 4, exp -= 2;\n-\n-  y = cbrt (y);\n-  y = scalbnq (y, exp / 3);\n-\n-  /* Two Newton iterations.  */\n-  y -= 0.333333333333333333333333333333333333333333333333333Q\n-\t * (y - x / (y * y));\n-  y -= 0.333333333333333333333333333333333333333333333333333Q\n-\t * (y - x / (y * y));\n-  return y;\n-}\n+    return (x);\n+\n+  if (x > 0)\n+    sign = 1;\n+  else\n+    {\n+      sign = -1;\n+      x = -x;\n+    }\n+\n+  z = x;\n+ /* extract power of 2, leaving mantissa between 0.5 and 1  */\n+  x = frexpq (x, &e);\n+\n+  /* Approximate cube root of number between .5 and 1,\n+     peak relative error = 1.2e-6  */\n+  x = ((((1.3584464340920900529734e-1L * x\n+\t  - 6.3986917220457538402318e-1L) * x\n+\t + 1.2875551670318751538055e0L) * x\n+\t- 1.4897083391357284957891e0L) * x\n+       + 1.3304961236013647092521e0L) * x + 3.7568280825958912391243e-1L;\n \n+  /* exponent divided by 3 */\n+  if (e >= 0)\n+    {\n+      rem = e;\n+      e /= 3;\n+      rem -= 3 * e;\n+      if (rem == 1)\n+\tx *= CBRT2;\n+      else if (rem == 2)\n+\tx *= CBRT4;\n+    }\n+  else\n+    {\t\t\t\t/* argument less than 1 */\n+      e = -e;\n+      rem = e;\n+      e /= 3;\n+      rem -= 3 * e;\n+      if (rem == 1)\n+\tx *= CBRT2I;\n+      else if (rem == 2)\n+\tx *= CBRT4I;\n+      e = -e;\n+    }\n+\n+  /* multiply by power of 2 */\n+  x = ldexpq (x, e);\n+\n+  /* Newton iteration */\n+  x -= (x - (z / (x * x))) * 0.3333333333333333333333333333333333333333L;\n+  x -= (x - (z / (x * x))) * 0.3333333333333333333333333333333333333333L;\n+  x -= (x - (z / (x * x))) * 0.3333333333333333333333333333333333333333L;\n+\n+  if (sign < 0)\n+    x = -x;\n+  return (x);\n+}"}, {"sha": "8d55ad3a99d005349a7a2944b5c2b3beacfa2237", "filename": "libquadmath/math/ccoshq.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fccoshq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fccoshq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fccoshq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,145 @@\n+/* Complex cosine hyperbole function for complex __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+ccoshq (__complex128 x)\n+{\n+  __complex128 retval;\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  if (__builtin_expect (rcls >= QUADFP_ZERO, 1))\n+    {\n+      /* Real part is finite.  */\n+      if (__builtin_expect (icls >= QUADFP_ZERO, 1))\n+\t{\n+\t  /* Imaginary part is finite.  */\n+\t  const int t = (int) ((FLT128_MAX_EXP - 1) * M_LN2q);\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__imag__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __imag__ x;\n+\t      cosix = 1.0Q;\n+\t    }\n+\n+\t  if (fabsq (__real__ x) > t)\n+\t    {\n+\t      __float128 exp_t = expq (t);\n+\t      __float128 rx = fabsq (__real__ x);\n+\t      if (signbitq (__real__ x))\n+\t\tsinix = -sinix;\n+\t      rx -= t;\n+\t      sinix *= exp_t / 2.0Q;\n+\t      cosix *= exp_t / 2.0Q;\n+\t      if (rx > t)\n+\t\t{\n+\t\t  rx -= t;\n+\t\t  sinix *= exp_t;\n+\t\t  cosix *= exp_t;\n+\t\t}\n+\t      if (rx > t)\n+\t\t{\n+\t\t  /* Overflow (original real part of x > 3t).  */\n+\t\t  __real__ retval = FLT128_MAX * cosix;\n+\t\t  __imag__ retval = FLT128_MAX * sinix;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __float128 exp_val = expq (rx);\n+\t\t  __real__ retval = exp_val * cosix;\n+\t\t  __imag__ retval = exp_val * sinix;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ retval = coshq (__real__ x) * cosix;\n+\t      __imag__ retval = sinhq (__real__ x) * sinix;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  __imag__ retval = __real__ x == 0.0Q ? 0.0Q : nanq (\"\");\n+\t  __real__ retval = nanq (\"\") + nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  if (icls == QUADFP_INFINITE)\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+        }\n+    }\n+  else if (rcls == QUADFP_INFINITE)\n+    {\n+      /* Real part is infinite.  */\n+      if (__builtin_expect (icls > QUADFP_ZERO, 1))\n+\t{\n+\t  /* Imaginary part is finite.  */\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__imag__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __imag__ x;\n+\t      cosix = 1.0Q;\n+\t    }\n+\n+\t  __real__ retval = copysignq (HUGE_VALQ, cosix);\n+\t  __imag__ retval = (copysignq (HUGE_VALQ, sinix)\n+\t\t\t     * copysignq (1.0Q, __real__ x));\n+\t}\n+      else if (icls == QUADFP_ZERO)\n+\t{\n+\t  /* Imaginary part is 0.0.  */\n+\t  __real__ retval = HUGE_VALQ;\n+\t  __imag__ retval = __imag__ x * copysignq (1.0Q, __real__ x);\n+\t}\n+      else\n+\t{\n+\t  /* The addition raises the invalid exception.  */\n+\t  __real__ retval = HUGE_VALQ;\n+\t  __imag__ retval = nanq (\"\") + nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  if (icls == QUADFP_INFINITE)\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+\t }\n+    }\n+  else\n+    {\n+      __real__ retval = nanq (\"\");\n+      __imag__ retval = __imag__ x == 0.0 ? __imag__ x : nanq (\"\");\n+    }\n+\n+  return retval;\n+}"}, {"sha": "0d9bb8b87f3b4898303d70c94989d652e62c01ba", "filename": "libquadmath/math/ceilq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fceilq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fceilq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fceilq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_ceill.c -- long double version of s_ceil.c.\n+/* ceilq.c -- __float128 version of s_ceil.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "bd4be1ebe7112489e27bce69fcbe8b6c3fc9dcfd", "filename": "libquadmath/math/cexpq.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcexpq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcexpq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcexpq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,152 @@\n+/* Return value of complex exponential function for complex __float128 value.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+cexpq (__complex128 x)\n+{\n+  __complex128 retval;\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  if (__builtin_expect (rcls >= QUADFP_ZERO, 1))\n+    {\n+      /* Real part is finite.  */\n+      if (__builtin_expect (icls >= QUADFP_ZERO, 1))\n+\t{\n+\t  /* Imaginary part is finite.  */\n+\t  const int t = (int) ((FLT128_MAX_EXP - 1) * M_LN2q);\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__imag__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __imag__ x;\n+\t      cosix = 1.0Q;\n+\t    }\n+\n+\t  if (__real__ x > t)\n+\t    {\n+\t      __float128 exp_t = expq (t);\n+\t      __real__ x -= t;\n+\t      sinix *= exp_t;\n+\t      cosix *= exp_t;\n+\t      if (__real__ x > t)\n+\t\t{\n+\t\t  __real__ x -= t;\n+\t\t  sinix *= exp_t;\n+\t\t  cosix *= exp_t;\n+\t\t}\n+\t    }\n+\t  if (__real__ x > t)\n+\t    {\n+\t      /* Overflow (original real part of x > 3t).  */\n+\t      __real__ retval = FLT128_MAX * cosix;\n+\t      __imag__ retval = FLT128_MAX * sinix;\n+\t    }\n+\t  else\n+\t    {\n+\t      __float128 exp_val = expq (__real__ x);\n+\t      __real__ retval = exp_val * cosix;\n+\t      __imag__ retval = exp_val * sinix;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* If the imaginary part is +-inf or NaN and the real part\n+\t     is not +-inf the result is NaN + iNaN.  */\n+\t  __real__ retval = nanq (\"\");\n+\t  __imag__ retval = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  feraiseexcept (FE_INVALID);\n+#endif\n+\t}\n+    }\n+  else if (__builtin_expect (rcls == QUADFP_INFINITE, 1))\n+    {\n+      /* Real part is infinite.  */\n+      if (__builtin_expect (icls >= QUADFP_ZERO, 1))\n+\t{\n+\t  /* Imaginary part is finite.  */\n+\t  __float128 value = signbitq (__real__ x) ? 0.0Q : HUGE_VALQ;\n+\n+\t  if (icls == QUADFP_ZERO)\n+\t    {\n+\t      /* Imaginary part is 0.0.  */\n+\t      __real__ retval = value;\n+\t      __imag__ retval = __imag__ x;\n+\t    }\n+\t  else\n+\t    {\n+\t      __float128 sinix, cosix;\n+\n+\t      if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t\t{\n+\t\t  sincosq (__imag__ x, &sinix, &cosix);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sinix = __imag__ x;\n+\t\t  cosix = 1.0Q;\n+\t\t}\n+\n+\t      __real__ retval = copysignq (value, cosix);\n+\t      __imag__ retval = copysignq (value, sinix);\n+\t    }\n+\t}\n+      else if (signbitq (__real__ x) == 0)\n+\t{\n+\t  __real__ retval = HUGE_VALQ;\n+\t  __imag__ retval = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  if (icls == QUADFP_INFINITE)\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+\t}\n+      else\n+\t{\n+\t  __real__ retval = 0.0Q;\n+\t  __imag__ retval = copysignq (0.0Q, __imag__ x);\n+\t}\n+    }\n+  else\n+    {\n+      /* If the real part is NaN the result is NaN + iNaN.  */\n+      __real__ retval = nanq (\"\");\n+      __imag__ retval = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+      if (rcls != QUADFP_NAN || icls != QUADFP_NAN)\n+\tferaiseexcept (FE_INVALID);\n+#endif\n+    }\n+\n+  return retval;\n+}"}, {"sha": "c379bec72b623f30826d389c03eeabed0ba643d9", "filename": "libquadmath/math/clog10q.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fclog10q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fclog10q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fclog10q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,116 @@\n+/* Compute complex base 10 logarithm for complex __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+\n+/* log_10 (2).  */\n+#define M_LOG10_2q 0.3010299956639811952137388947244930267682Q\n+\n+\n+__complex128\n+clog10q (__complex128 x)\n+{\n+  __complex128 result;\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  if (__builtin_expect (rcls == QUADFP_ZERO && icls == QUADFP_ZERO, 0))\n+    {\n+      /* Real and imaginary part are 0.0.  */\n+      __imag__ result = signbitq (__real__ x) ? M_PIq : 0.0Q;\n+      __imag__ result = copysignq (__imag__ result, __imag__ x);\n+      /* Yes, the following line raises an exception.  */\n+      __real__ result = -1.0Q / fabsq (__real__ x);\n+    }\n+  else if (__builtin_expect (rcls != QUADFP_NAN && icls != QUADFP_NAN, 1))\n+    {\n+      /* Neither real nor imaginary part is NaN.  */\n+      __float128 absx = fabsq (__real__ x), absy = fabsq (__imag__ x);\n+      int scale = 0;\n+\n+      if (absx < absy)\n+\t{\n+\t  __float128 t = absx;\n+\t  absx = absy;\n+\t  absy = t;\n+\t}\n+\n+      if (absx > FLT128_MAX / 2.0Q)\n+\t{\n+\t  scale = -1;\n+\t  absx = scalbnq (absx, scale);\n+\t  absy = (absy >= FLT128_MIN * 2.0Q ? scalbnq (absy, scale) : 0.0Q);\n+\t}\n+      else if (absx < FLT128_MIN && absy < FLT128_MIN)\n+\t{\n+\t  scale = FLT128_MANT_DIG;\n+\t  absx = scalbnq (absx, scale);\n+\t  absy = scalbnq (absy, scale);\n+\t}\n+\n+      if (absx == 1.0Q && scale == 0)\n+\t{\n+\t  __float128 absy2 = absy * absy;\n+\t  if (absy2 <= FLT128_MIN * 2.0Q * M_LN10q)\n+\t    __real__ result\n+\t      = (absy2 / 2.0Q - absy2 * absy2 / 4.0Q) * M_LOG10Eq;\n+\t  else\n+\t    __real__ result = log1pq (absy2) * (M_LOG10Eq / 2.0Q);\n+\t}\n+      else if (absx > 1.0Q && absx < 2.0Q && absy < 1.0Q && scale == 0)\n+\t{\n+\t  __float128 d2m1 = (absx - 1.0Q) * (absx + 1.0Q);\n+\t  if (absy >= FLT128_EPSILON)\n+\t    d2m1 += absy * absy;\n+\t  __real__ result = log1pq (d2m1) * (M_LOG10Eq / 2.0Q);\n+\t}\n+      else if (absx < 1.0Q\n+\t       && absx >= 0.75Q\n+\t       && absy < FLT128_EPSILON / 2.0Q\n+\t       && scale == 0)\n+\t{\n+\t  __float128 d2m1 = (absx - 1.0Q) * (absx + 1.0Q);\n+\t  __real__ result = log1pq (d2m1) * (M_LOG10Eq / 2.0Q);\n+\t}\n+      else if (absx < 1.0Q && (absx >= 0.75Q || absy >= 0.5Q) && scale == 0)\n+\t{\n+\t  __float128 d2m1 = __quadmath_x2y2m1q (absx, absy);\n+\t  __real__ result = log1pq (d2m1) * (M_LOG10Eq / 2.0Q);\n+\t}\n+      else\n+\t{\n+\t  __float128 d = hypotq (absx, absy);\n+\t  __real__ result = log10q (d) - scale * M_LOG10_2q;\n+\t}\n+\n+      __imag__ result = M_LOG10Eq * atan2q (__imag__ x, __real__ x);\n+    }\n+  else\n+    {\n+      __imag__ result = nanq (\"\");\n+      if (rcls == QUADFP_INFINITE || icls == QUADFP_INFINITE)\n+\t/* Real or imaginary part is infinite.  */\n+\t__real__ result = HUGE_VALQ;\n+      else\n+\t__real__ result = nanq (\"\");\n+    }\n+\n+  return result;\n+}"}, {"sha": "1a772cd434dc80ba13ba3802b009621c16fb6c25", "filename": "libquadmath/math/clogq.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fclogq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fclogq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fclogq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,111 @@\n+/* Compute complex natural logarithm for complex __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+\n+__complex128\n+clogq (__complex128 x)\n+{\n+  __complex128 result;\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  if (__builtin_expect (rcls == QUADFP_ZERO && icls == QUADFP_ZERO, 0))\n+    {\n+      /* Real and imaginary part are 0.0.  */\n+      __imag__ result = signbitq (__real__ x) ? M_PIq : 0.0Q;\n+      __imag__ result = copysignq (__imag__ result, __imag__ x);\n+      /* Yes, the following line raises an exception.  */\n+      __real__ result = -1.0Q / fabsq (__real__ x);\n+    }\n+  else if (__builtin_expect (rcls != QUADFP_NAN && icls != QUADFP_NAN, 1))\n+    {\n+      /* Neither real nor imaginary part is NaN.  */\n+      __float128 absx = fabsq (__real__ x), absy = fabsq (__imag__ x);\n+      int scale = 0;\n+\n+      if (absx < absy)\n+\t{\n+\t  __float128 t = absx;\n+\t  absx = absy;\n+\t  absy = t;\n+\t}\n+\n+      if (absx > FLT128_MAX / 2.0)\n+\t{\n+\t  scale = -1;\n+\t  absx = scalbnq (absx, scale);\n+\t  absy = (absy >= FLT128_MIN * 2.0Q ? scalbnq (absy, scale) : 0.0Q);\n+\t}\n+      else if (absx < FLT128_MIN && absy < FLT128_MIN)\n+\t{\n+\t  scale = FLT128_MANT_DIG;\n+\t  absx = scalbnq (absx, scale);\n+\t  absy = scalbnq (absy, scale);\n+\t}\n+\n+      if (absx == 1.0Q && scale == 0)\n+\t{\n+\t  __float128 absy2 = absy * absy;\n+\t  if (absy2 <= FLT128_MIN * 2.0Q)\n+\t    __real__ result = absy2 / 2.0Q - absy2 * absy2 / 4.0Q;\n+\t  else\n+\t    __real__ result = log1pq (absy2) / 2.0Q;\n+\t}\n+      else if (absx > 1.0Q && absx < 2.0Q && absy < 1.0Q && scale == 0)\n+\t{\n+\t  __float128 d2m1 = (absx - 1.0Q) * (absx + 1.0Q);\n+\t  if (absy >= FLT128_EPSILON)\n+\t    d2m1 += absy * absy;\n+\t  __real__ result = log1pq (d2m1) / 2.0Q;\n+\t}\n+      else if (absx < 1.0Q\n+\t       && absx >= 0.75Q\n+\t       && absy < FLT128_EPSILON / 2.0Q\n+\t       && scale == 0)\n+\t{\n+\t  __float128 d2m1 = (absx - 1.0Q) * (absx + 1.0Q);\n+\t  __real__ result = log1pq (d2m1) / 2.0Q;\n+\t}\n+      else if (absx < 1.0 && (absx >= 0.75Q || absy >= 0.5Q) && scale == 0)\n+\t{\n+\t  __float128 d2m1 = __quadmath_x2y2m1q (absx, absy);\n+\t  __real__ result = log1pq (d2m1) / 2.0Q;\n+\t}\n+      else\n+\t{\n+\t  __float128 d = hypotq (absx, absy);\n+\t  __real__ result = logq (d) - scale * M_LN2q;\n+\t}\n+\n+      __imag__ result = atan2q (__imag__ x, __real__ x);\n+    }\n+  else\n+    {\n+      __imag__ result = nanq (\"\");\n+      if (rcls == QUADFP_INFINITE || icls == QUADFP_INFINITE)\n+\t/* Real or imaginary part is infinite.  */\n+\t__real__ result = HUGE_VALQ;\n+      else\n+\t__real__ result = nanq (\"\");\n+    }\n+\n+  return result;\n+}"}, {"sha": "8cf9e9808cc2275184dff201bb0d1e970cf98284", "filename": "libquadmath/math/complex.c", "status": "modified", "additions": 32, "deletions": 178, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcomplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcomplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcomplex.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,75 +1,49 @@\n+/* GCC Quad-Precision Math Library\n+   Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+   Written by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+This file is part of the libquadmath library.\n+Libquadmath is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libquadmath is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libquadmath; see the file COPYING.LIB.  If\n+not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n #include \"quadmath-imp.h\"\n \n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n \n #define REALPART(z) (__real__(z)) \n #define IMAGPART(z) (__imag__(z)) \n #define COMPLEX_ASSIGN(z_, r_, i_) {__real__(z_) = (r_); __imag__(z_) = (i_);} \n \n \n-// Horrible... GCC doesn't know how to multiply or divide these\n-// __complex128 things. We have to do it on our own.\n-// Protect it around macros so, some day, we can switch it on\n-\n-#if 0\n-\n-# define C128_MULT(x,y) ((x)*(y))\n-# define C128_DIV(x,y) ((x)/(y))\n-\n-#else\n-\n-#define C128_MULT(x,y) mult_c128(x,y)\n-#define C128_DIV(x,y) div_c128(x,y)\n-\n-static inline __complex128 mult_c128 (__complex128 x, __complex128 y)\n-{\n-  __float128 r1 = REALPART(x), i1 = IMAGPART(x);\n-  __float128 r2 = REALPART(y), i2 = IMAGPART(y);\n-  __complex128 res;\n-  COMPLEX_ASSIGN(res, r1*r2 - i1*i2, i2*r1 + i1*r2);\n-  return res;\n-}\n-\n-\n-// Careful: the algorithm for the division sucks. A lot.\n-static inline __complex128 div_c128 (__complex128 x, __complex128 y)\n-{\n-  __float128 n = hypotq (REALPART (y), IMAGPART (y));\n-  __float128 r1 = REALPART(x), i1 = IMAGPART(x);\n-  __float128 r2 = REALPART(y), i2 = IMAGPART(y);\n-  __complex128 res;\n-  COMPLEX_ASSIGN(res, r1*r2 + i1*i2, i1*r2 - i2*r1);\n-  return res / n;\n-}\n-\n-#endif\n-\n-\n-\n __float128\n cabsq (__complex128 z)\n {\n   return hypotq (REALPART (z), IMAGPART (z));\n }\n \n \n-__complex128\n-cexpq (__complex128 z)\n-{\n-  __float128 a, b;\n-  __complex128 v;\n-\n-  a = REALPART (z);\n-  b = IMAGPART (z);\n-  COMPLEX_ASSIGN (v, cosq (b), sinq (b));\n-  return expq (a) * v;\n-}\n-\n-\n __complex128\n cexpiq (__float128 x)\n {\n+  __float128 sinix, cosix;\n   __complex128 v;\n-  COMPLEX_ASSIGN (v, cosq (x), sinq (x));\n+  sincosq (x, &sinix, &cosix);\n+  COMPLEX_ASSIGN (v, cosix, sinix);\n   return v;\n }\n \n@@ -81,138 +55,18 @@ cargq (__complex128 z)\n }\n \n \n-__complex128\n-clogq (__complex128 z)\n-{\n-  __complex128 v;\n-  COMPLEX_ASSIGN (v, logq (cabsq (z)), cargq (z));\n-  return v;\n-}\n-\n-\n-__complex128\n-clog10q (__complex128 z)\n-{\n-  __complex128 v;\n-  COMPLEX_ASSIGN (v, log10q (cabsq (z)), cargq (z));\n-  return v;\n-}\n-\n-\n __complex128\n cpowq (__complex128 base, __complex128 power)\n {\n-  return cexpq (C128_MULT(power, clogq (base)));\n+  return cexpq (power * clogq (base));\n }\n \n \n __complex128\n-csinq (__complex128 a)\n+ccosq (__complex128 x)\n {\n-  __float128 r = REALPART (a), i = IMAGPART (a);\n-  __complex128 v;\n-  COMPLEX_ASSIGN (v, sinq (r) * coshq (i), cosq (r) * sinhq (i));\n-  return v;\n-}\n-\n-\n-__complex128\n-csinhq (__complex128 a)\n-{\n-  __float128 r = REALPART (a), i = IMAGPART (a);\n-  __complex128 v;\n-  COMPLEX_ASSIGN (v, sinhq (r) * cosq (i), coshq (r) * sinq (i));\n-  return v;\n-}\n-\n-\n-__complex128\n-ccosq (__complex128 a)\n-{\n-  __float128 r = REALPART (a), i = IMAGPART (a);\n-  __complex128 v;\n-  COMPLEX_ASSIGN (v, cosq (r) * coshq (i), - (sinq (r) * sinhq (i)));\n-  return v;\n-}\n-\n-\n-__complex128\n-ccoshq (__complex128 a)\n-{\n-  __float128 r = REALPART (a), i = IMAGPART (a);\n-  __complex128 v;\n-  COMPLEX_ASSIGN (v, coshq (r) * cosq (i),  sinhq (r) * sinq (i));\n-  return v;\n-}\n-\n-\n-__complex128\n-ctanq (__complex128 a)\n-{\n-  __float128 rt = tanq (REALPART (a)), it = tanhq (IMAGPART (a));\n-  __complex128 n, d;\n-  COMPLEX_ASSIGN (n, rt, it);\n-  COMPLEX_ASSIGN (d, 1, - (rt * it));\n-  return C128_DIV(n,d);\n-}\n-\n-\n-__complex128\n-ctanhq (__complex128 a)\n-{\n-  __float128 rt = tanhq (REALPART (a)), it = tanq (IMAGPART (a));\n-  __complex128 n, d;\n-  COMPLEX_ASSIGN (n, rt, it);\n-  COMPLEX_ASSIGN (d, 1, rt * it);\n-  return C128_DIV(n,d);\n-}\n-\n-\n-/* Square root algorithm from glibc.  */\n-__complex128\n-csqrtq (__complex128 z)\n-{\n-  __float128 re = REALPART(z), im = IMAGPART(z);\n-  __complex128 v;\n+  __complex128 y;\n \n-  if (im == 0)\n-  {\n-    if (isnanq (re))\n-    {\n-      COMPLEX_ASSIGN (v, -re, -re);\n-    }\n-    else if (re < 0)\n-    {\n-      COMPLEX_ASSIGN (v, 0, copysignq (sqrtq (-re), im));\n-    }\n-    else\n-    {\n-      COMPLEX_ASSIGN (v, fabsq (sqrtq (re)), copysignq (0, im));\n-    }\n-  }\n-  else if (isinfq (im))\n-  {\n-    COMPLEX_ASSIGN (v, fabsq (im), im);\n-  }\n-  else if (re == 0)\n-  {\n-    __float128 r = sqrtq (0.5 * fabsq (im));\n-    COMPLEX_ASSIGN (v, r, copysignq (r, im));\n-  }\n-  else\n-  {\n-    __float128 d = hypotq (re, im);\n-    __float128 r, s;\n-\n-    /* Use the identity   2  Re res  Im res = Im x\n-\tto avoid cancellation error in  d +/- Re x.  */\n-    if (re > 0)\n-      r = sqrtq (0.5 * d + 0.5 * re), s = (0.5 * im) / r;\n-    else\n-      s = sqrtq (0.5 * d - 0.5 * re), r = fabsq ((0.5 * im) / s);\n-\n-    COMPLEX_ASSIGN (v, r, copysignq (s, im));\n-  }\n-  return v;\n+  COMPLEX_ASSIGN (y, -IMAGPART (x), REALPART (x));\n+  return ccoshq (y);\n }\n-"}, {"sha": "054de2d2eb38b9da0a0ef8e43371809ef410ddae", "filename": "libquadmath/math/copysignq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcopysignq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcopysignq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcopysignq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_copysignl.c -- long double version of s_copysign.c.\n+/* copysignq.c -- __float128 version of s_copysign.c.\n  * Conversion to long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "77f4b98338b3e8ba5f77d9703f2126870d0ce3af", "filename": "libquadmath/math/coshq.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcoshq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcoshq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcoshq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -30,25 +30,25 @@\n     License along with this library; if not, write to the Free Software\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n-/* __ieee754_coshl(x)\n+/* coshq(x)\n  * Method :\n- * mathematically coshl(x) if defined to be (exp(x)+exp(-x))/2\n- *      1. Replace x by |x| (coshl(x) = coshl(-x)).\n+ * mathematically coshq(x) if defined to be (exp(x)+exp(-x))/2\n+ *      1. Replace x by |x| (coshq(x) = coshq(-x)).\n  *      2.\n  *                                                      [ exp(x) - 1 ]^2\n- *          0        <= x <= ln2/2  :  coshl(x) := 1 + -------------------\n+ *          0        <= x <= ln2/2  :  coshq(x) := 1 + -------------------\n  *                                                         2*exp(x)\n  *\n  *                                                 exp(x) +  1/exp(x)\n- *          ln2/2    <= x <= 22     :  coshl(x) := -------------------\n+ *          ln2/2    <= x <= 22     :  coshq(x) := -------------------\n  *                                                         2\n- *          22       <= x <= lnovft :  coshl(x) := expl(x)/2\n- *          lnovft   <= x <= ln2ovft:  coshl(x) := expl(x/2)/2 * expl(x/2)\n- *          ln2ovft  <  x           :  coshl(x) := huge*huge (overflow)\n+ *          22       <= x <= lnovft :  coshq(x) := expq(x)/2\n+ *          lnovft   <= x <= ln2ovft:  coshq(x) := expq(x/2)/2 * expq(x/2)\n+ *          ln2ovft  <  x           :  coshq(x) := huge*huge (overflow)\n  *\n  * Special cases:\n- *      coshl(x) is |x| if x is +INF, -INF, or NaN.\n- *      only coshl(0)=1 is exact for finite x.\n+ *      coshq(x) is |x| if x is +INF, -INF, or NaN.\n+ *      only coshq(0)=1 is exact for finite x.\n  */\n \n #include \"quadmath-imp.h\"\n@@ -73,7 +73,7 @@ coshq (__float128 x)\n   if (ex >= 0x7fff0000)\n     return x * x;\n \n-  /* |x| in [0,0.5*ln2], return 1+expm1l(|x|)^2/(2*expl(|x|)) */\n+  /* |x| in [0,0.5*ln2], return 1+expm1l(|x|)^2/(2*expq(|x|)) */\n   if (ex < 0x3ffd62e4) /* 0.3465728759765625 */\n     {\n       t = expm1q (u.value);"}, {"sha": "28630b93a6f0e2cbc82c28f716ca632ecab79757", "filename": "libquadmath/math/cosq.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcosq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcosq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcosq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_cosl.c -- long double version of s_cos.c.\n+/* cosq.c -- __float128 version of s_cos.c.\n  * Conversion to long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n \n@@ -13,13 +13,13 @@\n  * ====================================================\n  */\n \n-/* cosl(x)\n+/* cosq(x)\n  * Return cosine function of x.\n  *\n  * kernel function:\n- *\t__kernel_sinl\t\t... sine function on [-pi/4,pi/4]\n- *\t__kernel_cosl\t\t... cosine function on [-pi/4,pi/4]\n- *\t__ieee754_rem_pio2l\t... argument reduction routine\n+ *\t__quadmath_kernel_sinq\t... sine function on [-pi/4,pi/4]\n+ *\t__quadmath_kernel_cosq\t... cosine function on [-pi/4,pi/4]\n+ *\t__quadmath_rem_pio2q\t... argument reduction routine\n  *\n  * Method.\n  *      Let S,C and T denote the sin, cos and tan respectively on"}, {"sha": "42d29adfd8c3198df29f412f1ece090033b7e79b", "filename": "libquadmath/math/cosq_kernel.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcosq_kernel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcosq_kernel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcosq_kernel.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -99,13 +99,17 @@ __quadmath_kernel_cosq (__float128 x, __float128 y)\n     {\n       /* So that we don't have to use too large polynomial,  we find\n \t l and h such that x = l + h,  where fabsl(l) <= 1.0/256 with 83\n-\t possible values for h.  We look up cosl(h) and sinl(h) in\n-\t pre-computed tables,  compute cosl(l) and sinl(l) using a\n+\t possible values for h.  We look up cosq(h) and sinq(h) in\n+\t pre-computed tables,  compute cosq(l) and sinq(l) using a\n \t Chebyshev polynomial of degree 10(11) and compute\n-\t cosl(h+l) = cosl(h)cosl(l) - sinl(h)sinl(l).  */\n+\t cosq(h+l) = cosq(h)cosq(l) - sinq(h)sinq(l).  */\n       index = 0x3ffe - (tix >> 16);\n       hix = (tix + (0x200 << index)) & (0xfffffc00 << index);\n-      x = fabsq (x);\n+      if (signbitq (x))\n+       {\n+         x = -x;\n+         y = -y;\n+       }\n       switch (index)\n \t{\n \tcase 0: index = ((45 << 10) + hix - 0x3ffe0000) >> 8; break;"}, {"sha": "c16d576f4daf4b3782fca041bed6f8f69828c803", "filename": "libquadmath/math/csinhq.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcsinhq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcsinhq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcsinhq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,166 @@\n+/* Complex sine hyperbole function for complex __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+csinhq (__complex128 x)\n+{\n+  __complex128 retval;\n+  int negate = signbitq (__real__ x);\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  __real__ x = fabsq (__real__ x);\n+\n+  if (__builtin_expect (rcls >= QUADFP_ZERO, 1))\n+    {\n+      /* Real part is finite.  */\n+      if (__builtin_expect (icls >= QUADFP_ZERO, 1))\n+\t{\n+\t  /* Imaginary part is finite.  */\n+\t  const int t = (int) ((FLT128_MAX_EXP - 1) * M_LN2q);\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__imag__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __imag__ x;\n+\t      cosix = 1.0Q;\n+\t    }\n+\n+\t  if (fabsq (__real__ x) > t)\n+\t    {\n+\t      __float128 exp_t = expq (t);\n+\t      __float128 rx = fabsq (__real__ x);\n+\t      if (signbitq (__real__ x))\n+\t\tcosix = -cosix;\n+\t      rx -= t;\n+\t      sinix *= exp_t / 2.0Q;\n+\t      cosix *= exp_t / 2.0Q;\n+\t      if (rx > t)\n+\t\t{\n+\t\t  rx -= t;\n+\t\t  sinix *= exp_t;\n+\t\t  cosix *= exp_t;\n+\t\t}\n+\t      if (rx > t)\n+\t\t{\n+\t\t  /* Overflow (original real part of x > 3t).  */\n+\t\t  __real__ retval = FLT128_MAX * cosix;\n+\t\t  __imag__ retval = FLT128_MAX * sinix;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __float128 exp_val = expq (rx);\n+\t\t  __real__ retval = exp_val * cosix;\n+\t\t  __imag__ retval = exp_val * sinix;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ retval = sinhq (__real__ x) * cosix;\n+\t      __imag__ retval = coshq (__real__ x) * sinix;\n+\t    }\n+\n+\t  if (negate)\n+\t    __real__ retval = -__real__ retval;\n+\t}\n+      else\n+\t{\n+\t  if (rcls == QUADFP_ZERO)\n+\t    {\n+\t      /* Real part is 0.0.  */\n+\t      __real__ retval = copysignq (0.0Q, negate ? -1.0Q : 1.0Q);\n+\t      __imag__ retval = nanq (\"\") + nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t      if (icls == QUADFP_INFINITE)\n+\t\tferaiseexcept (FE_INVALID);\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ retval = nanq (\"\");\n+\t      __imag__ retval = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t      feraiseexcept (FE_INVALID);\n+#endif\n+\t    }\n+\t}\n+    }\n+  else if (rcls == QUADFP_INFINITE)\n+    {\n+      /* Real part is infinite.  */\n+      if (__builtin_expect (icls > QUADFP_ZERO, 1))\n+\t{\n+\t  /* Imaginary part is finite.  */\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__imag__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __imag__ x;\n+\t      cosix = 1.0;\n+\t    }\n+\n+\t  __real__ retval = copysignq (HUGE_VALQ, cosix);\n+\t  __imag__ retval = copysignq (HUGE_VALQ, sinix);\n+\n+\t  if (negate)\n+\t    __real__ retval = -__real__ retval;\n+\t}\n+      else if (icls == QUADFP_ZERO)\n+\t{\n+\t  /* Imaginary part is 0.0.  */\n+\t  __real__ retval = negate ? -HUGE_VALQ : HUGE_VALQ;\n+\t  __imag__ retval = __imag__ x;\n+\t}\n+      else\n+\t{\n+\t  /* The addition raises the invalid exception.  */\n+\t  __real__ retval = HUGE_VALQ;\n+\t  __imag__ retval = nanq (\"\") + nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  if (icls == QUADFP_INFINITE)\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+\t}\n+    }\n+  else\n+    {\n+      __real__ retval = nanq (\"\");\n+      __imag__ retval = __imag__ x == 0.0Q ? __imag__ x : nanq (\"\");\n+    }\n+\n+  return retval;\n+}"}, {"sha": "c837e50b87fda07a470c1eef3e03c5bd95c773f3", "filename": "libquadmath/math/csinq.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcsinq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcsinq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcsinq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,171 @@\n+/* Complex sine function for complex __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+csinq (__complex128 x)\n+{\n+  __complex128 retval;\n+  int negate = signbitq (__real__ x);\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  __real__ x = fabsq (__real__ x);\n+\n+  if (__builtin_expect (icls >= QUADFP_ZERO, 1))\n+    {\n+      /* Imaginary part is finite.  */\n+      if (__builtin_expect (rcls >= QUADFP_ZERO, 1))\n+\t{\n+\t  /* Real part is finite.  */\n+\t  const int t = (int) ((FLT128_MAX_EXP - 1) * M_LN2q);\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (rcls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__real__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __real__ x;\n+\t      cosix = 1.0Q;\n+\t    }\n+\n+\t  if (fabsq (__imag__ x) > t)\n+\t    {\n+\t      __float128 exp_t = expq (t);\n+\t      __float128 ix = fabsq (__imag__ x);\n+\t      if (signbitq (__imag__ x))\n+\t\tcosix = -cosix;\n+\t      ix -= t;\n+\t      sinix *= exp_t / 2.0Q;\n+\t      cosix *= exp_t / 2.0Q;\n+\t      if (ix > t)\n+\t\t{\n+\t\t  ix -= t;\n+\t\t  sinix *= exp_t;\n+\t\t  cosix *= exp_t;\n+\t\t}\n+\t      if (ix > t)\n+\t\t{\n+\t\t  /* Overflow (original imaginary part of x > 3t).  */\n+\t\t  __real__ retval = FLT128_MAX * sinix;\n+\t\t  __imag__ retval = FLT128_MAX * cosix;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __float128 exp_val = expq (ix);\n+\t\t  __real__ retval = exp_val * sinix;\n+\t\t  __imag__ retval = exp_val * cosix;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ retval = coshq (__imag__ x) * sinix;\n+\t      __imag__ retval = sinhq (__imag__ x) * cosix;\n+\t    }\n+\n+\t  if (negate)\n+\t    __real__ retval = -__real__ retval;\n+\t}\n+      else\n+\t{\n+\t  if (icls == QUADFP_ZERO)\n+\t    {\n+\t      /* Imaginary part is 0.0.  */\n+\t      __real__ retval = nanq (\"\");\n+\t      __imag__ retval = __imag__ x;\n+\n+#ifdef HAVE_FENV_H\n+\t      if (rcls == QUADFP_INFINITE)\n+\t\tferaiseexcept (FE_INVALID);\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ retval = nanq (\"\");\n+\t      __imag__ retval = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t      feraiseexcept (FE_INVALID);\n+#endif\n+\t    }\n+\t}\n+    }\n+  else if (icls == QUADFP_INFINITE)\n+    {\n+      /* Imaginary part is infinite.  */\n+      if (rcls == QUADFP_ZERO)\n+\t{\n+\t  /* Real part is 0.0.  */\n+\t  __real__ retval = copysignq (0.0Q, negate ? -1.0Q : 1.0Q);\n+\t  __imag__ retval = __imag__ x;\n+\t}\n+      else if (rcls > QUADFP_ZERO)\n+\t{\n+\t  /* Real part is finite.  */\n+\t  __float128 sinix, cosix;\n+\n+\t  if (__builtin_expect (rcls != QUADFP_SUBNORMAL, 1))\n+\t    {\n+\t      sincosq (__real__ x, &sinix, &cosix);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinix = __real__ x;\n+\t      cosix = 1.0;\n+\t    }\n+\n+\t  __real__ retval = copysignq (HUGE_VALQ, sinix);\n+\t  __imag__ retval = copysignq (HUGE_VALQ, cosix);\n+\n+\t  if (negate)\n+\t    __real__ retval = -__real__ retval;\n+\t  if (signbitq (__imag__ x))\n+\t    __imag__ retval = -__imag__ retval;\n+\t}\n+      else\n+\t{\n+\t  /* The addition raises the invalid exception.  */\n+\t  __real__ retval = nanq (\"\");\n+\t  __imag__ retval = HUGE_VALQ;\n+\n+#ifdef HAVE_FENV_H\n+\t  if (rcls == QUADFP_INFINITE)\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+\t}\n+    }\n+  else\n+    {\n+      if (rcls == QUADFP_ZERO)\n+\t__real__ retval = copysignq (0.0Q, negate ? -1.0Q : 1.0Q);\n+      else\n+\t__real__ retval = nanq (\"\");\n+      __imag__ retval = nanq (\"\");\n+    }\n+\n+  return retval;\n+}"}, {"sha": "5279e4378a29f3d0583d1eb8c62de8e3776f7ab4", "filename": "libquadmath/math/csqrtq.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcsqrtq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fcsqrtq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fcsqrtq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,143 @@\n+/* Complex square root of __float128 value.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Based on an algorithm by Stephen L. Moshier <moshier@world.std.com>.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+csqrtq (__complex128 x)\n+{\n+  __complex128 res;\n+  int rcls = fpclassifyq (__real__ x);\n+  int icls = fpclassifyq (__imag__ x);\n+\n+  if (__builtin_expect (rcls <= QUADFP_INFINITE || icls <= QUADFP_INFINITE, 0))\n+    {\n+      if (icls == QUADFP_INFINITE)\n+\t{\n+\t  __real__ res = HUGE_VALQ;\n+\t  __imag__ res = __imag__ x;\n+\t}\n+      else if (rcls == QUADFP_INFINITE)\n+\t{\n+\t  if (__real__ x < 0.0Q)\n+\t    {\n+\t      __real__ res = icls == QUADFP_NAN ? nanq (\"\") : 0;\n+\t      __imag__ res = copysignq (HUGE_VALQ, __imag__ x);\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ res = __real__ x;\n+\t      __imag__ res = (icls == QUADFP_NAN\n+\t\t\t      ? nanq (\"\") : copysignq (0.0Q, __imag__ x));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  __real__ res = nanq (\"\");\n+\t  __imag__ res = nanq (\"\");\n+\t}\n+    }\n+  else\n+    {\n+      if (__builtin_expect (icls == QUADFP_ZERO, 0))\n+\t{\n+\t  if (__real__ x < 0.0Q)\n+\t    {\n+\t      __real__ res = 0.0Q;\n+\t      __imag__ res = copysignq (sqrtq (-__real__ x),\n+\t\t\t\t\t__imag__ x);\n+\t    }\n+\t  else\n+\t    {\n+\t      __real__ res = fabsq (sqrtq (__real__ x));\n+\t      __imag__ res = copysignq (0.0Q, __imag__ x);\n+\t    }\n+\t}\n+      else if (__builtin_expect (rcls == QUADFP_ZERO, 0))\n+\t{\n+\t  __float128 r;\n+\t  if (fabsq (__imag__ x) >= 2.0Q * FLT128_MIN)\n+\t    r = sqrtq (0.5Q * fabsq (__imag__ x));\n+\t  else\n+\t    r = 0.5Q * sqrtq (2.0Q * fabsq (__imag__ x));\n+\n+\t  __real__ res = r;\n+\t  __imag__ res = copysignq (r, __imag__ x);\n+\t}\n+      else\n+\t{\n+\t  __float128 d, r, s;\n+\t  int scale = 0;\n+\n+\t  if (fabsq (__real__ x) > FLT128_MAX / 4.0Q)\n+\t    {\n+\t      scale = 1;\n+\t      __real__ x = scalbnq (__real__ x, -2 * scale);\n+\t      __imag__ x = scalbnq (__imag__ x, -2 * scale);\n+\t    }\n+\t  else if (fabsq (__imag__ x) > FLT128_MAX / 4.0Q)\n+\t    {\n+\t      scale = 1;\n+\t      if (fabsq (__real__ x) >= 4.0Q * FLT128_MIN)\n+\t\t__real__ x = scalbnq (__real__ x, -2 * scale);\n+\t      else\n+\t\t__real__ x = 0.0Q;\n+\t      __imag__ x = scalbnq (__imag__ x, -2 * scale);\n+\t    }\n+\t  else if (fabsq (__real__ x) < FLT128_MIN\n+\t\t   && fabsq (__imag__ x) < FLT128_MIN)\n+\t    {\n+\t      scale = -(FLT128_MANT_DIG / 2);\n+\t      __real__ x = scalbnq (__real__ x, -2 * scale);\n+\t      __imag__ x = scalbnq (__imag__ x, -2 * scale);\n+\t    }\n+\n+\t  d = hypotq (__real__ x, __imag__ x);\n+\t  /* Use the identity   2  Re res  Im res = Im x\n+\t     to avoid cancellation error in  d +/- Re x.  */\n+\t  if (__real__ x > 0)\n+\t    {\n+\t      r = sqrtq (0.5Q * (d + __real__ x));\n+\t      s = 0.5Q * (__imag__ x / r);\n+\t    }\n+\t  else\n+\t    {\n+\t      s = sqrtq (0.5Q * (d - __real__ x));\n+\t      r = fabsq (0.5Q * (__imag__ x / s));\n+\t    }\n+\n+\t  if (scale)\n+\t    {\n+\t      r = scalbnq (r, scale);\n+\t      s = scalbnq (s, scale);\n+\t    }\n+\n+\t  __real__ res = r;\n+\t  __imag__ res = copysignq (s, __imag__ x);\n+\t}\n+    }\n+\n+  return res;\n+}"}, {"sha": "8934cfad59f26d9f18a153dcd7dd2b890ddd8b66", "filename": "libquadmath/math/ctanhq.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fctanhq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fctanhq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fctanhq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,120 @@\n+/* Complex hyperbole tangent for __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+ctanhq (__complex128 x)\n+{\n+  __complex128 res;\n+\n+  if (__builtin_expect (!finiteq (__real__ x) || !finiteq (__imag__ x), 0))\n+    {\n+      if (__quadmath_isinf_nsq (__real__ x))\n+\t{\n+\t  __real__ res = copysignq (1.0Q, __real__ x);\n+\t  __imag__ res = copysignq (0.0Q, __imag__ x);\n+\t}\n+      else if (__imag__ x == 0.0Q)\n+\t{\n+\t  res = x;\n+\t}\n+      else\n+\t{\n+\t  __real__ res = nanq (\"\");\n+\t  __imag__ res = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  if (__quadmath_isinf_nsq (__imag__ x))\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+\t}\n+    }\n+  else\n+    {\n+      __float128 sinix, cosix;\n+      __float128 den;\n+      const int t = (int) ((FLT128_MAX_EXP - 1) * M_LN2q / 2);\n+      int icls = fpclassifyq (__imag__ x);\n+\n+      /* tanh(x+iy) = (sinh(2x) + i*sin(2y))/(cosh(2x) + cos(2y))\n+\t = (sinh(x)*cosh(x) + i*sin(y)*cos(y))/(sinh(x)^2 + cos(y)^2).  */\n+\n+      if (__builtin_expect (icls != QUADFP_SUBNORMAL, 1))\n+\t{\n+\t  sincosq (__imag__ x, &sinix, &cosix);\n+\t}\n+      else\n+\t{\n+\t  sinix = __imag__ x;\n+\t  cosix = 1.0Q;\n+\t}\n+\n+      if (fabsq (__real__ x) > t)\n+\t{\n+\t  /* Avoid intermediate overflow when the imaginary part of\n+\t     the result may be subnormal.  Ignoring negligible terms,\n+\t     the real part is +/- 1, the imaginary part is\n+\t     sin(y)*cos(y)/sinh(x)^2 = 4*sin(y)*cos(y)/exp(2x).  */\n+\t  __float128 exp_2t = expq (2 * t);\n+\n+\t  __real__ res = copysignq (1.0, __real__ x);\n+\t  __imag__ res = 4 * sinix * cosix;\n+\t  __real__ x = fabsq (__real__ x);\n+\t  __real__ x -= t;\n+\t  __imag__ res /= exp_2t;\n+\t  if (__real__ x > t)\n+\t    {\n+\t      /* Underflow (original real part of x has absolute value\n+\t\t > 2t).  */\n+\t      __imag__ res /= exp_2t;\n+\t    }\n+\t  else\n+\t    __imag__ res /= expq (2 * __real__ x);\n+\t}\n+      else\n+\t{\n+\t  __float128 sinhrx, coshrx;\n+\t  if (fabsq (__real__ x) > FLT128_MIN)\n+\t    {\n+\t      sinhrx = sinhq (__real__ x);\n+\t      coshrx = coshq (__real__ x);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinhrx = __real__ x;\n+\t      coshrx = 1.0Q;\n+\t    }\n+\n+\t  if (fabsq (sinhrx) > fabsq (cosix) * FLT128_EPSILON)\n+\t    den = sinhrx * sinhrx + cosix * cosix;\n+\t  else\n+\t    den = cosix * cosix;\n+\t  __real__ res = sinhrx * coshrx / den;\n+\t  __imag__ res = sinix * cosix / den;\n+\t}\n+    }\n+\n+  return res;\n+}"}, {"sha": "d390511ca2008c3f10162dc76e765a6200eb1973", "filename": "libquadmath/math/ctanq.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fctanq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fctanq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fctanq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,120 @@\n+/* Complex tangent function for complex __float128.\n+   Copyright (C) 1997-2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+\n+#ifdef HAVE_FENV_H\n+# include <fenv.h>\n+#endif\n+\n+\n+__complex128\n+ctanq (__complex128 x)\n+{\n+  __complex128 res;\n+\n+  if (__builtin_expect (!finiteq (__real__ x) || !finiteq (__imag__ x), 0))\n+    {\n+      if (__quadmath_isinf_nsq (__imag__ x))\n+\t{\n+\t  __real__ res = copysignq (0.0Q, __real__ x);\n+\t  __imag__ res = copysignq (1.0Q, __imag__ x);\n+\t}\n+      else if (__real__ x == 0.0Q)\n+\t{\n+\t  res = x;\n+\t}\n+      else\n+\t{\n+\t  __real__ res = nanq (\"\");\n+\t  __imag__ res = nanq (\"\");\n+\n+#ifdef HAVE_FENV_H\n+\t  if (__quadmath_isinf_nsq (__real__ x))\n+\t    feraiseexcept (FE_INVALID);\n+#endif\n+\t}\n+    }\n+  else\n+    {\n+      __float128 sinrx, cosrx;\n+      __float128 den;\n+      const int t = (int) ((FLT128_MAX_EXP - 1) * M_LN2q / 2.0Q);\n+      int rcls = fpclassifyq (__real__ x);\n+\n+      /* tan(x+iy) = (sin(2x) + i*sinh(2y))/(cos(2x) + cosh(2y))\n+\t = (sin(x)*cos(x) + i*sinh(y)*cosh(y)/(cos(x)^2 + sinh(y)^2). */\n+\n+      if (__builtin_expect (rcls != QUADFP_SUBNORMAL, 1))\n+\t{\n+\t  sincosq (__real__ x, &sinrx, &cosrx);\n+\t}\n+      else\n+\t{\n+\t  sinrx = __real__ x;\n+\t  cosrx = 1.0Q;\n+\t}\n+\n+      if (fabsq (__imag__ x) > t)\n+\t{\n+\t  /* Avoid intermediate overflow when the real part of the\n+\t     result may be subnormal.  Ignoring negligible terms, the\n+\t     imaginary part is +/- 1, the real part is\n+\t     sin(x)*cos(x)/sinh(y)^2 = 4*sin(x)*cos(x)/exp(2y).  */\n+\t  __float128 exp_2t = expq (2 * t);\n+\n+\t  __imag__ res = copysignq (1.0Q, __imag__ x);\n+\t  __real__ res = 4 * sinrx * cosrx;\n+\t  __imag__ x = fabsq (__imag__ x);\n+\t  __imag__ x -= t;\n+\t  __real__ res /= exp_2t;\n+\t  if (__imag__ x > t)\n+\t    {\n+\t      /* Underflow (original imaginary part of x has absolute\n+\t\t value > 2t).  */\n+\t      __real__ res /= exp_2t;\n+\t    }\n+\t  else\n+\t    __real__ res /= expq (2 * __imag__ x);\n+\t}\n+      else\n+\t{\n+\t  __float128 sinhix, coshix;\n+\t  if (fabsq (__imag__ x) > FLT128_MIN)\n+\t    {\n+\t      sinhix = sinhq (__imag__ x);\n+\t      coshix = coshq (__imag__ x);\n+\t    }\n+\t  else\n+\t    {\n+\t      sinhix = __imag__ x;\n+\t      coshix = 1.0Q;\n+\t    }\n+\n+\t  if (fabsq (sinhix) > fabsq (cosrx) * FLT128_EPSILON)\n+\t    den = cosrx * cosrx + sinhix * sinhix;\n+\t  else\n+\t    den = cosrx * cosrx;\n+\t  __real__ res = sinrx * cosrx / den;\n+\t  __imag__ res = sinhix * coshix / den;\n+\t}\n+    }\n+\n+  return res;\n+}"}, {"sha": "8d383e9ca7028e4642bcaaeba5c88a81547f53d5", "filename": "libquadmath/math/erfq.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ferfq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ferfq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ferfq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -30,8 +30,8 @@\n     License along with this library; if not, write to the Free Software\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n-/* double erf(double x)\n- * double erfc(double x)\n+/* __float128 erfq(__float128 x)\n+ * __float128 erfcq(__float128 x)\n  *\t\t\t     x\n  *\t\t      2      |\\\n  *     erf(x)  =  ---------  | exp(-t*t)dt"}, {"sha": "70c638d7a08620bda8491e6ac1f6afbdc997b669", "filename": "libquadmath/math/expq.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fexpq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fexpq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fexpq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -30,19 +30,19 @@\n #endif\n \n \n-/* __expl_table basically consists of four tables, T_EXPL_ARG{1,2} and\n+/* __expq_table basically consists of four tables, T_EXPL_ARG{1,2} and\n    T_EXPL_RES{1,2}. All tables use positive and negative indexes, the 0 points\n    are marked by T_EXPL_* defines.\n    For ARG1 and RES1 tables lets B be 89 and S 256.0, for ARG2 and RES2 B is 65\n    and S 32768.0.\n    These table have the property that, for all integers -B <= i <= B\n-   expl(__expl_table[T_EXPL_ARGN+2*i]+__expl_table[T_EXPL_ARGN+2*i+1]+r) ==\n-   __expl_table[T_EXPL_RESN+i], __expl_table[T_EXPL_RESN+i] is some exact number\n+   expl(__expq_table[T_EXPL_ARGN+2*i]+__expq_table[T_EXPL_ARGN+2*i+1]+r) ==\n+   __expq_table[T_EXPL_RESN+i], __expq_table[T_EXPL_RESN+i] is some exact number\n    with the low 58 bits of the mantissa 0,\n-   __expl_table[T_EXPL_ARGN+2*i] == i/S+s\n+   __expq_table[T_EXPL_ARGN+2*i] == i/S+s\n    where absl(s) <= 2^-54 and absl(r) <= 2^-212.  */\n \n-static const __float128 __expl_table [] = {\n+static const __float128 __expq_table [] = {\n  -3.47656250000000000584188889839535373E-01Q, /* bffd640000000000002b1b04213cf000 */\n   6.90417668990715641167244540876988960E-32Q, /* 3f97667c3fdb588a6ae1af8748357a17 */\n  -3.43749999999999981853132895957607418E-01Q, /* bffd5ffffffffffffac4ff5f4050b000 */\n@@ -1122,8 +1122,8 @@ expq (__float128 x)\n       /* Compute tval1 = t.  */\n       tval1 = (int) (t * TWO8);\n \n-      x -= __expl_table[T_EXPL_ARG1+2*tval1];\n-      xl -= __expl_table[T_EXPL_ARG1+2*tval1+1];\n+      x -= __expq_table[T_EXPL_ARG1+2*tval1];\n+      xl -= __expq_table[T_EXPL_ARG1+2*tval1+1];\n \n       /* Calculate t/32768.  */\n       t = x + THREEp96;\n@@ -1132,14 +1132,14 @@ expq (__float128 x)\n       /* Compute tval2 = t.  */\n       tval2 = (int) (t * TWO15);\n \n-      x -= __expl_table[T_EXPL_ARG2+2*tval2];\n-      xl -= __expl_table[T_EXPL_ARG2+2*tval2+1];\n+      x -= __expq_table[T_EXPL_ARG2+2*tval2];\n+      xl -= __expq_table[T_EXPL_ARG2+2*tval2+1];\n \n       x = x + xl;\n \n       /* Compute ex2 = 2^n_0 e^(argtable[tval1]) e^(argtable[tval2]).  */\n-      ex2_u.value = __expl_table[T_EXPL_RES1 + tval1]\n-\t\t* __expl_table[T_EXPL_RES2 + tval2];\n+      ex2_u.value = __expq_table[T_EXPL_RES1 + tval1]\n+\t\t* __expq_table[T_EXPL_RES2 + tval2];\n       n_i = (int)n;\n       /* 'unsafe' is 1 iff n_1 != 0.  */\n       unsafe = abs(n_i) >= -FLT128_MIN_EXP - 1;"}, {"sha": "a103f840f38e67fd6462f2db3b80d7ec6799fb50", "filename": "libquadmath/math/fabsq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffabsq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffabsq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffabsq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_fabsl.c -- __float128 version of s_fabs.c.\n+/* fabsq.c -- __float128 version of s_fabs.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "c5326d2194ba1498a078d7627b434e1095538e03", "filename": "libquadmath/math/finiteq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffiniteq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffiniteq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffiniteq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_finitel.c -- long double version of s_finite.c.\n+/* finiteq.c -- __float128 version of s_finite.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "0d74f94e27d015d65bcfa702de0b41e07d65160c", "filename": "libquadmath/math/floorq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffloorq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffloorq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffloorq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_floorl.c -- long double version of s_floor.c.\n+/* floorq.c -- __float128 version of s_floor.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "5616c1a278176aa43580cb197c9748b8aa67457b", "filename": "libquadmath/math/fmaq.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffmaq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffmaq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffmaq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -228,6 +228,17 @@ fmaq (__float128 x, __float128 y, __float128 z)\n \t for proper rounding.  */\n       if (v.ieee.exponent == 226)\n \t{\n+         /* If the exponent would be in the normal range when\n+            rounding to normal precision with unbounded exponent\n+            range, the exact result is known and spurious underflows\n+            must be avoided on systems detecting tininess after\n+            rounding.  */\n+         if (TININESS_AFTER_ROUNDING)\n+           {\n+             w.value = a1 + u.value;\n+             if (w.ieee.exponent == 227)\n+               return w.value * 0x1p-226L;\n+           }\n \t  /* v.ieee.mant_low & 2 is LSB bit of the result before rounding,\n \t     v.ieee.mant_low & 1 is the round bit and j is our sticky\n \t     bit. */"}, {"sha": "55eb18ffb0acc36b39c4f73f3caf392ff90590c7", "filename": "libquadmath/math/fmodq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffmodq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffmodq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffmodq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* e_fmodl.c -- long double version of e_fmod.c.\n+/* fmodq.c -- __float128 version of e_fmod.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n /*"}, {"sha": "b0b305af574082358992e0407047686e995286bc", "filename": "libquadmath/math/frexpq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffrexpq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ffrexpq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ffrexpq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_frexpl.c -- long double version of s_frexp.c.\n+/* frexpq.c -- __float128 version of s_frexp.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "7f95e9c22400e62f80236e723f3bd29c3e37c415", "filename": "libquadmath/math/ilogbq.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Filogbq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Filogbq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Filogbq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_ilogbl.c -- long double version of s_ilogb.c.\n+/* ilogbq.c -- __float128 version of s_ilogb.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n \n@@ -17,7 +17,7 @@\n static char rcsid[] = \"$NetBSD: $\";\n #endif\n \n-/* ilogbl(long double x)\n+/* ilogbl(__float128 x)\n  * return the binary exponent of non-zero x\n  * ilogbl(0) = FP_ILOGB0\n  * ilogbl(NaN) = FP_ILOGBNAN (no signal is raised)\n@@ -26,6 +26,7 @@ static char rcsid[] = \"$NetBSD: $\";\n \n #include <limits.h>\n #include <math.h>\n+#include <errno.h>\n #include \"quadmath-imp.h\"\n \n #ifndef FP_ILOGB0\n@@ -45,7 +46,13 @@ ilogbq (__float128 x)\n \thx &= 0x7fffffffffffffffLL;\n \tif(hx <= 0x0001000000000000LL) {\n \t    if((hx|lx)==0)\n+\t      {\n+\t\terrno = EDOM;\n+#ifdef USE_FENV_H\n+\t\tferaiseexcept (FE_INVALID);\n+#endif\n \t\treturn FP_ILOGB0;\t/* ilogbl(0) = FP_ILOGB0 */\n+\t      }\n \t    else\t\t\t/* subnormal x */\n \t\tif(hx==0) {\n \t\t    for (ix = -16431; lx>0; lx<<=1) ix -=1;\n@@ -58,7 +65,18 @@ ilogbq (__float128 x)\n \telse if (FP_ILOGBNAN != INT_MAX) {\n \t    /* ISO C99 requires ilogbl(+-Inf) == INT_MAX.  */\n \t    if (((hx^0x7fff000000000000LL)|lx) == 0)\n+\t      {\n+\t\terrno = EDOM;\n+#ifdef USE_FENV_H\n+\t\tferaiseexcept (FE_INVALID);\n+#endif\n \t\treturn INT_MAX;\n+\t      }\n \t}\n+\n+\terrno = EDOM;\n+#ifdef USE_FENV_H\n+\tferaiseexcept (FE_INVALID);\n+#endif\n \treturn FP_ILOGBNAN;\n }"}, {"sha": "2f0834361c5f9d4bb5ba92c229bf2fd8e1e95576", "filename": "libquadmath/math/isinf_nsq.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fisinf_nsq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fisinf_nsq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fisinf_nsq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,19 @@\n+/*\n+ * Written by Ulrich Drepper <drepper@gmail.com>\n+ */\n+\n+/*\n+ * __quadmath_isinf_nsq (x) returns != 0 if x is \u00b1inf, else 0;\n+ * no branching!\n+ */\n+\n+#include \"quadmath-imp.h\"\n+\n+int\n+__quadmath_isinf_nsq (__float128 x)\n+{\n+        int64_t hx,lx;\n+        GET_FLT128_WORDS64(hx,lx,x);\n+        return !(lx | ((hx & 0x7fffffffffffffffLL) ^ 0x7fff000000000000LL));\n+}\n+"}, {"sha": "4462d0139e0406ec92ac41d98a01c86ef9202806", "filename": "libquadmath/math/isnanq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fisnanq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fisnanq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fisnanq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_isnanl.c -- long double version of s_isnan.c.\n+/* isnanq.c -- __float128 version of s_isnan.c.\n  * Conversion to long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "3ef9201a8a42407aeafdd360c925a42010827673", "filename": "libquadmath/math/j0q.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fj0q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fj0q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fj0q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -6,7 +6,7 @@\n  *\n  * SYNOPSIS:\n  *\n- * long double x, y, j0l();\n+ * __float128 x, y, j0l();\n  *\n  * y = j0l( x );\n  *\n@@ -52,7 +52,7 @@\n  *\n  * SYNOPSIS:\n  *\n- * double x, y, y0l();\n+ * __float128 x, y, y0l();\n  *\n  * y = y0l( x );\n  *"}, {"sha": "8a18e2779b2b79c77ed1098523e66002a88156a1", "filename": "libquadmath/math/j1q.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fj1q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fj1q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fj1q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -6,9 +6,9 @@\n  *\n  * SYNOPSIS:\n  *\n- * long double x, y, j1l();\n+ * __float128 x, y, j1q();\n  *\n- * y = j1l( x );\n+ * y = j1q( x );\n  *\n  *\n  *\n@@ -52,9 +52,9 @@\n  *\n  * SYNOPSIS:\n  *\n- * double x, y, y1l();\n+ * __float128, y, y1q();\n  *\n- * y = y1l( x );\n+ * y = y1q( x );\n  *\n  *\n  *"}, {"sha": "c18968b03bc3e740465104ced48be83e94340df0", "filename": "libquadmath/math/ldexpq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fldexpq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fldexpq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fldexpq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_ldexpl.c -- long double version of s_ldexp.c.\n+/* ldexpq.c -- __float128 version of s_ldexp.c.\n  * Conversion to long double by Ulrich Drepper,\n  * Cygnus Support, drepper@cygnus.com.\n  */"}, {"sha": "361f7037bc3cf69e9a7cfcfce08ea8462f61725d", "filename": "libquadmath/math/lgammaq.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flgammaq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flgammaq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Flgammaq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -18,7 +18,7 @@\n  * Returns the base e (2.718...) logarithm of the absolute\n  * value of the gamma function of the argument.\n  * The sign (+1 or -1) of the gamma function is returned in a\n- * global (extern) variable named sgngam.\n+ * global (extern) variable named signgam.\n  *\n  * The positive domain is partitioned into numerous segments for approximation.\n  * For x > 10,\n@@ -69,6 +69,7 @@\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n #include \"quadmath-imp.h\"\n+#include <math.h>  /* For extern int signgam.  */\n \n static const __float128 PIQ = 3.1415926535897932384626433832795028841972E0Q;\n static const __float128 MAXLGM = 1.0485738685148938358098967157129705071571E4928Q;\n@@ -757,19 +758,20 @@ __float128\n lgammaq (__float128 x)\n {\n   __float128 p, q, w, z, nx;\n-  int i, nn, sign;\n-\n-  sign = 1;\n+  int i, nn;\n+  int sign;\n \n   if (! finiteq (x))\n     return x * x;\n \n   if (x == 0.0Q)\n     {\n       if (signbitq (x))\n-        sign = -1;\n+\tsign = -1;\n     }\n \n+  signgam = sign;\n+\n   if (x < 0.0Q)\n     {\n       q = -x;\n@@ -788,6 +790,8 @@ lgammaq (__float128 x)\n \t  z = p - q;\n \t}\n       z = q * sinq (PIQ * z);\n+      signgam = sign;\n+\n       if (z == 0.0Q)\n \treturn (sign * huge * huge);\n       w = lgammaq (q);\n@@ -855,7 +859,7 @@ lgammaq (__float128 x)\n \t\t{\n \t\t  z = x - 0.75Q;\n \t\t  p = z * neval (z, RN1r75, NRN1r75)\n-\t\t        / deval (z, RD1r75, NRD1r75);\n+\t\t\t/ deval (z, RD1r75, NRD1r75);\n \t\t  p += lgam1r75b;\n \t\t  p += lgam1r75a;\n \t\t}"}, {"sha": "d22180d6bbad03ef3f25c638df8b4ff5f75e2467", "filename": "libquadmath/math/llroundq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fllroundq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fllroundq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fllroundq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* Round long double value to long long int.\n+/* Round __float128 value to long long int.\n    Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and"}, {"sha": "9eeb9ae3fc4ffa4a41aa9c0a0b3666b5132dfe10", "filename": "libquadmath/math/log10q.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flog10q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flog10q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Flog10q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,14 +1,14 @@\n-/*\t\t\t\t\t\t\tlog10l.c\n+/*\t\t\t\t\t\t\tlog10q.c\n  *\n- *\tCommon logarithm, 128-bit long double precision\n+ *\tCommon logarithm, 128-bit __float128 precision\n  *\n  *\n  *\n  * SYNOPSIS:\n  *\n- * long double x, y, log10l();\n+ * __float128 x, y, log10l();\n  *\n- * y = log10l( x );\n+ * y = log10q( x );\n  *\n  *\n  *"}, {"sha": "2de13fe2adcc94067db062505c0d7ce29492496d", "filename": "libquadmath/math/log1pq.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flog1pq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flog1pq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Flog1pq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,15 +1,15 @@\n /*\t\t\t\t\t\t\tlog1pl.c\n  *\n  *      Relative error logarithm\n- *\tNatural logarithm of 1+x, 128-bit long double precision\n+ *\tNatural logarithm of 1+x for __float128 precision\n  *\n  *\n  *\n  * SYNOPSIS:\n  *\n- * long double x, y, log1pl();\n+ * __float128 x, y, log1pl();\n  *\n- * y = log1pl( x );\n+ * y = log1pq( x );\n  *\n  *\n  *"}, {"sha": "f8275369b37a9a4a1dd5c30455a0637665752dea", "filename": "libquadmath/math/log2q.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flog2q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flog2q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Flog2q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,13 +1,13 @@\n-/*                                                      log2l.c\n- *      Base 2 logarithm, 128-bit long double precision\n+/*                                                      log2q.c\n+ *      Base 2 logarithm for __float128 precision\n  *\n  *\n  *\n  * SYNOPSIS:\n  *\n- * long double x, y, log2l();\n+ * __float128 x, y, log2q();\n  *\n- * y = log2l( x );\n+ * y = log2q( x );\n  *\n  *\n  *"}, {"sha": "7aae9b101ad76fafac6189a7206de94d931415dd", "filename": "libquadmath/math/logq.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flogq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flogq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Flogq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,14 +1,14 @@\n-/*\t\t\t\t\t\t\tlogll.c\n+/*\t\t\t\t\t\t\tlogq.c\n  *\n- * Natural logarithm for 128-bit long double precision.\n+ * Natural logarithm for __float128 precision.\n  *\n  *\n  *\n  * SYNOPSIS:\n  *\n- * long double x, y, logl();\n+ * __float128 x, y, logq();\n  *\n- * y = logl( x );\n+ * y = logq( x );\n  *\n  *\n  *"}, {"sha": "59c883a1464d8e39efd90421cd55badad16dfdcf", "filename": "libquadmath/math/lroundq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flroundq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Flroundq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Flroundq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* Round long double value to long int.\n+/* Round __float128 value to long int.\n    Copyright (C) 1997, 1999, 2004 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and"}, {"sha": "8c5db54bb760204db90a446c55a2147afb2459b1", "filename": "libquadmath/math/modfq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fmodfq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fmodfq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fmodfq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_modfl.c -- long double version of s_modf.c.\n+/* modfq.c -- __float128 version of s_modf.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "04d63deb8e22d335b7d2baee7f6c35bf2fc983cf", "filename": "libquadmath/math/nextafterq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fnextafterq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fnextafterq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fnextafterq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_nextafterl.c -- long double version of s_nextafter.c.\n+/* nextafterq.c -- __float128 version of s_nextafter.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "12b87d536d7250660f8b7b12f58094b9ed1918fb", "filename": "libquadmath/math/powq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fpowq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fpowq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fpowq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -30,7 +30,7 @@\n     License along with this library; if not, write to the Free Software\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n-/* __ieee754_powl(x,y) return x**y\n+/* powq(x,y) return x**y\n  *\n  *\t\t      n\n  * Method:  Let x =  2   * (1+f)"}, {"sha": "60653c8d1d3e850a275eb82162820458bd48d393", "filename": "libquadmath/math/rem_pio2q.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Frem_pio2q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Frem_pio2q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Frem_pio2q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -15,10 +15,10 @@\n  */\n \n /*\n- * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n+ * __quadmath_kernel_rem_pio2 (x,y,e0,nx,prec,ipio2)\n  * double x[],y[]; int e0,nx,prec; int ipio2[];\n  *\n- * __kernel_rem_pio2 return the last three digits of N with\n+ * __quadmath_kernel_rem_pio2  return the last three digits of N with\n  *\t\ty = x - N*pi/2\n  * so that |y| < pi/2.\n  *"}, {"sha": "c3f5641293f95c0a49b7a331779d830bbb58b4f2", "filename": "libquadmath/math/remainderq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fremainderq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fremainderq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fremainderq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* e_fmodl.c -- long double version of e_fmod.c.\n+/* fmodq.c -- __float128 version of e_fmod.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n /*"}, {"sha": "4a50503721c4711cf174b4350d2c9013ed1d5326", "filename": "libquadmath/math/rintq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Frintq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Frintq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Frintq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_rintl.c -- long double version of s_rint.c.\n+/* rintq.c -- __float128 version of s_rint.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n "}, {"sha": "7c9d640e933291fe21801f550c7244b666601b69", "filename": "libquadmath/math/roundq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Froundq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Froundq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Froundq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* Round long double to integer away from zero.\n+/* Round __float128 to integer away from zero.\n    Copyright (C) 1997, 1999 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and"}, {"sha": "a414045b51f84fb61aa0c49bfc5a59f96a3ec246", "filename": "libquadmath/math/scalblnq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fscalblnq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fscalblnq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fscalblnq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_scalblnl.c -- long double version of s_scalbn.c.\n+/* scalblnq.c -- __float128 version of s_scalbn.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n    "}, {"sha": "9975a47154c047f767193e2f56866dd2399c066a", "filename": "libquadmath/math/scalbnq.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fscalbnq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fscalbnq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fscalbnq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_scalbnl.c -- long double version of s_scalbn.c.\n+/* scalbnq.c -- __float128 version of s_scalbn.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n    "}, {"sha": "f6341a4d9487afbf64ea834a44bd3ca203d31bf3", "filename": "libquadmath/math/sincosq_kernel.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsincosq_kernel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsincosq_kernel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fsincosq_kernel.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -126,14 +126,18 @@ __quadmath_kernel_sincosq(__float128 x, __float128 y, __float128 *sinx,\n     {\n       /* So that we don't have to use too large polynomial,  we find\n \t l and h such that x = l + h,  where fabsl(l) <= 1.0/256 with 83\n-\t possible values for h.  We look up cosl(h) and sinl(h) in\n-\t pre-computed tables,  compute cosl(l) and sinl(l) using a\n+\t possible values for h.  We look up cosq(h) and sinq(h) in\n+\t pre-computed tables,  compute cosq(l) and sinq(l) using a\n \t Chebyshev polynomial of degree 10(11) and compute\n-\t sinl(h+l) = sinl(h)cosl(l) + cosl(h)sinl(l) and\n-\t cosl(h+l) = cosl(h)cosl(l) - sinl(h)sinl(l).  */\n+\t sinq(h+l) = sinq(h)cosq(l) + cosq(h)sinq(l) and\n+\t cosq(h+l) = cosq(h)cosq(l) - sinq(h)sinq(l).  */\n       index = 0x3ffe - (tix >> 16);\n       hix = (tix + (0x200 << index)) & (0xfffffc00 << index);\n-      x = fabsq (x);\n+      if (signbitq (x))\n+       {\n+         x = -x;\n+         y = -y;\n+       }\n       switch (index)\n \t{\n \tcase 0: index = ((45 << 10) + hix - 0x3ffe0000) >> 8; break;"}, {"sha": "eff8149b515ce22b21e5d1c630904be0af8e6933", "filename": "libquadmath/math/sinhq.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsinhq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsinhq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fsinhq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* e_sinhl.c -- __float128 version of e_sinh.c.\n+/* sinhq.c -- __float128 version of e_sinh.c.\n  * Conversion to __float128 by Ulrich Drepper,\n  * Cygnus Support, drepper@cygnus.com.\n  */\n@@ -35,22 +35,22 @@\n     License along with this library; if not, write to the Free Software\n     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA */\n \n-/* __ieee754_sinhl(x)\n+/* sinhq(x)\n  * Method :\n  * mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2\n- *      1. Replace x by |x| (sinhl(-x) = -sinhl(x)).\n+ *      1. Replace x by |x| (sinhq(-x) = -sinhq(x)).\n  *      2.\n  *                                                   E + E/(E+1)\n- *          0        <= x <= 25     :  sinhl(x) := --------------, E=expm1l(x)\n+ *          0        <= x <= 25     :  sinhq(x) := --------------, E=expm1q(x)\n  *                                                       2\n  *\n- *          25       <= x <= lnovft :  sinhl(x) := expl(x)/2\n- *          lnovft   <= x <= ln2ovft:  sinhl(x) := expl(x/2)/2 * expl(x/2)\n- *          ln2ovft  <  x           :  sinhl(x) := x*shuge (overflow)\n+ *          25       <= x <= lnovft :  sinhq(x) := expq(x)/2\n+ *          lnovft   <= x <= ln2ovft:  sinhq(x) := expq(x/2)/2 * expq(x/2)\n+ *          ln2ovft  <  x           :  sinhq(x) := x*shuge (overflow)\n  *\n  * Special cases:\n- *      sinhl(x) is |x| if x is +INF, -INF, or NaN.\n- *      only sinhl(0)=0 is exact for finite x.\n+ *      sinhq(x) is |x| if x is +INF, -INF, or NaN.\n+ *      only sinhq(0)=0 is exact for finite x.\n  */\n \n #include \"quadmath-imp.h\"\n@@ -106,6 +106,6 @@ sinhq (__float128 x)\n       return t * w;\n     }\n \n-  /* |x| > overflowthreshold, sinhl(x) overflow */\n+  /* |x| > overflowthreshold, sinhq(x) overflow */\n   return x * shuge;\n }"}, {"sha": "989f679d6d6ecf83467f365c97ae3f8af2bc5239", "filename": "libquadmath/math/sinq.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsinq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsinq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fsinq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -1,4 +1,4 @@\n-/* s_sinl.c -- long double version of s_sin.c.\n+/* sinq.c -- __float128 version of s_sin.c.\n  * Conversion to long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n \n@@ -13,13 +13,13 @@\n  * ====================================================\n  */\n \n-/* sinl(x)\n+/* sinq(x)\n  * Return sine function of x.\n  *\n  * kernel function:\n- *\t__kernel_sinl\t\t... sine function on [-pi/4,pi/4]\n- *\t__kernel_cosl\t\t... cose function on [-pi/4,pi/4]\n- *\t__ieee754_rem_pio2l\t... argument reduction routine\n+ *\t__quadmath_kernel_sinq\t... sine function on [-pi/4,pi/4]\n+ *\t__quadmath_kernel_cosq\t... cose function on [-pi/4,pi/4]\n+ *\t__quadmath_rem_pio2q\t... argument reduction routine\n  *\n  * Method.\n  *      Let S,C and T denote the sin, cos and tan respectively on"}, {"sha": "86034551d43e51d746ac3a8b4dffc58884cd2b09", "filename": "libquadmath/math/sinq_kernel.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsinq_kernel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fsinq_kernel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fsinq_kernel.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -99,10 +99,10 @@ __quadmath_kernel_sinq (__float128 x, __float128 y, int iy)\n     {\n       /* So that we don't have to use too large polynomial,  we find\n \t l and h such that x = l + h,  where fabsl(l) <= 1.0/256 with 83\n-\t possible values for h.  We look up cosl(h) and sinl(h) in\n-\t pre-computed tables,  compute cosl(l) and sinl(l) using a\n+\t possible values for h.  We look up cosq(h) and sinq(h) in\n+\t pre-computed tables,  compute cosq(l) and sinq(l) using a\n \t Chebyshev polynomial of degree 10(11) and compute\n-\t sinl(h+l) = sinl(h)cosl(l) + cosl(h)sinl(l).  */\n+\t sinq(h+l) = sinq(h)cosq(l) + cosq(h)sinq(l).  */\n       index = 0x3ffe - (tix >> 16);\n       hix = (tix + (0x200 << index)) & (0xfffffc00 << index);\n       x = fabsq (x);\n@@ -116,7 +116,7 @@ __quadmath_kernel_sinq (__float128 x, __float128 y, int iy)\n \n       SET_FLT128_WORDS64(h, ((uint64_t)hix) << 32, 0);\n       if (iy)\n-\tl = y - (h - x);\n+\tl = (ix < 0 ? -y : y) - (h - x);\n       else\n \tl = x - h;\n       z = l * l;"}, {"sha": "690d94b782c968ef14e51d59fdb2b528774c20f0", "filename": "libquadmath/math/tanq.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ftanq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ftanq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ftanq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -160,7 +160,7 @@ __quadmath_kernel_tanq (__float128 x, __float128 y, int iy)\n \n \n \n-/* s_tanl.c -- long double version of s_tan.c.\n+/* tanq.c -- __float128 version of s_tan.c.\n  * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.\n  */\n   \n@@ -180,8 +180,8 @@ __quadmath_kernel_tanq (__float128 x, __float128 y, int iy)\n  * Return tangent function of x.\n  *\n  * kernel function:\n- *\t__kernel_tanq\t\t... tangent function on [-pi/4,pi/4]\n- *\t__ieee754_rem_pio2q\t... argument reduction routine\n+ *\t__quadmath_kernel_tanq\t... tangent function on [-pi/4,pi/4]\n+ *\t__quadmath_rem_pio2q\t... argument reduction routine\n  *\n  * Method.\n  *      Let S,C and T denote the sin, cos and tan respectively on"}, {"sha": "a07d5831de03c34c88e9eb00568e38dfe9470e5f", "filename": "libquadmath/math/tgammaq.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ftgammaq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Ftgammaq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Ftgammaq.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -30,6 +30,8 @@ tgammaq (__float128 x)\n      conditions we must check some values separately.  */\n   int64_t hx;\n   uint64_t lx;\n+  __float128 res;\n+  int sign;\n \n   GET_FLT128_WORDS64 (hx, lx, x);\n \n@@ -46,5 +48,6 @@ tgammaq (__float128 x)\n     return x - x;\n \n   /* XXX FIXME.  */\n-  return expq (lgammaq (x));\n+  res = expq (lgammaq (x));\n+  return signbitq (x) ? -res : res;\n }"}, {"sha": "90bbc2f605d46ffc5475c5d1ab6dfba9463b9aa0", "filename": "libquadmath/math/x2y2m1q.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fx2y2m1q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fmath%2Fx2y2m1q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fmath%2Fx2y2m1q.c?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -0,0 +1,93 @@\n+/* Compute x^2 + y^2 - 1, without large cancellation error.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"quadmath-imp.h\"\n+#include <stdlib.h>\n+\n+/* Calculate X + Y exactly and store the result in *HI + *LO.  It is\n+   given that |X| >= |Y| and the values are small enough that no\n+   overflow occurs.  */\n+\n+static inline void\n+add_split (__float128 *hi, __float128 *lo, __float128 x, __float128 y)\n+{\n+  /* Apply Dekker's algorithm.  */\n+  *hi = x + y;\n+  *lo = (x - *hi) + y;\n+}\n+\n+/* Calculate X * Y exactly and store the result in *HI + *LO.  It is\n+   given that the values are small enough that no overflow occurs and\n+   large enough (or zero) that no underflow occurs.  */\n+\n+static inline void\n+mul_split (__float128 *hi, __float128 *lo, __float128 x, __float128 y)\n+{\n+  /* Fast built-in fused multiply-add.  */\n+  *hi = x * y;\n+  *lo = fmaq (x, y, -*hi);\n+}\n+\n+/* Compare absolute values of floating-point values pointed to by P\n+   and Q for qsort.  */\n+\n+static int\n+compare (const void *p, const void *q)\n+{\n+  __float128 pld = fabsq (*(const __float128 *) p);\n+  __float128 qld = fabsq (*(const __float128 *) q);\n+  if (pld < qld)\n+    return -1;\n+  else if (pld == qld)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+/* Return X^2 + Y^2 - 1, computed without large cancellation error.\n+   It is given that 1 > X >= Y >= epsilon / 2, and that either X >=\n+   0.75 or Y >= 0.5.  */\n+\n+__float128\n+__quadmath_x2y2m1q (__float128 x, __float128 y)\n+{\n+  __float128 vals[4];\n+  size_t i;\n+\n+  /* FIXME:  SET_RESTORE_ROUNDL (FE_TONEAREST);  */\n+  mul_split (&vals[1], &vals[0], x, x);\n+  mul_split (&vals[3], &vals[2], y, y);\n+  if (x >= 0.75Q)\n+    vals[1] -= 1.0Q;\n+  else\n+    {\n+      vals[1] -= 0.5Q;\n+      vals[3] -= 0.5Q;\n+    }\n+  qsort (vals, 4, sizeof (__float128), compare);\n+  /* Add up the values so that each element of VALS has absolute value\n+     at most equal to the last set bit of the next nonzero\n+     element.  */\n+  for (i = 0; i <= 2; i++)\n+    {\n+      add_split (&vals[i + 1], &vals[i], vals[i + 1], vals[i]);\n+      qsort (vals + i + 1, 3 - i, sizeof (__float128), compare);\n+    }\n+  /* Now any error from this addition will be small.  */\n+  return vals[3] + vals[2] + vals[1] + vals[0];\n+}"}, {"sha": "40b346b6ff22bd4028d0931f5b8ea576b4d57eda", "filename": "libquadmath/quadmath-imp.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fquadmath-imp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f029f4be17d5b897de8abc53d76cf6c2a6239dde/libquadmath%2Fquadmath-imp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fquadmath-imp.h?ref=f029f4be17d5b897de8abc53d76cf6c2a6239dde", "patch": "@@ -27,12 +27,26 @@ Boston, MA 02110-1301, USA.  */\n #include \"config.h\"\n \n \n+/* Under IEEE 754, an architecture may determine tininess of\n+   floating-point results either \"before rounding\" or \"after\n+   rounding\", but must do so in the same way for all operations\n+   returning binary results.  Define TININESS_AFTER_ROUNDING to 1 for\n+   \"after rounding\" architectures, 0 for \"before rounding\"\n+   architectures.  */\n+\n+#define TININESS_AFTER_ROUNDING   1\n+\n+\n /* Prototypes for internal functions.  */\n extern int32_t __quadmath_rem_pio2q (__float128, __float128 *);\n extern void __quadmath_kernel_sincosq (__float128, __float128, __float128 *,\n \t\t\t\t       __float128 *, int);\n extern __float128 __quadmath_kernel_sinq (__float128, __float128, int);\n extern __float128 __quadmath_kernel_cosq (__float128, __float128);\n+extern __float128 __quadmath_x2y2m1q (__float128 x, __float128 y);\n+extern int __quadmath_isinf_nsq (__float128 x);\n+\n+\n \n \n "}]}