{"sha": "b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNkNDAxMWJhMTAyNzVmYmQ1ZDZlYzVhMTZkNWFhZWJiZGZiNWQzYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-07-21T07:36:48Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-07-21T07:36:48Z"}, "message": "Fortran: Fix bind(C) character length checks\n\ngcc/fortran/ChangeLog:\n\n\t* decl.c (gfc_verify_c_interop_param): Update for F2008 + F2018\n\tchanges; reject unsupported bits with 'Error: Sorry,'.\n\t* trans-expr.c (gfc_conv_procedure_call): Fix condition to\n\tFor using CFI descriptor with characters.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/iso_c_binding_char_1.f90: Update dg-error.\n\t* gfortran.dg/pr32599.f03: Use -std=-f2003 + update comment.\n\t* gfortran.dg/bind_c_char_10.f90: New test.\n\t* gfortran.dg/bind_c_char_6.f90: New test.\n\t* gfortran.dg/bind_c_char_7.f90: New test.\n\t* gfortran.dg/bind_c_char_8.f90: New test.\n\t* gfortran.dg/bind_c_char_9.f90: New test.", "tree": {"sha": "2375d0a9b7f7eae0d79a2f95934f1a0edfb83b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2375d0a9b7f7eae0d79a2f95934f1a0edfb83b75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957952ce64e067c56e58df5ee36bbb004eecffa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957952ce64e067c56e58df5ee36bbb004eecffa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/957952ce64e067c56e58df5ee36bbb004eecffa1"}], "stats": {"total": 1581, "additions": 1557, "deletions": 24}, "files": [{"sha": "05081c40f1e48e7fd78e9a58538636b67fdd8024", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 104, "deletions": 9, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -1552,20 +1552,115 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t    }\n \n           /* Character strings are only C interoperable if they have a\n-             length of 1.  */\n-          if (sym->ts.type == BT_CHARACTER && !sym->attr.dimension)\n+\t     length of 1.  However, as argument they are either iteroperable\n+\t     when passed as descriptor (which requires len=: or len=*) or\n+\t     when having a constant length or are always passed by\n+\t     descriptor.  */\n+\t  if (sym->ts.type == BT_CHARACTER)\n \t    {\n \t      gfc_charlen *cl = sym->ts.u.cl;\n-\t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT\n-                  || mpz_cmp_si (cl->length->value.integer, 1) != 0)\n+\n+\t      if (sym->attr.allocatable || sym->attr.pointer)\n \t\t{\n-\t\t  gfc_error (\"Character argument %qs at %L \"\n-\t\t\t     \"must be length 1 because \"\n-\t\t\t     \"procedure %qs is BIND(C)\",\n-\t\t\t     sym->name, &sym->declared_at,\n-\t\t\t     sym->ns->proc_name->name);\n+\t\t  /* F2018, 18.3.6 (6).  */\n+\t\t  if (!sym->ts.deferred)\n+\t\t    {\n+\t\t      if (sym->attr.allocatable)\n+\t\t\tgfc_error (\"Allocatable character dummy argument %qs \"\n+\t\t\t\t   \"at %L must have deferred length as \"\n+\t\t\t\t   \"procedure %qs is BIND(C)\", sym->name,\n+\t\t\t\t   &sym->declared_at, sym->ns->proc_name->name);\n+\t\t      else\n+\t\t\tgfc_error (\"Pointer character dummy argument %qs at %L \"\n+\t\t\t\t   \"must have deferred length as procedure %qs \"\n+\t\t\t\t   \"is BIND(C)\", sym->name, &sym->declared_at,\n+\t\t\t\t   sym->ns->proc_name->name);\n+\t\t      retval = false;\n+\t\t    }\n+\t\t  else if (!gfc_notify_std (GFC_STD_F2018,\n+\t\t\t\t\t    \"Deferred-length character dummy \"\n+\t\t\t\t\t    \"argument %qs at %L of procedure \"\n+\t\t\t\t\t    \"%qs with BIND(C) attribute\",\n+\t\t\t\t\t    sym->name, &sym->declared_at,\n+\t\t\t\t\t    sym->ns->proc_name->name))\n+\t\t    retval = false;\n+\t\t  else if (!sym->attr.dimension)\n+\t\t    {\n+\t\t      /* FIXME: Use CFI array descriptor for scalars.  */\n+\t\t      gfc_error (\"Sorry, deferred-length scalar character dummy \"\n+\t\t\t\t \"argument %qs at %L of procedure %qs with \"\n+\t\t\t\t \"BIND(C) not yet supported\", sym->name,\n+\t\t\t\t &sym->declared_at, sym->ns->proc_name->name);\n+\t\t      retval = false;\n+\t\t    }\n+\t\t}\n+\t      else if (sym->attr.value\n+\t\t       && (!cl || !cl->length\n+\t\t\t   || cl->length->expr_type != EXPR_CONSTANT\n+\t\t\t   || mpz_cmp_si (cl->length->value.integer, 1) != 0))\n+\t\t{\n+\t\t  gfc_error (\"Character dummy argument %qs at %L must be \"\n+\t\t\t     \"of length 1 as it has the VALUE attribute\",\n+\t\t\t     sym->name, &sym->declared_at);\n \t\t  retval = false;\n \t\t}\n+\t      else if (!cl || !cl->length)\n+\t\t{\n+\t\t  /* Assumed length; F2018, 18.3.6 (5)(2).\n+\t\t     Uses the CFI array descriptor.  */\n+\t\t  if (!gfc_notify_std (GFC_STD_F2018,\n+\t\t\t\t      \"Assumed-length character dummy argument \"\n+\t\t\t\t      \"%qs at %L of procedure %qs with BIND(C) \"\n+\t\t\t\t      \"attribute\", sym->name, &sym->declared_at,\n+\t\t\t\t      sym->ns->proc_name->name))\n+\t\t    retval = false;\n+\t\t  else if (!sym->attr.dimension\n+\t\t\t   || sym->as->type == AS_ASSUMED_SIZE\n+\t\t\t   || sym->as->type == AS_EXPLICIT)\n+\t\t    {\n+\t\t      /* FIXME: Valid - should use the CFI array descriptor, but\n+\t\t\t not yet handled for scalars and assumed-/explicit-size\n+\t\t\t arrays.  */\n+\t\t      gfc_error (\"Sorry, character dummy argument %qs at %L \"\n+\t\t\t\t \"with assumed length is not yet supported for \"\n+\t\t\t\t \"procedure %qs with BIND(C) attribute\",\n+\t\t\t\t sym->name, &sym->declared_at,\n+\t\t\t\t sym->ns->proc_name->name);\n+\t\t      retval = false;\n+\t\t    }\n+\t\t}\n+\t      else if (cl->length->expr_type != EXPR_CONSTANT)\n+\t\t{\n+\t\t  /* F2018, 18.3.6, (5), item 4.  */\n+\t\t  if (!sym->attr.dimension\n+\t\t      || sym->as->type == AS_ASSUMED_SIZE\n+\t\t      || sym->as->type == AS_EXPLICIT)\n+\t\t    {\n+\t\t      gfc_error (\"Character dummy argument %qs at %L must be \"\n+\t\t\t\t \"of constant length or assumed length, \"\n+\t\t\t\t \"unless it has assumed shape or assumed rank, \"\n+\t\t\t\t \"as procedure %qs has the BIND(C) attribute\",\n+\t\t\t\t sym->name, &sym->declared_at,\n+\t\t\t\t sym->ns->proc_name->name);\n+\t\t      retval = false;\n+\t\t    }\n+\t\t  else if (!gfc_notify_std (GFC_STD_F2018,\n+\t\t\t\t\t    \"Character dummy argument %qs at \"\n+\t\t\t\t\t    \"%L with nonconstant length as \"\n+\t\t\t\t\t    \"procedure %qs is BIND(C)\",\n+\t\t\t\t\t    sym->name, &sym->declared_at,\n+\t\t\t\t\t    sym->ns->proc_name->name))\n+\t\t    retval = false;\n+\t\t}\n+\t     else if (mpz_cmp_si (cl->length->value.integer, 1) != 0\n+\t\t      && !gfc_notify_std (GFC_STD_F2008,\n+\t\t\t\t\t  \"Character dummy argument %qs at %L \"\n+\t\t\t\t\t  \"with length greater than 1 for \"\n+\t\t\t\t\t  \"procedure %qs with BIND(C) \"\n+\t\t\t\t\t  \"attribute\",\n+\t\t\t\t\t  sym->name, &sym->declared_at,\n+\t\t\t\t\t  sym->ns->proc_name->name))\n+\t       retval = false;\n \t    }\n \n \t  /* We have to make sure that any param to a bind(c) routine does"}, {"sha": "b18a9ec9799853e69447b52d5e1efec5d85dee53", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -5757,18 +5757,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n        arg = arg->next, formal = formal ? formal->next : NULL, ++argc)\n     {\n       bool finalized = false;\n-      bool non_unity_length_string = false;\n+      bool assumed_length_string = false;\n       tree derived_array = NULL_TREE;\n \n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n \n-      if (fsym && fsym->ts.type == BT_CHARACTER && fsym->ts.u.cl\n-\t  && (!fsym->ts.u.cl->length\n-\t      || fsym->ts.u.cl->length->expr_type != EXPR_CONSTANT\n-\t      || mpz_cmp_si (fsym->ts.u.cl->length->value.integer, 1) != 0))\n-\tnon_unity_length_string = true;\n+      if (fsym && fsym->ts.type == BT_CHARACTER\n+\t  && (!fsym->ts.u.cl || !fsym->ts.u.cl->length))\n+\tassumed_length_string = true;\n \n       /* If the procedure requires an explicit interface, the actual\n \t argument is passed according to the corresponding formal\n@@ -6002,8 +6000,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t      else if (sym->attr.is_bind_c && e\n \t\t       && (is_CFI_desc (fsym, NULL)\n-\t\t\t   || non_unity_length_string))\n-\t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n+\t\t\t   || assumed_length_string))\n+\t\t/* Implement F2018, 18.3.6, list item (5), bullet point 2.  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n \n \t      else if (fsym && fsym->attr.value)\n@@ -6447,8 +6445,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \n \t      if (sym->attr.is_bind_c && e\n-\t\t  && (is_CFI_desc (fsym, NULL) || non_unity_length_string))\n-\t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n+\t\t  && (is_CFI_desc (fsym, NULL) || assumed_length_string))\n+\t\t/* Implement F2018, 18.3.6, list item (5), bullet point 2.  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n \n \t      else if (e->expr_type == EXPR_VARIABLE"}, {"sha": "35958515d385d3e23de09349dbbc35e221992cce", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_10.f90", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_10.f90?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -0,0 +1,480 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+! F2018  - examples with array descriptor\n+\n+module m\n+  use iso_c_binding, only: c_char\n+  implicit none (type, external)\n+\n+contains\n+\n+! Assumed-shape array, nonallocatable/nonpointer\n+\n+subroutine as1 (x1) bind(C)\n+  character(kind=c_char, len=1) :: x1(:)\n+  if (size(x1) /= 6) stop\n+  if (len(x1) /= 1) stop  \n+  if (any (x1 /= ['g', &\n+                  'd', &\n+                  'f', &\n+                  's', &\n+                  '3', &\n+                  '5'])) stop 1\n+  x1 = ['1', &\n+        'h', &\n+        'f', &\n+        '3', &\n+        '4', &\n+        'h']\n+end\n+\n+subroutine as2 (x2) bind(C)\n+  character(kind=c_char, len=2) :: x2(:)\n+  if (size(x2) /= 6) stop\n+  if (len(x2) /= 2) stop  \n+  if (any (x2 /= ['ab', &\n+                  'fd', &\n+                  'D4', &\n+                  '54', &\n+                  'ga', &\n+                  'hg'])) stop\n+  x2 = ['ab', &\n+        'hd', &\n+        'fj', &\n+        'a4', &\n+        '4a', &\n+        'hf']\n+end\n+\n+subroutine as3 (xn, n) bind(C)\n+  integer :: n\n+  character(kind=c_char, len=n) :: xn(:)\n+  if (size(xn) /= 6) stop\n+  if (len(xn) /= 5) stop  \n+  if (any (xn /= ['DDGhf', &\n+                 'hdrh$', &\n+                 'fDGSl', &\n+                 'DFHs3', &\n+                 '43grG', &\n+                 'hFG$k'])) stop\n+  xn = ['FDGhf', &\n+       'hdrhg', &\n+       'fDgFl', &\n+       'DFHs3', &\n+       '4a54G', &\n+       'hSs6k']\n+end\n+\n+subroutine as4 (xstar) bind(C)\n+  character(kind=c_char, len=*) :: xstar(:)\n+  if (size(xstar) /= 6) stop\n+  if (len(xstar) /= 5) stop  \n+  if (any (xstar /= ['DDGhf', &\n+                     'hdrh$', &\n+                     'fDGSl', &\n+                     'DFHs3', &\n+                     '43grG', &\n+                     'hFG$k'])) stop\n+  xstar = ['FDGhf', &\n+           'hdrhg', &\n+           'fDgFl', &\n+           'DFHs3', &\n+           '4a54G', &\n+           'hSs6k']\n+end\n+\n+! Assumed-rank array, nonallocatable/nonpointer\n+\n+subroutine ar1 (x1) bind(C)\n+  character(kind=c_char, len=1) :: x1(..)\n+  if (size(x1) /= 6) stop\n+  if (len(x1) /= 1) stop  \n+  select rank(x1)\n+    rank(1)\n+      if (any (x1 /= ['g', &\n+                      'd', &\n+                      'f', &\n+                      's', &\n+                      '3', &\n+                      '5'])) stop\n+      x1 = ['1', &\n+            'h', &\n+            'f', &\n+            '3', &\n+            '4', &\n+            'h']\n+  rank default\n+    stop\n+  end select\n+end\n+\n+subroutine ar2 (x2) bind(C)\n+  character(kind=c_char, len=2) :: x2(..)\n+  if (size(x2) /= 6) stop\n+  if (len(x2) /= 2) stop  \n+  select rank(x2)\n+    rank(1)\n+      if (any (x2 /= ['ab', &\n+                      'fd', &\n+                      'D4', &\n+                      '54', &\n+                      'ga', &\n+                      'hg'])) stop\n+      x2 = ['ab', &\n+            'hd', &\n+            'fj', &\n+            'a4', &\n+            '4a', &\n+            'hf']\n+    rank default\n+      stop\n+  end select\n+end\n+\n+subroutine ar3 (xn, n) bind(C)\n+  integer :: n\n+  character(len=n) :: xn(..)\n+  if (size(xn) /= 6) stop\n+  if (len(xn) /= 5) stop  \n+  select rank(xn)\n+    rank(1)\n+      if (any (xn /= ['DDGhf', &\n+                      'hdrh$', &\n+                      'fDGSl', &\n+                      'DFHs3', &\n+                      '43grG', &\n+                      'hFG$k'])) stop\n+      xn = ['FDGhf', &\n+            'hdrhg', &\n+            'fDgFl', &\n+            'DFHs3', &\n+            '4a54G', &\n+            'hSs6k']\n+  rank default\n+    stop\n+  end select\n+end\n+\n+subroutine ar4 (xstar) bind(C)\n+  character(kind=c_char, len=*) :: xstar(..)\n+  if (size(xstar) /= 6) stop\n+  if (len(xstar) /= 5) stop  \n+  select rank(xstar)\n+    rank(1)\n+      if (any (xstar /= ['DDGhf', &\n+                         'hdrh$', &\n+                         'fDGSl', &\n+                         'DFHs3', &\n+                         '43grG', &\n+                         'hFG$k'])) stop\n+      xstar = ['FDGhf', &\n+               'hdrhg', &\n+               'fDgFl', &\n+               'DFHs3', &\n+               '4a54G', &\n+               'hSs6k']\n+  rank default\n+    stop\n+  end select\n+end\n+\n+! ALLOCATABLE\n+\n+! Assumed-shape array, allocatable\n+\n+subroutine a5a (xcolon) bind(C)\n+  character(kind=c_char, len=:), allocatable :: xcolon(:)\n+  if (.not. allocated (xcolon)) stop\n+  if (size(xcolon) /= 6) stop\n+  if (len(xcolon) /= 5) stop  \n+  if (any (xcolon /= ['DDGhf', &\n+                     'hdrh$', &\n+                     'fDGSl', &\n+                     'DFHs3', &\n+                     '43grG', &\n+                     'hFG$k'])) stop\n+  xcolon = ['FDGhf', &\n+           'hdrhg', &\n+           'fDgFl', &\n+           'DFHs3', &\n+           '4a54G', &\n+           'hSs6k']\n+end\n+\n+! Assumed-rank array, allocatable\n+\n+subroutine a5ar (xcolon) bind(C)\n+  character(kind=c_char, len=:), allocatable :: xcolon(..)\n+  if (.not. allocated (xcolon)) stop\n+  if (size(xcolon) /= 6) stop\n+  if (len(xcolon) /= 5) stop  \n+  select rank(xcolon)\n+    rank(1)\n+      if (any (xcolon /= ['DDGhf', &\n+                         'hdrh$', &\n+                         'fDGSl', &\n+                         'DFHs3', &\n+                         '43grG', &\n+                         'hFG$k'])) stop\n+      xcolon = ['FDGhf', &\n+               'hdrhg', &\n+               'fDgFl', &\n+               'DFHs3', &\n+               '4a54G', &\n+               'hSs6k']\n+  rank default\n+    stop\n+  end select\n+end\n+\n+! POINTER\n+! Assumed-shape array, pointer\n+\n+subroutine a5p (xcolon) bind(C)\n+  character(kind=c_char, len=:), pointer :: xcolon(:)\n+  if (.not. associated (xcolon)) stop\n+  if (size(xcolon) /= 6) stop\n+  if (len(xcolon) /= 5) stop  \n+  if (any (xcolon /= ['DDGhf', &\n+                     'hdrh$', &\n+                     'fDGSl', &\n+                     'DFHs3', &\n+                     '43grG', &\n+                     'hFG$k'])) stop\n+  xcolon = ['FDGhf', &\n+           'hdrhg', &\n+           'fDgFl', &\n+           'DFHs3', &\n+           '4a54G', &\n+           'hSs6k']\n+end\n+\n+! Assumed-rank array, pointer\n+\n+subroutine a5pr (xcolon) bind(C)\n+  character(kind=c_char, len=:), pointer :: xcolon(..)\n+  if (.not. associated (xcolon)) stop\n+  if (size(xcolon) /= 6) stop\n+  if (len(xcolon) /= 5) stop  \n+  select rank(xcolon)\n+    rank(1)\n+      if (any (xcolon /= ['DDGhf', &\n+                         'hdrh$', &\n+                         'fDGSl', &\n+                         'DFHs3', &\n+                         '43grG', &\n+                         'hFG$k'])) stop\n+      xcolon = ['FDGhf', &\n+               'hdrhg', &\n+               'fDgFl', &\n+               'DFHs3', &\n+               '4a54G', &\n+               'hSs6k']\n+  rank default\n+    stop\n+  end select\n+end\n+end module m\n+\n+program main\n+  use m\n+  implicit none (type, external)\n+  character(kind=c_char, len=1) :: str1a6(6)\n+  character(kind=c_char, len=2) :: str2a6(6)\n+  character(kind=c_char, len=5) :: str5a6(6)\n+\n+  character(kind=c_char, len=:), allocatable :: astr5a6(:)\n+  character(kind=c_char, len=:), pointer :: pstr5a6(:)\n+\n+  allocate (character(kind=c_char, len=5) :: astr5a6(6), pstr5a6(6))\n+\n+  ! assumed shape - with array descriptor\n+\n+  str1a6 = ['g', &\n+            'd', &\n+            'f', &\n+            's', &\n+            '3', &\n+            '5']\n+  call as1 (str1a6)\n+  if (any (str1a6 /= ['1', &\n+                      'h', &\n+                      'f', &\n+                      '3', &\n+                      '4', &\n+                      'h'])) stop\n+  str2a6 = ['ab', &\n+            'fd', &\n+            'D4', &\n+            '54', &\n+            'ga', &\n+            'hg']\n+  call as2 (str2a6)\n+  if (any (str2a6 /= ['ab', &\n+                      'hd', &\n+                      'fj', &\n+                      'a4', &\n+                      '4a', &\n+                      'hf'])) stop\n+\n+  str5a6 = ['DDGhf', &\n+            'hdrh$', &\n+            'fDGSl', &\n+            'DFHs3', &\n+            '43grG', &\n+            'hFG$k']\n+  call as3 (str5a6, 5)\n+  if (any (str5a6 /= ['FDGhf', &\n+                      'hdrhg', &\n+                      'fDgFl', &\n+                      'DFHs3', &\n+                      '4a54G', &\n+                      'hSs6k'])) stop\n+\n+  str5a6 = ['DDGhf', &\n+            'hdrh$', &\n+            'fDGSl', &\n+            'DFHs3', &\n+            '43grG', &\n+            'hFG$k']\n+  call as4 (str5a6)\n+  if (any (str5a6 /= ['FDGhf', &\n+                      'hdrhg', &\n+                      'fDgFl', &\n+                      'DFHs3', &\n+                      '4a54G', &\n+                      'hSs6k'])) stop\n+\n+  ! assumed rank - with array descriptor\n+\n+  str1a6 = ['g', &\n+            'd', &\n+            'f', &\n+            's', &\n+            '3', &\n+            '5']\n+  call ar1 (str1a6)\n+  if (any (str1a6 /= ['1', &\n+                      'h', &\n+                      'f', &\n+                      '3', &\n+                      '4', &\n+                      'h'])) stop\n+  str2a6 = ['ab', &\n+            'fd', &\n+            'D4', &\n+            '54', &\n+            'ga', &\n+            'hg']\n+  call ar2 (str2a6)\n+  if (any (str2a6 /= ['ab', &\n+                      'hd', &\n+                      'fj', &\n+                      'a4', &\n+                      '4a', &\n+                      'hf'])) stop\n+\n+  str5a6 = ['DDGhf', &\n+            'hdrh$', &\n+            'fDGSl', &\n+            'DFHs3', &\n+            '43grG', &\n+            'hFG$k']\n+  call ar3 (str5a6, 5)\n+  if (any (str5a6 /= ['FDGhf', &\n+                      'hdrhg', &\n+                      'fDgFl', &\n+                      'DFHs3', &\n+                      '4a54G', &\n+                      'hSs6k'])) stop\n+\n+\n+  str5a6 = ['DDGhf', &\n+            'hdrh$', &\n+            'fDGSl', &\n+            'DFHs3', &\n+            '43grG', &\n+            'hFG$k']\n+  call ar4 (str5a6)\n+  if (any (str5a6 /= ['FDGhf', &\n+                      'hdrhg', &\n+                      'fDgFl', &\n+                      'DFHs3', &\n+                      '4a54G', &\n+                      'hSs6k'])) stop\n+\n+  ! allocatable - with array descriptor\n+  astr5a6(:) = ['DDGhf', &\n+                'hdrh$', &\n+                'fDGSl', &\n+                'DFHs3', &\n+                '43grG', &\n+                'hFG$k']\n+  call a5a (astr5a6)\n+  if (any (astr5a6 /= ['FDGhf', &\n+                       'hdrhg', &\n+                       'fDgFl', &\n+                       'DFHs3', &\n+                       '4a54G', &\n+                       'hSs6k'])) stop\n+\n+  astr5a6(:) = ['DDGhf', &\n+                'hdrh$', &\n+                'fDGSl', &\n+                'DFHs3', &\n+                '43grG', &\n+                'hFG$k']\n+  call a5ar (astr5a6)\n+  if (any (astr5a6 /= ['FDGhf', &\n+                       'hdrhg', &\n+                       'fDgFl', &\n+                       'DFHs3', &\n+                       '4a54G', &\n+                       'hSs6k'])) stop\n+\n+\n+  ! pointer - with array descriptor\n+  pstr5a6 = ['DDGhf', &\n+             'hdrh$', &\n+             'fDGSl', &\n+             'DFHs3', &\n+             '43grG', &\n+             'hFG$k']\n+  call a5p (pstr5a6)\n+  if (any (pstr5a6 /= ['FDGhf', &\n+                       'hdrhg', &\n+                       'fDgFl', &\n+                       'DFHs3', &\n+                       '4a54G', &\n+                       'hSs6k'])) stop\n+\n+  pstr5a6 = ['DDGhf', &\n+             'hdrh$', &\n+             'fDGSl', &\n+             'DFHs3', &\n+             '43grG', &\n+             'hFG$k']\n+  call a5pr (pstr5a6)\n+  if (any (pstr5a6 /= ['FDGhf', &\n+                       'hdrhg', &\n+                       'fDgFl', &\n+                       'DFHs3', &\n+                       '4a54G', &\n+                       'hSs6k'])) stop\n+  deallocate (astr5a6, pstr5a6)\n+end\n+\n+! All arguments shall use array descriptors\n+! { dg-final { scan-tree-dump-times \"void as1 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as2 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict x2\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as4 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict xstar\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void as3 \\\\(struct array01_character\\\\(kind=1\\\\) & restrict xn, integer(kind=4) & restrict n)\n+! { dg-final { scan-tree-dump-times \"void ar1 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ar2 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict x2\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ar3 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict xn, integer(kind=4) & restrict n)\n+! { dg-final { scan-tree-dump-times \"void ar4 \\\\(struct array15_character\\\\(kind=1\\\\) & restrict xstar\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5a \\\\(struct array01_character\\\\(kind=1\\\\) & restrict xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5ar \\\\(struct array15_character\\\\(kind=1\\\\) & restrict xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5p \\\\(struct array01_character\\\\(kind=1\\\\) & xcolon\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void a5pr \\\\(struct array15_character\\\\(kind=1\\\\) & xcolon\\\\)\" 1 \"original\" } }"}, {"sha": "23e1d92334b1c2aeec1f12eda0b6ff661f6174d2", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_6.f90", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_6.f90?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -0,0 +1,262 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-std=f2003 -fimplicit-none\" }\n+\n+! F2003 only permits length=1 character dummy args\n+\n+! Scalar, nonallocatable/nonpointer\n+\n+subroutine s1 (x1) bind(C)\n+  character(len=1) :: x1\n+end\n+\n+subroutine s2 (x2) bind(C) ! { dg-error \"Fortran 2008: Character dummy argument 'x2' at .1. with length greater than 1 for procedure 's2' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=2) :: x2\n+end\n+\n+subroutine s3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 's3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn\n+end\n+\n+subroutine s4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 's4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar\n+end\n+\n+! Assumed-shape array, nonallocatable/nonpointer\n+\n+subroutine as1 (x1) bind(C)  ! { dg-error \"Fortran 2018: Assumed-shape array 'x1' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as1' at .2.\" }\n+  character(len=1) :: x1(:)\n+end\n+\n+subroutine as2 (x2) bind(C) ! { dg-error \"Fortran 2008: Character dummy argument 'x2' at .1. with length greater than 1 for procedure 'as2' with BIND\\\\(C\\\\) attribute\" }\n+                            ! { dg-error \"Fortran 2018: Assumed-shape array 'x2' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as2' at .2.\" \"\" { target *-*-* } .-1 }\n+  character(len=2) :: x2(:,:)\n+end\n+\n+subroutine as3 (xn, n) bind(C) ! { dg-error \"Fortran 2018: Character dummy argument 'xn' at .1. with nonconstant length as procedure 'as3' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Assumed-shape array 'xn' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as3' at .2.\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n) :: xn(:,:,:)\n+end\n+\n+subroutine as4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 'as4' with BIND\\\\(C\\\\) attribute\" }\n+                            ! { dg-error \"Fortran 2018: Assumed-shape array 'xstar' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as4' at .2.\" \"\" { target *-*-* } .-1 }\n+  character(len=*) :: xstar(:,:,:,:)\n+end\n+\n+! Assumed-rank array, nonallocatable/nonpointer\n+\n+subroutine ar1 (x1) bind(C) ! { dg-error \"Symbol 'x1' at .1. has no IMPLICIT type\" }\n+  character(len=1) :: x1(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine ar2 (x2) bind(C) ! { dg-error \"Symbol 'x2' at .1. has no IMPLICIT type\" }\n+  character(len=2) :: x2(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine ar3 (xn, n) bind(C) ! { dg-error \"Symbol 'xn' at .1. has no IMPLICIT type\" }\n+  integer :: n\n+  character(len=n) :: xn(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine ar4 (xstar) bind(C) ! { dg-error \"Symbol 'xstar' at .1. has no IMPLICIT type\" }\n+  character(len=*) :: xstar(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+! Assumed-size array, nonallocatable/nonpointer\n+\n+subroutine az1 (x1) bind(C)\n+  character(len=1) :: x1(*)\n+end\n+\n+subroutine az2 (x2) bind(C) ! { dg-error \"Fortran 2008: Character dummy argument 'x2' at .1. with length greater than 1 for procedure 'az2' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=2) :: x2(*)\n+end\n+                                             \n+subroutine az3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 'az3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn(*)\n+end\n+\n+subroutine az4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 'az4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar(*)\n+end\n+\n+! Explicit-size array, nonallocatable/nonpointer\n+\n+subroutine ae1 (x1) bind(C)\n+  character(len=1) :: x1(5)\n+end\n+\n+subroutine ae2 (x2) bind(C) ! { dg-error \"Fortran 2008: Character dummy argument 'x2' at .1. with length greater than 1 for procedure 'ae2' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=2) :: x2(7)\n+end\n+\n+subroutine ae3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 'ae3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn(9)\n+end\n+\n+subroutine ae4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 'ae4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar(3)\n+end\n+\n+! ALLOCATABLE\n+! Scalar, allocatable\n+\n+subroutine s1a (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 's1a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with ALLOCATABLE attribute in procedure 's1a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), allocatable :: x1\n+end\n+\n+subroutine s2a (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 's2a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with ALLOCATABLE attribute in procedure 's2a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), allocatable :: x2\n+end\n+\n+subroutine s3a (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 's3a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with ALLOCATABLE attribute in procedure 's3a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), allocatable :: xn\n+end\n+\n+subroutine s4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 's4a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with ALLOCATABLE attribute in procedure 's4a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), allocatable :: xstar\n+end\n+\n+subroutine s5a (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 's5a' with BIND\\\\(C\\\\) attribute\" }\n+                                ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with ALLOCATABLE attribute in procedure 's5a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), allocatable :: xcolon\n+end\n+\n+! Assumed-shape array, allocatable\n+\n+subroutine a1a (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 'a1a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with ALLOCATABLE attribute in procedure 'a1a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), allocatable :: x1(:)\n+end\n+\n+subroutine a2a (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 'a2a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with ALLOCATABLE attribute in procedure 'a2a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), allocatable :: x2(:,:)\n+end\n+\n+subroutine a3a (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 'a3a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with ALLOCATABLE attribute in procedure 'a3a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), allocatable :: xn(:,:,:)\n+end\n+\n+subroutine a4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with ALLOCATABLE attribute in procedure 'a4a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), allocatable :: xstar(:,:,:,:)\n+end\n+\n+subroutine a5a (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 'a5a' with BIND\\\\(C\\\\) attribute\" }\n+                                ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with ALLOCATABLE attribute in procedure 'a5a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), allocatable :: xcolon(:)\n+end\n+\n+! Assumed-rank array, allocatable\n+\n+subroutine a1ar (x1) bind(C) ! { dg-error \"Symbol 'x1' at .1. has no IMPLICIT type\" }\n+  character(len=1), allocatable :: x1(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a2ar (x2) bind(C) ! { dg-error \"Symbol 'x2' at .1. has no IMPLICIT type\" }\n+  character(len=2), allocatable :: x2(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a3ar (xn, n) bind(C) ! { dg-error \"Symbol 'xn' at .1. has no IMPLICIT type\" }\n+  integer :: n\n+  character(len=n), allocatable :: xn(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a4ar (xstar) bind(C) ! { dg-error \"Symbol 'xstar' at .1. has no IMPLICIT type\" }\n+  character(len=*), allocatable :: xstar(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a5ar (xcolon) bind(C) ! { dg-error \"Symbol 'xcolon' at .1. has no IMPLICIT type\" }\n+  character(len=:), allocatable :: xcolon(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+! POINTER\n+! Scalar, pointer\n+\n+subroutine s1p (x1) bind(C) ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 's1p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with POINTER attribute in procedure 's1p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), pointer :: x1\n+end\n+\n+subroutine s2p (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 's2p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with POINTER attribute in procedure 's2p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), pointer :: x2\n+end\n+\n+subroutine s3p (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 's3p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with POINTER attribute in procedure 's3p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), pointer :: xn\n+end\n+\n+subroutine s4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 's4p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with POINTER attribute in procedure 's4p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), pointer :: xstar\n+end\n+\n+subroutine s5p (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 's5p' with BIND\\\\(C\\\\) attribute\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with POINTER attribute in procedure 's5p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), pointer :: xcolon\n+end\n+\n+! Assumed-shape array, pointer\n+\n+subroutine a1p (x1) bind(C) ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 'a1p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with POINTER attribute in procedure 'a1p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), pointer :: x1(:)\n+end\n+\n+subroutine a2p (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 'a2p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with POINTER attribute in procedure 'a2p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), pointer :: x2(:,:)\n+end\n+\n+subroutine a3p (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 'a3p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with POINTER attribute in procedure 'a3p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), pointer :: xn(:,:,:)\n+end\n+\n+subroutine a4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with POINTER attribute in procedure 'a4p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), pointer :: xstar(:,:,:,:)\n+end\n+\n+subroutine a5p (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 'a5p' with BIND\\\\(C\\\\) attribute\" }\n+                                ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with POINTER attribute in procedure 'a5p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), pointer :: xcolon(:)\n+end\n+\n+! Assumed-rank array, pointer\n+\n+subroutine a1pr (x1) bind(C) ! { dg-error \"Symbol 'x1' at .1. has no IMPLICIT type\" }\n+  character(len=1), pointer :: x1(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a2pr (x2) bind(C) ! { dg-error \"Symbol 'x2' at .1. has no IMPLICIT type\" }\n+  character(len=2), pointer :: x2(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a3pr (xn, n) bind(C) ! { dg-error \"Symbol 'xn' at .1. has no IMPLICIT type\" }\n+  integer :: n\n+  character(len=n), pointer :: xn(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a4pr (xstar) bind(C) ! { dg-error \"Symbol 'xstar' at .1. has no IMPLICIT type\" }\n+  character(len=*), pointer :: xstar(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a5pr (xcolon) bind(C) ! { dg-error \"Symbol 'xcolon' at .1. has no IMPLICIT type\" }\n+  character(len=:), pointer :: xcolon(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end"}, {"sha": "a9b8c3b2c203f687714d5d63e4ea722c40a14eb4", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_7.f90", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_7.f90?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -0,0 +1,261 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-std=f2008 -fimplicit-none\" }\n+\n+! F2008 permits constant character lengths for dummy arguments\n+\n+! Scalar, nonallocatable/nonpointer\n+\n+subroutine s1 (x1) bind(C)\n+  character(len=1) :: x1\n+end\n+\n+subroutine s2 (x2) bind(C)\n+  character(len=2) :: x2\n+end\n+\n+subroutine s3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 's3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn\n+end\n+\n+subroutine s4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 's4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar\n+end\n+\n+! Assumed-shape array, nonallocatable/nonpointer\n+\n+subroutine as1 (x1) bind(C)  ! { dg-error \"Fortran 2018: Assumed-shape array 'x1' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as1' at .2.\" }\n+  character(len=1) :: x1(:)\n+end\n+\n+subroutine as2 (x2) bind(C) ! { dg-error \"Fortran 2018: Assumed-shape array 'x2' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as2' at .2.\" }\n+  character(len=2) :: x2(:,:)\n+end\n+\n+subroutine as3 (xn, n) bind(C) ! { dg-error \"Fortran 2018: Character dummy argument 'xn' at .1. with nonconstant length as procedure 'as3' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Assumed-shape array 'xn' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as3' at .2.\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n) :: xn(:,:,:)\n+end\n+\n+subroutine as4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 'as4' with BIND\\\\(C\\\\) attribute\" }\n+                               ! { dg-error \"Fortran 2018: Assumed-shape array 'xstar' at .1. as dummy argument to the BIND\\\\(C\\\\) procedure 'as4' at .2.\" \"\" { target *-*-* } .-1 }\n+  character(len=*) :: xstar(:,:,:,:)\n+end\n+\n+! Assumed-rank array, nonallocatable/nonpointer\n+\n+subroutine ar1 (x1) bind(C) ! { dg-error \"Symbol 'x1' at .1. has no IMPLICIT type\" }\n+  character(len=1) :: x1(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine ar2 (x2) bind(C) ! { dg-error \"Symbol 'x2' at .1. has no IMPLICIT type\" }\n+  character(len=2) :: x2(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine ar3 (xn, n) bind(C) ! { dg-error \"Symbol 'xn' at .1. has no IMPLICIT type\" }\n+  integer :: n\n+  character(len=n) :: xn(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine ar4 (xstar) bind(C) ! { dg-error \"Symbol 'xstar' at .1. has no IMPLICIT type\" }\n+  character(len=*) :: xstar(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+! Assumed-size array, nonallocatable/nonpointer\n+\n+subroutine az1 (x1) bind(C)\n+  character(len=1) :: x1(*)\n+end\n+\n+subroutine az2 (x2) bind(C)\n+  character(len=2) :: x2(*)\n+end\n+\n+subroutine az3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 'az3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn(*)\n+end\n+\n+subroutine az4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 'az4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar(*)\n+end\n+\n+! Explicit-size array, nonallocatable/nonpointer\n+\n+subroutine ae1 (x1) bind(C)\n+  character(len=1) :: x1(5)\n+end\n+\n+subroutine ae2 (x2) bind(C)\n+  character(len=2) :: x2(7)\n+end\n+\n+subroutine ae3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 'ae3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn(9)\n+end\n+\n+subroutine ae4 (xstar) bind(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'xstar' at .1. of procedure 'ae4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar(3)\n+end\n+\n+! ALLOCATABLE\n+! Scalar, allocatable\n+\n+subroutine s1a (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 's1a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with ALLOCATABLE attribute in procedure 's1a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), allocatable :: x1\n+end\n+\n+subroutine s2a (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 's2a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with ALLOCATABLE attribute in procedure 's2a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), allocatable :: x2\n+end\n+\n+subroutine s3a (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 's3a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with ALLOCATABLE attribute in procedure 's3a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), allocatable :: xn\n+end\n+\n+subroutine s4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 's4a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with ALLOCATABLE attribute in procedure 's4a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), allocatable :: xstar\n+end\n+\n+subroutine s5a (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 's5a' with BIND\\\\(C\\\\) attribute\" }\n+                                ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with ALLOCATABLE attribute in procedure 's5a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), allocatable :: xcolon\n+end\n+\n+! Assumed-shape array, allocatable\n+\n+subroutine a1a (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 'a1a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with ALLOCATABLE attribute in procedure 'a1a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), allocatable :: x1(:)\n+end\n+\n+subroutine a2a (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 'a2a' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with ALLOCATABLE attribute in procedure 'a2a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), allocatable :: x2(:,:)\n+end\n+\n+subroutine a3a (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 'a3a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with ALLOCATABLE attribute in procedure 'a3a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), allocatable :: xn(:,:,:)\n+end\n+\n+subroutine a4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4a' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with ALLOCATABLE attribute in procedure 'a4a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), allocatable :: xstar(:,:,:,:)\n+end\n+\n+subroutine a5a (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 'a5a' with BIND\\\\(C\\\\) attribute\" }\n+                                ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with ALLOCATABLE attribute in procedure 'a5a' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), allocatable :: xcolon(:)\n+end\n+\n+! Assumed-rank array, allocatable\n+\n+subroutine a1ar (x1) bind(C) ! { dg-error \"Symbol 'x1' at .1. has no IMPLICIT type\" }\n+  character(len=1), allocatable :: x1(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a2ar (x2) bind(C) ! { dg-error \"Symbol 'x2' at .1. has no IMPLICIT type\" }\n+  character(len=2), allocatable :: x2(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a3ar (xn, n) bind(C) ! { dg-error \"Symbol 'xn' at .1. has no IMPLICIT type\" }\n+  integer :: n\n+  character(len=n), allocatable :: xn(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a4ar (xstar) bind(C) ! { dg-error \"Symbol 'xstar' at .1. has no IMPLICIT type\" }\n+  character(len=*), allocatable :: xstar(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a5ar (xcolon) bind(C) ! { dg-error \"Symbol 'xcolon' at .1. has no IMPLICIT type\" }\n+  character(len=:), allocatable :: xcolon(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+! POINTER\n+! Scalar, pointer\n+\n+subroutine s1p (x1) bind(C) ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 's1p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with POINTER attribute in procedure 's1p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), pointer :: x1\n+end\n+\n+subroutine s2p (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 's2p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with POINTER attribute in procedure 's2p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), pointer :: x2\n+end\n+\n+subroutine s3p (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 's3p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with POINTER attribute in procedure 's3p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), pointer :: xn\n+end\n+\n+subroutine s4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 's4p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with POINTER attribute in procedure 's4p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), pointer :: xstar\n+end\n+\n+subroutine s5p (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 's5p' with BIND\\\\(C\\\\) attribute\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with POINTER attribute in procedure 's5p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), pointer :: xcolon\n+end\n+\n+! Assumed-shape array, pointer\n+\n+subroutine a1p (x1) bind(C) ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 'a1p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x1' at .1. with POINTER attribute in procedure 'a1p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=1), pointer :: x1(:)\n+end\n+\n+subroutine a2p (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 'a2p' is BIND\\\\(C\\\\)\" }\n+                            ! { dg-error \"Fortran 2018: Variable 'x2' at .1. with POINTER attribute in procedure 'a2p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=2), pointer :: x2(:,:)\n+end\n+\n+subroutine a3p (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 'a3p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xn' at .1. with POINTER attribute in procedure 'a3p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  integer :: n\n+  character(len=n), pointer :: xn(:,:,:)\n+end\n+\n+subroutine a4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4p' is BIND\\\\(C\\\\)\" }\n+                               ! { dg-error \"Fortran 2018: Variable 'xstar' at .1. with POINTER attribute in procedure 'a4p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=*), pointer :: xstar(:,:,:,:)\n+end\n+\n+subroutine a5p (xcolon) bind(C) ! { dg-error \"Fortran 2018: Deferred-length character dummy argument 'xcolon' at .1. of procedure 'a5p' with BIND\\\\(C\\\\) attribute\" }\n+                                ! { dg-error \"Fortran 2018: Variable 'xcolon' at .1. with POINTER attribute in procedure 'a5p' with BIND\\\\(C\\\\)\" \"\" { target *-*-* } .-1 }\n+  character(len=:), pointer :: xcolon(:)\n+end\n+\n+! Assumed-rank array, pointer\n+\n+subroutine a1pr (x1) bind(C) ! { dg-error \"Symbol 'x1' at .1. has no IMPLICIT type\" }\n+  character(len=1), pointer :: x1(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a2pr (x2) bind(C) ! { dg-error \"Symbol 'x2' at .1. has no IMPLICIT type\" }\n+  character(len=2), pointer :: x2(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a3pr (xn, n) bind(C) ! { dg-error \"Symbol 'xn' at .1. has no IMPLICIT type\" }\n+  integer :: n\n+  character(len=n), pointer :: xn(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a4pr (xstar) bind(C) ! { dg-error \"Symbol 'xstar' at .1. has no IMPLICIT type\" }\n+  character(len=*), pointer :: xstar(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end\n+\n+subroutine a5pr (xcolon) bind(C) ! { dg-error \"Symbol 'xcolon' at .1. has no IMPLICIT type\" }\n+  character(len=:), pointer :: xcolon(..) ! { dg-error \"Fortran 2018: Assumed-rank array at .1.\" }\n+end"}, {"sha": "1d566c0334d8721fbc61a7d9292130c1f3e64fc4", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_8.f90", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_8.f90?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -0,0 +1,249 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fimplicit-none\" }\n+\n+! F2018 only permittes len=*, len=: or len=<const> as dummy argument\n+! but not len=<non-const-expr>\n+! Additionally, for allocatable/pointer, len=: is required.\n+\n+! Scalar, nonallocatable/nonpointer\n+\n+subroutine val_s1(x1) bind(C)\n+  character(len=1), value :: x1\n+end\n+\n+subroutine val_s2(x2) bind(C) ! { dg-error \"Character dummy argument 'x2' at .1. must be of length 1 as it has the VALUE attribute\" }\n+  character(len=2), value :: x2\n+end\n+\n+subroutine s1 (x1) bind(C)\n+  character(len=1) :: x1\n+end\n+\n+subroutine s2 (x2) bind(C)\n+  character(len=2) :: x2\n+end\n+\n+subroutine s3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 's3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn\n+end\n+\n+subroutine s4 (xstar) bind(C) ! { dg-error \"Sorry, character dummy argument 'xstar' at .1. with assumed length is not yet supported for procedure 's4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar\n+end\n+\n+! Assumed-shape array, nonallocatable/nonpointer\n+\n+subroutine as1 (x1) bind(C)\n+  character(len=1) :: x1(:)\n+end\n+\n+subroutine as2 (x2) bind(C)\n+  character(len=2) :: x2(:,:)\n+end\n+\n+subroutine as3 (xn, n) bind(C)\n+  integer :: n\n+  character(len=n) :: xn(:,:,:)\n+end\n+\n+subroutine as4 (xstar) bind(C)\n+  character(len=*) :: xstar(:,:,:,:)\n+end\n+\n+! Assumed-rank array, nonallocatable/nonpointer\n+\n+subroutine ar1 (x1) bind(C)\n+  character(len=1) :: x1(..)\n+end\n+\n+subroutine ar2 (x2) bind(C)\n+  character(len=2) :: x2(..)\n+end\n+\n+subroutine ar3 (xn, n) bind(C)\n+  integer :: n\n+  character(len=n) :: xn(..)\n+end\n+\n+subroutine ar4 (xstar) bind(C)\n+  character(len=*) :: xstar(..)\n+end\n+\n+! Assumed-size array, nonallocatable/nonpointer\n+\n+subroutine az1 (x1) bind(C)\n+  character(len=1) :: x1(*)\n+end\n+\n+subroutine az2 (x2) bind(C)\n+  character(len=2) :: x2(*)\n+end\n+\n+subroutine az3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 'az3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn(*)\n+end\n+\n+subroutine az4 (xstar) bind(C)  ! { dg-error \"Sorry, character dummy argument 'xstar' at .1. with assumed length is not yet supported for procedure 'az4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar(*)\n+end\n+\n+! Explicit-size array, nonallocatable/nonpointer\n+\n+subroutine ae1 (x1) bind(C)\n+  character(len=1) :: x1(5)\n+end\n+\n+subroutine ae2 (x2) bind(C)\n+  character(len=2) :: x2(7)\n+end\n+\n+subroutine ae3 (xn, n) bind(C) ! { dg-error \"Character dummy argument 'xn' at .1. must be of constant length or assumed length, unless it has assumed shape or assumed rank, as procedure 'ae3' has the BIND\\\\(C\\\\) attribute\" }\n+  integer :: n\n+  character(len=n) :: xn(9)\n+end\n+\n+subroutine ae4 (xstar) bind(C) ! { dg-error \"Sorry, character dummy argument 'xstar' at .1. with assumed length is not yet supported for procedure 'ae4' with BIND\\\\(C\\\\) attribute\" }\n+  character(len=*) :: xstar(3)\n+end\n+\n+! ALLOCATABLE\n+! Scalar, allocatable\n+\n+subroutine s1a (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 's1a' is BIND\\\\(C\\\\)\" }\n+  character(len=1), allocatable :: x1\n+end\n+\n+subroutine s2a (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 's2a' is BIND\\\\(C\\\\)\" }\n+  character(len=2), allocatable :: x2\n+end\n+\n+subroutine s3a (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 's3a' is BIND\\\\(C\\\\)\" }\n+  integer :: n\n+  character(len=n), allocatable :: xn\n+end\n+\n+subroutine s4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 's4a' is BIND\\\\(C\\\\)\" }\n+  character(len=*), allocatable :: xstar\n+end\n+\n+subroutine s5a (xcolon) bind(C) ! { dg-error \"Sorry, deferred-length scalar character dummy argument 'xcolon' at .1. of procedure 's5a' with BIND\\\\(C\\\\) not yet supported\" }\n+  character(len=:), allocatable :: xcolon\n+end\n+\n+! Assumed-shape array, allocatable\n+\n+subroutine a1a (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 'a1a' is BIND\\\\(C\\\\)\" }\n+  character(len=1), allocatable :: x1(:)\n+end\n+\n+subroutine a2a (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 'a2a' is BIND\\\\(C\\\\)\" }\n+  character(len=2), allocatable :: x2(:,:)\n+end\n+\n+subroutine a3a (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 'a3a' is BIND\\\\(C\\\\)\" }\n+  integer :: n\n+  character(len=n), allocatable :: xn(:,:,:)\n+end\n+\n+subroutine a4a (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4a' is BIND\\\\(C\\\\)\" }\n+  character(len=*), allocatable :: xstar(:,:,:,:)\n+end\n+\n+subroutine a5a (xcolon) bind(C)\n+  character(len=:), allocatable :: xcolon(:)\n+end\n+\n+! Assumed-rank array, allocatable\n+\n+subroutine a1ar (x1) bind(C) ! { dg-error \"Allocatable character dummy argument 'x1' at .1. must have deferred length as procedure 'a1ar' is BIND\\\\(C\\\\)\" }\n+  character(len=1), allocatable :: x1(..)\n+end\n+\n+subroutine a2ar (x2) bind(C) ! { dg-error \"Allocatable character dummy argument 'x2' at .1. must have deferred length as procedure 'a2ar' is BIND\\\\(C\\\\)\" }\n+  character(len=2), allocatable :: x2(..)\n+end\n+\n+subroutine a3ar (xn, n) bind(C) ! { dg-error \"Allocatable character dummy argument 'xn' at .1. must have deferred length as procedure 'a3ar' is BIND\\\\(C\\\\)\" }\n+  integer :: n\n+  character(len=n), allocatable :: xn(..)\n+end\n+\n+subroutine a4ar (xstar) bind(C) ! { dg-error \"Allocatable character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4ar' is BIND\\\\(C\\\\)\" }\n+  character(len=*), allocatable :: xstar(..)\n+end\n+\n+subroutine a5ar (xcolon) bind(C)\n+  character(len=:), allocatable :: xcolon(..)\n+end\n+\n+! POINTER\n+! Scalar, pointer\n+\n+subroutine s1p (x1) bind(C) ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 's1p' is BIND\\\\(C\\\\)\" }\n+  character(len=1), pointer :: x1\n+end\n+\n+subroutine s2p (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 's2p' is BIND\\\\(C\\\\)\" }\n+  character(len=2), pointer :: x2\n+end\n+\n+subroutine s3p (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 's3p' is BIND\\\\(C\\\\)\" }\n+  integer :: n\n+  character(len=n), pointer :: xn\n+end\n+\n+subroutine s4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 's4p' is BIND\\\\(C\\\\)\" }\n+  character(len=*), pointer :: xstar\n+end\n+\n+subroutine s5p (xcolon) bind(C) ! { dg-error \"Sorry, deferred-length scalar character dummy argument 'xcolon' at .1. of procedure 's5p' with BIND\\\\(C\\\\) not yet supported\" }\n+  character(len=:), pointer :: xcolon\n+end\n+\n+! Assumed-shape array, pointer\n+\n+subroutine a1p (x1) bind(C) ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 'a1p' is BIND\\\\(C\\\\)\" }\n+  character(len=1), pointer :: x1(:)\n+end\n+\n+subroutine a2p (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 'a2p' is BIND\\\\(C\\\\)\" }\n+  character(len=2), pointer :: x2(:,:)\n+end\n+\n+subroutine a3p (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 'a3p' is BIND\\\\(C\\\\)\" }\n+  integer :: n\n+  character(len=n), pointer :: xn(:,:,:)\n+end\n+\n+subroutine a4p (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4p' is BIND\\\\(C\\\\)\" }\n+  character(len=*), pointer :: xstar(:,:,:,:)\n+end\n+\n+subroutine a5p (xcolon) bind(C)\n+  character(len=:), pointer :: xcolon(:)\n+end\n+\n+! Assumed-rank array, pointer\n+\n+subroutine a1pr (x1) bind(C)  ! { dg-error \"Pointer character dummy argument 'x1' at .1. must have deferred length as procedure 'a1pr' is BIND\\\\(C\\\\)\" }\n+  character(len=1), pointer :: x1(..)\n+end\n+\n+subroutine a2pr (x2) bind(C) ! { dg-error \"Pointer character dummy argument 'x2' at .1. must have deferred length as procedure 'a2pr' is BIND\\\\(C\\\\)\" }\n+  character(len=2), pointer :: x2(..)\n+end\n+\n+subroutine a3pr (xn, n) bind(C) ! { dg-error \"Pointer character dummy argument 'xn' at .1. must have deferred length as procedure 'a3pr' is BIND\\\\(C\\\\)\" }\n+  integer :: n\n+  character(len=n), pointer :: xn(..)\n+end\n+\n+subroutine a4pr (xstar) bind(C) ! { dg-error \"Pointer character dummy argument 'xstar' at .1. must have deferred length as procedure 'a4pr' is BIND\\\\(C\\\\)\" }\n+  character(len=*), pointer :: xstar(..)\n+end\n+\n+subroutine a5pr (xcolon) bind(C)\n+  character(len=:), pointer :: xcolon(..)\n+end"}, {"sha": "d31862c89e8502cd3110fc58b60c9743f57862d6", "filename": "gcc/testsuite/gfortran.dg/bind_c_char_9.f90", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_char_9.f90?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -0,0 +1,188 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+! F2018  - examples without array descriptor\n+\n+\n+module m\n+  use iso_c_binding, only: c_char\n+  implicit none (type, external)\n+\n+contains\n+\n+! Scalar, nonallocatable/nonpointer\n+subroutine s1 (x1) bind(C)\n+  character(kind=c_char, len=1) :: x1\n+  if (len (x1) /= 1) stop\n+  if (x1 /= 'Z') stop\n+  x1 = 'A'\n+end\n+\n+subroutine s2 (x2) bind(C)\n+  character(kind=c_char, len=2) :: x2\n+  if (len (x2) /= 2) stop\n+  if (x2 /= '42') stop\n+  x2 = '64'\n+end\n+\n+! Assumed-size array, nonallocatable/nonpointer\n+\n+subroutine az1 (x1) bind(C)\n+  character(kind=c_char, len=1) :: x1(*)\n+  if (len(x1) /= 1) stop  \n+  if (any (x1(:6) /= ['g', &\n+                      'd', &\n+                      'f', &\n+                      's', &\n+                      '3', &\n+                      '5'])) stop 1\n+  x1(:6) = ['1', &\n+            'h', &\n+            'f', &\n+            '3', &\n+            '4', &\n+            'h']\n+end\n+\n+subroutine az2 (x2) bind(C)\n+  character(kind=c_char, len=2) :: x2(*)\n+  if (len(x2) /= 2) stop  \n+  if (any (x2(:6) /= ['ab', &\n+                      'fd', &\n+                      'D4', &\n+                      '54', &\n+                      'ga', &\n+                      'hg'])) stop\n+  x2(:6) = ['ab', &\n+            'hd', &\n+            'fj', &\n+            'a4', &\n+            '4a', &\n+            'hf']\n+end\n+\n+! Explicit-size array, nonallocatable/nonpointer\n+\n+subroutine ae1 (x1) bind(C)\n+  character(kind=c_char, len=1) :: x1(6)\n+  if (size(x1) /= 6) stop\n+  if (len(x1) /= 1) stop  \n+  if (any (x1 /= ['g', &\n+                  'd', &\n+                  'f', &\n+                  's', &\n+                  '3', &\n+                  '5'])) stop 1\n+  x1 = ['1', &\n+        'h', &\n+        'f', &\n+        '3', &\n+        '4', &\n+        'h']\n+end\n+\n+subroutine ae2 (x2) bind(C)\n+  character(kind=c_char, len=2) :: x2(6)\n+  if (size(x2) /= 6) stop\n+  if (len(x2) /= 2) stop  \n+  if (any (x2 /= ['ab', &\n+                  'fd', &\n+                  'D4', &\n+                  '54', &\n+                  'ga', &\n+                  'hg'])) stop\n+  x2 = ['ab', &\n+        'hd', &\n+        'fj', &\n+        'a4', &\n+        '4a', &\n+        'hf']\n+end\n+\n+end module m\n+\n+program main\n+  use m\n+  implicit none (type, external)\n+  character(kind=c_char, len=1) :: str1\n+  character(kind=c_char, len=2) :: str2\n+\n+  character(kind=c_char, len=1) :: str1a6(6)\n+  character(kind=c_char, len=2) :: str2a6(6)\n+\n+  ! Scalar - no array descriptor\n+\n+  str1 = 'Z'\n+  call s1 (str1)\n+  if (str1 /= 'A') stop\n+\n+  str2 = '42'\n+  call s2 (str2)\n+  if (str2 /= '64') stop\n+\n+  ! assumed size - without array descriptor\n+\n+  str1a6 = ['g', &\n+            'd', &\n+            'f', &\n+            's', &\n+            '3', &\n+            '5']\n+  call az1 (str1a6)\n+  if (any (str1a6 /= ['1', &\n+                      'h', &\n+                      'f', &\n+                      '3', &\n+                      '4', &\n+                      'h'])) stop\n+  str2a6 = ['ab', &\n+            'fd', &\n+            'D4', &\n+            '54', &\n+            'ga', &\n+            'hg']\n+  call az2 (str2a6)\n+  if (any (str2a6 /= ['ab', &\n+                      'hd', &\n+                      'fj', &\n+                      'a4', &\n+                      '4a', &\n+                      'hf'])) stop\n+  ! explicit size - without array descriptor\n+\n+  str1a6 = ['g', &\n+            'd', &\n+            'f', &\n+            's', &\n+            '3', &\n+            '5']\n+  call ae1 (str1a6)\n+  if (any (str1a6 /= ['1', &\n+                      'h', &\n+                      'f', &\n+                      '3', &\n+                      '4', &\n+                      'h'])) stop\n+  str2a6 = ['ab', &\n+            'fd', &\n+            'D4', &\n+            '54', &\n+            'ga', &\n+            'hg']\n+  call ae2 (str2a6)\n+  if (any (str2a6 /= ['ab', &\n+                      'hd', &\n+                      'fj', &\n+                      'a4', &\n+                      '4a', &\n+                      'hf'])) stop\n+end\n+\n+! All argument shall be passed without descriptor\n+! { dg-final { scan-tree-dump-not \"dtype\" \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void s1 \\\\(character\\\\(kind=1\\\\)\\\\\\[1:1\\\\\\] & restrict x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void s2 \\\\(character\\\\(kind=1\\\\)\\\\\\[1:2\\\\\\] & restrict x2\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void az1 \\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:1\\\\\\] \\\\* restrict x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void az2 \\\\(character\\\\(kind=1\\\\)\\\\\\[0:\\\\\\]\\\\\\[1:2\\\\\\] \\\\* restrict x2\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ae1 \\\\(character\\\\(kind=1\\\\)\\\\\\[6\\\\\\]\\\\\\[1:1\\\\\\] \\\\* restrict x1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"void ae2 \\\\(character\\\\(kind=1\\\\)\\\\\\[6\\\\\\]\\\\\\[1:2\\\\\\] \\\\* restrict x2\\\\)\" 1 \"original\" } }"}, {"sha": "abe5cb71bfc7fb98508661fd15594bcf92f5fedb", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_char_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -4,7 +4,7 @@\n !\n ! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n !\n-subroutine bar(c,d) BIND(C) ! { dg-error \"must be length 1\" }\n+subroutine bar(c,d) BIND(C) ! { dg-error \"character dummy argument 'c' at .1. with assumed length is not yet supported for procedure 'bar' with BIND\\\\(C\\\\) attribute\" }\n   character (len=*) c\n   character (len=2) d\n end"}, {"sha": "bf9bd8c1d68b5f89cc4e0671b17027930e707d50", "filename": "gcc/testsuite/gfortran.dg/pr32599.f03", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32599.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32599.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32599.f03?ref=b3d4011ba10275fbd5d6ec5a16d5aaebbdfb5d3c", "patch": "@@ -1,20 +1,20 @@\n ! { dg-do compile }\n-! { dg-options \"-std=f2008\" }\n+! { dg-options \"-std=f2003\" }\n !\n ! PR fortran/32599\n ! Verifies that character string arguments to a bind(c) procedure have length\n-! 1, or no len is specified. Note that the C interop extensions in F2018 allow\n+! 1, or no len is specified. Note that the C interop extensions in F2008 allow\n ! string arguments of length greater than one to be passed to a C descriptor.\n !\n module pr32599\n   interface\n-     subroutine destroy(path) BIND(C) ! { dg-error \"must be length 1\" }\n+     subroutine destroy(path) BIND(C) ! { dg-error \"Fortran 2018: Assumed-length character dummy argument 'path' at .1. of procedure .destroy. with BIND\\\\(C\\\\) attribute\" }\n        use iso_c_binding\n        implicit none\n        character(len=*,kind=c_char), intent(IN) :: path\n      end subroutine destroy\n \n-     subroutine create(path) BIND(C) ! { dg-error \"must be length 1\" }\n+     subroutine create(path) BIND(C) ! { dg-error \"Fortran 2008: Character dummy argument 'path' at .1. with length greater than 1 for procedure 'create' with BIND\\\\(C\\\\) attribute\" }\n        use iso_c_binding\n        implicit none\n        character(len=5,kind=c_char), intent(IN) :: path"}]}