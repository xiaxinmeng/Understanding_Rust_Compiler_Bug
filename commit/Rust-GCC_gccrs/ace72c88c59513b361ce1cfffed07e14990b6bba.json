{"sha": "ace72c88c59513b361ce1cfffed07e14990b6bba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNlNzJjODhjNTk1MTNiMzYxY2UxY2ZmZmVkMDdlMTQ5OTBiNmJiYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-30T18:44:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-30T18:44:41Z"}, "message": "lto.c (get_filename_for_set): Look for cgraph node and if none found, use default name.\n\n\n\t* lto.c (get_filename_for_set): Look for cgraph node and if none found, use\n\tdefault name.\n\t(lto_wpa_write_files): Write any non-empty partition.\n\n\t* cgraph.h (cgraph_node_set_nonempty_p, varpool_node_set_nonempty_p): New.\n\t* lto-cgraph.c (input_cgraph): Remove call to lto_mark_file_for_ltrans.\n\t* lto-streamer.h (lto_file_decl_data): Remove needs_ltrans_p.\n\t(lto_file_needs_ltrans_p, lto_mark_file_for_ltrans,\n\tcgraph_node_set_needs_ltrans_p): Remove.\n\nFrom-SVN: r158943", "tree": {"sha": "cb91ee477b569e52145f60b6fcf1d8acc58becd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb91ee477b569e52145f60b6fcf1d8acc58becd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ace72c88c59513b361ce1cfffed07e14990b6bba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace72c88c59513b361ce1cfffed07e14990b6bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace72c88c59513b361ce1cfffed07e14990b6bba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace72c88c59513b361ce1cfffed07e14990b6bba/comments", "author": null, "committer": null, "parents": [{"sha": "bf65e4b1840a177da33775556f9b7f7eecf66fc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf65e4b1840a177da33775556f9b7f7eecf66fc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf65e4b1840a177da33775556f9b7f7eecf66fc4"}], "stats": {"total": 155, "additions": 72, "deletions": 83}, "files": [{"sha": "5a7de8f10f1cb375fb87a3d3479a641deb8aed39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ace72c88c59513b361ce1cfffed07e14990b6bba", "patch": "@@ -1,3 +1,11 @@\n+2010-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_node_set_nonempty_p, varpool_node_set_nonempty_p): New.\n+\t* lto-cgraph.c (input_cgraph): Remove call to lto_mark_file_for_ltrans.\n+\t* lto-streamer.h (lto_file_decl_data): Remove needs_ltrans_p.\n+\t(lto_file_needs_ltrans_p, lto_mark_file_for_ltrans,\n+\tcgraph_node_set_needs_ltrans_p): Remove.\n+\n 2010-04-30  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* sdbout.c: Include vec.h, do not include varray.h."}, {"sha": "80594b13875e882839c325b236fce5fadf24a06f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ace72c88c59513b361ce1cfffed07e14990b6bba", "patch": "@@ -827,6 +827,20 @@ struct GTY(()) constant_descriptor_tree {\n   hashval_t hash;\n };\n \n+/* Return true if set is nonempty.  */\n+static inline bool\n+cgraph_node_set_nonempty_p (cgraph_node_set set)\n+{\n+  return VEC_length (cgraph_node_ptr, set->nodes);\n+}\n+\n+/* Return true if set is nonempty.  */\n+static inline bool\n+varpool_node_set_nonempty_p (varpool_node_set set)\n+{\n+  return VEC_length (varpool_node_ptr, set->nodes);\n+}\n+\n /* Return true when function NODE is only called directly.\n    i.e. it is not externally visible, address was not taken and\n    it is not used in any other non-standard way.  */"}, {"sha": "3f7a22b7367b7f54a4840d6c28ae8f1e8fce269d", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ace72c88c59513b361ce1cfffed07e14990b6bba", "patch": "@@ -962,10 +962,6 @@ input_cgraph (void)\n       input_varpool_1 (file_data, ib);\n       lto_destroy_simple_input_block (file_data, LTO_section_varpool,\n \t\t\t\t      ib, data, len);\n-\n-      /* Assume that every file read needs to be processed by LTRANS.  */\n-      if (flag_wpa)\n-\tlto_mark_file_for_ltrans (file_data);\n     }\n \n   /* Clear out the aux field that was used to store enough state to"}, {"sha": "cc1922a6a7f0230b9a12c8ce625cc5d23fa0ecd8", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=ace72c88c59513b361ce1cfffed07e14990b6bba", "patch": "@@ -552,9 +552,6 @@ struct GTY(()) lto_file_decl_data\n   /* The .o file that these offsets relate to.  */\n   const char *GTY((skip)) file_name;\n \n-  /* Nonzero if this file should be recompiled with LTRANS.  */\n-  unsigned needs_ltrans_p : 1;\n-\n   /* Hash table maps lto-related section names to location in file.  */\n   htab_t GTY((skip)) section_hash_table;\n \n@@ -922,38 +919,6 @@ lto_tag_to_tree_code (enum LTO_tags tag)\n   return (enum tree_code) ((unsigned) tag - 1);\n }\n \n-\n-/* Return true if FILE needs to be compiled with LTRANS.  */\n-static inline bool\n-lto_file_needs_ltrans_p (struct lto_file_decl_data *file)\n-{\n-  return file->needs_ltrans_p != 0;\n-}\n-\n-\n-/* Mark FILE to be compiled with LTRANS.  */\n-static inline void\n-lto_mark_file_for_ltrans (struct lto_file_decl_data *file)\n-{\n-  file->needs_ltrans_p = 1;\n-}\n-\n-\n-/* Return true if any files in node set SET need to be compiled\n-   with LTRANS.  */\n-static inline bool\n-cgraph_node_set_needs_ltrans_p (cgraph_node_set set)\n-{\n-  cgraph_node_set_iterator csi;\n-\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-    if (lto_file_needs_ltrans_p (csi_node (csi)->local.lto_file_data))\n-      return true;\n-\n-  return false;\n-}\n-\n-\n /* Initialize an lto_out_decl_buffer ENCODER.  */\n static inline void\n lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder,"}, {"sha": "c17da3b8d199209e72b37d867db676851f5cc09e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ace72c88c59513b361ce1cfffed07e14990b6bba", "patch": "@@ -1,3 +1,9 @@\n+2010-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (get_filename_for_set): Look for cgraph node and if none found, use\n+\tdefault name.\n+\t(lto_wpa_write_files): Write any non-empty partition.\n+\n 2010-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c: Do not attempt to make constant pool references global."}, {"sha": "d306580a971a6e9b93642a3ff8372b6251d1c560", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ace72c88c59513b361ce1cfffed07e14990b6bba/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ace72c88c59513b361ce1cfffed07e14990b6bba", "patch": "@@ -817,57 +817,50 @@ get_filename_for_set (cgraph_node_set set)\n   char *fname = NULL;\n   static const size_t max_fname_len = 100;\n \n-  if (cgraph_node_set_needs_ltrans_p (set))\n+  /* Create a new temporary file to store SET.  To facilitate\n+     debugging, use file names from SET as part of the new\n+     temporary file name.  */\n+  cgraph_node_set_iterator si;\n+  struct pointer_set_t *pset = pointer_set_create ();\n+  for (si = csi_start (set); !csi_end_p (si); csi_next (&si))\n     {\n-      /* Create a new temporary file to store SET.  To facilitate\n-\t debugging, use file names from SET as part of the new\n-\t temporary file name.  */\n-      cgraph_node_set_iterator si;\n-      struct pointer_set_t *pset = pointer_set_create ();\n-      for (si = csi_start (set); !csi_end_p (si); csi_next (&si))\n-\t{\n-\t  struct cgraph_node *n = csi_node (si);\n-\t  const char *node_fname;\n-\t  char *f;\n+      struct cgraph_node *n = csi_node (si);\n+      const char *node_fname;\n+      char *f;\n \n-\t  /* Don't use the same file name more than once.  */\n-\t  if (pointer_set_insert (pset, n->local.lto_file_data))\n-\t    continue;\n+      /* Don't use the same file name more than once.  */\n+      if (pointer_set_insert (pset, n->local.lto_file_data))\n+\tcontinue;\n \n-\t  /* The first file name found in SET determines the output\n-\t     directory.  For the remaining files, we use their\n-\t     base names.  */\n-\t  node_fname = n->local.lto_file_data->file_name;\n-\t  if (fname == NULL)\n-\t    {\n-\t      fname = strip_extension (node_fname);\n-\t      continue;\n-\t    }\n+      /* The first file name found in SET determines the output\n+\t directory.  For the remaining files, we use their\n+\t base names.  */\n+      node_fname = n->local.lto_file_data->file_name;\n+      if (fname == NULL)\n+\t{\n+\t  fname = strip_extension (node_fname);\n+\t  continue;\n+\t}\n \n-\t  f = strip_extension (lbasename (node_fname));\n+      f = strip_extension (lbasename (node_fname));\n \n-\t  /* If the new name causes an excessively long file name,\n-\t     make the last component \"___\" to indicate overflow.  */\n-\t  if (strlen (fname) + strlen (f) > max_fname_len - 3)\n-\t    {\n-\t      fname = reconcat (fname, fname, \"___\", NULL);\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      fname = reconcat (fname, fname, \"_\", f, NULL);\n-\t      free (f);\n-\t    }\n+      /* If the new name causes an excessively long file name,\n+\t make the last component \"___\" to indicate overflow.  */\n+      if (strlen (fname) + strlen (f) > max_fname_len - 3)\n+\t{\n+\t  fname = reconcat (fname, fname, \"___\", NULL);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  fname = reconcat (fname, fname, \"_\", f, NULL);\n+\t  free (f);\n \t}\n+    }\n \n-      pointer_set_destroy (pset);\n+  pointer_set_destroy (pset);\n \n-      /* Add the extension .wpa.o to indicate that this file has been\n-\t produced by WPA.  */\n-      fname = reconcat (fname, fname, \".wpa.o\", NULL);\n-      gcc_assert (fname);\n-    }\n-  else\n+  if (!fname)\n     {\n       /* Since SET does not need to be processed by LTRANS, use\n \t the original file name and mark it with a '*' prefix so that\n@@ -876,6 +869,13 @@ get_filename_for_set (cgraph_node_set set)\n       struct cgraph_node *first = csi_node (si);\n       fname = prefix_name_with_star (first->local.lto_file_data->file_name);\n     }\n+  else\n+    {\n+      /* Add the extension .wpa.o to indicate that this file has been\n+\t produced by WPA.  */\n+      fname = reconcat (fname, fname, \".wpa.o\", NULL);\n+      gcc_assert (fname);\n+    }\n \n   return fname;\n }\n@@ -933,7 +933,7 @@ lto_wpa_write_files (void)\n       temp_filename = get_filename_for_set (set);\n       output_files[i] = temp_filename;\n \n-      if (cgraph_node_set_needs_ltrans_p (set))\n+      if (cgraph_node_set_nonempty_p (set) || varpool_node_set_nonempty_p (vset))\n \t{\n \t  /* Write all the nodes in SET to TEMP_FILENAME.  */\n \t  file = lto_obj_file_open (temp_filename, true);"}]}