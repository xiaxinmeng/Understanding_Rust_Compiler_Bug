{"sha": "fb81a61b15689be318482bdecb8bbbb2017523ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI4MWE2MWIxNTY4OWJlMzE4NDgyYmRlY2I4YmJiYjIwMTc1MjNlZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-04-13T08:04:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-04-13T08:04:52Z"}, "message": "re PR c++/69953 (Using lto causes gtkmm/gparted and gtkmm/inkscape compile to fail)\n\n\tPR lto/69953 \n\t* ipa-visibility.c (non_local_p): Fix typos.\n\t(localize_node): When localizing symbol in same comdat group,\n\tdissolve the group only when we know external symbols are going\n\tto be privatized.\n\t(function_and_variable_visibility): Do not localize DECL_EXTERNAL.\n\nFrom-SVN: r246899", "tree": {"sha": "2694a0cced121412469ebccb812aa5b72e3da568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2694a0cced121412469ebccb812aa5b72e3da568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb81a61b15689be318482bdecb8bbbb2017523ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb81a61b15689be318482bdecb8bbbb2017523ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb81a61b15689be318482bdecb8bbbb2017523ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb81a61b15689be318482bdecb8bbbb2017523ed/comments", "author": null, "committer": null, "parents": [{"sha": "8da3e6995ee3bd5bd2a6966ffceb356ea4768097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da3e6995ee3bd5bd2a6966ffceb356ea4768097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da3e6995ee3bd5bd2a6966ffceb356ea4768097"}], "stats": {"total": 47, "additions": 43, "deletions": 4}, "files": [{"sha": "3154103579ff15f395dcb5df00508e9cd956ce99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb81a61b15689be318482bdecb8bbbb2017523ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb81a61b15689be318482bdecb8bbbb2017523ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb81a61b15689be318482bdecb8bbbb2017523ed", "patch": "@@ -1,3 +1,12 @@\n+2017-04-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/69953 \n+\t* ipa-visibility.c (non_local_p): Fix typos.\n+\t(localize_node): When localizing symbol in same comdat group,\n+\tdissolve the group only when we know external symbols are going\n+\tto be privatized.\n+\t(function_and_variable_visibility): Do not localize DECL_EXTERNAL.\n+\n 2017-04-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/79390"}, {"sha": "d5a3ae56c46ee02b1a2109fe14732ec5cdc147b8", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb81a61b15689be318482bdecb8bbbb2017523ed/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb81a61b15689be318482bdecb8bbbb2017523ed/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=fb81a61b15689be318482bdecb8bbbb2017523ed", "patch": "@@ -90,8 +90,8 @@ static bool\n non_local_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n   return !(node->only_called_directly_or_aliased_p ()\n-\t   /* i386 would need update to output thunk with locak calling\n-\t      ocnvetions.  */\n+\t   /* i386 would need update to output thunk with local calling\n+\t      convetions.  */\n \t   && !node->thunk.thunk_p\n \t   && node->definition\n \t   && !DECL_EXTERNAL (node->decl)\n@@ -153,7 +153,7 @@ comdat_can_be_unshared_p_1 (symtab_node *node)\n /* COMDAT functions must be shared only if they have address taken,\n    otherwise we can produce our own private implementation with\n    -fwhole-program.  \n-   Return true when turning COMDAT functoin static can not lead to wrong\n+   Return true when turning COMDAT function static can not lead to wrong\n    code when the resulting object links with a library defining same COMDAT.\n \n    Virtual functions do have their addresses taken from the vtables,\n@@ -537,6 +537,35 @@ localize_node (bool whole_program, symtab_node *node)\n {\n   gcc_assert (whole_program || in_lto_p || !TREE_PUBLIC (node->decl));\n \n+  /* It is possible that one comdat group contains both hidden and non-hidden\n+     symbols.  In this case we can privatize all hidden symbol but we need\n+     to keep non-hidden exported.  */\n+  if (node->same_comdat_group\n+      && node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    {\n+      symtab_node *next;\n+      for (next = node->same_comdat_group;\n+\t   next != node; next = next->same_comdat_group)\n+\tif (next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n+\t    || next->resolution == LDPR_PREVAILING_DEF)\n+\t  break;\n+      if (node != next)\n+\t{\n+\t  if (!node->transparent_alias)\n+\t    {\n+\t      node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t      node->make_decl_local ();\n+\t      if (!flag_incremental_link)\n+\t        node->unique_name |= true;\n+\t      return;\n+\t    }\n+\t}\n+    }\n+  /* For similar reason do not privatize whole comdat when seeing comdat\n+     local.  Wait for non-comdat symbol to be privatized first.  */\n+  if (node->comdat_local_p ())\n+    return;\n+\n   if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n     {\n       for (symtab_node *next = node->same_comdat_group;\n@@ -765,7 +794,8 @@ function_and_variable_visibility (bool whole_program)\n \tvnode->no_reorder = 1;\n \n       if (!vnode->externally_visible\n-\t  && !vnode->transparent_alias)\n+\t  && !vnode->transparent_alias\n+\t  && !DECL_EXTERNAL (vnode->decl))\n \tlocalize_node (whole_program, vnode);\n \n       update_visibility_by_resolution_info (vnode);"}]}