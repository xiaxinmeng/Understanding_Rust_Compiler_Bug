{"sha": "93188a0b5933e138ca8c4863af5b0cfc142325f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMxODhhMGI1OTMzZTEzOGNhOGM0ODYzYWY1YjBjZmMxNDIzMjVmMw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-09-10T12:48:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-10T12:48:35Z"}, "message": "exp_ch3.adb (Predef_Spec_Or_Body): When the type is abstract, only create an abstract subprogram in the case of 'Input.\n\n2007-09-10  Gary Dismukes  <dismukes@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch3.adb (Predef_Spec_Or_Body): When the type is abstract, only\n\tcreate an abstract subprogram in the case of 'Input. For 'Output we now\n\tcreate a real spec/body when the type is abstract, since it can\n\tpotentially be called.\n\t(Predefined_Primitive_Bodies): Now allow the creation of a predefined\n\tbody for 'Output when the type is abstract (only the creation of the\n\tbody for 'Input is excluded when the type is abstract).\n\t(Stream_Operation_OK): Add an additional condition in the return\n\tstatement, so that False will be returned for TTS_Stream_Input if the\n\tassociated tagged type is an abstract extension. Add comments for\n\treturn statement.\n\t(Expand_N_Object_Declaration): For the case of a shared passive\n\tvariable, insert init proc call only after the shared variable\n\tprocedures have been processed, because the IP call needs to undergo\n\tshared passive variable reference expansion, which requires these\n\tprocedures to be available (and elaborated).\n\nFrom-SVN: r128335", "tree": {"sha": "ae8baeb331bcedc03406ac0c15b0bd03cb4167b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae8baeb331bcedc03406ac0c15b0bd03cb4167b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93188a0b5933e138ca8c4863af5b0cfc142325f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93188a0b5933e138ca8c4863af5b0cfc142325f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93188a0b5933e138ca8c4863af5b0cfc142325f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93188a0b5933e138ca8c4863af5b0cfc142325f3/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/094f05440704449bcfaa13fa1da6c6d80ed6ddc4"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "e2569ff0d4dcc2699758719feddd5525353b1cfe", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93188a0b5933e138ca8c4863af5b0cfc142325f3/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93188a0b5933e138ca8c4863af5b0cfc142325f3/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=93188a0b5933e138ca8c4863af5b0cfc142325f3", "patch": "@@ -10,14 +10,13 @@\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n -- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n -- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n@@ -4041,6 +4040,12 @@ package body Exp_Ch3 is\n       New_Ref  : Node_Id;\n       BIP_Call : Boolean := False;\n \n+      Init_After : Node_Id := N;\n+      --  Node after which the init proc call is to be inserted. This is\n+      --  normally N, except for the case of a shared passive variable, in\n+      --  which case the init proc call must be inserted only after the bodies\n+      --  of the shared variable procedures have been seen.\n+\n    begin\n       --  Don't do anything for deferred constants. All proper actions will\n       --  be expanded during the full declaration.\n@@ -4079,7 +4084,7 @@ package body Exp_Ch3 is\n       --  Make shared memory routines for shared passive variable\n \n       if Is_Shared_Passive (Def_Id) then\n-         Make_Shared_Var_Procs (N);\n+         Init_After := Make_Shared_Var_Procs (N);\n       end if;\n \n       --  If tasks being declared, make sure we have an activation chain\n@@ -4127,7 +4132,7 @@ package body Exp_Ch3 is\n          elsif not Abort_Allowed\n            or else not Comes_From_Source (N)\n          then\n-            Insert_Actions_After (N,\n+            Insert_Actions_After (Init_After,\n               Make_Init_Call (\n                 Ref         => New_Occurrence_Of (Def_Id, Loc),\n                 Typ         => Base_Type (Typ),\n@@ -4168,7 +4173,7 @@ package body Exp_Ch3 is\n                Prepend_To (L, Build_Runtime_Call (Loc, RE_Abort_Defer));\n                Set_At_End_Proc (Handled_Statement_Sequence (Blk),\n                  New_Occurrence_Of (RTE (RE_Abort_Undefer_Direct), Loc));\n-               Insert_Actions_After (N, New_List (Blk));\n+               Insert_Actions_After (Init_After, New_List (Blk));\n                Expand_At_End_Handler\n                  (Handled_Statement_Sequence (Blk), Entity (Identifier (Blk)));\n             end;\n@@ -4220,7 +4225,7 @@ package body Exp_Ch3 is\n                else\n                   Initialization_Warning (Id_Ref);\n \n-                  Insert_Actions_After (N,\n+                  Insert_Actions_After (Init_After,\n                     Build_Initialization_Call (Loc, Id_Ref, Typ));\n                end if;\n             end;\n@@ -4441,7 +4446,7 @@ package body Exp_Ch3 is\n               and then not Is_Limited_Type (Typ)\n               and then not BIP_Call\n             then\n-               Insert_Actions_After (N,\n+               Insert_Actions_After (Init_After,\n                  Make_Adjust_Call (\n                    Ref          => New_Reference_To (Def_Id, Loc),\n                    Typ          => Base_Type (Typ),\n@@ -4475,7 +4480,7 @@ package body Exp_Ch3 is\n \n                Set_Assignment_OK (New_Ref);\n \n-               Insert_After (N,\n+               Insert_After (Init_After,\n                  Make_Assignment_Statement (Loc,\n                    Name => New_Ref,\n                    Expression =>\n@@ -4544,8 +4549,7 @@ package body Exp_Ch3 is\n                Set_No_Initialization (N);\n                Set_Assignment_OK (Name (Stat));\n                Set_No_Ctrl_Actions (Stat);\n-               Insert_After (N, Stat);\n-               Analyze (Stat);\n+               Insert_After_And_Analyze (Init_After, Stat);\n             end;\n          end if;\n       end if;\n@@ -7685,14 +7689,12 @@ package body Exp_Ch3 is\n       if For_Body then\n          return Make_Subprogram_Body (Loc, Spec, Empty_List, Empty);\n \n-      --  For the case of Input/Output attributes applied to an abstract type,\n-      --  generate abstract specifications. These will never be called, but we\n-      --  need the slots allocated in the dispatching table so that attributes\n+      --  For the case of an Input attribute predefined for an abstract type,\n+      --  generate an abstract specification. This will never be called, but we\n+      --  need the slot allocated in the dispatching table so that attributes\n       --  typ'Class'Input and typ'Class'Output will work properly.\n \n-      elsif (Is_TSS (Name, TSS_Stream_Input)\n-              or else\n-             Is_TSS (Name, TSS_Stream_Output))\n+      elsif Is_TSS (Name, TSS_Stream_Input)\n         and then Is_Abstract_Type (Tag_Typ)\n       then\n          return Make_Abstract_Subprogram_Declaration (Loc, Spec);\n@@ -7835,25 +7837,24 @@ package body Exp_Ch3 is\n          Append_To (Res, Decl);\n       end if;\n \n-      --  Skip bodies of _Input and _Output for the abstract case, since the\n-      --  corresponding specs are abstract (see Predef_Spec_Or_Body).\n+      --  Skip body of _Input for the abstract case, since the corresponding\n+      --  spec is abstract (see Predef_Spec_Or_Body).\n \n-      if not Is_Abstract_Type (Tag_Typ) then\n-         if Stream_Operation_OK (Tag_Typ, TSS_Stream_Input)\n-           and then No (TSS (Tag_Typ, TSS_Stream_Input))\n-         then\n-            Build_Record_Or_Elementary_Input_Function\n-              (Loc, Tag_Typ, Decl, Ent);\n-            Append_To (Res, Decl);\n-         end if;\n+      if not Is_Abstract_Type (Tag_Typ)\n+        and then Stream_Operation_OK (Tag_Typ, TSS_Stream_Input)\n+        and then No (TSS (Tag_Typ, TSS_Stream_Input))\n+      then\n+         Build_Record_Or_Elementary_Input_Function\n+           (Loc, Tag_Typ, Decl, Ent);\n+         Append_To (Res, Decl);\n+      end if;\n \n-         if Stream_Operation_OK (Tag_Typ, TSS_Stream_Output)\n-           and then No (TSS (Tag_Typ, TSS_Stream_Output))\n-         then\n-            Build_Record_Or_Elementary_Output_Procedure\n-              (Loc, Tag_Typ, Decl, Ent);\n-            Append_To (Res, Decl);\n-         end if;\n+      if Stream_Operation_OK (Tag_Typ, TSS_Stream_Output)\n+        and then No (TSS (Tag_Typ, TSS_Stream_Output))\n+      then\n+         Build_Record_Or_Elementary_Output_Procedure\n+           (Loc, Tag_Typ, Decl, Ent);\n+         Append_To (Res, Decl);\n       end if;\n \n       --  Ada 2005: Generate bodies for the following primitive operations for\n@@ -8137,8 +8138,27 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n+      --  If the type is not limited, or else is limited but the attribute is\n+      --  explicitly specified or is predefined for the type, then return True,\n+      --  unless other conditions prevail, such as restrictions prohibiting\n+      --  streams or dispatching operations.\n+\n+      --  We exclude the Input operation from being a predefined subprogram in\n+      --  the case where the associated type is an abstract extension, because\n+      --  the attribute is not callable in that case, per 13.13.2(49/2). Also,\n+      --  we don't want an abstract version created because types derived from\n+      --  the abstract type may not even have Input available (for example if\n+      --  derived from a private view of the abstract type that doesn't have\n+      --  a visible Input), but a VM such as .NET or the Java VM can treat the\n+      --  operation as inherited anyway, and we don't want an abstract function\n+      --  to be (implicitly) inherited in that case because it can lead to a VM\n+      --  exception.\n+\n       return (not Is_Limited_Type (Typ)\n                or else Has_Predefined_Or_Specified_Stream_Attribute)\n+        and then (Operation /= TSS_Stream_Input\n+                   or else not Is_Abstract_Type (Typ)\n+                   or else not Is_Derived_Type (Typ))\n         and then not Has_Unknown_Discriminants (Typ)\n         and then not (Is_Interface (Typ)\n                        and then (Is_Task_Interface (Typ)"}]}