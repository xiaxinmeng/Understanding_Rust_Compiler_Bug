{"sha": "a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY0YzczYTJmMDBhYjRhYjZhNzQ4NWIzNDYyNmQwN2VhMmIyZDUxOQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2015-09-20T16:34:44Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-09-20T16:34:44Z"}, "message": "[AArch64][1/5] Reimplement aarch64_bitmask_imm\n\n2015-09-20  Wilco Dijkstra  <wdijkstr@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_bitmask_imm): Reimplement using\n\tfaster algorithm.\n\nFrom-SVN: r227946", "tree": {"sha": "23aac25dd7cebb695bd64a8b8947c7507294268f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23aac25dd7cebb695bd64a8b8947c7507294268f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519/comments", "author": null, "committer": null, "parents": [{"sha": "e4bdea2f3092425ace1a883d9c496786fdef5719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4bdea2f3092425ace1a883d9c496786fdef5719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4bdea2f3092425ace1a883d9c496786fdef5719"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "9810ec6e345745e43b3417853992e30c77ad90a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "patch": "@@ -1,3 +1,8 @@\n+2015-09-20  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_bitmask_imm): Reimplement using\n+\tfaster algorithm.\n+\n 2015-09-20  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/47679"}, {"sha": "2e7b9ec0567bbcfd1ae8f3cb424862f26949bdb8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "patch": "@@ -3405,19 +3405,63 @@ aarch64_movw_imm (HOST_WIDE_INT val, machine_mode mode)\n \t  || (val & (((HOST_WIDE_INT) 0xffff) << 16)) == val);\n }\n \n+/* Multipliers for repeating bitmasks of width 32, 16, 8, 4, and 2.  */\n+\n+static const unsigned HOST_WIDE_INT bitmask_imm_mul[] =\n+  {\n+    0x0000000100000001ull,\n+    0x0001000100010001ull,\n+    0x0101010101010101ull,\n+    0x1111111111111111ull,\n+    0x5555555555555555ull,\n+  };\n+\n \n /* Return true if val is a valid bitmask immediate.  */\n+\n bool\n-aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode mode)\n+aarch64_bitmask_imm (HOST_WIDE_INT val_in, machine_mode mode)\n {\n-  if (GET_MODE_SIZE (mode) < 8)\n-    {\n-      /* Replicate bit pattern.  */\n-      val &= (HOST_WIDE_INT) 0xffffffff;\n-      val |= val << 32;\n-    }\n-  return bsearch (&val, aarch64_bitmasks, AARCH64_NUM_BITMASKS,\n-\t\t  sizeof (aarch64_bitmasks[0]), aarch64_bitmasks_cmp) != NULL;\n+  unsigned HOST_WIDE_INT val, tmp, mask, first_one, next_one;\n+  int bits;\n+\n+  /* Check for a single sequence of one bits and return quickly if so.\n+     The special cases of all ones and all zeroes returns false.  */\n+  val = (unsigned HOST_WIDE_INT) val_in;\n+  tmp = val + (val & -val);\n+\n+  if (tmp == (tmp & -tmp))\n+    return (val + 1) > 1;\n+\n+  /* Replicate 32-bit immediates so we can treat them as 64-bit.  */\n+  if (mode == SImode)\n+    val = (val << 32) | (val & 0xffffffff);\n+\n+  /* Invert if the immediate doesn't start with a zero bit - this means we\n+     only need to search for sequences of one bits.  */\n+  if (val & 1)\n+    val = ~val;\n+\n+  /* Find the first set bit and set tmp to val with the first sequence of one\n+     bits removed.  Return success if there is a single sequence of ones.  */\n+  first_one = val & -val;\n+  tmp = val & (val + first_one);\n+\n+  if (tmp == 0)\n+    return true;\n+\n+  /* Find the next set bit and compute the difference in bit position.  */\n+  next_one = tmp & -tmp;\n+  bits = clz_hwi (first_one) - clz_hwi (next_one);\n+  mask = val ^ tmp;\n+\n+  /* Check the bit position difference is a power of 2, and that the first\n+     sequence of one bits fits within 'bits' bits.  */\n+  if ((mask >> bits) != 0 || bits != (bits & -bits))\n+    return false;\n+\n+  /* Check the sequence of one bits is repeated 64/bits times.  */\n+  return val == mask * bitmask_imm_mul[__builtin_clz (bits) - 26];\n }\n \n "}]}