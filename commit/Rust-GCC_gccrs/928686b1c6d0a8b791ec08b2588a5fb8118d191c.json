{"sha": "928686b1c6d0a8b791ec08b2588a5fb8118d191c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4Njg2YjFjNmQwYThiNzkxZWMwOGIyNTg4YTVmYjgxMThkMTkxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:42:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:42:12Z"}, "message": "poly_int: TYPE_VECTOR_SUBPARTS\n\nThis patch changes TYPE_VECTOR_SUBPARTS to a poly_uint64.  The value is\nencoded in the 10-bit precision field and was previously always stored\nas a simple log2 value.  The challenge was to use this 10 bits to\nencode the number of elements in variable-length vectors, so that\nwe didn't need to increase the size of the tree.\n\nIn practice the number of vector elements should always have the form\nN + N * X (where X is the runtime value), and as for constant-length\nvectors, N must be a power of 2 (even though X itself might not be).\nThe patch therefore uses the low 8 bits to encode log2(N) and bit\n8 to select between constant-length and variable-length vectors.\nTargets without variable-length vectors continue to use the old scheme.\n\nA new valid_vector_subparts_p function tests whether a given number\nof elements can be encoded.  This is false for the vector modes that\nrepresent an LD3 or ST3 vector triple (which we want to treat as arrays\nof vectors rather than single vectors).\n\nMost of the patch is mechanical; previous patches handled the changes\nthat weren't entirely straightforward.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree.h (TYPE_VECTOR_SUBPARTS): Turn into a function and handle\n\tpolynomial numbers of units.\n\t(SET_TYPE_VECTOR_SUBPARTS): Likewise.\n\t(valid_vector_subparts_p): New function.\n\t(build_vector_type): Remove temporary shim and take the number\n\tof units as a poly_uint64 rather than an int.\n\t(build_opaque_vector_type): Take the number of units as a\n\tpoly_uint64 rather than an int.\n\t* tree.c (build_vector_from_ctor): Handle polynomial\n\tTYPE_VECTOR_SUBPARTS.\n\t(type_hash_canon_hash, type_cache_hasher::equal): Likewise.\n\t(uniform_vector_p, vector_type_mode, build_vector): Likewise.\n\t(build_vector_from_val): If the number of units is variable,\n\tuse build_vec_duplicate_cst for constant operands and\n\tVEC_DUPLICATE_EXPR otherwise.\n\t(make_vector_type): Remove temporary is_constant ().\n\t(build_vector_type, build_opaque_vector_type): Take the number of\n\tunits as a poly_uint64 rather than an int.\n\t(check_vector_cst): Handle polynomial TYPE_VECTOR_SUBPARTS and\n\tVECTOR_CST_NELTS.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* expr.c (count_type_elements, categorize_ctor_elements_1): Likewise.\n\t(store_constructor, expand_expr_real_1): Likewise.\n\t(const_scalar_mask_from_tree): Likewise.\n\t* fold-const-call.c (fold_const_reduction): Likewise.\n\t* fold-const.c (const_binop, const_unop, fold_convert_const): Likewise.\n\t(operand_equal_p, fold_vec_perm, fold_ternary_loc): Likewise.\n\t(native_encode_vector, vec_cst_ctor_to_array): Likewise.\n\t(fold_relational_const): Likewise.\n\t(native_interpret_vector): Likewise.  Change the size from an\n\tint to an unsigned int.\n\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Handle polynomial\n\tTYPE_VECTOR_SUBPARTS.\n\t(gimple_fold_indirect_ref, gimple_build_vector): Likewise.\n\t(gimple_build_vector_from_val): Use VEC_DUPLICATE_EXPR when\n\tduplicating a non-constant operand into a variable-length vector.\n\t* hsa-brig.c (hsa_op_immed::emit_to_buffer): Handle polynomial\n\tTYPE_VECTOR_SUBPARTS and VECTOR_CST_NELTS.\n\t* ipa-icf.c (sem_variable::equals): Likewise.\n\t* match.pd: Likewise.\n\t* omp-simd-clone.c (simd_clone_subparts): Likewise.\n\t* print-tree.c (print_node): Likewise.\n\t* stor-layout.c (layout_type): Likewise.\n\t* targhooks.c (default_builtin_vectorization_cost): Likewise.\n\t* tree-cfg.c (verify_gimple_comparison): Likewise.\n\t(verify_gimple_assign_binary): Likewise.\n\t(verify_gimple_assign_ternary): Likewise.\n\t(verify_gimple_assign_single): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n\t(simplify_bitfield_ref, is_combined_permutation_identity): Likewise.\n\t* tree-vect-data-refs.c (vect_permute_store_chain): Likewise.\n\t(vect_grouped_load_supported, vect_permute_load_chain): Likewise.\n\t(vect_shift_permute_load_chain): Likewise.\n\t* tree-vect-generic.c (nunits_for_known_piecewise_op): Likewise.\n\t(expand_vector_condition, optimize_vector_constructor): Likewise.\n\t(lower_vec_perm, get_compute_type): Likewise.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n\t(get_initial_defs_for_reduction, vect_transform_loop): Likewise.\n\t* tree-vect-patterns.c (vect_recog_bool_pattern): Likewise.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\t* tree-vect-slp.c (vect_supported_load_permutation_p): Likewise.\n\t(vect_get_constant_vectors, vect_transform_slp_perm_load): Likewise.\n\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n\t(get_group_load_store_type, vectorizable_mask_load_store): Likewise.\n\t(vectorizable_bswap, simd_clone_subparts, vectorizable_assignment)\n\t(vectorizable_shift, vectorizable_operation, vectorizable_store)\n\t(vectorizable_load, vect_is_simple_cond, vectorizable_comparison)\n\t(supportable_widening_operation): Likewise.\n\t(supportable_narrowing_operation): Likewise.\n\t* tree-vector-builder.c (tree_vector_builder::binary_encoded_nelts):\n\tLikewise.\n\t* varasm.c (output_constant): Likewise.\n\ngcc/ada/\n\t* gcc-interface/utils.c (gnat_types_compatible_p): Handle\n\tpolynomial TYPE_VECTOR_SUBPARTS.\n\ngcc/brig/\n\t* brigfrontend/brig-to-generic.cc (get_unsigned_int_type): Handle\n\tpolynomial TYPE_VECTOR_SUBPARTS.\n\t* brigfrontend/brig-util.h (gccbrig_type_vector_subparts): Likewise.\n\ngcc/c-family/\n\t* c-common.c (vector_types_convertible_p, c_build_vec_perm_expr)\n\t(convert_vector_to_array_for_subscript): Handle polynomial\n\tTYPE_VECTOR_SUBPARTS.\n\t(c_common_type_for_mode): Check valid_vector_subparts_p.\n\t* c-pretty-print.c (pp_c_initializer_list): Handle polynomial\n\tVECTOR_CST_NELTS.\n\ngcc/c/\n\t* c-typeck.c (comptypes_internal, build_binary_op): Handle polynomial\n\tTYPE_VECTOR_SUBPARTS.\n\ngcc/cp/\n\t* constexpr.c (cxx_eval_array_reference): Handle polynomial\n\tVECTOR_CST_NELTS.\n\t(cxx_fold_indirect_ref): Handle polynomial TYPE_VECTOR_SUBPARTS.\n\t* call.c (build_conditional_expr_1): Likewise.\n\t* decl.c (cp_finish_decomp): Likewise.\n\t* mangle.c (write_type): Likewise.\n\t* typeck.c (structural_comptypes): Likewise.\n\t(cp_build_binary_op): Likewise.\n\t* typeck2.c (process_init_constructor_array): Likewise.\n\ngcc/fortran/\n\t* trans-types.c (gfc_type_for_mode): Check valid_vector_subparts_p.\n\ngcc/lto/\n\t* lto-lang.c (lto_type_for_mode): Check valid_vector_subparts_p.\n\t* lto.c (hash_canonical_type): Handle polynomial TYPE_VECTOR_SUBPARTS.\n\ngcc/go/\n\t* go-lang.c (go_langhook_type_for_mode): Check valid_vector_subparts_p.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256197", "tree": {"sha": "88cbf9a40cb8344238ea471bb4c046691b5a1e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88cbf9a40cb8344238ea471bb4c046691b5a1e40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/928686b1c6d0a8b791ec08b2588a5fb8118d191c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928686b1c6d0a8b791ec08b2588a5fb8118d191c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928686b1c6d0a8b791ec08b2588a5fb8118d191c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928686b1c6d0a8b791ec08b2588a5fb8118d191c/comments", "author": null, "committer": null, "parents": [{"sha": "edab8e10e3cc127335ae4fa7a5935a28acfae0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edab8e10e3cc127335ae4fa7a5935a28acfae0a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edab8e10e3cc127335ae4fa7a5935a28acfae0a9"}], "stats": {"total": 870, "additions": 582, "deletions": 288}, "files": [{"sha": "75099e3f43689eebc31243776e9479d18a6a86ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,81 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree.h (TYPE_VECTOR_SUBPARTS): Turn into a function and handle\n+\tpolynomial numbers of units.\n+\t(SET_TYPE_VECTOR_SUBPARTS): Likewise.\n+\t(valid_vector_subparts_p): New function.\n+\t(build_vector_type): Remove temporary shim and take the number\n+\tof units as a poly_uint64 rather than an int.\n+\t(build_opaque_vector_type): Take the number of units as a\n+\tpoly_uint64 rather than an int.\n+\t* tree.c (build_vector_from_ctor): Handle polynomial\n+\tTYPE_VECTOR_SUBPARTS.\n+\t(type_hash_canon_hash, type_cache_hasher::equal): Likewise.\n+\t(uniform_vector_p, vector_type_mode, build_vector): Likewise.\n+\t(build_vector_from_val): If the number of units is variable,\n+\tuse build_vec_duplicate_cst for constant operands and\n+\tVEC_DUPLICATE_EXPR otherwise.\n+\t(make_vector_type): Remove temporary is_constant ().\n+\t(build_vector_type, build_opaque_vector_type): Take the number of\n+\tunits as a poly_uint64 rather than an int.\n+\t(check_vector_cst): Handle polynomial TYPE_VECTOR_SUBPARTS and\n+\tVECTOR_CST_NELTS.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* expr.c (count_type_elements, categorize_ctor_elements_1): Likewise.\n+\t(store_constructor, expand_expr_real_1): Likewise.\n+\t(const_scalar_mask_from_tree): Likewise.\n+\t* fold-const-call.c (fold_const_reduction): Likewise.\n+\t* fold-const.c (const_binop, const_unop, fold_convert_const): Likewise.\n+\t(operand_equal_p, fold_vec_perm, fold_ternary_loc): Likewise.\n+\t(native_encode_vector, vec_cst_ctor_to_array): Likewise.\n+\t(fold_relational_const): Likewise.\n+\t(native_interpret_vector): Likewise.  Change the size from an\n+\tint to an unsigned int.\n+\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Handle polynomial\n+\tTYPE_VECTOR_SUBPARTS.\n+\t(gimple_fold_indirect_ref, gimple_build_vector): Likewise.\n+\t(gimple_build_vector_from_val): Use VEC_DUPLICATE_EXPR when\n+\tduplicating a non-constant operand into a variable-length vector.\n+\t* hsa-brig.c (hsa_op_immed::emit_to_buffer): Handle polynomial\n+\tTYPE_VECTOR_SUBPARTS and VECTOR_CST_NELTS.\n+\t* ipa-icf.c (sem_variable::equals): Likewise.\n+\t* match.pd: Likewise.\n+\t* omp-simd-clone.c (simd_clone_subparts): Likewise.\n+\t* print-tree.c (print_node): Likewise.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t* targhooks.c (default_builtin_vectorization_cost): Likewise.\n+\t* tree-cfg.c (verify_gimple_comparison): Likewise.\n+\t(verify_gimple_assign_binary): Likewise.\n+\t(verify_gimple_assign_ternary): Likewise.\n+\t(verify_gimple_assign_single): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n+\t(simplify_bitfield_ref, is_combined_permutation_identity): Likewise.\n+\t* tree-vect-data-refs.c (vect_permute_store_chain): Likewise.\n+\t(vect_grouped_load_supported, vect_permute_load_chain): Likewise.\n+\t(vect_shift_permute_load_chain): Likewise.\n+\t* tree-vect-generic.c (nunits_for_known_piecewise_op): Likewise.\n+\t(expand_vector_condition, optimize_vector_constructor): Likewise.\n+\t(lower_vec_perm, get_compute_type): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n+\t(get_initial_defs_for_reduction, vect_transform_loop): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_bool_pattern): Likewise.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\t* tree-vect-slp.c (vect_supported_load_permutation_p): Likewise.\n+\t(vect_get_constant_vectors, vect_transform_slp_perm_load): Likewise.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n+\t(get_group_load_store_type, vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_bswap, simd_clone_subparts, vectorizable_assignment)\n+\t(vectorizable_shift, vectorizable_operation, vectorizable_store)\n+\t(vectorizable_load, vect_is_simple_cond, vectorizable_comparison)\n+\t(supportable_widening_operation): Likewise.\n+\t(supportable_narrowing_operation): Likewise.\n+\t* tree-vector-builder.c (tree_vector_builder::binary_encoded_nelts):\n+\tLikewise.\n+\t* varasm.c (output_constant): Likewise.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "aeb2115f9626a68bc2ed583b756bc08408ff5189", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/utils.c (gnat_types_compatible_p): Handle\n+\tpolynomial TYPE_VECTOR_SUBPARTS.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "5d03585a5558b2afefe0a39c7caca985b64e77b9", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -3561,7 +3561,7 @@ gnat_types_compatible_p (tree t1, tree t2)\n   /* Vector types are also compatible if they have the same number of subparts\n      and the same form of (scalar) element type.  */\n   if (code == VECTOR_TYPE\n-      && TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n+      && known_eq (TYPE_VECTOR_SUBPARTS (t1), TYPE_VECTOR_SUBPARTS (t2))\n       && TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2))\n       && TYPE_PRECISION (TREE_TYPE (t1)) == TYPE_PRECISION (TREE_TYPE (t2)))\n     return 1;"}, {"sha": "7805b99e1b76b93778c8fc7eb923599a64c5e97d", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* brigfrontend/brig-to-generic.cc (get_unsigned_int_type): Handle\n+\tpolynomial TYPE_VECTOR_SUBPARTS.\n+\t* brigfrontend/brig-util.h (gccbrig_type_vector_subparts): Likewise.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "f644db81ecbd531d38974854416bd5eb60b53fef", "filename": "gcc/brig/brigfrontend/brig-to-generic.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -913,7 +913,7 @@ get_unsigned_int_type (tree original_type)\n     {\n       size_t esize\n \t= int_size_in_bytes (TREE_TYPE (original_type)) * BITS_PER_UNIT;\n-      size_t ecount = TYPE_VECTOR_SUBPARTS (original_type);\n+      poly_uint64 ecount = TYPE_VECTOR_SUBPARTS (original_type);\n       return build_vector_type (build_nonstandard_integer_type (esize, true),\n \t\t\t\tecount);\n     }"}, {"sha": "6de0fa5dd0c06134ff66cbf5be299ada3cc0501e", "filename": "gcc/brig/brigfrontend/brig-util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -112,7 +112,7 @@ void gccbrig_print_reg_use_info (FILE *dump, const regs_use_index &info);\n inline unsigned HOST_WIDE_INT\n gccbrig_type_vector_subparts (const_tree type)\n {\n-  return TYPE_VECTOR_SUBPARTS (type);\n+  return TYPE_VECTOR_SUBPARTS (type).to_constant ();\n }\n \n #endif"}, {"sha": "ab8f51767a48bd665cffd48efab92da3c3e4c5b3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,14 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-common.c (vector_types_convertible_p, c_build_vec_perm_expr)\n+\t(convert_vector_to_array_for_subscript): Handle polynomial\n+\tTYPE_VECTOR_SUBPARTS.\n+\t(c_common_type_for_mode): Check valid_vector_subparts_p.\n+\t* c-pretty-print.c (pp_c_initializer_list): Handle polynomial\n+\tVECTOR_CST_NELTS.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "cebd1b871d1a1f1e6dce80b2409ae776be0201bf", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -940,15 +940,16 @@ vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note)\n \n   convertible_lax =\n     (tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n-     && (TREE_CODE (TREE_TYPE (t1)) != REAL_TYPE ||\n-\t TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2))\n+     && (TREE_CODE (TREE_TYPE (t1)) != REAL_TYPE\n+\t || known_eq (TYPE_VECTOR_SUBPARTS (t1),\n+\t\t      TYPE_VECTOR_SUBPARTS (t2)))\n      && (INTEGRAL_TYPE_P (TREE_TYPE (t1))\n \t == INTEGRAL_TYPE_P (TREE_TYPE (t2))));\n \n   if (!convertible_lax || flag_lax_vector_conversions)\n     return convertible_lax;\n \n-  if (TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n+  if (known_eq (TYPE_VECTOR_SUBPARTS (t1), TYPE_VECTOR_SUBPARTS (t2))\n       && lang_hooks.types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n     return true;\n \n@@ -1016,10 +1017,10 @@ c_build_vec_perm_expr (location_t loc, tree v0, tree v1, tree mask,\n       return error_mark_node;\n     }\n \n-  if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (v0))\n-      != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask))\n-      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (v1))\n-\t != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask)))\n+  if (maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (v0)),\n+\t\tTYPE_VECTOR_SUBPARTS (TREE_TYPE (mask)))\n+      && maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (v1)),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask))))\n     {\n       if (complain)\n \terror_at (loc, \"__builtin_shuffle number of elements of the \"\n@@ -2278,7 +2279,8 @@ c_common_type_for_mode (machine_mode mode, int unsignedp)\n       if (inner_type != NULL_TREE)\n \treturn build_complex_type (inner_type);\n     }\n-  else if (VECTOR_MODE_P (mode))\n+  else if (VECTOR_MODE_P (mode)\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {\n       machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = c_common_type_for_mode (inner_mode, unsignedp);\n@@ -7660,7 +7662,7 @@ convert_vector_to_array_for_subscript (location_t loc,\n \n       if (TREE_CODE (index) == INTEGER_CST)\n         if (!tree_fits_uhwi_p (index)\n-            || tree_to_uhwi (index) >= TYPE_VECTOR_SUBPARTS (type))\n+\t    || maybe_ge (tree_to_uhwi (index), TYPE_VECTOR_SUBPARTS (type)))\n           warning_at (loc, OPT_Warray_bounds, \"index value is out of bound\");\n \n       /* We are building an ARRAY_REF so mark the vector as addressable"}, {"sha": "6e4f85c0a0269f3da8b62c860656e01fb0145e03", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1379,8 +1379,9 @@ pp_c_initializer_list (c_pretty_printer *pp, tree e)\n     case VECTOR_TYPE:\n       if (TREE_CODE (e) == VECTOR_CST)\n \t{\n-\t  unsigned i;\n-\t  for (i = 0; i < VECTOR_CST_NELTS (e); ++i)\n+\t  /* We don't create variable-length VECTOR_CSTs.  */\n+\t  unsigned int nunits = VECTOR_CST_NELTS (e).to_constant ();\n+\t  for (unsigned int i = 0; i < nunits; ++i)\n \t    {\n \t      if (i > 0)\n \t\tpp_separate_with (pp, ',');"}, {"sha": "d15073e6f8b885d12beb709078898f9064fbe0c4", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-typeck.c (comptypes_internal, build_binary_op): Handle polynomial\n+\tTYPE_VECTOR_SUBPARTS.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "33b43648d8d536536282df48975117fa7f8f7789", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1237,7 +1237,7 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n       break;\n \n     case VECTOR_TYPE:\n-      val = (TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n+      val = (known_eq (TYPE_VECTOR_SUBPARTS (t1), TYPE_VECTOR_SUBPARTS (t2))\n \t     && comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t\t\t    enum_and_int_p, different_types_p));\n       break;\n@@ -11346,7 +11346,8 @@ build_binary_op (location_t location, enum tree_code code,\n       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n \t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n-\t  && TYPE_VECTOR_SUBPARTS (type0) == TYPE_VECTOR_SUBPARTS (type1))\n+\t  && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t       TYPE_VECTOR_SUBPARTS (type1)))\n \t{\n \t  result_type = type0;\n \t  converted = 1;\n@@ -11403,7 +11404,8 @@ build_binary_op (location_t location, enum tree_code code,\n       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n \t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n-\t  && TYPE_VECTOR_SUBPARTS (type0) == TYPE_VECTOR_SUBPARTS (type1))\n+\t  && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t       TYPE_VECTOR_SUBPARTS (type1)))\n \t{\n \t  result_type = type0;\n \t  converted = 1;\n@@ -11477,7 +11479,8 @@ build_binary_op (location_t location, enum tree_code code,\n               return error_mark_node;\n             }\n \n-          if (TYPE_VECTOR_SUBPARTS (type0) != TYPE_VECTOR_SUBPARTS (type1))\n+\t  if (maybe_ne (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t\tTYPE_VECTOR_SUBPARTS (type1)))\n             {\n               error_at (location, \"comparing vectors with different \"\n                                   \"number of elements\");\n@@ -11637,7 +11640,8 @@ build_binary_op (location_t location, enum tree_code code,\n               return error_mark_node;\n             }\n \n-          if (TYPE_VECTOR_SUBPARTS (type0) != TYPE_VECTOR_SUBPARTS (type1))\n+\t  if (maybe_ne (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t\tTYPE_VECTOR_SUBPARTS (type1)))\n             {\n               error_at (location, \"comparing vectors with different \"\n                                   \"number of elements\");"}, {"sha": "f278eb2660642048eb6336fed9fa2b21a453ed59", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -4961,9 +4961,11 @@ expand_debug_expr (tree exp)\n \n     case VECTOR_CST:\n       {\n-\tunsigned i, nelts;\n+\tunsigned HOST_WIDE_INT i, nelts;\n+\n+\tif (!VECTOR_CST_NELTS (exp).is_constant (&nelts))\n+\t  return NULL;\n \n-\tnelts = VECTOR_CST_NELTS (exp);\n \top0 = gen_rtx_CONCATN (mode, rtvec_alloc (nelts));\n \n \tfor (i = 0; i < nelts; ++i)\n@@ -4983,10 +4985,13 @@ expand_debug_expr (tree exp)\n       else if (TREE_CODE (TREE_TYPE (exp)) == VECTOR_TYPE)\n \t{\n \t  unsigned i;\n+\t  unsigned HOST_WIDE_INT nelts;\n \t  tree val;\n \n-\t  op0 = gen_rtx_CONCATN\n-\t    (mode, rtvec_alloc (TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp))));\n+\t  if (!TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp)).is_constant (&nelts))\n+\t    goto flag_unsupported;\n+\n+\t  op0 = gen_rtx_CONCATN (mode, rtvec_alloc (nelts));\n \n \t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), i, val)\n \t    {\n@@ -4996,15 +5001,15 @@ expand_debug_expr (tree exp)\n \t      XVECEXP (op0, 0, i) = op1;\n \t    }\n \n-\t  if (i < TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp)))\n+\t  if (i < nelts)\n \t    {\n \t      op1 = expand_debug_expr\n \t\t(build_zero_cst (TREE_TYPE (TREE_TYPE (exp))));\n \n \t      if (!op1)\n \t\treturn NULL;\n \n-\t      for (; i < TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp)); i++)\n+\t      for (; i < nelts; i++)\n \t\tXVECEXP (op0, 0, i) = op1;\n \t    }\n "}, {"sha": "73a31dfcf75cf322311065ce204ac2eea659962f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,17 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* constexpr.c (cxx_eval_array_reference): Handle polynomial\n+\tVECTOR_CST_NELTS.\n+\t(cxx_fold_indirect_ref): Handle polynomial TYPE_VECTOR_SUBPARTS.\n+\t* call.c (build_conditional_expr_1): Likewise.\n+\t* decl.c (cp_finish_decomp): Likewise.\n+\t* mangle.c (write_type): Likewise.\n+\t* typeck.c (structural_comptypes): Likewise.\n+\t(cp_build_binary_op): Likewise.\n+\t* typeck2.c (process_init_constructor_array): Likewise.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/83555"}, {"sha": "1c54bab124afc590652e8c8cb9f18688ed8d294a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -4919,8 +4919,8 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t}\n \n       if (!same_type_p (arg2_type, arg3_type)\n-\t  || TYPE_VECTOR_SUBPARTS (arg1_type)\n-\t     != TYPE_VECTOR_SUBPARTS (arg2_type)\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (arg1_type),\n+\t\t       TYPE_VECTOR_SUBPARTS (arg2_type))\n \t  || TYPE_SIZE (arg1_type) != TYPE_SIZE (arg2_type))\n \t{\n \t  if (complain & tf_error)"}, {"sha": "c91ca960df4fdc62deef45876e9979b48279ba44", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -2338,7 +2338,8 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t  len = (unsigned) TREE_STRING_LENGTH (ary) / elem_nchars;\n \t}\n       else if (TREE_CODE (ary) == VECTOR_CST)\n-\tlen = VECTOR_CST_NELTS (ary);\n+\t/* We don't create variable-length VECTOR_CSTs.  */\n+\tlen = VECTOR_CST_NELTS (ary).to_constant ();\n       else\n \t{\n \t  /* We can't do anything with other tree codes, so use\n@@ -3115,7 +3116,8 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n \t      tree index = bitsize_int (indexi);\n \n-\t      if (offset / part_widthi < TYPE_VECTOR_SUBPARTS (op00type))\n+\t      if (known_lt (offset / part_widthi,\n+\t\t\t    TYPE_VECTOR_SUBPARTS (op00type)))\n \t\treturn fold_build3_loc (loc,\n \t\t\t\t\tBIT_FIELD_REF, type, op00,\n \t\t\t\t\tpart_width, index);"}, {"sha": "6ba657801d9a9f752aa687cd43d93f7a530a1001", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -7500,7 +7500,11 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n     }\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n     {\n-      eltscnt = TYPE_VECTOR_SUBPARTS (type);\n+      if (!TYPE_VECTOR_SUBPARTS (type).is_constant (&eltscnt))\n+\t{\n+\t  error_at (loc, \"cannot decompose variable length vector %qT\", type);\n+\t  goto error_out;\n+\t}\n       if (count != eltscnt)\n \tgoto cnt_mismatch;\n       eltype = cp_build_qualified_type (TREE_TYPE (type), TYPE_QUALS (type));"}, {"sha": "bd745432dc1bbe20be7bce7ea7c6c4b2d5244efa", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -2287,7 +2287,8 @@ write_type (tree type)\n \t\t  write_string (\"Dv\");\n \t\t  /* Non-constant vector size would be encoded with\n \t\t     _ expression, but we don't support that yet.  */\n-\t\t  write_unsigned_number (TYPE_VECTOR_SUBPARTS (type));\n+\t\t  write_unsigned_number (TYPE_VECTOR_SUBPARTS (type)\n+\t\t\t\t\t .to_constant ());\n \t\t  write_char ('_');\n \t\t}\n \t      else"}, {"sha": "dc04b4bee848f93b72acb6f2d5942a50f9258e4b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1412,7 +1412,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n       break;\n \n     case VECTOR_TYPE:\n-      if (TYPE_VECTOR_SUBPARTS (t1) != TYPE_VECTOR_SUBPARTS (t2)\n+      if (maybe_ne (TYPE_VECTOR_SUBPARTS (t1), TYPE_VECTOR_SUBPARTS (t2))\n \t  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n       break;\n@@ -4585,9 +4585,10 @@ cp_build_binary_op (location_t location,\n           converted = 1;\n         }\n       else if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n-\t  && TYPE_VECTOR_SUBPARTS (type0) == TYPE_VECTOR_SUBPARTS (type1))\n+\t       && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n+\t       && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n+\t       && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t\t    TYPE_VECTOR_SUBPARTS (type1)))\n \t{\n \t  result_type = type0;\n \t  converted = 1;\n@@ -4630,9 +4631,10 @@ cp_build_binary_op (location_t location,\n           converted = 1;\n         }\n       else if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n-\t  && TYPE_VECTOR_SUBPARTS (type0) == TYPE_VECTOR_SUBPARTS (type1))\n+\t       && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE\n+\t       && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE\n+\t       && known_eq (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t\t    TYPE_VECTOR_SUBPARTS (type1)))\n \t{\n \t  result_type = type0;\n \t  converted = 1;\n@@ -4997,7 +4999,8 @@ cp_build_binary_op (location_t location,\n \t      return error_mark_node;\n \t    }\n \n-\t  if (TYPE_VECTOR_SUBPARTS (type0) != TYPE_VECTOR_SUBPARTS (type1))\n+\t  if (maybe_ne (TYPE_VECTOR_SUBPARTS (type0),\n+\t\t\tTYPE_VECTOR_SUBPARTS (type1)))\n \t    {\n \t      if (complain & tf_error)\n \t\t{"}, {"sha": "8d933257f5f481f97484c72cd41827c55b7bf67b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1292,7 +1292,7 @@ process_init_constructor_array (tree type, tree init, int nested,\n     }\n   else\n     /* Vectors are like simple fixed-size arrays.  */\n-    len = TYPE_VECTOR_SUBPARTS (type);\n+    unbounded = !TYPE_VECTOR_SUBPARTS (type).is_constant (&len);\n \n   /* There must not be more initializers than needed.  */\n   if (!unbounded && vec_safe_length (v) > len)"}, {"sha": "c6a0ff0a57ae37d462e439102f2293f4c51ea719", "filename": "gcc/expr.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -5922,7 +5922,13 @@ count_type_elements (const_tree type, bool for_ctor_p)\n       return 2;\n \n     case VECTOR_TYPE:\n-      return TYPE_VECTOR_SUBPARTS (type);\n+      {\n+\tunsigned HOST_WIDE_INT nelts;\n+\tif (TYPE_VECTOR_SUBPARTS (type).is_constant (&nelts))\n+\t  return nelts;\n+\telse\n+\t  return -1;\n+      }\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n@@ -6024,8 +6030,10 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \n \tcase VECTOR_CST:\n \t  {\n-\t    unsigned i;\n-\t    for (i = 0; i < VECTOR_CST_NELTS (value); ++i)\n+\t    /* We can only construct constant-length vectors using\n+\t       CONSTRUCTOR.  */\n+\t    unsigned int nunits = VECTOR_CST_NELTS (value).to_constant ();\n+\t    for (unsigned int i = 0; i < nunits; ++i)\n \t      {\n \t\ttree v = VECTOR_CST_ELT (value, i);\n \t\tif (!initializer_zerop (v))\n@@ -6669,7 +6677,8 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \tHOST_WIDE_INT bitsize;\n \tHOST_WIDE_INT bitpos;\n \trtvec vector = NULL;\n-\tunsigned n_elts;\n+\tpoly_uint64 n_elts;\n+\tunsigned HOST_WIDE_INT const_n_elts;\n \talias_set_type alias;\n \tbool vec_vec_init_p = false;\n \tmachine_mode mode = GET_MODE (target);\n@@ -6694,7 +6703,9 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t  }\n \n \tn_elts = TYPE_VECTOR_SUBPARTS (type);\n-\tif (REG_P (target) && VECTOR_MODE_P (mode))\n+\tif (REG_P (target)\n+\t    && VECTOR_MODE_P (mode)\n+\t    && n_elts.is_constant (&const_n_elts))\n \t  {\n \t    machine_mode emode = eltmode;\n \n@@ -6703,14 +6714,15 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t\t    == VECTOR_TYPE))\n \t      {\n \t\ttree etype = TREE_TYPE (CONSTRUCTOR_ELT (exp, 0)->value);\n-\t\tgcc_assert (CONSTRUCTOR_NELTS (exp) * TYPE_VECTOR_SUBPARTS (etype)\n-\t\t\t    == n_elts);\n+\t\tgcc_assert (known_eq (CONSTRUCTOR_NELTS (exp)\n+\t\t\t\t      * TYPE_VECTOR_SUBPARTS (etype),\n+\t\t\t\t      n_elts));\n \t\temode = TYPE_MODE (etype);\n \t      }\n \t    icode = convert_optab_handler (vec_init_optab, mode, emode);\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n-\t\tunsigned int i, n = n_elts;\n+\t\tunsigned int i, n = const_n_elts;\n \n \t\tif (emode != eltmode)\n \t\t  {\n@@ -6749,7 +6761,8 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \n \t    /* Clear the entire vector first if there are any missing elements,\n \t       or if the incidence of zero elements is >= 75%.  */\n-\t    need_to_clear = (count < n_elts || 4 * zero_count >= 3 * count);\n+\t    need_to_clear = (maybe_lt (count, n_elts)\n+\t\t\t     || 4 * zero_count >= 3 * count);\n \t  }\n \n \tif (need_to_clear && maybe_gt (size, 0) && !vector)\n@@ -10082,9 +10095,10 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tif (!tmp)\n \t  {\n \t    vec<constructor_elt, va_gc> *v;\n-\t    unsigned i;\n-\t    vec_alloc (v, VECTOR_CST_NELTS (exp));\n-\t    for (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n+\t    /* Constructors need to be fixed-length.  FIXME.  */\n+\t    unsigned int nunits = VECTOR_CST_NELTS (exp).to_constant ();\n+\t    vec_alloc (v, nunits);\n+\t    for (unsigned int i = 0; i < nunits; ++i)\n \t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, VECTOR_CST_ELT (exp, i));\n \t    tmp = build_constructor (type, v);\n \t  }\n@@ -11837,9 +11851,10 @@ const_scalar_mask_from_tree (scalar_int_mode mode, tree exp)\n {\n   wide_int res = wi::zero (GET_MODE_PRECISION (mode));\n   tree elt;\n-  unsigned i;\n \n-  for (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n+  /* The result has a fixed number of bits so the input must too.  */\n+  unsigned int nunits = VECTOR_CST_NELTS (exp).to_constant ();\n+  for (unsigned int i = 0; i < nunits; ++i)\n     {\n       elt = VECTOR_CST_ELT (exp, i);\n       gcc_assert (TREE_CODE (elt) == INTEGER_CST);"}, {"sha": "7e3cd1e79e79d4631ff391a980be26ab4a1f7866", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -588,12 +588,13 @@ fold_const_builtin_nan (tree type, tree arg, bool quiet)\n static tree\n fold_const_reduction (tree type, tree arg, tree_code code)\n {\n-  if (TREE_CODE (arg) != VECTOR_CST)\n+  unsigned HOST_WIDE_INT nelts;\n+  if (TREE_CODE (arg) != VECTOR_CST\n+      || !VECTOR_CST_NELTS (arg).is_constant (&nelts))\n     return NULL_TREE;\n \n   tree res = VECTOR_CST_ELT (arg, 0);\n-  unsigned int nelts = VECTOR_CST_NELTS (arg);\n-  for (unsigned int i = 1; i < nelts; i++)\n+  for (unsigned HOST_WIDE_INT i = 1; i < nelts; i++)\n     {\n       res = const_binop (code, type, res, VECTOR_CST_ELT (arg, i));\n       if (res == NULL_TREE || !CONSTANT_CLASS_P (res))"}, {"sha": "eabaa4a08a85116f4a08520f49144cfdefe25619", "filename": "gcc/fold-const.c", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1500,8 +1500,8 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n \n   if (TREE_CODE (arg1) == VECTOR_CST\n       && TREE_CODE (arg2) == VECTOR_CST\n-      && (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1))\n-\t  == TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2))))\n+      && known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2))))\n     {\n       tree type = TREE_TYPE (arg1);\n       bool step_ok_p;\n@@ -1617,16 +1617,18 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n       {\n-\tunsigned int out_nelts, in_nelts, i;\n+\tunsigned int HOST_WIDE_INT out_nelts, in_nelts, i;\n \n \tif (TREE_CODE (arg1) != VECTOR_CST\n \t    || TREE_CODE (arg2) != VECTOR_CST)\n \t  return NULL_TREE;\n \n-\tin_nelts = VECTOR_CST_NELTS (arg1);\n+\tif (!VECTOR_CST_NELTS (arg1).is_constant (&in_nelts))\n+\t  return NULL_TREE;\n+\n \tout_nelts = in_nelts * 2;\n-\tgcc_assert (in_nelts == VECTOR_CST_NELTS (arg2)\n-\t\t    && out_nelts == TYPE_VECTOR_SUBPARTS (type));\n+\tgcc_assert (known_eq (in_nelts, VECTOR_CST_NELTS (arg2))\n+\t\t    && known_eq (out_nelts, TYPE_VECTOR_SUBPARTS (type)));\n \n \ttree_vector_builder elts (type, out_nelts, 1);\n \tfor (i = 0; i < out_nelts; i++)\n@@ -1650,15 +1652,16 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n     case VEC_WIDEN_MULT_EVEN_EXPR:\n     case VEC_WIDEN_MULT_ODD_EXPR:\n       {\n-\tunsigned int out_nelts, in_nelts, out, ofs, scale;\n+\tunsigned HOST_WIDE_INT out_nelts, in_nelts, out, ofs, scale;\n \n \tif (TREE_CODE (arg1) != VECTOR_CST || TREE_CODE (arg2) != VECTOR_CST)\n \t  return NULL_TREE;\n \n-\tin_nelts = VECTOR_CST_NELTS (arg1);\n+\tif (!VECTOR_CST_NELTS (arg1).is_constant (&in_nelts))\n+\t  return NULL_TREE;\n \tout_nelts = in_nelts / 2;\n-\tgcc_assert (in_nelts == VECTOR_CST_NELTS (arg2)\n-\t\t    && out_nelts == TYPE_VECTOR_SUBPARTS (type));\n+\tgcc_assert (known_eq (in_nelts, VECTOR_CST_NELTS (arg2))\n+\t\t    && known_eq (out_nelts, TYPE_VECTOR_SUBPARTS (type)));\n \n \tif (code == VEC_WIDEN_MULT_LO_EXPR)\n \t  scale = 0, ofs = BYTES_BIG_ENDIAN ? out_nelts : 0;\n@@ -1809,15 +1812,16 @@ const_unop (enum tree_code code, tree type, tree arg0)\n     case VEC_UNPACK_FLOAT_LO_EXPR:\n     case VEC_UNPACK_FLOAT_HI_EXPR:\n       {\n-\tunsigned int out_nelts, in_nelts, i;\n+\tunsigned HOST_WIDE_INT out_nelts, in_nelts, i;\n \tenum tree_code subcode;\n \n \tif (TREE_CODE (arg0) != VECTOR_CST)\n \t  return NULL_TREE;\n \n-\tin_nelts = VECTOR_CST_NELTS (arg0);\n+\tif (!VECTOR_CST_NELTS (arg0).is_constant (&in_nelts))\n+\t  return NULL_TREE;\n \tout_nelts = in_nelts / 2;\n-\tgcc_assert (out_nelts == TYPE_VECTOR_SUBPARTS (type));\n+\tgcc_assert (known_eq (out_nelts, TYPE_VECTOR_SUBPARTS (type)));\n \n \tunsigned int offset = 0;\n \tif ((!BYTES_BIG_ENDIAN) ^ (code == VEC_UNPACK_LO_EXPR\n@@ -2275,7 +2279,7 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n     {\n       if (TREE_CODE (arg1) == VECTOR_CST\n-\t  && TYPE_VECTOR_SUBPARTS (type) == VECTOR_CST_NELTS (arg1))\n+\t  && known_eq (TYPE_VECTOR_SUBPARTS (type), VECTOR_CST_NELTS (arg1)))\n \t{\n \t  tree elttype = TREE_TYPE (type);\n \t  tree arg1_elttype = TREE_TYPE (TREE_TYPE (arg1));\n@@ -3429,8 +3433,8 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t     We only tested element precision and modes to match.\n \t     Vectors may be BLKmode and thus also check that the number of\n \t     parts match.  */\n-\t  if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0))\n-\t      != TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)))\n+\t  if (maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)),\n+\t\t\tTYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1))))\n \t    return 0;\n \n \t  vec<constructor_elt, va_gc> *v0 = CONSTRUCTOR_ELTS (arg0);\n@@ -7290,12 +7294,13 @@ native_encode_complex (const_tree expr, unsigned char *ptr, int len, int off)\n static int\n native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)\n {\n-  unsigned i, count;\n+  unsigned HOST_WIDE_INT i, count;\n   int size, offset;\n   tree itype, elem;\n \n   offset = 0;\n-  count = VECTOR_CST_NELTS (expr);\n+  if (!VECTOR_CST_NELTS (expr).is_constant (&count))\n+    return 0;\n   itype = TREE_TYPE (TREE_TYPE (expr));\n   size = GET_MODE_SIZE (SCALAR_TYPE_MODE (itype));\n   for (i = 0; i < count; i++)\n@@ -7532,15 +7537,16 @@ native_interpret_complex (tree type, const unsigned char *ptr, int len)\n    If the buffer cannot be interpreted, return NULL_TREE.  */\n \n static tree\n-native_interpret_vector (tree type, const unsigned char *ptr, int len)\n+native_interpret_vector (tree type, const unsigned char *ptr, unsigned int len)\n {\n   tree etype, elem;\n-  int i, size, count;\n+  unsigned int i, size;\n+  unsigned HOST_WIDE_INT count;\n \n   etype = TREE_TYPE (type);\n   size = GET_MODE_SIZE (SCALAR_TYPE_MODE (etype));\n-  count = TYPE_VECTOR_SUBPARTS (type);\n-  if (size * count > len)\n+  if (!TYPE_VECTOR_SUBPARTS (type).is_constant (&count)\n+      || size * count > len)\n     return NULL_TREE;\n \n   tree_vector_builder elements (type, count, 1);\n@@ -8894,11 +8900,12 @@ fold_mult_zconjz (location_t loc, tree type, tree expr)\n static bool\n vec_cst_ctor_to_array (tree arg, unsigned int nelts, tree *elts)\n {\n-  unsigned int i;\n+  unsigned HOST_WIDE_INT i, nunits;\n \n-  if (TREE_CODE (arg) == VECTOR_CST)\n+  if (TREE_CODE (arg) == VECTOR_CST\n+      && VECTOR_CST_NELTS (arg).is_constant (&nunits))\n     {\n-      for (i = 0; i < VECTOR_CST_NELTS (arg); ++i)\n+      for (i = 0; i < nunits; ++i)\n \telts[i] = VECTOR_CST_ELT (arg, i);\n     }\n   else if (TREE_CODE (arg) == CONSTRUCTOR)\n@@ -8932,9 +8939,9 @@ fold_vec_perm (tree type, tree arg0, tree arg1, const vec_perm_indices &sel)\n \n   if (!sel.length ().is_constant (&nelts))\n     return NULL_TREE;\n-  gcc_assert (TYPE_VECTOR_SUBPARTS (type) == nelts\n-\t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts\n-\t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts);\n+  gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (type), nelts)\n+\t      && known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)), nelts)\n+\t      && known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)), nelts));\n   if (TREE_TYPE (TREE_TYPE (arg0)) != TREE_TYPE (type)\n       || TREE_TYPE (TREE_TYPE (arg1)) != TREE_TYPE (type))\n     return NULL_TREE;\n@@ -11371,15 +11378,15 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t}\n       else if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n+\t  unsigned HOST_WIDE_INT nelts;\n \t  if ((TREE_CODE (arg1) == VECTOR_CST\n \t       || TREE_CODE (arg1) == CONSTRUCTOR)\n \t      && (TREE_CODE (arg2) == VECTOR_CST\n-\t\t  || TREE_CODE (arg2) == CONSTRUCTOR))\n+\t\t  || TREE_CODE (arg2) == CONSTRUCTOR)\n+\t      && TYPE_VECTOR_SUBPARTS (type).is_constant (&nelts))\n \t    {\n-\t      unsigned int nelts = VECTOR_CST_NELTS (arg0), i;\n-\t      gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n \t      vec_perm_builder sel (nelts, nelts, 1);\n-\t      for (i = 0; i < nelts; i++)\n+\t      for (unsigned int i = 0; i < nelts; i++)\n \t\t{\n \t\t  tree val = VECTOR_CST_ELT (arg0, i);\n \t\t  if (integer_all_onesp (val))\n@@ -11644,7 +11651,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  if (n != 0\n \t      && (idx % width) == 0\n \t      && (n % width) == 0\n-\t      && ((idx + n) / width) <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)))\n+\t      && known_le ((idx + n) / width,\n+\t\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0))))\n \t    {\n \t      idx = idx / width;\n \t      n = n / width;\n@@ -11716,7 +11724,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t    return NULL_TREE;\n \n \t  /* Create a vec_perm_indices for the integer vector.  */\n-\t  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n+\t  poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (type);\n \t  bool single_arg = (op0 == op1);\n \t  vec_perm_indices sel (builder, single_arg ? 1 : 2, nelts);\n \n@@ -11803,14 +11811,14 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  if (bitpos % elsize == 0)\n \t    {\n \t      unsigned k = bitpos / elsize;\n+\t      unsigned HOST_WIDE_INT nelts;\n \t      if (operand_equal_p (VECTOR_CST_ELT (arg0, k), arg1, 0))\n \t\treturn arg0;\n-\t      else\n+\t      else if (VECTOR_CST_NELTS (arg0).is_constant (&nelts))\n \t\t{\n-\t\t  unsigned int nelts = VECTOR_CST_NELTS (arg0);\n \t\t  tree_vector_builder elts (type, nelts, 1);\n \t\t  elts.quick_grow (nelts);\n-\t\t  for (unsigned int i = 0; i < nelts; ++i)\n+\t\t  for (unsigned HOST_WIDE_INT i = 0; i < nelts; ++i)\n \t\t    elts[i] = (i == k ? arg1 : VECTOR_CST_ELT (arg0, i));\n \t\t  return elts.build ();\n \t\t}\n@@ -13937,8 +13945,12 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t{\n \t  /* Have vector comparison with scalar boolean result.  */\n \t  gcc_assert ((code == EQ_EXPR || code == NE_EXPR)\n-\t\t      && VECTOR_CST_NELTS (op0) == VECTOR_CST_NELTS (op1));\n-\t  for (unsigned i = 0; i < VECTOR_CST_NELTS (op0); i++)\n+\t\t      && known_eq (VECTOR_CST_NELTS (op0),\n+\t\t\t\t   VECTOR_CST_NELTS (op1)));\n+\t  unsigned HOST_WIDE_INT nunits;\n+\t  if (!VECTOR_CST_NELTS (op0).is_constant (&nunits))\n+\t    return NULL_TREE;\n+\t  for (unsigned i = 0; i < nunits; i++)\n \t    {\n \t      tree elem0 = VECTOR_CST_ELT (op0, i);\n \t      tree elem1 = VECTOR_CST_ELT (op1, i);"}, {"sha": "6188c250b3d20eee0bb798589010945a5584f795", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* trans-types.c (gfc_type_for_mode): Check valid_vector_subparts_p.\n+\n 2018-01-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/83664"}, {"sha": "82415beea847a905b5499bd3a91beb9e29fe15fe", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -3185,7 +3185,8 @@ gfc_type_for_mode (machine_mode mode, int unsignedp)\n       tree type = gfc_type_for_size (GET_MODE_PRECISION (int_mode), unsignedp);\n       return type != NULL_TREE && mode == TYPE_MODE (type) ? type : NULL_TREE;\n     }\n-  else if (VECTOR_MODE_P (mode))\n+  else if (VECTOR_MODE_P (mode)\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {\n       machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = gfc_type_for_mode (inner_mode, unsignedp);"}, {"sha": "99f265e20826a0e1b2e7e252df2a544670be0585", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -6079,13 +6079,13 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t\t}\n \t      else if (TREE_CODE (rhs) == CONSTRUCTOR\n \t\t       && TREE_CODE (TREE_TYPE (rhs)) == VECTOR_TYPE\n-\t\t       && (CONSTRUCTOR_NELTS (rhs)\n-\t\t\t   == TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs))))\n+\t\t       && known_eq (CONSTRUCTOR_NELTS (rhs),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs))))\n \t\t{\n \t\t  unsigned i, nelts;\n \t\t  tree val;\n \n-\t\t  nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs));\n+\t\t  nelts = CONSTRUCTOR_NELTS (rhs);\n \t\t  tree_vector_builder vec (TREE_TYPE (rhs), nelts, 1);\n \t\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n \t\t    {\n@@ -6930,8 +6930,8 @@ gimple_fold_indirect_ref (tree t)\n             = tree_to_shwi (part_width) / BITS_PER_UNIT;\n           unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n           tree index = bitsize_int (indexi);\n-          if (offset / part_widthi\n-\t      < TYPE_VECTOR_SUBPARTS (TREE_TYPE (addrtype)))\n+\t  if (known_lt (offset / part_widthi,\n+\t\t\tTYPE_VECTOR_SUBPARTS (TREE_TYPE (addrtype))))\n             return fold_build3 (BIT_FIELD_REF, type, TREE_OPERAND (addr, 0),\n                                 part_width, index);\n \t}\n@@ -7233,6 +7233,10 @@ tree\n gimple_build_vector_from_val (gimple_seq *seq, location_t loc, tree type,\n \t\t\t      tree op)\n {\n+  if (!TYPE_VECTOR_SUBPARTS (type).is_constant ()\n+      && !CONSTANT_CLASS_P (op))\n+    return gimple_build (seq, loc, VEC_DUPLICATE_EXPR, type, op);\n+\n   tree res, vec = build_vector_from_val (type, op);\n   if (is_gimple_val (vec))\n     return vec;\n@@ -7265,7 +7269,7 @@ gimple_build_vector (gimple_seq *seq, location_t loc,\n     if (!TREE_CONSTANT ((*builder)[i]))\n       {\n \ttree type = builder->type ();\n-\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n+\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type).to_constant ();\n \tvec<constructor_elt, va_gc> *v;\n \tvec_alloc (v, nelts);\n \tfor (i = 0; i < nelts; ++i)"}, {"sha": "727254b9ee54f84af23c883c8e773a370375740a", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* go-lang.c (go_langhook_type_for_mode): Check valid_vector_subparts_p.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "4a057992da72c1856229b8dd7eda6d42230df10c", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -377,7 +377,8 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n      make sense for the middle-end to ask the frontend for a type\n      which the frontend does not support.  However, at least for now\n      it is required.  See PR 46805.  */\n-  if (VECTOR_MODE_P (mode))\n+  if (VECTOR_MODE_P (mode)\n+      && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {\n       tree inner;\n "}, {"sha": "d3efff40453f690c7a7515905177b706466429cb", "filename": "gcc/hsa-brig.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -963,7 +963,8 @@ hsa_op_immed::emit_to_buffer (unsigned *brig_repr_size)\n \n       if (TREE_CODE (m_tree_value) == VECTOR_CST)\n \t{\n-\t  int i, num = VECTOR_CST_NELTS (m_tree_value);\n+\t  /* Variable-length vectors aren't supported.  */\n+\t  int i, num = VECTOR_CST_NELTS (m_tree_value).to_constant ();\n \t  for (i = 0; i < num; i++)\n \t    {\n \t      tree v = VECTOR_CST_ELT (m_tree_value, i);"}, {"sha": "edb0b7896cd8a84438faef0b34782bc59942b3da", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -2025,8 +2025,8 @@ sem_variable::equals (tree t1, tree t2)\n \t\t\t\t\t\t&TREE_REAL_CST (t2)));\n     case VECTOR_CST:\n       {\n-        if (VECTOR_CST_NELTS (t1) != VECTOR_CST_NELTS (t2))\n-          return return_false_with_msg (\"VECTOR_CST nelts mismatch\");\n+\tif (maybe_ne (VECTOR_CST_NELTS (t1), VECTOR_CST_NELTS (t2)))\n+\t  return return_false_with_msg (\"VECTOR_CST nelts mismatch\");\n \n \tunsigned int count\n \t  = tree_vector_builder::binary_encoded_nelts (t1, t2);"}, {"sha": "8240d9f35a50d90297c7840cc3ed1146fd35211c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lto-lang.c (lto_type_for_mode): Check valid_vector_subparts_p.\n+\t* lto.c (hash_canonical_type): Handle polynomial TYPE_VECTOR_SUBPARTS.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "81a20358a2cd25053f1872daefaf0a0485242dad", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1012,7 +1012,8 @@ lto_type_for_mode (machine_mode mode, int unsigned_p)\n       if (inner_type != NULL_TREE)\n \treturn build_complex_type (inner_type);\n     }\n-  else if (VECTOR_MODE_P (mode))\n+  else if (VECTOR_MODE_P (mode)\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {\n       machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = lto_type_for_mode (inner_mode, unsigned_p);"}, {"sha": "a8707d40c4992e71537e19282e8cb437795e54f8", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -316,7 +316,7 @@ hash_canonical_type (tree type)\n \n   if (VECTOR_TYPE_P (type))\n     {\n-      hstate.add_int (TYPE_VECTOR_SUBPARTS (type));\n+      hstate.add_poly_int (TYPE_VECTOR_SUBPARTS (type));\n       hstate.add_int (TYPE_UNSIGNED (type));\n     }\n "}, {"sha": "f189cb19b4188b400aac00e30961e292151c9910", "filename": "gcc/match.pd", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -83,7 +83,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (match (nop_convert @0)\n  (view_convert @0)\n  (if (VECTOR_TYPE_P (type) && VECTOR_TYPE_P (TREE_TYPE (@0))\n-      && TYPE_VECTOR_SUBPARTS (type) == TYPE_VECTOR_SUBPARTS (TREE_TYPE (@0))\n+      && known_eq (TYPE_VECTOR_SUBPARTS (type),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (@0)))\n       && tree_nop_conversion_p (TREE_TYPE (type), TREE_TYPE (TREE_TYPE (@0))))))\n /* This one has to be last, or it shadows the others.  */\n (match (nop_convert @0)\n@@ -2849,7 +2850,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n  (plus:c @3 (view_convert? (vec_cond:s @0 integer_each_onep@1 integer_zerop@2)))\n  (if (VECTOR_TYPE_P (type)\n-      && TYPE_VECTOR_SUBPARTS (type) == TYPE_VECTOR_SUBPARTS (TREE_TYPE (@1))\n+      && known_eq (TYPE_VECTOR_SUBPARTS (type),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (@1)))\n       && (TYPE_MODE (TREE_TYPE (type))\n           == TYPE_MODE (TREE_TYPE (TREE_TYPE (@1)))))\n   (minus @3 (view_convert (vec_cond @0 (negate @1) @2)))))\n@@ -2858,7 +2860,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n  (minus @3 (view_convert? (vec_cond:s @0 integer_each_onep@1 integer_zerop@2)))\n  (if (VECTOR_TYPE_P (type)\n-      && TYPE_VECTOR_SUBPARTS (type) == TYPE_VECTOR_SUBPARTS (TREE_TYPE (@1))\n+      && known_eq (TYPE_VECTOR_SUBPARTS (type),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (@1)))\n       && (TYPE_MODE (TREE_TYPE (type))\n           == TYPE_MODE (TREE_TYPE (TREE_TYPE (@1)))))\n   (plus @3 (view_convert (vec_cond @0 (negate @1) @2)))))\n@@ -4524,7 +4527,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (if (n != 0\n \t&& (idx % width) == 0\n \t&& (n % width) == 0\n-\t&& ((idx + n) / width) <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (ctor)))\n+\t&& known_le ((idx + n) / width,\n+\t\t     TYPE_VECTOR_SUBPARTS (TREE_TYPE (ctor))))\n     (with\n      {\n        idx = idx / width;"}, {"sha": "b7737a258248fbe20967bc1e2d7f961592ef93a0", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -57,7 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n static unsigned HOST_WIDE_INT\n simd_clone_subparts (tree vectype)\n {\n-  return TYPE_VECTOR_SUBPARTS (vectype);\n+  return TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n }\n \n /* Allocate a fresh `simd_clone' and return it.  NARGS is the number"}, {"sha": "cba8bacdb8a5eaeb6e44496eef3d08a0d3ee6914", "filename": "gcc/print-tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -630,7 +630,10 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n       else if (code == ARRAY_TYPE)\n \tprint_node (file, \"domain\", TYPE_DOMAIN (node), indent + 4);\n       else if (code == VECTOR_TYPE)\n-\tfprintf (file, \" nunits:%d\", (int) TYPE_VECTOR_SUBPARTS (node));\n+\t{\n+\t  fprintf (file, \" nunits:\");\n+\t  print_dec (TYPE_VECTOR_SUBPARTS (node), file);\n+\t}\n       else if (code == RECORD_TYPE\n \t       || code == UNION_TYPE\n \t       || code == QUAL_UNION_TYPE)"}, {"sha": "af3303b5d4d352267a40badb392f6b08d97fec88", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -2271,11 +2271,9 @@ layout_type (tree type)\n \n     case VECTOR_TYPE:\n       {\n-\tint nunits = TYPE_VECTOR_SUBPARTS (type);\n+\tpoly_uint64 nunits = TYPE_VECTOR_SUBPARTS (type);\n \ttree innertype = TREE_TYPE (type);\n \n-\tgcc_assert (!(nunits & (nunits - 1)));\n-\n \t/* Find an appropriate mode for the vector type.  */\n \tif (TYPE_MODE (type) == VOIDmode)\n \t  SET_TYPE_MODE (type,"}, {"sha": "f98cdc9bb46b88ccb0e05df63fca3b48b523caaa", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -713,7 +713,7 @@ default_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n         return 3;\n \n       case vec_construct:\n-\treturn TYPE_VECTOR_SUBPARTS (vectype) - 1;\n+\treturn estimated_poly_value (TYPE_VECTOR_SUBPARTS (vectype)) - 1;\n \n       default:\n         gcc_unreachable ();"}, {"sha": "a0cc1edbfc568463fd67a6d976e093e947d92305", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -3775,7 +3775,8 @@ verify_gimple_comparison (tree type, tree op0, tree op1, enum tree_code code)\n           return true;\n         }\n \n-      if (TYPE_VECTOR_SUBPARTS (type) != TYPE_VECTOR_SUBPARTS (op0_type))\n+      if (maybe_ne (TYPE_VECTOR_SUBPARTS (type),\n+\t\t    TYPE_VECTOR_SUBPARTS (op0_type)))\n         {\n           error (\"invalid vector comparison resulting type\");\n           debug_generic_expr (type);\n@@ -4214,8 +4215,8 @@ verify_gimple_assign_binary (gassign *stmt)\n       if (VECTOR_BOOLEAN_TYPE_P (lhs_type)\n \t  && VECTOR_BOOLEAN_TYPE_P (rhs1_type)\n \t  && types_compatible_p (rhs1_type, rhs2_type)\n-\t  && (TYPE_VECTOR_SUBPARTS (lhs_type)\n-\t      == 2 * TYPE_VECTOR_SUBPARTS (rhs1_type)))\n+\t  && known_eq (TYPE_VECTOR_SUBPARTS (lhs_type),\n+\t\t       2 * TYPE_VECTOR_SUBPARTS (rhs1_type)))\n \treturn false;\n \n       /* Fallthru.  */\n@@ -4365,8 +4366,8 @@ verify_gimple_assign_ternary (gassign *stmt)\n \n     case VEC_COND_EXPR:\n       if (!VECTOR_BOOLEAN_TYPE_P (rhs1_type)\n-\t  || TYPE_VECTOR_SUBPARTS (rhs1_type)\n-\t     != TYPE_VECTOR_SUBPARTS (lhs_type))\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (rhs1_type),\n+\t\t       TYPE_VECTOR_SUBPARTS (lhs_type)))\n \t{\n \t  error (\"the first argument of a VEC_COND_EXPR must be of a \"\n \t\t \"boolean vector type of the same number of elements \"\n@@ -4412,11 +4413,12 @@ verify_gimple_assign_ternary (gassign *stmt)\n \t  return true;\n \t}\n \n-      if (TYPE_VECTOR_SUBPARTS (rhs1_type) != TYPE_VECTOR_SUBPARTS (rhs2_type)\n-\t  || TYPE_VECTOR_SUBPARTS (rhs2_type)\n-\t     != TYPE_VECTOR_SUBPARTS (rhs3_type)\n-\t  || TYPE_VECTOR_SUBPARTS (rhs3_type)\n-\t     != TYPE_VECTOR_SUBPARTS (lhs_type))\n+      if (maybe_ne (TYPE_VECTOR_SUBPARTS (rhs1_type),\n+\t\t    TYPE_VECTOR_SUBPARTS (rhs2_type))\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (rhs2_type),\n+\t\t       TYPE_VECTOR_SUBPARTS (rhs3_type))\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (rhs3_type),\n+\t\t       TYPE_VECTOR_SUBPARTS (lhs_type)))\n \t{\n \t  error (\"vectors with different element number found \"\n \t\t \"in vector permute expression\");\n@@ -4699,9 +4701,9 @@ verify_gimple_assign_single (gassign *stmt)\n \t\t\t  debug_generic_stmt (rhs1);\n \t\t\t  return true;\n \t\t\t}\n-\t\t      else if (CONSTRUCTOR_NELTS (rhs1)\n-\t\t\t       * TYPE_VECTOR_SUBPARTS (elt_t)\n-\t\t\t       != TYPE_VECTOR_SUBPARTS (rhs1_type))\n+\t\t      else if (maybe_ne (CONSTRUCTOR_NELTS (rhs1)\n+\t\t\t\t\t * TYPE_VECTOR_SUBPARTS (elt_t),\n+\t\t\t\t\t TYPE_VECTOR_SUBPARTS (rhs1_type)))\n \t\t\t{\n \t\t\t  error (\"incorrect number of vector CONSTRUCTOR\"\n \t\t\t\t \" elements\");\n@@ -4716,8 +4718,8 @@ verify_gimple_assign_single (gassign *stmt)\n \t\t      debug_generic_stmt (rhs1);\n \t\t      return true;\n \t\t    }\n-\t\t  else if (CONSTRUCTOR_NELTS (rhs1)\n-\t\t\t   > TYPE_VECTOR_SUBPARTS (rhs1_type))\n+\t\t  else if (maybe_gt (CONSTRUCTOR_NELTS (rhs1),\n+\t\t\t\t     TYPE_VECTOR_SUBPARTS (rhs1_type)))\n \t\t    {\n \t\t      error (\"incorrect number of vector CONSTRUCTOR elements\");\n \t\t      debug_generic_stmt (rhs1);"}, {"sha": "c6cd65fbe79c142052beb299e3787514e13fa9e7", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1793,13 +1793,18 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       {\n \tunsigned i;\n \tpp_string (pp, \"{ \");\n-\tfor (i = 0; i < VECTOR_CST_NELTS (node); ++i)\n+\tunsigned HOST_WIDE_INT nunits;\n+\tif (!VECTOR_CST_NELTS (node).is_constant (&nunits))\n+\t  nunits = vector_cst_encoded_nelts (node);\n+\tfor (i = 0; i < nunits; ++i)\n \t  {\n \t    if (i != 0)\n \t      pp_string (pp, \", \");\n \t    dump_generic_node (pp, VECTOR_CST_ELT (node, i),\n \t\t\t       spc, flags, false);\n \t  }\n+\tif (!VECTOR_CST_NELTS (node).is_constant ())\n+\t  pp_string (pp, \", ...\");\n \tpp_string (pp, \" }\");\n       }\n       break;"}, {"sha": "8ddef997fff214f128124035b151a13fa71738f7", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1824,11 +1824,11 @@ simplify_bitfield_ref (gimple_stmt_iterator *gsi)\n       && constant_multiple_p (bit_field_offset (op), size, &idx))\n     {\n       tree p, m, tem;\n-      unsigned nelts;\n+      unsigned HOST_WIDE_INT nelts;\n       m = gimple_assign_rhs3 (def_stmt);\n-      if (TREE_CODE (m) != VECTOR_CST)\n+      if (TREE_CODE (m) != VECTOR_CST\n+\t  || !VECTOR_CST_NELTS (m).is_constant (&nelts))\n \treturn false;\n-      nelts = VECTOR_CST_NELTS (m);\n       idx = TREE_INT_CST_LOW (VECTOR_CST_ELT (m, idx));\n       idx %= 2 * nelts;\n       if (idx < nelts)\n@@ -1858,7 +1858,7 @@ static int\n is_combined_permutation_identity (tree mask1, tree mask2)\n {\n   tree mask;\n-  unsigned int nelts, i, j;\n+  unsigned HOST_WIDE_INT nelts, i, j;\n   bool maybe_identity1 = true;\n   bool maybe_identity2 = true;\n \n@@ -1867,7 +1867,8 @@ is_combined_permutation_identity (tree mask1, tree mask2)\n   mask = fold_ternary (VEC_PERM_EXPR, TREE_TYPE (mask1), mask1, mask1, mask2);\n   gcc_assert (TREE_CODE (mask) == VECTOR_CST);\n \n-  nelts = VECTOR_CST_NELTS (mask);\n+  if (!VECTOR_CST_NELTS (mask).is_constant (&nelts))\n+    return 0;\n   for (i = 0; i < nelts; i++)\n     {\n       tree val = VECTOR_CST_ELT (mask, i);\n@@ -2003,7 +2004,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   gimple *stmt = gsi_stmt (*gsi);\n   gimple *def_stmt;\n   tree op, op2, orig, type, elem_type;\n-  unsigned elem_size, nelts, i;\n+  unsigned elem_size, i;\n+  unsigned HOST_WIDE_INT nelts;\n   enum tree_code code, conv_code;\n   constructor_elt *elt;\n   bool maybe_ident;\n@@ -2014,7 +2016,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   type = TREE_TYPE (op);\n   gcc_checking_assert (TREE_CODE (type) == VECTOR_TYPE);\n \n-  nelts = TYPE_VECTOR_SUBPARTS (type);\n+  if (!TYPE_VECTOR_SUBPARTS (type).is_constant (&nelts))\n+    return false;\n   elem_type = TREE_TYPE (type);\n   elem_size = TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n \n@@ -2086,8 +2089,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n     return false;\n \n   if (! VECTOR_TYPE_P (TREE_TYPE (orig))\n-      || (TYPE_VECTOR_SUBPARTS (type)\n-\t  != TYPE_VECTOR_SUBPARTS (TREE_TYPE (orig))))\n+      || maybe_ne (TYPE_VECTOR_SUBPARTS (type),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (orig))))\n     return false;\n \n   tree tem;"}, {"sha": "c1005eec26990ccee835469ccdc4e849455302b4", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -4772,7 +4772,7 @@ vect_permute_store_chain (vec<tree> dr_chain,\n   if (length == 3)\n     {\n       /* vect_grouped_store_supported ensures that this is constant.  */\n-      unsigned int nelt = TYPE_VECTOR_SUBPARTS (vectype);\n+      unsigned int nelt = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n       unsigned int j0 = 0, j1 = 0, j2 = 0;\n \n       vec_perm_builder sel (nelt, nelt, 1);\n@@ -4839,7 +4839,7 @@ vect_permute_store_chain (vec<tree> dr_chain,\n       gcc_assert (pow2p_hwi (length));\n \n       /* The encoding has 2 interleaved stepped patterns.  */\n-      unsigned int nelt = TYPE_VECTOR_SUBPARTS (vectype);\n+      poly_uint64 nelt = TYPE_VECTOR_SUBPARTS (vectype);\n       vec_perm_builder sel (nelt, 2, 3);\n       sel.quick_grow (6);\n       for (i = 0; i < 3; i++)\n@@ -4851,7 +4851,7 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \tperm_mask_high = vect_gen_perm_mask_checked (vectype, indices);\n \n \tfor (i = 0; i < 6; i++)\n-\t  sel[i] += nelt / 2;\n+\t  sel[i] += exact_div (nelt, 2);\n \tindices.new_vector (sel, 2, nelt);\n \tperm_mask_low = vect_gen_perm_mask_checked (vectype, indices);\n \n@@ -5174,7 +5174,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n      that leaves unused vector loads around punt - we at least create\n      very sub-optimal code in that case (and blow up memory,\n      see PR65518).  */\n-  if (single_element_p && count > TYPE_VECTOR_SUBPARTS (vectype))\n+  if (single_element_p && maybe_gt (count, TYPE_VECTOR_SUBPARTS (vectype)))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5385,7 +5385,7 @@ vect_permute_load_chain (vec<tree> dr_chain,\n   if (length == 3)\n     {\n       /* vect_grouped_load_supported ensures that this is constant.  */\n-      unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n+      unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n       unsigned int k;\n \n       vec_perm_builder sel (nelt, nelt, 1);\n@@ -5438,7 +5438,7 @@ vect_permute_load_chain (vec<tree> dr_chain,\n       gcc_assert (pow2p_hwi (length));\n \n       /* The encoding has a single stepped pattern.  */\n-      unsigned int nelt = TYPE_VECTOR_SUBPARTS (vectype);\n+      poly_uint64 nelt = TYPE_VECTOR_SUBPARTS (vectype);\n       vec_perm_builder sel (nelt, 1, 3);\n       sel.quick_grow (3);\n       for (i = 0; i < 3; ++i)\n@@ -5581,12 +5581,12 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   unsigned int i;\n-  unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n-  unsigned HOST_WIDE_INT vf;\n-  if (!LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&vf))\n+  unsigned HOST_WIDE_INT nelt, vf;\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nelt)\n+      || !LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&vf))\n     /* Not supported for variable-length vectors.  */\n     return false;\n "}, {"sha": "d7e77b6ace37fdd647a28897853fad3ff065272d", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -50,7 +50,7 @@ static void expand_vector_operations_1 (gimple_stmt_iterator *);\n static unsigned int\n nunits_for_known_piecewise_op (const_tree type)\n {\n-  return TYPE_VECTOR_SUBPARTS (type);\n+  return TYPE_VECTOR_SUBPARTS (type).to_constant ();\n }\n \n /* Return true if TYPE1 has more elements than TYPE2, where either\n@@ -917,9 +917,9 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n      Similarly for vbfld_10 instead of x_2 < y_3.  */\n   if (VECTOR_BOOLEAN_TYPE_P (type)\n       && SCALAR_INT_MODE_P (TYPE_MODE (type))\n-      && (GET_MODE_BITSIZE (TYPE_MODE (type))\n-\t  < (TYPE_VECTOR_SUBPARTS (type)\n-\t     * GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type)))))\n+      && known_lt (GET_MODE_BITSIZE (TYPE_MODE (type)),\n+\t\t   TYPE_VECTOR_SUBPARTS (type)\n+\t\t   * GET_MODE_BITSIZE (SCALAR_TYPE_MODE (TREE_TYPE (type))))\n       && (a_is_comparison\n \t  ? useless_type_conversion_p (type, TREE_TYPE (a))\n \t  : expand_vec_cmp_expr_p (TREE_TYPE (a1), type, TREE_CODE (a))))\n@@ -1084,14 +1084,17 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n   tree lhs = gimple_assign_lhs (stmt);\n   tree rhs = gimple_assign_rhs1 (stmt);\n   tree type = TREE_TYPE (rhs);\n-  unsigned int i, j, nelts = TYPE_VECTOR_SUBPARTS (type);\n+  unsigned int i, j;\n+  unsigned HOST_WIDE_INT nelts;\n   bool all_same = true;\n   constructor_elt *elt;\n   gimple *g;\n   tree base = NULL_TREE;\n   optab op;\n \n-  if (nelts <= 2 || CONSTRUCTOR_NELTS (rhs) != nelts)\n+  if (!TYPE_VECTOR_SUBPARTS (type).is_constant (&nelts)\n+      || nelts <= 2\n+      || CONSTRUCTOR_NELTS (rhs) != nelts)\n     return;\n   op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n   if (op == unknown_optab\n@@ -1303,14 +1306,17 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n   tree mask_type = TREE_TYPE (mask);\n   tree vect_elt_type = TREE_TYPE (vect_type);\n   tree mask_elt_type = TREE_TYPE (mask_type);\n-  unsigned int elements = TYPE_VECTOR_SUBPARTS (vect_type);\n+  unsigned HOST_WIDE_INT elements;\n   vec<constructor_elt, va_gc> *v;\n   tree constr, t, si, i_val;\n   tree vec0tmp = NULL_TREE, vec1tmp = NULL_TREE, masktmp = NULL_TREE;\n   bool two_operand_p = !operand_equal_p (vec0, vec1, 0);\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n   unsigned i;\n \n+  if (!TYPE_VECTOR_SUBPARTS (vect_type).is_constant (&elements))\n+    return;\n+\n   if (TREE_CODE (mask) == SSA_NAME)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (mask);\n@@ -1338,17 +1344,18 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \t  && TREE_CODE (vec1) == VECTOR_CST\n \t  && initializer_zerop (vec1)\n \t  && maybe_ne (indices[0], 0)\n-\t  && known_lt (indices[0], elements))\n+\t  && known_lt (poly_uint64 (indices[0]), elements))\n \t{\n \t  bool ok_p = indices.series_p (0, 1, indices[0], 1);\n \t  if (!ok_p)\n \t    {\n \t      for (i = 1; i < elements; ++i)\n \t\t{\n-\t\t  poly_int64 expected = i + indices[0];\n+\t\t  poly_uint64 actual = indices[i];\n+\t\t  poly_uint64 expected = i + indices[0];\n \t\t  /* Indices into the second vector are all equivalent.  */\n-\t\t  if (maybe_lt (indices[i], elements)\n-\t\t      ? maybe_ne (indices[i], expected)\n+\t\t  if (maybe_lt (actual, elements)\n+\t\t      ? maybe_ne (actual, expected)\n \t\t      : maybe_lt (expected, elements))\n \t\t    break;\n \t\t}\n@@ -1472,7 +1479,7 @@ get_compute_type (enum tree_code code, optab op, tree type)\n \t= type_for_widest_vector_mode (TREE_TYPE (type), op);\n       if (vector_compute_type != NULL_TREE\n \t  && subparts_gt (compute_type, vector_compute_type)\n-\t  && TYPE_VECTOR_SUBPARTS (vector_compute_type) > 1\n+\t  && maybe_ne (TYPE_VECTOR_SUBPARTS (vector_compute_type), 1U)\n \t  && (optab_handler (op, TYPE_MODE (vector_compute_type))\n \t      != CODE_FOR_nothing))\n \tcompute_type = vector_compute_type;"}, {"sha": "a74992bbc9c3655f9663527cc8ea7e029ace6783", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -258,9 +258,11 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t}\n \n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"nunits = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t\t\t TYPE_VECTOR_SUBPARTS (vectype));\n+\t\t{\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"nunits = \");\n+\t\t  dump_dec (MSG_NOTE, TYPE_VECTOR_SUBPARTS (vectype));\n+\t\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t\t}\n \n \t      vect_update_max_nunits (&vectorization_factor, vectype);\n \t    }\n@@ -551,9 +553,11 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    }\n \n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"nunits = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t\t     TYPE_VECTOR_SUBPARTS (vf_vectype));\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"nunits = \");\n+\t      dump_dec (MSG_NOTE, TYPE_VECTOR_SUBPARTS (vf_vectype));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n+\t    }\n \n \t  vect_update_max_nunits (&vectorization_factor, vf_vectype);\n \n@@ -635,8 +639,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t      if (!mask_type)\n \t\tmask_type = vectype;\n-\t      else if (TYPE_VECTOR_SUBPARTS (mask_type)\n-\t\t       != TYPE_VECTOR_SUBPARTS (vectype))\n+\t      else if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n+\t\t\t\t TYPE_VECTOR_SUBPARTS (vectype)))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    {\n@@ -4156,7 +4160,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   scalar_type = TREE_TYPE (vector_type);\n   /* vectorizable_reduction has already rejected SLP reductions on\n      variable-length vectors.  */\n-  nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n+  nunits = TYPE_VECTOR_SUBPARTS (vector_type).to_constant ();\n \n   gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def);\n \n@@ -7733,9 +7737,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  if (STMT_VINFO_VECTYPE (stmt_info))\n \t    {\n-\t      unsigned int nunits\n-\t\t= (unsigned int)\n-\t\t  TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+\t      poly_uint64 nunits\n+\t\t= TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n \t      if (!STMT_SLP_TYPE (stmt_info)\n \t\t  && maybe_ne (nunits, vf)\n \t\t  && dump_enabled_p ())"}, {"sha": "01806e7b8c5e27c2a568682d6188e290f86a905d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -3714,8 +3714,9 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n          vectorized matches the vector type of the result in\n \t size and number of elements.  */\n       unsigned prec\n-\t= wi::udiv_trunc (wi::to_wide (TYPE_SIZE (vectype)),\n-\t\t\t  TYPE_VECTOR_SUBPARTS (vectype)).to_uhwi ();\n+\t= vector_element_size (tree_to_poly_uint64 (TYPE_SIZE (vectype)),\n+\t\t\t       TYPE_VECTOR_SUBPARTS (vectype));\n+\n       tree type\n \t= build_nonstandard_integer_type (prec,\n \t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (var)));\n@@ -3898,7 +3899,8 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n       vectype2 = get_mask_type_for_scalar_type (rhs1_type);\n \n       if (!vectype1 || !vectype2\n-\t  || TYPE_VECTOR_SUBPARTS (vectype1) == TYPE_VECTOR_SUBPARTS (vectype2))\n+\t  || known_eq (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n \treturn NULL;\n \n       tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n@@ -3973,15 +3975,17 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n       vectype2 = get_mask_type_for_scalar_type (rhs1_type);\n \n       if (!vectype1 || !vectype2\n-\t  || TYPE_VECTOR_SUBPARTS (vectype1) == TYPE_VECTOR_SUBPARTS (vectype2))\n+\t  || known_eq (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n \treturn NULL;\n \n       /* If rhs1 is invariant and we can promote it leave the COND_EXPR\n          in place, we can handle it in vectorizable_condition.  This avoids\n \t unnecessary promotion stmts and increased vectorization factor.  */\n       if (COMPARISON_CLASS_P (rhs1)\n \t  && INTEGRAL_TYPE_P (rhs1_type)\n-\t  && TYPE_VECTOR_SUBPARTS (vectype1) < TYPE_VECTOR_SUBPARTS (vectype2))\n+\t  && known_le (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n \t{\n \t  gimple *dummy;\n \t  enum vect_def_type dt;"}, {"sha": "2563fc008a8b0d9056e28e1124807e55b30a3dd0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1625,15 +1625,16 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t      stmt_vec_info group_info\n \t\t= vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n \t      group_info = vinfo_for_stmt (GROUP_FIRST_ELEMENT (group_info));\n-\t      unsigned nunits\n-\t\t= TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (group_info));\n+\t      unsigned HOST_WIDE_INT nunits;\n \t      unsigned k, maxk = 0;\n \t      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (node), j, k)\n \t\tif (k > maxk)\n \t\t  maxk = k;\n \t      /* In BB vectorization we may not actually use a loaded vector\n \t\t accessing elements in excess of GROUP_SIZE.  */\n-\t      if (maxk >= (GROUP_SIZE (group_info) & ~(nunits - 1)))\n+\t      tree vectype = STMT_VINFO_VECTYPE (group_info);\n+\t      if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n+\t\t  || maxk >= (GROUP_SIZE (group_info) & ~(nunits - 1)))\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"BB vectorization with gaps at the end of \"\n@@ -3257,7 +3258,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   else\n     vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n   /* Enforced by vect_get_and_check_slp_defs.  */\n-  nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n+  nunits = TYPE_VECTOR_SUBPARTS (vector_type).to_constant ();\n \n   if (STMT_VINFO_DATA_REF (stmt_vinfo))\n     {\n@@ -3616,12 +3617,12 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree mask_element_type = NULL_TREE, mask_type;\n-  int nunits, vec_index = 0;\n+  int vec_index = 0;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n-  int mask_element;\n+  unsigned int mask_element;\n   machine_mode mode;\n-  unsigned HOST_WIDE_INT const_vf;\n+  unsigned HOST_WIDE_INT nunits, const_vf;\n \n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n@@ -3631,16 +3632,17 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   mode = TYPE_MODE (vectype);\n \n   /* At the moment, all permutations are represented using per-element\n-     indices, so we can't cope with variable vectorization factors.  */\n-  if (!vf.is_constant (&const_vf))\n+     indices, so we can't cope with variable vector lengths or\n+     vectorization factors.  */\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n+      || !vf.is_constant (&const_vf))\n     return false;\n \n   /* The generic VEC_PERM_EXPR code always uses an integral type of the\n      same size as the vector element being permuted.  */\n   mask_element_type = lang_hooks.types.type_for_mode\n     (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   vec_perm_builder mask (nunits, nunits, 1);\n   mask.quick_grow (nunits);\n   vec_perm_indices indices;\n@@ -3671,7 +3673,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n      {c2,a3,b3,c3}.  */\n \n   int vect_stmts_counter = 0;\n-  int index = 0;\n+  unsigned int index = 0;\n   int first_vec_index = -1;\n   int second_vec_index = -1;\n   bool noop_p = true;\n@@ -3681,8 +3683,8 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n     {\n       for (int k = 0; k < group_size; k++)\n \t{\n-\t  int i = (SLP_TREE_LOAD_PERMUTATION (node)[k]\n-\t\t   + j * STMT_VINFO_GROUP_SIZE (stmt_info));\n+\t  unsigned int i = (SLP_TREE_LOAD_PERMUTATION (node)[k]\n+\t\t\t    + j * STMT_VINFO_GROUP_SIZE (stmt_info));\n \t  vec_index = i / nunits;\n \t  mask_element = i % nunits;\n \t  if (vec_index == first_vec_index\n@@ -3710,8 +3712,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t      return false;\n \t    }\n \n-\t  gcc_assert (mask_element >= 0\n-\t\t      && mask_element < 2 * nunits);\n+\t  gcc_assert (mask_element < 2 * nunits);\n \t  if (mask_element != index)\n \t    noop_p = false;\n \t  mask[index++] = mask_element;"}, {"sha": "14ffdd4aa65c101b7045e8c9cae22465246fbc2e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 56, "deletions": 47, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1721,13 +1721,11 @@ compare_step_with_zero (gimple *stmt)\n static tree\n perm_mask_for_reverse (tree vectype)\n {\n-  int i, nunits;\n-\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* The encoding has a single stepped pattern.  */\n   vec_perm_builder sel (nunits, 1, 3);\n-  for (i = 0; i < 3; ++i)\n+  for (int i = 0; i < 3; ++i)\n     sel.quick_push (nunits - 1 - i);\n \n   vec_perm_indices indices (sel, 1, nunits);\n@@ -1760,7 +1758,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n   bool single_element_p = (stmt == first_stmt\n \t\t\t   && !GROUP_NEXT_ELEMENT (stmt_info));\n   unsigned HOST_WIDE_INT gap = GROUP_GAP (vinfo_for_stmt (first_stmt));\n-  unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* True if the vectorized statements would access beyond the last\n      statement in the group.  */\n@@ -1784,7 +1782,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t  /* Try to use consecutive accesses of GROUP_SIZE elements,\n \t     separated by the stride, until we have a complete vector.\n \t     Fall back to scalar accesses if that isn't possible.  */\n-\t  if (nunits % group_size == 0)\n+\t  if (multiple_p (nunits, group_size))\n \t    *memory_access_type = VMAT_STRIDED_SLP;\n \t  else\n \t    *memory_access_type = VMAT_ELEMENTWISE;\n@@ -2112,7 +2110,8 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n     mask_vectype = get_mask_type_for_scalar_type (TREE_TYPE (vectype));\n \n   if (!mask_vectype || !VECTOR_BOOLEAN_TYPE_P (mask_vectype)\n-      || TYPE_VECTOR_SUBPARTS (mask_vectype) != TYPE_VECTOR_SUBPARTS (vectype))\n+      || maybe_ne (TYPE_VECTOR_SUBPARTS (mask_vectype),\n+\t\t   TYPE_VECTOR_SUBPARTS (vectype)))\n     return false;\n \n   if (gimple_call_internal_fn (stmt) == IFN_MASK_STORE)\n@@ -2269,8 +2268,8 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t  if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n \t    {\n-\t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n-\t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n+\t      gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op)),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (idxtype)));\n \t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n@@ -2295,8 +2294,9 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      mask_op = vec_mask;\n \t      if (!useless_type_conversion_p (masktype, TREE_TYPE (vec_mask)))\n \t\t{\n-\t\t  gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask_op))\n-\t\t\t      == TYPE_VECTOR_SUBPARTS (masktype));\n+\t\t  gcc_assert\n+\t\t    (known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask_op)),\n+\t\t\t       TYPE_VECTOR_SUBPARTS (masktype)));\n \t\t  var = vect_get_new_ssa_name (masktype, vect_simple_var);\n \t\t  mask_op = build1 (VIEW_CONVERT_EXPR, masktype, mask_op);\n \t\t  new_stmt\n@@ -2312,8 +2312,8 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t  if (!useless_type_conversion_p (vectype, rettype))\n \t    {\n-\t      gcc_assert (TYPE_VECTOR_SUBPARTS (vectype)\n-\t\t\t  == TYPE_VECTOR_SUBPARTS (rettype));\n+\t      gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (rettype)));\n \t      op = vect_get_new_ssa_name (rettype, vect_simple_var);\n \t      gimple_call_set_lhs (new_stmt, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -2507,11 +2507,14 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree op, vectype;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  unsigned ncopies, nunits;\n+  unsigned ncopies;\n+  unsigned HOST_WIDE_INT nunits, num_bytes;\n \n   op = gimple_call_arg (stmt, 0);\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n+    return false;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n@@ -2527,7 +2530,9 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (! char_vectype)\n     return false;\n \n-  unsigned int num_bytes = TYPE_VECTOR_SUBPARTS (char_vectype);\n+  if (!TYPE_VECTOR_SUBPARTS (char_vectype).is_constant (&num_bytes))\n+    return false;\n+\n   unsigned word_bytes = num_bytes / nunits;\n \n   /* The encoding uses one stepped pattern for each byte in the word.  */\n@@ -3226,7 +3231,7 @@ vect_simd_lane_linear (tree op, struct loop *loop,\n static unsigned HOST_WIDE_INT\n simd_clone_subparts (tree vectype)\n {\n-  return TYPE_VECTOR_SUBPARTS (vectype);\n+  return TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n }\n \n /* Function vectorizable_simd_clone_call.\n@@ -4745,7 +4750,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n     op = TREE_OPERAND (op, 0);\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n@@ -4770,7 +4775,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   if ((CONVERT_EXPR_CODE_P (code)\n        || code == VIEW_CONVERT_EXPR)\n       && (!vectype_in\n-\t  || TYPE_VECTOR_SUBPARTS (vectype_in) != nunits\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (vectype_in), nunits)\n \t  || (GET_MODE_SIZE (TYPE_MODE (vectype))\n \t      != GET_MODE_SIZE (TYPE_MODE (vectype_in)))))\n     return false;\n@@ -4919,8 +4924,8 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   int ndts = 2;\n   gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n-  int nunits_in;\n-  int nunits_out;\n+  poly_uint64 nunits_in;\n+  poly_uint64 nunits_out;\n   tree vectype_out;\n   tree op1_vectype;\n   int ncopies;\n@@ -4987,7 +4992,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (nunits_out != nunits_in)\n+  if (maybe_ne (nunits_out, nunits_in))\n     return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n@@ -5287,8 +5292,8 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   int ndts = 3;\n   gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n-  int nunits_in;\n-  int nunits_out;\n+  poly_uint64 nunits_in;\n+  poly_uint64 nunits_out;\n   tree vectype_out;\n   int ncopies;\n   int j, i;\n@@ -5400,7 +5405,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (nunits_out != nunits_in)\n+  if (maybe_ne (nunits_out, nunits_in))\n     return false;\n \n   if (op_type == binary_op || op_type == ternary_op)\n@@ -5972,8 +5977,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  if (!useless_type_conversion_p (srctype, TREE_TYPE (src)))\n \t    {\n-\t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (src))\n-\t\t\t  == TYPE_VECTOR_SUBPARTS (srctype));\n+\t      gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (src)),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (srctype)));\n \t      var = vect_get_new_ssa_name (srctype, vect_simple_var);\n \t      src = build1 (VIEW_CONVERT_EXPR, srctype, src);\n \t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, src);\n@@ -5983,8 +5988,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n \t    {\n-\t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n-\t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n+\t      gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op)),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (idxtype)));\n \t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n@@ -7023,8 +7028,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n \t    {\n-\t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n-\t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n+\t      gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op)),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (idxtype)));\n \t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n@@ -7038,8 +7043,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  if (!useless_type_conversion_p (vectype, rettype))\n \t    {\n-\t      gcc_assert (TYPE_VECTOR_SUBPARTS (vectype)\n-\t\t\t  == TYPE_VECTOR_SUBPARTS (rettype));\n+\t      gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (rettype)));\n \t      op = vect_get_new_ssa_name (rettype, vect_simple_var);\n \t      gimple_call_set_lhs (new_stmt, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -7936,7 +7941,8 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n     return false;\n \n   if (vectype1 && vectype2\n-      && TYPE_VECTOR_SUBPARTS (vectype1) != TYPE_VECTOR_SUBPARTS (vectype2))\n+      && maybe_ne (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t   TYPE_VECTOR_SUBPARTS (vectype2)))\n     return false;\n \n   *comp_vectype = vectype1 ? vectype1 : vectype2;\n@@ -8353,7 +8359,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum vect_def_type dts[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int ndts = 2;\n-  unsigned nunits;\n+  poly_uint64 nunits;\n   int ncopies;\n   enum tree_code code, bitop1 = NOP_EXPR, bitop2 = NOP_EXPR;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -8413,7 +8419,8 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   if (vectype1 && vectype2\n-      && TYPE_VECTOR_SUBPARTS (vectype1) != TYPE_VECTOR_SUBPARTS (vectype2))\n+      && maybe_ne (TYPE_VECTOR_SUBPARTS (vectype1),\n+\t\t   TYPE_VECTOR_SUBPARTS (vectype2)))\n     return false;\n \n   vectype = vectype1 ? vectype1 : vectype2;\n@@ -8422,10 +8429,10 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vectype)\n     {\n       vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n-      if (TYPE_VECTOR_SUBPARTS (vectype) != nunits)\n+      if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype), nunits))\n \treturn false;\n     }\n-  else if (nunits != TYPE_VECTOR_SUBPARTS (vectype))\n+  else if (maybe_ne (nunits, TYPE_VECTOR_SUBPARTS (vectype)))\n     return false;\n \n   /* Can't compare mask and non-mask types.  */\n@@ -9656,8 +9663,8 @@ supportable_widening_operation (enum tree_code code, gimple *stmt,\n \t vector types having the same QImode.  Thus we\n \t add additional check for elements number.  */\n     return (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t    || (TYPE_VECTOR_SUBPARTS (vectype) / 2\n-\t\t== TYPE_VECTOR_SUBPARTS (wide_vectype)));\n+\t    || known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t TYPE_VECTOR_SUBPARTS (wide_vectype) * 2));\n \n   /* Check if it's a multi-step conversion that can be done using intermediate\n      types.  */\n@@ -9678,8 +9685,10 @@ supportable_widening_operation (enum tree_code code, gimple *stmt,\n       intermediate_mode = insn_data[icode1].operand[0].mode;\n       if (VECTOR_BOOLEAN_TYPE_P (prev_type))\n \t{\n+\t  poly_uint64 intermediate_nelts\n+\t    = exact_div (TYPE_VECTOR_SUBPARTS (prev_type), 2);\n \t  intermediate_type\n-\t    = build_truth_vector_type (TYPE_VECTOR_SUBPARTS (prev_type) / 2,\n+\t    = build_truth_vector_type (intermediate_nelts,\n \t\t\t\t       current_vector_size);\n \t  if (intermediate_mode != TYPE_MODE (intermediate_type))\n \t    return false;\n@@ -9709,8 +9718,8 @@ supportable_widening_operation (enum tree_code code, gimple *stmt,\n       if (insn_data[icode1].operand[0].mode == TYPE_MODE (wide_vectype)\n \t  && insn_data[icode2].operand[0].mode == TYPE_MODE (wide_vectype))\n \treturn (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t\t|| (TYPE_VECTOR_SUBPARTS (intermediate_type) / 2\n-\t\t    == TYPE_VECTOR_SUBPARTS (wide_vectype)));\n+\t\t|| known_eq (TYPE_VECTOR_SUBPARTS (intermediate_type),\n+\t\t\t     TYPE_VECTOR_SUBPARTS (wide_vectype) * 2));\n \n       prev_type = intermediate_type;\n       prev_mode = intermediate_mode;\n@@ -9798,8 +9807,8 @@ supportable_narrowing_operation (enum tree_code code,\n        vector types having the same QImode.  Thus we\n        add additional check for elements number.  */\n     return (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t    || (TYPE_VECTOR_SUBPARTS (vectype) * 2\n-\t\t== TYPE_VECTOR_SUBPARTS (narrow_vectype)));\n+\t    || known_eq (TYPE_VECTOR_SUBPARTS (vectype) * 2,\n+\t\t\t TYPE_VECTOR_SUBPARTS (narrow_vectype)));\n \n   /* Check if it's a multi-step conversion that can be done using intermediate\n      types.  */\n@@ -9865,8 +9874,8 @@ supportable_narrowing_operation (enum tree_code code,\n \n       if (insn_data[icode1].operand[0].mode == TYPE_MODE (narrow_vectype))\n \treturn (!VECTOR_BOOLEAN_TYPE_P (vectype)\n-\t\t|| (TYPE_VECTOR_SUBPARTS (intermediate_type) * 2\n-\t\t    == TYPE_VECTOR_SUBPARTS (narrow_vectype)));\n+\t\t|| known_eq (TYPE_VECTOR_SUBPARTS (intermediate_type) * 2,\n+\t\t\t     TYPE_VECTOR_SUBPARTS (narrow_vectype)));\n \n       prev_mode = intermediate_mode;\n       prev_type = intermediate_type;"}, {"sha": "08652a20f497fc5a592f9aca0778e035b11d8b25", "filename": "gcc/tree-vector-builder.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -108,14 +108,17 @@ tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n unsigned int\n tree_vector_builder::binary_encoded_nelts (tree t1, tree t2)\n {\n-  unsigned int nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1));\n-  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2)));\n+  poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1));\n+  gcc_assert (known_eq (nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2))));\n   /* See new_binary_operation for details.  */\n   unsigned int npatterns = least_common_multiple (VECTOR_CST_NPATTERNS (t1),\n \t\t\t\t\t\t  VECTOR_CST_NPATTERNS (t2));\n   unsigned int nelts_per_pattern = MAX (VECTOR_CST_NELTS_PER_PATTERN (t1),\n \t\t\t\t\tVECTOR_CST_NELTS_PER_PATTERN (t2));\n-  return MIN (npatterns * nelts_per_pattern, nelts);\n+  unsigned HOST_WIDE_INT const_nelts;\n+  if (nelts.is_constant (&const_nelts))\n+    return MIN (npatterns * nelts_per_pattern, const_nelts);\n+  return npatterns * nelts_per_pattern;\n }\n \n /* Return a vector element with the value BASE + FACTOR * STEP.  */"}, {"sha": "d2631294662f98f1201d1fe3e3f458675760fdad", "filename": "gcc/tree.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -1851,16 +1851,21 @@ make_vector (unsigned log2_npatterns,\n tree\n build_vector_from_ctor (tree type, vec<constructor_elt, va_gc> *v)\n {\n-  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n-  unsigned HOST_WIDE_INT idx;\n+  unsigned HOST_WIDE_INT idx, nelts;\n   tree value;\n \n+  /* We can't construct a VECTOR_CST for a variable number of elements.  */\n+  nelts = TYPE_VECTOR_SUBPARTS (type).to_constant ();\n   tree_vector_builder vec (type, nelts, 1);\n   FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n     {\n       if (TREE_CODE (value) == VECTOR_CST)\n-\tfor (unsigned i = 0; i < VECTOR_CST_NELTS (value); ++i)\n-\t  vec.quick_push (VECTOR_CST_ELT (value, i));\n+\t{\n+\t  /* If NELTS is constant then this must be too.  */\n+\t  unsigned int sub_nelts = VECTOR_CST_NELTS (value).to_constant ();\n+\t  for (unsigned i = 0; i < sub_nelts; ++i)\n+\t    vec.quick_push (VECTOR_CST_ELT (value, i));\n+\t}\n       else\n \tvec.quick_push (value);\n     }\n@@ -1872,9 +1877,9 @@ build_vector_from_ctor (tree type, vec<constructor_elt, va_gc> *v)\n \n /* Build a vector of type VECTYPE where all the elements are SCs.  */\n tree\n-build_vector_from_val (tree vectype, tree sc) \n+build_vector_from_val (tree vectype, tree sc)\n {\n-  int i, nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned HOST_WIDE_INT i, nunits;\n \n   if (sc == error_mark_node)\n     return sc;\n@@ -1894,7 +1899,7 @@ build_vector_from_val (tree vectype, tree sc)\n       v.quick_push (sc);\n       return v.build ();\n     }\n-  else if (0)\n+  else if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n     return fold_build1 (VEC_DUPLICATE_EXPR, vectype, sc);\n   else\n     {\n@@ -6497,11 +6502,8 @@ type_hash_canon_hash (tree type)\n       }\n \n     case VECTOR_TYPE:\n-      {\n-\tunsigned nunits = TYPE_VECTOR_SUBPARTS (type);\n-\thstate.add_object (nunits);\n-\tbreak;\n-      }\n+      hstate.add_poly_int (TYPE_VECTOR_SUBPARTS (type));\n+      break;\n \n     default:\n       break;\n@@ -6545,7 +6547,8 @@ type_cache_hasher::equal (type_hash *a, type_hash *b)\n       return 1;\n \n     case VECTOR_TYPE:\n-      return TYPE_VECTOR_SUBPARTS (a->type) == TYPE_VECTOR_SUBPARTS (b->type);\n+      return known_eq (TYPE_VECTOR_SUBPARTS (a->type),\n+\t\t       TYPE_VECTOR_SUBPARTS (b->type));\n \n     case ENUMERAL_TYPE:\n       if (TYPE_VALUES (a->type) != TYPE_VALUES (b->type)\n@@ -9610,7 +9613,7 @@ make_vector_type (tree innertype, poly_int64 nunits, machine_mode mode)\n \n   t = make_node (VECTOR_TYPE);\n   TREE_TYPE (t) = mv_innertype;\n-  SET_TYPE_VECTOR_SUBPARTS (t, nunits.to_constant ()); /* Temporary */\n+  SET_TYPE_VECTOR_SUBPARTS (t, nunits);\n   SET_TYPE_MODE (t, mode);\n \n   if (TYPE_STRUCTURAL_EQUALITY_P (mv_innertype) || in_lto_p)\n@@ -10533,7 +10536,7 @@ build_vector_type_for_mode (tree innertype, machine_mode mode)\n    a power of two.  */\n \n tree\n-build_vector_type (tree innertype, int nunits)\n+build_vector_type (tree innertype, poly_int64 nunits)\n {\n   return make_vector_type (innertype, nunits, VOIDmode);\n }\n@@ -10578,7 +10581,7 @@ build_same_sized_truth_vector_type (tree vectype)\n /* Similarly, but builds a variant type with TYPE_VECTOR_OPAQUE set.  */\n \n tree\n-build_opaque_vector_type (tree innertype, int nunits)\n+build_opaque_vector_type (tree innertype, poly_int64 nunits)\n {\n   tree t = make_vector_type (innertype, nunits, VOIDmode);\n   tree cand;\n@@ -10727,7 +10730,7 @@ tree\n uniform_vector_p (const_tree vec)\n {\n   tree first, t;\n-  unsigned i;\n+  unsigned HOST_WIDE_INT i, nelts;\n \n   if (vec == NULL_TREE)\n     return NULL_TREE;\n@@ -10744,7 +10747,8 @@ uniform_vector_p (const_tree vec)\n       return NULL_TREE;\n     }\n \n-  else if (TREE_CODE (vec) == CONSTRUCTOR)\n+  else if (TREE_CODE (vec) == CONSTRUCTOR\n+\t   && TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec)).is_constant (&nelts))\n     {\n       first = error_mark_node;\n \n@@ -10758,7 +10762,7 @@ uniform_vector_p (const_tree vec)\n \t  if (!operand_equal_p (first, t, 0))\n \t    return NULL_TREE;\n         }\n-      if (i != TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec)))\n+      if (i != nelts)\n \treturn NULL_TREE;\n \n       return first;\n@@ -13034,8 +13038,8 @@ vector_type_mode (const_tree t)\n       /* For integers, try mapping it to a same-sized scalar mode.  */\n       if (is_int_mode (TREE_TYPE (t)->type_common.mode, &innermode))\n \t{\n-\t  unsigned int size = (TYPE_VECTOR_SUBPARTS (t)\n-\t\t\t       * GET_MODE_BITSIZE (innermode));\n+\t  poly_int64 size = (TYPE_VECTOR_SUBPARTS (t)\n+\t\t\t     * GET_MODE_BITSIZE (innermode));\n \t  scalar_int_mode mode;\n \t  if (int_mode_for_size (size, 0).exists (&mode)\n \t      && have_regs_of_mode[mode])\n@@ -14319,7 +14323,7 @@ test_labels ()\n static tree\n build_vector (tree type, vec<tree> vals MEM_STAT_DECL)\n {\n-  gcc_assert (vals.length () == TYPE_VECTOR_SUBPARTS (type));\n+  gcc_assert (known_eq (vals.length (), TYPE_VECTOR_SUBPARTS (type)));\n   tree_vector_builder builder (type, vals.length (), 1);\n   builder.splice (vals);\n   return builder.build ();\n@@ -14330,7 +14334,8 @@ build_vector (tree type, vec<tree> vals MEM_STAT_DECL)\n static void\n check_vector_cst (vec<tree> expected, tree actual)\n {\n-  ASSERT_EQ (expected.length (), TYPE_VECTOR_SUBPARTS (TREE_TYPE (actual)));\n+  ASSERT_KNOWN_EQ (expected.length (),\n+\t\t   TYPE_VECTOR_SUBPARTS (TREE_TYPE (actual)));\n   for (unsigned int i = 0; i < expected.length (); ++i)\n     ASSERT_EQ (wi::to_wide (expected[i]),\n \t       wi::to_wide (vector_cst_elt (actual, i)));"}, {"sha": "60c44118a3b28025f633ac8f1f48bb135abe7e9a", "filename": "gcc/tree.h", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -2035,15 +2035,6 @@ extern machine_mode vector_type_mode (const_tree);\n    If set in a INTEGER_TYPE, indicates a character type.  */\n #define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type_common.string_flag)\n \n-/* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n-#define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n-  (HOST_WIDE_INT_1U \\\n-   << VECTOR_TYPE_CHECK (VECTOR_TYPE)->type_common.precision)\n-\n-/* Set precision to n when we have 2^n sub-parts of the vector.  */\n-#define SET_TYPE_VECTOR_SUBPARTS(VECTOR_TYPE, X) \\\n-  (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type_common.precision = exact_log2 (X))\n-\n /* Nonzero in a VECTOR_TYPE if the frontends should not emit warnings\n    about missing conversions to other vector types of the same size.  */\n #define TYPE_VECTOR_OPAQUE(NODE) \\\n@@ -3677,6 +3668,64 @@ id_equal (const char *str, const_tree id)\n   return !strcmp (str, IDENTIFIER_POINTER (id));\n }\n \n+/* Return the number of elements in the VECTOR_TYPE given by NODE.  */\n+\n+inline poly_uint64\n+TYPE_VECTOR_SUBPARTS (const_tree node)\n+{\n+  STATIC_ASSERT (NUM_POLY_INT_COEFFS <= 2);\n+  unsigned int precision = VECTOR_TYPE_CHECK (node)->type_common.precision;\n+  if (NUM_POLY_INT_COEFFS == 2)\n+    {\n+      poly_uint64 res = 0;\n+      res.coeffs[0] = 1 << (precision & 0xff);\n+      if (precision & 0x100)\n+\tres.coeffs[1] = 1 << (precision & 0xff);\n+      return res;\n+    }\n+  else\n+    return 1 << precision;\n+}\n+\n+/* Set the number of elements in VECTOR_TYPE NODE to SUBPARTS, which must\n+   satisfy valid_vector_subparts_p.  */\n+\n+inline void\n+SET_TYPE_VECTOR_SUBPARTS (tree node, poly_uint64 subparts)\n+{\n+  STATIC_ASSERT (NUM_POLY_INT_COEFFS <= 2);\n+  unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];\n+  int index = exact_log2 (coeff0);\n+  gcc_assert (index >= 0);\n+  if (NUM_POLY_INT_COEFFS == 2)\n+    {\n+      unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];\n+      gcc_assert (coeff1 == 0 || coeff1 == coeff0);\n+      VECTOR_TYPE_CHECK (node)->type_common.precision\n+\t= index + (coeff1 != 0 ? 0x100 : 0);\n+    }\n+  else\n+    VECTOR_TYPE_CHECK (node)->type_common.precision = index;\n+}\n+\n+/* Return true if we can construct vector types with the given number\n+   of subparts.  */\n+\n+static inline bool\n+valid_vector_subparts_p (poly_uint64 subparts)\n+{\n+  unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];\n+  if (!pow2p_hwi (coeff0))\n+    return false;\n+  if (NUM_POLY_INT_COEFFS == 2)\n+    {\n+      unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];\n+      if (coeff1 != 0 && coeff1 != coeff0)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n #define error_mark_node\t\t\tglobal_trees[TI_ERROR_MARK]\n \n #define intQI_type_node\t\t\tglobal_trees[TI_INTQI_TYPE]\n@@ -4121,16 +4170,10 @@ extern tree build_pointer_type (tree);\n extern tree build_reference_type_for_mode (tree, machine_mode, bool);\n extern tree build_reference_type (tree);\n extern tree build_vector_type_for_mode (tree, machine_mode);\n-extern tree build_vector_type (tree innertype, int nunits);\n-/* Temporary.  */\n-inline tree\n-build_vector_type (tree innertype, poly_uint64 nunits)\n-{\n-  return build_vector_type (innertype, (int) nunits.to_constant ());\n-}\n+extern tree build_vector_type (tree, poly_int64);\n extern tree build_truth_vector_type (poly_uint64, poly_uint64);\n extern tree build_same_sized_truth_vector_type (tree vectype);\n-extern tree build_opaque_vector_type (tree innertype, int nunits);\n+extern tree build_opaque_vector_type (tree, poly_int64);\n extern tree build_index_type (tree);\n extern tree build_array_type (tree, tree, bool = false);\n extern tree build_nonshared_array_type (tree, tree);"}, {"sha": "915b99bbf22494e9ef4a33bcc09a8f560e47ccb3", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928686b1c6d0a8b791ec08b2588a5fb8118d191c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=928686b1c6d0a8b791ec08b2588a5fb8118d191c", "patch": "@@ -4920,7 +4920,9 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align,\n \t    output_constant (VECTOR_CST_ELT (exp, 0), elt_size, align,\n \t\t\t     reverse);\n \t    thissize = elt_size;\n-\t    for (unsigned int i = 1; i < VECTOR_CST_NELTS (exp); i++)\n+\t    /* Static constants must have a fixed size.  */\n+\t    unsigned int nunits = VECTOR_CST_NELTS (exp).to_constant ();\n+\t    for (unsigned int i = 1; i < nunits; i++)\n \t      {\n \t\toutput_constant (VECTOR_CST_ELT (exp, i), elt_size, nalign,\n \t\t\t\t reverse);"}]}