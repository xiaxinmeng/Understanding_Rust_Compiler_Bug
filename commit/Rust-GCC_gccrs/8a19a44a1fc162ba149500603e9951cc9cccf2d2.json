{"sha": "8a19a44a1fc162ba149500603e9951cc9cccf2d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExOWE0NGExZmMxNjJiYTE0OTUwMDYwM2U5OTUxY2M5Y2NjZjJkMg==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-04-17T11:45:01Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-04-17T11:45:01Z"}, "message": "forgot to add ffe.texi, the actual g77 front-end internals docs\n\nFrom-SVN: r26518", "tree": {"sha": "1ed70f51cb9c41ce52d1af38fa9e94d2b3cad5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ed70f51cb9c41ce52d1af38fa9e94d2b3cad5c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a19a44a1fc162ba149500603e9951cc9cccf2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a19a44a1fc162ba149500603e9951cc9cccf2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a19a44a1fc162ba149500603e9951cc9cccf2d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a19a44a1fc162ba149500603e9951cc9cccf2d2/comments", "author": null, "committer": null, "parents": [{"sha": "0f4668ef1ac72bd6e64d97cc72e8d182755ce7ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4668ef1ac72bd6e64d97cc72e8d182755ce7ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4668ef1ac72bd6e64d97cc72e8d182755ce7ed"}], "stats": {"total": 883, "additions": 883, "deletions": 0}, "files": [{"sha": "4948050074aa74dc790d88db05d4390452b5cb35", "filename": "gcc/f/ffe.texi", "status": "added", "additions": 883, "deletions": 0, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a19a44a1fc162ba149500603e9951cc9cccf2d2/gcc%2Ff%2Fffe.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a19a44a1fc162ba149500603e9951cc9cccf2d2/gcc%2Ff%2Fffe.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fffe.texi?ref=8a19a44a1fc162ba149500603e9951cc9cccf2d2", "patch": "@@ -0,0 +1,883 @@\n+@node Front End\n+@chapter Front End\n+@cindex GNU Fortran Front End (FFE)\n+@cindex FFE\n+@cindex @code{g77}, front end\n+@cindex front end, @code{g77}\n+\n+This chapter describes some aspects of the design and implementation\n+of the @code{g77} front end.\n+\n+@menu\n+* Philosophy of Code Generation::\n+* Two-pass Design::\n+* Challenges Posed::\n+* Transforming Statements::\n+* Transforming Expressions::\n+@end menu\n+\n+@node Philosophy of Code Generation\n+@section Philosophy of Code Generation\n+\n+Don't poke the bear.\n+\n+The @code{g77} front end generates code\n+via the @code{gcc} back end.\n+\n+@cindex GNU Back End (GBE)\n+@cindex GBE\n+@cindex @code{gcc}, back end\n+@cindex back end, gcc\n+@cindex code generator\n+The @code{gcc} back end (GBE) is a large, complex\n+labyrinth of intricate code\n+written in a combination of the C language\n+and specialized languages internal to @code{gcc}.\n+\n+While the @emph{code} that implements the GBE\n+is written in a combination of languages,\n+the GBE itself is,\n+to the front end for a language like Fortran,\n+best viewed as a @emph{compiler}\n+that compiles its own, unique, language.\n+\n+The GBE's ``source'', then, is written in this language,\n+which consists primarily of\n+a combination of calls to GBE functions\n+and @dfn{tree} nodes\n+(which are, themselves, created\n+by calling GBE functions).\n+\n+So, the @code{g77} generates code by, in effect,\n+translating the Fortran code it reads\n+into a form ``written'' in the ``language''\n+of the @code{gcc} back end.\n+\n+@cindex GBEL\n+@cindex GNU Back End Language (GBEL)\n+This language will heretofore be referred to as @dfn{GBEL},\n+for GNU Back End Language.\n+\n+GBEL is an evolving language,\n+not fully specified in any published form\n+as of this writing.\n+It offers many facilities,\n+but its ``core'' facilities\n+are those that corresponding most directly\n+to those needed to support @code{gcc}\n+(compiling code written in GNU C).\n+\n+The @code{g77} Fortran Front End (FFE)\n+is designed and implemented\n+to navigate the currents and eddies\n+of ongoing GBEL and @code{gcc} development\n+while also delivering on the potential\n+of an integrated FFE\n+(as compared to using a converter like @code{f2c}\n+and feeding the output into @code{gcc}).\n+\n+Goals of the FFE's code-generation strategy include:\n+\n+@itemize @bullet\n+@item\n+High likelihood of generation of correct code,\n+or, failing that, producing a fatal diagnostic or crashing.\n+\n+@item\n+Generation of highly optimized code,\n+as directed by the user\n+via GBE-specific (versus @code{g77}-specific) constructs,\n+such as command-line options.\n+\n+@item\n+Fast overall (FFE plus GBE) compilation.\n+\n+@item\n+Preservation of source-level debugging information.\n+@end itemize\n+\n+The strategies historically, and currently, used by the FFE\n+to achieve these goals include:\n+\n+@itemize @bullet\n+@item\n+Use of GBEL constructs that most faithfully encapsulate\n+the semantics of Fortran.\n+\n+@item\n+Avoidance of GBEL constructs that are so rarely used,\n+or limited to use in specialized situations not related to Fortran,\n+that their reliability and performance has not yet been established\n+as sufficient for use by the FFE.\n+\n+@item\n+Flexible design, to readily accommodate changes to specific\n+code-generation strategies, perhaps governed by command-line options.\n+@end itemize\n+\n+@cindex Bear-poking\n+@cindex Poking the bear\n+``Don't poke the bear'' somewhat summarizes the above strategies.\n+The GBE is the bear.\n+The FFE is designed and implemented to avoid poking it\n+in ways that are likely to just annoy it.\n+The FFE usually either tackles it head-on,\n+or avoids treating it in ways dissimilar to how\n+the @code{gcc} front end treats it.\n+\n+For example, the FFE uses the native array facility in the back end\n+instead of the lower-level pointer-arithmetic facility\n+used by @code{gcc} when compiling @code{f2c} output).\n+Theoretically, this presents more opportunities for optimization,\n+faster compile times,\n+and the production of more faithful debugging information.\n+These benefits were not, however, immediately realized,\n+mainly because @code{gcc} itself makes little or no use\n+of the native array facility.\n+\n+Complex arithmetic is a case study of the evolution of this strategy.\n+When originally implemented,\n+the GBEL had just evolved its own native complex-arithmetic facility,\n+so the FFE took advantage of that.\n+\n+When porting @code{g77} to 64-bit systems,\n+it was discovered that the GBE didn't really\n+implement its native complex-arithmetic facility properly.\n+\n+The short-term solution was to rewrite the FFE\n+to instead use the lower-level facilities\n+that'd be used by @code{gcc}-compiled code\n+(assuming that code, itself, didn't use the native complex type\n+provided, as an extension, by @code{gcc}),\n+since these were known to work,\n+and, in any case, if shown to not work,\n+would likely be rapidly fixed\n+(since they'd likely not work for vanilla C code in similar circumstances).\n+\n+However, the rewrite accommodated the original, native approach as well\n+by offering a command-line option to select it over the emulated approach.\n+This allowed users, and especially GBE maintainers, to try out\n+fixes to complex-arithmetic support in the GBE\n+while @code{g77} continued to default to compiling more code correctly,\n+albeit producing (typically) slower executables.\n+\n+As of April 1999, it appeared that the last few bugs\n+in the GBE's support of its native complex-arithmetic facility\n+were worked out.\n+The FFE was changed back to default to using that native facility,\n+leaving emulation as an option.\n+\n+Other Fortran constructs---arrays, character strings,\n+complex division, @code{COMMON} and @code{EQUIVALENCE} aggregates,\n+and so on---involve issues similar to those pertaining to complex arithmetic.\n+\n+So, it is possible that the history\n+of how the FFE handled complex arithmetic\n+will be repeated, probably in modified form\n+(and hopefully over shorter timeframes),\n+for some of these other facilities.\n+\n+@node Two-pass Design\n+@section Two-pass Design\n+\n+The FFE does not tell the GBE anything about a program unit\n+until after the last statement in that unit has been parsed.\n+(A program unit is a Fortran concept that corresponds, in the C world,\n+mostly closely to functions definitions in ISO C.\n+That is, a program unit in Fortran is like a top-level function in C.\n+Nested functions, found among the extensions offered by GNU C,\n+correspond roughly to Fortran's statement functions.)\n+\n+So, while parsing the code in a program unit,\n+the FFE saves up all the information\n+on statements, expressions, names, and so on,\n+until it has seen the last statement.\n+\n+At that point, the FFE revisits the saved information\n+(in what amounts to a second @dfn{pass} over the program unit)\n+to perform the actual translation of the program unit into GBEL,\n+ultimating in the generation of assembly code for it.\n+\n+Some lookahead is performed during this second pass,\n+so the FFE could be viewed as a ``two-plus-pass'' design.\n+\n+@menu\n+* Two-pass Code::\n+* Why Two Passes::\n+@end menu\n+\n+@node Two-pass Code\n+@subsection Two-pass Code\n+\n+Most of the code that turns the first pass (parsing)\n+into a second pass for code generation\n+is in @file{@value{path-g77}/std.c}.\n+\n+It has external functions,\n+called mainly by siblings in @file{@value{path-g77}/stc.c},\n+that record the information on statements and expressions\n+in the order they are seen in the source code.\n+These functions save that information.\n+\n+It also has an external function that revisits that information,\n+calling the siblings in @file{@value{path-g77}/ste.c},\n+which handles the actual code generation\n+(by generating GBEL code,\n+that is, by calling GBE routines\n+to represent and specify expressions, statements, and so on).\n+\n+@node Why Two Passes\n+@subsection Why Two Passes\n+\n+The need for two passes was not immediately evident\n+during the design and implementation of the code in the FFE\n+that was to produce GBEL.\n+Only after a few kludges,\n+to handle things like incorrectly-guessed @code{ASSIGN} label nature,\n+had been implemented,\n+did enough evidence pile up to make it clear\n+that @file{std.c} had to be introduced to intercept,\n+save, then revisit as part of a second pass,\n+the digested contents of a program unit.\n+\n+Other such missteps have occurred during the evolution of the FFE,\n+because of the different goals of the FFE and the GBE.\n+\n+Because the GBE's original, and still primary, goal\n+was to directly support the GNU C language,\n+the GBEL, and the GBE itself,\n+requires more complexity\n+on the part of most front ends\n+than it requires of @code{gcc}'s.\n+\n+For example,\n+the GBEL offers an interface that permits the @code{gcc} front end\n+to implement most, or all, of the language features it supports,\n+without the front end having to\n+make use of non-user-defined variables.\n+(It's almost certainly the case that all of K&R C,\n+and probably ANSI C as well,\n+is handled by the @code{gcc} front end\n+without declaring such variables.)\n+\n+The FFE, on the other hand, must resort to a variety of ``tricks''\n+to achieve its goals.\n+\n+Consider the following C code:\n+\n+@smallexample\n+int\n+foo (int a, int b)\n+@{\n+  int c = 0;\n+\n+  if ((c = bar (c)) == 0)\n+    goto done;\n+\n+  quux (c << 1);\n+\n+done:\n+  return c;\n+@}\n+@end smallexample\n+\n+Note what kinds of objects are declared, or defined, before their use,\n+and before any actual code generation involving them\n+would normally take place:\n+\n+@itemize @bullet\n+@item\n+Return type of function\n+\n+@item\n+Entry point(s) of function\n+\n+@item\n+Dummy arguments\n+\n+@item\n+Variables\n+\n+@item\n+Initial values for variables\n+@end itemize\n+\n+Whereas, the following items can, and do,\n+suddenly appear ``out of the blue'' in C:\n+\n+@itemize @bullet\n+@item\n+Label references\n+\n+@item\n+Function references\n+@end itemize\n+\n+Not surprisingly, the GBE faithfully permits the latter set of items\n+to be ``discovered'' partway through GBEL ``programs'',\n+just as they are permitted to in C.\n+\n+Yet, the GBE has tended, at least in the past,\n+to be reticent to fully support similar ``late'' discovery\n+of items in the former set.\n+\n+This makes Fortran a poor fit for the ``safe'' subset of GBEL.\n+Consider:\n+\n+@smallexample\n+      FUNCTION X (A, ARRAY, ID1)\n+      CHARACTER*(*) A\n+      DOUBLE PRECISION X, Y, Z, TMP, EE, PI\n+      REAL ARRAY(ID1*ID2)\n+      COMMON ID2\n+      EXTERNAL FRED\n+\n+      ASSIGN 100 TO J\n+      CALL FOO (I)\n+      IF (I .EQ. 0) PRINT *, A(0)\n+      GOTO 200\n+\n+      ENTRY Y (Z)\n+      ASSIGN 101 TO J\n+200   PRINT *, A(1)\n+      READ *, TMP\n+      GOTO J\n+100   X = TMP * EE\n+      RETURN\n+101   Y = TMP * PI\n+      CALL FRED\n+      DATA EE, PI /2.71D0, 3.14D0/\n+      END\n+@end smallexample\n+\n+Here are some observations about the above code,\n+which, while somewhat contrived,\n+conforms to the FORTRAN 77 and Fortran 90 standards:\n+\n+@itemize @bullet\n+@item\n+The return type of function @samp{X} is not known\n+until the @samp{DOUBLE PRECISION} line has been parsed.\n+\n+@item\n+Whether @samp{A} is a function or a variable\n+is not known until the @samp{PRINT *, A(0)} statement\n+has been parsed.\n+\n+@item\n+The bounds of the array of argument @samp{ARRAY}\n+depend on a computation involving\n+the subsequent argument @samp{ID1}\n+and the blank-common member @samp{ID2}.\n+\n+@item\n+Whether @samp{Y} and @samp{Z} are local variables,\n+additional function entry points,\n+or dummy arguments to additional entry points\n+is not known\n+until the @samp{ENTRY} statement is parsed.\n+\n+@item\n+Similarly, whether @samp{TMP} is a local variable is not known\n+until the @samp{READ *, TMP} statement is parsed.\n+\n+@item\n+The initial values for @samp{EE} and @samp{PI}\n+are not known until after the @samp{DATA} statement is parsed.\n+\n+@item\n+Whether @samp{FRED} is a function returning type @code{REAL}\n+or a subroutine\n+(which can be thought of as returning type @code{void}\n+@emph{or}, to support alternate returns in a simple way,\n+type @code{int})\n+is not known\n+until the @samp{CALL FRED} statement is parsed.\n+\n+@item\n+Whether @samp{100} is a @code{FORMAT} label\n+or the label of an executable statement\n+is not known\n+until the @samp{X =} statement is parsed.\n+(These two types of labels get @emph{very} different treatment,\n+especially when @code{ASSIGN}'ed.)\n+\n+@item\n+That @samp{J} is a local variable is not known\n+until the first @samp{ASSIGN} statement is parsed.\n+(This happens @emph{after} executable code has been seen.)\n+@end itemize\n+\n+Very few of these ``discoveries''\n+can be accommodated by the GBE as it has evolved over the years.\n+The GBEL doesn't support several of them,\n+and those it might appear to support\n+don't always work properly,\n+especially in combination with other GBEL and GBE features,\n+as implemented in the GBE.\n+\n+(Had the GBE and its GBEL originally evolved to support @code{g77},\n+the shoe would be on the other foot, so to speak---most, if not all,\n+of the above would be directly supported by the GBEL,\n+and a few C constructs would probably not, as they are in reality,\n+be supported.\n+Both this mythical, and today's real, GBE caters to its GBEL\n+by, sometimes, scrambling around, cleaning up after itself---after\n+discovering that assumptions it made earlier during code generation\n+are incorrect.)\n+\n+So, the FFE handles these discrepancies---between the order in which\n+it discovers facts about the code it is compiling,\n+and the order in which the GBEL and GBE support such discoveries---by\n+performing what amounts to two\n+passes over each program unit.\n+\n+(A few ambiguities can remain at that point,\n+such as whether, given @samp{EXTERNAL BAZ}\n+and no other reference to @samp{BAZ} in the program unit,\n+it is a subroutine, a function, or a block-data---which, in C-speak,\n+governs its declared return type.\n+Fortunately, these distinctions are easily finessed\n+for the procedure, library, and object-file interfaces\n+supported by @code{g77}.)\n+\n+@node Challenges Posed\n+@section Challenges Posed\n+\n+Consider the following Fortran code, which uses various extensions\n+(including some to Fortran 90):\n+\n+@smallexample\n+SUBROUTINE X(A)\n+CHARACTER*(*) A\n+COMPLEX CFUNC\n+INTEGER*2 CLOCKS(200)\n+INTEGER IFUNC\n+\n+CALL SYSTEM_CLOCK (CLOCKS (IFUNC (CFUNC ('('//A//')'))))\n+@end smallexample\n+\n+The above poses the following challenges to any Fortran compiler\n+that uses run-time interfaces, and a run-time library, roughly similar\n+to those used by @code{g77}:\n+\n+@itemize @bullet\n+@item\n+Assuming the library routine that supports @code{SYSTEM_CLOCK}\n+expects to set an @code{INTEGER*4} variable via its @code{COUNT} argument,\n+the compiler must make available to it a temporary variable of that type.\n+\n+@item\n+Further, after the @code{SYSTEM_CLOCK} library routine returns,\n+the compiler must ensure that the temporary variable it wrote\n+is copied into the appropriate element of the @samp{CLOCKS} array.\n+(This assumes the compiler doesn't just reject the code,\n+which it should if it is compiling under some kind of a \"strict\" option.)\n+\n+@item\n+To determine the correct index into the @samp{CLOCKS} array,\n+(putting aside the fact that the index, in this particular case,\n+need not be computed until after\n+the @code{SYSTEM_CLOCK} library routine returns),\n+the compiler must ensure that the @code{IFUNC} function is called.\n+\n+That requires evaluating its argument,\n+which requires, for @code{g77}\n+(assuming @code{-ff2c} is in force),\n+reserving a temporary variable of type @code{COMPLEX}\n+for use as a repository for the return value\n+being computed by @samp{CFUNC}.\n+\n+@item\n+Before invoking @samp{CFUNC},\n+is argument must be evaluated,\n+which requires allocating, at run time,\n+a temporary large enough to hold the result of the concatenation,\n+as well as actually performing the concatenation.\n+\n+@item\n+The large temporary needed during invocation of @code{CFUNC}\n+should, ideally, be deallocated\n+(or, at least, left to the GBE to dispose of, as it sees fit)\n+as soon as @code{CFUNC} returns,\n+which means before @code{IFUNC} is called\n+(as it might need a lot of dynamically allocated memory).\n+@end itemize\n+\n+@code{g77} currently doesn't support all of the above,\n+but, so that it might someday, it has evolved to handle\n+at least some of the above requirements.\n+\n+Meeting the above requirements is made more challenging\n+by conforming to the requirements of the GBEL/GBE combination.\n+\n+@node Transforming Statements\n+@section Transforming Statements\n+\n+Most Fortran statements are given their own block,\n+and, for temporary variables they might need, their own scope.\n+(A block is what distinguishes @samp{@{ foo (); @}}\n+from just @samp{foo ();} in C.\n+A scope is included with every such block,\n+providing a distinct name space for local variables.)\n+\n+Label definitions for the statement precede this block,\n+so @samp{10 PRINT *, I} is handled more like\n+@samp{fl10: @{ @dots{} @}} than @samp{@{ fl10: @dots{} @}}\n+(where @samp{fl10} is just a notation meaning ``Fortran Label 10''\n+for the purposes of this document).\n+\n+@menu\n+* Statements Needing Temporaries::\n+* Transforming DO WHILE::\n+* Transforming Iterative DO::\n+* Transforming Block IF::\n+* Transforming SELECT CASE::\n+@end menu\n+\n+@node Statements Needing Temporaries\n+@subsection Statements Needing Temporaries\n+\n+Any temporaries needed during, but not beyond,\n+execution of a Fortran statement,\n+are made local to the scope of that statement's block.\n+\n+This allows the GBE to share storage for these temporaries\n+among the various statements without the FFE\n+having to manage that itself.\n+\n+(The GBE could, of course, decide to optimize \n+management of these temporaries.\n+For example, it could, theoretically,\n+schedule some of the computations involving these temporaries\n+to occur in parallel.\n+More practically, it might leave the storage for some temporaries\n+``live'' beyond their scopes, to reduce the number of\n+manipulations of the stack pointer at run time.)\n+\n+Temporaries needed across distinct statement boundaries usually\n+are associated with Fortran blocks (such as @code{DO}/@code{END DO}).\n+(Also, there might be temporaries not associated with blocks at all---these\n+would be in the scope of the entire program unit.)\n+\n+Each Fortran block @emph{should} get its own block/scope in the GBE.\n+This is best, because it allows temporaries to be more naturally handled.\n+However, it might pose problems when handling labels\n+(in particular, when they're the targets of @code{GOTO}s outside the Fortran\n+block), and generally just hassling with replicating\n+parts of the @code{gcc} front end\n+(because the FFE needs to support\n+an arbitrary number of nested back-end blocks\n+if each Fortran block gets one).\n+\n+So, there might still be a need for top-level temporaries, whose\n+``owning'' scope is that of the containing procedure.\n+\n+Also, there seems to be problems declaring new variables after\n+generating code (within a block) in the back end, leading to, e.g.,\n+@samp{label not defined before binding contour} or similar messages,\n+when compiling with @samp{-fstack-check} or\n+when compiling for certain targets.\n+\n+Because of that, and because sometimes these temporaries are not\n+discovered until in the middle of of generating code for an expression\n+statement (as in the case of the optimization for @samp{X**I}),\n+it seems best to always\n+pre-scan all the expressions that'll be expanded for a block\n+before generating any of the code for that block.\n+\n+This pre-scan then handles discovering and declaring, to the back end,\n+the temporaries needed for that block.\n+\n+It's also important to treat distinct items in an I/O list as distinct\n+statements deserving their own blocks.\n+That's because there's a requirement\n+that each I/O item be fully processed before the next one,\n+which matters in cases like @samp{READ (*,*), I, A(I)}---the\n+element of @samp{A} read in the second item\n+@emph{must} be determined from the value\n+of @samp{I} read in the first item.\n+\n+@node Transforming DO WHILE\n+@subsection Transforming DO WHILE\n+\n+@samp{DO WHILE(expr)} @emph{must} be implemented\n+so that temporaries needed to evaluate @samp{expr}\n+are generated just for the test, each time.\n+\n+Consider how @samp{DO WHILE (A//B .NE. 'END'); @dots{}; END DO} is transformed:\n+\n+@smallexample\n+for (;;)\n+  @{\n+    int temp0;\n+\n+    @{\n+      char temp1[large];\n+\n+      libg77_catenate (temp1, a, b);\n+      temp0 = libg77_ne (temp1, 'END');\n+    @}\n+\n+    if (! temp0)\n+      break;\n+\n+    @dots{}\n+  @}\n+@end smallexample\n+\n+In this case, it seems like a time/space tradeoff\n+between allocating and deallocating @samp{temp1} for each iteration\n+and allocating it just once for the entire loop.\n+\n+However, if @samp{temp1} is allocated just once for the entire loop,\n+it could be the wrong size for subsequent iterations of that loop\n+in cases like @samp{DO WHILE (A(I:J)//B .NE. 'END')},\n+because the body of the loop might modify @samp{I} or @samp{J}.\n+\n+So, the above implementation is used,\n+though a more optimal one can be used\n+in specific circumstances.\n+\n+@node Transforming Iterative DO\n+@subsection Transforming Iterative DO\n+\n+An iterative @code{DO} loop\n+(one that specifies an iteration variable)\n+is required by the Fortran standards\n+to be implemented as though an iteration count\n+is computed before entering the loop body,\n+and that iteration count used to determine\n+the number of times the loop body is to be performed\n+(assuming the loop isn't cut short via @code{GOTO} or @code{EXIT}).\n+\n+The FFE handles this by allocating a temporary variable\n+to contain the computed number of iterations.\n+Since this variable must be in a scope that includes the entire loop,\n+a GBEL block is created for that loop,\n+and the variable declared as belonging to the scope of that block.\n+\n+@node Transforming Block IF\n+@subsection Transforming Block IF\n+\n+Consider:\n+\n+@smallexample\n+SUBROUTINE X(A,B,C)\n+CHARACTER*(*) A, B, C\n+LOGICAL LFUNC\n+\n+IF (LFUNC (A//B)) THEN\n+  CALL SUBR1\n+ELSE IF (LFUNC (A//C)) THEN\n+  CALL SUBR2\n+ELSE\n+  CALL SUBR3\n+END\n+@end smallexample\n+\n+The arguments to the two calls to @samp{LFUNC}\n+require dynamic allocation (at run time),\n+but are not required during execution of the @samp{CALL} statements.\n+\n+So, the scopes of those temporaries must be within blocks inside\n+the block corresponding to the Fortran @code{IF} block.\n+\n+This cannot be represented ``naturally''\n+in vanilla C, nor in GBEL.\n+The @samp{if}, @samp{elseif}, @samp{else},\n+and @samp{endif} constructs\n+provided by both languages must,\n+for a given @samp{if} block,\n+share the same C/GBE block.\n+\n+Therefore, any temporaries needed during evaluation of @samp{expr}\n+while executing @samp{ELSE IF(expr)}\n+must either have been predeclared\n+at the top of the corresponding @code{IF} block,\n+or declared within a new block for that @code{ELSE IF}---a block that,\n+since it cannot contain the @code{else} or @code{else if} itself\n+(due to the above requirement),\n+actually implements the rest of the @code{IF} block's\n+@code{ELSE IF} and @code{ELSE} statements\n+within an inner block.\n+\n+The FFE takes the latter approach.\n+\n+@node Transforming SELECT CASE\n+@subsection Transforming SELECT CASE\n+\n+@code{SELECT CASE} poses a few interesting problems for code generation,\n+if efficiency and frugal stack management are important.\n+\n+Consider @samp{SELECT CASE (I('PREFIX'//A))},\n+where @samp{A} is @code{CHARACTER*(*)}.\n+In a case like this---basically,\n+in any case where largish temporaries are needed\n+to evaluate the expression---those temporaries should\n+not be ``live'' during execution of any of the @code{CASE} blocks.\n+\n+So, evaluation of the expression is best done within its own block,\n+which in turn is within the @code{SELECT CASE} block itself\n+(which contains the code for the CASE blocks as well,\n+though each within their own block).\n+\n+Otherwise, we'd have the rough equivalent of this pseudo-code:\n+\n+@smallexample\n+@{\n+  char temp[large];\n+\n+  libg77_catenate (temp, 'prefix', a);\n+\n+  switch (i (temp))\n+    @{\n+    case 0:\n+      @dots{}\n+    @}\n+@}\n+@end smallexample\n+\n+And that would leave temp[large] in scope during the CASE blocks\n+(although a clever back end *could* see that it isn't referenced\n+in them, and thus free that temp before executing the blocks).\n+\n+So this approach is used instead:\n+\n+@smallexample\n+@{\n+  int temp0;\n+\n+  @{\n+    char temp1[large];\n+\n+    libg77_catenate (temp1, 'prefix', a);\n+    temp0 = i (temp1);\n+  @}\n+\n+  switch (temp0)\n+    @{\n+    case 0:\n+      @dots{}\n+    @}\n+@}\n+@end smallexample\n+\n+Note how @samp{temp1} goes out of scope before starting the switch,\n+thus making it easy for a back end to free it.\n+\n+The problem @emph{that} solution has, however,\n+is with @samp{SELECT CASE('prefix'//A)}\n+(which is currently not supported).\n+\n+Unless the GBEL is extended to support arbitrarily long character strings\n+in its @code{case} facility,\n+the FFE has to implement @code{SELECT CASE} on @code{CHARACTER}\n+(probably excepting @code{CHARACTER*1})\n+using a cascade of\n+@code{if}, @code{elseif}, @code{else}, and @code{endif} constructs\n+in GBEL.\n+\n+To prevent the (potentially large) temporary,\n+needed to hold the selected expression itself (@samp{'prefix'//A}),\n+from being in scope during execution of the @code{CASE} blocks,\n+two approaches are available:\n+\n+@itemize @bullet\n+@item\n+Pre-evaluate all the @code{CASE} tests,\n+producing an integer ordinal that is used,\n+a la @samp{temp0} in the earlier example,\n+as if @samp{SELECT CASE(temp0)} had been written.\n+\n+Each corresponding @code{CASE} is replaced with @samp{CASE(@var{i})},\n+where @var{i} is the ordinal for that case,\n+determined while, or before,\n+generating the cascade of @samp{if}-related constructs\n+to cope with @code{CHARACTER} selection.\n+\n+@item\n+Make @samp{temp0} above just\n+large enough to hold the longest @code{CASE} string\n+that'll actually be compared against the expression\n+(in this case, @samp{'prefix'//A}).\n+\n+Since that length must be constant\n+(because @code{CASE} expressions are all constant),\n+it won't be so large,\n+and, further, @samp{temp1} need not be dynamically allocated,\n+since normal @code{CHARACTER} assignment can be used\n+into the fixed-length @samp{temp0}.\n+@end itemize\n+\n+Both of these solutions require @code{SELECT CASE} implementation\n+to be changed so all the corresponding @code{CASE} statements\n+are seen during the actual code generation for @code{SELECT CASE}.\n+\n+@node Transforming Expressions\n+@section Transforming Expressions\n+\n+The interactions between statements, expressions, and subexpressions\n+at program run time can be viewed as:\n+\n+@smallexample\n+@var{action}(@var{expr})\n+@end smallexample\n+\n+Here, @var{action} is the series of steps\n+performed to effect the statement,\n+and @var{expr} is the expression\n+whose value is used by @var{action}.\n+\n+Expanding the above shows a typical order of events at run time:\n+\n+@smallexample\n+Evaluate @var{expr}\n+Perform @var{action}, using result of evaluation of @var{expr}\n+Clean up after evaluating @var{expr}\n+@end smallexample\n+\n+So, if evaluating @var{expr} requires allocating memory,\n+that memory can be freed before performing @var{action}\n+only if it is not needed to hold the result of evaluating @var{expr}.\n+Otherwise, it must be freed no sooner than\n+after @var{action} has been performed.\n+\n+The above are recursive definitions,\n+in the sense that they apply to subexpressions of @var{expr}.\n+\n+That is, evaluating @var{expr} involves\n+evaluating all of its subexpressions,\n+performing the @var{action} that computes the\n+result value of @var{expr},\n+then cleaning up after evaluating those subexpressions.\n+\n+The recursive nature of this evaluation is implemented\n+via recursive-descent transformation of the top-level statements,\n+their expressions, @emph{their} subexpressions, and so on.\n+\n+However, that recursive-descent transformation is,\n+due to the nature of the GBEL,\n+focused primarily on generating a @emph{single} stream of code\n+to be executed at run time.\n+\n+Yet, from the above, it's clear that multiple streams of code\n+must effectively be simultaneously generated\n+during the recursive-descent analysis of statements.\n+\n+The primary stream implements the primary @var{action} items,\n+while at least two other streams implement\n+the evaluation and clean-up items.\n+\n+Requirements imposed by expressions include:\n+\n+@itemize @bullet\n+@item\n+Whether the caller needs to have a temporary ready\n+to hold the value of the expression.\n+\n+@item\n+Other stuff???\n+\n+\n+@end itemize"}]}