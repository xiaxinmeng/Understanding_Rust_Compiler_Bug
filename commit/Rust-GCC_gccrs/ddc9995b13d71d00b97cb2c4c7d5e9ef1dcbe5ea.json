{"sha": "ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRjOTk5NWIxM2Q3MWQwMGI5N2NiMmM0YzdkNWU5ZWYxZGNiZTVlYQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-11-22T18:08:07Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-11-22T18:08:07Z"}, "message": "re PR fortran/36313 ([F03] {MIN,MAX}{LOC,VAL} should accept character arguments)\n\n2017-11-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36313\n\t* Makefile.am: Add i_maxloc0s_c, i_maxloc1s_c, i_maxloc2s_c,\n\ti_minloc0s_c, i_minloc1s_c and i_minloc2s_c.\n\t* Makefile.in: Regenerated.\n        * generated/maxloc0_16_s1.c: New file.\n        * generated/maxloc0_16_s4.c: New file.\n        * generated/maxloc0_4_s1.c: New file.\n        * generated/maxloc0_4_s4.c: New file.\n        * generated/maxloc0_8_s1.c: New file.\n        * generated/maxloc0_8_s4.c: New file.\n        * generated/maxloc1_16_s1.c: New file.\n        * generated/maxloc1_16_s4.c: New file.\n        * generated/maxloc1_4_s1.c: New file.\n        * generated/maxloc1_4_s4.c: New file.\n        * generated/maxloc1_8_s1.c: New file.\n        * generated/maxloc1_8_s4.c: New file.\n        * generated/maxloc2_16_s1.c: New file.\n        * generated/maxloc2_16_s4.c: New file.\n        * generated/maxloc2_4_s1.c: New file.\n        * generated/maxloc2_4_s4.c: New file.\n        * generated/maxloc2_8_s1.c: New file.\n        * generated/maxloc2_8_s4.c: New file.\n        * generated/minloc0_16_s1.c: New file.\n        * generated/minloc0_16_s4.c: New file.\n        * generated/minloc0_4_s1.c: New file.\n        * generated/minloc0_4_s4.c: New file.\n        * generated/minloc0_8_s1.c: New file.\n        * generated/minloc0_8_s4.c: New file.\n        * generated/minloc1_16_s1.c: New file.\n        * generated/minloc1_16_s4.c: New file.\n        * generated/minloc1_4_s1.c: New file.\n        * generated/minloc1_4_s4.c: New file.\n        * generated/minloc1_8_s1.c: New file.\n        * generated/minloc1_8_s4.c: New file.\n        * generated/minloc2_16_s1.c: New file.\n        * generated/minloc2_16_s4.c: New file.\n        * generated/minloc2_4_s1.c: New file.\n        * generated/minloc2_4_s4.c: New file.\n        * generated/minloc2_8_s1.c: New file.\n        * generated/minloc2_8_s4.c: New file.\n        * m4/iforeach-s.m4: New file.\n        * m4/ifunction-s.m4: New file.\n        * m4/maxloc0s.m4: New file.\n        * m4/maxloc1s.m4: New file.\n        * m4/maxloc2s.m4: New file.\n        * m4/minloc0s.m4: New file.\n        * m4/minloc1s.m4: New file.\n        * m4/minloc2s.m4: New file.\n\t* gfortran.map: Add new functions.\n\t* libgfortran.h: Add gfc_array_s1 and gfc_array_s4.\n\n2017-11-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36313\n\t* check.c (int_or_real_or_char_check_f2003): New function.\n\t* iresolve.c (gfc_resolve_maxloc): Add number \"2\" for\n\tcharacter arguments and rank-zero return value.\n\t(gfc_resolve_minloc): Likewise.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Handle case of\n\tcharacter arguments and rank-zero return value by removing\n\tunneeded arguments and calling the library function.\n\n2017-11-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36313\n\t* gfortran.dg/maxloc_string_1.f90: New test.\n\t* gfortran.dg/minloc_string_1.f90: New test.\n\nFrom-SVN: r255070", "tree": {"sha": "a56711799c15dbdca3426f951fa31ef645b06e75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a56711799c15dbdca3426f951fa31ef645b06e75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/comments", "author": null, "committer": null, "parents": [{"sha": "824a2b3d8cb18e80ed11231ed57b4bf67134fcd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824a2b3d8cb18e80ed11231ed57b4bf67134fcd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/824a2b3d8cb18e80ed11231ed57b4bf67134fcd0"}], "stats": {"total": 14744, "additions": 14711, "deletions": 33}, "files": [{"sha": "30e033afa399e98a9e9c589b9870c050684cf61e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -1,3 +1,14 @@\n+2017-11-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36313\n+\t* check.c (int_or_real_or_char_check_f2003): New function.\n+\t* iresolve.c (gfc_resolve_maxloc): Add number \"2\" for\n+\tcharacter arguments and rank-zero return value.\n+\t(gfc_resolve_minloc): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Handle case of\n+\tcharacter arguments and rank-zero return value by removing\n+\tunneeded arguments and calling the library function.\n+\n 2017-11-22  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/79072"}, {"sha": "29281723b8d4a8f3adcb7c4dec9650b34e30aae4", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -117,6 +117,37 @@ int_or_real_check (gfc_expr *e, int n)\n   return true;\n }\n \n+/* Check that an expression is integer or real; allow character for\n+   F2003 or later.  */\n+\n+static bool\n+int_or_real_or_char_check_f2003 (gfc_expr *e, int n)\n+{\n+  if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL)\n+    {\n+      if (e->ts.type == BT_CHARACTER)\n+\treturn gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Character for \"\n+\t\t\t       \"%qs argument of %qs intrinsic at %L\",\n+\t\t\t       gfc_current_intrinsic_arg[n]->name,\n+\t\t\t       gfc_current_intrinsic, &e->where);\n+      else\n+\t{\n+\t  if (gfc_option.allow_std & GFC_STD_F2003)\n+\t    gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n+\t\t       \"or REAL or CHARACTER\",\n+\t\t       gfc_current_intrinsic_arg[n]->name,\n+\t\t       gfc_current_intrinsic, &e->where);\n+\t  else\n+\t    gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n+\t\t       \"or REAL\", gfc_current_intrinsic_arg[n]->name,\n+\t\t       gfc_current_intrinsic, &e->where);\n+\t}\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n \n /* Check that an expression is real or complex.  */\n \n@@ -3189,7 +3220,7 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n   gfc_expr *a, *m, *d, *k;\n \n   a = ap->expr;\n-  if (!int_or_real_check (a, 0) || !array_check (a, 0))\n+  if (!int_or_real_or_char_check_f2003 (a, 0) || !array_check (a, 0))\n     return false;\n \n   d = ap->next->expr;"}, {"sha": "be1c35bc57e30ab55cf652ba2b0ef5690039bca4", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -1702,6 +1702,7 @@ gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   const char *name;\n   int i, j, idim;\n   int fkind;\n+  int d_num;\n \n   f->ts.type = BT_INTEGER;\n \n@@ -1752,8 +1753,18 @@ gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   else\n     name = \"maxloc\";\n \n+  if (dim)\n+    {\n+      if (array->ts.type != BT_CHARACTER || f->rank != 0)\n+\td_num = 1;\n+      else\n+\td_num = 2;\n+    }\n+  else\n+    d_num = 0;\n+\n   f->value.function.name\n-    = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n+    = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, d_num, f->ts.kind,\n \t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n \n   if (kind)\n@@ -1896,6 +1907,7 @@ gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   const char *name;\n   int i, j, idim;\n   int fkind;\n+  int d_num;\n \n   f->ts.type = BT_INTEGER;\n \n@@ -1946,8 +1958,18 @@ gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   else\n     name = \"minloc\";\n \n+  if (dim)\n+    {\n+      if (array->ts.type != BT_CHARACTER || f->rank != 0)\n+\td_num = 1;\n+      else\n+\td_num = 2;\n+    }\n+  else\n+    d_num = 0;\n+\n   f->value.function.name\n-    = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n+    = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, d_num, f->ts.kind,\n \t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n \n   if (fkind != f->ts.kind)"}, {"sha": "90d5e59a0501618c0cb999f48dec994e9ea2a56d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -4568,14 +4568,41 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       return;\n     }\n \n+  actual = expr->value.function.actual;\n+  arrayexpr = actual->expr;\n+\n+  /* Special case for character maxval.  Remove unneeded actual\n+     arguments, then call a library function.  */\n+  \n+  if (arrayexpr->ts.type == BT_CHARACTER)\n+    {\n+      gfc_actual_arglist *a2, *a3, *a4;\n+      a2 = actual->next;\n+      a3 = a2->next;\n+      a4 = a3->next;\n+      a4->next = NULL;\n+      if (a3->expr == NULL)\n+\t{\n+\t  actual->next = NULL;\n+\t  gfc_free_actual_arglist (a2);\n+\t}\n+      else\n+\t{\n+\t  actual->next = a3;  /* dim */\n+\t  a3->next = NULL;\n+\t  a2->next = a4;\n+\t  gfc_free_actual_arglist (a4);\n+\t}\n+      gfc_conv_intrinsic_funcall (se, expr);\n+      return;\n+    }\n+\n   /* Initialize the result.  */\n   pos = gfc_create_var (gfc_array_index_type, \"pos\");\n   offset = gfc_create_var (gfc_array_index_type, \"offset\");\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   /* Walk the arguments.  */\n-  actual = expr->value.function.actual;\n-  arrayexpr = actual->expr;\n   arrayss = gfc_walk_expr (arrayexpr);\n   gcc_assert (arrayss != gfc_ss_terminator);\n "}, {"sha": "573a97a4762fc49be78c85aba627906417b75e76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -1,3 +1,9 @@\n+2017-11-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36313\n+\t* gfortran.dg/maxloc_string_1.f90: New test.\n+\t* gfortran.dg/minloc_string_1.f90: New test.\n+\n 2017-11-22  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/83104"}, {"sha": "a5511624dd5f4016ae3d00bb931fe62ba10c25c4", "filename": "gcc/testsuite/gfortran.dg/maxloc_string_1.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_string_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_string_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_string_1.f90?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do run }\n+! Test maxloc for strings for different code paths\n+\n+program main\n+  implicit none\n+  integer, parameter :: n=4\n+  character(len=4), dimension(n,n) :: c\n+  integer, dimension(n,n) :: a\n+  integer, dimension(2) :: res1, res2\n+  real, dimension(n,n) :: r\n+  logical, dimension(n,n) :: amask\n+  logical(kind=8) :: smask\n+  integer :: i,j\n+  integer, dimension(n) :: q1, q2\n+  character(len=4,kind=4), dimension(n,n) :: c4\n+  character(len=4), dimension(n*n) :: e\n+  integer, dimension(n*n) :: f\n+  logical, dimension(n*n) :: cmask\n+\n+  call random_number (r)\n+  a = int(r*100)\n+  do j=1,n\n+     do i=1,n\n+        write (unit=c(i,j),fmt='(I4.4)') a(i,j)\n+        write (unit=c4(i,j),fmt='(I4.4)') a(i,j)\n+     end do\n+  end do\n+  res1 = maxloc(c)\n+  res2 = maxloc(a)\n+\n+  if (any(res1 /= res2)) call abort\n+  res1 = maxloc(c4)\n+  if (any(res1 /= res2)) call abort\n+\n+  amask = a < 50\n+  res1 = maxloc(c,mask=amask)\n+  res2 = maxloc(a,mask=amask)\n+\n+ if (any(res1 /= res2)) call abort\n+\n+ amask = .false.\n+ res1 = maxloc(c,mask=amask)\n+ if (any(res1 /= 0)) call abort\n+\n+ amask(2,3) = .true.\n+ res1 = maxloc(c,mask=amask)\n+ if (any(res1 /= [2,3])) call abort\n+\n+ res1 = maxloc(c,mask=.false.)\n+ if (any(res1 /= 0)) call abort\n+\n+ res2 = maxloc(a)\n+ res1 = maxloc(c,mask=.true.)\n+ if (any(res1 /= res2)) call abort\n+\n+ q1 = maxloc(c, dim=1)\n+ q2 = maxloc(a, dim=1)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = maxloc(c, dim=2)\n+ q2 = maxloc(a, dim=2)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = maxloc(c, dim=1, mask=amask)\n+ q2 = maxloc(a, dim=1, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = maxloc(c, dim=2, mask=amask)\n+ q2 = maxloc(a, dim=2, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+  amask = a < 50\n+\n+ q1 = maxloc(c, dim=1, mask=amask)\n+ q2 = maxloc(a, dim=1, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = maxloc(c, dim=2, mask=amask)\n+ q2 = maxloc(a, dim=2, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+ e = reshape(c, shape(e))\n+ f = reshape(a, shape(f))\n+ if (maxloc(e,dim=1) /= maxloc(f,dim=1)) call abort\n+\n+ cmask = .false.\n+ if (maxloc(e,dim=1,mask=cmask) /= 0) call abort\n+\n+ cmask = f > 50\n+ if ( maxloc(e, dim=1, mask=cmask) /= maxloc (f, dim=1, mask=cmask)) call abort\n+end program main"}, {"sha": "88847cce8a2d30f00f58b556029187221ada9c94", "filename": "gcc/testsuite/gfortran.dg/minloc_string_1.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_string_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_string_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminloc_string_1.f90?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do run }\n+! Test minloc for strings for different code paths\n+\n+program main\n+  implicit none\n+  integer, parameter :: n=4\n+  character(len=4), dimension(n,n) :: c\n+  integer, dimension(n,n) :: a\n+  integer, dimension(2) :: res1, res2\n+  real, dimension(n,n) :: r\n+  logical, dimension(n,n) :: amask\n+  logical(kind=8) :: smask\n+  integer :: i,j\n+  integer, dimension(n) :: q1, q2\n+  character(len=4,kind=4), dimension(n,n) :: c4\n+  character(len=4), dimension(n*n) :: e\n+  integer, dimension(n*n) :: f\n+  logical, dimension(n*n) :: cmask\n+\n+  call random_number (r)\n+  a = int(r*100)\n+  do j=1,n\n+     do i=1,n\n+        write (unit=c(i,j),fmt='(I4.4)') a(i,j)\n+        write (unit=c4(i,j),fmt='(I4.4)') a(i,j)\n+     end do\n+  end do\n+  res1 = minloc(c)\n+  res2 = minloc(a)\n+\n+  if (any(res1 /= res2)) call abort\n+  res1 = minloc(c4)\n+  if (any(res1 /= res2)) call abort\n+\n+  amask = a < 50\n+  res1 = minloc(c,mask=amask)\n+  res2 = minloc(a,mask=amask)\n+\n+ if (any(res1 /= res2)) call abort\n+\n+ amask = .false.\n+ res1 = minloc(c,mask=amask)\n+ if (any(res1 /= 0)) call abort\n+\n+ amask(2,3) = .true.\n+ res1 = minloc(c,mask=amask)\n+ if (any(res1 /= [2,3])) call abort\n+\n+ res1 = minloc(c,mask=.false.)\n+ if (any(res1 /= 0)) call abort\n+\n+ res2 = minloc(a)\n+ res1 = minloc(c,mask=.true.)\n+ if (any(res1 /= res2)) call abort\n+\n+ q1 = minloc(c, dim=1)\n+ q2 = minloc(a, dim=1)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = minloc(c, dim=2)\n+ q2 = minloc(a, dim=2)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = minloc(c, dim=1, mask=amask)\n+ q2 = minloc(a, dim=1, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = minloc(c, dim=2, mask=amask)\n+ q2 = minloc(a, dim=2, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+  amask = a < 50\n+\n+ q1 = minloc(c, dim=1, mask=amask)\n+ q2 = minloc(a, dim=1, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+ q1 = minloc(c, dim=2, mask=amask)\n+ q2 = minloc(a, dim=2, mask=amask)\n+ if (any(q1 /= q2)) call abort\n+\n+ e = reshape(c, shape(e))\n+ f = reshape(a, shape(f))\n+ if (minloc(e,dim=1) /= minloc(f,dim=1)) call abort\n+\n+ cmask = .false.\n+ if (minloc(e,dim=1,mask=cmask) /= 0) call abort\n+\n+ cmask = f > 50\n+ if ( minloc(e, dim=1, mask=cmask) /= minloc (f, dim=1, mask=cmask)) call abort\n+end program main"}, {"sha": "85d73951ac676a8b48c8d78ae2d1fdba9f6fc2f1", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -1,3 +1,56 @@\n+2017-11-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36313\n+\t* Makefile.am: Add i_maxloc0s_c, i_maxloc1s_c, i_maxloc2s_c,\n+\ti_minloc0s_c, i_minloc1s_c and i_minloc2s_c.\n+\t* Makefile.in: Regenerated.\n+        * generated/maxloc0_16_s1.c: New file.\n+        * generated/maxloc0_16_s4.c: New file.\n+        * generated/maxloc0_4_s1.c: New file.\n+        * generated/maxloc0_4_s4.c: New file.\n+        * generated/maxloc0_8_s1.c: New file.\n+        * generated/maxloc0_8_s4.c: New file.\n+        * generated/maxloc1_16_s1.c: New file.\n+        * generated/maxloc1_16_s4.c: New file.\n+        * generated/maxloc1_4_s1.c: New file.\n+        * generated/maxloc1_4_s4.c: New file.\n+        * generated/maxloc1_8_s1.c: New file.\n+        * generated/maxloc1_8_s4.c: New file.\n+        * generated/maxloc2_16_s1.c: New file.\n+        * generated/maxloc2_16_s4.c: New file.\n+        * generated/maxloc2_4_s1.c: New file.\n+        * generated/maxloc2_4_s4.c: New file.\n+        * generated/maxloc2_8_s1.c: New file.\n+        * generated/maxloc2_8_s4.c: New file.\n+        * generated/minloc0_16_s1.c: New file.\n+        * generated/minloc0_16_s4.c: New file.\n+        * generated/minloc0_4_s1.c: New file.\n+        * generated/minloc0_4_s4.c: New file.\n+        * generated/minloc0_8_s1.c: New file.\n+        * generated/minloc0_8_s4.c: New file.\n+        * generated/minloc1_16_s1.c: New file.\n+        * generated/minloc1_16_s4.c: New file.\n+        * generated/minloc1_4_s1.c: New file.\n+        * generated/minloc1_4_s4.c: New file.\n+        * generated/minloc1_8_s1.c: New file.\n+        * generated/minloc1_8_s4.c: New file.\n+        * generated/minloc2_16_s1.c: New file.\n+        * generated/minloc2_16_s4.c: New file.\n+        * generated/minloc2_4_s1.c: New file.\n+        * generated/minloc2_4_s4.c: New file.\n+        * generated/minloc2_8_s1.c: New file.\n+        * generated/minloc2_8_s4.c: New file.\n+        * m4/iforeach-s.m4: New file.\n+        * m4/ifunction-s.m4: New file.\n+        * m4/maxloc0s.m4: New file.\n+        * m4/maxloc1s.m4: New file.\n+        * m4/maxloc2s.m4: New file.\n+        * m4/minloc0s.m4: New file.\n+        * m4/minloc1s.m4: New file.\n+        * m4/minloc2s.m4: New file.\n+\t* gfortran.map: Add new functions.\n+\t* libgfortran.h: Add gfc_array_s1 and gfc_array_s4.\n+\n 2017-11-22  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/83070"}, {"sha": "b88d62b685732aa5f174b0b531bd1334f4fc3701", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -293,6 +293,14 @@ $(srcdir)/generated/maxloc0_4_r16.c \\\n $(srcdir)/generated/maxloc0_8_r16.c \\\n $(srcdir)/generated/maxloc0_16_r16.c\n \n+i_maxloc0s_c = \\\n+$(srcdir)/generated/maxloc0_4_s1.c \\\n+$(srcdir)/generated/maxloc0_4_s4.c \\\n+$(srcdir)/generated/maxloc0_8_s1.c \\\n+$(srcdir)/generated/maxloc0_8_s4.c \\\n+$(srcdir)/generated/maxloc0_16_s1.c \\\n+$(srcdir)/generated/maxloc0_16_s4.c\n+\n i_maxloc1_c= \\\n $(srcdir)/generated/maxloc1_4_i1.c \\\n $(srcdir)/generated/maxloc1_8_i1.c \\\n@@ -322,6 +330,22 @@ $(srcdir)/generated/maxloc1_4_r16.c \\\n $(srcdir)/generated/maxloc1_8_r16.c \\\n $(srcdir)/generated/maxloc1_16_r16.c\n \n+i_maxloc1s_c= \\\n+$(srcdir)/generated/maxloc1_4_s1.c \\\n+$(srcdir)/generated/maxloc1_4_s4.c \\\n+$(srcdir)/generated/maxloc1_8_s1.c \\\n+$(srcdir)/generated/maxloc1_8_s4.c \\\n+$(srcdir)/generated/maxloc1_16_s1.c \\\n+$(srcdir)/generated/maxloc1_16_s4.c\n+\n+i_maxloc2s_c= \\\n+$(srcdir)/generated/maxloc2_4_s1.c \\\n+$(srcdir)/generated/maxloc2_4_s4.c \\\n+$(srcdir)/generated/maxloc2_8_s1.c \\\n+$(srcdir)/generated/maxloc2_8_s4.c \\\n+$(srcdir)/generated/maxloc2_16_s1.c \\\n+$(srcdir)/generated/maxloc2_16_s4.c\n+\n i_maxval_c= \\\n $(srcdir)/generated/maxval_i1.c \\\n $(srcdir)/generated/maxval_i2.c \\\n@@ -362,6 +386,14 @@ $(srcdir)/generated/minloc0_4_r16.c \\\n $(srcdir)/generated/minloc0_8_r16.c \\\n $(srcdir)/generated/minloc0_16_r16.c\n \n+i_minloc0s_c = \\\n+$(srcdir)/generated/minloc0_4_s1.c \\\n+$(srcdir)/generated/minloc0_4_s4.c \\\n+$(srcdir)/generated/minloc0_8_s1.c \\\n+$(srcdir)/generated/minloc0_8_s4.c \\\n+$(srcdir)/generated/minloc0_16_s1.c \\\n+$(srcdir)/generated/minloc0_16_s4.c\n+\n i_minloc1_c= \\\n $(srcdir)/generated/minloc1_4_i1.c \\\n $(srcdir)/generated/minloc1_8_i1.c \\\n@@ -391,6 +423,22 @@ $(srcdir)/generated/minloc1_4_r16.c \\\n $(srcdir)/generated/minloc1_8_r16.c \\\n $(srcdir)/generated/minloc1_16_r16.c\n \n+i_minloc1s_c= \\\n+$(srcdir)/generated/minloc1_4_s1.c \\\n+$(srcdir)/generated/minloc1_4_s4.c \\\n+$(srcdir)/generated/minloc1_8_s1.c \\\n+$(srcdir)/generated/minloc1_8_s4.c \\\n+$(srcdir)/generated/minloc1_16_s1.c \\\n+$(srcdir)/generated/minloc1_16_s4.c\n+\n+i_minloc2s_c= \\\n+$(srcdir)/generated/minloc2_4_s1.c \\\n+$(srcdir)/generated/minloc2_4_s4.c \\\n+$(srcdir)/generated/minloc2_8_s1.c \\\n+$(srcdir)/generated/minloc2_8_s4.c \\\n+$(srcdir)/generated/minloc2_16_s1.c \\\n+$(srcdir)/generated/minloc2_16_s4.c\n+\n i_minval_c= \\\n $(srcdir)/generated/minval_i1.c \\\n $(srcdir)/generated/minval_i2.c \\\n@@ -688,7 +736,7 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/pack.m4 \\\n     m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n-    m4/iall.m4 m4/iany.m4 m4/iparity.m4\n+    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n@@ -699,7 +747,8 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n-    $(i_cshift1a_c)\n+    $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n+    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c)\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n@@ -922,6 +971,8 @@ I_M4_DEPS=m4/iparm.m4\n I_M4_DEPS0=$(I_M4_DEPS) m4/iforeach.m4\n I_M4_DEPS1=$(I_M4_DEPS) m4/ifunction.m4\n I_M4_DEPS2=$(I_M4_DEPS) m4/ifunction_logical.m4\n+I_M4_DEPS3=$(I_M4_DEPS) m4/iforeach-s.m4\n+I_M4_DEPS4=$(I_M4_DEPS) m4/ifunction-s.m4\n \n kinds.h: $(srcdir)/mk-kinds-h.sh\n \t$(SHELL) $(srcdir)/mk-kinds-h.sh '$(FCCOMPILE)' > $@ || rm $@\n@@ -973,18 +1024,36 @@ $(i_iparity_c): m4/iparity.m4 $(I_M4_DEPS1)\n $(i_maxloc0_c): m4/maxloc0.m4 $(I_M4_DEPS0)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc0.m4 > $@\n \n+$(i_maxloc0s_c) : m4/maxloc0s.m4 $(I_M4_DEPS3)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc0s.m4 > $@\n+\n $(i_maxloc1_c): m4/maxloc1.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc1.m4 > $@\n \n+$(i_maxloc1s_c): m4/maxloc1s.m4 $(I_M4_DEPS4)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc1s.m4 > $@\n+\n+$(i_maxloc2s_c): m4/maxloc2s.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc2s.m4 > $@\n+\n $(i_maxval_c): m4/maxval.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval.m4 > $@\n \n $(i_minloc0_c): m4/minloc0.m4 $(I_M4_DEPS0)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc0.m4 > $@\n \n+$(i_minloc0s_c) : m4/minloc0s.m4 $(I_M4_DEPS3)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc0s.m4 > $@\n+\n $(i_minloc1_c): m4/minloc1.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc1.m4 > $@\n \n+$(i_minloc1s_c): m4/minloc1s.m4 $(I_M4_DEPS4)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc1s.m4 > $@\n+\n+$(i_minloc2s_c): m4/minloc2s.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc2s.m4 > $@\n+\n $(i_minval_c): m4/minval.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval.m4 > $@\n "}, {"sha": "0263498878267a91024b2126f096ce76078005e6", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 391, "deletions": 20, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -317,7 +317,19 @@ am__objects_36 = cshift1_4_i1.lo cshift1_4_i2.lo cshift1_4_i4.lo \\\n \tcshift1_16_i16.lo cshift1_16_r4.lo cshift1_16_r8.lo \\\n \tcshift1_16_r10.lo cshift1_16_r16.lo cshift1_16_c4.lo \\\n \tcshift1_16_c8.lo cshift1_16_c10.lo cshift1_16_c16.lo\n-am__objects_37 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n+am__objects_37 = maxloc0_4_s1.lo maxloc0_4_s4.lo maxloc0_8_s1.lo \\\n+\tmaxloc0_8_s4.lo maxloc0_16_s1.lo maxloc0_16_s4.lo\n+am__objects_38 = minloc0_4_s1.lo minloc0_4_s4.lo minloc0_8_s1.lo \\\n+\tminloc0_8_s4.lo minloc0_16_s1.lo minloc0_16_s4.lo\n+am__objects_39 = maxloc1_4_s1.lo maxloc1_4_s4.lo maxloc1_8_s1.lo \\\n+\tmaxloc1_8_s4.lo maxloc1_16_s1.lo maxloc1_16_s4.lo\n+am__objects_40 = minloc1_4_s1.lo minloc1_4_s4.lo minloc1_8_s1.lo \\\n+\tminloc1_8_s4.lo minloc1_16_s1.lo minloc1_16_s4.lo\n+am__objects_41 = maxloc2_4_s1.lo maxloc2_4_s4.lo maxloc2_8_s1.lo \\\n+\tmaxloc2_8_s4.lo maxloc2_16_s1.lo maxloc2_16_s4.lo\n+am__objects_42 = minloc2_4_s1.lo minloc2_4_s4.lo minloc2_8_s1.lo \\\n+\tminloc2_8_s4.lo minloc2_16_s1.lo minloc2_16_s4.lo\n+am__objects_43 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n@@ -327,14 +339,16 @@ am__objects_37 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_25) $(am__objects_26) $(am__objects_27) \\\n \t$(am__objects_28) $(am__objects_29) $(am__objects_30) \\\n \t$(am__objects_31) $(am__objects_32) $(am__objects_33) \\\n-\t$(am__objects_34) $(am__objects_35) $(am__objects_36)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_38 = close.lo file_pos.lo format.lo \\\n+\t$(am__objects_34) $(am__objects_35) $(am__objects_36) \\\n+\t$(am__objects_37) $(am__objects_38) $(am__objects_39) \\\n+\t$(am__objects_40) $(am__objects_41) $(am__objects_42)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_44 = close.lo file_pos.lo format.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tfbuf.lo\n-am__objects_39 = size_from_kind.lo $(am__objects_38)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_40 = access.lo c99_functions.lo \\\n+am__objects_45 = size_from_kind.lo $(am__objects_44)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_46 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tctime.lo date_and_time.lo dtime.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tenv.lo etime.lo execute_command_line.lo \\\n@@ -344,19 +358,19 @@ am__objects_39 = size_from_kind.lo $(am__objects_38)\n @LIBGFOR_MINIMAL_FALSE@\trename.lo stat.lo symlnk.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tsystem_clock.lo time.lo umask.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tunlink.lo\n-@IEEE_SUPPORT_TRUE@am__objects_41 = ieee_helper.lo\n-am__objects_42 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_47 = ieee_helper.lo\n+am__objects_48 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \teoshift2.lo erfc_scaled.lo extends_type_of.lo fnum.lo \\\n \tierrno.lo ishftc.lo mvbits.lo move_alloc.lo pack_generic.lo \\\n \tselected_char_kind.lo size.lo spread_generic.lo \\\n \tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n \treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n \tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\t$(am__objects_40) $(am__objects_41)\n-@IEEE_SUPPORT_TRUE@am__objects_43 = ieee_arithmetic.lo \\\n+\t$(am__objects_46) $(am__objects_47)\n+@IEEE_SUPPORT_TRUE@am__objects_49 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n-am__objects_44 =\n-am__objects_45 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_50 =\n+am__objects_51 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -380,19 +394,19 @@ am__objects_45 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_46 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_52 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_47 = misc_specifics.lo\n-am__objects_48 = $(am__objects_45) $(am__objects_46) $(am__objects_47) \\\n+am__objects_53 = misc_specifics.lo\n+am__objects_54 = $(am__objects_51) $(am__objects_52) $(am__objects_53) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_49 = $(am__objects_3) $(am__objects_37) $(am__objects_39) \\\n-\t$(am__objects_42) $(am__objects_43) $(am__objects_44) \\\n-\t$(am__objects_48)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_49)\n+am__objects_55 = $(am__objects_3) $(am__objects_43) $(am__objects_45) \\\n+\t$(am__objects_48) $(am__objects_49) $(am__objects_50) \\\n+\t$(am__objects_54)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_55)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -732,6 +746,14 @@ $(srcdir)/generated/maxloc0_4_r16.c \\\n $(srcdir)/generated/maxloc0_8_r16.c \\\n $(srcdir)/generated/maxloc0_16_r16.c\n \n+i_maxloc0s_c = \\\n+$(srcdir)/generated/maxloc0_4_s1.c \\\n+$(srcdir)/generated/maxloc0_4_s4.c \\\n+$(srcdir)/generated/maxloc0_8_s1.c \\\n+$(srcdir)/generated/maxloc0_8_s4.c \\\n+$(srcdir)/generated/maxloc0_16_s1.c \\\n+$(srcdir)/generated/maxloc0_16_s4.c\n+\n i_maxloc1_c = \\\n $(srcdir)/generated/maxloc1_4_i1.c \\\n $(srcdir)/generated/maxloc1_8_i1.c \\\n@@ -761,6 +783,22 @@ $(srcdir)/generated/maxloc1_4_r16.c \\\n $(srcdir)/generated/maxloc1_8_r16.c \\\n $(srcdir)/generated/maxloc1_16_r16.c\n \n+i_maxloc1s_c = \\\n+$(srcdir)/generated/maxloc1_4_s1.c \\\n+$(srcdir)/generated/maxloc1_4_s4.c \\\n+$(srcdir)/generated/maxloc1_8_s1.c \\\n+$(srcdir)/generated/maxloc1_8_s4.c \\\n+$(srcdir)/generated/maxloc1_16_s1.c \\\n+$(srcdir)/generated/maxloc1_16_s4.c\n+\n+i_maxloc2s_c = \\\n+$(srcdir)/generated/maxloc2_4_s1.c \\\n+$(srcdir)/generated/maxloc2_4_s4.c \\\n+$(srcdir)/generated/maxloc2_8_s1.c \\\n+$(srcdir)/generated/maxloc2_8_s4.c \\\n+$(srcdir)/generated/maxloc2_16_s1.c \\\n+$(srcdir)/generated/maxloc2_16_s4.c\n+\n i_maxval_c = \\\n $(srcdir)/generated/maxval_i1.c \\\n $(srcdir)/generated/maxval_i2.c \\\n@@ -801,6 +839,14 @@ $(srcdir)/generated/minloc0_4_r16.c \\\n $(srcdir)/generated/minloc0_8_r16.c \\\n $(srcdir)/generated/minloc0_16_r16.c\n \n+i_minloc0s_c = \\\n+$(srcdir)/generated/minloc0_4_s1.c \\\n+$(srcdir)/generated/minloc0_4_s4.c \\\n+$(srcdir)/generated/minloc0_8_s1.c \\\n+$(srcdir)/generated/minloc0_8_s4.c \\\n+$(srcdir)/generated/minloc0_16_s1.c \\\n+$(srcdir)/generated/minloc0_16_s4.c\n+\n i_minloc1_c = \\\n $(srcdir)/generated/minloc1_4_i1.c \\\n $(srcdir)/generated/minloc1_8_i1.c \\\n@@ -830,6 +876,22 @@ $(srcdir)/generated/minloc1_4_r16.c \\\n $(srcdir)/generated/minloc1_8_r16.c \\\n $(srcdir)/generated/minloc1_16_r16.c\n \n+i_minloc1s_c = \\\n+$(srcdir)/generated/minloc1_4_s1.c \\\n+$(srcdir)/generated/minloc1_4_s4.c \\\n+$(srcdir)/generated/minloc1_8_s1.c \\\n+$(srcdir)/generated/minloc1_8_s4.c \\\n+$(srcdir)/generated/minloc1_16_s1.c \\\n+$(srcdir)/generated/minloc1_16_s4.c\n+\n+i_minloc2s_c = \\\n+$(srcdir)/generated/minloc2_4_s1.c \\\n+$(srcdir)/generated/minloc2_4_s4.c \\\n+$(srcdir)/generated/minloc2_8_s1.c \\\n+$(srcdir)/generated/minloc2_8_s4.c \\\n+$(srcdir)/generated/minloc2_16_s1.c \\\n+$(srcdir)/generated/minloc2_16_s4.c\n+\n i_minval_c = \\\n $(srcdir)/generated/minval_i1.c \\\n $(srcdir)/generated/minval_i2.c \\\n@@ -1127,7 +1189,7 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/pack.m4 \\\n     m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n-    m4/iall.m4 m4/iany.m4 m4/iparity.m4\n+    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n@@ -1138,7 +1200,8 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n-    $(i_cshift1a_c)\n+    $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n+    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c)\n \n \n # Machine generated specifics\n@@ -1314,6 +1377,8 @@ I_M4_DEPS = m4/iparm.m4\n I_M4_DEPS0 = $(I_M4_DEPS) m4/iforeach.m4\n I_M4_DEPS1 = $(I_M4_DEPS) m4/ifunction.m4\n I_M4_DEPS2 = $(I_M4_DEPS) m4/ifunction_logical.m4\n+I_M4_DEPS3 = $(I_M4_DEPS) m4/iforeach-s.m4\n+I_M4_DEPS4 = $(I_M4_DEPS) m4/ifunction-s.m4\n EXTRA_DIST = $(m4_files)\n all: $(BUILT_SOURCES) config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n@@ -1656,6 +1721,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_i2.Plo@am__quote@\n@@ -1665,6 +1732,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_4_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_i2.Plo@am__quote@\n@@ -1674,6 +1743,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_8_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_i2.Plo@am__quote@\n@@ -1683,6 +1754,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_16_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_i2.Plo@am__quote@\n@@ -1692,6 +1765,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_4_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_i2.Plo@am__quote@\n@@ -1701,6 +1776,14 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc1_8_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_16_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_16_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_4_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_4_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_8_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_8_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval_i2.Plo@am__quote@\n@@ -1721,6 +1804,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_16_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_16_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_16_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_16_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_16_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_i2.Plo@am__quote@\n@@ -1730,6 +1815,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_4_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_i2.Plo@am__quote@\n@@ -1739,6 +1826,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc0_8_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_i2.Plo@am__quote@\n@@ -1748,6 +1837,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_16_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_i2.Plo@am__quote@\n@@ -1757,6 +1848,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_4_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_i2.Plo@am__quote@\n@@ -1766,6 +1859,14 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc1_8_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_16_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_16_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_4_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_4_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_8_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_8_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval_i2.Plo@am__quote@\n@@ -5259,6 +5360,258 @@ cshift1_16_c16.lo: $(srcdir)/generated/cshift1_16_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_c16.lo `test -f '$(srcdir)/generated/cshift1_16_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c16.c\n \n+maxloc0_4_s1.lo: $(srcdir)/generated/maxloc0_4_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_4_s1.lo -MD -MP -MF $(DEPDIR)/maxloc0_4_s1.Tpo -c -o maxloc0_4_s1.lo `test -f '$(srcdir)/generated/maxloc0_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_4_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc0_4_s1.Tpo $(DEPDIR)/maxloc0_4_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc0_4_s1.c' object='maxloc0_4_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc0_4_s1.lo `test -f '$(srcdir)/generated/maxloc0_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_4_s1.c\n+\n+maxloc0_4_s4.lo: $(srcdir)/generated/maxloc0_4_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_4_s4.lo -MD -MP -MF $(DEPDIR)/maxloc0_4_s4.Tpo -c -o maxloc0_4_s4.lo `test -f '$(srcdir)/generated/maxloc0_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_4_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc0_4_s4.Tpo $(DEPDIR)/maxloc0_4_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc0_4_s4.c' object='maxloc0_4_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc0_4_s4.lo `test -f '$(srcdir)/generated/maxloc0_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_4_s4.c\n+\n+maxloc0_8_s1.lo: $(srcdir)/generated/maxloc0_8_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_8_s1.lo -MD -MP -MF $(DEPDIR)/maxloc0_8_s1.Tpo -c -o maxloc0_8_s1.lo `test -f '$(srcdir)/generated/maxloc0_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_8_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc0_8_s1.Tpo $(DEPDIR)/maxloc0_8_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc0_8_s1.c' object='maxloc0_8_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc0_8_s1.lo `test -f '$(srcdir)/generated/maxloc0_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_8_s1.c\n+\n+maxloc0_8_s4.lo: $(srcdir)/generated/maxloc0_8_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_8_s4.lo -MD -MP -MF $(DEPDIR)/maxloc0_8_s4.Tpo -c -o maxloc0_8_s4.lo `test -f '$(srcdir)/generated/maxloc0_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_8_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc0_8_s4.Tpo $(DEPDIR)/maxloc0_8_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc0_8_s4.c' object='maxloc0_8_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc0_8_s4.lo `test -f '$(srcdir)/generated/maxloc0_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_8_s4.c\n+\n+maxloc0_16_s1.lo: $(srcdir)/generated/maxloc0_16_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_16_s1.lo -MD -MP -MF $(DEPDIR)/maxloc0_16_s1.Tpo -c -o maxloc0_16_s1.lo `test -f '$(srcdir)/generated/maxloc0_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_16_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc0_16_s1.Tpo $(DEPDIR)/maxloc0_16_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc0_16_s1.c' object='maxloc0_16_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc0_16_s1.lo `test -f '$(srcdir)/generated/maxloc0_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_16_s1.c\n+\n+maxloc0_16_s4.lo: $(srcdir)/generated/maxloc0_16_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_16_s4.lo -MD -MP -MF $(DEPDIR)/maxloc0_16_s4.Tpo -c -o maxloc0_16_s4.lo `test -f '$(srcdir)/generated/maxloc0_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_16_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc0_16_s4.Tpo $(DEPDIR)/maxloc0_16_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc0_16_s4.c' object='maxloc0_16_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc0_16_s4.lo `test -f '$(srcdir)/generated/maxloc0_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_16_s4.c\n+\n+minloc0_4_s1.lo: $(srcdir)/generated/minloc0_4_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc0_4_s1.lo -MD -MP -MF $(DEPDIR)/minloc0_4_s1.Tpo -c -o minloc0_4_s1.lo `test -f '$(srcdir)/generated/minloc0_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_4_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc0_4_s1.Tpo $(DEPDIR)/minloc0_4_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc0_4_s1.c' object='minloc0_4_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc0_4_s1.lo `test -f '$(srcdir)/generated/minloc0_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_4_s1.c\n+\n+minloc0_4_s4.lo: $(srcdir)/generated/minloc0_4_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc0_4_s4.lo -MD -MP -MF $(DEPDIR)/minloc0_4_s4.Tpo -c -o minloc0_4_s4.lo `test -f '$(srcdir)/generated/minloc0_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_4_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc0_4_s4.Tpo $(DEPDIR)/minloc0_4_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc0_4_s4.c' object='minloc0_4_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc0_4_s4.lo `test -f '$(srcdir)/generated/minloc0_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_4_s4.c\n+\n+minloc0_8_s1.lo: $(srcdir)/generated/minloc0_8_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc0_8_s1.lo -MD -MP -MF $(DEPDIR)/minloc0_8_s1.Tpo -c -o minloc0_8_s1.lo `test -f '$(srcdir)/generated/minloc0_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_8_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc0_8_s1.Tpo $(DEPDIR)/minloc0_8_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc0_8_s1.c' object='minloc0_8_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc0_8_s1.lo `test -f '$(srcdir)/generated/minloc0_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_8_s1.c\n+\n+minloc0_8_s4.lo: $(srcdir)/generated/minloc0_8_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc0_8_s4.lo -MD -MP -MF $(DEPDIR)/minloc0_8_s4.Tpo -c -o minloc0_8_s4.lo `test -f '$(srcdir)/generated/minloc0_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_8_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc0_8_s4.Tpo $(DEPDIR)/minloc0_8_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc0_8_s4.c' object='minloc0_8_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc0_8_s4.lo `test -f '$(srcdir)/generated/minloc0_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_8_s4.c\n+\n+minloc0_16_s1.lo: $(srcdir)/generated/minloc0_16_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc0_16_s1.lo -MD -MP -MF $(DEPDIR)/minloc0_16_s1.Tpo -c -o minloc0_16_s1.lo `test -f '$(srcdir)/generated/minloc0_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_16_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc0_16_s1.Tpo $(DEPDIR)/minloc0_16_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc0_16_s1.c' object='minloc0_16_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc0_16_s1.lo `test -f '$(srcdir)/generated/minloc0_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_16_s1.c\n+\n+minloc0_16_s4.lo: $(srcdir)/generated/minloc0_16_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc0_16_s4.lo -MD -MP -MF $(DEPDIR)/minloc0_16_s4.Tpo -c -o minloc0_16_s4.lo `test -f '$(srcdir)/generated/minloc0_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_16_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc0_16_s4.Tpo $(DEPDIR)/minloc0_16_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc0_16_s4.c' object='minloc0_16_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc0_16_s4.lo `test -f '$(srcdir)/generated/minloc0_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc0_16_s4.c\n+\n+maxloc1_4_s1.lo: $(srcdir)/generated/maxloc1_4_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc1_4_s1.lo -MD -MP -MF $(DEPDIR)/maxloc1_4_s1.Tpo -c -o maxloc1_4_s1.lo `test -f '$(srcdir)/generated/maxloc1_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_4_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc1_4_s1.Tpo $(DEPDIR)/maxloc1_4_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc1_4_s1.c' object='maxloc1_4_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc1_4_s1.lo `test -f '$(srcdir)/generated/maxloc1_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_4_s1.c\n+\n+maxloc1_4_s4.lo: $(srcdir)/generated/maxloc1_4_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc1_4_s4.lo -MD -MP -MF $(DEPDIR)/maxloc1_4_s4.Tpo -c -o maxloc1_4_s4.lo `test -f '$(srcdir)/generated/maxloc1_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_4_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc1_4_s4.Tpo $(DEPDIR)/maxloc1_4_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc1_4_s4.c' object='maxloc1_4_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc1_4_s4.lo `test -f '$(srcdir)/generated/maxloc1_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_4_s4.c\n+\n+maxloc1_8_s1.lo: $(srcdir)/generated/maxloc1_8_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc1_8_s1.lo -MD -MP -MF $(DEPDIR)/maxloc1_8_s1.Tpo -c -o maxloc1_8_s1.lo `test -f '$(srcdir)/generated/maxloc1_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_8_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc1_8_s1.Tpo $(DEPDIR)/maxloc1_8_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc1_8_s1.c' object='maxloc1_8_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc1_8_s1.lo `test -f '$(srcdir)/generated/maxloc1_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_8_s1.c\n+\n+maxloc1_8_s4.lo: $(srcdir)/generated/maxloc1_8_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc1_8_s4.lo -MD -MP -MF $(DEPDIR)/maxloc1_8_s4.Tpo -c -o maxloc1_8_s4.lo `test -f '$(srcdir)/generated/maxloc1_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_8_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc1_8_s4.Tpo $(DEPDIR)/maxloc1_8_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc1_8_s4.c' object='maxloc1_8_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc1_8_s4.lo `test -f '$(srcdir)/generated/maxloc1_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_8_s4.c\n+\n+maxloc1_16_s1.lo: $(srcdir)/generated/maxloc1_16_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc1_16_s1.lo -MD -MP -MF $(DEPDIR)/maxloc1_16_s1.Tpo -c -o maxloc1_16_s1.lo `test -f '$(srcdir)/generated/maxloc1_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_16_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc1_16_s1.Tpo $(DEPDIR)/maxloc1_16_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc1_16_s1.c' object='maxloc1_16_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc1_16_s1.lo `test -f '$(srcdir)/generated/maxloc1_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_16_s1.c\n+\n+maxloc1_16_s4.lo: $(srcdir)/generated/maxloc1_16_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc1_16_s4.lo -MD -MP -MF $(DEPDIR)/maxloc1_16_s4.Tpo -c -o maxloc1_16_s4.lo `test -f '$(srcdir)/generated/maxloc1_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_16_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc1_16_s4.Tpo $(DEPDIR)/maxloc1_16_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc1_16_s4.c' object='maxloc1_16_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc1_16_s4.lo `test -f '$(srcdir)/generated/maxloc1_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc1_16_s4.c\n+\n+minloc1_4_s1.lo: $(srcdir)/generated/minloc1_4_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc1_4_s1.lo -MD -MP -MF $(DEPDIR)/minloc1_4_s1.Tpo -c -o minloc1_4_s1.lo `test -f '$(srcdir)/generated/minloc1_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_4_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc1_4_s1.Tpo $(DEPDIR)/minloc1_4_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc1_4_s1.c' object='minloc1_4_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc1_4_s1.lo `test -f '$(srcdir)/generated/minloc1_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_4_s1.c\n+\n+minloc1_4_s4.lo: $(srcdir)/generated/minloc1_4_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc1_4_s4.lo -MD -MP -MF $(DEPDIR)/minloc1_4_s4.Tpo -c -o minloc1_4_s4.lo `test -f '$(srcdir)/generated/minloc1_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_4_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc1_4_s4.Tpo $(DEPDIR)/minloc1_4_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc1_4_s4.c' object='minloc1_4_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc1_4_s4.lo `test -f '$(srcdir)/generated/minloc1_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_4_s4.c\n+\n+minloc1_8_s1.lo: $(srcdir)/generated/minloc1_8_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc1_8_s1.lo -MD -MP -MF $(DEPDIR)/minloc1_8_s1.Tpo -c -o minloc1_8_s1.lo `test -f '$(srcdir)/generated/minloc1_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_8_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc1_8_s1.Tpo $(DEPDIR)/minloc1_8_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc1_8_s1.c' object='minloc1_8_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc1_8_s1.lo `test -f '$(srcdir)/generated/minloc1_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_8_s1.c\n+\n+minloc1_8_s4.lo: $(srcdir)/generated/minloc1_8_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc1_8_s4.lo -MD -MP -MF $(DEPDIR)/minloc1_8_s4.Tpo -c -o minloc1_8_s4.lo `test -f '$(srcdir)/generated/minloc1_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_8_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc1_8_s4.Tpo $(DEPDIR)/minloc1_8_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc1_8_s4.c' object='minloc1_8_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc1_8_s4.lo `test -f '$(srcdir)/generated/minloc1_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_8_s4.c\n+\n+minloc1_16_s1.lo: $(srcdir)/generated/minloc1_16_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc1_16_s1.lo -MD -MP -MF $(DEPDIR)/minloc1_16_s1.Tpo -c -o minloc1_16_s1.lo `test -f '$(srcdir)/generated/minloc1_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_16_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc1_16_s1.Tpo $(DEPDIR)/minloc1_16_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc1_16_s1.c' object='minloc1_16_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc1_16_s1.lo `test -f '$(srcdir)/generated/minloc1_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_16_s1.c\n+\n+minloc1_16_s4.lo: $(srcdir)/generated/minloc1_16_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc1_16_s4.lo -MD -MP -MF $(DEPDIR)/minloc1_16_s4.Tpo -c -o minloc1_16_s4.lo `test -f '$(srcdir)/generated/minloc1_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_16_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc1_16_s4.Tpo $(DEPDIR)/minloc1_16_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc1_16_s4.c' object='minloc1_16_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc1_16_s4.lo `test -f '$(srcdir)/generated/minloc1_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc1_16_s4.c\n+\n+maxloc2_4_s1.lo: $(srcdir)/generated/maxloc2_4_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc2_4_s1.lo -MD -MP -MF $(DEPDIR)/maxloc2_4_s1.Tpo -c -o maxloc2_4_s1.lo `test -f '$(srcdir)/generated/maxloc2_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_4_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc2_4_s1.Tpo $(DEPDIR)/maxloc2_4_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc2_4_s1.c' object='maxloc2_4_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc2_4_s1.lo `test -f '$(srcdir)/generated/maxloc2_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_4_s1.c\n+\n+maxloc2_4_s4.lo: $(srcdir)/generated/maxloc2_4_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc2_4_s4.lo -MD -MP -MF $(DEPDIR)/maxloc2_4_s4.Tpo -c -o maxloc2_4_s4.lo `test -f '$(srcdir)/generated/maxloc2_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_4_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc2_4_s4.Tpo $(DEPDIR)/maxloc2_4_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc2_4_s4.c' object='maxloc2_4_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc2_4_s4.lo `test -f '$(srcdir)/generated/maxloc2_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_4_s4.c\n+\n+maxloc2_8_s1.lo: $(srcdir)/generated/maxloc2_8_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc2_8_s1.lo -MD -MP -MF $(DEPDIR)/maxloc2_8_s1.Tpo -c -o maxloc2_8_s1.lo `test -f '$(srcdir)/generated/maxloc2_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_8_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc2_8_s1.Tpo $(DEPDIR)/maxloc2_8_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc2_8_s1.c' object='maxloc2_8_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc2_8_s1.lo `test -f '$(srcdir)/generated/maxloc2_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_8_s1.c\n+\n+maxloc2_8_s4.lo: $(srcdir)/generated/maxloc2_8_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc2_8_s4.lo -MD -MP -MF $(DEPDIR)/maxloc2_8_s4.Tpo -c -o maxloc2_8_s4.lo `test -f '$(srcdir)/generated/maxloc2_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_8_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc2_8_s4.Tpo $(DEPDIR)/maxloc2_8_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc2_8_s4.c' object='maxloc2_8_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc2_8_s4.lo `test -f '$(srcdir)/generated/maxloc2_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_8_s4.c\n+\n+maxloc2_16_s1.lo: $(srcdir)/generated/maxloc2_16_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc2_16_s1.lo -MD -MP -MF $(DEPDIR)/maxloc2_16_s1.Tpo -c -o maxloc2_16_s1.lo `test -f '$(srcdir)/generated/maxloc2_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_16_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc2_16_s1.Tpo $(DEPDIR)/maxloc2_16_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc2_16_s1.c' object='maxloc2_16_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc2_16_s1.lo `test -f '$(srcdir)/generated/maxloc2_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_16_s1.c\n+\n+maxloc2_16_s4.lo: $(srcdir)/generated/maxloc2_16_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc2_16_s4.lo -MD -MP -MF $(DEPDIR)/maxloc2_16_s4.Tpo -c -o maxloc2_16_s4.lo `test -f '$(srcdir)/generated/maxloc2_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_16_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxloc2_16_s4.Tpo $(DEPDIR)/maxloc2_16_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxloc2_16_s4.c' object='maxloc2_16_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxloc2_16_s4.lo `test -f '$(srcdir)/generated/maxloc2_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc2_16_s4.c\n+\n+minloc2_4_s1.lo: $(srcdir)/generated/minloc2_4_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc2_4_s1.lo -MD -MP -MF $(DEPDIR)/minloc2_4_s1.Tpo -c -o minloc2_4_s1.lo `test -f '$(srcdir)/generated/minloc2_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_4_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc2_4_s1.Tpo $(DEPDIR)/minloc2_4_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc2_4_s1.c' object='minloc2_4_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_4_s1.lo `test -f '$(srcdir)/generated/minloc2_4_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_4_s1.c\n+\n+minloc2_4_s4.lo: $(srcdir)/generated/minloc2_4_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc2_4_s4.lo -MD -MP -MF $(DEPDIR)/minloc2_4_s4.Tpo -c -o minloc2_4_s4.lo `test -f '$(srcdir)/generated/minloc2_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_4_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc2_4_s4.Tpo $(DEPDIR)/minloc2_4_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc2_4_s4.c' object='minloc2_4_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_4_s4.lo `test -f '$(srcdir)/generated/minloc2_4_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_4_s4.c\n+\n+minloc2_8_s1.lo: $(srcdir)/generated/minloc2_8_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc2_8_s1.lo -MD -MP -MF $(DEPDIR)/minloc2_8_s1.Tpo -c -o minloc2_8_s1.lo `test -f '$(srcdir)/generated/minloc2_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_8_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc2_8_s1.Tpo $(DEPDIR)/minloc2_8_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc2_8_s1.c' object='minloc2_8_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_8_s1.lo `test -f '$(srcdir)/generated/minloc2_8_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_8_s1.c\n+\n+minloc2_8_s4.lo: $(srcdir)/generated/minloc2_8_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc2_8_s4.lo -MD -MP -MF $(DEPDIR)/minloc2_8_s4.Tpo -c -o minloc2_8_s4.lo `test -f '$(srcdir)/generated/minloc2_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_8_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc2_8_s4.Tpo $(DEPDIR)/minloc2_8_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc2_8_s4.c' object='minloc2_8_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_8_s4.lo `test -f '$(srcdir)/generated/minloc2_8_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_8_s4.c\n+\n+minloc2_16_s1.lo: $(srcdir)/generated/minloc2_16_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc2_16_s1.lo -MD -MP -MF $(DEPDIR)/minloc2_16_s1.Tpo -c -o minloc2_16_s1.lo `test -f '$(srcdir)/generated/minloc2_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_16_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc2_16_s1.Tpo $(DEPDIR)/minloc2_16_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc2_16_s1.c' object='minloc2_16_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_16_s1.lo `test -f '$(srcdir)/generated/minloc2_16_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_16_s1.c\n+\n+minloc2_16_s4.lo: $(srcdir)/generated/minloc2_16_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minloc2_16_s4.lo -MD -MP -MF $(DEPDIR)/minloc2_16_s4.Tpo -c -o minloc2_16_s4.lo `test -f '$(srcdir)/generated/minloc2_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_16_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minloc2_16_s4.Tpo $(DEPDIR)/minloc2_16_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minloc2_16_s4.c' object='minloc2_16_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_16_s4.lo `test -f '$(srcdir)/generated/minloc2_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_16_s4.c\n+\n size_from_kind.lo: io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT size_from_kind.lo -MD -MP -MF $(DEPDIR)/size_from_kind.Tpo -c -o size_from_kind.lo `test -f 'io/size_from_kind.c' || echo '$(srcdir)/'`io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/size_from_kind.Tpo $(DEPDIR)/size_from_kind.Plo\n@@ -6139,18 +6492,36 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_maxloc0_c): m4/maxloc0.m4 $(I_M4_DEPS0)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc0.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_maxloc0s_c) : m4/maxloc0s.m4 $(I_M4_DEPS3)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc0s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_maxloc1_c): m4/maxloc1.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc1.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_maxloc1s_c): m4/maxloc1s.m4 $(I_M4_DEPS4)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc1s.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_maxloc2s_c): m4/maxloc2s.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc2s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_maxval_c): m4/maxval.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval.m4 > $@\n \n @MAINTAINER_MODE_TRUE@$(i_minloc0_c): m4/minloc0.m4 $(I_M4_DEPS0)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc0.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_minloc0s_c) : m4/minloc0s.m4 $(I_M4_DEPS3)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc0s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_minloc1_c): m4/minloc1.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc1.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_minloc1s_c): m4/minloc1s.m4 $(I_M4_DEPS4)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc1s.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_minloc2s_c): m4/minloc2s.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc2s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_minval_c): m4/minval.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval.m4 > $@\n "}, {"sha": "949fb2099010df0be3fbd205eb4b7ceb10fbca72", "filename": "libgfortran/generated/maxloc0_16_s1.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void maxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+export_proto(maxloc0_16_s1);\n+\n+void\n+maxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_1 *maxval;\n+   maxval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mmaxloc0_16_s1);\n+\n+void\n+mmaxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_1 *maxval;\n+\n+  maxval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(smaxloc0_16_s1);\n+\n+void\n+smaxloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_s1 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "1ac7a9da1a6b70b932256e5eaa5fb3f862e4f13c", "filename": "libgfortran/generated/maxloc0_16_s4.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void maxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+export_proto(maxloc0_16_s4);\n+\n+void\n+maxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_4 *maxval;\n+   maxval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mmaxloc0_16_s4);\n+\n+void\n+mmaxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_4 *maxval;\n+\n+  maxval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(smaxloc0_16_s4);\n+\n+void\n+smaxloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_s4 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "6d897d8a83587938a1ff01c35288fe14f78d85bd", "filename": "libgfortran/generated/maxloc0_4_s1.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void maxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+export_proto(maxloc0_4_s1);\n+\n+void\n+maxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_1 *maxval;\n+   maxval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mmaxloc0_4_s1);\n+\n+void\n+mmaxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_1 *maxval;\n+\n+  maxval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(smaxloc0_4_s1);\n+\n+void\n+smaxloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_s1 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "3a8e603fe92b0d334adf24501fdfa44a1af94675", "filename": "libgfortran/generated/maxloc0_4_s4.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void maxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+export_proto(maxloc0_4_s4);\n+\n+void\n+maxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_4 *maxval;\n+   maxval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mmaxloc0_4_s4);\n+\n+void\n+mmaxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_4 *maxval;\n+\n+  maxval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(smaxloc0_4_s4);\n+\n+void\n+smaxloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_s4 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "f01973604a71d737de053b45a3851c98febebad7", "filename": "libgfortran/generated/maxloc0_8_s1.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void maxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+export_proto(maxloc0_8_s1);\n+\n+void\n+maxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_1 *maxval;\n+   maxval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mmaxloc0_8_s1);\n+\n+void\n+mmaxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_1 *maxval;\n+\n+  maxval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(smaxloc0_8_s1);\n+\n+void\n+smaxloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_s1 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "524a6215222aea334fc84544759daf288318f78e", "filename": "libgfortran/generated/maxloc0_8_s4.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void maxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+export_proto(maxloc0_8_s4);\n+\n+void\n+maxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_4 *maxval;\n+   maxval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mmaxloc0_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mmaxloc0_8_s4);\n+\n+void\n+mmaxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_4 *maxval;\n+\n+  maxval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(smaxloc0_8_s4);\n+\n+void\n+smaxloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_s4 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "b8efc0aadea2781691eb92608ca17c0d2d295e7b", "filename": "libgfortran/generated/maxloc1_16_s1.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxloc1_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(maxloc1_16_s1);\n+\n+void\n+maxloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *maxval;\n+\tmaxval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxloc1_16_s1);\n+\n+void\n+mmaxloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *maxval;\n+\tmaxval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxloc1_16_s1);\n+\n+void\n+smaxloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_s1 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "466d3627059ed960031d3620b6d4a3793952b173", "filename": "libgfortran/generated/maxloc1_16_s4.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxloc1_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(maxloc1_16_s4);\n+\n+void\n+maxloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *maxval;\n+\tmaxval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxloc1_16_s4);\n+\n+void\n+mmaxloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *maxval;\n+\tmaxval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxloc1_16_s4);\n+\n+void\n+smaxloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_s4 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "6116e5be1aff67775f2d034b6569946ec9b5fd8a", "filename": "libgfortran/generated/maxloc1_4_s1.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxloc1_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(maxloc1_4_s1);\n+\n+void\n+maxloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *maxval;\n+\tmaxval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxloc1_4_s1);\n+\n+void\n+mmaxloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *maxval;\n+\tmaxval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxloc1_4_s1);\n+\n+void\n+smaxloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_s1 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "16b1616f1b54ce5840861b190f246b80135de424", "filename": "libgfortran/generated/maxloc1_4_s4.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxloc1_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(maxloc1_4_s4);\n+\n+void\n+maxloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *maxval;\n+\tmaxval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxloc1_4_s4);\n+\n+void\n+mmaxloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *maxval;\n+\tmaxval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxloc1_4_s4);\n+\n+void\n+smaxloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_s4 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "f3d8697367e0d710358ca6641fce1a7cb5b7e968", "filename": "libgfortran/generated/maxloc1_8_s1.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxloc1_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(maxloc1_8_s1);\n+\n+void\n+maxloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *maxval;\n+\tmaxval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxloc1_8_s1);\n+\n+void\n+mmaxloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *maxval;\n+\tmaxval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxloc1_8_s1);\n+\n+void\n+smaxloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_s1 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "bebc18541320b7cecd77a51c5952f843fbdabb99", "filename": "libgfortran/generated/maxloc1_8_s4.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxloc1_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(maxloc1_8_s4);\n+\n+void\n+maxloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *maxval;\n+\tmaxval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxloc1_8_s4);\n+\n+void\n+mmaxloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *maxval;\n+\tmaxval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxloc1_8_s4);\n+\n+void\n+smaxloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_s4 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "7770101e0f7569d611e7c9cfe79cf85ec10e5296", "filename": "libgfortran/generated/maxloc2_16_s1.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_16 maxloc2_16_s1 (gfc_array_s1 * const restrict, int);\n+export_proto(maxloc2_16_s1);\n+\n+GFC_INTEGER_16\n+maxloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 mmaxloc2_16_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(mmaxloc2_16_s1);\n+\n+GFC_INTEGER_16\n+mmaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 smaxloc2_16_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(smaxloc2_16_s1);\n+\n+GFC_INTEGER_16\n+smaxloc2_16_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return maxloc2_16_s1 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "327979000fc2eaf028082e2b39b5892b9e4d155a", "filename": "libgfortran/generated/maxloc2_16_s4.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_16_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_16 maxloc2_16_s4 (gfc_array_s4 * const restrict, int);\n+export_proto(maxloc2_16_s4);\n+\n+GFC_INTEGER_16\n+maxloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 mmaxloc2_16_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(mmaxloc2_16_s4);\n+\n+GFC_INTEGER_16\n+mmaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 smaxloc2_16_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(smaxloc2_16_s4);\n+\n+GFC_INTEGER_16\n+smaxloc2_16_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return maxloc2_16_s4 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "a969fcbac93820ed2d40e6ba42a5cd18d654aee2", "filename": "libgfortran/generated/maxloc2_4_s1.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_4 maxloc2_4_s1 (gfc_array_s1 * const restrict, int);\n+export_proto(maxloc2_4_s1);\n+\n+GFC_INTEGER_4\n+maxloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 mmaxloc2_4_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(mmaxloc2_4_s1);\n+\n+GFC_INTEGER_4\n+mmaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 smaxloc2_4_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(smaxloc2_4_s1);\n+\n+GFC_INTEGER_4\n+smaxloc2_4_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return maxloc2_4_s1 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "3e9c089e2811604b64f76aec872962b4ac77551f", "filename": "libgfortran/generated/maxloc2_4_s4.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_4_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_4 maxloc2_4_s4 (gfc_array_s4 * const restrict, int);\n+export_proto(maxloc2_4_s4);\n+\n+GFC_INTEGER_4\n+maxloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 mmaxloc2_4_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(mmaxloc2_4_s4);\n+\n+GFC_INTEGER_4\n+mmaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 smaxloc2_4_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(smaxloc2_4_s4);\n+\n+GFC_INTEGER_4\n+smaxloc2_4_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return maxloc2_4_s4 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "bb84ff40461d1307680c4ad8a47600c5940f305e", "filename": "libgfortran/generated/maxloc2_8_s1.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_8 maxloc2_8_s1 (gfc_array_s1 * const restrict, int);\n+export_proto(maxloc2_8_s1);\n+\n+GFC_INTEGER_8\n+maxloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 mmaxloc2_8_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(mmaxloc2_8_s1);\n+\n+GFC_INTEGER_8\n+mmaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 smaxloc2_8_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(smaxloc2_8_s1);\n+\n+GFC_INTEGER_8\n+smaxloc2_8_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return maxloc2_8_s1 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "1aa67ca391c60c313dc3803c7656e76662f01eb9", "filename": "libgfortran/generated/maxloc2_8_s4.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc2_8_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_8 maxloc2_8_s4 (gfc_array_s4 * const restrict, int);\n+export_proto(maxloc2_8_s4);\n+\n+GFC_INTEGER_8\n+maxloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 mmaxloc2_8_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(mmaxloc2_8_s4);\n+\n+GFC_INTEGER_8\n+mmaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 smaxloc2_8_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(smaxloc2_8_s4);\n+\n+GFC_INTEGER_8\n+smaxloc2_8_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return maxloc2_8_s4 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "e43feaf2c4e07c6ae36a1b30708e7b8e023d5f45", "filename": "libgfortran/generated/minloc0_16_s1.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void minloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+export_proto(minloc0_16_s1);\n+\n+void\n+minloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_1 *minval;\n+   minval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mminloc0_16_s1);\n+\n+void\n+mminloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_1 *minval;\n+\n+  minval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(sminloc0_16_s1);\n+\n+void\n+sminloc0_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_s1 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "9e1ba354b5c52208c0cf6bf848ea7504c38e3976", "filename": "libgfortran/generated/minloc0_16_s4.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void minloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+export_proto(minloc0_16_s4);\n+\n+void\n+minloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_4 *minval;\n+   minval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mminloc0_16_s4);\n+\n+void\n+mminloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_4 *minval;\n+\n+  minval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(sminloc0_16_s4);\n+\n+void\n+sminloc0_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_s4 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "ab95a83ecd6265d46c2122e433b8bb231a71edd6", "filename": "libgfortran/generated/minloc0_4_s1.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void minloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+export_proto(minloc0_4_s1);\n+\n+void\n+minloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_1 *minval;\n+   minval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mminloc0_4_s1);\n+\n+void\n+mminloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_1 *minval;\n+\n+  minval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(sminloc0_4_s1);\n+\n+void\n+sminloc0_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_s1 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "4afe02e5ed2fba0069d1b0781403d58f7b35587d", "filename": "libgfortran/generated/minloc0_4_s4.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void minloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+export_proto(minloc0_4_s4);\n+\n+void\n+minloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_4 *minval;\n+   minval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mminloc0_4_s4);\n+\n+void\n+mminloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_4 *minval;\n+\n+  minval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(sminloc0_4_s4);\n+\n+void\n+sminloc0_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_s4 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "0dc18feb8ec93db1f40e2692dec106d112ed4d7c", "filename": "libgfortran/generated/minloc0_8_s1.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void minloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len);\n+export_proto(minloc0_8_s1);\n+\n+void\n+minloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_1 *base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_1 *minval;\n+   minval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mminloc0_8_s1);\n+\n+void\n+mminloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_1 *minval;\n+\n+  minval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(sminloc0_8_s1);\n+\n+void\n+sminloc0_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_s1 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "bd847889bc7e8f0d9a0b7539c65c5795ecb5b070", "filename": "libgfortran/generated/minloc0_8_s4.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc0_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,327 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void minloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len);\n+export_proto(minloc0_8_s4);\n+\n+void\n+minloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_INTEGER_4 *base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+  const GFC_INTEGER_4 *minval;\n+   minval = base;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void mminloc0_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(mminloc0_8_s4);\n+\n+void\n+mminloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  const GFC_INTEGER_4 *minval;\n+\n+  minval = NULL;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void sminloc0_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(sminloc0_8_s4);\n+\n+void\n+sminloc0_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_s4 (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "80269a6c495ce399e66722e1ed63c7418739731f", "filename": "libgfortran/generated/minloc1_16_s1.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minloc1_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(minloc1_16_s1);\n+\n+void\n+minloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *minval;\n+\tminval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminloc1_16_s1);\n+\n+void\n+mminloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *minval;\n+\tminval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_16_s1 (gfc_array_i16 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminloc1_16_s1);\n+\n+void\n+sminloc1_16_s1 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minloc1_16_s1 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "1ba1a011b090e2593d09bf2609020dc9474bbeaf", "filename": "libgfortran/generated/minloc1_16_s4.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minloc1_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(minloc1_16_s4);\n+\n+void\n+minloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *minval;\n+\tminval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminloc1_16_s4);\n+\n+void\n+mminloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *minval;\n+\tminval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_16_s4 (gfc_array_i16 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminloc1_16_s4);\n+\n+void\n+sminloc1_16_s4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minloc1_16_s4 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "bbead6b88338e4eaa3471ed3bfea9ef91a4f1d2d", "filename": "libgfortran/generated/minloc1_4_s1.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minloc1_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(minloc1_4_s1);\n+\n+void\n+minloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *minval;\n+\tminval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminloc1_4_s1);\n+\n+void\n+mminloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *minval;\n+\tminval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_4_s1 (gfc_array_i4 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminloc1_4_s1);\n+\n+void\n+sminloc1_4_s1 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minloc1_4_s1 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "673702b6e5ad27c57cca946b21ceb22dc831381a", "filename": "libgfortran/generated/minloc1_4_s4.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minloc1_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(minloc1_4_s4);\n+\n+void\n+minloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *minval;\n+\tminval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminloc1_4_s4);\n+\n+void\n+mminloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *minval;\n+\tminval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_4_s4 (gfc_array_i4 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminloc1_4_s4);\n+\n+void\n+sminloc1_4_s4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minloc1_4_s4 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "90ab35324a295de381bb06b9fb068064aa2326fe", "filename": "libgfortran/generated/minloc1_8_s1.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minloc1_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(minloc1_8_s1);\n+\n+void\n+minloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *minval;\n+\tminval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminloc1_8_s1);\n+\n+void\n+mminloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *minval;\n+\tminval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_8_s1 (gfc_array_i8 * const restrict, \n+\tgfc_array_s1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminloc1_8_s1);\n+\n+void\n+sminloc1_8_s1 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minloc1_8_s1 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "10c02083a9450775df07f3a43ea19e0edc1ea8b7", "filename": "libgfortran/generated/minloc1_8_s4.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc1_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,552 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+#include <string.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minloc1_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(minloc1_8_s4);\n+\n+void\n+minloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *minval;\n+\tminval = base;\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminloc1_8_s4);\n+\n+void\n+mminloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *minval;\n+\tminval = base;\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      \n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_8_s4 (gfc_array_i8 * const restrict, \n+\tgfc_array_s4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminloc1_8_s4);\n+\n+void\n+sminloc1_8_s4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minloc1_8_s4 (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "3f9e907f84db63c8b54a1bbea513b1b4db08f4b6", "filename": "libgfortran/generated/minloc2_16_s1.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_16_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,155 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_16 minloc2_16_s1 (gfc_array_s1 * const restrict, int);\n+export_proto(minloc2_16_s1);\n+\n+GFC_INTEGER_16\n+minloc2_16_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 mminloc2_16_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(mminloc2_16_s1);\n+\n+GFC_INTEGER_16\n+mminloc2_16_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 sminloc2_16_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(sminloc2_16_s1);\n+\n+GFC_INTEGER_16\n+sminloc2_16_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return minloc2_16_s1 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "4857b08832c302bee4264f7bdc21fe65691dc143", "filename": "libgfortran/generated/minloc2_16_s4.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_16_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_16_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,155 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_16 minloc2_16_s4 (gfc_array_s4 * const restrict, int);\n+export_proto(minloc2_16_s4);\n+\n+GFC_INTEGER_16\n+minloc2_16_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 mminloc2_16_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(mminloc2_16_s4);\n+\n+GFC_INTEGER_16\n+mminloc2_16_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_16 sminloc2_16_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(sminloc2_16_s4);\n+\n+GFC_INTEGER_16\n+sminloc2_16_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return minloc2_16_s4 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "2fd526df0b863556e076c8cdc7e07c66c53e1fc3", "filename": "libgfortran/generated/minloc2_4_s1.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_4_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,155 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_4 minloc2_4_s1 (gfc_array_s1 * const restrict, int);\n+export_proto(minloc2_4_s1);\n+\n+GFC_INTEGER_4\n+minloc2_4_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 mminloc2_4_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(mminloc2_4_s1);\n+\n+GFC_INTEGER_4\n+mminloc2_4_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 sminloc2_4_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(sminloc2_4_s1);\n+\n+GFC_INTEGER_4\n+sminloc2_4_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return minloc2_4_s1 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "ad85d266fe2c1d589766cd53b85bb8db6b626b2b", "filename": "libgfortran/generated/minloc2_4_s4.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_4_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_4_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,155 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_4 minloc2_4_s4 (gfc_array_s4 * const restrict, int);\n+export_proto(minloc2_4_s4);\n+\n+GFC_INTEGER_4\n+minloc2_4_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 mminloc2_4_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(mminloc2_4_s4);\n+\n+GFC_INTEGER_4\n+mminloc2_4_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_4 sminloc2_4_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(sminloc2_4_s4);\n+\n+GFC_INTEGER_4\n+sminloc2_4_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return minloc2_4_s4 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "0b594d6c6c61be729de6f8fb646441f3924564ee", "filename": "libgfortran/generated/minloc2_8_s1.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_8_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s1.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,155 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_8 minloc2_8_s1 (gfc_array_s1 * const restrict, int);\n+export_proto(minloc2_8_s1);\n+\n+GFC_INTEGER_8\n+minloc2_8_s1 (gfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 mminloc2_8_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(mminloc2_8_s1);\n+\n+GFC_INTEGER_8\n+mminloc2_8_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_1 *src;\n+  const GFC_INTEGER_1 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 sminloc2_8_s1 (gfc_array_s1 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(sminloc2_8_s1);\n+\n+GFC_INTEGER_8\n+sminloc2_8_s1 (gfc_array_s1 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return minloc2_8_s1 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "71a55fcfba26eddb9575a8a9e01b681a449be17e", "filename": "libgfortran/generated/minloc2_8_s4.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgenerated%2Fminloc2_8_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc2_8_s4.c?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,155 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, int n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern GFC_INTEGER_8 minloc2_8_s4 (gfc_array_s4 * const restrict, int);\n+export_proto(minloc2_8_s4);\n+\n+GFC_INTEGER_8\n+minloc2_8_s4 (gfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 mminloc2_8_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(mminloc2_8_s4);\n+\n+GFC_INTEGER_8\n+mminloc2_8_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const GFC_INTEGER_4 *src;\n+  const GFC_INTEGER_4 *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern GFC_INTEGER_8 sminloc2_8_s4 (gfc_array_s4 * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(sminloc2_8_s4);\n+\n+GFC_INTEGER_8\n+sminloc2_8_s4 (gfc_array_s4 * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return minloc2_8_s4 (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif"}, {"sha": "4f8b4f3e298069d97401faf9621834889a32a298", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -1,4 +1,4 @@\n-GFORTRAN_7 {\n+GFORTRAN_8 {\n   global:\n     __ieee_arithmetic_MOD_ieee_class_10;\n     __ieee_arithmetic_MOD_ieee_class_16;\n@@ -357,6 +357,8 @@ GFORTRAN_7 {\n     _gfortran_maxloc0_16_r16;\n     _gfortran_maxloc0_16_r4;\n     _gfortran_maxloc0_16_r8;\n+    _gfortran_maxloc0_16_s1;\n+    _gfortran_maxloc0_16_s4;\n     _gfortran_maxloc0_4_i16;\n     _gfortran_maxloc0_4_i1;\n     _gfortran_maxloc0_4_i2;\n@@ -366,6 +368,8 @@ GFORTRAN_7 {\n     _gfortran_maxloc0_4_r16;\n     _gfortran_maxloc0_4_r4;\n     _gfortran_maxloc0_4_r8;\n+    _gfortran_maxloc0_4_s1;\n+    _gfortran_maxloc0_4_s4;\n     _gfortran_maxloc0_8_i16;\n     _gfortran_maxloc0_8_i1;\n     _gfortran_maxloc0_8_i2;\n@@ -375,6 +379,8 @@ GFORTRAN_7 {\n     _gfortran_maxloc0_8_r16;\n     _gfortran_maxloc0_8_r4;\n     _gfortran_maxloc0_8_r8;\n+    _gfortran_maxloc0_8_s1;\n+    _gfortran_maxloc0_8_s4;\n     _gfortran_maxloc1_16_i16;\n     _gfortran_maxloc1_16_i1;\n     _gfortran_maxloc1_16_i2;\n@@ -384,6 +390,8 @@ GFORTRAN_7 {\n     _gfortran_maxloc1_16_r16;\n     _gfortran_maxloc1_16_r4;\n     _gfortran_maxloc1_16_r8;\n+    _gfortran_maxloc1_16_s1;\n+    _gfortran_maxloc1_16_s4;\n     _gfortran_maxloc1_4_i16;\n     _gfortran_maxloc1_4_i1;\n     _gfortran_maxloc1_4_i2;\n@@ -393,6 +401,8 @@ GFORTRAN_7 {\n     _gfortran_maxloc1_4_r16;\n     _gfortran_maxloc1_4_r4;\n     _gfortran_maxloc1_4_r8;\n+    _gfortran_maxloc1_4_s1;\n+    _gfortran_maxloc1_4_s4;\n     _gfortran_maxloc1_8_i16;\n     _gfortran_maxloc1_8_i1;\n     _gfortran_maxloc1_8_i2;\n@@ -402,6 +412,14 @@ GFORTRAN_7 {\n     _gfortran_maxloc1_8_r16;\n     _gfortran_maxloc1_8_r4;\n     _gfortran_maxloc1_8_r8;\n+    _gfortran_maxloc1_8_s1;\n+    _gfortran_maxloc1_8_s4;\n+    _gfortran_maxloc2_16_s1;\n+    _gfortran_maxloc2_16_s4;\n+    _gfortran_maxloc2_4_s1;\n+    _gfortran_maxloc2_4_s4;\n+    _gfortran_maxloc2_8_s1;\n+    _gfortran_maxloc2_8_s4;\n     _gfortran_maxval_i16;\n     _gfortran_maxval_i1;\n     _gfortran_maxval_i2;\n@@ -432,6 +450,8 @@ GFORTRAN_7 {\n     _gfortran_minloc0_16_r16;\n     _gfortran_minloc0_16_r4;\n     _gfortran_minloc0_16_r8;\n+    _gfortran_minloc0_16_s1;\n+    _gfortran_minloc0_16_s4;\n     _gfortran_minloc0_4_i16;\n     _gfortran_minloc0_4_i1;\n     _gfortran_minloc0_4_i2;\n@@ -441,6 +461,8 @@ GFORTRAN_7 {\n     _gfortran_minloc0_4_r16;\n     _gfortran_minloc0_4_r4;\n     _gfortran_minloc0_4_r8;\n+    _gfortran_minloc0_4_s1;\n+    _gfortran_minloc0_4_s4;\n     _gfortran_minloc0_8_i16;\n     _gfortran_minloc0_8_i1;\n     _gfortran_minloc0_8_i2;\n@@ -450,6 +472,8 @@ GFORTRAN_7 {\n     _gfortran_minloc0_8_r16;\n     _gfortran_minloc0_8_r4;\n     _gfortran_minloc0_8_r8;\n+    _gfortran_minloc0_8_s1;\n+    _gfortran_minloc0_8_s4;\n     _gfortran_minloc1_16_i16;\n     _gfortran_minloc1_16_i1;\n     _gfortran_minloc1_16_i2;\n@@ -459,6 +483,8 @@ GFORTRAN_7 {\n     _gfortran_minloc1_16_r16;\n     _gfortran_minloc1_16_r4;\n     _gfortran_minloc1_16_r8;\n+    _gfortran_minloc1_16_s1;\n+    _gfortran_minloc1_16_s4;\n     _gfortran_minloc1_4_i16;\n     _gfortran_minloc1_4_i1;\n     _gfortran_minloc1_4_i2;\n@@ -468,6 +494,8 @@ GFORTRAN_7 {\n     _gfortran_minloc1_4_r16;\n     _gfortran_minloc1_4_r4;\n     _gfortran_minloc1_4_r8;\n+    _gfortran_minloc1_4_s1;\n+    _gfortran_minloc1_4_s4;\n     _gfortran_minloc1_8_i16;\n     _gfortran_minloc1_8_i1;\n     _gfortran_minloc1_8_i2;\n@@ -477,6 +505,14 @@ GFORTRAN_7 {\n     _gfortran_minloc1_8_r16;\n     _gfortran_minloc1_8_r4;\n     _gfortran_minloc1_8_r8;\n+    _gfortran_minloc1_8_s1;\n+    _gfortran_minloc1_8_s4;\n+    _gfortran_minloc2_16_s1;\n+    _gfortran_minloc2_16_s4;\n+    _gfortran_minloc2_4_s1;\n+    _gfortran_minloc2_4_s4;\n+    _gfortran_minloc2_8_s1;\n+    _gfortran_minloc2_8_s4;\n     _gfortran_minval_i16;\n     _gfortran_minval_i1;\n     _gfortran_minval_i2;\n@@ -500,6 +536,8 @@ GFORTRAN_7 {\n     _gfortran_mmaxloc0_16_r16;\n     _gfortran_mmaxloc0_16_r4;\n     _gfortran_mmaxloc0_16_r8;\n+    _gfortran_mmaxloc0_16_s1;\n+    _gfortran_mmaxloc0_16_s4;\n     _gfortran_mmaxloc0_4_i16;\n     _gfortran_mmaxloc0_4_i1;\n     _gfortran_mmaxloc0_4_i2;\n@@ -509,6 +547,8 @@ GFORTRAN_7 {\n     _gfortran_mmaxloc0_4_r16;\n     _gfortran_mmaxloc0_4_r4;\n     _gfortran_mmaxloc0_4_r8;\n+    _gfortran_mmaxloc0_4_s1;\n+    _gfortran_mmaxloc0_4_s4;\n     _gfortran_mmaxloc0_8_i16;\n     _gfortran_mmaxloc0_8_i1;\n     _gfortran_mmaxloc0_8_i2;\n@@ -518,6 +558,8 @@ GFORTRAN_7 {\n     _gfortran_mmaxloc0_8_r16;\n     _gfortran_mmaxloc0_8_r4;\n     _gfortran_mmaxloc0_8_r8;\n+    _gfortran_mmaxloc0_8_s1;\n+    _gfortran_mmaxloc0_8_s4;\n     _gfortran_mmaxloc1_16_i16;\n     _gfortran_mmaxloc1_16_i1;\n     _gfortran_mmaxloc1_16_i2;\n@@ -527,6 +569,8 @@ GFORTRAN_7 {\n     _gfortran_mmaxloc1_16_r16;\n     _gfortran_mmaxloc1_16_r4;\n     _gfortran_mmaxloc1_16_r8;\n+    _gfortran_mmaxloc1_16_s1;\n+    _gfortran_mmaxloc1_16_s4;\n     _gfortran_mmaxloc1_4_i16;\n     _gfortran_mmaxloc1_4_i1;\n     _gfortran_mmaxloc1_4_i2;\n@@ -536,6 +580,8 @@ GFORTRAN_7 {\n     _gfortran_mmaxloc1_4_r16;\n     _gfortran_mmaxloc1_4_r4;\n     _gfortran_mmaxloc1_4_r8;\n+    _gfortran_mmaxloc1_4_s1;\n+    _gfortran_mmaxloc1_4_s4;\n     _gfortran_mmaxloc1_8_i16;\n     _gfortran_mmaxloc1_8_i1;\n     _gfortran_mmaxloc1_8_i2;\n@@ -545,6 +591,14 @@ GFORTRAN_7 {\n     _gfortran_mmaxloc1_8_r16;\n     _gfortran_mmaxloc1_8_r4;\n     _gfortran_mmaxloc1_8_r8;\n+    _gfortran_mmaxloc1_8_s1;\n+    _gfortran_mmaxloc1_8_s4;\n+    _gfortran_mmaxloc2_16_s1;\n+    _gfortran_mmaxloc2_16_s4;\n+    _gfortran_mmaxloc2_4_s1;\n+    _gfortran_mmaxloc2_4_s4;\n+    _gfortran_mmaxloc2_8_s1;\n+    _gfortran_mmaxloc2_8_s4;\n     _gfortran_mmaxval_i16;\n     _gfortran_mmaxval_i1;\n     _gfortran_mmaxval_i2;\n@@ -563,6 +617,8 @@ GFORTRAN_7 {\n     _gfortran_mminloc0_16_r16;\n     _gfortran_mminloc0_16_r4;\n     _gfortran_mminloc0_16_r8;\n+    _gfortran_mminloc0_16_s1;\n+    _gfortran_mminloc0_16_s4;\n     _gfortran_mminloc0_4_i16;\n     _gfortran_mminloc0_4_i1;\n     _gfortran_mminloc0_4_i2;\n@@ -572,6 +628,8 @@ GFORTRAN_7 {\n     _gfortran_mminloc0_4_r16;\n     _gfortran_mminloc0_4_r4;\n     _gfortran_mminloc0_4_r8;\n+    _gfortran_mminloc0_4_s1;\n+    _gfortran_mminloc0_4_s4;\n     _gfortran_mminloc0_8_i16;\n     _gfortran_mminloc0_8_i1;\n     _gfortran_mminloc0_8_i2;\n@@ -581,6 +639,8 @@ GFORTRAN_7 {\n     _gfortran_mminloc0_8_r16;\n     _gfortran_mminloc0_8_r4;\n     _gfortran_mminloc0_8_r8;\n+    _gfortran_mminloc0_8_s1;\n+    _gfortran_mminloc0_8_s4;\n     _gfortran_mminloc1_16_i16;\n     _gfortran_mminloc1_16_i1;\n     _gfortran_mminloc1_16_i2;\n@@ -590,6 +650,8 @@ GFORTRAN_7 {\n     _gfortran_mminloc1_16_r16;\n     _gfortran_mminloc1_16_r4;\n     _gfortran_mminloc1_16_r8;\n+    _gfortran_mminloc1_16_s1;\n+    _gfortran_mminloc1_16_s4;\n     _gfortran_mminloc1_4_i16;\n     _gfortran_mminloc1_4_i1;\n     _gfortran_mminloc1_4_i2;\n@@ -599,6 +661,8 @@ GFORTRAN_7 {\n     _gfortran_mminloc1_4_r16;\n     _gfortran_mminloc1_4_r4;\n     _gfortran_mminloc1_4_r8;\n+    _gfortran_mminloc1_4_s1;\n+    _gfortran_mminloc1_4_s4;\n     _gfortran_mminloc1_8_i16;\n     _gfortran_mminloc1_8_i1;\n     _gfortran_mminloc1_8_i2;\n@@ -608,6 +672,14 @@ GFORTRAN_7 {\n     _gfortran_mminloc1_8_r16;\n     _gfortran_mminloc1_8_r4;\n     _gfortran_mminloc1_8_r8;\n+    _gfortran_mminloc1_8_s1;\n+    _gfortran_mminloc1_8_s4;\n+    _gfortran_mminloc2_16_s1;\n+    _gfortran_mminloc2_16_s4;\n+    _gfortran_mminloc2_4_s1;\n+    _gfortran_mminloc2_4_s4;\n+    _gfortran_mminloc2_8_s1;\n+    _gfortran_mminloc2_8_s4;\n     _gfortran_mminval_i16;\n     _gfortran_mminval_i1;\n     _gfortran_mminval_i2;\n@@ -792,6 +864,8 @@ GFORTRAN_7 {\n     _gfortran_smaxloc0_16_r16;\n     _gfortran_smaxloc0_16_r4;\n     _gfortran_smaxloc0_16_r8;\n+    _gfortran_smaxloc0_16_s1;\n+    _gfortran_smaxloc0_16_s4;\n     _gfortran_smaxloc0_4_i16;\n     _gfortran_smaxloc0_4_i1;\n     _gfortran_smaxloc0_4_i2;\n@@ -801,6 +875,8 @@ GFORTRAN_7 {\n     _gfortran_smaxloc0_4_r16;\n     _gfortran_smaxloc0_4_r4;\n     _gfortran_smaxloc0_4_r8;\n+    _gfortran_smaxloc0_4_s1;\n+    _gfortran_smaxloc0_4_s4;\n     _gfortran_smaxloc0_8_i16;\n     _gfortran_smaxloc0_8_i1;\n     _gfortran_smaxloc0_8_i2;\n@@ -810,6 +886,8 @@ GFORTRAN_7 {\n     _gfortran_smaxloc0_8_r16;\n     _gfortran_smaxloc0_8_r4;\n     _gfortran_smaxloc0_8_r8;\n+    _gfortran_smaxloc0_8_s1;\n+    _gfortran_smaxloc0_8_s4;\n     _gfortran_smaxloc1_16_i16;\n     _gfortran_smaxloc1_16_i1;\n     _gfortran_smaxloc1_16_i2;\n@@ -819,6 +897,8 @@ GFORTRAN_7 {\n     _gfortran_smaxloc1_16_r16;\n     _gfortran_smaxloc1_16_r4;\n     _gfortran_smaxloc1_16_r8;\n+    _gfortran_smaxloc1_16_s1;\n+    _gfortran_smaxloc1_16_s4;\n     _gfortran_smaxloc1_4_i16;\n     _gfortran_smaxloc1_4_i1;\n     _gfortran_smaxloc1_4_i2;\n@@ -828,6 +908,8 @@ GFORTRAN_7 {\n     _gfortran_smaxloc1_4_r16;\n     _gfortran_smaxloc1_4_r4;\n     _gfortran_smaxloc1_4_r8;\n+    _gfortran_smaxloc1_4_s1;\n+    _gfortran_smaxloc1_4_s4;\n     _gfortran_smaxloc1_8_i16;\n     _gfortran_smaxloc1_8_i1;\n     _gfortran_smaxloc1_8_i2;\n@@ -837,6 +919,14 @@ GFORTRAN_7 {\n     _gfortran_smaxloc1_8_r16;\n     _gfortran_smaxloc1_8_r4;\n     _gfortran_smaxloc1_8_r8;\n+    _gfortran_smaxloc1_8_s1;\n+    _gfortran_smaxloc1_8_s4;\n+    _gfortran_smaxloc2_16_s1;\n+    _gfortran_smaxloc2_16_s4;\n+    _gfortran_smaxloc2_4_s1;\n+    _gfortran_smaxloc2_4_s4;\n+    _gfortran_smaxloc2_8_s1;\n+    _gfortran_smaxloc2_8_s4;\n     _gfortran_smaxval_i16;\n     _gfortran_smaxval_i1;\n     _gfortran_smaxval_i2;\n@@ -855,6 +945,8 @@ GFORTRAN_7 {\n     _gfortran_sminloc0_16_r16;\n     _gfortran_sminloc0_16_r4;\n     _gfortran_sminloc0_16_r8;\n+    _gfortran_sminloc0_16_s1;\n+    _gfortran_sminloc0_16_s4;\n     _gfortran_sminloc0_4_i16;\n     _gfortran_sminloc0_4_i1;\n     _gfortran_sminloc0_4_i2;\n@@ -864,6 +956,8 @@ GFORTRAN_7 {\n     _gfortran_sminloc0_4_r16;\n     _gfortran_sminloc0_4_r4;\n     _gfortran_sminloc0_4_r8;\n+    _gfortran_sminloc0_4_s1;\n+    _gfortran_sminloc0_4_s4;\n     _gfortran_sminloc0_8_i16;\n     _gfortran_sminloc0_8_i1;\n     _gfortran_sminloc0_8_i2;\n@@ -873,6 +967,8 @@ GFORTRAN_7 {\n     _gfortran_sminloc0_8_r16;\n     _gfortran_sminloc0_8_r4;\n     _gfortran_sminloc0_8_r8;\n+    _gfortran_sminloc0_8_s1;\n+    _gfortran_sminloc0_8_s4;\n     _gfortran_sminloc1_16_i16;\n     _gfortran_sminloc1_16_i1;\n     _gfortran_sminloc1_16_i2;\n@@ -882,6 +978,8 @@ GFORTRAN_7 {\n     _gfortran_sminloc1_16_r16;\n     _gfortran_sminloc1_16_r4;\n     _gfortran_sminloc1_16_r8;\n+    _gfortran_sminloc1_16_s1;\n+    _gfortran_sminloc1_16_s4;\n     _gfortran_sminloc1_4_i16;\n     _gfortran_sminloc1_4_i1;\n     _gfortran_sminloc1_4_i2;\n@@ -891,6 +989,8 @@ GFORTRAN_7 {\n     _gfortran_sminloc1_4_r16;\n     _gfortran_sminloc1_4_r4;\n     _gfortran_sminloc1_4_r8;\n+    _gfortran_sminloc1_4_s1;\n+    _gfortran_sminloc1_4_s4;\n     _gfortran_sminloc1_8_i16;\n     _gfortran_sminloc1_8_i1;\n     _gfortran_sminloc1_8_i2;\n@@ -900,6 +1000,14 @@ GFORTRAN_7 {\n     _gfortran_sminloc1_8_r16;\n     _gfortran_sminloc1_8_r4;\n     _gfortran_sminloc1_8_r8;\n+    _gfortran_sminloc1_8_s1;\n+    _gfortran_sminloc1_8_s4;\n+    _gfortran_sminloc2_16_s1;\n+    _gfortran_sminloc2_16_s4;\n+    _gfortran_sminloc2_4_s1;\n+    _gfortran_sminloc2_4_s4;\n+    _gfortran_sminloc2_8_s1;\n+    _gfortran_sminloc2_8_s4;\n     _gfortran_sminval_i16;\n     _gfortran_sminval_i1;\n     _gfortran_sminval_i2;\n@@ -1196,7 +1304,7 @@ GFORTRAN_7 {\n     *;\n };\n \n-GFORTRAN_F2C_7 {\n+GFORTRAN_F2C_8 {\n   global:\n     _gfortran_f2c_specific__abs_c4;\n     _gfortran_f2c_specific__abs_r4;\n@@ -1238,7 +1346,7 @@ GFORTRAN_F2C_7 {\n     _gfortran_f2c_specific__tan_r4;\n };\n \n-GFORTRAN_C99_7 {\n+GFORTRAN_C99_8 {\n   global:\n     acosf;\n     acoshf;"}, {"sha": "52f4764a30711d89c283d63ec34a32713cd2cf03", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -376,7 +376,8 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_8) gfc_array_l8;\n #ifdef HAVE_GFC_LOGICAL_16\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_16) gfc_array_l16;\n #endif\n-\n+typedef gfc_array_i1 gfc_array_s1;\n+typedef gfc_array_i4 gfc_array_s4;\n \n #define GFC_DESCRIPTOR_RANK(desc) ((desc)->dtype & GFC_DTYPE_RANK_MASK)\n #define GFC_DESCRIPTOR_TYPE(desc) (((desc)->dtype & GFC_DTYPE_TYPE_MASK) \\"}, {"sha": "39868ddf3eef6a553c2466b14506dcce5715085b", "filename": "libgfortran/m4/iforeach-s.m4", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fiforeach-s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fiforeach-s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach-s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,288 @@\n+dnl Support macro file for intrinsic functions.\n+dnl Contains the generic sections of the array functions.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+define(START_FOREACH_FUNCTION,\n+`static inline int\n+compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n+{\n+  if (sizeof ('atype_name`) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+extern void name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array, gfc_charlen_type len);\n+export_proto(name`'rtype_qual`_'atype_code);\n+\n+void\n+name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const atype_name *base;\n+  rtype_name * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"u_name\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+')dnl\n+define(START_FOREACH_BLOCK,\n+`  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+')dnl\n+define(FINISH_FOREACH_FUNCTION,\n+`\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}')dnl\n+define(START_MASKED_FOREACH_FUNCTION,\n+`\n+extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, gfc_array_l1 * const restrict, gfc_charlen_type len);\n+export_proto(`m'name`'rtype_qual`_'atype_code);\n+\n+void\n+`m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  rtype_name *dest;\n+  const atype_name *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"u_name\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"u_name\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+')dnl\n+define(START_MASKED_FOREACH_BLOCK, `START_FOREACH_BLOCK')dnl\n+define(FINISH_MASKED_FOREACH_FUNCTION,\n+`\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}')dnl\n+define(FOREACH_FUNCTION,\n+`START_FOREACH_FUNCTION\n+$1\n+START_FOREACH_BLOCK\n+$2\n+FINISH_FOREACH_FUNCTION')dnl\n+define(MASKED_FOREACH_FUNCTION,\n+`START_MASKED_FOREACH_FUNCTION\n+$1\n+START_MASKED_FOREACH_BLOCK\n+$2\n+FINISH_MASKED_FOREACH_FUNCTION')dnl\n+define(SCALAR_FOREACH_FUNCTION,\n+`\n+extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, GFC_LOGICAL_4 *, gfc_charlen_type len);\n+export_proto(`s'name`'rtype_qual`_'atype_code);\n+\n+void\n+`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array,\n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type len)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  rtype_name *dest;\n+\n+  if (*mask)\n+    {\n+      name`'rtype_qual`_'atype_code (retarray, array, len);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"u_name\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = $1 ;\n+}')dnl"}, {"sha": "93ca694c8263773fdc478ee31840ea84ddb5bbf5", "filename": "libgfortran/m4/ifunction-s.m4", "status": "added", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fifunction-s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fifunction-s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction-s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,530 @@\n+dnl Support macro file for intrinsic functions.\n+dnl Contains the generic sections of the array functions.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+dnl\n+dnl Pass the implementation for a single section as the parameter to\n+dnl {MASK_}ARRAY_FUNCTION.\n+dnl The variables base, delta, and len describe the input section.\n+dnl For masked section the mask is described by mbase and mdelta.\n+dnl These should not be modified. The result should be stored in *dest.\n+dnl The names count, extent, sstride, dstride, base, dest, rank, dim\n+dnl retarray, array, pdim and mstride should not be used.\n+dnl The variable n is declared as index_type and may be used.\n+dnl Other variable declarations may be placed at the start of the code,\n+dnl The types of the array parameter and the return value are\n+dnl atype_name and rtype_name respectively.\n+dnl Execution should be allowed to continue to the end of the block.\n+dnl You should not return or break from the inner loop of the implementation.\n+dnl Care should also be taken to avoid using the names defined in iparm.m4\n+define(START_ARRAY_FUNCTION,\n+`#include <string.h>\n+\n+static inline int\n+compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n+{\n+  if (sizeof ('atype_name`) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, const index_type * const restrict,\n+\tgfc_charlen_type);\n+export_proto(name`'rtype_qual`_'atype_code);\n+\n+void\n+name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const atype_name * restrict base;\n+  rtype_name * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in u_name intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" u_name intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"u_name\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const atype_name * restrict src;\n+      rtype_name result;\n+      src = base;\n+      {\n+')dnl\n+define(START_ARRAY_BLOCK,\n+`\tif (len <= 0)\n+\t  *dest = '$1`;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+')dnl\n+define(FINISH_ARRAY_FUNCTION,\n+`\t      }\n+\t    '$1`\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}')dnl\n+define(START_MASKED_ARRAY_FUNCTION,\n+`\n+extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(`m'name`'rtype_qual`_'atype_code);\n+\n+void\n+`m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  rtype_name * restrict dest;\n+  const atype_name * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in u_name intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in u_name intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"u_name\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"u_name\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const atype_name * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      rtype_name result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+')dnl\n+define(START_MASKED_ARRAY_BLOCK,\n+`\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+')dnl\n+define(FINISH_MASKED_ARRAY_FUNCTION,\n+`\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}')dnl\n+define(SCALAR_ARRAY_FUNCTION,\n+`\n+extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(`s'name`'rtype_qual`_'atype_code);\n+\n+void\n+`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  rtype_name * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      name`'rtype_qual`_'atype_code (retarray, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in u_name intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1) * string_len;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" u_name intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" u_name intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = '$1`;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}')dnl\n+define(ARRAY_FUNCTION,\n+`START_ARRAY_FUNCTION\n+$2\n+START_ARRAY_BLOCK($1)\n+$3\n+FINISH_ARRAY_FUNCTION($4)')dnl\n+define(MASKED_ARRAY_FUNCTION,\n+`START_MASKED_ARRAY_FUNCTION\n+$2\n+START_MASKED_ARRAY_BLOCK\n+$3\n+FINISH_MASKED_ARRAY_FUNCTION')dnl"}, {"sha": "7777a0c8c078e525e8ba6fdeefc7351c079f9a4c", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -42,8 +42,8 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   int continue_loop;\n \n   /* Make dim zero based to avoid confusion.  */\n-  dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n \n   if (unlikely (dim < 0 || dim > rank))\n     {"}, {"sha": "4bf2a3010cf627ff7cb77c79d584776a4deb997a", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -4,7 +4,7 @@ dnl This file is part of the GNU Fortran 95 Runtime Library (libgfortran)\n dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n dnl M4 macro file to get type names from filenames\n define(get_typename2, `GFC_$1_$2')dnl\n-define(get_typename, `get_typename2(ifelse($1,i,INTEGER,ifelse($1,r,REAL,ifelse($1,l,LOGICAL,ifelse($1,c,COMPLEX,unknown)))),`$2')')dnl\n+define(get_typename, `get_typename2(ifelse($1,i,INTEGER,ifelse($1,r,REAL,ifelse($1,l,LOGICAL,ifelse($1,c,COMPLEX,ifelse($1,s,INTEGER,unknown))))),`$2')')dnl\n define(get_arraytype, `gfc_array_$1$2')dnl\n define(define_type, `dnl\n ifelse(regexp($2,`^[0-9]'),-1,`dnl"}, {"sha": "96935dc72c09903beedf964a1b7b3caf716d672f", "filename": "libgfortran/m4/maxloc0s.m4", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fmaxloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fmaxloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,61 @@\n+`/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>'\n+\n+include(iparm.m4)dnl\n+include(iforeach-s.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+FOREACH_FUNCTION(\n+`  const atype_name *maxval;\n+   maxval = base;'\n+,\n+`  if (compare_fcn (base, maxval, len) > 0)\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }')\n+\n+MASKED_FOREACH_FUNCTION(\n+`  const atype_name *maxval;\n+\n+  maxval = NULL;'\n+,\n+`  if (*mbase && (maxval == NULL || compare_fcn (base, maxval, len) > 0))\n+    {\n+      maxval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }')\n+\n+SCALAR_FOREACH_FUNCTION(`0')\n+#endif"}, {"sha": "dbb69b47589ef1bf0296dc700427dc4a390d1cea", "filename": "libgfortran/m4/maxloc1s.m4", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fmaxloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fmaxloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,65 @@\n+`/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"'\n+\n+include(iparm.m4)dnl\n+include(ifunction-s.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(0,\n+`\tconst atype_name *maxval;\n+\tmaxval = base;\n+\tresult = 1;',\n+`\t\tif (compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (rtype_name)n + 1;\n+\t\t  }', `')\n+\n+MASKED_ARRAY_FUNCTION(0,\n+`\tconst atype_name *maxval;\n+\tmaxval = base;\n+\tresult = 0;',\n+`\t\tif (*msrc)\n+\t\t      {\n+\t\t\tmaxval = src;\n+\t\t\tresult = (rtype_name)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, maxval, string_len) > 0)\n+\t\t  {\n+\t\t    maxval = src;\n+\t\t    result = (rtype_name)n + 1;\n+\t\t  }\n+\t      ')\n+\n+SCALAR_ARRAY_FUNCTION(0)\n+\n+#endif"}, {"sha": "9b2ed740acafc7bbebb29ac925c60d9cd6e3e40b", "filename": "libgfortran/m4/maxloc2s.m4", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fmaxloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fmaxloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc2s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,157 @@\n+`/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>'\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)\n+\n+static inline int\n+compare_fcn (const 'atype_name` *a, const 'atype_name` *b, int n)\n+{\n+  if (sizeof ('atype_name`) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern 'rtype_name` 'name`'rtype_qual`_'atype_code` ('atype` * const restrict, int);\n+export_proto('name`'rtype_qual`_'atype_code`);\n+\n+'rtype_name`\n+'name`'rtype_qual`_'atype_code` ('atype` * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const 'atype_name` *src;\n+  const 'atype_name` *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern 'rtype_name` m'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, gfc_charlen_type);\n+export_proto(m'name`'rtype_qual`_'atype_code`);\n+\n+'rtype_name`\n+m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask,\n+\t\t\t\t gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const 'atype_name` *src;\n+  const 'atype_name` *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) > 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern 'rtype_name` s'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, int);\n+export_proto(s'name`'rtype_qual`_'atype_code`);\n+\n+'rtype_name`\n+s'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return 'name`'rtype_qual`_'atype_code` (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif'"}, {"sha": "b907be3d99325880cb6b9018020fa633c1f45a6a", "filename": "libgfortran/m4/minloc0s.m4", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fminloc0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fminloc0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,61 @@\n+`/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>'\n+\n+include(iparm.m4)dnl\n+include(iforeach-s.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+FOREACH_FUNCTION(\n+`  const atype_name *minval;\n+   minval = base;'\n+,\n+`  if (compare_fcn (base, minval, len) < 0)\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }')\n+\n+MASKED_FOREACH_FUNCTION(\n+`  const atype_name *minval;\n+\n+  minval = NULL;'\n+,\n+`  if (*mbase && (minval == NULL || compare_fcn (base, minval, len) < 0))\n+    {\n+      minval = base;\n+      for (n = 0; n < rank; n++)\n+        dest[n * dstride] = count[n] + 1;\n+    }')\n+\n+SCALAR_FOREACH_FUNCTION(`0')\n+#endif"}, {"sha": "d64935a36add9a9db227e0b02a043c53f8755b9f", "filename": "libgfortran/m4/minloc1s.m4", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fminloc1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fminloc1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,65 @@\n+`/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"'\n+\n+include(iparm.m4)dnl\n+include(ifunction-s.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(0,\n+`\tconst atype_name *minval;\n+\tminval = base;\n+\tresult = 1;',\n+`\t\tif (compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (rtype_name)n + 1;\n+\t\t  }', `')\n+\n+MASKED_ARRAY_FUNCTION(0,\n+`\tconst atype_name *minval;\n+\tminval = base;\n+\tresult = 0;',\n+`\t\tif (*msrc)\n+\t\t      {\n+\t\t\tminval = src;\n+\t\t\tresult = (rtype_name)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+            }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, minval, string_len) < 0)\n+\t\t  {\n+\t\t    minval = src;\n+\t\t    result = (rtype_name)n + 1;\n+\t\t  }\n+\t      ')\n+\n+SCALAR_ARRAY_FUNCTION(0)\n+\n+#endif"}, {"sha": "38073ce75d51e20b9d2217eff88f66d724e4f6ed", "filename": "libgfortran/m4/minloc2s.m4", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fminloc2s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea/libgfortran%2Fm4%2Fminloc2s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc2s.m4?ref=ddc9995b13d71d00b97cb2c4c7d5e9ef1dcbe5ea", "patch": "@@ -0,0 +1,156 @@\n+`/* Implementation of the MINLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>'\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)\n+\n+static inline int\n+compare_fcn (const 'atype_name` *a, const 'atype_name` *b, int n)\n+{\n+  if (sizeof ('atype_name`) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern 'rtype_name` 'name`'rtype_qual`_'atype_code` ('atype` * const restrict, int);\n+export_proto('name`'rtype_qual`_'atype_code`);\n+\n+'rtype_name`\n+'name`'rtype_qual`_'atype_code` ('atype` * const restrict array, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const 'atype_name` *src;\n+  const 'atype_name` *maxval;\n+  index_type i;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  ret = 1;\n+  src = array->base_addr;\n+  maxval = src;\n+  for (i=2; i<=extent; i++)\n+    {\n+      src += sstride;\n+      if (compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+    }\n+  return ret;\n+}\n+\n+extern 'rtype_name` m'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n+       \t\t    \tgfc_array_l1 *const restrict mask, int);\n+export_proto(m'name`'rtype_qual`_'atype_code`);\n+\n+'rtype_name`\n+m'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n+\t\t\t\t gfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type ret;\n+  index_type sstride;\n+  index_type extent;\n+  const 'atype_name` *src;\n+  const 'atype_name` *maxval;\n+  index_type i, j;\n+  GFC_LOGICAL_1 *mbase;\n+  int mask_kind;\n+  index_type mstride;\n+\n+  extent = GFC_DESCRIPTOR_EXTENT(array,0);\n+  if (extent <= 0)\n+    return 0;\n+\n+  sstride = GFC_DESCRIPTOR_STRIDE(array,0) * len;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  mstride = GFC_DESCRIPTOR_STRIDE_BYTES(mask,0);\n+\n+  /* Search for the first occurrence of a true element in mask. */\n+  for (j=0; j<extent; j++)\n+    {\n+      if (*mbase)\n+        break;\n+      mbase += mstride;\n+    }\n+\n+  if (j == extent)\n+    return 0;\n+\n+  ret = j + 1;\n+  src = array->base_addr + j * sstride;\n+  maxval = src;\n+\n+  for (i=j+1; i<=extent; i++)\n+    {\n+      if (*mbase && compare_fcn (src, maxval, len) < 0)\n+      {\n+\t ret = i;\n+\t maxval = src;\n+      }\n+      src += sstride;\n+      mbase += mstride;\n+    }\n+  return ret;\n+}\n+\n+extern 'rtype_name` s'name`'rtype_qual`_'atype_code` ('atype` * const restrict,\n+       \t\t    \tGFC_LOGICAL_4 *mask, gfc_charlen_type);\n+export_proto(s'name`'rtype_qual`_'atype_code`);\n+\n+'rtype_name`\n+s'name`'rtype_qual`_'atype_code` ('atype` * const restrict array,\n+\t\t\t\t GFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+{\n+  if (mask)\n+    return 'name`'rtype_qual`_'atype_code` (array, len);\n+  else\n+    return 0;\n+}\n+\n+#endif'"}]}