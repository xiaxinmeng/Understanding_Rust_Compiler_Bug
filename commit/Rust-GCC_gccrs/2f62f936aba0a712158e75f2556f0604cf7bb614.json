{"sha": "2f62f936aba0a712158e75f2556f0604cf7bb614", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY2MmY5MzZhYmEwYTcxMjE1OGU3NWYyNTU2ZjA2MDRjZjdiYjYxNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T17:06:32Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T21:39:45Z"}, "message": "Add check for duplicate overlapping impl-items\n\nWhen we have impl blocks for a generic type rust allows the programmer\nto reuse impl item names but if you give a generic implementation it means\nthis generic implementation will overlap meaning it will not be possible\nto determine the Path. See rustc error: rustc --explain E0592\nrustc_typeck/src/coherence/inherent_impls_overlap.rs\n\nFixes #353", "tree": {"sha": "1db74c53d3aaac6f7930ae6d7844808c103c548b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1db74c53d3aaac6f7930ae6d7844808c103c548b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f62f936aba0a712158e75f2556f0604cf7bb614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f62f936aba0a712158e75f2556f0604cf7bb614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f62f936aba0a712158e75f2556f0604cf7bb614", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f62f936aba0a712158e75f2556f0604cf7bb614/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e4ca97cac069886c2e54674f973f723e68ee912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4ca97cac069886c2e54674f973f723e68ee912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4ca97cac069886c2e54674f973f723e68ee912"}], "stats": {"total": 252, "additions": 252, "deletions": 0}, "files": [{"sha": "b0071c3ee6f09f78376e4273b1dc92f8e4276a5c", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f62f936aba0a712158e75f2556f0604cf7bb614/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f62f936aba0a712158e75f2556f0604cf7bb614/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=2f62f936aba0a712158e75f2556f0604cf7bb614", "patch": "@@ -0,0 +1,220 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H\n+#define RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class InherentImplItemToName : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static bool resolve (HIR::InherentImplItem *item, std::string &name_result)\n+  {\n+    InherentImplItemToName resolver (name_result);\n+    item->accept_vis (resolver);\n+    return resolver.ok;\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    ok = true;\n+    result.assign (method.get_method_name ());\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ok = true;\n+    result.assign (function.get_function_name ());\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    ok = true;\n+    result.assign (constant.get_identifier ());\n+  }\n+\n+private:\n+  InherentImplItemToName (std::string &result)\n+    : TypeCheckBase (), ok (false), result (result)\n+  {}\n+\n+  bool ok;\n+  std::string &result;\n+};\n+\n+class GetLocusFromImplItem : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static bool Resolve (HIR::InherentImplItem *query, Location &locus)\n+  {\n+    GetLocusFromImplItem resolver (locus);\n+    query->accept_vis (resolver);\n+    return resolver.ok;\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    ok = true;\n+    locus = constant.get_locus ();\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ok = true;\n+    locus = function.get_locus ();\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    ok = true;\n+    locus = method.get_locus ();\n+  }\n+\n+private:\n+  GetLocusFromImplItem (Location &locus)\n+    : TypeCheckBase (), ok (false), locus (locus)\n+  {}\n+\n+  bool ok;\n+  Location &locus;\n+};\n+\n+class OverlappingImplItemPass : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void go ()\n+  {\n+    OverlappingImplItemPass pass;\n+\n+    // generate mappings\n+    pass.mappings->iterate_impl_items ([&] (HirId id,\n+\t\t\t\t\t    HIR::InherentImplItem *impl_item,\n+\t\t\t\t\t    HIR::InherentImpl *impl) -> bool {\n+      pass.process_impl_item (id, impl_item, impl);\n+      return true;\n+    });\n+\n+    pass.scan ();\n+  }\n+\n+  void process_impl_item (HirId id, HIR::InherentImplItem *impl_item,\n+\t\t\t  HIR::InherentImpl *impl)\n+  {\n+    // lets make a mapping of impl-item Self type to (impl-item,name):\n+    // {\n+    //   impl-type -> [ (item, name), ... ]\n+    // }\n+\n+    HirId impl_type_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_type = nullptr;\n+    bool ok = context->lookup_type (impl_type_id, &impl_type);\n+    rust_assert (ok);\n+\n+    std::string impl_item_name;\n+    ok = InherentImplItemToName::resolve (impl_item, impl_item_name);\n+    rust_assert (ok);\n+\n+    std::pair<HIR::InherentImplItem *, std::string> elem (impl_item,\n+\t\t\t\t\t\t\t  impl_item_name);\n+    impl_mappings[impl_type].insert (std::move (elem));\n+  }\n+\n+  void scan ()\n+  {\n+    // we can now brute force the map looking for can_eq on each of the\n+    // impl_items_types to look for possible colliding impl blocks;\n+    for (auto it = impl_mappings.begin (); it != impl_mappings.end (); it++)\n+      {\n+\tTyTy::BaseType *query = it->first;\n+\n+\tfor (auto iy = impl_mappings.begin (); iy != impl_mappings.end (); iy++)\n+\t  {\n+\t    TyTy::BaseType *candidate = iy->first;\n+\t    if (query == candidate)\n+\t      continue;\n+\n+\t    if (query->can_eq (candidate))\n+\t      possible_collision (it->second, iy->second);\n+\t  }\n+      }\n+  }\n+\n+  void possible_collision (\n+    std::set<std::pair<HIR::InherentImplItem *, std::string> > query,\n+    std::set<std::pair<HIR::InherentImplItem *, std::string> > candidate)\n+  {\n+    for (auto &q : query)\n+      {\n+\tHIR::InherentImplItem *query_impl_item = q.first;\n+\tstd::string query_impl_item_name = q.second;\n+\n+\tfor (auto &c : candidate)\n+\t  {\n+\t    HIR::InherentImplItem *candidate_impl_item = c.first;\n+\t    std::string candidate_impl_item_name = c.second;\n+\n+\t    if (query_impl_item_name.compare (candidate_impl_item_name) == 0)\n+\t      collision_detected (query_impl_item, candidate_impl_item,\n+\t\t\t\t  candidate_impl_item_name);\n+\t  }\n+      }\n+  }\n+\n+  void collision_detected (HIR::InherentImplItem *query,\n+\t\t\t   HIR::InherentImplItem *dup, const std::string &name)\n+  {\n+    Location qlocus;\n+    bool ok = GetLocusFromImplItem::Resolve (query, qlocus);\n+    rust_assert (ok);\n+\n+    Location dlocus;\n+    ok = GetLocusFromImplItem::Resolve (dup, dlocus);\n+    rust_assert (ok);\n+\n+    // this needs GCC Rich locations see\n+    // https://github.com/Rust-GCC/gccrs/issues/97\n+    rust_error_at (qlocus, \"duplicate definitions with name %s\", name.c_str ());\n+    rust_error_at (dlocus, \"duplicate def associated with\");\n+  }\n+\n+private:\n+  OverlappingImplItemPass () : TypeCheckBase () {}\n+\n+  std::map<TyTy::BaseType *,\n+\t   std::set<std::pair<HIR::InherentImplItem *, std::string> > >\n+    impl_mappings;\n+\n+  std::map<TyTy::BaseType *, std::set<TyTy::BaseType *> >\n+    possible_colliding_impls;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H"}, {"sha": "c8394c8dcbe5f0139a1c86abe99627e468ef2a6f", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f62f936aba0a712158e75f2556f0604cf7bb614/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f62f936aba0a712158e75f2556f0604cf7bb614/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=2f62f936aba0a712158e75f2556f0604cf7bb614", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-inherent-impl-overlap.h\"\n \n extern bool\n saw_errors (void);\n@@ -38,6 +39,10 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   if (saw_errors ())\n     return;\n \n+  OverlappingImplItemPass::go ();\n+  if (saw_errors ())\n+    return;\n+\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     TypeCheckItem::Resolve (it->get ());\n "}, {"sha": "d8a9e93e13f22aa7ab03259ca9d64114a8976c4b", "filename": "gcc/testsuite/rust.test/xfail_compile/generics7.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f62f936aba0a712158e75f2556f0604cf7bb614/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f62f936aba0a712158e75f2556f0604cf7bb614/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics7.rs?ref=2f62f936aba0a712158e75f2556f0604cf7bb614", "patch": "@@ -0,0 +1,27 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+impl Foo<isize> {\n+    fn bar(self) -> isize { // { dg-error \"duplicate definitions with name bar\" }\n+        self.a\n+    }\n+}\n+\n+impl Foo<char> {\n+    fn bar(self) -> char { // { dg-error \"duplicate definitions with name bar\" }\n+        self.a\n+    }\n+}\n+\n+impl<T> Foo<T> {\n+    fn bar(self) -> T {\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo { a: 123 };\n+    a.bar();\n+}"}]}