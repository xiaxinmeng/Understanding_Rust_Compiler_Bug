{"sha": "6fa05db65c8202c23d3370feb72fc41472498e82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhMDVkYjY1YzgyMDJjMjNkMzM3MGZlYjcyZmM0MTQ3MjQ5OGU4Mg==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-10-19T16:37:10Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-10-19T16:37:10Z"}, "message": "s390.c (s390_expand_insv): New.\n\n2005-10-19  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_insv): New.\n\t* config/s390/s390-protos.h (s390_expand_insv): Declare.\n\t* config/s390/s390.md (\"UNSPEC_SETHIGH\"): Rename to \"UNSPEC_ICM\".\n\t(\"icm_hi\"): Remove mode attribute.\n\t(\"*sethigh<mode><mode>\"): Rewrite to \"sethighpart<mode>\".\n\tAdjust all uses.\n\t(\"*extracthi\", \"*extractqi\"): Remove.\n\t(extv<mode>\", \"*extzv<mode>\"): New.\n\t(\"insv\", \"*insv<mode>_mem_reg\", \"*insvdi_mem_reghigh\",\n\t\"*insv<mode>_reg_imm\", \"*insv<mode>_reg_extimm\"): New.\n\nFrom-SVN: r105625", "tree": {"sha": "077e1a0a0ddd7137851ee644b623a485c87fa8a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/077e1a0a0ddd7137851ee644b623a485c87fa8a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa05db65c8202c23d3370feb72fc41472498e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa05db65c8202c23d3370feb72fc41472498e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa05db65c8202c23d3370feb72fc41472498e82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa05db65c8202c23d3370feb72fc41472498e82/comments", "author": null, "committer": null, "parents": [{"sha": "a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696"}], "stats": {"total": 304, "additions": 261, "deletions": 43}, "files": [{"sha": "feb6a71ab21f7140cf00e4f1a066662dc6a1e4b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fa05db65c8202c23d3370feb72fc41472498e82", "patch": "@@ -1,3 +1,16 @@\n+2005-10-19  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_insv): New.\n+\t* config/s390/s390-protos.h (s390_expand_insv): Declare.\n+\t* config/s390/s390.md (\"UNSPEC_SETHIGH\"): Rename to \"UNSPEC_ICM\".\n+\t(\"icm_hi\"): Remove mode attribute.\n+\t(\"*sethigh<mode><mode>\"): Rewrite to \"sethighpart<mode>\".\n+\tAdjust all uses.\n+\t(\"*extracthi\", \"*extractqi\"): Remove.\n+\t(extv<mode>\", \"*extzv<mode>\"): New.\n+\t(\"insv\", \"*insv<mode>_mem_reg\", \"*insvdi_mem_reghigh\",\n+\t\"*insv<mode>_reg_imm\", \"*insv<mode>_reg_extimm\"): New.\n+\n 2005-10-19  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* cfgexpand.c (discover_nonconstant_array_refs_r,"}, {"sha": "3ae43ea209eab01e2b23e13bc3279c25438312f6", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=6fa05db65c8202c23d3370feb72fc41472498e82", "patch": "@@ -74,6 +74,7 @@ extern void s390_expand_movmem (rtx, rtx, rtx);\n extern void s390_expand_setmem (rtx, rtx, rtx);\n extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n+extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);\n extern rtx s390_emit_call (rtx, rtx, rtx, rtx);"}, {"sha": "009c17828d89d71bcd0ecefc680392380028163d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6fa05db65c8202c23d3370feb72fc41472498e82", "patch": "@@ -3815,6 +3815,101 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n   return false;\n }\n \n+/* Expand code for the insv template. Return true if successful, false else.  */\n+\n+bool \n+s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n+{\n+  int bitsize = INTVAL (op1);\n+  int bitpos = INTVAL (op2);\n+\n+  /* We need byte alignement.  */\n+  if (bitsize % BITS_PER_UNIT)\n+    return false;\n+\n+  if (bitpos == 0\n+      && memory_operand (dest, VOIDmode)\n+      && (register_operand (src, word_mode)\n+\t  || const_int_operand (src, VOIDmode)))\n+    {\n+      /* Emit standard pattern if possible.  */\n+      enum machine_mode mode = smallest_mode_for_size (bitsize, MODE_INT);\n+      if (GET_MODE_BITSIZE (mode) == bitsize)\n+\temit_move_insn (adjust_address (dest, mode, 0), gen_lowpart (mode, src));\n+\n+      /* (set (ze (mem)) (const_int)).  */\n+      else if (const_int_operand (src, VOIDmode))\n+\t{\n+\t  int size = bitsize / BITS_PER_UNIT;\n+\t  rtx src_mem = adjust_address (force_const_mem (word_mode, src), BLKmode,\n+\t\t\t\t\tGET_MODE_SIZE (word_mode) - size);\n+\n+\t  dest = adjust_address (dest, BLKmode, 0);\n+\t  set_mem_size (dest, GEN_INT (size));\n+\t  s390_expand_movmem (dest, src_mem, GEN_INT (size));\n+\t}\n+\t  \n+      /* (set (ze (mem)) (reg)).  */\n+      else if (register_operand (src, word_mode))\n+\t{\n+\t  if (bitsize <= GET_MODE_BITSIZE (SImode))\n+\t    emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, op1,\n+\t\t\t\t\t\t  const0_rtx), src);\n+\t  else\n+\t    {\n+\t      /* Emit st,stcmh sequence.  */\n+\t      int stcmh_width = bitsize - GET_MODE_BITSIZE (SImode);\n+\t      int size = stcmh_width / BITS_PER_UNIT;\n+\n+\t      emit_move_insn (adjust_address (dest, SImode, size), \n+\t\t\t      gen_lowpart (SImode, src));\n+\t      set_mem_size (dest, GEN_INT (size));\n+\t      emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, GEN_INT\n+\t\t\t\t\t\t    (stcmh_width), const0_rtx),\n+\t\t\t      gen_rtx_LSHIFTRT (word_mode, src, GEN_INT\n+\t\t\t\t\t\t(GET_MODE_BITSIZE (SImode))));\n+\t    }\n+\t}\n+      else\n+\treturn false;\n+\n+      return true;\n+    }\n+\n+  /* (set (ze (reg)) (const_int)).  */\n+  if (TARGET_ZARCH\n+      && register_operand (dest, word_mode) \n+      && (bitpos % 16) == 0\n+      && (bitsize % 16) == 0\n+      && const_int_operand (src, VOIDmode))\n+    {\n+      HOST_WIDE_INT val = INTVAL (src);\n+      int regpos = bitpos + bitsize;\n+\n+      while (regpos > bitpos)\n+\t{\n+\t  enum machine_mode putmode;\n+\t  int putsize;\n+\n+\t  if (TARGET_EXTIMM && (regpos % 32 == 0) && (regpos >= bitpos + 32))\n+\t    putmode = SImode;\n+\t  else\n+\t    putmode = HImode;\n+\n+\t  putsize = GET_MODE_BITSIZE (putmode);\n+\t  regpos -= putsize;\n+\t  emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, \n+\t\t\t\t\t\tGEN_INT (putsize),\n+\t\t\t\t\t\tGEN_INT (regpos)), \n+\t\t\t  gen_int_mode (val, putmode));\n+\t  val >>= putsize;\n+\t}\n+      gcc_assert (regpos == bitpos);\n+      return true;\n+    }\n+\n+  return false;\n+}\n \n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */"}, {"sha": "bc9e4c362629eb68e689ff40c7b35630a346effe", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 152, "deletions": 43, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa05db65c8202c23d3370feb72fc41472498e82/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=6fa05db65c8202c23d3370feb72fc41472498e82", "patch": "@@ -102,7 +102,7 @@\n   [; Miscellaneous\n    (UNSPEC_ROUND\t\t1)\n    (UNSPEC_CMPINT\t\t2)\n-   (UNSPEC_SETHIGH\t\t10)\n+   (UNSPEC_ICM\t\t\t10)\n \n    ; GOT/PLT and lt-relative accesses\n    (UNSPEC_LTREL_OFFSET\t\t100)\n@@ -352,10 +352,6 @@\n ;; and \"cfdbr\" in SImode.\n (define_mode_attr gf [(DI \"g\") (SI \"f\")])\n \n-;; ICM mask required to load MODE value into the highest subreg\n-;; of a SImode register.\n-(define_mode_attr icm_hi [(HI \"12\") (QI \"8\")])\n-\n ;; ICM mask required to load MODE value into the lowest subreg\n ;; of a SImode register.\n (define_mode_attr icm_lo [(HI \"3\") (QI \"1\")])\n@@ -2464,73 +2460,180 @@\n ;;- Conversion instructions.\n ;;\n \n-\n-(define_insn \"*sethigh<mode>si\"\n+(define_insn \"*sethighpartsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (unspec:SI [(match_operand:HQI 1 \"s_operand\" \"Q,S\")] UNSPEC_SETHIGH))\n+\t(unspec:SI [(match_operand:BLK 1 \"s_operand\" \"Q,S\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n,n\")] UNSPEC_ICM))\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n-   icm\\t%0,<icm_hi>,%S1\n-   icmy\\t%0,<icm_hi>,%S1\"\n+   icm\\t%0,%2,%S1\n+   icmy\\t%0,%2,%S1\"\n   [(set_attr \"op_type\" \"RS,RSY\")])\n \n-(define_insn \"*sethighqidi_64\"\n+(define_insn \"*sethighpartdi_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (unspec:DI [(match_operand:QI 1 \"s_operand\" \"QS\")] UNSPEC_SETHIGH))\n+\t(unspec:DI [(match_operand:BLK 1 \"s_operand\" \"QS\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n\")] UNSPEC_ICM))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_64BIT\"\n-  \"icmh\\t%0,8,%S1\"\n+  \"icmh\\t%0,%2,%S1\"\n   [(set_attr \"op_type\" \"RSY\")])\n \n-(define_insn \"*sethighqidi_31\"\n+(define_insn \"*sethighpartdi_31\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (unspec:DI [(match_operand:QI 1 \"s_operand\" \"Q,S\")] UNSPEC_SETHIGH))\n+\t(unspec:DI [(match_operand:BLK 1 \"s_operand\" \"Q,S\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n,n\")] UNSPEC_ICM))\n    (clobber (reg:CC CC_REGNUM))]\n   \"!TARGET_64BIT\"\n   \"@\n-   icm\\t%0,8,%S1\n-   icmy\\t%0,8,%S1\"\n+   icm\\t%0,%2,%S1\n+   icmy\\t%0,%2,%S1\"\n   [(set_attr \"op_type\" \"RS,RSY\")])\n \n-(define_insn_and_split \"*extractqi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (zero_extract:SI (match_operand:QI 1 \"s_operand\" \"Q\")\n-                         (match_operand 2 \"const_int_operand\" \"n\")\n-                         (const_int 0)))\n+(define_insn_and_split \"*extzv<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(zero_extract:GPR (match_operand:QI 1 \"s_operand\" \"QS\")\n+\t\t          (match_operand 2 \"const_int_operand\" \"n\")\n+\t\t          (const_int 0)))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT\n-   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 8\"\n+  \"INTVAL (operands[2]) > 0\n+   && INTVAL (operands[2]) <= GET_MODE_BITSIZE (SImode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n-    [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_SETHIGH))\n+    [(set (match_dup 0) (unspec:GPR [(match_dup 1) (match_dup 3)] UNSPEC_ICM))\n      (clobber (reg:CC CC_REGNUM))])\n-    (set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 2)))]\n+   (set (match_dup 0) (lshiftrt:GPR (match_dup 0) (match_dup 2)))]\n {\n-  operands[2] = GEN_INT (32 - INTVAL (operands[2]));\n-  operands[1] = change_address (operands[1], QImode, 0);\n+  int bitsize = INTVAL (operands[2]);\n+  int size = (bitsize - 1) / BITS_PER_UNIT + 1; /* round up */\n+  int mask = ((1ul << size) - 1) << (GET_MODE_SIZE (SImode) - size);\n+\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+  set_mem_size (operands[1], GEN_INT (size));\n+  operands[2] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) - bitsize);\n+  operands[3] = GEN_INT (mask);\n })\n \n-(define_insn_and_split \"*extracthi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (zero_extract:SI (match_operand:QI 1 \"s_operand\" \"Q\")\n-                         (match_operand 2 \"const_int_operand\" \"n\")\n-                         (const_int 0)))\n+(define_insn_and_split \"*extv<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(sign_extract:GPR (match_operand:QI 1 \"s_operand\" \"QS\")\n+\t\t          (match_operand 2 \"const_int_operand\" \"n\")\n+\t\t          (const_int 0)))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT\n-   && INTVAL (operands[2]) >= 8 && INTVAL (operands[2]) < 16\"\n+  \"INTVAL (operands[2]) > 0\n+   && INTVAL (operands[2]) <= GET_MODE_BITSIZE (SImode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n-    [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_SETHIGH))\n+    [(set (match_dup 0) (unspec:GPR [(match_dup 1) (match_dup 3)] UNSPEC_ICM))\n      (clobber (reg:CC CC_REGNUM))])\n-    (set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 2)))]\n+   (parallel\n+    [(set (match_dup 0) (ashiftrt:GPR (match_dup 0) (match_dup 2)))\n+     (clobber (reg:CC CC_REGNUM))])]\n {\n-  operands[2] = GEN_INT (32 - INTVAL (operands[2]));\n-  operands[1] = change_address (operands[1], HImode, 0);\n+  int bitsize = INTVAL (operands[2]);\n+  int size = (bitsize - 1) / BITS_PER_UNIT + 1; /* round up */\n+  int mask = ((1ul << size) - 1) << (GET_MODE_SIZE (SImode) - size);\n+\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+  set_mem_size (operands[1], GEN_INT (size));\n+  operands[2] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) - bitsize);\n+  operands[3] = GEN_INT (mask);\n+})\n+\n+;\n+; insv instruction patterns\n+;\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract (match_operand 0 \"nonimmediate_operand\" \"\")\n+\t\t      (match_operand 1 \"const_int_operand\" \"\")\n+\t\t      (match_operand 2 \"const_int_operand\" \"\"))\n+\t(match_operand 3 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (s390_expand_insv (operands[0], operands[1], operands[2], operands[3]))\n+    DONE;\n+  FAIL;\n })\n \n+(define_insn \"*insv<mode>_mem_reg\"\n+  [(set (zero_extract:P (match_operand:QI 0 \"memory_operand\" \"+Q,S\")\n+\t\t\t(match_operand 1 \"const_int_operand\" \"n,n\")\n+\t\t\t(const_int 0))\n+\t(match_operand:P 2 \"register_operand\" \"d,d\"))]\n+  \"INTVAL (operands[1]) > 0\n+   && INTVAL (operands[1]) <= GET_MODE_BITSIZE (SImode)\n+   && INTVAL (operands[1]) % BITS_PER_UNIT == 0\"\n+{\n+    int size = INTVAL (operands[1]) / BITS_PER_UNIT;\n+\n+    operands[1] = GEN_INT ((1ul << size) - 1);\n+    return (which_alternative == 0) ? \"stcm\\t%2,%1,%S0\" \n+\t\t\t\t    : \"stcmy\\t%2,%1,%S0\";\n+}\n+  [(set_attr \"op_type\" \"RS,RSY\")])\n+\n+(define_insn \"*insvdi_mem_reghigh\"\n+  [(set (zero_extract:DI (match_operand:QI 0 \"memory_operand\" \"+QS\")\n+\t\t\t (match_operand 1 \"const_int_operand\" \"n\")\n+\t\t\t (const_int 0))\n+\t(lshiftrt:DI (match_operand:DI 2 \"register_operand\" \"d\")\n+\t\t     (const_int 32)))]\n+  \"TARGET_64BIT\n+   && INTVAL (operands[1]) > 0\n+   && INTVAL (operands[1]) <= GET_MODE_BITSIZE (SImode)\n+   && INTVAL (operands[1]) % BITS_PER_UNIT == 0\"\n+{\n+    int size = INTVAL (operands[1]) / BITS_PER_UNIT;\n+\n+    operands[1] = GEN_INT ((1ul << size) - 1);\n+    return \"stcmh\\t%2,%1,%S0\";\n+}\n+[(set_attr \"op_type\" \"RSY\")])\n+\n+(define_insn \"*insv<mode>_reg_imm\"\n+  [(set (zero_extract:P (match_operand:P 0 \"register_operand\" \"+d\")\n+\t\t\t(const_int 16)\n+\t\t\t(match_operand 1 \"const_int_operand\" \"n\"))\n+\t(match_operand:P 2 \"const_int_operand\" \"K\"))]\n+  \"TARGET_ZARCH\n+   && INTVAL (operands[1]) >= 0\n+   && INTVAL (operands[1]) < BITS_PER_WORD\n+   && INTVAL (operands[1]) % 16 == 0\"\n+{\n+  switch (BITS_PER_WORD - INTVAL (operands[1]))\n+    {\n+      case 64: return \"iihh\\t%0,%x2\"; break;\n+      case 48: return \"iihl\\t%0,%x2\"; break;\n+      case 32: return \"iilh\\t%0,%x2\"; break;\n+      case 16: return \"iill\\t%0,%x2\"; break;\n+      default: gcc_unreachable();\n+    }\n+}\n+  [(set_attr \"op_type\" \"RI\")])\n+\n+(define_insn \"*insv<mode>_reg_extimm\"\n+  [(set (zero_extract:P (match_operand:P 0 \"register_operand\" \"+d\")\n+\t\t\t(const_int 32)\n+\t\t\t(match_operand 1 \"const_int_operand\" \"n\"))\n+\t(match_operand:P 2 \"const_int_operand\" \"Os\"))]\n+  \"TARGET_EXTIMM\n+   && INTVAL (operands[1]) >= 0\n+   && INTVAL (operands[1]) < BITS_PER_WORD\n+   && INTVAL (operands[1]) % 32 == 0\"\n+{\n+  switch (BITS_PER_WORD - INTVAL (operands[1]))\n+    {\n+      case 64: return \"iihf\\t%0,%o2\"; break;\n+      case 32: return \"iilf\\t%0,%o2\"; break;\n+      default: gcc_unreachable();\n+    }\n+}\n+  [(set_attr \"op_type\" \"RIL\")])\n+\n ;\n ; extendsidi2 instruction pattern(s).\n ;\n@@ -2626,12 +2729,15 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n-    [(set (match_dup 0) (unspec:DI [(match_dup 1)] UNSPEC_SETHIGH))\n+    [(set (match_dup 0) (unspec:DI [(match_dup 1) (const_int 8)] UNSPEC_ICM))\n      (clobber (reg:CC CC_REGNUM))])\n    (parallel\n     [(set (match_dup 0) (ashiftrt:DI (match_dup 0) (const_int 56)))\n      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+{\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+  set_mem_size (operands[1], GEN_INT (GET_MODE_SIZE (QImode)));\n+})\n \n ;\n ; extend(hi|qi)si2 instruction pattern(s).\n@@ -2696,12 +2802,15 @@\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n-    [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_SETHIGH))\n+    [(set (match_dup 0) (unspec:SI [(match_dup 1) (const_int 8)] UNSPEC_ICM))\n      (clobber (reg:CC CC_REGNUM))])\n    (parallel\n     [(set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 24)))\n      (clobber (reg:CC CC_REGNUM))])]\n-  \"\")\n+{\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n+  set_mem_size (operands[1], GEN_INT (GET_MODE_SIZE (QImode)));\n+})\n \n ;\n ; extendqihi2 instruction pattern(s)."}]}