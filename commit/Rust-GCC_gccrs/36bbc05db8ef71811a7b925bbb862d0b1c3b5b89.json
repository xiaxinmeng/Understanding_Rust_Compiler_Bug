{"sha": "36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZiYmMwNWRiOGVmNzE4MTFhN2I5MjViYmI4NjJkMGIxYzNiNWI4OQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2018-10-22T08:27:50Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2018-10-22T08:27:50Z"}, "message": "Add a fun parameter to three stmt_could_throw... functions\n\nThis long patch only does one simple thing, adds an explicit function\nparameter to predicates stmt_could_throw_p, stmt_can_throw_external\nand stmt_can_throw_internal.\n\nMy motivation was ability to use stmt_can_throw_external in IPA\nanalysis phase without the need to push cfun.  As I have discovered,\nwe were already doing that in cgraph.c, which this patch avoids as\nwell.  In the process, I had to add a struct function parameter to\nstmt_could_throw_p and decided to also change the interface of\nstmt_can_throw_internal just for the sake of some minimal consistency.\n\nIn the process I have discovered that calling method\ncgraph_node::create_version_clone_with_body (used by ipa-split,\nipa-sra, OMP simd and multiple_target) leads to calls of\nstmt_can_throw_external with NULL cfun.  I have worked around this by\nmaking stmt_can_throw_external and stmt_could_throw_p gracefully\naccept NULL and just be pessimistic in that case.  The problem with\nfixing this in a better way is that struct function for the clone is\ncreated after cloning edges where we attempt to push the yet not\nexisting cfun, and moving it before would require a bit of surgery in\ntree-inline.c.  A slightly hackish but simpler fix might be to\nexplicitely pass the \"old\" function to symbol_table::create_edge\nbecause it should be just as good at that moment.  In any event, that\nis a topic for another patch.\n\nI believe that currently we incorrectly use cfun in\nmaybe_clean_eh_stmt_fn and maybe_duplicate_eh_stmt_fn, both in\ntree-eh.c, and so I have fixed these cases too.  The bulk of other\nchanges is just mechanical adding of cfun to all users.\n\nBootstrapped and tested on x86_64-linux (also with extra NULLing and\nrestoring cfun to double check it is not used in a place I missed), OK\nfor trunk?\n\nThanks,\n\nMartin\n\n2018-10-22  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-eh.h (stmt_could_throw_p): Add function parameter.\n\t(stmt_can_throw_external): Likewise.\n\t(stmt_can_throw_internal): Likewise.\n\t* tree-eh.c (lower_eh_constructs_2): Pass cfun to stmt_could_throw_p.\n\t(lower_eh_constructs_2): Likewise.\n\t(stmt_could_throw_p): Add fun parameter, use it instead of cfun.\n\t(stmt_can_throw_external): Likewise.\n\t(stmt_can_throw_internal): Likewise.\n\t(maybe_clean_eh_stmt_fn): Pass cfun to stmt_could_throw_p.\n\t(maybe_clean_or_replace_eh_stmt): Pass cfun to stmt_could_throw_p.\n\t(maybe_duplicate_eh_stmt_fn): Pass new_fun to stmt_could_throw_p.\n\t(maybe_duplicate_eh_stmt): Pass cfun to stmt_could_throw_p.\n\t(pass_lower_eh_dispatch::execute): Pass cfun to\n\tstmt_can_throw_external.\n\t(cleanup_empty_eh): Likewise.\n\t(verify_eh_edges): Pass cfun to stmt_could_throw_p.\n\t* cgraph.c (cgraph_edge::set_call_stmt): Pass a function to\n\tstmt_can_throw_external instead of pushing it to cfun.\n\t(symbol_table::create_edge): Likewise.\n\t* gimple-fold.c (fold_builtin_atomic_compare_exchange): Pass cfun to\n\tstmt_can_throw_internal.\n\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Pass cfun\n\tto stmt_could_throw_p.\n\t* gimple-ssa-store-merging.c (handled_load): Pass cfun to\n\tstmt_can_throw_internal.\n\t(pass_store_merging::execute): Likewise.\n\t* gimple-ssa-strength-reduction.c\n\t(find_candidates_dom_walker::before_dom_children): Pass cfun to\n\tstmt_could_throw_p.\n\t* gimplify-me.c (gimple_regimplify_operands): Pass cfun to\n\tstmt_can_throw_internal.\n\t* ipa-pure-const.c (check_call): Pass cfun to stmt_could_throw_p and\n\tto stmt_can_throw_external.\n\t(check_stmt): Pass cfun to stmt_could_throw_p.\n\t(check_stmt): Pass cfun to stmt_can_throw_external.\n\t(pass_nothrow::execute): Likewise.\n\t* trans-mem.c (expand_call_tm): Pass cfun to stmt_can_throw_internal.\n\t* tree-cfg.c (is_ctrl_altering_stmt): Pass cfun to\n\tstmt_can_throw_internal.\n\t(verify_gimple_in_cfg): Pass cfun to stmt_could_throw_p.\n\t(stmt_can_terminate_bb_p): Pass cfun to stmt_can_throw_external.\n\t(gimple_purge_dead_eh_edges): Pass cfun to stmt_can_throw_internal.\n\t* tree-complex.c (expand_complex_libcall): Pass cfun to\n\tstmt_could_throw_p and to stmt_can_throw_internal.\n\t(expand_complex_multiplication): Pass cfun to stmt_can_throw_internal.\n\t* tree-inline.c (copy_edges_for_bb): Likewise.\n\t(maybe_move_debug_stmts_to_successors): Likewise.\n\t* tree-outof-ssa.c (ssa_is_replaceable_p): Pass cfun to\n\tstmt_could_throw_p.\n\t* tree-parloops.c (oacc_entry_exit_ok_1): Likewise.\n\t* tree-sra.c (scan_function): Pass cfun to stmt_can_throw_external.\n\t* tree-ssa-alias.c (stmt_kills_ref_p): Pass cfun to\n\tstmt_can_throw_internal.\n\t* tree-ssa-ccp.c (optimize_atomic_bit_test_and): Likewise.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Pass cfun to\n\tstmt_could_throw_p.\n\t(mark_aliased_reaching_defs_necessary_1): Pass cfun to\n\tstmt_can_throw_internal.\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Likewise.\n\t* tree-ssa-loop-im.c (movement_possibility): Pass cfun to\n\tstmt_could_throw_p.\n\t* tree-ssa-loop-ivopts.c (find_givs_in_stmt_scev): Likewise.\n\t(add_autoinc_candidates): Pass cfun to stmt_can_throw_internal.\n\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Likewise.\n\t(convert_mult_to_fma_1): Likewise.\n\t(convert_to_divmod): Likewise.\n\t* tree-ssa-phiprop.c (propagate_with_phi): Likewise.\n\t* tree-ssa-pre.c (compute_avail): Pass cfun to stmt_could_throw_p.\n\t* tree-ssa-propagate.c\n\t(substitute_and_fold_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-reassoc.c (suitable_cond_bb): Likewise.\n\t(maybe_optimize_range_tests): Likewise.\n\t(linearize_expr_tree): Likewise.\n\t(reassociate_bb): Likewise.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_call): Likewise.\n\t* tree-ssa-scopedtables.c (hashable_expr_equal_p): Likewise.\n\t* tree-ssa-strlen.c (adjust_last_stmt): Likewise.\n\t(handle_char_store): Likewise.\n\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Pass cfun to\n\tstmt_can_throw_internal.\n\t* tree-vect-patterns.c (check_bool_pattern): Pass cfun to\n\tstmt_could_throw_p.\n\t* tree-vect-stmts.c (vect_finish_stmt_generation_1): Likewise.\n\t(vectorizable_call): Pass cfun to stmt_can_throw_internal.\n\t(vectorizable_simd_clone_call): Likewise.\n\t* value-prof.c (gimple_ic): Pass cfun to stmt_could_throw_p.\n\t(gimple_stringop_fixed_value): Likewise.\n\nFrom-SVN: r265372", "tree": {"sha": "c7ed4a03002467a31c3a0cf10bca6c5d06b40338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7ed4a03002467a31c3a0cf10bca6c5d06b40338"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3703b60c903e1cb7629c1a51cda68e53ebd8fbe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3703b60c903e1cb7629c1a51cda68e53ebd8fbe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3703b60c903e1cb7629c1a51cda68e53ebd8fbe8"}], "stats": {"total": 275, "additions": 184, "deletions": 91}, "files": [{"sha": "57db965f6e6ff284dab914a272d5464fc3d2a53a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1,3 +1,93 @@\n+2018-10-22  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-eh.h (stmt_could_throw_p): Add function parameter.\n+\t(stmt_can_throw_external): Likewise.\n+\t(stmt_can_throw_internal): Likewise.\n+\t* tree-eh.c (lower_eh_constructs_2): Pass cfun to stmt_could_throw_p.\n+\t(lower_eh_constructs_2): Likewise.\n+\t(stmt_could_throw_p): Add fun parameter, use it instead of cfun.\n+\t(stmt_can_throw_external): Likewise.\n+\t(stmt_can_throw_internal): Likewise.\n+\t(maybe_clean_eh_stmt_fn): Pass cfun to stmt_could_throw_p.\n+\t(maybe_clean_or_replace_eh_stmt): Pass cfun to stmt_could_throw_p.\n+\t(maybe_duplicate_eh_stmt_fn): Pass new_fun to stmt_could_throw_p.\n+\t(maybe_duplicate_eh_stmt): Pass cfun to stmt_could_throw_p.\n+\t(pass_lower_eh_dispatch::execute): Pass cfun to\n+\tstmt_can_throw_external.\n+\t(cleanup_empty_eh): Likewise.\n+\t(verify_eh_edges): Pass cfun to stmt_could_throw_p.\n+\t* cgraph.c (cgraph_edge::set_call_stmt): Pass a function to\n+\tstmt_can_throw_external instead of pushing it to cfun.\n+\t(symbol_table::create_edge): Likewise.\n+\t* gimple-fold.c (fold_builtin_atomic_compare_exchange): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Pass cfun\n+\tto stmt_could_throw_p.\n+\t* gimple-ssa-store-merging.c (handled_load): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t(pass_store_merging::execute): Likewise.\n+\t* gimple-ssa-strength-reduction.c\n+\t(find_candidates_dom_walker::before_dom_children): Pass cfun to\n+\tstmt_could_throw_p.\n+\t* gimplify-me.c (gimple_regimplify_operands): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t* ipa-pure-const.c (check_call): Pass cfun to stmt_could_throw_p and\n+\tto stmt_can_throw_external.\n+\t(check_stmt): Pass cfun to stmt_could_throw_p.\n+\t(check_stmt): Pass cfun to stmt_can_throw_external.\n+\t(pass_nothrow::execute): Likewise.\n+\t* trans-mem.c (expand_call_tm): Pass cfun to stmt_can_throw_internal.\n+\t* tree-cfg.c (is_ctrl_altering_stmt): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t(verify_gimple_in_cfg): Pass cfun to stmt_could_throw_p.\n+\t(stmt_can_terminate_bb_p): Pass cfun to stmt_can_throw_external.\n+\t(gimple_purge_dead_eh_edges): Pass cfun to stmt_can_throw_internal.\n+\t* tree-complex.c (expand_complex_libcall): Pass cfun to\n+\tstmt_could_throw_p and to stmt_can_throw_internal.\n+\t(expand_complex_multiplication): Pass cfun to stmt_can_throw_internal.\n+\t* tree-inline.c (copy_edges_for_bb): Likewise.\n+\t(maybe_move_debug_stmts_to_successors): Likewise.\n+\t* tree-outof-ssa.c (ssa_is_replaceable_p): Pass cfun to\n+\tstmt_could_throw_p.\n+\t* tree-parloops.c (oacc_entry_exit_ok_1): Likewise.\n+\t* tree-sra.c (scan_function): Pass cfun to stmt_can_throw_external.\n+\t* tree-ssa-alias.c (stmt_kills_ref_p): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t* tree-ssa-ccp.c (optimize_atomic_bit_test_and): Likewise.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Pass cfun to\n+\tstmt_could_throw_p.\n+\t(mark_aliased_reaching_defs_necessary_1): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t* tree-ssa-forwprop.c (pass_forwprop::execute): Likewise.\n+\t* tree-ssa-loop-im.c (movement_possibility): Pass cfun to\n+\tstmt_could_throw_p.\n+\t* tree-ssa-loop-ivopts.c (find_givs_in_stmt_scev): Likewise.\n+\t(add_autoinc_candidates): Pass cfun to stmt_can_throw_internal.\n+\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Likewise.\n+\t(convert_mult_to_fma_1): Likewise.\n+\t(convert_to_divmod): Likewise.\n+\t* tree-ssa-phiprop.c (propagate_with_phi): Likewise.\n+\t* tree-ssa-pre.c (compute_avail): Pass cfun to stmt_could_throw_p.\n+\t* tree-ssa-propagate.c\n+\t(substitute_and_fold_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-reassoc.c (suitable_cond_bb): Likewise.\n+\t(maybe_optimize_range_tests): Likewise.\n+\t(linearize_expr_tree): Likewise.\n+\t(reassociate_bb): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_call): Likewise.\n+\t* tree-ssa-scopedtables.c (hashable_expr_equal_p): Likewise.\n+\t* tree-ssa-strlen.c (adjust_last_stmt): Likewise.\n+\t(handle_char_store): Likewise.\n+\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Pass cfun to\n+\tstmt_can_throw_internal.\n+\t* tree-vect-patterns.c (check_bool_pattern): Pass cfun to\n+\tstmt_could_throw_p.\n+\t* tree-vect-stmts.c (vect_finish_stmt_generation_1): Likewise.\n+\t(vectorizable_call): Pass cfun to stmt_can_throw_internal.\n+\t(vectorizable_simd_clone_call): Likewise.\n+\t* value-prof.c (gimple_ic): Pass cfun to stmt_could_throw_p.\n+\t(gimple_stringop_fixed_value): Likewise.\n+\n 2018-10-22  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \t* config/s390/s390.c (s390_loadrelative_operand_p): Accept"}, {"sha": "48bab9f274996f6f43626626d94c62786acaa850", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -815,9 +815,8 @@ cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)\n       e = make_direct (new_callee);\n     }\n \n-  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n-  e->can_throw_external = stmt_can_throw_external (new_stmt);\n-  pop_cfun ();\n+  function *fun = DECL_STRUCT_FUNCTION (e->caller->decl);\n+  e->can_throw_external = stmt_can_throw_external (fun, new_stmt);\n   if (e->caller->call_site_hash)\n     cgraph_add_edge_to_call_site_hash (e);\n }\n@@ -870,10 +869,9 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->count = count;\n \n   edge->call_stmt = call_stmt;\n-  push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n   edge->can_throw_external\n-    = call_stmt ? stmt_can_throw_external (call_stmt) : false;\n-  pop_cfun ();\n+    = call_stmt ? stmt_can_throw_external (DECL_STRUCT_FUNCTION (caller->decl),\n+\t\t\t\t\t   call_stmt) : false;\n   if (call_stmt\n       && callee && callee->decl\n       && !gimple_check_call_matching_types (call_stmt, callee->decl,"}, {"sha": "7d2bd1c659998c91d590d751d4174c963b0c5de4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -4023,7 +4023,7 @@ fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *gsi)\n   gimple_set_vuse (g, gimple_vuse (stmt));\n   SSA_NAME_DEF_STMT (gimple_vdef (g)) = g;\n   tree oldlhs = gimple_call_lhs (stmt);\n-  if (stmt_can_throw_internal (stmt))\n+  if (stmt_can_throw_internal (cfun, stmt))\n     {\n       throws = true;\n       e = find_fallthru_edge (gsi_bb (*gsi)->succs);"}, {"sha": "deb45cdb9f62580d829cdd71a1964b6071db607b", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -163,7 +163,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t      /* Mark stmts whose output we fully propagate for removal.  */\n \t      if ((val = value_range_constant_singleton (vr))\n \t\t  && may_propagate_copy (output, val)\n-\t\t  && !stmt_could_throw_p (stmt)\n+\t\t  && !stmt_could_throw_p (cfun, stmt)\n \t\t  && !gimple_has_side_effects (stmt))\n \t\t{\n \t\t  stmts_to_remove.safe_push (stmt);"}, {"sha": "e1ddcb5e558d06883fd267261095e80aa4a39db5", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -4256,7 +4256,7 @@ handled_load (gimple *stmt, store_operand_info *op,\n     }\n   if (gimple_vuse (stmt)\n       && gimple_assign_load_p (stmt)\n-      && !stmt_can_throw_internal (stmt)\n+      && !stmt_can_throw_internal (cfun, stmt)\n       && !gimple_has_volatile_ops (stmt))\n     {\n       tree mem = gimple_assign_rhs1 (stmt);\n@@ -4551,7 +4551,7 @@ pass_store_merging::execute (function *fun)\n \t    }\n \n \t  if (gimple_assign_single_p (stmt) && gimple_vdef (stmt)\n-\t      && !stmt_can_throw_internal (stmt)\n+\t      && !stmt_can_throw_internal (cfun, stmt)\n \t      && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt)))\n \t    process_store (stmt);\n \t  else"}, {"sha": "d47772b4a518166f848be242d348e4a74f0aa670", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1775,7 +1775,7 @@ find_candidates_dom_walker::before_dom_children (basic_block bb)\n     {\n       gimple *gs = gsi_stmt (gsi);\n \n-      if (stmt_could_throw_p (gs))\n+      if (stmt_could_throw_p (cfun, gs))\n \tcontinue;\n \n       if (gimple_vuse (gs) && gimple_assign_single_p (gs))"}, {"sha": "269fe6b3bae32e9443029f97a63945c86bc27076", "filename": "gcc/gimplify-me.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimplify-me.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fgimplify-me.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify-me.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -273,7 +273,7 @@ gimple_regimplify_operands (gimple *stmt, gimple_stmt_iterator *gsi_p)\n \t\t\t  || !(i & (ECF_CONST | ECF_PURE)))\n \t\t\tneed_temp = true;\n \t\t    }\n-\t\t  if (stmt_can_throw_internal (stmt))\n+\t\t  if (stmt_can_throw_internal (cfun, stmt))\n \t\t    need_temp = true;\n \t\t}\n \t    }"}, {"sha": "1ca1d60517ee345cadd779c44b59a974f6ca3237", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -555,9 +555,9 @@ check_call (funct_state local, gcall *call, bool ipa)\n {\n   int flags = gimple_call_flags (call);\n   tree callee_t = gimple_call_fndecl (call);\n-  bool possibly_throws = stmt_could_throw_p (call);\n+  bool possibly_throws = stmt_could_throw_p (cfun, call);\n   bool possibly_throws_externally = (possibly_throws\n-  \t\t\t\t     && stmt_can_throw_external (call));\n+  \t\t\t\t     && stmt_can_throw_external (cfun, call));\n \n   if (possibly_throws)\n     {\n@@ -770,15 +770,15 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n \t\t\t    ipa ? check_ipa_store :  check_store);\n \n   if (gimple_code (stmt) != GIMPLE_CALL\n-      && stmt_could_throw_p (stmt))\n+      && stmt_could_throw_p (cfun, stmt))\n     {\n       if (cfun->can_throw_non_call_exceptions)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    can throw; looping\\n\");\n \t  local->looping = true;\n \t}\n-      if (stmt_can_throw_external (stmt))\n+      if (stmt_can_throw_external (cfun, stmt))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    can throw externally\\n\");\n@@ -2307,7 +2307,7 @@ pass_nothrow::execute (function *)\n       for (gimple_stmt_iterator gsi = gsi_start_bb (this_block);\n \t   !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n-        if (stmt_can_throw_external (gsi_stmt (gsi)))\n+        if (stmt_can_throw_external (cfun, gsi_stmt (gsi)))\n \t  {\n \t    if (is_gimple_call (gsi_stmt (gsi)))\n \t      {"}, {"sha": "7e4bcec4030ea65d44c97e9782f5d8c0ffd30833", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2582,7 +2582,7 @@ expand_call_tm (struct tm_region *region,\n       gassign *assign_stmt;\n \n       /* Remember if the call was going to throw.  */\n-      if (stmt_can_throw_internal (stmt))\n+      if (stmt_can_throw_internal (cfun, stmt))\n \t{\n \t  edge_iterator ei;\n \t  edge e;"}, {"sha": "d30e4aca773f141a4dd5df4d5f72297d6b732c68", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2720,7 +2720,7 @@ is_ctrl_altering_stmt (gimple *t)\n     }\n \n   /* If a statement can throw, it alters control flow.  */\n-  return stmt_can_throw_internal (t);\n+  return stmt_can_throw_internal (cfun, t);\n }\n \n \n@@ -5387,7 +5387,7 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t    visited_throwing_stmts.add (stmt);\n \t  if (lp_nr > 0)\n \t    {\n-\t      if (!stmt_could_throw_p (stmt))\n+\t      if (!stmt_could_throw_p (cfun, stmt))\n \t\t{\n \t\t  if (verify_nothrow)\n \t\t    {\n@@ -8283,7 +8283,7 @@ stmt_can_terminate_bb_p (gimple *t)\n \n   /* Eh exception not handled internally terminates execution of the whole\n      function.  */\n-  if (stmt_can_throw_external (t))\n+  if (stmt_can_throw_external (cfun, t))\n     return true;\n \n   /* NORETURN and LONGJMP calls already have an edge to exit.\n@@ -8599,7 +8599,7 @@ gimple_purge_dead_eh_edges (basic_block bb)\n   edge_iterator ei;\n   gimple *stmt = last_stmt (bb);\n \n-  if (stmt && stmt_can_throw_internal (stmt))\n+  if (stmt && stmt_can_throw_internal (cfun, stmt))\n     return false;\n \n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )"}, {"sha": "49088081bb09bb6d994b1812134a1e0a94f09d67", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1010,13 +1010,13 @@ expand_complex_libcall (gimple_stmt_iterator *gsi, tree type, tree ar, tree ai,\n   if (inplace_p)\n     {\n       gimple *old_stmt = gsi_stmt (*gsi);\n-      gimple_call_set_nothrow (stmt, !stmt_could_throw_p (old_stmt));\n+      gimple_call_set_nothrow (stmt, !stmt_could_throw_p (cfun, old_stmt));\n       lhs = gimple_assign_lhs (old_stmt);\n       gimple_call_set_lhs (stmt, lhs);\n       gsi_replace (gsi, stmt, true);\n \n       type = TREE_TYPE (type);\n-      if (stmt_can_throw_internal (stmt))\n+      if (stmt_can_throw_internal (cfun, stmt))\n \t{\n \t  edge_iterator ei;\n \t  edge e;\n@@ -1134,7 +1134,7 @@ expand_complex_multiplication (gimple_stmt_iterator *gsi, tree type,\n \t  /* If optimizing for size or not at all just do a libcall.\n \t     Same if there are exception-handling edges or signaling NaNs.  */\n \t  if (optimize == 0 || optimize_bb_for_size_p (gsi_bb (*gsi))\n-\t     || stmt_can_throw_internal (gsi_stmt (*gsi))\n+\t     || stmt_can_throw_internal (cfun, gsi_stmt (*gsi))\n \t     || flag_signaling_nans)\n \t    {\n \t      expand_complex_libcall (gsi, type, ar, ai, br, bi,"}, {"sha": "1c7d9dc1d597af55544600629d24bd80ce316c6c", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2033,7 +2033,7 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n \t available on the EH edge.  Only do so for statements that\n \t potentially fall through (no noreturn calls e.g.), otherwise\n \t this new assignment might create fake fallthru regions.  */\n-      if (stmt_could_throw_p (stmt)\n+      if (stmt_could_throw_p (cfun, stmt)\n \t  && gimple_has_lhs (stmt)\n \t  && gimple_stmt_may_fallthru (stmt)\n \t  && !tree_could_throw_p (gimple_get_lhs (stmt))\n@@ -2051,7 +2051,7 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n \t  gsi_insert_after (gsi, s, GSI_SAME_STMT);\n \t}\n       /* Look for things that can throw exceptions, and record them.  */\n-      if (state->cur_region && stmt_could_throw_p (stmt))\n+      if (state->cur_region && stmt_could_throw_p (cfun, stmt))\n \t{\n \t  record_stmt_eh_region (state->cur_region, stmt);\n \t  note_eh_region_may_contain_throw (state->cur_region);\n@@ -2866,10 +2866,10 @@ stmt_could_throw_1_p (gassign *stmt)\n }\n \n \n-/* Return true if statement STMT could throw an exception.  */\n+/* Return true if statement STMT within FUN could throw an exception.  */\n \n bool\n-stmt_could_throw_p (gimple *stmt)\n+stmt_could_throw_p (function *fun, gimple *stmt)\n {\n   if (!flag_exceptions)\n     return false;\n@@ -2886,7 +2886,7 @@ stmt_could_throw_p (gimple *stmt)\n \n     case GIMPLE_COND:\n       {\n-\tif (!cfun->can_throw_non_call_exceptions)\n+\tif (fun && !fun->can_throw_non_call_exceptions)\n \t  return false;\n \tgcond *cond = as_a <gcond *> (stmt);\n \ttree lhs = gimple_cond_lhs (cond);\n@@ -2896,13 +2896,13 @@ stmt_could_throw_p (gimple *stmt)\n       }\n \n     case GIMPLE_ASSIGN:\n-      if (!cfun->can_throw_non_call_exceptions\n+      if ((fun && !fun->can_throw_non_call_exceptions)\n \t  || gimple_clobber_p (stmt))\n         return false;\n       return stmt_could_throw_1_p (as_a <gassign *> (stmt));\n \n     case GIMPLE_ASM:\n-      if (!cfun->can_throw_non_call_exceptions)\n+      if (fun && !fun->can_throw_non_call_exceptions)\n         return false;\n       return gimple_asm_volatile_p (as_a <gasm *> (stmt));\n \n@@ -2936,33 +2936,37 @@ tree_could_throw_p (tree t)\n   return false;\n }\n \n-/* Return true if STMT can throw an exception that is not caught within\n-   the current function (CFUN).  */\n+/* Return true if STMT can throw an exception that is not caught within its\n+   function FUN.  FUN can be NULL but the function is extra conservative\n+   then.  */\n \n bool\n-stmt_can_throw_external (gimple *stmt)\n+stmt_can_throw_external (function *fun, gimple *stmt)\n {\n   int lp_nr;\n \n-  if (!stmt_could_throw_p (stmt))\n+  if (!stmt_could_throw_p (fun, stmt))\n     return false;\n+  if (!fun)\n+    return true;\n \n-  lp_nr = lookup_stmt_eh_lp (stmt);\n+  lp_nr = lookup_stmt_eh_lp_fn (fun, stmt);\n   return lp_nr == 0;\n }\n \n-/* Return true if STMT can throw an exception that is caught within\n-   the current function (CFUN).  */\n+/* Return true if STMT can throw an exception that is caught within its\n+   function FUN.  */\n \n bool\n-stmt_can_throw_internal (gimple *stmt)\n+stmt_can_throw_internal (function *fun, gimple *stmt)\n {\n   int lp_nr;\n \n-  if (!stmt_could_throw_p (stmt))\n+  gcc_checking_assert (fun);\n+  if (!stmt_could_throw_p (fun, stmt))\n     return false;\n \n-  lp_nr = lookup_stmt_eh_lp (stmt);\n+  lp_nr = lookup_stmt_eh_lp_fn (fun, stmt);\n   return lp_nr > 0;\n }\n \n@@ -2973,7 +2977,7 @@ stmt_can_throw_internal (gimple *stmt)\n bool\n maybe_clean_eh_stmt_fn (struct function *ifun, gimple *stmt)\n {\n-  if (stmt_could_throw_p (stmt))\n+  if (stmt_could_throw_p (ifun, stmt))\n     return false;\n   return remove_stmt_from_eh_lp_fn (ifun, stmt);\n }\n@@ -2998,7 +3002,7 @@ maybe_clean_or_replace_eh_stmt (gimple *old_stmt, gimple *new_stmt)\n \n   if (lp_nr != 0)\n     {\n-      bool new_stmt_could_throw = stmt_could_throw_p (new_stmt);\n+      bool new_stmt_could_throw = stmt_could_throw_p (cfun, new_stmt);\n \n       if (new_stmt == old_stmt && new_stmt_could_throw)\n \treturn false;\n@@ -3028,7 +3032,7 @@ maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple *new_stmt,\n {\n   int old_lp_nr, new_lp_nr;\n \n-  if (!stmt_could_throw_p (new_stmt))\n+  if (!stmt_could_throw_p (new_fun, new_stmt))\n     return false;\n \n   old_lp_nr = lookup_stmt_eh_lp_fn (old_fun, old_stmt);\n@@ -3067,7 +3071,7 @@ maybe_duplicate_eh_stmt (gimple *new_stmt, gimple *old_stmt)\n {\n   int lp_nr;\n \n-  if (!stmt_could_throw_p (new_stmt))\n+  if (!stmt_could_throw_p (cfun, new_stmt))\n     return false;\n \n   lp_nr = lookup_stmt_eh_lp (old_stmt);\n@@ -3862,7 +3866,7 @@ pass_lower_eh_dispatch::execute (function *fun)\n \t}\n       else if (gimple_code (last) == GIMPLE_RESX)\n \t{\n-\t  if (stmt_can_throw_external (last))\n+\t  if (stmt_can_throw_external (cfun, last))\n \t    optimize_clobbers (bb);\n \t  else\n \t    flags |= sink_clobbers (bb);\n@@ -4502,7 +4506,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n   resx = gsi_stmt (gsi);\n   if (resx && is_gimple_resx (resx))\n     {\n-      if (stmt_can_throw_external (resx))\n+      if (stmt_can_throw_external (cfun, resx))\n \toptimize_clobbers (bb);\n       else if (sink_clobbers (bb))\n \tret = true;\n@@ -4783,7 +4787,7 @@ verify_eh_edges (gimple *stmt)\n       return false;\n     }\n \n-  if (!stmt_could_throw_p (stmt))\n+  if (!stmt_could_throw_p (cfun, stmt))\n     {\n       error (\"BB %i last statement has incorrectly set lp\", bb->index);\n       return true;"}, {"sha": "2bd6a856bd99b6a4cfb991abed6c274376a1006d", "filename": "gcc/tree-eh.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-eh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-eh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.h?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -38,10 +38,10 @@ extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,\n extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);\n extern bool tree_could_trap_p (tree);\n extern tree rewrite_to_non_trapping_overflow (tree);\n-extern bool stmt_could_throw_p (gimple *);\n+extern bool stmt_could_throw_p (function *, gimple *);\n extern bool tree_could_throw_p (tree);\n-extern bool stmt_can_throw_external (gimple *);\n-extern bool stmt_can_throw_internal (gimple *);\n+extern bool stmt_can_throw_external (function *, gimple *);\n+extern bool stmt_can_throw_internal (function *, gimple *);\n extern bool maybe_clean_eh_stmt_fn (struct function *, gimple *);\n extern bool maybe_clean_eh_stmt (gimple *);\n extern bool maybe_clean_or_replace_eh_stmt (gimple *, gimple *);"}, {"sha": "297fcd70c824ca8201c94e20b8c6efc18489324c", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2246,7 +2246,7 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n          propagation can change an INDIRECT_REF which throws\n          into a COMPONENT_REF which doesn't.  If the copy\n          can throw, the original could also throw.  */\n-      can_throw = stmt_can_throw_internal (copy_stmt);\n+      can_throw = stmt_can_throw_internal (cfun, copy_stmt);\n       nonlocal_goto\n \t= (stmt_can_make_abnormal_goto (copy_stmt)\n \t   && !computed_goto_p (copy_stmt));\n@@ -2514,7 +2514,7 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \n   if (gsi_end_p (si)\n       || gsi_one_before_end_p (si)\n-      || !(stmt_can_throw_internal (gsi_stmt (si))\n+      || !(stmt_can_throw_internal (cfun, gsi_stmt (si))\n \t   || stmt_can_make_abnormal_goto (gsi_stmt (si))))\n     return;\n "}, {"sha": "fca15e5f89817fa5342a99f6fef8ea9f216de717", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -65,7 +65,7 @@ ssa_is_replaceable_p (gimple *stmt)\n     return false;\n \n   /* If the statement may throw an exception, it cannot be replaced.  */\n-  if (stmt_could_throw_p (stmt))\n+  if (stmt_could_throw_p (cfun, stmt))\n     return false;\n \n   /* Punt if there is more than 1 def.  */"}, {"sha": "5935cf4092759841167530ad20ea8ea632684324", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -3076,7 +3076,7 @@ oacc_entry_exit_ok_1 (bitmap in_loop_bbs, vec<basic_block> region_bbs,\n \t    continue;\n \t  else if (!gimple_has_side_effects (stmt)\n \t\t   && !gimple_could_trap_p (stmt)\n-\t\t   && !stmt_could_throw_p (stmt)\n+\t\t   && !stmt_could_throw_p (cfun, stmt)\n \t\t   && !gimple_vdef (stmt)\n \t\t   && !gimple_vuse (stmt))\n \t    continue;"}, {"sha": "e3e3746628341f33d17ec9ce8de361ca4dc6dd64", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1470,7 +1470,7 @@ scan_function (void)\n \t  tree t;\n \t  unsigned i;\n \n-\t  if (final_bbs && stmt_can_throw_external (stmt))\n+\t  if (final_bbs && stmt_can_throw_external (cfun, stmt))\n \t    bitmap_set_bit (final_bbs, bb->index);\n \t  switch (gimple_code (stmt))\n \t    {"}, {"sha": "85a5de7ce0532cc1d2dbc0883731edb02471c53a", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2396,7 +2396,7 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t ???  We only need to care about the RHS throwing.  For aggregate\n \t assignments or similar calls and non-call exceptions the LHS\n \t might throw as well.  */\n-      && !stmt_can_throw_internal (stmt))\n+      && !stmt_can_throw_internal (cfun, stmt))\n     {\n       tree lhs = gimple_get_lhs (stmt);\n       /* If LHS is literally a base of the access we are done.  */"}, {"sha": "55ee30e7d130821f93da2e9ad38c7a8a57a06d3c", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2931,7 +2931,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   gimple_set_location (g, gimple_location (call));\n   gimple_set_vuse (g, gimple_vuse (call));\n   gimple_set_vdef (g, gimple_vdef (call));\n-  bool throws = stmt_can_throw_internal (call);\n+  bool throws = stmt_can_throw_internal (cfun, call);\n   gimple_call_set_nothrow (as_a <gcall *> (g),\n \t\t\t   gimple_call_nothrow_p (as_a <gcall *> (call)));\n   SSA_NAME_DEF_STMT (gimple_vdef (call)) = g;"}, {"sha": "a8261b9a476f9b5a89ac15fb455ed920da691721", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -195,7 +195,7 @@ mark_stmt_if_obviously_necessary (gimple *stmt, bool aggressive)\n      throw.  If a statement could throw, it can be deemed necessary.  */\n   if (cfun->can_throw_non_call_exceptions\n       && !cfun->can_delete_dead_exceptions\n-      && stmt_could_throw_p (stmt))\n+      && stmt_could_throw_p (cfun, stmt))\n     {\n       mark_stmt_necessary (stmt, true);\n       return;\n@@ -473,7 +473,7 @@ mark_aliased_reaching_defs_necessary_1 (ao_ref *ref, tree vdef, void *data)\n          ???  We only need to care about the RHS throwing.  For aggregate\n \t assignments or similar calls and non-call exceptions the LHS\n \t might throw as well.  */\n-      && !stmt_can_throw_internal (def_stmt))\n+      && !stmt_can_throw_internal (cfun, def_stmt))\n     {\n       tree base, lhs = gimple_get_lhs (def_stmt);\n       poly_int64 size, offset, max_size;"}, {"sha": "7449eaf86ae63d471396efcc29dba32d4ec033ae", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -2343,7 +2343,7 @@ pass_forwprop::execute (function *fun)\n \t\t   && !gimple_has_volatile_ops (stmt)\n \t\t   && (TREE_CODE (gimple_assign_rhs1 (stmt))\n \t\t       != TARGET_MEM_REF)\n-\t\t   && !stmt_can_throw_internal (stmt))\n+\t\t   && !stmt_can_throw_internal (cfun, stmt))\n \t    {\n \t      /* Rewrite loads used only in real/imagpart extractions to\n \t         component-wise loads.  */"}, {"sha": "3c59134d8407fb9bce770718cb2c3a5f97dc8f8b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -302,7 +302,7 @@ movement_possibility (gimple *stmt)\n   if (stmt_ends_bb_p (stmt)\n       || gimple_has_volatile_ops (stmt)\n       || gimple_has_side_effects (stmt)\n-      || stmt_could_throw_p (stmt))\n+      || stmt_could_throw_p (cfun, stmt))\n     return MOVE_IMPOSSIBLE;\n \n   if (is_gimple_call (stmt))"}, {"sha": "b42f32da2b3c65883ac863bf67f77f8ffea9115a", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1440,7 +1440,7 @@ find_givs_in_stmt_scev (struct ivopts_data *data, gimple *stmt, affine_iv *iv)\n   /* If STMT could throw, then do not consider STMT as defining a GIV.\n      While this will suppress optimizations, we can not safely delete this\n      GIV and associated statements, even if it appears it is not used.  */\n-  if (stmt_could_throw_p (stmt))\n+  if (stmt_could_throw_p (cfun, stmt))\n     return false;\n \n   return true;\n@@ -3222,7 +3222,7 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n      statement.  */\n   if (use_bb->loop_father != data->current_loop\n       || !dominated_by_p (CDI_DOMINATORS, data->current_loop->latch, use_bb)\n-      || stmt_can_throw_internal (use->stmt)\n+      || stmt_can_throw_internal (cfun, use->stmt)\n       || !cst_and_fits_in_hwi (step))\n     return;\n "}, {"sha": "ccff56f4297fb24a47bd68842c59ef9186301de2", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -951,7 +951,7 @@ pass_cse_reciprocals::execute (function *fun)\n \t      stmt = gsi_stmt (gsi);\n \t      if (flag_unsafe_math_optimizations\n \t\t  && is_gimple_assign (stmt)\n-\t\t  && !stmt_can_throw_internal (stmt)\n+\t\t  && !stmt_can_throw_internal (cfun, stmt)\n \t\t  && gimple_assign_rhs_code (stmt) == RDIV_EXPR)\n \t\toptimize_recip_sqrt (&gsi, def);\n \t    }\n@@ -2904,7 +2904,8 @@ convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n       else\n \tfma_stmt = gimple_build_call_internal (IFN_FMA, 3, mulop1, op2, addop);\n       gimple_set_lhs (fma_stmt, gimple_get_lhs (use_stmt));\n-      gimple_call_set_nothrow (fma_stmt, !stmt_can_throw_internal (use_stmt));\n+      gimple_call_set_nothrow (fma_stmt, !stmt_can_throw_internal (cfun,\n+\t\t\t\t\t\t\t\t   use_stmt));\n       gsi_replace (&gsi, fma_stmt, true);\n       /* Follow all SSA edges so that we generate FMS, FNMA and FNMS\n \t regardless of where the negation occurs.  */\n@@ -3534,7 +3535,7 @@ divmod_candidate_p (gassign *stmt)\n static bool\n convert_to_divmod (gassign *stmt)\n {\n-  if (stmt_can_throw_internal (stmt)\n+  if (stmt_can_throw_internal (cfun, stmt)\n       || !divmod_candidate_p (stmt))\n     return false;\n \n@@ -3560,7 +3561,7 @@ convert_to_divmod (gassign *stmt)\n \t  && operand_equal_p (op1, gimple_assign_rhs1 (use_stmt), 0)\n \t  && operand_equal_p (op2, gimple_assign_rhs2 (use_stmt), 0))\n \t{\n-\t  if (stmt_can_throw_internal (use_stmt))\n+\t  if (stmt_can_throw_internal (cfun, use_stmt))\n \t    continue;\n \n \t  basic_block bb = gimple_bb (use_stmt);\n@@ -3598,7 +3599,7 @@ convert_to_divmod (gassign *stmt)\n \t  && operand_equal_p (top_op2, gimple_assign_rhs2 (use_stmt), 0))\n \t{\n \t  if (use_stmt == top_stmt\n-\t      || stmt_can_throw_internal (use_stmt)\n+\t      || stmt_can_throw_internal (cfun, use_stmt)\n \t      || !dominated_by_p (CDI_DOMINATORS, gimple_bb (use_stmt), top_bb))\n \t    continue;\n "}, {"sha": "bb18f3e9b497b151ace4a046d09444b08a1f19c5", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -339,7 +339,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,\n \t\t|| types_compatible_p\n \t\t     (TREE_TYPE (gimple_assign_lhs (use_stmt)), type))\n \t    /* We cannot replace a load that may throw or is volatile.  */\n-\t    && !stmt_can_throw_internal (use_stmt)))\n+\t    && !stmt_can_throw_internal (cfun, use_stmt)))\n \tcontinue;\n \n       /* Check if we can move the loads.  The def stmt of the virtual use"}, {"sha": "20d3c7807a1a49e8313eacf6a1064142e4b10ce5", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -3827,7 +3827,7 @@ compute_avail (void)\n \t    BB_LIVE_VOP_ON_EXIT (block) = gimple_vdef (stmt);\n \n \t  if (gimple_has_side_effects (stmt)\n-\t      || stmt_could_throw_p (stmt)\n+\t      || stmt_could_throw_p (cfun, stmt)\n \t      || is_gimple_debug (stmt))\n \t    continue;\n "}, {"sha": "c635e3069f42f16c0d06d714ed01bf7b64fba135", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1038,7 +1038,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t  if (sprime\n \t      && sprime != lhs\n \t      && may_propagate_copy (lhs, sprime)\n-\t      && !stmt_could_throw_p (stmt)\n+\t      && !stmt_could_throw_p (cfun, stmt)\n \t      && !gimple_has_side_effects (stmt)\n \t      /* We have to leave ASSERT_EXPRs around for jump-threading.  */\n \t      && (!is_gimple_assign (stmt)"}, {"sha": "971d926e7895c8ebebe660dbc5bdc02372a46f2c", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -3702,7 +3702,7 @@ suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,\n       || (gimple_code (stmt) != GIMPLE_COND\n \t  && (backward || !final_range_test_p (stmt)))\n       || gimple_visited_p (stmt)\n-      || stmt_could_throw_p (stmt)\n+      || stmt_could_throw_p (cfun, stmt)\n       || *other_bb == bb)\n     return false;\n   is_cond = gimple_code (stmt) == GIMPLE_COND;\n@@ -3958,7 +3958,7 @@ maybe_optimize_range_tests (gimple *stmt)\n   else\n     return cfg_cleanup_needed;\n \n-  if (stmt_could_throw_p (stmt))\n+  if (stmt_could_throw_p (cfun, stmt))\n     return cfg_cleanup_needed;\n \n   /* As relative ordering of post-dominator sons isn't fixed,\n@@ -5109,14 +5109,14 @@ linearize_expr_tree (vec<operand_entry *> *ops, gimple *stmt,\n     {\n       binlhsdef = SSA_NAME_DEF_STMT (binlhs);\n       binlhsisreassoc = (is_reassociable_op (binlhsdef, rhscode, loop)\n-\t\t\t && !stmt_could_throw_p (binlhsdef));\n+\t\t\t && !stmt_could_throw_p (cfun, binlhsdef));\n     }\n \n   if (TREE_CODE (binrhs) == SSA_NAME)\n     {\n       binrhsdef = SSA_NAME_DEF_STMT (binrhs);\n       binrhsisreassoc = (is_reassociable_op (binrhsdef, rhscode, loop)\n-\t\t\t && !stmt_could_throw_p (binrhsdef));\n+\t\t\t && !stmt_could_throw_p (cfun, binrhsdef));\n     }\n \n   /* If the LHS is not reassociable, but the RHS is, we need to swap\n@@ -5851,7 +5851,7 @@ reassociate_bb (basic_block bb)\n       stmt = gsi_stmt (gsi);\n \n       if (is_gimple_assign (stmt)\n-\t  && !stmt_could_throw_p (stmt))\n+\t  && !stmt_could_throw_p (cfun, stmt))\n \t{\n \t  tree lhs, rhs1, rhs2;\n \t  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);"}, {"sha": "e61f0ba7b8c64529eac601a0c2f5a579f70b34f3", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1210,7 +1210,7 @@ copy_reference_ops_from_call (gcall *call,\n   temp.opcode = CALL_EXPR;\n   temp.op0 = gimple_call_fn (call);\n   temp.op1 = gimple_call_chain (call);\n-  if (stmt_could_throw_p (call) && (lr = lookup_stmt_eh_lp (call)) > 0)\n+  if (stmt_could_throw_p (cfun, call) && (lr = lookup_stmt_eh_lp (call)) > 0)\n     temp.op2 = size_int (lr);\n   temp.off = -1;\n   result->safe_push (temp);"}, {"sha": "d1a73a5d64c7096d434d9cfa6fcdf9da3eb00418", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -666,7 +666,7 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n                                  expr1->ops.call.args[i], 0))\n             return false;\n \n-\tif (stmt_could_throw_p (expr0->ops.call.fn_from))\n+\tif (stmt_could_throw_p (cfun, expr0->ops.call.fn_from))\n \t  {\n \t    int lp0 = lookup_stmt_eh_lp (expr0->ops.call.fn_from);\n \t    int lp1 = lookup_stmt_eh_lp (expr1->ops.call.fn_from);"}, {"sha": "d508d36e1a538ea31121e31a631eef84f69ae128", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1064,7 +1064,7 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n \n       if (!integer_zerop (gimple_assign_rhs1 (last.stmt)))\n \treturn;\n-      if (stmt_could_throw_p (last.stmt))\n+      if (stmt_could_throw_p (cfun, last.stmt))\n \treturn;\n       gsi = gsi_for_stmt (last.stmt);\n       unlink_stmt_vdef (last.stmt);\n@@ -3253,7 +3253,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t{\n \t  /* When overwriting a '\\0' with a '\\0', the store can be removed\n \t     if we know it has been stored in the current function.  */\n-\t  if (!stmt_could_throw_p (stmt) && si->writable)\n+\t  if (!stmt_could_throw_p (cfun, stmt) && si->writable)\n \t    {\n \t      unlink_stmt_vdef (stmt);\n \t      release_defs (stmt);"}, {"sha": "4b3711442e680d8aaca37e50f55f3ab7791acd55", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -3844,7 +3844,7 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n     return opt_result::failure_at (stmt, \"not vectorized: volatile type: %G\",\n \t\t\t\t   stmt);\n \n-  if (stmt_can_throw_internal (stmt))\n+  if (stmt_can_throw_internal (cfun, stmt))\n     return opt_result::failure_at (stmt,\n \t\t\t\t   \"not vectorized:\"\n \t\t\t\t   \" statement can throw an exception: %G\","}, {"sha": "3053642b24108350d092fb6955beb5f9752086ca", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -3235,7 +3235,7 @@ check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n \n \t  /* If the comparison can throw, then is_gimple_condexpr will be\n \t     false and we can't make a COND_EXPR/VEC_COND_EXPR out of it.  */\n-\t  if (stmt_could_throw_p (def_stmt))\n+\t  if (stmt_could_throw_p (cfun, def_stmt))\n \t    return false;\n \n \t  comp_vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));"}, {"sha": "8995da80b1e62f11c242443cb961416f67a81990", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1711,7 +1711,7 @@ vect_finish_stmt_generation_1 (stmt_vec_info stmt_info, gimple *vec_stmt)\n      e.g. be in a must-not-throw region.  Ensure newly created stmts\n      that could throw are part of the same region.  */\n   int lp_nr = lookup_stmt_eh_lp (stmt_info->stmt);\n-  if (lp_nr != 0 && stmt_could_throw_p (vec_stmt))\n+  if (lp_nr != 0 && stmt_could_throw_p (cfun, vec_stmt))\n     add_stmt_to_eh_lp (vec_stmt, lp_nr);\n \n   return vec_stmt_info;\n@@ -3116,7 +3116,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       || TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME)\n     return false;\n \n-  gcc_checking_assert (!stmt_can_throw_internal (stmt));\n+  gcc_checking_assert (!stmt_can_throw_internal (cfun, stmt));\n \n   vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n \n@@ -3751,7 +3751,7 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n       && TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME)\n     return false;\n \n-  gcc_checking_assert (!stmt_can_throw_internal (stmt));\n+  gcc_checking_assert (!stmt_can_throw_internal (cfun, stmt));\n \n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n "}, {"sha": "f3be9ff8747a492066813efcdfe21bc019c454ca", "filename": "gcc/value-prof.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36bbc05db8ef71811a7b925bbb862d0b1c3b5b89/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=36bbc05db8ef71811a7b925bbb862d0b1c3b5b89", "patch": "@@ -1392,7 +1392,7 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n \n   /* Build an EH edge for the direct call if necessary.  */\n   lp_nr = lookup_stmt_eh_lp (icall_stmt);\n-  if (lp_nr > 0 && stmt_could_throw_p (dcall_stmt))\n+  if (lp_nr > 0 && stmt_could_throw_p (cfun, dcall_stmt))\n     {\n       add_stmt_to_eh_lp (dcall_stmt, lp_nr);\n     }\n@@ -1410,7 +1410,7 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n \t\t     PHI_ARG_DEF_FROM_EDGE (phi, e_eh));\n \t  }\n        }\n-  if (!stmt_could_throw_p (dcall_stmt))\n+  if (!stmt_could_throw_p (cfun, dcall_stmt))\n     gimple_purge_dead_eh_edges (dcall_bb);\n   return dcall_stmt;\n }\n@@ -1634,8 +1634,8 @@ gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, profile_probabi\n     }\n \n   /* Because these are all string op builtins, they're all nothrow.  */\n-  gcc_assert (!stmt_could_throw_p (vcall_stmt));\n-  gcc_assert (!stmt_could_throw_p (icall_stmt));\n+  gcc_assert (!stmt_could_throw_p (cfun, vcall_stmt));\n+  gcc_assert (!stmt_could_throw_p (cfun, icall_stmt));\n }\n \n /* Find values inside STMT for that we want to measure histograms for"}]}