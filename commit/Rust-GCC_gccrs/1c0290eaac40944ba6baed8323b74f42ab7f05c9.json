{"sha": "1c0290eaac40944ba6baed8323b74f42ab7f05c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMwMjkwZWFhYzQwOTQ0YmE2YmFlZDgzMjNiNzRmNDJhYjdmMDVjOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-09-23T11:34:49Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-09-23T11:34:49Z"}, "message": "Use cbranch patterns when available\n\nFrom-SVN: r29613", "tree": {"sha": "f3957a52a53f08158be8aba1c10f20bd084118d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3957a52a53f08158be8aba1c10f20bd084118d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c0290eaac40944ba6baed8323b74f42ab7f05c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0290eaac40944ba6baed8323b74f42ab7f05c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c0290eaac40944ba6baed8323b74f42ab7f05c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0290eaac40944ba6baed8323b74f42ab7f05c9/comments", "author": null, "committer": null, "parents": [{"sha": "708d3415cfbb4258becce97364825ee8a6c2b957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708d3415cfbb4258becce97364825ee8a6c2b957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708d3415cfbb4258becce97364825ee8a6c2b957"}], "stats": {"total": 178, "additions": 118, "deletions": 60}, "files": [{"sha": "912eee50da6e37a2294499292c2fc8eca5fd4006", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c0290eaac40944ba6baed8323b74f42ab7f05c9", "patch": "@@ -1,3 +1,27 @@\n+Thu Sep 23 11:15:36 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* expmed.c (do_cmp_and_jump): Pass ccp_jump to can_compare_p.\n+\t* expr.c (expand_expr): Likewise.\n+\t(do_jump): Likewise.\n+\t(do_store_flag): Pass ccp_store_flag to can_compare_p.\n+\t* expr.h (enum optab_index): Add cbranch, cmov, cstore optabs and\n+\taccessor macros.\n+\t(enum can_compare_purpose): New.\n+\t(can_compare_p): Adjust prototype.\n+\t(prepare_cmp_insn, prepare_operand): Declare.\n+\t* genopinit.c (optabs): Add cbranch_optab, cmov_optab, cstore_optab.\n+\t* optabs.c (cmp_available_p): Deleted.\n+\t(expand_abs): Pass ccp_jump to can_compare_p.\n+\t(can_compare_p): New arg PURPOSE.  Check for combined optabs.\n+\t(prepare_cmp_insn): No longer static.  Add arg PURPOSE.\n+\tCall can_compare_p rather than cmp_available_p.\n+\t(prepare_operand): No longer static.\n+\t(emit_cmp_and_jump_insn): Check for and use cbranch patterns.\n+\t(emit_cmp_and_jump_insns): Pass ccp_jump to prepare_cmp_insn.\n+\t(expand_float): Fix a slightly broken emit_cmp_insn/emit_jump_insn\n+\tsequence to use emit_cmp_and_jump_insns.\n+\t(init_optabs): Initialize cbranch_optab, cmov_optab, cstore_optab.\n+\n Wed Sep 22 17:58:01 1999  Stan Cox  <scox@cygnus.com>\n \n \t* mips.h (GO_IF_LEGITIMATE_ADDRESS): Don't accept large"}, {"sha": "291d766f7034d0690da9f9969fc94cec3856912d", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1c0290eaac40944ba6baed8323b74f42ab7f05c9", "patch": "@@ -4548,7 +4548,7 @@ do_cmp_and_jump (arg1, arg2, op, mode, label)\n   /* If this mode is an integer too wide to compare properly,\n      compare word by word.  Rely on cse to optimize constant cases.  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n+  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode, ccp_jump))\n     {\n       rtx label2 = gen_label_rtx ();\n "}, {"sha": "568460bebbb481b09a77f708e877e0b3e4487d32", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1c0290eaac40944ba6baed8323b74f42ab7f05c9", "patch": "@@ -7388,7 +7388,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* If this mode is an integer too wide to compare properly,\n \t compare word by word.  Rely on cse to optimize constant cases.  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n+      if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode, ccp_jump))\n \t{\n \t  if (code == MAX_EXPR)\n \t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type),\n@@ -8938,7 +8938,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n \n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-\t\t && !can_compare_p (TYPE_MODE (inner_type)))\n+\t\t && !can_compare_p (TYPE_MODE (inner_type), ccp_jump))\n \t  do_jump_by_parts_equality (exp, if_false_label, if_true_label);\n \telse\n \t  do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label);\n@@ -8978,44 +8978,44 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n \n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-\t\t && !can_compare_p (TYPE_MODE (inner_type)))\n+\t\t && !can_compare_p (TYPE_MODE (inner_type), ccp_jump))\n \t  do_jump_by_parts_equality (exp, if_true_label, if_false_label);\n \telse\n \t  do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label);\n \tbreak;\n       }\n \n     case LT_EXPR:\n-      if ((GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t   == MODE_INT)\n-\t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && ! can_compare_p (mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 1, if_false_label, if_true_label);\n       else\n \tdo_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label);\n       break;\n \n     case LE_EXPR:\n-      if ((GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t   == MODE_INT)\n-\t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && ! can_compare_p (mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 0, if_true_label, if_false_label);\n       else\n \tdo_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label);\n       break;\n \n     case GT_EXPR:\n-      if ((GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t   == MODE_INT)\n-\t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && ! can_compare_p (mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 0, if_false_label, if_true_label);\n       else\n \tdo_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label);\n       break;\n \n     case GE_EXPR:\n-      if ((GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t   == MODE_INT)\n-\t  && !can_compare_p (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n+      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && ! can_compare_p (mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 1, if_true_label, if_false_label);\n       else\n \tdo_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);\n@@ -9044,7 +9044,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t    emit_jump (target);\n \t}\n       else if (GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT\n-\t       && ! can_compare_p (GET_MODE (temp)))\n+\t       && ! can_compare_p (GET_MODE (temp), ccp_jump))\n \t/* Note swapping the labels gives us not-equal.  */\n \tdo_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n       else if (GET_MODE (temp) != VOIDmode)\n@@ -9658,7 +9658,7 @@ do_store_flag (exp, target, mode, only_cheap)\n     }\n \n   /* Now see if we are likely to be able to do this.  Return if not.  */\n-  if (! can_compare_p (operand_mode))\n+  if (! can_compare_p (operand_mode, ccp_store_flag))\n     return 0;\n   icode = setcc_gen_code[(int) code];\n   if (icode == CODE_FOR_nothing"}, {"sha": "52f743b2f3c8746368be5e15cd778851d75d9c41", "filename": "gcc/expr.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1c0290eaac40944ba6baed8323b74f42ab7f05c9", "patch": "@@ -377,6 +377,11 @@ enum optab_index\n   /* String length */\n   OTI_strlen,\n \n+  /* Combined compare & jump/store flags/move operations.  */\n+  OTI_cbranch,\n+  OTI_cmov,\n+  OTI_cstore,\n+    \n   OTI_MAX\n };\n \n@@ -427,6 +432,10 @@ extern optab optab_table[OTI_MAX];\n \n #define strlen_optab (optab_table[OTI_strlen])\n \n+#define cbranch_optab (optab_table[OTI_cbranch])\n+#define cmov_optab (optab_table[OTI_cmov])\n+#define cstore_optab (optab_table[OTI_cstore])\n+\n /* Tables of patterns for extending one integer mode to another.  */\n extern enum insn_code extendtab[MAX_MACHINE_MODE][MAX_MACHINE_MODE][2];\n \n@@ -778,9 +787,24 @@ extern void emit_cmp_insn PROTO((rtx, rtx, enum rtx_code, rtx,\n extern void emit_cmp_and_jump_insns PROTO((rtx, rtx, enum rtx_code, rtx,\n \t\t\t\t\t   enum machine_mode, int, int, rtx));\n \n+/* The various uses that a comparison can have; used by can_compare_p:\n+   jumps, conditional moves, store flag operations.  */\n+enum can_compare_purpose\n+{\n+  ccp_jump,\n+  ccp_cmov,\n+  ccp_store_flag\n+};\n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n-extern int can_compare_p PROTO((enum machine_mode));\n+extern int can_compare_p PROTO((enum machine_mode, enum can_compare_purpose));\n+\n+extern void prepare_cmp_insn PROTO((rtx *, rtx *, enum rtx_code *, rtx,\n+\t\t\t\t    enum machine_mode *, int *, int,\n+\t\t\t\t    enum can_compare_purpose));\n+\n+extern rtx prepare_operand PROTO((int, rtx, int, enum machine_mode,\n+\t\t\t\t  enum machine_mode, int));\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump PROTO((rtx));"}, {"sha": "81366f02c3888613eba4dbdaf48a198ee8c2eed7", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=1c0290eaac40944ba6baed8323b74f42ab7f05c9", "patch": "@@ -113,6 +113,9 @@ const char * const optabs[] =\n   \"bcc_gen_fctn[(int) %C] = gen_%(b%c%)\",\n   \"setcc_gen_code[(int) %C] = CODE_FOR_%(s%c%)\",\n   \"movcc_gen_code[(int) %A] = CODE_FOR_%(mov%acc%)\",\n+  \"cbranch_optab->handlers[(int) %A].insn_code = CODE_FOR_%(cbranch%a4%)\",\n+  \"cmov_optab->handlers[(int) %A].insn_code = CODE_FOR_%(cmov%a6%)\",\n+  \"cstore_optab->handlers[(int) %A].insn_code = CODE_FOR_%(cstore%a4%)\",\n   \"reload_in_optab[(int) %A] = CODE_FOR_%(reload_in%a%)\",\n   \"reload_out_optab[(int) %A] = CODE_FOR_%(reload_out%a%)\",\n   \"movstr_optab[(int) %A] = CODE_FOR_%(movstr%a%)\","}, {"sha": "b424f1b931ee2287e70068787b03583201db0332", "filename": "gcc/optabs.c", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0290eaac40944ba6baed8323b74f42ab7f05c9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1c0290eaac40944ba6baed8323b74f42ab7f05c9", "patch": "@@ -105,13 +105,8 @@ static void init_floating_libfuncs PROTO((optab, const char *, int));\n #ifdef HAVE_conditional_trap\n static void init_traps PROTO((void));\n #endif\n-static int cmp_available_p PROTO((enum machine_mode, int));\n static void emit_cmp_and_jump_insn_1 PROTO((rtx, rtx, enum machine_mode,\n \t\t\t\t\t    enum rtx_code, int, rtx));\n-static void prepare_cmp_insn PROTO((rtx *, rtx *, enum rtx_code *, rtx,\n-\t\t\t\t    enum machine_mode *, int *, int));\n-static rtx prepare_operand PROTO((int, rtx, int, enum machine_mode,\n-\t\t\t\t  enum machine_mode, int));\n static void prepare_float_lib_cmp PROTO((rtx *, rtx *, enum rtx_code *,\n \t\t\t\t\t enum machine_mode *, int *));\n \f\n@@ -2309,7 +2304,7 @@ expand_abs (mode, op0, target, safe)\n \n   /* If this mode is an integer too wide to compare properly,\n      compare word by word.  Rely on CSE to optimize constant cases.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n+  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode, ccp_jump))\n     do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n \t\t\t\t  NULL_RTX, op1);\n   else\n@@ -2823,22 +2818,32 @@ emit_0_to_1_insn (x)\n   emit_move_insn (x, const1_rtx);\n }\n \n-/* Nonzero if we can perform a comparison of mode MODE for a conditional jump\n-   straightforwardly.  */\n-\n-static int\n-cmp_available_p (mode, can_use_tst_p)\n+/* Nonzero if we can perform a comparison of mode MODE straightforwardly.\n+   If FOR_JUMP is nonzero, we will be generating a jump based on this\n+   comparison, otherwise a store-flags operation.  */\n+  \n+int\n+can_compare_p (mode, purpose)\n      enum machine_mode mode;\n-     int can_use_tst_p;\n+     enum can_compare_purpose purpose;\n {\n   do\n     {\n-      if (cmp_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing\n-\t  || (can_use_tst_p\n-\t      && tst_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing))\n+      if (cmp_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n \treturn 1;\n+      if (purpose == ccp_jump\n+\t  && cbranch_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+\treturn 1;\n+      if (purpose == ccp_cmov\n+\t  && cmov_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+\treturn 1;\n+      if (purpose == ccp_store_flag\n+\t  && cstore_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+\treturn 1;\n+\n       mode = GET_MODE_WIDER_MODE (mode);\n-    } while (mode != VOIDmode);\n+    }\n+  while (mode != VOIDmode);\n \n   return 0;\n }\n@@ -2860,14 +2865,16 @@ cmp_available_p (mode, can_use_tst_p)\n    The values which are passed in through pointers can be modified; the caller\n    should perform the comparison on the modified values.  */\n \n-static void\n-prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n+void\n+prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n+\t\t  purpose)\n      rtx *px, *py;\n      enum rtx_code *pcomparison;\n      rtx size;\n      enum machine_mode *pmode;\n      int *punsignedp;\n      int align;\n+     enum can_compare_purpose purpose;\n {\n   enum machine_mode mode = *pmode;\n   rtx x = *px, y = *py;\n@@ -2988,7 +2995,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n \n   *px = x;\n   *py = y;\n-  if (cmp_available_p (mode, y == CONST0_RTX (mode)))\n+  if (can_compare_p (mode, purpose))\n     return;\n \n   /* Handle a lib call just for the mode we are using.  */\n@@ -3032,7 +3039,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n    to be used for operand OPNUM of the insn, is converted from mode MODE to\n    WIDER_MODE (UNSIGNEDP determines whether it is a unsigned conversion), and\n    that it is accepted by the operand predicate.  Return the new value.  */\n-static rtx\n+rtx\n prepare_operand (icode, x, opnum, mode, wider_mode, unsignedp)\n      int icode;\n      rtx x;\n@@ -3074,6 +3081,20 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n       enum insn_code icode;\n       PUT_MODE (test, wider_mode);\n \n+      if (label)\n+\t{\t  \n+\t  icode = cbranch_optab->handlers[(int)wider_mode].insn_code;\n+\t  \n+\t  if (icode != CODE_FOR_nothing\n+\t      && (*insn_data[icode].operand[0].predicate) (test, wider_mode))\n+\t    {\n+\t      x = prepare_operand (icode, x, 1, mode, wider_mode, unsignedp);\n+\t      y = prepare_operand (icode, y, 2, mode, wider_mode, unsignedp);\n+\t      emit_jump_insn (GEN_FCN (icode) (test, x, y, label));\n+\t      return;\n+\t    }\n+\t}\n+\n       /* Handle some compares against zero.  */\n       icode = (int) tst_optab->handlers[(int) wider_mode].insn_code;\n       if (y == CONST0_RTX (mode) && icode != CODE_FOR_nothing)\n@@ -3164,7 +3185,8 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n   emit_queue ();\n   if (unsignedp)\n     comparison = unsigned_condition (comparison);\n-  prepare_cmp_insn (&op0, &op1, &comparison, size, &mode, &unsignedp, align);\n+  prepare_cmp_insn (&op0, &op1, &comparison, size, &mode, &unsignedp, align,\n+\t\t    ccp_jump);\n   emit_cmp_and_jump_insn_1 (op0, op1, mode, comparison, unsignedp, label);\n }\n \n@@ -3180,24 +3202,6 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n {\n   emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, 0);\n }\n-\n-\n-/* Nonzero if a compare of mode MODE can be done straightforwardly\n-   (without splitting it into pieces).  */\n-\n-int\n-can_compare_p (mode)\n-     enum machine_mode mode;\n-{\n-  do\n-    {\n-      if (cmp_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n-\treturn 1;\n-      mode = GET_MODE_WIDER_MODE (mode);\n-    } while (mode != VOIDmode);\n-\n-  return 0;\n-}\n \f\n /* Emit a library call comparison between floating point X and Y.\n    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */\n@@ -3876,8 +3880,8 @@ expand_float (to, from, unsignedp)\n \t      do_pending_stack_adjust ();\n \n \t      /* Test whether the sign bit is set.  */\n-\t      emit_cmp_insn (from, const0_rtx, GE, NULL_RTX, imode, 0, 0);\n-\t      emit_jump_insn (gen_blt (neglabel));\n+\t      emit_cmp_and_jump_insns (from, const0_rtx, LT, NULL_RTX, imode,\n+\t\t\t\t       0, 0, neglabel);\n \n \t      /* The sign bit is not set.  Convert as signed.  */\n \t      expand_float (target, from, 0);\n@@ -4467,6 +4471,9 @@ init_optabs ()\n   sin_optab = init_optab (UNKNOWN);\n   cos_optab = init_optab (UNKNOWN);\n   strlen_optab = init_optab (UNKNOWN);\n+  cbranch_optab = init_optab (UNKNOWN);\n+  cmov_optab = init_optab (UNKNOWN);\n+  cstore_optab = init_optab (UNKNOWN);\n \n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {"}]}