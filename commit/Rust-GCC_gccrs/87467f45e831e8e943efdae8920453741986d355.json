{"sha": "87467f45e831e8e943efdae8920453741986d355", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc0NjdmNDVlODMxZThlOTQzZWZkYWU4OTIwNDUzNzQxOTg2ZDM1NQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-06-28T16:20:00Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-06-28T16:24:34Z"}, "message": "ipa-sra: Restructure how cloning and call redirection communicate (PR 93385)\n\nI was asked by Richi to split my fix for PR 93385 for easier review\ninto IPA-SRA materialization refactoring and the actual DCE addition.\nFortunately it was mostly natural except for a temporary weird\ncondition in ipa_param_body_adjustments::modify_call_stmt.\nAdditionally.  In addition to the patch I posted previously, this one\nalso deallocated the newly added summary in toplev::finalize and fixes\na mistakenly uninitialized field.\n\nThis is the first part which basically replaces performed_splits in\nclone_info and the code which generates it, keeps it up-to-date and\nconsumes it with new edge summaries which are much nicer.  It simply\ncontains 1) a mapping from the original argument indices to the actual\nindices in the call statement as it is now, 2) information needed to\nidentify arguments representing pass-through IPA-SRA splits with which\nhave been added to the call arguments in place of an original\nargument/reference and 3) a delta to the index where va_args may start\n- so basically directly all the information that the consumer of\nperformed_splits had to compute and we also do not need the weird\ndummy declarations.\n\nThe main disadvantage is that the information has to be created (and\nkept up-to-date) for all call graph edges associated with the given\nstatement from all clones (including inline clones) of the clone where\nsplitting or removal happened first.  But all of this happens during\nclone materialization so the only effect on WPA memory consumption is\nthe removal of a pointer from clone_info.\n\nThe statement modification code also has to know the statement from\nthe original function in order to be able to locate the edge summaries\nwhich at this point are still keyed to these.  However, the code is\nalready quite heavily dependant on how things are structured in\ntree-inline.c and in order to fix bugs like these it probably has to\nbe.\n\nThe subsequent patch needs this new information to be able to remove\narguments from calls during materialization and communicate this\ninformation to the call redirection.\n\ngcc/ChangeLog:\n\n2021-05-17  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* symtab-clones.h (clone_info): Removed member param_adjustments.\n\t* ipa-param-manipulation.h: Adjust initial comment to reflect how we\n\tdeal with pass-through splits now.\n\t(ipa_param_performed_split): Removed.\n\t(ipa_param_adjustments::modify_call): Adjusted parameters.\n\t(class ipa_param_body_adjustments): Adjusted parameters of\n\tregister_replacement, modify_gimple_stmt and modify_call_stmt.\n\t(ipa_verify_edge_has_no_modifications): Declare.\n\t(ipa_edge_modifications_finalize): Declare.\n\t* cgraph.c (cgraph_edge::redirect_call_stmt_to_callee): Remove\n\tperformed_splits processing, pas only edge to padjs->modify_call,\n\tcheck that call arguments were not modified if they should not have\n\tbeen.\n\t* cgraphclones.c (cgraph_node::create_clone): Do not copy performed\n\tsplits.\n\t* ipa-param-manipulation.c (struct pass_through_split_map): New type.\n\t(ipa_edge_modification_info): Likewise.\n\t(ipa_edge_modification_sum): Likewise.\n\t(ipa_edge_modifications): New edge summary.\n\t(ipa_verify_edge_has_no_modifications): New function.\n\t(transitive_split_p): Removed.\n\t(transitive_split_map): Likewise.\n\t(init_transitive_splits): Likewise.\n\t(ipa_param_adjustments::modify_call): Adjusted to use the new edge\n\tsummary instead of performed_splits.\n\t(ipa_param_body_adjustments::register_replacement): Drop dummy\n\tparameter, set base_index of the created ipa_param_body_replacement.\n\t(phi_arg_will_live_p): New function.\n\t(ipa_param_body_adjustments::common_initialization): Do not create\n\tIPA_SRA dummy decls.\n\t(simple_tree_swap_info): Removed.\n\t(remap_split_decl_to_dummy): Likewise.\n\t(record_argument_state_1): New function.\n\t(record_argument_state): Likewise.\n\t(ipa_param_body_adjustments::modify_call_stmt): New parameter\n\torig_stmt.  Do not work with dummy decls, save necessary info about\n\tchanges to ipa_edge_modifications.\n\t(ipa_param_body_adjustments::modify_gimple_stmt): New parameter\n\torig_stmt, pass it to modify_call_stmt.\n\t(ipa_param_body_adjustments::modify_cfun_body): Adjust call to\n\tmodify_gimple_stmt.\n\t(ipa_edge_modifications_finalize): New function.\n\t* tree-inline.c (remap_gimple_stmt): Pass original statement to\n\tmodify_gimple_stmt.\n\t(copy_phis_for_bb): Do not copy dead PHI nodes.\n\t(expand_call_inline): Do not remap performed_splits.\n\t(update_clone_info): Likewise.\n\t* toplev.c: Include ipa-param-manipulation.h.\n\t(toplev::finalize): Call ipa_edge_modifications_finalize.", "tree": {"sha": "70576b14c034cef4781e3657ce6101805a303c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70576b14c034cef4781e3657ce6101805a303c15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87467f45e831e8e943efdae8920453741986d355", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmDZ98IACgkQv2PBvD+k\nNUDizRAAiWQZy5RJIsXgZBraN9vOuOZq/Ujf7GikFoh/N/bUQ8JkaFzH25b9+M4r\neEn4fEVOVlCDcm5fHr2zfhZe1+Lr5Nuzh9fdAxCce1HJTe/m182QBh/NpIb/tGS4\nyW7L+bK1CR0Q+Z/wUxFWxxlrvpYA3yQxE9WcUu4fg7zpMTvRzN+eCWWmxwLCbLVb\n8xtN0FHdH5sASbC0N2QHBZ6MWz9qqDE/2GUZtEnBJ/p0n1Gcj5TrjdadtQDnCsX1\nMoR0cEHIaqu+fVZdjz4Olk8yKxDuB12W63XVIZAEQo3IIS3j0ZryMG2FHTtYuEyh\nO6Jc/iWU4zPUT81/moOBac07v96ZZx361asBN3ooPRNsvKdeQrOY6AOfhHtbSTwH\nwuhziqeDfXMsM+VBz1K+QegheT7xMWxJCt6CExOPFkZKXDRhknUH6WtzNvany3jo\n1U/OMsTaSKrqtQgL+y0U8JGeOQsY8cGoqJtwxiJm3K1ujURlD7n+HHxxNZWDvt8l\nr22PZ2EuHbWF7v7VBk9CFIQXMsx/5R+YyxS7d05WjAWkfTlrva9PImP1aVux1Ueg\nLIzDflXZdUAwFZlUu7AqBPK5HXDaDZRmNfYfK8+nmRxrua3I4u5egL2U6VPs4/5C\nvffxKJn7w1z5gMKH2ArgnLL9QgkfIRIym54NryvYTX9ZeN5Pjn8=\n=Wdle\n-----END PGP SIGNATURE-----", "payload": "tree 70576b14c034cef4781e3657ce6101805a303c15\nparent 084635aa80daa45403aebd86712b2c61779c4173\nauthor Martin Jambor <mjambor@suse.cz> 1624897200 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1624897474 +0200\n\nipa-sra: Restructure how cloning and call redirection communicate (PR 93385)\n\nI was asked by Richi to split my fix for PR 93385 for easier review\ninto IPA-SRA materialization refactoring and the actual DCE addition.\nFortunately it was mostly natural except for a temporary weird\ncondition in ipa_param_body_adjustments::modify_call_stmt.\nAdditionally.  In addition to the patch I posted previously, this one\nalso deallocated the newly added summary in toplev::finalize and fixes\na mistakenly uninitialized field.\n\nThis is the first part which basically replaces performed_splits in\nclone_info and the code which generates it, keeps it up-to-date and\nconsumes it with new edge summaries which are much nicer.  It simply\ncontains 1) a mapping from the original argument indices to the actual\nindices in the call statement as it is now, 2) information needed to\nidentify arguments representing pass-through IPA-SRA splits with which\nhave been added to the call arguments in place of an original\nargument/reference and 3) a delta to the index where va_args may start\n- so basically directly all the information that the consumer of\nperformed_splits had to compute and we also do not need the weird\ndummy declarations.\n\nThe main disadvantage is that the information has to be created (and\nkept up-to-date) for all call graph edges associated with the given\nstatement from all clones (including inline clones) of the clone where\nsplitting or removal happened first.  But all of this happens during\nclone materialization so the only effect on WPA memory consumption is\nthe removal of a pointer from clone_info.\n\nThe statement modification code also has to know the statement from\nthe original function in order to be able to locate the edge summaries\nwhich at this point are still keyed to these.  However, the code is\nalready quite heavily dependant on how things are structured in\ntree-inline.c and in order to fix bugs like these it probably has to\nbe.\n\nThe subsequent patch needs this new information to be able to remove\narguments from calls during materialization and communicate this\ninformation to the call redirection.\n\ngcc/ChangeLog:\n\n2021-05-17  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* symtab-clones.h (clone_info): Removed member param_adjustments.\n\t* ipa-param-manipulation.h: Adjust initial comment to reflect how we\n\tdeal with pass-through splits now.\n\t(ipa_param_performed_split): Removed.\n\t(ipa_param_adjustments::modify_call): Adjusted parameters.\n\t(class ipa_param_body_adjustments): Adjusted parameters of\n\tregister_replacement, modify_gimple_stmt and modify_call_stmt.\n\t(ipa_verify_edge_has_no_modifications): Declare.\n\t(ipa_edge_modifications_finalize): Declare.\n\t* cgraph.c (cgraph_edge::redirect_call_stmt_to_callee): Remove\n\tperformed_splits processing, pas only edge to padjs->modify_call,\n\tcheck that call arguments were not modified if they should not have\n\tbeen.\n\t* cgraphclones.c (cgraph_node::create_clone): Do not copy performed\n\tsplits.\n\t* ipa-param-manipulation.c (struct pass_through_split_map): New type.\n\t(ipa_edge_modification_info): Likewise.\n\t(ipa_edge_modification_sum): Likewise.\n\t(ipa_edge_modifications): New edge summary.\n\t(ipa_verify_edge_has_no_modifications): New function.\n\t(transitive_split_p): Removed.\n\t(transitive_split_map): Likewise.\n\t(init_transitive_splits): Likewise.\n\t(ipa_param_adjustments::modify_call): Adjusted to use the new edge\n\tsummary instead of performed_splits.\n\t(ipa_param_body_adjustments::register_replacement): Drop dummy\n\tparameter, set base_index of the created ipa_param_body_replacement.\n\t(phi_arg_will_live_p): New function.\n\t(ipa_param_body_adjustments::common_initialization): Do not create\n\tIPA_SRA dummy decls.\n\t(simple_tree_swap_info): Removed.\n\t(remap_split_decl_to_dummy): Likewise.\n\t(record_argument_state_1): New function.\n\t(record_argument_state): Likewise.\n\t(ipa_param_body_adjustments::modify_call_stmt): New parameter\n\torig_stmt.  Do not work with dummy decls, save necessary info about\n\tchanges to ipa_edge_modifications.\n\t(ipa_param_body_adjustments::modify_gimple_stmt): New parameter\n\torig_stmt, pass it to modify_call_stmt.\n\t(ipa_param_body_adjustments::modify_cfun_body): Adjust call to\n\tmodify_gimple_stmt.\n\t(ipa_edge_modifications_finalize): New function.\n\t* tree-inline.c (remap_gimple_stmt): Pass original statement to\n\tmodify_gimple_stmt.\n\t(copy_phis_for_bb): Do not copy dead PHI nodes.\n\t(expand_call_inline): Do not remap performed_splits.\n\t(update_clone_info): Likewise.\n\t* toplev.c: Include ipa-param-manipulation.h.\n\t(toplev::finalize): Call ipa_edge_modifications_finalize.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87467f45e831e8e943efdae8920453741986d355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87467f45e831e8e943efdae8920453741986d355", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87467f45e831e8e943efdae8920453741986d355/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "084635aa80daa45403aebd86712b2c61779c4173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084635aa80daa45403aebd86712b2c61779c4173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084635aa80daa45403aebd86712b2c61779c4173"}], "stats": {"total": 1012, "additions": 476, "deletions": 536}, "files": [{"sha": "8f3af003f2af96422585390c5e7adf55f52ec54b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -1506,27 +1506,13 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n     }\n \n   clone_info *callee_info = clone_info::get (e->callee);\n-  clone_info *caller_info = clone_info::get (e->caller);\n-\n   if (symtab->dump_file)\n     {\n       fprintf (symtab->dump_file, \"updating call of %s -> %s: \",\n \t       e->caller->dump_name (), e->callee->dump_name ());\n       print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n       if (callee_info && callee_info->param_adjustments)\n \tcallee_info->param_adjustments->dump (symtab->dump_file);\n-      unsigned performed_len\n-\t= caller_info ? vec_safe_length (caller_info->performed_splits) : 0;\n-      if (performed_len > 0)\n-\tfprintf (symtab->dump_file, \"Performed splits records:\\n\");\n-      for (unsigned i = 0; i < performed_len; i++)\n-\t{\n-\t  ipa_param_performed_split *sm\n-\t    = &(*caller_info->performed_splits)[i];\n-\t  print_node_brief (symtab->dump_file, \"  dummy_decl: \", sm->dummy_decl,\n-\t\t\t    TDF_UID);\n-\t  fprintf (symtab->dump_file, \", unit_offset: %u\\n\", sm->unit_offset);\n-\t}\n     }\n \n   if (ipa_param_adjustments *padjs\n@@ -1541,10 +1527,7 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \tremove_stmt_from_eh_lp (e->call_stmt);\n \n       tree old_fntype = gimple_call_fntype (e->call_stmt);\n-      new_stmt = padjs->modify_call (e->call_stmt,\n-\t\t\t\t     caller_info\n-\t\t\t\t     ? caller_info->performed_splits : NULL,\n-\t\t\t\t     e->callee->decl, false);\n+      new_stmt = padjs->modify_call (e, false);\n       cgraph_node *origin = e->callee;\n       while (origin->clone_of)\n \torigin = origin->clone_of;\n@@ -1564,6 +1547,9 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n     }\n   else\n     {\n+      if (flag_checking\n+\t  && !fndecl_built_in_p (e->callee->decl, BUILT_IN_UNREACHABLE))\n+\tipa_verify_edge_has_no_modifications (e);\n       new_stmt = e->call_stmt;\n       gimple_call_set_fndecl (new_stmt, e->callee->decl);\n       update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), new_stmt);"}, {"sha": "7e463acab91101dd9708ee65633b2337168cedef", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -414,9 +414,6 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   else if (info && info->param_adjustments)\n     clone_info::get_create (new_node)->param_adjustments\n \t = info->param_adjustments;\n-  if (info && info->performed_splits)\n-    clone_info::get_create (new_node)->performed_splits\n-\t = vec_safe_copy (info->performed_splits);\n   new_node->split_part = split_part;\n \n   FOR_EACH_VEC_ELT (redirect_callers, i, e)"}, {"sha": "6a423391d2f3440c24007ec64a5fe886408c75fd", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 436, "deletions": 349, "changes": 785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -62,6 +62,80 @@ static const char *ipa_param_op_names[IPA_PARAM_PREFIX_COUNT]\n      \"IPA_PARAM_OP_NEW\",\n      \"IPA_PARAM_OP_SPLIT\"};\n \n+/* Structure to hold declarations representing pass-through IPA-SRA splits.  In\n+   essence, it tells new index for a combination of original index and\n+   offset.  */\n+\n+struct pass_through_split_map\n+{\n+  /* Original argument index.  */\n+  unsigned base_index;\n+  /* Offset of the split part in the original argument.  */\n+  unsigned unit_offset;\n+  /* Index of the split part in the call statement - where clone\n+     materialization put it.  */\n+  int new_index;\n+};\n+\n+/* Information about some call statements that needs to be conveyed from clone\n+   materialization to edge redirection. */\n+\n+class ipa_edge_modification_info\n+{\n+ public:\n+  ipa_edge_modification_info ()\n+    {}\n+\n+  /* Mapping of original argument indices to where those arguments sit in the\n+     call statement now or to a negative index if they were removed.  */\n+  auto_vec<int> index_map;\n+  /* Information about ISRA replacements put into the call statement at the\n+     clone materialization stages.  */\n+  auto_vec<pass_through_split_map> pass_through_map;\n+  /* Necessary adjustment to ipa_param_adjustments::m_always_copy_start when\n+     redirecting the call.  */\n+  int always_copy_delta = 0;\n+};\n+\n+/* Class for storing and retrieving summaries about cal statement\n+   modifications.  */\n+\n+class ipa_edge_modification_sum\n+  : public call_summary <ipa_edge_modification_info *>\n+{\n+ public:\n+  ipa_edge_modification_sum (symbol_table *table)\n+    : call_summary<ipa_edge_modification_info *> (table)\n+  {\n+  }\n+\n+  /* Hook that is called by summary when an edge is duplicated.  */\n+\n+  virtual void duplicate (cgraph_edge *,\n+\t\t\t  cgraph_edge *,\n+\t\t\t  ipa_edge_modification_info *old_info,\n+\t\t\t  ipa_edge_modification_info *new_info)\n+  {\n+    new_info->index_map.safe_splice (old_info->index_map);\n+    new_info->pass_through_map.safe_splice (old_info->pass_through_map);\n+    new_info->always_copy_delta = old_info->always_copy_delta;\n+  }\n+};\n+\n+/* Call summary to store information about edges which have had their arguments\n+   partially modified already.  */\n+\n+static ipa_edge_modification_sum *ipa_edge_modifications;\n+\n+/* Fail compilation if CS has any summary associated with it in\n+   ipa_edge_modifications.  */\n+\n+DEBUG_FUNCTION void\n+ipa_verify_edge_has_no_modifications (cgraph_edge *cs)\n+{\n+  gcc_assert (!ipa_edge_modifications || !ipa_edge_modifications->get (cs));\n+}\n+\n /* Fill an empty vector ARGS with PARM_DECLs representing formal parameters of\n    FNDECL.  The function should not be called during LTO WPA phase except for\n    thunks (or functions with bodies streamed in). */\n@@ -459,147 +533,46 @@ isra_get_ref_base_and_offset (tree expr, tree *base_p, unsigned *unit_offset_p)\n   return true;\n }\n \n-/* Return true if EXPR describes a transitive split (i.e. one that happened for\n-   both the caller and the callee) as recorded in PERFORMED_SPLITS.  In that\n-   case, store index of the respective record in PERFORMED_SPLITS into\n-   *SM_IDX_P and the unit offset from all handled components in EXPR into\n-   *UNIT_OFFSET_P.  */\n+/* Modify actual arguments of a function call in statement currently belonging\n+   to CS, and make it call CS->callee->decl.  Return the new statement that\n+   replaced the old one.  When invoked, cfun and current_function_decl have to\n+   be set to the caller.  */\n \n-static bool\n-transitive_split_p (vec<ipa_param_performed_split, va_gc> *performed_splits,\n-\t\t    tree expr, unsigned *sm_idx_p, unsigned *unit_offset_p)\n-{\n-  tree base;\n-  if (!isra_get_ref_base_and_offset (expr, &base, unit_offset_p))\n-    return false;\n-\n-  if (TREE_CODE (base) == SSA_NAME)\n-    {\n-      base = SSA_NAME_VAR (base);\n-      if (!base)\n-\treturn false;\n-    }\n-\n-  unsigned len = vec_safe_length (performed_splits);\n-  for (unsigned i = 0 ; i < len; i++)\n-    {\n-      ipa_param_performed_split *sm = &(*performed_splits)[i];\n-      if (sm->dummy_decl == base)\n-\t{\n-\t  *sm_idx_p = i;\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Structure to hold declarations representing transitive IPA-SRA splits.  In\n-   essence, if we need to pass UNIT_OFFSET of a parameter which originally has\n-   number BASE_INDEX, we should pass down REPL.  */\n-\n-struct transitive_split_map\n+gcall *\n+ipa_param_adjustments::modify_call (cgraph_edge *cs,\n+\t\t\t\t    bool update_references)\n {\n-  tree repl;\n-  unsigned base_index;\n-  unsigned unit_offset;\n-};\n-\n-/* If call STMT contains any parameters representing transitive splits as\n-   described by PERFORMED_SPLITS, return the number of extra parameters that\n-   were addded during clone materialization and fill in INDEX_MAP with adjusted\n-   indices of corresponding original parameters and TRANS_MAP with description\n-   of all transitive replacement descriptions.  Otherwise return zero. */\n+  gcall *stmt = cs->call_stmt;\n+  tree callee_decl = cs->callee->decl;\n \n-static unsigned\n-init_transitive_splits (vec<ipa_param_performed_split, va_gc> *performed_splits,\n-\t\t\tgcall *stmt, vec <unsigned> *index_map,\n-\t\t\tauto_vec <transitive_split_map> *trans_map)\n-{\n-  unsigned phony_arguments = 0;\n-  unsigned stmt_idx = 0, base_index = 0;\n-  unsigned nargs = gimple_call_num_args (stmt);\n-  while (stmt_idx < nargs)\n+  ipa_edge_modification_info *mod_info\n+    = ipa_edge_modifications ? ipa_edge_modifications->get (cs) : NULL;\n+  if (mod_info && symtab->dump_file)\n     {\n-      unsigned unit_offset_delta;\n-      tree base_arg = gimple_call_arg (stmt, stmt_idx);\n-\n-      if (phony_arguments > 0)\n-\tindex_map->safe_push (stmt_idx);\n-\n-      unsigned sm_idx;\n-      stmt_idx++;\n-      if (transitive_split_p (performed_splits, base_arg, &sm_idx,\n-\t\t\t      &unit_offset_delta))\n-\t{\n-\t  if (phony_arguments == 0)\n-\t    /* We have optimistically avoided constructing index_map do far but\n-\t       now it is clear it will be necessary, so let's create the easy\n-\t       bit we skipped until now.  */\n-\t    for (unsigned k = 0; k < stmt_idx; k++)\n-\t      index_map->safe_push (k);\n-\n-\t  tree dummy = (*performed_splits)[sm_idx].dummy_decl;\n-\t  for (unsigned j = sm_idx; j < performed_splits->length (); j++)\n-\t    {\n-\t      ipa_param_performed_split *caller_split\n-\t\t= &(*performed_splits)[j];\n-\t      if (caller_split->dummy_decl != dummy)\n-\t\tbreak;\n-\n-\t      tree arg = gimple_call_arg (stmt, stmt_idx);\n-\t      struct transitive_split_map tsm;\n-\t      tsm.repl = arg;\n-\t      tsm.base_index = base_index;\n-\t      if (caller_split->unit_offset >= unit_offset_delta)\n-\t\t{\n-\t\t  tsm.unit_offset\n-\t\t    = (caller_split->unit_offset - unit_offset_delta);\n-\t\t  trans_map->safe_push (tsm);\n-\t\t}\n-\n-\t      phony_arguments++;\n-\t      stmt_idx++;\n-\t    }\n-\t}\n-      base_index++;\n+      fprintf (symtab->dump_file, \"Information about pre-exiting \"\n+\t       \"modifications.\\n  Index map:\");\n+      unsigned idx_len = mod_info->index_map.length ();\n+      for (unsigned i = 0; i < idx_len; i++)\n+\tfprintf (symtab->dump_file, \" %i\", mod_info->index_map[i]);\n+      fprintf (symtab->dump_file, \"\\n  Pass-through split map: \");\n+      unsigned ptm_len = mod_info->pass_through_map.length ();\n+      for (unsigned i = 0; i < ptm_len; i++)\n+\tfprintf (symtab->dump_file,\n+\t\t \" (base_index: %u, offset: %u, new_index: %i)\",\n+\t\t mod_info->pass_through_map[i].base_index,\n+\t\t mod_info->pass_through_map[i].unit_offset,\n+\t\t mod_info->pass_through_map[i].new_index);\n+      fprintf (symtab->dump_file, \"\\n  Always-copy delta: %i\\n\",\n+\t       mod_info->always_copy_delta);\n     }\n-  return phony_arguments;\n-}\n \n-/* Modify actual arguments of a function call in statement STMT, assuming it\n-   calls CALLEE_DECL.  CALLER_ADJ must be the description of parameter\n-   adjustments of the caller or NULL if there are none.  Return the new\n-   statement that replaced the old one.  When invoked, cfun and\n-   current_function_decl have to be set to the caller.  */\n-\n-gcall *\n-ipa_param_adjustments::modify_call (gcall *stmt,\n-\t\t\t\t    vec<ipa_param_performed_split,\n-\t\t\t\t        va_gc> *performed_splits,\n-\t\t\t\t    tree callee_decl, bool update_references)\n-{\n   unsigned len = vec_safe_length (m_adj_params);\n   auto_vec<tree, 16> vargs (len);\n-  tree old_decl = gimple_call_fndecl (stmt);\n   unsigned old_nargs = gimple_call_num_args (stmt);\n+  unsigned orig_nargs = mod_info ? mod_info->index_map.length () : old_nargs;\n   auto_vec<bool, 16> kept (old_nargs);\n   kept.quick_grow_cleared (old_nargs);\n \n-  auto_vec <unsigned, 16> index_map;\n-  auto_vec <transitive_split_map> trans_map;\n-  bool transitive_remapping = false;\n-\n-  if (performed_splits)\n-    {\n-      unsigned removed = init_transitive_splits (performed_splits,\n-\t\t\t\t\t\t stmt, &index_map, &trans_map);\n-      if (removed > 0)\n-\t{\n-\t  transitive_remapping = true;\n-\t  old_nargs -= removed;\n-\t}\n-    }\n-\n   cgraph_node *current_node = cgraph_node::get (current_function_decl);\n   if (update_references)\n     current_node->remove_stmt_references (stmt);\n@@ -612,13 +585,16 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n       ipa_adjusted_param *apm = &(*m_adj_params)[i];\n       if (apm->op == IPA_PARAM_OP_COPY)\n \t{\n-\t  unsigned index = apm->base_index;\n-\t  if (index >= old_nargs)\n+\t  int index = apm->base_index;\n+\t  if ((unsigned) index >= orig_nargs)\n \t    /* Can happen if the original call has argument mismatch,\n \t       ignore.  */\n \t    continue;\n-\t  if (transitive_remapping)\n-\t    index = index_map[apm->base_index];\n+\t  if (mod_info)\n+\t    {\n+\t      index = mod_info->index_map[apm->base_index];\n+\t      gcc_assert (index >= 0);\n+\t    }\n \n \t  tree arg = gimple_call_arg (stmt, index);\n \n@@ -636,14 +612,17 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n \t materialization.  */\n       gcc_assert (apm->op == IPA_PARAM_OP_SPLIT);\n \n-      /* We have to handle transitive changes differently using the maps we\n-\t have created before.  So look into them first.  */\n+      /* We have to handle pass-through changes differently using the map\n+\t clone materialziation might have left behind.  */\n       tree repl = NULL_TREE;\n-      for (unsigned j = 0; j < trans_map.length (); j++)\n-\tif (trans_map[j].base_index == apm->base_index\n-\t    && trans_map[j].unit_offset == apm->unit_offset)\n+      unsigned ptm_len = mod_info ? mod_info->pass_through_map.length () : 0;\n+      for (unsigned j = 0; j < ptm_len; j++)\n+\tif (mod_info->pass_through_map[j].base_index == apm->base_index\n+\t    && mod_info->pass_through_map[j].unit_offset == apm->unit_offset)\n \t  {\n-\t    repl = trans_map[j].repl;\n+\t    int repl_idx = mod_info->pass_through_map[j].new_index;\n+\t    gcc_assert (repl_idx >= 0);\n+\t    repl = gimple_call_arg (stmt, repl_idx);\n \t    break;\n \t  }\n       if (repl)\n@@ -652,12 +631,15 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n \t  continue;\n \t}\n \n-      unsigned index = apm->base_index;\n-      if (index >= old_nargs)\n+      int index = apm->base_index;\n+      if ((unsigned) index >= orig_nargs)\n \t/* Can happen if the original call has argument mismatch, ignore.  */\n \tcontinue;\n-      if (transitive_remapping)\n-\tindex = index_map[apm->base_index];\n+      if (mod_info)\n+\t{\n+\t  index = mod_info->index_map[apm->base_index];\n+\t  gcc_assert (index >= 0);\n+\t}\n       tree base = gimple_call_arg (stmt, index);\n \n       /* We create a new parameter out of the value of the old one, we can\n@@ -773,15 +755,24 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n     }\n \n   if (m_always_copy_start >= 0)\n-    for (unsigned i = m_always_copy_start; i < old_nargs; i++)\n-      vargs.safe_push (gimple_call_arg (stmt, i));\n+    {\n+      int always_copy_start = m_always_copy_start;\n+      if (mod_info)\n+\t{\n+\t  always_copy_start += mod_info->always_copy_delta;\n+\t  gcc_assert (always_copy_start >= 0);\n+\t}\n+      for (unsigned i = always_copy_start; i < old_nargs; i++)\n+\tvargs.safe_push (gimple_call_arg (stmt, i));\n+    }\n \n   /* For optimized away parameters, add on the caller side\n      before the call\n      DEBUG D#X => parm_Y(D)\n      stmts and associate D#X with parm in decl_debug_args_lookup\n      vector to say for debug info that if parameter parm had been passed,\n      it would have value parm_Y(D).  */\n+  tree old_decl = gimple_call_fndecl (stmt);\n   if (MAY_HAVE_DEBUG_BIND_STMTS && old_decl && callee_decl)\n     {\n       vec<tree, va_gc> **debug_args = NULL;\n@@ -799,13 +790,17 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n \t{\n \t  if (!is_gimple_reg (old_parm) || kept[i])\n \t    continue;\n-\t  tree origin = DECL_ORIGIN (old_parm);\n \t  tree arg;\n-\t  if (transitive_remapping)\n-\t    arg = gimple_call_arg (stmt, index_map[i]);\n+\t  if (mod_info)\n+\t    {\n+\t      if (mod_info->index_map[i] < 0)\n+\t\tcontinue;\n+\t      arg = gimple_call_arg (stmt, mod_info->index_map[i]);\n+\t    }\n \t  else\n \t    arg = gimple_call_arg (stmt, i);\n \n+\t  tree origin = DECL_ORIGIN (old_parm);\n \t  if (!useless_type_conversion_p (TREE_TYPE (origin), TREE_TYPE (arg)))\n \t    {\n \t      if (!fold_convertible_p (TREE_TYPE (origin), arg))\n@@ -909,6 +904,9 @@ ipa_param_adjustments::modify_call (gcall *stmt,\n \tgsi_prev (&gsi);\n       }\n     while (gsi_stmt (gsi) != gsi_stmt (prev_gsi));\n+\n+  if (mod_info)\n+    ipa_edge_modifications->remove (cs);\n   return new_stmt;\n }\n \n@@ -931,21 +929,19 @@ ipa_param_adjustments::debug ()\n   dump (stderr);\n }\n \n-/* Register that REPLACEMENT should replace parameter described in APM and\n-   optionally as DUMMY to mark transitive splits across calls.  */\n+/* Register that REPLACEMENT should replace parameter described in APM.  */\n \n void\n ipa_param_body_adjustments::register_replacement (ipa_adjusted_param *apm,\n-\t\t\t\t\t\t  tree replacement,\n-\t\t\t\t\t\t  tree dummy)\n+\t\t\t\t\t\t  tree replacement)\n {\n   gcc_checking_assert (apm->op == IPA_PARAM_OP_SPLIT\n \t\t       || apm->op == IPA_PARAM_OP_NEW);\n   gcc_checking_assert (!apm->prev_clone_adjustment);\n   ipa_param_body_replacement psr;\n   psr.base = m_oparms[apm->prev_clone_index];\n   psr.repl = replacement;\n-  psr.dummy = dummy;\n+  psr.dummy = NULL_TREE;\n   psr.unit_offset = apm->unit_offset;\n   m_replacements.safe_push (psr);\n }\n@@ -1007,9 +1003,6 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n   auto_vec<bool, 16> kept;\n   kept.reserve_exact (m_oparms.length ());\n   kept.quick_grow_cleared (m_oparms.length ());\n-  auto_vec<tree, 16> isra_dummy_decls;\n-  isra_dummy_decls.reserve_exact (m_oparms.length ());\n-  isra_dummy_decls.quick_grow_cleared (m_oparms.length ());\n \n   unsigned adj_len = vec_safe_length (m_adj_params);\n   m_method2func = ((TREE_CODE (TREE_TYPE (m_fndecl)) == METHOD_TYPE)\n@@ -1055,35 +1048,7 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t  if (apm->op == IPA_PARAM_OP_SPLIT)\n \t    {\n \t      m_split_modifications_p = true;\n-\n-\t      if (m_id)\n-\t\t{\n-\t\t  tree dummy_decl;\n-\t\t  if (!isra_dummy_decls[prev_index])\n-\t\t    {\n-\t\t      dummy_decl = copy_decl_to_var (m_oparms[prev_index],\n-\t\t\t\t\t\t     m_id);\n-\t\t      /* Any attempt to remap this dummy in this particular\n-\t\t\t instance of clone materialization should yield\n-\t\t\t itself.  */\n-\t\t      insert_decl_map (m_id, dummy_decl, dummy_decl);\n-\n-\t\t      DECL_CHAIN (dummy_decl) = *vars;\n-\t\t      *vars = dummy_decl;\n-\t\t      isra_dummy_decls[prev_index] = dummy_decl;\n-\t\t    }\n-\t\t  else\n-\t\t    dummy_decl = isra_dummy_decls[prev_index];\n-\n-\t\t  register_replacement (apm, new_parm, dummy_decl);\n-\t\t  ipa_param_performed_split ps;\n-\t\t  ps.dummy_decl = dummy_decl;\n-\t\t  ps.unit_offset = apm->unit_offset;\n-\t\t  vec_safe_push (clone_info::get_create\n-\t\t\t\t   (m_id->dst_node)->performed_splits, ps);\n-\t\t}\n-\t      else\n-\t\tregister_replacement (apm, new_parm);\n+\t      register_replacement (apm, new_parm);\n \t    }\n         }\n       else\n@@ -1110,8 +1075,6 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t  {\n \t    if (!m_id->decl_map->get (m_oparms[i]))\n \t      {\n-\t\t/* TODO: Perhaps at least aggregate-type params could re-use\n-\t\t   their isra_dummy_decl here?  */\n \t\ttree var = copy_decl_to_var (m_oparms[i], m_id);\n \t\tinsert_decl_map (m_id, m_oparms[i], var);\n \t\t/* Declare this new variable.  */\n@@ -1502,220 +1465,329 @@ ipa_param_body_adjustments::modify_assignment (gimple *stmt,\n   return any;\n }\n \n-/* Data passed to remap_split_decl_to_dummy through walk_tree.  */\n-\n-struct simple_tree_swap_info\n-{\n-  /* Change FROM to TO.  */\n-  tree from, to;\n-  /* And set DONE to true when doing so.  */\n-  bool done;\n-};\n+/* Record information about what modifications to call arguments have already\n+   been done by clone materialization into a summary describing CS.  The\n+   information is stored in NEW_INDEX_MAP, NEW_PT_MAP and NEW_ALWAYS_COPY_DELTA\n+   and correspond to equivalent fields in ipa_edge_modification_info.  Return\n+   the edge summary.  */\n \n-/* Simple remapper to remap a split parameter to the same expression based on a\n-   special dummy decl so that edge redirections can detect transitive splitting\n-   and finish them.  */\n+static ipa_edge_modification_info *\n+record_argument_state_1 (cgraph_edge *cs, const vec<int> &new_index_map,\n+\t\t\t const vec<pass_through_split_map> &new_pt_map,\n+\t\t\t int new_always_copy_delta)\n \n-static tree\n-remap_split_decl_to_dummy (tree *tp, int *walk_subtrees, void *data)\n {\n-  tree t = *tp;\n+  ipa_edge_modification_info *sum = ipa_edge_modifications->get_create (cs);\n \n-  if (DECL_P (t) || TREE_CODE (t) == SSA_NAME)\n+  unsigned len = sum->pass_through_map.length ();\n+  for (unsigned i = 0; i < len; i++)\n     {\n-      struct simple_tree_swap_info *swapinfo\n-\t= (struct simple_tree_swap_info *) data;\n-      if (t == swapinfo->from\n-\t  || (TREE_CODE (t) == SSA_NAME\n-\t      && SSA_NAME_VAR (t) == swapinfo->from))\n+      unsigned oldnew = sum->pass_through_map[i].new_index;\n+      sum->pass_through_map[i].new_index = new_index_map[oldnew];\n+    }\n+\n+  len = sum->index_map.length ();\n+  if (len > 0)\n+    {\n+      unsigned nptlen = new_pt_map.length ();\n+      for (unsigned j = 0; j < nptlen; j++)\n \t{\n-\t  *tp = swapinfo->to;\n-\t  swapinfo->done = true;\n+\t  int inverse = -1;\n+\t  for (unsigned i = 0; i < len ; i++)\n+\t    if ((unsigned) sum->index_map[i] == new_pt_map[j].base_index)\n+\t    {\n+\t      inverse = i;\n+\t      break;\n+\t    }\n+\t  gcc_assert (inverse >= 0);\n+\t  pass_through_split_map ptm_item;\n+\n+\t  ptm_item.base_index = inverse;\n+\t  ptm_item.unit_offset = new_pt_map[j].unit_offset;\n+\t  ptm_item.new_index = new_pt_map[j].new_index;\n+\t  sum->pass_through_map.safe_push (ptm_item);\n+\t}\n+\n+      for (unsigned i = 0; i < len; i++)\n+\t{\n+\t  int idx = sum->index_map[i];\n+\t  if (idx < 0)\n+\t    continue;\n+\t  sum->index_map[i] = new_index_map[idx];\n \t}\n-      *walk_subtrees = 0;\n     }\n-  else if (TYPE_P (t))\n-      *walk_subtrees = 0;\n   else\n-    *walk_subtrees = 1;\n-  return NULL_TREE;\n+    {\n+      sum->pass_through_map.safe_splice (new_pt_map);\n+      sum->index_map.safe_splice (new_index_map);\n+    }\n+  sum->always_copy_delta += new_always_copy_delta;\n+  return sum;\n }\n \n+/* Record information about what modifications to call arguments have already\n+   been done by clone materialization into a summary of an edge describing the\n+   call in this clone and all its clones.  NEW_INDEX_MAP, NEW_PT_MAP and\n+   NEW_ALWAYS_COPY_DELTA have the same meaning as record_argument_state_1.\n+\n+   In order to associate the info with the right edge summaries, we need\n+   address of the ORIG_STMT in the function from which we are cloning (because\n+   the edges have not yet been re-assigned to the new statement that has just\n+   been created) and ID, the structure governing function body copying.  */\n+\n+static void\n+record_argument_state (copy_body_data *id, gimple *orig_stmt,\n+\t\t       const vec<int> &new_index_map,\n+\t\t       const vec<pass_through_split_map> &new_pt_map,\n+\t\t       int new_always_copy_delta)\n+{\n+  if (!ipa_edge_modifications)\n+    ipa_edge_modifications = new ipa_edge_modification_sum (symtab);\n+\n+  struct cgraph_node *this_node = id->dst_node;\n+  ipa_edge_modification_info *first_sum = NULL;\n+  cgraph_edge *cs = this_node->get_edge (orig_stmt);\n+  if (cs)\n+    first_sum = record_argument_state_1 (cs, new_index_map, new_pt_map,\n+\t\t\t\t\t new_always_copy_delta);\n+  else\n+    gcc_assert (this_node->clones);\n+\n+  if (!this_node->clones)\n+    return;\n+  for (cgraph_node *subclone = this_node->clones; subclone != this_node;)\n+    {\n+      cs = subclone->get_edge (orig_stmt);\n+      if (cs)\n+\t{\n+\t  if (!first_sum)\n+\t    first_sum = record_argument_state_1 (cs, new_index_map, new_pt_map,\n+\t\t\t\t\t\t new_always_copy_delta);\n+\t  else\n+\t    {\n+\t      ipa_edge_modification_info *s2\n+\t\t= ipa_edge_modifications->get_create (cs);\n+\t      s2->index_map.truncate (0);\n+\t      s2->index_map.safe_splice (first_sum->index_map);\n+\t      s2->pass_through_map.truncate (0);\n+\t      s2->pass_through_map.safe_splice (first_sum->pass_through_map);\n+\t      s2->always_copy_delta = first_sum->always_copy_delta;\n+\t    }\n+\t}\n+      else\n+\tgcc_assert (subclone->clones);\n+\n+      if (subclone->clones)\n+\tsubclone = subclone->clones;\n+      else if (subclone->next_sibling_clone)\n+\tsubclone = subclone->next_sibling_clone;\n+      else\n+\t{\n+\t  while (subclone != this_node && !subclone->next_sibling_clone)\n+\t    subclone = subclone->clone_of;\n+\t  if (subclone != this_node)\n+\t    subclone = subclone->next_sibling_clone;\n+\t}\n+    }\n+}\n \n /* If the call statement pointed at by STMT_P contains any expressions that\n    need to replaced with a different one as noted by ADJUSTMENTS, do so.  f the\n    statement needs to be rebuilt, do so.  Return true if any modifications have\n-   been performed.\n+   been performed.  ORIG_STMT, if not NULL, is the original statement in the\n+   function that is being cloned from, which at this point can be used to look\n+   up call_graph edges.\n \n    If the method is invoked as a part of IPA clone materialization and if any\n-   parameter split is transitive, i.e. it applies to the functin that is being\n-   modified and also to the callee of the statement, replace the parameter\n-   passed to old callee with an equivalent expression based on a dummy decl\n-   followed by PARM_DECLs representing the actual replacements.  The actual\n-   replacements will be then converted into SSA_NAMEs and then\n-   ipa_param_adjustments::modify_call will find the appropriate ones and leave\n-   only those in the call.  */\n+   parameter split is pass-through, i.e. it applies to the functin that is\n+   being modified and also to the callee of the statement, replace the\n+   parameter passed to old callee with all of the replacement a callee might\n+   possibly want and record the performed argument modifications in\n+   ipa_edge_modifications.  Likewise if any argument has already been left out\n+   because it is not necessary.  */\n \n bool\n-ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p)\n+ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n+\t\t\t\t\t      gimple *orig_stmt)\n {\n-  gcall *stmt = *stmt_p;\n   auto_vec <unsigned, 4> pass_through_args;\n   auto_vec <unsigned, 4> pass_through_pbr_indices;\n+  auto_vec <HOST_WIDE_INT, 4> pass_through_offsets;\n+  gcall *stmt = *stmt_p;\n+  unsigned nargs = gimple_call_num_args (stmt);\n+  bool recreate = false;\n \n-  if (m_split_modifications_p && m_id)\n+  for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n-      for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n-\t{\n-\t  tree t = gimple_call_arg (stmt, i);\n-\t  gcc_assert (TREE_CODE (t) != BIT_FIELD_REF\n-\t\t      && TREE_CODE (t) != IMAGPART_EXPR\n-\t\t      && TREE_CODE (t) != REALPART_EXPR);\n+      tree t = gimple_call_arg (stmt, i);\n+      gcc_assert (TREE_CODE (t) != BIT_FIELD_REF\n+\t\t  && TREE_CODE (t) != IMAGPART_EXPR\n+\t\t  && TREE_CODE (t) != REALPART_EXPR);\n \n-\t  tree base;\n-\t  unsigned unit_offset;\n-\t  if (!isra_get_ref_base_and_offset (t, &base, &unit_offset))\n-\t    continue;\n+      /* The follow-up patch will check whether t needs to be removed, that's\n+\t why this condition is in the loop.  */\n \n-\t  bool by_ref = false;\n-\t  if (TREE_CODE (base) == SSA_NAME)\n-\t    {\n-\t      if (!SSA_NAME_IS_DEFAULT_DEF (base))\n-\t\tcontinue;\n-\t      base = SSA_NAME_VAR (base);\n-\t      gcc_checking_assert (base);\n-\t      by_ref = true;\n-\t    }\n-\t  if (TREE_CODE (base) != PARM_DECL)\n+      if (!m_split_modifications_p)\n+\tcontinue;\n+\n+      tree base;\n+      unsigned agg_arg_offset;\n+      if (!isra_get_ref_base_and_offset (t, &base, &agg_arg_offset))\n+\tcontinue;\n+\n+      bool by_ref = false;\n+      if (TREE_CODE (base) == SSA_NAME)\n+\t{\n+\t  if (!SSA_NAME_IS_DEFAULT_DEF (base))\n \t    continue;\n+\t  base = SSA_NAME_VAR (base);\n+\t  gcc_checking_assert (base);\n+\t  by_ref = true;\n+\t}\n+      if (TREE_CODE (base) != PARM_DECL)\n+\tcontinue;\n \n-\t  bool base_among_replacements = false;\n-\t  unsigned j, repl_list_len = m_replacements.length ();\n-\t  for (j = 0; j < repl_list_len; j++)\n+      bool base_among_replacements = false;\n+      unsigned j, repl_list_len = m_replacements.length ();\n+      for (j = 0; j < repl_list_len; j++)\n+\t{\n+\t  ipa_param_body_replacement *pbr = &m_replacements[j];\n+\t  if (pbr->base == base)\n \t    {\n-\t      ipa_param_body_replacement *pbr = &m_replacements[j];\n-\t      if (pbr->base == base)\n-\t\t{\n-\t\t  base_among_replacements = true;\n-\t\t  break;\n-\t\t}\n+\t      base_among_replacements = true;\n+\t      break;\n \t    }\n-\t  if (!base_among_replacements)\n-\t    continue;\n+\t}\n+      if (!base_among_replacements)\n+\tcontinue;\n \n-\t  /* We still have to distinguish between an end-use that we have to\n-\t     transform now and a pass-through, which happens in the following\n-\t     two cases.  */\n+      /* We still have to distinguish between an end-use that we have to\n+\t transform now and a pass-through, which happens in the following\n+\t two cases.  */\n \n-\t  /* TODO: After we adjust ptr_parm_has_nonarg_uses to also consider\n-\t     &MEM_REF[ssa_name + offset], we will also have to detect that case\n-\t     here.    */\n+      /* TODO: After we adjust ptr_parm_has_nonarg_uses to also consider\n+\t &MEM_REF[ssa_name + offset], we will also have to detect that case\n+\t here.    */\n \n-\t  if (TREE_CODE (t) == SSA_NAME\n-\t      && SSA_NAME_IS_DEFAULT_DEF (t)\n-\t      && SSA_NAME_VAR (t)\n-\t      && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL)\n+      if (TREE_CODE (t) == SSA_NAME\n+\t  && SSA_NAME_IS_DEFAULT_DEF (t)\n+\t  && SSA_NAME_VAR (t)\n+\t  && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL)\n+\t{\n+\t  /* This must be a by_reference pass-through.  */\n+\t  recreate = true;\n+\t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n+\t  pass_through_args.safe_push (i);\n+\t  pass_through_pbr_indices.safe_push (j);\n+\t  pass_through_offsets.safe_push (agg_arg_offset);\n+\t}\n+      else if (!by_ref && AGGREGATE_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  /* Currently IPA-SRA guarantees the aggregate access type\n+\t     exactly matches in this case.  So if it does not match, it is\n+\t     a pass-through argument that will be sorted out at edge\n+\t     redirection time.  */\n+\t  ipa_param_body_replacement *pbr\n+\t    = lookup_replacement_1 (base, agg_arg_offset);\n+\n+\t  if (!pbr\n+\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (t))\n+\t\t  != TYPE_MAIN_VARIANT (TREE_TYPE (pbr->repl))))\n \t    {\n-\t      /* This must be a by_reference pass-through.  */\n-\t      gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n+\t      recreate = true;\n \t      pass_through_args.safe_push (i);\n \t      pass_through_pbr_indices.safe_push (j);\n-\t    }\n-\t  else if (!by_ref && AGGREGATE_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      /* Currently IPA-SRA guarantees the aggregate access type\n-\t\t exactly matches in this case.  So if it does not match, it is\n-\t\t a pass-through argument that will be sorted out at edge\n-\t\t redirection time.  */\n-\t      ipa_param_body_replacement *pbr\n-\t\t= lookup_replacement_1 (base, unit_offset);\n-\n-\t      if (!pbr\n-\t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (t))\n-\t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (pbr->repl))))\n-\t\t{\n-\t\t  pass_through_args.safe_push (i);\n-\t\t  pass_through_pbr_indices.safe_push (j);\n-\t\t}\n+\t      pass_through_offsets.safe_push (agg_arg_offset);\n \t    }\n \t}\n     }\n \n-  unsigned nargs = gimple_call_num_args (stmt);\n-  if (!pass_through_args.is_empty ())\n+  if (!recreate)\n     {\n-      auto_vec<tree, 16> vargs;\n-      unsigned pt_idx = 0;\n+      /* No need to rebuild the statement, let's just modify arguments\n+\t and the LHS if/as appropriate.  */\n+      bool modified = false;\n       for (unsigned i = 0; i < nargs; i++)\n \t{\n-\t  if (pt_idx < pass_through_args.length ()\n-\t      && i == pass_through_args[pt_idx])\n-\t    {\n-\t      unsigned j = pass_through_pbr_indices[pt_idx];\n-\t      pt_idx++;\n-\t      tree base = m_replacements[j].base;\n-\n-\t      /* Map base will get mapped to the special transitive-isra marker\n-\t\t dummy decl. */\n-\t      struct simple_tree_swap_info swapinfo;\n-\t      swapinfo.from = base;\n-\t      swapinfo.to = m_replacements[j].dummy;\n-\t      swapinfo.done = false;\n-\t      tree arg = gimple_call_arg (stmt, i);\n-\t      walk_tree (&arg, remap_split_decl_to_dummy, &swapinfo, NULL);\n-\t      gcc_assert (swapinfo.done);\n-\t      vargs.safe_push (arg);\n-\t      /* Now let's push all replacements pertaining to this parameter\n-\t\t so that all gimple register ones get correct SSA_NAMES.  Edge\n-\t\t redirection will weed out the dummy argument as well as all\n-\t\t unused replacements later.  */\n-\t      unsigned int repl_list_len = m_replacements.length ();\n-\t      for (; j < repl_list_len; j++)\n-\t\t{\n-\t\t  if (m_replacements[j].base != base)\n-\t\t    break;\n-\t\t  vargs.safe_push (m_replacements[j].repl);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      tree t = gimple_call_arg (stmt, i);\n-\t      modify_expression (&t, true);\n-\t      vargs.safe_push (t);\n-\t    }\n+\t  tree *t = gimple_call_arg_ptr (stmt, i);\n+\t  modified |= modify_expression (t, true);\n \t}\n-      gcall *new_stmt = gimple_build_call_vec (gimple_call_fn (stmt), vargs);\n-      if (gimple_has_location (stmt))\n-\tgimple_set_location (new_stmt, gimple_location (stmt));\n-      gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n-      gimple_call_copy_flags (new_stmt, stmt);\n-      if (tree lhs = gimple_call_lhs (stmt))\n+      if (gimple_call_lhs (stmt))\n \t{\n-\t  modify_expression (&lhs, false);\n-\t  /* Avoid adjusting SSA_NAME_DEF_STMT of a SSA lhs, SSA names\n-\t     have not yet been remapped.  */\n-\t  *gimple_call_lhs_ptr (new_stmt) = lhs;\n+\t  tree *t = gimple_call_lhs_ptr (stmt);\n+\t  modified |= modify_expression (t, false);\n \t}\n-      *stmt_p = new_stmt;\n-      return true;\n+      return modified;\n     }\n \n-  /* Otherwise, no need to rebuild the statement, let's just modify arguments\n-     and the LHS if/as appropriate.  */\n-  bool modified = false;\n+  auto_vec<int, 16> index_map;\n+  auto_vec<pass_through_split_map, 4> pass_through_map;\n+  auto_vec<tree, 16> vargs;\n+  int always_copy_delta = 0;\n+  unsigned pt_idx = 0;\n+  int new_arg_idx = 0;\n   for (unsigned i = 0; i < nargs; i++)\n     {\n-      tree *t = gimple_call_arg_ptr (stmt, i);\n-      modified |= modify_expression (t, true);\n+      if (pt_idx < pass_through_args.length ()\n+\t  && i == pass_through_args[pt_idx])\n+\t{\n+\t  unsigned j = pass_through_pbr_indices[pt_idx];\n+\t  unsigned agg_arg_offset = pass_through_offsets[pt_idx];\n+\t  pt_idx++;\n+\t  always_copy_delta--;\n+\t  tree base = m_replacements[j].base;\n+\n+\t  /* In order to be put into SSA form, we have to push all replacements\n+\t     pertaining to this parameter as parameters to the call statement.\n+\t     Edge redirection will need to use edge summary to weed out the\n+\t     unnecessary ones.  */\n+\t  unsigned repl_list_len = m_replacements.length ();\n+\t  for (; j < repl_list_len; j++)\n+\t    {\n+\t      if (m_replacements[j].base != base)\n+\t\tbreak;\n+\t      if (m_replacements[j].unit_offset < agg_arg_offset)\n+\t\tcontinue;\n+\t      pass_through_split_map pt_map;\n+\t      pt_map.base_index = i;\n+\t      pt_map.unit_offset\n+\t\t= m_replacements[j].unit_offset - agg_arg_offset;\n+\t      pt_map.new_index = new_arg_idx;\n+\t      pass_through_map.safe_push (pt_map);\n+\t      vargs.safe_push (m_replacements[j].repl);\n+\t      new_arg_idx++;\n+\t      always_copy_delta++;\n+\t    }\n+\t  index_map.safe_push (-1);\n+\t}\n+      else\n+\t{\n+\t  tree t = gimple_call_arg (stmt, i);\n+\t  modify_expression (&t, true);\n+\t  vargs.safe_push (t);\n+\t  index_map.safe_push (new_arg_idx);\n+\t  new_arg_idx++;\n+\t}\n     }\n \n-  if (gimple_call_lhs (stmt))\n+  gcall *new_stmt = gimple_build_call_vec (gimple_call_fn (stmt), vargs);\n+  if (gimple_has_location (stmt))\n+    gimple_set_location (new_stmt, gimple_location (stmt));\n+  gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n+  gimple_call_copy_flags (new_stmt, stmt);\n+  if (tree lhs = gimple_call_lhs (stmt))\n     {\n-      tree *t = gimple_call_lhs_ptr (stmt);\n-      modified |= modify_expression (t, false);\n+      modify_expression (&lhs, false);\n+      /* Avoid adjusting SSA_NAME_DEF_STMT of a SSA lhs, SSA names\n+\t have not yet been remapped.  */\n+      *gimple_call_lhs_ptr (new_stmt) = lhs;\n     }\n+  *stmt_p = new_stmt;\n \n-  return modified;\n+  if (orig_stmt)\n+    record_argument_state (m_id, orig_stmt, index_map, pass_through_map,\n+\t\t\t   always_copy_delta);\n+  return true;\n }\n \n /* If the statement STMT contains any expressions that need to replaced with a\n@@ -1726,7 +1798,8 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p)\n \n bool\n ipa_param_body_adjustments::modify_gimple_stmt (gimple **stmt,\n-\t\t\t\t\t\tgimple_seq *extra_stmts)\n+\t\t\t\t\t\tgimple_seq *extra_stmts,\n+\t\t\t\t\t\tgimple *orig_stmt)\n {\n   bool modified = false;\n   tree *t;\n@@ -1746,7 +1819,7 @@ ipa_param_body_adjustments::modify_gimple_stmt (gimple **stmt,\n       break;\n \n     case GIMPLE_CALL:\n-      modified |= modify_call_stmt ((gcall **) stmt);\n+      modified |= modify_call_stmt ((gcall **) stmt, orig_stmt);\n       break;\n \n     case GIMPLE_ASM:\n@@ -1803,7 +1876,7 @@ ipa_param_body_adjustments::modify_cfun_body ()\n \t  gimple *stmt = gsi_stmt (gsi);\n \t  gimple *stmt_copy = stmt;\n \t  gimple_seq extra_stmts = NULL;\n-\t  bool modified = modify_gimple_stmt (&stmt, &extra_stmts);\n+\t  bool modified = modify_gimple_stmt (&stmt, &extra_stmts, NULL);\n \t  if (stmt != stmt_copy)\n \t    {\n \t      gcc_checking_assert (modified);\n@@ -1952,3 +2025,17 @@ ipa_param_body_adjustments::perform_cfun_body_modifications ()\n   return cfg_changed;\n }\n \n+\n+/* Deallocate summaries which otherwise stay alive until the end of\n+   compilation.  */\n+\n+void\n+ipa_edge_modifications_finalize ()\n+{\n+  if (!ipa_edge_modifications)\n+    return;\n+  delete ipa_edge_modifications;\n+  ipa_edge_modifications = NULL;\n+}\n+\n+"}, {"sha": "31dcc4b97687e2a7281e92d0965f1ce7b1e4a521", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -54,7 +54,7 @@ or only a vector of ipa_adjusted_params.\n When these classes are used in the context of call graph clone materialization\n and subsequent call statement redirection - which is the point at which we\n modify arguments in call statements - they need to cooperate with each other in\n-order to handle what we refer to as transitive (IPA-SRA) splits.  These are\n+order to handle what we refer to as pass-through (IPA-SRA) splits.  These are\n situations when a formal parameter of one function is split into several\n smaller ones and some of them are then passed on in a call to another function\n because the formal parameter of this callee has also been split.\n@@ -83,7 +83,7 @@ baz ()\n Both bar and foo would have their parameter split.  Foo would receive one\n replacement representing s.b.  Function bar would see its parameter split into\n one replacement representing z.s.a and another representing z.s.b which would\n-be passed on to foo.  It would be a so called transitive split IPA-SRA\n+be passed on to foo.  It would be a so called pass-through split IPA-SRA\n replacement, one which is passed in a call as an actual argument to another\n IPA-SRA replacement in another function.\n \n@@ -95,30 +95,25 @@ all of the above.\n \n Call redirection has to be able to find the right decl or SSA_NAME that\n corresponds to the transitive split in the caller.  The SSA names are assigned\n-right after clone materialization/ modification and cannot be \"added\"\n-afterwards.  Moreover, if the caller has been inlined the SSA_NAMEs in question\n-no longer belong to PARM_DECLs but to VAR_DECLs, indistinguishable from any\n-others.\n+right after clone materialization/ modification and cannot be \"added\" to call\n+arguments at any later point.  Moreover, if the caller has been inlined the\n+SSA_NAMEs in question no longer belong to PARM_DECLs but to VAR_DECLs,\n+indistinguishable from any others.\n \n Therefore, when clone materialization finds a call statement which it knows is\n-a part of a transitive split, it will modify it into:\n+a part of a transitive split, it will simply add as arguments all new \"split\"\n+replacements (that have grater or equal offset than the original call\n+argument):\n \n-  foo (DUMMY_Z_VAR.s, repl_for_a, repl_for_b, <rest of original arguments>);\n+  foo (repl_for_a, repl_for_b, <rest of original arguments>);\n \n-It will also store {DUMMY_S_VAR, 32} and {DUMMY_S_VAR, 64} representing offsets\n-of z.s.a and z.s.b (assuming a 32-bit int) into foo's cgraph node\n-clone->performed_splits vector (which is storing structures of type\n-ipa_param_performed_split also defined in this header file).\n-\n-Call redirection will identify that expression DUMMY_Z_VAR.s is based on a\n-variable stored in performed_splits vector and learn that the following\n-arguments, already in SSA form, represent offsets 32 and 64 in a split original\n-parameter.  It subtracts offset of DUMMY_Z_VAR.s from 32 and 64 and arrives at\n-offsets 0 and 32 within callee's original parameter.  At this point it also\n-knows from the call graph that only the bit with offset 32 is needed and so\n-changes the call statement into final:\n-\n-bar (repl_for_b, <rest of original arguments>);  */\n+It will also store into ipa_edge_modification_info (which is internal to\n+ipa-param-modification.c) information about which replacement is which and\n+where original arguments are.  Call redirection will then invoke\n+ipa_param_adjustments::modify_call which will access this information and\n+eliminate all replacements which the callee does not expect (repl_for_a in our\n+example above).  In between these two steps, however, a call statement might\n+have extraneous arguments.  */\n \n #ifndef IPA_PARAM_MANIPULATION_H\n #define IPA_PARAM_MANIPULATION_H\n@@ -207,21 +202,6 @@ struct GTY(()) ipa_adjusted_param\n void ipa_dump_adjusted_parameters (FILE *f,\n \t\t\t\t   vec<ipa_adjusted_param, va_gc> *adj_params);\n \n-/* Structure to remember the split performed on a node so that edge redirection\n-   (i.e. splitting arguments of call statements) know how split formal\n-   parameters of the caller are represented.  */\n-\n-struct GTY(()) ipa_param_performed_split\n-{\n-  /* The dummy VAR_DECL that was created instead of the split parameter that\n-     sits in the call in the meantime between clone materialization and call\n-     redirection.  All entries in a vector of performed splits that correspond\n-     to the same dumy decl must be grouped together.  */\n-  tree dummy_decl;\n-  /* Offset into the original parameter.  */\n-  unsigned unit_offset;\n-};\n-\n /* Class used to record planned modifications to parameters of a function and\n    also to perform necessary modifications at the caller side at the gimple\n    level.  Used to describe all cgraph node clones that have their parameters\n@@ -244,9 +224,7 @@ class GTY(()) ipa_param_adjustments\n \n   /* Modify a call statement arguments (and possibly remove the return value)\n      as described in the data fields of this class.  */\n-  gcall *modify_call (gcall *stmt,\n-\t\t      vec<ipa_param_performed_split, va_gc> *performed_splits,\n-\t\t      tree callee_decl, bool update_references);\n+  gcall *modify_call (cgraph_edge *cs, bool update_references);\n   /* Return if the first parameter is left intact.  */\n   bool first_param_intact_p ();\n   /* Build a function type corresponding to the modified call.  */\n@@ -293,15 +271,9 @@ struct ipa_param_body_replacement\n   tree base;\n   /* The new decl it should be replaced with.  */\n   tree repl;\n-  /* When modifying clones during IPA clone materialization, this is a dummy\n-     decl used to mark calls in which we need to apply transitive splitting,\n-     these dummy delcls are inserted as arguments to such calls and then\n-     followed by all the replacements with offset info stored in\n-     ipa_param_performed_split.\n-\n-     Users of ipa_param_body_adjustments that modify standalone functions\n-     outside of IPA clone materialization can use this field for their internal\n-     purposes.  */\n+  /* Users of ipa_param_body_adjustments that modify standalone functions\n+     outside of IPA clone materialization can use the following field for their\n+     internal purposes.  */\n   tree dummy;\n   /* The offset within BASE that REPL represents.  */\n   unsigned unit_offset;\n@@ -342,8 +314,7 @@ class ipa_param_body_adjustments\n   /* Change the PARM_DECLs.  */\n   void modify_formal_parameters ();\n   /* Register a replacement decl for the transformation done in APM.  */\n-  void register_replacement (ipa_adjusted_param *apm, tree replacement,\n-\t\t\t     tree dummy = NULL_TREE);\n+  void register_replacement (ipa_adjusted_param *apm, tree replacement);\n   /* Lookup a replacement for a given offset within a given parameter.  */\n   tree lookup_replacement (tree base, unsigned unit_offset);\n   /* Lookup a replacement for an expression, if there is one.  */\n@@ -353,7 +324,8 @@ class ipa_param_body_adjustments\n      parameter. */\n   tree get_replacement_ssa_base (tree old_decl);\n   /* Modify a statement.  */\n-  bool modify_gimple_stmt (gimple **stmt, gimple_seq *extra_stmts);\n+  bool modify_gimple_stmt (gimple **stmt, gimple_seq *extra_stmts,\n+\t\t\t   gimple *orig_stmt);\n   /* Return the new chain of parameters.  */\n   tree get_new_param_chain ();\n \n@@ -380,9 +352,10 @@ class ipa_param_body_adjustments\n   tree replace_removed_params_ssa_names (tree old_name, gimple *stmt);\n   bool modify_expression (tree *expr_p, bool convert);\n   bool modify_assignment (gimple *stmt, gimple_seq *extra_stmts);\n-  bool modify_call_stmt (gcall **stmt_p);\n+  bool modify_call_stmt (gcall **stmt_p, gimple *orig_stmt);\n   bool modify_cfun_body ();\n   void reset_debug_stmts ();\n+  void mark_dead_statements (tree dead_param);\n \n   /* Declaration of the function that is being transformed.  */\n \n@@ -431,5 +404,8 @@ class ipa_param_body_adjustments\n \n void push_function_arg_decls (vec<tree> *args, tree fndecl);\n void push_function_arg_types (vec<tree> *types, tree fntype);\n+void ipa_verify_edge_has_no_modifications (cgraph_edge *cs);\n+void ipa_edge_modifications_finalize ();\n+\n \n #endif\t/* IPA_PARAM_MANIPULATION_H */"}, {"sha": "a6ad4a6e27f16982b50495afb2666e9c1370b206", "filename": "gcc/symtab-clones.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Fsymtab-clones.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Fsymtab-clones.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab-clones.h?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -26,27 +26,14 @@ struct GTY(()) clone_info\n   /* Constructor.  */\n   clone_info ()\n     : tree_map (NULL),\n-      param_adjustments (NULL),\n-      performed_splits (NULL)\n+      param_adjustments (NULL)\n   {\n   }\n   /* Constants discovered by IPA-CP, i.e. which parameter should be replaced\n      with what.  */\n   vec<ipa_replace_map *, va_gc> *tree_map;\n   /* Parameter modification that IPA-SRA decided to perform.  */\n   ipa_param_adjustments *param_adjustments;\n-  /* Lists of dummy-decl and offset pairs representing split formal parameters\n-     in the caller.  Offsets of all new replacements are enumerated, those\n-     coming from the same original parameter have the same dummy decl stored\n-     along with them.\n-\n-     Dummy decls sit in call statement arguments followed by new parameter\n-     decls (or their SSA names) in between (caller) clone materialization and\n-     call redirection.  Redirection then recognizes the dummy variable and\n-     together with the stored offsets can reconstruct what exactly the new\n-     parameter decls represent and can leave in place only those that the\n-     callee expects.  */\n-  vec<ipa_param_performed_split, va_gc> *performed_splits;\n \n   /* Return clone_info, if available.  */\n   static clone_info *get (cgraph_node *node);"}, {"sha": "a78552278edc825b38f97330ed238390b83cc5b8", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optinfo-emit-json.h\"\n #include \"ipa-modref-tree.h\"\n #include \"ipa-modref.h\"\n+#include \"ipa-param-manipulation.h\"\n #include \"dbgcnt.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n@@ -2393,6 +2394,7 @@ toplev::finalize (void)\n   ipa_reference_c_finalize ();\n   ipa_fnsummary_c_finalize ();\n   ipa_modref_c_finalize ();\n+  ipa_edge_modifications_finalize ();\n \n   cgraph_c_finalize ();\n   cgraphunit_c_finalize ();"}, {"sha": "4f15e57da0bfa0662eb2ee6ca125ffffe43d01c9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 99, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87467f45e831e8e943efdae8920453741986d355/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87467f45e831e8e943efdae8920453741986d355/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=87467f45e831e8e943efdae8920453741986d355", "patch": "@@ -1922,7 +1922,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n   if (id->param_body_adjs)\n     {\n       gimple_seq extra_stmts = NULL;\n-      id->param_body_adjs->modify_gimple_stmt (&copy, &extra_stmts);\n+      id->param_body_adjs->modify_gimple_stmt (&copy, &extra_stmts, stmt);\n       if (!gimple_seq_empty_p (extra_stmts))\n \t{\n \t  memset (&wi, 0, sizeof (wi));\n@@ -4730,7 +4730,6 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n   use_operand_p use;\n   gimple *simtenter_stmt = NULL;\n   vec<tree> *simtvars_save;\n-  clone_info *info;\n \n   /* The gimplifier uses input_location in too many places, such as\n      internal_get_tmp_var ().  */\n@@ -5055,40 +5054,6 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n   /* Add local vars in this inlined callee to caller.  */\n   add_local_variables (id->src_cfun, cfun, id);\n \n-  info = clone_info::get (id->src_node);\n-  if (info && info->performed_splits)\n-    {\n-      clone_info *dst_info = clone_info::get_create (id->dst_node);\n-      /* Any calls from the inlined function will be turned into calls from the\n-\t function we inline into.  We must preserve notes about how to split\n-\t parameters such calls should be redirected/updated.  */\n-      unsigned len = vec_safe_length (info->performed_splits);\n-      for (unsigned i = 0; i < len; i++)\n-\t{\n-\t  ipa_param_performed_split ps\n-\t    = (*info->performed_splits)[i];\n-\t  ps.dummy_decl = remap_decl (ps.dummy_decl, id);\n-\t  vec_safe_push (dst_info->performed_splits, ps);\n-\t}\n-\n-      if (flag_checking)\n-\t{\n-\t  len = vec_safe_length (dst_info->performed_splits);\n-\t  for (unsigned i = 0; i < len; i++)\n-\t    {\n-\t      ipa_param_performed_split *ps1\n-\t\t= &(*dst_info->performed_splits)[i];\n-\t      for (unsigned j = i + 1; j < len; j++)\n-\t\t{\n-\t\t  ipa_param_performed_split *ps2\n-\t\t    = &(*dst_info->performed_splits)[j];\n-\t\t  gcc_assert (ps1->dummy_decl != ps2->dummy_decl\n-\t\t\t      || ps1->unit_offset != ps2->unit_offset);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n   if (dump_enabled_p ())\n     {\n       char buf[128];\n@@ -6112,23 +6077,10 @@ tree_versionable_function_p (tree fndecl)\n static void\n update_clone_info (copy_body_data * id)\n {\n-  clone_info *dst_info = clone_info::get (id->dst_node);\n-  vec<ipa_param_performed_split, va_gc> *cur_performed_splits\n-    = dst_info ? dst_info->performed_splits : NULL;\n-  if (cur_performed_splits)\n-    {\n-      unsigned len = cur_performed_splits->length ();\n-      for (unsigned i = 0; i < len; i++)\n-\t{\n-\t  ipa_param_performed_split *ps = &(*cur_performed_splits)[i];\n-\t  ps->dummy_decl = remap_decl (ps->dummy_decl, id);\n-\t}\n-    }\n-\n-  struct cgraph_node *node;\n-  if (!id->dst_node->clones)\n+  struct cgraph_node *this_node = id->dst_node;\n+  if (!this_node->clones)\n     return;\n-  for (node = id->dst_node->clones; node != id->dst_node;)\n+  for (cgraph_node *node = this_node->clones; node != this_node;)\n     {\n       /* First update replace maps to match the new body.  */\n       clone_info *info = clone_info::get (node);\n@@ -6142,53 +6094,6 @@ update_clone_info (copy_body_data * id)\n \t      walk_tree (&replace_info->new_tree, copy_tree_body_r, id, NULL);\n \t    }\n \t}\n-      if (info && info->performed_splits)\n-\t{\n-\t  unsigned len = vec_safe_length (info->performed_splits);\n-\t  for (unsigned i = 0; i < len; i++)\n-\t    {\n-\t      ipa_param_performed_split *ps\n-\t\t= &(*info->performed_splits)[i];\n-\t      ps->dummy_decl = remap_decl (ps->dummy_decl, id);\n-\t    }\n-\t}\n-      if (unsigned len = vec_safe_length (cur_performed_splits))\n-\t{\n-\t  /* We do not want to add current performed splits when we are saving\n-\t     a copy of function body for later during inlining, that would just\n-\t     duplicate all entries.  So let's have a look whether anything\n-\t     referring to the first dummy_decl is present.  */\n-\t  if (!info)\n-\t    info = clone_info::get_create (node);\n-\t  unsigned dst_len = vec_safe_length (info->performed_splits);\n-\t  ipa_param_performed_split *first = &(*cur_performed_splits)[0];\n-\t  for (unsigned i = 0; i < dst_len; i++)\n-\t    if ((*info->performed_splits)[i].dummy_decl\n-\t\t== first->dummy_decl)\n-\t      {\n-\t\tlen = 0;\n-\t\tbreak;\n-\t      }\n-\n-\t  for (unsigned i = 0; i < len; i++)\n-\t    vec_safe_push (info->performed_splits,\n-\t\t\t   (*cur_performed_splits)[i]);\n-\t  if (flag_checking)\n-\t    {\n-\t      for (unsigned i = 0; i < dst_len; i++)\n-\t\t{\n-\t\t  ipa_param_performed_split *ps1\n-\t\t    = &(*info->performed_splits)[i];\n-\t\t  for (unsigned j = i + 1; j < dst_len; j++)\n-\t\t    {\n-\t\t      ipa_param_performed_split *ps2\n-\t\t\t= &(*info->performed_splits)[j];\n-\t\t      gcc_assert (ps1->dummy_decl != ps2->dummy_decl\n-\t\t\t\t  || ps1->unit_offset != ps2->unit_offset);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n \n       if (node->clones)\n \tnode = node->clones;"}]}