{"sha": "d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFkNWM4MzZhMWE0MjZjMjI0ZWZlODk4YjViYWQ0ZWQ2ZjNlMDU1ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-02-10T13:27:43Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-02-10T13:27:43Z"}, "message": "linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Don't bump retaddr here.\n\n\t* config/rs6000/linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Don't\n\tbump retaddr here.\n\n\t* include/powerpc-signal.h: Revert 2004-01-21 change.\n\t(INIT_SEGV, INIT_FPE): Provide powerpc64 versions.  Check return\n\tfrom syscall for ppc32 versions.\n\nFrom-SVN: r77601", "tree": {"sha": "9cbd974e4e220d597f62a4a13f920675f34ef268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cbd974e4e220d597f62a4a13f920675f34ef268"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/comments", "author": null, "committer": null, "parents": [{"sha": "6ab36f91824ccdcd505e725201f4bd66b080a8fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab36f91824ccdcd505e725201f4bd66b080a8fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab36f91824ccdcd505e725201f4bd66b080a8fb"}], "stats": {"total": 82, "additions": 56, "deletions": 26}, "files": [{"sha": "1f6b7482152b5a7b2d6d37ab577ba5e14ef0766a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "patch": "@@ -1,3 +1,8 @@\n+2004-02-10  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Don't\n+\tbump retaddr here.\n+\n 2004-02-10  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* rtl.h (schedule_insns, schedule_ebbs, fix_sched_param,"}, {"sha": "44f7cb72a558d4cbabd166de7de6c46cbf23b98e", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "patch": "@@ -643,15 +643,9 @@ enum { SIGNAL_FRAMESIZE = 64 };\n     (FS)->regs.reg[LINK_REGISTER_REGNUM].loc.offset \t\t\t\\\n       = (long)&(sc_->regs->link) - new_cfa_;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* The unwinder expects the IP to point to the following insn,\t\\\n-       whereas the kernel returns the address of the actual\t\t\\\n-       faulting insn. We store NIP+4 in an unused register slot to\t\\\n-       get the same result for multiple evaluation of the same signal\t\\\n-       frame.  */\t\t\t\t\t\t\t\\\n-    sc_->regs->gpr[47] = sc_->regs->nip + 4;  \t\t\t\t\\\n     (FS)->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;\t\t\\\n     (FS)->regs.reg[ARG_POINTER_REGNUM].loc.offset \t\t\t\\\n-      = (long)&(sc_->regs->gpr[47]) - new_cfa_;\t\t\t\t\\\n+      = (long)&(sc_->regs->nip) - new_cfa_;\t\t\t\t\\\n     (FS)->retaddr_column = ARG_POINTER_REGNUM;\t\t\t\t\\\n     goto SUCCESS;\t\t\t\t\t\t\t\\\n   } while (0)"}, {"sha": "ec293183985ccd2995c56ba57d57af1b8532bf49", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "patch": "@@ -1,3 +1,9 @@\n+2004-02-10  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* include/powerpc-signal.h: Revert 2004-01-21 change.\n+\t(INIT_SEGV, INIT_FPE): Provide powerpc64 versions.  Check return\n+\tfrom syscall for ppc32 versions.\n+\n 2004-02-08  Per Bothner  <per@bothner.com>\n \n \t* java/nio/ByteBuffer.java (shiftDown):  New helper method."}, {"sha": "0d5a6627fe7624d51db5514ea18abf2c18398d60", "filename": "libjava/include/powerpc-signal.h", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/libjava%2Finclude%2Fpowerpc-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d5c836a1a426c224efe898b5bad4ed6f3e055e/libjava%2Finclude%2Fpowerpc-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fpowerpc-signal.h?ref=d1d5c836a1a426c224efe898b5bad4ed6f3e055e", "patch": "@@ -11,25 +11,23 @@ details.  */\n \n \n #ifndef JAVA_SIGNAL_H\n-# define JAVA_SIGNAL_H 1\n+#define JAVA_SIGNAL_H 1\n \n-# ifndef __powerpc64__\n+#include <signal.h>\n+#include <sys/syscall.h>\n \n-#  include <signal.h>\n-#  include <sys/syscall.h>\n+#define HANDLE_SEGV 1\n+#undef HANDLE_FPE\n \n-#  define HANDLE_SEGV 1\n-#  undef HANDLE_FPE\n-\n-#  define SIGNAL_HANDLER(_name)\t\t\t\t\t\t\\\n+#define SIGNAL_HANDLER(_name)\t\t\t\t\t\t\\\n   static void _name (int /* _signal */, struct sigcontext *_sc)\n \n /* PPC either leaves PC pointing at a faulting instruction or the\n    following instruction, depending on the signal.  SEGV always does\n    the former, so we adjust the saved PC to point to the following\n    instruction. This is what the handler in libgcc expects.  */\n \n-#  define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n+#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     _sc->regs->nip += 4;\t\t\t\t\t\t\\\n@@ -53,42 +51,69 @@ while (0)\n    compatibility hacks in MAKE_THROW_FRAME, as the ucontext layout\n    on PPC changed during the 2.5 kernel series.  */\n \n+#ifndef __powerpc64__\n struct kernel_old_sigaction {\n   void (*k_sa_handler) (int, struct sigcontext *);\n   unsigned long k_sa_mask;\n   unsigned long k_sa_flags;\n   void (*k_sa_restorer) (void);\n };\n \n-#  define INIT_SEGV\t\t\t\t\t\t\t\\\n+#define INIT_SEGV\t\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     struct kernel_old_sigaction kact;\t\t\t\t\t\\\n     kact.k_sa_handler = catch_segv;\t\t\t\t\t\\\n     kact.k_sa_mask = 0;\t\t\t\t\t\t\t\\\n     kact.k_sa_flags = 0;\t\t\t\t\t\t\\\n-    syscall (SYS_sigaction, SIGSEGV, &kact, NULL);\t\t\t\\\n+    if (syscall (SYS_sigaction, SIGSEGV, &kact, NULL) != 0)\t\t\\\n+      __asm__ __volatile__ (\".long 0\");\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)  \n \n-#  define INIT_FPE\t\t\t\t\t\t\t\\\n+#define INIT_FPE\t\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     struct kernel_old_sigaction kact;\t\t\t\t\t\\\n     kact.k_sa_handler = catch_fpe;\t\t\t\t\t\\\n     kact.k_sa_mask = 0;\t\t\t\t\t\t\t\\\n     kact.k_sa_flags = 0;\t\t\t\t\t\t\\\n-    syscall (SYS_sigaction, SIGFPE, &kact, NULL);\t\t\t\\\n+    if (syscall (SYS_sigaction, SIGFPE, &kact, NULL) != 0)\t\t\\\n+      __asm__ __volatile__ (\".long 0\");\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-# else\n+#else /* powerpc64 */\n+\n+struct kernel_sigaction\n+{\n+  void (*k_sa_handler) (int, struct sigcontext *);\n+  unsigned long k_sa_flags;\n+  void (*k_sa_restorer)(void);\n+  unsigned long k_sa_mask;\n+};\n \n-#  undef HANDLE_SEGV\n-#  undef HANDLE_FPE\n+#define INIT_SEGV\t\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    struct kernel_sigaction kact;\t\t\t\t\t\\\n+    memset (&kact, 0, sizeof (kact));\t\t\t\t\t\\\n+    kact.k_sa_handler = catch_segv;\t\t\t\t\t\\\n+    if (syscall (SYS_rt_sigaction, SIGSEGV, &kact, NULL, 8) != 0)\t\\\n+      __asm__ __volatile__ (\".long 0\");\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)  \n \n-#  define INIT_SEGV   do {} while (0)\n-#  define INIT_FPE   do {} while (0)\n-# endif\n+#define INIT_FPE\t\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    struct kernel_sigaction kact;\t\t\t\t\t\\\n+    memset (&kact, 0, sizeof (kact));\t\t\t\t\t\\\n+    kact.k_sa_handler = catch_fpe;\t\t\t\t\t\\\n+    if (syscall (SYS_rt_sigaction, SIGFPE, &kact, NULL, 8) != 0)\t\\\n+      __asm__ __volatile__ (\".long 0\");\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#endif\n \n #endif /* JAVA_SIGNAL_H */"}]}