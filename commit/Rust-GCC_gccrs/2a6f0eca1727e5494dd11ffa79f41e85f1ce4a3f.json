{"sha": "2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE2ZjBlY2ExNzI3ZTU0OTRkZDExZmZhNzlmNDFlODVmMWNlNGEzZg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-11-07T16:34:37Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-11-07T16:34:37Z"}, "message": "Makefile.in (df.o): Add fibheap.h to dependencies.\n\n2001-11-07  Daniel Berlin  <dan@cgsoftware.com>\n\n        * Makefile.in (df.o): Add fibheap.h to dependencies.\n\n        * df.h: Add prototypes for transfer functions, iterative_dataflow\n        functions.\n        (enum df_flow_dir): New enum.\n        (enum df_confluence_op): New enum.\n        (struct df): Add inverse_rts_map.\n\n        * df.c: Add sbitmap.h to the list of includes.\n        (df_rd_global_compute): Removed.\n        (df_ru_global_compute): Removed.\n        (df_lr_global_compute): Removed.\n        (df_rd_transfer_function): New function.\n        (df_ru_transfer_function): New function.\n        (df_lr_transfer_function): New function.\n        (df_analyse_1): allocate/compute/free df->inverse_rts_map.\n        Use iterative_dataflow_bitmap instead of df_*_global_compute.\n        (iterative_dataflow_sbitmap): New function.\n        (iterative_dataflow_bitmap): New function.\n\nFrom-SVN: r46827", "tree": {"sha": "33eb1552401de9032f76941b218708537752d6c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33eb1552401de9032f76941b218708537752d6c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/comments", "author": null, "committer": null, "parents": [{"sha": "526ca58c2642fb5a5758381bddcfc0059195ae55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526ca58c2642fb5a5758381bddcfc0059195ae55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/526ca58c2642fb5a5758381bddcfc0059195ae55"}], "stats": {"total": 734, "additions": 453, "deletions": 281}, "files": [{"sha": "df947461d343d03f44564cafd5d1fd13d993363a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "patch": "@@ -1,3 +1,25 @@\n+2001-11-07  Daniel Berlin  <dan@cgsoftware.com>\n+\n+        * Makefile.in (df.o): Add fibheap.h to dependencies.\n+       \n+        * df.h: Add prototypes for transfer functions, iterative_dataflow\n+        functions.\n+        (enum df_flow_dir): New enum.\n+        (enum df_confluence_op): New enum.\n+        (struct df): Add inverse_rts_map.\n+\n+        * df.c: Add sbitmap.h to the list of includes.\n+        (df_rd_global_compute): Removed.\n+        (df_ru_global_compute): Removed.\n+        (df_lr_global_compute): Removed.\n+        (df_rd_transfer_function): New function.\n+        (df_ru_transfer_function): New function.\n+        (df_lr_transfer_function): New function.\n+        (df_analyse_1): allocate/compute/free df->inverse_rts_map.\n+        Use iterative_dataflow_bitmap instead of df_*_global_compute.\n+        (iterative_dataflow_sbitmap): New function.\n+        (iterative_dataflow_bitmap): New function.\n+\n 2001-11-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* doc/gcc.texi: Move terminology and spelling conventions to"}, {"sha": "8a9bf0e58e56bdb9e6bd606e4dfd4f23bcdb7577", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "patch": "@@ -231,6 +231,7 @@ SYSTEM_HEADER_DIR = /usr/include\n HASHTAB_H   = $(srcdir)/../include/hashtab.h\n OBSTACK_H   = $(srcdir)/../include/obstack.h\n SPLAY_TREE_H= $(srcdir)/../include/splay-tree.h\n+FIBHEAP_H   = $(srcdir)/../include/fibheap.h\n \n # Default cross SYSTEM_HEADER_DIR, to be overridden by targets.\n CROSS_SYSTEM_HEADER_DIR = $(tooldir)/sys-include\n@@ -1480,7 +1481,8 @@ ssa-ccp.o : ssa-ccp.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h \\\n     $(BASIC_BLOCK_H) ssa.h insn-config.h $(RECOG_H) output.h \\\n     errors.h $(GGC_H) df.h function.h\n df.o : df.c $(CONFIG_H) system.h $(RTL_H) insn-config.h $(RECOG_H) \\\n-   function.h $(REGS_H) $(OBSTACK_H) hard-reg-set.h $(BASIC_BLOCK_H) df.h\n+   function.h $(REGS_H) $(OBSTACK_H) hard-reg-set.h $(BASIC_BLOCK_H) df.h \\\n+   $(FIBHEAP_H)\n conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H) $(HASHTAB_H) \\\n    $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\"}, {"sha": "9af3518e2fe1ee1658160d2ba749013eb981dceb", "filename": "gcc/df.c", "status": "modified", "additions": 390, "deletions": 274, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "patch": "@@ -153,7 +153,7 @@ when optimising a loop, only certain registers are of interest.\n Perhaps there should be a bitmap argument to df_analyse to specify\n  which registers should be analysed?   */\n \n-#define HANDLE_SUBREG\n+#define HANDLE_SUBREG \n \n #include \"config.h\"\n #include \"system.h\"\n@@ -166,9 +166,10 @@ Perhaps there should be a bitmap argument to df_analyse to specify\n #include \"obstack.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"sbitmap.h\"\n #include \"bitmap.h\"\n #include \"df.h\"\n-\n+#include \"fibheap.h\"\n \n #define FOR_ALL_BBS(BB, CODE)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n@@ -239,8 +240,6 @@ static void df_insn_refs_record PARAMS((struct df *, basic_block, rtx));\n static void df_bb_refs_record PARAMS((struct df *, basic_block));\n static void df_refs_record PARAMS((struct df *, bitmap));\n \n-static int df_visit_next_rc PARAMS ((struct df *, sbitmap));\n-static int df_visit_next_rts PARAMS ((struct df *, sbitmap));\n static void df_bb_reg_def_chain_create PARAMS((struct df *, basic_block));\n static void df_reg_def_chain_create PARAMS((struct df *, bitmap));\n static void df_bb_reg_use_chain_create PARAMS((struct df *, basic_block));\n@@ -249,9 +248,6 @@ static void df_bb_du_chain_create PARAMS((struct df *, basic_block, bitmap));\n static void df_du_chain_create PARAMS((struct df *, bitmap));\n static void df_bb_ud_chain_create PARAMS((struct df *, basic_block));\n static void df_ud_chain_create PARAMS((struct df *, bitmap));\n-static void df_rd_global_compute PARAMS((struct df *, bitmap));\n-static void df_ru_global_compute PARAMS((struct df *, bitmap));\n-static void df_lr_global_compute PARAMS((struct df *, bitmap));\n static void df_bb_rd_local_compute PARAMS((struct df *, basic_block));\n static void df_rd_local_compute PARAMS((struct df *, bitmap));\n static void df_bb_ru_local_compute PARAMS((struct df *, basic_block));\n@@ -296,6 +292,12 @@ static void df_chain_dump PARAMS((struct df_link *, FILE *file));\n static void df_chain_dump_regno PARAMS((struct df_link *, FILE *file));\n static void df_regno_debug PARAMS ((struct df *, unsigned int, FILE *));\n static void df_ref_debug PARAMS ((struct df *, struct ref *, FILE *));\n+static void df_rd_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n+\t\t\t\t\t     bitmap, bitmap, void *));\n+static void df_ru_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n+\t\t\t\t\t     bitmap, bitmap, void *));\n+static void df_lr_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n+\t\t\t\t\t     bitmap, bitmap, void *));\n \n \f\n /* Local memory allocation/deallocation routines.  */\n@@ -898,7 +900,6 @@ df_ref_record (df, reg, loc, bb, insn, ref_type)\n     }\n }\n \n-\n /* Process all the registers defined in the rtx, X.  */\n static void\n df_def_record_1 (df, x, bb, insn)\n@@ -951,9 +952,9 @@ df_def_record_1 (df, x, bb, insn)\n       dst = *loc;\n     }\n #endif\n-\n-  if (GET_CODE (dst) == REG\n-      || (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n+  \n+    if (GET_CODE (dst) == REG\n+        || (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n       df_ref_record (df, dst, loc, bb, insn, DF_REF_REG_DEF);\n }\n \n@@ -1040,6 +1041,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \t  df_uses_record (df, loc, ref_type, bb, insn);\n \t  return;\n \t}\n+\n #else\n       loc = &SUBREG_REG (x);\n       x = *loc;\n@@ -1049,7 +1051,6 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \t  return;\n \t}\n #endif\n-\n       /* ... Fall through ...  */\n \n     case REG:\n@@ -1619,260 +1620,34 @@ df_ud_chain_create (df, blocks)\n }\n \f\n \n-/* Use reverse completion order, and the worklist, to figure out what block\n-   to look at next.  */\n-\n-static int\n-df_visit_next_rc (df, blocks)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     sbitmap blocks;\n-{\n-  int i=0;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (TEST_BIT (blocks, df->rc_order[i]))\n-      return df->rc_order[i];\n-  return sbitmap_first_set_bit (blocks);\n-}\n-\n-/* Use reverse topsort order, and the worklist, to figure out what block\n-   to look at next.  */\n-\n-static int\n-df_visit_next_rts (df, blocks)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     sbitmap blocks;\n-{\n-  int i=0;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (TEST_BIT (blocks, df->rts_order[i]))\n-      return df->rts_order[i];\n-  return sbitmap_first_set_bit (blocks);\n-}\n \n-\n-/* Calculate reaching defs for each basic block in BLOCKS, i.e., the\n-   defs that are live at the start of a basic block.  */\n static void\n-df_rd_global_compute (df, blocks)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     bitmap blocks;\n+df_rd_transfer_function (bb, changed, in, out, gen, kill, data)\n+     int bb ATTRIBUTE_UNUSED;\n+     int *changed;\n+     bitmap in, out, gen, kill;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  int i;\n-  basic_block bb;\n-  sbitmap worklist;\n-\n-  worklist = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (worklist);\n-\n-  /* Copy the blocklist to the worklist */\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-  {\n-    SET_BIT (worklist, i);\n-  });\n-\n-  /* We assume that only the basic blocks in WORKLIST have been\n-     modified.  */\n-  FOR_EACH_BB_IN_SBITMAP (worklist, 0, bb,\n-    {\n-      struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-\n-      bitmap_copy (bb_info->rd_out, bb_info->rd_gen);\n-    });\n-\n-  while ((i = df_visit_next_rc (df, worklist)) >= 0)\n-    {\n-      struct bb_info *bb_info;\n-      edge e;\n-      int changed;\n-\n-      /* Remove this block from the worklist.  */\n-      RESET_BIT (worklist, i);\n-\n-\n-      bb = BASIC_BLOCK (i);\n-      bb_info = DF_BB_INFO (df, bb);\n-\n-      /* Calculate union of predecessor outs.  */\n-      bitmap_zero (bb_info->rd_in);\n-      for (e = bb->pred; e != 0; e = e->pred_next)\n-\t{\n-\t  struct bb_info *pred_refs = DF_BB_INFO (df, e->src);\n-\n-\t  if (e->src == ENTRY_BLOCK_PTR)\n-\t    continue;\n-\n-\t  bitmap_a_or_b (bb_info->rd_in, bb_info->rd_in,\n-\t\t\t  pred_refs->rd_out);\n-\t}\n-\n-      /* RD_OUT is the set of defs that are live at the end of the\n-\t BB.  These are the defs that are either generated by defs\n-\t (RD_GEN) within the BB or are live at the start (RD_IN)\n-\t and are not killed by other defs (RD_KILL).  */\n-      changed = bitmap_union_of_diff (bb_info->rd_out, bb_info->rd_gen,\n-\t\t\t\t       bb_info->rd_in, bb_info->rd_kill);\n-\n-      if (changed)\n-\t{\n-\t  /* Add each of this block's successors to the worklist.  */\n-\t  for (e = bb->succ; e != 0; e = e->succ_next)\n-\t    {\n-\t      if (e->dest == EXIT_BLOCK_PTR)\n-\t\tcontinue;\n-\n-\t      SET_BIT (worklist, e->dest->index);\n-\t    }\n-\t}\n-    }\n-  sbitmap_free (worklist);\n+  *changed = bitmap_union_of_diff (out, gen, in, kill);\n }\n-\n-\n-/* Calculate reaching uses for each basic block within BLOCKS, i.e.,\n-   the uses that are live at the start of a basic block.  */\n static void\n-df_ru_global_compute (df, blocks)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     bitmap blocks;\n+df_ru_transfer_function (bb, changed, in, out, gen, kill, data)\n+     int bb ATTRIBUTE_UNUSED;\n+     int *changed;\n+     bitmap in, out, gen, kill;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  int i;\n-  basic_block bb;\n-  sbitmap worklist;\n-\n-  worklist = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (worklist);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-  {\n-    SET_BIT (worklist, i);\n-  });\n-\n-  /* We assume that only the basic blocks in WORKLIST have been\n-     modified.  */\n-  FOR_EACH_BB_IN_SBITMAP (worklist, 0, bb,\n-    {\n-      struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-\n-      bitmap_copy (bb_info->ru_in, bb_info->ru_gen);\n-    });\n-\n-\n-  while ((i = df_visit_next_rts (df, worklist)) >= 0)\n-    {\n-      struct bb_info *bb_info;\n-      edge e;\n-      int changed;\n-\n-      /* Remove this block from the worklist.  */\n-      RESET_BIT (worklist, i);\n-\n-      bb = BASIC_BLOCK (i);\n-      bb_info = DF_BB_INFO (df, bb);\n-\n-      /* Calculate union of successor ins.  */\n-      bitmap_zero (bb_info->ru_out);\n-      for (e = bb->succ; e != 0; e = e->succ_next)\n-\t{\n-\t  struct bb_info *succ_refs = DF_BB_INFO (df, e->dest);\n-\n-\t  if (e->dest == EXIT_BLOCK_PTR)\n-\t    continue;\n-\n-\t  bitmap_a_or_b (bb_info->ru_out, bb_info->ru_out,\n-\t\t\t  succ_refs->ru_in);\n-\t}\n-\n-      /* RU_IN is the set of uses that are live at the start of the\n-\t BB.  These are the uses that are either generated within the\n-\t BB (RU_GEN) or are live at the end (RU_OUT) and are not uses\n-\t killed by defs within the BB (RU_KILL).  */\n-      changed = bitmap_union_of_diff (bb_info->ru_in, bb_info->ru_gen,\n-\t\t\t\t       bb_info->ru_out, bb_info->ru_kill);\n-\n-      if (changed)\n-\t{\n-\t  /* Add each of this block's predecessors to the worklist.  */\n-\t  for (e = bb->pred; e != 0; e = e->pred_next)\n-\t    {\n-\t      if (e->src == ENTRY_BLOCK_PTR)\n-\t\tcontinue;\n-\n-\t      SET_BIT (worklist, e->src->index);\n-\t    }\n-\t}\n-    }\n-\n-  sbitmap_free (worklist);\n+  *changed = bitmap_union_of_diff (in, gen, out, kill);\n }\n \n-\n-/* Calculate live registers for each basic block within BLOCKS.  */\n static void\n-df_lr_global_compute (df, blocks)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     bitmap blocks;\n+df_lr_transfer_function (bb, changed, in, out, use, def, data)\n+     int bb ATTRIBUTE_UNUSED;\n+     int *changed;\n+     bitmap in, out, use, def;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  int i;\n-  basic_block bb;\n-  bitmap worklist;\n-\n-  worklist = BITMAP_XMALLOC ();\n-  bitmap_copy (worklist, blocks);\n-\n-  /* We assume that only the basic blocks in WORKLIST have been\n-     modified.  */\n-  FOR_EACH_BB_IN_BITMAP (worklist, 0, bb,\n-    {\n-      struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-\n-      bitmap_copy (bb_info->lr_in, bb_info->lr_use);\n-    });\n-\n-  while ((i = bitmap_last_set_bit (worklist)) >= 0)\n-    {\n-      struct bb_info *bb_info = DF_BB_INFO (df, bb);\n-      edge e;\n-      int changed;\n-\n-      /* Remove this block from the worklist.  */\n-      bitmap_clear_bit (worklist, i);\n-\n-      bb = BASIC_BLOCK (i);\n-      bb_info = DF_BB_INFO (df, bb);\n-\n-      /* Calculate union of successor ins.  */\n-      bitmap_zero (bb_info->lr_out);\n-      for (e = bb->succ; e != 0; e = e->succ_next)\n-\t{\n-\t  struct bb_info *succ_refs = DF_BB_INFO (df, e->dest);\n-\n-\t  if (e->dest == EXIT_BLOCK_PTR)\n-\t    continue;\n-\n-\t  bitmap_a_or_b (bb_info->lr_out, bb_info->lr_out,\n-\t\t\t  succ_refs->lr_in);\n-\t}\n-\n-      /* LR_IN is the set of uses that are live at the start of the\n-\t BB.  These are the uses that are either generated by uses\n-\t (LR_USE) within the BB or are live at the end (LR_OUT)\n-\t and are not killed by other uses (LR_DEF).  */\n-      changed = bitmap_union_of_diff (bb_info->lr_in, bb_info->lr_use,\n-\t\t\t\t       bb_info->lr_out, bb_info->lr_def);\n-\n-      if (changed)\n-\t{\n-\t  /* Add each of this block's predecessors to the worklist.  */\n-\t  for (e = bb->pred; e != 0; e = e->pred_next)\n-\t    {\n-\t      if (e->src == ENTRY_BLOCK_PTR)\n-\t\tcontinue;\n-\n-\t      bitmap_set_bit (worklist, e->src->index);\n-\t    }\n-\t}\n-    }\n-  BITMAP_XFREE (worklist);\n+  *changed = bitmap_union_of_diff (in, use, out, def);\n }\n \n \n@@ -1918,7 +1693,7 @@ df_bb_rd_local_compute (df, bb)\n \t  bitmap_set_bit (bb_info->rd_gen, DF_REF_ID (def));\n \t}\n     }\n-\n+  \n   bb_info->rd_valid = 1;\n }\n \n@@ -1948,10 +1723,11 @@ df_bb_ru_local_compute (df, bb)\n   /* This is much more tricky than computing reaching defs.  With\n      reaching defs, defs get killed by other defs.  With upwards\n      exposed uses, these get killed by defs with the same regno.  */\n-\n+  \n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n \n+\n   for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n        insn = PREV_INSN (insn))\n     {\n@@ -2071,7 +1847,7 @@ static void\n df_bb_reg_info_compute (df, bb, live)\n      struct df *df;\n      basic_block bb;\n-  bitmap live;\n+     bitmap live;\n {\n   struct reg_info *reg_info = df->regs;\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n@@ -2190,7 +1966,7 @@ df_analyse_1 (df, blocks, flags, update)\n {\n   int aflags;\n   int dflags;\n-\n+  int i;\n   dflags = 0;\n   aflags = flags;\n   if (flags & DF_UD_CHAIN)\n@@ -2257,16 +2033,43 @@ df_analyse_1 (df, blocks, flags, update)\n   df->dfs_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rc_order = xmalloc (sizeof(int) * n_basic_blocks);\n   df->rts_order = xmalloc (sizeof(int) * n_basic_blocks);\n-\n+  df->inverse_dfs_map = xmalloc (sizeof(int) * n_basic_blocks);\n+  df->inverse_rc_map = xmalloc (sizeof(int) * n_basic_blocks);\n+  df->inverse_rts_map = xmalloc (sizeof(int) * n_basic_blocks);\n+  \n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n   flow_reverse_top_sort_order_compute (df->rts_order);\n+  for (i = 0; i < n_basic_blocks; i ++)\n+   {\n+     df->inverse_dfs_map[df->dfs_order[i]] = i;\n+     df->inverse_rc_map[df->rc_order[i]] = i;\n+     df->inverse_rts_map[df->rts_order[i]] = i;\n+   }\n   if (aflags & DF_RD)\n     {\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n       df_rd_local_compute (df, df->flags & DF_RD ? blocks : df->all_blocks);\n-\n-      /* Compute the global reaching definitions.  */\n-      df_rd_global_compute (df, df->all_blocks);\n+      {\n+\tint i;\n+\tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *gen = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *kill = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tfor (i = 0; i < n_basic_blocks; i ++)\n+\t  {\n+\t    in[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_in;\n+\t    out[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_out;\n+\t    gen[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_gen;\n+\t    kill[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_kill;\n+\t  }\n+\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks, \n+\t\t\t\t   FORWARD, UNION, df_rd_transfer_function,\n+\t\t\t\t   df->inverse_rc_map, NULL);\n+\tfree (in);\n+\tfree (out);\n+\tfree (gen);\n+\tfree (kill);\n+      }\n     }\n \n   if (aflags & DF_UD_CHAIN)\n@@ -2283,9 +2086,27 @@ df_analyse_1 (df, blocks, flags, update)\n       /* Compute the sets of gens and kills for the upwards exposed\n \t uses in each bb.  */\n       df_ru_local_compute (df, df->flags & DF_RU ? blocks : df->all_blocks);\n-\n-      /* Compute the global reaching uses.  */\n-      df_ru_global_compute (df, df->all_blocks);\n+      {\n+\tint i;\n+\tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *gen = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *kill = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tfor (i = 0; i < n_basic_blocks; i ++)\n+\t  {\n+\t    in[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_in;\n+\t    out[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_out;\n+\t    gen[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_gen;\n+\t    kill[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_kill;\n+\t  }\n+\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks, \n+\t\t\t\t   BACKWARD, UNION, df_ru_transfer_function,\n+\t\t\t\t   df->inverse_rts_map, NULL);\n+\tfree (in);\n+\tfree (out);\n+\tfree (gen);\n+\tfree (kill);\n+      }\n     }\n \n   if (aflags & DF_DU_CHAIN)\n@@ -2304,10 +2125,28 @@ df_analyse_1 (df, blocks, flags, update)\n   if (aflags & DF_LR)\n     {\n       /* Compute the sets of defs and uses of live variables.  */\n-      df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);\n-\n-      /* Compute the global live variables.  */\n-      df_lr_global_compute (df, df->all_blocks);\n+      df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);      \n+      {\n+\tint i;\n+\tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *use = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tbitmap *def = xmalloc (sizeof (bitmap) * n_basic_blocks);\n+\tfor (i = 0; i < n_basic_blocks; i ++)\n+\t  {\n+\t    in[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_in;\n+\t    out[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_out;\n+\t    use[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_use;\n+\t    def[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_def;\n+\t  }\n+\titerative_dataflow_bitmap (in, out, use, def, df->all_blocks, \n+\t\t\t\t   BACKWARD, UNION, df_lr_transfer_function,\n+\t\t\t\t   df->inverse_rts_map, NULL);\n+\tfree (in);\n+\tfree (out);\n+\tfree (use);\n+\tfree (def);\n+      }\n     }\n \n   if (aflags & DF_REG_INFO)\n@@ -2317,6 +2156,9 @@ df_analyse_1 (df, blocks, flags, update)\n   free (df->dfs_order);\n   free (df->rc_order);\n   free (df->rts_order);\n+  free (df->inverse_rc_map);\n+  free (df->inverse_dfs_map);\n+  free (df->inverse_rts_map);\n }\n \n \n@@ -2641,14 +2483,11 @@ df_insn_modify (df, bb, insn)\n   bitmap_set_bit (df->bbs_modified, bb->index);\n   bitmap_set_bit (df->insns_modified, uid);\n \n-#if 0\n   /* For incremental updating on the fly, perhaps we could make a copy\n      of all the refs of the original insn and turn them into\n      anti-refs.  When df_refs_update finds these anti-refs, it annihilates\n      the original refs.  If validate_change fails then these anti-refs\n      will just get ignored.  */\n-  */\n-#endif\n }\n \n \n@@ -3770,3 +3609,280 @@ debug_df_chain (link)\n   df_chain_dump (link, stderr);\n   fputc ('\\n', stderr);\n }\n+\n+/* gen = GEN set.\n+   kill = KILL set.\n+   in, out = Filled in by function.\n+   blocks = Blocks to analyze.\n+   dir = Dataflow direction.\n+   conf_op = Confluence operation.\n+   transfun = Transfer function.\n+   order = Order to iterate in. (Should map block numbers -> order)\n+   data = Whatever you want.  It's passed to the transfer function.\n+   \n+   This function will perform iterative bitvector dataflow, producing\n+   the in and out sets.  Even if you only want to perform it for a\n+   small number of blocks, the vectors for in and out must be large\n+   enough for *all* blocks, because changing one block might affect\n+   others.  However, it'll only put what you say to analyze on the\n+   initial worklist.\n+   \n+   For forward problems, you probably want to pass in a mapping of\n+   block number to rc_order (like df->inverse_rc_map).\n+*/\n+\n+void\n+iterative_dataflow_sbitmap (in, out, gen, kill, blocks, \n+\t\t\t    dir, conf_op, transfun, order, data)\n+     sbitmap *in, *out, *gen, *kill;\n+     bitmap blocks;\n+     enum df_flow_dir dir;\n+     enum df_confluence_op conf_op;\n+     transfer_function_sbitmap transfun;\n+     int *order;\n+     void *data;\n+{\n+  int changed;\n+  int i;\n+  fibheap_t worklist;\n+  sbitmap onqueue;\n+  basic_block bb;\n+  onqueue = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (onqueue);\n+  worklist = fibheap_new ();\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+  {\n+    fibheap_insert (worklist, order[i], (void *) i); \n+    SET_BIT (onqueue, i);\n+    if (dir == FORWARD)\n+      {\n+\tsbitmap_copy (out[i], gen[i]);\n+      }\n+    else\n+      {\n+\tsbitmap_copy (in[i], gen[i]);\n+      }\n+    \n+  });\n+  while (!fibheap_empty (worklist))\n+    {\n+      edge e;\n+      i = (int) fibheap_extract_min  (worklist);\n+      changed = 0;\n+      bb = BASIC_BLOCK (i);\n+      RESET_BIT (onqueue, i);\n+      if (dir == FORWARD)\n+\t{\n+\t  /*  Calculate <conf_op> of predecessor_outs */\n+\t  for (e = bb->pred; e != 0; e = e->pred_next)\n+\t    {\n+\t      if (e->src == ENTRY_BLOCK_PTR)\n+\t\t{\n+\t\t  sbitmap_zero (in[i]);\n+\t\t  continue;\n+\t\t}\n+\t      sbitmap_copy (in[i], out[e->src->index]);\n+\t      break;\n+\t    }\n+\t  if (e == 0)\n+\t    sbitmap_zero (in[i]);\n+\t  for (e = bb->pred; e != 0; e = e->pred_next)\n+\t    {\n+\t      if (e->src == ENTRY_BLOCK_PTR)\n+\t\tcontinue;\n+\t      switch (conf_op)\n+\t\t{\n+\t\tcase UNION:\n+\t\t  sbitmap_a_or_b (in[i], in[i], out[e->src->index]);\n+\t\t  break;\n+\t\tcase INTERSECTION:\n+\t\t  sbitmap_a_and_b (in[i], in[i], out[e->src->index]);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else \n+\t{\n+\t  /* Calculate <conf_op> of successor ins */\n+\t  sbitmap_zero (out[i]);\n+\t  for (e = bb->succ; e != 0; e = e->succ_next)\n+\t    {\n+\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\t      switch (conf_op)\n+\t\t{\t\n+\t\tcase UNION:\n+\t\t  sbitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n+\t\t  break;\n+\t\tcase INTERSECTION:\n+\t\t  sbitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}      \n+      /* Common part */\n+      (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n+\n+      if (changed)\n+\t{\n+\t  if (dir == FORWARD)\n+\t    {\n+\t      for (e = bb->succ; e != 0; e = e->succ_next)\n+\t\t{\n+\t\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t\t    continue;\n+\t\t  if (!TEST_BIT (onqueue, e->dest->index))\n+\t\t    { \n+\t\t      SET_BIT (onqueue, e->dest->index);\n+\t\t      fibheap_insert (worklist, \n+\t\t\t\t      order[e->dest->index], \n+\t\t\t\t      (void *)e->dest->index);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      for (e = bb->pred; e != 0; e = e->pred_next)\n+\t\t{\n+\t\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t\t    continue;\n+\t\t  if (!TEST_BIT (onqueue, e->src->index))\n+\t\t    {\n+\t\t      SET_BIT (onqueue, e->src->index);\n+\t\t      fibheap_insert (worklist, \n+\t\t\t\t      order[e->src->index], \n+\t\t\t\t      (void *)e->src->index);\n+\t\t    }\n+\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  sbitmap_free (onqueue);\n+  fibheap_delete (worklist);\n+  \n+}\n+/* Exactly the same as iterative_dataflow_sbitmap, except it works on\n+   bitmaps instead */\n+void\n+iterative_dataflow_bitmap (in, out, gen, kill, blocks, \n+\t\t\t   dir, conf_op, transfun, order, data)     \n+     bitmap *in, *out, *gen, *kill;\n+     bitmap blocks;\n+     enum df_flow_dir dir;\n+     enum df_confluence_op conf_op;\n+     transfer_function_bitmap transfun;\n+     int *order;\n+     void *data;\n+{\n+  int changed;\n+  int i;\n+  fibheap_t worklist;\n+  sbitmap onqueue;\n+  basic_block bb;\n+\n+  onqueue = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (onqueue);\n+  worklist = fibheap_new ();\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+  {\n+    fibheap_insert (worklist, order[i], (void *) i); \n+    SET_BIT (onqueue, i);\n+    if (dir == FORWARD)\n+      {\n+\tbitmap_copy (out[i], gen[i]);\n+      }\n+    else\n+      {\n+\tbitmap_copy (in[i], gen[i]);\n+      }\n+    \n+  });\n+  while (!fibheap_empty (worklist))\n+    {\n+      edge e;\n+      i = (int) fibheap_extract_min  (worklist);\n+      changed = 0;\n+      bb = BASIC_BLOCK (i);\n+      RESET_BIT (onqueue, i);\n+      \n+      if (dir == FORWARD)\n+\t{\n+\t  /*  Calculate <conf_op> of predecessor_outs */\n+\t  bitmap_zero (in[i]);\n+\t  for (e = bb->pred; e != 0; e = e->pred_next)\n+\t    {\n+\t      if (e->src == ENTRY_BLOCK_PTR)\n+\t\tcontinue;\n+\t      switch (conf_op)\n+\t\t{\n+\t\tcase UNION:\n+\t\t  bitmap_a_or_b (in[i], in[i], out[e->src->index]);\n+\t\t  break;\n+\t\tcase INTERSECTION:\n+\t\t  bitmap_a_and_b (in[i], in[i], out[e->src->index]);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else \n+\t{\n+\t  /* Calculate <conf_op> of successor ins */\n+\t  bitmap_zero(out[i]);\n+\t  for (e = bb->succ; e != 0; e = e->succ_next)\n+\t    {\n+\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\t      switch (conf_op)\n+\t\t{\t\n+\t\tcase UNION:\n+\t\t  bitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n+\t\t  break;\n+\t\tcase INTERSECTION:\n+\t\t  bitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}      \n+      /* Common part */\n+      (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n+\n+      if (changed)\n+\t{\n+\t  if (dir == FORWARD)\n+\t    {\n+\t      for (e = bb->succ; e != 0; e = e->succ_next)\n+\t\t{\n+\t\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t\t    continue;\n+\t\t  if (!TEST_BIT (onqueue, e->dest->index))\n+\t\t    { \n+\t\t      SET_BIT (onqueue, e->dest->index);\n+\t\t      fibheap_insert (worklist, \n+\t\t\t\t      order[e->dest->index], \n+\t\t\t\t      (void *)e->dest->index);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      for (e = bb->pred; e != 0; e = e->pred_next)\n+\t\t{\n+\t\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t\t    continue;\n+\t\t  if (!TEST_BIT (onqueue, e->src->index))\n+\t\t    {\n+\t\t      SET_BIT (onqueue, e->src->index);\n+\t\t      fibheap_insert (worklist, \n+\t\t\t\t      order[e->src->index], \n+\t\t\t\t      (void *)e->src->index);\n+\t\t    }\n+\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  sbitmap_free (onqueue);\n+  fibheap_delete (worklist);\n+  \n+}"}, {"sha": "89c62883a0a45e292079d30eff6cdd435f502db6", "filename": "gcc/df.h", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=2a6f0eca1727e5494dd11ffa79f41e85f1ce4a3f", "patch": "@@ -20,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-\n #define DF_RD\t\t 1\t/* Reaching definitions.  */\n #define DF_RU\t\t 2\t/* Reaching uses.  */\n #define DF_LR\t\t 4\t/* Live registers.  */\n@@ -136,12 +135,15 @@ struct df\n   bitmap insns_modified;\t/* Insns that (may) have changed.  */\n   bitmap bbs_modified;\t\t/* Blocks that (may) have changed.  */\n   bitmap all_blocks;\t\t/* All blocks in CFG.  */\n-  /* The bitmap vector of dominators or NULL if not computed. \n+  /* The sbitmap vector of dominators or NULL if not computed. \n      Ideally, this should be a pointer to a CFG object.  */\n-  bitmap *dom;\n-  int * dfs_order;\n-  int * rc_order;\n-  int * rts_order;\n+  sbitmap *dom;\n+  int * dfs_order; /* DFS order -> block number */\n+  int * rc_order; /* reverse completion order -> block number */\n+  int * rts_order; /* reverse top sort order -> block number */\n+  int * inverse_rc_map; /* block number -> reverse completion order */\n+  int * inverse_dfs_map; /* block number -> DFS order */\n+  int * inverse_rts_map; /* block number -> reverse top-sort order */\n };\n \n \n@@ -297,3 +299,33 @@ extern void debug_df_ref PARAMS ((struct ref *));\n extern void debug_df_chain PARAMS ((struct df_link *));\n extern void df_insn_debug PARAMS ((struct df *, rtx, FILE *));\n extern void df_insn_debug_regno PARAMS ((struct df *, rtx, FILE *));\n+/* Meet over any path (UNION) or meet over all paths (INTERSECTION) */\n+enum df_confluence_op\n+  {\n+    UNION,\n+    INTERSECTION\n+  };\n+/* Dataflow direction */\n+enum df_flow_dir\n+  {\n+    FORWARD,\n+    BACKWARD\n+  };\n+\n+typedef void (*transfer_function_sbitmap) (int, int *, sbitmap, sbitmap, \n+\t\t\t\t\t   sbitmap, sbitmap, void *);\n+typedef void (*transfer_function_bitmap) (int, int *, bitmap, bitmap,\n+\t\t\t\t\t  bitmap, bitmap, void *);\n+\n+extern void iterative_dataflow_sbitmap PARAMS ((sbitmap *, sbitmap *, \n+\t\t\t\t\t\tsbitmap *, sbitmap *, \n+\t\t\t\t\t\tbitmap, enum df_flow_dir, \n+\t\t\t\t\t\tenum df_confluence_op, \n+\t\t\t\t\t\ttransfer_function_sbitmap, \n+\t\t\t\t\t\tint *, void *));\n+extern void iterative_dataflow_bitmap PARAMS ((bitmap *, bitmap *, bitmap *, \n+\t\t\t\t\t       bitmap *, bitmap, \n+\t\t\t\t\t       enum df_flow_dir, \n+\t\t\t\t\t       enum df_confluence_op, \n+\t\t\t\t\t       transfer_function_bitmap, \n+\t\t\t\t\t       int *, void *));"}]}