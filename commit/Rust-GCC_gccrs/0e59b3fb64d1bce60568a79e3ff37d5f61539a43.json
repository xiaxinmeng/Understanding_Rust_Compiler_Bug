{"sha": "0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1OWIzZmI2NGQxYmNlNjA1NjhhNzllM2ZmMzdkNWY2MTUzOWE0Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-11-12T19:57:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-11-12T19:57:56Z"}, "message": "decl.c (finish_case_label): Do not check that we are within a switch statement here.\n\n\t* decl.c (finish_case_label): Do not check that we are within a\n\tswitch statement here.\n\t* parser.c (struct cp_parser): Add in_iteration_statement_p and\n\tin_switch_statement_p.\n\t(cp_parser_new): Initialize them.\n\t(cp_parser_labeled_statement): Check validity of case labels\n\there.\n\t(cp_parser_selection_statement): Set in_switch_statement_p.\n\t(cp_parser_iteration_statement): Set in_iteration_statement_p.\n\t(cp_parser_jump_statement): Check validity of break/continue\n\tstatements here.\n\nFrom-SVN: r73508", "tree": {"sha": "aa9b2c397865aa98457ff6c9f73d6eeff4d68475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa9b2c397865aa98457ff6c9f73d6eeff4d68475"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/comments", "author": null, "committer": null, "parents": [{"sha": "d5123baefb715e5d861535910f3c82deb8675f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5123baefb715e5d861535910f3c82deb8675f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5123baefb715e5d861535910f3c82deb8675f22"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "d8c54b02220a2c6c0c69fe8295a3a6a134c45797", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "patch": "@@ -1,5 +1,17 @@\n 2003-11-12  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* decl.c (finish_case_label): Do not check that we are within a\n+\tswitch statement here.\n+\t* parser.c (struct cp_parser): Add in_iteration_statement_p and\n+\tin_switch_statement_p.\n+\t(cp_parser_new): Initialize them.\n+\t(cp_parser_labeled_statement): Check validity of case labels\n+\there.\n+\t(cp_parser_selection_statement): Set in_switch_statement_p.\n+\t(cp_parser_iteration_statement): Set in_iteration_statement_p.\n+\t(cp_parser_jump_statement): Check validity of break/continue\n+\tstatements here.\n+\n \tPR c++/12735\n \t* cp-tree.h (duplicate_decls): Return a tree.\n \t* decl.c (duplicate_decls): Clarify documentation.  Return"}, {"sha": "b1fd4f793d5013144808750c3b3eb47f4f884af7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "patch": "@@ -2433,18 +2433,6 @@ finish_case_label (tree low_value, tree high_value)\n   tree cond, r;\n   register struct cp_binding_level *p;\n \n-  if (! switch_stack)\n-    {\n-      if (high_value)\n-\terror (\"case label not within a switch statement\");\n-      else if (low_value)\n-\terror (\"case label `%E' not within a switch statement\",\n-\t\t  low_value);\n-      else\n-\terror (\"`default' label not within a switch statement\");\n-      return NULL_TREE;\n-    }\n-\n   if (processing_template_decl)\n     {\n       tree label;"}, {"sha": "5e24fd56b71ef6276075d7f8bfc79d6b4932ee10", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e59b3fb64d1bce60568a79e3ff37d5f61539a43/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0e59b3fb64d1bce60568a79e3ff37d5f61539a43", "patch": "@@ -1230,6 +1230,14 @@ typedef struct cp_parser GTY(())\n      direct-declarator.  */\n   bool in_declarator_p;\n \n+  /* TRUE if we are presently parsing the body of an\n+     iteration-statement.  */\n+  bool in_iteration_statement_p;\n+\n+  /* TRUE if we are presently parsing the body of a switch\n+     statement.  */\n+  bool in_switch_statement_p;\n+\n   /* If non-NULL, then we are parsing a construct where new type\n      definitions are not permitted.  The string stored here will be\n      issued as an error message if a type is defined.  */\n@@ -2118,6 +2126,12 @@ cp_parser_new (void)\n   /* We are not processing a declarator.  */\n   parser->in_declarator_p = false;\n \n+  /* We are not in an iteration statement.  */\n+  parser->in_iteration_statement_p = false;\n+\n+  /* We are not in a switch statement.  */\n+  parser->in_switch_statement_p = false;\n+\n   /* The unparsed function queue is empty.  */\n   parser->unparsed_functions_queues = build_tree_list (NULL_TREE, NULL_TREE);\n \n@@ -5228,7 +5242,7 @@ static tree\n cp_parser_labeled_statement (cp_parser* parser, bool in_statement_expr_p)\n {\n   cp_token *token;\n-  tree statement = NULL_TREE;\n+  tree statement = error_mark_node;\n \n   /* The next token should be an identifier.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -5251,16 +5265,20 @@ cp_parser_labeled_statement (cp_parser* parser, bool in_statement_expr_p)\n \texpr = cp_parser_constant_expression (parser, \n \t\t\t\t\t      /*allow_non_constant_p=*/false,\n \t\t\t\t\t      NULL);\n-\t/* Create the label.  */\n-\tstatement = finish_case_label (expr, NULL_TREE);\n+\tif (!parser->in_switch_statement_p)\n+\t  error (\"case label `%E' not within a switch statement\", expr);\n+\telse\n+\t  statement = finish_case_label (expr, NULL_TREE);\n       }\n       break;\n \n     case RID_DEFAULT:\n       /* Consume the `default' token.  */\n       cp_lexer_consume_token (parser->lexer);\n-      /* Create the label.  */\n-      statement = finish_case_label (NULL_TREE, NULL_TREE);\n+      if (!parser->in_switch_statement_p)\n+\terror (\"case label not within a switch statement\");\n+      else\n+\tstatement = finish_case_label (NULL_TREE, NULL_TREE);\n       break;\n \n     default:\n@@ -5443,12 +5461,16 @@ cp_parser_selection_statement (cp_parser* parser)\n \telse\n \t  {\n \t    tree body;\n+\t    bool in_switch_statement_p;\n \n \t    /* Add the condition.  */\n \t    finish_switch_cond (condition, statement);\n \n \t    /* Parse the body of the switch-statement.  */\n+\t    in_switch_statement_p = parser->in_switch_statement_p;\n+\t    parser->in_switch_statement_p = true;\n \t    body = cp_parser_implicitly_scoped_statement (parser);\n+\t    parser->in_switch_statement_p = in_switch_statement_p;\n \n \t    /* Now we're all done with the switch-statement.  */\n \t    finish_switch_stmt (statement);\n@@ -5564,12 +5586,18 @@ cp_parser_iteration_statement (cp_parser* parser)\n   cp_token *token;\n   enum rid keyword;\n   tree statement;\n+  bool in_iteration_statement_p;\n+\n \n   /* Peek at the next token.  */\n   token = cp_parser_require (parser, CPP_KEYWORD, \"iteration-statement\");\n   if (!token)\n     return error_mark_node;\n \n+  /* Remember whether or not we are already within an iteration\n+     statement.  */ \n+  in_iteration_statement_p = parser->in_iteration_statement_p;\n+\n   /* See what kind of keyword it is.  */\n   keyword = token->keyword;\n   switch (keyword)\n@@ -5588,7 +5616,9 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \t/* Parse the dependent statement.  */\n+\tparser->in_iteration_statement_p = true;\n \tcp_parser_already_scoped_statement (parser);\n+\tparser->in_iteration_statement_p = in_iteration_statement_p;\n \t/* We're done with the while-statement.  */\n \tfinish_while_stmt (statement);\n       }\n@@ -5601,7 +5631,9 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Begin the do-statement.  */\n \tstatement = begin_do_stmt ();\n \t/* Parse the body of the do-statement.  */\n+\tparser->in_iteration_statement_p = true;\n \tcp_parser_implicitly_scoped_statement (parser);\n+\tparser->in_iteration_statement_p = in_iteration_statement_p;\n \tfinish_do_body (statement);\n \t/* Look for the `while' keyword.  */\n \tcp_parser_require_keyword (parser, RID_WHILE, \"`while'\");\n@@ -5646,7 +5678,9 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`;'\");\n \n \t/* Parse the body of the for-statement.  */\n+\tparser->in_iteration_statement_p = true;\n \tcp_parser_already_scoped_statement (parser);\n+\tparser->in_iteration_statement_p = in_iteration_statement_p;\n \n \t/* We're done with the for-statement.  */\n \tfinish_for_stmt (statement);\n@@ -5727,12 +5761,25 @@ cp_parser_jump_statement (cp_parser* parser)\n   switch (keyword)\n     {\n     case RID_BREAK:\n-      statement = finish_break_stmt ();\n+      if (!parser->in_switch_statement_p\n+\t  && !parser->in_iteration_statement_p)\n+\t{\n+\t  error (\"break statement not within loop or switch\");\n+\t  statement = error_mark_node;\n+\t}\n+      else\n+\tstatement = finish_break_stmt ();\n       cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n       break;\n \n     case RID_CONTINUE:\n-      statement = finish_continue_stmt ();\n+      if (!parser->in_iteration_statement_p)\n+\t{\n+\t  error (\"continue statement not within a loop\");\n+\t  statement = error_mark_node;\n+\t}\n+      else\n+\tstatement = finish_continue_stmt ();\n       cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n       break;\n "}]}