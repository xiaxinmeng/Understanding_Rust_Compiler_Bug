{"sha": "69f619018a585979500e0e80d3d106aaf3b62820", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmNjE5MDE4YTU4NTk3OTUwMGUwZTgwZDNkMTA2YWFmM2I2MjgyMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T21:50:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T21:50:23Z"}, "message": "(expand_divmod, case ROUND_DIV_EXPR): Implement.\n\nFrom-SVN: r8442", "tree": {"sha": "11d366944335943467490654830ef4440ff6a7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11d366944335943467490654830ef4440ff6a7e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69f619018a585979500e0e80d3d106aaf3b62820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f619018a585979500e0e80d3d106aaf3b62820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f619018a585979500e0e80d3d106aaf3b62820", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f619018a585979500e0e80d3d106aaf3b62820/comments", "author": null, "committer": null, "parents": [{"sha": "923f781d832a9ac82e0013d035a7b7afb108f6ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923f781d832a9ac82e0013d035a7b7afb108f6ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923f781d832a9ac82e0013d035a7b7afb108f6ff"}], "stats": {"total": 76, "additions": 68, "deletions": 8}, "files": [{"sha": "6c60f6a6b9c9663b11441a45e0b104eb728fff08", "filename": "gcc/expmed.c", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f619018a585979500e0e80d3d106aaf3b62820/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f619018a585979500e0e80d3d106aaf3b62820/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=69f619018a585979500e0e80d3d106aaf3b62820", "patch": "@@ -2608,13 +2608,13 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n      Second comes a switch statement with code specific for each rounding mode.\n      For some special operands this code emits all RTL for the desired\n-     operation, for other cases, it generates a quotient and stores it in\n+     operation, for other cases, it generates only a quotient and stores it in\n      QUOTIENT.  The case for trunc division/remainder might leave quotient = 0,\n      to indicate that it has not done anything.\n \n-     Last comes code that finishes the operation.  If QUOTIENT is set an\n-     REM_FLAG, the remainder is computed as OP0 - QUOTIENT * OP1.  If QUOTIENT\n-     is not set, it is computed using trunc rounding.\n+     Last comes code that finishes the operation.  If QUOTIENT is set and\n+     REM_FLAG is set, the remainder is computed as OP0 - QUOTIENT * OP1.  If\n+     QUOTIENT is not set, it is computed using trunc rounding.\n \n      We try to generate special code for division and remainder when OP1 is a\n      constant.  If |OP1| = 2**n we can use shifts and some other fast\n@@ -3408,10 +3408,70 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n       case ROUND_DIV_EXPR:\n       case ROUND_MOD_EXPR:\n-\t/* The code that used to be here was wrong, and nothing really\n-\t   depends on it.  */\n-\tabort ();\n-\tbreak;\n+\tif (unsignedp)\n+\t  {\n+\t    rtx tem;\n+\t    rtx label;\n+\t    label = gen_label_rtx ();\n+\t    quotient = gen_reg_rtx (compute_mode);\n+\t    remainder = gen_reg_rtx (compute_mode);\n+\t    if (expand_twoval_binop (udivmod_optab, op0, op1, quotient, remainder, 1) == 0)\n+\t      {\n+\t\trtx tem;\n+\t\tquotient = expand_binop (compute_mode, udiv_optab, op0, op1,\n+\t\t\t\t\t quotient, 1, OPTAB_LIB_WIDEN);\n+\t\ttem = expand_mult (compute_mode, quotient, op1, NULL_RTX, 1);\n+\t\tremainder = expand_binop (compute_mode, sub_optab, op0, tem,\n+\t\t\t\t\t  remainder, 1, OPTAB_LIB_WIDEN);\n+\t      }\n+\t    tem = plus_constant (op1, -1);\n+\t    tem = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n+\t\t\t\tbuild_int_2 (1, 0), NULL_RTX, 1);\n+\t    emit_cmp_insn (remainder, tem, LEU, NULL_RTX, compute_mode, 0, 0);\n+\t    emit_jump_insn (gen_bleu (label));\n+\t    expand_inc (quotient, const1_rtx);\n+\t    expand_dec (remainder, op1);\n+\t    emit_label (label);\n+\t  }\n+\telse\n+\t  {\n+\t    rtx abs_rem, abs_op1, tem, mask;\n+\t    rtx label;\n+\t    label = gen_label_rtx ();\n+\t    quotient = gen_reg_rtx (compute_mode);\n+\t    remainder = gen_reg_rtx (compute_mode);\n+\t    if (expand_twoval_binop (sdivmod_optab, op0, op1, quotient, remainder, 0) == 0)\n+\t      {\n+\t\trtx tem;\n+\t\tquotient = expand_binop (compute_mode, sdiv_optab, op0, op1,\n+\t\t\t\t\t quotient, 0, OPTAB_LIB_WIDEN);\n+\t\ttem = expand_mult (compute_mode, quotient, op1, NULL_RTX, 0);\n+\t\tremainder = expand_binop (compute_mode, sub_optab, op0, tem,\n+\t\t\t\t\t  remainder, 0, OPTAB_LIB_WIDEN);\n+\t      }\n+\t    abs_rem = expand_abs (compute_mode, remainder, NULL_RTX, 0, 0);\n+\t    abs_op1 = expand_abs (compute_mode, op1, NULL_RTX, 0, 0);\n+\t    tem = expand_shift (LSHIFT_EXPR, compute_mode, abs_rem,\n+\t\t\t\tbuild_int_2 (1, 0), NULL_RTX, 1);\n+\t    emit_cmp_insn (tem, abs_op1, LTU, NULL_RTX, compute_mode, 0, 0);\n+\t    emit_jump_insn (gen_bltu (label));\n+\t    tem = expand_binop (compute_mode, xor_optab, op0, op1,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\t    mask = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n+\t\t\t\tbuild_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t    tem = expand_binop (compute_mode, xor_optab, mask, const1_rtx,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\t    tem = expand_binop (compute_mode, sub_optab, tem, mask,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\t    expand_inc (quotient, tem);\n+\t    tem = expand_binop (compute_mode, xor_optab, mask, op1,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\t    tem = expand_binop (compute_mode, sub_optab, tem, mask,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\t    expand_dec (remainder, tem);\n+\t    emit_label (label);\n+\t  }\n+\treturn gen_lowpart (mode, rem_flag ? remainder : quotient);\n       }\n \n   if (quotient == 0)"}]}