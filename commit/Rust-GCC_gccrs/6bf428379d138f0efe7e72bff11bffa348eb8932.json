{"sha": "6bf428379d138f0efe7e72bff11bffa348eb8932", "node_id": "C_kwDOANBUbNoAKDZiZjQyODM3OWQxMzhmMGVmZTdlNzJiZmYxMWJmZmEzNDhlYjg5MzI", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-28T08:52:47Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-31T07:42:26Z"}, "message": "macros: Expand macro invocation properly in type contexts\n\nMacro invocations can be present where the language expects types. Thus,\nwe need to add a new type of parsing context, a new transcriber, as well\nas a new way to extract types from the AST Fragments. This adds a lot of\n\"expansion places\" in the attribute visitor, as types can be present in\na wide variety of constructs", "tree": {"sha": "cb555416a721400eafa49db930bc38bac72c5ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb555416a721400eafa49db930bc38bac72c5ead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bf428379d138f0efe7e72bff11bffa348eb8932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf428379d138f0efe7e72bff11bffa348eb8932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bf428379d138f0efe7e72bff11bffa348eb8932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf428379d138f0efe7e72bff11bffa348eb8932/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3413f632ec84dca6489fe1ca47545b5543c2a1d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3413f632ec84dca6489fe1ca47545b5543c2a1d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3413f632ec84dca6489fe1ca47545b5543c2a1d5"}], "stats": {"total": 280, "additions": 280, "deletions": 0}, "files": [{"sha": "859ae7e97082e6642e8e3a78d4a6e198fd8600e2", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf428379d138f0efe7e72bff11bffa348eb8932/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf428379d138f0efe7e72bff11bffa348eb8932/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=6bf428379d138f0efe7e72bff11bffa348eb8932", "patch": "@@ -35,13 +35,22 @@ AttrVisitor::expand_struct_fields (std::vector<AST::StructField> &fields)\n \t  continue;\n \t}\n \n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       // expand sub-types of type, but can't strip type itself\n       auto &type = field.get_field_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n+      expander.pop_context ();\n+\n       // if nothing else happens, increment\n       ++it;\n     }\n@@ -77,6 +86,8 @@ AttrVisitor::expand_tuple_fields (std::vector<AST::TupleField> &fields)\n void\n AttrVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n {\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   for (auto it = params.begin (); it != params.end ();)\n     {\n       auto &param = *it;\n@@ -98,34 +109,52 @@ AttrVisitor::expand_function_params (std::vector<AST::FunctionParam> &params)\n \n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n       // increment\n       ++it;\n     }\n+\n+  expander.pop_context ();\n }\n \n void\n AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n {\n   // lifetime args can't be expanded\n+  // FIXME: Can we have macro invocations for lifetimes?\n+\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n \n   // expand type args - strip sub-types only\n   for (auto &type : args.get_type_args ())\n     {\n       type->accept_vis (*this);\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n     }\n \n+  expander.pop_context ();\n+\n+  // FIXME: Can we have macro invocations in generic type bindings?\n   // expand binding args - strip sub-types only\n   for (auto &binding : args.get_binding_args ())\n     {\n       auto &type = binding.get_type ();\n       type->accept_vis (*this);\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n@@ -135,8 +164,17 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n void\n AttrVisitor::expand_qualified_path_type (AST::QualifiedPathType &path_type)\n {\n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = path_type.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n+  expander.pop_context ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n@@ -174,11 +212,19 @@ AttrVisitor::AttrVisitor::expand_closure_params (\n \n       if (param.has_type_given ())\n \t{\n+\t  expander.push_context (MacroExpander::ContextType::TYPE);\n \t  auto &type = param.get_type ();\n \t  type->accept_vis (*this);\n+\n+\t  auto t_fragment = expander.take_expanded_fragment (*this);\n+\t  if (t_fragment.should_expand ())\n+\t    type = t_fragment.take_type_fragment ();\n+\n \t  if (type->is_marked_for_strip ())\n \t    rust_error_at (type->get_locus (),\n \t\t\t   \"cannot strip type in this position\");\n+\n+\t  expander.pop_context ();\n \t}\n \n       // increment if found nothing else so far\n@@ -191,11 +237,19 @@ AttrVisitor::expand_self_param (AST::SelfParam &self_param)\n {\n   if (self_param.has_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n       auto &type = self_param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n   /* TODO: maybe check for invariants being violated - e.g. both type and\n    * lifetime? */\n@@ -222,11 +276,20 @@ AttrVisitor::expand_trait_function_decl (AST::TraitFunctionDecl &decl)\n \n   if (decl.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = decl.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (decl.has_where_clause ())\n@@ -251,11 +314,20 @@ AttrVisitor::expand_trait_method_decl (AST::TraitMethodDecl &decl)\n \n   if (decl.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = decl.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (decl.has_where_clause ())\n@@ -368,11 +440,20 @@ AttrVisitor::visit (AST::TypePathSegmentFunction &segment)\n \n   if (type_path_function.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = type_path_function.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n }\n void\n@@ -1176,12 +1257,21 @@ AttrVisitor::visit (AST::ClosureExprInnerTyped &expr)\n    * allowed by spec */\n   expand_closure_params (expr.get_params ());\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // can't strip return type, but can strip sub-types\n   auto &type = expr.get_return_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   // can't strip expression itself, but can strip sub-expressions\n   auto &definition_block = expr.get_definition_block ();\n   definition_block->accept_vis (*this);\n@@ -1928,11 +2018,19 @@ AttrVisitor::visit (AST::TypeParam &param)\n \n   if (param.has_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n }\n void\n@@ -1945,11 +2043,20 @@ AttrVisitor::visit (AST::TypeBoundWhereClauseItem &item)\n {\n   // for lifetimes shouldn't require\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   // don't strip directly, only components of bounds\n   for (auto &bound : item.get_type_param_bounds ())\n     bound->accept_vis (*this);\n@@ -1980,11 +2087,20 @@ AttrVisitor::visit (AST::Method &method)\n \n   if (method.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = method.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (method.has_where_clause ())\n@@ -2093,11 +2209,20 @@ AttrVisitor::visit (AST::Function &function)\n \n   if (function.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = function.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\treturn_type = t_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (function.has_where_clause ())\n@@ -2297,12 +2422,21 @@ AttrVisitor::visit (AST::ConstantItem &const_item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // strip any sub-types\n   auto &type = const_item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped. */\n@@ -2324,12 +2458,21 @@ AttrVisitor::visit (AST::StaticItem &static_item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // strip any sub-types\n   auto &type = static_item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped. */\n@@ -2403,12 +2546,21 @@ AttrVisitor::visit (AST::TraitItemConst &item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   // strip any sub-types\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   /* strip any internal sub-expressions - expression itself isn't\n    * allowed to have external attributes in this position so can't be\n    * stripped */\n@@ -2502,11 +2654,20 @@ AttrVisitor::visit (AST::InherentImpl &impl)\n   for (auto &param : impl.get_generic_params ())\n     param->accept_vis (*this);\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = impl.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   if (impl.has_where_clause ())\n     expand_where_clause (impl.get_where_clause ());\n \n@@ -2539,11 +2700,20 @@ AttrVisitor::visit (AST::TraitImpl &impl)\n   for (auto &param : impl.get_generic_params ())\n     param->accept_vis (*this);\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = impl.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n \n+  expander.pop_context ();\n+\n   auto &trait_path = impl.get_trait_path ();\n   visit (trait_path);\n   if (trait_path.is_marked_for_strip ())\n@@ -2571,10 +2741,19 @@ AttrVisitor::visit (AST::ExternalStaticItem &item)\n       return;\n     }\n \n+  expander.push_context (MacroExpander::ContextType::TYPE);\n+\n   auto &type = item.get_type ();\n   type->accept_vis (*this);\n+\n+  auto t_fragment = expander.take_expanded_fragment (*this);\n+  if (t_fragment.should_expand ())\n+    type = t_fragment.take_type_fragment ();\n+\n   if (type->is_marked_for_strip ())\n     rust_error_at (type->get_locus (), \"cannot strip type in this position\");\n+\n+  expander.pop_context ();\n }\n void\n AttrVisitor::visit (AST::ExternalFunctionItem &item)\n@@ -2606,12 +2785,21 @@ AttrVisitor::visit (AST::ExternalFunctionItem &item)\n \t  continue;\n \t}\n \n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n+      expander.pop_context ();\n+\n       // increment if nothing else happens\n       ++it;\n     }\n@@ -2624,16 +2812,26 @@ AttrVisitor::visit (AST::ExternalFunctionItem &item)\n \n   if (item.has_return_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &return_type = item.get_return_type ();\n       return_type->accept_vis (*this);\n+\n+      auto r_fragment = expander.take_expanded_fragment (*this);\n+      if (r_fragment.should_expand ())\n+\treturn_type = r_fragment.take_type_fragment ();\n+\n       if (return_type->is_marked_for_strip ())\n \trust_error_at (return_type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   if (item.has_where_clause ())\n     expand_where_clause (item.get_where_clause ());\n }\n+\n void\n AttrVisitor::visit (AST::ExternBlock &block)\n {\n@@ -2991,11 +3189,20 @@ AttrVisitor::visit (AST::LetStmt &stmt)\n   // similar for type\n   if (stmt.has_type ())\n     {\n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &type = stmt.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n+\n+      expander.pop_context ();\n     }\n \n   /* strip any internal sub-expressions - expression itself isn't\n@@ -3190,12 +3397,21 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n \t  continue;\n \t}\n \n+      expander.push_context (MacroExpander::ContextType::TYPE);\n+\n       auto &type = param.get_type ();\n       type->accept_vis (*this);\n+\n+      auto t_fragment = expander.take_expanded_fragment (*this);\n+      if (t_fragment.should_expand ())\n+\ttype = t_fragment.take_type_fragment ();\n+\n       if (type->is_marked_for_strip ())\n \trust_error_at (type->get_locus (),\n \t\t       \"cannot strip type in this position\");\n \n+      expander.pop_context ();\n+\n       // increment if nothing else happens\n       ++it;\n     }\n@@ -3205,6 +3421,9 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n \n   if (type.has_return_type ())\n     {\n+      // FIXME: Can we have type expansion in this position?\n+      // In that case, we need to handle AST::TypeNoBounds on top of just\n+      // AST::Types\n       auto &return_type = type.get_return_type ();\n       return_type->accept_vis (*this);\n       if (return_type->is_marked_for_strip ())"}, {"sha": "7151f3a83bce7c4248d05fcda535e03ab54d2f59", "filename": "gcc/testsuite/rust/compile/macro40.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf428379d138f0efe7e72bff11bffa348eb8932/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro40.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf428379d138f0efe7e72bff11bffa348eb8932/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro40.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro40.rs?ref=6bf428379d138f0efe7e72bff11bffa348eb8932", "patch": "@@ -0,0 +1,48 @@\n+// { dg-additional-options \"-w\" }\n+\n+macro_rules! t {\n+    () => {\n+        i32\n+    };\n+}\n+\n+macro_rules! s {\n+    () => {\n+        *const i8\n+    };\n+}\n+\n+extern \"C\" {\n+    fn printf(s: s!(), ...);\n+}\n+\n+fn square(arg: t!()) -> t!() {\n+    let input: t!() = arg;\n+\n+    input * input\n+}\n+\n+trait Trait {\n+    fn f() -> t!();\n+    fn g(arg: t!());\n+}\n+\n+struct Wrapper {\n+    inner: t!(),\n+}\n+\n+impl Trait for Wrapper {\n+    fn f() -> t!() {\n+        1\n+    }\n+\n+    fn g(arg: t!()) {}\n+}\n+\n+fn id<T>(arg: T) -> T {\n+    arg\n+}\n+\n+fn main() {\n+    id::<t!()>(15);\n+}"}, {"sha": "b011f92414945671f377740648dce6058de58ebf", "filename": "gcc/testsuite/rust/execute/torture/macros28.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf428379d138f0efe7e72bff11bffa348eb8932/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros28.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf428379d138f0efe7e72bff11bffa348eb8932/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros28.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros28.rs?ref=6bf428379d138f0efe7e72bff11bffa348eb8932", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! t {\n+    () => {\n+        i32\n+    };\n+}\n+\n+fn id<T>(arg: T) -> T {\n+    arg\n+}\n+\n+fn main() -> i32 {\n+    id::<t!()>(15) - 15\n+}"}]}