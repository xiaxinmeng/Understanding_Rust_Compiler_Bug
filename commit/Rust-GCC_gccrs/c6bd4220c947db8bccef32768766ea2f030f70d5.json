{"sha": "c6bd4220c947db8bccef32768766ea2f030f70d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZiZDQyMjBjOTQ3ZGI4YmNjZWYzMjc2ODc2NmVhMmYwMzBmNzBkNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-27T14:44:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-27T14:44:17Z"}, "message": "init.c (__gnat_set_globals): Add prototype.\n\n\t* init.c (__gnat_set_globals): Add prototype.\n\t* adaint.c (__gnat_binder_supports_auto_init): Likewise.\n\t(__gnat_sals_init_using_constructors): Likewise.\n\t* gcc-interface/utils.c (gnat_pushlevel): Likewise.\n\t(get_block_jmpbuf_decl): Likewise.\n\t(gnat_poplevel): Likewise.\n\t(merge_sizes): Rename local variable.\n\t(copy_type): Likewise.\n\t(build_vms_descriptor32): Likewise.\n\t(build_vms_descriptor): Likewise.\n\t(convert_vms_descriptor64): Likewise.\n\t(convert_vms_descriptor32): Likewise.\n\t(convert_to_fat_pointer): Likewise.\n\t(maybe_unconstrained_array): Likewise.\n\t(def_fn_type): Use promoted type with va_arg.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add declaration.\n\t(substitute_in_type): Rename local variable.\n\t* gcc-interface/Make-lang.in (ada-warn): Use STRICT_WARN.\n\nFrom-SVN: r149007", "tree": {"sha": "eba8cb8889bfb211e4e47688a77766530f1505aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eba8cb8889bfb211e4e47688a77766530f1505aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6bd4220c947db8bccef32768766ea2f030f70d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bd4220c947db8bccef32768766ea2f030f70d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bd4220c947db8bccef32768766ea2f030f70d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bd4220c947db8bccef32768766ea2f030f70d5/comments", "author": null, "committer": null, "parents": [{"sha": "92ec357043e418aab4037909005df3978d6276e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ec357043e418aab4037909005df3978d6276e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92ec357043e418aab4037909005df3978d6276e6"}], "stats": {"total": 246, "additions": 136, "deletions": 110}, "files": [{"sha": "5b809b3a2521b481e74b5604087626b7cbc723cf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c6bd4220c947db8bccef32768766ea2f030f70d5", "patch": "@@ -1,3 +1,24 @@\n+2009-06-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* init.c (__gnat_set_globals): Add prototype.\n+\t* adaint.c (__gnat_binder_supports_auto_init): Likewise.\n+\t(__gnat_sals_init_using_constructors): Likewise.\n+\t* gcc-interface/utils.c (gnat_pushlevel): Likewise.\n+\t(get_block_jmpbuf_decl): Likewise.\n+\t(gnat_poplevel): Likewise.\n+\t(merge_sizes): Rename local variable.\n+\t(copy_type): Likewise.\n+\t(build_vms_descriptor32): Likewise.\n+\t(build_vms_descriptor): Likewise.\n+\t(convert_vms_descriptor64): Likewise.\n+\t(convert_vms_descriptor32): Likewise.\n+\t(convert_to_fat_pointer): Likewise.\n+\t(maybe_unconstrained_array): Likewise.\n+\t(def_fn_type): Use promoted type with va_arg.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add declaration.\n+\t(substitute_in_type): Rename local variable.\n+\t* gcc-interface/Make-lang.in (ada-warn): Use STRICT_WARN.\n+\n 2009-06-26  Laurent GUERBY  <laurent@guerby.net>\n \n \t* tb-gcc.c (trace_callback): Use char* instead of void*."}, {"sha": "fd7b1b31ff9d5cb21c2840885dab74e61a6d71f2", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=c6bd4220c947db8bccef32768766ea2f030f70d5", "patch": "@@ -3510,7 +3510,7 @@ __gnat_set_close_on_exec (int fd ATTRIBUTE_UNUSED,\n /* Indicates if platforms supports automatic initialization through the\n    constructor mechanism */\n int\n-__gnat_binder_supports_auto_init ()\n+__gnat_binder_supports_auto_init (void)\n {\n #ifdef VMS\n    return 0;\n@@ -3522,7 +3522,7 @@ __gnat_binder_supports_auto_init ()\n /* Indicates that Stand-Alone Libraries are automatically initialized through\n    the constructor mechanism */\n int\n-__gnat_sals_init_using_constructors ()\n+__gnat_sals_init_using_constructors (void)\n {\n #if defined (__vxworks) || defined (__Lynx__) || defined (VMS)\n    return 0;"}, {"sha": "d655e048bd3e51738da0bab2bb9f7e457d92d851", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=c6bd4220c947db8bccef32768766ea2f030f70d5", "patch": "@@ -75,12 +75,10 @@ ADA_FLAGS_TO_PASS = \\\n .SUFFIXES: .ada .adb .ads\n \n # FIXME: need to add $(ADA_CFLAGS) to .c.o suffix rule\n-# Use loose warnings for this front end, but add some special flags\n-ada-warn = $(ADA_CFLAGS) $(WERROR)\n-# unresolved warnings in a couple of files\n-ada/tracebak.o-warn = -Wno-error\n-ada/b_gnat1.o-warn = -Wno-error\n-ada/b_gnatb.o-warn = -Wno-error\n+# Use mildly strict warnings for this front end and add special flags.\n+ada-warn = $(ADA_CFLAGS) $(filter-out -pedantic, $(STRICT_WARN))\n+# Unresolved warnings in specific files.\n+ada/adaint.o-warn = -Wno-error\n \n .adb.o:\n \t$(CC) -c $(ALL_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)"}, {"sha": "48acbfbe3c11a03a958e2aa6f3a7efd2d11ae6ad", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c6bd4220c947db8bccef32768766ea2f030f70d5", "patch": "@@ -2898,7 +2898,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     gnat_field = Next_Stored_Discriminant (gnat_field))\n \t\t  if (Present (Corresponding_Discriminant (gnat_field)))\n \t\t    {\n-\t\t      gnu_field = gnat_to_gnu_field_decl (gnat_field);\n+\t\t      tree gnu_field = gnat_to_gnu_field_decl (gnat_field);\n \t\t      tree gnu_ref\n \t\t\t= build3 (COMPONENT_REF, TREE_TYPE (gnu_field),\n \t\t\t\t  gnu_get_parent, gnu_field, NULL_TREE);\n@@ -7840,7 +7840,7 @@ compatible_signatures_p (tree ftype1, tree ftype2)\n tree\n substitute_in_type (tree t, tree f, tree r)\n {\n-  tree new_tree;\n+  tree nt;\n \n   gcc_assert (CONTAINS_PLACEHOLDER_P (r));\n \n@@ -7861,15 +7861,15 @@ substitute_in_type (tree t, tree f, tree r)\n \t  if (low == TYPE_GCC_MIN_VALUE (t) && high == TYPE_GCC_MAX_VALUE (t))\n \t    return t;\n \n-\t  new_tree = copy_type (t);\n-\t  TYPE_GCC_MIN_VALUE (new_tree) = low;\n-\t  TYPE_GCC_MAX_VALUE (new_tree) = high;\n+\t  nt = copy_type (t);\n+\t  TYPE_GCC_MIN_VALUE (nt) = low;\n+\t  TYPE_GCC_MAX_VALUE (nt) = high;\n \n \t  if (TREE_CODE (t) == INTEGER_TYPE && TYPE_INDEX_TYPE (t))\n \t    SET_TYPE_INDEX_TYPE\n-\t      (new_tree, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n+\t      (nt, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n \n-\t  return new_tree;\n+\t  return nt;\n \t}\n \n       /* Then the subtypes.  */\n@@ -7882,21 +7882,21 @@ substitute_in_type (tree t, tree f, tree r)\n \t  if (low == TYPE_RM_MIN_VALUE (t) && high == TYPE_RM_MAX_VALUE (t))\n \t    return t;\n \n-\t  new_tree = copy_type (t);\n-\t  SET_TYPE_RM_MIN_VALUE (new_tree, low);\n-\t  SET_TYPE_RM_MAX_VALUE (new_tree, high);\n+\t  nt = copy_type (t);\n+\t  SET_TYPE_RM_MIN_VALUE (nt, low);\n+\t  SET_TYPE_RM_MAX_VALUE (nt, high);\n \n-\t  return new_tree;\n+\t  return nt;\n \t}\n \n       return t;\n \n     case COMPLEX_TYPE:\n-      new_tree = substitute_in_type (TREE_TYPE (t), f, r);\n-      if (new_tree == TREE_TYPE (t))\n+      nt = substitute_in_type (TREE_TYPE (t), f, r);\n+      if (nt == TREE_TYPE (t))\n \treturn t;\n \n-      return build_complex_type (new_tree);\n+      return build_complex_type (nt);\n \n     case OFFSET_TYPE:\n     case METHOD_TYPE:\n@@ -7913,16 +7913,16 @@ substitute_in_type (tree t, tree f, tree r)\n \tif (component == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n \n-\tnew_tree = build_array_type (component, domain);\n-\tTYPE_ALIGN (new_tree) = TYPE_ALIGN (t);\n-\tTYPE_USER_ALIGN (new_tree) = TYPE_USER_ALIGN (t);\n-\tSET_TYPE_MODE (new_tree, TYPE_MODE (t));\n-\tTYPE_SIZE (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n-\tTYPE_SIZE_UNIT (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n-\tTYPE_NONALIASED_COMPONENT (new_tree) = TYPE_NONALIASED_COMPONENT (t);\n-\tTYPE_MULTI_ARRAY_P (new_tree) = TYPE_MULTI_ARRAY_P (t);\n-\tTYPE_CONVENTION_FORTRAN_P (new_tree) = TYPE_CONVENTION_FORTRAN_P (t);\n-\treturn new_tree;\n+\tnt = build_array_type (component, domain);\n+\tTYPE_ALIGN (nt) = TYPE_ALIGN (t);\n+\tTYPE_USER_ALIGN (nt) = TYPE_USER_ALIGN (t);\n+\tSET_TYPE_MODE (nt, TYPE_MODE (t));\n+\tTYPE_SIZE (nt) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n+\tTYPE_SIZE_UNIT (nt) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n+\tTYPE_NONALIASED_COMPONENT (nt) = TYPE_NONALIASED_COMPONENT (t);\n+\tTYPE_MULTI_ARRAY_P (nt) = TYPE_MULTI_ARRAY_P (t);\n+\tTYPE_CONVENTION_FORTRAN_P (nt) = TYPE_CONVENTION_FORTRAN_P (t);\n+\treturn nt;\n       }\n \n     case RECORD_TYPE:\n@@ -7935,8 +7935,8 @@ substitute_in_type (tree t, tree f, tree r)\n \t/* Start out with no fields, make new fields, and chain them\n \t   in.  If we haven't actually changed the type of any field,\n \t   discard everything we've done and return the old type.  */\n-\tnew_tree = copy_type (t);\n-\tTYPE_FIELDS (new_tree) = NULL_TREE;\n+\tnt = copy_type (t);\n+\tTYPE_FIELDS (nt) = NULL_TREE;\n \n \tfor (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n \t  {\n@@ -7967,23 +7967,23 @@ substitute_in_type (tree t, tree f, tree r)\n \t\t  }\n \t      }\n \n-\t    DECL_CONTEXT (new_field) = new_tree;\n+\t    DECL_CONTEXT (new_field) = nt;\n \t    SET_DECL_ORIGINAL_FIELD (new_field,\n \t\t\t\t     (DECL_ORIGINAL_FIELD (field)\n \t\t\t\t      ? DECL_ORIGINAL_FIELD (field) : field));\n \n-\t    TREE_CHAIN (new_field) = TYPE_FIELDS (new_tree);\n-\t    TYPE_FIELDS (new_tree) = new_field;\n+\t    TREE_CHAIN (new_field) = TYPE_FIELDS (nt);\n+\t    TYPE_FIELDS (nt) = new_field;\n \t  }\n \n \tif (!changed_field)\n \t  return t;\n \n-\tTYPE_FIELDS (new_tree) = nreverse (TYPE_FIELDS (new_tree));\n-\tTYPE_SIZE (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n-\tTYPE_SIZE_UNIT (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n-\tSET_TYPE_ADA_SIZE (new_tree, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (t), f, r));\n-\treturn new_tree;\n+\tTYPE_FIELDS (nt) = nreverse (TYPE_FIELDS (nt));\n+\tTYPE_SIZE (nt) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n+\tTYPE_SIZE_UNIT (nt) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n+\tSET_TYPE_ADA_SIZE (nt, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (t), f, r));\n+\treturn nt;\n       }\n \n     default:"}, {"sha": "a4d77a39c014d659cb6d3de2b14ab347786b5d8b", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 74, "deletions": 67, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=c6bd4220c947db8bccef32768766ea2f030f70d5", "patch": "@@ -319,7 +319,7 @@ global_bindings_p (void)\n /* Enter a new binding level. */\n \n void\n-gnat_pushlevel ()\n+gnat_pushlevel (void)\n {\n   struct gnat_binding_level *newlevel = NULL;\n \n@@ -379,15 +379,15 @@ set_block_jmpbuf_decl (tree decl)\n /* Get the jmpbuf_decl, if any, for the current binding level.  */\n \n tree\n-get_block_jmpbuf_decl ()\n+get_block_jmpbuf_decl (void)\n {\n   return current_binding_level->jmpbuf_decl;\n }\n \n /* Exit a binding level. Set any BLOCK into the current code group.  */\n \n void\n-gnat_poplevel ()\n+gnat_poplevel (void)\n {\n   struct gnat_binding_level *level = current_binding_level;\n   tree block = level->block;\n@@ -1017,33 +1017,33 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n \t     bool has_rep)\n {\n   tree type = TREE_TYPE (last_size);\n-  tree new_tree;\n+  tree new_size;\n \n   if (!special || TREE_CODE (size) != COND_EXPR)\n     {\n-      new_tree = size_binop (PLUS_EXPR, first_bit, size);\n+      new_size = size_binop (PLUS_EXPR, first_bit, size);\n       if (has_rep)\n-\tnew_tree = size_binop (MAX_EXPR, last_size, new_tree);\n+\tnew_size = size_binop (MAX_EXPR, last_size, new_size);\n     }\n \n   else\n-    new_tree = fold_build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n-\t\t            integer_zerop (TREE_OPERAND (size, 1))\n-\t\t            ? last_size : merge_sizes (last_size, first_bit,\n-\t\t     \t\t\t\t  TREE_OPERAND (size, 1),\n-\t\t     \t\t\t\t  1, has_rep),\n-\t\t            integer_zerop (TREE_OPERAND (size, 2))\n-\t\t            ? last_size : merge_sizes (last_size, first_bit,\n-\t\t     \t\t\t\t  TREE_OPERAND (size, 2),\n-\t\t     \t\t\t\t  1, has_rep));\n+    new_size = fold_build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n+\t\t\t    integer_zerop (TREE_OPERAND (size, 1))\n+\t\t\t    ? last_size : merge_sizes (last_size, first_bit,\n+\t\t\t\t\t\t       TREE_OPERAND (size, 1),\n+\t\t\t\t\t\t       1, has_rep),\n+\t\t\t    integer_zerop (TREE_OPERAND (size, 2))\n+\t\t\t    ? last_size : merge_sizes (last_size, first_bit,\n+\t\t\t\t\t\t       TREE_OPERAND (size, 2),\n+\t\t\t\t\t\t       1, has_rep));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n      when fed through substitute_in_expr) into thinking that a constant\n      size is not constant.  */\n-  while (TREE_CODE (new_tree) == NON_LVALUE_EXPR)\n-    new_tree = TREE_OPERAND (new_tree, 0);\n+  while (TREE_CODE (new_size) == NON_LVALUE_EXPR)\n+    new_size = TREE_OPERAND (new_size, 0);\n \n-  return new_tree;\n+  return new_size;\n }\n \n /* Utility function of above to see if OP0 and OP1, both of SIZETYPE, are\n@@ -1163,18 +1163,18 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n tree\n copy_type (tree type)\n {\n-  tree new_tree = copy_node (type);\n+  tree new_type = copy_node (type);\n \n   /* copy_node clears this field instead of copying it, because it is\n      aliased with TREE_CHAIN.  */\n-  TYPE_STUB_DECL (new_tree) = TYPE_STUB_DECL (type);\n+  TYPE_STUB_DECL (new_type) = TYPE_STUB_DECL (type);\n \n-  TYPE_POINTER_TO (new_tree) = 0;\n-  TYPE_REFERENCE_TO (new_tree) = 0;\n-  TYPE_MAIN_VARIANT (new_tree) = new_tree;\n-  TYPE_NEXT_VARIANT (new_tree) = 0;\n+  TYPE_POINTER_TO (new_type) = 0;\n+  TYPE_REFERENCE_TO (new_type) = 0;\n+  TYPE_MAIN_VARIANT (new_type) = new_type;\n+  TYPE_NEXT_VARIANT (new_type) = 0;\n \n-  return new_tree;\n+  return new_type;\n }\n \f\n /* Return a subtype of sizetype with range MIN to MAX and whose\n@@ -2515,7 +2515,7 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   tree record_type = make_node (RECORD_TYPE);\n   tree pointer32_type;\n   tree field_list = 0;\n-  int class_i;\n+  int klass;\n   int dtype = 0;\n   tree inner_type;\n   int ndim;\n@@ -2627,22 +2627,22 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     {\n     case By_Descriptor_A:\n     case By_Short_Descriptor_A:\n-      class_i = 4;\n+      klass = 4;\n       break;\n     case By_Descriptor_NCA:\n     case By_Short_Descriptor_NCA:\n-      class_i = 10;\n+      klass = 10;\n       break;\n     case By_Descriptor_SB:\n     case By_Short_Descriptor_SB:\n-      class_i = 15;\n+      klass = 15;\n       break;\n     case By_Descriptor:\n     case By_Short_Descriptor:\n     case By_Descriptor_S:\n     case By_Short_Descriptor_S:\n     default:\n-      class_i = 1;\n+      klass = 1;\n       break;\n     }\n \n@@ -2664,7 +2664,7 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   field_list = chainon (field_list,\n \t\t\tmake_descriptor_field (\"CLASS\",\n \t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record_type, size_int (class_i)));\n+\t\t\t\t\t       record_type, size_int (klass)));\n \n   /* Of course this will crash at run-time if the address space is not\n      within the low 32 bits, but there is nothing else we can do.  */\n@@ -2830,7 +2830,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   tree record64_type = make_node (RECORD_TYPE);\n   tree pointer64_type;\n   tree field_list64 = 0;\n-  int class_i;\n+  int klass;\n   int dtype = 0;\n   tree inner_type;\n   int ndim;\n@@ -2941,18 +2941,18 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   switch (mech)\n     {\n     case By_Descriptor_A:\n-      class_i = 4;\n+      klass = 4;\n       break;\n     case By_Descriptor_NCA:\n-      class_i = 10;\n+      klass = 10;\n       break;\n     case By_Descriptor_SB:\n-      class_i = 15;\n+      klass = 15;\n       break;\n     case By_Descriptor:\n     case By_Descriptor_S:\n     default:\n-      class_i = 1;\n+      klass = 1;\n       break;\n     }\n \n@@ -2971,7 +2971,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   field_list64 = chainon (field_list64,\n \t\t\tmake_descriptor_field (\"CLASS\",\n \t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record64_type, size_int (class_i)));\n+\t\t\t\t\t       record64_type, size_int (klass)));\n \n   field_list64 = chainon (field_list64,\n \t\t\tmake_descriptor_field (\"MBMO\",\n@@ -3154,9 +3154,9 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree class_tree = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  tree klass = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 6th field in the descriptor.  */\n-  tree pointer64 = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (class_tree)));\n+  tree pointer64 = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (klass)));\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr64\n@@ -3174,18 +3174,18 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n       tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n-      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class_tree));\n+      int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n       tree lfield, ufield;\n \n       /* Convert POINTER to the type of the P_ARRAY field.  */\n       gnu_expr64 = convert (p_array_type, gnu_expr64);\n \n-      switch (iclass)\n+      switch (iklass)\n \t{\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH64 is the 5th field.  */\n-\t  t = TREE_CHAIN (TREE_CHAIN (class_tree));\n+\t  t = TREE_CHAIN (TREE_CHAIN (klass));\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  t = tree_cons (min_field,\n \t\t\t convert (TREE_TYPE (min_field), integer_one_node),\n@@ -3196,12 +3196,12 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n \n \t  /* For class S, we are done.  */\n-\t  if (iclass == 1)\n+\t  if (iklass == 1)\n \t    break;\n \n \t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (class_tree), desc, class_tree, NULL);\n-\t  u = convert (TREE_TYPE (class_tree), DECL_INITIAL (class_tree));\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (klass), desc, klass, NULL);\n+\t  u = convert (TREE_TYPE (klass), DECL_INITIAL (klass));\n \t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  The fields are\n@@ -3271,7 +3271,8 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n \t\t\t    template_tree);\n-\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n+\t  template_addr\n+\t    = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n \t  break;\n \n \tcase 10: /* Class NCA */\n@@ -3302,9 +3303,9 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree class_tree = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  tree klass = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 4th field in the descriptor.  */\n-  tree pointer = TREE_CHAIN (class_tree);\n+  tree pointer = TREE_CHAIN (klass);\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr32\n@@ -3322,12 +3323,12 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n       tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n-      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class_tree));\n+      int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n \n       /* Convert POINTER to the type of the P_ARRAY field.  */\n       gnu_expr32 = convert (p_array_type, gnu_expr32);\n \n-      switch (iclass)\n+      switch (iklass)\n \t{\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n@@ -3343,17 +3344,18 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n \n \t  /* For class S, we are done.  */\n-\t  if (iclass == 1)\n+\t  if (iklass == 1)\n \t    break;\n \n \t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (class_tree), desc, class_tree, NULL);\n-\t  u = convert (TREE_TYPE (class_tree), DECL_INITIAL (class_tree));\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (klass), desc, klass, NULL);\n+\t  u = convert (TREE_TYPE (klass), DECL_INITIAL (klass));\n \t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  */\n \t  t = TREE_CHAIN (pointer);\n-\t  template_tree = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  template_tree\n+\t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* Otherwise use the {1, LENGTH} template we build above.  */\n \t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n \t\t\t\t  build_unary_op (ADDR_EXPR, p_bounds_type,\n@@ -3384,12 +3386,14 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* There is already a template in the descriptor and it is\n \t     located at the start of block 3 (12th field).  */\n \t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (t))));\n-\t  template_tree = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  template_tree\n+\t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  template_tree = build3 (COND_EXPR, p_bounds_type, u,\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n \t\t\t    template_tree);\n-\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n+\t  template_addr\n+\t    = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n \t  break;\n \n \tcase 10: /* Class NCA */\n@@ -3774,7 +3778,8 @@ convert_to_fat_pointer (tree type, tree expr)\n        tree_cons (TYPE_FIELDS (type),\n \t\t  convert (p_array_type, expr),\n \t\t  tree_cons (TREE_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, template_tree),\n+\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t     template_tree),\n \t\t\t     NULL_TREE)));\n }\n \f\n@@ -4304,20 +4309,21 @@ tree\n maybe_unconstrained_array (tree exp)\n {\n   enum tree_code code = TREE_CODE (exp);\n-  tree new_tree;\n+  tree new_exp;\n \n   switch (TREE_CODE (TREE_TYPE (exp)))\n     {\n     case UNCONSTRAINED_ARRAY_TYPE:\n       if (code == UNCONSTRAINED_ARRAY_REF)\n \t{\n-\t  new_tree\n+\t  new_exp\n \t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t      build_component_ref (TREE_OPERAND (exp, 0),\n \t\t\t\t\t\t   get_identifier (\"P_ARRAY\"),\n \t\t\t\t\t\t   NULL_TREE, false));\n-\t  TREE_READONLY (new_tree) = TREE_STATIC (new_tree) = TREE_READONLY (exp);\n-\t  return new_tree;\n+\t  TREE_READONLY (new_exp) = TREE_STATIC (new_exp)\n+\t    = TREE_READONLY (exp);\n+\t  return new_exp;\n \t}\n \n       else if (code == NULL_EXPR)\n@@ -4331,12 +4337,13 @@ maybe_unconstrained_array (tree exp)\n \t it contains a template.  */\n       if (TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n \t{\n-\t  new_tree = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n-\t  if (TREE_CODE (TREE_TYPE (new_tree)) == RECORD_TYPE\n-\t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (new_tree)))\n+\t  new_exp = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n+\t  if (TREE_CODE (TREE_TYPE (new_exp)) == RECORD_TYPE\n+\t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (new_exp)))\n \t    return\n-\t      build_component_ref (new_tree, NULL_TREE,\n-\t\t\t\t   TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new_tree))),\n+\t      build_component_ref (new_exp, NULL_TREE,\n+\t\t\t\t   TREE_CHAIN\n+\t\t\t\t   (TYPE_FIELDS (TREE_TYPE (new_exp))),\n \t\t\t\t   0);\n \t}\n       else if (TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (exp)))\n@@ -4864,7 +4871,7 @@ def_fn_type (builtin_type def, builtin_type ret, bool var, int n, ...)\n   va_start (list, n);\n   for (i = 0; i < n; ++i)\n     {\n-      builtin_type a = va_arg (list, builtin_type);\n+      builtin_type a = (builtin_type) va_arg (list, int);\n       t = builtin_types[a];\n       if (t == error_mark_node)\n \tgoto egress;"}, {"sha": "d5c7cca43fcb793012b4befcbaa75a9b8480fc31", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bd4220c947db8bccef32768766ea2f030f70d5/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=c6bd4220c947db8bccef32768766ea2f030f70d5", "patch": "@@ -178,7 +178,7 @@ __gnat_get_specific_dispatching (int priority)\n    file now sets the __gl_* variables directly.  */\n \n void\n-__gnat_set_globals ()\n+__gnat_set_globals (void)\n {\n }\n "}]}