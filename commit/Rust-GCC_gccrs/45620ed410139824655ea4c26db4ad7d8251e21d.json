{"sha": "45620ed410139824655ea4c26db4ad7d8251e21d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2MjBlZDQxMDEzOTgyNDY1NWVhNGMyNmRiNGFkN2Q4MjUxZTIxZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-10T12:03:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-10T12:03:37Z"}, "message": "No longer handle LSHIFT.\n\nFrom-SVN: r7020", "tree": {"sha": "ad096dc10d4fc4f073328d477e2dcf6db96f1ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad096dc10d4fc4f073328d477e2dcf6db96f1ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45620ed410139824655ea4c26db4ad7d8251e21d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45620ed410139824655ea4c26db4ad7d8251e21d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45620ed410139824655ea4c26db4ad7d8251e21d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45620ed410139824655ea4c26db4ad7d8251e21d/comments", "author": null, "committer": null, "parents": [{"sha": "e5df894b42716006a8fccd922530782b7aaeb745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5df894b42716006a8fccd922530782b7aaeb745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5df894b42716006a8fccd922530782b7aaeb745"}], "stats": {"total": 65, "additions": 20, "deletions": 45}, "files": [{"sha": "5e69d8017cc7952c84e628ac5d09ead9c3a2b1eb", "filename": "gcc/combine.c", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=45620ed410139824655ea4c26db4ad7d8251e21d", "patch": "@@ -3856,7 +3856,6 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n       break;\n \n-    case LSHIFT:\n     case ASHIFT:\n     case LSHIFTRT:\n     case ASHIFTRT:\n@@ -5296,7 +5295,6 @@ make_compound_operation (x, in_code)\n   switch (code)\n     {\n     case ASHIFT:\n-    case LSHIFT:\n       /* Convert shifts by constants into multiplications if inside\n \t an address.  */\n       if (in_code == MEM && GET_CODE (XEXP (x, 1)) == CONST_INT\n@@ -5338,7 +5336,7 @@ make_compound_operation (x, in_code)\n \t\t\t\t XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n \t\t\t\t 0, in_code == COMPARE);\n \t}\n-      /* Same as previous, but for (xor/ior (lshift...) (lshift...)).  */\n+      /* Same as previous, but for (xor/ior (lshiftrt...) (lshiftrt...)).  */\n       else if ((GET_CODE (XEXP (x, 0)) == XOR\n \t\t|| GET_CODE (XEXP (x, 0)) == IOR)\n \t       && GET_CODE (XEXP (XEXP (x, 0), 0)) == LSHIFTRT\n@@ -5811,7 +5809,6 @@ force_to_mode (x, mode, mask, reg, just_select)\n       break;\n \n     case ASHIFT:\n-    case LSHIFT:\n       /* For left shifts, do the same, but just for the first operand.\n \t However, we cannot do anything with shifts where we cannot\n \t guarantee that the counts are smaller than the size of the mode\n@@ -6458,8 +6455,7 @@ apply_distributive_law (x)\n       break;\n \n     case ASHIFT:\n-    case LSHIFT:\n-      /* These are also multiplies, so they distribute over everything.  */\n+      /* This is also a multiply, so it distributes over everything.  */\n       break;\n \n     case SUBREG:\n@@ -6926,7 +6922,6 @@ nonzero_bits (x, mode)\n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ASHIFT:\n-    case LSHIFT:\n     case ROTATE:\n       /* The nonzero bits are in two classes: any bits within MODE\n \t that aren't in GET_MODE (x) are always significant.  The rest of the\n@@ -6961,7 +6956,7 @@ nonzero_bits (x, mode)\n \t      if (inner & ((HOST_WIDE_INT) 1 << (width - 1 - count)))\n \t\tinner |= (((HOST_WIDE_INT) 1 << count) - 1) << (width - count);\n \t    }\n-\t  else if (code == LSHIFT || code == ASHIFT)\n+\t  else if (code == ASHIFT)\n \t    inner <<= count;\n \t  else\n \t    inner = ((inner << (count % width)\n@@ -7229,7 +7224,6 @@ num_sign_bit_copies (x, mode)\n       return num0;\n \n     case ASHIFT:\n-    case LSHIFT:\n       /* Left shifts destroy copies.  */\n       if (GET_CODE (XEXP (x, 1)) != CONST_INT\n \t  || INTVAL (XEXP (x, 1)) < 0\n@@ -7477,10 +7471,6 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       if (code == ROTATERT)\n \tcode = ROTATE, count = GET_MODE_BITSIZE (result_mode) - count;\n \n-      /* Canonicalize LSHIFT to ASHIFT.  */\n-      if (code == LSHIFT)\n-\tcode = ASHIFT;\n-\n       /* We need to determine what mode we will do the shift in.  If the\n \t shift is a ASHIFTRT or ROTATE, we must always do it in the mode it\n \t was originally done in.  Otherwise, we can do it in MODE, the widest\n@@ -7672,7 +7662,6 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \n \tcase LSHIFTRT:\n \tcase ASHIFT:\n-\tcase LSHIFT:\n \tcase ROTATE:\n \t  /* Here we have two nested shifts.  The result is usually the\n \t     AND of a new shift with a mask.  We compute the result below.  */\n@@ -7687,9 +7676,6 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      unsigned HOST_WIDE_INT mask;\n \t      rtx mask_rtx;\n \n-\t      if (first_code == LSHIFT)\n-\t\tfirst_code = ASHIFT;\n-\n \t      /* We have one common special case.  We can't do any merging if\n \t\t the inner code is an ASHIFTRT of a smaller mode.  However, if\n \t\t we have (ashift:M1 (subreg:M1 (ashiftrt:M2 FOO C1) 0) C2)\n@@ -7894,11 +7880,11 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  break;\n \n \tcase EQ:\n-\t  /* convert (lshift (eq FOO 0) C) to (xor FOO 1) if STORE_FLAG_VALUE\n+\t  /* convert (lshiftrt (eq FOO 0) C) to (xor FOO 1) if STORE_FLAG_VALUE\n \t     says that the sign bit can be tested, FOO has mode MODE, C is\n-\t     GET_MODE_BITSIZE (MODE) - 1, and FOO has only the low-order bit\n-\t     may be nonzero.  */\n-\t  if (code == LSHIFT\n+\t     GET_MODE_BITSIZE (MODE) - 1, and FOO has only its low-order bit\n+\t     that may be nonzero.  */\n+\t  if (code == LSHIFTRT\n \t      && XEXP (varop, 1) == const0_rtx\n \t      && GET_MODE (XEXP (varop, 0)) == result_mode\n \t      && count == GET_MODE_BITSIZE (result_mode) - 1\n@@ -8517,9 +8503,7 @@ simplify_comparison (code, pop0, pop1)\n       if (GET_CODE (op0) == GET_CODE (op1)\n \t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n \t  && ((GET_CODE (op0) == ROTATE && (code == NE || code == EQ))\n-\t      || ((GET_CODE (op0) == LSHIFTRT\n-\t\t   || GET_CODE (op0) == ASHIFT\n-\t\t   || GET_CODE (op0) == LSHIFT)\n+\t      || ((GET_CODE (op0) == LSHIFTRT || GET_CODE (op0) == ASHIFT)\n \t\t  && (code != GT && code != LT && code != GE && code != LE))\n \t      || (GET_CODE (op0) == ASHIFTRT\n \t\t  && (code != GTU && code != LTU\n@@ -8535,7 +8519,7 @@ simplify_comparison (code, pop0, pop1)\n \n \t  if (GET_CODE (op0) == LSHIFTRT || GET_CODE (op0) == ASHIFTRT)\n \t    mask &= (mask >> shift_count) << shift_count;\n-\t  else if (GET_CODE (op0) == ASHIFT || GET_CODE (op0) == LSHIFT)\n+\t  else if (GET_CODE (op0) == ASHIFT)\n \t    mask = (mask & (mask << shift_count)) >> shift_count;\n \n \t  if ((nonzero_bits (XEXP (op0, 0), mode) & ~ mask) == 0\n@@ -9145,8 +9129,7 @@ simplify_comparison (code, pop0, pop1)\n \t  /* Convert (and (xshift 1 X) Y) to (and (lshiftrt Y X) 1).  This\n \t     will be converted to a ZERO_EXTRACT later.  */\n \t  if (const_op == 0 && equality_comparison_p\n-\t      && (GET_CODE (XEXP (op0, 0)) == ASHIFT\n-\t\t  || GET_CODE (XEXP (op0, 0)) == LSHIFT)\n+\t      && GET_CODE (XEXP (op0, 0)) == ASHIFT\n \t      && XEXP (XEXP (op0, 0), 0) == const1_rtx)\n \t    {\n \t      op0 = simplify_and_const_int\n@@ -9213,8 +9196,7 @@ simplify_comparison (code, pop0, pop1)\n \t  break;\n \n \tcase ASHIFT:\n-\tcase LSHIFT:\n-\t  /* If we have (compare (xshift FOO N) (const_int C)) and\n+\t  /* If we have (compare (ashift FOO N) (const_int C)) and\n \t     the high order N bits of FOO (N+1 if an inequality comparison)\n \t     are known to be zero, we can do this by comparing FOO with C\n \t     shifted right N bits so long as the low-order N bits of C are"}, {"sha": "23dd7c7da2dbd854fb2272eb458c8bdd75c97807", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=45620ed410139824655ea4c26db4ad7d8251e21d", "patch": "@@ -3431,7 +3431,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase LSHIFTRT:   case ASHIFTRT:\n-\tcase ASHIFT:     case LSHIFT:\n+\tcase ASHIFT:\n \tcase ROTATE:     case ROTATERT:\n #ifdef SHIFT_COUNT_TRUNCATED\n \t  if (SHIFT_COUNT_TRUNCATED)\n@@ -3444,9 +3444,8 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  if (code == LSHIFTRT || code == ASHIFTRT)\n \t    rshift_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv,\n \t\t\t   code == ASHIFTRT);\n-\t  else if (code == ASHIFT || code == LSHIFT)\n-\t    lshift_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv,\n-\t\t\t   code == ASHIFT);\n+\t  else if (code == ASHIFT)\n+\t    lshift_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv, 1);\n \t  else if (code == ROTATE)\n \t    lrotate_double (l1, h1, l2, GET_MODE_BITSIZE (mode), &lv, &hv);\n \t  else /* code == ROTATERT */\n@@ -3851,7 +3850,6 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  /* ... fall through ... */\n \n-\tcase LSHIFT:\n \tcase ASHIFT:\n \tcase ASHIFTRT:\n \tcase LSHIFTRT:\n@@ -3993,7 +3991,6 @@ simplify_binary_operation (code, mode, op0, op1)\n       break;\n \n     case ASHIFT:\n-    case LSHIFT:\n       if (arg1 < 0)\n \treturn 0;\n \n@@ -4816,8 +4813,7 @@ fold_rtx (x, insn)\n \t\t     to compute that in SImode, because a 32-bit shift\n \t\t     in SImode is unpredictable.  We know the value is 0.  */\n \t\t  if (op0 && op1\n-\t\t      && (GET_CODE (elt->exp) == ASHIFT\n-\t\t\t  || GET_CODE (elt->exp) == LSHIFT)\n+\t\t      && GET_CODE (elt->exp) == ASHIFT\n \t\t      && GET_CODE (op1) == CONST_INT\n \t\t      && INTVAL (op1) >= GET_MODE_BITSIZE (mode))\n \t\t    {"}, {"sha": "4f40d0b540a9c46c20f48357126d20eabf0e4c21", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=45620ed410139824655ea4c26db4ad7d8251e21d", "patch": "@@ -2719,8 +2719,8 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n     case DIV:      case UDIV:\n     case MOD:      case UMOD:\n     case AND:      case IOR:      case XOR:\n-    case LSHIFT:   case ASHIFT:   case ROTATE:\n-    case ASHIFTRT: case LSHIFTRT: case ROTATERT:\n+    case ROTATERT: case ROTATE:\n+    case ASHIFTRT: case LSHIFTRT: case ASHIFT:\n     case NE:       case EQ:\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:"}, {"sha": "bacdafb8e12dbd76a5ce73f92b864d051fd59c43", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=45620ed410139824655ea4c26db4ad7d8251e21d", "patch": "@@ -4287,7 +4287,7 @@ write_test_expr (exp, in_comparison)\n \n     case PLUS:   case MINUS:  case MULT:     case DIV:      case MOD:\n     case AND:    case IOR:    case XOR:\n-    case LSHIFT: case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n+    case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n       write_test_expr (XEXP (exp, 0), in_comparison || comparison_operator);\n       switch (code)\n         {\n@@ -4351,7 +4351,6 @@ write_test_expr (exp, in_comparison)\n \tcase XOR:\n \t  printf (\" ^ \");\n \t  break;\n-\tcase LSHIFT:\n \tcase ASHIFT:\n \t  printf (\" << \");\n \t  break;"}, {"sha": "17ef97a2776f196a55ba770b8a850ea83cc191b8", "filename": "gcc/loop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=45620ed410139824655ea4c26db4ad7d8251e21d", "patch": "@@ -2470,7 +2470,6 @@ mark_loop_jump (x, loop_num)\n     case PLUS:\n     case MINUS:\n     case MULT:\n-    case LSHIFT:\n       mark_loop_jump (XEXP (x, 0), loop_num);\n       mark_loop_jump (XEXP (x, 1), loop_num);\n       return;\n@@ -5165,7 +5164,6 @@ simplify_giv_expr (x, benefit)\n \t}\n \n     case ASHIFT:\n-    case LSHIFT:\n       /* Shift by constant is multiply by power of two.  */\n       if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \treturn 0;"}, {"sha": "d25dc7334b1827da304c4281d6b786c9346c46e3", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45620ed410139824655ea4c26db4ad7d8251e21d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=45620ed410139824655ea4c26db4ad7d8251e21d", "patch": "@@ -2928,8 +2928,8 @@ eliminate_regs (x, mem_mode, insn)\n     case DIV:      case UDIV:\n     case MOD:      case UMOD:\n     case AND:      case IOR:      case XOR:\n-    case LSHIFT:   case ASHIFT:   case ROTATE:\n-    case ASHIFTRT: case LSHIFTRT: case ROTATERT:\n+    case ROTATERT: case ROTATE:\n+    case ASHIFTRT: case LSHIFTRT: case ASHIFT:\n     case NE:       case EQ:\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:"}]}