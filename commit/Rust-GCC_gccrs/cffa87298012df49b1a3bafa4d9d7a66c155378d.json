{"sha": "cffa87298012df49b1a3bafa4d9d7a66c155378d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmYTg3Mjk4MDEyZGY0OWIxYTNiYWZhNGQ5ZDdhNjZjMTU1Mzc4ZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-20T20:35:10Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-20T20:35:10Z"}, "message": "82nd Cygnus<->FSF merge\n\nFrom-SVN: r11328", "tree": {"sha": "6ee9a4da1768cb23abf74781faddd9d48d5f4b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ee9a4da1768cb23abf74781faddd9d48d5f4b37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cffa87298012df49b1a3bafa4d9d7a66c155378d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffa87298012df49b1a3bafa4d9d7a66c155378d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cffa87298012df49b1a3bafa4d9d7a66c155378d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffa87298012df49b1a3bafa4d9d7a66c155378d/comments", "author": null, "committer": null, "parents": [{"sha": "1144563fbc40c80298e1477c67c0614d1e9a917e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1144563fbc40c80298e1477c67c0614d1e9a917e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1144563fbc40c80298e1477c67c0614d1e9a917e"}], "stats": {"total": 606, "additions": 374, "deletions": 232}, "files": [{"sha": "217146b76c9b847fd8d5cc39863d9a2e8632161d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -1,8 +1,107 @@\n+Thu Feb 15 18:44:42 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (cp_finish_decl): Delay emitting the debug information for\n+\ta typedef that has been installed as the canonical typedef, if the\n+\ttype has not yet been defined.\n+\n+Thu Feb 15 09:39:08 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (grokfield): Still call pop_nested_class for access decls.\n+\n+Wed Feb 14 17:30:04 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (lookup_label): Call label_rtx.\n+\n+\t* decl.c (make_binding_level): New function.\n+\t(pushlevel, pushlevel_class): Call it instead of explicit\n+\tduplicate calls to xmalloc.\n+\n+\t* decl.c (init_decl_processing): Delete useless build_pointer_type\n+\tcall.\n+\n+\t* decl.c (float_ftype_float, ldouble_ftype_ldouble): Add definitions.\n+\t(sizet_ftype_string): Delete variable.\n+\t(init_decl_processing): Add built-in functions fabsf, fabsl,\n+\tsqrtf, sqrtl, sinf, sin, sinl, cosf, cos, cosl.  New local\n+\tvariable strlen_ftype, used for strlen.\n+\n+Wed Feb 14 16:21:25 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (push_to_top_level): Start from current_binding_level\n+ \tagain for now; the stl hacks depend on g++ being broken in this\n+ \tway, and it'll be fixed in the template rewrite.\n+\n+\t* tree.def: Add USING_DECL.\n+\t* decl2.c (do_class_using_decl): Implement.\n+\t(grokfield): Pass access decls off to do_class_using_decl instead of\n+\tgrokdeclarator.\n+\t* error.c (dump_decl): Handle USING_DECLs.\n+\t* decl.c (grokdeclarator): Remove code for handling access decls.\n+\t* class.c (finish_struct_1): Adjust accordingly, treat using-decls\n+ \tas access decls for now.\n+\t(finish_struct): Don't check USING_DECLs for other uses of the name.\n+\n+\t* search.c (get_matching_virtual): Use cp_error_at.\n+\n+Wed Feb 14 10:36:58 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* typeck.c (comptypes): Default COMP_TYPE_ATTRIBUTES to 1, to\n+\tmatch c-typeck.c.\n+\t(self_promoting_args_p): Move the check that TYPE is non-nil\n+\tbefore trying to look at its main variant.\n+\t(unsigned_type, signed_type): Add checking of DI/SI/HI/QI nodes.\n+\n+\t* cp-tree.h (DECL_WAITING_FRIENDS, SET_DECL_WAITING_FRIENDS):\n+\tDelete macros.\n+\t* init.c (xref_friend, embrace_waiting_friends): Delete functions.\n+\t(do_friend): Delete call to xref_friend.\n+\t* class.c (finish_struct_1): Delete call to embrace_waiting_friends.\n+\n+\t* typeck.c (convert_sequence): #if 0 unused function.\n+\n+\t* cp-tree.h (DECL_IN_MEMORY_P): New macro w/ the check that used to\n+\tbe in decl_in_memory_p.\n+\t(decl_in_memory_p): Delete decl.\n+\t* expr.c (decl_in_memory_p): Delete fn.\n+\t* typeck.c (mark_addressable): Use DECL_IN_MEMORY_P.\n+\n+\t* decl.c (cp_finish_decl): Use DECL_IN_MEMORY_P.\n+\n+Tue Feb 13 12:51:21 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Check for a pure-specifier on a\n+ \tnon-virtual function here.\n+\n+\t* decl2.c (grok_function_init): Don't check whether the function\n+ \tis virtual here.\n+\t(grokfield): Don't call check_for_override here.\n+\n+\t* decl.c (push_to_top_level): Start from inner_binding_level,\n+ \tcheck class_shadowed in class levels.\n+\n+Mon Feb 12 17:46:59 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (resume_level): Ignore things that don't have names, instead\n+\tof core dumping.\n+\n+Mon Feb 12 15:47:44 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl2.c (grokfield): Set DECL_VINDEX properly for FUNCTION_DECLs.\n+\n+Sat Feb 10 17:59:45 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Set DECL_VINDEX properly on a\n+ \tsynthesized dtor.\n+\n+\t* parse.y (complete_type_name): Bind global_scope earlier.\n+\t(complex_type_name): Ditto.\n+\t(qualified_type_name): Remove.\n+\n Thu Feb  8 15:15:14 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (grokfndecl): Move code that looks for virtuals in base\n  \tclasses...\n-\t* class.c (fixup_virtual): ... to a new function.\n+\t* class.c (check_for_override): ... to a new function.\n \t(finish_struct_1): Call it.\n \n \t* cp-tree.h: Declare warn_sign_compare."}, {"sha": "6b8f88098550aabed9464bdb4973a0b879598b4e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -2758,7 +2758,7 @@ mark_overriders (fndecl, base_fndecls)\n    mark this field as being virtual as well.  */\n \n void\n-fixup_virtual (decl, ctype)\n+check_for_override (decl, ctype)\n      tree decl, ctype;\n {\n   tree binfos = BINFO_BASETYPES (TYPE_BINFO (ctype));\n@@ -3177,7 +3177,9 @@ finish_struct_1 (t, attributes, warn_anon)\n       DECL_SAVED_INSNS (x) = NULL_RTX;\n       DECL_FIELD_SIZE (x) = 0;\n \n-      fixup_virtual (x, t);\n+      check_for_override (x, t);\n+      if (DECL_ABSTRACT_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n+\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n \n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n@@ -3198,19 +3200,36 @@ finish_struct_1 (t, attributes, warn_anon)\n       GNU_xref_member (current_class_name, x);\n \n       /* Handle access declarations.  */\n-      if (DECL_NAME (x) && TREE_CODE (DECL_NAME (x)) == SCOPE_REF)\n+      if (TREE_CODE (x) == USING_DECL)\n \t{\n-\t  tree fdecl = TREE_OPERAND (DECL_NAME (x), 1);\n+\t  tree ctype = DECL_INITIAL (x);\n+\t  tree sname = DECL_NAME (x);\n \t  tree access\n \t    = TREE_PRIVATE (x) ? access_private_node :\n \t      TREE_PROTECTED (x) ? access_protected_node : access_public_node;\n+\t  tree fdecl, binfo;\n \n \t  if (last_x)\n \t    TREE_CHAIN (last_x) = TREE_CHAIN (x);\n \t  else\n \t    fields = TREE_CHAIN (x);\n \n-\t  access_decls = tree_cons (access, fdecl, access_decls);\n+\t  binfo = binfo_or_else (ctype, t);\n+\t  if (! binfo)\n+\t    continue;\n+\n+\t  if (sname == constructor_name (ctype)\n+\t      || sname == constructor_name_full (ctype))\n+\t    cp_error_at (\"using-declaration for constructor\", x);\n+\n+\t  fdecl = lookup_field (binfo, sname, 0, 0);\n+\t  if (! fdecl)\n+\t    fdecl = lookup_fnfields (binfo, sname, 0);\n+\n+\t  if (fdecl)\n+\t    access_decls = tree_cons (access, fdecl, access_decls);\n+\t  else\n+\t    cp_error_at (\"no members matching `%D' in `%#T'\", x, ctype);\n \t  continue;\n \t}\n \n@@ -3529,6 +3548,7 @@ finish_struct_1 (t, attributes, warn_anon)\n     {\n       /* Here we must cons up a destructor on the fly.  */\n       tree dtor = cons_up_default_function (t, name, needs_virtual_dtor != 0);\n+      check_for_override (dtor, t);\n \n       /* If we couldn't make it work, then pretend we didn't need it.  */\n       if (dtor == void_type_node)\n@@ -4125,9 +4145,6 @@ finish_struct_1 (t, attributes, warn_anon)\n   else if (TYPE_NEEDS_CONSTRUCTING (t))\n     build_class_init_list (t);\n \n-  if (! IS_SIGNATURE (t))\n-    embrace_waiting_friends (t);\n-\n   /* Write out inline function definitions.  */\n   do_inline_function_hair (t, CLASSTYPE_INLINE_FRIENDS (t));\n   CLASSTYPE_INLINE_FRIENDS (t) = 0;\n@@ -4289,7 +4306,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \n \t  /* Check for inconsistent use of this name in the class body.\n              Enums, types and static vars have already been checked.  */\n-\t  if (TREE_CODE (x) != TYPE_DECL\n+\t  if (TREE_CODE (x) != TYPE_DECL && TREE_CODE (x) != USING_DECL\n \t      && TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n \t    {\n \t      tree name = DECL_NAME (x);"}, {"sha": "197e9c90e0f278103619984294aa3baab64154c3", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -114,3 +114,7 @@ DEFTREECODE (THUNK_DECL, \"thunk_decl\", \"d\", 0)\n \n /* A namespace declaration.  */\n DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", \"d\", 0)\n+\n+/* A using declaration.  DECL_INITIAL contains the specified scope.  \n+   This is not an alias, but is later expanded into multiple aliases.  */\n+DEFTREECODE (USING_DECL, \"using_decl\", \"d\", 0)"}, {"sha": "67e0de3a82ac91d65f1cb335ff03c127e6d2b5dc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -973,6 +973,14 @@ struct lang_decl\n #define TREE_READONLY_DECL_P(NODE) \\\n   (TREE_READONLY (NODE) && TREE_CODE_CLASS (TREE_CODE (NODE)) == 'd')\n \n+/* Non-zero iff DECL is memory-based.  The DECL_RTL of\n+   certain const variables might be a CONST_INT, or a REG\n+   in some cases.  We cannot use `memory_operand' as a test\n+   here because on most RISC machines, a variable's address\n+   is not, by itself, a legitimate address.  */\n+#define DECL_IN_MEMORY_P(NODE) \\\n+  (DECL_RTL (NODE) != NULL_RTX && GET_CODE (DECL_RTL (NODE)) == MEM)\n+\n /* For FUNCTION_DECLs: return the language in which this decl\n    was declared.  */\n #define DECL_LANGUAGE(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.language)\n@@ -1302,12 +1310,6 @@ extern int flag_new_for_scope;\n \n /* C++: all of these are overloaded!  These apply only to TYPE_DECLs.  */\n #define DECL_FRIENDLIST(NODE)\t\t(DECL_INITIAL (NODE))\n-#if 0\n-#define DECL_UNDEFINED_FRIENDS(NODE)\t((NODE)->decl.result)\n-#endif\n-#define DECL_WAITING_FRIENDS(NODE)\t((tree)(NODE)->decl.rtl)\n-#define SET_DECL_WAITING_FRIENDS(NODE,VALUE) \\\n-\t((NODE)->decl.rtl=(struct rtx_def*)VALUE)\n \n /* The DECL_ACCESS is used to record under which context\n    special access rules apply.  */\n@@ -2124,7 +2126,6 @@ extern tree start_anon_func\t\t\tPROTO((void));\n /* skip cplus_expand_expr */\n extern void init_cplus_expand\t\t\tPROTO((void));\n extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n-extern int decl_in_memory_p\t\t\tPROTO((tree));\n extern tree unsave_expr_now\t\t\tPROTO((tree));\n \n /* in rtti.c */"}, {"sha": "ee66250cdb2159bc54473a2fc003476c9bb80755", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 93, "deletions": 79, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -220,6 +220,8 @@ tree default_function_type;\n \n tree double_ftype_double, double_ftype_double_double;\n tree int_ftype_int, long_ftype_long;\n+tree float_ftype_float;\n+tree ldouble_ftype_ldouble;\n \n /* Function type `void (void *, void *, int)' and similar ones.  */\n \n@@ -228,9 +230,6 @@ tree void_ftype_ptr_ptr_int, int_ftype_ptr_ptr_int, void_ftype_ptr_int_int;\n /* Function type `char *(char *, char *)' and similar ones */\n tree string_ftype_ptr_ptr, int_ftype_string_string;\n \n-/* Function type `size_t (const char *)' */\n-tree sizet_ftype_string;\n-\n /* Function type `int (const void *, const void *, size_t)' */\n tree int_ftype_cptr_cptr_sizet;\n \n@@ -796,6 +795,16 @@ resume_binding_level (b)\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n }\n \f\n+/* Create a new `struct binding_level'.  */\n+\n+static\n+struct binding_level *\n+make_binding_level ()\n+{\n+  /* NOSTRICT */\n+  return (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+}\n+\n /* Nonzero if we are currently in the global binding level.  */\n \n int\n@@ -924,9 +933,9 @@ pushlevel (tag_transparent)\n     }\n   else\n     {\n-      /* Create a new `struct binding_level'.  */\n-      newlevel = (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+      newlevel = make_binding_level ();\n     }\n+\n   push_binding_level (newlevel, tag_transparent, keep_next_level_flag);\n   GNU_xref_start_scope ((HOST_WIDE_INT) newlevel);\n   keep_next_level_flag = 0;\n@@ -1283,8 +1292,11 @@ resume_level (b)\n \n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n-      if (DECL_NAME (link) != NULL_TREE)\n-\tIDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = link;\n+      /* If it doesn't have a name, there is nothing left to do with it.  */\n+      if (DECL_NAME (link) == NULL_TREE)\n+\tcontinue;\n+\n+      IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = link;\n \n       /* If this is a TYPE_DECL, push it into the type value slot.  */\n       if (TREE_CODE (link) == TYPE_DECL)\n@@ -1366,8 +1378,7 @@ pushlevel_class ()\n     }\n   else\n     {\n-      /* Create a new `struct binding_level'.  */\n-      newlevel = (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+      newlevel = make_binding_level ();\n     }\n \n #if defined(DEBUG_CP_BINDING_LEVELS)\n@@ -1818,10 +1829,10 @@ push_to_top_level ()\n \tcontinue;\n \n       old_bindings = store_bindings (b->names, old_bindings);\n-      /* We also need to check type_shadowed to save class-level type\n+      /* We also need to check class_shadowed to save class-level type\n \t bindings, since pushclass doesn't fill in b->names.  */\n       if (b->parm_flag == 2)\n-\told_bindings = store_bindings (b->type_shadowed, old_bindings);\n+\told_bindings = store_bindings (b->class_shadowed, old_bindings);\n \n       /* Unwind type-value slots back to top level.  */\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n@@ -3754,6 +3765,9 @@ lookup_label (id)\n \n   decl = build_decl (LABEL_DECL, id, void_type_node);\n \n+  /* Make sure every label has an rtx.  */\n+  label_rtx (decl);\n+\n   /* A label not explicitly declared must be local to where it's ref'd.  */\n   DECL_CONTEXT (decl) = current_function_decl;\n \n@@ -4016,8 +4030,8 @@ storetags (tags)\n static tree\n lookup_tag (form, name, binding_level, thislevel_only)\n      enum tree_code form;\n-     struct binding_level *binding_level;\n      tree name;\n+     struct binding_level *binding_level;\n      int thislevel_only;\n {\n   register struct binding_level *level;\n@@ -4561,12 +4575,12 @@ void\n init_decl_processing ()\n {\n   tree decl;\n-  register tree endlink, int_endlink, double_endlink, ptr_endlink;\n+  register tree endlink, int_endlink, double_endlink, ptr_endlink, float_endlink;\n   tree fields[20];\n   /* Either char* or void*.  */\n   tree traditional_ptr_type_node;\n   /* Data type of memcpy.  */\n-  tree memcpy_ftype;\n+  tree memcpy_ftype, strlen_ftype;\n   int wchar_type_size;\n   tree temp;\n   tree array_domain_type;\n@@ -4810,7 +4824,6 @@ init_decl_processing ()\n \n   default_function_type\n     = build_function_type (integer_type_node, NULL_TREE);\n-  build_pointer_type (default_function_type);\n \n   ptr_type_node = build_pointer_type (void_type_node);\n   const_ptr_type_node =\n@@ -4819,11 +4832,21 @@ init_decl_processing ()\n   endlink = void_list_node;\n   int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);\n   double_endlink = tree_cons (NULL_TREE, double_type_node, endlink);\n+  float_endlink = tree_cons (NULL_TREE, float_type_node, endlink);\n   ptr_endlink = tree_cons (NULL_TREE, ptr_type_node, endlink);\n \n+  float_ftype_float\n+    = build_function_type (float_type_node,\n+\t\t\t   tree_cons (NULL_TREE, float_type_node, endlink));\n+\n   double_ftype_double\n     = build_function_type (double_type_node, double_endlink);\n \n+  ldouble_ftype_ldouble\n+    = build_function_type (long_double_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_double_type_node,\n+\t\t\t\t      endlink));\n+\n   double_ftype_double_double\n     = build_function_type (double_type_node,\n \t\t\t   tree_cons (NULL_TREE, double_type_node,\n@@ -4871,7 +4894,7 @@ init_decl_processing ()\n \t\t\t\t\t\t const_string_type_node,\n \t\t\t\t\t\t endlink)));\n \n-  sizet_ftype_string\t\t/* strlen prototype */\n+  strlen_ftype\t\t/* strlen prototype */\n     = build_function_type (sizetype,\n \t\t\t   tree_cons (NULL_TREE, const_string_type_node,\n \t\t\t\t      endlink));\n@@ -4910,13 +4933,13 @@ init_decl_processing ()\n \t\t\t\t\t\t    endlink)),\n \t\t    BUILT_IN_FRAME_ADDRESS, NULL_PTR);\n \n-\n   builtin_function (\"__builtin_alloca\",\n \t\t    build_function_type (ptr_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    sizetype,\n \t\t\t\t\t\t    endlink)),\n \t\t    BUILT_IN_ALLOCA, \"alloca\");\n+  builtin_function (\"__builtin_ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);\n   /* Define alloca, ffs as builtins.\n      Declare _exit just to mark it as volatile.  */\n   if (! flag_no_builtin && !flag_no_nonansi_builtin)\n@@ -4941,20 +4964,15 @@ init_decl_processing ()\n       DECL_BUILT_IN_NONANSI (temp) = 1;\n     }\n \n-  builtin_function (\"__builtin_abs\", int_ftype_int,\n-\t\t    BUILT_IN_ABS, NULL_PTR);\n-  builtin_function (\"__builtin_fabs\", double_ftype_double,\n-\t\t    BUILT_IN_FABS, NULL_PTR);\n+  builtin_function (\"__builtin_abs\", int_ftype_int, BUILT_IN_ABS, NULL_PTR);\n+  builtin_function (\"__builtin_fabsf\", float_ftype_float, BUILT_IN_FABS,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_fabs\", double_ftype_double, BUILT_IN_FABS,\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_fabsl\", ldouble_ftype_ldouble, BUILT_IN_FABS,\n+\t\t    NULL_PTR);\n   builtin_function (\"__builtin_labs\", long_ftype_long,\n \t\t    BUILT_IN_LABS, NULL_PTR);\n-  builtin_function (\"__builtin_ffs\", int_ftype_int,\n-\t\t    BUILT_IN_FFS, NULL_PTR);\n-  builtin_function (\"__builtin_fsqrt\", double_ftype_double,\n-\t\t    BUILT_IN_FSQRT, NULL_PTR);\n-  builtin_function (\"__builtin_sin\", double_ftype_double, \n-\t\t    BUILT_IN_SIN, \"sin\");\n-  builtin_function (\"__builtin_cos\", double_ftype_double, \n-\t\t    BUILT_IN_COS, \"cos\");\n   builtin_function (\"__builtin_saveregs\",\n \t\t    build_function_type (ptr_type_node, NULL_TREE),\n \t\t    BUILT_IN_SAVEREGS, NULL_PTR);\n@@ -5002,8 +5020,26 @@ init_decl_processing ()\n \t\t    BUILT_IN_STRCMP, \"strcmp\");\n   builtin_function (\"__builtin_strcpy\", string_ftype_ptr_ptr,\n \t\t    BUILT_IN_STRCPY, \"strcpy\");\n-  builtin_function (\"__builtin_strlen\", sizet_ftype_string,\n+  builtin_function (\"__builtin_strlen\", strlen_ftype,\n \t\t    BUILT_IN_STRLEN, \"strlen\");\n+  builtin_function (\"__builtin_sqrtf\", float_ftype_float, \n+\t\t    BUILT_IN_FSQRT, \"sqrtf\");\n+  builtin_function (\"__builtin_fsqrt\", double_ftype_double,\n+\t\t    BUILT_IN_FSQRT, NULL_PTR);\n+  builtin_function (\"__builtin_sqrtl\", ldouble_ftype_ldouble, \n+\t\t    BUILT_IN_FSQRT, \"sqrtl\");\n+  builtin_function (\"__builtin_sinf\", float_ftype_float, \n+\t\t    BUILT_IN_SIN, \"sinf\");\n+  builtin_function (\"__builtin_sin\", double_ftype_double, \n+\t\t    BUILT_IN_SIN, \"sin\");\n+  builtin_function (\"__builtin_sinl\", ldouble_ftype_ldouble, \n+\t\t    BUILT_IN_SIN, \"sinl\");\n+  builtin_function (\"__builtin_cosf\", float_ftype_float, \n+\t\t    BUILT_IN_COS, \"cosf\");\n+  builtin_function (\"__builtin_cos\", double_ftype_double, \n+\t\t    BUILT_IN_COS, \"cos\");\n+  builtin_function (\"__builtin_cosl\", ldouble_ftype_ldouble, \n+\t\t    BUILT_IN_COS, \"cosl\");\n \n   if (!flag_no_builtin)\n     {\n@@ -5012,15 +5048,27 @@ init_decl_processing ()\n       builtin_function (\"fabs\", double_ftype_double, BUILT_IN_FABS, NULL_PTR);\n       builtin_function (\"labs\", long_ftype_long, BUILT_IN_LABS, NULL_PTR);\n #endif\n+      builtin_function (\"fabsf\", float_ftype_float, BUILT_IN_FABS, NULL_PTR);\n+      builtin_function (\"fabsl\", ldouble_ftype_ldouble, BUILT_IN_FABS,\n+\t\t\tNULL_PTR);\n       builtin_function (\"memcpy\", memcpy_ftype, BUILT_IN_MEMCPY, NULL_PTR);\n       builtin_function (\"memcmp\", int_ftype_cptr_cptr_sizet, BUILT_IN_MEMCMP,\n \t\t\tNULL_PTR);\n-      builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP, NULL_PTR);\n+      builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP,\n+\t\t\tNULL_PTR);\n       builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY,\n \t\t\tNULL_PTR);\n-      builtin_function (\"strlen\", sizet_ftype_string, BUILT_IN_STRLEN, NULL_PTR);\n+      builtin_function (\"strlen\", strlen_ftype, BUILT_IN_STRLEN, NULL_PTR);\n+      builtin_function (\"sqrtf\", float_ftype_float, BUILT_IN_FSQRT, NULL_PTR);\n+      builtin_function (\"sqrt\", double_ftype_double, BUILT_IN_FSQRT, NULL_PTR);\n+      builtin_function (\"sqrtl\", ldouble_ftype_ldouble, BUILT_IN_FSQRT,\n+\t\t\tNULL_PTR);\n+      builtin_function (\"sinf\", float_ftype_float, BUILT_IN_SIN, NULL_PTR);\n       builtin_function (\"sin\", double_ftype_double, BUILT_IN_SIN, NULL_PTR);\n+      builtin_function (\"sinl\", ldouble_ftype_ldouble, BUILT_IN_SIN, NULL_PTR);\n+      builtin_function (\"cosf\", float_ftype_float, BUILT_IN_COS, NULL_PTR);\n       builtin_function (\"cos\", double_ftype_double, BUILT_IN_COS, NULL_PTR);\n+      builtin_function (\"cosl\", ldouble_ftype_ldouble, BUILT_IN_COS, NULL_PTR);\n \n       /* Declare these functions volatile\n \t to avoid spurious \"control drops through\" warnings.  */\n@@ -5047,13 +5095,14 @@ init_decl_processing ()\n   builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV, NULL_PTR);\n   builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR,\n \t\t    NULL_PTR);\n-  builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL, NULL_PTR);\n+  builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL,\n+\t\t    NULL_PTR);\n   builtin_function (\"__builtin_fmod\", double_ftype_double_double,\n \t\t    BUILT_IN_FMOD, NULL_PTR);\n   builtin_function (\"__builtin_frem\", double_ftype_double_double,\n \t\t    BUILT_IN_FREM, NULL_PTR);\n-  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET,\n-\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int,\n+\t\t    BUILT_IN_MEMSET, NULL_PTR);\n   builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP,\n \t\t    NULL_PTR);\n   builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN,\n@@ -6109,6 +6158,14 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t  CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \t}\n       GNU_xref_decl (current_function_decl, decl);\n+\n+      /* If we have installed this as the canonical typedef for this\n+\t type, and that type has not been defined yet, delay emitting\n+\t the debug informaion for it, as we will emit it later.  */\n+      if (TYPE_NAME (TREE_TYPE (decl)) == decl\n+\t  && TYPE_SIZE (TREE_TYPE (decl)) == NULL_TREE)\n+\tTYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n+\n       rest_of_decl_compilation (decl, NULL_PTR,\n \t\t\t\tDECL_CONTEXT (decl) == NULL_TREE, 0);\n       goto finish_end;\n@@ -6538,7 +6595,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t    }\n \t\t  if (link == NULL)\n \t\t    {\n-\t\t      if (DECL_RTL (decl) && GET_CODE (DECL_RTL (decl)) == MEM)\n+\t\t      if (DECL_IN_MEMORY_P (decl))\n \t\t\tpreserve_temp_slots (DECL_RTL (decl));\n \t\t      break;\n \t\t    }\n@@ -7698,10 +7755,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  opaque_typedef = 1;\n \t  type = copy_node (opaque_type_node);\n \t}\n-      /* access declaration */\n-      else if (decl_context == FIELD && declarator\n-\t       && TREE_CODE (declarator) == SCOPE_REF)\n-\ttype = void_type_node;\n       else\n \t{\n \t  if (funcdef_flag)\n@@ -8719,50 +8772,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\telse if (TYPE_SIZE (ctype) != NULL_TREE\n \t\t\t || (RIDBIT_SETP (RID_TYPEDEF, specbits)))\n \t\t  {\n-\t\t    tree t;\n \t\t    /* have to move this code elsewhere in this function.\n \t\t       this code is used for i.e., typedef int A::M; M *pm;\n \n \t\t       It is?  How? jason 10/2/94 */\n \n-\t\t    if (explicit_int == -1 && decl_context == FIELD\n-\t\t\t&& funcdef_flag == 0)\n-\t\t      {\n-\t\t\t/* The code in here should only be used to build\n-\t\t\t   stuff that will be grokked as access decls.  */\n-\t\t\tt = lookup_field (ctype, sname, 0, 0);\n-\t\t\tif (t)\n-\t\t\t  {\n-\t\t\t    t = build_lang_field_decl (FIELD_DECL, build_nt (SCOPE_REF, ctype, t), type);\n-\t\t\t    DECL_INITIAL (t) = init;\n-\t\t\t    return t;\n-\t\t\t  }\n-\t\t\t/* No such field, try member functions.  */\n-\t\t\tt = lookup_fnfields (TYPE_BINFO (ctype), sname, 0);\n-\t\t\tif (t)\n-\t\t\t  {\n-\t\t\t    if (flags == DTOR_FLAG)\n-\t\t\t      t = TREE_VALUE (t);\n-\t\t\t    else if (CLASSTYPE_METHOD_VEC (ctype)\n-\t\t\t\t     && TREE_VALUE (t) == TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (ctype), 0))\n-\t\t\t      {\n-\t\t\t\t/* Don't include destructor with constructors.  */\n-\t\t\t\tt = DECL_CHAIN (TREE_VALUE (t));\n-\t\t\t\tif (t == NULL_TREE)\n-\t\t\t\t  cp_error (\"`%T' does not have any constructors\",\n-\t\t\t\t\t    ctype);\n-\t\t\t\tt = build_tree_list (NULL_TREE, t);\n-\t\t\t      }\n-\t\t\t    t = build_lang_field_decl (FIELD_DECL, build_nt (SCOPE_REF, ctype, t), type);\n-\t\t\t    DECL_INITIAL (t) = init;\n-\t\t\t    return t;\n-\t\t\t  }\n-\n-\t\t\tcp_error\n-\t\t\t  (\"field `%D' is not a member of structure `%T'\",\n-\t\t\t   sname, ctype);\n-\t\t      }\n-\n \t\t    if (current_class_type)\n \t\t      {\n \t\t\tcp_error (\"cannot declare member `%T::%s' within `%T'\","}, {"sha": "38af65277f711ba7e818f6644f8ec17e0230ca09", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n static void grok_function_init ();\n+extern int current_class_depth;\n \n /* A list of virtual function tables we must make sure to write out.  */\n tree pending_vtables;\n@@ -1328,11 +1329,20 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n       flags = 0;\n     }\n \n+  if (declspecs == NULL_TREE\n+      && TREE_CODE (declarator) == SCOPE_REF)\n+    {\n+      /* Access declaration */\n+      if (TREE_COMPLEXITY (declarator) == current_class_depth)\n+\tpop_nested_class (1);\n+      return do_class_using_decl (declarator);\n+    }\n+\n   if (init\n       && TREE_CODE (init) == TREE_LIST\n       && TREE_VALUE (init) == error_mark_node\n       && TREE_CHAIN (init) == NULL_TREE)\n-\tinit = NULL_TREE;\n+    init = NULL_TREE;\n \n   value = grokdeclarator (declarator, declspecs, FIELD, init != 0,\n \t\t\t  raises, NULL_TREE);\n@@ -1867,8 +1877,11 @@ grok_function_init (decl, init)\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     cp_error (\"initializer specified for non-member function `%D'\", decl);\n+#if 0\n+  /* We'll check for this in finish_struct_1.  */\n   else if (DECL_VINDEX (decl) == NULL_TREE)\n     cp_error (\"initializer specified for non-virtual method `%D'\", decl);\n+#endif\n   else if (integer_zerop (init))\n     {\n #if 0\n@@ -3404,10 +3417,23 @@ tree\n do_class_using_decl (decl)\n      tree decl;\n {\n-  tree type;\n+  tree name, value;\n \n-  /* Ignore for now, unimplemented. */\n-  return NULL_TREE;\n+  if (TREE_CODE (decl) != SCOPE_REF)\n+    {\n+      cp_error (\"using-declaration for non-member at class scope\");\n+      return NULL_TREE;\n+    }\n+  name = TREE_OPERAND (decl, 1);\n+  if (TREE_CODE (name) == BIT_NOT_EXPR)\n+    {\n+      cp_error (\"using-declaration for destructor\");\n+      return NULL_TREE;\n+    }\n+\n+  value = build_lang_field_decl (USING_DECL, name, unknown_type_node);\n+  DECL_INITIAL (value) = TREE_OPERAND (decl, 0);\n+  return value;\n }\n \n void"}, {"sha": "6c7a83821341d9e419fe48e6dbb728e1804070aa", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -740,6 +740,13 @@ dump_decl (t, v)\n \tdump_expr (DECL_INITIAL (t), 0);\n       break;\n \n+    case USING_DECL:\n+      OB_PUTS (\"using \");\n+      dump_type (DECL_INITIAL (t), 0);\n+      OB_PUTS (\"::\");\n+      OB_PUTID (DECL_NAME (t));\n+      break;\n+\n     default:\n       sorry (\"`%s' not supported by dump_decl\",\n \t     tree_code_name[(int) TREE_CODE (t)]);"}, {"sha": "d0d7b494a4ca7b0e19ea7f5026e2e36cc5204cb0", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -278,19 +278,6 @@ fixup_result_decl (decl, result)\n     }\n }\n \n-/* Return nonzero iff DECL is memory-based.  The DECL_RTL of\n-   certain const variables might be a CONST_INT, or a REG\n-   in some cases.  We cannot use `memory_operand' as a test\n-   here because on most RISC machines, a variable's address\n-   is not, by itself, a legitimate address.  */\n-\n-int\n-decl_in_memory_p (decl)\n-     tree decl;\n-{\n-  return DECL_RTL (decl) != 0 && GET_CODE (DECL_RTL (decl)) == MEM;\n-}\n-\n /* Expand this initialization inline and see if it's simple enough that\n    it can be done at compile-time.  */\n "}, {"sha": "54581f283ead822e97a89c8101308efb4c868776", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -1287,13 +1287,13 @@ Ln:\t\t\t\t\tthrow value;\n         copy value onto heap\n         jump throw (Ln, id, address of copy of value on heap)\n \n-                                        try {\n+                                        try @{\n +Lstart:\tthe start of the main EH region\n |...\t\t\t\t\t\t...\n +Lend:\t\tthe end of the main EH region\n-                                        } catch (T o) {\n+                                        @} catch (T o) @{\n \t\t\t\t\t\t...1\n-                                        }\n+                                        @}\n Lresume:\n         nop\tused to make sure there is something before\n                 the next region ends, if there is one\n@@ -1314,15 +1314,15 @@ Lover:\n [\n  [\n         call throw_type_match\n-        if (eq) {\n+        if (eq) @{\n  ] these lines disappear when there is no catch condition\n +Lsregion2:\n |\t...1\n |\tjump Lresume\n |Lhandler:\thandler for the region Lsregion2-Leregion2\n |\trethrow (Lresume, same id, same obj);\n +Leregion2\n-        }\n+        @}\n ] there are zero or more of these sections, depending upon how many\n   catch clauses there are\n ----------------------------- expand_end_all_catch --------------------------\n@@ -1338,7 +1338,7 @@ Ldone:\n \n start_all_catch emits labels: Lresume, \n \n-#end example\n+@end example\n \n The __unwind_function takes a pointer to the throw handler, and is\n expected to pop the stack frame that was built to call it, as well as\n@@ -1348,7 +1348,7 @@ machine state as determined by the context in which we are unwinding\n into.  The way I normally start is to compile:\n \n         void *g;\n-        foo(void* a) { g = a; }\n+        foo(void* a) @{ g = a; @}\n \n with -S, and change the thing that alters the PC (return, or ret\n usually) to not alter the PC, making sure to leave all other semantics\n@@ -1455,7 +1455,7 @@ descriptor that refers to fully contained code that has been eliminated\n should also be removed, although not doing this is harmless in terms of\n semantics.\n \n-#end itemize\n+@end itemize\n \n The above is not meant to be exhaustive, but does include all things I\n have thought of so far.  I am sure other limitations exist.\n@@ -1517,7 +1517,7 @@ pointer, frame pointer, arg pointer and so on.\n \n The eh archive (~mrs/eh) might be good reading for understanding the Ada\n perspective, and some of kenners mindset, and a detailed explanation\n-(Message-Id: <9308301130.AA10543@vlsi1.ultra.nyu.edu>) of the concepts\n+(Message-Id: <9308301130.AA10543@@vlsi1.ultra.nyu.edu>) of the concepts\n involved.\n \n Here is a guide to existing backend type code.  It is all in"}, {"sha": "6c2ae1750ec07ea8741cc6f938e73d0d6fd91baa", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 76, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -2332,23 +2332,6 @@ add_friends (type, name, friend_type)\n     }\n }\n \n-/* Set up a cross reference so that type TYPE will make member function\n-   CTYPE::DECL a friend when CTYPE is finally defined.  For more than\n-   one, set up a cross reference so that functions with the name DECL\n-   and type CTYPE know that they are friends of TYPE.  */\n-static void\n-xref_friend (type, decl, ctype)\n-     tree type, decl, ctype;\n-{\n-  tree friend_decl = TYPE_NAME (ctype);\n-  tree t = 0;\n-\n-  SET_DECL_WAITING_FRIENDS (friend_decl,\n-\t\t\t    tree_cons (type, t,\n-\t\t\t\t       DECL_WAITING_FRIENDS (friend_decl)));\n-  TREE_TYPE (DECL_WAITING_FRIENDS (friend_decl)) = decl;\n-}\n-\n /* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already\n    been defined, we make all of its member functions friends of\n    TYPE.  If not, we make it a pending friend, which can later be added\n@@ -2469,24 +2452,14 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n \n \t  /* Get the class they belong to.  */\n \t  tree ctype = IDENTIFIER_TYPE_VALUE (cname);\n+\t  tree fields = lookup_fnfields (TYPE_BINFO (ctype), declarator, 0);\n \n-\t  /* This class is defined, use its methods now.  */\n-\t  if (TYPE_SIZE (ctype))\n-\t    {\n-\t      tree fields = lookup_fnfields (TYPE_BINFO (ctype), declarator, 0);\n-\t      if (fields)\n-\t\tadd_friends (current_class_type, declarator, ctype);\n-\t      else\n-\t\terror (\"method `%s' is not a member of class `%s'\",\n-\t\t       IDENTIFIER_POINTER (declarator),\n-\t\t       IDENTIFIER_POINTER (cname));\n-\t    }\n+\t  if (fields)\n+\t    add_friends (current_class_type, declarator, ctype);\n \t  else\n-\t    /* Note: DECLARATOR actually has more than one; in this\n-\t       case, we're making sure that fns with the name DECLARATOR\n-\t       and type CTYPE know they are friends of the current\n-\t       class type.  */\n-\t    xref_friend (current_class_type, declarator, ctype);\n+\t    error (\"method `%s' is not a member of class `%s'\",\n+\t\t   IDENTIFIER_POINTER (declarator),\n+\t\t   IDENTIFIER_POINTER (cname));\n \t  decl = void_type_node;\n \t}\n     }\n@@ -2561,49 +2534,6 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n     }\n   return decl;\n }\n-\n-/* TYPE has now been defined.  It may, however, have a number of things\n-   waiting make make it their friend.  We resolve these references\n-   here.  */\n-void\n-embrace_waiting_friends (type)\n-     tree type;\n-{\n-  tree decl = TYPE_NAME (type);\n-  tree waiters;\n-\n-  if (TREE_CODE (decl) != TYPE_DECL)\n-    return;\n-\n-  for (waiters = DECL_WAITING_FRIENDS (decl); waiters;\n-       waiters = TREE_CHAIN (waiters))\n-    {\n-      tree waiter = TREE_PURPOSE (waiters);\n-      tree decl = TREE_TYPE (waiters);\n-      tree name = decl ? (TREE_CODE (decl) == IDENTIFIER_NODE\n-\t\t\t  ? decl : DECL_NAME (decl)) : NULL_TREE;\n-      if (name)\n-\t{\n-\t  /* @@ There may be work to be done since we have not verified\n-\t     @@ consistency between original and friend declarations\n-\t     @@ of the functions waiting to become friends.  */\n-\t  tree field = lookup_fnfields (TYPE_BINFO (type), name, 0);\n-\t  if (field)\n-\t    if (decl == name)\n-\t      add_friends (waiter, name, type);\n-\t    else\n-\t      add_friend (waiter, decl);\n-\t  else\n-\t    error_with_file_and_line (DECL_SOURCE_FILE (TYPE_NAME (waiter)),\n-\t\t\t\t      DECL_SOURCE_LINE (TYPE_NAME (waiter)),\n-\t\t\t\t      \"no method `%s' defined in class `%s' to be friend\",\n-\t\t\t\t      IDENTIFIER_POINTER (DECL_NAME (TREE_TYPE (waiters))),\n-\t\t\t\t      TYPE_NAME_STRING (type));\n-\t}\n-      else\n-\tmake_friend_class (type, waiter);\n-    }\n-}\n \f\n /* Common subroutines of build_new and build_vec_delete.  */\n "}, {"sha": "a75344bbea1cb41c8c5ec92ccb20ae4a908ffa8d", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 56, "deletions": 20, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -254,7 +254,7 @@ empty_parms ()\n /* %type <itype> try_for_typename */\n %type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n-%type <ttype> qualified_type_name complete_type_name notype_identifier\n+%type <ttype> complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n %type <ttype> new_initializer new_placement specialization type_specifier_seq\n@@ -2854,23 +2854,48 @@ after_type_declarator:\n \t| direct_after_type_declarator\n \t;\n \n-qualified_type_name:\n+complete_type_name:\n \t  type_name %prec EMPTY\n \t\t{\n-\t\t  $$ = identifier_typedecl_value ($1);\n-\t\t  /* Remember that this name has been used in the class\n-\t\t     definition, as per [class.scope0] */\n-\t\t  if (current_class_type\n-\t\t      && TYPE_BEING_DEFINED (current_class_type)\n-\t\t      && ! IDENTIFIER_TEMPLATE ($1)\n-\t\t      && ! IDENTIFIER_CLASS_VALUE ($1))\n+\t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n+\t\t    {\n+\t\t      if (current_class_type\n+\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n+\t\t\t  && ! TREE_MANGLED ($1)\n+\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($1))\n+\t\t\t{\n+\t\t\t  /* Be sure to get an inherited typedef.  */\n+\t\t\t  $$ = lookup_name ($1, 1);\n+\t\t\t  /* Remember that this name has been used in the class\n+\t\t\t     definition, as per [class.scope0] */\n+\t\t\t  pushdecl_class_level ($$);\n+\t\t\t}\n+\t\t      else\n+\t\t\t$$ = identifier_typedecl_value ($1);\n+\t\t    }\n+\t\t  else\n+\t\t    $$ = $1;\n+\t\t}\n+\t| global_scope type_name\n+\t\t{\n+\t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    {\n-\t\t      /* Be sure to get an inherited typedef.  */\n-\t\t      $$ = lookup_name ($1, 1);\n-\t\t      pushdecl_class_level ($$);\n+\t\t      if (current_class_type\n+\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n+\t\t\t  && ! TREE_MANGLED ($2)\n+\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($2))\n+\t\t\t/* Be sure to get an inherited typedef.  */\n+\t\t\t$$ = lookup_name ($2, 1);\n+\t\t      else\n+\t\t        $$ = identifier_typedecl_value ($2);\n \t\t    }\n+\t\t  else\n+\t\t    $$ = $2;\n+\t\t  got_scope = NULL_TREE;\n \t\t}\n \t| nested_type\n+\t| global_scope nested_type\n+\t\t{ $$ = $2; }\n \t;\n \n nested_type:\n@@ -3016,15 +3041,26 @@ nested_name_specifier_1:\n \t\t{ goto failed_scope; } */\n \t;\n \n-complete_type_name:\n-\t  qualified_type_name\n-\t| global_scope qualified_type_name\n-\t\t{ $$ = $2; }\n-\t;\n-\n complex_type_name:\n-\t  nested_type\n-\t| global_scope qualified_type_name\n+\t  global_scope type_name\n+\t\t{\n+\t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n+\t\t    {\n+\t\t      if (current_class_type\n+\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n+\t\t\t  && ! TREE_MANGLED ($2)\n+\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($2))\n+\t\t\t/* Be sure to get an inherited typedef.  */\n+\t\t\t$$ = lookup_name ($2, 1);\n+\t\t      else\n+\t\t        $$ = identifier_typedecl_value ($2);\n+\t\t    }\n+\t\t  else\n+\t\t    $$ = $2;\n+\t\t  got_scope = NULL_TREE;\n+\t\t}\n+\t| nested_type\n+\t| global_scope nested_type\n \t\t{ $$ = $2; }\n \t;\n "}, {"sha": "2f1b0c307efa2649ffb22e7f5ac9e209764c4949", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -2034,13 +2034,13 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t\t}\n \t\t      if (TYPE_READONLY (d) > TYPE_READONLY (b))\n \t\t\t{\n-\t\t\t  cp_error (\"return type of `%#D' adds const\", fndecl);\n+\t\t\t  cp_error_at (\"return type of `%#D' adds const\", fndecl);\n \t\t\t  cp_error_at (\"  overriding definition as `%#D'\",\n \t\t\t\t       tmp);\n \t\t\t}\n \t\t      else if (TYPE_VOLATILE (d) > TYPE_VOLATILE (b))\n \t\t\t{\n-\t\t\t  cp_error (\"return type of `%#D' adds volatile\",\n+\t\t\t  cp_error_at (\"return type of `%#D' adds volatile\",\n \t\t\t\t    fndecl);\n \t\t\t  cp_error_at (\"  overriding definition as `%#D'\",\n \t\t\t\t       tmp);\n@@ -2051,11 +2051,11 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t    {\n \t\t      error (\"invalid covariant return type (must use pointer or reference)\");\n \t\t      cp_error_at (\"  overriding `%#D'\", tmp);\n-\t\t      cp_error (\"  with `%#D'\", fndecl);\n+\t\t      cp_error_at (\"  with `%#D'\", fndecl);\n \t\t    }\n \t\t  else if (IDENTIFIER_ERROR_LOCUS (name) == NULL_TREE)\n \t\t    {\n-\t\t      cp_error (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n+\t\t      cp_error_at (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n \t\t      cp_error_at (\"  overriding definition as `%#D'\", tmp);\n \t\t      SET_IDENTIFIER_ERROR_LOCUS (name, basetype);\n \t\t    }"}, {"sha": "5a3d2fb672409ea476113823cc4f9ddaf629cceb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffa87298012df49b1a3bafa4d9d7a66c155378d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cffa87298012df49b1a3bafa4d9d7a66c155378d", "patch": "@@ -643,13 +643,15 @@ comptypes (type1, type2, strict)\n   if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return 1;\n \n-#ifdef COMP_TYPE_ATTRIBUTES\n+  /* ??? COMP_TYPE_ATTRIBUTES is currently useless for variables as each\n+     attribute is its own main variant (`val' will remain 0).  */\n+#ifndef COMP_TYPE_ATTRIBUTES\n+#define COMP_TYPE_ATTRIBUTES(t1,t2)\t1\n+#endif\n+\n+  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n   if (! (attrval = COMP_TYPE_ATTRIBUTES (t1, t2)))\n      return 0;\n-#else\n-  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-  attrval = 1;\n-#endif\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n   val = 0;\n@@ -1110,10 +1112,10 @@ self_promoting_args_p (parms)\n       if (TREE_CHAIN (t) == 0 && type != void_type_node)\n \treturn 0;\n \n-      if (TYPE_MAIN_VARIANT (type) == float_type_node)\n+      if (type == 0)\n \treturn 0;\n \n-      if (type == 0)\n+      if (TYPE_MAIN_VARIANT (type) == float_type_node)\n \treturn 0;\n \n       if (C_PROMOTING_INTEGER_TYPE_P (type))\n@@ -1141,6 +1143,14 @@ unsigned_type (type)\n     return long_unsigned_type_node;\n   if (type1 == long_long_integer_type_node)\n     return long_long_unsigned_type_node;\n+  if (type1 == intDI_type_node)\n+    return unsigned_intDI_type_node;\n+  if (type1 == intSI_type_node)\n+    return unsigned_intSI_type_node;\n+  if (type1 == intHI_type_node)\n+    return unsigned_intHI_type_node;\n+  if (type1 == intQI_type_node)\n+    return unsigned_intQI_type_node;\n   return type;\n }\n \n@@ -1161,6 +1171,14 @@ signed_type (type)\n     return long_integer_type_node;\n   if (type1 == long_long_unsigned_type_node)\n     return long_long_integer_type_node;\n+  if (type1 == unsigned_intDI_type_node)\n+    return intDI_type_node;\n+  if (type1 == unsigned_intSI_type_node)\n+    return intSI_type_node;\n+  if (type1 == unsigned_intHI_type_node)\n+    return intHI_type_node;\n+  if (type1 == unsigned_intQI_type_node)\n+    return intQI_type_node;\n   return type;\n }\n \n@@ -1188,6 +1206,8 @@ signed_or_unsigned_type (unsignedp, type)\n   return type;\n }\n \n+/* Compute the value of the `sizeof' operator.  */\n+\n tree\n c_sizeof (type)\n      tree type;\n@@ -4251,6 +4271,7 @@ build_unary_op (code, xarg, noconvert)\n   return error_mark_node;\n }\n \n+#if 0\n /* If CONVERSIONS is a conversion expression or a nested sequence of such,\n    convert ARG with the same conversions in the same order\n    and return the result.  */\n@@ -4277,6 +4298,7 @@ convert_sequence (conversions, arg)\n       return arg;\n     }\n }\n+#endif\n \n /* Apply unary lvalue-demanding operator CODE to the expression ARG\n    for certain kinds of expressions which are not really lvalues\n@@ -4444,10 +4466,9 @@ mark_addressable (exp)\n \t    return 1;\n \t  }\n       case VAR_DECL:\n-\tif (TREE_STATIC (x)\n-\t    && TREE_READONLY (x)\n+\tif (TREE_STATIC (x) && TREE_READONLY (x)\n \t    && DECL_RTL (x) != 0\n-\t    && ! decl_in_memory_p (x))\n+\t    && ! DECL_IN_MEMORY_P (x))\n \t  {\n \t    /* We thought this would make a good constant variable,\n \t       but we were wrong.  */"}]}