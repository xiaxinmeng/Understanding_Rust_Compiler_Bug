{"sha": "6b828f69519a50e6e2961b62ea552bf89d287199", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4MjhmNjk1MTlhNTBlNmUyOTYxYjYyZWE1NTJiZjg5ZDI4NzE5OQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2019-12-19T21:15:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-24T01:25:51Z"}, "message": "analyzer: add testcases for PR 93355 (intl/localealias.c leak)\n\nPR analyzer/93355 reports a missing diagnostic about a FILE leak in\nintl/localealias.c.  This appears to be due to a issue in the\nfeasibility-checking code, though there is also a state explosion.\n\nThis patch adds test cases that I've been using when investigating this,\ntwo of them currently requiring -fno-analyzer-feasibility, and one\ncurrently requiring -Wno-analyzer-too-complex.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/93355\n\t* gcc.dg/analyzer/pr93355-localealias-feasibility.c: New test.\n\t* gcc.dg/analyzer/pr93355-localealias-simplified.c: New test.\n\t* gcc.dg/analyzer/pr93355-localealias.c: New test.", "tree": {"sha": "872976c733f31ad9c2e9790ddf21a5eeb9ae3fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/872976c733f31ad9c2e9790ddf21a5eeb9ae3fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b828f69519a50e6e2961b62ea552bf89d287199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b828f69519a50e6e2961b62ea552bf89d287199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b828f69519a50e6e2961b62ea552bf89d287199", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b828f69519a50e6e2961b62ea552bf89d287199/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84fb35466654ec179fa16e718a5014fbe9f41357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fb35466654ec179fa16e718a5014fbe9f41357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fb35466654ec179fa16e718a5014fbe9f41357"}], "stats": {"total": 514, "additions": 514, "deletions": 0}, "files": [{"sha": "0d470d6602b4cea1bc7ec71cc78dabbe8b3c1e15", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias-feasibility.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b828f69519a50e6e2961b62ea552bf89d287199/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b828f69519a50e6e2961b62ea552bf89d287199/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c?ref=6b828f69519a50e6e2961b62ea552bf89d287199", "patch": "@@ -0,0 +1,79 @@\n+/* Simplified version of test to ensure we issue a FILE * leak diagnostic,\n+   reproducing a feasibility issue.\n+   Adapted from intl/localealias.c, with all #includes removed.  */\n+\n+/* { dg-do \"compile\" } */\n+/* { dg-additional-options \"-fno-analyzer-feasibility\" } */\n+/* TODO: remove the need for this option.  */\n+\n+/* Handle aliases for locale names.\n+   Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Library General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,\n+   USA.  */\n+\n+/* Minimal version of system headers.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *)0)\n+\n+typedef struct _IO_FILE FILE;\n+extern FILE *fopen (const char *__restrict __filename,\n+\t\t    const char *__restrict __modes);\n+extern int fclose (FILE *__stream);\n+\n+extern int isspace (int) __attribute__((__nothrow__, __leaf__));\n+\n+/* Cleaned-up body of localealias.c follows.  */\n+\n+size_t\n+read_alias_file (const char *fname, int fname_len)\n+{\n+  FILE *fp;\n+  size_t added;\n+  char buf[400];\n+  char *alias;\n+  char *value;\n+  char *cp;\n+\n+  fp = fopen (fname, \"r\"); /* { dg-message \"opened here\" } */\n+  if (fp == NULL)\n+    return 0;\n+\n+  cp = buf;\n+\n+  /* Ignore leading white space.  */\n+  while (isspace ((unsigned char)cp[0]))\n+    ++cp;\n+\n+  if (cp[0] != '\\0' && cp[0] != '#')\n+    {\n+      alias = cp++;\n+      while (cp[0] != '\\0' && !isspace ((unsigned char)cp[0]))\n+\t++cp;\n+      if (cp[0] != '\\0')\n+\t*cp++ = '\\0';\n+\n+      while (isspace ((unsigned char)cp[0]))\n+\t++cp;\n+\n+      if (cp[0] != '\\0')\n+\treturn 42; /* { dg-warning \"leak of FILE 'fp'\" } */\n+    }\n+\n+  fclose(fp);\n+\n+  return 0;\n+}"}, {"sha": "6f65add346b88f81c8c896571084a683ccc592b8", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias-simplified.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b828f69519a50e6e2961b62ea552bf89d287199/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-simplified.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b828f69519a50e6e2961b62ea552bf89d287199/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-simplified.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-simplified.c?ref=6b828f69519a50e6e2961b62ea552bf89d287199", "patch": "@@ -0,0 +1,45 @@\n+/* Simplified version of test for ensuring we issue a FILE * leak diagnostic,\n+   made trivial.\n+   Adapted from intl/localealias.c, with all #includes removed.  */\n+\n+/* { dg-do \"compile\" } */\n+\n+/* Handle aliases for locale names.\n+   Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Library General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,\n+   USA.  */\n+\n+/* Minimal version of system headers.  */\n+#define NULL ((void *) 0)\n+typedef struct _IO_FILE FILE;\n+extern FILE *fopen(const char *__restrict __filename,\n+\t\t   const char *__restrict __modes);\n+extern int fclose(FILE *__stream);\n+\n+void\n+read_alias_file (int flag)\n+{\n+  FILE *fp;\n+\n+  fp = fopen (\"name\", \"r\"); /* { dg-message \"opened here\" } */\n+  if (fp == NULL)\n+    return;\n+\n+  if (flag)\n+    return; /* { dg-warning \"leak of FILE 'fp'\" } */\n+\n+  fclose (fp);\n+}"}, {"sha": "a5cb0d56e70dc296a070a91d6e45664173c1c686", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias.c", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b828f69519a50e6e2961b62ea552bf89d287199/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b828f69519a50e6e2961b62ea552bf89d287199/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias.c?ref=6b828f69519a50e6e2961b62ea552bf89d287199", "patch": "@@ -0,0 +1,390 @@\n+/* Integration test to ensure we issue a FILE * leak diagnostic for\n+   this particular non-trivial case.\n+   Adapted from intl/localealias.c, with all #includes removed.  */\n+\n+/* { dg-do \"compile\" } */\n+/* { dg-additional-options \"-Wno-analyzer-too-complex -fno-analyzer-feasibility\" } */\n+/* TODO: remove the need for these options.  */\n+\n+/* Handle aliases for locale names.\n+   Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Library General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,\n+   USA.  */\n+\n+/* Minimal version of system headers.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *) 0)\n+\n+#define PATH_SEPARATOR ':'\n+typedef struct _IO_FILE FILE;\n+extern FILE *fopen(const char *__restrict __filename,\n+\t\t   const char *__restrict __modes);\n+extern int feof_unlocked(FILE *__stream) __attribute__((__nothrow__, __leaf__));\n+extern char *fgets_unlocked(char *__restrict __s, int __n,\n+\t\t\t    FILE *__restrict __stream);\n+extern int fclose(FILE *__stream);\n+\n+#define alloca __builtin_alloca\n+\n+extern char *strchr(const char *__s, int __c)\n+    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))\n+    __attribute__((__nonnull__(1)));\n+extern void *memcpy(void *__restrict __dest, const void *__restrict __src,\n+\t\t    size_t __n) __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__nonnull__(1, 2)));\n+extern void *mempcpy(void *__restrict __dest, const void *__restrict __src,\n+\t\t     size_t __n) __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__nonnull__(1, 2)));\n+#define HAVE_MEMPCPY 1\n+extern size_t strlen(const char *__s) __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__pure__)) __attribute__((__nonnull__(1)));\n+\n+extern int strcasecmp(const char *__s1, const char *__s2)\n+    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))\n+    __attribute__((__nonnull__(1, 2)));\n+\n+extern int isspace(int) __attribute__((__nothrow__, __leaf__));\n+\n+extern void *realloc(void *__ptr, size_t __size)\n+    __attribute__((__nothrow__, __leaf__))\n+    __attribute__((__warn_unused_result__));\n+\n+typedef int (*__compar_fn_t)(const void *, const void *);\n+extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,\n+\t\t     size_t __size, __compar_fn_t __compar)\n+    __attribute__((__nonnull__(1, 2, 5)));\n+\n+extern __inline __attribute__((__gnu_inline__)) void *\n+bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size,\n+\t__compar_fn_t __compar) {\n+  size_t __l, __u, __idx;\n+  const void *__p;\n+  int __comparison;\n+\n+  __l = 0;\n+  __u = __nmemb;\n+  while (__l < __u) {\n+    __idx = (__l + __u) / 2;\n+    __p = (void *)(((const char *)__base) + (__idx * __size));\n+    __comparison = (*__compar)(__key, __p);\n+    if (__comparison < 0)\n+      __u = __idx;\n+    else if (__comparison > 0)\n+      __l = __idx + 1;\n+    else\n+      return (void *)__p;\n+  }\n+\n+  return ((void *)0);\n+}\n+\n+extern void qsort(void *__base, size_t __nmemb, size_t __size,\n+\t\t  __compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));\n+\n+/* Minimal version of intl headers.  */\n+\n+#define PARAMS(args) args\n+\n+#define relocate libintl_relocate\n+extern const char *libintl_relocate(const char *pathname);\n+\n+#define LOCALE_ALIAS_PATH \"value for LOCALE_ALIAS_PATH\"\n+\n+/* Cleaned-up body of localealias.c follows.  */\n+\n+#ifndef internal_function\n+# define internal_function\n+#endif\n+\n+/* Some optimizations for glibc.  */\n+# define FEOF(fp)\t\tfeof_unlocked (fp)\n+# define FGETS(buf, n, fp)\tfgets_unlocked (buf, n, fp)\n+\n+/* For those losing systems which don't have `alloca' we have to add\n+   some additional code emulating it.  */\n+# define freea(p) /* nothing */\n+\n+struct alias_map\n+{\n+  const char *alias;\n+  const char *value;\n+};\n+\n+# define libc_freeres_ptr(decl) decl\n+\n+libc_freeres_ptr (static char *string_space);\n+static size_t string_space_act;\n+static size_t string_space_max;\n+libc_freeres_ptr (static struct alias_map *map);\n+static size_t nmap;\n+static size_t maxmap;\n+\n+\n+/* Prototypes for local functions.  */\n+static size_t read_alias_file PARAMS ((const char *fname, int fname_len))\n+     internal_function;\n+static int extend_alias_table PARAMS ((void));\n+static int alias_compare PARAMS ((const struct alias_map *map1,\n+\t\t\t\t  const struct alias_map *map2));\n+\n+\n+const char *\n+_nl_expand_alias (name)\n+    const char *name;\n+{\n+  static const char *locale_alias_path;\n+  struct alias_map *retval;\n+  const char *result = NULL;\n+  size_t added;\n+\n+#ifdef _LIBC\n+  __libc_lock_lock (lock);\n+#endif\n+\n+  if (locale_alias_path == NULL)\n+    locale_alias_path = LOCALE_ALIAS_PATH;\n+\n+  do\n+    {\n+      struct alias_map item;\n+\n+      item.alias = name;\n+\n+      if (nmap > 0)\n+\tretval = (struct alias_map *) bsearch (&item, map, nmap,\n+\t\t\t\t\t       sizeof (struct alias_map),\n+\t\t\t\t\t       (int (*) PARAMS ((const void *,\n+\t\t\t\t\t\t\t\t const void *))\n+\t\t\t\t\t\t) alias_compare);\n+      else\n+\tretval = NULL;\n+\n+      /* We really found an alias.  Return the value.  */\n+      if (retval != NULL)\n+\t{\n+\t  result = retval->value;\n+\t  break;\n+\t}\n+\n+      /* Perhaps we can find another alias file.  */\n+      added = 0;\n+      while (added == 0 && locale_alias_path[0] != '\\0')\n+\t{\n+\t  const char *start;\n+\n+\t  while (locale_alias_path[0] == PATH_SEPARATOR)\n+\t    ++locale_alias_path;\n+\t  start = locale_alias_path;\n+\n+\t  while (locale_alias_path[0] != '\\0'\n+\t\t && locale_alias_path[0] != PATH_SEPARATOR)\n+\t    ++locale_alias_path;\n+\n+\t  if (start < locale_alias_path)\n+\t    added = read_alias_file (start, locale_alias_path - start);\n+\t}\n+    }\n+  while (added != 0);\n+\n+#ifdef _LIBC\n+  __libc_lock_unlock (lock);\n+#endif\n+\n+  return result;\n+}\n+\n+\n+static size_t\n+internal_function\n+read_alias_file (fname, fname_len)\n+     const char *fname;\n+     int fname_len;\n+{\n+  FILE *fp;\n+  char *full_fname;\n+  size_t added;\n+  static const char aliasfile[] = \"/locale.alias\";\n+\n+  full_fname = (char *) alloca (fname_len + sizeof aliasfile);\n+#ifdef HAVE_MEMPCPY\n+  mempcpy (mempcpy (full_fname, fname, fname_len),\n+\t   aliasfile, sizeof aliasfile);\n+#else\n+  memcpy (full_fname, fname, fname_len);\n+  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);\n+#endif\n+\n+  fp = fopen (relocate (full_fname), \"r\"); /* { dg-message \"opened here\" } */\n+  freea (full_fname);\n+  if (fp == NULL)\n+    return 0;\n+\n+#ifdef HAVE___FSETLOCKING\n+  /* No threads present.  */\n+  __fsetlocking (fp, FSETLOCKING_BYCALLER);\n+#endif\n+\n+  added = 0;\n+  while (!FEOF (fp))\n+    {\n+      /* It is a reasonable approach to use a fix buffer here because\n+\t a) we are only interested in the first two fields\n+\t b) these fields must be usable as file names and so must not\n+\t    be that long\n+\t We avoid a multi-kilobyte buffer here since this would use up\n+\t stack space which we might not have if the program ran out of\n+\t memory.  */\n+      char buf[400];\n+      char *alias;\n+      char *value;\n+      char *cp;\n+\n+      if (FGETS (buf, sizeof buf, fp) == NULL)\n+\t/* EOF reached.  */\n+\tbreak;\n+\n+      cp = buf;\n+      /* Ignore leading white space.  */\n+      while (isspace ((unsigned char) cp[0]))\n+\t++cp;\n+\n+      /* A leading '#' signals a comment line.  */\n+      if (cp[0] != '\\0' && cp[0] != '#')\n+\t{\n+\t  alias = cp++;\n+\t  while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n+\t    ++cp;\n+\t  /* Terminate alias name.  */\n+\t  if (cp[0] != '\\0')\n+\t    *cp++ = '\\0';\n+\n+\t  /* Now look for the beginning of the value.  */\n+\t  while (isspace ((unsigned char) cp[0]))\n+\t    ++cp;\n+\n+\t  if (cp[0] != '\\0')\n+\t    {\n+\t      size_t alias_len;\n+\t      size_t value_len;\n+\n+\t      value = cp++;\n+\t      while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n+\t\t++cp;\n+\t      /* Terminate value.  */\n+\t      if (cp[0] == '\\n')\n+\t\t{\n+\t\t  /* This has to be done to make the following test\n+\t\t     for the end of line possible.  We are looking for\n+\t\t     the terminating '\\n' which do not overwrite here.  */\n+\t\t  *cp++ = '\\0';\n+\t\t  *cp = '\\n';\n+\t\t}\n+\t      else if (cp[0] != '\\0')\n+\t\t*cp++ = '\\0';\n+\n+\t      if (nmap >= maxmap)\n+\t\tif (__builtin_expect (extend_alias_table (), 0))\n+\t\t  return added; /* { dg-warning \"leak of FILE 'fp'\" } */\n+\n+\t      alias_len = strlen (alias) + 1;\n+\t      value_len = strlen (value) + 1;\n+\n+\t      if (string_space_act + alias_len + value_len > string_space_max)\n+\t\t{\n+\t\t  /* Increase size of memory pool.  */\n+\t\t  size_t new_size = (string_space_max\n+\t\t\t\t     + (alias_len + value_len > 1024\n+\t\t\t\t\t? alias_len + value_len : 1024));\n+\t\t  char *new_pool = (char *) realloc (string_space, new_size);\n+\t\t  if (new_pool == NULL)\n+\t\t    return added;\n+\n+\t\t  if (__builtin_expect (string_space != new_pool, 0))\n+\t\t    {\n+\t\t      size_t i;\n+\n+\t\t      for (i = 0; i < nmap; i++)\n+\t\t\t{\n+\t\t\t  map[i].alias += new_pool - string_space;\n+\t\t\t  map[i].value += new_pool - string_space;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  string_space = new_pool;\n+\t\t  string_space_max = new_size;\n+\t\t}\n+\n+\t      map[nmap].alias = memcpy (&string_space[string_space_act],\n+\t\t\t\t\talias, alias_len);\n+\t      string_space_act += alias_len;\n+\n+\t      map[nmap].value = memcpy (&string_space[string_space_act],\n+\t\t\t\t\tvalue, value_len);\n+\t      string_space_act += value_len;\n+\n+\t      ++nmap;\n+\t      ++added;\n+\t    }\n+\t}\n+\n+      /* Possibly not the whole line fits into the buffer.  Ignore\n+\t the rest of the line.  */\n+      while (strchr (buf, '\\n') == NULL)\n+\tif (FGETS (buf, sizeof buf, fp) == NULL)\n+\t  /* Make sure the inner loop will be left.  The outer loop\n+\t     will exit at the `feof' test.  */\n+\t  break;\n+    }\n+\n+  /* Should we test for ferror()?  I think we have to silently ignore\n+     errors.  --drepper  */\n+  fclose (fp);\n+\n+  if (added > 0)\n+    qsort (map, nmap, sizeof (struct alias_map),\n+\t   (int (*) PARAMS ((const void *, const void *))) alias_compare);\n+\n+  return added;\n+}\n+\n+\n+static int\n+extend_alias_table ()\n+{\n+  size_t new_size;\n+  struct alias_map *new_map;\n+\n+  new_size = maxmap == 0 ? 100 : 2 * maxmap;\n+  new_map = (struct alias_map *) realloc (map, (new_size\n+\t\t\t\t\t\t* sizeof (struct alias_map)));\n+  if (new_map == NULL)\n+    /* Simply don't extend: we don't have any more core.  */\n+    return -1;\n+\n+  map = new_map;\n+  maxmap = new_size;\n+  return 0;\n+}\n+\n+\n+static int\n+alias_compare (map1, map2)\n+     const struct alias_map *map1;\n+     const struct alias_map *map2;\n+{\n+  return strcasecmp (map1->alias, map2->alias);\n+}"}]}