{"sha": "c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM2ZmNlOWE0MjgzZjcxYjk2MTNlMTkyM2ZiYjZjZWEyYzBkNjRhMg==", "commit": {"author": {"name": "Gavin Romig-Koch", "email": "gavin@cygnus.com", "date": "1998-10-01T13:00:21Z"}, "committer": {"name": "Gavin Romig-Koch", "email": "gavin@gcc.gnu.org", "date": "1998-10-01T13:00:21Z"}, "message": "calls.c (expand_call): Encapsulate code into copy_blkmode_from_reg.\n\n\t* calls.c (expand_call) : Encapsulate code into\n\tcopy_blkmode_from_reg.\n\t* expr.c (copy_blkmode_from_reg): New function.\n\t* expr.h (copy_blkmode_from_reg): New function.\n\t* integrate.c (function_cannot_inline_p): We can inline\n\tthese now.\n\t(expand_inline_function): Use copy_blkmode_from_reg\n\tif needed.  Avoid creating BLKmode REGs.\n\t(copy_rtx_and_substitute): Don't try to SUBREG a BLKmode\n\tobject.\n\nFrom-SVN: r22714", "tree": {"sha": "9b145af594c102bee9b10b504ce7129d9016e08b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b145af594c102bee9b10b504ce7129d9016e08b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/comments", "author": null, "committer": null, "parents": [{"sha": "38f01e5a57f979f7427e99be377b4717a330cf7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f01e5a57f979f7427e99be377b4717a330cf7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f01e5a57f979f7427e99be377b4717a330cf7a"}], "stats": {"total": 202, "additions": 126, "deletions": 76}, "files": [{"sha": "f4e7eab7e38951573106ee99f95b48223e6b4c5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "patch": "@@ -1,3 +1,16 @@\n+Thu Oct  1 15:56:01 1998  Gavin Romig-Koch  <gavin@cygnus.com>\n+\n+\t* calls.c (expand_call) : Encapsulate code into \n+\tcopy_blkmode_from_reg.\n+\t* expr.c (copy_blkmode_from_reg): New function.\n+\t* expr.h (copy_blkmode_from_reg): New function.\n+\t* integrate.c (function_cannot_inline_p): We can inline\n+\tthese now.\n+\t(expand_inline_function): Use copy_blkmode_from_reg\n+\tif needed.  Avoid creating BLKmode REGs.\n+\t(copy_rtx_and_substitute): Don't try to SUBREG a BLKmode\n+\tobject.\n+\n Thu Oct  1 10:42:27 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* c-pragma.c: Add support for HANDLE_PRAGMA_PACK and"}, {"sha": "2bddc2a32a1d74f18774ca92a39a480c7773bb0d", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "patch": "@@ -2105,75 +2105,7 @@ expand_call (exp, target, ignore)\n        when function inlining is being done.  */\n     emit_move_insn (target, valreg);\n   else if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n-    {\n-      /* Some machines (the PA for example) want to return all small\n-\t structures in registers regardless of the structure's alignment.\n-\t \n-\t Deal with them explicitly by copying from the return registers\n-\t into the target MEM locations.  */\n-      int bytes = int_size_in_bytes (TREE_TYPE (exp));\n-      rtx src = NULL, dst = NULL;\n-      int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (exp)), BITS_PER_WORD);\n-      int bitpos, xbitpos, big_endian_correction = 0;\n-      \n-      if (target == 0)\n-\t{\n-\t  target = assign_stack_temp (BLKmode, bytes, 0);\n-\t  MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n-\t  preserve_temp_slots (target);\n-\t}\n-\n-      /* This code assumes valreg is at least a full word.  If it isn't,\n-\t copy it into a new pseudo which is a full word.  */\n-      if (GET_MODE (valreg) != BLKmode\n-\t  && GET_MODE_SIZE (GET_MODE (valreg)) < UNITS_PER_WORD)\n-\tvalreg = convert_to_mode (word_mode, valreg,\n-\t\t\t\t  TREE_UNSIGNED (TREE_TYPE (exp)));\n-\n-      /* Structures whose size is not a multiple of a word are aligned\n-\t to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n-\t machine, this means we must skip the empty high order bytes when\n-\t calculating the bit offset.  */\n-      if (BYTES_BIG_ENDIAN && bytes % UNITS_PER_WORD)\n-\tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n-\t\t\t\t\t\t  * BITS_PER_UNIT));\n-\n-      /* Copy the structure BITSIZE bites at a time.\n-\n-\t We could probably emit more efficient code for machines\n-\t which do not use strict alignment, but it doesn't seem\n-\t worth the effort at the current time.  */\n-      for (bitpos = 0, xbitpos = big_endian_correction;\n-\t   bitpos < bytes * BITS_PER_UNIT;\n-\t   bitpos += bitsize, xbitpos += bitsize)\n-\t{\n-\n-\t  /* We need a new source operand each time xbitpos is on a \n-\t     word boundary and when xbitpos == big_endian_correction\n-\t     (the first time through).  */\n-\t  if (xbitpos % BITS_PER_WORD == 0\n-\t      || xbitpos == big_endian_correction)\n-\t    src = operand_subword_force (valreg,\n-\t\t\t\t\t xbitpos / BITS_PER_WORD, \n-\t\t\t\t\t BLKmode);\n-\n-\t  /* We need a new destination operand each time bitpos is on\n-\t     a word boundary.  */\n-\t  if (bitpos % BITS_PER_WORD == 0)\n-\t    dst = operand_subword (target, bitpos / BITS_PER_WORD, 1, BLKmode);\n-\t      \n-\t  /* Use xbitpos for the source extraction (right justified) and\n-\t     xbitpos for the destination store (left justified).  */\n-\t  store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, word_mode,\n-\t\t\t   extract_bit_field (src, bitsize,\n-\t\t\t\t\t      xbitpos % BITS_PER_WORD, 1,\n-\t\t\t\t\t      NULL_RTX, word_mode,\n-\t\t\t\t\t      word_mode,\n-\t\t\t\t\t      bitsize / BITS_PER_UNIT,\n-\t\t\t\t\t      BITS_PER_WORD),\n-\t\t\t   bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n-\t}\n-    }\n+    target = copy_blkmode_from_reg (target, valreg, TREE_TYPE (exp));\n   else\n     target = copy_to_reg (valreg);\n "}, {"sha": "445f151615680486baa1402b460fc4690493ae01", "filename": "gcc/expr.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "patch": "@@ -2064,6 +2064,88 @@ emit_group_store (orig_dst, src, ssize, align)\n     emit_move_insn (orig_dst, dst);\n }\n \n+/* Generate code to copy a BLKmode object of TYPE out of a\n+   set of registers starting with SRCREG into TGTBLK.  If TGTBLK\n+   is null, a stack temporary is created.  TGTBLK is returned.\n+\n+   The primary purpose of this routine is to handle functions\n+   that return BLKmode structures in registers.  Some machines\n+   (the PA for example) want to return all small structures\n+   in registers regardless of the structure's alignment.\n+  */\n+\n+rtx\n+copy_blkmode_from_reg(tgtblk,srcreg,type)\n+     rtx tgtblk;\n+     rtx srcreg;\n+     tree type;\n+{\n+      int bytes = int_size_in_bytes (type);\n+      rtx src = NULL, dst = NULL;\n+      int bitsize = MIN (TYPE_ALIGN (type), BITS_PER_WORD);\n+      int bitpos, xbitpos, big_endian_correction = 0;\n+      \n+      if (tgtblk == 0)\n+\t{\n+\t  tgtblk = assign_stack_temp (BLKmode, bytes, 0);\n+\t  MEM_IN_STRUCT_P (tgtblk) = AGGREGATE_TYPE_P (type);\n+\t  preserve_temp_slots (tgtblk);\n+\t}\n+      \n+      /* This code assumes srcreg is at least a full word.  If it isn't,\n+\t copy it into a new pseudo which is a full word.  */\n+      if (GET_MODE (srcreg) != BLKmode\n+\t  && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n+\tsrcreg = convert_to_mode (word_mode, srcreg,\n+\t\t\t\t  TREE_UNSIGNED (type));\n+\n+      /* Structures whose size is not a multiple of a word are aligned\n+\t to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n+\t machine, this means we must skip the empty high order bytes when\n+\t calculating the bit offset.  */\n+      if (BYTES_BIG_ENDIAN && bytes % UNITS_PER_WORD)\n+\tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n+\t\t\t\t\t\t  * BITS_PER_UNIT));\n+\n+      /* Copy the structure BITSIZE bites at a time.\n+\n+\t We could probably emit more efficient code for machines\n+\t which do not use strict alignment, but it doesn't seem\n+\t worth the effort at the current time.  */\n+      for (bitpos = 0, xbitpos = big_endian_correction;\n+\t   bitpos < bytes * BITS_PER_UNIT;\n+\t   bitpos += bitsize, xbitpos += bitsize)\n+\t{\n+\n+\t  /* We need a new source operand each time xbitpos is on a \n+\t     word boundary and when xbitpos == big_endian_correction\n+\t     (the first time through).  */\n+\t  if (xbitpos % BITS_PER_WORD == 0\n+\t      || xbitpos == big_endian_correction)\n+\t    src = operand_subword_force (srcreg,\n+\t\t\t\t\t xbitpos / BITS_PER_WORD, \n+\t\t\t\t\t BLKmode);\n+\n+\t  /* We need a new destination operand each time bitpos is on\n+\t     a word boundary.  */\n+\t  if (bitpos % BITS_PER_WORD == 0)\n+\t    dst = operand_subword (tgtblk, bitpos / BITS_PER_WORD, 1, BLKmode);\n+\t      \n+\t  /* Use xbitpos for the source extraction (right justified) and\n+\t     xbitpos for the destination store (left justified).  */\n+\t  store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, word_mode,\n+\t\t\t   extract_bit_field (src, bitsize,\n+\t\t\t\t\t      xbitpos % BITS_PER_WORD, 1,\n+\t\t\t\t\t      NULL_RTX, word_mode,\n+\t\t\t\t\t      word_mode,\n+\t\t\t\t\t      bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t      BITS_PER_WORD),\n+\t\t\t   bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n+\t}\n+      return tgtblk;\n+}\n+\n+\n /* Add a USE expression for REG to the (possibly empty) list pointed\n    to by CALL_FUSAGE.  REG must denote a hard register.  */\n "}, {"sha": "353e6fdfe46071ec983e4e230e9e0d0e3c11433e", "filename": "gcc/expr.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "patch": "@@ -732,6 +732,11 @@ extern void emit_group_load PROTO((rtx, rtx, int, int));\n    PARALLEL.  */\n extern void emit_group_store PROTO((rtx, rtx, int, int));\n \n+#ifdef TREE_CODE\n+/* Copy BLKmode object from a set of registers. */\n+extern rtx copy_blkmode_from_reg PROTO((rtx,rtx,tree));\n+#endif\n+\n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n extern void use_reg PROTO((rtx *, rtx));\n /* Mark NREGS consecutive regs, starting at REGNO, as holding parameters"}, {"sha": "db82e322b064af339d30805c37bad3cf152a244f", "filename": "gcc/integrate.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c36fce9a4283f71b9613e1923fbb6cea2c0d64a2/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c36fce9a4283f71b9613e1923fbb6cea2c0d64a2", "patch": "@@ -154,11 +154,6 @@ function_cannot_inline_p (fndecl)\n   if (current_function_returns_pcc_struct)\n     return \"inline functions not supported for this return value type\";\n \n-  /* We can't inline functions that return BLKmode structures in registers.  */\n-  if (TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))) == BLKmode\n-      && ! aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl))))\n-    return \"inline functions not supported for this return value type\";\n-\n   /* We can't inline functions that return structures of varying size.  */\n   if (int_size_in_bytes (TREE_TYPE (TREE_TYPE (fndecl))) < 0)\n     return \"function with varying-size return value cannot be inline\";\n@@ -1804,7 +1799,23 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t Let the combiner substitute the MEM if that is valid.  */\n       if (target == 0 || GET_CODE (target) != REG\n \t  || GET_MODE (target) != departing_mode)\n+\t{\n+\t  /* Don't make BLKmode registers.  If this looks like\n+\t     a BLKmode object being returned in a register, get\n+\t     the mode from that, otherwise abort. */\n+\t  if (departing_mode == BLKmode)\n+\t    {\n+\t      if (REG == GET_CODE (DECL_RTL (DECL_RESULT (fndecl))))\n+\t\t{\n+\t\t  departing_mode = GET_MODE (DECL_RTL (DECL_RESULT (fndecl)));\n+\t\t  arriving_mode = departing_mode;\n+\t\t}\n+\t      else\n+\t\tabort();\n+\t    }\n+\t      \n \ttarget = gen_reg_rtx (departing_mode);\n+\t}\n \n       /* If function's value was promoted before return,\n \t avoid machine mode mismatch when we substitute INLINE_TARGET.\n@@ -2164,6 +2175,12 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   emit_line_note (input_filename, lineno);\n \n+  /* If the function returns a BLKmode object in a register, copy it\n+     out of the temp register into a BLKmode memory object. */\n+  if (TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))) == BLKmode\n+      && ! aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl))))\n+    target = copy_blkmode_from_reg (0, target, TREE_TYPE (TREE_TYPE (fndecl)));\n+  \n   if (structure_value_addr)\n     {\n       target = gen_rtx_MEM (TYPE_MODE (type),\n@@ -2428,12 +2445,13 @@ copy_rtx_and_substitute (orig, map)\n \t    {\n \t      /* This is a reference to the function return value.  If\n \t\t the function doesn't have a return value, error.  If the\n-\t\t mode doesn't agree, make a SUBREG.  */\n+\t\t mode doesn't agree, and it ain't BLKmode, make a SUBREG.  */\n \t      if (map->inline_target == 0)\n \t\t/* Must be unrolling loops or replicating code if we\n \t\t   reach here, so return the register unchanged.  */\n \t\treturn orig;\n-\t      else if (mode != GET_MODE (map->inline_target))\n+\t      else if (GET_MODE (map->inline_target) != BLKmode\n+\t\t       && mode != GET_MODE (map->inline_target))\n \t\treturn gen_lowpart (mode, map->inline_target);\n \t      else\n \t\treturn map->inline_target;"}]}