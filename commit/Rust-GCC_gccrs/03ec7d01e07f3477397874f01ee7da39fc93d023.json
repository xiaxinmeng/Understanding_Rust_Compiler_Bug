{"sha": "03ec7d01e07f3477397874f01ee7da39fc93d023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNlYzdkMDFlMDdmMzQ3NzM5Nzg3NGYwMWVlN2RhMzlmYzkzZDAyMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-10-01T23:20:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-10-01T23:20:15Z"}, "message": "cgraph.c (cgraph_clone_node): Add redirect_callers parameter.\n\n\n\t* cgraph.c (cgraph_clone_node): Add redirect_callers parameter.\n\t(cgraph_create_virtual_clone): Just pass redirect_callers\n\taround.\n\t* cgraph.h (cgraph_clone_node): Update prototype.\n\t* ipa-pure-const.c (self_recursive_p): New function.\n\t(propagate): Use it.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes,\n\t* cgraph_decide_recursive_inlining): Update.\n\t* gcc.dg/tree-ssa/ipa-cp-1.c: New testcase.\n\nFrom-SVN: r152388", "tree": {"sha": "851bbe5f7a341f0badf18bf5a177dfbf5e290e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/851bbe5f7a341f0badf18bf5a177dfbf5e290e5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03ec7d01e07f3477397874f01ee7da39fc93d023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ec7d01e07f3477397874f01ee7da39fc93d023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03ec7d01e07f3477397874f01ee7da39fc93d023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ec7d01e07f3477397874f01ee7da39fc93d023/comments", "author": null, "committer": null, "parents": [{"sha": "0ecdd2aae98b931eb50dff3c8013a1b7adcfaa95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecdd2aae98b931eb50dff3c8013a1b7adcfaa95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecdd2aae98b931eb50dff3c8013a1b7adcfaa95"}], "stats": {"total": 103, "additions": 89, "deletions": 14}, "files": [{"sha": "aebdbffcdb96494702f986b85d45bac9b0b586da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -1,3 +1,14 @@\n+2009-10-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_clone_node): Add redirect_callers parameter.\n+\t(cgraph_create_virtual_clone): Just pass redirect_callers\n+\taround.\n+\t* cgraph.h (cgraph_clone_node): Update prototype.\n+\t* ipa-pure-const.c (self_recursive_p): New function.\n+\t(propagate): Use it.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes,\n+\tcgraph_decide_recursive_inlining): Update.\n+\n 2009-10-01  David Daney  <ddaney@caviumnetworks.com>\n \n \t* gcc/config/mips/mips.c (mips_process_sync_loop) Emit syncw"}, {"sha": "15dd60a7ee4f195b751425e14c988674e794c643", "filename": "gcc/cgraph.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -1656,11 +1656,13 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n    by node.  */\n struct cgraph_node *\n cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n-\t\t   int loop_nest, bool update_original)\n+\t\t   int loop_nest, bool update_original,\n+\t\t   VEC(cgraph_edge_p,heap) *redirect_callers)\n {\n   struct cgraph_node *new_node = cgraph_create_node ();\n   struct cgraph_edge *e;\n   gcov_type count_scale;\n+  unsigned i;\n \n   new_node->decl = n->decl;\n   new_node->origin = n->origin;\n@@ -1691,6 +1693,14 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n \tn->count = 0;\n     }\n \n+  for (i = 0; VEC_iterate (cgraph_edge_p, redirect_callers, i, e); i++)\n+    {\n+      /* Redirect calls to the old version node to point to its new\n+\t version.  */\n+      cgraph_redirect_edge_callee (e, new_node);\n+    }\n+\n+\n   for (e = n->callees;e; e=e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, count_scale, freq, loop_nest,\n \t\t       update_original);\n@@ -1744,8 +1754,6 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   struct cgraph_node *new_node = NULL;\n   tree new_decl;\n   struct cgraph_node key, **slot;\n-  unsigned i;\n-  struct cgraph_edge *e;\n \n   gcc_assert  (tree_versionable_function_p (old_decl));\n \n@@ -1762,7 +1770,8 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   SET_DECL_RTL (new_decl, NULL);\n \n   new_node = cgraph_clone_node (old_node, old_node->count,\n-  \t\t\t\tCGRAPH_FREQ_BASE, 0, false);\n+\t\t\t\tCGRAPH_FREQ_BASE, 0, false,\n+\t\t\t\tredirect_callers);\n   new_node->decl = new_decl;\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n@@ -1821,13 +1830,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n       gcc_assert (!*aslot);\n       *aslot = new_node;\n     }\n-   for (i = 0; VEC_iterate (cgraph_edge_p, redirect_callers, i, e); i++)\n-     {\n-       /* Redirect calls to the old version node to point to its new\n-\t  version.  */\n-       cgraph_redirect_edge_callee (e, new_node);\n-     }\n-  \n+\n   return new_node;\n }\n "}, {"sha": "292eccd028430bfcf49d7ba32cd234482c6a2a26", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -409,7 +409,7 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *,\n \t\t\t\t\tgimple, gcov_type, int, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int,\n-\t\t\t\t\tint, bool);\n+\t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n "}, {"sha": "8851d605372094880213cb5843544f3e65b6bff2", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -238,7 +238,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t{\n \t  struct cgraph_node *n;\n \t  n = cgraph_clone_node (e->callee, e->count, e->frequency, e->loop_nest, \n-\t\t\t\t update_original);\n+\t\t\t\t update_original, NULL);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }\n@@ -723,7 +723,8 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n \t     cgraph_node_name (node));\n \n   /* We need original clone to copy around.  */\n-  master_clone = cgraph_clone_node (node, node->count, CGRAPH_FREQ_BASE, 1, false);\n+  master_clone = cgraph_clone_node (node, node->count, CGRAPH_FREQ_BASE, 1,\n+  \t\t\t\t    false, NULL);\n   master_clone->needed = true;\n   for (e = master_clone->callees; e; e = e->next_callee)\n     if (!e->inline_failed)"}, {"sha": "04d4e112ed350974a57576203822af190cdb68ba", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -688,6 +688,18 @@ ignore_edge (struct cgraph_edge *e)\n   return (!e->can_throw_external);\n }\n \n+/* Return true if NODE is self recursive function.  */\n+\n+static bool\n+self_recursive_p (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->callee == node)\n+      return true;\n+  return false;\n+}\n+\n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by generate_summary.\n    Note that there is no function_transform pass since this only\n@@ -776,6 +788,8 @@ propagate (void)\n \t  if (w_l->state_previously_known != IPA_NEITHER\n \t      && this_state > w_l->state_previously_known)\n             this_state = w_l->state_previously_known;\n+\t  if (!this_looping && self_recursive_p (w))\n+\t    this_looping = true;\n \t  if (!w_l->looping_previously_known)\n \t    this_looping = false;\n "}, {"sha": "a981836180eca8c7df04798c2db84a8df59a343c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -1,3 +1,7 @@\n+2009-10-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/ipa-cp-1.c: New testcase.\n+\n 2009-10-01  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* gcc.dg/20021014-1.c (*-*-freebsd*): Use dg-message."}, {"sha": "bd24446e162c707752d696a1537bba77bcd34a8d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-cp-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ec7d01e07f3477397874f01ee7da39fc93d023/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c?ref=03ec7d01e07f3477397874f01ee7da39fc93d023", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized -fno-inline\" } */\n+int\n+very_long_function(int a)\n+{\n+  return very_long_function (a)/4;\n+}\n+main()\n+{\n+  very_long_function (1);\n+}\n+/* One appereance for dump, one self recursive call and one call from main.  */\n+/* { dg-final { scan-tree-dump-times \"very_long_function.clone.0 \\\\(\\\\)\" 3 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized -fno-inline\" } */\n+int\n+very_long_function(int a)\n+{\n+  return very_long_function (a)/4;\n+}\n+main()\n+{\n+  very_long_function (1);\n+}\n+/* One appereance for dump, one self recursive call and one call from main.  */\n+/* { dg-final { scan-tree-dump-times \"very_long_function.clone.0 \\\\(\\\\)\" 3 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized -fno-inline\" } */\n+int\n+very_long_function(int a)\n+{\n+  return very_long_function (a)/4;\n+}\n+main()\n+{\n+  very_long_function (1);\n+}\n+/* One appereance for dump, one self recursive call and one call from main.  */\n+/* { dg-final { scan-tree-dump-times \"very_long_function.clone.0 \\\\(\\\\)\" 3 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}