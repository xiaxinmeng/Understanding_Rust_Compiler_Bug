{"sha": "c3e76028d0a476503e8be8448a9ab0803b4f26b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNlNzYwMjhkMGE0NzY1MDNlOGJlODQ0OGE5YWIwODAzYjRmMjZiNw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-09-12T09:10:28Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-09-12T09:10:28Z"}, "message": "error.c (TFF_PLAIN_IDENTIFIER, [...]): New macros.\n\n\t* error.c (TFF_PLAIN_IDENTIFIER, TFF_NAMESPACE_SCOPE,\n\tTFF_CLASS_SCOPE, TFF_CHASE_NAMESPACE_ALIAS, TFF_CHASE_TYPDEF,\n\tTFF_DECL_SPECIFIERS, TFF_CLASS_KEY_OR_ENUM, TFF_RETURN_TYPE,\n\tTFF_FUNCTION_DEFAULT_ARGUMENTS, TFF_EXCEPTION_SPECIFICATION,\n\tTFF_TEMPLATE_HEADER, TFF_TEMPLATE_DEFAULT_ARGUMENTS, TFF_SCOPE):\n\tNew macros.\n\t(sorry_for_unsupported_tree, print_scope_operator,\n\tprint_left_paren, print_right_paren, print_left_bracket,\n\tprint_right_bracket, print_whitespace): Likewise.\n\t(aggr_variety): Rename to class_key_or_enum.\n\t(print_type): Rename to print_type_id.\n\t(print_type_specifier_seq, print_simple_type_specifier,\n\tprint_elaborated_type_specifier,\n\tprint_rest_of_abstract_declarator,\n\tprint_parameter_declaration_clause, print_exception_specification,\n\tprint_nested_name_specifier, print_template_id,\n\ttypedef_original_name,  print_template_argument_list_start,\n\tprint_template_argument_list_end): New functions.\n\nFrom-SVN: r36356", "tree": {"sha": "9675fa25ab445dd08f58133db21d9c57216849cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9675fa25ab445dd08f58133db21d9c57216849cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3e76028d0a476503e8be8448a9ab0803b4f26b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e76028d0a476503e8be8448a9ab0803b4f26b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e76028d0a476503e8be8448a9ab0803b4f26b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e76028d0a476503e8be8448a9ab0803b4f26b7/comments", "author": null, "committer": null, "parents": [{"sha": "eb50138bec5581401884dcfd86080d27bd7c446f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb50138bec5581401884dcfd86080d27bd7c446f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb50138bec5581401884dcfd86080d27bd7c446f"}], "stats": {"total": 688, "additions": 669, "deletions": 19}, "files": [{"sha": "0df451c1d6aa64ead0d55b2f96e913ef13832e8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e76028d0a476503e8be8448a9ab0803b4f26b7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e76028d0a476503e8be8448a9ab0803b4f26b7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c3e76028d0a476503e8be8448a9ab0803b4f26b7", "patch": "@@ -1,3 +1,24 @@\n+2000-09-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* error.c (TFF_PLAIN_IDENTIFIER, TFF_NAMESPACE_SCOPE,\n+\tTFF_CLASS_SCOPE, TFF_CHASE_NAMESPACE_ALIAS, TFF_CHASE_TYPDEF,\n+\tTFF_DECL_SPECIFIERS, TFF_CLASS_KEY_OR_ENUM, TFF_RETURN_TYPE,\n+\tTFF_FUNCTION_DEFAULT_ARGUMENTS, TFF_EXCEPTION_SPECIFICATION,\n+\tTFF_TEMPLATE_HEADER, TFF_TEMPLATE_DEFAULT_ARGUMENTS, TFF_SCOPE):\n+\tNew macros.\n+\t(sorry_for_unsupported_tree, print_scope_operator,\n+\tprint_left_paren, print_right_paren, print_left_bracket,\n+\tprint_right_bracket, print_whitespace): Likewise.\n+\t(aggr_variety): Rename to class_key_or_enum.\n+\t(print_type): Rename to print_type_id.\n+\t(print_type_specifier_seq, print_simple_type_specifier,\n+\tprint_elaborated_type_specifier,\n+\tprint_rest_of_abstract_declarator,\n+\tprint_parameter_declaration_clause, print_exception_specification,\n+\tprint_nested_name_specifier, print_template_id,\n+\ttypedef_original_name,  print_template_argument_list_start,\n+\tprint_template_argument_list_end): New functions.\n+\n 2000-09-11  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n         * ir.texi: Add more documentation."}, {"sha": "41e5f40a4f4d3f253e7c50fd898b312fabc551a2", "filename": "gcc/cp/error.c", "status": "modified", "additions": 648, "deletions": 19, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e76028d0a476503e8be8448a9ab0803b4f26b7/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e76028d0a476503e8be8448a9ab0803b4f26b7/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=c3e76028d0a476503e8be8448a9ab0803b4f26b7", "patch": "@@ -29,6 +29,39 @@ Boston, MA 02111-1307, USA.  */\n \n enum pad { none, before, after };\n \n+/* These constants can used as bit flags in the process of tree formatting.\n+\n+   TFF_PLAIN_IDENTIFER: unqualified part of a name.\n+   TFF_NAMESPACE_SCOPE: the complete qualified-id form of a name.\n+   TFF_CLASS_SCOPE: if possible, include the class-name part of a\n+        qualified-id.  This flag may be implied in some circumstances by\n+        TFF_NAMESPACE_SCOPE.\n+   TFF_SCOPE: the combinaison of the two above.        \n+   TFF_CHASE_TYPDEF: print the original type-id instead of the typedef-name.\n+   TFF_DECL_SPECIFIERS: print decl-specifiers.\n+   TFF_CLASS_KEY_OR_ENUM: precede a class-type name (resp. enum name) with\n+       a class-key (resp. `enum').\n+   TFF_RETURN_TYPE: include function return type.\n+   TFF_FUNCTION_DEFAULT_ARGUMENTS: include function default parameter values.\n+   TFF_EXCEPTION_SPECIFICATION: show function exception specification.\n+   TFF_TEMPLATE_HEADER: show the template<...> hearder in a\n+       template-declaration.\n+   TFF_TEMPLATE_DEFAULT_ARGUMENTS: show template paramter default values.  */\n+\n+#define TFF_PLAIN_IDENTIFIER               (0)\n+#define TFF_NAMESPACE_SCOPE                (1)\n+#define TFF_CLASS_SCOPE                    (1 << 1)\n+#define TFF_CHASE_NAMESPACE_ALIAS          (1 << 2)\n+#define TFF_CHASE_TYPEDEF                  (1 << 3)\n+#define TFF_DECL_SPECIFIERS                (1 << 4)\n+#define TFF_CLASS_KEY_OR_ENUM              (1 << 5)\n+#define TFF_RETURN_TYPE                    (1 << 6)\n+#define TFF_FUNCTION_DEFAULT_ARGUMENTS     (1 << 7)\n+#define TFF_EXCEPTION_SPECIFICATION        (1 << 8)\n+#define TFF_TEMPLATE_HEADER                (1 << 9)\n+#define TFF_TEMPLATE_DEFAULT_ARGUMENTS     (1 << 10)\n+#define TFF_SCOPE (TFF_NAMESPACE_SCOPE | TFF_CLASS_SCOPE)\n+\n /* This data structure bundles altogether, all the information necessary\n    for pretty-printing a C++ source-level entity represented by a tree.  */\n typedef struct\n@@ -42,6 +75,21 @@ typedef struct\n #define tree_formatting_flags(TFI) (TFI)->flags\n #define put_whitespace(TFI) (TFI)->pad\n \n+#define sorry_for_unsupported_tree(T)                                      \\\n+   sorry (\"`%s' not supported by %s\", tree_code_name[(int) TREE_CODE (T)], \\\n+             __FUNCTION__)\n+\n+#define print_scope_operator(BUFFER)  output_add_string (BUFFER, \"::\")\n+#define print_left_paren(BUFFER)      output_add_character (BUFFER, '(')\n+#define print_right_paren(BUFFER)     output_add_character (BUFFER, ')')\n+#define print_left_bracket(BUFFER)    output_add_character (BUFFER, '[')\n+#define print_right_bracket(BUFFER)   output_add_character (BUFFER, ']')\n+#define print_whitespace(BUFFER, TFI)        \\\n+   do {                                      \\\n+     output_add_space (BUFFER);              \\\n+     put_whitespace (TFI) = none;            \\\n+   } while (0)\n+\n typedef const char *cp_printer ();\n \n #define obstack_chunk_alloc xmalloc\n@@ -105,7 +153,7 @@ static enum pad dump_qualifiers PARAMS ((tree, enum pad));\n static void dump_char PARAMS ((int));\n static void dump_parameters PARAMS ((tree, enum tree_string_flags));\n static void dump_exception_spec PARAMS ((tree, enum tree_string_flags));\n-static const char *aggr_variety PARAMS ((tree));\n+static const char *class_key_or_enum PARAMS ((tree));\n static tree ident_fndecl PARAMS ((tree));\n static void dump_template_argument PARAMS ((tree, enum tree_string_flags));\n static void dump_template_argument_list PARAMS ((tree, enum tree_string_flags));\n@@ -133,9 +181,21 @@ static void print_declaration PARAMS ((output_buffer *, tfi_t));\n static void print_expression PARAMS ((output_buffer *, tfi_t));\n static void print_function_declaration PARAMS ((output_buffer *, tfi_t));\n static void print_function_parameter PARAMS ((output_buffer *, int));\n-static void print_type PARAMS ((output_buffer *, tfi_t));\n-static void print_cv_qualifier PARAMS ((output_buffer *, tfi_t));\n-\n+static void print_type_id PARAMS ((output_buffer *, tfi_t));\n+static void print_cv_qualifier_seq PARAMS ((output_buffer *, tfi_t));\n+static void print_type_specifier_seq PARAMS ((output_buffer *, tfi_t));\n+static void print_simple_type_specifier PARAMS ((output_buffer *, tfi_t));\n+static void print_elaborated_type_specifier PARAMS ((output_buffer *, tfi_t));\n+static void print_rest_of_abstract_declarator PARAMS ((output_buffer *,\n+                                                       tfi_t));\n+static void print_parameter_declaration_clause PARAMS ((output_buffer *,\n+                                                        tfi_t));\n+static void print_exception_specification PARAMS ((output_buffer *, tfi_t));\n+static void print_nested_name_specifier PARAMS ((output_buffer *, tfi_t));\n+static void print_template_id PARAMS ((output_buffer *, tfi_t));\n+static void print_template_argument_list_start PARAMS ((output_buffer *));\n+static void print_template_argument_list_end PARAMS ((output_buffer *));\n+static tree typedef_original_name PARAMS ((tree));\n \n #define A args_to_string\n #define C code_to_string\n@@ -545,7 +605,7 @@ dump_typename (t, flags)\n /* Return the name of the supplied aggregate, or enumeral type.  */\n \n static const char *\n-aggr_variety (t)\n+class_key_or_enum (t)\n      tree t;\n {\n   if (TREE_CODE (t) == ENUMERAL_TYPE)\n@@ -567,7 +627,7 @@ dump_aggr_type (t, flags)\n      enum tree_string_flags flags;\n {\n   tree name;\n-  const char *variety = aggr_variety (t);\n+  const char *variety = class_key_or_enum (t);\n   int typdef = 0;\n   int tmplate = 0;\n \n@@ -2658,8 +2718,8 @@ cp_tree_printer (buffer)\n {\n   int be_verbose = 0;\n   tree_formatting_info tfi;\n-  \n-  put_whitespace (&tfi) = none;\n+\n+  bzero (&tfi, sizeof (tree_formatting_info));\n \n   if (*output_buffer_text_cursor (buffer) == '+')\n     ++output_buffer_text_cursor (buffer);\n@@ -2674,24 +2734,38 @@ cp_tree_printer (buffer)\n     case 'A':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n+      if (be_verbose)\n+        tree_formatting_flags (&tfi) = TFF_SCOPE\n+          | TFF_FUNCTION_DEFAULT_ARGUMENTS;\n       print_function_argument_list (buffer, &tfi);\n       break;\n       \n     case 'D':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n+      if (be_verbose)\n+        tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_DECL_SPECIFIERS\n+          | TFF_CLASS_KEY_OR_ENUM | TFF_RETURN_TYPE\n+          | TFF_FUNCTION_DEFAULT_ARGUMENTS | TFF_TEMPLATE_DEFAULT_ARGUMENTS\n+          | TFF_EXCEPTION_SPECIFICATION | TFF_CHASE_NAMESPACE_ALIAS;\n       print_declaration (buffer, &tfi);\n       break;\n       \n     case 'E':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n+      if (be_verbose)\n+        tree_formatting_flags (&tfi) = TFF_SCOPE;\n       print_expression (buffer, &tfi);\n       break;\n       \n     case 'F':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n+      if (be_verbose)\n+        tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_DECL_SPECIFIERS\n+          | TFF_RETURN_TYPE | TFF_FUNCTION_DEFAULT_ARGUMENTS\n+          | TFF_EXCEPTION_SPECIFICATION;          \n       print_function_declaration (buffer, &tfi);\n       break;\n       \n@@ -2703,13 +2777,16 @@ cp_tree_printer (buffer)\n     case 'T':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n-      print_type (buffer, &tfi);\n+      if (be_verbose)\n+        tree_formatting_flags (&tfi) = TFF_SCOPE | TFF_CLASS_KEY_OR_ENUM\n+          | TFF_RETURN_TYPE | TFF_EXCEPTION_SPECIFICATION;\n+      print_type_id (buffer, &tfi);\n       break;\n       \n     case 'V':\n       tree_being_formatted (&tfi) =\n         va_arg (output_buffer_format_args (buffer), tree);\n-      print_cv_qualifier (buffer, &tfi);\n+      print_cv_qualifier_seq (buffer, &tfi);\n       break;\n       \n     default:\n@@ -2755,14 +2832,6 @@ print_function_declaration (buffer, tfi)\n {\n }\n \n-/* Print a type represented by tree_being_formattted (TFI) onto BUFFER.  */\n-static void\n-print_type (buffer, tfi)\n-     output_buffer *buffer __attribute__ ((__unused__));\n-     tfi_t tfi __attribute__ ((__unused__));\n-{\n-}\n-\n /* Print the N'th function parameter onto BUFFER.  A negative value of N\n    means the implicit \"this\" parameter of a member function.  */\n static void\n@@ -2775,10 +2844,479 @@ print_function_parameter (buffer, n)\n   else\n     output_decimal (buffer, n + 1);\n }\n+\f\n+/* Print a type represented by tree_being_formatted (TFI) onto BUFFER.  */\n+static void\n+print_type_id (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi;\n+{\n+  tree t = tree_being_formatted (tfi);\n+  int flags = tree_formatting_flags (tfi);\n+  if (t == NULL_TREE)\n+    return;\n+\n+  if (flags & TFF_CHASE_TYPEDEF)\n+    tree_being_formatted (tfi) =\n+      typedef_original_name (tree_being_formatted (tfi));\n+  \n+  /* A type-id is of the form:\n+     type-id:\n+        type-specifier-seq abstract-declarator(opt)  */\n+  print_type_specifier_seq (buffer, tfi);\n+\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    goto ptr_mem_fun;\n+\n+  /* For types with abstract-declarator, print_type_specifier_seq prints\n+     the start of the abstract-declarator.  Fiinish the job.  */\n+  switch (TREE_CODE (t))\n+    {\n+    case ARRAY_TYPE:\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+    ptr_mem_fun:\n+      print_rest_of_abstract_declarator (buffer, tfi);\n+  \n+    default:\n+      break;\n+    }\n+\n+  tree_being_formatted (tfi) = t;\n+}\n+\n+/* Print the type-specifier-seq part of a type-id.  If appropriate, print\n+ also the prefix of the abstract-declarator.  */\n+static void\n+print_type_specifier_seq (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi;\n+{\n+  int flags = tree_formatting_flags (tfi);\n+  tree t = tree_being_formatted (tfi);\n+  enum tree_code code = TREE_CODE (t);\n+\n+  /* A type-speficier-seq is:\n+         type-specifier type-specifier-seq(opt)\n+     where\n+         type-specifier:\n+             simple-type-specifier\n+             class-specifier\n+             enum-specifier\n+             elaborated-type-specifier\n+             cv-qualifier\n+\n+     We do not, however, pretty-print class-specifier nor enum-specifier.  */\n+\n+  switch (code)\n+    {\n+    case UNKNOWN_TYPE:\n+    case IDENTIFIER_NODE:\n+    case VOID_TYPE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case UNION_TYPE:\n+    case TYPE_DECL:\n+    case TEMPLATE_DECL:\n+    case TEMPLATE_TYPE_PARM:\n+    case TYPEOF_TYPE:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TYPENAME_TYPE:\n+    class_type:\n+      print_cv_qualifier_seq (buffer, tfi);\n+      if ((flags & TFF_DECL_SPECIFIERS)\n+          && (code ==  TYPENAME_TYPE || IS_AGGR_TYPE (t)))\n+        print_elaborated_type_specifier (buffer, tfi);\n+      else\n+        print_simple_type_specifier (buffer, tfi);\n+      break;\n+\n+      /* Because the abstract-declarator can modify the type-specifier-seq\n+         in a highly non linear manner, we pretty-print its prefix here.\n+         The suffix part is handled by print_rest_of_abstract_declarator.  */\n+      \n+      /* A RECORD_TYPE is also used to represent a pointer to member\n+         function.  */\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+        {\n+          /* Print the return type.  */\n+          tree_being_formatted (tfi) =\n+            TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t));\n+          print_type_id (buffer, tfi);\n+          print_whitespace (buffer, tfi);\n+          \n+          /* Then the beginning of the abstract-declarator part.  */\n+          tree_being_formatted (tfi) =\n+            TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (t));\n+          print_left_paren (buffer);\n+          print_nested_name_specifier (buffer, tfi);\n+        }\n+      else\n+        goto class_type;\n+      break;\n+\n+    case POINTER_TYPE:\n+      if (TYPE_PTRMEM_P (t))\n+        goto ptr_data_member;\n+      else\n+        goto non_ptr_data_member;\n+      break;\n+\n+    case ARRAY_TYPE:\n+    case REFERENCE_TYPE:\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+    non_ptr_data_member:\n+      tree_being_formatted (tfi) = TREE_TYPE (t);\n+      print_type_specifier_seq (buffer, tfi);\n+      if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n+        {\n+          if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+            print_left_paren (buffer);\n+        }\n+      else if (code == FUNCTION_TYPE || code == METHOD_TYPE)\n+        {\n+          print_whitespace (buffer, tfi);\n+          print_left_paren (buffer);\n+          if (code == METHOD_TYPE)\n+            {\n+              tree_being_formatted (tfi) = TYPE_METHOD_BASETYPE (t);\n+              print_nested_name_specifier (buffer, tfi);\n+              tree_being_formatted (tfi) = t;\n+            }\n+        }\n+      tree_being_formatted (tfi) = t;\n+      break;\n+\n+    ptr_data_member:\n+    case OFFSET_TYPE:\n+      /* Firstly, the type of the member.  */\n+      tree_being_formatted (tfi) = TREE_TYPE (t);\n+      print_type_id (buffer, tfi);\n+      print_whitespace (buffer, tfi);\n+      \n+      /* Then, the containing class.  */\n+      tree_being_formatted (tfi) = TYPE_OFFSET_BASETYPE (t);\n+      print_nested_name_specifier (buffer, tfi);\n+      tree_being_formatted (tfi) = t;\n+      break;\n+\n+    default:\n+      sorry_for_unsupported_tree (t);\n+      /* fall throught  */\n+\n+    case ERROR_MARK:\n+      print_identifier (buffer, \"{type-specifier-seq error}\");\n+      break;\n+    }\n+\n+  tree_being_formatted (tfi) = t;\n+}\n+\n+/* Print the simpe-type-specifier component of a type-specifier.  */\n+static void\n+print_simple_type_specifier (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi;\n+{\n+  int flags = tree_formatting_flags (tfi);\n+  tree t = tree_being_formatted (tfi);\n+  enum tree_code code = TREE_CODE (t);\n+\n+  switch (code)\n+    {\n+    case UNKNOWN_TYPE:\n+      print_identifier (buffer, \"{unknown type}\");\n+      break;\n+\n+    case IDENTIFIER_NODE:\n+      print_tree_identifier (buffer, t);\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      print_identifier (buffer, \"__complex__ \");\n+      tree_being_formatted (tfi) = TREE_TYPE (t);\n+      print_type_id (buffer, tfi);\n+      break;\n+\n+    case TYPENAME_TYPE:\n+      tree_being_formatted (tfi) = TYPE_CONTEXT (t);\n+      print_nested_name_specifier (buffer, tfi);\n+      tree_being_formatted (tfi) = TYPENAME_TYPE_FULLNAME (t);\n+      tree_formatting_flags (tfi) |= ~TFF_CHASE_TYPEDEF;\n+      print_type_id (buffer, tfi);\n+      break;\n+\n+    case TYPEOF_TYPE:\n+      print_identifier (buffer, \"__typeof__\");\n+      tree_being_formatted (tfi) = TYPE_FIELDS (t);\n+      print_left_paren (buffer);\n+      print_expression (buffer, tfi);\n+      print_right_paren (buffer);\n+      break;\n+\n+    case INTEGER_TYPE:\n+      if (TREE_UNSIGNED (t))\n+        {\n+          if (TYPE_MAIN_VARIANT (t) == integer_type_node)\n+            /* We don't want pedantry like `unsigned int'.  */;\n+          else if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)))\n+            {\n+              print_identifier (buffer, \"unsigned\");\n+              print_whitespace (buffer, tfi);\n+            }\n+        }\n+      else if (TYPE_MAIN_VARIANT (t) == char_type_node)\n+        {\n+          print_identifier (buffer, \"signed\");\n+          print_whitespace (buffer, tfi);\n+        }\n+    case REAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case VOID_TYPE:\n+      {\n+        tree s = (flags & TFF_CHASE_TYPEDEF) ? TYPE_MAIN_VARIANT (t) : t;\n+\n+        if (TYPE_NAME (s) && TYPE_IDENTIFIER (s))\n+          print_tree_identifier (buffer, TYPE_IDENTIFIER (s));\n+        else\n+\t  /* Types like intQI_type_node and friends have no names.\n+\t     These don't come up in user error messages, but it's nice\n+\t     to be able to print them from the debugger.  */\n+          print_identifier (buffer, \"{anonymous}\");\n+      }\n+      break;\n+\n+    case TEMPLATE_TEMPLATE_PARM:\n+      if (TYPE_IDENTIFIER (t))\n+        print_tree_identifier (buffer, TYPE_IDENTIFIER (t));\n+      else\n+        print_identifier (buffer, \"{anonymous template template parameter}\");\n+      break;\n+\n+    case TYPE_DECL:\n+      if (flags & TFF_CHASE_TYPEDEF)\n+        print_type_id (buffer, tfi);\n+      else\n+        print_tree_identifier (buffer, DECL_NAME (t));\n+      break;\n+\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_DECL:\n+      print_template_id (buffer, tfi);\n+      break;\n+\n+    case TEMPLATE_TYPE_PARM:\n+      if (TYPE_IDENTIFIER (t))\n+        print_tree_identifier (buffer, TYPE_IDENTIFIER (t));\n+      else\n+        print_identifier (buffer, \"{anonymous template type parameter}\");\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  tree_being_formatted (tfi) = t;\n+  tree_formatting_flags (tfi) = flags;\n+}\n+\n+/* Print the elaborated-type-specifier form of a type-specifier.  */\n+static void\n+print_elaborated_type_specifier (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi;\n+{\n+  int flags = tree_formatting_flags (tfi);\n+  tree t = tree_being_formatted (tfi);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case TYPENAME_TYPE:\n+      print_identifier (buffer, \"typename\");\n+      print_whitespace (buffer, tfi);\n+      tree_formatting_flags (tfi) |= ~TFF_DECL_SPECIFIERS;\n+      print_simple_type_specifier (buffer, tfi);\n+      break;\n+\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      {\n+        tree name = NULL_TREE;\n+\n+        if (flags & TFF_CHASE_TYPEDEF)\n+          tree_being_formatted (tfi) = typedef_original_name (t);\n+\n+        print_identifier\n+          (buffer, class_key_or_enum (tree_being_formatted (tfi)));\n+        print_whitespace (buffer, tfi);\n+\n+        name = TYPE_NAME (tree_being_formatted (tfi));\n+        if (name)\n+          {\n+            if (flags & TFF_SCOPE)\n+              {\n+                tree_being_formatted (tfi) = CP_DECL_CONTEXT (name);\n+                print_nested_name_specifier (buffer, tfi);\n+              }\n+            print_tree_identifier (buffer, DECL_NAME (name));\n+          }\n+        else\n+          print_identifier (buffer, \"{anonymous}\");\n+      }\n+      break;\n+\n+    default:\n+      sorry_for_unsupported_tree (t);\n+      break;\n+    }\n+\n+  tree_being_formatted (tfi) = t;\n+  tree_formatting_flags (tfi) = flags;\n+}\n+\n+/* Finish the job of printing the abstract-declarator part of a\n+   type-id.  */\n+static void\n+print_rest_of_abstract_declarator (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi;\n+{\n+  tree t = tree_being_formatted (tfi);\n+  enum tree_code code = TREE_CODE (t);\n+  \n+  /* An abstract-declarator has the form:\n+    \n+     abstract-declarator:\n+          ptr-operator abstract-declarator(opt)\n+          direct-abstract-declarator\n+\n+     direct-abstract-declarator:\n+          direct-abstract-declarator(opt)\n+              ( parameter-declaration-clause ) cv-qualifier-seq(opt)\n+                    exception-specification(opt)\n+          direct-abstract-declarator(opt) [ constant-expression(opt) ]\n+          ( direct-abstract-declarator )   */\n+\n+  switch (code)\n+    {\n+    case ARRAY_TYPE:\n+      print_left_bracket (buffer);\n+      if (TYPE_DOMAIN (t))\n+\t{\n+          tree s = TYPE_DOMAIN (t);\n+\n+\t  if (host_integerp (TYPE_MAX_VALUE (s), 0))\n+\t    output_decimal (buffer, tree_low_cst (TYPE_MAX_VALUE (s), 0) + 1);\n+\t  else if (TREE_CODE (TYPE_MAX_VALUE (s)) == MINUS_EXPR)\n+            {\n+              tree_being_formatted (tfi) =\n+                TREE_OPERAND (TYPE_MAX_VALUE (s), 0);\n+              print_expression (buffer, tfi);\n+              tree_being_formatted (tfi) = t;\n+            }\n+\t  else\n+            {\n+              tree_being_formatted (tfi) = fold\n+                (cp_build_binary_op (PLUS_EXPR, TYPE_MAX_VALUE (s),\n+                                     integer_one_node));\n+              print_expression (buffer, tfi);\n+              tree_being_formatted (tfi) = t;\n+            }\n+\t}\n+      print_right_bracket (buffer);\n+      put_whitespace (tfi) = none;\n+      tree_being_formatted (tfi) = TREE_TYPE (t);\n+      print_rest_of_abstract_declarator (buffer, tfi);\n+      tree_being_formatted (tfi) = t;\n+      break;\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n+      if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n+        {\n+          output_add_character (buffer, \"&*\"[code == POINTER_TYPE]);\n+          if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+            print_right_paren (buffer);\n+        }\n+      put_whitespace (tfi) = before;\n+      print_cv_qualifier_seq (buffer, tfi);\n+      tree_being_formatted (tfi) = TREE_TYPE (t);\n+      print_rest_of_abstract_declarator (buffer, tfi);\n+      tree_being_formatted (tfi) = t;\n+      break;\n+\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      print_right_paren (buffer);\n+      print_whitespace (buffer, tfi);\n+\n+      /* Skip the `this' implicit parameter if present.  */\n+      tree_being_formatted (tfi) = TYPE_ARG_TYPES (t);\n+      if (code == METHOD_TYPE)\n+        tree_being_formatted (tfi) = TREE_CHAIN (tree_being_formatted (tfi));\n+\n+      /* Print the parameter-list.  */\n+      print_left_paren (buffer);\n+      print_parameter_declaration_clause (buffer, tfi);\n+      print_right_paren (buffer);\n+\n+      print_whitespace (buffer, tfi);\n+\n+      if (code == METHOD_TYPE)\n+        {\n+          tree_being_formatted (tfi) =\n+            TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t)));\n+          print_cv_qualifier_seq (buffer, tfi);\n+        }\n+\n+      /* Finish the abstract-declarator.  */\n+      tree_being_formatted (tfi) = TREE_TYPE (t);\n+      print_rest_of_abstract_declarator (buffer, tfi);\n+\n+      /* Print the exception-specification for documentaion purpose.  */\n+      tree_being_formatted (tfi) = TYPE_RAISES_EXCEPTIONS (t);\n+      print_exception_specification (buffer, tfi);\n+      tree_being_formatted (tfi) = t;\n+      break;\n+\n+      /* These types don't have abstract-declarator.  */\n+    case UNKNOWN_TYPE:\n+    case IDENTIFIER_NODE:\n+    case VOID_TYPE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case UNION_TYPE:\n+    case TYPE_DECL:\n+    case TEMPLATE_DECL:\n+    case TEMPLATE_TYPE_PARM:\n+    case TYPEOF_TYPE:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TYPENAME_TYPE:\n+      break;\n+\n+    default:\n+      sorry_for_unsupported_tree (t);\n+      /* fall throught.  */\n+    case ERROR_MARK:\n+      break;      \n+    }\n+}\n \n /* Print the cv-quafilers of tree_being_formatted (TFI) onto BUFFER.  */\n static void\n-print_cv_qualifier (buffer, tfi)\n+print_cv_qualifier_seq (buffer, tfi)\n      output_buffer *buffer;\n      tree_formatting_info *tfi;\n {\n@@ -2808,3 +3346,94 @@ print_cv_qualifier (buffer, tfi)\n         }\n     }\n }\n+\n+static void\n+print_parameter_declaration_clause (buffer, tfi)\n+     output_buffer *buffer __attribute__ ((__unused__));\n+     tfi_t tfi __attribute__ ((__unused__));\n+{\n+}\n+\n+static void\n+print_exception_specification (buffer, tfi)\n+     output_buffer *buffer __attribute__ ((__unused__));\n+     tfi_t tfi __attribute__ ((__unused__));\n+{\n+}\n+\n+static void\n+print_nested_name_specifier (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi;\n+{\n+  int flags = tree_formatting_flags (tfi);\n+  tree t = tree_being_formatted (tfi);\n+  /* A nested-name-specifier is:\n+        class-or-namespace-name :: nested-name-specifier(opt)\n+        class-or-namespace-name :: template nested-name-specifier\n+\n+     The latter form being the correct syntax for a name  designating\n+     a template member, where the preceding class-or-namespace-name part\n+     is name-dependent.  For the time being, we do not do such a\n+     sophisticated pretty-printing.\n+\n+     class-or-namespace-name:\n+        class-name\n+        namespace-name  */\n+\n+  if (t == NULL_TREE || t == global_namespace)\n+    return;\n+\n+  if (CLASS_TYPE_P (t) && !(flags & TFF_CLASS_SCOPE))\n+    return;\n+\n+  if (TREE_CODE (t) == NAMESPACE_DECL && !(flags & TFF_NAMESPACE_SCOPE))\n+    return;\n+\n+  tree_being_formatted (tfi) = DECL_CONTEXT (t);\n+  print_nested_name_specifier (buffer, tfi);\n+  print_scope_operator (buffer);\n+  if (TREE_CODE (t) == NAMESPACE_DECL)\n+    print_tree_identifier (buffer, DECL_NAME (t));\n+  else if (CLASS_TYPE_P (t))\n+    {\n+      if (!DECL_USE_TEMPLATE (t))\n+        print_tree_identifier (buffer, TYPE_IDENTIFIER (t));\n+      else\n+        {\n+          tree_being_formatted (tfi) = t;\n+          print_template_id (buffer, tfi);\n+        }\n+    }\n+\n+  tree_being_formatted (tfi) = t;             \n+}\n+\n+static void\n+print_template_id (buffer, tfi)\n+     output_buffer *buffer;\n+     tfi_t tfi __attribute__ ((__unused__));\n+{\n+  print_template_argument_list_start (buffer);\n+  /* ... */\n+  print_template_argument_list_end (buffer);\n+}\n+\n+static tree\n+typedef_original_name (t)\n+     tree t;\n+{\n+  return DECL_ORIGINAL_TYPE (t) ? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t);\n+}\n+\n+static void\n+print_template_argument_list_start (buffer)\n+     output_buffer *buffer __attribute__ ((__unused__));\n+{\n+}\n+\n+static void\n+print_template_argument_list_end (buffer)\n+     output_buffer *buffer __attribute__ ((__unused__));\n+{\n+}"}]}