{"sha": "69d6b01d68502863c670be61b797313515f81d58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkNmIwMWQ2ODUwMjg2M2M2NzBiZTYxYjc5NzMxMzUxNWY4MWQ1OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-20T18:08:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-20T18:08:53Z"}, "message": "(type_main_variant): New function.\n\nUse it in place of TYPE_MAIN_VARIANT everywhere in dwarfout.c.\n\nFrom-SVN: r4704", "tree": {"sha": "214b927396dade1c792e24f7ddaffc588c919cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/214b927396dade1c792e24f7ddaffc588c919cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69d6b01d68502863c670be61b797313515f81d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d6b01d68502863c670be61b797313515f81d58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d6b01d68502863c670be61b797313515f81d58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d6b01d68502863c670be61b797313515f81d58/comments", "author": null, "committer": null, "parents": [{"sha": "630ef4bf34f04161c7ea0e7134c64ea34eb1ec8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630ef4bf34f04161c7ea0e7134c64ea34eb1ec8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630ef4bf34f04161c7ea0e7134c64ea34eb1ec8b"}], "stats": {"total": 38, "additions": 29, "deletions": 9}, "files": [{"sha": "cd2dca50a75035faf43bf97b5215fdc3777d012a", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d6b01d68502863c670be61b797313515f81d58/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d6b01d68502863c670be61b797313515f81d58/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=69d6b01d68502863c670be61b797313515f81d58", "patch": "@@ -762,6 +762,26 @@ is_pseudo_reg (rtl)\n \t      && (REGNO (XEXP (rtl, 0)) >= FIRST_PSEUDO_REGISTER)));\n }\n \n+inline tree\n+type_main_variant (type)\n+     register tree type;\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  /* There really should be only one main variant among any group of variants\n+     of a given type (and all of the MAIN_VARIANT values for all members of\n+     the group should point to that one type) but sometimes the C front-end\n+     messes this up for array types, so we work around that bug here.  */\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      while (type != TYPE_MAIN_VARIANT (type))\n+        type = TYPE_MAIN_VARIANT (type);\n+    }\n+\n+  return type;\n+}\n+\n /* Return non-zero if the given type node represents a tagged type.  */\n \n inline int\n@@ -1317,10 +1337,10 @@ root_type (type)\n \n       case POINTER_TYPE:\n       case REFERENCE_TYPE:\n-\treturn TYPE_MAIN_VARIANT (root_type (TREE_TYPE (type)));\n+\treturn type_main_variant (root_type (TREE_TYPE (type)));\n \n       default:\n-\treturn TYPE_MAIN_VARIANT (type);\n+\treturn type_main_variant (type);\n     }\n }\n \n@@ -1455,7 +1475,7 @@ equate_type_number_to_die_number (type)\n      to get the equate to come out right, we need to get the main variant\n      itself here.  */\n \n-  type = TYPE_MAIN_VARIANT (type);\n+  type = type_main_variant (type);\n \n   sprintf (type_label, TYPE_NAME_FMT, TYPE_UID (type));\n   sprintf (die_label, DIE_BEGIN_LABEL_FMT, current_dienum);\n@@ -2186,8 +2206,8 @@ location_or_const_value_attribute (decl)\n     if (rtl == NULL_RTX || is_pseudo_reg (rtl))\n       {\n \t/* This decl represents a formal parameter which was optimized out.  */\n-        register tree declared_type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n-        register tree passed_type = TYPE_MAIN_VARIANT (DECL_ARG_TYPE (decl));\n+        register tree declared_type = type_main_variant (TREE_TYPE (decl));\n+        register tree passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n \n \t/* Note that DECL_INCOMING_RTL may be NULL in here, but we handle\n \t   *all* cases where (rtl == NULL_RTX) just below.  */\n@@ -2871,7 +2891,7 @@ type_attribute (type, decl_const, decl_volatile)\n     if (root_type_modified)\n \tmod_u_d_type_attribute (type, decl_const, decl_volatile);\n     else\n-\t/* We have to get the TYPE_MAIN_VARIANT here (and pass that to the\n+\t/* We have to get the type_main_variant here (and pass that to the\n \t   `user_def_type_attribute' routine) because the ..._TYPE node we\n \t   have might simply be a *copy* of some original type node (where\n \t   the copy was created to help us keep track of typedef names)\n@@ -2880,7 +2900,7 @@ type_attribute (type, decl_const, decl_volatile)\n \t   is labeling a given type DIE for future reference, it always and\n \t   only creates labels for DIEs representing *main variants*, and it\n \t   never even knows about non-main-variants.)  */\n-\tuser_def_type_attribute (TYPE_MAIN_VARIANT (type));\n+\tuser_def_type_attribute (type_main_variant (type));\n }\n \n /* Given a tree pointer to a struct, class, union, or enum type node, return\n@@ -3910,7 +3930,7 @@ output_type (type, containing_scope)\n      of this type (i.e. without any const or volatile qualifiers) so get\n      the main variant (i.e. the unqualified version) of this type now.  */\n \n-  type = TYPE_MAIN_VARIANT (type);\n+  type = type_main_variant (type);\n \n   if (TREE_ASM_WRITTEN (type))\n     return;\n@@ -4154,7 +4174,7 @@ output_tagged_type_instantiation (type)\n      sure that we have the main variant (i.e. the unqualified version) of\n      this type now.  */\n \n-  assert (type == TYPE_MAIN_VARIANT (type));\n+  assert (type == type_main_variant (type));\n \n   assert (TREE_ASM_WRITTEN (type));\n "}]}