{"sha": "b91322f2ba88548f5137cea907c85cd74b0b90a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkxMzIyZjJiYTg4NTQ4ZjUxMzdjZWE5MDdjODVjZDc0YjBiOTBhOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-04-28T06:54:02Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-04-28T06:54:02Z"}, "message": "re PR target/39911 (The 'z' suffix doesn't work with 16bit integer insn)\n\n\tPR target/39911\n\t* config/i386/i386.c (print_operand) ['Z']: Handle floating point\n\tand integer modes for x87 operands.  Do not ICE for unsupported size,\n\tgenerate error instead.  Generate error for unsupported operand types.\n\t['z']: Do not handle HImode memory operands specially.  Warning\n\tfor floating-point operands.  Fallthru to 'Z' for unsupported operand\n\ttypes.  Do not ICE for unsupported size, generate error instead.\n\t(output_387_binary_op): Use %Z to output operands.\n\t(output_fp_compare): Ditto.\n\t(output_387_reg_move): Ditto.\n\ntestsuite/ChangeLog:\n\n\tPR target/39911\n\t* gcc.target/i386/pr39911.c: New test.\n\nFrom-SVN: r146874", "tree": {"sha": "e907955ebd25213e01b632ca3ab28601b9dcb477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e907955ebd25213e01b632ca3ab28601b9dcb477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b91322f2ba88548f5137cea907c85cd74b0b90a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91322f2ba88548f5137cea907c85cd74b0b90a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91322f2ba88548f5137cea907c85cd74b0b90a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91322f2ba88548f5137cea907c85cd74b0b90a8/comments", "author": null, "committer": null, "parents": [{"sha": "297c37173212c85e2e0c61cb9a1fd89fa9d44f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297c37173212c85e2e0c61cb9a1fd89fa9d44f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297c37173212c85e2e0c61cb9a1fd89fa9d44f25"}], "stats": {"total": 249, "additions": 173, "deletions": 76}, "files": [{"sha": "601b0b17e6607f31acbb48c8ce19987f0731a6ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b91322f2ba88548f5137cea907c85cd74b0b90a8", "patch": "@@ -1,3 +1,16 @@\n+2009-04-28  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/39911\n+\t* config/i386/i386.c (print_operand) ['Z']: Handle floating point\n+\tand integer modes for x87 operands.  Do not ICE for unsupported size,\n+\tgenerate error instead.  Generate error for unsupported operand types.\n+\t['z']: Do not handle HImode memory operands specially.  Warning\n+\tfor floating-point operands.  Fallthru to 'Z' for unsupported operand\n+\ttypes.  Do not ICE for unsupported size, generate error instead.\n+\t(output_387_binary_op): Use %Z to output operands.\n+\t(output_fp_compare): Ditto.\n+\t(output_387_reg_move): Ditto.\n+\n 2009-04-28  Ben Elliston  <bje@au.ibm.com>\n \n \tPR c++/35652"}, {"sha": "650325ad1058abc07eba2b1e9f936e399d5ed8fe", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 94, "deletions": 74, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b91322f2ba88548f5137cea907c85cd74b0b90a8", "patch": "@@ -10851,7 +10851,7 @@ get_some_local_dynamic_name (void)\n         otherwise nothing\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n-   Z -- likewise, with special suffixes for fild/fist instructions.\n+   Z -- likewise, with special suffixes for x87 instructions.\n    * -- print a star (in certain assembler syntax)\n    A -- print an absolute memory reference.\n    w -- print the operand as if it's a \"word\" (HImode) even if it isn't.\n@@ -10950,91 +10950,111 @@ print_operand (FILE *file, rtx x, int code)\n \t    putc ('t', file);\n \t  return;\n \n-\tcase 'Z':\n-\t  gcc_assert (MEM_P (x));\n+\tcase 'z':\n+\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\t    {\n+\t      /* Opcodes don't get size suffixes if using Intel opcodes.  */\n+\t      if (ASSEMBLER_DIALECT == ASM_INTEL)\n+\t\treturn;\n+\n+\t      switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t\t{\n+\t\tcase 1:\n+\t\t  putc ('b', file);\n+\t\t  return;\n+\n+\t\tcase 2:\n+\t\t  putc ('w', file);\n+\t\t  return;\n+\n+\t\tcase 4:\n+\t\t  putc ('l', file);\n+\t\t  return;\n+\n+\t\tcase 8:\n+\t\t  putc ('q', file);\n+\t\t  return;\n+\n+\t\tdefault:\n+\t\t  output_operand_lossage\n+\t\t    (\"invalid operand size for operand code '%c'\", code);\n+\t\t  return;\n+\t\t}\n+\t    }\n \n-\t  /* fild/fist don't get size suffixes if using Intel opcodes.  */\n+\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+\t    warning\n+\t      (0, \"non-integer operand used with operand code '%c'\", code);\n+\t  /* FALLTHRU */\n+\n+\tcase 'Z':\n+\t  /* 387 opcodes don't get size suffixes if using Intel opcodes.  */\n \t  if (ASSEMBLER_DIALECT == ASM_INTEL)\n \t    return;\n \n-\t  switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n \t    {\n-\t    case 2:\n+\t      switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t\t{\n+\t\tcase 2:\n #ifdef HAVE_AS_IX86_FILDS\n-\t      putc ('s', file);\n+\t\t  putc ('s', file);\n #endif\n-\t      return;\n+\t\t  return;\n \n-\t    case 4:\n-\t      putc ('l', file);\n-\t      return;\n+\t\tcase 4:\n+\t\t  putc ('l', file);\n+\t\t  return;\n \n-\t    case 8:\n+\t\tcase 8:\n #ifdef HAVE_AS_IX86_FILDQ\n-\t      putc ('q', file);\n+\t\t  putc ('q', file);\n #else\n-\t      fputs (\"ll\", file);\n+\t\t  fputs (\"ll\", file);\n #endif\n-\t      return;\n+\t\t  return;\n \n-\t    default:\n-\t      gcc_unreachable ();\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \t    }\n-\t    \n-\tcase 'z':\n-\t  /* 387 opcodes don't get size suffixes if the operands are\n-\t     registers.  */\n-\t  if (STACK_REG_P (x))\n-\t    return;\n-\n-\t  /* Likewise if using Intel opcodes.  */\n-\t  if (ASSEMBLER_DIALECT == ASM_INTEL)\n-\t    return;\n-\n-\t  /* This is the size of op from size of operand.  */\n-\t  switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t  else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n \t    {\n-\t    case 1:\n-\t      putc ('b', file);\n-\t      return;\n+\t      /* 387 opcodes don't get size suffixes\n+\t\t if the operands are registers.  */\n+\t      if (STACK_REG_P (x))\n+\t\treturn;\n \n-\t    case 2:\n-\t      /* ??? This fails for HImode integer\n-\t\t operator with memory operand.  */\n-\t      if (MEM_P (x))\n+\t      switch (GET_MODE_SIZE (GET_MODE (x)))\n \t\t{\n-#ifdef HAVE_AS_IX86_FILDS\n+\t\tcase 4:\n \t\t  putc ('s', file);\n-#endif\n \t\t  return;\n-\t\t}\n-\t      else\n-\t\tputc ('w', file);\n-\t      return;\n \n-\t    case 4:\n-\t      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t\tputc ('l', file);\n-\t      else\n-\t\tputc ('s', file);\n-\t      return;\n+\t\tcase 8:\n+\t\t  putc ('l', file);\n+\t\t  return;\n \n-\t    case 8:\n-\t      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t\tputc ('q', file);\n-\t      else\n-\t        putc ('l', file);\n-\t      return;\n+\t\tcase 12:\n+\t\tcase 16:\n+\t\t  putc ('t', file);\n+\t\t  return;\n \n-\t    case 12:\n-\t    case 16:\n-\t      putc ('t', file);\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      output_operand_lossage\n+\t\t(\"invalid operand type used with operand code '%c'\", code);\n \t      return;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n \t    }\n \n+\t  output_operand_lossage\n+\t    (\"invalid operand size for operand code '%c'\", code);\n+\t  return;\n+\t    \n \tcase 'd':\n \tcase 'b':\n \tcase 'w':\n@@ -11833,7 +11853,7 @@ output_387_binary_op (rtx insn, rtx *operands)\n \n       if (MEM_P (operands[2]))\n \t{\n-\t  p = \"%z2\\t%2\";\n+\t  p = \"%Z2\\t%2\";\n \t  break;\n \t}\n \n@@ -11863,13 +11883,13 @@ output_387_binary_op (rtx insn, rtx *operands)\n     case DIV:\n       if (MEM_P (operands[1]))\n \t{\n-\t  p = \"r%z1\\t%1\";\n+\t  p = \"r%Z1\\t%1\";\n \t  break;\n \t}\n \n       if (MEM_P (operands[2]))\n \t{\n-\t  p = \"%z2\\t%2\";\n+\t  p = \"%Z2\\t%2\";\n \t  break;\n \t}\n \n@@ -12241,13 +12261,13 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n \n       static const char * const alt[16] =\n       {\n-\t\"fcom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fcomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fucom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fucomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fcom%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fcomp%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fucom%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fucomp%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n \n-\t\"ficom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"ficomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"ficom%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"ficomp%Z2\\t%y2\\n\\tfnstsw\\t%0\",\n \tNULL,\n \tNULL,\n \n@@ -28782,22 +28802,22 @@ output_387_reg_move (rtx insn, rtx *operands)\n \t  return \"fstp\\t%y0\";\n \t}\n       if (STACK_TOP_P (operands[0]))\n-\treturn \"fld%z1\\t%y1\";\n+\treturn \"fld%Z1\\t%y1\";\n       return \"fst\\t%y0\";\n     }\n   else if (MEM_P (operands[0]))\n     {\n       gcc_assert (REG_P (operands[1]));\n       if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n-\treturn \"fstp%z0\\t%y0\";\n+\treturn \"fstp%Z0\\t%y0\";\n       else\n \t{\n \t  /* There is no non-popping store to memory for XFmode.\n \t     So if we need one, follow the store with a load.  */\n \t  if (GET_MODE (operands[0]) == XFmode)\n-\t    return \"fstp%z0\\t%y0\\n\\tfld%z0\\t%y0\";\n+\t    return \"fstp%Z0\\t%y0\\n\\tfld%Z0\\t%y0\";\n \t  else\n-\t    return \"fst%z0\\t%y0\";\n+\t    return \"fst%Z0\\t%y0\";\n \t}\n     }\n   else"}, {"sha": "29794313716757ba9a678c060846f04489124ba5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b91322f2ba88548f5137cea907c85cd74b0b90a8", "patch": "@@ -36,7 +36,7 @@\n ;;      otherwise nothing\n ;; R -- print the prefix for register names.\n ;; z -- print the opcode suffix for the size of the current operand.\n-;; Z -- likewise, with special suffixes for fild/fist instructions.\n+;; Z -- likewise, with special suffixes for x87 instructions.\n ;; * -- print a star (in certain assembler syntax)\n ;; A -- print an absolute memory reference.\n ;; w -- print the operand as if it's a \"word\" (HImode) even if it isn't."}, {"sha": "91e2337fc7179aea4995c872707737c6b6146150", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b91322f2ba88548f5137cea907c85cd74b0b90a8", "patch": "@@ -1,3 +1,9 @@\n+2009-04-28  Uros Bizjak  <ubizjak@gmail.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/39911\n+\t* gcc.target/i386/pr39911.c: New test.\n+\n 2009-04-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/39879\n@@ -24,7 +30,8 @@\n \t* gcc.dg/Wconversion-real.c: Require large_double.\n \t* gcc.dg/cdce1.c: Require large_double instead of checking targets.\n \n-\t* gcc.c-torture/execute/ieee/unsafe-fp-assoc-1.c: Skip if doubles are too small.\n+\t* gcc.c-torture/execute/ieee/unsafe-fp-assoc-1.c: Skip if doubles\n+\tare too small.\n \n \t* gcc.c-torture/execute/ieee/20010226-1.c: Mark all floating point\n \tconstants as long."}, {"sha": "fe63ff005fec46a5517d209b5ebd0536af397722", "filename": "gcc/testsuite/gcc.target/i386/pr39911.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39911.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b91322f2ba88548f5137cea907c85cd74b0b90a8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39911.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39911.c?ref=b91322f2ba88548f5137cea907c85cd74b0b90a8", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O2\" } */\n+\n+void \n+bar1 () \n+{\n+  char foo;\n+  asm volatile (\"mov%z0 %1, %0\": \"=m\" (foo): \"iq\" (-23));\n+  asm volatile (\"add%z0 %1, %0\": \"+m\" (foo): \"iq\" (23));\n+  asm volatile (\"mov%z0 %1, %0\": \"=q\" (foo): \"iq\" (-23));\n+  asm volatile (\"add%z0 %1, %0\": \"+q\" (foo): \"iq\" (23));\n+}\n+\n+void\n+bar2 () \n+{\n+  short foo;\n+  asm volatile (\"mov%z0 %1, %0\": \"=m\" (foo): \"ir\" (-23));\n+  asm volatile (\"add%z0 %1, %0\": \"+m\" (foo): \"ir\" (23));\n+  asm volatile (\"mov%z0 %1, %0\": \"=r\" (foo): \"ir\" (-23));\n+  asm volatile (\"add%z0 %1, %0\": \"+r\" (foo): \"ir\" (23));\n+\n+  asm volatile (\"pop%z0 %0\": \"=m\" (foo));\n+  asm volatile (\"pop%z0 %0\": \"=r\" (foo));\n+}\n+\n+void\n+bar3 () \n+{\n+  int foo;\n+  asm volatile (\"mov%z0 %1, %0\": \"=m\" (foo): \"ir\" (-23));\n+  asm volatile (\"add%z0 %1, %0\": \"+m\" (foo): \"ir\" (23));\n+  asm volatile (\"mov%z0 %1, %0\": \"=r\" (foo): \"ir\" (-23));\n+  asm volatile (\"add%z0 %1, %0\": \"+r\" (foo): \"ir\" (23));\n+\n+  if (sizeof (void *) == sizeof (int))\n+    {\n+      asm volatile (\"pop%z0 %0\": \"=m\" (foo));\n+      asm volatile (\"pop%z0 %0\": \"=r\" (foo));\n+    }\n+}\n+\n+void\n+bar4 () \n+{\n+  if (sizeof (void *) == sizeof (long long))\n+    {\n+      long long foo;\n+      asm volatile (\"mov%z0 %1, %0\": \"=m\" (foo): \"er\" (-23));\n+      asm volatile (\"add%z0 %1, %0\": \"+m\" (foo): \"er\" (23));\n+      asm volatile (\"mov%z0 %1, %0\": \"=r\" (foo): \"er\" (-23));\n+      asm volatile (\"add%z0 %1, %0\": \"+r\" (foo): \"er\" (23));\n+\n+      asm volatile (\"pop%z0 %0\": \"=m\" (foo));\n+      asm volatile (\"pop%z0 %0\": \"=r\" (foo));\n+    }\n+}"}]}