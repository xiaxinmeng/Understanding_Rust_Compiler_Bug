{"sha": "5dc22714565caf136771deefa4e59a0fa9967750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRjMjI3MTQ1NjVjYWYxMzY3NzFkZWVmYTRlNTlhMGZhOTk2Nzc1MA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-03-26T02:19:10Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-03-26T02:19:10Z"}, "message": "[multiple changes]\n\n2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/bits/unordered_map.h (operator==, operator!=): Add per N3068.\n\t* include/bits/unordered_set.h (operator==, operator!=): Likewise.\n\t* include/debug/unordered_map (operator==, operator!=): Likewise.\n\t* include/debug/unordered_set: Likewise.\n\t* include/profile/unordered_map: Likewise.\n\t* include/profile/unordered_set: Likewise.\n\t* testsuite/23_containers/unordered_map/operators/1.cc: New.\n\t* testsuite/23_containers/unordered_multimap/operators/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/operators/2.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/operators/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/operators/1.cc: Likewise.\n\n2010-03-25  John Lakos  <jlakos@bloomberg.net>\n\t    Pablo Halpern  <phalpern@halpernwightsoftware.com>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/bits/hashtable_policy.h (struct _Equality_base): Add.\n\t* include/bits/hashtable.h (_Hashtable<>): Derive from the latter.\n\nFrom-SVN: r157736", "tree": {"sha": "06a7073a79a6845868ab73273d19c6bb49d0db35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a7073a79a6845868ab73273d19c6bb49d0db35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dc22714565caf136771deefa4e59a0fa9967750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc22714565caf136771deefa4e59a0fa9967750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dc22714565caf136771deefa4e59a0fa9967750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc22714565caf136771deefa4e59a0fa9967750/comments", "author": null, "committer": null, "parents": [{"sha": "5cefd11aee2c0556d2288dc59d8c9fbccc12fc4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cefd11aee2c0556d2288dc59d8c9fbccc12fc4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cefd11aee2c0556d2288dc59d8c9fbccc12fc4e"}], "stats": {"total": 1040, "additions": 1026, "deletions": 14}, "files": [{"sha": "5bd9f95f604e796ac4bb6f5a38ba0f6f1dd16b46", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -1,3 +1,24 @@\n+2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/bits/unordered_map.h (operator==, operator!=): Add per N3068.\n+\t* include/bits/unordered_set.h (operator==, operator!=): Likewise.\n+\t* include/debug/unordered_map (operator==, operator!=): Likewise.\n+\t* include/debug/unordered_set: Likewise.\n+\t* include/profile/unordered_map: Likewise.\n+\t* include/profile/unordered_set: Likewise.\n+\t* testsuite/23_containers/unordered_map/operators/1.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/operators/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/operators/2.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/operators/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/operators/1.cc: Likewise.\n+\n+2010-03-25  John Lakos  <jlakos@bloomberg.net>\n+\t    Pablo Halpern  <phalpern@halpernwightsoftware.com>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/bits/hashtable_policy.h (struct _Equality_base): Add.\n+\t* include/bits/hashtable.h (_Hashtable<>): Derive from the latter.\n+\n 2010-03-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/util/testsuite_tr1.h (NType, TType, SLType, PODType): Add."}, {"sha": "c7aceb19f8e7c3342552ccbfd8c80a58d1a92b8f", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -118,7 +118,15 @@ namespace std\n \t\t\t\t\t    _RehashPolicy,\n \t\t\t\t\t    __cache_hash_code,\n \t\t\t\t\t    __constant_iterators,\n-\t\t\t\t\t    __unique_keys> >\n+\t\t\t\t\t    __unique_keys> >,\n+      public __detail::_Equality_base<_ExtractKey, __unique_keys,\n+\t\t\t\t      _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t\t _ExtractKey,\n+\t\t\t\t\t\t _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t\t _RehashPolicy,\n+\t\t\t\t\t\t __cache_hash_code,\n+\t\t\t\t\t\t __constant_iterators,\n+\t\t\t\t\t\t __unique_keys> >\n     {\n     public:\n       typedef _Allocator                                  allocator_type;"}, {"sha": "6e6a8fb0177e727d02e29f62f7dd3ad2d6276ec1", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 134, "deletions": 13, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -484,24 +484,24 @@ namespace __detail\n       return std::make_pair(false, 0);\n   }\n \n-  // Base classes for std::tr1::_Hashtable.  We define these base\n-  // classes because in some cases we want to do different things\n-  // depending on the value of a policy class.  In some cases the\n-  // policy class affects which member functions and nested typedefs\n-  // are defined; we handle that by specializing base class templates.\n-  // Several of the base class templates need to access other members\n-  // of class template _Hashtable, so we use the \"curiously recurring\n-  // template pattern\" for them.\n-\n-  // class template _Map_base.  If the hashtable has a value type of the\n-  // form pair<T1, T2> and a key extraction policy that returns the\n+  // Base classes for std::_Hashtable.  We define these base classes\n+  // because in some cases we want to do different things depending\n+  // on the value of a policy class.  In some cases the policy class\n+  // affects which member functions and nested typedefs are defined;\n+  // we handle that by specializing base class templates.  Several of\n+  // the base class templates need to access other members of class\n+  // template _Hashtable, so we use the \"curiously recurring template\n+  // pattern\" for them.\n+\n+  // class template _Map_base.  If the hashtable has a value type of\n+  // the form pair<T1, T2> and a key extraction policy that returns the\n   // first part of the pair, the hashtable gets a mapped_type typedef.\n   // If it satisfies those criteria and also has unique keys, then it\n   // also gets an operator[].  \n   template<typename _Key, typename _Value, typename _Ex, bool __unique,\n \t   typename _Hashtable>\n     struct _Map_base { };\n-\t  \n+\n   template<typename _Key, typename _Pair, typename _Hashtable>\n     struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>\n     {\n@@ -512,7 +512,7 @@ namespace __detail\n     struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>\n     {\n       typedef typename _Pair::second_type mapped_type;\n-      \n+\n       mapped_type&\n       operator[](const _Key& __k);\n \n@@ -832,6 +832,127 @@ namespace __detail\n       _H1          _M_h1;\n       _H2          _M_h2;\n     };\n+\n+\n+  // Class template _Equality_base.  This is for implementing equality\n+  // comparison for unordered containers, per N3068, by John Lakos and\n+  // Pablo Halpern.  Algorithmically, we follow closely the reference\n+  // implementations therein.\n+  template<typename _ExtractKey, bool __unique_keys,\n+\t   typename _Hashtable>\n+    struct _Equality_base;\n+\n+  template<typename _ExtractKey, typename _Hashtable>\n+    struct _Equality_base<_ExtractKey, true, _Hashtable>\n+    {\n+      bool _M_equal(const _Hashtable&) const;\n+    };\n+\n+  template<typename _ExtractKey, typename _Hashtable>\n+    bool\n+    _Equality_base<_ExtractKey, true, _Hashtable>::\n+    _M_equal(const _Hashtable& __other) const\n+    {\n+      const _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+\n+      if (__this->size() != __other.size())\n+\treturn false;\n+\n+      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)\n+\t{\n+\t  const auto __ity = __other.find(_ExtractKey()(*__itx));\n+\t  if (__ity == __other.end() || *__ity != *__itx)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  template<typename _ExtractKey, typename _Hashtable>\n+    struct _Equality_base<_ExtractKey, false, _Hashtable>\n+    {\n+      bool _M_equal(const _Hashtable&) const;\n+\n+    private:\n+      template<typename _Uiterator>\n+        static bool\n+        _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);\n+    };\n+\n+  // See std::is_permutation in N3068.\n+  template<typename _ExtractKey, typename _Hashtable>\n+    template<typename _Uiterator>\n+      bool\n+      _Equality_base<_ExtractKey, false, _Hashtable>::\n+      _S_is_permutation(_Uiterator __first1, _Uiterator __last1,\n+\t\t\t_Uiterator __first2)\n+      {\n+\tfor (; __first1 != __last1; ++__first1, ++__first2)\n+\t  if (!(*__first1 == *__first2))\n+\t    break;\n+\n+\tif (__first1 == __last1)\n+\t  return true;\n+\n+\t_Uiterator __last2 = __first2;\n+\tstd::advance(__last2, std::distance(__first1, __last1));\n+\n+\tfor (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)\n+\t  {\n+\t    _Uiterator __tmp =  __first1;\n+\t    while (__tmp != __it1 && !(*__tmp == *__it1))\n+\t      ++__tmp;\n+\n+\t    // We've seen this one before.\n+\t    if (__tmp != __it1)\n+\t      continue;\n+\n+\t    std::ptrdiff_t __n2 = 0;\n+\t    for (__tmp = __first2; __tmp != __last2; ++__tmp)\n+\t      if (*__tmp == *__it1)\n+\t\t++__n2;\n+\n+\t    if (!__n2)\n+\t      return false;\n+\n+\t    std::ptrdiff_t __n1 = 0;\n+\t    for (__tmp = __it1; __tmp != __last1; ++__tmp)\n+\t      if (*__tmp == *__it1)\n+\t\t++__n1;\n+\n+\t    if (__n1 != __n2)\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+\n+  template<typename _ExtractKey, typename _Hashtable>\n+    bool\n+    _Equality_base<_ExtractKey, false, _Hashtable>::\n+    _M_equal(const _Hashtable& __other) const\n+    {\n+      const _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+\n+      if (__this->size() != __other.size())\n+\treturn false;\n+\n+      for (auto __itx = __this->begin(); __itx != __this->end();)\n+\t{\n+\t  const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));\n+\t  const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));\n+\n+\t  if (std::distance(__xrange.first, __xrange.second)\n+\t      != std::distance(__yrange.first, __yrange.second))\n+\t    return false;\n+\n+\t  if (!_S_is_permutation(__xrange.first,\n+\t\t\t\t __xrange.second,\n+\t\t\t\t __yrange.first))\n+\t    return false;\n+\n+\t  __itx = __xrange.second;\n+\t}\n+      return true;\n+    }\n } // namespace __detail\n }\n "}, {"sha": "74998ff7725670f0668378674b09468026dd0adb", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -159,6 +159,41 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t _Alloc, __cache_hash_code>& __y)\n     { __x.swap(__y); }\n \n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator==(const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator!=(const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return !(__x == __y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator==(const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator!=(const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return !(__x == __y); }\n \n   /**\n    *  @brief A standard container composed of unique keys (containing\n@@ -335,6 +370,30 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _UNORDERED_MAP_H */"}, {"sha": "50dee215e16b4baa33d4c5fbb18f664500cffc7e", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -155,6 +155,41 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t _Alloc, __cache_hash_code>& __y)\n     { __x.swap(__y); }\n \n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator==(const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator!=(const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_set<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return !(__x == __y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator==(const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n+    inline bool\n+    operator!=(const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __x,\n+\t       const __unordered_multiset<_Value, _Hash, _Pred, _Alloc,\n+\t       __cache_hash_code>& __y)\n+    { return !(__x == __y); }\n \n   /**\n    *  @brief A standard container composed of unique keys (containing\n@@ -325,6 +360,30 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    inline bool\n+    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _UNORDERED_SET_H */"}, {"sha": "6fef1e970577a929dfb5b9dc423419586b9b135e", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -287,6 +287,20 @@ namespace __debug\n \t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n \n   /// Class std::unordered_multimap with safety/checking/debug instrumentation.\n   template<typename _Key, typename _Tp,\n@@ -524,6 +538,20 @@ namespace __debug\n \t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n } // namespace __debug\n } // namespace std\n "}, {"sha": "09329b00367301df860d8789eedfaf0bcb33a722", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -286,6 +286,18 @@ namespace __debug\n \t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n \n   /// Class std::unordered_multiset with safety/checking/debug instrumentation.\n   template<typename _Value,\n@@ -521,6 +533,18 @@ namespace __debug\n \t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n } // namespace __debug\n } // namespace std\n "}, {"sha": "b9e67873d95614e5560763676217aa40ed295352", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -272,6 +272,20 @@ namespace __profile\n \t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n #undef _GLIBCXX_BASE\n #undef _GLIBCXX_STD_BASE\n #define _GLIBCXX_BASE unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n@@ -482,6 +496,20 @@ namespace __profile\n \t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n } // namespace __profile\n } // namespace std\n "}, {"sha": "6dcdc8373986cb474f344a106c38b5efb362949e", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -262,6 +262,18 @@ namespace __profile\n \t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n #undef _GLIBCXX_BASE\n #undef _GLIBCXX_STD_BASE\n #define _GLIBCXX_STD_BASE _GLIBCXX_STD_PR::_GLIBCXX_BASE\n@@ -474,6 +486,18 @@ namespace __profile\n \t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_equal(__y); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return !(__x == __y); }\n+\n } // namespace __profile\n } // namespace std\n "}, {"sha": "f5e68dea79d37afb4aa9afa01282f4287ac8dc19", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/operators/1.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperators%2F1.cc?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -0,0 +1,169 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::pair<const int, int> Pair;\n+  std::unordered_map<int, int> um1, um2;\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(2, -1));\n+  um2.insert(Pair(2, -1));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(3, -3));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um2.insert(Pair(3, -3));\n+  VERIFY( (um1 == um2) );\n+  VERIFY( !(um1 != um2) );\n+\n+  um2.clear();\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.clear();\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(2, -2));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(2, -2));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(3, -3));\n+  um2.insert(Pair(4, -4));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(4, -4));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um2.insert(Pair(3, -3));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(4, -4));\n+  um2.insert(Pair(4, -4));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.clear();\n+  um2.clear();\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -2));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.clear();\n+  um2.clear();\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(2, -2));\n+  um2.insert(Pair(2, -3));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(2, -3));\n+  um2.insert(Pair(2, -2));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.clear();\n+  um2.clear();\n+  VERIFY( um1 == um2 );\n+  VERIFY( !(um1 != um2) );\n+\n+  um1.insert(Pair(2, -2));\n+  um2.insert(Pair(2, -3));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(2, -3));\n+  um2.insert(Pair(2, -2));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -1));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  um1.insert(Pair(1, -1));\n+  um2.insert(Pair(1, -2));\n+  VERIFY( um1 != um2 );\n+  VERIFY( !(um1 == um2) );\n+\n+  const std::unordered_map<int, int> cum1(um1), cum2(um2);\n+  VERIFY( cum1 != cum2 );\n+  VERIFY( !(cum1 == cum2) );\n+  VERIFY( cum1 != um2 );\n+  VERIFY( !(um1 == cum2) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f6e21f8b845ad68259468eecc36f19b9b3f9f52c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/operators/1.cc", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperators%2F1.cc?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -0,0 +1,192 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::pair<const int, int> Pair;\n+  std::unordered_multimap<int, int> umm1, umm2;\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(2, -1));\n+  umm2.insert(Pair(2, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(3, -3));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm2.insert(Pair(3, -3));\n+  VERIFY( (umm1 == umm2) );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm2.clear();\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.clear();\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(2, -2));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(2, -2));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(3, -3));\n+  umm2.insert(Pair(4, -4));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(4, -4));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm2.insert(Pair(3, -3));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(4, -4));\n+  umm2.insert(Pair(4, -4));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.clear();\n+  umm2.clear();\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -2));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.clear();\n+  umm2.clear();\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(2, -2));\n+  umm2.insert(Pair(2, -3));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(2, -3));\n+  umm2.insert(Pair(2, -2));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.clear();\n+  umm2.clear();\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(2, -2));\n+  umm2.insert(Pair(2, -3));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(2, -3));\n+  umm2.insert(Pair(2, -2));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  umm1.insert(Pair(1, -1));\n+  umm2.insert(Pair(1, -2));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(3, -3));\n+  umm2.insert(Pair(3, -3));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(3, -4));\n+  umm2.insert(Pair(3, -3));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm1.insert(Pair(3, -3));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+ \n+  umm1.insert(Pair(1, -2));\n+  umm2.insert(Pair(1, -1));\n+  VERIFY( umm1 != umm2 );\n+  VERIFY( !(umm1 == umm2) );\n+\n+  umm2.insert(Pair(3, -4));\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  const std::unordered_multimap<int, int> cumm1(umm1), cumm2(umm2);\n+  VERIFY( cumm1 == cumm2 );\n+  VERIFY( !(cumm1 != cumm2) );\n+  VERIFY( cumm1 == umm2 );\n+  VERIFY( !(umm1 != cumm2) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1121dbc520012a2072f99a8e45e2b704b12f274a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/operators/2.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Foperators%2F2.cc?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::pair<const int, int> Pair;\n+  std::unordered_multimap<int, int> umm1, umm2;\n+  VERIFY( umm1 == umm2 );\n+  VERIFY( !(umm1 != umm2) );\n+\n+  int second1[] = { -1, -2, -3, -4, -5 };\n+  int second2[] = { -1, -2, -3, -4, -5 };\n+  const unsigned size = sizeof(second1) / sizeof(int);\n+\n+  for (unsigned perm1 = 0; perm1 < 120; ++perm1)\n+    {\n+      umm1.clear();\n+      std::next_permutation(second1, second1 + size);\n+      for (unsigned i1 = 0; i1 < size; ++i1)\n+\tumm1.insert(Pair(0, second1[i1]));\n+\n+      for (unsigned perm2 = 0; perm2 < 120; ++perm2)\n+\t{\n+\t  umm2.clear();\n+\t  std::next_permutation(second2, second2 + size);\n+\t  for (unsigned i2 = 0; i2 < size; ++i2)\n+\t    umm2.insert(Pair(0, second2[i2]));\n+\n+\t  VERIFY( umm1 == umm2 );\n+\t  VERIFY( !(umm1 != umm2) );\n+\t}\n+    }\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3e3b1c762fbc72ade5335647221b8ab6c94dc1ec", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/operators/1.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Foperators%2F1.cc?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_multiset<int> ums1, ums2;\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(1);\n+  ums2.insert(1);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(2);\n+  ums2.insert(2);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(1);\n+  ums2.insert(1);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(3);\n+  VERIFY( ums1 != ums2 );\n+  VERIFY( !(ums1 == ums2) );\n+\n+  ums2.insert(3);\n+  VERIFY( (ums1 == ums2) );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums2.clear();\n+  VERIFY( ums1 != ums2 );\n+  VERIFY( !(ums1 == ums2) );\n+\n+  ums1.clear();\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(1);\n+  ums2.insert(2);\n+  VERIFY( ums1 != ums2 );\n+  VERIFY( !(ums1 == ums2) );\n+\n+  ums1.insert(2);\n+  ums2.insert(1);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(3);\n+  ums2.insert(4);\n+  VERIFY( ums1 != ums2 );\n+  VERIFY( !(ums1 == ums2) );\n+\n+  ums1.insert(4);\n+  VERIFY( ums1 != ums2 );\n+  VERIFY( !(ums1 == ums2) );\n+\n+  ums2.insert(3);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(1);\n+  ums2.insert(1);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  ums1.insert(4);\n+  ums2.insert(4);\n+  VERIFY( ums1 == ums2 );\n+  VERIFY( !(ums1 != ums2) );\n+\n+  const std::unordered_multiset<int> cums1(ums1), cums2(ums2);\n+  VERIFY( cums1 == cums2 );\n+  VERIFY( !(cums1 != cums2) );\n+  VERIFY( cums1 == ums2 );\n+  VERIFY( !(ums1 != cums2) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "63e726d047356c7367fa227ec12f255512b9dbef", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/operators/1.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc22714565caf136771deefa4e59a0fa9967750/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Foperators%2F1.cc?ref=5dc22714565caf136771deefa4e59a0fa9967750", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-03-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_set<int> us1, us2;\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(1);\n+  us2.insert(1);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(2);\n+  us2.insert(2);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(1);\n+  us2.insert(1);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(3);\n+  VERIFY( us1 != us2 );\n+  VERIFY( !(us1 == us2) );\n+\n+  us2.insert(3);\n+  VERIFY( (us1 == us2) );\n+  VERIFY( !(us1 != us2) );\n+\n+  us2.clear();\n+  VERIFY( us1 != us2 );\n+  VERIFY( !(us1 == us2) );\n+\n+  us1.clear();\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(1);\n+  us2.insert(2);\n+  VERIFY( us1 != us2 );\n+  VERIFY( !(us1 == us2) );\n+\n+  us1.insert(2);\n+  us2.insert(1);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(3);\n+  us2.insert(4);\n+  VERIFY( us1 != us2 );\n+  VERIFY( !(us1 == us2) );\n+\n+  us1.insert(4);\n+  VERIFY( us1 != us2 );\n+  VERIFY( !(us1 == us2) );\n+\n+  us2.insert(3);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(1);\n+  us2.insert(1);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  us1.insert(4);\n+  us2.insert(4);\n+  VERIFY( us1 == us2 );\n+  VERIFY( !(us1 != us2) );\n+\n+  const std::unordered_set<int> cus1(us1), cus2(us2);\n+  VERIFY( cus1 == cus2 );\n+  VERIFY( !(cus1 != cus2) );\n+  VERIFY( cus1 == us2 );\n+  VERIFY( !(us1 != cus2) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}