{"sha": "f0699540f37e2550974f9049778a42a634062c0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA2OTk1NDBmMzdlMjU1MDk3NGY5MDQ5Nzc4YTQyYTYzNDA2MmMwYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-08-05T10:00:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-08-05T10:04:18Z"}, "message": "Make genmatch transform failure handling more consistent\n\nCurrently whether a fail during the transform stage is fatal or\nwhether following patterns are still considers is a bit random\ndepending on whether the pattern is wrapped in a for for example.\nThe follwing makes it consistent by replacing early returns with\ngotos to the end of the pattern processing.\n\n2020-08-05  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (fail_label): New global.\n\t(expr::gen_transform): Branch to fail_label instead of\n\treturning.  Fix indent of call argument checking.\n\t(dt_simplify::gen_1): Compute and emit fail_label, branch\n\tto it instead of returning early.", "tree": {"sha": "4b2bf40f27ee4dce0a05d0b68082c20c02988699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b2bf40f27ee4dce0a05d0b68082c20c02988699"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0699540f37e2550974f9049778a42a634062c0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0699540f37e2550974f9049778a42a634062c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0699540f37e2550974f9049778a42a634062c0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0699540f37e2550974f9049778a42a634062c0b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3abfb84e2a7ca115b0550c32308b5ada3e6a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f3abfb84e2a7ca115b0550c32308b5ada3e6a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f3abfb84e2a7ca115b0550c32308b5ada3e6a46"}], "stats": {"total": 44, "additions": 29, "deletions": 15}, "files": [{"sha": "107f6f2ec9ee97cfaaceb7ede88c8c3198cf811f", "filename": "gcc/genmatch.c", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0699540f37e2550974f9049778a42a634062c0b/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0699540f37e2550974f9049778a42a634062c0b/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=f0699540f37e2550974f9049778a42a634062c0b", "patch": "@@ -2352,6 +2352,10 @@ capture_info::walk_c_expr (c_expr *e)\n }\n \n \n+/* The current label failing the current matched pattern during\n+   code generation.  */\n+static char *fail_label;\n+\n /* Code generation off the decision tree and the refered AST nodes.  */\n \n bool\n@@ -2527,8 +2531,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n \t\t      \"_r%d = maybe_push_res_to_seq (&tem_op, %s);\\n\", depth,\n \t\t      !force_leaf ? \"lseq\" : \"NULL\");\n       fprintf_indent (f, indent,\n-\t\t      \"if (!_r%d) return false;\\n\",\n-\t\t      depth);\n+\t\t      \"if (!_r%d) goto %s;\\n\",\n+\t\t      depth, fail_label);\n       if (*opr == CONVERT_EXPR)\n \t{\n \t  indent -= 4;\n@@ -2560,7 +2564,7 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       if (opr->kind != id_base::CODE)\n \t{\n \t  fprintf_indent (f, indent, \"  if (!_r%d)\\n\", depth);\n-\t  fprintf_indent (f, indent, \"    return NULL_TREE;\\n\");\n+\t  fprintf_indent (f, indent, \"    goto %s;\\n\", fail_label);\n \t  fprintf_indent (f, indent, \"}\\n\");\n \t}\n       if (*opr == CONVERT_EXPR)\n@@ -3068,12 +3072,12 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple, int depth,\n \t      /* We need to be defensive against bogus prototypes allowing\n \t\t calls with not enough arguments.  */\n \t      fprintf_indent (f, indent,\n-\t\t\t      \"  if (gimple_call_num_args (_c%d) == %d)\\n\"\n-\t\t\t      \"    {\\n\", depth, e->ops.length ());\n+\t\t\t      \"  if (gimple_call_num_args (_c%d) == %d)\\n\",\n+\t\t\t      depth, e->ops.length ());\n+\t      fprintf_indent (f, indent, \"    {\\n\");\n \t      fns[i]->gen (f, indent + 6, true, depth);\n-\t      fprintf_indent (f, indent,\n-\t\t\t      \"    }\\n\"\n-\t\t\t      \"  break;\\n\");\n+\t      fprintf_indent (f, indent, \"    }\\n\");\n+\t      fprintf_indent (f, indent, \"  break;\\n\");\n \t    }\n \n \t  fprintf_indent (f, indent, \"default:;\\n\");\n@@ -3278,6 +3282,11 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t}\n     }\n \n+  static unsigned fail_label_cnt;\n+  char local_fail_label[256];\n+  snprintf (local_fail_label, 256, \"next_after_fail%u\", ++fail_label_cnt);\n+  fail_label = local_fail_label;\n+\n   /* Analyze captures and perform early-outs on the incoming arguments\n      that cover cases we cannot handle.  */\n   capture_info cinfo (s, result, gimple);\n@@ -3289,8 +3298,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t    if (cinfo.force_no_side_effects & (1 << i))\n \t      {\n \t\tfprintf_indent (f, indent,\n-\t\t\t\t\"if (TREE_SIDE_EFFECTS (_p%d)) return NULL_TREE;\\n\",\n-\t\t\t\ti);\n+\t\t\t\t\"if (TREE_SIDE_EFFECTS (_p%d)) goto %s;\\n\",\n+\t\t\t\ti, fail_label);\n \t\tif (verbose >= 1)\n \t\t  warning_at (as_a <expr *> (s->match)->ops[i]->location,\n \t\t\t      \"forcing toplevel operand to have no \"\n@@ -3305,7 +3314,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t      {\n \t\tfprintf_indent (f, indent,\n \t\t\t\t\"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n-\t\t\t\t\"return NULL_TREE;\\n\", i);\n+\t\t\t\t\"goto %s;\\n\", i, fail_label);\n \t\tif (verbose >= 1)\n \t\t  warning_at (cinfo.info[i].c->location,\n \t\t\t      \"forcing captured operand to have no \"\n@@ -3348,8 +3357,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n     }\n \n   if (s->kind == simplify::SIMPLIFY)\n-    fprintf_indent (f, indent, \"if (__builtin_expect (!dbg_cnt (match), 0)) return %s;\\n\",\n-\t\t    gimple ? \"false\" : \"NULL_TREE\");\n+    fprintf_indent (f, indent, \"if (__builtin_expect (!dbg_cnt (match), 0)) goto %s;\\n\", fail_label);\n \n   fprintf_indent (f, indent, \"if (__builtin_expect (dump_file && (dump_flags & TDF_FOLDING), 0)) \"\n \t   \"fprintf (dump_file, \\\"%s \",\n@@ -3361,6 +3369,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t\t true);\n   fprintf (f, \", __FILE__, __LINE__);\\n\");\n \n+  fprintf_indent (f, indent, \"{\\n\");\n+  indent += 2;\n   if (!result)\n     {\n       /* If there is no result then this is a predicate implementation.  */\n@@ -3474,7 +3484,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t    > cinfo.info[i].match_use_count)\n \t\t  fprintf_indent (f, indent,\n \t\t\t\t  \"if (! tree_invariant_p (captures[%d])) \"\n-\t\t\t\t  \"return NULL_TREE;\\n\", i);\n+\t\t\t\t  \"goto %s;\\n\", i, fail_label);\n \t      }\n \t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t    {\n@@ -3524,7 +3534,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t  if (!is_a <operator_id *> (opr))\n \t\t    {\n \t\t      fprintf_indent (f, indent, \"if (!_r)\\n\");\n-\t\t      fprintf_indent (f, indent, \"  return NULL_TREE;\\n\");\n+\t\t      fprintf_indent (f, indent, \"  goto %s;\\n\", fail_label);\n \t\t    }\n \t\t}\n \t    }\n@@ -3563,6 +3573,10 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t  fprintf_indent (f, indent, \"return _r;\\n\");\n \t}\n     }\n+  indent -= 2;\n+  fprintf_indent (f, indent, \"}\\n\");\n+  fprintf (f, \"%s:;\\n\", fail_label);\n+  fail_label = NULL;\n }\n \n /* Generate code for the '(if ...)', '(with ..)' and actual transform"}]}