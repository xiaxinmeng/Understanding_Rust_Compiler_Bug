{"sha": "141719a8d7441a64d057e5095e7c96c19cf2aa7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQxNzE5YThkNzQ0MWE2NGQwNTdlNTA5NWU3Yzk2YzE5Y2YyYWE3ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-21T12:06:53Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-21T12:06:53Z"}, "message": "x\n\nFrom-SVN: r13339", "tree": {"sha": "f075334643348fce480f1e4b050189c675bb48f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f075334643348fce480f1e4b050189c675bb48f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/141719a8d7441a64d057e5095e7c96c19cf2aa7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141719a8d7441a64d057e5095e7c96c19cf2aa7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/141719a8d7441a64d057e5095e7c96c19cf2aa7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141719a8d7441a64d057e5095e7c96c19cf2aa7e/comments", "author": null, "committer": null, "parents": [{"sha": "1bf2b2d2a86ccae42e47a88be0c3cae16ecf352f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf2b2d2a86ccae42e47a88be0c3cae16ecf352f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf2b2d2a86ccae42e47a88be0c3cae16ecf352f"}], "stats": {"total": 208, "additions": 134, "deletions": 74}, "files": [{"sha": "eaf24c28fff79272cac1490daa109b13eb557268", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141719a8d7441a64d057e5095e7c96c19cf2aa7e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141719a8d7441a64d057e5095e7c96c19cf2aa7e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=141719a8d7441a64d057e5095e7c96c19cf2aa7e", "patch": "@@ -4976,6 +4976,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n   long gp_offset;\n   long fp_offset;\n   long end_offset;\n+  rtx insn;\n \n   if (frame_pointer_needed && !BITSET_P (mask, FRAME_POINTER_REGNUM - GP_REG_FIRST))\n     abort ();\n@@ -5019,9 +5020,10 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  if (file == (FILE *)0)\n \t    {\n \t      if (TARGET_LONG64)\n-\t\temit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n \t      else\n-\t\temit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n \t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n@@ -5037,11 +5039,13 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  base_offset  = gp_offset;\n \t  if (file == (FILE *)0)\n \t    {\n-\t      emit_move_insn (base_reg_rtx, GEN_INT (gp_offset));\n+\t      insn = emit_move_insn (base_reg_rtx, GEN_INT (gp_offset));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t      if (TARGET_LONG64)\n-\t\temit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n \t      else\n-\t\temit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n \t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\t%s\\t%s,%s,%s\\n\",\n@@ -5067,7 +5071,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n \t\t  if (store_p)\n \t\t    {\n-\t\t      rtx insn = emit_move_insn (mem_rtx, reg_rtx);\n+\t\t      insn = emit_move_insn (mem_rtx, reg_rtx);\n \t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t\t    }\n \t\t  else if (!TARGET_ABICALLS || mips_abi != ABI_32\n@@ -5133,9 +5137,10 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  if (file == (FILE *)0)\n \t    {\n \t      if (TARGET_LONG64)\n-\t\temit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n \t      else\n-\t\temit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n \t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n@@ -5151,11 +5156,13 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  base_offset  = fp_offset;\n \t  if (file == (FILE *)0)\n \t    {\n-\t      emit_move_insn (base_reg_rtx, GEN_INT (fp_offset));\n+\t      insn = emit_move_insn (base_reg_rtx, GEN_INT (fp_offset));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t      if (TARGET_LONG64)\n-\t\temit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n \t      else\n-\t\temit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n \t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\t%s\\t%s,%s,%s\\n\",\n@@ -5183,7 +5190,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n \t\t  if (store_p)\n \t\t    {\n-\t\t      rtx insn = emit_move_insn (mem_rtx, reg_rtx);\n+\t\t      insn = emit_move_insn (mem_rtx, reg_rtx);\n \t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t\t    }\n \t\t  else\n@@ -5416,7 +5423,8 @@ mips_expand_prologue ()\n \t  if (tsize > 32767)\n \t    {\n \t      tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n-\t      emit_move_insn (tmp_rtx, tsize_rtx);\n+\t      insn = emit_move_insn (tmp_rtx, tsize_rtx);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t      tsize_rtx = tmp_rtx;\n \t    }\n "}, {"sha": "811977c15f770c7e83b9709917d1430a7b59b4de", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 113, "deletions": 61, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141719a8d7441a64d057e5095e7c96c19cf2aa7e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141719a8d7441a64d057e5095e7c96c19cf2aa7e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=141719a8d7441a64d057e5095e7c96c19cf2aa7e", "patch": "@@ -3940,16 +3940,29 @@ dwarf2out_frame_debug (insn)\n   char *label;\n   rtx src, dest;\n   long offset;\n+\n+  /* The current rule for calculating the DWARF2 canonical frame address.  */\n   static unsigned cfa_reg;\n   static long cfa_offset;\n-  static long cfa_sp_offset;\n+\n+  /* The register used for saving registers to the stack, and its offset\n+     from the CFA.  */\n+  static unsigned cfa_store_reg;\n+  static long cfa_store_offset;\n+\n+  /* A temporary register used in adjusting SP or setting up the store_reg.  */\n+  static unsigned cfa_temp_reg;\n+  static long cfa_temp_value;\n \n   if (insn == NULL_RTX)\n     {\n       /* Set up state for generating call frame debug info.  */\n       cfa_reg = STACK_POINTER_REGNUM;\n       cfa_offset = 0;\n-      cfa_sp_offset = 0;\n+      cfa_store_reg = STACK_POINTER_REGNUM;\n+      cfa_store_offset = 0;\n+      cfa_temp_reg = -1;\n+      cfa_temp_value = 0;\n       return;\n     }\n \n@@ -3966,26 +3979,57 @@ dwarf2out_frame_debug (insn)\n     case REG:\n       /* Update the CFA rule wrt SP or FP.  Make sure src is\n \t relative to the current CFA register.  */\n-      assert (REGNO (dest) == STACK_POINTER_REGNUM\n-\t      || frame_pointer_needed && REGNO (dest) == FRAME_POINTER_REGNUM);\n       switch (GET_CODE (src))\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n \t  assert (cfa_reg == REGNO (src));\n+\t  assert (REGNO (dest) == STACK_POINTER_REGNUM\n+\t\t  || frame_pointer_needed && REGNO (dest) == FRAME_POINTER_REGNUM);\n \t  cfa_reg = REGNO (dest);\n \t  break;\n \n-\t  /* Adjusting SP.  */\n \tcase PLUS:\n-\t  cfa_sp_offset -= INTVAL (XEXP (src, 1));\n-\t  goto add;\n \tcase MINUS:\n-\t  cfa_sp_offset += INTVAL (XEXP (src, 1));\n-\tadd:\n-\t  assert (REGNO (XEXP (src, 0)) == STACK_POINTER_REGNUM);\n-\t  if (cfa_reg == STACK_POINTER_REGNUM)\n-\t    cfa_offset = cfa_sp_offset;\n+\t  if (dest == stack_pointer_rtx)\n+\t    {\n+\t      /* Adjusting SP.  */\n+\t      switch (GET_CODE (XEXP (src, 1)))\n+\t\t{\n+\t\tcase CONST_INT:\n+\t\t  offset = INTVAL (XEXP (src, 1));\n+\t\t  break;\n+\t\tcase REG:\n+\t\t  assert (REGNO (XEXP (src, 1)) == cfa_temp_reg);\n+\t\t  offset = cfa_temp_value;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t      if (GET_CODE (src) == PLUS)\n+\t\toffset = -offset;\n+\t      if (cfa_reg == STACK_POINTER_REGNUM)\n+\t\tcfa_offset += offset;\n+\t      if (cfa_store_reg == STACK_POINTER_REGNUM)\n+\t\tcfa_store_offset += offset;\n+\t      assert (XEXP (src, 0) == stack_pointer_rtx);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Initializing the store base register.  */\n+\t      assert (GET_CODE (src) == PLUS);\n+\t      assert (XEXP (src, 1) == stack_pointer_rtx);\n+\t      assert (GET_CODE (XEXP (src, 0)) == REG\n+\t\t      && REGNO (XEXP (src, 0)) == cfa_temp_reg);\n+\t      assert (cfa_store_reg == STACK_POINTER_REGNUM);\n+\t      cfa_store_reg = REGNO (dest);\n+\t      cfa_store_offset -= cfa_temp_value;\n+\t    }\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  cfa_temp_reg = REGNO (dest);\n+\t  cfa_temp_value = INTVAL (src);\n \t  break;\n \n \tdefault:\n@@ -4001,27 +4045,27 @@ dwarf2out_frame_debug (insn)\n       switch (GET_CODE (XEXP (dest, 0)))\n \t{\n \t  /* With a push.  */\n-\tcase PRE_DEC:\n-\t  cfa_sp_offset += GET_MODE_SIZE (GET_MODE (dest));\n-\t  goto pre;\n \tcase PRE_INC:\n-\t  cfa_sp_offset -= GET_MODE_SIZE (GET_MODE (dest));\n-\tpre:\n+\tcase PRE_DEC:\n+\t  offset = GET_MODE_SIZE (GET_MODE (dest));\n+\t  if (GET_CODE (src) == PRE_INC)\n+\t    offset = -offset;\n \t  assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM);\n+\t  assert (cfa_store_reg == STACK_POINTER_REGNUM);\n+\t  cfa_store_offset += offset;\n \t  if (cfa_reg == STACK_POINTER_REGNUM)\n-\t    cfa_offset = cfa_sp_offset;\n-\t  offset = -cfa_sp_offset;\n+\t    cfa_offset = cfa_store_offset;\n+\t  offset = -cfa_store_offset;\n \t  break;\n \n \t  /* With an offset.  */\n \tcase PLUS:\n-\t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n-\t  goto off;\n \tcase MINUS:\n-\t  offset = -INTVAL (XEXP (XEXP (dest, 0), 1));\n-\toff:\n-\t  assert (cfa_reg == REGNO (XEXP (XEXP (dest, 0), 0)));\n-\t  offset -= cfa_offset;\n+\t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+\t  if (GET_CODE (src) == MINUS)\n+\t    offset = -offset;\n+\t  assert (cfa_store_reg == REGNO (XEXP (XEXP (dest, 0), 0)));\n+\t  offset -= cfa_store_offset;\n \t  break;\n \n \tdefault:\n@@ -6000,12 +6044,12 @@ add_bound_info (subrange_die, bound_attr, bound)\n     /* All fixed-bounds are represented by INTEGER_CST nodes.        */\n     case INTEGER_CST:\n       bound_value = TREE_INT_CST_LOW (bound);\n-      /* TODO: we need to check for C language below, or some flag\n-\t derived from the language.  C implies a lower bound of 0.   */\n-      if (!(bound_attr == DW_AT_lower_bound && bound_value == 0))\n-\t{\n-\t  add_AT_unsigned (subrange_die, bound_attr, bound_value);\n-        }\n+      if (bound_attr == DW_AT_lower_bound\n+\t  && ((is_c_family () && bound_value == 0)\n+\t      || (is_fortran () && bound_value == 1)))\n+\t/* use the default */;\n+      else\n+\tadd_AT_unsigned (subrange_die, bound_attr, bound_value);\n       break;\n \n     /* Dynamic bounds may be represented by NOP_EXPR nodes containing\n@@ -6015,34 +6059,45 @@ add_bound_info (subrange_die, bound_attr, bound)\n       /* ... fall thru...  */\n \n     case SAVE_EXPR:\n+      /* Handle the simple case of `int ar[i];'.  */\n+      if (bound_attr == DW_AT_upper_bound && is_c_family ()\n+\t  && TREE_CODE (TREE_OPERAND (bound, 0)) == MINUS_EXPR)\n+\t{\n+\t  tree t = TREE_OPERAND (bound, 0);\n+\t  if (integer_onep (TREE_OPERAND (bound, 1)))\n+\t    t = TREE_OPERAND (t, 0);\n+\t  if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+\t    {\n+\t      add_AT_die_ref (subrange_die, DW_AT_count, lookup_decl_die (t));\n+\t      return;\n+\t    }\n+\t}\n+\n       /* If optimization is turned on, the SAVE_EXPRs that describe how to\n          access the upper bound values are essentially bogus. They only\n          describe (at best) how to get at these values at the points in the\n-         generated code right after they have just been computed.  Worse yet, \n-         in the typical case, the upper bound values will not even *be*\n-         computed in the optimized code, so these SAVE_EXPRs are entirely\n-         bogus. In order to compensate for this fact, we check here to see if\n-         optimization is enabled, and if so, we effectively create an empty\n-         location description for the (unknown and unknowable) upper bound.\n-         This should not cause too much trouble for existing (stupid?)\n-         debuggers because they have to deal with empty upper bounds location\n-         descriptions anyway in order to be able to deal with incomplete array \n-         types.  Of course an intelligent debugger (GDB?) should be able to\n-         comprehend that a missing upper bound specification in a array type\n-         used for a storage class `auto' local array variable indicates that\n-         the upper bound is both unknown (at compile- time) and unknowable (at\n-         run-time) due to optimization.  */\n+         generated code right after they have just been computed.  Worse\n+         yet, in the typical case, the upper bound values will not even\n+         *be* computed in the optimized code, so these SAVE_EXPRs are\n+         entirely bogus. In order to compensate for this fact, we check\n+         here to see if optimization is enabled, and if so, we don't add an\n+         attribute for the (unknown and unknowable) upper bound.  This\n+         should not cause too much trouble for existing (stupid?)\n+         debuggers because they have to deal with empty upper bounds\n+         location descriptions anyway in order to be able to deal with\n+         incomplete array types.  Of course an intelligent debugger (GDB?)\n+         should be able to comprehend that a missing upper bound\n+         specification in a array type used for a storage class `auto'\n+         local array variable indicates that the upper bound is both\n+         unknown (at compile- time) and unknowable (at run-time) due to\n+         optimization.  */\n       if (!optimize)\n \t{\n-\t  bound_loc = mem_loc_descriptor (\n-\t\t\t\t      eliminate_regs (SAVE_EXPR_RTL (bound),\n-\t\t\t\t\t\t      0, NULL_RTX));\n+\t  bound_loc = mem_loc_descriptor\n+\t    (eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));\n+\t  add_AT_loc (subrange_die, bound_attr, bound_loc);\n \t}\n-      else\n-\t{\n-\t  bound_loc = NULL;\n-\t}\n-      add_AT_loc (subrange_die, bound_attr, bound_loc);\n+      /* else leave out the attribute.  */\n       break;\n \n     default:\n@@ -6096,8 +6151,7 @@ add_subscript_info (type_die, type)\n \t    add_type_attribute (subrange_die, TREE_TYPE (domain), 0, 0,\n \t\t\t\ttype_die);\n \n-\t  if (! is_c_family () && ! is_fortran ())\n-\t    add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n+\t  add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n \t  add_bound_info (subrange_die, DW_AT_upper_bound, upper);\n \t}\n       else\n@@ -6741,9 +6795,8 @@ gen_formal_parameter_die (node, context_die)\n \t  if (DECL_ARTIFICIAL (node))\n \t    add_AT_flag (parm_die, DW_AT_artificial, 1);\n \t}\n-      if (DECL_ABSTRACT (node))\n-\tequate_decl_number_to_die (node, parm_die);\n-      else\n+      equate_decl_number_to_die (node, parm_die);\n+      if (! DECL_ABSTRACT (node))\n \tadd_location_or_const_value_attribute (parm_die, node);\n       break;\n \n@@ -7117,7 +7170,7 @@ gen_variable_die (decl, context_die)\n     {\n       add_abstract_origin_attribute (var_die, origin);\n     }\n-  else if (old_die)\n+  else if (old_die && TREE_STATIC (decl))\n     {\n       assert (get_AT_flag (old_die, DW_AT_declaration) == 1);\n       add_AT_die_ref (var_die, DW_AT_specification, old_die);\n@@ -7157,8 +7210,7 @@ gen_variable_die (decl, context_die)\n \n   if (! declaration && ! DECL_ABSTRACT (decl))\n     {\n-      if (TREE_STATIC (decl))\n-\tequate_decl_number_to_die (decl, var_die);\n+      equate_decl_number_to_die (decl, var_die);\n       add_location_or_const_value_attribute (var_die, decl);\n       add_pubname (decl, var_die);\n     }"}]}