{"sha": "201312c254f778e19ac9407874217ddbe83d2aa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAxMzEyYzI1NGY3NzhlMTlhYzk0MDc4NzQyMTdkZGJlODNkMmFhNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-13T19:11:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-13T19:11:35Z"}, "message": "Makefile.in (insn-preds.o): Depend on TREE_H.\n\n        * Makefile.in (insn-preds.o): Depend on TREE_H.\n        * genpreds.c (write_insn_preds_c): Include tree.h.\n        * config/alpha/alpha.c (reg_or_0_operand, reg_or_6bit_operand,\n        reg_or_8bit_operand, cint8_operand, add_operand, sext_add_operand,\n        const48_operand, and_operand, or_operand, mode_width_operand,\n        mode_mask_operand, mul8_operand, const0_operand,\n        hard_fp_register_operand, hard_int_register_operand,\n        reg_or_cint_operand, some_operand, some_ni_operand, input_operand,\n        samegp_function_operand, direct_call_operand, small_symbolic_operand,\n        global_symbolic_operand, call_operand, symbolic_operand,\n        dtp16_symbolic_operand, dtp32_symbolic_operand,\n        gotdtp_symbolic_operand, tp16_symbolic_operand, tp32_symbolic_operand,\n        gottp_symbolic_operand, alpha_comparison_operator,\n        alpha_zero_comparison_operator, alpha_swapped_comparison_operator,\n        signed_comparison_operator, alpha_fp_comparison_operator,\n        divmod_operator, fix_operator, aligned_memory_operand,\n        unaligned_memory_operand, reg_or_unaligned_mem_operand,\n        any_memory_operand, reg_not_elim_operand, normal_memory_operand,\n        reg_no_subreg_operand, addition_operation): Move to predicates.md.\n        (reg_or_const_int_operand): Remove.  Replace all users with\n        reg_or_cint_operand.\n        (tls_symbolic_operand_1): Export.  Don't check mode or for CONST.\n        (resolve_reload_operand): Split out of aligned_memory_operand.\n        * config/alpha/alpha-protos.h: Update for exports.\n        * config/alpha/alpha.h (PREDICATE_CODES): Remove.\n        * config/alpha/alpha.md: Include predicates.md.\n        * config/alpha/predicates.md: New file.\n\nFrom-SVN: r85953", "tree": {"sha": "ce0557eff8d18b82b01391444564ca92f0df5fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce0557eff8d18b82b01391444564ca92f0df5fe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/201312c254f778e19ac9407874217ddbe83d2aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201312c254f778e19ac9407874217ddbe83d2aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/201312c254f778e19ac9407874217ddbe83d2aa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201312c254f778e19ac9407874217ddbe83d2aa5/comments", "author": null, "committer": null, "parents": [{"sha": "73389fa4a2ec749ef646627ef69c6245a8d862a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73389fa4a2ec749ef646627ef69c6245a8d862a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73389fa4a2ec749ef646627ef69c6245a8d862a4"}], "stats": {"total": 1515, "additions": 614, "deletions": 901}, "files": [{"sha": "f6376e36f7ffa3c8f9fd43fd8b537dde3fa7dafe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -1,3 +1,33 @@\n+2004-08-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (insn-preds.o): Depend on TREE_H.\n+\t* genpreds.c (write_insn_preds_c): Include tree.h.\n+\t* config/alpha/alpha.c (reg_or_0_operand, reg_or_6bit_operand,\n+\treg_or_8bit_operand, cint8_operand, add_operand, sext_add_operand,\n+\tconst48_operand, and_operand, or_operand, mode_width_operand,\n+\tmode_mask_operand, mul8_operand, const0_operand,\n+\thard_fp_register_operand, hard_int_register_operand,\n+\treg_or_cint_operand, some_operand, some_ni_operand, input_operand,\n+\tsamegp_function_operand, direct_call_operand, small_symbolic_operand,\n+\tglobal_symbolic_operand, call_operand, symbolic_operand, \n+\tdtp16_symbolic_operand, dtp32_symbolic_operand,\n+\tgotdtp_symbolic_operand, tp16_symbolic_operand, tp32_symbolic_operand,\n+\tgottp_symbolic_operand, alpha_comparison_operator,\n+\talpha_zero_comparison_operator, alpha_swapped_comparison_operator,\n+\tsigned_comparison_operator, alpha_fp_comparison_operator,\n+\tdivmod_operator, fix_operator, aligned_memory_operand,\n+\tunaligned_memory_operand, reg_or_unaligned_mem_operand,\n+\tany_memory_operand, reg_not_elim_operand, normal_memory_operand,\n+\treg_no_subreg_operand, addition_operation): Move to predicates.md.\n+\t(reg_or_const_int_operand): Remove.  Replace all users with\n+\treg_or_cint_operand.\n+\t(tls_symbolic_operand_1): Export.  Don't check mode or for CONST.\n+\t(resolve_reload_operand): Split out of aligned_memory_operand.\n+\t* config/alpha/alpha-protos.h: Update for exports.\n+\t* config/alpha/alpha.h (PREDICATE_CODES): Remove.\n+\t* config/alpha/alpha.md: Include predicates.md.\n+\t* config/alpha/predicates.md: New file.\n+\n 2004-08-13  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* genattrtab.c (insn_ent): Replace insn_code, insn_index and lineno"}, {"sha": "1358b01546499bfbf70da6592d9487d85cd46354", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -2350,8 +2350,8 @@ s-preds: $(md_file) genpreds$(build_exeext)\n \t$(STAMP) s-preds\n \n insn-preds.o : insn-preds.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-  $(RTL_H) insn-config.h $(RECOG_H) real.h output.h $(FLAGS_H)  function.h \\\n-  hard-reg-set.h $(RESOURCE_H) $(TM_P_H) toplev.h reload.h\n+  $(RTL_H) $(TREE_H) insn-config.h $(RECOG_H) real.h output.h $(FLAGS_H) \\\n+  function.h hard-reg-set.h $(RESOURCE_H) $(TM_P_H) toplev.h reload.h\n \n GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(CPP_ID_DATA_H) $(host_xm_file_list) \\"}, {"sha": "f8fded816ed1b89535dc86c58c44ad32d9e9bfd3", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -121,3 +121,7 @@ extern char * unicosmk_data_section (void);\n extern void unicosmk_output_common (FILE *, const char *, int, int);\n extern int unicosmk_initial_elimination_offset (int, int);\n #endif\n+\n+extern int some_small_symbolic_operand (rtx, enum machine_mode);\n+extern int tls_symbolic_operand_1 (rtx, int, int);\n+extern rtx resolve_reload_operand (rtx);"}, {"sha": "d9dc759107049bfa17ea2ba66e920f8b8ef4df1c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 12, "deletions": 835, "changes": 847, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -519,527 +519,12 @@ zap_mask (HOST_WIDE_INT value)\n   return 1;\n }\n \n-/* Returns 1 if OP is either the constant zero or a register.  If a\n-   register, it must be in the proper mode unless MODE is VOIDmode.  */\n+/* Return true if OP is valid for a particular TLS relocation. \n+   We are already guaranteed that OP is a CONST.  */\n \n int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n+tls_symbolic_operand_1 (rtx op, int size, int unspec)\n {\n-  return op == CONST0_RTX (mode) || register_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a constant in the range of 0-63 (for a shift) or\n-   any register.  */\n-\n-int\n-reg_or_6bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 64)\n-\t  || register_operand (op, mode));\n-}\n-\n-\n-/* Return 1 if OP is an 8-bit constant or any register.  */\n-\n-int\n-reg_or_8bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 0x100)\n-\t  || register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a constant or any register.  */\n-\n-int\n-reg_or_const_int_operand (rtx op, enum machine_mode mode)\n-{\n-  return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is an 8-bit constant.  */\n-\n-int\n-cint8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 0x100));\n-}\n-\n-/* Return 1 if the operand is a valid second operand to an add insn.  */\n-\n-int\n-add_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    /* Constraints I, J, O and P are covered by K.  */\n-    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'K')\n-\t    || CONST_OK_FOR_LETTER_P (INTVAL (op), 'L'));\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if the operand is a valid second operand to a sign-extending\n-   add insn.  */\n-\n-int\n-sext_add_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n-\t    || CONST_OK_FOR_LETTER_P (INTVAL (op), 'O'));\n-\n-  return reg_not_elim_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is the constant 4 or 8.  */\n-\n-int\n-const48_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) == 4 || INTVAL (op) == 8));\n-}\n-\n-/* Return 1 if OP is a valid first operand to an AND insn.  */\n-\n-int\n-and_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == VOIDmode)\n-    return (zap_mask (CONST_DOUBLE_LOW (op))\n-\t    && zap_mask (CONST_DOUBLE_HIGH (op)));\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return ((unsigned HOST_WIDE_INT) INTVAL (op) < 0x100\n-\t    || (unsigned HOST_WIDE_INT) ~ INTVAL (op) < 0x100\n-\t    || zap_mask (INTVAL (op)));\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a valid first operand to an IOR or XOR insn.  */\n-\n-int\n-or_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return ((unsigned HOST_WIDE_INT) INTVAL (op) < 0x100\n-\t    || (unsigned HOST_WIDE_INT) ~ INTVAL (op) < 0x100);\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a constant that is the width, in bits, of an integral\n-   mode smaller than DImode.  */\n-\n-int\n-mode_width_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) == 8 || INTVAL (op) == 16\n-\t      || INTVAL (op) == 32 || INTVAL (op) == 64));\n-}\n-\n-/* Return 1 if OP is a constant that is the width of an integral machine mode\n-   smaller than an integer.  */\n-\n-int\n-mode_mask_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (op);\n-\n-      if (value == 0xff)\n-\treturn 1;\n-      if (value == 0xffff)\n-\treturn 1;\n-      if (value == 0xffffffff)\n-\treturn 1;\n-      if (value == -1)\n-\treturn 1;\n-    }\n-  else if (HOST_BITS_PER_WIDE_INT == 32 && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      if (CONST_DOUBLE_LOW (op) == 0xffffffff && CONST_DOUBLE_HIGH (op) == 0)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return 1 if OP is a multiple of 8 less than 64.  */\n-\n-int\n-mul8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (unsigned HOST_WIDE_INT) INTVAL (op) < 64\n-\t  && (INTVAL (op) & 7) == 0);\n-}\n-\n-/* Return 1 if OP is the zero constant for MODE.  */\n-\n-int\n-const0_operand (rtx op, enum machine_mode mode)\n-{\n-  return op == CONST0_RTX (mode);\n-}\n-\n-/* Return 1 if OP is a hard floating-point register.  */\n-\n-int\n-hard_fp_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return GET_CODE (op) == REG && REGNO_REG_CLASS (REGNO (op)) == FLOAT_REGS;\n-}\n-\n-/* Return 1 if OP is a hard general register.  */\n-\n-int\n-hard_int_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return GET_CODE (op) == REG && REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS;\n-}\n-\n-/* Return 1 if OP is a register or a constant integer.  */\n-\n-\n-int\n-reg_or_cint_operand (rtx op, enum machine_mode mode)\n-{\n-     return (GET_CODE (op) == CONST_INT\n-\t     || register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is something that can be reloaded into a register;\n-   if it is a MEM, it need not be valid.  */\n-\n-int\n-some_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case REG:\n-    case MEM:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST:\n-    case HIGH:\n-      return 1;\n-\n-    case SUBREG:\n-      return some_operand (SUBREG_REG (op), VOIDmode);\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Likewise, but don't accept constants.  */\n-\n-int\n-some_ni_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  return (GET_CODE (op) == REG || GET_CODE (op) == MEM);\n-}\n-\n-/* Return 1 if OP is a valid operand for the source of a move insn.  */\n-\n-int\n-input_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT && GET_MODE (op) != mode)\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST:\n-      if (TARGET_EXPLICIT_RELOCS)\n-\t{\n-\t  /* We don't split symbolic operands into something unintelligable\n-\t     until after reload, but we do not wish non-small, non-global\n-\t     symbolic operands to be reconstructed from their high/lo_sum\n-\t     form.  */\n-\t  return (small_symbolic_operand (op, mode)\n-\t\t  || global_symbolic_operand (op, mode)\n-\t\t  || gotdtp_symbolic_operand (op, mode)\n-\t\t  || gottp_symbolic_operand (op, mode));\n-\t}\n-\n-      /* This handles both the Windows/NT and OSF cases.  */\n-      return mode == ptr_mode || mode == DImode;\n-\n-    case HIGH:\n-      return (TARGET_EXPLICIT_RELOCS\n-\t      && local_symbolic_operand (XEXP (op, 0), mode));\n-\n-    case REG:\n-      return 1;\n-\n-    case SUBREG:\n-      if (register_operand (op, mode))\n-\treturn 1;\n-      /* ... fall through ...  */\n-    case MEM:\n-      return ((TARGET_BWX || (mode != HImode && mode != QImode))\n-\t      && general_operand (op, mode));\n-\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-      return op == CONST0_RTX (mode);\n-\n-    case CONST_INT:\n-      return mode == QImode || mode == HImode || add_operand (op, mode);\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return 1 if OP is a SYMBOL_REF for a function known to be in this\n-   file, and in the same section as the current function.  */\n-\n-int\n-samegp_function_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != SYMBOL_REF)\n-    return false;\n-\n-  /* Easy test for recursion.  */\n-  if (op == XEXP (DECL_RTL (current_function_decl), 0))\n-    return true;\n-\n-  /* Functions that are not local can be overridden, and thus may\n-     not share the same gp.  */\n-  if (! SYMBOL_REF_LOCAL_P (op))\n-    return false;\n-\n-  /* If -msmall-data is in effect, assume that there is only one GP\n-     for the module, and so any local symbol has this property.  We\n-     need explicit relocations to be able to enforce this for symbols\n-     not defined in this unit of translation, however.  */\n-  if (TARGET_EXPLICIT_RELOCS && TARGET_SMALL_DATA)\n-    return true;\n-\n-  /* Functions that are not external are defined in this UoT,\n-     and thus must share the same gp.  */\n-  return ! SYMBOL_REF_EXTERNAL_P (op);\n-}\n-\n-/* Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.  */\n-\n-int\n-direct_call_operand (rtx op, enum machine_mode mode)\n-{\n-  tree op_decl, cfun_sec, op_sec;\n-\n-  /* Must share the same GP.  */\n-  if (!samegp_function_operand (op, mode))\n-    return false;\n-\n-  /* If profiling is implemented via linker tricks, we can't jump\n-     to the nogp alternate entry point.  Note that current_function_profile\n-     would not be correct, since that doesn't indicate if the target\n-     function uses profiling.  */\n-  /* ??? TARGET_PROFILING_NEEDS_GP isn't really the right test,\n-     but is approximately correct for the OSF ABIs.  Don't know\n-     what to do for VMS, NT, or UMK.  */\n-  if (!TARGET_PROFILING_NEEDS_GP && profile_flag)\n-    return false;\n-\n-  /* Must be a function.  In some cases folks create thunks in static\n-     data structures and then make calls to them.  If we allow the\n-     direct call, we'll get an error from the linker about !samegp reloc\n-     against a symbol without a .prologue directive.  */\n-  if (!SYMBOL_REF_FUNCTION_P (op))\n-    return false;\n-  \n-  /* Must be \"near\" so that the branch is assumed to reach.  With\n-     -msmall-text, this is assumed true of all local symbols.  Since\n-     we've already checked samegp, locality is already assured.  */\n-  if (TARGET_SMALL_TEXT)\n-    return true;\n-\n-  /* Otherwise, a decl is \"near\" if it is defined in the same section.  */\n-  if (flag_function_sections)\n-    return false;\n-\n-  op_decl = SYMBOL_REF_DECL (op);\n-  if (DECL_ONE_ONLY (current_function_decl)\n-      || (op_decl && DECL_ONE_ONLY (op_decl)))\n-    return false;\n-\n-  cfun_sec = DECL_SECTION_NAME (current_function_decl);\n-  op_sec = op_decl ? DECL_SECTION_NAME (op_decl) : NULL;\n-  return ((!cfun_sec && !op_sec)\n-\t  || (cfun_sec && op_sec\n-\t      && strcmp (TREE_STRING_POINTER (cfun_sec),\n-\t\t         TREE_STRING_POINTER (op_sec)) == 0));\n-}\n-\n-/* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n-   a (non-tls) variable known to be defined in this file.  */\n-\n-int\n-local_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == LABEL_REF)\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n-    op = XEXP (XEXP (op, 0), 0);\n-\n-  if (GET_CODE (op) != SYMBOL_REF)\n-    return 0;\n-\n-  return SYMBOL_REF_LOCAL_P (op) && !SYMBOL_REF_TLS_MODEL (op);\n-}\n-\n-/* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n-   known to be defined in this file in the small data area.  */\n-\n-int\n-small_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (! TARGET_SMALL_DATA)\n-    return 0;\n-\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n-    op = XEXP (XEXP (op, 0), 0);\n-\n-  if (GET_CODE (op) != SYMBOL_REF)\n-    return 0;\n-\n-  /* ??? There's no encode_section_info equivalent for the rtl\n-     constant pool, so SYMBOL_FLAG_SMALL never gets set.  */\n-  if (CONSTANT_POOL_ADDRESS_P (op))\n-    return GET_MODE_SIZE (get_pool_mode (op)) <= g_switch_value;\n-\n-  return (SYMBOL_REF_LOCAL_P (op)\n-\t  && SYMBOL_REF_SMALL_P (op)\n-\t  && SYMBOL_REF_TLS_MODEL (op) == 0);\n-}\n-\n-/* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n-   not known (or known not) to be defined in this file.  */\n-\n-int\n-global_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n-    op = XEXP (XEXP (op, 0), 0);\n-\n-  if (GET_CODE (op) != SYMBOL_REF)\n-    return 0;\n-\n-  return !SYMBOL_REF_LOCAL_P (op) && !SYMBOL_REF_TLS_MODEL (op);\n-}\n-\n-/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n-\n-int\n-call_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != Pmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == REG)\n-    {\n-      if (TARGET_ABI_OSF)\n-\t{\n-\t  /* Disallow virtual registers to cope with pathological test cases\n-\t     such as compile/930117-1.c in which the virtual reg decomposes\n-\t     to the frame pointer.  Which is a hard reg that is not $27.  */\n-\t  return (REGNO (op) == 27 || REGNO (op) > LAST_VIRTUAL_REGISTER);\n-\t}\n-      else\n-\treturn 1;\n-    }\n-  if (TARGET_ABI_UNICOSMK)\n-    return 0;\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n-   possibly with an offset.  */\n-\n-int\n-symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n-    return 1;\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op,0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (op,0), 1)) == CONST_INT)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Return true if OP is valid for a particular TLS relocation.  */\n-\n-static int\n-tls_symbolic_operand_1 (rtx op, enum machine_mode mode, int size, int unspec)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) != CONST)\n-    return 0;\n   op = XEXP (op, 0);\n \n   if (GET_CODE (op) != UNSPEC || XINT (op, 1) != unspec)\n@@ -1073,203 +558,12 @@ tls_symbolic_operand_1 (rtx op, enum machine_mode mode, int size, int unspec)\n     }\n }\n \n-/* Return true if OP is valid for 16-bit DTP relative relocations.  */\n-\n-int\n-dtp16_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  return tls_symbolic_operand_1 (op, mode, 16, UNSPEC_DTPREL);\n-}\n-\n-/* Return true if OP is valid for 32-bit DTP relative relocations.  */\n-\n-int\n-dtp32_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  return tls_symbolic_operand_1 (op, mode, 32, UNSPEC_DTPREL);\n-}\n-\n-/* Return true if OP is valid for 64-bit DTP relative relocations.  */\n-\n-int\n-gotdtp_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  return tls_symbolic_operand_1 (op, mode, 64, UNSPEC_DTPREL);\n-}\n-\n-/* Return true if OP is valid for 16-bit TP relative relocations.  */\n-\n-int\n-tp16_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  return tls_symbolic_operand_1 (op, mode, 16, UNSPEC_TPREL);\n-}\n-\n-/* Return true if OP is valid for 32-bit TP relative relocations.  */\n-\n-int\n-tp32_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  return tls_symbolic_operand_1 (op, mode, 32, UNSPEC_TPREL);\n-}\n-\n-/* Return true if OP is valid for 64-bit TP relative relocations.  */\n-\n-int\n-gottp_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  return tls_symbolic_operand_1 (op, mode, 64, UNSPEC_TPREL);\n-}\n-\n-/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n-   comparisons are valid in which insn.  */\n-\n-int\n-alpha_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  return (code == EQ || code == LE || code == LT\n-\t  || code == LEU || code == LTU);\n-}\n-\n-/* Return 1 if OP is a valid Alpha comparison operator against zero. \n-   Here we know which comparisons are valid in which insn.  */\n-\n-int\n-alpha_zero_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  return (code == EQ || code == NE || code == LE || code == LT\n-\t  || code == LEU || code == LTU);\n-}\n-\n-/* Return 1 if OP is a valid Alpha swapped comparison operator.  */\n-\n-int\n-alpha_swapped_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code;\n-\n-  if ((mode != GET_MODE (op) && mode != VOIDmode)\n-      || !COMPARISON_P (op))\n-    return 0;\n-\n-  code = swap_condition (GET_CODE (op));\n-  return (code == EQ || code == LE || code == LT\n-\t  || code == LEU || code == LTU);\n-}\n-\n-/* Return 1 if OP is a signed comparison operation.  */\n-\n-int\n-signed_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  return (code == EQ || code == NE\n-\t  || code == LE || code == LT\n-\t  || code == GE || code == GT);\n-}\n-\n-/* Return 1 if OP is a valid Alpha floating point comparison operator.\n-   Here we know which comparisons are valid in which insn.  */\n-\n-int\n-alpha_fp_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  return (code == EQ || code == LE || code == LT || code == UNORDERED);\n-}\n-\n-/* Return 1 if this is a divide or modulus operator.  */\n-\n-int\n-divmod_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  return (code == DIV || code == MOD || code == UDIV || code == UMOD);\n-}\n-\n-/* Return 1 if this is a float->int conversion operator.  */\n-\n-int\n-fix_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  return (code == FIX || code == UNSIGNED_FIX);\n-}\n-\n-/* Return 1 if this memory address is a known aligned register plus\n-   a constant.  It must be a valid address.  This means that we can do\n-   this as an aligned reference plus some offset.\n-\n-   Take into account what reload will do.  */\n-\n-int\n-aligned_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx base;\n-\n-  if (reload_in_progress)\n-    {\n-      rtx tmp = op;\n-      if (GET_CODE (tmp) == SUBREG)\n-\ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG\n-\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  op = reg_equiv_memory_loc[REGNO (tmp)];\n-\t  if (op == 0)\n-\t    return 0;\n-\t}\n-    }\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  if (MEM_ALIGN (op) >= 32)\n-    return 1;\n-  op = XEXP (op, 0);\n-\n-  /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n-     sorts of constructs.  Dig for the real base register.  */\n-  if (reload_in_progress\n-      && GET_CODE (op) == PLUS\n-      && GET_CODE (XEXP (op, 0)) == PLUS)\n-    base = XEXP (XEXP (op, 0), 0);\n-  else\n-    {\n-      if (! memory_address_p (mode, op))\n-\treturn 0;\n-      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n-    }\n-\n-  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) >= 32);\n-}\n-\n-/* Similar, but return 1 if OP is a MEM which is not alignable.  */\n+/* Used by aligned_memory_operand and unaligned_memory_operand to\n+   resolve what reload is going to do with OP if it's a register.  */\n \n-int\n-unaligned_memory_operand (rtx op, enum machine_mode mode)\n+rtx\n+resolve_reload_operand (rtx op)\n {\n-  rtx base;\n-\n   if (reload_in_progress)\n     {\n       rtx tmp = op;\n@@ -1283,128 +577,7 @@ unaligned_memory_operand (rtx op, enum machine_mode mode)\n \t    return 0;\n \t}\n     }\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  if (MEM_ALIGN (op) >= 32)\n-    return 0;\n-  op = XEXP (op, 0);\n-\n-  /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n-     sorts of constructs.  Dig for the real base register.  */\n-  if (reload_in_progress\n-      && GET_CODE (op) == PLUS\n-      && GET_CODE (XEXP (op, 0)) == PLUS)\n-    base = XEXP (XEXP (op, 0), 0);\n-  else\n-    {\n-      if (! memory_address_p (mode, op))\n-\treturn 0;\n-      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n-    }\n-\n-  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) < 32);\n-}\n-\n-/* Return 1 if OP is either a register or an unaligned memory location.  */\n-\n-int\n-reg_or_unaligned_mem_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode) || unaligned_memory_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */\n-\n-int\n-any_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == MEM\n-\t  || (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n-\t  || (reload_in_progress && GET_CODE (op) == REG\n-\t      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t  || (reload_in_progress && GET_CODE (op) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (op)) == REG\n-\t      && REGNO (SUBREG_REG (op)) >= FIRST_PSEUDO_REGISTER));\n-}\n-\n-/* Returns 1 if OP is not an eliminable register.\n-\n-   This exists to cure a pathological abort in the s8addq (et al) patterns,\n-\n-\tlong foo () { long t; bar(); return (long) &t * 26107; }\n-\n-   which run afoul of a hack in reload to cure a (presumably) similar\n-   problem with lea-type instructions on other targets.  But there is\n-   one of us and many of them, so work around the problem by selectively\n-   preventing combine from making the optimization.  */\n-\n-int\n-reg_not_elim_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx inner = op;\n-  if (GET_CODE (op) == SUBREG)\n-    inner = SUBREG_REG (op);\n-  if (inner == frame_pointer_rtx || inner == arg_pointer_rtx)\n-    return 0;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 is OP is a memory location that is not a reference (using\n-   an AND) to an unaligned location.  Take into account what reload\n-   will do.  */\n-\n-int\n-normal_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (reload_in_progress)\n-    {\n-      rtx tmp = op;\n-      if (GET_CODE (tmp) == SUBREG)\n-\ttmp = SUBREG_REG (tmp);\n-      if (GET_CODE (tmp) == REG\n-\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  op = reg_equiv_memory_loc[REGNO (tmp)];\n-\n-\t  /* This may not have been assigned an equivalent address if it will\n-\t     be eliminated.  In that case, it doesn't matter what we do.  */\n-\t  if (op == 0)\n-\t    return 1;\n-\t}\n-    }\n-\n-  return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) != AND;\n-}\n-\n-/* Accept a register, but not a subreg of any kind.  This allows us to\n-   avoid pathological cases in reload wrt data movement common in \n-   int->fp conversion.  */\n-\n-int\n-reg_no_subreg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-  return register_operand (op, mode);\n-}\n-\n-/* Recognize an addition operation that includes a constant.  Used to\n-   convince reload to canonize (plus (plus reg c1) c2) during register\n-   elimination.  */\n-\n-int\n-addition_operation (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-  if (GET_CODE (op) == PLUS\n-      && register_operand (XEXP (op, 0), mode)\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n-      && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op, 1)), 'K'))\n-    return 1;\n-  return 0;\n+  return op;\n }\n \n /* Implements CONST_OK_FOR_LETTER_P.  Return true if the value matches\n@@ -1984,6 +1157,10 @@ alpha_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n    small symbolic operand until after reload.  At which point we need\n    to replace (mem (symbol_ref)) with (mem (lo_sum $29 symbol_ref))\n    so that sched2 has the proper dependency information.  */\n+/* \n+  {\"some_small_symbolic_operand\", {SET, PARALLEL, PREFETCH, UNSPEC,\t\\\n+\t\t\t\t   UNSPEC_VOLATILE}},\n+*/\n \n static int\n some_small_symbolic_operand_1 (rtx *px, void *data ATTRIBUTE_UNUSED)"}, {"sha": "43cdfff7f2a825ffb5dcf25162e4e7f38b47499b", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -1609,68 +1609,11 @@ do {\t\t\t\t\t\t\\\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '/' || (CODE) == ',' || (CODE) == '-' || (CODE) == '~' \\\n    || (CODE) == '#' || (CODE) == '*' || (CODE) == '&' || (CODE) == '+')\n-\f\n+\n /* Print a memory address as an operand to reference that memory location.  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n   print_operand_address((FILE), (ADDR))\n-\n-/* Define the codes that are matched by predicates in alpha.c.  */\n-\n-#define PREDICATE_CODES \t\t\t\t\t\t\\\n-  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t\tCONST_VECTOR}},\t\t\t\t\t\\\n-  {\"reg_or_6bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"reg_or_const_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"cint8_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"sext_add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"const48_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"or_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"mode_mask_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"mul8_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"mode_width_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"alpha_comparison_operator\", {EQ, LE, LT, LEU, LTU}},\t\t\\\n-  {\"alpha_zero_comparison_operator\", {EQ, NE, LE, LT, LEU, LTU}},\t\\\n-  {\"alpha_swapped_comparison_operator\", {EQ, GE, GT, GEU, GTU}},\t\\\n-  {\"signed_comparison_operator\", {EQ, NE, LE, LT, GE, GT}},\t\t\\\n-  {\"alpha_fp_comparison_operator\", {EQ, LE, LT, UNORDERED}},\t\t\\\n-  {\"divmod_operator\", {DIV, MOD, UDIV, UMOD}},\t\t\t\t\\\n-  {\"fix_operator\", {FIX, UNSIGNED_FIX}},\t\t\t\t\\\n-  {\"const0_operand\", {CONST_INT, CONST_DOUBLE, CONST_VECTOR}},\t\t\\\n-  {\"samegp_function_operand\", {SYMBOL_REF}},\t\t\t\t\\\n-  {\"direct_call_operand\", {SYMBOL_REF}},\t\t\t\t\\\n-  {\"local_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n-  {\"small_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n-  {\"global_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n-  {\"dtp16_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n-  {\"dtp32_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n-  {\"gotdtp_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n-  {\"tp16_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n-  {\"tp32_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n-  {\"gottp_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n-  {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n-  {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     CONST_VECTOR, SYMBOL_REF, CONST, LABEL_REF, HIGH}},\\\n-  {\"some_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t    CONST_VECTOR, SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\\\n-  {\"some_ni_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"aligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"unaligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"reg_or_unaligned_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"any_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"normal_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"hard_fp_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"hard_int_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"reg_not_elim_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"reg_no_subreg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"addition_operation\", {PLUS}},\t\t\t\t\t\\\n-  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n-  {\"some_small_symbolic_operand\", {SET, PARALLEL, PREFETCH, UNSPEC,\t\\\n-\t\t\t\t   UNSPEC_VOLATILE}},\n \f\n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(valist, nextarg) \\"}, {"sha": "4efff7ca220d7d60498f5805ddb0052f6e64f80a", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -168,6 +168,12 @@\n (include \"ev4.md\")\n (include \"ev5.md\")\n (include \"ev6.md\")\n+\n+\f\n+;; Include predicate definitions\n+\n+(include \"predicates.md\")\n+\n \f\n ;; First define the arithmetic insns.  Note that the 32-bit forms also\n ;; sign-extend.\n@@ -7378,9 +7384,9 @@\n (define_expand \"builtin_zap\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(and:DI (unspec:DI\n-\t\t  [(match_operand:DI 2 \"reg_or_const_int_operand\" \"\")]\n+\t\t  [(match_operand:DI 2 \"reg_or_cint_operand\" \"\")]\n \t\t  UNSPEC_ZAP)\n-\t\t(match_operand:DI 1 \"reg_or_const_int_operand\" \"\")))]\n+\t\t(match_operand:DI 1 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -7410,9 +7416,9 @@\n (define_insn \"*builtin_zap_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r\")\n \t(and:DI (unspec:DI\n-\t\t  [(match_operand:QI 2 \"reg_or_const_int_operand\" \"n,n,r,r\")]\n+\t\t  [(match_operand:QI 2 \"reg_or_cint_operand\" \"n,n,r,r\")]\n \t\t  UNSPEC_ZAP)\n-\t\t(match_operand:DI 1 \"reg_or_const_int_operand\" \"n,r,J,r\")))]\n+\t\t(match_operand:DI 1 \"reg_or_cint_operand\" \"n,r,J,r\")))]\n   \"\"\n   \"@\n    #\n@@ -7471,9 +7477,9 @@\n (define_expand \"builtin_zapnot\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(and:DI (unspec:DI\n-\t\t  [(not:QI (match_operand:DI 2 \"reg_or_const_int_operand\" \"\"))]\n+\t\t  [(not:QI (match_operand:DI 2 \"reg_or_cint_operand\" \"\"))]\n \t\t  UNSPEC_ZAP)\n-\t\t(match_operand:DI 1 \"reg_or_const_int_operand\" \"\")))]\n+\t\t(match_operand:DI 1 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)"}, {"sha": "56486bcb0feda697e6624dba0156154cea2f6777", "filename": "gcc/config/alpha/predicates.md", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -0,0 +1,552 @@\n+;; Predicate definitions for DEC Alpha.\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return 1 if OP is the zero constant for MODE.\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Returns true if OP is either the constant zero or a register.\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const0_operand\")))\n+\n+;; Return 1 if OP is a constant in the range of 0-63 (for a shift) or\n+;; any register.\n+(define_predicate \"reg_or_6bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 64\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if OP is an 8-bit constant.\n+(define_predicate \"cint8_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 256\")))\n+\n+;; Return 1 if OP is an 8-bit constant or any register.\n+(define_predicate \"reg_or_8bit_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 256\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if OP is a constant or any register.\n+(define_predicate \"reg_or_cint_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_int_operand\")))\n+\n+;; Return 1 if the operand is a valid second operand to an add insn.\n+(define_predicate \"add_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'K')\n+\t\t || CONST_OK_FOR_LETTER_P (INTVAL (op), 'L')\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if the operand is a valid second operand to a\n+;; sign-extending add insn.\n+(define_predicate \"sext_add_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n+\t\t || CONST_OK_FOR_LETTER_P (INTVAL (op), 'O')\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if OP is the constant 4 or 8.\n+(define_predicate \"const48_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 4 || INTVAL (op) == 8\")))\n+\n+;; Return 1 if OP is a valid first operand to an AND insn.\n+(define_predicate \"and_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"(unsigned HOST_WIDE_INT) INTVAL (op) < 0x100\n+\t\t || (unsigned HOST_WIDE_INT) ~ INTVAL (op) < 0x100\n+\t\t || zap_mask (INTVAL (op))\")\n+    (if_then_else (match_code \"const_double\")\n+      (match_test \"zap_mask (CONST_DOUBLE_LOW (op))\n+\t\t   && zap_mask (CONST_DOUBLE_HIGH (op))\")\n+      (match_operand 0 \"register_operand\"))))\n+\n+;; Return 1 if OP is a valid first operand to an IOR or XOR insn.\n+(define_predicate \"or_operand\"\n+  (if_then_else (match_code \"const_int\")\n+    (match_test \"(unsigned HOST_WIDE_INT) INTVAL (op) < 0x100\n+\t\t || (unsigned HOST_WIDE_INT) ~ INTVAL (op) < 0x100\")\n+    (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if OP is a constant that is the width, in bits, of an integral\n+;; mode not larger than DImode.\n+(define_predicate \"mode_width_operand\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT i = INTVAL (op);\n+  return i == 8 || i == 16 || i == 32 || i == 64;\n+})\n+\n+;; Return 1 if OP is a constant that is a mask of ones of width of an\n+;; integral machine mode not larger than DImode.\n+(define_predicate \"mode_mask_operand\"\n+  (match_code \"const_int,const_double\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      HOST_WIDE_INT value = INTVAL (op);\n+\n+      if (value == 0xff)\n+\treturn 1;\n+      if (value == 0xffff)\n+\treturn 1;\n+      if (value == 0xffffffff)\n+\treturn 1;\n+      if (value == -1)\n+\treturn 1;\n+    }\n+  else if (HOST_BITS_PER_WIDE_INT == 32 && GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      if (CONST_DOUBLE_LOW (op) == 0xffffffff && CONST_DOUBLE_HIGH (op) == 0)\n+\treturn 1;\n+    }\n+  return 0;\n+})\n+\n+;; Return 1 if OP is a multiple of 8 less than 64.\n+(define_predicate \"mul8_operand\"\n+  (match_code \"const_int\")\n+{\n+  unsigned HOST_WIDE_INT i = INTVAL (op);\n+  return i < 64 && i % 8 == 0;\n+})\n+\n+;; Return 1 if OP is a hard floating-point register.\n+(define_predicate \"hard_fp_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REGNO_REG_CLASS (REGNO (op)) == FLOAT_REGS;\n+})\n+\n+;; Return 1 if OP is a hard general register.\n+(define_predicate \"hard_int_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS;\n+})\n+\n+;; Return 1 if OP is something that can be reloaded into a register;\n+;; if it is a MEM, it need not be valid.\n+(define_predicate \"some_operand\"\n+  (ior (match_code \"reg,mem,const_int,const_double,const_vector,\n+\t\t    label_ref,symbol_ref,const,high\")\n+       (and (match_code \"subreg\")\n+\t    (match_test \"some_operand (SUBREG_REG (op), VOIDmode)\"))))\n+\n+;; Likewise, but don't accept constants.\n+(define_predicate \"some_ni_operand\"\n+  (ior (match_code \"reg,mem\")\n+       (and (match_code \"subreg\")\n+\t    (match_test \"some_ni_operand (SUBREG_REG (op), VOIDmode)\"))))\n+\n+;; Return 1 if OP is a valid operand for the source of a move insn.\n+(define_predicate \"input_operand\"\n+  (match_code \"label_ref,symbol_ref,const,high,reg,subreg,mem,\n+\t       const_double,const_vector,const_int\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      if (TARGET_EXPLICIT_RELOCS)\n+\t{\n+\t  /* We don't split symbolic operands into something unintelligable\n+\t     until after reload, but we do not wish non-small, non-global\n+\t     symbolic operands to be reconstructed from their high/lo_sum\n+\t     form.  */\n+\t  return (small_symbolic_operand (op, mode)\n+\t\t  || global_symbolic_operand (op, mode)\n+\t\t  || gotdtp_symbolic_operand (op, mode)\n+\t\t  || gottp_symbolic_operand (op, mode));\n+\t}\n+\n+      /* This handles both the Windows/NT and OSF cases.  */\n+      return mode == ptr_mode || mode == DImode;\n+\n+    case HIGH:\n+      return (TARGET_EXPLICIT_RELOCS\n+\t      && local_symbolic_operand (XEXP (op, 0), mode));\n+\n+    case REG:\n+      return 1;\n+\n+    case SUBREG:\n+      if (register_operand (op, mode))\n+\treturn 1;\n+      /* ... fall through ...  */\n+    case MEM:\n+      return ((TARGET_BWX || (mode != HImode && mode != QImode))\n+\t      && general_operand (op, mode));\n+\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+      return op == CONST0_RTX (mode);\n+\n+    case CONST_INT:\n+      return mode == QImode || mode == HImode || add_operand (op, mode);\n+\n+    default:\n+      abort ();\n+    }\n+  return 0;\n+})\n+\n+;; Return 1 if OP is a SYMBOL_REF for a function known to be in this\n+;; file, and in the same section as the current function.\n+\n+(define_predicate \"samegp_function_operand\"\n+  (match_code \"symbol_ref\")\n+{\n+  /* Easy test for recursion.  */\n+  if (op == XEXP (DECL_RTL (current_function_decl), 0))\n+    return true;\n+\n+  /* Functions that are not local can be overridden, and thus may\n+     not share the same gp.  */\n+  if (! SYMBOL_REF_LOCAL_P (op))\n+    return false;\n+\n+  /* If -msmall-data is in effect, assume that there is only one GP\n+     for the module, and so any local symbol has this property.  We\n+     need explicit relocations to be able to enforce this for symbols\n+     not defined in this unit of translation, however.  */\n+  if (TARGET_EXPLICIT_RELOCS && TARGET_SMALL_DATA)\n+    return true;\n+\n+  /* Functions that are not external are defined in this UoT,\n+     and thus must share the same gp.  */\n+  return ! SYMBOL_REF_EXTERNAL_P (op);\n+})\n+\n+;; Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.\n+(define_predicate \"direct_call_operand\"\n+  (match_operand 0 \"samegp_function_operand\")\n+{\n+  tree op_decl, cfun_sec, op_sec;\n+\n+  /* If profiling is implemented via linker tricks, we can't jump\n+     to the nogp alternate entry point.  Note that current_function_profile\n+     would not be correct, since that doesn't indicate if the target\n+     function uses profiling.  */\n+  /* ??? TARGET_PROFILING_NEEDS_GP isn't really the right test,\n+     but is approximately correct for the OSF ABIs.  Don't know\n+     what to do for VMS, NT, or UMK.  */\n+  if (!TARGET_PROFILING_NEEDS_GP && profile_flag)\n+    return false;\n+\n+  /* Must be a function.  In some cases folks create thunks in static\n+     data structures and then make calls to them.  If we allow the\n+     direct call, we'll get an error from the linker about !samegp reloc\n+     against a symbol without a .prologue directive.  */\n+  if (!SYMBOL_REF_FUNCTION_P (op))\n+    return false;\n+  \n+  /* Must be \"near\" so that the branch is assumed to reach.  With\n+     -msmall-text, this is assumed true of all local symbols.  Since\n+     we've already checked samegp, locality is already assured.  */\n+  if (TARGET_SMALL_TEXT)\n+    return true;\n+\n+  /* Otherwise, a decl is \"near\" if it is defined in the same section.  */\n+  if (flag_function_sections)\n+    return false;\n+\n+  op_decl = SYMBOL_REF_DECL (op);\n+  if (DECL_ONE_ONLY (current_function_decl)\n+      || (op_decl && DECL_ONE_ONLY (op_decl)))\n+    return false;\n+\n+  cfun_sec = DECL_SECTION_NAME (current_function_decl);\n+  op_sec = op_decl ? DECL_SECTION_NAME (op_decl) : NULL;\n+  return ((!cfun_sec && !op_sec)\n+\t  || (cfun_sec && op_sec\n+\t      && strcmp (TREE_STRING_POINTER (cfun_sec),\n+\t\t         TREE_STRING_POINTER (op_sec)) == 0));\n+})\n+\n+;; Return 1 if OP is a valid operand for the MEM of a CALL insn.\n+;;\n+;; For TARGET_ABI_OSF, we want to restrict to R27 or a pseudo.\n+;; For TARGET_ABI_UNICOSMK, we want to restrict to registers.\n+\n+(define_predicate \"call_operand\"\n+  (if_then_else (match_code \"reg\")\n+    (match_test \"!TARGET_ABI_OSF\n+\t\t || REGNO (op) == 27 || REGNO (op) > LAST_VIRTUAL_REGISTER\")\n+    (and (match_test \"!TARGET_ABI_UNICOSMK\")\n+\t (match_code \"symbol_ref\"))))\n+\n+;; Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n+;; a (non-tls) variable known to be defined in this file.\n+(define_predicate \"local_symbolic_operand\"\n+  (match_code \"label_ref,const,symbol_ref\")\n+{\n+  if (GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  return SYMBOL_REF_LOCAL_P (op) && !SYMBOL_REF_TLS_MODEL (op);\n+})\n+\n+;; Return true if OP is a SYMBOL_REF or CONST referencing a variable\n+;; known to be defined in this file in the small data area.\n+(define_predicate \"small_symbolic_operand\"\n+  (match_code \"const,symbol_ref\")\n+{\n+  if (! TARGET_SMALL_DATA)\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  /* ??? There's no encode_section_info equivalent for the rtl\n+     constant pool, so SYMBOL_FLAG_SMALL never gets set.  */\n+  if (CONSTANT_POOL_ADDRESS_P (op))\n+    return GET_MODE_SIZE (get_pool_mode (op)) <= g_switch_value;\n+\n+  return (SYMBOL_REF_LOCAL_P (op)\n+\t  && SYMBOL_REF_SMALL_P (op)\n+\t  && SYMBOL_REF_TLS_MODEL (op) == 0);\n+})\n+\n+;; Return true if OP is a SYMBOL_REF or CONST referencing a variable\n+;; not known (or known not) to be defined in this file.\n+(define_predicate \"global_symbolic_operand\"\n+  (match_code \"const,symbol_ref\")\n+{\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  return !SYMBOL_REF_LOCAL_P (op) && !SYMBOL_REF_TLS_MODEL (op);\n+})\n+\n+;; Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n+;; possibly with an offset.\n+(define_predicate \"symbolic_operand\"\n+  (ior (match_code \"symbol_ref,label_ref\")\n+       (and (match_code \"const\")\n+\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n+\t\t\t && GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n+\t\t\t && GET_CODE (XEXP (XEXP (op,0), 1)) == CONST_INT\"))))\n+\n+;; Return true if OP is valid for 16-bit DTP relative relocations.\n+(define_predicate \"dtp16_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"tls_symbolic_operand_1 (op, 16, UNSPEC_DTPREL)\")))\n+\n+;; Return true if OP is valid for 32-bit DTP relative relocations.\n+(define_predicate \"dtp32_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"tls_symbolic_operand_1 (op, 32, UNSPEC_DTPREL)\")))\n+\n+;; Return true if OP is valid for 64-bit DTP relative relocations.\n+(define_predicate \"gotdtp_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"tls_symbolic_operand_1 (op, 64, UNSPEC_DTPREL)\")))\n+\n+;; Return true if OP is valid for 16-bit TP relative relocations.\n+(define_predicate \"tp16_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"tls_symbolic_operand_1 (op, 16, UNSPEC_TPREL)\")))\n+\n+;; Return true if OP is valid for 32-bit TP relative relocations.\n+(define_predicate \"tp32_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"tls_symbolic_operand_1 (op, 32, UNSPEC_TPREL)\")))\n+\n+;; Return true if OP is valid for 64-bit TP relative relocations.\n+(define_predicate \"gottp_symbolic_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"tls_symbolic_operand_1 (op, 64, UNSPEC_TPREL)\")))\n+\n+;; Return 1 if this memory address is a known aligned register plus\n+;; a constant.  It must be a valid address.  This means that we can do\n+;; this as an aligned reference plus some offset.\n+;;\n+;; Take into account what reload will do.  Oh god this is awful.\n+;; The horrible comma-operator construct below is to prevent genrecog\n+;; from thinking that this predicate accepts REG and SUBREG.  We don't\n+;; use recog during reload, so pretending these codes are accepted \n+;; pessimizes things a tad.\n+\n+(define_predicate \"aligned_memory_operand\"\n+  (ior (match_test \"op = resolve_reload_operand (op), 0\")\n+       (match_code \"mem\"))\n+{\n+  rtx base;\n+\n+  if (MEM_ALIGN (op) >= 32)\n+    return 1;\n+  op = XEXP (op, 0);\n+\n+  /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n+     sorts of constructs.  Dig for the real base register.  */\n+  if (reload_in_progress\n+      && GET_CODE (op) == PLUS\n+      && GET_CODE (XEXP (op, 0)) == PLUS)\n+    base = XEXP (XEXP (op, 0), 0);\n+  else\n+    {\n+      if (! memory_address_p (mode, op))\n+\treturn 0;\n+      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n+    }\n+\n+  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) >= 32);\n+})\n+\n+;; Similar, but return 1 if OP is a MEM which is not alignable.\n+\n+(define_predicate \"unaligned_memory_operand\"\n+  (ior (match_test \"op = resolve_reload_operand (op), 0\")\n+       (match_code \"mem\"))\n+{\n+  rtx base;\n+\n+  if (MEM_ALIGN (op) >= 32)\n+    return 0;\n+  op = XEXP (op, 0);\n+\n+  /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n+     sorts of constructs.  Dig for the real base register.  */\n+  if (reload_in_progress\n+      && GET_CODE (op) == PLUS\n+      && GET_CODE (XEXP (op, 0)) == PLUS)\n+    base = XEXP (XEXP (op, 0), 0);\n+  else\n+    {\n+      if (! memory_address_p (mode, op))\n+\treturn 0;\n+      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n+    }\n+\n+  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) < 32);\n+})\n+\n+;; Return 1 if OP is any memory location.  During reload a pseudo matches.\n+(define_predicate \"any_memory_operand\"\n+  (ior (match_code \"mem,reg\")\n+       (and (match_code \"subreg\")\n+\t    (match_test \"GET_CODE (SUBREG_REG (op)) == REG\"))))\n+\n+;; Return 1 if OP is either a register or an unaligned memory location.\n+(define_predicate \"reg_or_unaligned_mem_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"unaligned_memory_operand\")))\n+\n+;; Return 1 is OP is a memory location that is not a reference\n+;; (using an AND) to an unaligned location.  Take into account\n+;; what reload will do.\n+(define_predicate \"normal_memory_operand\"\n+  (ior (match_test \"op = resolve_reload_operand (op), 0\")\n+       (and (match_code \"mem\")\n+\t    (match_test \"GET_CODE (XEXP (op, 0)) != AND\"))))\n+\n+;; Returns 1 if OP is not an eliminable register.\n+;;\n+;; This exists to cure a pathological abort in the s8addq (et al) patterns,\n+;;\n+;;\tlong foo () { long t; bar(); return (long) &t * 26107; }\n+;;\n+;; which run afoul of a hack in reload to cure a (presumably) similar\n+;; problem with lea-type instructions on other targets.  But there is\n+;; one of us and many of them, so work around the problem by selectively\n+;; preventing combine from making the optimization.\n+\n+(define_predicate \"reg_not_elim_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return op != frame_pointer_rtx && op != arg_pointer_rtx;\n+})\n+\n+;; Accept a register, but not a subreg of any kind.  This allows us to\n+;; avoid pathological cases in reload wrt data movement common in \n+;; int->fp conversion.  */\n+(define_predicate \"reg_no_subreg_operand\"\n+  (and (match_code \"reg\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Return 1 if OP is a valid Alpha comparison operator for \"cmp\" style\n+;; instructions.\n+(define_predicate \"alpha_comparison_operator\"\n+  (match_code \"eq,le,lt,leu,ltu\"))\n+\n+;; Similarly, but with swapped operands.\n+(define_predicate \"alpha_swapped_comparison_operator\"\n+  (match_code \"eq,ge,gt,gtu,gtu\"))\n+\n+;; Return 1 if OP is a valid Alpha comparison operator against zero\n+;; for \"bcc\" style instructions.\n+(define_predicate \"alpha_zero_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,leu,ltu\"))\n+\n+;; Return 1 if OP is a signed comparison operation.\n+(define_predicate \"signed_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt\"))\n+\n+;; Return 1 if OP is a valid Alpha floating point comparison operator.\n+(define_predicate \"alpha_fp_comparison_operator\"\n+  (match_code \"eq,le,lt,unordered\"))\n+\n+;; Return 1 if this is a divide or modulus operator.\n+(define_predicate \"divmod_operator\"\n+  (match_code \"div,mod,udiv,umod\"))\n+\n+;; Return 1 if this is a float->int conversion operator.\n+(define_predicate \"fix_operator\"\n+  (match_code \"fix,unsigned_fix\"))\n+\n+;; Recognize an addition operation that includes a constant.  Used to\n+;; convince reload to canonize (plus (plus reg c1) c2) during register\n+;; elimination.\n+\n+(define_predicate \"addition_operation\"\n+  (and (match_code \"plus\")\n+       (match_test \"register_operand (XEXP (op, 0), mode)\n+\t\t    && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op, 1)), 'K')\")))"}, {"sha": "cdfc8f54d36a8e73abba2f1bee6987afe2e14875", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201312c254f778e19ac9407874217ddbe83d2aa5/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=201312c254f778e19ac9407874217ddbe83d2aa5", "patch": "@@ -417,6 +417,7 @@ write_insn_preds_c (void)\n #include \\\"coretypes.h\\\"\\n\\\n #include \\\"tm.h\\\"\\n\\\n #include \\\"rtl.h\\\"\\n\\\n+#include \\\"tree.h\\\"\\n\\\n #include \\\"tm_p.h\\\"\\n\\\n #include \\\"function.h\\\"\\n\\\n #include \\\"insn-config.h\\\"\\n\\"}]}