{"sha": "5b3be7cf99e5b833c073c119be2b60c84db7ec35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIzYmU3Y2Y5OWU1YjgzM2MwNzNjMTE5YmUyYjYwYzg0ZGI3ZWMzNQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-01-28T20:52:13Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-01-28T20:52:13Z"}, "message": "hashtable_policy.h (_Local_iterator_base): Use _Hashtable_ebo_helper to embed functors into the local_iterator when necessary.\n\n2013-01-28  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable_policy.h (_Local_iterator_base): Use\n\t_Hashtable_ebo_helper to embed functors into the local_iterator\n\twhen necessary. Pass information about functors involved in hash\n\tcode by copy.\n\t* include/bits/hashtable.h (__cache_default): Do not cache for\n\tbuiltin integral types unless the hash functor is not noexcept\n\tqualified or is not default constructible. Adapt static assertions\n\tand local iterator instantiations.\n\t* include/debug/unordered_set\n\t(std::__debug::unordered_set<>::erase): Detect local iterators to\n\tinvalidate using contained node rather than generating a dummy\n\tlocal_iterator instance.\n\t(std::__debug::unordered_multiset<>::erase): Likewise.\n\t* include/debug/unordered_map\n\t(std::__debug::unordered_map<>::erase): Likewise.\n\t(std::__debug::unordered_multimap<>::erase): Likewise.\n\t* testsuite/performance/23_containers/insert_erase/41975.cc: Test\n\tstd::tr1 and std versions of unordered_set regardless of any\n\tmacro. Add test on default cache behavior.\n\t* testsuite/performance/23_containers/insert/54075.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n\tAdapt line number.\n\t* testsuite/23_containers/unordered_set/\n\tnot_default_constructible_hash_neg.cc: New.\n\t* testsuite/23_containers/unordered_set/buckets/swap.cc: New.\n\nFrom-SVN: r195517", "tree": {"sha": "8545a60d6c1448b1ab73d4df8cbd0068780d2f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8545a60d6c1448b1ab73d4df8cbd0068780d2f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b3be7cf99e5b833c073c119be2b60c84db7ec35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b3be7cf99e5b833c073c119be2b60c84db7ec35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b3be7cf99e5b833c073c119be2b60c84db7ec35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b3be7cf99e5b833c073c119be2b60c84db7ec35/comments", "author": null, "committer": null, "parents": [{"sha": "5a579c3b65d5571b3d10d2b7e22d4c1915cc6b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a579c3b65d5571b3d10d2b7e22d4c1915cc6b1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a579c3b65d5571b3d10d2b7e22d4c1915cc6b1c"}], "stats": {"total": 706, "additions": 444, "deletions": 262}, "files": [{"sha": "2aed1e3d79b49efa100f33084a4565046e744641", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -1,3 +1,31 @@\n+2013-01-28  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable_policy.h (_Local_iterator_base): Use\n+\t_Hashtable_ebo_helper to embed functors into the local_iterator\n+\twhen necessary. Pass information about functors involved in hash\n+\tcode by copy.\n+\t* include/bits/hashtable.h (__cache_default): Do not cache for\n+\tbuiltin integral types unless the hash functor is not noexcept\n+\tqualified or is not default constructible. Adapt static assertions\n+\tand local iterator instantiations.\n+\t* include/debug/unordered_set\n+\t(std::__debug::unordered_set<>::erase): Detect local iterators to\n+\tinvalidate using contained node rather than generating a dummy\n+\tlocal_iterator instance.\n+\t(std::__debug::unordered_multiset<>::erase): Likewise.\n+\t* include/debug/unordered_map\n+\t(std::__debug::unordered_map<>::erase): Likewise.\n+\t(std::__debug::unordered_multimap<>::erase): Likewise.\n+\t* testsuite/performance/23_containers/insert_erase/41975.cc: Test\n+\tstd::tr1 and std versions of unordered_set regardless of any\n+\tmacro. Add test on default cache behavior.\n+\t* testsuite/performance/23_containers/insert/54075.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n+\tAdapt line number.\n+\t* testsuite/23_containers/unordered_set/\n+\tnot_default_constructible_hash_neg.cc: New.\n+\t* testsuite/23_containers/unordered_set/buckets/swap.cc: New.\n+\n 2013-01-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/56085"}, {"sha": "d899fa728ebac1503c7aa5edae19744bbc616552", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -1,6 +1,6 @@\n // hashtable.h header -*- C++ -*-\n \n-// Copyright (C) 2007-2012 Free Software Foundation, Inc.\n+// Copyright (C) 2007-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,10 +39,15 @@ namespace std _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp, typename _Hash>\n-    using __cache_default =  __not_<__and_<is_integral<_Tp>,\n-\t\t\t\t\t   is_empty<_Hash>,\n-\t\t\t\t  integral_constant<bool, !__is_final(_Hash)>,\n-\t\t\t\t __detail::__is_noexcept_hash<_Tp, _Hash> >>;\n+    using __cache_default\n+      =  __not_<__and_<// Do not cache for builtin integral types having trivial\n+\t\t       // hasher.\n+\t\t       is_integral<_Tp>,\n+\t\t       // Mandatory to make local_iterator default\n+\t\t       // constructible.\n+\t\t       is_default_constructible<_Hash>,\n+\t\t       // Mandatory to have erase not throwing.\n+\t\t       __detail::__is_noexcept_hash<_Tp, _Hash>>>;\n \n   /**\n    *  Primary class template _Hashtable.\n@@ -249,21 +254,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    \" or qualify your hash functor with noexcept\");\n \n       // Following two static assertions are necessary to guarantee\n-      // that swapping two hashtable instances won't invalidate\n-      // associated local iterators.\n+      // that local_iterator will be default constructible.\n \n-      // When hash codes are cached local iterator only uses H2 which\n-      // must then be empty.\n-      static_assert(__if_hash_cached<is_empty<_H2>>::value,\n+      // When hash codes are cached local iterator inherits from H2 functor\n+      // which must then be default constructible.\n+      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,\n \t\t    \"Functor used to map hash code to bucket index\"\n-\t\t    \" must be empty\");\n+\t\t    \" must be default constructible\");\n \n-      // When hash codes are not cached local iterator is going to use\n-      // __hash_code_base above to compute node bucket index so it has\n-      // to be empty.\n-      static_assert(__if_hash_not_cached<is_empty<__hash_code_base>>::value,\n-\t\t   \"Cache the hash code or make functors involved in hash code\"\n-\t\t   \" and bucket index computation empty\");\n+      // When hash codes are not cached local iterator inherits from\n+      // __hash_code_base above to compute node bucket index so it has to be\n+      // default constructible.\n+      static_assert(__if_hash_not_cached<\n+\t\t      is_default_constructible<__hash_code_base>>::value,\n+\t\t    \"Cache the hash code or make functors involved in hash code\"\n+\t\t    \" and bucket index computation default constructible\");\n \n     public:\n       template<typename _Keya, typename _Valuea, typename _Alloca,\n@@ -500,30 +505,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       local_iterator\n       begin(size_type __n)\n-      { return local_iterator(_M_bucket_begin(__n), __n, _M_bucket_count); }\n+      {\n+\treturn local_iterator(*this, _M_bucket_begin(__n),\n+\t\t\t      __n, _M_bucket_count);\n+      }\n \n       local_iterator\n       end(size_type __n)\n-      { return local_iterator(nullptr, __n, _M_bucket_count); }\n+      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }\n \n       const_local_iterator\n       begin(size_type __n) const\n-      { return const_local_iterator(_M_bucket_begin(__n), __n,\n-\t\t\t\t    _M_bucket_count); }\n+      {\n+\treturn const_local_iterator(*this, _M_bucket_begin(__n),\n+\t\t\t\t    __n, _M_bucket_count);\n+      }\n \n       const_local_iterator\n       end(size_type __n) const\n-      { return const_local_iterator(nullptr, __n, _M_bucket_count); }\n+      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }\n \n       // DR 691.\n       const_local_iterator\n       cbegin(size_type __n) const\n-      { return const_local_iterator(_M_bucket_begin(__n), __n,\n-\t\t\t\t    _M_bucket_count); }\n+      {\n+\treturn const_local_iterator(*this, _M_bucket_begin(__n),\n+\t\t\t\t    __n, _M_bucket_count);\n+      }\n \n       const_local_iterator\n       cend(size_type __n) const\n-      { return const_local_iterator(nullptr, __n, _M_bucket_count); }\n+      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }\n \n       float\n       load_factor() const noexcept\n@@ -1141,7 +1153,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  if (this->_M_equals(__k, __code, __p))\n \t    return __prev_p;\n-\t  if (!(__p->_M_nxt) || _M_bucket_index(__p->_M_next()) != __n)\n+\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n \t  __prev_p = __p;\n \t}"}, {"sha": "f089bcf308b96813824cc8a3c0ae1496c5f44236", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 90, "deletions": 65, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -1,6 +1,6 @@\n // Internal policy header for unordered_set and unordered_map -*- C++ -*-\n \n-// Copyright (C) 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -202,7 +202,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Value, bool _Cache_hash_code>\n     struct _Node_iterator_base\n     {\n-      typedef _Hash_node<_Value, _Cache_hash_code>    \t__node_type;\n+      using __node_type = _Hash_node<_Value, _Cache_hash_code>;\n \n       __node_type*  _M_cur;\n \n@@ -282,7 +282,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Node_const_iterator\n     : public _Node_iterator_base<_Value, __cache>\n     {\n-     private:\n+    private:\n       using __base_type = _Node_iterator_base<_Value, __cache>;\n       using __node_type = typename __base_type::__node_type;\n \n@@ -940,6 +940,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Tp _M_tp;\n     };\n \n+  /**\n+   *  Primary class template _Local_iterator_base.\n+   *\n+   *  Base class for local iterators, used to iterate within a bucket\n+   *  but not between buckets.\n+   */\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __cache_hash_code>\n+    struct _Local_iterator_base;\n+\n   /**\n    *  Primary class template _Hash_code_base.\n    *\n@@ -974,8 +985,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private _Hashtable_ebo_helper<1, _Hash>\n     {\n     private:\n-      typedef _Hashtable_ebo_helper<0, _ExtractKey> \t_EboExtractKey;\n-      typedef _Hashtable_ebo_helper<1, _Hash> \t\t_EboHash;\n+      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;\n+      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;\n \n     protected:\n       typedef void* \t\t\t\t\t__hash_code;\n@@ -986,7 +997,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,\n \t\t      const _Hash& __h)\n-      : _EboExtractKey(__ex), _EboHash(__h) { }\n+      : __ebo_extract_key(__ex), __ebo_hash(__h) { }\n \n       __hash_code\n       _M_hash_code(const _Key& __key) const\n@@ -1017,16 +1028,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     protected:\n       const _ExtractKey&\n-      _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }\n \n       _ExtractKey&\n-      _M_extract() { return _EboExtractKey::_S_get(*this); }\n+      _M_extract() { return __ebo_extract_key::_S_get(*this); }\n \n       const _Hash&\n-      _M_ranged_hash() const { return _EboHash::_S_cget(*this); }\n+      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }\n \n       _Hash&\n-      _M_ranged_hash() { return _EboHash::_S_get(*this); }\n+      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }\n     };\n \n   // No specialization for ranged hash function while caching hash codes.\n@@ -1041,7 +1052,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// Specialization: hash function and range-hashing function, no\n   /// caching of hash codes.\n-  /// Provides typedef and accessor required by TR1.\n+  /// Provides typedef and accessor required by C++ 11.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2>\n     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n@@ -1051,9 +1062,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private _Hashtable_ebo_helper<2, _H2>\n     {\n     private:\n-      typedef _Hashtable_ebo_helper<0, _ExtractKey> \t_EboExtractKey;\n-      typedef _Hashtable_ebo_helper<1, _H1> \t\t_EboH1;\n-      typedef _Hashtable_ebo_helper<2, _H2> \t\t_EboH2;\n+      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;\n+      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;\n+      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;\n \n     public:\n       typedef _H1 \t\t\t\t\thasher;\n@@ -1062,17 +1073,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       hash_function() const\n       { return _M_h1(); }\n \n+    protected:\n       typedef std::size_t \t\t\t\t__hash_code;\n       typedef _Hash_node<_Value, false>\t\t\t__node_type;\n \n-    protected:\n       // We need the default constructor for the local iterators.\n       _Hash_code_base() = default;\n \n       _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1& __h1, const _H2& __h2,\n \t\t      const _Default_ranged_hash&)\n-      : _EboExtractKey(__ex), _EboH1(__h1), _EboH2(__h2) { }\n+      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }\n \n       __hash_code\n       _M_hash_code(const _Key& __k) const\n@@ -1104,27 +1115,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       const _ExtractKey&\n-      _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }\n \n       _ExtractKey&\n-      _M_extract() { return _EboExtractKey::_S_get(*this); }\n+      _M_extract() { return __ebo_extract_key::_S_get(*this); }\n \n       const _H1&\n-      _M_h1() const { return _EboH1::_S_cget(*this); }\n+      _M_h1() const { return __ebo_h1::_S_cget(*this); }\n \n       _H1&\n-      _M_h1() { return _EboH1::_S_get(*this); }\n+      _M_h1() { return __ebo_h1::_S_get(*this); }\n \n       const _H2&\n-      _M_h2() const { return _EboH2::_S_cget(*this); }\n+      _M_h2() const { return __ebo_h2::_S_cget(*this); }\n \n       _H2&\n-      _M_h2() { return _EboH2::_S_get(*this); }\n+      _M_h2() { return __ebo_h2::_S_get(*this); }\n     };\n \n   /// Specialization: hash function and range-hashing function,\n   /// caching hash codes.  H is provided but ignored.  Provides\n-  /// typedef and accessor required by TR1.\n+  /// typedef and accessor required by C++ 11.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2>\n     struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n@@ -1134,9 +1145,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private _Hashtable_ebo_helper<2, _H2>\n     {\n     private:\n-      typedef _Hashtable_ebo_helper<0, _ExtractKey>\t_EboExtractKey;\n-      typedef _Hashtable_ebo_helper<1, _H1> \t\t_EboH1;\n-      typedef _Hashtable_ebo_helper<2, _H2> \t\t_EboH2;\n+      // Gives access to _M_h2() to the local iterator implementation.\n+      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,\n+\t\t\t\t\t _Default_ranged_hash, true>;\n+\n+      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;\n+      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;\n+      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;\n \n     public:\n       typedef _H1 \t\t\t\t\thasher;\n@@ -1145,14 +1160,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       hash_function() const\n       { return _M_h1(); }\n \n+    protected:\n       typedef std::size_t \t\t\t\t__hash_code;\n       typedef _Hash_node<_Value, true>\t\t\t__node_type;\n \n-    protected:\n       _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1& __h1, const _H2& __h2,\n \t\t      const _Default_ranged_hash&)\n-      : _EboExtractKey(__ex), _EboH1(__h1), _EboH2(__h2) { }\n+      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }\n \n       __hash_code\n       _M_hash_code(const _Key& __k) const\n@@ -1184,22 +1199,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       const _ExtractKey&\n-      _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }\n \n       _ExtractKey&\n-      _M_extract() { return _EboExtractKey::_S_get(*this); }\n+      _M_extract() { return __ebo_extract_key::_S_get(*this); }\n \n       const _H1&\n-      _M_h1() const { return _EboH1::_S_cget(*this); }\n+      _M_h1() const { return __ebo_h1::_S_cget(*this); }\n \n       _H1&\n-      _M_h1() { return _EboH1::_S_get(*this); }\n+      _M_h1() { return __ebo_h1::_S_get(*this); }\n \n       const _H2&\n-      _M_h2() const { return _EboH2::_S_cget(*this); }\n+      _M_h2() const { return __ebo_h2::_S_cget(*this); }\n \n       _H2&\n-      _M_h2() { return _EboH2::_S_get(*this); }\n+      _M_h2() { return __ebo_h2::_S_get(*this); }\n     };\n \n   /**\n@@ -1234,44 +1249,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n \n \n-  /**\n-   *  Primary class template _Local_iterator_base.\n-   *\n-   *  Base class for local iterators, used to iterate within a bucket\n-   *  but not between buckets.\n-   */\n-  template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash,\n-\t   bool __cache_hash_code>\n-    struct _Local_iterator_base;\n-\n   /// Specialization.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash>\n     struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n \t\t\t\t_H1, _H2, _Hash, true>\n-    : private _H2\n+    : private _Hashtable_ebo_helper<0, _H2>\n     {\n+    protected:\n+      using __base_type = _Hashtable_ebo_helper<0, _H2>;\n+      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _H1, _H2, _Hash, true>;\n+\n+    public:\n       _Local_iterator_base() = default;\n-      _Local_iterator_base(_Hash_node<_Value, true>* __p,\n+      _Local_iterator_base(const __hash_code_base& __base,\n+\t\t\t   _Hash_node<_Value, true>* __p,\n \t\t\t   std::size_t __bkt, std::size_t __bkt_count)\n-      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n+      : __base_type(__base._M_h2()),\n+\t_M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n \n       void\n       _M_incr()\n       {\n \t_M_cur = _M_cur->_M_next();\n \tif (_M_cur)\n \t  {\n-\t    std::size_t __bkt = _M_h2()(_M_cur->_M_hash_code, _M_bucket_count);\n+\t    std::size_t __bkt\n+\t      = __base_type::_S_get(*this)(_M_cur->_M_hash_code,\n+\t\t\t\t\t   _M_bucket_count);\n \t    if (__bkt != _M_bucket)\n \t      _M_cur = nullptr;\n \t  }\n       }\n \n-      const _H2& _M_h2() const\n-      { return *this; }\n-\n       _Hash_node<_Value, true>*  _M_cur;\n       std::size_t _M_bucket;\n       std::size_t _M_bucket_count;\n@@ -1285,10 +1296,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : private _Hash_code_base<_Key, _Value, _ExtractKey,\n \t\t\t      _H1, _H2, _Hash, false>\n     {\n+    protected:\n+      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _H1, _H2, _Hash, false>;\n+\n+    public:\n       _Local_iterator_base() = default;\n-      _Local_iterator_base(_Hash_node<_Value, false>* __p,\n+      _Local_iterator_base(const __hash_code_base& __base,\n+\t\t\t   _Hash_node<_Value, false>* __p,\n \t\t\t   std::size_t __bkt, std::size_t __bkt_count)\n-      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n+\t: __hash_code_base(__base),\n+\t  _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n \n       void\n       _M_incr()\n@@ -1333,6 +1351,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public _Local_iterator_base<_Key, _Value, _ExtractKey,\n \t\t\t\t  _H1, _H2, _Hash, __cache>\n     {\n+    private:\n+      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _H1, _H2, _Hash, __cache>;\n+      using __hash_code_base = typename __base_type::__hash_code_base;\n+    public:\n       typedef _Value                                   value_type;\n       typedef typename std::conditional<__constant_iterators,\n \t\t\t\t\tconst _Value*, _Value*>::type\n@@ -1345,11 +1368,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Local_iterator() = default;\n \n-      explicit\n-      _Local_iterator(_Hash_node<_Value, __cache>* __p,\n+      _Local_iterator(const __hash_code_base& __base,\n+\t\t      _Hash_node<_Value, __cache>* __p,\n \t\t      std::size_t __bkt, std::size_t __bkt_count)\n-      : _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n-\t\t\t     __cache>(__p, __bkt, __bkt_count)\n+\t: __base_type(__base, __p, __bkt, __bkt_count)\n       { }\n \n       reference\n@@ -1384,6 +1406,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public _Local_iterator_base<_Key, _Value, _ExtractKey,\n \t\t\t\t  _H1, _H2, _Hash, __cache>\n     {\n+    private:\n+      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _H1, _H2, _Hash, __cache>;\n+      using __hash_code_base = typename __base_type::__hash_code_base;\n+\n+    public:\n       typedef _Value                                   value_type;\n       typedef const _Value*                            pointer;\n       typedef const _Value&                            reference;\n@@ -1392,20 +1420,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Local_const_iterator() = default;\n \n-      explicit\n-      _Local_const_iterator(_Hash_node<_Value, __cache>* __p,\n+      _Local_const_iterator(const __hash_code_base& __base,\n+\t\t\t    _Hash_node<_Value, __cache>* __p,\n \t\t\t    std::size_t __bkt, std::size_t __bkt_count)\n-      : _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n-\t\t\t     __cache>(__p, __bkt, __bkt_count)\n+\t: __base_type(__base, __p, __bkt, __bkt_count)\n       { }\n \n       _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,\n \t\t\t\t\t\t  _H1, _H2, _Hash,\n \t\t\t\t\t\t  __constant_iterators,\n \t\t\t\t\t\t  __cache>& __x)\n-      : _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n-\t\t\t     __cache>(__x._M_cur, __x._M_bucket,\n-\t\t\t\t      __x._M_bucket_count)\n+\t: __base_type(__x)\n       { }\n \n       reference"}, {"sha": "a826b0190d5762abfaf7bb781b557ea4cc804648", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 12, "deletions": 50, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -361,10 +361,9 @@ namespace __debug\n \t  {\n \t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n \t\t\t    { return __it == __victim; });\n-\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_victim; });\n+\t\t\t    [__victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __victim._M_cur; });\n \t    size_type __bucket_count = this->bucket_count();\n \t    _Base::erase(__victim);\n \t    _M_check_rehashed(__bucket_count);\n@@ -380,10 +379,9 @@ namespace __debug\n \t_Base_const_iterator __victim = __it.base();\n \tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n \t\t\t{ return __it == __victim; });\n-\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n \tthis->_M_invalidate_local_if(\n-\t\t\t[__local_victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it == __local_victim; });\n+\t\t\t[__victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it._M_cur == __victim._M_cur; });\n \tsize_type __bucket_count = this->bucket_count();\n \t_Base_iterator __next = _Base::erase(__it.base()); \n \t_M_check_rehashed(__bucket_count);\n@@ -407,10 +405,9 @@ namespace __debug\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n \t\t\t    { return __it == __tmp; });\n-\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_tmp; });\n+\t\t\t    [__tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __tmp._M_cur; });\n \t  }\n \tsize_type __bucket_count = this->bucket_count();\n \t_Base_iterator __next = _Base::erase(__first.base(), __last.base());\n@@ -449,22 +446,6 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  _M_invalidate_locals();\n       }\n-\n-      static _Base_local_iterator\n-      _S_to_local(_Base_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n-      }\n-\n-      static _Base_const_local_iterator\n-      _S_to_local(_Base_const_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n-      }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,\n@@ -807,10 +788,9 @@ namespace __debug\n \t  {\n \t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n \t\t\t    { return __it == __victim; });\n-\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_victim; });\n+\t\t\t    [__victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __victim._M_cur; });\n \t    _Base::erase(__victim++);\n \t    ++__ret;\n \t  }\n@@ -825,10 +805,9 @@ namespace __debug\n \t_Base_const_iterator __victim = __it.base();\n \tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n \t\t\t{ return __it == __victim; });\n-\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n \tthis->_M_invalidate_local_if(\n-\t\t\t[__local_victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it == __local_victim; });\n+\t\t\t[__victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it._M_cur == __victim._M_cur; });\n \tsize_type __bucket_count = this->bucket_count();\n \t_Base_iterator __next = _Base::erase(__it.base());\n \t_M_check_rehashed(__bucket_count);\n@@ -852,10 +831,9 @@ namespace __debug\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n \t\t\t    { return __it == __tmp; });\n-\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_tmp; });\n+\t\t\t    [__tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __tmp._M_cur; });\n \t  }\n \tsize_type __bucket_count = this->bucket_count();\n \t_Base_iterator __next = _Base::erase(__first.base(), __last.base());\n@@ -894,22 +872,6 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  _M_invalidate_locals();\n       }\n-\n-      static _Base_local_iterator\n-      _S_to_local(_Base_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n-      }\n-\n-      static _Base_const_local_iterator\n-      _S_to_local(_Base_const_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n-      }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,"}, {"sha": "8e88addd87f6d35ad24bae23a82ca522a69d474a", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 12, "deletions": 50, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -356,10 +356,9 @@ namespace __debug\n \t    this->_M_invalidate_if(\n \t\t\t    [__victim](_Base_const_iterator __it)\n \t\t\t    { return __it == __victim; });\n-\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_victim; });\n+\t\t\t    [__victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __victim._M_cur; });\n \t    size_type __bucket_count = this->bucket_count();\n \t    _Base::erase(__victim);\n \t    _M_check_rehashed(__bucket_count);\n@@ -376,10 +375,9 @@ namespace __debug\n \tthis->_M_invalidate_if(\n \t\t\t[__victim](_Base_const_iterator __it)\n \t\t\t{ return __it == __victim; });\n-\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n \tthis->_M_invalidate_local_if(\n-\t\t\t[__local_victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it == __local_victim; });\n+\t\t\t[__victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it._M_cur == __victim._M_cur; });\n \tsize_type __bucket_count = this->bucket_count();\n \t_Base_iterator __next = _Base::erase(__it.base());\n \t_M_check_rehashed(__bucket_count);\n@@ -404,10 +402,9 @@ namespace __debug\n \t    this->_M_invalidate_if(\n \t\t\t    [__tmp](_Base_const_iterator __it)\n \t\t\t    { return __it == __tmp; });\n-\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_tmp; });\n+\t\t\t    [__tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __tmp._M_cur; });\n \t  }\n \tsize_type __bucket_count = this->bucket_count();\n \t_Base_iterator __next = _Base::erase(__first.base(),\n@@ -448,22 +445,6 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  _M_invalidate_locals();\n       }\n-\n-      static _Base_local_iterator\n-      _S_to_local(_Base_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n-      }\n-\n-      static _Base_const_local_iterator\n-      _S_to_local(_Base_const_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n-      }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n@@ -798,10 +779,9 @@ namespace __debug\n \t  {\n \t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n \t\t\t    { return __it == __victim; });\n-\t    _Base_local_iterator __local_victim = _S_to_local(__victim);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_victim; });\n+\t\t\t    [__victim](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __victim._M_cur; });\n \t    _Base::erase(__victim++);\n \t    ++__ret;\n \t  }\n@@ -815,10 +795,9 @@ namespace __debug\n \t_Base_const_iterator __victim = __it.base();\n \tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n \t\t\t{ return __it == __victim; });\n-\t_Base_const_local_iterator __local_victim = _S_to_local(__victim);\n \tthis->_M_invalidate_local_if(\n-\t\t\t[__local_victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it == __local_victim; });\n+\t\t\t[__victim](_Base_const_local_iterator __it)\n+\t\t\t{ return __it._M_cur == __victim._M_cur; });\n \treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n@@ -839,10 +818,9 @@ namespace __debug\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n \t\t\t    { return __it == __tmp; });\n-\t    _Base_const_local_iterator __local_tmp = _S_to_local(__tmp);\n \t    this->_M_invalidate_local_if(\n-\t\t\t    [__local_tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it == __local_tmp; });\n+\t\t\t    [__tmp](_Base_const_local_iterator __it)\n+\t\t\t    { return __it._M_cur == __tmp._M_cur; });\n \t  }\n \treturn iterator(_Base::erase(__first.base(),\n \t\t\t\t     __last.base()), this);\n@@ -879,22 +857,6 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  _M_invalidate_locals();\n       }\n-\n-      static _Base_local_iterator\n-      _S_to_local(_Base_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n-      }\n-\n-      static _Base_const_local_iterator\n-      _S_to_local(_Base_const_iterator __it)\n-      {\n-        // The returned local iterator will not be incremented so we don't\n-\t// need to compute __it's node bucket\n-\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n-      }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>"}, {"sha": "6a9a281e31bd89918686bfe94a370bc134c0b8a3", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/buckets/swap.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fbuckets%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fbuckets%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fbuckets%2Fswap.cc?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -0,0 +1,72 @@\n+// { dg-options \"-std=c++11\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <testsuite_hooks.h>\n+#include <unordered_set>\n+\n+namespace\n+{\n+  struct hash\n+  {\n+    hash() = default;\n+    hash(int modulo)\n+      : _M_modulo(modulo)\n+    { }\n+\n+    std::size_t operator() (int val) const noexcept\n+    { return val % _M_modulo; }\n+\n+    int _M_modulo;\n+  };\n+}\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // static_assert(std::__cache_default<int, hash>::value,\n+  // \t\t\"Unexpected default cache value\");\n+  typedef std::unordered_set<int, hash> us_t;\n+  us_t us1(10, hash(13));\n+  us_t us2(10, hash(7));\n+\n+  VERIFY( us1.hash_function()._M_modulo == 13 );\n+  VERIFY( us2.hash_function()._M_modulo == 7 );\n+\n+  const int nb = 5;\n+  for (int i = 0; i != nb * us1.hash_function()._M_modulo; ++i)\n+    us1.insert(i);\n+\n+  us_t::local_iterator lit = us1.begin(12);\n+  us_t::local_iterator litend = us1.end(12);\n+  VERIFY( std::distance(lit, litend) == nb );\n+\n+  us1.swap(us2);\n+\n+  VERIFY( us1.hash_function()._M_modulo == 7 );\n+  VERIFY( us2.hash_function()._M_modulo == 13 );\n+\n+  VERIFY( std::distance(lit, litend) == nb );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "6712d626231e9664d011b04886708fa51ed1d55a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -2,7 +2,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-require-normal-mode \"\" }\n \n-// Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2011-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 247 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 252 }\n \n #include <unordered_set>\n "}, {"sha": "53a25bc65b8961dabc224a076aaf84a80d4e55ef", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/not_default_constructible_hash_neg.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-normal-mode \"\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-error \"default constructible\" \"\" { target *-*-* } 268 }\n+\n+#include <unordered_set>\n+\n+namespace\n+{\n+  struct hash\n+  {\n+    hash(std::size_t seed)\n+      : _M_seed(seed)\n+    { }\n+\n+    std::size_t operator() (int val) const noexcept\n+    { return val ^ _M_seed; }\n+\n+  private:\n+    std::size_t _M_seed;\n+  };\n+}\n+\n+void\n+test01()\n+{\n+  using traits = std::__detail::_Hashtable_traits<false, true, true>;\n+  using hashtable = std::__uset_hashtable<int, hash,\n+\t\t\t\t\t  std::equal_to<int>,\n+\t\t\t\t\t  std::allocator<int>, traits>;\n+\n+  hashtable ht(10, hash(1));\n+}"}, {"sha": "43927c2b153993d7353ef36efab33ca5e141a47b", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert/54075.cc", "status": "modified", "additions": 82, "deletions": 26, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2012-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,10 +21,14 @@\n #include <random>\n #include <sstream>\n #include <tr1/unordered_set>\n-#include<unordered_set>\n+#include <unordered_set>\n+\n+#define USE_MY_FOO 1\n \n struct Foo\n {\n+#if USE_MY_FOO\n+\n   typedef std::random_device::result_type _Type;\n   _Type bar;\n   _Type baz;\n@@ -38,6 +42,18 @@ struct Foo\n     meh = randev();\n   }\n \n+#else\n+\n+  int bar;\n+  int baz;\n+  int meh;\n+\n+  Foo() \n+  { bar = random(); baz = random(); meh = random(); }\n+  Foo(const Foo&) = default;\n+\n+#endif\n+\n   std::size_t\n   hash() const noexcept\n   { return std::size_t(bar ^ baz ^ meh); }\n@@ -54,36 +70,30 @@ struct HashFunction\n     { return t.hash(); }\n };\n \n+const int sz = 300000;\n+\n template<typename _ContType>\n-  void bench(const char* container_desc)\n+  void\n+  bench(const char* container_desc, const typename _ContType::value_type* foos)\n   {\n     using namespace __gnu_test;\n \n+    _ContType s;\n+\n     time_counter time;\n     resource_counter resource;\n-\n-    const int sz = 300000;\n-\n-    Foo foos[sz];\n-    {\n-      std::random_device randev;\n-      for (int i = 0; i != sz; ++i)\n-\tfoos[i].init(randev);\n-    }\n-\n-    _ContType s;\n     start_counters(time, resource);\n \n     for (int i = 0; i != sz ; ++i)\n-      s.insert(foos[i]);\n+\ts.insert(foos[i]);\n \n     stop_counters(time, resource);\n     std::ostringstream ostr;\n-    ostr << container_desc << sz << \" Foo insertions\";\n+    ostr << container_desc << sz << \" insertion attempts, \" \n+\t << s.size() << \" inserted\";\n     report_performance(__FILE__, ostr.str().c_str(), time, resource);\n \n     // Try to insert again to check performance of collision detection\n-    \n     const int nb_loop = 10;\n     start_counters(time, resource);\n \n@@ -94,7 +104,7 @@ template<typename _ContType>\n     stop_counters(time, resource);\n     ostr.str(\"\");\n     ostr << container_desc << nb_loop << \" times insertion of \"\n-\t << sz << \" Foo\";\n+\t << sz << \" elements\";\n     report_performance(__FILE__, ostr.str().c_str(), time, resource);\n   }\n \n@@ -121,12 +131,58 @@ template<bool cache>\n \n int main()\n {\n-  bench<__tr1_uset<false>>(\"std::tr1::unordered_set without hash code cached \");\n-  bench<__tr1_uset<true>>(\"std::tr1::unordered_set with hash code cached \");\n-  bench<__tr1_umset<false>>(\"std::tr1::unordered_multiset without hash code cached \");\n-  bench<__tr1_umset<true>>(\"std::tr1::unordered_multiset with hash code cached \");\n-  bench<__uset<false>>(\"std::unordered_set without hash code cached \");\n-  bench<__uset<true>>(\"std::unordered_set with hash code cached \");\n-  bench<__umset<false>>(\"std::unordered_multiset without hash code cached \");\n-  bench<__umset<true>>(\"std::unordered_multiset with hash code cached \");\n+  using namespace __gnu_test;\n+\n+  {\n+    int bars[sz];\n+    for (int i = 0; i != sz; ++i)\n+      bars[i] = i;\n+    bench<std::tr1::unordered_set<int>>(\n+\t\"std::tr1::unordered_set<int> \", bars);\n+    bench<std::unordered_set<int>>(\n+\t\"std::unordered_set<int> \", bars);\n+  }\n+\n+  Foo foos[sz];\n+#if USE_MY_FOO\n+  {\n+    std::random_device randev;\n+    for (int i = 0; i != sz; ++i)\n+      foos[i].init(randev);\n+  }\n+#endif\n+\n+  time_counter time;\n+  resource_counter resource;\n+  start_counters(time, resource);\n+\n+  bench<__tr1_uset<false>>(\n+\t\"std::tr1::unordered_set without hash code cached \", foos);\n+  bench<__tr1_uset<true>>(\n+\t\"std::tr1::unordered_set with hash code cached \", foos);\n+  bench<__tr1_umset<false>>(\n+\t\"std::tr1::unordered_multiset without hash code cached \", foos);\n+  bench<__tr1_umset<true>>(\n+\t\"std::tr1::unordered_multiset with hash code cached \", foos);\n+\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"tr1 benches\", time, resource);\n+\n+  start_counters(time, resource);\n+  bench<__uset<false>>(\n+\t\"std::unordered_set without hash code cached \", foos);\n+  bench<__uset<true>>(\n+\t\"std::unordered_set with hash code cached \", foos);\n+  bench<__umset<false>>(\n+\t\"std::unordered_multiset without hash code cached \", foos);\n+  bench<__umset<true>>(\n+\t\"std::unordered_multiset with hash code cached \", foos);\n+\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"std benches\", time, resource);\n+\n+  bench<std::unordered_set<Foo, HashFunction>>(\n+\t\"std::unordered_set default cache \", foos);\n+  bench<std::unordered_multiset<Foo, HashFunction>>(\n+\t\"std::unordered_multiset default cache \", foos);\n }"}, {"sha": "9b59e803c4a8af24b32e94995fb56fb8de5cd790", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert_erase/41975.cc", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3be7cf99e5b833c073c119be2b60c84db7ec35/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc?ref=5b3be7cf99e5b833c073c119be2b60c84db7ec35", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2011-2013 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,46 +18,31 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <sstream>\n-#ifdef _USE_TR1\n-#  include <tr1/unordered_set>\n-#else\n-#  include <unordered_set>\n-#endif\n+#include <tr1/unordered_set>\n+#include <unordered_set>\n #include <testsuite_performance.h>\n \n namespace\n {\n   // Bench using an unordered_set<int>. Hash functor for int is quite\n   // predictable so it helps bench very specific use cases.\n-  template<bool use_cache>\n-    void bench()\n+  template<typename _ContType>\n+    void bench(const char* desc)\n     {\n       using namespace __gnu_test;\n-      std::ostringstream ostr;\n-      ostr << \"unordered_set<int> \" << (use_cache ? \"with\" : \"without\")\n-\t   << \" cache\";\n-      const std::string desc = ostr.str();\n \n       time_counter time;\n       resource_counter resource;\n \n       const int nb = 200000;\n       start_counters(time, resource);\n \n-#ifdef _USE_TR1\n-      std::tr1::__unordered_set<int, std::hash<int>, std::equal_to<int>,\n-\t\t\t\tstd::allocator<int>,\n-\t\t\t       \tuse_cache> us;\n-#else\n-      std::__uset_hashtable<int, std::hash<int>, std::equal_to<int>,\n-\t\t\t    std::allocator<int>,\n-\t\t\t    std::__uset_traits<use_cache>> us;\n-#endif\n+      _ContType us;\n       for (int i = 0; i != nb; ++i)\n \t  us.insert(i);\n \n       stop_counters(time, resource);\n-      ostr.str(\"\");\n+      std::ostringstream ostr;\n       ostr << desc << \": first insert\";\n       report_performance(__FILE__, ostr.str().c_str(), time, resource);\n \n@@ -110,21 +95,18 @@ namespace\n   // Bench using unordered_set<string> that show how important it is to cache\n   // hash code as computing string hash code is quite expensive compared to\n   // computing it for int.\n-  template<bool use_cache>\n-    void bench_str()\n+  template<typename _ContType>\n+    void bench_str(const char* desc)\n     {\n       using namespace __gnu_test;\n-      std::ostringstream ostr;\n-      ostr << \"unordered_set<string> \" << (use_cache ? \"with\" : \"without\")\n-\t   << \" cache\";\n-      const std::string desc = ostr.str();\n \n       time_counter time;\n       resource_counter resource;\n \n       const int nb = 200000;\n       // First generate once strings that are going to be used throughout the\n       // bench:\n+      std::ostringstream ostr;\n       std::vector<std::string> strs;\n       strs.reserve(nb);\n       for (int i = 0; i != nb; ++i)\n@@ -136,17 +118,7 @@ namespace\n \n       start_counters(time, resource);\n \n-#ifdef _USE_TR1\n-      std::tr1::__unordered_set<std::string, std::hash<std::string>,\n-\t\t\t\tstd::equal_to<std::string>,\n-\t\t\t\tstd::allocator<std::string>,\n-\t\t\t\tuse_cache> us;\n-#else\n-      std::__uset_hashtable<std::string, std::hash<std::string>,\n-\t\t\t    std::equal_to<std::string>,\n-\t\t\t    std::allocator<std::string>,\n-\t\t\t    std::__uset_traits<use_cache>> us;\n-#endif\n+      _ContType us;\n       for (int i = 0; i != nb; ++i)\n \tus.insert(strs[i]);\n \n@@ -192,11 +164,53 @@ namespace\n     }\n }\n \n+template<bool cache>\n+  using __uset =\n+\t      std::__uset_hashtable<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t\t    std::allocator<int>,\n+\t\t\t\t    std::__uset_traits<cache>>;\n+\n+template<bool cache>\n+  using __tr1_uset =\n+\t      std::tr1::__unordered_set<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t\t\tstd::allocator<int>,\n+\t\t\t\t\tcache>;\n+\n+template<bool cache>\n+  using __str_uset = \n+\t      std::__uset_hashtable<std::string, std::hash<std::string>,\n+\t\t\t\t    std::equal_to<std::string>,\n+\t\t\t\t    std::allocator<std::string>,\n+\t\t\t\t    std::__uset_traits<cache>>;\n+\n+template<bool cache>\n+  using __tr1_str_uset = \n+\t      std::tr1::__unordered_set<std::string, std::hash<std::string>,\n+\t\t\t\t\tstd::equal_to<std::string>,\n+\t\t\t\t\tstd::allocator<std::string>,\n+\t\t\t\t\tcache>;\n+\n int main()\n {\n-  bench<false>();\n-  bench<true>();\n-  bench_str<false>();\n-  bench_str<true>();\n+  bench<__tr1_uset<false>>(\n+\t\"std::tr1::unordered_set<int> without hash code cached\");\n+  bench<__tr1_uset<true>>(\n+\t\"std::tr1::unordered_set<int> with hash code cached\");\n+  bench<__uset<false>>(\n+\t\"std::unordered_set<int> without hash code cached\");\n+  bench<__uset<true>>(\n+\t\"std::unordered_set<int> with hash code cached\");\n+  bench<std::unordered_set<int>>(\n+\t\"std::unordered_set<int> default cache\");\n+  bench_str<__tr1_str_uset<false>>(\n+\t\"std::tr1::unordered_set<string> without hash code cached\");\n+  bench_str<__tr1_str_uset<true>>(\n+\t\"std::tr1::unordered_set<string> with hash code cached\");\n+  bench_str<__str_uset<false>>(\n+\t\"std::unordered_set<string> without hash code cached\");\n+  bench_str<__str_uset<true>>(\n+\t\"std::unordered_set<string> with hash code cached\");\n+    bench_str<std::unordered_set<std::string>>(\n+\t\"std::unordered_set<string> default cache\");\n   return 0;\n }"}]}