{"sha": "e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0ODFjZjVmY2ZhNWMzZGViMjFmNmViZmJkZjU5OGVhMzU2MjczMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-09-16T08:51:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-26T08:59:07Z"}, "message": "[Ada] Minor editions to documentation of Ada.Text_IO.Fixed_IO\n\ngcc/ada/\n\n\t* libgnat/a-tifiio.adb: Minor editions to documentation.", "tree": {"sha": "746082b466d95f4fc13a4222477a4e9af6d8221b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/746082b466d95f4fc13a4222477a4e9af6d8221b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "326c36ce378edd0d965bb6dfd3d98a90668fff30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326c36ce378edd0d965bb6dfd3d98a90668fff30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/326c36ce378edd0d965bb6dfd3d98a90668fff30"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "35951dc30767b9874f8e6755f051380942d29e8a", "filename": "gcc/ada/libgnat/a-tifiio.adb", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb?ref=e0481cf5fcfa5c3deb21f6ebfbdf598ea3562732", "patch": "@@ -32,40 +32,38 @@\n --  Fixed point I/O\n --  ---------------\n \n---  The following documents implementation details of the fixed point\n---  input/output routines in the GNAT run time. The first part describes\n---  general properties of fixed point types as defined by the Ada 95 standard,\n+--  The following text documents implementation details of the fixed point\n+--  input/output routines in the GNAT runtime. The first part describes the\n+--  general properties of fixed point types as defined by the Ada standard,\n --  including the Information Systems Annex.\n \n --  Subsequently these are reduced to implementation constraints and the impact\n---  of these constraints on a few possible approaches to I/O are given.\n+--  of these constraints on a few possible approaches to input/output is given.\n --  Based on this analysis, a specific implementation is selected for use in\n---  the GNAT run time. Finally, the chosen algorithm is analyzed numerically in\n+--  the GNAT runtime. Finally, the chosen algorithm is analyzed numerically in\n --  order to provide user-level documentation on limits for range and precision\n --  of fixed point types as well as accuracy of input/output conversions.\n \n --  -------------------------------------------\n --  - General Properties of Fixed Point Types -\n --  -------------------------------------------\n \n---  Operations on fixed point values, other than input and output, are not\n---  important for the purposes of this document. Only the set of values that a\n---  fixed point type can represent and the input and output operations are\n---  significant.\n+--  Operations on fixed point types, other than input/output, are not important\n+--  for the purpose of this document. Only the set of values that a fixed point\n+--  type can represent and the input/output operations are significant.\n \n --  Values\n --  ------\n \n---  Set set of values of a fixed point type comprise the integral\n---  multiples of a number called the small of the type. The small can\n---  either be a power of ten, a power of two or (if the implementation\n---  allows) an arbitrary strictly positive real value.\n+--  The set of values of a fixed point type comprise the integral multiples of\n+--  a number called the small of the type. The small can be either a power of\n+--  two, a power of ten or (if the implementation allows) an arbitrary strictly\n+--  positive real value.\n \n---  Implementations need to support fixed-point types with a precision\n---  of at least 24 bits, and (in order to comply with the Information\n---  Systems Annex) decimal types need to support at least digits 18.\n---  For the rest, however, no requirements exist for the minimal small\n---  and range that need to be supported.\n+--  Implementations need to support ordinary fixed point types with a precision\n+--  of at least 24 bits, and (in order to comply with the Information Systems\n+--  Annex) decimal fixed point types with at least 18 digits. For the rest, no\n+--  requirements exist for the minimal small and range that must be supported.\n \n --  Operations\n --  ----------\n@@ -112,27 +110,27 @@\n --  Implementation Strategies\n --  -------------------------\n \n---  * Float arithmetic\n+--  * Floating point arithmetic\n --  * Arbitrary-precision integer arithmetic\n --  * Fixed-precision integer arithmetic\n \n---  Although it seems convenient to convert fixed point numbers to floating-\n+--  Although it seems convenient to convert fixed point numbers to floating\n --  point and then print them, this leads to a number of restrictions.\n --  The first one is precision. The widest floating-point type generally\n --  available has 53 bits of mantissa. This means that Fine_Delta cannot\n --  be less than 2.0**(-53).\n \n---  In GNAT, Fine_Delta is 2.0**(-63), and Duration for example is a\n---  64-bit type. It would still be possible to use multi-precision\n---  floating-point to perform calculations using longer mantissas,\n---  but this is a much harder approach.\n+--  In GNAT, Fine_Delta is 2.0**(-63), and Duration for example is a 64-bit\n+--  type. This means that a floating-point type with 63 bits of mantissa needs\n+--  to be used, which is only generally available on the x86 architecture. It\n+--  would still be possible to use multi-precision floating point to perform\n+--  calculations using longer mantissas, but this is a much harder approach.\n \n---  The base conversions needed for input and output of (non-decimal)\n---  fixed point types can be seen as pairs of integer multiplications\n---  and divisions.\n+--  The base conversions needed for input/output of (non-decimal) fixed point\n+--  types can be seen as pairs of integer multiplications and divisions.\n \n---  Arbitrary-precision integer arithmetic would be suitable for the job\n---  at hand, but has the draw-back that it is very heavy implementation-wise.\n+--  Arbitrary-precision integer arithmetic would be suitable for the job at\n+--  hand, but has the drawback that it is very heavy implementation-wise.\n --  Especially in embedded systems, where fixed point types are often used,\n --  it may not be desirable to require large amounts of storage and time\n --  for fixed I/O operations.\n@@ -181,7 +179,7 @@ package body Ada.Text_IO.Fixed_IO is\n \n    --    Fore + Aft + Exp + Extra_Layout_Space\n \n-   --  is always long enough for formatting any fixed point number\n+   --  is always long enough for formatting any fixed point number.\n \n    --  Implementation of Put routines\n \n@@ -205,9 +203,9 @@ package body Ada.Text_IO.Fixed_IO is\n    --  factor 10**E can be trivially handled during final output, by adjusting\n    --  the decimal point or exponent.\n \n-   --  Convert a value X * S of type T to a 64-bit integer value Q equal\n-   --  to 10.0**D * (X * S) rounded to the nearest integer.\n-   --  This conversion is a scaled integer divide of the form\n+   --  Convert a value X * S of type T to a 64-bit integer value Q equal to\n+   --  10.0**D * (X * S) rounded to the nearest integer. This conversion is\n+   --  a scaled integer divide of the form\n \n    --     Q := (X * Y) / Z,\n \n@@ -242,8 +240,8 @@ package body Ada.Text_IO.Fixed_IO is\n    --     S * 10.0**D = Y / Z;\n \n    --  If S is an integer greater than or equal to one, then Fore must be at\n-   --  least 20 in order to print T'First, which is at most -2.0**63.\n-   --  This means D < 0, so use\n+   --  least 20 in order to print T'First, which is at most -2.0**63. This\n+   --  means that D < 0, so use\n \n    --    (1)   Y = -S and Z = -10**(-D)\n "}]}