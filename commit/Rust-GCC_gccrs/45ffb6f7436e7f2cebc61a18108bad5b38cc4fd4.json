{"sha": "45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmZmI2Zjc0MzZlN2YyY2ViYzYxYTE4MTA4YmFkNWIzOGNjNGZkNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-07-11T11:53:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-07-11T11:53:23Z"}, "message": "DR 1402\n\n\tDR 1402\n\t* method.c (synthesized_method_walk): Replace uses of msg with diag.\n\tCorrect handling of virtual bases with move operations.\n\t(process_subob_fn, walk_field_subobs): Replace uses of msg with diag.\n\nFrom-SVN: r189426", "tree": {"sha": "a8706d18216573732634c99a664840765d92409b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8706d18216573732634c99a664840765d92409b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bdf3519449086bc04f2431305607ff8c71e27ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdf3519449086bc04f2431305607ff8c71e27ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdf3519449086bc04f2431305607ff8c71e27ca"}], "stats": {"total": 124, "additions": 78, "deletions": 46}, "files": [{"sha": "fd2ba7315cd88a530be52ebf6749d2666a972bef", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "patch": "@@ -1,3 +1,10 @@\n+2012-07-11  Jason Merrill  <jason@redhat.com>\n+\n+\tDR 1402\n+\t* method.c (synthesized_method_walk): Replace uses of msg with diag.\n+\tCorrect handling of virtual bases with move operations.\n+\t(process_subob_fn, walk_field_subobs): Replace uses of msg with diag.\n+\n 2012-07-11  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* method.c: Do not include tree-pass.h."}, {"sha": "bd0792fae3bbb15d1f6bc245b44aab11c749b27f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "patch": "@@ -922,7 +922,7 @@ get_copy_assign (tree type)\n static void\n process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n \t\t  bool *deleted_p, bool *constexpr_p, bool *no_implicit_p,\n-\t\t  const char *msg, tree arg)\n+\t\t  bool diag, tree arg)\n {\n   if (!fn || fn == error_mark_node)\n     goto bad;\n@@ -942,7 +942,7 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n \t{\n \t  if (deleted_p)\n \t    *deleted_p = true;\n-\t  if (msg)\n+\t  if (diag)\n \t    error (\"union member %q+D with non-trivial %qD\", arg, fn);\n \t}\n     }\n@@ -955,7 +955,7 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n   if (constexpr_p && !DECL_DECLARED_CONSTEXPR_P (fn))\n     {\n       *constexpr_p = false;\n-      if (msg)\n+      if (diag)\n \t{\n \t  inform (0, \"defaulted constructor calls non-constexpr \"\n \t\t  \"%q+D\", fn);\n@@ -978,7 +978,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\t   int quals, bool copy_arg_p, bool move_p,\n \t\t   bool assign_p, tree *spec_p, bool *trivial_p,\n \t\t   bool *deleted_p, bool *constexpr_p, bool *no_implicit_p,\n-\t\t   const char *msg, int flags, tsubst_flags_t complain)\n+\t\t   bool diag, int flags, tsubst_flags_t complain)\n {\n   tree field;\n   for (field = fields; field; field = DECL_CHAIN (field))\n@@ -995,13 +995,13 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t  bool bad = true;\n \t  if (CP_TYPE_CONST_P (mem_type) && !CLASS_TYPE_P (mem_type))\n \t    {\n-\t      if (msg)\n+\t      if (diag)\n \t\terror (\"non-static const member %q#D, can%'t use default \"\n \t\t       \"assignment operator\", field);\n \t    }\n \t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n \t    {\n-\t      if (msg)\n+\t      if (diag)\n \t\terror (\"non-static reference member %q#D, can%'t use \"\n \t\t       \"default assignment operator\", field);\n \t    }\n@@ -1017,7 +1017,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \n \t  if (DECL_INITIAL (field))\n \t    {\n-\t      if (msg && DECL_INITIAL (field) == error_mark_node)\n+\t      if (diag && DECL_INITIAL (field) == error_mark_node)\n \t\tinform (0, \"initializer for %q+#D is invalid\", field);\n \t      if (trivial_p)\n \t\t*trivial_p = false;\n@@ -1040,14 +1040,14 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t  if (CP_TYPE_CONST_P (mem_type)\n \t      && default_init_uninitialized_part (mem_type))\n \t    {\n-\t      if (msg)\n+\t      if (diag)\n \t\terror (\"uninitialized non-static const member %q#D\",\n \t\t       field);\n \t      bad = true;\n \t    }\n \t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n \t    {\n-\t      if (msg)\n+\t      if (diag)\n \t\terror (\"uninitialized non-static reference member %q#D\",\n \t\t       field);\n \t      bad = true;\n@@ -1063,7 +1063,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t      && TREE_CODE (DECL_CONTEXT (field)) != UNION_TYPE)\n \t    {\n \t      *constexpr_p = false;\n-\t      if (msg)\n+\t      if (diag)\n \t\tinform (0, \"defaulted default constructor does not \"\n \t\t\t\"initialize %q+#D\", field);\n \t    }\n@@ -1077,7 +1077,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t  walk_field_subobs (TYPE_FIELDS (mem_type), fnname, sfk, quals,\n \t\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n \t\t\t     deleted_p, constexpr_p, no_implicit_p,\n-\t\t\t     msg, flags, complain);\n+\t\t\t     diag, flags, complain);\n \t  continue;\n \t}\n \n@@ -1094,7 +1094,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n       rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n \n       process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tconstexpr_p, no_implicit_p, msg, field);\n+\t\t\tconstexpr_p, no_implicit_p, diag, field);\n     }\n }\n \n@@ -1115,7 +1115,6 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   VEC(tree,gc) *vbases;\n   int i, quals, flags;\n   tsubst_flags_t complain;\n-  const char *msg;\n   bool ctor_p;\n \n   if (spec_p)\n@@ -1239,25 +1238,21 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     quals = TYPE_UNQUALIFIED;\n   argtype = NULL_TREE;\n \n-  if (!diag)\n-    msg = NULL;\n-  else if (assign_p)\n-    msg = (\"base %qT does not have a move assignment operator or trivial \"\n-\t   \"copy assignment operator\");\n-  else\n-    msg = (\"base %qT does not have a move constructor or trivial \"\n-\t   \"copy constructor\");\n-\n   for (binfo = TYPE_BINFO (ctype), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n       tree basetype = BINFO_TYPE (base_binfo);\n+\n+      if (!assign_p && BINFO_VIRTUAL_P (base_binfo))\n+\t/* We'll handle virtual bases below.  */\n+\tcontinue;\n+\n       if (copy_arg_p)\n \targtype = build_stub_type (basetype, quals, move_p);\n       rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n       process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tconstexpr_p, no_implicit_p, msg, basetype);\n+\t\t\tconstexpr_p, no_implicit_p, diag, basetype);\n       if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n \t{\n \t  /* In a constructor we also need to check the subobject\n@@ -1270,7 +1265,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t     throw) or exception-specification (a throw from one of the\n \t     dtors would be a double-fault).  */\n \t  process_subob_fn (rval, false, NULL, NULL,\n-\t\t\t    deleted_p, NULL, NULL, NULL,\n+\t\t\t    deleted_p, NULL, NULL, false,\n \t\t\t    basetype);\n \t}\n \n@@ -1287,21 +1282,31 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     }\n \n   vbases = CLASSTYPE_VBASECLASSES (ctype);\n-  if (vbases && assign_p && move_p)\n+  if (vbases == NULL)\n+    /* No virtual bases to worry about.  */;\n+  else if (assign_p && move_p && no_implicit_p)\n     {\n+      /* Don't implicitly declare a defaulted move assignment if a virtual\n+\t base has non-trivial move assignment, since moving the same base\n+\t more than once is dangerous.  */\n       /* Should the spec be changed to allow vbases that only occur once?  */\n-      if (diag)\n-\terror (\"%qT has virtual bases, default move assignment operator \"\n-\t       \"cannot be generated\", ctype);\n-      else if (deleted_p)\n-\t*deleted_p = true;\n+      FOR_EACH_VEC_ELT (tree, vbases, i, base_binfo)\n+\t{\n+\t  tree basetype = BINFO_TYPE (base_binfo);\n+\t  if (copy_arg_p)\n+\t    argtype = build_stub_type (basetype, quals, move_p);\n+\t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n+\t  if (rval && rval != error_mark_node\n+\t      && move_fn_p (rval) && !trivial_fn_p (rval))\n+\t    {\n+\t      *no_implicit_p = true;\n+\t      break;\n+\t    }\n+\t}\n     }\n   else if (!assign_p)\n     {\n-      if (diag)\n-\tmsg = (\"virtual base %qT does not have a move constructor \"\n-\t       \"or trivial copy constructor\");\n-      if (vbases && constexpr_p)\n+      if (constexpr_p)\n \t*constexpr_p = false;\n       FOR_EACH_VEC_ELT (tree, vbases, i, base_binfo)\n \t{\n@@ -1311,35 +1316,29 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n \t  process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\t    constexpr_p, no_implicit_p, msg, basetype);\n+\t\t\t    constexpr_p, no_implicit_p, diag, basetype);\n \t  if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n \t    {\n \t      rval = locate_fn_flags (base_binfo, complete_dtor_identifier,\n \t\t\t\t      NULL_TREE, flags, complain);\n \t      process_subob_fn (rval, false, NULL, NULL,\n-\t\t\t\tdeleted_p, NULL, NULL, NULL,\n+\t\t\t\tdeleted_p, NULL, NULL, false,\n \t\t\t\tbasetype);\n \t    }\n \t}\n     }\n-  if (!diag)\n-    /* Leave msg null. */;\n-  else if (assign_p)\n-    msg = (\"non-static data member %qD does not have a move \"\n-\t   \"assignment operator or trivial copy assignment operator\");\n-  else\n-    msg = (\"non-static data member %qD does not have a move \"\n-\t   \"constructor or trivial copy constructor\");\n+\n+  /* Now handle the non-static data members.  */\n   walk_field_subobs (TYPE_FIELDS (ctype), fnname, sfk, quals,\n \t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n \t\t     deleted_p, constexpr_p, no_implicit_p,\n-\t\t     msg, flags, complain);\n+\t\t     diag, flags, complain);\n   if (ctor_p)\n     walk_field_subobs (TYPE_FIELDS (ctype), complete_dtor_identifier,\n \t\t       sfk_destructor, TYPE_UNQUALIFIED, false,\n \t\t       false, false, NULL, NULL,\n \t\t       deleted_p, NULL,\n-\t\t       NULL, NULL, flags, complain);\n+\t\t       NULL, false, flags, complain);\n \n   pop_scope (scope);\n "}, {"sha": "a82ac1c09220ecd7570a5fc039f92c0eaa7529b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "patch": "@@ -1,3 +1,8 @@\n+2012-07-11  Jason Merrill  <jason@redhat.com>\n+\n+\tDR 1402\n+\t* g++.g/cpp0x/defaulted37.C: New.\n+\n 2012-07-11  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \tPR target/53859"}, {"sha": "69105cc3146e0693feab37393c9b954ab1cd63fb", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted37.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted37.C?ref=45ffb6f7436e7f2cebc61a18108bad5b38cc4fd4", "patch": "@@ -0,0 +1,21 @@\n+// DR 1402\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  int moved = 0;\n+  A& operator=(A&&) { ++moved; }\n+  ~A() { if (moved > 1) __builtin_abort(); }\n+};\n+\n+struct B: virtual A { B& operator=(B&&) = default; };\n+struct C: virtual A { };\t// { dg-error \"operator=.const A&\" }\n+\n+int main()\n+{\n+  B b1, b2;\n+  b2 = static_cast<B&&>(b1);\n+\n+  C c1, c2;\n+  c2 = static_cast<C&&>(c1);\t// { dg-error \"operator=.const C&\" }\n+}"}]}