{"sha": "cb2ec1510d0661c159a0405c8e1791ff986d8b28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IyZWMxNTEwZDA2NjFjMTU5YTA0MDVjOGUxNzkxZmY5ODZkOGIyOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-30T21:36:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-30T21:36:13Z"}, "message": "ggc-common.c: Update pre-function commentary.\n\n\t* ggc-common.c: Update pre-function commentary.\n\t* ggc-page.c: Likewise.\n\t(poison): Remove.\n\t(poison_pages): Use memset directly.\n\t(ggc_alloc_obj): Likewise.  Use a different pattern than poison_pages.\n\t(ggc_collect): Poison before sweeping.\n\t* ggc-simple.c: Update pre-function commentary.\n\t(ggc_alloc_obj): Poison non-zeroed memory.\n\nFrom-SVN: r30275", "tree": {"sha": "c179cab27ce27f6172b9dfdffd3e669d553f80f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c179cab27ce27f6172b9dfdffd3e669d553f80f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb2ec1510d0661c159a0405c8e1791ff986d8b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2ec1510d0661c159a0405c8e1791ff986d8b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2ec1510d0661c159a0405c8e1791ff986d8b28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2ec1510d0661c159a0405c8e1791ff986d8b28/comments", "author": null, "committer": null, "parents": [{"sha": "e225758aeea3737865fc2341560d5c3f7ddf3d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e225758aeea3737865fc2341560d5c3f7ddf3d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e225758aeea3737865fc2341560d5c3f7ddf3d52"}], "stats": {"total": 118, "additions": 90, "deletions": 28}, "files": [{"sha": "718a270bb9fd20478a960c5e1b51b2ee731891da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb2ec1510d0661c159a0405c8e1791ff986d8b28", "patch": "@@ -1,3 +1,14 @@\n+Sat Oct 30 14:31:48 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* ggc-common.c: Update pre-function commentary.\n+\t* ggc-page.c: Likewise.\n+\t(poison): Remove.\n+\t(poison_pages): Use memset directly.\n+\t(ggc_alloc_obj): Likewise.  Use a different pattern than poison_pages.\n+\t(ggc_collect): Poison before sweeping.\n+\t* ggc-simple.c: Update pre-function commentary.\n+\t(ggc_alloc_obj): Poison non-zeroed memory.\n+\n Sat Oct 30 14:28:52 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ggc-common.c (ggc_print_statistics): Make arguments to fprintf"}, {"sha": "8c15dc07ede6e254786ebb41769b3c54e1574c21", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=cb2ec1510d0661c159a0405c8e1791ff986d8b28", "patch": "@@ -97,13 +97,22 @@ ggc_mark_tree_hash_table_ptr (elt)\n   ggc_mark_tree_hash_table (*(struct hash_table **) elt);\n }\n \n+/* Type-correct function to pass to ggc_add_root.  It just forwards\n+   ELT (which is really a char **) to ggc_mark_string.  */\n+\n static void\n ggc_mark_string_ptr (elt)\n      void *elt;\n {\n   ggc_mark_string (*(char **)elt);\n }\n \n+/* Add BASE as a new garbage collection root.  It is an array of\n+   length NELT with each element SIZE bytes long.  CB is a \n+   function that will be called with a pointer to each element\n+   of the array; it is the intention that CB call the appropriate\n+   routine to mark gc-able memory for that element.  */\n+\n void\n ggc_add_root (base, nelt, size, cb)\n      void *base;\n@@ -121,6 +130,8 @@ ggc_add_root (base, nelt, size, cb)\n   roots = x;\n }\n \n+/* Register an array of rtx as a GC root.  */\n+\n void\n ggc_add_rtx_root (base, nelt)\n      rtx *base;\n@@ -129,6 +140,8 @@ ggc_add_rtx_root (base, nelt)\n   ggc_add_root (base, nelt, sizeof(rtx), ggc_mark_rtx_ptr);\n }\n \n+/* Register an array of trees as a GC root.  */\n+\n void\n ggc_add_tree_root (base, nelt)\n      tree *base;\n@@ -137,7 +150,7 @@ ggc_add_tree_root (base, nelt)\n   ggc_add_root (base, nelt, sizeof(tree), ggc_mark_tree_ptr);\n }\n \n-/* Add V (a varray full of trees) to the list of GC roots.  */\n+/* Register a varray of trees as a GC root.  */\n \n void\n ggc_add_tree_varray_root (base, nelt)\n@@ -148,8 +161,7 @@ ggc_add_tree_varray_root (base, nelt)\n \t\tggc_mark_tree_varray_ptr);\n }\n \n-/* Add HT (a hash-table where ever key is a tree) to the list of GC\n-   roots.  */\n+/* Register a hash table of trees as a GC root.  */\n \n void\n ggc_add_tree_hash_table_root (base, nelt)\n@@ -160,6 +172,8 @@ ggc_add_tree_hash_table_root (base, nelt)\n \t\tggc_mark_tree_hash_table_ptr);\n }\n \n+/* Register an array of strings as a GC root.  */\n+\n void\n ggc_add_string_root (base, nelt)\n      char **base;\n@@ -168,6 +182,7 @@ ggc_add_string_root (base, nelt)\n   ggc_add_root (base, nelt, sizeof (char *), ggc_mark_string_ptr);\n }\n \n+/* Remove the previously registered GC root at BASE.  */\n \n void\n ggc_del_root (base)\n@@ -191,6 +206,8 @@ ggc_del_root (base)\n   abort();\n }\n \n+/* Iterate through all registered roots and mark each element.  */\n+\n void\n ggc_mark_roots ()\n {\n@@ -208,6 +225,9 @@ ggc_mark_roots ()\n     }\n }\n \n+/* R had not been previously marked, but has now been marked via\n+   ggc_set_mark.  Now recurse and process the children.  */\n+\n void\n ggc_mark_rtx_children (r)\n      rtx r;\n@@ -285,6 +305,9 @@ ggc_mark_rtx_children (r)\n     }\n }\n \n+/* V had not been previously marked, but has now been marked via\n+   ggc_set_mark.  Now recurse and process the children.  */\n+\n void\n ggc_mark_rtvec_children (v)\n      rtvec v;\n@@ -296,6 +319,9 @@ ggc_mark_rtvec_children (v)\n     ggc_mark_rtx (RTVEC_ELT (v, i));\n }\n \n+/* T had not been previously marked, but has now been marked via\n+   ggc_set_mark.  Now recurse and process the children.  */\n+\n void\n ggc_mark_tree_children (t)\n      tree t;\n@@ -466,7 +492,10 @@ ggc_mark_tree_hash_table (ht)\n   hash_traverse (ht, ggc_mark_tree_hash_table_entry, /*info=*/0);\n }\n \n-/* Allocation wrappers.  */\n+/* Allocate a gc-able string.  If CONTENTS is null, then the memory will\n+   be uninitialized.  If LENGTH is -1, then CONTENTS is assumed to be a\n+   null-terminated string and the memory sized accordingly.  Otherwise,\n+   the memory is filled with LENGTH bytes from CONTENTS.  */\n \n char *\n ggc_alloc_string (contents, length)"}, {"sha": "9177943d88e3f18d2c54bb947dfd2d8488cda376", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=cb2ec1510d0661c159a0405c8e1791ff986d8b28", "patch": "@@ -281,7 +281,6 @@ static void clear_marks PROTO ((void));\n static void sweep_pages PROTO ((void));\n \n #ifdef GGC_POISON\n-static void poison PROTO ((void *, size_t));\n static void poison_pages PROTO ((void));\n #endif\n \n@@ -346,8 +345,8 @@ lookup_page_table_entry(p)\n   return base[L1][L2];\n }\n \n-\n /* Set the page table entry for a page.  */\n+\n static void\n set_page_table_entry(p, entry)\n      void *p;\n@@ -384,8 +383,8 @@ set_page_table_entry(p, entry)\n   base[L1][L2] = entry;\n }\n \n-\n /* Prints the page-entry for object size ORDER, for debugging.  */\n+\n void\n debug_print_page_list (order)\n      int order;\n@@ -402,20 +401,9 @@ debug_print_page_list (order)\n   fflush (stdout);\n }\n \n-#ifdef GGC_POISON\n-/* `Poisons' the region of memory starting at START and extending for\n-   LEN bytes.  */\n-static inline void\n-poison (start, len)\n-     void *start;\n-     size_t len;\n-{\n-  memset (start, 0xa5, len);\n-}\n-#endif\n-\n /* Allocate SIZE bytes of anonymous memory, preferably near PREF,\n    (if non-null).  */\n+\n static inline char *\n alloc_anon (pref, size)\n      char *pref ATTRIBUTE_UNUSED;\n@@ -456,6 +444,7 @@ alloc_anon (pref, size)\n /* Allocate a new page for allocating objects of size 2^ORDER,\n    and return an entry for it.  The entry is not added to the\n    appropriate page_table list.  */\n+\n static inline struct page_entry *\n alloc_page (order)\n      unsigned order;\n@@ -496,7 +485,7 @@ alloc_page (order)\n     }\n   else\n     {\n-      /* Actually allocate the memory, using mmap.  */\n+      /* Actually allocate the memory.  */\n       page = alloc_anon (NULL, entry_size);\n     }\n \n@@ -525,8 +514,8 @@ alloc_page (order)\n   return entry;\n }\n \n+/* For a page that is no longer needed, put it on the free page list.  */\n \n-/* Free a page when it's no longer needed.  */\n static inline void\n free_page (entry)\n      page_entry *entry;\n@@ -542,8 +531,8 @@ free_page (entry)\n   G.free_pages = entry;\n }\n \n+/* Release the free page cache to the system.  */\n \n-/* Release the page cache to the system.  */\n static inline void\n release_pages ()\n {\n@@ -598,9 +587,9 @@ release_pages ()\n   G.free_pages = NULL;\n }\n \n-\n /* This table provides a fast way to determine ceil(log_2(size)) for\n    allocation requests.  The minimum allocation size is four bytes.  */\n+\n static unsigned char const size_lookup[257] = \n { \n   2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, \n@@ -624,6 +613,7 @@ static unsigned char const size_lookup[257] =\n \n /* Allocate a chunk of memory of SIZE bytes.  If ZERO is non-zero, the\n    memory is zeroed; otherwise, its contents are undefined.  */\n+\n void *\n ggc_alloc_obj (size, zero)\n      size_t size;\n@@ -721,8 +711,9 @@ ggc_alloc_obj (size, zero)\n #ifdef GGC_POISON\n   /* `Poison' the entire allocated object before zeroing the requested area,\n      so that bytes beyond the end, if any, will not necessarily be zero.  */\n-  poison (result, 1 << order);\n+  memset (result, 0xaf, 1 << order);\n #endif\n+\n   if (zero)\n     memset (result, 0, size);\n \n@@ -738,10 +729,10 @@ ggc_alloc_obj (size, zero)\n   return result;\n }\n \n-\n-/* If P is not marked, marks it and returns 0.  Otherwise returns 1.\n+/* If P is not marked, marks it and return false.  Otherwise return true.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */\n+\n int\n ggc_set_mark (p)\n      void *p;\n@@ -780,6 +771,8 @@ ggc_set_mark (p)\n   return 0;\n }\n \n+/* Mark P, but check first that it was allocated by the collector.  */\n+\n void\n ggc_mark_if_gcable (p)\n      void *p;\n@@ -788,6 +781,8 @@ ggc_mark_if_gcable (p)\n     ggc_set_mark (p);\n }\n \n+/* Return the size of the gc-able object P.  */\n+\n size_t\n ggc_get_size (p)\n      void *p;\n@@ -797,6 +792,7 @@ ggc_get_size (p)\n }\n \f\n /* Initialize the ggc-mmap allocator.  */\n+\n void\n init_ggc ()\n {\n@@ -841,6 +837,8 @@ init_ggc ()\n   ggc_add_string_root (&empty_string, 1);\n }\n \n+/* Increment the `GC context'.  Objects allocated in an outer context\n+   are never freed, eliminating the need to register their roots.  */\n \n void\n ggc_push_context ()\n@@ -852,6 +850,8 @@ ggc_push_context ()\n     abort ();\n }\n \n+/* Decrement the `GC context'.  All objects allocated since the \n+   previous ggc_push_context are migrated to the outer context.  */\n \n void\n ggc_pop_context ()\n@@ -890,6 +890,8 @@ ggc_pop_context ()\n     }\n }\n \f\n+/* Unmark all objects.  */\n+\n static inline void\n clear_marks ()\n {\n@@ -932,6 +934,9 @@ clear_marks ()\n     }\n }\n \n+/* Free all empty pages.  Partially empty pages need no attention\n+   because the `mark' bit doubles as an `unused' bit.  */\n+\n static inline void\n sweep_pages ()\n {\n@@ -1024,6 +1029,8 @@ sweep_pages ()\n }\n \n #ifdef GGC_POISON\n+/* Clobber all free objects.  */\n+\n static inline void\n poison_pages ()\n {\n@@ -1052,13 +1059,15 @@ poison_pages ()\n \t      word = i / HOST_BITS_PER_LONG;\n \t      bit = i % HOST_BITS_PER_LONG;\n \t      if (((p->in_use_p[word] >> bit) & 1) == 0)\n-\t\tpoison (p->page + i * size, size);\n+\t\tmemset (p->page + i * size, 0xa5, size);\n \t    }\n \t}\n     }\n }\n #endif\n \n+/* Top level mark-and-sweep routine.  */\n+\n void\n ggc_collect ()\n {\n@@ -1086,12 +1095,13 @@ ggc_collect ()\n \n   clear_marks ();\n   ggc_mark_roots ();\n-  sweep_pages ();\n   \n #ifdef GGC_POISON\n   poison_pages ();\n #endif\n \n+  sweep_pages ();\n+\n   G.allocated_last_gc = G.allocated;\n   if (G.allocated_last_gc < GGC_MIN_LAST_ALLOCATED)\n     G.allocated_last_gc = GGC_MIN_LAST_ALLOCATED;"}, {"sha": "53d6579dbac0afe9d57a8d9593324782aef694b5", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2ec1510d0661c159a0405c8e1791ff986d8b28/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=cb2ec1510d0661c159a0405c8e1791ff986d8b28", "patch": "@@ -200,6 +200,10 @@ ggc_alloc_obj (size, zero)\n \n   if (zero)\n     memset (&x->u, 0, size);\n+#ifdef GGC_POISON\n+  else\n+    memset (&x->u, 0xaf, size);\n+#endif\n \n   tree_insert (x);\n   G.allocated += size;\n@@ -232,6 +236,8 @@ ggc_set_mark (p)\n   return 0;\n }\n \n+/* Mark a node, but check first to see that it's really gc-able memory.  */\n+\n void\n ggc_mark_if_gcable (p)\n      void *p;\n@@ -253,6 +259,8 @@ ggc_mark_if_gcable (p)\n   G.objects += 1;\n }\n \n+/* Return the size of the gc-able object P.  */\n+\n size_t\n ggc_get_size (p)\n      void *p;\n@@ -262,6 +270,8 @@ ggc_get_size (p)\n   return x->size;\n }\n \n+/* Unmark all objects.  */\n+\n static void\n clear_marks (x)\n      struct ggc_mem *x;\n@@ -273,6 +283,8 @@ clear_marks (x)\n     clear_marks (x->sub[1]);\n }\n \n+/* Free all objects in the current context that are not marked.  */\n+\n static void\n sweep_objs (root)\n      struct ggc_mem **root;"}]}