{"sha": "a6d7adfd473e40d71079c5751c12de64e3796a0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkN2FkZmQ0NzNlNDBkNzEwNzljNTc1MWMxMmRlNjRlMzc5NmEwZg==", "commit": {"author": {"name": "Greg McGary", "email": "gkm@gnu.org", "date": "2000-05-03T19:58:42Z"}, "committer": {"name": "Greg McGary", "email": "gkm@gcc.gnu.org", "date": "2000-05-03T19:58:42Z"}, "message": "tree.h (tree_common): Add bounded_flag member.\n\n\t* tree.h (tree_common): Add bounded_flag member.  Remove\n\tinaccurate comment about number of remaining bits.\n\t(BOUNDED_INDIRECT_TYPE_P, BOUNDED_POINTER_TYPE_P,\n\tBOUNDED_REFERENCE_TYPE_P, MAYBE_BOUNDED_INDIRECT_TYPE_P,\n\tMAYBE_BOUNDED_POINTER_TYPE_P, MAYBE_BOUNDED_REFERENCE_TYPE_P,\n\tTREE_BOUNDED, TYPE_MAIN_VARIANTS_PHYSICALLY_EQUAL_P,\n\tTYPE_MAIN_PHYSICAL_VARIANT, TYPE_BOUNDED): New macros.\n\t(TYPE_QUAL_BOUNDED): New constant.\n\t(TYPE_QUALS): Handle bounded qualifier.\n\t(TREE_EXPR_QUALS, TREE_FUNC_QUALS): New macros.\n\t(TYPE_BOUNDED_VALUE, TYPE_BOUNDED_BASE, TYPE_BOUNDED_EXTENT,\n\tTYPE_BOUNDED_SUBTYPE, TYPE_UNBOUNDED_VARIANT, TYPE_POINTER_DEPTH,\n\tTYPE_AMBIENT_BOUNDEDNESS): New macros.\n\t(MAX_POINTER_DEPTH, VA_LIST_POINTER_DEPTH): New constants.\n\t(tree_type): Add pointer_depth member.  Remove\n\tinaccurate comment about number of remaining bits.\n\t(DECL_POINTER_DEPTH): Add macro.\n\t(tree_decl): Add pointer_depth member.\n\nFrom-SVN: r33641", "tree": {"sha": "6088f3bc91feea1350a778bc9ab0e91f10fbb21c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6088f3bc91feea1350a778bc9ab0e91f10fbb21c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6d7adfd473e40d71079c5751c12de64e3796a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d7adfd473e40d71079c5751c12de64e3796a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d7adfd473e40d71079c5751c12de64e3796a0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d7adfd473e40d71079c5751c12de64e3796a0f/comments", "author": null, "committer": null, "parents": [{"sha": "28e801e2780703efce05cd7a415b818f1d46ee26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e801e2780703efce05cd7a415b818f1d46ee26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e801e2780703efce05cd7a415b818f1d46ee26"}], "stats": {"total": 231, "additions": 222, "deletions": 9}, "files": [{"sha": "96da99a3a135855858626bb6a26868cddbee7f9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d7adfd473e40d71079c5751c12de64e3796a0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d7adfd473e40d71079c5751c12de64e3796a0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6d7adfd473e40d71079c5751c12de64e3796a0f", "patch": "@@ -1,3 +1,24 @@\n+2000-05-03  Greg McGary  <gkm@gnu.org>\n+\n+\t* tree.h (tree_common): Add bounded_flag member.  Remove\n+\tinaccurate comment about number of remaining bits.\n+\t(BOUNDED_INDIRECT_TYPE_P, BOUNDED_POINTER_TYPE_P,\n+\tBOUNDED_REFERENCE_TYPE_P, MAYBE_BOUNDED_INDIRECT_TYPE_P,\n+\tMAYBE_BOUNDED_POINTER_TYPE_P, MAYBE_BOUNDED_REFERENCE_TYPE_P,\n+\tTREE_BOUNDED, TYPE_MAIN_VARIANTS_PHYSICALLY_EQUAL_P,\n+\tTYPE_MAIN_PHYSICAL_VARIANT, TYPE_BOUNDED): New macros.\n+\t(TYPE_QUAL_BOUNDED): New constant.\n+\t(TYPE_QUALS): Handle bounded qualifier.\n+\t(TREE_EXPR_QUALS, TREE_FUNC_QUALS): New macros.\n+\t(TYPE_BOUNDED_VALUE, TYPE_BOUNDED_BASE, TYPE_BOUNDED_EXTENT,\n+\tTYPE_BOUNDED_SUBTYPE, TYPE_UNBOUNDED_VARIANT, TYPE_POINTER_DEPTH,\n+\tTYPE_AMBIENT_BOUNDEDNESS): New macros.\n+\t(MAX_POINTER_DEPTH, VA_LIST_POINTER_DEPTH): New constants.\n+\t(tree_type): Add pointer_depth member.  Remove\n+\tinaccurate comment about number of remaining bits.\n+\t(DECL_POINTER_DEPTH): Add macro.\n+\t(tree_decl): Add pointer_depth member.\n+\n Wed May  3 22:52:53 2000  Denis Chertykov  <denisc@overta.ru>\n \n \t* config/avr/avr-protos.h (test_hard_reg_class): Declared."}, {"sha": "84ae93787afdceeb6500955a0a1fe6d0576e4254", "filename": "gcc/tree.h", "status": "modified", "additions": 201, "deletions": 9, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d7adfd473e40d71079c5751c12de64e3796a0f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d7adfd473e40d71079c5751c12de64e3796a0f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a6d7adfd473e40d71079c5751c12de64e3796a0f", "patch": "@@ -142,6 +142,7 @@ struct tree_common\n   unsigned public_flag : 1;\n   unsigned private_flag : 1;\n   unsigned protected_flag : 1;\n+  unsigned bounded_flag : 1;\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;\n@@ -150,8 +151,6 @@ struct tree_common\n   unsigned lang_flag_4 : 1;\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n-\n-  /* There is room for three more flags.  */\n };\n \n /* The following table lists the uses of each of the above flags and\n@@ -258,7 +257,14 @@ struct tree_common\n        TREE_NOTHROW in\n            CALL_EXPR, FUNCTION_DECL\n \n-\t\t\t\t\t\t\t  */\n+   bounded_flag:\n+\n+       TREE_BOUNDED in\n+\t   expressions, VAR_DECL, PARM_DECL, FIELD_DECL, FUNCTION_DECL\n+       TYPE_BOUNDED in\n+\t   ..._TYPE\n+*/\n+\n /* Define accessors for the fields that all tree nodes have\n    (though some fields are not used for all kinds of nodes).  */\n \n@@ -394,11 +400,55 @@ extern void tree_class_check_failed PARAMS ((const tree, char,\n    || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE \\\n    || TREE_CODE (TYPE) == SET_TYPE)\n \n-/* Nonzero if TYPE represents a pointer type.  */\n+/* Nonzero if TYPE represents an unbounded pointer or unbounded\n+   reference type.  (It should be renamed to INDIRECT_TYPE_P.)  */\n \n #define POINTER_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)\n \n+/* Nonzero if TYPE represents a bounded pointer or bounded reference type.  */\n+\n+#define BOUNDED_INDIRECT_TYPE_P(TYPE) \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_TYPE (TYPE))\n+\n+/* Nonzero if TYPE represents a bounded pointer type.  */\n+\n+#define BOUNDED_POINTER_TYPE_P(TYPE) \\\n+  (BOUNDED_INDIRECT_TYPE_P (TYPE) \\\n+   && TREE_CODE (TYPE_BOUNDED_SUBTYPE (TYPE)) == POINTER_TYPE)\n+\n+/* Nonzero if TYPE represents a bounded reference type.  Bounded\n+   reference types have two specific uses: (1) When a reference is\n+   seated to a variable-length RECORD_TYPE that has an array of\n+   indeterminate length as its final field.  For all other objects, it\n+   is sufficient to check bounds at the time the reference is seated,\n+   and assume that all future uses of the reference are safe, since\n+   the address of references cannot change.  (2) When a reference\n+   supertype is seated to an subtype object.  The bounds \"remember\"\n+   the true size of the complete object, so that subsequent upcasts of\n+   the address of the reference will be checked properly (is such a\n+   thing valid C++?).  */\n+\n+#define BOUNDED_REFERENCE_TYPE_P(TYPE) \\\n+  (BOUNDED_INDIRECT_TYPE_P (TYPE) \\\n+   && TREE_CODE (TYPE_BOUNDED_SUBTYPE (TYPE)) == REFERENCE_TYPE)\n+\n+/* Nonzero if TYPE represents a pointer or reference type, either\n+   bounded or unbounded.  */\n+\n+#define MAYBE_BOUNDED_INDIRECT_TYPE_P(TYPE) \\\n+  (POINTER_TYPE_P (TYPE) || BOUNDED_INDIRECT_TYPE_P (TYPE))\n+\n+/* Nonzero if TYPE represents a pointer type, either bounded or unbounded.  */\n+\n+#define MAYBE_BOUNDED_POINTER_TYPE_P(TYPE) \\\n+  (TREE_CODE (TYPE) == POINTER_TYPE || BOUNDED_POINTER_TYPE_P (TYPE))\n+\n+/* Nonzero if TYPE represents a reference type, either bounded or unbounded.  */\n+\n+#define MAYBE_BOUNDED_REFERENCE_TYPE_P(TYPE) \\\n+  (TREE_CODE (TYPE) == REFERENCE_TYPE || BOUNDED_REFERENCE_TYPE_P (TYPE))\n+\n /* Nonzero if this type is a complete type.  */\n #define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)\n \n@@ -551,6 +601,40 @@ extern void tree_class_check_failed PARAMS ((const tree, char,\n    In a BLOCK node, this is BLOCK_HANDLER_BLOCK.  */\n #define TREE_PROTECTED(NODE) ((NODE)->common.protected_flag)\n \n+/* In a ..._TYPE node, nonzero means that the type's size and layout,\n+   (or the size and layout of its arguments and/or return value in the\n+   case of a FUNCTION_TYPE or METHOD_TYPE) was changed by the presence\n+   of pointer bounds.  Use TYPE_BOUNDED instead of this macro when the\n+   node is a type, because eventually we may make that a different\n+   bit.  TYPE_BOUNDED doesn't mean that this type is a bounded indirect\n+   type--use BOUNDED_POINTER_TYPE_P, BOUNDED_REFERENCE_TYPE_P,\n+   BOUNDED_INDIRECT_TYPE_P to test for that.\n+\n+   In a FUNCTION_DECL, nonzero means that the size and layout of one\n+   of its arguments and/or return value was changed by the presence of\n+   pointer bounds.  This value can differ from the value of\n+   TYPE_BOUNDED (TREE_TYPE (fundecl)) if the function was implicitly\n+   declared, then later called with pointer args, or was declared with\n+   a variable argument list and is later called with pointer values in\n+   the variable argument list.\n+\n+   In a VAR_DECL, PARM_DECL or FIELD_DECL, TREE_BOUNDED matches the value\n+   of the decl's type's BOUNDED_POINTER_TYPE_P.\n+\n+   In a CONSTRUCTOR or other expression, nonzero means the value is a\n+   bounded pointer.  It is insufficient to determine the boundedness\n+   of an expression EXP with BOUNDED_POINTER_TYPE_P (TREE_TYPE (EXP)),\n+   since we allow pointer to be temporarily cast to integer for\n+   rounding up to an alignment boudary in a way that preserves the\n+   pointer's bounds.\n+\n+   In an IDENTIFIER_NODE, nonzero means that the name is prefixed with\n+   BP_PREFIX (see varasm.c).  This occurs for the DECL_ASSEMBLER_NAME\n+   of a function that has bounded pointer(s) for its return type and/or\n+   argument type(s).  */\n+\n+#define TREE_BOUNDED(NODE) ((NODE)->common.bounded_flag)\n+\n /* These flags are available for each language front end to use internally.  */\n #define TREE_LANG_FLAG_0(NODE) ((NODE)->common.lang_flag_0)\n #define TREE_LANG_FLAG_1(NODE) ((NODE)->common.lang_flag_1)\n@@ -795,6 +879,26 @@ struct tree_block\n #define TYPE_OBSTACK(NODE) (TYPE_CHECK (NODE)->type.obstack)\n #define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n \n+/* Indirect types present difficulties because they may be represented\n+   as either POINTER_TYPE/REFERENCE_TYPE nodes (unbounded) or as\n+   RECORD_TYPE nodes (bounded).  Bounded and unbounded pointers might\n+   be logically equivalent, but physically different.  Simple\n+   comparison of the main variant only tells if the types are\n+   logically equivalent.  Use this predicate to compare for physical\n+   equivalency.  */\n+\n+/* Types have the same main variant, and have the same boundedness.  */\n+#define TYPE_MAIN_VARIANTS_PHYSICALLY_EQUAL_P(TYPE1, TYPE2)\t\\\n+  (TYPE_MAIN_VARIANT (TYPE1) == TYPE_MAIN_VARIANT (TYPE2)\t\\\n+   && TREE_CODE (TYPE1) == TREE_CODE (TYPE2))\n+\n+/* Return the type variant that has no qualifiers (i.e., the main variant),\n+   except that the boundedness qualifier is preserved.  */\n+#define TYPE_MAIN_PHYSICAL_VARIANT(TYPE)\t\t\\\n+  (BOUNDED_POINTER_TYPE_P (TYPE)\t\t\t\\\n+   ? build_qualified_type (TYPE, TYPE_QUAL_BOUNDED)\t\\\n+   : TYPE_MAIN_VARIANT (TYPE))\n+\n /* For aggregate types, information about this type, as a base type\n    for itself.  Used in a language-dependent way for types that are\n    neither a RECORD_TYPE, QUAL_UNION_TYPE, nor a UNION_TYPE.  */\n@@ -846,6 +950,11 @@ struct tree_block\n    the term.  */\n #define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)\n \n+/* If nonzero, this type's size and layout, (or the size and layout of\n+   its arguments and/or return value in the case of a FUNCTION_TYPE or\n+   METHOD_TYPE) was changed by the presence of pointer bounds.  */\n+#define TYPE_BOUNDED(NODE) (TYPE_CHECK (NODE)->common.bounded_flag)\n+\n /* There is a TYPE_QUAL value for each type qualifier.  They can be\n    combined by bitwise-or to form the complete set of qualifiers for a\n    type.  */\n@@ -854,12 +963,25 @@ struct tree_block\n #define TYPE_QUAL_CONST    0x1\n #define TYPE_QUAL_VOLATILE 0x2\n #define TYPE_QUAL_RESTRICT 0x4\n+#define TYPE_QUAL_BOUNDED  0x8\n \n /* The set of type qualifiers for this type.  */\n-#define TYPE_QUALS(NODE)\t\t\t\\\n-  ((TYPE_READONLY(NODE) * TYPE_QUAL_CONST)\t\\\n-   | (TYPE_VOLATILE(NODE) * TYPE_QUAL_VOLATILE)\t\\\n-   | (TYPE_RESTRICT(NODE) * TYPE_QUAL_RESTRICT))\n+#define TYPE_QUALS(NODE)\t\t\t\t\t\\\n+  ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\t\\\n+   | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n+   | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)\t\t\\\n+   | (BOUNDED_INDIRECT_TYPE_P (NODE) * TYPE_QUAL_BOUNDED))\n+\n+/* The set of qualifiers pertinent to an expression node.  */\n+#define TREE_EXPR_QUALS(NODE)\t\t\t\t\\\n+  ((TREE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n+   | (TREE_THIS_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\\\n+   | (TREE_BOUNDED (NODE) * TYPE_QUAL_BOUNDED))\n+\n+/* The set of qualifiers pertinent to a FUNCTION_DECL node.  */\n+#define TREE_FUNC_QUALS(NODE)\t\t\t\t\\\n+  ((TREE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n+   | (TREE_THIS_VOLATILE (NODE) * TYPE_QUAL_VOLATILE))\n \n /* These flags are available for each language front end to use internally.  */\n #define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type.lang_flag_0)\n@@ -891,6 +1013,65 @@ struct tree_block\n    compact a way as possible.  */\n #define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->type.packed_flag)\n \n+/* A bounded pointer or bounded reference type (collectively called\n+   indirect types) is represented as a RECORD_TYPE node containing\n+   three pointer fields whose type is the corresponding unbounded\n+   POINTER_TYPE or REFERENCE_TYPE.  A RECORD_TYPE node that represents\n+   a bounded indirect type differs from a normal RECORD_TYPE node in\n+   that its TREE_TYPE is non-NULL and has the pointed-to type just as\n+   a POINTER_TYPE or REFERENCE_TYPE node has.  The bounded RECORD_TYPE\n+   nodes are stored on the same type variant chain alongside the\n+   variants of the underlaying indirect types nodes.  The main variant\n+   of such chains is always the unbounded type.  */\n+\n+/* Access the field decls of a bounded-pointer type.  */\n+#define TYPE_BOUNDED_VALUE(TYPE) TYPE_FIELDS (TYPE)\n+#define TYPE_BOUNDED_BASE(TYPE) TREE_CHAIN (TYPE_BOUNDED_VALUE (TYPE))\n+#define TYPE_BOUNDED_EXTENT(TYPE) TREE_CHAIN (TYPE_BOUNDED_BASE (TYPE))\n+\n+/* Access the simple-pointer subtype of a bounded-pointer type.  */\n+#define TYPE_BOUNDED_SUBTYPE(TYPE) TREE_TYPE (TYPE_BOUNDED_VALUE (TYPE))\n+\n+/* Find the unbounded counterpart to a type, or return TYPE if it is\n+   already unbounded.  */\n+#define TYPE_UNBOUNDED_VARIANT(TYPE) \\\n+  (BOUNDED_POINTER_TYPE_P (TYPE) ? TYPE_BOUNDED_SUBTYPE (TYPE) : (TYPE))\n+\n+/* This field comprises two bits, for values in the range 0..3:\n+\n+   depth=0 means that type is a scalar, or an aggregate that contains\n+   only depth=0 types, or a function that has only depth=0 types for\n+   its return value and argument types.\n+\n+   depth=1 means that type is a pointer to a depth=0 type, or an\n+   aggregate that contains only depth=0 and depth=1 types, or a\n+   function that has only depth=0 and depth=1 types for its return\n+   value and argument types.\n+\n+   The meanings of depth=2 and depth=3 are obvious by induction.\n+   Varargs functions are depth=3.  The type `va_list' is depth=3.\n+\n+   The purpose of measuring pointer depth of a type is to determine\n+   the eligibility of a function for an automatically-generated\n+   bounded-pointer thunk.  A depth=0 functions needs no thunk.  A\n+   depth=1 function is eligible for an automatic thunk.  Functions\n+   with depth 2 or more are too complex to get automatic thunks.\n+\n+   Function decls also have a pointer_depth field, since we also\n+   consider the actual argument types for functions.  */\n+\n+#define TYPE_POINTER_DEPTH(TYPE) (TYPE_CHECK (TYPE)->type.pointer_depth)\n+\n+/* In a FUNCTION_TYPE node, this bit stores the value of\n+   default_pointer_boundedness at the time TYPE was created.  It is\n+   useful for choosing default boundedness of function arguments for\n+   non-prototype function decls and for varargs/stdarg lists.  */\n+\n+#define TYPE_AMBIENT_BOUNDEDNESS(TYPE) (TYPE_CHECK (TYPE)->type.transparent_union_flag)\n+\n+#define MAX_POINTER_DEPTH 2\n+#define VA_LIST_POINTER_DEPTH 3\n+\n struct tree_type\n {\n   char common[sizeof (struct tree_common)];\n@@ -909,6 +1090,7 @@ struct tree_type\n   unsigned transparent_union_flag : 1;\n   unsigned packed_flag : 1;\n   unsigned restrict_flag : 1;\n+  unsigned pointer_depth : 2;\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;\n@@ -917,7 +1099,6 @@ struct tree_type\n   unsigned lang_flag_4 : 1;\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n-  /* room for 3 more bits */\n \n   unsigned int align;\n   union tree_node *pointer_to;\n@@ -1347,6 +1528,16 @@ struct tree_type\n #define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n   (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n \n+/* The pointer_depth field comprises two bits for values in the range\n+   0..3.  The value is normally equal to TYPE_POINTER_DEPTH of decl's\n+   type node, but for functions it migth be greater.  For example,\n+   this can happen when the function is declared to accept a parameter\n+   of type void* (depth=1), but is actually called with an argument of\n+   type foo** (depth=2).  The function type will get the formal\n+   parameter's depth, but the function decl will get the actual\n+   argument's depth.  */\n+#define DECL_POINTER_DEPTH(DECL) (DECL_CHECK (DECL)->decl.pointer_depth)\n+\n struct tree_decl\n {\n   char common[sizeof (struct tree_common)];\n@@ -1382,6 +1573,7 @@ struct tree_decl\n   unsigned no_limit_stack : 1;\n   unsigned pure_flag : 1;\n   ENUM_BITFIELD(built_in_class) built_in_class : 2;\n+  unsigned pointer_depth : 2;\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;"}]}