{"sha": "32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJmZTUyNzE0ZTQyYTM5MWM2YTdhMWFjMThiYjBhNTdhODBlY2I1Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-10-29T01:16:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-10-29T01:16:05Z"}, "message": "Make gengtype more robust against user error\n\n\t* doc/gty.texi (\"Inheritance and GTY\"): Make it clear that\n\tto use autogenerated markers for a class-hierarchy, every class\n\tmust have a GTY marker.\n\t* gengtype.h (struct type): Add linked list of subclasses to\n\tthe \"s\" member of the union.\n\t(add_subclass): New decl.\n\t* gengtype-state.c (read_state_struct_type): Set up subclass\n\tlinked list.\n\t* gengtype.c (get_ultimate_base_class): New.\n\t(add_subclass): New.\n\t(new_structure): Set up subclass linked list.\n\t(set_gc_used_type): Propagate usage information to subclasses.\n\t(output_mangled_typename): Use get_ultimate_base_class.\n\t(walk_subclasses): Use the subclass linked list, avoiding an\n\tO(N^2) when writing out all types.\n\t(walk_type): Issue an error if the base class is missing a tag,\n\trather than generating bogus C code.  Add a gcc_unreachable\n\tdefault case, in case people omit tags from concrete subclasses,\n\tor get the values wrong.\n\t(write_func_for_structure): Issue an error for subclasses for\n\twhich the base doesn't have a \"desc\", since otherwise the\n\tautogenerated routines for the base would silently fail to visit\n\tany subclass fields.\n\t(write_root): Use get_ultimate_base_class, tweaking constness of\n\ttp to match that function's signature.\n\nFrom-SVN: r204148", "tree": {"sha": "456914960b33f804e0e0a01a2caaa7e312150c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/456914960b33f804e0e0a01a2caaa7e312150c73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ed5a6cc504ef8089f1431590c2fbca15b6a2475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed5a6cc504ef8089f1431590c2fbca15b6a2475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed5a6cc504ef8089f1431590c2fbca15b6a2475"}], "stats": {"total": 166, "additions": 137, "deletions": 29}, "files": [{"sha": "fca665b39be79528208fe582f8647a8606b255b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "patch": "@@ -1,3 +1,31 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/gty.texi (\"Inheritance and GTY\"): Make it clear that\n+\tto use autogenerated markers for a class-hierarchy, every class\n+\tmust have a GTY marker.\n+\t* gengtype.h (struct type): Add linked list of subclasses to\n+\tthe \"s\" member of the union.\n+\t(add_subclass): New decl.\n+\t* gengtype-state.c (read_state_struct_type): Set up subclass\n+\tlinked list.\n+\t* gengtype.c (get_ultimate_base_class): New.\n+\t(add_subclass): New.\n+\t(new_structure): Set up subclass linked list.\n+\t(set_gc_used_type): Propagate usage information to subclasses.\n+\t(output_mangled_typename): Use get_ultimate_base_class.\n+\t(walk_subclasses): Use the subclass linked list, avoiding an\n+\tO(N^2) when writing out all types.\n+\t(walk_type): Issue an error if the base class is missing a tag,\n+\trather than generating bogus C code.  Add a gcc_unreachable\n+\tdefault case, in case people omit tags from concrete subclasses,\n+\tor get the values wrong.\n+\t(write_func_for_structure): Issue an error for subclasses for\n+\twhich the base doesn't have a \"desc\", since otherwise the\n+\tautogenerated routines for the base would silently fail to visit\n+\tany subclass fields.\n+\t(write_root): Use get_ultimate_base_class, tweaking constness of\n+\ttp to match that function's signature.\n+\n 2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \t* doc/gty.texi (GTY Options): Add note about inheritance to"}, {"sha": "a64d110a980e90c3337973f7d301b3baeb672423", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "patch": "@@ -497,6 +497,13 @@ The base class and its discriminator must be identified using the ``desc''\n option.  Each concrete subclass must use the ``tag'' option to identify\n which value of the discriminator it corresponds to.\n \n+Every class in the hierarchy must have a @code{GTY(())} marker, as\n+gengtype will only attempt to parse classes that have such a marker\n+@footnote{Classes lacking such a marker will not be identified as being\n+part of the hierarchy, and so the marking routines will not handle them,\n+leading to a assertion failure within the marking routines due to an\n+unknown tag value (assuming that assertions are enabled).}.\n+\n @smallexample\n class GTY((desc(\"%h.kind\"), tag(\"0\"))) example_base\n @{"}, {"sha": "fda473a2dbe5e5774806a18598c0f516516b8cad", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "patch": "@@ -1615,6 +1615,8 @@ read_state_struct_type (type_p type)\n       read_state_lang_bitmap (&(type->u.s.bitmap));\n       read_state_type (&(type->u.s.lang_struct));\n       read_state_type (&(type->u.s.base_class));\n+      if (type->u.s.base_class)\n+\tadd_subclass (type->u.s.base_class, type);\n     }\n   else\n     {"}, {"sha": "f35952e5a55583bc8587dc84804ea48f172f6458", "filename": "gcc/gengtype.c", "status": "modified", "additions": 90, "deletions": 29, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "patch": "@@ -137,6 +137,16 @@ xasprintf (const char *format, ...)\n   return result;\n }\n \f\n+/* Locate the ultimate base class of struct S.  */\n+\n+static const_type_p\n+get_ultimate_base_class (const_type_p s)\n+{\n+  while (s->u.s.base_class)\n+    s = s->u.s.base_class;\n+  return s;\n+}\n+\f\n /* Input file handling. */\n \n /* Table of all input files.  */\n@@ -667,6 +677,16 @@ resolve_typedef (const char *s, struct fileloc *pos)\n   return p;\n }\n \n+/* Add SUBCLASS to head of linked list of BASE's subclasses.  */\n+\n+void add_subclass (type_p base, type_p subclass)\n+{\n+  gcc_assert (union_or_struct_p (base));\n+  gcc_assert (union_or_struct_p (subclass));\n+\n+  subclass->u.s.next_sibling_class = base->u.s.first_subclass;\n+  base->u.s.first_subclass = subclass;\n+}\n \n /* Create and return a new structure with tag NAME at POS with fields\n    FIELDS and options O.  The KIND of structure must be one of\n@@ -749,6 +769,8 @@ new_structure (const char *name, enum typekind kind, struct fileloc *pos,\n   if (s->u.s.lang_struct)\n     s->u.s.lang_struct->u.s.bitmap |= bitmap;\n   s->u.s.base_class = base_class;\n+  if (base_class)\n+    add_subclass (base_class, s);\n \n   return s;\n }\n@@ -1535,6 +1557,12 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM],\n \tif (t->u.s.base_class)\n \t  set_gc_used_type (t->u.s.base_class, level, param,\n \t\t\t    allow_undefined_types);\n+\t/* Anything pointing to a base class might actually be pointing\n+\t   to a subclass.  */\n+\tfor (type_p subclass = t->u.s.first_subclass; subclass;\n+\t     subclass = subclass->u.s.next_sibling_class)\n+\t  set_gc_used_type (subclass, level, param,\n+\t\t\t    allow_undefined_types);\n \n \tFOR_ALL_INHERITED_FIELDS(t, f)\n \t  {\n@@ -2554,8 +2582,7 @@ output_mangled_typename (outf_p of, const_type_p t)\n \t  /* For references to classes within an inheritance hierarchy,\n \t     only ever reference the ultimate base class, since only\n \t     it will have gt_ functions.  */\n-\t  while (t->u.s.base_class)\n-\t    t = t->u.s.base_class;\n+\t  t = get_ultimate_base_class (t);\n \t  const char *id_for_tag = filter_type_name (t->u.s.tag);\n \t  oprintf (of, \"%lu%s\", (unsigned long) strlen (id_for_tag),\n \t\t   id_for_tag);\n@@ -2630,30 +2657,28 @@ get_string_option (options_p opt, const char *key)\n static void\n walk_subclasses (type_p base, struct walk_type_data *d)\n {\n-  for (type_p sub = structures; sub != NULL; sub = sub->next)\n+  for (type_p sub = base->u.s.first_subclass; sub != NULL;\n+       sub = sub->u.s.next_sibling_class)\n     {\n-      if (sub->u.s.base_class == base)\n+      const char *type_tag = get_string_option (sub->u.s.opt, \"tag\");\n+      if (type_tag)\n \t{\n-\t  const char *type_tag = get_string_option (sub->u.s.opt, \"tag\");\n-\t  if (type_tag)\n-\t    {\n-\t      oprintf (d->of, \"%*scase %s:\\n\", d->indent, \"\", type_tag);\n-\t      d->indent += 2;\n-\t      oprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n-\t      d->indent += 2;\n-\t      oprintf (d->of, \"%*s%s *sub = static_cast <%s *> (x);\\n\",\n-\t\t       d->indent, \"\", sub->u.s.tag, sub->u.s.tag);\n-\t      const char *old_val = d->val;\n-\t      d->val = \"(*sub)\";\n-\t      walk_type (sub, d);\n-\t      d->val = old_val;\n-\t      d->indent -= 2;\n-\t      oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n-\t      oprintf (d->of, \"%*sbreak;\\n\", d->indent, \"\");\n-\t      d->indent -= 2;\n-\t    }\n-\t  walk_subclasses (sub, d);\n+\t  oprintf (d->of, \"%*scase %s:\\n\", d->indent, \"\", type_tag);\n+\t  d->indent += 2;\n+\t  oprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n+\t  d->indent += 2;\n+\t  oprintf (d->of, \"%*s%s *sub = static_cast <%s *> (x);\\n\",\n+\t\t   d->indent, \"\", sub->u.s.tag, sub->u.s.tag);\n+\t  const char *old_val = d->val;\n+\t  d->val = \"(*sub)\";\n+\t  walk_type (sub, d);\n+\t  d->val = old_val;\n+\t  d->indent -= 2;\n+\t  oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\t  oprintf (d->of, \"%*sbreak;\\n\", d->indent, \"\");\n+\t  d->indent -= 2;\n \t}\n+      walk_subclasses (sub, d);\n     }\n }\n \n@@ -3023,6 +3048,20 @@ walk_type (type_p t, struct walk_type_data *d)\n \t  }\n \telse if (desc)\n \t  {\n+\t    /* We have a \"desc\" option on a struct, signifying the\n+\t       base class within a GC-managed inheritance hierarchy.\n+\t       The current code specialcases the base class, then walks\n+\t       into subclasses, recursing into this routine to handle them.\n+\t       This organization requires the base class to have a case in\n+\t       the switch statement, and hence a tag value is mandatory\n+\t       for the base class.   This restriction could be removed, but\n+\t       it would require some restructing of this code.  */\n+\t    if (!type_tag)\n+\t      {\n+\t\terror_at_line (d->line,\n+\t\t\t       \"missing `tag' option for type `%s'\",\n+\t\t\t       t->u.s.tag);\n+\t      }\n \t    oprintf (d->of, \"%*sswitch (\", d->indent, \"\");\n \t    output_escaped_param (d, desc, \"desc\");\n \t    oprintf (d->of, \")\\n\");\n@@ -3188,6 +3227,16 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    /* Add cases to handle subclasses.  */\n \t    walk_subclasses (t, d);\n \n+\t    /* Ensure that if someone forgets a \"tag\" option that we don't\n+\t       silent fail to traverse that subclass's fields.  */\n+\t    if (!seen_default_p)\n+\t      {\n+\t\toprintf (d->of, \"%*s/* Unrecognized tag value.  */\\n\",\n+\t\t\t d->indent, \"\");\n+\t\toprintf (d->of, \"%*sdefault: gcc_unreachable (); \\n\",\n+\t\t\t d->indent, \"\");\n+\t      }\n+\n \t    /* End of the switch statement */\n \t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n \t    d->indent -= 2;\n@@ -3537,10 +3586,23 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n   options_p opt;\n   struct walk_type_data d;\n \n-  /* Don't write fns for subclasses, only for the ultimate base class\n-     within an inheritance hierarchy.  */\n   if (s->u.s.base_class)\n-    return;\n+    {\n+      /* Verify that the base class has a \"desc\", since otherwise\n+\t the traversal hooks there won't attempt to visit fields of\n+\t subclasses such as this one.  */\n+      const_type_p ubc = get_ultimate_base_class (s);\n+      if ((!opts_have (ubc->u.s.opt, \"user\")\n+\t   && !opts_have (ubc->u.s.opt, \"desc\")))\n+\terror_at_line (&s->u.s.line,\n+\t\t       (\"'%s' is a subclass of non-GTY(user) GTY class '%s'\"\n+\t\t\t\", but '%s' lacks a discriminator 'desc' option\"),\n+\t\t       s->u.s.tag, ubc->u.s.tag, ubc->u.s.tag);\n+\n+      /* Don't write fns for subclasses, only for the ultimate base class\n+\t within an inheritance hierarchy.  */\n+      return;\n+    }\n \n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_for_structure (s, param);\n@@ -4452,7 +4514,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n     case TYPE_POINTER:\n       {\n-\ttype_p tp;\n+\tconst_type_p tp;\n \n \tif (!start_root_entry (f, v, name, line))\n \t  return;\n@@ -4461,8 +4523,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n \tif (!has_length && union_or_struct_p (tp))\n \t  {\n-\t    while (tp->u.s.base_class)\n-\t      tp = tp->u.s.base_class;\n+\t    tp = get_ultimate_base_class (tp);\n \t    const char *id_for_tag = filter_type_name (tp->u.s.tag);\n \t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", id_for_tag);\n \t    if (emit_pch)"}, {"sha": "0c3ec964a2f74f417764ec1da3f03a01d5f74744", "filename": "gcc/gengtype.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=32fe52714e42a391c6a7a1ac18bb0a57a80ecb5b", "patch": "@@ -293,6 +293,15 @@ struct type {\n       type_p lang_struct;\n \n       type_p base_class; /* the parent class, if any.  */\n+\n+      /* The following two fields are not serialized in state files, and\n+\t are instead reconstructed on load.  */\n+\n+      /* The head of a singly-linked list of immediate descendents in\n+\t the inheritance hierarchy.  */\n+      type_p first_subclass;\n+      /* The next in that list.  */\n+      type_p next_sibling_class;\n     } s;\n \n     /* when TYPE_SCALAR: */\n@@ -424,6 +433,7 @@ extern char *xasprintf (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n extern void do_scalar_typedef (const char *s, struct fileloc *pos);\n extern type_p resolve_typedef (const char *s, struct fileloc *pos);\n+extern void add_subclass (type_p base, type_p subclass);\n extern type_p new_structure (const char *name, enum typekind kind,\n \t\t\t     struct fileloc *pos, pair_p fields,\n \t\t\t     options_p o, type_p base);"}]}