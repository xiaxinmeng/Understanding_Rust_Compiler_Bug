{"sha": "c5c20c556bdb6bac0df8df2218ab5d4920b07137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjMjBjNTU2YmRiNmJhYzBkZjhkZjIyMThhYjVkNDkyMGIwNzEzNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-17T12:02:30Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-17T12:02:30Z"}, "message": "stmt.c (cost_table_, [...]): Remove.\n\n\t* stmt.c (cost_table_, use_cost_table, cost_table_initialize,\n\tCOST_TABLE): Remove.\n\t(estimate_case_costs): Remove.\n\t(expand_case): Do not call estimate_case_costs\n\tto set use_cost_table.\n\t(balance_case_nodes): Do not use use_cost_table.\n\nFrom-SVN: r186526", "tree": {"sha": "1c827010ad293254bf736d7bb0be5324b940366b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c827010ad293254bf736d7bb0be5324b940366b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5c20c556bdb6bac0df8df2218ab5d4920b07137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c20c556bdb6bac0df8df2218ab5d4920b07137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5c20c556bdb6bac0df8df2218ab5d4920b07137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c20c556bdb6bac0df8df2218ab5d4920b07137/comments", "author": null, "committer": null, "parents": [{"sha": "1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ab24192d5e8e4fcee353bb5c024995e5439f5e3"}], "stats": {"total": 143, "additions": 12, "deletions": 131}, "files": [{"sha": "b1e16312744c17aa4bc1fb865c754dee3722daf1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c20c556bdb6bac0df8df2218ab5d4920b07137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c20c556bdb6bac0df8df2218ab5d4920b07137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5c20c556bdb6bac0df8df2218ab5d4920b07137", "patch": "@@ -1,3 +1,12 @@\n+2012-04-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* stmt.c (cost_table_, use_cost_table, cost_table_initialize,\n+\tCOST_TABLE): Remove.\n+\t(estimate_case_costs): Remove.\n+\t(expand_case): Do not call estimate_case_costs\n+\tto set use_cost_table.\n+\t(balance_case_nodes): Do not use use_cost_table.\n+\n 2012-04-16  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_hash, assembler_name_hash): Remove."}, {"sha": "a519f0bbe14ea737f78711d17c4cd87e6d7e4e52", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 131, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c20c556bdb6bac0df8df2218ab5d4920b07137/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c20c556bdb6bac0df8df2218ab5d4920b07137/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c5c20c556bdb6bac0df8df2218ab5d4920b07137", "patch": "@@ -98,16 +98,6 @@ struct case_node\n typedef struct case_node case_node;\n typedef struct case_node *case_node_ptr;\n \n-/* These are used by estimate_case_costs and balance_case_nodes.  */\n-\n-/* This must be a signed type, and non-ANSI compilers lack signed char.  */\n-static short cost_table_[129];\n-static int use_cost_table;\n-static int cost_table_initialized;\n-\n-/* Special care is needed because we allow -1, but TREE_INT_CST_LOW\n-   is unsigned.  */\n-#define COST_TABLE(I)  cost_table_[(unsigned HOST_WIDE_INT) ((I) + 1)]\n \f\n static int n_occurrences (int, const char *);\n static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n@@ -117,7 +107,6 @@ static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n static void expand_null_return_1 (void);\n static void expand_value_return (rtx);\n-static int estimate_case_costs (case_node_ptr);\n static bool lshift_cheap_p (void);\n static int case_bit_test_cmp (const void *, const void *);\n static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, rtx);\n@@ -2304,7 +2293,6 @@ expand_case (gimple stmt)\n \t     decision tree an unconditional jump to the\n \t     default code is emitted.  */\n \n-\t  use_cost_table = estimate_case_costs (case_list);\n \t  balance_case_nodes (&case_list, NULL);\n \t  emit_case_nodes (index, case_list, default_label, index_type);\n \t  if (default_label)\n@@ -2403,86 +2391,6 @@ do_jump_if_equal (enum machine_mode mode, rtx op0, rtx op1, rtx label,\n \t\t\t   NULL_RTX, NULL_RTX, label, -1);\n }\n \f\n-/* Not all case values are encountered equally.  This function\n-   uses a heuristic to weight case labels, in cases where that\n-   looks like a reasonable thing to do.\n-\n-   Right now, all we try to guess is text, and we establish the\n-   following weights:\n-\n-\tchars above space:\t16\n-\tdigits:\t\t\t16\n-\tdefault:\t\t12\n-\tspace, punct:\t\t8\n-\ttab:\t\t\t4\n-\tnewline:\t\t2\n-\tother \"\\\" chars:\t1\n-\tremaining chars:\t0\n-\n-   If we find any cases in the switch that are not either -1 or in the range\n-   of valid ASCII characters, or are control characters other than those\n-   commonly used with \"\\\", don't treat this switch scanning text.\n-\n-   Return 1 if these nodes are suitable for cost estimation, otherwise\n-   return 0.  */\n-\n-static int\n-estimate_case_costs (case_node_ptr node)\n-{\n-  tree min_ascii = integer_minus_one_node;\n-  tree max_ascii = build_int_cst (TREE_TYPE (node->high), 127);\n-  case_node_ptr n;\n-  int i;\n-\n-  /* If we haven't already made the cost table, make it now.  Note that the\n-     lower bound of the table is -1, not zero.  */\n-\n-  if (! cost_table_initialized)\n-    {\n-      cost_table_initialized = 1;\n-\n-      for (i = 0; i < 128; i++)\n-\t{\n-\t  if (ISALNUM (i))\n-\t    COST_TABLE (i) = 16;\n-\t  else if (ISPUNCT (i))\n-\t    COST_TABLE (i) = 8;\n-\t  else if (ISCNTRL (i))\n-\t    COST_TABLE (i) = -1;\n-\t}\n-\n-      COST_TABLE (' ') = 8;\n-      COST_TABLE ('\\t') = 4;\n-      COST_TABLE ('\\0') = 4;\n-      COST_TABLE ('\\n') = 2;\n-      COST_TABLE ('\\f') = 1;\n-      COST_TABLE ('\\v') = 1;\n-      COST_TABLE ('\\b') = 1;\n-    }\n-\n-  /* See if all the case expressions look like text.  It is text if the\n-     constant is >= -1 and the highest constant is <= 127.  Do all comparisons\n-     as signed arithmetic since we don't want to ever access cost_table with a\n-     value less than -1.  Also check that none of the constants in a range\n-     are strange control characters.  */\n-\n-  for (n = node; n; n = n->right)\n-    {\n-      if (tree_int_cst_lt (n->low, min_ascii)\n-\t  || tree_int_cst_lt (max_ascii, n->high))\n-\treturn 0;\n-\n-      for (i = (HOST_WIDE_INT) TREE_INT_CST_LOW (n->low);\n-\t   i <= (HOST_WIDE_INT) TREE_INT_CST_LOW (n->high); i++)\n-\tif (COST_TABLE (i) < 0)\n-\t  return 0;\n-    }\n-\n-  /* All interesting values are within the range of interesting\n-     ASCII characters.  */\n-  return 1;\n-}\n-\n /* Take an ordered list of case nodes\n    and transform them into a near optimal binary tree,\n    on the assumption that any target code selection value is as\n@@ -2501,7 +2409,6 @@ balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n   np = *head;\n   if (np)\n     {\n-      int cost = 0;\n       int i = 0;\n       int ranges = 0;\n       case_node_ptr *npp;\n@@ -2512,14 +2419,7 @@ balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n       while (np)\n \t{\n \t  if (!tree_int_cst_equal (np->low, np->high))\n-\t    {\n-\t      ranges++;\n-\t      if (use_cost_table)\n-\t\tcost += COST_TABLE (TREE_INT_CST_LOW (np->high));\n-\t    }\n-\n-\t  if (use_cost_table)\n-\t    cost += COST_TABLE (TREE_INT_CST_LOW (np->low));\n+\t    ranges++;\n \n \t  i++;\n \t  np = np->right;\n@@ -2530,37 +2430,9 @@ balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n \t  /* Split this list if it is long enough for that to help.  */\n \t  npp = head;\n \t  left = *npp;\n-\t  if (use_cost_table)\n-\t    {\n-\t      /* Find the place in the list that bisects the list's total cost,\n-\t\t Here I gets half the total cost.  */\n-\t      int n_moved = 0;\n-\t      i = (cost + 1) / 2;\n-\t      while (1)\n-\t\t{\n-\t\t  /* Skip nodes while their cost does not reach that amount.  */\n-\t\t  if (!tree_int_cst_equal ((*npp)->low, (*npp)->high))\n-\t\t    i -= COST_TABLE (TREE_INT_CST_LOW ((*npp)->high));\n-\t\t  i -= COST_TABLE (TREE_INT_CST_LOW ((*npp)->low));\n-\t\t  if (i <= 0)\n-\t\t    break;\n-\t\t  npp = &(*npp)->right;\n-\t\t  n_moved += 1;\n-\t\t}\n-\t      if (n_moved == 0)\n-\t\t{\n-\t\t  /* Leave this branch lopsided, but optimize left-hand\n-\t\t     side and fill in `parent' fields for right-hand side.  */\n-\t\t  np = *head;\n-\t\t  np->parent = parent;\n-\t\t  balance_case_nodes (&np->left, np);\n-\t\t  for (; np->right; np = np->right)\n-\t\t    np->right->parent = np;\n-\t\t  return;\n-\t\t}\n-\t    }\n+\n \t  /* If there are just three nodes, split at the middle one.  */\n-\t  else if (i == 3)\n+\t  if (i == 3)\n \t    npp = &(*npp)->right;\n \t  else\n \t    {"}]}