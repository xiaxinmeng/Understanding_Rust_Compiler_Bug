{"sha": "b5ba341fce44821f9b3e12bfadb2a2604c766284", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjViYTM0MWZjZTQ0ODIxZjliM2UxMmJmYWRiMmEyNjA0Yzc2NjI4NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-05-04T17:57:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-05-04T17:57:39Z"}, "message": "reload1.c (inherit_piecemeal_p): New function.\n\n\t* reload1.c (inherit_piecemeal_p): New function.\n\t(emit_reload_insns): When reloading a group of hard registers, use\n\tinherit_piecemeal_p to decide whether the values of individual hard\n\tregisters can be inherited.\n\nFrom-SVN: r81480", "tree": {"sha": "f5a7552270f94b216907f31eb882e92ff5e8a010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5a7552270f94b216907f31eb882e92ff5e8a010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ba341fce44821f9b3e12bfadb2a2604c766284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ba341fce44821f9b3e12bfadb2a2604c766284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ba341fce44821f9b3e12bfadb2a2604c766284", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ba341fce44821f9b3e12bfadb2a2604c766284/comments", "author": null, "committer": null, "parents": [{"sha": "065afdfa8e2e699b1f5ac17c43ac4664940f6659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/065afdfa8e2e699b1f5ac17c43ac4664940f6659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/065afdfa8e2e699b1f5ac17c43ac4664940f6659"}], "stats": {"total": 75, "additions": 71, "deletions": 4}, "files": [{"sha": "95a70e6851a91ced1822972d84ca74934eb049a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5ba341fce44821f9b3e12bfadb2a2604c766284", "patch": "@@ -1,3 +1,10 @@\n+2004-05-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* reload1.c (inherit_piecemeal_p): New function.\n+\t(emit_reload_insns): When reloading a group of hard registers, use\n+\tinherit_piecemeal_p to decide whether the values of individual hard\n+\tregisters can be inherited.\n+\n 2004-05-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/ia64/t-ia64 (LIB2ADDEH): Remove gthr-gnat.c."}, {"sha": "8c17a61a4b0c5c9b87a52bfecb4277b9875667d9", "filename": "gcc/reload1.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b5ba341fce44821f9b3e12bfadb2a2604c766284", "patch": "@@ -417,6 +417,7 @@ static void emit_output_reload_insns (struct insn_chain *, struct reload *,\n \t\t\t\t      int);\n static void do_input_reload (struct insn_chain *, struct reload *, int);\n static void do_output_reload (struct insn_chain *, struct reload *, int);\n+static bool inherit_piecemeal_p (int, int);\n static void emit_reload_insns (struct insn_chain *);\n static void delete_output_reload (rtx, int, int);\n static void delete_address_reloads (rtx, rtx);\n@@ -6956,6 +6957,27 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n   emit_output_reload_insns (chain, rld + j, j);\n }\n \n+/* Reload number R reloads from or to a group of hard registers starting at\n+   register REGNO.  Return true if it can be treated for inheritance purposes\n+   like a group of reloads, each one reloading a single hard register.\n+   The caller has already checked that the spill register and REGNO use\n+   the same number of registers to store the reload value.  */\n+\n+static bool\n+inherit_piecemeal_p (int r, int regno)\n+{\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  return (!REG_CANNOT_CHANGE_MODE_P (reload_spill_index[r],\n+\t\t\t\t     GET_MODE (rld[r].reg_rtx),\n+\t\t\t\t     reg_raw_mode[reload_spill_index[r]])\n+\t  && !REG_CANNOT_CHANGE_MODE_P (regno,\n+\t\t\t\t\tGET_MODE (rld[r].reg_rtx),\n+\t\t\t\t\treg_raw_mode[regno]));\n+#else\n+  return true;\n+#endif\n+}\n+\n /* Output insns to reload values in and out of the chosen reload regs.  */\n \n static void\n@@ -7137,11 +7159,16 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t     : hard_regno_nregs[nregno]\n \t\t\t\t\t       [GET_MODE (rld[r].reg_rtx)]);\n+\t\t  bool piecemeal;\n \n \t\t  spill_reg_store[i] = new_spill_reg_store[i];\n \t\t  spill_reg_stored_to[i] = out;\n \t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n \n+\t\t  piecemeal = (nregno < FIRST_PSEUDO_REGISTER\n+\t\t\t       && nr == nnr\n+\t\t\t       && inherit_piecemeal_p (r, nregno));\n+\n \t\t  /* If NREGNO is a hard register, it may occupy more than\n \t\t     one register.  If it does, say what is in the\n \t\t     rest of the registers assuming that both registers\n@@ -7151,7 +7178,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n \t\t    for (k = 1; k < nnr; k++)\n \t\t      reg_last_reload_reg[nregno + k]\n-\t\t\t= (nr == nnr\n+\t\t\t= (piecemeal\n \t\t\t   ? regno_reg_rtx[REGNO (rld[r].reg_rtx) + k]\n \t\t\t   : 0);\n \n@@ -7160,7 +7187,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t    {\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, i + k);\n \t\t      reg_reloaded_contents[i + k]\n-\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr\n+\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || !piecemeal\n \t\t\t   ? nregno\n \t\t\t   : nregno + k);\n \t\t      reg_reloaded_insn[i + k] = insn;\n@@ -7185,6 +7212,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  int nregno;\n \t\t  int nnr;\n \t\t  rtx in;\n+\t\t  bool piecemeal;\n \n \t\t  if (GET_CODE (rld[r].in) == REG\n \t\t      && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER)\n@@ -7201,10 +7229,14 @@ emit_reload_insns (struct insn_chain *chain)\n \n \t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n \n+\t\t  piecemeal = (nregno < FIRST_PSEUDO_REGISTER\n+\t\t\t       && nr == nnr\n+\t\t\t       && inherit_piecemeal_p (r, nregno));\n+\n \t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n \t\t    for (k = 1; k < nnr; k++)\n \t\t      reg_last_reload_reg[nregno + k]\n-\t\t\t= (nr == nnr\n+\t\t\t= (piecemeal\n \t\t\t   ? regno_reg_rtx[REGNO (rld[r].reg_rtx) + k]\n \t\t\t   : 0);\n \n@@ -7220,7 +7252,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t    {\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, i + k);\n \t\t      reg_reloaded_contents[i + k]\n-\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr\n+\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || !piecemeal\n \t\t\t   ? nregno\n \t\t\t   : nregno + k);\n \t\t      reg_reloaded_insn[i + k] = insn;"}, {"sha": "f2d454b89a59108e7b85b45c1c92ab4473caac25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5ba341fce44821f9b3e12bfadb2a2604c766284", "patch": "@@ -1,3 +1,7 @@\n+2004-05-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.dg/torture/mips-hilo-2.c: New test.\n+\n 2004-05-03  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/14389"}, {"sha": "a8db6176682d45b4842f0e6e8708fa3ae9726c61", "filename": "gcc/testsuite/gcc.dg/torture/mips-hilo-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ba341fce44821f9b3e12bfadb2a2604c766284/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fmips-hilo-2.c?ref=b5ba341fce44821f9b3e12bfadb2a2604c766284", "patch": "@@ -0,0 +1,24 @@\n+/* Due to a reload inheritance bug, the asm statement in f() would be passed\n+   the low part of u.ll on little-endian 32-bit targets.  */\n+/* { dg-do run { target mips*-*-* } } */\n+\n+unsigned int g;\n+\n+unsigned long long f (unsigned int x)\n+{\n+  union { unsigned long long ll; unsigned int parts[2]; } u;\n+\n+  u.ll = ((unsigned long long) x * x);\n+  asm (\"mflo\\t%0\" : \"=r\" (g) : \"l\" (u.parts[1]));\n+  return u.ll;\n+}\n+\n+int main ()\n+{\n+  union { unsigned long long ll; unsigned int parts[2]; } u;\n+\n+  u.ll = f (0x12345678);\n+  if (g != u.parts[1])\n+    abort ();\n+  exit (0);\n+}"}]}