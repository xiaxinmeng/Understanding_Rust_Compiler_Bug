{"sha": "e6e52be0731568a32b46ca158cd8ef5c3835f1c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlNTJiZTA3MzE1NjhhMzJiNDZjYTE1OGNkOGVmNWMzODM1ZjFjNg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-03-26T15:08:53Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-03-26T15:08:53Z"}, "message": "reload inheritance improvement:\n\n\t* reload1.c (reg_reloaded_contents, reg_reloaded_insn):\n\tChange meaning: index is now hard reg number.\n\t(reg_reloaded_valid, reg_reloaded_dead): New variables.\n\t(reload_spill_index): Content is now a hard reg number.\n\t(reload_as_needed): Change to fit new variable meaning.\n\t(forget_old_reloads_1, allocate_reload_reg): Likewise.\n\t(choose_reload_regs, emit_reload_insns): Likewise.\n\nFrom-SVN: r18848", "tree": {"sha": "6a088845acb08fd98dfcb3a3462b8f9fbd9019e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a088845acb08fd98dfcb3a3462b8f9fbd9019e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6e52be0731568a32b46ca158cd8ef5c3835f1c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e52be0731568a32b46ca158cd8ef5c3835f1c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6e52be0731568a32b46ca158cd8ef5c3835f1c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e52be0731568a32b46ca158cd8ef5c3835f1c6/comments", "author": null, "committer": null, "parents": [{"sha": "a9c3c9a520a63a48429b9da74f056878add85643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c3c9a520a63a48429b9da74f056878add85643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c3c9a520a63a48429b9da74f056878add85643"}], "stats": {"total": 181, "additions": 98, "deletions": 83}, "files": [{"sha": "a86f834ee33e0b995a05684fc2a4d8be6e5d0206", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e52be0731568a32b46ca158cd8ef5c3835f1c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e52be0731568a32b46ca158cd8ef5c3835f1c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6e52be0731568a32b46ca158cd8ef5c3835f1c6", "patch": "@@ -1,3 +1,14 @@\n+Thu Mar 26 23:00:11 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\treload inheritance improvement:\n+\t* reload1.c (reg_reloaded_contents, reg_reloaded_insn):\n+\tChange meaning: index is now hard reg number.\n+\t(reg_reloaded_valid, reg_reloaded_dead): New variables.\n+\t(reload_spill_index): Content is now a hard reg number.\n+\t(reload_as_needed): Change to fit new variable meaning.\n+\t(forget_old_reloads_1, allocate_reload_reg): Likewise.\n+\t(choose_reload_regs, emit_reload_insns): Likewise.\n+\n Thu Mar 26 18:34:13 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* regclass.c (record_reg_classes): '?' increases cost by two."}, {"sha": "e1f56d2335bab96aec490e62cd5fcd3241f288fd", "filename": "gcc/reload1.c", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e52be0731568a32b46ca158cd8ef5c3835f1c6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e52be0731568a32b46ca158cd8ef5c3835f1c6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e6e52be0731568a32b46ca158cd8ef5c3835f1c6", "patch": "@@ -114,19 +114,23 @@ static int *reg_max_ref_width;\n    constant or memory slot.  */\n static rtx *reg_equiv_init;\n \n-/* During reload_as_needed, element N contains the last pseudo regno\n-   reloaded into the Nth reload register.  This vector is in parallel\n-   with spill_regs.  If that pseudo reg occupied more than one register,\n+/* During reload_as_needed, element N contains the last pseudo regno reloaded\n+  into hard register N.  If that pseudo reg occupied more than one register,\n    reg_reloaded_contents points to that pseudo for each spill register in\n    use; all of these must remain set for an inheritance to occur.  */\n static int reg_reloaded_contents[FIRST_PSEUDO_REGISTER];\n \n /* During reload_as_needed, element N contains the insn for which\n-   the Nth reload register was last used.  This vector is in parallel\n-   with spill_regs, and its contents are significant only when\n-   reg_reloaded_contents is significant.  */\n+   hard register N was last used.   Its contents are significant only\n+   when reg_reloaded_valid is set for this register.  */\n static rtx reg_reloaded_insn[FIRST_PSEUDO_REGISTER];\n \n+/* Indicate if reg_reloaded_insn / reg_reloaded_contents is valid */\n+static HARD_REG_SET reg_reloaded_valid;\n+/* Indicate if the register was dead at the end of the reload.\n+   This is only valid if reg_reloaded_contents is set and valid.  */\n+static HARD_REG_SET reg_reloaded_dead;\n+\n /* Number of spill-regs so far; number of valid elements of spill_regs.  */\n static int n_spills;\n \n@@ -3980,11 +3984,7 @@ reload_as_needed (first, live_known)\n   reg_last_reload_reg = (rtx *) alloca (max_regno * sizeof (rtx));\n   bzero ((char *) reg_last_reload_reg, max_regno * sizeof (rtx));\n   reg_has_output_reload = (char *) alloca (max_regno);\n-  for (i = 0; i < n_spills; i++)\n-    {\n-      reg_reloaded_contents[i] = -1;\n-      reg_reloaded_insn[i] = 0;\n-    }\n+  CLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n   /* Reset all offsets on eliminable registers to their initial values.  */\n #ifdef ELIMINABLE_REGS\n@@ -4197,32 +4197,21 @@ reload_as_needed (first, live_known)\n \t}\n       /* A reload reg's contents are unknown after a label.  */\n       if (GET_CODE (insn) == CODE_LABEL)\n-\tfor (i = 0; i < n_spills; i++)\n-\t  {\n-\t    reg_reloaded_contents[i] = -1;\n-\t    reg_reloaded_insn[i] = 0;\n-\t  }\n+\tCLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n       /* Don't assume a reload reg is still good after a call insn\n \t if it is a call-used reg.  */\n       else if (GET_CODE (insn) == CALL_INSN)\n-\tfor (i = 0; i < n_spills; i++)\n-\t  if (call_used_regs[spill_regs[i]])\n-\t    {\n-\t      reg_reloaded_contents[i] = -1;\n-\t      reg_reloaded_insn[i] = 0;\n-\t    }\n+\tAND_COMPL_HARD_REG_SET(reg_reloaded_valid, call_used_reg_set);\n \n       /* In case registers overlap, allow certain insns to invalidate\n \t particular hard registers.  */\n \n #ifdef INSN_CLOBBERS_REGNO_P\n-      for (i = 0 ; i < n_spills ; i++)\n-\tif (INSN_CLOBBERS_REGNO_P (insn, spill_regs[i]))\n-\t  {\n-\t    reg_reloaded_contents[i] = -1;\n-\t    reg_reloaded_insn[i] = 0;\n-\t  }\n+      for (i = 0 ; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n+\t    && INSN_CLOBBERS_REGNO_P (insn, i))\n+\t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i);\n #endif\n \n       insn = next;\n@@ -4272,15 +4261,11 @@ forget_old_reloads_1 (x, ignored)\n \t and it wasn't spilled because this block's total need is 0.\n \t Then some insn might have an optional reload and use this reg.  */\n       for (i = 0; i < nr; i++)\n-\tif (spill_reg_order[regno + i] >= 0\n-\t    /* But don't do this if the reg actually serves as an output\n-\t       reload reg in the current instruction.  */\n-\t    && (n_reloads == 0\n-\t\t|| ! TEST_HARD_REG_BIT (reg_is_output_reload, regno + i)))\n-\t  {\n-\t    reg_reloaded_contents[spill_reg_order[regno + i]] = -1;\n-\t    reg_reloaded_insn[spill_reg_order[regno + i]] = 0;\n-\t  }\n+\t/* But don't do this if the reg actually serves as an output\n+\t   reload reg in the current instruction.  */\n+\tif (n_reloads == 0\n+\t    || ! TEST_HARD_REG_BIT (reg_is_output_reload, regno + i))\n+\t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, regno + i);\n     }\n \n   /* Since value of X has changed,\n@@ -5005,8 +4990,8 @@ rtx reload_inheritance_insn[MAX_RELOADS];\n    rather than using reload_in.  */\n rtx reload_override_in[MAX_RELOADS];\n \n-/* For each reload, the index in spill_regs of the spill register used,\n-   or -1 if we did not need one of the spill registers for this reload.  */\n+/* For each reload, the hard register number of the register used,\n+   or -1 if we did not need a register for this reload.  */\n int reload_spill_index[MAX_RELOADS];\n \n /* Find a spill register to use as a reload register for reload R.\n@@ -5181,7 +5166,7 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \t\t\t\t    reload_when_needed[r], reload_mode[r]);\n \n \t    reload_reg_rtx[r] = new;\n-\t    reload_spill_index[r] = i;\n+\t    reload_spill_index[r] = spill_regs[i];\n \t    return 1;\n \t  }\n     }\n@@ -5504,32 +5489,32 @@ choose_reload_regs (insn, avoid_return_reg)\n \n \t      if (regno >= 0 && reg_last_reload_reg[regno] != 0)\n \t\t{\n-\t\t  i = spill_reg_order[REGNO (reg_last_reload_reg[regno])];\n+\t\t  i = REGNO (reg_last_reload_reg[regno]);\n \n \t\t  if (reg_reloaded_contents[i] == regno\n+\t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n \t\t      && (GET_MODE_SIZE (GET_MODE (reg_last_reload_reg[regno]))\n \t\t\t  >= GET_MODE_SIZE (mode))\n-\t\t      && HARD_REGNO_MODE_OK (spill_regs[i], reload_mode[r])\n+\t\t      && HARD_REGNO_MODE_OK (i, reload_mode[r])\n \t\t      && TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n-\t\t\t\t\t    spill_regs[i])\n+\t\t\t\t\t    i)\n \t\t      && (reload_nregs[r] == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n-\t\t\t\t\t\t  spill_regs[i]))\n-\t\t      && reload_reg_free_p (spill_regs[i], reload_opnum[r],\n+\t\t\t\t\t\t  i))\n+\t\t      && reload_reg_free_p (i, reload_opnum[r],\n \t\t\t\t\t    reload_when_needed[r])\n-\t\t      && reload_reg_free_before_p (spill_regs[i],\n-\t\t\t\t\t\t   reload_opnum[r],\n+\t\t      && reload_reg_free_before_p (i, reload_opnum[r],\n \t\t\t\t\t\t   reload_when_needed[r]))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n \t\t      int nr\n-\t\t\t= HARD_REGNO_NREGS (spill_regs[i], reload_mode[r]);\n+\t\t\t= HARD_REGNO_NREGS (i, reload_mode[r]);\n \t\t      int k;\n \n \t\t      for (k = 1; k < nr; k++)\n-\t\t\tif (reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n-\t\t\t    != regno)\n+\t\t\tif (reg_reloaded_contents[i + k] != regno\n+\t\t\t    || ! TEST_HARD_REG_BIT (reg_reloaded_valid, i + k))\n \t\t\t  break;\n \n \t\t      if (k == nr)\n@@ -5550,6 +5535,10 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t      break;\n \n \t\t\t  if (i1 != n_earlyclobbers\n+\t\t\t      /* Don't use it if we'd clobber a pseudo reg.  */\n+\t\t\t      || (spill_reg_order[i] < 0\n+\t\t\t\t  && reload_out[r]\n+\t\t\t\t  && ! TEST_HARD_REG_BIT (reg_reloaded_dead, i))\n \t\t\t      /* Don't really use the inherited spill reg\n \t\t\t\t if we need it wider than we've got it.  */\n \t\t\t      || (GET_MODE_SIZE (reload_mode[r])\n@@ -5561,7 +5550,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t      /* We can use this as a reload reg.  */\n \t\t\t      /* Mark the register as in use for this part of\n \t\t\t\t the insn.  */\n-\t\t\t      mark_reload_reg_in_use (spill_regs[i],\n+\t\t\t      mark_reload_reg_in_use (i,\n \t\t\t\t\t\t      reload_opnum[r],\n \t\t\t\t\t\t      reload_when_needed[r],\n \t\t\t\t\t\t      reload_mode[r]);\n@@ -5572,7 +5561,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t      reload_spill_index[r] = i;\n \t\t\t      for (k = 0; k < nr; k++)\n \t\t\t\tSET_HARD_REG_BIT (reload_reg_used_for_inherit,\n-\t\t\t\t\t\t  spill_regs[i + k]);\n+\t\t\t\t\t\t  i + k);\n \t\t\t    }\n \t\t\t}\n \t\t    }\n@@ -5844,7 +5833,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \n       i = reload_spill_index[r];\n \n-      /* I is nonneg if this reload used one of the spill regs.\n+      /* I is nonneg if this reload uses a register.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n \t that we opted to ignore.  */\n       if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG\n@@ -5861,9 +5850,9 @@ choose_reload_regs (insn, avoid_return_reg)\n \n \t  if (i >= 0)\n \t    {\n-\t      nr = HARD_REGNO_NREGS (spill_regs[i], reload_mode[r]);\n+\t      nr = HARD_REGNO_NREGS (i, reload_mode[r]);\n \t      while (--nr >= 0)\n-\t\tSET_HARD_REG_BIT (reg_is_output_reload, spill_regs[i] + nr);\n+\t\tSET_HARD_REG_BIT (reg_is_output_reload, i + nr);\n \t    }\n \n \t  if (reload_when_needed[r] != RELOAD_OTHER\n@@ -5985,6 +5974,9 @@ emit_reload_insns (insn)\n   int special;\n   /* Values to be put in spill_reg_store are put here first.  */\n   rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n+  HARD_REG_SET reg_reloaded_died;\n+\n+  CLEAR_HARD_REG_SET (reg_reloaded_died);\n \n   for (j = 0; j < reload_n_operands; j++)\n     input_reload_insns[j] = input_address_reload_insns[j]\n@@ -6151,14 +6143,12 @@ emit_reload_insns (insn)\n \n \t  if (optimize && GET_CODE (oldequiv) == REG\n \t      && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n-\t      && spill_reg_order[REGNO (oldequiv)] >= 0\n-\t      && spill_reg_store[spill_reg_order[REGNO (oldequiv)]] != 0\n-\t      && find_reg_note (insn, REG_DEAD, reload_in[j])\n+\t      && spill_reg_store[REGNO (oldequiv)]\n+\t      && GET_CODE (old) == REG && dead_or_set_p (insn, old)\n \t      /* This is unsafe if operand occurs more than once in current\n \t\t insn.  Perhaps some occurrences weren't reloaded.  */\n-\t      && count_occurrences (PATTERN (insn), reload_in[j]) == 1)\n-\t    delete_output_reload\n-\t      (insn, j, spill_reg_store[spill_reg_order[REGNO (oldequiv)]]);\n+\t      && count_occurrences (PATTERN (insn), old) == 1)\n+\t    delete_output_reload (insn, j, spill_reg_store[REGNO (oldequiv)]);\n \n \t  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n \t     then load RELOADREG from OLDEQUIV.  Note that we cannot use\n@@ -6566,7 +6556,7 @@ emit_reload_insns (insn)\n #endif\n \t  && spill_reg_store[reload_spill_index[j]] != 0\n \t  /* This is unsafe if some other reload uses the same reg first.  */\n-\t  && reload_reg_free_before_p (spill_regs[reload_spill_index[j]],\n+\t  && reload_reg_free_before_p (reload_spill_index[j],\n \t\t\t\t       reload_opnum[j], reload_when_needed[j])\n \t  && dead_or_set_p (insn, reload_in[j])\n \t  /* This is unsafe if operand occurs more than once in current\n@@ -6769,15 +6759,30 @@ emit_reload_insns (insn)\n \t  for (p = get_insns (); p; p = NEXT_INSN (p))\n \t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n \t      {\n+\t\trtx pat = PATTERN (p);\n+\n \t\t/* If this output reload doesn't come from a spill reg,\n \t\t   clear any memory of reloaded copies of the pseudo reg.\n \t\t   If this output reload comes from a spill reg,\n \t\t   reg_has_output_reload will make this do nothing.  */\n-\t\tnote_stores (PATTERN (p), forget_old_reloads_1);\n+\t\tnote_stores (pat, forget_old_reloads_1);\n+\n+\t\tif (reg_mentioned_p (reload_reg_rtx[j], pat))\n+\t\t  {\n+\t\t    if (reload_spill_index[j] < 0\n+\t\t\t&& GET_CODE (pat) == SET\n+\t\t\t&& SET_SRC (pat) == reload_reg_rtx[j])\n+\t\t      {\n+\t\t\tint src = REGNO (SET_SRC (pat));\n \n-\t\tif (reg_mentioned_p (reload_reg_rtx[j], PATTERN (p))\n-\t\t    && reload_spill_index[j] >= 0)\n-\t\t  new_spill_reg_store[reload_spill_index[j]] = p;\n+\t\t\treload_spill_index[j] = src;\n+\t\t\tSET_HARD_REG_BIT (reg_is_output_reload, src);\n+\t\t\tif (find_regno_note (insn, REG_DEAD, src))\n+\t\t\t  SET_HARD_REG_BIT (reg_reloaded_died, src);\n+\t\t      }\n+\t\t    if (reload_spill_index[j] >= 0)\n+\t\t      new_spill_reg_store[reload_spill_index[j]] = p;\n+\t\t  }\n \t      }\n \n \t  if (reload_when_needed[j] == RELOAD_OTHER)\n@@ -6893,14 +6898,14 @@ emit_reload_insns (insn)\n       register int r = reload_order[j];\n       register int i = reload_spill_index[r];\n \n-      /* I is nonneg if this reload used one of the spill regs.\n+      /* I is nonneg if this reload used a register.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n \t that we opted to ignore.  */\n \n       if (i >= 0 && reload_reg_rtx[r] != 0)\n \t{\n \t  int nr\n-\t    = HARD_REGNO_NREGS (spill_regs[i], GET_MODE (reload_reg_rtx[r]));\n+\t    = HARD_REGNO_NREGS (i, GET_MODE (reload_reg_rtx[r]));\n \t  int k;\n \t  int part_reaches_end = 0;\n \t  int all_reaches_end = 1;\n@@ -6909,7 +6914,7 @@ emit_reload_insns (insn)\n \t     of the value lives to the end.  */\n \t  for (k = 0; k < nr; k++)\n \t    {\n-\t      if (reload_reg_reaches_end_p (spill_regs[i] + k, reload_opnum[r],\n+\t      if (reload_reg_reaches_end_p (i + k, reload_opnum[r],\n \t\t\t\t\t    reload_when_needed[r]))\n \t\tpart_reaches_end = 1;\n \t      else\n@@ -6924,10 +6929,7 @@ emit_reload_insns (insn)\n \t\t If consecutive registers are used, clear them all.  */\n \n \t      for (k = 0; k < nr; k++)\n-\t\t{\n-\t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]] = -1;\n-\t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = 0;\n-\t\t}\n+\t\tCLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \n \t      /* Maybe the spill reg contains a copy of reload_out.  */\n \t      if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n@@ -6957,11 +6959,13 @@ emit_reload_insns (insn)\n \t\t  /* Now do the inverse operation.  */\n \t\t  for (k = 0; k < nr; k++)\n \t\t    {\n-\t\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n+\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, i + k);\n+\t\t      reg_reloaded_contents[i + k]\n \t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr\n \t\t\t   ? nregno\n \t\t\t   : nregno + k);\n-\t\t      reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = insn;\n+\t\t      reg_reloaded_insn[i + k] = insn;\n+\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \t\t    }\n \t\t}\n \n@@ -6970,6 +6974,7 @@ emit_reload_insns (insn)\n \t\t the register being reloaded.  */\n \t      else if (reload_out[r] == 0\n \t\t       && reload_in[r] != 0\n+\t\t       && spill_reg_order[i] >= 0\n \t\t       && ((GET_CODE (reload_in[r]) == REG\n \t\t\t    && ! reg_has_output_reload[REGNO (reload_in[r])])\n \t\t\t   || (GET_CODE (reload_in_reg[r]) == REG\n@@ -7004,12 +7009,13 @@ emit_reload_insns (insn)\n \n \t\t  for (k = 0; k < nr; k++)\n \t\t    {\n-\t\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n+\t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, i + k);\n+\t\t      reg_reloaded_contents[i + k]\n \t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr\n \t\t\t   ? nregno\n \t\t\t   : nregno + k);\n-\t\t      reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]]\n-\t\t\t= insn;\n+\t\t      reg_reloaded_insn[i + k] = insn;\n+\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \t\t    }\n \t\t}\n \t    }\n@@ -7019,13 +7025,10 @@ emit_reload_insns (insn)\n \t  else if (part_reaches_end)\n \t    {\n \t      for (k = 0; k < nr; k++)\n-\t\tif (reload_reg_reaches_end_p (spill_regs[i] + k,\n+\t\tif (reload_reg_reaches_end_p (i + k,\n \t\t\t\t\t      reload_opnum[r],\n \t\t\t\t\t      reload_when_needed[r]))\n-\t\t  {\n-\t\t    reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]] = -1;\n-\t\t    reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = 0;\n-\t\t  }\n+\t\t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \t    }\n \t}\n \n@@ -7051,6 +7054,7 @@ emit_reload_insns (insn)\n \t    }\n \t}\n     }\n+  IOR_HARD_REG_SET (reg_reloaded_dead, reg_reloaded_died);\n }\n \f\n /* Emit code to perform a reload from IN (which may be a reload register) to"}]}