{"sha": "2d6744f47576c61fa914057cc7d60e40b74eda95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ2NzQ0ZjQ3NTc2YzYxZmE5MTQwNTdjYzdkNjBlNDBiNzRlZGE5NQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-10-10T15:36:42Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-10-10T15:36:42Z"}, "message": "S/390: Wrap more macro args into ()\n\nTurned out that there where a few () around macro args uses missing.\nOne real problem with it was detected with the int-in-bool-context in\nthe definition of DBX_REGISTER_NUMBER. But while being at it I've\nalso tried to fix other places where brackets might be missing.\n\ngcc/ChangeLog:\n\n2016-10-10  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.h: Wrap more macros args in brackets and fix\n        some formatting.\n\nFrom-SVN: r240930", "tree": {"sha": "9ffef9ddd23e589c8a5079dd5987886cc646937c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ffef9ddd23e589c8a5079dd5987886cc646937c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d6744f47576c61fa914057cc7d60e40b74eda95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6744f47576c61fa914057cc7d60e40b74eda95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d6744f47576c61fa914057cc7d60e40b74eda95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6744f47576c61fa914057cc7d60e40b74eda95/comments", "author": null, "committer": null, "parents": [{"sha": "9e023e3321886e0ba1ea7b25c7ef70e50c267963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e023e3321886e0ba1ea7b25c7ef70e50c267963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e023e3321886e0ba1ea7b25c7ef70e50c267963"}], "stats": {"total": 92, "additions": 49, "deletions": 43}, "files": [{"sha": "2d5e330725becd3ac2bd536b8f942abbc699f620", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6744f47576c61fa914057cc7d60e40b74eda95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6744f47576c61fa914057cc7d60e40b74eda95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d6744f47576c61fa914057cc7d60e40b74eda95", "patch": "@@ -1,3 +1,7 @@\n+2016-10-10  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.h: Wrap more macros args in brackets and fix\n+\n 2016-10-10  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/gen-avr-mmcu-texi.c (string.h): Include."}, {"sha": "501c8e446df75fa35727b292fb0cf1383da4043e", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6744f47576c61fa914057cc7d60e40b74eda95/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6744f47576c61fa914057cc7d60e40b74eda95/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=2d6744f47576c61fa914057cc7d60e40b74eda95", "patch": "@@ -320,9 +320,9 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n    FUNCTION is VOIDmode because calling convention maintains SP.\n    BLOCK needs Pmode for SP.\n    NONLOCAL needs twice Pmode to maintain both backchain and SP.  */\n-#define STACK_SAVEAREA_MODE(LEVEL)      \\\n-  (LEVEL == SAVE_FUNCTION ? VOIDmode    \\\n-  : LEVEL == SAVE_NONLOCAL ? (TARGET_64BIT ? OImode : TImode) : Pmode)\n+#define STACK_SAVEAREA_MODE(LEVEL)\t\t\t\t\t\\\n+  ((LEVEL) == SAVE_FUNCTION ? VOIDmode\t\t\t\t\t\\\n+   : (LEVEL) == SAVE_NONLOCAL ? (TARGET_64BIT ? OImode : TImode) : Pmode)\n \n \n /* Type layout.  */\n@@ -491,7 +491,7 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n   s390_hard_regno_mode_ok ((REGNO), (MODE))\n \n #define HARD_REGNO_RENAME_OK(FROM, TO)          \\\n-  s390_hard_regno_rename_ok (FROM, TO)\n+  s390_hard_regno_rename_ok ((FROM), (TO))\n \n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n    (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n@@ -584,7 +584,7 @@ enum reg_class\n    reload can decide not to use the hard register because some\n    constant was forced to be in memory.  */\n #define IRA_HARD_REGNO_ADD_COST_MULTIPLIER(regno)\t\\\n-  (regno != BASE_REGNUM ? 0.0 : 0.5)\n+  ((regno) != BASE_REGNUM ? 0.0 : 0.5)\n \n /* Register -> class mapping.  */\n extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n@@ -617,10 +617,10 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n \n      FIXME: Should we try splitting it into two vlgvg's/vlvg's instead?  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n-  (((reg_classes_intersect_p (CLASS1, VEC_REGS)\t\t\t\t\\\n-     && reg_classes_intersect_p (CLASS2, GENERAL_REGS))\t\t\t\\\n-    || (reg_classes_intersect_p (CLASS1, GENERAL_REGS)\t\t\t\\\n-\t&& reg_classes_intersect_p (CLASS2, VEC_REGS)))\t\t\t\\\n+  (((reg_classes_intersect_p ((CLASS1), VEC_REGS)\t\t\t\\\n+     && reg_classes_intersect_p ((CLASS2), GENERAL_REGS))\t\t\\\n+    || (reg_classes_intersect_p ((CLASS1), GENERAL_REGS)\t\t\\\n+\t&& reg_classes_intersect_p ((CLASS2), VEC_REGS)))\t\t\\\n    && (!TARGET_DFP || !TARGET_64BIT || GET_MODE_SIZE (MODE) != 8)\t\\\n    && (!TARGET_VX || (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n \t\t\t  && GET_MODE_SIZE (MODE) > 8)))\n@@ -630,7 +630,7 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n  (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n   ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\\\n-  : MODE)\n+  : (MODE))\n \n \n /* Stack layout and calling conventions.  */\n@@ -720,8 +720,8 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n /* Define the dwarf register mapping.\n    v16-v31 -> 68-83\n    rX      -> X      otherwise  */\n-#define DBX_REGISTER_NUMBER(regno)\t\t\t\\\n-  ((regno >= 38 && regno <= 53) ? regno + 30 : regno)\n+#define DBX_REGISTER_NUMBER(regno)\t\t\t\t\\\n+  (((regno) >= 38 && (regno) <= 53) ? (regno) + 30 : (regno))\n \n /* Frame registers.  */\n \n@@ -832,24 +832,25 @@ CUMULATIVE_ARGS;\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.  */\n #define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  rtx new_rtx = legitimize_reload_address (AD, MODE, OPNUM, (int)(TYPE));\t\\\n-  if (new_rtx)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (AD) = new_rtx;\t\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    rtx new_rtx = legitimize_reload_address ((AD), (MODE),\t\t\\\n+\t\t\t\t\t     (OPNUM), (int)(TYPE));\t\\\n+    if (new_rtx)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(AD) = new_rtx;\t\t\t\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n /* Helper macro for s390.c and s390.md to check for symbolic constants.  */\n-#define SYMBOLIC_CONST(X)       \\\n-(GET_CODE (X) == SYMBOL_REF                                             \\\n- || GET_CODE (X) == LABEL_REF                                           \\\n- || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+#define SYMBOLIC_CONST(X)\t\t\t\t\t\t\\\n+  (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+   || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n \n-#define TLS_SYMBOLIC_CONST(X)\t\\\n-((GET_CODE (X) == SYMBOL_REF && tls_symbolic_operand (X))\t\\\n- || (GET_CODE (X) == CONST && tls_symbolic_reference_mentioned_p (X)))\n+#define TLS_SYMBOLIC_CONST(X)\t\t\t\t\t\t\\\n+  ((GET_CODE (X) == SYMBOL_REF && tls_symbolic_operand (X))\t\t\\\n+   || (GET_CODE (X) == CONST && tls_symbolic_reference_mentioned_p (X)))\n \n \n /* Condition codes.  */\n@@ -928,8 +929,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_COMMENT_START \"#\"\n \n /* Declare an uninitialized external linkage data object.  */\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\t\\\n+  asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n \n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \".globl \"\n@@ -946,7 +947,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LOCAL_LABEL_PREFIX \".\"\n \n #define LABEL_ALIGN(LABEL) \\\n-  s390_label_align (LABEL)\n+  s390_label_align ((LABEL))\n \n /* How to refer to registers in assembler output.  This sequence is\n    indexed by compiler's hard-register-number (see above).  */\n@@ -967,8 +968,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n     { \"v9\", 28 }, { \"v11\", 29 }, { \"v13\", 30 }, { \"v15\", 31 } };\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.  */\n-#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand ((FILE), (X), (CODE))\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address ((FILE), (ADDR))\n \n /* Output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\t\\\n@@ -998,8 +999,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define EPILOGUE_USES(REGNO) ((REGNO) == RETURN_REGNUM)\n \n #undef ASM_OUTPUT_FUNCTION_LABEL\n-#define ASM_OUTPUT_FUNCTION_LABEL(FILE, NAME, DECL) \\\n-  s390_asm_output_function_label (FILE, NAME, DECL)\n+#define ASM_OUTPUT_FUNCTION_LABEL(FILE, NAME, DECL)\t\t\\\n+  s390_asm_output_function_label ((FILE), (NAME), (DECL))\n \n #if S390_USE_TARGET_ATTRIBUTE\n /* Hook to output .machine and .machinemode at start of function.  */\n@@ -1056,24 +1057,25 @@ do {\t\t\t\t\t\t\t\t\t\\\n    the symbol_refs that can be misaligned and assume that the others\n    are correctly aligned.  Hence, if a symbol_ref does not have\n    a _NOTALIGN flag it is supposed to be correctly aligned.  */\n-#define SYMBOL_FLAG_SET_NOTALIGN2(X) SYMBOL_FLAG_SET_ALIGN(X, 1)\n-#define SYMBOL_FLAG_SET_NOTALIGN4(X) SYMBOL_FLAG_SET_ALIGN(X, 2)\n-#define SYMBOL_FLAG_SET_NOTALIGN8(X) SYMBOL_FLAG_SET_ALIGN(X, 3)\n+#define SYMBOL_FLAG_SET_NOTALIGN2(X) SYMBOL_FLAG_SET_ALIGN((X), 1)\n+#define SYMBOL_FLAG_SET_NOTALIGN4(X) SYMBOL_FLAG_SET_ALIGN((X), 2)\n+#define SYMBOL_FLAG_SET_NOTALIGN8(X) SYMBOL_FLAG_SET_ALIGN((X), 3)\n \n #define SYMBOL_FLAG_NOTALIGN2_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 1)\n-#define SYMBOL_FLAG_NOTALIGN4_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 2 \\\n+#define SYMBOL_FLAG_NOTALIGN4_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 2\t\\\n \t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 1)\n-#define SYMBOL_FLAG_NOTALIGN8_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 3 \\\n-\t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 2 \\\n+#define SYMBOL_FLAG_NOTALIGN8_P(X) (SYMBOL_FLAG_GET_ALIGN(X) == 3\t\\\n+\t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 2\t\\\n \t\t\t\t    || SYMBOL_FLAG_GET_ALIGN(X) == 1)\n \n /* Check whether integer displacement is in range for a short displacement.  */\n #define SHORT_DISP_IN_RANGE(d) ((d) >= 0 && (d) <= 4095)\n \n /* Check whether integer displacement is in range.  */\n-#define DISP_IN_RANGE(d) \\\n-  (TARGET_LONG_DISPLACEMENT? ((d) >= -524288 && (d) <= 524287) \\\n-                           : SHORT_DISP_IN_RANGE(d))\n+#define DISP_IN_RANGE(d)\t\t\t\t\\\n+  (TARGET_LONG_DISPLACEMENT\t\t\t\t\\\n+   ? ((d) >= -524288 && (d) <= 524287)\t\t\t\\\n+   : SHORT_DISP_IN_RANGE(d))\n \n /* Reads can reuse write prefetches, used by tree-ssa-prefetch-loops.c.  */\n #define READ_CAN_USE_WRITE_PREFETCH 1"}]}