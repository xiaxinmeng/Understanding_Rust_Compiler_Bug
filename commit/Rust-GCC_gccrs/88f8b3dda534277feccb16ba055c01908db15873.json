{"sha": "88f8b3dda534277feccb16ba055c01908db15873", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmOGIzZGRhNTM0Mjc3ZmVjY2IxNmJhMDU1YzAxOTA4ZGIxNTg3Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-27T15:48:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-27T17:07:31Z"}, "message": "c++: Small cleanup for do_type_instantiation\n\nIn working on a bigger cleanup I noticed some opportunities to make\ndo_type_instantiation's control flow simpler.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_explicit_instantiation): Refactor some RAII.\n\t* pt.c (bt_instantiate_type_proc): DATA is the tree, pass type to\n\tdo_type_instantiation.\n\t(do_type_instantiation): Require T to be a type.  Refactor for\n\tsome RAII.", "tree": {"sha": "09833d73c65c0d6ea4fe45d6453771ebc8dd03a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09833d73c65c0d6ea4fe45d6453771ebc8dd03a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88f8b3dda534277feccb16ba055c01908db15873", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f8b3dda534277feccb16ba055c01908db15873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f8b3dda534277feccb16ba055c01908db15873", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f8b3dda534277feccb16ba055c01908db15873/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f801e0b6cc9f67c9a8983127e23161f6025c5b6"}], "stats": {"total": 97, "additions": 41, "deletions": 56}, "files": [{"sha": "6a5469b553b1f85b9f86b805f30145840d1505dd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f8b3dda534277feccb16ba055c01908db15873/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f8b3dda534277feccb16ba055c01908db15873/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=88f8b3dda534277feccb16ba055c01908db15873", "patch": "@@ -17642,10 +17642,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n      instantiation.  */\n   if (declares_class_or_enum && cp_parser_declares_only_class_p (parser))\n     {\n-      tree type;\n-\n-      type = check_tag_decl (&decl_specifiers,\n-\t\t\t     /*explicit_type_instantiation_p=*/true);\n+      tree type = check_tag_decl (&decl_specifiers,\n+\t\t\t\t  /*explicit_type_instantiation_p=*/true);\n       /* Turn access control back on for names used during\n \t template instantiation.  */\n       pop_deferring_access_checks ();\n@@ -25156,14 +25154,12 @@ cp_parser_member_declaration (cp_parser* parser)\n \t}\n       else\n \t{\n-\t  tree type;\n-\n \t  /* See if this declaration is a friend.  */\n \t  friend_p = cp_parser_friend_p (&decl_specifiers);\n \t  /* If there were decl-specifiers, check to see if there was\n \t     a class-declaration.  */\n-\t  type = check_tag_decl (&decl_specifiers,\n-\t\t\t\t /*explicit_type_instantiation_p=*/false);\n+\t  tree type = check_tag_decl (&decl_specifiers,\n+\t\t\t\t      /*explicit_type_instantiation_p=*/false);\n \t  /* Nested classes have already been added to the class, but\n \t     a `friend' needs to be explicitly registered.  */\n \t  if (friend_p)"}, {"sha": "701f7c190fe23bd24409d76bcaf927b92b02fd19", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f8b3dda534277feccb16ba055c01908db15873/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f8b3dda534277feccb16ba055c01908db15873/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=88f8b3dda534277feccb16ba055c01908db15873", "patch": "@@ -24964,12 +24964,12 @@ mark_class_instantiated (tree t, int extern_p)\n static void\n bt_instantiate_type_proc (binding_entry entry, void *data)\n {\n-  tree storage = *(tree *) data;\n+  tree storage = tree (data);\n \n-  if (MAYBE_CLASS_TYPE_P (entry->type)\n+  if (CLASS_TYPE_P (entry->type)\n       && CLASSTYPE_TEMPLATE_INFO (entry->type)\n       && !uses_template_parms (CLASSTYPE_TI_ARGS (entry->type)))\n-    do_type_instantiation (TYPE_MAIN_DECL (entry->type), storage, 0);\n+    do_type_instantiation (entry->type, storage, 0);\n }\n \n /* Perform an explicit instantiation of template class T.  STORAGE, if\n@@ -24980,20 +24980,11 @@ bt_instantiate_type_proc (binding_entry entry, void *data)\n void\n do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n {\n-  int extern_p = 0;\n-  int nomem_p = 0;\n-  int static_p = 0;\n-  int previous_instantiation_extern_p = 0;\n-\n-  if (TREE_CODE (t) == TYPE_DECL)\n-    t = TREE_TYPE (t);\n-\n-  if (! CLASS_TYPE_P (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n+  if (!(CLASS_TYPE_P (t) && CLASSTYPE_TEMPLATE_INFO (t)))\n     {\n-      tree tmpl =\n-\t(TYPE_TEMPLATE_INFO (t)) ? TYPE_TI_TEMPLATE (t) : NULL;\n-      if (tmpl)\n-\terror (\"explicit instantiation of non-class template %qD\", tmpl);\n+      if (tree ti = TYPE_TEMPLATE_INFO (t))\n+\terror (\"explicit instantiation of non-class template %qD\",\n+\t       TI_TEMPLATE (ti));\n       else\n \terror (\"explicit instantiation of non-template type %qT\", t);\n       return;\n@@ -25009,6 +25000,11 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n       return;\n     }\n \n+  /* At most one of these will be true.  */\n+  bool extern_p = false;\n+  bool nomem_p = false;\n+  bool static_p = false;\n+\n   if (storage != NULL_TREE)\n     {\n       if (storage == ridpointers[(int) RID_EXTERN])\n@@ -25024,52 +25020,45 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t\t \" on explicit instantiations\", storage);\n \n       if (storage == ridpointers[(int) RID_INLINE])\n-\tnomem_p = 1;\n+\tnomem_p = true;\n       else if (storage == ridpointers[(int) RID_EXTERN])\n-\textern_p = 1;\n+\textern_p = true;\n       else if (storage == ridpointers[(int) RID_STATIC])\n-\tstatic_p = 1;\n+\tstatic_p = true;\n       else\n-\t{\n-\t  error (\"storage class %qD applied to template instantiation\",\n-\t\t storage);\n-\t  extern_p = 0;\n-\t}\n+\terror (\"storage class %qD applied to template instantiation\",\n+\t       storage);\n     }\n \n   if (CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n-    {\n-      /* DR 259 [temp.spec].\n+    /* DR 259 [temp.spec].\n \n-\t Both an explicit instantiation and a declaration of an explicit\n-\t specialization shall not appear in a program unless the explicit\n-\t instantiation follows a declaration of the explicit specialization.\n+       Both an explicit instantiation and a declaration of an explicit\n+       specialization shall not appear in a program unless the\n+       explicit instantiation follows a declaration of the explicit\n+       specialization.\n \n-\t For a given set of template parameters, if an explicit\n-\t instantiation of a template appears after a declaration of an\n-\t explicit specialization for that template, the explicit\n-\t instantiation has no effect.  */\n-      return;\n-    }\n-  else if (CLASSTYPE_EXPLICIT_INSTANTIATION (t))\n+       For a given set of template parameters, if an explicit\n+       instantiation of a template appears after a declaration of an\n+       explicit specialization for that template, the explicit\n+       instantiation has no effect.  */\n+    return;\n+\n+  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && !CLASSTYPE_INTERFACE_ONLY (t))\n     {\n+      /* We've already instantiated the template.  */\n+\n       /* [temp.spec]\n \n \t No program shall explicitly instantiate any template more\n \t than once.\n \n-\t If PREVIOUS_INSTANTIATION_EXTERN_P, then the first explicit\n-\t instantiation was `extern'.  If EXTERN_P then the second is.\n-\t These cases are OK.  */\n-      previous_instantiation_extern_p = CLASSTYPE_INTERFACE_ONLY (t);\n+\t If EXTERN_P then this is ok.  */\n+      if (!extern_p && (complain & tf_error))\n+\tpermerror (input_location,\n+\t\t   \"duplicate explicit instantiation of %q#T\", t);\n \n-      if (!previous_instantiation_extern_p && !extern_p\n-\t  && (complain & tf_error))\n-\tpermerror (input_location, \"duplicate explicit instantiation of %q#T\", t);\n-\n-      /* If we've already instantiated the template, just return now.  */\n-      if (!CLASSTYPE_INTERFACE_ONLY (t))\n-\treturn;\n+      return;\n     }\n \n   check_explicit_instantiation_namespace (TYPE_NAME (t));\n@@ -25109,7 +25098,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n   if (CLASSTYPE_NESTED_UTDS (t))\n     binding_table_foreach (CLASSTYPE_NESTED_UTDS (t),\n-\t\t\t   bt_instantiate_type_proc, &storage);\n+\t\t\t   bt_instantiate_type_proc, storage);\n }\n \n /* Given a function DECL, which is a specialization of TMPL, modify"}]}