{"sha": "5c72d561883d0d8828962d84ee64739d8abce84c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM3MmQ1NjE4ODNkMGQ4ODI4OTYyZDg0ZWU2NDczOWQ4YWJjZTg0Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-05T13:55:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-05T13:55:17Z"}, "message": "df-problems.c (seen_in_block, [...]): Convert to bitmap_head.\n\n\t* df-problems.c (seen_in_block, seen_in_insn): Convert to bitmap_head.\n\t(df_rd_problem_data): Convert sparse_invalidated_by_call,\n\tdense_invalidated_by_call to bitmap head.\n\t(df_rd_alloc, df_rd_bb_local_compute_process_def,\n\tdf_rd_bb_local_compute, df_rd_confluence_n, df_rd_transfer_function,\n\tdf_rd_start_dump, df_lr_verify_transfer_functions,\n\tdf_live_verify_transfer_functions, df_chain_create_bb,\n\tdf_chain_add_problem, df_byte_lr_check_regs, df_byte_lr_alloc,\n\tdf_byte_lr_confluence_0, df_byte_lr_confluence_n, df_note_compute,\n\tdf_simulate_one_insn_forwards, df_md_alloc, df_md_bb_local_compute_process_def,\n\tdf_md_bb_local_compute_process_def, df_md_local_compute, df_md_transfer_function\n\tdf_md_free): Update.\n\nFrom-SVN: r160315", "tree": {"sha": "8fee96ac80284c0e5363e89c077d43c827538bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fee96ac80284c0e5363e89c077d43c827538bb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c72d561883d0d8828962d84ee64739d8abce84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c72d561883d0d8828962d84ee64739d8abce84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c72d561883d0d8828962d84ee64739d8abce84c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c72d561883d0d8828962d84ee64739d8abce84c/comments", "author": null, "committer": null, "parents": [{"sha": "d65aed7092a459f92769dea4aac2cb0ebb0680a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d65aed7092a459f92769dea4aac2cb0ebb0680a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d65aed7092a459f92769dea4aac2cb0ebb0680a8"}], "stats": {"total": 344, "additions": 181, "deletions": 163}, "files": [{"sha": "5f83ec7c19d07e236d6a4798da202ea187a85d45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c72d561883d0d8828962d84ee64739d8abce84c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c72d561883d0d8828962d84ee64739d8abce84c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c72d561883d0d8828962d84ee64739d8abce84c", "patch": "@@ -1,3 +1,18 @@\n+2010-06-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df-problems.c (seen_in_block, seen_in_insn): Convert to bitmap_head.\n+\t(df_rd_problem_data): Convert sparse_invalidated_by_call,\n+\tdense_invalidated_by_call to bitmap head.\n+\t(df_rd_alloc, df_rd_bb_local_compute_process_def,\n+\tdf_rd_bb_local_compute, df_rd_confluence_n, df_rd_transfer_function,\n+\tdf_rd_start_dump, df_lr_verify_transfer_functions,\n+\tdf_live_verify_transfer_functions, df_chain_create_bb,\n+\tdf_chain_add_problem, df_byte_lr_check_regs, df_byte_lr_alloc,\n+\tdf_byte_lr_confluence_0, df_byte_lr_confluence_n, df_note_compute,\n+\tdf_simulate_one_insn_forwards, df_md_alloc, df_md_bb_local_compute_process_def,\n+\tdf_md_bb_local_compute_process_def, df_md_local_compute, df_md_transfer_function\n+\tdf_md_free): Update.\n+\n 2010-06-05  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/44322"}, {"sha": "30d0ba6a3b2351ef244b2bf6f14cffbc72636401", "filename": "gcc/df-problems.c", "status": "modified", "additions": 118, "deletions": 117, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c72d561883d0d8828962d84ee64739d8abce84c/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c72d561883d0d8828962d84ee64739d8abce84c/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=5c72d561883d0d8828962d84ee64739d8abce84c", "patch": "@@ -54,8 +54,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #define DF_SPARSE_THRESHOLD 32\n \n-static bitmap seen_in_block = NULL;\n-static bitmap seen_in_insn = NULL;\n+static bitmap_head seen_in_block;\n+static bitmap_head seen_in_insn;\n \n \f\n /*----------------------------------------------------------------------------\n@@ -195,9 +195,9 @@ df_print_bb_index (basic_block bb, FILE *file)\n struct df_rd_problem_data\n {\n   /* The set of defs to regs invalidated by call.  */\n-  bitmap sparse_invalidated_by_call;\n+  bitmap_head sparse_invalidated_by_call;\n   /* The set of defs to regs invalidate by call for rd.  */\n-  bitmap dense_invalidated_by_call;\n+  bitmap_head dense_invalidated_by_call;\n   /* An obstack for the bitmaps we need for this problem.  */\n   bitmap_obstack rd_bitmaps;\n };\n@@ -250,19 +250,19 @@ df_rd_alloc (bitmap all_blocks)\n   if (df_rd->problem_data)\n     {\n       problem_data = (struct df_rd_problem_data *) df_rd->problem_data;\n-      bitmap_clear (problem_data->sparse_invalidated_by_call);\n-      bitmap_clear (problem_data->dense_invalidated_by_call);\n+      bitmap_clear (&problem_data->sparse_invalidated_by_call);\n+      bitmap_clear (&problem_data->dense_invalidated_by_call);\n     }\n   else\n     {\n       problem_data = XNEW (struct df_rd_problem_data);\n       df_rd->problem_data = problem_data;\n \n       bitmap_obstack_initialize (&problem_data->rd_bitmaps);\n-      problem_data->sparse_invalidated_by_call\n-\t= BITMAP_ALLOC (&problem_data->rd_bitmaps);\n-      problem_data->dense_invalidated_by_call\n-\t= BITMAP_ALLOC (&problem_data->rd_bitmaps);\n+      bitmap_initialize (&problem_data->sparse_invalidated_by_call,\n+\t\t\t &problem_data->rd_bitmaps);\n+      bitmap_initialize (&problem_data->dense_invalidated_by_call,\n+\t\t\t &problem_data->rd_bitmaps);\n     }\n \n   df_grow_bb_info (df_rd);\n@@ -370,11 +370,11 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t    {\n \t      /* Only the last def(s) for a regno in the block has any\n \t\t effect.  */\n-\t      if (!bitmap_bit_p (seen_in_block, regno))\n+\t      if (!bitmap_bit_p (&seen_in_block, regno))\n \t\t{\n \t\t  /* The first def for regno in insn gets to knock out the\n \t\t     defs from other instructions.  */\n-\t\t  if ((!bitmap_bit_p (seen_in_insn, regno))\n+\t\t  if ((!bitmap_bit_p (&seen_in_insn, regno))\n \t\t      /* If the def is to only part of the reg, it does\n \t\t\t not kill the other defs that reach here.  */\n \t\t      && (!(DF_REF_FLAGS (def) &\n@@ -392,7 +392,7 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t\t}\n \t\t    }\n \n-\t\t  bitmap_set_bit (seen_in_insn, regno);\n+\t\t  bitmap_set_bit (&seen_in_insn, regno);\n \t\t  /* All defs for regno in the instruction may be put into\n \t\t     the gen set.  */\n \t\t  if (!(DF_REF_FLAGS (def)\n@@ -414,8 +414,8 @@ df_rd_bb_local_compute (unsigned int bb_index)\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   rtx insn;\n \n-  bitmap_clear (seen_in_block);\n-  bitmap_clear (seen_in_insn);\n+  bitmap_clear (&seen_in_block);\n+  bitmap_clear (&seen_in_insn);\n \n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n@@ -439,8 +439,8 @@ df_rd_bb_local_compute (unsigned int bb_index)\n \t result and another def for the clobber.  If only one vector\n \t is used and the clobber goes first, the result will be\n \t lost.  */\n-      bitmap_ior_into (seen_in_block, seen_in_insn);\n-      bitmap_clear (seen_in_insn);\n+      bitmap_ior_into (&seen_in_block, &seen_in_insn);\n+      bitmap_clear (&seen_in_insn);\n     }\n \n   /* Process the artificial defs at the top of the block last since we\n@@ -463,11 +463,11 @@ df_rd_local_compute (bitmap all_blocks)\n   unsigned int regno;\n   struct df_rd_problem_data *problem_data\n     = (struct df_rd_problem_data *) df_rd->problem_data;\n-  bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n-  bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n+  bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_call;\n+  bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n \n-  seen_in_block = BITMAP_ALLOC (&df_bitmap_obstack);\n-  seen_in_insn = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_initialize (&seen_in_block, &df_bitmap_obstack);\n+  bitmap_initialize (&seen_in_insn, &df_bitmap_obstack);\n \n   df_maybe_reorganize_def_refs (DF_REF_ORDER_BY_REG);\n \n@@ -487,8 +487,8 @@ df_rd_local_compute (bitmap all_blocks)\n \t\t\t  DF_DEFS_COUNT (regno));\n     }\n \n-  BITMAP_FREE (seen_in_block);\n-  BITMAP_FREE (seen_in_insn);\n+  bitmap_clear (&seen_in_block);\n+  bitmap_clear (&seen_in_insn);\n }\n \n \n@@ -524,23 +524,24 @@ df_rd_confluence_n (edge e)\n     {\n       struct df_rd_problem_data *problem_data\n \t= (struct df_rd_problem_data *) df_rd->problem_data;\n-      bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n-      bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n+      bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_call;\n+      bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n       bitmap_iterator bi;\n       unsigned int regno;\n-      bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n+      bitmap_head tmp;\n \n-      bitmap_copy (tmp, op2);\n-      bitmap_and_compl_into (tmp, dense_invalidated);\n+      bitmap_initialize (&tmp, &df_bitmap_obstack);\n+      bitmap_copy (&tmp, op2);\n+      bitmap_and_compl_into (&tmp, dense_invalidated);\n \n       EXECUTE_IF_SET_IN_BITMAP (sparse_invalidated, 0, regno, bi)\n  \t{\n- \t  bitmap_clear_range (tmp,\n+ \t  bitmap_clear_range (&tmp,\n  \t\t\t      DF_DEFS_BEGIN (regno),\n  \t\t\t      DF_DEFS_COUNT (regno));\n \t}\n-      bitmap_ior_into (op1, tmp);\n-      BITMAP_FREE (tmp);\n+      bitmap_ior_into (op1, &tmp);\n+      bitmap_clear (&tmp);\n     }\n   else\n     bitmap_ior_into (op1, op2);\n@@ -567,30 +568,30 @@ df_rd_transfer_function (int bb_index)\n     {\n       struct df_rd_problem_data *problem_data;\n       bool changed = false;\n-      bitmap tmp;\n+      bitmap_head tmp;\n \n       /* Note that TMP is _not_ a temporary bitmap if we end up replacing\n \t OUT with TMP.  Therefore, allocate TMP in the RD bitmaps obstack.  */\n       problem_data = (struct df_rd_problem_data *) df_rd->problem_data;\n-      tmp = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n+      bitmap_initialize (&tmp, &problem_data->rd_bitmaps);\n \n-      bitmap_copy (tmp, in);\n+      bitmap_copy (&tmp, in);\n       EXECUTE_IF_SET_IN_BITMAP (sparse_kill, 0, regno, bi)\n \t{\n-\t  bitmap_clear_range (tmp,\n+\t  bitmap_clear_range (&tmp,\n \t\t\t      DF_DEFS_BEGIN (regno),\n \t\t\t      DF_DEFS_COUNT (regno));\n \t}\n-      bitmap_and_compl_into (tmp, kill);\n-      bitmap_ior_into (tmp, gen);\n-      changed = !bitmap_equal_p (tmp, out);\n+      bitmap_and_compl_into (&tmp, kill);\n+      bitmap_ior_into (&tmp, gen);\n+      changed = !bitmap_equal_p (&tmp, out);\n       if (changed)\n \t{\n \t  bitmap_clear (out);\n-\t  bb_info->out = *tmp;\n+\t  bb_info->out = tmp;\n \t}\n       else\n-\t  bitmap_clear (tmp);\n+\t  bitmap_clear (&tmp);\n       return changed;\n     }\n }\n@@ -633,9 +634,9 @@ df_rd_start_dump (FILE *file)\n   fprintf (file, \";; Reaching defs:\\n\\n\");\n \n   fprintf (file, \"  sparse invalidated \\t\");\n-  dump_bitmap (file, problem_data->sparse_invalidated_by_call);\n+  dump_bitmap (file, &problem_data->sparse_invalidated_by_call);\n   fprintf (file, \"  dense invalidated \\t\");\n-  dump_bitmap (file, problem_data->dense_invalidated_by_call);\n+  dump_bitmap (file, &problem_data->dense_invalidated_by_call);\n \n   for (regno = 0; regno < m; regno++)\n     if (DF_DEFS_COUNT (regno))\n@@ -1269,25 +1270,21 @@ void\n df_lr_verify_transfer_functions (void)\n {\n   basic_block bb;\n-  bitmap saved_def;\n-  bitmap saved_use;\n-  bitmap saved_adef;\n-  bitmap saved_ause;\n-  bitmap all_blocks;\n+  bitmap_head saved_def;\n+  bitmap_head saved_use;\n+  bitmap_head all_blocks;\n \n   if (!df)\n     return;\n \n-  saved_def = BITMAP_ALLOC (NULL);\n-  saved_use = BITMAP_ALLOC (NULL);\n-  saved_adef = BITMAP_ALLOC (NULL);\n-  saved_ause = BITMAP_ALLOC (NULL);\n-  all_blocks = BITMAP_ALLOC (NULL);\n+  bitmap_initialize (&saved_def, &bitmap_default_obstack); \n+  bitmap_initialize (&saved_use, &bitmap_default_obstack);\n+  bitmap_initialize (&all_blocks, &bitmap_default_obstack);\n \n   FOR_ALL_BB (bb)\n     {\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n-      bitmap_set_bit (all_blocks, bb->index);\n+      bitmap_set_bit (&all_blocks, bb->index);\n \n       if (bb_info)\n \t{\n@@ -1297,14 +1294,14 @@ df_lr_verify_transfer_functions (void)\n \t  if (!bitmap_bit_p (df_lr->out_of_date_transfer_functions,\n \t\t\t     bb->index))\n \t    {\n-\t      bitmap_copy (saved_def, &bb_info->def);\n-\t      bitmap_copy (saved_use, &bb_info->use);\n+\t      bitmap_copy (&saved_def, &bb_info->def);\n+\t      bitmap_copy (&saved_use, &bb_info->use);\n \t      bitmap_clear (&bb_info->def);\n \t      bitmap_clear (&bb_info->use);\n \n \t      df_lr_bb_local_compute (bb->index);\n-\t      gcc_assert (bitmap_equal_p (saved_def, &bb_info->def));\n-\t      gcc_assert (bitmap_equal_p (saved_use, &bb_info->use));\n+\t      gcc_assert (bitmap_equal_p (&saved_def, &bb_info->def));\n+\t      gcc_assert (bitmap_equal_p (&saved_use, &bb_info->use));\n \t    }\n \t}\n       else\n@@ -1322,13 +1319,11 @@ df_lr_verify_transfer_functions (void)\n \n   /* Make sure there are no dirty bits in blocks that have been deleted.  */\n   gcc_assert (!bitmap_intersect_compl_p (df_lr->out_of_date_transfer_functions,\n-\t\t\t\t\t all_blocks));\n+\t\t\t\t\t &all_blocks));\n \n-  BITMAP_FREE (saved_def);\n-  BITMAP_FREE (saved_use);\n-  BITMAP_FREE (saved_adef);\n-  BITMAP_FREE (saved_ause);\n-  BITMAP_FREE (all_blocks);\n+  bitmap_clear (&saved_def);\n+  bitmap_clear (&saved_use);\n+  bitmap_clear (&all_blocks);\n }\n \n \n@@ -1828,23 +1823,23 @@ void\n df_live_verify_transfer_functions (void)\n {\n   basic_block bb;\n-  bitmap saved_gen;\n-  bitmap saved_kill;\n-  bitmap all_blocks;\n+  bitmap_head saved_gen;\n+  bitmap_head saved_kill;\n+  bitmap_head all_blocks;\n \n   if (!df)\n     return;\n \n-  saved_gen = BITMAP_ALLOC (NULL);\n-  saved_kill = BITMAP_ALLOC (NULL);\n-  all_blocks = BITMAP_ALLOC (NULL);\n+  bitmap_initialize (&saved_gen, &bitmap_default_obstack);\n+  bitmap_initialize (&saved_kill, &bitmap_default_obstack);\n+  bitmap_initialize (&all_blocks, &bitmap_default_obstack);\n \n   df_grow_insn_info ();\n \n   FOR_ALL_BB (bb)\n     {\n       struct df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n-      bitmap_set_bit (all_blocks, bb->index);\n+      bitmap_set_bit (&all_blocks, bb->index);\n \n       if (bb_info)\n \t{\n@@ -1854,14 +1849,14 @@ df_live_verify_transfer_functions (void)\n \t  if (!bitmap_bit_p (df_live->out_of_date_transfer_functions,\n \t\t\t     bb->index))\n \t    {\n-\t      bitmap_copy (saved_gen, &bb_info->gen);\n-\t      bitmap_copy (saved_kill, &bb_info->kill);\n+\t      bitmap_copy (&saved_gen, &bb_info->gen);\n+\t      bitmap_copy (&saved_kill, &bb_info->kill);\n \t      bitmap_clear (&bb_info->gen);\n \t      bitmap_clear (&bb_info->kill);\n \n \t      df_live_bb_local_compute (bb->index);\n-\t      gcc_assert (bitmap_equal_p (saved_gen, &bb_info->gen));\n-\t      gcc_assert (bitmap_equal_p (saved_kill, &bb_info->kill));\n+\t      gcc_assert (bitmap_equal_p (&saved_gen, &bb_info->gen));\n+\t      gcc_assert (bitmap_equal_p (&saved_kill, &bb_info->kill));\n \t    }\n \t}\n       else\n@@ -1879,10 +1874,10 @@ df_live_verify_transfer_functions (void)\n \n   /* Make sure there are no dirty bits in blocks that have been deleted.  */\n   gcc_assert (!bitmap_intersect_compl_p (df_live->out_of_date_transfer_functions,\n-\t\t\t\t\t all_blocks));\n-  BITMAP_FREE (saved_gen);\n-  BITMAP_FREE (saved_kill);\n-  BITMAP_FREE (all_blocks);\n+\t\t\t\t\t &all_blocks));\n+  bitmap_clear (&saved_gen);\n+  bitmap_clear (&saved_kill);\n+  bitmap_clear (&all_blocks);\n }\n \f\n /*----------------------------------------------------------------------------\n@@ -2109,9 +2104,10 @@ df_chain_create_bb (unsigned int bb_index)\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   rtx insn;\n-  bitmap cpy = BITMAP_ALLOC (NULL);\n+  bitmap_head cpy;\n \n-  bitmap_copy (cpy, &bb_info->in);\n+  bitmap_initialize (&cpy, &bitmap_default_obstack);\n+  bitmap_copy (&cpy, &bb_info->in);\n   bitmap_set_bit (df_chain->out_of_date_transfer_functions, bb_index);\n \n   /* Since we are going forwards, process the artificial uses first\n@@ -2123,12 +2119,12 @@ df_chain_create_bb (unsigned int bb_index)\n \n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_chain_create_bb_process_use (cpy,\n+    df_chain_create_bb_process_use (&cpy,\n \t\t\t\t    df_get_artificial_uses (bb->index),\n \t\t\t\t    DF_REF_AT_TOP);\n #endif\n \n-  df_rd_simulate_artificial_defs_at_top (bb, cpy);\n+  df_rd_simulate_artificial_defs_at_top (bb, &cpy);\n \n   /* Process the regular instructions next.  */\n   FOR_BB_INSNS (bb, insn)\n@@ -2138,22 +2134,22 @@ df_chain_create_bb (unsigned int bb_index)\n \n         /* First scan the uses and link them up with the defs that remain\n \t   in the cpy vector.  */\n-        df_chain_create_bb_process_use (cpy, DF_INSN_UID_USES (uid), 0);\n+        df_chain_create_bb_process_use (&cpy, DF_INSN_UID_USES (uid), 0);\n         if (df->changeable_flags & DF_EQ_NOTES)\n-\t  df_chain_create_bb_process_use (cpy, DF_INSN_UID_EQ_USES (uid), 0);\n+\t  df_chain_create_bb_process_use (&cpy, DF_INSN_UID_EQ_USES (uid), 0);\n \n         /* Since we are going forwards, process the defs second.  */\n-        df_rd_simulate_one_insn (bb, insn, cpy);\n+        df_rd_simulate_one_insn (bb, insn, &cpy);\n       }\n \n   /* Create the chains for the artificial uses of the hard registers\n      at the end of the block.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_chain_create_bb_process_use (cpy,\n+    df_chain_create_bb_process_use (&cpy,\n \t\t\t\t    df_get_artificial_uses (bb->index),\n \t\t\t\t    0);\n \n-  BITMAP_FREE (cpy);\n+  bitmap_clear (&cpy);\n }\n \n /* Create def-use chains from reaching use bitmaps for basic blocks\n@@ -2368,12 +2364,12 @@ df_chain_add_problem (unsigned int chain_flags)\n struct df_byte_lr_problem_data\n {\n   /* Expanded versions of bitvectors used in lr.  */\n-  bitmap invalidated_by_call;\n-  bitmap hardware_regs_used;\n+  bitmap_head invalidated_by_call;\n+  bitmap_head hardware_regs_used;\n \n   /* Indexed by regno, this is true if there are subregs, extracts or\n      strict_low_parts for this regno.  */\n-  bitmap needs_expansion;\n+  bitmap_head needs_expansion;\n \n   /* The start position and len for each regno in the various bit\n      vectors.  */\n@@ -2452,7 +2448,7 @@ df_byte_lr_check_regs (df_ref *ref_rec)\n \t\t\t       | DF_REF_ZERO_EXTRACT\n \t\t\t       | DF_REF_STRICT_LOW_PART)\n \t  || GET_CODE (DF_REF_REG (ref)) == SUBREG)\n-\tbitmap_set_bit (problem_data->needs_expansion, DF_REF_REGNO (ref));\n+\tbitmap_set_bit (&problem_data->needs_expansion, DF_REF_REGNO (ref));\n     }\n }\n \n@@ -2509,9 +2505,12 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   bitmap_obstack_initialize (&problem_data->byte_lr_bitmaps);\n   problem_data->regno_start = XNEWVEC (unsigned int, max_reg);\n   problem_data->regno_len = XNEWVEC (unsigned int, max_reg);\n-  problem_data->hardware_regs_used = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n-  problem_data->invalidated_by_call = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n-  problem_data->needs_expansion = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n+  bitmap_initialize (&problem_data->hardware_regs_used,\n+\t\t     &problem_data->byte_lr_bitmaps);\n+  bitmap_initialize (&problem_data->invalidated_by_call,\n+\t\t     &problem_data->byte_lr_bitmaps);\n+  bitmap_initialize (&problem_data->needs_expansion,\n+\t\t     &problem_data->byte_lr_bitmaps);\n \n   /* Discover which regno's use subregs, extracts or\n      strict_low_parts.  */\n@@ -2538,7 +2537,7 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n     {\n       int len;\n       problem_data->regno_start[regno] = index;\n-      if (bitmap_bit_p (problem_data->needs_expansion, regno))\n+      if (bitmap_bit_p (&problem_data->needs_expansion, regno))\n \tlen = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n       else\n \tlen = 1;\n@@ -2547,9 +2546,9 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n       index += len;\n     }\n \n-  df_byte_lr_expand_bitmap (problem_data->hardware_regs_used,\n+  df_byte_lr_expand_bitmap (&problem_data->hardware_regs_used,\n \t\t\t    df->hardware_regs_used);\n-  df_byte_lr_expand_bitmap (problem_data->invalidated_by_call,\n+  df_byte_lr_expand_bitmap (&problem_data->invalidated_by_call,\n \t\t\t    regs_invalidated_by_call_regset);\n \n   EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n@@ -2771,7 +2770,7 @@ df_byte_lr_confluence_0 (basic_block bb)\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   bitmap op1 = &df_byte_lr_get_bb_info (bb->index)->out;\n   if (bb != EXIT_BLOCK_PTR)\n-    bitmap_copy (op1, problem_data->hardware_regs_used);\n+    bitmap_copy (op1, &problem_data->hardware_regs_used);\n }\n \n \n@@ -2789,11 +2788,11 @@ df_byte_lr_confluence_n (edge e)\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n   if (e->flags & EDGE_EH)\n-    bitmap_ior_and_compl_into (op1, op2, problem_data->invalidated_by_call);\n+    bitmap_ior_and_compl_into (op1, op2, &problem_data->invalidated_by_call);\n   else\n     bitmap_ior_into (op1, op2);\n \n-  bitmap_ior_into (op1, problem_data->hardware_regs_used);\n+  bitmap_ior_into (op1, &problem_data->hardware_regs_used);\n }\n \n \n@@ -3808,9 +3807,11 @@ df_note_compute (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n-  bitmap live = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bitmap do_not_gen = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bitmap artificial_uses = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head live, do_not_gen, artificial_uses;\n+\n+  bitmap_initialize (&live, &df_bitmap_obstack);\n+  bitmap_initialize (&do_not_gen, &df_bitmap_obstack);\n+  bitmap_initialize (&artificial_uses, &df_bitmap_obstack);\n \n #ifdef REG_DEAD_DEBUGGING\n   if (dump_file)\n@@ -3819,12 +3820,12 @@ df_note_compute (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n   {\n-    df_note_bb_compute (bb_index, live, do_not_gen, artificial_uses);\n+    df_note_bb_compute (bb_index, &live, &do_not_gen, &artificial_uses);\n   }\n \n-  BITMAP_FREE (live);\n-  BITMAP_FREE (do_not_gen);\n-  BITMAP_FREE (artificial_uses);\n+  bitmap_clear (&live);\n+  bitmap_clear (&do_not_gen);\n+  bitmap_clear (&artificial_uses);\n }\n \n \n@@ -4191,7 +4192,7 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n \n /* Scratch var used by transfer functions.  This is used to do md analysis\n    only for live registers.  */\n-static bitmap df_md_scratch;\n+static bitmap_head df_md_scratch;\n \n /* Set basic block info.  */\n \n@@ -4236,7 +4237,7 @@ df_md_alloc (bitmap all_blocks)\n                                            sizeof (struct df_md_bb_info), 50);\n \n   df_grow_bb_info (df_md);\n-  df_md_scratch = BITMAP_ALLOC (NULL);\n+  bitmap_initialize (&df_md_scratch, &bitmap_default_obstack);\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -4320,7 +4321,7 @@ df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n                                     int top_flag)\n {\n   df_ref def;\n-  bitmap_clear (seen_in_insn);\n+  bitmap_clear (&seen_in_insn);\n \n   while ((def = *def_rec++) != NULL)\n     {\n@@ -4329,7 +4330,7 @@ df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n \t    || (dregno >= FIRST_PSEUDO_REGISTER))\n \t  && top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n \t{\n-          if (!bitmap_bit_p (seen_in_insn, dregno))\n+          if (!bitmap_bit_p (&seen_in_insn, dregno))\n \t    {\n \t      if (DF_REF_FLAGS (def)\n \t          & (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))\n@@ -4341,7 +4342,7 @@ df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n \t        {\n \t\t  /* When we find a clobber and a regular def,\n \t\t     make sure the regular def wins.  */\n-\t          bitmap_set_bit (seen_in_insn, dregno);\n+\t          bitmap_set_bit (&seen_in_insn, dregno);\n \t          bitmap_set_bit (&bb_info->kill, dregno);\n \t          bitmap_clear_bit (&bb_info->gen, dregno);\n \t        }\n@@ -4391,14 +4392,14 @@ df_md_local_compute (bitmap all_blocks)\n   basic_block bb;\n   bitmap *frontiers;\n \n-  seen_in_insn = BITMAP_ALLOC (NULL);\n+  bitmap_initialize (&seen_in_insn, &bitmap_default_obstack);\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi1)\n     {\n       df_md_bb_local_compute (bb_index);\n     }\n \n-  BITMAP_FREE (seen_in_insn);\n+  bitmap_clear (&seen_in_insn);\n \n   frontiers = XNEWVEC (bitmap, last_basic_block);\n   FOR_ALL_BB (bb)\n@@ -4455,13 +4456,13 @@ df_md_transfer_function (int bb_index)\n   /* We need to use a scratch set here so that the value returned from this\n      function invocation properly reflects whether the sets changed in a\n      significant way; i.e. not just because the live set was anded in.  */\n-  bitmap_and (df_md_scratch, gen, df_get_live_out (bb));\n+  bitmap_and (&df_md_scratch, gen, df_get_live_out (bb));\n \n   /* Multiple definitions of a register are not relevant if it is not\n      live.  Thus we trim the result to the places where it is live.  */\n   bitmap_and_into (in, df_get_live_in (bb));\n \n-  return bitmap_ior_and_compl (out, df_md_scratch, in, kill);\n+  return bitmap_ior_and_compl (out, &df_md_scratch, in, kill);\n }\n \n /* Initialize the solution bit vectors for problem.  */\n@@ -4524,7 +4525,7 @@ df_md_free (void)\n \t}\n     }\n \n-  BITMAP_FREE (df_md_scratch);\n+  bitmap_clear (&df_md_scratch);\n   free_alloc_pool (df_md->block_pool);\n \n   df_md->block_info_size = 0;"}, {"sha": "687a3633d6870498e52bb4c8abee02630fe8d424", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c72d561883d0d8828962d84ee64739d8abce84c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c72d561883d0d8828962d84ee64739d8abce84c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5c72d561883d0d8828962d84ee64739d8abce84c", "patch": "@@ -356,15 +356,15 @@ static bool in_fre = false;\n    expressions.  */\n typedef struct bitmap_set\n {\n-  bitmap expressions;\n-  bitmap values;\n+  bitmap_head expressions;\n+  bitmap_head values;\n } *bitmap_set_t;\n \n #define FOR_EACH_EXPR_ID_IN_SET(set, id, bi)\t\t\\\n-  EXECUTE_IF_SET_IN_BITMAP((set)->expressions, 0, (id), (bi))\n+  EXECUTE_IF_SET_IN_BITMAP(&(set)->expressions, 0, (id), (bi))\n \n #define FOR_EACH_VALUE_ID_IN_SET(set, id, bi)\t\t\\\n-  EXECUTE_IF_SET_IN_BITMAP((set)->values, 0, (id), (bi))\n+  EXECUTE_IF_SET_IN_BITMAP(&(set)->values, 0, (id), (bi))\n \n /* Mapping from value id to expressions with that value_id.  */\n DEF_VEC_P (bitmap_set_t);\n@@ -615,8 +615,8 @@ static bitmap_set_t\n bitmap_set_new (void)\n {\n   bitmap_set_t ret = (bitmap_set_t) pool_alloc (bitmap_set_pool);\n-  ret->expressions = BITMAP_ALLOC (&grand_bitmap_obstack);\n-  ret->values = BITMAP_ALLOC (&grand_bitmap_obstack);\n+  bitmap_initialize (&ret->expressions, &grand_bitmap_obstack);\n+  bitmap_initialize (&ret->values, &grand_bitmap_obstack);\n   return ret;\n }\n \n@@ -657,8 +657,8 @@ bitmap_remove_from_set (bitmap_set_t set, pre_expr expr)\n   unsigned int val  = get_expr_value_id (expr);\n   if (!value_id_constant_p (val))\n     {\n-      bitmap_clear_bit (set->values, val);\n-      bitmap_clear_bit (set->expressions, get_expression_id (expr));\n+      bitmap_clear_bit (&set->values, val);\n+      bitmap_clear_bit (&set->expressions, get_expression_id (expr));\n     }\n }\n \n@@ -670,8 +670,8 @@ bitmap_insert_into_set_1 (bitmap_set_t set, pre_expr expr,\n     {\n       /* We specifically expect this and only this function to be able to\n \t insert constants into a set.  */\n-      bitmap_set_bit (set->values, val);\n-      bitmap_set_bit (set->expressions, get_or_alloc_expression_id (expr));\n+      bitmap_set_bit (&set->values, val);\n+      bitmap_set_bit (&set->expressions, get_or_alloc_expression_id (expr));\n     }\n }\n \n@@ -688,17 +688,17 @@ bitmap_insert_into_set (bitmap_set_t set, pre_expr expr)\n static void\n bitmap_set_copy (bitmap_set_t dest, bitmap_set_t orig)\n {\n-  bitmap_copy (dest->expressions, orig->expressions);\n-  bitmap_copy (dest->values, orig->values);\n+  bitmap_copy (&dest->expressions, &orig->expressions);\n+  bitmap_copy (&dest->values, &orig->values);\n }\n \n \n /* Free memory used up by SET.  */\n static void\n bitmap_set_free (bitmap_set_t set)\n {\n-  BITMAP_FREE (set->expressions);\n-  BITMAP_FREE (set->values);\n+  bitmap_clear (&set->expressions);\n+  bitmap_clear (&set->values);\n }\n \n \n@@ -712,7 +712,7 @@ sorted_array_from_bitmap_set (bitmap_set_t set)\n   VEC(pre_expr, heap) *result;\n \n   /* Pre-allocate roughly enough space for the array.  */\n-  result = VEC_alloc (pre_expr, heap, bitmap_count_bits (set->values));\n+  result = VEC_alloc (pre_expr, heap, bitmap_count_bits (&set->values));\n \n   FOR_EACH_VALUE_ID_IN_SET (set, i, bi)\n     {\n@@ -729,7 +729,7 @@ sorted_array_from_bitmap_set (bitmap_set_t set)\n       bitmap_set_t exprset = VEC_index (bitmap_set_t, value_expressions, i);\n       FOR_EACH_EXPR_ID_IN_SET (exprset, j, bj)\n \t{\n-\t  if (bitmap_bit_p (set->expressions, j))\n+\t  if (bitmap_bit_p (&set->expressions, j))\n \t    VEC_safe_push (pre_expr, heap, result, expression_for_id (j));\n         }\n     }\n@@ -747,18 +747,19 @@ bitmap_set_and (bitmap_set_t dest, bitmap_set_t orig)\n \n   if (dest != orig)\n     {\n-      bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n+      bitmap_head temp;\n+      bitmap_initialize (&temp, &grand_bitmap_obstack);\n \n-      bitmap_and_into (dest->values, orig->values);\n-      bitmap_copy (temp, dest->expressions);\n-      EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n+      bitmap_and_into (&dest->values, &orig->values);\n+      bitmap_copy (&temp, &dest->expressions);\n+      EXECUTE_IF_SET_IN_BITMAP (&temp, 0, i, bi)\n \t{\n \t  pre_expr expr = expression_for_id (i);\n \t  unsigned int value_id = get_expr_value_id (expr);\n-\t  if (!bitmap_bit_p (dest->values, value_id))\n-\t    bitmap_clear_bit (dest->expressions, i);\n+\t  if (!bitmap_bit_p (&dest->values, value_id))\n+\t    bitmap_clear_bit (&dest->expressions, i);\n \t}\n-      BITMAP_FREE (temp);\n+      bitmap_clear (&temp);\n     }\n }\n \n@@ -771,14 +772,14 @@ bitmap_set_subtract (bitmap_set_t dest, bitmap_set_t orig)\n   bitmap_iterator bi;\n   unsigned int i;\n \n-  bitmap_and_compl (result->expressions, dest->expressions,\n-\t\t    orig->expressions);\n+  bitmap_and_compl (&result->expressions, &dest->expressions,\n+\t\t    &orig->expressions);\n \n   FOR_EACH_EXPR_ID_IN_SET (result, i, bi)\n     {\n       pre_expr expr = expression_for_id (i);\n       unsigned int value_id = get_expr_value_id (expr);\n-      bitmap_set_bit (result->values, value_id);\n+      bitmap_set_bit (&result->values, value_id);\n     }\n \n   return result;\n@@ -791,16 +792,18 @@ bitmap_set_subtract_values (bitmap_set_t a, bitmap_set_t b)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n-  bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n+  bitmap_head temp;\n \n-  bitmap_copy (temp, a->expressions);\n-  EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n+  bitmap_initialize (&temp, &grand_bitmap_obstack);\n+\n+  bitmap_copy (&temp, &a->expressions);\n+  EXECUTE_IF_SET_IN_BITMAP (&temp, 0, i, bi)\n     {\n       pre_expr expr = expression_for_id (i);\n       if (bitmap_set_contains_value (b, get_expr_value_id (expr)))\n \tbitmap_remove_from_set (a, expr);\n     }\n-  BITMAP_FREE (temp);\n+  bitmap_clear (&temp);\n }\n \n \n@@ -812,16 +815,16 @@ bitmap_set_contains_value (bitmap_set_t set, unsigned int value_id)\n   if (value_id_constant_p (value_id))\n     return true;\n \n-  if (!set || bitmap_empty_p (set->expressions))\n+  if (!set || bitmap_empty_p (&set->expressions))\n     return false;\n \n-  return bitmap_bit_p (set->values, value_id);\n+  return bitmap_bit_p (&set->values, value_id);\n }\n \n static inline bool\n bitmap_set_contains_expr (bitmap_set_t set, const pre_expr expr)\n {\n-  return bitmap_bit_p (set->expressions, get_expression_id (expr));\n+  return bitmap_bit_p (&set->expressions, get_expression_id (expr));\n }\n \n /* Replace an instance of value LOOKFOR with expression EXPR in SET.  */\n@@ -852,10 +855,10 @@ bitmap_set_replace_value (bitmap_set_t set, unsigned int lookfor,\n   exprset = VEC_index (bitmap_set_t, value_expressions, lookfor);\n   FOR_EACH_EXPR_ID_IN_SET (exprset, i, bi)\n     {\n-      if (bitmap_bit_p (set->expressions, i))\n+      if (bitmap_bit_p (&set->expressions, i))\n \t{\n-\t  bitmap_clear_bit (set->expressions, i);\n-\t  bitmap_set_bit (set->expressions, get_expression_id (expr));\n+\t  bitmap_clear_bit (&set->expressions, i);\n+\t  bitmap_set_bit (&set->expressions, get_expression_id (expr));\n \t  return;\n \t}\n     }\n@@ -866,7 +869,7 @@ bitmap_set_replace_value (bitmap_set_t set, unsigned int lookfor,\n static bool\n bitmap_set_equal (bitmap_set_t a, bitmap_set_t b)\n {\n-  return bitmap_equal_p (a->values, b->values);\n+  return bitmap_equal_p (&a->values, &b->values);\n }\n \n /* Replace an instance of EXPR's VALUE with EXPR in SET if it exists,\n@@ -900,8 +903,8 @@ bitmap_value_insert_into_set (bitmap_set_t set, pre_expr expr)\n     return;\n \n   /* If the value membership changed, add the expression.  */\n-  if (bitmap_set_bit (set->values, val))\n-    bitmap_set_bit (set->expressions, expr->id);\n+  if (bitmap_set_bit (&set->values, val))\n+    bitmap_set_bit (&set->expressions, expr->id);\n }\n \n /* Print out EXPR to outfile.  */\n@@ -1870,8 +1873,8 @@ bitmap_find_leader (bitmap_set_t set, unsigned int val, gimple stmt)\n       bitmap_iterator bi;\n       bitmap_set_t exprset = VEC_index (bitmap_set_t, value_expressions, val);\n \n-      EXECUTE_IF_AND_IN_BITMAP (exprset->expressions,\n-\t\t\t\tset->expressions, 0, i, bi)\n+      EXECUTE_IF_AND_IN_BITMAP (&exprset->expressions,\n+\t\t\t\t&set->expressions, 0, i, bi)\n \t{\n \t  pre_expr val = expression_for_id (i);\n \t  /* At the point where stmt is not null, there should always\n@@ -2291,8 +2294,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \n   clean (ANTIC_IN (block), block);\n \n-  /* !old->expressions can happen when we deferred a block.  */\n-  if (!old->expressions || !bitmap_set_equal (old, ANTIC_IN (block)))\n+  if (!bitmap_set_equal (old, ANTIC_IN (block)))\n     {\n       changed = true;\n       SET_BIT (changed_blocks, block->index);\n@@ -2367,7 +2369,7 @@ compute_partial_antic_aux (basic_block block,\n      before the translation starts.  */\n   if (max_pa\n       && single_succ_p (block)\n-      && bitmap_count_bits (PA_IN (single_succ (block))->values) > max_pa)\n+      && bitmap_count_bits (&PA_IN (single_succ (block))->values) > max_pa)\n     goto maybe_dump_sets;\n \n   old_PA_IN = PA_IN (block);\n@@ -2437,8 +2439,8 @@ compute_partial_antic_aux (basic_block block,\n \n   /* For partial antic, we want to put back in the phi results, since\n      we will properly avoid making them partially antic over backedges.  */\n-  bitmap_ior_into (PA_IN (block)->values, PHI_GEN (block)->values);\n-  bitmap_ior_into (PA_IN (block)->expressions, PHI_GEN (block)->expressions);\n+  bitmap_ior_into (&PA_IN (block)->values, &PHI_GEN (block)->values);\n+  bitmap_ior_into (&PA_IN (block)->expressions, &PHI_GEN (block)->expressions);\n \n   /* PA_IN[block] = PA_IN[block] - ANTIC_IN[block] */\n   bitmap_set_subtract_values (PA_IN (block), ANTIC_IN (block));"}]}