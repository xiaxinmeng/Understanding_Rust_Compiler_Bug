{"sha": "5d30228e2b9837e66827acfe95c9a74c90c1d42b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQzMDIyOGUyYjk4MzdlNjY4MjdhY2ZlOTVjOWE3NGM5MGMxZDQyYg==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2019-05-07T21:40:46Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2019-05-07T21:40:46Z"}, "message": "re PR middle-end/89765 (Multiple problems with vec-insert implementation on PowerPC)\n\ngcc/ChangeLog:\n\n2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\tPR target/89765\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tIn handling of ALTIVEC_BUILTIN_VEC_INSERT, use modular arithmetic\n\tto compute vector element selector for both constant and variable\n\toperands.\n\ngcc/testsuite/ChangeLog:\n\n2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\tPR target/89765\n\t* gcc.target/powerpc/pr89765-mc.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-10c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-10d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-11c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-11d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-12c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-12d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-13c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-13d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-14c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-14d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-15c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-15d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-16c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-16d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-17c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-17d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-18c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-18d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-19c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-19d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-20c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-20d.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-9c.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-9d.c: New test.\n\nFrom-SVN: r270982", "tree": {"sha": "ec7ecf83d3fff95876808bcfa581e0bf0a84ce72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec7ecf83d3fff95876808bcfa581e0bf0a84ce72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d30228e2b9837e66827acfe95c9a74c90c1d42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d30228e2b9837e66827acfe95c9a74c90c1d42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d30228e2b9837e66827acfe95c9a74c90c1d42b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d30228e2b9837e66827acfe95c9a74c90c1d42b/comments", "author": null, "committer": null, "parents": [{"sha": "e9d2e7b8962fa17582a67dfe408391e61f126446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d2e7b8962fa17582a67dfe408391e61f126446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d2e7b8962fa17582a67dfe408391e61f126446"}], "stats": {"total": 3870, "additions": 3862, "deletions": 8}, "files": [{"sha": "9571c3b62b66b7b67ce5887a360cc6dfcc44a267", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -1,3 +1,11 @@\n+2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\tPR target/89765\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tIn handling of ALTIVEC_BUILTIN_VEC_INSERT, use modular arithmetic\n+\tto compute vector element selector for both constant and variable\n+\toperands.\n+\n 2019-05-07  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (cvt_mnemonic): New mode attribute."}, {"sha": "7c28d4d81768892d8b8a6de2b77372049c30cde3", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -6736,11 +6736,13 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       /* If we can use the VSX xxpermdi instruction, use that for insert.  */\n       mode = TYPE_MODE (arg1_type);\n       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)\n-\t  && TREE_CODE (arg2) == INTEGER_CST\n-\t  && wi::ltu_p (wi::to_wide (arg2), 2))\n+\t  && TREE_CODE (arg2) == INTEGER_CST)\n \t{\n+\t  wide_int selector = wi::to_wide (arg2);\n+\t  selector = wi::umod_trunc (selector, 2);\n \t  tree call = NULL_TREE;\n \n+\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n \t  if (mode == V2DFmode)\n \t    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DF];\n \t  else if (mode == V2DImode)\n@@ -6752,22 +6754,26 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    return build_call_expr (call, 3, arg1, arg0, arg2);\n \t}\n       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n-\t       && TREE_CODE (arg2) == INTEGER_CST\n-\t       && wi::eq_p (wi::to_wide (arg2), 0))\n+\t       && TREE_CODE (arg2) == INTEGER_CST)\n \t{\n \t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];\n+\t  wide_int selector = wi::zero(32);\n \n+\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n \t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n \t     reversed.  */\n \t  return build_call_expr (call, 3, arg1, arg0, arg2);\n \t}\n \n       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */\n       arg1_inner_type = TREE_TYPE (arg1_type);\n-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,\n-\t\t\t      build_int_cst (TREE_TYPE (arg2),\n-\t\t\t\t\t     TYPE_VECTOR_SUBPARTS (arg1_type)\n-\t\t\t\t\t     - 1), 0);\n+      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)\n+\targ2 = build_int_cst (TREE_TYPE (arg2), 0);\n+      else\n+\targ2 = build_binary_op (loc, BIT_AND_EXPR, arg2,\n+\t\t\t\tbuild_int_cst (TREE_TYPE (arg2),\n+\t\t\t\t\t       TYPE_VECTOR_SUBPARTS (arg1_type)\n+\t\t\t\t\t       - 1), 0);\n       decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n       DECL_EXTERNAL (decl) = 0;\n       TREE_PUBLIC (decl) = 0;"}, {"sha": "a7b40dfc64e0516d7efa539aa9a0d4c6ea620ece", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -1,3 +1,32 @@\n+2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\tPR target/89765\n+\t* gcc.target/powerpc/pr89765-mc.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-10c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-10d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-11c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-11d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-12c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-12d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-13c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-13d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-14c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-14d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-15c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-15d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-16c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-16d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-17c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-17d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-18c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-18d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-19c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-19d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-20c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-20d.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-9c.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-9d.c: New test.\n+\n 2019-05-07  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n \n \t* gcc.target/aarch64/sve/sad_1.c: New test for sum of absolute"}, {"sha": "8384536058bd89edeaacb0644e23e1ac3b656a5b", "filename": "gcc/testsuite/gcc.target/powerpc/pr89765-mc.c", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr89765-mc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr89765-mc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr89765-mc.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,400 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <altivec.h>\n+\n+#include <stdio.h>\n+\n+static vector unsigned __int128\n+deoptimize_uint128 (vector unsigned __int128  a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned long long int\n+deoptimize_ulong (vector unsigned long long int a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned int\n+deoptimize_uint (vector unsigned int a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned char\n+deoptimize_uchar (vector unsigned char a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned short\n+deoptimize_ushort (vector unsigned short a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+__attribute ((noinline))\n+vector unsigned __int128\n+set_auto_n_uint128 (vector unsigned __int128 a, int n, unsigned __int128 x)\n+{\n+  return vec_insert (x, a, n);\n+}\n+\n+__attribute ((noinline))\n+vector unsigned long long int\n+set_auto_n_ulong (vector unsigned long long int a, int n,\n+\t\t  unsigned long long int x)\n+{\n+  return vec_insert (x, a, n);\n+}\n+\n+__attribute ((noinline))\n+vector unsigned int\n+set_auto_n_uint (vector unsigned int a, int n, unsigned int x)\n+{\n+  return vec_insert (x, a, n);\n+}\n+\n+__attribute ((noinline))\n+vector unsigned char\n+set_auto_n_uchar (vector unsigned char a, int n, unsigned char x)\n+{\n+  return vec_insert (x, a, n);\n+}\n+\n+__attribute ((noinline))\n+vector unsigned short\n+set_auto_n_ushort (vector unsigned short a, int n, unsigned short x)\n+{\n+  return vec_insert (x, a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned __int128\n+get_auto_n_uint128 (vector unsigned __int128 a, int n)\n+{\n+  return vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned long long int\n+get_auto_n_ulong (vector unsigned long long int a, int n)\n+{\n+  return vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned int\n+get_auto_n_uint (vector unsigned int a, int n)\n+{\n+  return vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned char\n+get_auto_n_uchar (vector unsigned char a, int n)\n+{\n+  return vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned short\n+get_auto_n_ushort (vector unsigned short a, int n)\n+{\n+  return vec_extract (a, n);\n+}\n+\n+int check_uint128_element (int i, unsigned __int128 entry)\n+{\n+  printf (\"checking uint128 entry at index %d\\n\", i);\n+\n+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)\n+\t\t    | 0x0706050403020100ULL));\n+}\n+\n+unsigned __int128 get_uint128_element (int i)\n+{\n+  return ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)\n+\t  | 0x0706050403020100ULL);\n+}\n+\n+int check_ulong_element (int i, unsigned long long int entry)\n+{\n+  printf (\"checking ulong entry 0x%llx at index %d\\n\", entry, i);\n+\n+  switch (i % 2)\n+    {\n+      case 0: return (entry == 0x9999901010ULL);\n+      case 1: return (entry == 0x7777733333ULL);\n+      default:\n+\treturn 0;\n+    }\n+}\n+\n+unsigned long long int get_ulong_element (int i)\n+{\n+  switch (i % 2)\n+    {\n+    case 0: return 0x9999901010ULL;\n+    case 1: return 0x7777733333ULL;\n+    }\n+}\n+\n+int check_uint_element (int i, unsigned int entry)\n+{\n+  printf (\"checking uint entry 0x%x at index %d\\n\", entry, i);\n+\n+  switch (i % 4)\n+    {\n+    case 0: return (entry == 0x99999);\n+    case 1: return (entry == 0x01010);\n+    case 2: return (entry == 0x77777);\n+    case 3: return (entry == 0x33333);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+unsigned int get_uint_element (int i)\n+{\n+  switch (i % 4)\n+    {\n+    case 0: return 0x99999;\n+    case 1: return 0x01010;\n+    case 2: return 0x77777;\n+    case 3: return 0x33333;\n+    }\n+}\n+\n+int check_uchar_element (int i, unsigned char entry)\n+{\n+  printf (\"checking uchar entry 0x%x at index %d\\n\", entry, i);\n+  switch (i % 16)\n+    {\n+    case 0: return (entry == 0x90);\n+    case 1: return (entry == 0x80);\n+    case 2: return (entry == 0x70);\n+    case 3: return (entry == 0x60);\n+    case 4: return (entry == 0x50);\n+    case 5: return (entry == 0x40);\n+    case 6: return (entry == 0x30);\n+    case 7: return (entry == 0x20);\n+    case 8: return (entry == 0x10);\n+    case 9: return (entry == 0xf0);\n+    case 10: return (entry == 0xe0);\n+    case 11: return (entry == 0xd0);\n+    case 12: return (entry == 0xc0);\n+    case 13: return (entry == 0xb0);\n+    case 14: return (entry == 0xa0);\n+    case 15: return (entry == 0xff);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+unsigned char get_uchar_element (int i)\n+{\n+  switch (i % 16)\n+    {\n+    case 0: return 0x90;\n+    case 1: return 0x80;\n+    case 2: return 0x70;\n+    case 3: return 0x60;\n+    case 4: return 0x50;\n+    case 5: return 0x40;\n+    case 6: return 0x30;\n+    case 7: return 0x20;\n+    case 8: return 0x10;\n+    case 9: return 0xf0;\n+    case 10: return 0xe0;\n+    case 11: return 0xd0;\n+    case 12: return 0xc0;\n+    case 13: return 0xb0;\n+    case 14: return 0xa0;\n+    case 15: return 0xff;\n+    }\n+}\n+\n+int check_ushort_element (int i, unsigned short entry)\n+{\n+  printf (\"checking ushort entry 0x%x at index %d\\n\", entry, i);\n+  switch (i % 8)\n+    {\n+    case 0: return (entry == 0x9988);\n+    case 1: return (entry == 0x8877);\n+    case 2: return (entry == 0x7766);\n+    case 3: return (entry == 0x6655);\n+    case 4: return (entry == 0x5544);\n+    case 5: return (entry == 0x4433);\n+    case 6: return (entry == 0x3322);\n+    case 7: return (entry == 0x2211);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+unsigned short get_ushort_element (int i)\n+{\n+  switch (i % 8)\n+    {\n+    case 0: return 0x9988;\n+    case 1: return 0x8877;\n+    case 2: return 0x7766;\n+    case 3: return 0x6655;\n+    case 4: return 0x5544;\n+    case 5: return 0x4433;\n+    case 6: return 0x3322;\n+    case 7: return 0x2211;\n+    }\n+}\n+\n+vector unsigned __int128\n+init_auto_uint128 (vector unsigned __int128 a)\n+{\n+  int i;\n+  for (i = 0; i < 32; i += 3)\n+    a = set_auto_n_uint128 (a, i, get_uint128_element (i));\n+  return a;\n+}\n+\n+void do_auto_uint128 (vector unsigned __int128 a)\n+{\n+  int i;\n+  unsigned __int128 c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_uint128 (a, i);\n+      if (!check_uint128_element (i, c)) abort ();\n+    }\n+}\n+\n+vector unsigned long long int\n+init_auto_ulong (vector unsigned long long int a)\n+{\n+  int i;\n+  for (i = 0; i < 32; i += 3)\n+    a = set_auto_n_ulong (a, i, get_ulong_element (i));\n+  return a;\n+}\n+\n+void do_auto_ulong (vector unsigned long long int a)\n+{\n+  int i;\n+  unsigned long long int c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_ulong (a, i);\n+      if (!check_ulong_element (i, c)) abort ();\n+    }\n+ }\n+\n+vector unsigned int init_auto_uint (vector unsigned int a)\n+{\n+  int i;\n+  for (i = 0; i < 32; i += 3)\n+    a = set_auto_n_uint (a, i, get_uint_element (i));\n+  return a;\n+}\n+\n+void do_auto_uint (vector unsigned int a)\n+{\n+  int i;\n+  unsigned int c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_uint (a, i);\n+      if (!check_uint_element (i, c)) abort ();\n+    }\n+ }\n+\n+vector unsigned short init_auto_ushort ( vector unsigned short a )\n+{\n+  int i;\n+  for (i = 0; i < 32; i += 3)\n+    a = set_auto_n_ushort (a, i, get_ushort_element (i));\n+  return a;\n+}\n+\n+void do_auto_ushort (vector unsigned short a)\n+{\n+  int i;\n+  unsigned short c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_ushort (a, i);\n+      if (!check_ushort_element (i, c)) abort ();\n+    }\n+}\n+\n+vector unsigned char init_auto_uchar (vector unsigned char a)\n+{\n+  int i;\n+  for (i = 0; i < 32; i += 3)\n+    a = set_auto_n_uchar (a, i, get_uchar_element (i));\n+  return a;\n+}\n+\n+void do_auto_uchar (vector unsigned char a)\n+{\n+  int i;\n+  unsigned char c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_uchar (a, i);\n+      if (!check_uchar_element (i, c)) abort ();\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  size_t i;\n+\n+  vector unsigned __int128 u = { 0 };\n+  vector unsigned __int128 du;\n+\n+  vector unsigned long long int v = { 0, 0 };\n+  vector unsigned long long int dv;\n+\n+  vector unsigned int x = { 0, 0, 0, 0 };\n+  vector unsigned int dx;\n+\n+  vector unsigned char y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+  vector unsigned char dy;\n+\n+  vector unsigned short z = { 0, 0, 0, 0, 0, 0, 0, 0 };\n+  vector unsigned short dz;\n+\n+  du = init_auto_uint128 (u);\n+  dv = init_auto_ulong (v);\n+  dx = init_auto_uint (x);\n+  dy = init_auto_uchar (y);\n+  dz = init_auto_ushort (z);\n+\n+  du = deoptimize_uint128 (du);\n+  dv = deoptimize_ulong (dv);\n+  dx = deoptimize_uint (dx);\n+  dy = deoptimize_uchar (dy);\n+  dz = deoptimize_ushort (dz);\n+\n+  do_auto_uint128 (du);\n+  do_auto_ulong (dv);\n+  do_auto_uint (dx);\n+  do_auto_uchar (dy);\n+  do_auto_ushort (dz);\n+  return 0;\n+}"}, {"sha": "5ed6424d64f3a0ef722a2d13d759bc8698688a68", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector short s3 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector short s7 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 7);\n+}\n+\n+vector short s21 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector short s30 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector short ms3 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector short ms7 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 7);\n+}\n+\n+vector short ms21 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector short ms30 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector short ci (vector short v, int i, short x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector short mci (vector short *vp, int i, short x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, short *argv[]) {\n+  vector short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+  short s;\n+\n+  sv = s3 (sv, CONST6);\n+  if (sv [3] != CONST6)\n+    abort ();\n+\n+  sv = s7 (sv, CONST4);\n+  if (sv [7] != CONST4)\n+    abort ();\n+\n+  sv = s21 (sv, CONST3);\n+  if (sv [5] != CONST3)\n+    abort ();\n+\n+  sv = s30 (sv, CONST2);\n+  if (sv [6] != CONST2)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST5);\n+  if (sv [3] != CONST5)\n+    abort ();\n+\n+  sv = ms7 (&sv, CONST1);\n+  if (sv [7] != CONST1)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST2);\n+  if (sv [5] != CONST2)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [6] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST6);\n+  if (sv [5] != CONST6)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST4);\n+  if (sv [2] != CONST4)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST3);\n+  if (sv [7] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST3);\n+  if (sv [4] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST3);\n+  if (sv [5] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST7);\n+  if (sv [4] != CONST7)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST6);\n+  if (sv [1] != CONST6)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST5);\n+  if (sv [0] != CONST5)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c9aaecad9204080c262421a417a0e90cee2c0351", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector short s3 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector short s7 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 7);\n+}\n+\n+vector short s21 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector short s30 (vector short v, short x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector short ms3 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector short ms7 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 7);\n+}\n+\n+vector short ms21 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector short ms30 (vector short *vp, short x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector short ci (vector short v, int i, short x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector short mci (vector short *vp, int i, short x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, short *argv[]) {\n+  vector short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+  short s;\n+\n+  sv = s3 (sv, CONST6);\n+  if (sv [3] != CONST6)\n+    abort ();\n+\n+  sv = s7 (sv, CONST4);\n+  if (sv [7] != CONST4)\n+    abort ();\n+\n+  sv = s21 (sv, CONST3);\n+  if (sv [5] != CONST3)\n+    abort ();\n+\n+  sv = s30 (sv, CONST2);\n+  if (sv [6] != CONST2)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST5);\n+  if (sv [3] != CONST5)\n+    abort ();\n+\n+  sv = ms7 (&sv, CONST1);\n+  if (sv [7] != CONST1)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST2);\n+  if (sv [5] != CONST2)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [6] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST6);\n+  if (sv [5] != CONST6)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST4);\n+  if (sv [2] != CONST4)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST3);\n+  if (sv [7] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST3);\n+  if (sv [4] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST3);\n+  if (sv [5] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST7);\n+  if (sv [4] != CONST7)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST6);\n+  if (sv [1] != CONST6)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST5);\n+  if (sv [0] != CONST5)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "8e514aa2b1fccd8b8d13d03c1c8c6c772d0f338e", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector int s3 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector int s1 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector int s21 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector int s30 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector int ms3  (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector int ms1 (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector int ms21 (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector int ms30 (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector int ci (vector int v, int i, int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector int mci(vector int *vp, int i, int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, int *argv[]) {\n+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };\n+  int s;\n+\n+  sv = s3 (sv, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = s1 (sv, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = s21 (sv, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = s30 (sv, CONST1);\n+  if (sv [2] != CONST1)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST2);\n+  if (sv [3] != CONST2)\n+    abort ();\n+\n+  sv = ms1 (&sv, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [2] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST3);\n+  if (sv [2] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST3);\n+  if (sv [0] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST2);\n+  if (sv [1] != CONST2)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST1);\n+  if (sv [0] != CONST1)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST2);\n+  if (sv [1] != CONST2)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST3);\n+  if (sv [0] != CONST3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "116802aeecec0b838d0f1716791e580966276a52", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector int s3 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector int s1 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector int s21 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector int s30 (vector int v, int x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector int ms3  (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector int ms1 (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector int ms21 (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector int ms30 (vector int *vp, int x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector int ci (vector int v, int i, int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector int mci(vector int *vp, int i, int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, int *argv[]) {\n+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };\n+  int s;\n+\n+  sv = s3 (sv, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = s1 (sv, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = s21 (sv, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = s30 (sv, CONST1);\n+  if (sv [2] != CONST1)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST2);\n+  if (sv [3] != CONST2)\n+    abort ();\n+\n+  sv = ms1 (&sv, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [2] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST3);\n+  if (sv [2] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST3);\n+  if (sv [0] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST2);\n+  if (sv [1] != CONST2)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST1);\n+  if (sv [0] != CONST1)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST2);\n+  if (sv [1] != CONST2)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST3);\n+  if (sv [0] != CONST3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1e57bc46cdd6d2b31c12ef2bcacfd7176c2eefb9", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,112 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+#define CONST2\t\t(3 * 31415926539LL)\n+#define CONST3\t\t(4 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector long long int e0 (vector long long int v, long long int x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector long long int e3 (vector long long int v, long long int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector long long int me0 (vector long long int *vp, long long int x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector long long int me3 (vector long long int *vp, long long int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector long long int ei (vector long long int v, int i, long long int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector long long int mei (vector long long int *vp, int i, long long int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector long long int dv = { CONST0, CONST1 };\n+  long long int d;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e3 (dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "3bf06085fb5a390cb1110dd5573c619da2f3618b", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,112 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+#define CONST2\t\t(3 * 31415926539LL)\n+#define CONST3\t\t(4 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector long long int e0 (vector long long int v, long long int x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector long long int e3 (vector long long int v, long long int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector long long int me0 (vector long long int *vp, long long int x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector long long int me3 (vector long long int *vp, long long int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector long long int ei (vector long long int v, int i, long long int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector long long int mei (vector long long int *vp, int i, long long int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector long long int dv = { CONST0, CONST1 };\n+  long long int d;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e3 (dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "43c6bed769549df26729bb0dab0314dfe53bacb3", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+#define SIGNED signed\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((SIGNED __int128) 31415926539) << 60)\n+#define CONST1\t\t(((SIGNED __int128) 31415926539) << 55)\n+#define CONST2\t\t(((SIGNED __int128) 31415926539) << 50)\n+#define CONST3\t\t(((SIGNED __int128) 31415926539) << 45)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector SIGNED __int128\n+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector SIGNED __int128\n+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector SIGNED __int128 dv = { CONST0 };\n+  SIGNED __int128 d;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e3 (dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "257de552e64d12340b0ad4b887e00703dc60d64a", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+#define SIGNED signed\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((SIGNED __int128) 31415926539) << 60)\n+#define CONST1\t\t(((SIGNED __int128) 31415926539) << 55)\n+#define CONST2\t\t(((SIGNED __int128) 31415926539) << 50)\n+#define CONST3\t\t(((SIGNED __int128) 31415926539) << 45)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector SIGNED __int128\n+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector SIGNED __int128\n+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector SIGNED __int128 dv = { CONST0 };\n+  SIGNED __int128 d;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e3 (dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5ba4bd59eb3239831b01518a028ab194951339e9", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t((float) (3.1415926539))\n+#define CONST1\t\t((float) (3.1415926539 * 2))\n+#define CONST2\t\t((float) (3.1415926539 * 3))\n+#define CONST3\t\t((float) (3.1415926539 * 4))\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector float e0(vector float v, float x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector float e1(vector float v, float x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector float e7(vector float v, float x)\n+{\n+  return vec_insert (x, v, 7);\n+}\n+\n+vector float e8(vector float v, float x)\n+{\n+  return vec_insert (x, v, 8);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector float me0(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector float me1(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector float me13(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 13);\n+}\n+\n+vector float me15(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 15);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector float ei(vector float v, int i, float x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector float mei(vector float *vp, int i, float x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };\n+  float d;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e1 (dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = e7 (dv, CONST2);\n+  if (dv [3] != CONST2)\n+    abort ();\n+\n+  dv = e8 (dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me1 (&dv, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = me13 (&dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = me15 (&dv, CONST1);\n+  if (dv [3] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST1);\n+  if (dv [2] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 11, CONST0);\n+  if (dv [3] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 17, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 15, CONST1);\n+  if (dv [3] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 6, CONST0);\n+  if (dv [2] != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "63784a2e220b3d5592e3e8b99bcc52241902849a", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t((float) (3.1415926539))\n+#define CONST1\t\t((float) (3.1415926539 * 2))\n+#define CONST2\t\t((float) (3.1415926539 * 3))\n+#define CONST3\t\t((float) (3.1415926539 * 4))\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector float e0(vector float v, float x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector float e1(vector float v, float x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector float e7(vector float v, float x)\n+{\n+  return vec_insert (x, v, 7);\n+}\n+\n+vector float e8(vector float v, float x)\n+{\n+  return vec_insert (x, v, 8);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector float me0(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector float me1(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector float me13(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 13);\n+}\n+\n+vector float me15(vector float *vp, float x)\n+{\n+  return vec_insert (x, *vp, 15);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector float ei(vector float v, int i, float x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector float mei(vector float *vp, int i, float x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };\n+  float d;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e1 (dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = e7 (dv, CONST2);\n+  if (dv [3] != CONST2)\n+    abort ();\n+\n+  dv = e8 (dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me1 (&dv, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = me13 (&dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = me15 (&dv, CONST1);\n+  if (dv [3] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST1);\n+  if (dv [2] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 11, CONST0);\n+  if (dv [3] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 17, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 15, CONST1);\n+  if (dv [3] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 6, CONST0);\n+  if (dv [2] != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1a23191e2533f9568f0193aff5122410ceb45665", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,151 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(3.1415926539)\n+#define CONST1\t\t(3.1415926539 * 2)\n+#define CONST2\t\t(3.1415926539 * 3)\n+#define CONST3\t\t(3.1415926539 * 4)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector double e0(vector double v, double x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector double e1(vector double v, double x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector double e2(vector double v, double x)\n+{\n+  return vec_insert (x, v, 2);\n+}\n+\n+vector double e3(vector double v, double x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector double me0(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector double me1(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector double me2(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 2);\n+}\n+\n+vector double me3(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector double ei(vector double v, int i, double x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector double mei(vector double *vp, int i, double x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector double dv;\n+  double d;\n+  dv[0] = CONST0;\n+  dv[1] = CONST1;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e1 (dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = e2 (dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = e3 (dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me1 (&dv, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = me2 (&dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "71f200d831b06fe763b44703333d87036e15c861", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,151 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(3.1415926539)\n+#define CONST1\t\t(3.1415926539 * 2)\n+#define CONST2\t\t(3.1415926539 * 3)\n+#define CONST3\t\t(3.1415926539 * 4)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector double e0(vector double v, double x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector double e1(vector double v, double x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector double e2(vector double v, double x)\n+{\n+  return vec_insert (x, v, 2);\n+}\n+\n+vector double e3(vector double v, double x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector double me0(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector double me1(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector double me2(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 2);\n+}\n+\n+vector double me3(vector double *vp, double x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector double ei(vector double v, int i, double x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector double mei(vector double *vp, int i, double x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector double dv;\n+  double d;\n+  dv[0] = CONST0;\n+  dv[1] = CONST1;\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e1 (dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = e2 (dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = e3 (dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me1 (&dv, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = me2 (&dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST0);\n+  if (dv [1] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "eea4d4062301411473ba256db3bed4d735419f31", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,180 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <stdio.h>\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned char c0 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector unsigned char c9 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 9);\n+}\n+\n+vector unsigned char c21 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector unsigned char c30 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 9);\n+}\n+\n+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t      CONST4, CONST5, CONST6, CONST7,\n+\t\t\t      CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t      CONSTC, CONSTD, CONSTE, CONSTF };\n+  printf (\"A\\n\");\n+  cv = c0 (cv, CONST3);\n+  if (cv [0] != CONST3)\n+    abort ();\n+\n+  printf (\"B\\n\");\n+  cv = c9 (cv, CONST2);\n+  if (cv [9] != CONST2)\n+    abort ();\n+\n+  printf (\"C\\n\");\n+  cv = c21 (cv, CONSTF);\n+  if (cv [5] != CONSTF)\n+    abort ();\n+\n+  printf (\"D\\n\");\n+  cv = c30 (cv, CONST3);\n+  if (cv [14] != CONST3)\n+    abort ();\n+\n+  printf (\"E\\n\");\n+  cv = mc0 (&cv, CONST4);\n+  if (cv [0] != CONST4)\n+    abort ();\n+\n+  printf (\"F\\n\");\n+  cv = mc9 (&cv, CONST3);\n+  if (cv [9] != CONST3)\n+    abort ();\n+\n+  printf (\"G\\n\");\n+  cv = mc21 (&cv, CONST1);\n+  if (cv [5] != CONST1)\n+    abort ();\n+\n+  printf (\"H\\n\");\n+  cv = mc30 (&cv, CONSTC);\n+  if (cv [14] != CONSTC)\n+    abort ();\n+\n+  printf (\"I\\n\");\n+  cv = ci (cv, 8, CONSTD);\n+  if (cv [8] != CONSTD)\n+    abort ();\n+\n+  printf (\"J\\n\");\n+  cv = ci (cv, 13, CONST5);\n+  if (cv [13] != CONST5)\n+    abort ();\n+\n+  printf (\"K\\n\");\n+  cv = ci (cv, 23, CONST6);\n+  if (cv [7] != CONST6)\n+    abort ();\n+\n+  printf (\"L\\n\");\n+  cv = ci (cv, 31, CONST7);\n+  if (cv [15] != CONST7)\n+    abort ();\n+\n+  printf (\"M\\n\");\n+  cv = mci (&cv, 5, CONST8);\n+  if (cv [5] != CONST8)\n+    abort ();\n+\n+  printf (\"N\\n\");\n+  cv = mci (&cv, 12, CONST9);\n+  if (cv [12] != CONST9)\n+    abort ();\n+\n+  printf (\"O\\n\");\n+  cv = mci (&cv, 25, CONSTA);\n+  if (cv [9] != CONSTA)\n+    abort ();\n+\n+  printf (\"P\\n\");\n+  cv = mci (&cv, 16, CONSTB);\n+  if (cv [0] != CONSTB)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "f899e57f2d4ac0298899c6bff84b5e832bc7f27f", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,163 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned char c0 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector unsigned char c9 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 9);\n+}\n+\n+vector unsigned char c21 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector unsigned char c30 (vector unsigned char v, unsigned char x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 9);\n+}\n+\n+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t      CONST4, CONST5, CONST6, CONST7,\n+\t\t\t      CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t      CONSTC, CONSTD, CONSTE, CONSTF };\n+  cv = c0 (cv, CONST3);\n+  if (cv [0] != CONST3)\n+    abort ();\n+\n+  cv = c9 (cv, CONST2);\n+  if (cv [9] != CONST2)\n+    abort ();\n+\n+  cv = c21 (cv, CONSTF);\n+  if (cv [5] != CONSTF)\n+    abort ();\n+\n+  cv = c30 (cv, CONST3);\n+  if (cv [14] != CONST3)\n+    abort ();\n+\n+  cv = mc0 (&cv, CONST4);\n+  if (cv [0] != CONST4)\n+    abort ();\n+\n+  cv = mc9 (&cv, CONST3);\n+  if (cv [9] != CONST3)\n+    abort ();\n+\n+  cv = mc21 (&cv, CONST1);\n+  if (cv [5] != CONST1)\n+    abort ();\n+\n+  cv = mc30 (&cv, CONSTC);\n+  if (cv [14] != CONSTC)\n+    abort ();\n+\n+  cv = ci (cv, 8, CONSTD);\n+  if (cv [8] != CONSTD)\n+    abort ();\n+\n+  cv = ci (cv, 13, CONST5);\n+  if (cv [13] != CONST5)\n+    abort ();\n+\n+  cv = ci (cv, 23, CONST6);\n+  if (cv [7] != CONST6)\n+    abort ();\n+\n+  cv = ci (cv, 31, CONST7);\n+  if (cv [15] != CONST7)\n+    abort ();\n+\n+  cv = mci (&cv, 5, CONST8);\n+  if (cv [5] != CONST8)\n+    abort ();\n+\n+  cv = mci (&cv, 12, CONST9);\n+  if (cv [12] != CONST9)\n+    abort ();\n+\n+  cv = mci (&cv, 25, CONSTA);\n+  if (cv [9] != CONSTA)\n+    abort ();\n+\n+  cv = mci (&cv, 16, CONSTB);\n+  if (cv [0] != CONSTB)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b95dbcdde1572160d5567461391a6f7b07259394", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,154 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned short s3 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector unsigned short s7 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 7);\n+}\n+\n+vector unsigned short s21 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector unsigned short s30 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 7);\n+}\n+\n+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, unsigned short *argv[]) {\n+  vector unsigned short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+\n+  sv = s3 (sv, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = s7 (sv, CONST2);\n+  if (sv [7] != CONST2)\n+    abort ();\n+\n+  sv = s21 (sv, CONST3);\n+  if (sv [5] != CONST3)\n+    abort ();\n+\n+  sv = s30 (sv, CONST4);\n+  if (sv [6] != CONST4)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST5);\n+  if (sv [3] != CONST5)\n+    abort ();\n+\n+  sv = ms7 (&sv, CONST6);\n+  if (sv [7] != CONST6)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST7);\n+  if (sv [5] != CONST7)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [6] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST1);\n+  if (sv [5] != CONST1)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST3);\n+  if (sv [2] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST2);\n+  if (sv [7] != CONST2)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST5);\n+  if (sv [4] != CONST5)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST4);\n+  if (sv [5] != CONST4)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST6);\n+  if (sv [4] != CONST6)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST7);\n+  if (sv [1] != CONST7)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST4);\n+  if (sv [0] != CONST4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b95dbcdde1572160d5567461391a6f7b07259394", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,154 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned short s3 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector unsigned short s7 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 7);\n+}\n+\n+vector unsigned short s21 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector unsigned short s30 (vector unsigned short v, unsigned short x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 7);\n+}\n+\n+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, unsigned short *argv[]) {\n+  vector unsigned short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+\n+  sv = s3 (sv, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = s7 (sv, CONST2);\n+  if (sv [7] != CONST2)\n+    abort ();\n+\n+  sv = s21 (sv, CONST3);\n+  if (sv [5] != CONST3)\n+    abort ();\n+\n+  sv = s30 (sv, CONST4);\n+  if (sv [6] != CONST4)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST5);\n+  if (sv [3] != CONST5)\n+    abort ();\n+\n+  sv = ms7 (&sv, CONST6);\n+  if (sv [7] != CONST6)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST7);\n+  if (sv [5] != CONST7)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [6] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST1);\n+  if (sv [5] != CONST1)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST3);\n+  if (sv [2] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST2);\n+  if (sv [7] != CONST2)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST5);\n+  if (sv [4] != CONST5)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST4);\n+  if (sv [5] != CONST4)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST6);\n+  if (sv [4] != CONST6)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST7);\n+  if (sv [1] != CONST7)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST4);\n+  if (sv [0] != CONST4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "19932629d4bdf45589548b76d667f982b3142d96", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,148 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Unsigned Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned int s3 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector unsigned int s1 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector unsigned int s21 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector unsigned int s30 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, unsigned char *argv[]) {\n+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };\n+\n+  sv = s3 (sv, CONST2);\n+  if (sv [3] != CONST2)\n+    abort ();\n+\n+  sv = s1 (sv, CONST2);\n+  if (sv [1] != CONST2)\n+    abort ();\n+\n+  sv = s21 (sv, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = s30 (sv, CONST1);\n+  if (sv [2] != CONST1)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST0);\n+  if (sv [3] != CONST0)\n+    abort ();\n+\n+  sv = ms1 (&sv, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST1);\n+  if (sv [1] != CONST1)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [2] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST0);\n+  if (sv [2] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST3);\n+  if (sv [0] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST2);\n+  if (sv [0] != CONST2)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST1);\n+  if (sv [0] != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "8c643aaafd316ed09127d26f815e10ca5f4cd9fc", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,148 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Unsigned Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned int s3 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+vector unsigned int s1 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 1);\n+}\n+\n+vector unsigned int s21 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector unsigned int s30 (vector unsigned int v, unsigned int x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 1);\n+}\n+\n+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, unsigned char *argv[]) {\n+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };\n+\n+  sv = s3 (sv, CONST2);\n+  if (sv [3] != CONST2)\n+    abort ();\n+\n+  sv = s1 (sv, CONST2);\n+  if (sv [1] != CONST2)\n+    abort ();\n+\n+  sv = s21 (sv, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = s30 (sv, CONST1);\n+  if (sv [2] != CONST1)\n+    abort ();\n+\n+  sv = ms3 (&sv, CONST0);\n+  if (sv [3] != CONST0)\n+    abort ();\n+\n+  sv = ms1 (&sv, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = ms21 (&sv, CONST1);\n+  if (sv [1] != CONST1)\n+    abort ();\n+\n+  sv = ms30 (&sv, CONST0);\n+  if (sv [2] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 5, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = ci (sv, 2, CONST0);\n+  if (sv [2] != CONST0)\n+    abort ();\n+\n+  sv = ci (sv, 15, CONST1);\n+  if (sv [3] != CONST1)\n+    abort ();\n+\n+  sv = ci (sv, 28, CONST3);\n+  if (sv [0] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 5, CONST0);\n+  if (sv [1] != CONST0)\n+    abort ();\n+\n+  sv = mci (&sv, 12, CONST2);\n+  if (sv [0] != CONST2)\n+    abort ();\n+\n+  sv = mci (&sv, 25, CONST3);\n+  if (sv [1] != CONST3)\n+    abort ();\n+\n+  sv = mci (&sv, 16, CONST1);\n+  if (sv [0] != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "3ff0dfe20b0281b2fe835c95e086815b540cb435", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,122 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+#define CONST2\t\t(3 * 31415926539LL)\n+#define CONST3\t\t(4 * 31415926539LL)\n+#define CONST4\t\t(5 * 31415926539LL)\n+#define CONST5\t\t(6 * 31415926539LL)\n+#define CONST6\t\t(7 * 31415926539LL)\n+#define CONST7\t\t(8 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned long long int\n+e0 (vector unsigned long long int v, unsigned long long int x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector unsigned long long int\n+e3 (vector unsigned long long int v, unsigned long long int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned long long int\n+me0 (vector unsigned long long int *vp, unsigned long long int x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector unsigned long long int\n+me3 (vector unsigned long long int *vp, unsigned long long int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned long long int\n+ei (vector unsigned long long int v, int i, unsigned long long int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned long long int\n+mei (vector unsigned long long int *vp, int i, unsigned long long int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned long long int dv = { CONST0, CONST1 };\n+  unsigned long long int d;\n+\n+  dv = e0 (dv, CONST7);\n+  if (dv [0] != CONST7)\n+    abort ();\n+\n+  dv = e3 (dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST4);\n+  if (dv [0] != CONST4)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST5);\n+  if (dv [0] != CONST5)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST6);\n+  if (dv [1] != CONST6)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "d0236df53084105f313ea4ef18b3927945808c54", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,122 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+#define CONST2\t\t(3 * 31415926539LL)\n+#define CONST3\t\t(4 * 31415926539LL)\n+#define CONST4\t\t(5 * 31415926539LL)\n+#define CONST5\t\t(6 * 31415926539LL)\n+#define CONST6\t\t(7 * 31415926539LL)\n+#define CONST7\t\t(8 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned long long int\n+e0 (vector unsigned long long int v, unsigned long long int x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector unsigned long long int\n+e3 (vector unsigned long long int v, unsigned long long int x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned long long int\n+me0 (vector unsigned long long int *vp, unsigned long long int x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector unsigned long long int\n+me3 (vector unsigned long long int *vp, unsigned long long int x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned long long int\n+ei (vector unsigned long long int v, int i, unsigned long long int x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned long long int\n+mei (vector unsigned long long int *vp, int i, unsigned long long int x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned long long int dv = { CONST0, CONST1 };\n+  unsigned long long int d;\n+\n+  dv = e0 (dv, CONST7);\n+  if (dv [0] != CONST7)\n+    abort ();\n+\n+  dv = e3 (dv, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST4);\n+  if (dv [0] != CONST4)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST5);\n+  if (dv [0] != CONST5)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST6);\n+  if (dv [1] != CONST6)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST3);\n+  if (dv [1] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST2);\n+  if (dv [1] != CONST2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e56d500515ed1e854be392fd81af95366aa4df79", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((unsigned __int128) 31415926539) << 60)\n+#define CONST1\t\t(((unsigned __int128) 31415926539) << 54)\n+#define CONST2\t\t(((unsigned __int128) 31415926539) << 48)\n+#define CONST3\t\t(((unsigned __int128) 31415926539) << 32)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned __int128\n+me0 (vector unsigned __int128 *vp, unsigned __int128 x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector unsigned __int128\n+me3 (vector unsigned __int128 *vp, unsigned __int128 x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned __int128\n+ei (vector unsigned __int128 v, int i, unsigned __int128 x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned __int128\n+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned __int128 dv = { CONST0 };\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e3 (dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST0);\n+  if (dv [0] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST0);\n+  if (dv [0] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "17c7b0e48a9f107b5c41a1597bbe4fe82c7464e3", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((unsigned __int128) 31415926539) << 60)\n+#define CONST1\t\t(((unsigned __int128) 31415926539) << 54)\n+#define CONST2\t\t(((unsigned __int128) 31415926539) << 48)\n+#define CONST3\t\t(((unsigned __int128) 31415926539) << 32)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)\n+{\n+  return vec_insert (x, v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector unsigned __int128\n+me0 (vector unsigned __int128 *vp, unsigned __int128 x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector unsigned __int128\n+me3 (vector unsigned __int128 *vp, unsigned __int128 x)\n+{\n+  return vec_insert (x, *vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector unsigned __int128\n+ei (vector unsigned __int128 v, int i, unsigned __int128 x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector unsigned __int128\n+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)\n+{\n+  return vec_insert (x, *vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned __int128 dv = { CONST0 };\n+\n+  dv = e0 (dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = e3 (dv, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = me0 (&dv, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = me3 (&dv, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = ei (dv, 0, CONST0);\n+  if (dv [0] != CONST0)\n+    abort ();\n+\n+  dv = ei (dv, 1, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = ei (dv, 2, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = ei (dv, 3, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  dv = mei (&dv, 0, CONST0);\n+  if (dv [0] != CONST0)\n+    abort ();\n+\n+  dv = mei (&dv, 1, CONST1);\n+  if (dv [0] != CONST1)\n+    abort ();\n+\n+  dv = mei (&dv, 2, CONST2);\n+  if (dv [0] != CONST2)\n+    abort ();\n+\n+  dv = mei (&dv, 3, CONST3);\n+  if (dv [0] != CONST3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "3bec1474954dc6ef4ec88258e080dc59810bd99c", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9c.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,164 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector signed char c0 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector signed char c9 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 9);\n+}\n+\n+vector signed char c21 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector signed char c30 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector signed char mc0 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector signed char mc9 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 9);\n+}\n+\n+vector signed char mc21 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector signed char mc30 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector signed char ci (vector signed char v, int i, signed char x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector signed char mci(vector signed char *vp, int i, signed char x) {\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t    CONST4, CONST5, CONST6, CONST7,\n+\t\t\t    CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t    CONSTC, CONSTD, CONSTE, CONSTF };\n+  signed char c;\n+\n+  cv = c0 (cv, CONSTF);\n+  if (cv [0] != CONSTF)\n+    abort ();\n+\n+  cv = c9 (cv, CONST7);\n+  if (cv [9] != CONST7)\n+    abort ();\n+\n+  cv = c21 (cv, CONSTA);\n+  if (cv [5] != CONSTA)\n+    abort ();\n+\n+  cv = c30 (cv, CONSTC);\n+  if (cv [14] != CONSTC)\n+    abort ();\n+\n+  cv = mc0 (&cv, CONSTB);\n+  if (cv [0] != CONSTB)\n+    abort ();\n+\n+  cv = mc9 (&cv, CONST1);\n+  if (cv [9] != CONST1)\n+    abort ();\n+\n+  cv = mc21 (&cv, CONST7);\n+  if (cv [5] != CONST7)\n+    abort ();\n+\n+  cv = mc30 (&cv, CONST2);\n+  if (cv [14] != CONST2)\n+    abort ();\n+\n+  cv = ci (cv, 8, CONST4);\n+  if (cv [8] != CONST4)\n+    abort ();\n+\n+  cv = ci (cv, 13, CONSTB);\n+  if (cv [13] != CONSTB)\n+    abort ();\n+\n+  cv = ci (cv, 23, CONST3);\n+  if (cv [7] != CONST3)\n+    abort ();\n+\n+  cv = ci (cv, 31, CONST2);\n+  if (cv [15] != CONST2)\n+    abort ();\n+\n+  cv = mci (&cv, 5, CONST1);\n+  if (cv [5] != CONST1)\n+    abort ();\n+\n+  cv = mci (&cv, 12, CONST3);\n+  if (cv [12] != CONST3)\n+    abort ();\n+\n+  cv = mci (&cv, 25, CONST5);\n+  if (cv [9] != CONST5)\n+    abort ();\n+\n+  cv = mci (&cv, 16, CONSTD);\n+  if (cv [0] != CONSTD)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1e70c521fec6812b4617a01bdcfb711258b63342", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d30228e2b9837e66827acfe95c9a74c90c1d42b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9d.c?ref=5d30228e2b9837e66827acfe95c9a74c90c1d42b", "patch": "@@ -0,0 +1,164 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/vmx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+vector signed char c0 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 0);\n+}\n+\n+vector signed char c9 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 9);\n+}\n+\n+vector signed char c21 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 21);\n+}\n+\n+vector signed char c30 (vector signed char v, signed char x)\n+{\n+  return vec_insert (x, v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+vector signed char mc0 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 0);\n+}\n+\n+vector signed char mc9 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 9);\n+}\n+\n+vector signed char mc21 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 21);\n+}\n+\n+vector signed char mc30 (vector signed char *vp, signed char x)\n+{\n+  return vec_insert (x, *vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+vector signed char ci (vector signed char v, int i, signed char x)\n+{\n+  return vec_insert (x, v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+vector signed char mci(vector signed char *vp, int i, signed char x) {\n+  return vec_insert (x, *vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t    CONST4, CONST5, CONST6, CONST7,\n+\t\t\t    CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t    CONSTC, CONSTD, CONSTE, CONSTF };\n+  signed char c;\n+\n+  cv = c0 (cv, CONSTF);\n+  if (cv [0] != CONSTF)\n+    abort ();\n+\n+  cv = c9 (cv, CONST7);\n+  if (cv [9] != CONST7)\n+    abort ();\n+\n+  cv = c21 (cv, CONSTA);\n+  if (cv [5] != CONSTA)\n+    abort ();\n+\n+  cv = c30 (cv, CONSTC);\n+  if (cv [14] != CONSTC)\n+    abort ();\n+\n+  cv = mc0 (&cv, CONSTB);\n+  if (cv [0] != CONSTB)\n+    abort ();\n+\n+  cv = mc9 (&cv, CONST1);\n+  if (cv [9] != CONST1)\n+    abort ();\n+\n+  cv = mc21 (&cv, CONST7);\n+  if (cv [5] != CONST7)\n+    abort ();\n+\n+  cv = mc30 (&cv, CONST2);\n+  if (cv [14] != CONST2)\n+    abort ();\n+\n+  cv = ci (cv, 8, CONST4);\n+  if (cv [8] != CONST4)\n+    abort ();\n+\n+  cv = ci (cv, 13, CONSTB);\n+  if (cv [13] != CONSTB)\n+    abort ();\n+\n+  cv = ci (cv, 23, CONST3);\n+  if (cv [7] != CONST3)\n+    abort ();\n+\n+  cv = ci (cv, 31, CONST2);\n+  if (cv [15] != CONST2)\n+    abort ();\n+\n+  cv = mci (&cv, 5, CONST1);\n+  if (cv [5] != CONST1)\n+    abort ();\n+\n+  cv = mci (&cv, 12, CONST3);\n+  if (cv [12] != CONST3)\n+    abort ();\n+\n+  cv = mci (&cv, 25, CONST5);\n+  if (cv [9] != CONST5)\n+    abort ();\n+\n+  cv = mci (&cv, 16, CONSTD);\n+  if (cv [0] != CONSTD)\n+    abort ();\n+\n+  return 0;\n+}"}]}