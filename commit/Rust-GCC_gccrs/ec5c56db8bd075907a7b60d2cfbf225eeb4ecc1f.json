{"sha": "ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1YzU2ZGI4YmQwNzU5MDdhN2I2MGQyY2ZiZjIyNWVlYjRlY2MxZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-08-01T17:57:27Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-08-01T17:57:27Z"}, "message": "alias.c: Fix comment formatting.\n\n\t* alias.c: Fix comment formatting.\n\t* bitmap.c: Likewise.\n\t* builtins.c: Likewise.\n\t* calls.c: Likewise.\n\t* c-common.c: Likewise.\n\t* c-decl.c: Likewise.\n\t* c-dump.c: Likewise.\n\t* c-lex.c: Likewise.\n\t* collect2.c: Likewise.\n\t* combine.c: Likewise.\n\t* conflict.c: Likewise.\n\t* cppfiles.c: Likewise.\n\t* cppinit.c: Likewise.\n\t* cpplex.c: Likewise.\n\t* cpplib.c: Likewise.\n\t* cppmacro.c: Likewise.\n\t* cppspec.c: Likewise.\n\t* c-pragma.c: Likewise.\n\t* crtstuff.c: Likewise.\n\t* cse.c: Likewise.\n\t* cselib.c: Likewise.\n\t* c-semantics.c: Likewise.\n\t* c-typeck.c: Likewise.\n\nFrom-SVN: r44547", "tree": {"sha": "86574f9925b42a9611cf138f95cf23040f8ab07f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86574f9925b42a9611cf138f95cf23040f8ab07f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/comments", "author": null, "committer": null, "parents": [{"sha": "60a78ccfac331b0d4ff71fcdddcfc302817eb110", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60a78ccfac331b0d4ff71fcdddcfc302817eb110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60a78ccfac331b0d4ff71fcdddcfc302817eb110"}], "stats": {"total": 318, "additions": 172, "deletions": 146}, "files": [{"sha": "d52b7fc4622c2148175459c52ceebcf9466f4133", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -1,3 +1,29 @@\n+2001-08-01  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* alias.c: Fix comment formatting.\n+\t* bitmap.c: Likewise.\n+\t* builtins.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-dump.c: Likewise.\n+\t* c-lex.c: Likewise.\n+\t* collect2.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* conflict.c: Likewise.\n+\t* cppfiles.c: Likewise.\n+\t* cppinit.c: Likewise.\n+\t* cpplex.c: Likewise.\n+\t* cpplib.c: Likewise.\n+\t* cppmacro.c: Likewise.\n+\t* cppspec.c: Likewise.\n+\t* c-pragma.c: Likewise.\n+\t* crtstuff.c: Likewise.\n+\t* cse.c: Likewise.\n+\t* cselib.c: Likewise.\n+\t* c-semantics.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\n 2001-08-01  H.J. Lu <hjl@gnu.org>\n \n \t* config/mips/linux.h (ASM_OUTPUT_IDENT): Defined."}, {"sha": "1a28eb635500d3f74d897435066295dc6d357806", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -352,7 +352,7 @@ objects_must_conflict_p (t1, t2)\n       != (t2 != 0 && AGGREGATE_TYPE_P (t2)))\n     return 0;\n \n-  /* Otherwise they conflict only if the alias sets conflict. */\n+  /* Otherwise they conflict only if the alias sets conflict.  */\n   return alias_sets_conflict_p (t1 ? get_alias_set (t1) : 0,\n \t\t\t\tt2 ? get_alias_set (t2) : 0);\n }\n@@ -758,7 +758,7 @@ find_base_value (src)\n       if (GET_CODE (src) != PLUS && GET_CODE (src) != MINUS)\n \tbreak;\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case PLUS:\n     case MINUS:\n@@ -807,7 +807,7 @@ find_base_value (src)\n \n     case AND:\n       /* If the second operand is constant set the base\n-\t address to the first operand. */\n+\t address to the first operand.  */\n       if (GET_CODE (XEXP (src, 1)) == CONST_INT && INTVAL (XEXP (src, 1)) != 0)\n \treturn find_base_value (XEXP (src, 0));\n       return 0;\n@@ -1344,7 +1344,7 @@ base_alias_check (x, y, x_mode, y_mode)\n   if (flag_argument_noalias > 1)\n     return 0;\n \n-  /* Weak noalias assertion (arguments are distinct, but may match globals). */\n+  /* Weak noalias assertion (arguments are distinct, but may match globals).  */\n   return ! (GET_MODE (x_base) == VOIDmode && GET_MODE (y_base) == VOIDmode);\n }\n \n@@ -2103,7 +2103,7 @@ init_alias_once ()\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     /* Check whether this register can hold an incoming pointer\n        argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n-       numbers, so translate if necessary due to register windows. */\n+       numbers, so translate if necessary due to register windows.  */\n     if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))\n \t&& HARD_REGNO_MODE_OK (i, Pmode))\n       SET_HARD_REG_BIT (argument_registers, i);\n@@ -2231,7 +2231,7 @@ init_alias_analysis ()\n \n \t      /* If this insn has a noalias note, process it,  Otherwise,\n \t         scan for sets.  A simple set will have no side effects\n-\t         which could change the base value of any other register. */\n+\t         which could change the base value of any other register.  */\n \n \t      if (GET_CODE (PATTERN (insn)) == SET\n \t\t  && REG_NOTES (insn) != 0"}, {"sha": "078b596b38b4ce2a252f4671bbc30165562ef2c8", "filename": "gcc/bitmap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -38,8 +38,8 @@ static int bitmap_obstack_init = FALSE;\n #endif\n \n /* Global data */\n-bitmap_element bitmap_zero_bits;\t/* An element of all zero bits. */\n-static bitmap_element *bitmap_free;\t/* Freelist of bitmap elements. */\n+bitmap_element bitmap_zero_bits;\t/* An element of all zero bits.  */\n+static bitmap_element *bitmap_free;\t/* Freelist of bitmap elements.  */\n \n static void bitmap_element_free\t\tPARAMS ((bitmap, bitmap_element *));\n static bitmap_element *bitmap_element_allocate PARAMS ((void));\n@@ -583,7 +583,7 @@ bitmap_operation (to, from1, from2, operation)\n \t}\n \n       /* Find the appropriate element from TO.  Begin by discarding\n-\t elements that we've skipped. */\n+\t elements that we've skipped.  */\n       while (to_ptr && to_ptr->indx < indx)\n \t{\n \t  changed = 1;\n@@ -671,7 +671,7 @@ bitmap_equal_p (a, b)\n }\n \f\n /* Or into bitmap TO bitmap FROM1 and'ed with the complement of\n-   bitmap FROM2. */\n+   bitmap FROM2.  */\n \n void\n bitmap_ior_and_compl (to, from1, from2)"}, {"sha": "62e000058b90a7e63d89b193deda5c1be8a1c38a", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -510,7 +510,7 @@ expand_builtin_setjmp_setup (buf_addr, receiver_label)\n   current_function_calls_setjmp = 1;\n \n   /* Set this so all the registers get saved in our frame; we need to be\n-     able to copy the saved values for any registers from frames we unwind. */\n+     able to copy the saved values for any registers from frames we unwind.  */\n   current_function_has_nonlocal_label = 1;\n }\n \n@@ -757,7 +757,7 @@ get_memory_rtx (exp)\n     return mem;\n \n   set_mem_attributes (mem, exp, 0);\n-  /* memcpy, memset and other builtin stringops can alias with anything. */\n+  /* memcpy, memset and other builtin stringops can alias with anything.  */\n   set_mem_alias_set (mem, 0);\n   return mem;\n }\n@@ -2480,7 +2480,7 @@ expand_builtin_strncat (arglist, target, mode)\n \t    fn = built_in_decls[BUILT_IN_STRCAT];\n \t  \n \t  /* If the replacement _DECL isn't initialized, don't do the\n-\t     transformation. */\n+\t     transformation.  */\n \t  if (!fn)\n \t    return 0;\n \n@@ -2574,7 +2574,7 @@ expand_builtin_strcspn (arglist, target, mode)\n \t    fn = built_in_decls[BUILT_IN_STRLEN];\n \t  \n \t  /* If the replacement _DECL isn't initialized, don't do the\n-\t     transformation. */\n+\t     transformation.  */\n \t  if (!fn)\n \t    return 0;\n \n@@ -3141,7 +3141,7 @@ expand_builtin_ffs (arglist, target, subtarget)\n }\n \n /* If the string passed to fputs is a constant and is one character\n-   long, we attempt to transform this call into __builtin_fputc(). */\n+   long, we attempt to transform this call into __builtin_fputc().  */\n \n static rtx\n expand_builtin_fputs (arglist, ignore)\n@@ -3152,11 +3152,11 @@ expand_builtin_fputs (arglist, ignore)\n     fn_fwrite = built_in_decls[BUILT_IN_FWRITE];\n \n   /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation. */\n+     initialized, don't do the transformation.  */\n   if (!ignore || !fn_fputc || !fn_fwrite)\n     return 0;\n \n-  /* Verify the arguments in the original call. */\n+  /* Verify the arguments in the original call.  */\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n       || current_function_check_memory_usage)\n     return 0;"}, {"sha": "59be405120e5913491b4422747e7652e0eb7ffa5", "filename": "gcc/c-common.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -222,23 +222,23 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC,\n \t    A_NO_LIMIT_STACK, A_PURE};\n \n-/* Information about how a function name is generated. */\n+/* Information about how a function name is generated.  */\n struct fname_var_t\n {\n-  tree *decl;\t/* pointer to the VAR_DECL. */\n-  unsigned rid;\t/* RID number for the identifier. */\n+  tree *decl;\t/* pointer to the VAR_DECL.  */\n+  unsigned rid;\t/* RID number for the identifier.  */\n   int pretty;\t/* How pretty is it? */\n };\n \n-/* The three ways of getting then name of the current function. */\n+/* The three ways of getting then name of the current function.  */\n \n const struct fname_var_t fname_vars[] =\n {\n-  /* C99 compliant __func__, must be first. */\n+  /* C99 compliant __func__, must be first.  */\n   {&c99_function_name_decl_node, RID_C99_FUNCTION_NAME, 0},\n-  /* GCC __FUNCTION__ compliant. */\n+  /* GCC __FUNCTION__ compliant.  */\n   {&function_name_decl_node, RID_FUNCTION_NAME, 0},\n-  /* GCC __PRETTY_FUNCTION__ compliant. */\n+  /* GCC __PRETTY_FUNCTION__ compliant.  */\n   {&pretty_function_name_decl_node, RID_PRETTY_FUNCTION_NAME, 1},\n   {NULL, 0, 0},\n };\n@@ -359,7 +359,7 @@ c_finish_else ()\n   RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n }\n \n-/* Push current bindings for the function name VAR_DECLS. */\n+/* Push current bindings for the function name VAR_DECLS.  */\n \n void\n start_fname_decls ()\n@@ -389,7 +389,7 @@ start_fname_decls ()\n    function's body in a COMPOUND_STMT containing these decls too. This\n    must be done _before_ finish_stmt_tree is called. If there is no\n    current function, we must be at file scope and no statements are\n-   involved. Pop the previous bindings. */\n+   involved. Pop the previous bindings.  */\n \n void\n finish_fname_decls ()\n@@ -403,7 +403,7 @@ finish_fname_decls ()\n   \n   if (body)\n     {\n-      /* They were called into existance, so add to statement tree. */\n+      /* They were called into existance, so add to statement tree.  */\n       body = chainon (body,\n \t\t      TREE_CHAIN (DECL_SAVED_TREE (current_function_decl)));\n       body = build_stmt (COMPOUND_STMT, body);\n@@ -417,7 +417,7 @@ finish_fname_decls ()\n   \n   if (stack)\n     {\n-      /* We had saved values, restore them. */\n+      /* We had saved values, restore them.  */\n       tree saved;\n \n       for (saved = TREE_PURPOSE (stack); saved; saved = TREE_CHAIN (saved))\n@@ -433,7 +433,7 @@ finish_fname_decls ()\n }\n \n /* Return the text name of the current function, suitable prettified\n-   by PRETTY_P. */\n+   by PRETTY_P.  */\n \n const char *\n fname_as_string (pretty_p)\n@@ -496,7 +496,7 @@ fname_decl (rid, id)\n \t{\n \t  /* We created some statement tree for the decl. This belongs\n \t     at the start of the function, so remove it now and reinsert\n-\t     it after the function is complete. */\n+\t     it after the function is complete.  */\n \t  tree stmts = TREE_CHAIN (saved_last_tree);\n \n \t  TREE_CHAIN (saved_last_tree) = NULL_TREE;\n@@ -1975,7 +1975,7 @@ type_for_mode (mode, unsignedp)\n   return 0;\n }\n \n-/* Return an unsigned type the same as TYPE in other respects. */\n+/* Return an unsigned type the same as TYPE in other respects.  */\n tree\n unsigned_type (type)\n      tree type;\n@@ -3951,7 +3951,7 @@ c_unsafe_for_reeval (exp)\n   return -1;\n }\n \n-/* Tree code classes. */\n+/* Tree code classes.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n@@ -3984,7 +3984,7 @@ static const char *c_tree_code_name[] = {\n #undef DEFTREECODE\n \n /* Adds the tree codes specific to the C front end to the list of all\n-   tree codes. */\n+   tree codes.  */\n \n void\n add_c_tree_codes ()\n@@ -4053,33 +4053,33 @@ c_expand_builtin (exp, target, tmode, modifier)\n \n /* Check an arglist to *printf for problems.  The arglist should start\n    at the format specifier, with the remaining arguments immediately\n-   following it. */\n+   following it.  */\n static int\n is_valid_printf_arglist (arglist)\n   tree arglist;\n {\n-  /* Save this value so we can restore it later. */\n+  /* Save this value so we can restore it later.  */\n   const int SAVE_pedantic = pedantic;\n   int diagnostic_occurred = 0;\n \n   /* Set this to a known value so the user setting won't affect code\n      generation.  */\n   pedantic = 1;\n-  /* Check to make sure there are no format specifier errors. */\n+  /* Check to make sure there are no format specifier errors.  */\n   check_function_format (&diagnostic_occurred,\n \t\t\t maybe_get_identifier(\"printf\"),\n \t\t\t NULL_TREE, arglist);\n \n-  /* Restore the value of `pedantic'. */\n+  /* Restore the value of `pedantic'.  */\n   pedantic = SAVE_pedantic;\n \n   /* If calling `check_function_format_ptr' produces a warning, we\n-     return false, otherwise we return true. */\n+     return false, otherwise we return true.  */\n   return ! diagnostic_occurred;\n }\n \n /* If the arguments passed to printf are suitable for optimizations,\n-   we attempt to transform the call. */\n+   we attempt to transform the call.  */\n static rtx\n c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n      tree arglist;\n@@ -4093,16 +4093,16 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n   tree fn, format_arg, stripped_string;\n \n   /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation. */\n+     initialized, don't do the transformation.  */\n   if (!ignore || !fn_putchar || !fn_puts)\n     return 0;\n \n-  /* Verify the required arguments in the original call. */\n+  /* Verify the required arguments in the original call.  */\n   if (arglist == 0\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE))\n     return 0;\n   \n-  /* Check the specifier vs. the parameters. */\n+  /* Check the specifier vs. the parameters.  */\n   if (!is_valid_printf_arglist (arglist))\n     return 0;\n   \n@@ -4118,21 +4118,21 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n   \n   /* OK!  We can attempt optimization.  */\n \n-  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg2). */\n+  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg2).  */\n   if (strcmp (TREE_STRING_POINTER (stripped_string), \"%s\\n\") == 0)\n     {\n       arglist = TREE_CHAIN (arglist);\n       fn = fn_puts;\n     }\n-  /* If the format specifier was \"%c\", call __builtin_putchar (arg2). */\n+  /* If the format specifier was \"%c\", call __builtin_putchar (arg2).  */\n   else if (strcmp (TREE_STRING_POINTER (stripped_string), \"%c\") == 0)\n     {\n       arglist = TREE_CHAIN (arglist);\n       fn = fn_putchar;\n     }\n   else\n     {\n-     /* We can't handle anything else with % args or %% ... yet. */\n+     /* We can't handle anything else with % args or %% ... yet.  */\n       if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n \treturn 0;\n       \n@@ -4143,7 +4143,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n         {\n \t  /* Given printf(\"c\"), (where c is any one character,)\n              convert \"c\"[0] to an int and pass that to the replacement\n-             function. */\n+             function.  */\n \t  arglist = build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0);\n \t  arglist = build_tree_list (NULL_TREE, arglist);\n \t  \n@@ -4180,7 +4180,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n }\n \n /* If the arguments passed to fprintf are suitable for optimizations,\n-   we attempt to transform the call. */\n+   we attempt to transform the call.  */\n static rtx\n c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore)\n      tree arglist;\n@@ -4194,19 +4194,19 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore)\n   tree fn, format_arg, stripped_string;\n \n   /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation. */\n+     initialized, don't do the transformation.  */\n   if (!ignore || !fn_fputc || !fn_fputs)\n     return 0;\n \n-  /* Verify the required arguments in the original call. */\n+  /* Verify the required arguments in the original call.  */\n   if (arglist == 0\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n       || (TREE_CHAIN (arglist) == 0)\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) !=\n \t  POINTER_TYPE))\n     return 0;\n   \n-  /* Check the specifier vs. the parameters. */\n+  /* Check the specifier vs. the parameters.  */\n   if (!is_valid_printf_arglist (TREE_CHAIN (arglist)))\n     return 0;\n   \n@@ -4222,7 +4222,7 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore)\n   \n   /* OK!  We can attempt optimization.  */\n \n-  /* If the format specifier was \"%s\", call __builtin_fputs(arg3, arg1). */\n+  /* If the format specifier was \"%s\", call __builtin_fputs(arg3, arg1).  */\n   if (strcmp (TREE_STRING_POINTER (stripped_string), \"%s\") == 0)\n     {\n       tree newarglist = build_tree_list (NULL_TREE, TREE_VALUE (arglist));\n@@ -4231,7 +4231,7 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore)\n \t\t\t   newarglist);\n       fn = fn_fputs;\n     }\n-  /* If the format specifier was \"%c\", call __builtin_fputc (arg3, arg1). */\n+  /* If the format specifier was \"%c\", call __builtin_fputc (arg3, arg1).  */\n   else if (strcmp (TREE_STRING_POINTER (stripped_string), \"%c\") == 0)\n     {\n       tree newarglist = build_tree_list (NULL_TREE, TREE_VALUE (arglist));\n@@ -4242,7 +4242,7 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore)\n     }\n   else\n     {\n-     /* We can't handle anything else with % args or %% ... yet. */\n+     /* We can't handle anything else with % args or %% ... yet.  */\n       if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n \treturn 0;\n       "}, {"sha": "b57e6d4f18c3cc9269a0d6e382b3436f9ab4b3ad", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -3098,7 +3098,7 @@ c_make_fname_decl (id, type_dep)\n \t   build_index_type (size_int (length)));\n \n   decl = build_decl (VAR_DECL, id, type);\n-  /* We don't push the decl, so have to set its context here. */\n+  /* We don't push the decl, so have to set its context here.  */\n   DECL_CONTEXT (decl) = current_function_decl;\n   \n   TREE_STATIC (decl) = 1;"}, {"sha": "84c99cc8f4d534e0925ac3a60b32fecb79fdf216", "filename": "gcc/c-dump.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -139,9 +139,9 @@ queue_and_dump_type (di, t)\n }\n \n /* Dump column control */\n-#define SOL_COLUMN 25\t\t/* Start of line column. */\n-#define EOL_COLUMN 55\t\t/* End of line column. */\n-#define COLUMN_ALIGNMENT 15\t/* Alignment. */\n+#define SOL_COLUMN 25\t\t/* Start of line column.  */\n+#define EOL_COLUMN 55\t\t/* End of line column.  */\n+#define COLUMN_ALIGNMENT 15\t/* Alignment.  */\n \n /* Insert a new line in the dump output, and indent to an appropriate\n    place to start printing more fields.  */\n@@ -736,7 +736,7 @@ dequeue_and_dump (di)\n }\n \n /* Return non-zero if FLAG has been specified for the dump, and NODE\n-   is not the root node of the dump. */\n+   is not the root node of the dump.  */\n \n int dump_flag (di, flag, node)\n      dump_info_p di;\n@@ -786,16 +786,16 @@ dump_node (t, flags, stream)\n   splay_tree_delete (di.nodes);\n }\n \n-/* Define a tree dump switch. */\n+/* Define a tree dump switch.  */\n struct dump_file_info\n {\n-  const char *suffix;\t\t/* suffix to give output file. */\n+  const char *suffix;\t\t/* suffix to give output file.  */\n   const char *swtch;\t\t/* command line switch */\n   int flags;\t\t\t/* user flags */\n   int state;\t\t\t/* state of play */\n };\n \n-/* Table of tree dump switches. */\n+/* Table of tree dump switches.  */\n static struct dump_file_info dump_files[TDI_end] =\n {\n   {\".tu\", \"dump-translation-unit\", 0, 0},\n@@ -808,7 +808,7 @@ static struct dump_file_info dump_files[TDI_end] =\n /* Begin a tree dump for PHASE. Stores any user supplied flag in\n    *FLAG_PTR and returns a stream to write to. If the dump is not\n    enabled, returns NULL.\n-   Multiple calls will reopen and append to the dump file. */\n+   Multiple calls will reopen and append to the dump file.  */\n \n FILE *\n dump_begin (phase, flag_ptr)\n@@ -834,7 +834,7 @@ dump_begin (phase, flag_ptr)\n   return stream;\n }\n \n-/* Returns non-zero if tree dump PHASE is enabled. */\n+/* Returns non-zero if tree dump PHASE is enabled.  */\n \n int\n dump_enabled_p (phase)\n@@ -843,7 +843,7 @@ dump_enabled_p (phase)\n   return dump_files[phase].state;\n }\n \n-/* Returns the switch name of PHASE. */\n+/* Returns the switch name of PHASE.  */\n \n const char *\n dump_flag_name (phase)\n@@ -853,7 +853,7 @@ dump_flag_name (phase)\n }\n \n /* Finish a tree dump for PHASE. STREAM is the stream created by\n-   dump_begin. */\n+   dump_begin.  */\n \n void\n dump_end (phase, stream)\n@@ -864,7 +864,7 @@ dump_end (phase, stream)\n }\n \n /* Parse ARG as a dump switch. Return non-zero if it is, and store the\n-   relevant details in the dump_files array. */\n+   relevant details in the dump_files array.  */\n \n int\n dump_switch_p (arg)"}, {"sha": "cf958f56c30eed6bb25eab22e4ec2f436d5f4d79", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -73,7 +73,7 @@ extern FILE *asm_out_file;\n /* Number of bytes in a wide character.  */\n #define WCHAR_BYTES (WCHAR_TYPE_SIZE / BITS_PER_UNIT)\n \n-int indent_level;        /* Number of { minus number of }. */\n+int indent_level;        /* Number of { minus number of }.  */\n int pending_lang_change; /* If we need to switch languages - C++ only */\n int c_header_level;\t /* depth in C headers - C++ only */\n \n@@ -309,7 +309,7 @@ cb_def_pragma (pfile)\n {\n   /* Issue a warning message if we have been asked to do so.  Ignore\n      unknown pragmas in system headers unless an explicit\n-     -Wunknown-pragmas has been given. */\n+     -Wunknown-pragmas has been given.  */\n   if (warn_unknown_pragmas > in_system_header)\n     {\n       const unsigned char *space, *name = 0;\n@@ -826,7 +826,7 @@ lex_number (str, len)\n      Two HOST_WIDE_INTs is the largest int literal we can store.\n      In order to detect overflow below, the number of parts (TOTAL_PARTS)\n      must be exactly the number of parts needed to hold the bits\n-     of two HOST_WIDE_INTs. */\n+     of two HOST_WIDE_INTs.  */\n #define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n   unsigned int parts[TOTAL_PARTS];\n   \n@@ -936,7 +936,7 @@ lex_number (str, len)\n \t  /* If the highest-order part overflows (gets larger than\n \t     a host char will hold) then the whole number has \n \t     overflowed.  Record this and truncate the highest-order\n-\t     part. */\n+\t     part.  */\n \t  if (parts[TOTAL_PARTS - 1] >> HOST_BITS_PER_CHAR)\n \t    {\n \t      overflow = 1;\n@@ -1123,7 +1123,7 @@ lex_number (str, len)\n \t    }\n \t}\n \n-      /* If the literal overflowed, pedwarn about it now. */\n+      /* If the literal overflowed, pedwarn about it now.  */\n       if (overflow)\n \t{\n \t  warn = 1;\n@@ -1264,7 +1264,7 @@ lex_number (str, len)\n \tTREE_TYPE (value) = type;\n \n       /* If it's still an integer (not a complex), and it doesn't\n-\t fit in the type we choose for it, then pedwarn. */\n+\t fit in the type we choose for it, then pedwarn.  */\n \n       if (! warn\n \t  && TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE"}, {"sha": "c30a57b9aa4fac44bc3966be3b43c19f2590575a", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -53,7 +53,7 @@ static struct align_stack * alignment_stack = NULL;\n    #pragma pack(push,<n>) is encountered, this stores the value of \n    maximum_field_alignment in effect.  When the final pop_alignment() \n    happens, we restore the value to this, not to a value of 0 for\n-   maximum_field_alignment.  Value is in bits. */\n+   maximum_field_alignment.  Value is in bits.  */\n static int  default_alignment;\n #define SET_GLOBAL_ALIGNMENT(ALIGN) \\\n (default_alignment = maximum_field_alignment = (ALIGN))\n@@ -84,7 +84,7 @@ push_alignment (alignment, id)\n       \n       /* The current value of maximum_field_alignment is not necessarily \n \t 0 since there may be a #pragma pack(<n>) in effect; remember it \n-\t so that we can restore it after the final #pragma pop(). */\n+\t so that we can restore it after the final #pragma pop().  */\n       if (alignment_stack == NULL)\n \tdefault_alignment = maximum_field_alignment;\n       "}, {"sha": "8f08ff38938058441db79a248d0c62b2ca0e1585", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -278,7 +278,7 @@ emit_local_var (decl)\n     expand_end_target_temps ();\n }\n \n-/* Helper for generating the RTL at the beginning of a scope. */\n+/* Helper for generating the RTL at the beginning of a scope.  */\n \n void\n genrtl_do_pushlevel ()\n@@ -287,7 +287,7 @@ genrtl_do_pushlevel ()\n   clear_last_expr ();\n }\n \n-/* Generate the RTL for DESTINATION, which is a GOTO_STMT. */\n+/* Generate the RTL for DESTINATION, which is a GOTO_STMT.  */\n \n void\n genrtl_goto_stmt (destination)\n@@ -312,7 +312,7 @@ genrtl_goto_stmt (destination)\n     expand_computed_goto (destination);\n }\n \n-/* Generate the RTL for EXPR, which is an EXPR_STMT. */\n+/* Generate the RTL for EXPR, which is an EXPR_STMT.  */\n \n void \n genrtl_expr_stmt (expr)\n@@ -333,7 +333,7 @@ genrtl_expr_stmt (expr)\n     }\n }\n \n-/* Generate the RTL for T, which is a DECL_STMT. */\n+/* Generate the RTL for T, which is a DECL_STMT.  */\n \n void\n genrtl_decl_stmt (t)\n@@ -368,7 +368,7 @@ genrtl_decl_stmt (t)\n     (*lang_expand_decl_stmt) (t);\n }\n \n-/* Generate the RTL for T, which is an IF_STMT. */\n+/* Generate the RTL for T, which is an IF_STMT.  */\n \n void\n genrtl_if_stmt (t)\n@@ -389,7 +389,7 @@ genrtl_if_stmt (t)\n   expand_end_cond ();\n }\n \n-/* Generate the RTL for T, which is a WHILE_STMT. */\n+/* Generate the RTL for T, which is a WHILE_STMT.  */\n \n void\n genrtl_while_stmt (t)\n@@ -411,7 +411,7 @@ genrtl_while_stmt (t)\n   expand_end_loop ();\n }\n \n-/* Generate the RTL for T, which is a DO_STMT. */\n+/* Generate the RTL for T, which is a DO_STMT.  */\n \n void\n genrtl_do_stmt (t)\n@@ -445,7 +445,7 @@ genrtl_do_stmt (t)\n     }\n }\n \n-/* Build the node for a return statement and return it. */\n+/* Build the node for a return statement and return it.  */\n \n tree\n build_return_stmt (expr)\n@@ -454,7 +454,7 @@ build_return_stmt (expr)\n   return (build_stmt (RETURN_STMT, expr));\n }\n \n-/* Generate the RTL for STMT, which is a RETURN_STMT. */\n+/* Generate the RTL for STMT, which is a RETURN_STMT.  */\n \n void\n genrtl_return_stmt (stmt)\n@@ -481,7 +481,7 @@ genrtl_return_stmt (stmt)\n     }\n }\n \n-/* Generate the RTL for T, which is a FOR_STMT. */\n+/* Generate the RTL for T, which is a FOR_STMT.  */\n \n void\n genrtl_for_stmt (t)\n@@ -527,15 +527,15 @@ genrtl_for_stmt (t)\n   expand_end_loop ();\n }\n \n-/* Build a break statement node and return it. */\n+/* Build a break statement node and return it.  */\n \n tree\n build_break_stmt ()\n {\n   return (build_stmt (BREAK_STMT));\n }\n \n-/* Generate the RTL for a BREAK_STMT. */\n+/* Generate the RTL for a BREAK_STMT.  */\n \n void\n genrtl_break_stmt ()\n@@ -545,15 +545,15 @@ genrtl_break_stmt ()\n     error (\"break statement not within loop or switch\");\n }\n \n-/* Build a continue statement node and return it. */\n+/* Build a continue statement node and return it.  */\n \n tree\n build_continue_stmt ()\n {\n   return (build_stmt (CONTINUE_STMT));\n }\n \n-/* Generate the RTL for a CONTINUE_STMT. */\n+/* Generate the RTL for a CONTINUE_STMT.  */\n \n void\n genrtl_continue_stmt ()\n@@ -563,7 +563,7 @@ genrtl_continue_stmt ()\n     error (\"continue statement not within a loop\");   \n }\n \n-/* Generate the RTL for T, which is a SCOPE_STMT. */\n+/* Generate the RTL for T, which is a SCOPE_STMT.  */\n \n void\n genrtl_scope_stmt (t)\n@@ -608,7 +608,7 @@ genrtl_scope_stmt (t)\n     }\n }\n \n-/* Generate the RTL for T, which is a SWITCH_STMT. */\n+/* Generate the RTL for T, which is a SWITCH_STMT.  */\n \n void\n genrtl_switch_stmt (t)\n@@ -620,7 +620,7 @@ genrtl_switch_stmt (t)\n   cond = expand_cond (SWITCH_COND (t));\n   if (cond == error_mark_node)\n     /* The code is in error, but we don't want expand_end_case to\n-       crash. */\n+       crash.  */\n     cond = boolean_false_node;\n \n   emit_line_note (input_filename, lineno);\n@@ -629,7 +629,7 @@ genrtl_switch_stmt (t)\n   expand_end_case (cond);\n }\n \n-/* Create a CASE_LABEL tree node and return it. */\n+/* Create a CASE_LABEL tree node and return it.  */\n \n tree\n build_case_label (low_value, high_value, label_decl)\n@@ -641,7 +641,7 @@ build_case_label (low_value, high_value, label_decl)\n }\n \n \n-/* Generate the RTL for a CASE_LABEL. */\n+/* Generate the RTL for a CASE_LABEL.  */\n \n void \n genrtl_case_label (case_label)\n@@ -668,7 +668,7 @@ genrtl_case_label (case_label)\n \t\t CASE_LABEL_DECL (case_label), &duplicate);\n }\n \n-/* Generate the RTL for T, which is a COMPOUND_STMT. */\n+/* Generate the RTL for T, which is a COMPOUND_STMT.  */\n \n void\n genrtl_compound_stmt (t)\n@@ -687,7 +687,7 @@ genrtl_compound_stmt (t)\n #endif\n }\n \n-/* Generate the RTL for an ASM_STMT. */\n+/* Generate the RTL for an ASM_STMT.  */\n \n void\n genrtl_asm_stmt (cv_qualifier, string, output_operands,\n@@ -716,7 +716,7 @@ genrtl_asm_stmt (cv_qualifier, string, output_operands,\n \t\t\t   input_filename, lineno);\n }\n \n-/* Generate the RTL for a DECL_CLEANUP. */\n+/* Generate the RTL for a DECL_CLEANUP.  */\n \n void \n genrtl_decl_cleanup (decl, cleanup)\n@@ -740,7 +740,7 @@ prep_stmt (t)\n }\n \n /* Generate the RTL for the statement T, its substatements, and any\n-   other statements at its nesting level. */\n+   other statements at its nesting level.  */\n \n void\n expand_stmt (t)"}, {"sha": "ecd106081f24b1e66453e19da29cc72680f5c990", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -5850,7 +5850,7 @@ add_pending_init (purpose, value)\n \t    {\n \t      if (r->balance < 0)\n \t\t{\n-\t\t  /* L rotation. */\n+\t\t  /* L rotation.  */\n \t\t  p->left = r->right;\n \t\t  if (p->left)\n \t\t    p->left->parent = p;\n@@ -5874,7 +5874,7 @@ add_pending_init (purpose, value)\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* LR rotation. */\n+\t\t  /* LR rotation.  */\n \t\t  struct init_node *t = r->right;\n \n \t\t  r->right = t->left;\n@@ -5923,7 +5923,7 @@ add_pending_init (purpose, value)\n \t    {\n \t      if (r->balance > 0)\n \t\t{\n-\t\t  /* R rotation. */\n+\t\t  /* R rotation.  */\n \t\t  p->right = r->left;\n \t\t  if (p->right)\n \t\t    p->right->parent = p;\n@@ -5982,7 +5982,7 @@ add_pending_init (purpose, value)\n \t    }\n \t  else\n \t    {\n-\t      /* p->balance == -1; growth of right side balances the node. */\n+\t      /* p->balance == -1; growth of right side balances the node.  */\n \t      p->balance = 0;\n \t      break;\n \t    }"}, {"sha": "bb12b0a17126b3b126bc1defd618f3ee4d3f6890", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -4619,7 +4619,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t}\n \n       /*  If parm is passed both in stack and in register and offset is \n-\t  greater than reg_parm_stack_space, split the offset. */\n+\t  greater than reg_parm_stack_space, split the offset.  */\n       if (arg->reg && arg->pass_on_stack)\n \t{\n \t  if (arg->offset.constant < reg_parm_stack_space && arg->offset.var)"}, {"sha": "4282b8736f9252725647df0f64de3c1d8e1d68fc", "filename": "gcc/collect2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -33,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #  define SIGCHLD SIGCLD\n #endif\n \n-#ifdef vfork /* Autoconf may define this to fork for us. */\n+#ifdef vfork /* Autoconf may define this to fork for us.  */\n # define VFORK_STRING \"fork\"\n #else\n # define VFORK_STRING \"vfork\"\n@@ -258,7 +258,7 @@ struct path_prefix\n };\n \n #ifdef COLLECT_EXPORT_LIST\n-/* Lists to keep libraries to be scanned for global constructors/destructors. */\n+/* Lists to keep libraries to be scanned for global constructors/destructors.  */\n static struct head libs;                    /* list of libraries */\n static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */\n static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */\n@@ -1435,7 +1435,7 @@ main (argc, argv)\n       return 0;\n     }\n \n-  /* Sort ctor and dtor lists by priority. */\n+  /* Sort ctor and dtor lists by priority.  */\n   sort_ids (&constructors);\n   sort_ids (&destructors);\n \n@@ -1711,7 +1711,7 @@ extract_init_priority (name)\n     ++pos;\n   pos += 10; /* strlen (\"GLOBAL__X_\") */\n \n-  /* Extract init_p number from ctor/dtor name. */\n+  /* Extract init_p number from ctor/dtor name.  */\n   pri = atoi (name + pos);\n   return pri ? pri : DEFAULT_INIT_PRIORITY;\n }\n@@ -2957,7 +2957,7 @@ static const char *aix_std_libs[] = {\n };\n \n /* This function checks the filename and returns 1\n-   if this name matches the location of a standard AIX library. */\n+   if this name matches the location of a standard AIX library.  */\n static int\n ignore_library (name)\n      const char *name;"}, {"sha": "f91665451fdaf327cd7fa60f8ea8df69477a1a19", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -84,7 +84,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"function.h\"\n-/* Include expr.h after insn-config.h so we get HAVE_conditional_move. */\n+/* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */\n #include \"expr.h\"\n #include \"insn-attr.h\"\n #include \"recog.h\"\n@@ -2469,7 +2469,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n     }\n #ifdef HAVE_cc0\n   /* If I2 is the setter CC0 and I3 is the user CC0 then check whether\n-     they are adjacent to each other or not. */\n+     they are adjacent to each other or not.  */\n   {\n     rtx p = prev_nonnote_insn (i3);\n     if (p && p != i2 && GET_CODE (p) == INSN && newi2pat\n@@ -3056,7 +3056,7 @@ find_split_point (loc, insn)\n \n \tcase NE:\n \t  /* if STORE_FLAG_VALUE is -1, this is (NE X 0) and only one bit of X\n-\t     is known to be on, this can be converted into a NEG of a shift. */\n+\t     is known to be on, this can be converted into a NEG of a shift.  */\n \t  if (STORE_FLAG_VALUE == -1 && XEXP (SET_SRC (x), 1) == const0_rtx\n \t      && GET_MODE (SET_SRC (x)) == GET_MODE (XEXP (SET_SRC (x), 0))\n \t      && 1 <= (pos = exact_log2"}, {"sha": "3c1cae005c2f5327cece5a97b4a41fbfd5b7b244", "filename": "gcc/conflict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -103,7 +103,7 @@ struct conflict_graph_def\n      conflicts exist involving that reg.  */\n   conflict_graph_arc *neighbor_heads;\n \n-  /* Arcs are allocated from here. */\n+  /* Arcs are allocated from here.  */\n   struct obstack arc_obstack;\n };\n \n@@ -122,7 +122,7 @@ static int print_conflict\tPARAMS ((int, int, void *));\n static void mark_reg\t\tPARAMS ((rtx, rtx, void *));\n \f\n /* Callback function to compute the hash value of an arc.  Uses\n-   current_graph to locate the graph to which the arc belongs. */\n+   current_graph to locate the graph to which the arc belongs.  */\n \n static unsigned\n arc_hash (arcp)"}, {"sha": "2592d4dc1fd4798ab3bf02d9414eb2dc16575aa0", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -219,11 +219,11 @@ open_file (pfile, filename)\n       return 0;\n     }\n \n-  /* Don't reopen an idempotent file. */\n+  /* Don't reopen an idempotent file.  */\n   if (DO_NOT_REREAD (file))\n     return file;\n       \n-  /* Don't reopen one which is already loaded. */\n+  /* Don't reopen one which is already loaded.  */\n   if (file->buffer != NULL)\n     return file;\n \n@@ -1066,11 +1066,11 @@ _cpp_simplify_pathname (path)\n     return path;\n \n #if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n-  /* Convert all backslashes to slashes. */\n+  /* Convert all backslashes to slashes.  */\n   for (from = path; *from; from++)\n     if (*from == '\\\\') *from = '/';\n     \n-  /* Skip over leading drive letter if present. */\n+  /* Skip over leading drive letter if present.  */\n   if (ISALPHA (path[0]) && path[1] == ':')\n     from = to = &path[2];\n   else"}, {"sha": "9c194109266446a697bd4fd8ab1d0be1bd18799f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -38,7 +38,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* Windows does not natively support inodes, and neither does MSDOS.\n    Cygwin's emulation can generate non-unique inodes, so don't use it.\n-   VMS has non-numeric inodes. */\n+   VMS has non-numeric inodes.  */\n #ifdef VMS\n # define INO_T_EQ(a, b) (!memcmp (&(a), &(b), sizeof (a)))\n #else\n@@ -198,7 +198,7 @@ path_include (pfile, list, path)\n }\n \n /* Append DIR to include path PATH.  DIR must be permanently allocated\n-   and writable. */\n+   and writable.  */\n static void\n append_include_chain (pfile, dir, path, cxx_aware)\n      cpp_reader *pfile;\n@@ -241,7 +241,7 @@ append_include_chain (pfile, dir, path, cxx_aware)\n   new->dev  = st.st_dev;\n   /* Both systm and after include file lists should be treated as system\n      include files since these two lists are really just a concatenation\n-     of one \"system\" list. */\n+     of one \"system\" list.  */\n   if (path == SYSTEM || path == AFTER)\n #ifdef NO_IMPLICIT_EXTERN_C\n     new->sysp = 1;\n@@ -468,7 +468,7 @@ init_library ()\n     }\n }\n \n-/* Initialize a cpp_reader structure. */\n+/* Initialize a cpp_reader structure.  */\n cpp_reader *\n cpp_create_reader (table, lang)\n      hash_table *table;\n@@ -809,7 +809,7 @@ init_standard_includes (pfile)\n   if (specd_prefix != 0 && cpp_GCC_INCLUDE_DIR_len)\n     {\n       /* Remove the `include' from /usr/local/lib/gcc.../include.\n-\t GCC_INCLUDE_DIR will always end in /include. */\n+\t GCC_INCLUDE_DIR will always end in /include.  */\n       int default_len = cpp_GCC_INCLUDE_DIR_len;\n       char *default_prefix = (char *) alloca (default_len + 1);\n       int specd_len = strlen (specd_prefix);\n@@ -1399,7 +1399,7 @@ cpp_handle_option (pfile, argc, argv)\n \t  CPP_OPTION (pfile, no_standard_includes) = 1;\n \t  break;\n \tcase OPT_nostdincplusplus:\n-\t  /* -nostdinc++ causes no default C++-specific include directories. */\n+\t  /* -nostdinc++ causes no default C++-specific include directories.  */\n \t  CPP_OPTION (pfile, no_standard_cplusplus_includes) = 1;\n \t  break;\n \tcase OPT_o:\n@@ -1696,7 +1696,7 @@ cpp_post_options (pfile)\n   if (CPP_OPTION (pfile, cplusplus))\n     CPP_OPTION (pfile, warn_traditional) = 0;\n \n-  /* Set this if it hasn't been set already. */\n+  /* Set this if it hasn't been set already.  */\n   if (CPP_OPTION (pfile, user_label_prefix) == NULL)\n     CPP_OPTION (pfile, user_label_prefix) = USER_LABEL_PREFIX;\n \n@@ -1780,7 +1780,7 @@ print_help ()\n {\n   fprintf (stderr, _(\"Usage: %s [switches] input output\\n\"), progname);\n   /* To keep the lines from getting too long for some compilers, limit\n-     to about 500 characters (6 lines) per chunk. */\n+     to about 500 characters (6 lines) per chunk.  */\n   fputs (_(\"\\\n Switches:\\n\\\n   -include <file>           Include the contents of <file> before other files\\n\\"}, {"sha": "af2b9e93006e0457c7ecba986b91c83f0ac3e87e", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -447,7 +447,7 @@ skip_whitespace (pfile, c)\n \tbreak;\n       c = *buffer->cur++;\n     }\n-  /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0. */\n+  /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0.  */\n   while (is_nvspace (c));\n \n   /* Remember the next character.  */\n@@ -960,7 +960,7 @@ _cpp_lex_token (pfile, result)\n     case '$':\n       if (!CPP_OPTION (pfile, dollars_in_ident))\n \tgoto random_char;\n-      /* Fall through... */\n+      /* Fall through...  */\n \n     case '_':\n     case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':"}, {"sha": "06bf6744ef693db241dba77bee8a6177c42184ff", "filename": "gcc/cpplib.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -154,7 +154,7 @@ SCCS_ENTRY\t\t\t\t\t\t   /* 0 SVR4? */\n    instead of void, because some old compilers have trouble with\n    pointers to functions returning void.  */\n \n-/* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n+/* Don't invoke CONCAT2 with any whitespace or K&R cc will fail.  */\n #define D(name, t, o, f) static void CONCAT2(do_,name) PARAMS ((cpp_reader *));\n DIRECTIVE_TABLE\n #undef D\n@@ -167,7 +167,7 @@ enum\n };\n #undef D\n \n-/* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n+/* Don't invoke CONCAT2 with any whitespace or K&R cc will fail.  */\n #define D(name, t, origin, flags) \\\n { CONCAT2(do_,name), (const U_CHAR *) STRINGX(name), \\\n   sizeof STRINGX(name) - 1, origin, flags },\n@@ -914,7 +914,7 @@ do_ident (pfile)\n    This implementation never macro-expands the text after #pragma.  */\n \n /* Sub-handlers for the pragmas needing treatment here.\n-   They return 1 if the token buffer is to be popped, 0 if not. */\n+   They return 1 if the token buffer is to be popped, 0 if not.  */\n struct pragma_entry\n {\n   struct pragma_entry *next;\n@@ -1647,7 +1647,7 @@ do_unassert (pfile)\n /* Process the string STR as if it appeared as the body of a #define.\n    If STR is just an identifier, define it with value 1.\n    If STR has anything after the identifier, then it should\n-   be identifier=definition. */\n+   be identifier=definition.  */\n \n void\n cpp_define (pfile, str)\n@@ -1696,7 +1696,7 @@ cpp_undef (pfile, macro)\n   run_directive (pfile, T_UNDEF, BUF_CL_OPTION, macro, strlen (macro));\n }\n \n-/* Process the string STR as if it appeared as the body of a #assert. */\n+/* Process the string STR as if it appeared as the body of a #assert.  */\n void\n cpp_assert (pfile, str)\n      cpp_reader *pfile;\n@@ -1705,7 +1705,7 @@ cpp_assert (pfile, str)\n   handle_assertion (pfile, str, T_ASSERT);\n }\n \n-/* Process STR as if it appeared as the body of an #unassert. */\n+/* Process STR as if it appeared as the body of an #unassert.  */\n void\n cpp_unassert (pfile, str)\n      cpp_reader *pfile;"}, {"sha": "dd0d5183d3ae9745126a7df9ce10b78b8db68565", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -1195,7 +1195,7 @@ warn_of_redefinition (pfile, node, macro2)\n     return 0;\n \n   /* Redefinition of a macro is allowed if and only if the old and new\n-     definitions are the same.  (6.10.3 paragraph 2). */\n+     definitions are the same.  (6.10.3 paragraph 2).  */\n   macro1 = node->value.macro;\n \n   /* The quick failures.  */"}, {"sha": "6fdb3a554b8ca9bf4cb195b2d97f75f5f33a9c3e", "filename": "gcc/cppspec.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppspec.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */\n    are errors.  It defaults to -x c for files with unrecognized\n    extensions, unless -x options appear in argv, in which case we\n    assume the user knows what they're doing.  If no explicit input is\n-   mentioned, it will read stdin. */\n+   mentioned, it will read stdin.  */\n \n /* Snarfed from gcc.c: */\n \n@@ -69,7 +69,7 @@ static const char *const known_suffixes[] =\n   NULL\n };\n \n-/* Filter argc and argv before processing by the gcc driver proper. */\n+/* Filter argc and argv before processing by the gcc driver proper.  */\n void\n lang_specific_driver (in_argc, in_argv, in_added_libraries)\n      int *in_argc;\n@@ -92,7 +92,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   int seen_input = 0;\n   \n   /* Positions to insert -xc, -xassembler-with-cpp, and -o, if necessary.\n-     0 means unnecessary. */\n+     0 means unnecessary.  */\n   int lang_c_here = 0;\n   int lang_S_here = 0;\n   int o_here = 0;\n@@ -227,11 +227,11 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   *in_argv = new_argv;\n } \n \n-/* Called before linking.  Returns 0 on success and -1 on failure. */\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n int lang_specific_pre_link ()\n {\n-  return 0;  /* Not used for cpp. */\n+  return 0;  /* Not used for cpp.  */\n }\n \n-/* Number of extra output files that lang_specific_pre_link may generate. */\n-int lang_specific_extra_outfiles = 0;  /* Not used for cpp. */\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+int lang_specific_extra_outfiles = 0;  /* Not used for cpp.  */"}, {"sha": "9f62009ee5889ab74905a14ce155982e49db0f5c", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -556,13 +556,13 @@ STATIC ui32 __FRAME_END__[] __attribute__ ((__unused__)) = { 0 };\n    by putting a constructor in crtbegin.o and a destructor in crtend.o.\n \n    crtend.o also puts in the terminating zero in the frame information\n-   segment. */\n+   segment.  */\n \n /* The crtstuff for other object formats use the symbol __EH_FRAME_BEGIN__\n    to figure out the start of the exception frame, but here we use\n    getsectbynamefromheader to find this value. Either method would work,\n    but this method avoids creating any global symbols, which seems\n-   cleaner. */\n+   cleaner.  */\n \n #include <mach-o/ldsyms.h>\n extern const struct section *\n@@ -600,7 +600,7 @@ __dereg_frame_dtor (void)\n   __deregister_frame_info ((void *) eh_frame->addr);\n }\n \n-/* Terminate the frame section with a final zero. */\n+/* Terminate the frame section with a final zero.  */\n \n /* Force cc1 to switch to .data section.  */\n static void * force_to_data[1] __attribute__ ((__unused__)) = { };"}, {"sha": "a1b13e41fd243093f69ae6bfbae5cf798eb763b1", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -6251,7 +6251,7 @@ cse_insn (insn, libcall_insn)\n \n \t     This section previously turned the REG_EQUIV into a REG_EQUAL\n \t     note.  We cannot do that because REG_EQUIV may provide an\n-\t     uninitialised stack slot when REG_PARM_STACK_SPACE is used. */\n+\t     uninitialised stack slot when REG_PARM_STACK_SPACE is used.  */\n \n \t  if (prev != 0 && GET_CODE (prev) == INSN\n \t      && GET_CODE (PATTERN (prev)) == SET\n@@ -7381,7 +7381,7 @@ check_for_label_ref (rtl, data)\n   /* If this insn uses a LABEL_REF and there isn't a REG_LABEL note for it,\n      we must rerun jump since it needs to place the note.  If this is a\n      LABEL_REF for a CODE_LABEL that isn't in the insn chain, don't do this\n-     since no REG_LABEL will be added. */\n+     since no REG_LABEL will be added.  */\n   return (GET_CODE (*rtl) == LABEL_REF\n \t  && INSN_UID (XEXP (*rtl, 0)) != 0\n \t  && ! find_reg_note (insn, REG_LABEL, XEXP (*rtl, 0)));"}, {"sha": "e8e6beb5bd296d477d930c1d236ae0b47c3f40da", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=ec5c56db8bd075907a7b60d2cfbf225eeb4ecc1f", "patch": "@@ -992,7 +992,7 @@ cselib_mem_conflict_p (mem_base, val)\n   code = GET_CODE (val);\n   switch (code)\n     {\n-      /* Get rid of a few simple cases quickly. */\n+      /* Get rid of a few simple cases quickly.  */\n     case REG:\n     case PC:\n     case CC0:"}]}