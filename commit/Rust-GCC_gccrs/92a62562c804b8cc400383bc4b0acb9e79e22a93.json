{"sha": "92a62562c804b8cc400383bc4b0acb9e79e22a93", "node_id": "C_kwDOANBUbNoAKDkyYTYyNTYyYzgwNGI4Y2M0MDAzODNiYzRiMGFjYjllNzllMjJhOTM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-22T09:36:41Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-23T09:13:06Z"}, "message": "substitute_repetition: Correctly insert sub-fragments", "tree": {"sha": "de007510a541c12da6bd0f52aa2bb6ffec936e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de007510a541c12da6bd0f52aa2bb6ffec936e82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92a62562c804b8cc400383bc4b0acb9e79e22a93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a62562c804b8cc400383bc4b0acb9e79e22a93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a62562c804b8cc400383bc4b0acb9e79e22a93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a62562c804b8cc400383bc4b0acb9e79e22a93/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f546e5e3addda01c5c449833642be8fcdf5dcdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f546e5e3addda01c5c449833642be8fcdf5dcdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f546e5e3addda01c5c449833642be8fcdf5dcdc"}], "stats": {"total": 190, "additions": 119, "deletions": 71}, "files": [{"sha": "b54aa0155a7e58f072b4636265e32d5dce321425", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a62562c804b8cc400383bc4b0acb9e79e22a93/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a62562c804b8cc400383bc4b0acb9e79e22a93/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=92a62562c804b8cc400383bc4b0acb9e79e22a93", "patch": "@@ -3118,7 +3118,7 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n \n   // find matching arm\n   AST::MacroRule *matched_rule = nullptr;\n-  std::map<std::string, MatchedFragment> matched_fragments;\n+  std::map<std::string, std::vector<MatchedFragment>> matched_fragments;\n   for (auto &rule : rules_def.get_rules ())\n     {\n       sub_stack.push ();\n@@ -3127,9 +3127,9 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n \n       if (did_match_rule)\n \t{\n-\t  for (auto &frag : matched_fragments)\n-\t    rust_debug (\"matched fragment: %s\",\n-\t\t\tfrag.second.as_string ().c_str ());\n+\t  for (auto &kv : matched_fragments)\n+\t    rust_debug (\"[fragment]: %s (%ld)\", kv.first.c_str (),\n+\t\t\tkv.second.size ());\n \n \t  matched_rule = &rule;\n \t  break;\n@@ -3535,9 +3535,8 @@ MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n \n \t    // matched fragment get the offset in the token stream\n \t    size_t offs_end = source.get_offs ();\n-\t    sub_stack.peek ().insert (\n-\t      {fragment->get_ident (),\n-\t       MatchedFragment (fragment->get_ident (), offs_begin, offs_end)});\n+\t    sub_stack.insert_fragment (\n+\t      MatchedFragment (fragment->get_ident (), offs_begin, offs_end));\n \t  }\n \t  break;\n \n@@ -3632,10 +3631,9 @@ MacroExpander::match_n_matches (\n \n \t\t// matched fragment get the offset in the token stream\n \t\tsize_t offs_end = source.get_offs ();\n-\t\tsub_stack.peek ().insert (\n-\t\t  {fragment->get_ident (),\n-\t\t   MatchedFragment (fragment->get_ident (), offs_begin,\n-\t\t\t\t    offs_end)});\n+\t\tsub_stack.insert_fragment (\n+\t\t  MatchedFragment (fragment->get_ident (), offs_begin,\n+\t\t\t\t   offs_end));\n \t      }\n \t      break;\n \n@@ -3729,17 +3727,19 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n \t  auto fragment = static_cast<AST::MacroMatchFragment *> (match.get ());\n \t  auto it = stack_map.find (fragment->get_ident ());\n \n-\t  // If we can't find the fragment, but the result was valid, then it's\n-\t  // a zero-matched fragment and we can insert it\n+\t  // If we can't find the fragment, but the result was valid, then\n+\t  // it's a zero-matched fragment and we can insert it\n \t  if (it == stack_map.end ())\n \t    {\n-\t      stack_map.insert (\n-\t\t{fragment->get_ident (),\n-\t\t MatchedFragment::zero (fragment->get_ident ())});\n+\t      sub_stack.insert_fragment (\n+\t\tMatchedFragment::zero (fragment->get_ident ()));\n \t    }\n \t  else\n \t    {\n-\t      it->second.set_match_amount (match_amount);\n+\t      // We can just set the repetition amount on the first match\n+\t      // FIXME: Make this more ergonomic and similar to what we fetch\n+\t      // in `substitute_repetition`\n+\t      it->second[0].set_match_amount (match_amount);\n \t    }\n \t}\n     }\n@@ -3750,8 +3750,8 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n AST::ASTFragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n-  std::map<std::string, MatchedFragment> &matched_fragments, bool semicolon,\n-  ContextType ctx)\n+  std::map<std::string, std::vector<MatchedFragment>> &matched_fragments,\n+  bool semicolon, ContextType ctx)\n {\n   // we can manipulate the token tree to substitute the dollar identifiers so\n   // that when we call parse its already substituted for us\n@@ -3765,10 +3765,10 @@ MacroExpander::transcribe_rule (\n     = substitute_tokens (invoc_stream, macro_rule_tokens, matched_fragments);\n \n   // // handy for debugging\n-  for (auto &tok : substituted_tokens)\n-    {\n-      rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n-    }\n+  // for (auto &tok : substituted_tokens)\n+  //   {\n+  //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n+  //   }\n \n   // parse it to an ASTFragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n@@ -3888,7 +3888,7 @@ MacroExpander::transcribe_rule (\n std::vector<std::unique_ptr<AST::Token>>\n MacroExpander::substitute_metavar (\n   std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::map<std::string, MatchedFragment> &fragments,\n+  std::map<std::string, std::vector<MatchedFragment>> &fragments,\n   std::unique_ptr<AST::Token> &metavar)\n {\n   auto metavar_name = metavar->get_str ();\n@@ -3903,7 +3903,10 @@ MacroExpander::substitute_metavar (\n   else\n     {\n       // Replace\n-      MatchedFragment &frag = it->second;\n+      // We only care about the vector when expanding repetitions. Just access\n+      // the first element of the vector.\n+      // FIXME: Clean this up so it makes more sense\n+      auto &frag = it->second[0];\n       for (size_t offs = frag.token_offset_begin; offs < frag.token_offset_end;\n \t   offs++)\n \t{\n@@ -3919,8 +3922,8 @@ std::vector<std::unique_ptr<AST::Token>>\n MacroExpander::substitute_repetition (\n   std::vector<std::unique_ptr<AST::Token>> &input,\n   std::vector<std::unique_ptr<AST::Token>> &macro,\n-  std::map<std::string, MatchedFragment> &fragments, size_t pattern_start,\n-  size_t pattern_end)\n+  std::map<std::string, std::vector<MatchedFragment>> &fragments,\n+  size_t pattern_start, size_t pattern_end)\n {\n   rust_assert (pattern_end < macro.size ());\n \n@@ -3929,10 +3932,6 @@ MacroExpander::substitute_repetition (\n \n   std::vector<std::unique_ptr<AST::Token>> expanded;\n \n-  for (size_t i = pattern_start; i < pattern_end; i++)\n-    rust_debug (\"[repetition pattern]: %s\",\n-\t\tmacro.at (i)->as_string ().c_str ());\n-\n   // Find the first fragment and get the amount of repetitions that we should\n   // perform\n   size_t repeat_amount = 0;\n@@ -3951,29 +3950,56 @@ MacroExpander::substitute_repetition (\n \t\t  // fragment), we can just error out. No need to paste the\n \t\t  // tokens as if nothing had happened.\n \t\t  rust_error_at (frag_token->get_locus (),\n-\t\t\t\t \"metavar used in repetition does not exist\");\n+\t\t\t\t \"metavar %s used in repetition does not exist\",\n+\t\t\t\t frag_token->get_str ().c_str ());\n+\t\t  // FIXME:\n \t\t  return expanded;\n \t\t}\n \n-\t      repeat_amount = it->second.match_amount;\n+\t      // FIXME: Refactor, ugly\n+\t      repeat_amount = it->second[0].match_amount;\n \t    }\n \t}\n     }\n \n+  rust_debug (\"repetition amount to use: %lu\", repeat_amount);\n   std::vector<std::unique_ptr<AST::Token>> new_macro;\n-  for (size_t tok_idx = pattern_start; tok_idx < pattern_end; tok_idx++)\n-    {\n-      new_macro.emplace_back (macro.at (tok_idx)->clone_token ());\n-      rust_debug (\"new macro token: %s\",\n-\t\t  macro.at (tok_idx)->as_string ().c_str ());\n-    }\n \n-  // FIXME: We have to be careful and not push the repetition token\n-  auto new_tokens = substitute_tokens (input, new_macro, fragments);\n+  // We want to generate a \"new macro\" to substitute with. This new macro\n+  // should contain only the tokens inside the pattern\n+  for (size_t tok_idx = pattern_start; tok_idx < pattern_end; tok_idx++)\n+    new_macro.emplace_back (macro.at (tok_idx)->clone_token ());\n+\n+  // Then, we want to create a subset of the matches so that\n+  // `substitute_tokens()` can only see one fragment per metavar. Let's say we\n+  // have the following user input: (1 145 'h')\n+  // on the following match arm: ($($lit:literal)*)\n+  // which causes the following matches: { \"lit\": [1, 145, 'h'] }\n+  //\n+  // The pattern (new_macro) is `$lit:literal`\n+  // The first time we expand it, we want $lit to have the following token: 1\n+  // The second time, 145\n+  // The third and final time, 'h'\n+  //\n+  // In order to do so we must create \"sub maps\", which only contain parts of\n+  // the original matches\n+  // sub-maps: [ { \"lit\": 1 }, { \"lit\": 145 }, { \"lit\": 'h' } ]\n+  //\n+  // and give them to `substitute_tokens` one by one.\n \n-  rust_debug (\"repetition amount to use: %lu\", repeat_amount);\n   for (size_t i = 0; i < repeat_amount; i++)\n     {\n+      std::map<std::string, std::vector<MatchedFragment>> sub_map;\n+      for (auto &kv_match : fragments)\n+\t{\n+\t  std::vector<MatchedFragment> sub_vec;\n+\t  sub_vec.emplace_back (kv_match.second[i]);\n+\n+\t  sub_map.insert ({kv_match.first, sub_vec});\n+\t}\n+\n+      auto new_tokens = substitute_tokens (input, new_macro, sub_map);\n+\n       for (auto &new_token : new_tokens)\n \texpanded.emplace_back (new_token->clone_token ());\n     }\n@@ -3988,7 +4014,8 @@ std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n MacroExpander::substitute_token (\n   std::vector<std::unique_ptr<AST::Token>> &input,\n   std::vector<std::unique_ptr<AST::Token>> &macro,\n-  std::map<std::string, MatchedFragment> &fragments, size_t token_idx)\n+  std::map<std::string, std::vector<MatchedFragment>> &fragments,\n+  size_t token_idx)\n {\n   auto &token = macro.at (token_idx);\n   switch (token->get_id ())\n@@ -4020,7 +4047,7 @@ MacroExpander::substitute_token (\n \treturn {\n \t  substitute_repetition (input, macro, fragments, pattern_start,\n \t\t\t\t pattern_end),\n-\t  // + 2 for the opening and closing parenthesis which are mandatory\n+\t  // + 2 for the opening and closing parentheses which are mandatory\n \t  // + 1 for the repetitor (+, *, ?)\n \t  pattern_end - pattern_start + 3};\n       }\n@@ -4044,7 +4071,7 @@ std::vector<std::unique_ptr<AST::Token>>\n MacroExpander::substitute_tokens (\n   std::vector<std::unique_ptr<AST::Token>> &input,\n   std::vector<std::unique_ptr<AST::Token>> &macro,\n-  std::map<std::string, MatchedFragment> &fragments)\n+  std::map<std::string, std::vector<MatchedFragment>> &fragments)\n {\n   std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n "}, {"sha": "eeafdb81816ee3de1438f1870b95fc599fc31f5a", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a62562c804b8cc400383bc4b0acb9e79e22a93/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a62562c804b8cc400383bc4b0acb9e79e22a93/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=92a62562c804b8cc400383bc4b0acb9e79e22a93", "patch": "@@ -89,17 +89,38 @@ class SubstitutionScope\n \n   void push () { stack.push_back ({}); }\n \n-  std::map<std::string, MatchedFragment> pop ()\n+  std::map<std::string, std::vector<MatchedFragment>> pop ()\n   {\n     auto top = stack.back ();\n     stack.pop_back ();\n     return top;\n   }\n \n-  std::map<std::string, MatchedFragment> &peek () { return stack.back (); }\n+  std::map<std::string, std::vector<MatchedFragment>> &peek ()\n+  {\n+    return stack.back ();\n+  }\n+\n+  void insert_fragment (MatchedFragment fragment)\n+  {\n+    auto &current_map = stack.back ();\n+    auto it = current_map.find (fragment.fragment_ident);\n+\n+    if (it == current_map.end ())\n+      {\n+\tauto new_frags = std::vector<MatchedFragment> ();\n+\tnew_frags.emplace_back (fragment);\n+\tcurrent_map.insert ({fragment.fragment_ident, new_frags});\n+      }\n+    else\n+      {\n+\tauto &frags = it->second;\n+\tfrags.emplace_back (fragment);\n+      }\n+  }\n \n private:\n-  std::vector<std::map<std::string, MatchedFragment>> stack;\n+  std::vector<std::map<std::string, std::vector<MatchedFragment>>> stack;\n };\n \n // Object used to store shared data (between functions) for macro expansion.\n@@ -151,11 +172,10 @@ struct MacroExpander\n   bool try_match_rule (AST::MacroRule &match_rule,\n \t\t       AST::DelimTokenTree &invoc_token_tree);\n \n-  AST::ASTFragment\n-  transcribe_rule (AST::MacroRule &match_rule,\n-\t\t   AST::DelimTokenTree &invoc_token_tree,\n-\t\t   std::map<std::string, MatchedFragment> &matched_fragments,\n-\t\t   bool semicolon, ContextType ctx);\n+  AST::ASTFragment transcribe_rule (\n+    AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n+    std::map<std::string, std::vector<MatchedFragment>> &matched_fragments,\n+    bool semicolon, ContextType ctx);\n \n   bool match_fragment (Parser<MacroInvocLexer> &parser,\n \t\t       AST::MacroMatchFragment &fragment);\n@@ -204,10 +224,10 @@ struct MacroExpander\n    * @return A token containing the associated fragment expanded into tokens if\n    * any, or the cloned token if no fragment was associated\n    */\n-  static std::vector<std::unique_ptr<AST::Token>>\n-  substitute_metavar (std::vector<std::unique_ptr<AST::Token>> &input,\n-\t\t      std::map<std::string, MatchedFragment> &fragments,\n-\t\t      std::unique_ptr<AST::Token> &metavar);\n+  static std::vector<std::unique_ptr<AST::Token>> substitute_metavar (\n+    std::vector<std::unique_ptr<AST::Token>> &input,\n+    std::map<std::string, std::vector<MatchedFragment>> &fragments,\n+    std::unique_ptr<AST::Token> &metavar);\n \n   /**\n    * Substitute a macro repetition by its given fragments\n@@ -219,11 +239,11 @@ struct MacroExpander\n    *\n    * @return A vector containing the repeated pattern\n    */\n-  static std::vector<std::unique_ptr<AST::Token>>\n-  substitute_repetition (std::vector<std::unique_ptr<AST::Token>> &input,\n-\t\t\t std::vector<std::unique_ptr<AST::Token>> &macro,\n-\t\t\t std::map<std::string, MatchedFragment> &fragments,\n-\t\t\t size_t pattern_start, size_t pattern_end);\n+  static std::vector<std::unique_ptr<AST::Token>> substitute_repetition (\n+    std::vector<std::unique_ptr<AST::Token>> &input,\n+    std::vector<std::unique_ptr<AST::Token>> &macro,\n+    std::map<std::string, std::vector<MatchedFragment>> &fragments,\n+    size_t pattern_start, size_t pattern_end);\n \n   /**\n    * Substitute a given token by its appropriate representation\n@@ -240,15 +260,16 @@ struct MacroExpander\n    * ahead of the input to avoid mis-substitutions\n    */\n   static std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n-  substitute_token (std::vector<std::unique_ptr<AST::Token>> &input,\n-\t\t    std::vector<std::unique_ptr<AST::Token>> &macro,\n-\t\t    std::map<std::string, MatchedFragment> &fragments,\n-\t\t    size_t token_idx);\n-\n-  static std::vector<std::unique_ptr<AST::Token>>\n-  substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,\n-\t\t     std::vector<std::unique_ptr<AST::Token>> &macro,\n-\t\t     std::map<std::string, MatchedFragment> &fragments);\n+  substitute_token (\n+    std::vector<std::unique_ptr<AST::Token>> &input,\n+    std::vector<std::unique_ptr<AST::Token>> &macro,\n+    std::map<std::string, std::vector<MatchedFragment>> &fragments,\n+    size_t token_idx);\n+\n+  static std::vector<std::unique_ptr<AST::Token>> substitute_tokens (\n+    std::vector<std::unique_ptr<AST::Token>> &input,\n+    std::vector<std::unique_ptr<AST::Token>> &macro,\n+    std::map<std::string, std::vector<MatchedFragment>> &fragments);\n \n   void push_context (ContextType t) { context.push_back (t); }\n "}]}