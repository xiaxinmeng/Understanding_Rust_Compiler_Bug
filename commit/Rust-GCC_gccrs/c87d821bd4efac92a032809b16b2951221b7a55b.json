{"sha": "c87d821bd4efac92a032809b16b2951221b7a55b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3ZDgyMWJkNGVmYWM5MmEwMzI4MDliMTZiMjk1MTIyMWI3YTU1Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-10T12:40:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-10T12:40:10Z"}, "message": "re PR c/11449 (ICE in invert_truthvalue called on AND operation)\n\n\tPR c/11449\n\t* fold-const.c (sign_bit_p): Return EXP if VAL is the sign bit\n\tof HOST_WIDE_INT.\n\t(fold_single_bit_test): If sign_bit_p() fails, assume that the\n\tbit being tested is not a sign bit.\n\n\tPR c/11449\n\t* gcc.c-torture/compile/20030707-1.c: New.\n\t* config/h8300/h8300.md (a peephole2): New.\n\nFrom-SVN: r69184", "tree": {"sha": "a8e19967fdd99d0fc53016195487b80ac8f20ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8e19967fdd99d0fc53016195487b80ac8f20ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c87d821bd4efac92a032809b16b2951221b7a55b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87d821bd4efac92a032809b16b2951221b7a55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87d821bd4efac92a032809b16b2951221b7a55b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87d821bd4efac92a032809b16b2951221b7a55b/comments", "author": null, "committer": null, "parents": [{"sha": "bcda12f4f4110d1376d822112c9c00d6287471a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcda12f4f4110d1376d822112c9c00d6287471a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcda12f4f4110d1376d822112c9c00d6287471a6"}], "stats": {"total": 45, "additions": 35, "deletions": 10}, "files": [{"sha": "95a68bcbeee4a7b0324e4800a8d8653cb939b8ad", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87d821bd4efac92a032809b16b2951221b7a55b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87d821bd4efac92a032809b16b2951221b7a55b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c87d821bd4efac92a032809b16b2951221b7a55b", "patch": "@@ -2730,8 +2730,8 @@ all_ones_mask_p (tree mask, int size)\n static tree\n sign_bit_p (tree exp, tree val)\n {\n-  unsigned HOST_WIDE_INT lo;\n-  HOST_WIDE_INT hi;\n+  unsigned HOST_WIDE_INT mask_lo, lo;\n+  HOST_WIDE_INT mask_hi, hi;\n   int width;\n   tree t;\n \n@@ -2750,14 +2750,25 @@ sign_bit_p (tree exp, tree val)\n     {\n       hi = (unsigned HOST_WIDE_INT) 1 << (width - HOST_BITS_PER_WIDE_INT - 1);\n       lo = 0;\n+\n+      mask_hi = ((unsigned HOST_WIDE_INT) -1\n+\t\t >> (2 * HOST_BITS_PER_WIDE_INT - width));\n+      mask_lo = -1;\n     }\n   else\n     {\n       hi = 0;\n       lo = (unsigned HOST_WIDE_INT) 1 << (width - 1);\n+\n+      mask_hi = 0;\n+      mask_lo = ((unsigned HOST_WIDE_INT) -1\n+\t\t >> (HOST_BITS_PER_WIDE_INT - width));\n     }\n \n-  if (TREE_INT_CST_HIGH (val) == hi && TREE_INT_CST_LOW (val) == lo)\n+  /* We mask off those bits beyond TREE_TYPE (exp) so that we can\n+     treat VAL as if it were unsigned.  */\n+  if ((TREE_INT_CST_HIGH (val) & mask_hi) == hi\n+      && (TREE_INT_CST_LOW (val) & mask_lo) == lo)\n     return exp;\n \n   /* Handle extension from a narrower type.  */\n@@ -4840,6 +4851,10 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t\t      convert (stype, arg00),\n \t\t\t      convert (stype, integer_zero_node)));\n \t}\n+\n+      /* At this point, we know that arg0 is not testing the sign bit.  */\n+      if (TYPE_PRECISION (type) - 1 == bitnum)\n+\tabort ();\n       \n       /* Otherwise we have (A & C) != 0 where C is a single bit, \n \t convert that into ((A >> C2) & 1).  Where C2 = log2(C).\n@@ -4861,13 +4876,11 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       /* If we are going to be able to omit the AND below, we must do our\n \t operations as unsigned.  If we must use the AND, we have a choice.\n \t Normally unsigned is faster, but for some machines signed is.  */\n-      ops_unsigned = (bitnum == TYPE_PRECISION (type) - 1 ? 1\n #ifdef LOAD_EXTEND_OP\n-\t\t      : (LOAD_EXTEND_OP (operand_mode) == SIGN_EXTEND ? 0 : 1)\n+      ops_unsigned = (LOAD_EXTEND_OP (operand_mode) == SIGN_EXTEND ? 0 : 1);\n #else\n-\t\t      : 1\n+      ops_unsigned = 1;\n #endif\n-\t\t      );\n \n       signed_type = (*lang_hooks.types.type_for_mode) (operand_mode, 0);\n       unsigned_type = (*lang_hooks.types.type_for_mode) (operand_mode, 1);\n@@ -4881,9 +4894,8 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t       inner, integer_one_node);\n \n       /* Put the AND last so it can combine with more things.  */\n-      if (bitnum != TYPE_PRECISION (type) - 1)\n-\tinner = build (BIT_AND_EXPR, ops_unsigned ? unsigned_type : signed_type,\n-\t\t       inner, integer_one_node);\n+      inner = build (BIT_AND_EXPR, ops_unsigned ? unsigned_type : signed_type,\n+\t\t     inner, integer_one_node);\n \n       /* Make sure to return the proper type.  */\n       if (TREE_TYPE (inner) != result_type)"}, {"sha": "8ce964512bf9c3551fd601260329e7e3f7bef914", "filename": "gcc/testsuite/gcc.c-torture/compile/20030707-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87d821bd4efac92a032809b16b2951221b7a55b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030707-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87d821bd4efac92a032809b16b2951221b7a55b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030707-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20030707-1.c?ref=c87d821bd4efac92a032809b16b2951221b7a55b", "patch": "@@ -0,0 +1,13 @@\n+/* PR c/11449.  */\n+\n+/* sign_bit_p() in fold-const.c failed to notice that (int) 0x80000000\n+   was the sign bit of m.  As a result, fold_single_bit_test()\n+   returned ((unsigned int) m >> 31), and that was eventually passed\n+   to invert_truthvalue(), which did not know how to handle\n+   RROTATE_EXPR, causing an ICE.  */\n+\n+int\n+foo (int m)\n+{\n+  return !(m & ((int) 0x80000000));\n+}"}]}