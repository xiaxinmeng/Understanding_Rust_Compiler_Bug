{"sha": "d0780379c1b621813fbea60449bc51b65f6f8c6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA3ODAzNzljMWI2MjE4MTNmYmVhNjA0NDliYzUxYjY1ZjZmOGM2ZQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-01-22T04:52:16Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2020-05-09T01:29:14Z"}, "message": "gcc/config/cris: Remove shared-library and CRIS v32 support.\n\nPart of the removal of crisv32-* and cris-*-linux* (cris-elf remains).\n\nEssentially everything is gone, including functions and\ntarget-specific definitions and most obvious knock-on effects,\nlike removing unused functions and arguments.\n\nThere's one exception: the register-class effects of the CRIS v32\nACR register are deliberately excluded and left in (i.e. its\nuse by-number is removed and the ACE_REGS regclass is always\nunusable - but present).  Changing register class definitions to\nremove ACR_REGS and related classes (folding their uses into\nremaining classes), causes extra register moves in libgcc (as an\nimmediate observation; actual net effect unknown), which is\nunwanted both for performance reasons and also causing extra\nwork comparing before/after cc0-machinery-conversion changes\nahead.  The actual cause and solution for these negative effects\nof cleaning up the register-classes will at the moment have to\nremain to-be-investigated.\n\nIf CRIS v32 support is reinstated, consider doing the .md part\nnot as separate patterns with opposite conditions but merged\npatterns with necessarily-different alternatives using the\n\"enabled\" attribute (which was not invented back then).\n\nAlso, a single ACR-related RTL-dump example in a cris.md\ncomment, related to a strict_low_part issue is kept, but marked\nas obsolete.\n\nNote that the \"b\" register-constraint (non-ACR registers; can be\nused for post-increment) is left in, as that may have extant\nuses outside of gcc.  Its availability is tested by\ngcc.target/cris/asm-b-1.c.  When ACR register classes are\nremoved, it's probably best to make it equal to GENERAL_REGS.\n\ngcc:\n\t* config/cris: Remove shared-library and CRIS v32 support.", "tree": {"sha": "31262352dd0257b77a99bc044a0a23a67e3d0649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31262352dd0257b77a99bc044a0a23a67e3d0649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0780379c1b621813fbea60449bc51b65f6f8c6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0780379c1b621813fbea60449bc51b65f6f8c6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0780379c1b621813fbea60449bc51b65f6f8c6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0780379c1b621813fbea60449bc51b65f6f8c6e/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e44849e9ef3f44b398dd824f7a4916a486325d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e44849e9ef3f44b398dd824f7a4916a486325d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e44849e9ef3f44b398dd824f7a4916a486325d3"}], "stats": {"total": 2482, "additions": 204, "deletions": 2278}, "files": [{"sha": "28250040d7f7b4719c1bf79127431aafd928eec0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -7,6 +7,7 @@\n \t* config/cris/t-linux, config/cris/linux.h, config/cris/linux.opt:\n \tRemove.\n \t* config/cris/t-elfmulti: Remove crisv32 multilib.\n+\t* config/cris: Remove shared-library and CRIS v32 support.\n \n 2020-05-08  Vladimir Makarov  <vmakarov@redhat.com>\n "}, {"sha": "e177a3c10fd89211a057e3d3481dc91fb1e74a61", "filename": "gcc/config/cris/constraints.md", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fconstraints.md?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -18,9 +18,6 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;; Register constraints.\n-(define_register_constraint \"a\" \"ACR_REGS\"\n-  \"@internal\")\n-\n (define_register_constraint \"b\" \"GENNONACR_REGS\"\n   \"@internal\")\n \n@@ -106,7 +103,7 @@\n        ;; A [reg] or (int) [reg], maybe with post-increment.\n        (match_test \"cris_bdap_index_p (op, reload_in_progress\n \t\t\t\t\t   || reload_completed)\")\n-       (match_test \"cris_constant_index_p (op)\")))\n+       (match_test \"CONSTANT_P (op)\")))\n \n (define_constraint \"T\"\n   \"Memory three-address operand.\"\n@@ -118,14 +115,14 @@\n \t\t\t\t\t\t       reload_in_progress\n \t\t\t\t\t\t       || reload_completed)\"))\n \t    ;; Just an explicit indirect reference: [const]?\n-\t    (match_test \"CRIS_CONSTANT_P (XEXP (op, 0))\")\n+\t    (match_test \"CONSTANT_P (XEXP (op, 0))\")\n \t    ;; Something that is indexed; [...+...]?\n \t    (and (match_code \"plus\" \"0\")\n \t\t      ;; A BDAP constant: [reg+(8|16|32)bit offset]?\n \t\t (ior (and (match_test \"cris_base_p (XEXP (XEXP (op, 0), 0),\n \t\t\t\t\t\t     reload_in_progress\n \t\t\t\t\t\t     || reload_completed)\")\n-\t\t\t   (match_test \"cris_constant_index_p (XEXP (XEXP (op, 0), 1))\"))\n+\t\t\t   (match_test \"CONSTANT_P (XEXP (XEXP (op, 0), 1))\"))\n \t\t      ;; A BDAP register: [reg+[reg(+)].S]?\n \t\t      (and (match_test \"cris_base_p (XEXP (XEXP (op, 0), 0),\n \t\t\t\t\t\t     reload_in_progress\n@@ -149,18 +146,3 @@\n \t\t\t   (match_test \"cris_biap_index_p (XEXP (XEXP (op, 0), 0),\n \t\t\t\t\t\t\t   reload_in_progress\n \t\t\t\t\t\t\t   || reload_completed)\")))))))\n-\n-(define_constraint \"S\"\n-  \"PIC-constructs for symbols.\"\n-  (and (match_test \"flag_pic\")\n-       (match_code \"const\")\n-       (match_test \"cris_valid_pic_const (op, false)\")))\n-\n-(define_constraint \"U\"\n-  \"@internal\"\n-  (and (match_test \"flag_pic\")\n-       ;; We're just interested in the ..._or_callable_symbol part.\n-       ;; (Using CRIS_CONSTANT_P would exclude that too.)\n-       (match_test \"CONSTANT_P (op)\")\n-       (match_operand 0 \"cris_nonmemory_operand_or_callable_symbol\")))\n-"}, {"sha": "f78eba45ea0d9aed722b796f2e97579eb508af49", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -27,14 +27,8 @@ extern void cris_notice_update_cc (rtx, rtx_insn *);\n extern bool cris_reload_address_legitimized (rtx, machine_mode, int, int, int);\n extern int cris_side_effect_mode_ok (enum rtx_code, rtx *, int, int,\n                                      int, int, int);\n-extern bool cris_cc0_user_requires_cmp (rtx_insn *);\n extern rtx cris_return_addr_rtx (int, rtx);\n extern rtx cris_split_movdx (rtx *);\n-extern int cris_legitimate_pic_operand (rtx);\n-extern enum cris_symbol_type cris_symbol_type_of (const_rtx);\n-extern bool cris_valid_pic_const (const_rtx, bool);\n-extern bool cris_legitimate_constant_p (machine_mode, rtx);\n-extern bool cris_constant_index_p (const_rtx);\n extern bool cris_base_p (const_rtx, bool);\n extern bool cris_base_or_autoincr_p (const_rtx, bool);\n extern bool cris_bdap_index_p (const_rtx, bool);\n@@ -44,11 +38,9 @@ extern bool cris_legitimate_address_p (machine_mode, rtx, bool);\n extern bool cris_store_multiple_op_p (rtx);\n extern bool cris_movem_load_rest_p (rtx, int);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);\n-extern int cris_cfun_uses_pic_table (void);\n extern void cris_asm_output_case_end (FILE *, int, rtx_insn *);\n extern rtx cris_gen_movem_load (rtx, rtx, int);\n extern rtx cris_emit_movem_store (rtx, rtx, int, bool);\n-extern void cris_expand_pic_call_address (rtx *, rtx *);\n extern void cris_order_for_addsi3 (rtx *, int);\n extern void cris_emit_trap_for_misalignment (rtx);\n #endif /* RTX_CODE */"}, {"sha": "6f7cdaee66ea090b9e23cd7153a49d917fea3036", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 50, "deletions": 804, "changes": 854, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -116,16 +116,14 @@ static int cris_initial_frame_pointer_offset (void);\n \n static void cris_operand_lossage (const char *, rtx);\n \n-static int cris_reg_saved_in_regsave_area  (unsigned int, bool);\n+static int cris_reg_saved_in_regsave_area  (unsigned int);\n \n static void cris_print_operand (FILE *, rtx, int);\n \n static void cris_print_operand_address (FILE *, machine_mode, rtx);\n \n static bool cris_print_operand_punct_valid_p (unsigned char code);\n \n-static bool cris_output_addr_const_extra (FILE *, rtx);\n-\n static void cris_conditional_register_usage (void);\n \n static void cris_asm_output_mi_thunk\n@@ -152,7 +150,6 @@ static void cris_function_arg_advance (cumulative_args_t,\n static rtx_insn *cris_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n \t\t\t\t     vec<const char *> &,\n \t\t\t\t     vec<rtx> &, HARD_REG_SET &);\n-static bool cris_cannot_force_const_mem (machine_mode, rtx);\n \n static void cris_option_override (void);\n \n@@ -164,7 +161,6 @@ static void cris_trampoline_init (rtx, tree, rtx);\n static rtx cris_function_value(const_tree, const_tree, bool);\n static rtx cris_libcall_value (machine_mode, const_rtx);\n static bool cris_function_value_regno_p (const unsigned int);\n-static void cris_file_end (void);\n static unsigned int cris_hard_regno_nregs (unsigned int, machine_mode);\n static bool cris_hard_regno_mode_ok (unsigned int, machine_mode);\n static HOST_WIDE_INT cris_static_rtx_alignment (machine_mode);\n@@ -202,8 +198,6 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #define TARGET_PRINT_OPERAND_ADDRESS cris_print_operand_address\n #undef TARGET_PRINT_OPERAND_PUNCT_VALID_P\n #define TARGET_PRINT_OPERAND_PUNCT_VALID_P cris_print_operand_punct_valid_p\n-#undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA\n-#define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA cris_output_addr_const_extra\n \n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE cris_conditional_register_usage\n@@ -215,8 +209,6 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n \n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START cris_file_start\n-#undef TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END cris_file_end\n \n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS cris_init_libfuncs\n@@ -227,9 +219,6 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P cris_legitimate_address_p\n \n-#undef TARGET_LEGITIMATE_CONSTANT_P\n-#define TARGET_LEGITIMATE_CONSTANT_P cris_legitimate_constant_p\n-\n #undef TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS cris_preferred_reload_class\n \n@@ -268,9 +257,6 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_MD_ASM_ADJUST\n #define TARGET_MD_ASM_ADJUST cris_md_asm_adjust\n \n-#undef TARGET_CANNOT_FORCE_CONST_MEM\n-#define TARGET_CANNOT_FORCE_CONST_MEM cris_cannot_force_const_mem\n-\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED cris_frame_pointer_required\n \n@@ -342,11 +328,8 @@ cris_movem_load_rest_p (rtx op, int offs)\n   else\n     i = offs + 1;\n \n-  if (!TARGET_V32)\n-    {\n-      regno_dir = -1;\n-      regno = reg_count - 1;\n-    }\n+  regno_dir = -1;\n+  regno = reg_count - 1;\n \n   elt = XVECEXP (op, 0, offs);\n   src_addr = XEXP (SET_SRC (elt), 0);\n@@ -446,11 +429,8 @@ cris_store_multiple_op_p (rtx op)\n   else\n     i = 1;\n \n-  if (!TARGET_V32)\n-    {\n-      regno_dir = -1;\n-      regno = reg_count - 1;\n-    }\n+  regno_dir = -1;\n+  regno = reg_count - 1;\n \n   if (GET_CODE (elt) != SET\n       || !REG_P (SET_SRC (elt))\n@@ -501,26 +481,6 @@ cris_store_multiple_op_p (rtx op)\n static void\n cris_conditional_register_usage (void)\n {\n-  /* FIXME: This isn't nice.  We should be able to use that register for\n-     something else if the PIC table isn't needed.  */\n-  if (flag_pic)\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\n-      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n-\n-  /* Allow use of ACR (PC in pre-V32) and tweak order.  */\n-  if (TARGET_V32)\n-    {\n-      static const int reg_alloc_order_v32[] = REG_ALLOC_ORDER_V32;\n-      unsigned int i;\n-\n-      fixed_regs[CRIS_ACR_REGNUM] = 0;\n-\n-      for (i = 0;\n-          i < sizeof (reg_alloc_order_v32)/sizeof (reg_alloc_order_v32[0]);\n-          i++)\n-       reg_alloc_order[i] = reg_alloc_order_v32[i];\n-    }\n-\n   if (TARGET_HAS_MUL_INSNS)\n     fixed_regs[CRIS_MOF_REGNUM] = 0;\n \n@@ -530,30 +490,6 @@ cris_conditional_register_usage (void)\n     reg_names[CRIS_CC0_REGNUM] = \"ccr\";\n }\n \n-/* Return crtl->uses_pic_offset_table.  For use in cris.md,\n-   since some generated files do not include function.h.  */\n-\n-int\n-cris_cfun_uses_pic_table (void)\n-{\n-  return crtl->uses_pic_offset_table;\n-}\n-\n-/* Worker function for TARGET_CANNOT_FORCE_CONST_MEM.\n-   We can't put PIC addresses in the constant pool, not even the ones that\n-   can be reached as pc-relative as we can't tell when or how to do that.  */\n-\n-static bool\n-cris_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n-{\n-  enum cris_symbol_type t = cris_symbol_type_of (x);\n-\n-  return\n-    t == cris_unspec\n-    || t == cris_got_symbol\n-    || t == cris_rel_symbol;\n-}\n-\n /* Given an rtx, return the text string corresponding to the CODE of X.\n    Intended for use in the assembly language output section of a\n    define_insn.  */\n@@ -637,7 +573,7 @@ cris_print_index (rtx index, FILE *file)\n \n   if (REG_P (index))\n     fprintf (file, \"$%s.b\", reg_names[REGNO (index)]);\n-  else if (CRIS_CONSTANT_P (index))\n+  else if (CONSTANT_P (index))\n     cris_output_addr_const (file, index);\n   else if (GET_CODE (index) == MULT)\n     {\n@@ -685,10 +621,7 @@ cris_print_base (rtx base, FILE *file)\n   if (REG_P (base))\n     fprintf (file, \"$%s\", reg_names[REGNO (base)]);\n   else if (GET_CODE (base) == POST_INC)\n-    {\n-      gcc_assert (REGNO (XEXP (base, 0)) != CRIS_ACR_REGNUM);\n-      fprintf (file, \"$%s+\", reg_names[REGNO (XEXP (base, 0))]);\n-    }\n+    fprintf (file, \"$%s+\", reg_names[REGNO (XEXP (base, 0))]);\n   else\n     cris_operand_lossage (\"unexpected base-type in cris_print_base\",\n \t\t\t  base);\n@@ -712,17 +645,11 @@ cris_fatal (char *arg)\n    wrapper for a complicated conditional.  */\n \n static int\n-cris_reg_saved_in_regsave_area (unsigned int regno, bool got_really_used)\n+cris_reg_saved_in_regsave_area (unsigned int regno)\n {\n   return\n     (((df_regs_ever_live_p (regno)\n-       && !call_used_or_fixed_reg_p (regno))\n-      || (regno == PIC_OFFSET_TABLE_REGNUM\n-\t  && (got_really_used\n-\t      /* It is saved anyway, if there would be a gap.  */\n-\t      || (flag_pic\n-\t\t  && df_regs_ever_live_p (regno + 1)\n-\t\t  && !call_used_or_fixed_reg_p (regno + 1)))))\n+       && !call_used_or_fixed_reg_p (regno)))\n      && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n      && regno != CRIS_SRP_REGNUM)\n     || (crtl->calls_eh_return\n@@ -866,16 +793,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n       putc (INTVAL (x) >= -128 && INTVAL (x) <= 255 ? 'b' : 'w', file);\n       return;\n \n-    case 'Z':\n-      /* If this is a GOT-symbol, print the size-letter corresponding to\n-\t -fpic/-fPIC.  For everything else, print \"d\".  */\n-      putc ((flag_pic == 1\n-\t     && GET_CODE (x) == CONST\n-\t     && GET_CODE (XEXP (x, 0)) == UNSPEC\n-\t     && XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREAD)\n-\t    ? 'w' : 'd', file);\n-      return;\n-\n     case '#':\n       /* Output a 'nop' if there's nothing for the delay slot.\n \t This method stolen from the sparc files.  */\n@@ -900,13 +817,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t       : \".p2alignw 5,0x050f,2\\n\\t\", file);\n       return;\n \n-    case ':':\n-      /* The PIC register.  */\n-      if (! flag_pic)\n-\tinternal_error (\"invalid use of %<:%> modifier\");\n-      fprintf (file, \"$%s\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n-      return;\n-\n     case 'H':\n       /* Print high (most significant) part of something.  */\n       switch (GET_CODE (operand))\n@@ -1073,21 +983,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n \tfprintf (file, \".d\");\n       return;\n \n-    case 'd':\n-      /* If this is a GOT symbol, force it to be emitted as :GOT and\n-\t :GOTPLT regardless of -fpic (i.e. not as :GOT16, :GOTPLT16).\n-\t Avoid making this too much of a special case.  */\n-      if (flag_pic == 1 && CRIS_CONSTANT_P (operand))\n-\t{\n-\t  int flag_pic_save = flag_pic;\n-\n-\t  flag_pic = 2;\n-\t  cris_output_addr_const (file, operand);\n-\t  flag_pic = flag_pic_save;\n-\t  return;\n-\t}\n-      break;\n-\n     case 'D':\n       /* When emitting an sub for the high part of a DImode constant, we\n \t want to use subq for 0 and subs.w for -1.  */\n@@ -1110,17 +1005,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n       fprintf (file, \"%s\", mults[INTVAL (operand)]);\n       return;\n \n-    case 'u':\n-      /* Print \"u.w\" if a GOT symbol and flag_pic == 1, else \".d\".  */\n-      if (flag_pic == 1\n-\t  && GET_CODE (operand) == CONST\n-\t  && GET_CODE (XEXP (operand, 0)) == UNSPEC\n-\t  && XINT (XEXP (operand, 0), 1) == CRIS_UNSPEC_GOTREAD)\n-\tfprintf (file, \"u.w\");\n-      else\n-\tfprintf (file, \".d\");\n-      return;\n-\n     case 0:\n       /* No code, print as usual.  */\n       break;\n@@ -1162,8 +1046,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t}\n       return;\n \n-    case UNSPEC:\n-      /* Fall through.  */\n     case CONST:\n       cris_output_addr_const (file, operand);\n       return;\n@@ -1194,7 +1076,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     default:\n       /* No need to handle all strange variants, let output_addr_const\n \t do it for us.  */\n-      if (CRIS_CONSTANT_P (operand))\n+      if (CONSTANT_P (operand))\n \t{\n \t  cris_output_addr_const (file, operand);\n \t  return;\n@@ -1207,7 +1089,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n static bool\n cris_print_operand_punct_valid_p (unsigned char code)\n {\n-  return (code == '#' || code == '!' || code == ':');\n+  return (code == '#' || code == '!');\n }\n \n /* The PRINT_OPERAND_ADDRESS worker.  */\n@@ -1304,20 +1186,10 @@ cris_initial_frame_pointer_offset (void)\n \n   /* Initial offset is 0 if we don't have a frame pointer.  */\n   int offs = 0;\n-  bool got_really_used = false;\n-\n-  if (crtl->uses_pic_offset_table)\n-    {\n-      push_topmost_sequence ();\n-      got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (),\n-\t\t\t      NULL);\n-      pop_topmost_sequence ();\n-    }\n \n   /* And 4 for each register pushed.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+    if (cris_reg_saved_in_regsave_area (regno))\n       offs += 4;\n \n   /* And then, last, we add the locals allocated.  */\n@@ -1384,15 +1256,6 @@ reg_ok_for_index_p (const_rtx x, bool strict)\n   return reg_ok_for_base_p (x, strict);\n }\n \n-/* No symbol can be used as an index (or more correct, as a base) together\n-   with a register with PIC; the PIC register must be there.  */\n-\n-bool\n-cris_constant_index_p (const_rtx x)\n-{\n-  return (CRIS_CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));\n-}\n-\n /* True if X is a valid base register.  */\n \n bool\n@@ -1416,8 +1279,7 @@ cris_base_or_autoincr_p (const_rtx x, bool strict)\n {\n   return (cris_base_p (x, strict)\n \t  || (GET_CODE (x) == POST_INC\n-\t      && cris_base_p (XEXP (x, 0), strict)\n-\t      && REGNO (XEXP (x, 0)) != CRIS_ACR_REGNUM));\n+\t      && cris_base_p (XEXP (x, 0), strict)));\n }\n \n /* True if X is a valid (register) index for BDAP, i.e. [Rs].S or [Rs+].S.  */\n@@ -1446,14 +1308,7 @@ cris_biap_index_p (const_rtx x, bool strict)\n \t      && cris_scale_int_operand (XEXP (x, 1), VOIDmode)));\n }\n \n-/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.\n-\n-   A PIC operand looks like a normal symbol here.  At output we dress it\n-   in \"[rPIC+symbol:GOT]\" (global symbol) or \"rPIC+symbol:GOTOFF\" (local\n-   symbol) so we exclude all addressing modes where we can't replace a\n-   plain \"symbol\" with that.  A global PIC symbol does not fit anywhere\n-   here (but is thankfully a general_operand in itself).  A local PIC\n-   symbol is valid for the plain \"symbol + offset\" case.  */\n+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */\n \n bool\n cris_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n@@ -1462,19 +1317,16 @@ cris_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \n   if (cris_base_or_autoincr_p (x, strict))\n     return true;\n-  else if (TARGET_V32)\n-    /* Nothing else is valid then.  */\n-    return false;\n-  else if (cris_constant_index_p (x))\n+  else if (CONSTANT_P (x))\n     return true;\n   /* Indexed?  */\n   else if (GET_CODE (x) == PLUS)\n     {\n       x1 = XEXP (x, 0);\n       x2 = XEXP (x, 1);\n       /* BDAP o, Rd.  */\n-      if ((cris_base_p (x1, strict) && cris_constant_index_p (x2))\n-\t  || (cris_base_p (x2, strict) && cris_constant_index_p (x1))\n+      if ((cris_base_p (x1, strict) && CONSTANT_P (x2))\n+\t  || (cris_base_p (x2, strict) && CONSTANT_P (x1))\n \t   /* BDAP Rs[+], Rd.  */\n \t  || (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t      && ((cris_base_p (x1, strict)\n@@ -1499,29 +1351,6 @@ cris_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n   return false;\n }\n \n-/* Worker function for TARGET_LEGITIMATE_CONSTANT_P.  We have to handle\n-   PIC constants that aren't legitimized.  FIXME: there used to be a\n-   guarantee that the target LEGITIMATE_CONSTANT_P didn't have to handle\n-   PIC constants, but no more (4.7 era); testcase: glibc init-first.c.\n-   While that may be seen as a bug, that guarantee seems a wart by design,\n-   so don't bother; fix the documentation instead.  */\n-\n-bool\n-cris_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n-{\n-  enum cris_symbol_type t;\n-\n-  if (flag_pic)\n-    return LEGITIMATE_PIC_OPERAND_P (x);\n-\n-  t = cris_symbol_type_of (x);\n-\n-  return\n-    t == cris_no_symbol\n-    || t == cris_offsettable_symbol\n-    || t == cris_unspec;\n-}\n-\n /* Worker function for LEGITIMIZE_RELOAD_ADDRESS.  */\n \n bool\n@@ -1538,9 +1367,6 @@ cris_reload_address_legitimized (rtx x,\n   if (GET_CODE (x) != PLUS)\n     return false;\n \n-  if (TARGET_V32)\n-    return false;\n-\n   op0 = XEXP (x, 0);\n   op1 = XEXP (x, 1);\n   op1p = &XEXP (x, 1);\n@@ -1689,7 +1515,7 @@ cris_normal_notice_update_cc (rtx exp, rtx insn)\n \n      (set (reg) (...)):\n      CC is (reg) and (...) - unless (...) is 0 or reg is a special\n-        register or (v32 and (...) is -32..-1), then CC does not change.\n+\tregister, then CC does not change.\n      CC_NO_OVERFLOW unless (...) is reg or mem.\n \n      (set (mem) (...)):\n@@ -1806,10 +1632,7 @@ cris_normal_notice_update_cc (rtx exp, rtx insn)\n \t  else if (SET_SRC (exp) == const0_rtx\n \t\t   || (REG_P (SET_SRC (exp))\n \t\t       && (REGNO (SET_SRC (exp))\n-\t\t\t   > CRIS_LAST_GENERAL_REGISTER))\n-\t\t   || (TARGET_V32\n-\t\t       && REG_P (SET_DEST (exp))\n-\t\t       && satisfies_constraint_I (SET_SRC (exp))))\n+\t\t\t   > CRIS_LAST_GENERAL_REGISTER)))\n \t    {\n \t      /* There's no CC0 change for this case.  Just check\n \t\t for overlap.  */\n@@ -1841,11 +1664,6 @@ cris_normal_notice_update_cc (rtx exp, rtx insn)\n \t\t  || GET_CODE (SET_SRC (exp)) == NEG)\n \t\tcc_status.flags |= CC_NO_OVERFLOW;\n \n-\t      /* For V32, nothing with a register destination sets\n-\t\t C and V usefully.  */\n-\t      if (TARGET_V32)\n-\t\tcc_status.flags |= CC_NO_OVERFLOW;\n-\n \t      return;\n \t    }\n \t}\n@@ -1889,10 +1707,6 @@ cris_normal_notice_update_cc (rtx exp, rtx insn)\n \t      if (cris_reg_overlap_mentioned_p (cc_status.value1,\n \t\t\t\t\t\tcc_status.value2))\n \t\tinternal_error (\"internal error: sideeffect-insn affecting main effect\");\n-\n-\t      /* For V32, moves to registers don't set C and V.  */\n-\t      if (TARGET_V32)\n-\t\tcc_status.flags |= CC_NO_OVERFLOW;\n \t      return;\n \t    }\n \t  else if ((REG_P (XEXP (XVECEXP (exp, 0, 0), 1))\n@@ -1972,16 +1786,8 @@ cris_notice_update_cc (rtx exp, rtx_insn *insn)\n       return;\n \n     case CC_REV:\n-    case CC_NOOV32:\n     case CC_NORMAL:\n       cris_normal_notice_update_cc (exp, insn);\n-\n-      /* The \"test\" insn doesn't clear (carry and) overflow on V32.  We\n-        can change bge => bpl and blt => bmi by passing on to the cc0\n-        user that V should not be considered; bgt and ble are taken\n-        care of by other methods (see {tst,cmp}{si,hi,qi}).  */\n-      if (attrval == CC_NOOV32 && TARGET_V32)\n-\tcc_status.flags |= CC_NO_OVERFLOW;\n       return;\n \n     default:\n@@ -2000,7 +1806,6 @@ cris_simple_epilogue (void)\n {\n   unsigned int regno;\n   unsigned int reglimit = STACK_POINTER_REGNUM;\n-  bool got_really_used = false;\n \n   if (! reload_completed\n       || frame_pointer_needed\n@@ -2015,21 +1820,9 @@ cris_simple_epilogue (void)\n       || !TARGET_PROLOGUE_EPILOGUE)\n     return false;\n \n-  /* Can't return from stacked return address with v32.  */\n-  if (TARGET_V32 && cris_return_address_on_stack ())\n-    return false;\n-\n-  if (crtl->uses_pic_offset_table)\n-    {\n-      push_topmost_sequence ();\n-      got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL);\n-      pop_topmost_sequence ();\n-    }\n-\n   /* No simple epilogue if there are saved registers.  */\n   for (regno = 0; regno < reglimit; regno++)\n-    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+    if (cris_reg_saved_in_regsave_area (regno))\n       return false;\n \n   return true;\n@@ -2273,7 +2066,7 @@ cris_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n \treturn (2 + 2) / 2;\n \n       /* A BDAP with some other constant is 2 bytes extra.  */\n-      if (CRIS_CONSTANT_P (tem2))\n+      if (CONSTANT_P (tem2))\n \treturn (2 + 2 + 2) / 2;\n \n       /* BDAP with something indirect should have a higher cost than\n@@ -2371,7 +2164,7 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n \treturn 0;\n \n       /* Check allowed cases, like [r(+)?].[bwd] and const.  */\n-      if (CRIS_CONSTANT_P (val_rtx))\n+      if (CONSTANT_P (val_rtx))\n \treturn 1;\n \n       if (MEM_P (val_rtx)\n@@ -2415,49 +2208,6 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n   internal_error (\"internal error: cris_side_effect_mode_ok with bad operands\");\n }\n \n-/* Whether next_cc0_user of insn is LE or GT or requires a real compare\n-   insn for other reasons.  */\n-\n-bool\n-cris_cc0_user_requires_cmp (rtx_insn *insn)\n-{\n-  rtx_insn *cc0_user = NULL;\n-  rtx body;\n-  rtx set;\n-\n-  gcc_assert (insn != NULL);\n-\n-  if (!TARGET_V32)\n-    return false;\n-\n-  cc0_user = next_cc0_user (insn);\n-  if (cc0_user == NULL)\n-    return false;\n-\n-  body = PATTERN (cc0_user);\n-  set = single_set (cc0_user);\n-\n-  /* Users can be sCC and bCC.  */\n-  if (JUMP_P (cc0_user)\n-      && GET_CODE (body) == SET\n-      && SET_DEST (body) == pc_rtx\n-      && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n-      && XEXP (XEXP (SET_SRC (body), 0), 0) == cc0_rtx)\n-    {\n-      return\n-\tGET_CODE (XEXP (SET_SRC (body), 0)) == GT\n-\t|| GET_CODE (XEXP (SET_SRC (body), 0)) == LE;\n-    }\n-  else if (set)\n-    {\n-      return\n-\tGET_CODE (SET_SRC (body)) == GT\n-\t|| GET_CODE (SET_SRC (body)) == LE;\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n /* The function reg_overlap_mentioned_p in CVS (still as of 2001-05-16)\n    does not handle the case where the IN operand is strict_low_part; it\n    does handle it for X.  Test-case in Axis-20010516.  This function takes\n@@ -2475,114 +2225,6 @@ cris_reg_overlap_mentioned_p (rtx x, rtx in)\n   return reg_overlap_mentioned_p (x, in);\n }\n \n-/* Return TRUE iff X is a CONST valid for e.g. indexing.\n-   ANY_OPERAND is 0 if X is in a CALL_P insn or movsi, 1\n-   elsewhere.  */\n-\n-bool\n-cris_valid_pic_const (const_rtx x, bool any_operand)\n-{\n-  gcc_assert (flag_pic);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return true;\n-    default:\n-      ;\n-    }\n-\n-  if (GET_CODE (x) != CONST)\n-    return false;\n-\n-  x = XEXP (x, 0);\n-\n-  /* Handle (const (plus (unspec .. UNSPEC_GOTREL) (const_int ...))).  */\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == UNSPEC\n-      && (XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREL\n-\t  || XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_PCREL)\n-      && CONST_INT_P (XEXP (x, 1)))\n-    x = XEXP (x, 0);\n-\n-  if (GET_CODE (x) == UNSPEC)\n-    switch (XINT (x, 1))\n-      {\n-\t/* A PCREL operand is only valid for call and movsi.  */\n-      case CRIS_UNSPEC_PLT_PCREL:\n-      case CRIS_UNSPEC_PCREL:\n-\treturn !any_operand;\n-\n-      case CRIS_UNSPEC_PLT_GOTREL:\n-      case CRIS_UNSPEC_PLTGOTREAD:\n-      case CRIS_UNSPEC_GOTREAD:\n-      case CRIS_UNSPEC_GOTREL:\n-\treturn true;\n-      default:\n-\tgcc_unreachable ();\n-      }\n-\n-  return cris_symbol_type_of (x) == cris_no_symbol;\n-}\n-\n-/* Helper function to find the right symbol-type to generate,\n-   given the original (non-PIC) representation.  */\n-\n-enum cris_symbol_type\n-cris_symbol_type_of (const_rtx x)\n-{\n-  switch (GET_CODE (x))\n-    {\n-    case SYMBOL_REF:\n-      return flag_pic\n-\t? (SYMBOL_REF_LOCAL_P (x)\n-\t   ? cris_rel_symbol : cris_got_symbol)\n-\t: cris_offsettable_symbol;\n-\n-    case LABEL_REF:\n-      return flag_pic ? cris_rel_symbol : cris_offsettable_symbol;\n-\n-    case CONST:\n-      return cris_symbol_type_of (XEXP (x, 0));\n-\n-    case PLUS:\n-    case MINUS:\n-      {\n-\tenum cris_symbol_type t1 = cris_symbol_type_of (XEXP (x, 0));\n-\tenum cris_symbol_type t2 = cris_symbol_type_of (XEXP (x, 1));\n-\n-\tgcc_assert (t1 == cris_no_symbol || t2 == cris_no_symbol);\n-\n-\tif (t1 == cris_got_symbol || t2 == cris_got_symbol)\n-\t  return cris_got_symbol_needing_fixup;\n-\n-\treturn t1 != cris_no_symbol ? t1 : t2;\n-      }\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return cris_no_symbol;\n-\n-    case UNSPEC:\n-      return cris_unspec;\n-\n-    default:\n-      fatal_insn (\"unrecognized supposed constant\", x);\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n-/* The LEGITIMATE_PIC_OPERAND_P worker.  */\n-\n-int\n-cris_legitimate_pic_operand (rtx x)\n-{\n-  /* Symbols are not valid PIC operands as-is; just constants.  */\n-  return cris_valid_pic_const (x, true);\n-}\n-\n /* Queue an .ident string in the queue of top-level asm statements.\n    If the front-end is done, we must be being called from toplev.c.\n    In that case, do nothing.  */\n@@ -2604,31 +2246,13 @@ cris_asm_output_case_end (FILE *stream, int num, rtx_insn *table)\n      assert that we find only what's expected.  */\n   rtx_insn *whole_jump_insn = prev_nonnote_nondebug_insn (table);\n   gcc_assert (whole_jump_insn != NULL_RTX && LABEL_P (whole_jump_insn));\n+\n   whole_jump_insn = prev_nonnote_nondebug_insn (whole_jump_insn);\n-  gcc_assert (whole_jump_insn != NULL_RTX\n-\t      && (JUMP_P (whole_jump_insn)\n-\t\t  || (TARGET_V32 && INSN_P (whole_jump_insn)\n-\t\t      && GET_CODE (PATTERN (whole_jump_insn)) == SEQUENCE)));\n+  gcc_assert (whole_jump_insn != NULL_RTX && JUMP_P (whole_jump_insn));\n+\n   /* Get the pattern of the casejump, so we can extract the default label.  */\n   rtx whole_jump_pat = PATTERN (whole_jump_insn);\n \n-  if (TARGET_V32)\n-    {\n-      /* This can be a SEQUENCE, meaning the delay-slot of the jump is\n-\t filled.  We also output the offset word a little differently.  */\n-      rtx parallel_jump\n-\t= (GET_CODE (whole_jump_pat) == SEQUENCE\n-\t   ? PATTERN (XVECEXP (whole_jump_pat, 0, 0)) : whole_jump_pat);\n-\n-      asm_fprintf (stream,\n-\t\t   \"\\t.word %LL%d-.%s\\n\",\n-\t\t   CODE_LABEL_NUMBER (XEXP (XEXP (XEXP (XVECEXP\n-\t\t\t\t\t\t\t(parallel_jump, 0, 0),\n-\t\t\t\t\t\t\t1), 2), 0)),\n-\t\t   (TARGET_PDEBUG ? \"; default\" : \"\"));\n-      return;\n-    }\n-\n   asm_fprintf (stream,\n \t       \"\\t.word %LL%d-%LL%d%s\\n\",\n \t       CODE_LABEL_NUMBER (XEXP\n@@ -2679,7 +2303,7 @@ cris_option_override (void)\n \t  || strcmp (\"etrax100lx\", cris_cpu_str) == 0)\n \tcris_cpu_version = 10;\n \n-      if (cris_cpu_version < 0 || cris_cpu_version > 32)\n+      if (cris_cpu_version < 0 || cris_cpu_version > 10)\n \terror (\"unknown CRIS version specification in %<-march=%> or \"\n \t       \"%<-mcpu=%> : %s\", cris_cpu_str);\n \n@@ -2727,28 +2351,13 @@ cris_option_override (void)\n \t      | MASK_DATA_ALIGN | MASK_ALIGN_BY_32);\n     }\n \n-  if (cris_cpu_version >= CRIS_CPU_V32)\n-    target_flags &= ~(MASK_SIDE_EFFECT_PREFIXES|MASK_MUL_BUG);\n-\n   if (flag_pic)\n     {\n       /* Use error rather than warning, so invalid use is easily\n \t detectable.  Still change to the values we expect, to avoid\n \t further errors.  */\n-      if (! TARGET_LINUX)\n-\t{\n-\t  error (\"%<-fPIC%> and %<-fpic%> are not supported \"\n-\t\t \"in this configuration\");\n-\t  flag_pic = 0;\n-\t}\n-\n-      /* Turn off function CSE.  We need to have the addresses reach the\n-\t call expanders to get PLT-marked, as they could otherwise be\n-\t compared against zero directly or indirectly.  After visiting the\n-\t call expanders they will then be cse:ed, as the call expanders\n-\t force_reg the addresses, effectively forcing flag_no_function_cse\n-\t to 0.  */\n-      flag_no_function_cse = 1;\n+      error (\"%<-fPIC%> and %<-fpic%> are not supported on this target\");\n+      flag_pic = 0;\n     }\n \n   /* Set the per-function-data initializer.  */\n@@ -2779,34 +2388,9 @@ cris_asm_output_mi_thunk (FILE *stream,\n \t     ADDITIVE_SIZE_MODIFIER (-delta), -delta,\n \t     reg_names[CRIS_FIRST_ARG_REG]);\n \n-  if (flag_pic)\n-    {\n-      const char *name = XSTR (XEXP (DECL_RTL (funcdecl), 0), 0);\n-\n-      name = (* targetm.strip_name_encoding) (name);\n-\n-      if (TARGET_V32)\n-\t{\n-\t  fprintf (stream, \"\\tba \");\n-\t  assemble_name (stream, name);\n-\t  fprintf (stream, \"%s\\n\\tnop\\n\", CRIS_PLT_PCOFFSET_SUFFIX);\n-\t}\n-      else\n-\t{\n-\t  fprintf (stream, \"\\tadd.d \");\n-\t  assemble_name (stream, name);\n-\t  fprintf (stream, \"%s,$pc\\n\", CRIS_PLT_PCOFFSET_SUFFIX);\n-\t}\n-    }\n-  else\n-    {\n-      fprintf (stream, \"\\tjump \");\n-      assemble_name (stream, XSTR (XEXP (DECL_RTL (funcdecl), 0), 0));\n-      fprintf (stream, \"\\n\");\n-\n-      if (TARGET_V32)\n-\tfprintf (stream, \"\\tnop\\n\");\n-    }\n+  fprintf (stream, \"\\tjump \");\n+  assemble_name (stream, XSTR (XEXP (DECL_RTL (funcdecl), 0), 0));\n+  fprintf (stream, \"\\n\");\n \n   final_end_function ();\n   assemble_end_function (thunkdecl, fnname);\n@@ -2827,17 +2411,6 @@ cris_file_start (void)\n   default_file_start ();\n }\n \n-/* Output that goes at the end of the file, similarly.  */\n-\n-static void\n-cris_file_end (void)\n-{\n-  /* For CRIS, the default is to assume *no* executable stack, so output\n-     an executable-stack-note only when needed.  */\n-  if (TARGET_LINUX && trampolines_created)\n-    file_end_indicate_exec_stack ();\n-}\n-\n /* Rename the function calls for integer multiply and divide.  */\n static void\n cris_init_libfuncs (void)\n@@ -3123,7 +2696,6 @@ cris_expand_prologue (void)\n   int framesize = 0;\n   rtx mem, insn;\n   int return_address_on_stack = cris_return_address_on_stack ();\n-  int got_really_used = false;\n   int n_movem_regs = 0;\n   int pretend = crtl->args.pretend_args_size;\n \n@@ -3133,17 +2705,6 @@ cris_expand_prologue (void)\n \n   CRIS_ASSERT (size >= 0);\n \n-  if (crtl->uses_pic_offset_table)\n-    {\n-      /* A reference may have been optimized out (like the abort () in\n-\t fde_split in unwind-dw2-fde.c, at least 3.2.1) so check that\n-\t it's still used.  */\n-      push_topmost_sequence ();\n-      got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL);\n-      pop_topmost_sequence ();\n-    }\n-\n   /* Align the size to what's best for the CPU model.  */\n   if (TARGET_STACK_ALIGN)\n     size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n@@ -3236,7 +2797,7 @@ cris_expand_prologue (void)\n      to be saved.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     {\n-      if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+      if (cris_reg_saved_in_regsave_area (regno))\n \t{\n \t  n_movem_regs++;\n \n@@ -3366,23 +2927,6 @@ cris_expand_prologue (void)\n       framesize += size + cfoa_size;\n     }\n \n-  /* Set up the PIC register, if it is used.  */\n-  if (got_really_used)\n-    {\n-      rtx got\n-\t= gen_rtx_UNSPEC (SImode, gen_rtvec (1, const0_rtx), CRIS_UNSPEC_GOT);\n-      emit_move_insn (pic_offset_table_rtx, got);\n-\n-      /* FIXME: This is a cover-up for flow2 messing up; it doesn't\n-\t follow exceptional paths and tries to delete the GOT load as\n-\t unused, if it isn't used on the non-exceptional paths.  Other\n-\t ports have similar or other cover-ups, or plain bugs marking\n-\t the GOT register load as maybe-dead.  To see this, remove the\n-\t line below and try libsupc++/vec.cc or a trivial\n-\t \"static void y (); void x () {try {y ();} catch (...) {}}\".  */\n-      emit_use (pic_offset_table_rtx);\n-    }\n-\n   if (cris_max_stackframe && framesize > cris_max_stackframe)\n     warning (0, \"stackframe too big: %d bytes\", framesize);\n }\n@@ -3402,23 +2946,11 @@ cris_expand_epilogue (void)\n   /* A reference may have been optimized out\n      (like the abort () in fde_split in unwind-dw2-fde.c, at least 3.2.1)\n      so check that it's still used.  */\n-  int got_really_used = false;\n   int n_movem_regs = 0;\n \n   if (!TARGET_PROLOGUE_EPILOGUE)\n     return;\n \n-  if (crtl->uses_pic_offset_table)\n-    {\n-      /* A reference may have been optimized out (like the abort () in\n-\t fde_split in unwind-dw2-fde.c, at least 3.2.1) so check that\n-\t it's still used.  */\n-      push_topmost_sequence ();\n-      got_really_used\n-\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL);\n-      pop_topmost_sequence ();\n-    }\n-\n   /* Align byte count of stack frame.  */\n   if (TARGET_STACK_ALIGN)\n     size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n@@ -3428,7 +2960,7 @@ cris_expand_epilogue (void)\n   for (regno = 0;\n        regno < FIRST_PSEUDO_REGISTER;\n        regno++)\n-    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+    if (cris_reg_saved_in_regsave_area (regno))\n       {\n \tn_movem_regs++;\n \n@@ -3448,7 +2980,7 @@ cris_expand_epilogue (void)\n   for (regno = FIRST_PSEUDO_REGISTER - 1;\n        regno > last_movem_reg;\n        regno--)\n-    if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+    if (cris_reg_saved_in_regsave_area (regno))\n       {\n \trtx insn;\n \n@@ -3548,7 +3080,7 @@ cris_expand_epilogue (void)\n      the return address on the stack.  */\n   if (return_address_on_stack && pretend == 0)\n     {\n-      if (TARGET_V32 || crtl->calls_eh_return)\n+      if (crtl->calls_eh_return)\n \t{\n \t  rtx mem;\n \t  rtx insn;\n@@ -3625,20 +3157,12 @@ cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n   unsigned int regno = nregs - 1;\n   int regno_inc = -1;\n \n-  if (TARGET_V32)\n-    {\n-      regno = 0;\n-      regno_inc = 1;\n-    }\n-\n   if (GET_CODE (srcreg) == POST_INC)\n     srcreg = XEXP (srcreg, 0);\n \n   CRIS_ASSERT (REG_P (srcreg));\n \n-  /* Don't use movem for just one insn.  The insns are equivalent except\n-     for the pipeline hazard (on v32); movem does not forward the loaded\n-     registers so there's a three cycles penalty for their use.  */\n+  /* Don't use movem for just one insn.  The insns are equivalent.  */\n   if (nregs == 1)\n     return gen_movsi (gen_rtx_REG (SImode, 0), src);\n \n@@ -3684,12 +3208,6 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n   unsigned int regno = nregs - 1;\n   int regno_inc = -1;\n \n-  if (TARGET_V32)\n-    {\n-      regno = 0;\n-      regno_inc = 1;\n-    }\n-\n   if (GET_CODE (destreg) == POST_INC)\n     increment += nregs * 4;\n \n@@ -3698,9 +3216,7 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n \n   CRIS_ASSERT (REG_P (destreg));\n \n-  /* Don't use movem for just one insn.  The insns are equivalent except\n-     for the pipeline hazard (on v32); movem does not forward the loaded\n-     registers so there's a three cycles penalty for use.  */\n+  /* Don't use movem for just one insn.  The insns are equivalent.  */\n   if (nregs == 1)\n     {\n       rtx mov = gen_rtx_SET (dest, gen_rtx_REG (SImode, 0));\n@@ -3800,138 +3316,6 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n   return insn;\n }\n \n-/* Worker function for expanding the address for PIC function calls.  */\n-\n-void\n-cris_expand_pic_call_address (rtx *opp, rtx *markerp)\n-{\n-  rtx op = *opp;\n-\n-  gcc_assert (flag_pic && MEM_P (op));\n-  op = XEXP (op, 0);\n-\n-  /* It might be that code can be generated that jumps to 0 (or to a\n-     specific address).  Don't die on that.  (There is a\n-     testcase.)  */\n-  if (CONSTANT_P (op) && !CONST_INT_P (op))\n-    {\n-      enum cris_symbol_type t = cris_symbol_type_of (op);\n-\n-      CRIS_ASSERT (can_create_pseudo_p ());\n-\n-      /* For local symbols (non-PLT), just get the plain symbol\n-\t reference into a register.  For symbols that can be PLT, make\n-\t them PLT.  */\n-      if (t == cris_rel_symbol)\n-\t{\n-\t  /* For v32, we're fine as-is; just PICify the symbol.  Forcing\n-\t     into a register caused performance regression for 3.2.1,\n-\t     observable in __floatdidf and elsewhere in libgcc.  */\n-\t  if (TARGET_V32)\n-\t    {\n-\t      rtx sym = GET_CODE (op) != CONST ? op : get_related_value (op);\n-\t      HOST_WIDE_INT offs = get_integer_term (op);\n-\n-\t      /* We can't get calls to sym+N, N integer, can we?  */\n-\t      gcc_assert (offs == 0);\n-\n-\t      op = gen_rtx_CONST (Pmode,\n-\t\t\t\t  gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n-\t\t\t\t\t\t  CRIS_UNSPEC_PCREL));\n-\t    }\n-\t  else\n-\t    op = force_reg (Pmode, op);\n-\n-\t  /* A local call.  */\n-\t  *markerp = const0_rtx;\n-\t}\n-      else if (t == cris_got_symbol)\n-\t{\n-\t  if (TARGET_AVOID_GOTPLT)\n-\t    {\n-\t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n-\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLT_GOTREL)),rM\"\n-\t\t \"add.d rPIC,rM,rO\", \"jsr rO\" for pre-v32 and\n-\t\t \"jsr (const (unspec [sym] CRIS_UNSPEC_PLT_PCREL))\"\n-\t\t for v32.  */\n-\t      rtx tem, rm, ro;\n-\n-\t      crtl->uses_pic_offset_table = 1;\n-\t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n-\t\t\t\t    TARGET_V32\n-\t\t\t\t    ? CRIS_UNSPEC_PLT_PCREL\n-\t\t\t\t    : CRIS_UNSPEC_PLT_GOTREL);\n-\t      tem = gen_rtx_CONST (Pmode, tem);\n-\t      if (TARGET_V32)\n-\t\top = tem;\n-\t      else\n-\t\t{\n-\t\t  rm = gen_reg_rtx (Pmode);\n-\t\t  emit_move_insn (rm, tem);\n-\t\t  ro = gen_reg_rtx (Pmode);\n-\t\t  if (expand_binop (Pmode, add_optab, rm,\n-\t\t\t\t    pic_offset_table_rtx,\n-\t\t\t\t    ro, 0, OPTAB_LIB_WIDEN) != ro)\n-\t\t    internal_error (\"expand_binop failed in movsi got\");\n-\t\t  op = ro;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n-\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLTGOTREAD)),rM\"\n-\t\t \"add.d rPIC,rM,rO\" \"jsr [rO]\" with the memory access\n-\t\t marked as not trapping and not aliasing.  No \"move.d\n-\t\t [rO],rP\" as that would invite to re-use of a value\n-\t\t that should not be reused.  FIXME: Need a peephole2\n-\t\t for cases when this is cse:d from the call, to change\n-\t\t back to just get the PLT entry address, so we don't\n-\t\t resolve the same symbol over and over (the memory\n-\t\t access of the PLTGOT isn't constant).  */\n-\t      rtx tem, mem, rm, ro;\n-\n-\t      gcc_assert (can_create_pseudo_p ());\n-\t      crtl->uses_pic_offset_table = 1;\n-\t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n-\t\t\t\t    CRIS_UNSPEC_PLTGOTREAD);\n-\t      rm = gen_reg_rtx (Pmode);\n-\t      emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n-\t      ro = gen_reg_rtx (Pmode);\n-\t      if (expand_binop (Pmode, add_optab, rm,\n-\t\t\t\tpic_offset_table_rtx,\n-\t\t\t\tro, 0, OPTAB_LIB_WIDEN) != ro)\n-\t\tinternal_error (\"expand_binop failed in movsi got\");\n-\t      mem = gen_rtx_MEM (Pmode, ro);\n-\n-\t      /* This MEM doesn't alias anything.  Whether it aliases\n-\t\t other same symbols is unimportant.  */\n-\t      set_mem_alias_set (mem, new_alias_set ());\n-\t      MEM_NOTRAP_P (mem) = 1;\n-\t      op = mem;\n-\t    }\n-\n-\t  /* We need to prepare this call to go through the PLT; we\n-\t     need to make GOT available.  */\n-\t  *markerp = pic_offset_table_rtx;\n-\t}\n-      else\n-\t/* Can't possibly get anything else for a function-call, right?  */\n-\tfatal_insn (\"unidentifiable call op\", op);\n-\n-      /* If the validizing variant is called, it will try to validize\n-\t the address as a valid any-operand constant, but as it's only\n-\t valid for calls and moves, it will fail and always be forced\n-\t into a register.  */\n-      *opp = replace_equiv_address_nv (*opp, op);\n-    }\n-  else\n-    /* Can't tell what locality a call to a non-constant address has;\n-       better make the GOT register alive at it.\n-       FIXME: Can we see whether the register has known constant\n-       contents?  */\n-    *markerp = pic_offset_table_rtx;\n-}\n-\n /* Make sure operands are in the right order for an addsi3 insn as\n    generated by a define_split.  Nothing but REG_P as the first\n    operand is recognized by addsi3 after reload.  OPERANDS contains\n@@ -3968,101 +3352,15 @@ void\n cris_asm_output_symbol_ref (FILE *file, rtx x)\n {\n   gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\n-  if (flag_pic && in_code > 0)\n-    {\n-     const char *origstr = XSTR (x, 0);\n-     const char *str;\n-     str = (* targetm.strip_name_encoding) (origstr);\n-     assemble_name (file, str);\n-\n-     /* Sanity check.  */\n-     if (!TARGET_V32 && !crtl->uses_pic_offset_table)\n-       output_operand_lossage (\"PIC register isn't set up\");\n-    }\n-  else\n-    assemble_name (file, XSTR (x, 0));\n+  assemble_name (file, XSTR (x, 0));\n }\n \n /* Worker function for ASM_OUTPUT_LABEL_REF.  */\n \n void\n cris_asm_output_label_ref (FILE *file, char *buf)\n {\n-  if (flag_pic && in_code > 0)\n-    {\n-      assemble_name (file, buf);\n-\n-      /* Sanity check.  */\n-      if (!TARGET_V32 && !crtl->uses_pic_offset_table)\n-\tinternal_error (\"emitting PIC operand, but PIC register \"\n-\t\t\t\"isn%'t set up\");\n-    }\n-  else\n-    assemble_name (file, buf);\n-}\n-\n-/* Worker function for TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA.  */\n-\n-static bool\n-cris_output_addr_const_extra (FILE *file, rtx xconst)\n-{\n-  switch (GET_CODE (xconst))\n-    {\n-      rtx x;\n-\n-    case UNSPEC:\n-      x = XVECEXP (xconst, 0, 0);\n-      CRIS_ASSERT (GET_CODE (x) == SYMBOL_REF\n-\t\t   || GET_CODE (x) == LABEL_REF\n-\t\t   || GET_CODE (x) == CONST);\n-      output_addr_const (file, x);\n-      switch (XINT (xconst, 1))\n-\t{\n-\tcase CRIS_UNSPEC_PCREL:\n-\t  /* We only get this with -fpic/PIC to tell it apart from an\n-\t     invalid symbol.  We can't tell here, but it should only\n-\t     be the operand of a call or movsi.  */\n-\t  gcc_assert (TARGET_V32 && flag_pic);\n-\t  break;\n-\n-\tcase CRIS_UNSPEC_PLT_PCREL:\n-\t  gcc_assert (TARGET_V32);\n-\t  fprintf (file, \":PLT\");\n-\t  break;\n-\n-\tcase CRIS_UNSPEC_PLT_GOTREL:\n-\t  gcc_assert (!TARGET_V32);\n-\t  fprintf (file, \":PLTG\");\n-\t  break;\n-\n-\tcase CRIS_UNSPEC_GOTREL:\n-\t  gcc_assert (!TARGET_V32);\n-\t  fprintf (file, \":GOTOFF\");\n-\t  break;\n-\n-\tcase CRIS_UNSPEC_GOTREAD:\n-\t  if (flag_pic == 1)\n-\t    fprintf (file, \":GOT16\");\n-\t  else\n-\t    fprintf (file, \":GOT\");\n-\t  break;\n-\n-\tcase CRIS_UNSPEC_PLTGOTREAD:\n-\t  if (flag_pic == 1)\n-\t    fprintf (file, CRIS_GOTPLT_SUFFIX \"16\");\n-\t  else\n-\t    fprintf (file, CRIS_GOTPLT_SUFFIX);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n+  assemble_name (file, buf);\n }\n \n /* Worker function for TARGET_STRUCT_VALUE_RTX.  */\n@@ -4286,51 +3584,12 @@ cris_frame_pointer_required (void)\n static void\n cris_asm_trampoline_template (FILE *f)\n {\n-  if (TARGET_V32)\n-    {\n-      /* This normally-unused nop insn acts as an instruction to\n-\t the simulator to flush its instruction cache.  None of\n-\t the other instructions in the trampoline template suits\n-\t as a trigger for V32.  The pc-relative addressing mode\n-\t works nicely as a trigger for V10.\n-\t FIXME: Have specific V32 template (possibly avoiding the\n-\t use of a special instruction).  */\n-      fprintf (f, \"\\tclearf x\\n\");\n-      /* We have to use a register as an intermediate, choosing\n-\t semi-randomly R1 (which has to not be the STATIC_CHAIN_REGNUM),\n-\t so we can use it for address indirection and jsr target.  */\n-      fprintf (f, \"\\tmove $r1,$mof\\n\");\n-      /* +4 */\n-      fprintf (f, \"\\tmove.d 0,$r1\\n\");\n-      fprintf (f, \"\\tmove.d $%s,[$r1]\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n-      fprintf (f, \"\\taddq 6,$r1\\n\");\n-      fprintf (f, \"\\tmove $mof,[$r1]\\n\");\n-      fprintf (f, \"\\taddq 6,$r1\\n\");\n-      fprintf (f, \"\\tmove $srp,[$r1]\\n\");\n-      /* +20 */\n-      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n-      /* +26 */\n-      fprintf (f, \"\\tmove.d 0,$r1\\n\");\n-      fprintf (f, \"\\tjsr $r1\\n\");\n-      fprintf (f, \"\\tsetf\\n\");\n-      /* +36 */\n-      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n-      /* +42 */\n-      fprintf (f, \"\\tmove.d 0,$r1\\n\");\n-      /* +48 */\n-      fprintf (f, \"\\tmove.d 0,$r9\\n\");\n-      fprintf (f, \"\\tjump $r9\\n\");\n-      fprintf (f, \"\\tsetf\\n\");\n-    }\n-  else\n-    {\n-      fprintf (f, \"\\tmove.d $%s,[$pc+20]\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n-      fprintf (f, \"\\tmove $srp,[$pc+22]\\n\");\n-      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n-      fprintf (f, \"\\tjsr 0\\n\");\n-      fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n-      fprintf (f, \"\\tjump 0\\n\");\n-    }\n+  fprintf (f, \"\\tmove.d $%s,[$pc+20]\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+  fprintf (f, \"\\tmove $srp,[$pc+22]\\n\");\n+  fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+  fprintf (f, \"\\tjsr 0\\n\");\n+  fprintf (f, \"\\tmove.d 0,$%s\\n\", reg_names[STATIC_CHAIN_REGNUM]);\n+  fprintf (f, \"\\tjump 0\\n\");\n }\n \n /* Implement TARGET_TRAMPOLINE_INIT.  */\n@@ -4339,28 +3598,15 @@ static void\n cris_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n   rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n-  rtx tramp = XEXP (m_tramp, 0);\n   rtx mem;\n \n   emit_block_move (m_tramp, assemble_trampoline_template (),\n \t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n \n-  if (TARGET_V32)\n-    {\n-      mem = adjust_address (m_tramp, SImode, 6);\n-      emit_move_insn (mem, plus_constant (Pmode, tramp, 38));\n-      mem = adjust_address (m_tramp, SImode, 22);\n-      emit_move_insn (mem, chain_value);\n-      mem = adjust_address (m_tramp, SImode, 28);\n-      emit_move_insn (mem, fnaddr);\n-    }\n-  else\n-    {\n-      mem = adjust_address (m_tramp, SImode, 10);\n-      emit_move_insn (mem, chain_value);\n-      mem = adjust_address (m_tramp, SImode, 16);\n-      emit_move_insn (mem, fnaddr);\n-    }\n+  mem = adjust_address (m_tramp, SImode, 10);\n+  emit_move_insn (mem, chain_value);\n+  mem = adjust_address (m_tramp, SImode, 16);\n+  emit_move_insn (mem, fnaddr);\n \n   /* Note that there is no need to do anything with the cache for\n      sake of a trampoline.  */\n@@ -4389,7 +3635,7 @@ cris_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   return ((mode == CCmode || regno != CRIS_CC0_REGNUM)\n \t  && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t      || (regno != CRIS_MOF_REGNUM && regno != CRIS_ACR_REGNUM)));\n+\t      || regno != CRIS_MOF_REGNUM));\n }\n \n /* Return the preferred minimum alignment for a static object.  */"}, {"sha": "4aa12b8c2764f9f910abee07a0c7f79ad64b3767", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 13, "deletions": 101, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -64,15 +64,6 @@ along with GCC; see the file COPYING3.  If not see\n    never clash with it for GCC purposes.  */\n #define CRIS_CANONICAL_CC0_REGNUM (16 + 13)\n \n-/* When generating PIC, these suffixes are added to the names of non-local\n-   functions when being output.  Contrary to other ports, we have offsets\n-   relative to the GOT, not the PC.  We might implement PC-relative PLT\n-   semantics later for the general case; they are used in some cases right\n-   now, such as MI thunks.  */\n-#define CRIS_GOTPLT_SUFFIX \":GOTPLT\"\n-#define CRIS_PLT_GOTOFFSET_SUFFIX \":PLTG\"\n-#define CRIS_PLT_PCOFFSET_SUFFIX \":PLT\"\n-\n #define CRIS_FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n   ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)\t\\\n    : (unsigned) int_size_in_bytes (TYPE))\n@@ -115,19 +106,10 @@ extern int cris_cpu_version;\n #define CRIS_DEFAULT_ASM_ARCH_OPTION \"\"\n \n #ifdef TARGET_CPU_DEFAULT\n-#if TARGET_CPU_DEFAULT != 32 && TARGET_CPU_DEFAULT != 10\n+#if TARGET_CPU_DEFAULT != 10\n  #error \"Due to '()'; e.g. '#define TARGET_CPU_DEFAULT (10)', stringize TARGET_CPU_DEFAULT isn't useful: update manually.\"\n #endif\n \n-#if TARGET_CPU_DEFAULT == 32\n-#undef CRIS_DEFAULT_TUNE\n-#define CRIS_DEFAULT_TUNE \"32\"\n-/* To enable use of \"generic\" cris-axis-elf binutils, always pass the\n-   architecture option to GAS.  (We don't do this for non-v32.)  */\n-#undef CRIS_DEFAULT_ASM_ARCH_OPTION\n-#define CRIS_DEFAULT_ASM_ARCH_OPTION \"--march=v32\"\n-#endif\n-\n #undef CRIS_ARCH_CPP_DEFAULT\n #define CRIS_ARCH_CPP_DEFAULT \\\n  \"%{!march=*:\\\n@@ -183,8 +165,7 @@ extern int cris_cpu_version;\n  \"%(asm_subtarget)\\\n  %{march=*:%{mcpu=*:%edo not specify both -march=... and -mcpu=...}}\\\n  %{march=v0|mcpu=v0|march=v3|mcpu=v3|march=v8|mcpu=v8:--march=v0_v10}\\\n- %{march=v10|mcpu=v10:--march=v10}\\\n- %{march=v32|mcpu=v32:--march=v32}\"\n+ %{march=v10|mcpu=v10:--march=v10}\"\n \n /* For the cris-*-elf subtarget.  */\n #define CRIS_ASM_SUBTARGET_SPEC \\\n@@ -252,35 +233,24 @@ extern int cris_cpu_version;\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-/* Previously controlled by target_flags.  Note that this is *not* set\n-   for -melinux.  */\n-#define TARGET_LINUX 0\n-\n /* For the cris-*-elf subtarget.  */\n #define CRIS_SUBTARGET_DEFAULT 0\n \n #define CRIS_CPU_BASE 0\n #define CRIS_CPU_ETRAX4 3\t/* Just lz added.  */\n #define CRIS_CPU_SVINTO 8\t/* Added swap, jsrc & Co., 32-bit accesses.  */\n #define CRIS_CPU_NG 10\t\t/* Added mul[su].  */\n-#define CRIS_CPU_V32 32\t\t/* Major changes.  */\n \n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT CRIS_CPU_BASE\n #endif\n \n /* Default target_flags if no switches specified.\n-   The alignment-by-32 is to make builtin atomic support for v10 and v32\n+   The alignment-by-32 is to make builtin atomic support for v10\n    work for *-elf for types without specified alignment (like plain\n    \"int\").  See top comment in sync.md.  */\n #ifndef TARGET_DEFAULT\n-# if TARGET_CPU_DEFAULT == 32\n-#  define TARGET_DEFAULT \\\n- (MASK_STACK_ALIGN \\\n-  + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n-  + MASK_ALIGN_BY_32 \\\n-  + MASK_PROLOGUE_EPILOGUE)\n-# elif TARGET_CPU_DEFAULT == 10\n+# if TARGET_CPU_DEFAULT == 10\n #  define TARGET_DEFAULT \\\n  (MASK_SIDE_EFFECT_PREFIXES + MASK_STACK_ALIGN \\\n   + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n@@ -301,16 +271,15 @@ extern int cris_cpu_version;\n #define TARGET_HAS_LZ (cris_cpu_version >= CRIS_CPU_ETRAX4)\n #define TARGET_HAS_BREAK (cris_cpu_version >= CRIS_CPU_ETRAX4)\n #define TARGET_HAS_SWAP (cris_cpu_version >= CRIS_CPU_SVINTO)\n-#define TARGET_V32 (cris_cpu_version >= CRIS_CPU_V32)\n \n /* The \"break\" instruction was introduced with ETRAX 4.  */\n #define TARGET_TRAP_USING_BREAK8 \\\n  (cris_trap_using_break8 == 2 ? TARGET_HAS_BREAK : cris_trap_using_break8)\n \n-/* Call library functions by default for GNU/Linux.  */\n+/* This condition controls whether to expand atomics inline or call\n+   library functions. */\n #define TARGET_ATOMICS_MAY_CALL_LIBFUNCS\t\t\\\n- (cris_atomics_calling_libfunc == 2\t\t\t\\\n-  ? TARGET_LINUX : cris_atomics_calling_libfunc)\n+ (cris_atomics_calling_libfunc != 2 && cris_atomics_calling_libfunc != 0)\n \n /* The < v10 atomics turn off interrupts, so they don't need alignment.\n    Incidentally, by default alignment is off there causing variables to\n@@ -319,7 +288,7 @@ extern int cris_cpu_version;\n    specify as aligned.  */\n #define TARGET_TRAP_UNALIGNED_ATOMIC\t\t\\\n  (cris_trap_unaligned_atomic == 2\t\t\\\n-  ? (TARGET_V32 || cris_cpu_version == 10)\t\\\n+  ? cris_cpu_version == 10\t\t\t\\\n   : cris_trap_unaligned_atomic)\n \n /* Node: Storage Layout */\n@@ -450,13 +419,6 @@ extern int cris_cpu_version;\n #define REG_ALLOC_ORDER \\\n  {9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 17, 16, 18, 19}\n \n-/* Use MOF and ACR.  Prefer ACR before any other register.  Prefer MOF\n-   then SRP after saved registers.  The *after* is because they're only\n-   useful for storage, not for things being computed, which is\n-   apparently more common.  */\n-#define REG_ALLOC_ORDER_V32 \\\n- {15, 9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 17, 16, 14, 18, 19}\n-\n \n /* Node: Leaf Functions */\n /* (no definitions) */\n@@ -542,14 +504,6 @@ enum reg_class\n   || (unsigned) reg_renumber[REGNO] <= CRIS_LAST_GENERAL_REGISTER\t\\\n   || (unsigned) reg_renumber[REGNO] == ARG_POINTER_REGNUM)\n \n-/* REGNO_OK_FOR_BASE_P seems to be obsolete wrt. this one, but not yet\n-   documented as such.  */\n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(REGNO, MODE, AS, OCODE, ICODE)\t\\\n- (REGNO_OK_FOR_BASE_P (REGNO)\t\t\t\t\t\t\\\n-  && ((OCODE) != POST_INC\t\t\t\t\t\t\\\n-      || !((REGNO) == CRIS_ACR_REGNUM\t\t\t\t\t\\\n-\t   || (unsigned) reg_renumber[REGNO] == CRIS_ACR_REGNUM)))\n-\n /* See REGNO_OK_FOR_BASE_P.  */\n #define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n@@ -566,11 +520,6 @@ enum reg_class\n \t\t\t\t    GENERAL_REGS)))\t\t\t\\\n    ? GENERAL_REGS : NO_REGS)\n \n-/* FIXME: Fix regrename.c; it should check validity of replacements,\n-   not just with a silly pass-specific macro.  We may miss some\n-   opportunities, but we must stop regrename from creating acr++.  */\n-#define HARD_REGNO_RENAME_OK(FROM, TO) ((TO) != CRIS_ACR_REGNUM)\n-\n /* For CRIS, this is always the size of MODE in words,\n    since all registers are the same size.  To use omitted modes in\n    patterns with reload constraints, you must say the widest size\n@@ -716,7 +665,7 @@ struct cum_args {int regs;};\n \n /* Node: Trampolines */\n \n-#define TRAMPOLINE_SIZE (TARGET_V32 ? 58 : 32)\n+#define TRAMPOLINE_SIZE 32\n \n /* CRIS wants instructions on word-boundary.  */\n #define TRAMPOLINE_ALIGNMENT 16\n@@ -735,8 +684,6 @@ struct cum_args {int regs;};\n #define CONSTANT_ADDRESS_P(X) \\\n   (CONSTANT_P (X) && cris_legitimate_address_p (QImode, X, false))\n \n-/* Must be a compile-time constant, so we go with the highest value\n-   among all CRIS variants.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n /* Fix reloads known to cause suboptimal spilling.  */\n@@ -748,12 +695,6 @@ struct cum_args {int regs;};\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* The mode argument to cris_legitimate_constant_p isn't used, so just\n-   pass a cheap dummy.  N.B. we have to cast away const from the\n-   parameter rather than adjust the parameter, as it's type is mandated\n-   by the TARGET_LEGITIMATE_CONSTANT_P target hook interface.  */\n-#define CRIS_CONSTANT_P(X) \\\n-  (CONSTANT_P (X) && cris_legitimate_constant_p (VOIDmode, CONST_CAST_RTX (X)))\n \n /* Node: Condition Code */\n \n@@ -789,25 +730,6 @@ struct cum_args {int regs;};\n #define JUMP_TABLES_IN_TEXT_SECTION 1\n \n \n-/* Node: PIC */\n-\n-/* Helper type.  */\n-\n-enum cris_symbol_type\n-  {\n-    cris_no_symbol = 0,\n-    cris_got_symbol = 1,\n-    cris_rel_symbol = 2,\n-    cris_got_symbol_needing_fixup = 3,\n-    cris_unspec = 7,\n-    cris_offsettable_symbol = 8\n-  };\n-\n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? CRIS_GOT_REGNUM : INVALID_REGNUM)\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X) cris_legitimate_pic_operand (X)\n-\n-\n /* Node: File Framework */\n \n /* We don't want an .ident for gcc.  To avoid that but still support\n@@ -898,10 +820,10 @@ enum cris_symbol_type\n \n #define REGISTER_NAMES\t\t\t\t\t\\\n  {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\",\t\\\n-  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"acr\", \"srp\", \"mof\", \"faked_ap\", \"dccr\"}\n+  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"pc\", \"srp\", \"mof\", \"faked_ap\", \"dccr\"}\n \n #define ADDITIONAL_REGISTER_NAMES \\\n- {{\"r14\", 14}, {\"r15\", 15}, {\"pc\", 15}}\n+ {{\"r14\", 14}, {\"r15\", 15}}\n \n /* Output an empty line to illustrate the presence of the delay slot.  */\n #define DBR_OUTPUT_SEQEND(FILE) \\\n@@ -922,10 +844,7 @@ enum cris_symbol_type\n #define USER_LABEL_PREFIX \"_\"\n \n #define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n-  fprintf (FILE,\t\t\t\t\t\t\t\\\n-\t   TARGET_V32\t\t\t\t\t\t\t\\\n-\t   ? \"\\tsubq 4,$sp\\n\\tmove $%s,[$sp]\\n\" : \"\\tpush $%s\\n\",\t\\\n-\t   reg_names[REGNO])\n+  fprintf (FILE, \"\\tpush $%s\\n\", reg_names[REGNO])\n \n #define ASM_OUTPUT_REG_POP(FILE, REGNO) \\\n   fprintf (FILE, \"\\tmove [$sp+],$%s\\n\", reg_names[REGNO])\n@@ -934,14 +853,7 @@ enum cris_symbol_type\n /* Node: Dispatch Tables */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (TARGET_V32)\t\t\t\t\t\t\t\\\n-       asm_fprintf (FILE, \"\\t.word %LL%d-.\\n\", VALUE);\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-       asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+  asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL)\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   asm_fprintf (FILE, \"\\t.dword %LL%d\\n\", VALUE)"}, {"sha": "9fe1f85552ebc195e80f13d974a7f65c8f0d4535", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 131, "deletions": 1247, "changes": 1378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -49,46 +49,8 @@\n ;; ??? But it should be re-checked for gcc > 2.7.2\n ;; FIXME: This changed some time ago (from 2000-03-16) for gcc-2.9x.\n \n-;; FIXME: When PIC, all [rX=rY+S] could be enabled to match\n-;; [rX=gotless_symbol].\n-;; The movsi for a gotless symbol could be split (post reload).\n-\f\n-\n (define_c_enum \"\"\n   [\n-   ;; PLT reference from call expansion: operand 0 is the address,\n-   ;; the mode is VOIDmode.  Always wrapped in CONST.\n-   ;; The value is relative to the GOT.\n-   CRIS_UNSPEC_PLT_GOTREL\n-\n-   ;; PLT reference from call expansion: operand 0 is the address,\n-   ;; the mode is VOIDmode.  Always wrapped in CONST.\n-   ;; The value is relative to the PC.  It's arch-dependent whether\n-   ;; the offset counts from the start or the end of the current item.\n-   CRIS_UNSPEC_PLT_PCREL\n-\n-   ;; The address of the global offset table as a source operand.\n-   CRIS_UNSPEC_GOT\n-\n-   ;; The offset from the global offset table to the operand.\n-   CRIS_UNSPEC_GOTREL\n-\n-   ;; The PC-relative offset to the operand.  It's arch-dependent whether\n-   ;; the offset counts from the start or the end of the current item.\n-   CRIS_UNSPEC_PCREL\n-\n-   ;; The index into the global offset table of a symbol, while\n-   ;; also generating a GOT entry for the symbol.\n-   CRIS_UNSPEC_GOTREAD\n-\n-   ;; Similar to CRIS_UNSPEC_GOTREAD, but also generating a PLT entry.\n-   CRIS_UNSPEC_PLTGOTREAD\n-\n-   ;; Condition for v32 casesi jump, since it needs to have if_then_else\n-   ;; form with register as one branch and default label as other.\n-   ;; Operand 0 is const_int 0.\n-   CRIS_UNSPEC_CASESI\n-\n    ;; Stack frame deallocation barrier.\n    CRIS_UNSPEC_FRAME_DEALLOC\n \n@@ -98,8 +60,7 @@\n \n ;; Register numbers.\n (define_constants\n-  [(CRIS_GOT_REGNUM 0)\n-   (CRIS_STATIC_CHAIN_REGNUM 7)\n+  [(CRIS_STATIC_CHAIN_REGNUM 7)\n    (CRIS_FP_REGNUM 8)\n    (CRIS_SP_REGNUM 14)\n    (CRIS_ACR_REGNUM 15)\n@@ -125,10 +86,8 @@\n ;; In short, any \"slottable\" instruction must be 16 bit and not refer\n ;; to pc, or alter it.\n ;;\n-;; The possible values are \"yes\", \"no\", \"has_slot\", \"has_return_slot\"\n-;; and \"has_call_slot\".\n-;; Yes/no tells whether the insn is slottable or not.  Has_call_slot means\n-;; that the insn is a call insn, which for CRIS v32 has a delay-slot.\n+;; The possible values are \"yes\", \"no\", \"has_slot\", and \"has_return_slot\".\n+;; Yes/no tells whether the insn is slottable or not.\n ;; Of special concern is that no RTX_FRAME_RELATED insn must go in that\n ;; call delay slot, as it's located in the address *after* the call insn,\n ;; and the unwind machinery doesn't know about delay slots.\n@@ -157,13 +116,13 @@\n ;; constraint pattern for the slottable pattern.  An alternative using\n ;; only \"r\" constraints is most often slottable.\n \n-(define_attr \"slottable\" \"no,yes,has_slot,has_return_slot,has_call_slot\"\n+(define_attr \"slottable\" \"no,yes,has_slot,has_return_slot\"\n   (const_string \"no\"))\n \n ;; We also need attributes to sanely determine the condition code\n ;; state.  See cris_notice_update_cc for how this is used.\n \n-(define_attr \"cc\" \"none,clobber,normal,noov32,rev\" (const_string \"normal\"))\n+(define_attr \"cc\" \"none,clobber,normal,rev\" (const_string \"normal\"))\n \n ;; At the moment, this attribute is just used to help bb-reorder do its\n ;; work; the default 0 doesn't help it.  Many insns have other lengths,\n@@ -181,19 +140,6 @@\n (define_delay (eq_attr \"slottable\" \"has_slot\")\n   [(eq_attr \"slottable\" \"yes\") (nil) (nil)])\n \n-;; We can't put prologue insns in call-insn delay-slots when\n-;; DWARF2 unwind info is emitted, because the unwinder matches the\n-;; address after the insn.  It must see the return address of a call at\n-;; a position at least *one byte after* the insn, or it'll think that\n-;; the insn hasn't been executed.  If the insn is in a delay-slot of a\n-;; call, it's just *exactly* after the insn.\n-\n-(define_delay (eq_attr \"slottable\" \"has_call_slot\")\n-  [(and (eq_attr \"slottable\" \"yes\")\n-\t(ior (not (match_test \"RTX_FRAME_RELATED_P (insn)\"))\n-\t     (not (match_test \"flag_exceptions\"))))\n-   (nil) (nil)])\n-\n ;; The insn in the return insn slot must not be the\n ;; return-address-register restore.  FIXME: Use has_slot and express\n ;; as a parallel with a use of the return-address-register (currently\n@@ -251,41 +197,14 @@\n \n ;; Normal named test patterns from SI on.\n \n-(define_insn \"*tstsi\"\n+(define_insn \"tst<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"r,Q>,m\")\n+\t(compare (match_operand:BWD 0 \"nonimmediate_operand\" \"r,Q>,m\")\n \t\t (const_int 0)))]\n   \"\"\n-{\n-  if (which_alternative == 0 && TARGET_V32)\n-    return \"cmpq 0,%0\";\n-  return \"test.d %0\";\n-}\n+  \"test<m> %0\"\n   [(set_attr \"slottable\" \"yes,yes,no\")])\n \n-(define_insn \"*tst<mode>_cmp\"\n-  [(set (cc0)\n-\t(compare (match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\")\n-\t\t (const_int 0)))]\n-  \"cris_cc0_user_requires_cmp (insn)\"\n-  \"@\n-   cmp<m> 0,%0\n-   test<m> %0\n-   test<m> %0\"\n-  [(set_attr \"slottable\" \"no,yes,no\")])\n-\n-(define_insn \"*tst<mode>_non_cmp\"\n-  [(set (cc0)\n-\t(compare (match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\")\n-\t\t (const_int 0)))]\n-  \"!cris_cc0_user_requires_cmp (insn)\"\n-  \"@\n-   move<m> %0,%0\n-   test<m> %0\n-   test<m> %0\"\n-  [(set_attr \"slottable\" \"yes,yes,no\")\n-   (set_attr \"cc\" \"noov32,*,*\")])\n-\n ;; It seems that the position of the sign-bit and the fact that 0.0 is\n ;; all 0-bits would make \"tstsf\" a straight-forward implementation;\n ;; either \"test.d\" it for positive/negative or \"btstq 30,r\" it for\n@@ -301,11 +220,11 @@\n ;; DImode for anything else but a structure/block-mode.  Just do the\n ;; obvious stuff for the straight-forward constraint letters.\n \n-(define_insn \"*cmpdi_non_v32\"\n+(define_insn \"*cmpdi\"\n   [(set (cc0)\n \t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"rm,r,r,r,r,r,r,o\")\n \t\t (match_operand:DI 1 \"general_operand\" \"M,Kc,I,P,n,r,o,r\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    test.d %M0\\;ax\\;test.d %H0\n    cmpq %1,%M0\\;ax\\;cmpq 0,%H0\n@@ -316,18 +235,6 @@\n    cmp.d %M1,%M0\\;ax\\;cmp.d %H1,%H0\n    cmp.d %M0,%M1\\;ax\\;cmp.d %H0,%H1\")\n \n-(define_insn \"*cmpdi_v32\"\n-  [(set (cc0)\n-\t(compare (match_operand:DI 0 \"register_operand\"  \"r,r,r,r,r\")\n-\t\t (match_operand:DI 1 \"nonmemory_operand\" \"Kc,I,P,n,r\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   cmpq %1,%M0\\;ax\\;cmpq 0,%H0\n-   cmpq %1,%M0\\;ax\\;cmpq -1,%H0\n-   cmp%e1.%z1 %1,%M0\\;ax\\;cmpq %H1,%H0\n-   cmp.d %M1,%M0\\;ax\\;cmp.d %H1,%H0\n-   cmp.d %M1,%M0\\;ax\\;cmp.d %H1,%H0\")\n-\n ;; Note that compare insns with side effect addressing mode (e.g.):\n ;;\n ;; cmp.S [rx=ry+i],rz;\n@@ -450,8 +357,7 @@\n    btst %2,%0\n    clearf nz\n    cmpq %p0,%2\"\n- [(set_attr \"slottable\" \"yes\")\n-  (set_attr \"cc\" \"noov32\")])\n+ [(set_attr \"slottable\" \"yes\")])\n \f\n ;; Move insns.\n \n@@ -499,8 +405,7 @@\n {\n   if (MEM_P (operands[0])\n       && operands[1] != const0_rtx\n-      && can_create_pseudo_p ()\n-      && (!TARGET_V32 || !REG_P (operands[1])))\n+      && can_create_pseudo_p ())\n     operands[1] = copy_to_mode_reg (DImode, operands[1]);\n \n   /* Some other ports (as of 2001-09-10 for example mcore and romp) also\n@@ -530,66 +435,16 @@\n     }\n })\n \n-(define_insn_and_split \"*movdi_insn_non_v32\"\n+(define_insn_and_split \"*movdi_insn\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rx,m\")\n \t(match_operand:DI 1 \"general_operand\"\t   \"rx,g,rxM\"))]\n   \"(register_operand (operands[0], DImode)\n     || register_operand (operands[1], DImode)\n-    || operands[1] == const0_rtx)\n-   && !TARGET_V32\"\n+    || operands[1] == const0_rtx)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(match_dup 2)]\n   \"operands[2] = cris_split_movdx (operands);\")\n-\n-;; Overlapping (but non-identical) source memory address and destination\n-;; register would be a compiler bug, so we don't have to specify that.\n-(define_insn \"*movdi_v32\"\n-  [(set\n-    (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rx,&r,>, m,r,x,m\")\n-    (match_operand:DI 1 \"general_operand\"     \"rxi,r>,m, rx,r,m,m,x\"))]\n-  \"TARGET_V32\"\n-{\n-  switch (which_alternative)\n-    {\n-      /* FIXME: 1) Use autoincrement where possible.  2) Have peephole2,\n-\t particularly for cases where the address register is dead.  */\n-    case 5:\n-      if (REGNO (operands[0]) == REGNO (XEXP (operands[1], 0)))\n-\treturn \"addq 4,%L1\\;move.d %1,%H0\\;subq 4,%L1\\;move.d %1,%M0\";\n-      gcc_assert (REGNO (operands[0]) + 1 == REGNO (XEXP (operands[1], 0)));\n-      return \"move.d [%L1+],%M0\\;move.d [%L1],%H0\";\n-    case 2:\n-      /* We could do away with the addq if we knew the address-register\n-\t isn't ACR.  If we knew the address-register is dead, we could do\n-\t away with the subq too.  */\n-      return \"move.d [%L1],%M0\\;addq 4,%L1\\;move.d [%L1],%H0\\;subq 4,%L1\";\n-    case 4:\n-      return \"move.d %M1,[%L0]\\;addq 4,%L0\\;move.d %H1,[%L0]\\;subq 4,%L0\";\n-    case 6:\n-      return \"move [%L1],%M0\\;addq 4,%L1\\;move [%L1],%H0\\;subq 4,%L1\";\n-    case 7:\n-      return \"move %M1,[%L0]\\;addq 4,%L0\\;move %H1,[%L0]\\;subq 4,%L0\";\n-\n-    default:\n-      return \"#\";\n-    }\n-}\n-  ;; The non-split cases clobber cc0 because of their adds and subs.\n-  ;; Beware that NOTICE_UPDATE_CC is called before the forced split happens.\n-  [(set_attr \"cc\" \"*,*,clobber,*,clobber,clobber,*,*\")])\n-\n-;; Much like \"*movdi_insn_non_v32\".  Overlapping registers and constants\n-;; is handled so much better in cris_split_movdx.\n-(define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"TARGET_V32\n-   && reload_completed\n-   && (!MEM_P (operands[0]) || !REG_P (XEXP (operands[0], 0)))\n-   && (!MEM_P (operands[1]) || !REG_P (XEXP (operands[1], 0)))\"\n-  [(match_dup 2)]\n-  \"operands[2] = cris_split_movdx (operands);\")\n \f\n ;; Side-effect patterns for move.S1 [rx=ry+rx.S2],rw\n ;; and move.S1 [rx=ry+i],rz\n@@ -917,163 +772,24 @@\n (define_expand \"movsi\"\n   [(set\n     (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-    (match_operand:SI 1 \"cris_general_operand_or_symbol\" \"\"))]\n+    (match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  enum cris_symbol_type t;\n-\n   /* If the output goes to a MEM, make sure we have zero or a register as\n      input.  */\n   if (MEM_P (operands[0])\n       && ! REG_S_P (operands[1])\n       && operands[1] != const0_rtx\n       && can_create_pseudo_p ())\n     operands[1] = force_reg (SImode, operands[1]);\n-\n-  /* If we're generating PIC and have an incoming symbol, validize it to a\n-     general operand or something that will match a special pattern.\n-\n-     FIXME: Do we *have* to recognize anything that would normally be a\n-     valid symbol?  Can we exclude global PIC addresses with an added\n-     offset?  */\n-    if (flag_pic\n-\t&& CONSTANT_P (operands[1])\n-\t&& !cris_valid_pic_const (operands[1], false))\n-      {\n-\tt = cris_symbol_type_of (operands[1]);\n-\n-\tgcc_assert (t != cris_no_symbol && t != cris_offsettable_symbol);\n-\n-\tif (! REG_S_P (operands[0]))\n-\t  {\n-\t    /* We must have a register as destination for what we're about to\n-\t       do, and for the patterns we generate.  */\n-\t    CRIS_ASSERT (can_create_pseudo_p ());\n-\t    operands[1] = force_reg (SImode, operands[1]);\n-\t  }\n-\telse\n-\t  {\n-\t    /* FIXME: add a REG_EQUAL (or is it REG_EQUIV) note to the\n-\t       destination register for the symbol.  It might not be\n-\t       worth it.  Measure.  */\n-\t    crtl->uses_pic_offset_table = 1;\n-\t    if (t == cris_rel_symbol)\n-\t      {\n-\t\t/* Change a \"move.d sym(+offs),rN\" into (allocate register rM)\n-\t\t   for pre-v32:\n-\t\t   \"move.d (const (plus (unspec [sym]\n-\t\t    CRIS_UNSPEC_GOTREL) offs)),rM\" \"add.d rPIC,rM,rN\"\n-\t\t   and for v32:\n-\t\t   \"move.d (const (plus (unspec [sym]\n-\t\t    CRIS_UNSPEC_PCREL) offs)),rN\".  */\n-\t\trtx tem, rm, rn = operands[0];\n-\t\trtx sym = GET_CODE (operands[1]) != CONST\n-\t\t  ? operands[1] : get_related_value (operands[1]);\n-\t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n-\n-\t\tgcc_assert (can_create_pseudo_p ());\n-\n-\t\tif (TARGET_V32)\n-\t\t  {\n-\t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n-\t\t\t\t\t  CRIS_UNSPEC_PCREL);\n-\t\t    if (offs != 0)\n-\t\t      tem = plus_constant (Pmode, tem, offs);\n-\t\t    rm = rn;\n-\t\t    emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* We still uses GOT-relative addressing for\n-\t\t       pre-v32.\t */\n-\t\t    crtl->uses_pic_offset_table = 1;\n-\t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n-\t\t\t\t\t  CRIS_UNSPEC_GOTREL);\n-\t\t    if (offs != 0)\n-\t\t      tem = plus_constant (Pmode, tem, offs);\n-\t\t    rm = gen_reg_rtx (Pmode);\n-\t\t    emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n-\t\t    if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n-\t\t\t\t      rn, 0, OPTAB_LIB_WIDEN) != rn)\n-\t\t      internal_error (\"expand_binop failed in movsi gotrel\");\n-\t\t  }\n-\t\tDONE;\n-\t      }\n-\t    else if (t == cris_got_symbol)\n-\t      {\n-\t\t/* Change a \"move.d sym,rN\" into (allocate register rM, rO)\n-\t\t   \"move.d (const (unspec [sym] CRIS_UNSPEC_GOTREAD)),rM\"\n-\t\t   \"add.d rPIC,rM,rO\", \"move.d [rO],rN\" with\n-\t\t   the memory access marked as read-only.  */\n-\t\trtx tem, mem, rm, ro, rn = operands[0];\n-\t\tgcc_assert (can_create_pseudo_p ());\n-\t\ttem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, operands[1]),\n-\t\t\t\t      CRIS_UNSPEC_GOTREAD);\n-\t\trm = gen_reg_rtx (Pmode);\n-\t\temit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n-\t\tro = gen_reg_rtx (Pmode);\n-\t        if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n-\t\t\t\t  ro, 0, OPTAB_LIB_WIDEN) != ro)\n-\t\t  internal_error (\"expand_binop failed in movsi got\");\n-\t\tmem = gen_rtx_MEM (Pmode, ro);\n-\n-\t\t/* This MEM doesn't alias anything.  Whether it\n-\t\t   aliases other same symbols is unimportant.  */\n-\t\tset_mem_alias_set (mem, new_alias_set ());\n-\t\tMEM_NOTRAP_P (mem) = 1;\n-\n-\t\t/* We can set the GOT memory read of a non-called symbol\n-\t\t   to readonly, but not that of a call symbol, as those\n-\t\t   are subject to lazy evaluation and usually have the value\n-\t\t   changed from the first call to the second (but\n-\t\t   constant thereafter).  */\n-\t\tMEM_READONLY_P (mem) = 1;\n-\t\temit_move_insn (rn, mem);\n-\t\tDONE;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* We get here when we have to change something that would\n-\t\t   be recognizable if it wasn't PIC.  A ``sym'' is ok for\n-\t\t   PIC symbols both with and without a GOT entry.  And ``sym\n-\t\t   + offset'' is ok for local symbols, so the only thing it\n-\t\t   could be, is a global symbol with an offset.  Check and\n-\t\t   abort if not.  */\n-\t\trtx reg = gen_reg_rtx (Pmode);\n-\t\trtx sym = get_related_value (operands[1]);\n-\t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n-\n-\t\tgcc_assert (can_create_pseudo_p ()\n-\t\t\t    && t == cris_got_symbol_needing_fixup\n-\t\t\t    && sym != NULL_RTX && offs != 0);\n-\n-\t\temit_move_insn (reg, sym);\n-\t\tif (expand_binop (SImode, add_optab, reg,\n-\t\t\t\t  GEN_INT (offs), operands[0], 0,\n-\t\t\t\t  OPTAB_LIB_WIDEN) != operands[0])\n-\t\t  internal_error (\"expand_binop failed in movsi got+offs\");\n-\t\tDONE;\n-\t      }\n-\t  }\n-      }\n })\n \n-(define_insn \"*movsi_got_load\"\n-  [(set (reg:SI CRIS_GOT_REGNUM) (unspec:SI [(const_int 0)] CRIS_UNSPEC_GOT))]\n-  \"flag_pic\"\n-{\n-  return TARGET_V32\n-    ? \"lapc _GLOBAL_OFFSET_TABLE_,%:\"\n-    : \"move.d $pc,%:\\;sub.d .:GOTOFF,%:\";\n-}\n-  [(set_attr \"cc\" \"clobber\")])\n-\n (define_insn \"*movsi_internal\"\n   [(set\n     (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t      \"=r,r, r,Q>,r,Q>,g,r,r, r,g,rQ>,x,  m,x\")\n-    (match_operand:SI 1 \"cris_general_operand_or_pic_source\"\n-\t\t       \"r,Q>,M,M, I,r, M,n,!S,g,r,x,  rQ>,x,gi\"))]\n+\t\t      \"=r,r, r,Q>,r,Q>,g,r,r,g,rQ>,x,  m,x\")\n+    (match_operand:SI 1 \"general_operand\"\n+\t\t       \"r,Q>,M,M, I,r, M,n,g,r,x,  rQ>,x,gi\"))]\n     ;; Note that we prefer not to use the S alternative (if for some reason\n     ;; it competes with others) above, but g matches S.\n   \"\"\n@@ -1083,44 +799,18 @@\n      letters.  FIXME: Check again.  It seems this could shrink a bit.  */\n   switch (which_alternative)\n     {\n-    case 9:\n-      if (TARGET_V32)\n-       {\n-\t if (!flag_pic\n-\t     && (GET_CODE (operands[1]) == SYMBOL_REF\n-\t\t || GET_CODE (operands[1]) == LABEL_REF\n-\t\t || (GET_CODE (operands[1]) == CONST\n-\t\t     && (GET_CODE (XEXP (operands[1], 0)) != UNSPEC\n-\t\t\t || (XINT (XEXP (operands[1], 0), 1)\n-\t\t\t     == CRIS_UNSPEC_PLT_PCREL)\n-\t\t\t || (XINT (XEXP (operands[1], 0), 1)\n-\t\t\t     == CRIS_UNSPEC_PCREL)))))\n-\t   {\n-\t     /* FIXME: Express this through (set_attr cc none) instead,\n-\t\tsince we can't express the ``none'' at this point.  FIXME:\n-\t\tUse lapc for everything except const_int and when next cc0\n-\t\tuser would want the flag setting.  */\n-\t     CC_STATUS_INIT;\n-\t     return \"lapc %1,%0\";\n-\t   }\n-\t if (flag_pic == 1\n-\t     && GET_CODE (operands[1]) == CONST\n-\t     && GET_CODE (XEXP (operands[1], 0)) == UNSPEC\n-\t     && XINT (XEXP (operands[1], 0), 1) == CRIS_UNSPEC_GOTREAD)\n-\t   return \"movu.w %1,%0\";\n-       }\n-       /* FALLTHROUGH */\n     case 0:\n     case 1:\n     case 5:\n-    case 10:\n+    case 8:\n+    case 9:\n       return \"move.d %1,%0\";\n \n+    case 10:\n     case 11:\n     case 12:\n     case 13:\n-    case 14:\n-      return \"move %d1,%0\";\n+      return \"move %1,%0\";\n \n     case 2:\n     case 3:\n@@ -1147,54 +837,12 @@\n \t}\n       return \"move.d %1,%0\";\n \n-    case 8:\n-      {\n-\trtx tem = operands[1];\n-\tgcc_assert (GET_CODE (tem) == CONST);\n-\ttem = XEXP (tem, 0);\n-\tif (GET_CODE (tem) == PLUS\n-\t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n-\t    && (XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n-\t\t|| XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_PCREL)\n-\t    && CONST_INT_P (XEXP (tem, 1)))\n-\t  tem = XEXP (tem, 0);\n-\tgcc_assert (GET_CODE (tem) == UNSPEC);\n-\tswitch (XINT (tem, 1))\n-\t  {\n-\t  case CRIS_UNSPEC_GOTREAD:\n-\t  case CRIS_UNSPEC_PLTGOTREAD:\n-\t    /* Using sign-extend mostly to be consistent with the\n-\t       indexed addressing mode.  */\n-\t    if (flag_pic == 1)\n-\t      return \"movs.w %1,%0\";\n-\t    return \"move.d %1,%0\";\n-\n-\t  case CRIS_UNSPEC_GOTREL:\n-\t  case CRIS_UNSPEC_PLT_GOTREL:\n-\t    gcc_assert (!TARGET_V32);\n-\t    return \"move.d %1,%0\";\n-\n-\t  case CRIS_UNSPEC_PCREL:\n-\t  case CRIS_UNSPEC_PLT_PCREL:\n-\t    gcc_assert (TARGET_V32);\n-\t    /* LAPC doesn't set condition codes; clear them to make the\n-\t       (equivalence-marked) result of this insn not presumed\n-\t       present.  This instruction can be a PIC symbol load (for\n-\t       a hidden symbol) which for weak symbols will be followed\n-\t       by a test for NULL.  */\n-\t    CC_STATUS_INIT;\n-\t    return \"lapc %1,%0\";\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-      }\n     default:\n-      return \"BOGUS: %1 to %0\";\n+      gcc_unreachable ();\n     }\n }\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,no,no,no,yes,yes,no,no\")\n-   (set_attr \"cc\" \"*,*,*,*,*,*,*,*,*,*,*,none,none,none,none\")])\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,no,no,yes,yes,no,no\")\n+   (set_attr \"cc\" \"*,*,*,*,*,*,*,*,*,*,none,none,none,none\")])\n \f\n ;; Extend operations with side-effect from mem to register, using\n ;; MOVS/MOVU.  These are from mem to register only.\n@@ -1431,66 +1079,9 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no,yes,yes,yes,no,yes,no\")])\n \f\n ;; Movem patterns.  Primarily for use in function prologue and epilogue.\n-;; The V32 variants have an ordering matching the expectations of the\n-;; standard names \"load_multiple\" and \"store_multiple\"; pre-v32 movem\n-;; store R0 in the highest memory location.\n-\n-(define_expand \"load_multiple\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"memory_operand\" \"\")\n-   (match_operand:SI 2 \"const_int_operand\" \"\")]\n-  \"TARGET_V32\"\n-{\n-  rtx indreg;\n-\n-  /* Apparently the predicate isn't checked, so we need to do so\n-     manually.  Once happened for libstdc++-v3 locale_facets.tcc.  */\n-  if (!MEM_P (operands[1]))\n-    FAIL;\n-\n-  indreg = XEXP (operands[1], 0);\n-\n-  if (GET_CODE (indreg) == POST_INC)\n-    indreg = XEXP (indreg, 0);\n-  if (!REG_P (indreg)\n-      || GET_CODE (operands[2]) != CONST_INT\n-      || !REG_P (operands[0])\n-      || REGNO (operands[0]) != 0\n-      || INTVAL (operands[2]) > CRIS_SP_REGNUM\n-      || (int) REGNO (indreg) < INTVAL (operands[2]))\n-    FAIL;\n-  gcc_unreachable ();\n-  emit_insn (cris_gen_movem_load (operands[1], operands[2], 0));\n-  DONE;\n-})\n-\n-(define_expand \"store_multiple\"\n-  [(match_operand:SI 0 \"memory_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"\")\n-   (match_operand:SI 2 \"const_int_operand\" \"\")]\n-  \"TARGET_V32\"\n-{\n-  rtx indreg;\n-\n-  /* See load_multiple.  */\n-  if (!MEM_P (operands[0]))\n-    FAIL;\n-\n-  indreg = XEXP (operands[0], 0);\n-\n-  if (GET_CODE (indreg) == POST_INC)\n-    indreg = XEXP (indreg, 0);\n-  if (!REG_P (indreg)\n-      || GET_CODE (operands[2]) != CONST_INT\n-      || !REG_P (operands[1])\n-      || REGNO (operands[1]) != 0\n-      || INTVAL (operands[2]) > CRIS_SP_REGNUM\n-      || (int) REGNO (indreg) < INTVAL (operands[2]))\n-    FAIL;\n-  gcc_unreachable ();\n-  cris_emit_movem_store (operands[0], operands[2], 0, false);\n-  DONE;\n-})\n+;; Unfortunately, movem stores R0 in the highest memory location, thus\n+;; the opposite of the expectation for the standard names \"load_multiple\"\n+;; and \"store_multiple\".\n \n (define_insn \"*cris_load_multiple\"\n   [(match_parallel 0 \"cris_load_multiple_op\"\n@@ -1697,37 +1288,20 @@\n \t(plus:DI (match_operand:DI 1 \"register_operand\")\n \t\t (match_operand:DI 2 \"general_operand\")))]\n   \"\"\n-{\n-  if (MEM_P (operands[2]) && TARGET_V32)\n-    operands[2] = force_reg (DImode, operands[2]);\n-})\n+  \"\")\n \n-(define_insn \"*adddi3_non_v32\"\n+(define_insn \"*adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,&r,&r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0,0,r\")\n \t\t (match_operand:DI 2 \"general_operand\" \"J,N,P,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    addq %2,%M0\\;ax\\;addq 0,%H0\n    subq %n2,%M0\\;ax\\;subq 0,%H0\n    add%e2.%z2 %2,%M0\\;ax\\;%A2 %H2,%H0\n    add.d %M2,%M0\\;ax\\;add.d %H2,%H0\n    add.d %M2,%M1,%M0\\;ax\\;add.d %H2,%H1,%H0\")\n \n-; It seems no use allowing a memory operand for this one, because we'd\n-; need a scratch register for incrementing the address.\n-(define_insn \"*adddi3_v32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r,r\")\n-       (plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0,0,0\")\n-                (match_operand:DI 2 \"nonmemory_operand\" \"J,N,P,r,n\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   addq %2,%M0\\;addc 0,%H0\n-   subq %n2,%M0\\;ax\\;subq 0,%H0\n-   add%e2.%z2 %2,%M0\\;addc %H2,%H0\n-   add.d %M2,%M0\\;addc %H2,%H0\n-   add.d %M2,%M0\\;addc %H2,%H0\")\n-\n (define_expand \"add<mode>3\"\n   [(set (match_operand:BWD 0 \"register_operand\")\n \t(plus:BWD\n@@ -1736,18 +1310,18 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*addsi3_non_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\"  \"=r,r, r,r,r,r, r,r,  r\")\n+(define_insn \"*addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"  \"=r,r, r,r,r,r,r,  r\")\n \t(plus:SI\n-\t (match_operand:SI 1 \"register_operand\" \"%0,0, 0,0,0,0, 0,r,  r\")\n-\t (match_operand:SI 2 \"general_operand\"   \"r,Q>,J,N,n,!S,g,!To,0\")))]\n+\t (match_operand:SI 1 \"register_operand\" \"%0,0, 0,0,0,0,r,  r\")\n+\t (match_operand:SI 2 \"general_operand\"   \"r,Q>,J,N,n,g,!To,0\")))]\n \n ;; The last constraint is due to that after reload, the '%' is not\n ;; honored, and canonicalization doesn't care about keeping the same\n ;; register as in destination.  This will happen after insn splitting.\n ;; gcc <= 2.7.2.  FIXME: Check for gcc-2.9x\n \n- \"!TARGET_V32\"\n+ \"\"\n {\n   switch (which_alternative)\n     {\n@@ -1777,78 +1351,22 @@\n \t}\n       return \"add.d %2,%0\";\n     case 5:\n-      {\n-\trtx tem = operands[2];\n-\tgcc_assert (GET_CODE (tem) == CONST);\n-\ttem = XEXP (tem, 0);\n-\tif (GET_CODE (tem) == PLUS\n-\t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n-\t    /* We don't allow CRIS_UNSPEC_PCREL here; we can't have a\n-\t       pc-relative operand in an add insn.  */\n-\t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n-\t    && CONST_INT_P (XEXP (tem, 1)))\n-\t  tem = XEXP (tem, 0);\n-\tgcc_assert (GET_CODE (tem) == UNSPEC);\n-\tswitch (XINT (tem, 1))\n-\t  {\n-\t  case CRIS_UNSPEC_GOTREAD:\n-\t  case CRIS_UNSPEC_PLTGOTREAD:\n-\t    /* Using sign-extend mostly to be consistent with the\n-\t       indexed addressing mode.  */\n-\t    if (flag_pic == 1)\n-\t      return \"adds.w %2,%0\";\n-\t    return \"add.d %2,%0\";\n-\n-\t  case CRIS_UNSPEC_PLT_GOTREL:\n-\t  case CRIS_UNSPEC_GOTREL:\n-\t    return \"add.d %2,%0\";\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-      }\n+      return \"add.d %2,%0\";\n     case 6:\n-      return \"add%u2 %2,%0\";\n-    case 7:\n       return \"add.d %2,%1,%0\";\n-    case 8:\n+    case 7:\n       return \"add.d %1,%0\";\n     default:\n       return \"BOGUS addsi %2+%1 to %0\";\n     }\n }\n- [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,no,yes\")])\n-\n-; FIXME: Check what's best: having the three-operand ACR alternative\n-; before or after the corresponding-operand2 alternative.  Check for\n-; *all* insns.  FIXME: constant constraint letter for -128..127.\n-(define_insn \"*addsi3_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\"  \"=r,!a,r,!a, r,r,!a,r,!a,r,r,r,!a\")\n-\t(plus:SI\n-\t (match_operand:SI 1 \"register_operand\" \"%0,r, 0, r, 0,0,r, 0,r, 0,0,0,r\")\n-\t (match_operand:SI 2 \"general_operand\"  \"r, r, Q>,Q>,J,N,NJ,L,L, P,n,g,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   add.d %2,%0\n-   addi %2.b,%1,%0\n-   add.d %2,%0\n-   addo.d %2,%1,%0\n-   addq %2,%0\n-   subq %n2,%0\n-   addoq %2,%1,%0\n-   adds.w %2,%0\n-   addo %2,%1,%0\n-   addu.w %2,%0\n-   add.d %2,%0\n-   add%u2 %2,%0\n-   addo.%Z2 %2,%1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,yes,no,no,no,no,no,no\")\n-   (set_attr \"cc\" \"*,none,*,none,*,*,none,*,none,*,*,*,none\")])\n+ [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,yes\")])\n \f\n-(define_insn \"*addhi3_non_v32\"\n+(define_insn \"*addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"\t\t\"=r,r, r,r,r,r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0, 0,0,0,r\")\n \t\t (match_operand:HI 2 \"general_operand\"   \"r,Q>,J,N,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    add.w %2,%0\n    add.w %2,%0\n@@ -1859,30 +1377,11 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,clobber,normal,normal\")])\n \n-(define_insn \"*addhi3_v32\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r, !a,r,!a, r,r,!a,r,!a\")\n-\t(plus:HI\n-\t (match_operand:HI 1 \"register_operand\" \"%0,r, 0, r, 0,0,r, 0,r\")\n-\t (match_operand:HI 2 \"general_operand\"  \"r, r, Q>,Q>,J,N,NJ,g,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   add.w %2,%0\n-   addi %2.b,%1,%0\n-   add.w %2,%0\n-   addo.w %2,%1,%0\n-   addq %2,%0\n-   subq %n2,%0\n-   addoq %2,%1,%0\n-   add.w %2,%0\n-   addo.w %2,%1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,yes,no,no\")\n-   (set_attr \"cc\" \"*,none,*,none,clobber,clobber,none,*,none\")])\n-\n-(define_insn \"*addqi3_non_v32\"\n+(define_insn \"*addqi3\"\n   [(set (match_operand:QI 0 \"register_operand\"\t\t\"=r,r, r,r,r,r,r\")\n \t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0,0, 0,0,0,0,r\")\n \t\t (match_operand:QI 2 \"general_operand\"\t \"r,Q>,J,N,O,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    add.b %2,%0\n    add.b %2,%0\n@@ -1893,26 +1392,6 @@\n    add.b %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,clobber,clobber,normal,normal\")])\n-\n-(define_insn \"*addqi3_v32\"\n-  [(set (match_operand:QI 0 \"register_operand\"  \"=r,!a,r,!a, r,r,!a,r,r,!a\")\n-\t(plus:QI\n-\t (match_operand:QI 1 \"register_operand\" \"%0,r, 0, r, 0,0,r, 0,0,r\")\n-\t (match_operand:QI 2 \"general_operand\"   \"r,r, Q>,Q>,J,N,NJ,O,g,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   add.b %2,%0\n-   addi %2.b,%1,%0\n-   add.b %2,%0\n-   addo.b %2,%1,%0\n-   addq %2,%0\n-   subq %n2,%0\n-   addoq %2,%1,%0\n-   subQ -%b2,%0\n-   add.b %2,%0\n-   addo.b %2,%1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,yes,yes,no,no\")\n-   (set_attr \"cc\" \"*,none,*,none,clobber,clobber,none,clobber,*,none\")])\n \f\n ;; Subtract.\n ;;\n@@ -1927,34 +1406,20 @@\n \t(minus:DI (match_operand:DI 1 \"register_operand\")\n \t\t  (match_operand:DI 2 \"general_operand\")))]\n   \"\"\n-{\n-  if (TARGET_V32 && MEM_P (operands[2]))\n-    operands[2] = force_reg (DImode, operands[2]);\n-})\n+  \"\")\n \n-(define_insn \"*subdi3_non_v32\"\n+(define_insn \"*subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,&r,&r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,0,0,0,r\")\n \t\t  (match_operand:DI 2 \"general_operand\" \"J,N,P,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    subq %2,%M0\\;ax\\;subq 0,%H0\n    addq %n2,%M0\\;ax\\;addq 0,%H0\n    sub%e2.%z2 %2,%M0\\;ax\\;%D2 %H2,%H0\n    sub.d %M2,%M0\\;ax\\;sub.d %H2,%H0\n    sub.d %M2,%M1,%M0\\;ax\\;sub.d %H2,%H1,%H0\")\n \n-(define_insn \"*subdi3_v32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,&r\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,0,0,0\")\n-\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"J,N,P,r\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   subq %2,%M0\\;ax\\;subq 0,%H0\n-   addq %n2,%M0\\;ax\\;addq 0,%H0\n-   sub%e2.%z2 %2,%M0\\;ax\\;%D2 %H2,%H0\n-   sub.d %M2,%M0\\;ax\\;sub.d %H2,%H0\")\n-\n (define_expand \"sub<mode>3\"\n   [(set (match_operand:BWD 0 \"register_operand\")\n \t(minus:BWD\n@@ -1963,12 +1428,12 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*subsi3_non_v32\"\n+(define_insn \"*subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r, r,r,r,r,r,r\")\n \t(minus:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0, 0,0,0,0,0,r\")\n \t (match_operand:SI 2 \"general_operand\"\t\"r,Q>,J,N,P,n,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n \n ;; This does not do the optimal: \"addu.w 65535,r0\" when %2 is negative.\n ;; But then again, %2 should not be negative.\n@@ -1983,28 +1448,12 @@\n    sub.d %2,%0\n    sub.d %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,no\")])\n-\n-(define_insn \"*subsi3_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r,r,r\")\n-       (minus:SI\n-        (match_operand:SI 1 \"register_operand\" \"0,0,0,0,0,0,0\")\n-        (match_operand:SI 2 \"general_operand\" \"r,Q>,J,N,P,n,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   sub.d %2,%0\n-   sub.d %2,%0\n-   subq %2,%0\n-   addq %n2,%0\n-   sub%e2.%z2 %2,%0\n-   sub.d %2,%0\n-   sub.d %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no\")])\n \f\n-(define_insn \"*sub<mode>3_nonv32\"\n+(define_insn \"*sub<mode>3\"\n   [(set (match_operand:BW 0 \"register_operand\"\t\t\"=r,r, r,r,r,r\")\n \t(minus:BW (match_operand:BW 1 \"register_operand\" \"0,0, 0,0,0,r\")\n \t\t  (match_operand:BW 2 \"general_operand\"  \"r,Q>,J,N,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    sub<m> %2,%0\n    sub<m> %2,%0\n@@ -2014,20 +1463,6 @@\n    sub<m> %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,clobber,normal,normal\")])\n-\n-(define_insn \"*sub<mode>3_v32\"\n-  [(set (match_operand:BW 0 \"register_operand\" \"=r,r,r,r,r\")\n-\t(minus:BW (match_operand:BW 1 \"register_operand\" \"0,0,0,0,0\")\n-\t\t  (match_operand:BW 2 \"general_operand\" \"r,Q>,J,N,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   sub<m> %2,%0\n-   sub<m> %2,%0\n-   subq %2,%0\n-   addq %n2,%0\n-   sub<m> %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,no\")\n-   (set_attr \"cc\" \"normal,normal,clobber,clobber,normal\")])\n \f\n ;; CRIS has some add/sub-with-sign/zero-extend instructions.\n ;;  Although these perform sign/zero-extension to SImode, they are\n@@ -2261,15 +1696,15 @@\n ;; QImode to HImode\n ;; FIXME: GCC should widen.\n \n-(define_insn \"*extopqihi_non_v32\"\n+(define_insn \"*extopqihi\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r\")\n \t(match_operator:HI\n \t 3 \"cris_additive_operand_extend_operator\"\n \t [(match_operand:HI 1 \"register_operand\" \"0,0,0,r\")\n \t  (match_operator:HI\n \t   4 \"cris_extend_operator\"\n \t   [(match_operand:QI 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])]))]\n-  \"!TARGET_V32 && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n+  \"GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && (operands[1] != frame_pointer_rtx || GET_CODE (operands[3]) != PLUS)\"\n   \"@\n    %x3%E4.%m4 %2,%0\n@@ -2279,31 +1714,17 @@\n   [(set_attr \"slottable\" \"yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"*extopqihi_v32\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(match_operator:HI\n-\t 3 \"cris_additive_operand_extend_operator\"\n-\t [(match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t  (match_operator:HI\n-\t   4 \"cris_extend_operator\"\n-\t   [(match_operand:QI 2 \"nonimmediate_operand\" \"r,m\")])]))]\n-  \"TARGET_V32\"\n-  \"%x3%e4.%m4 %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n ;; QImode to SImode\n \n-(define_insn \"*extop<mode>si_non_v32\"\n+(define_insn \"*extop<mode>si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(match_operator:SI\n \t 3 \"cris_operand_extend_operator\"\n \t [(match_operand:SI 1 \"register_operand\" \"0,0,0,r\")\n \t  (match_operator:SI\n \t   4 \"cris_extend_operator\"\n \t   [(match_operand:BW 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])]))]\n-  \"!TARGET_V32\n-   && (GET_CODE (operands[3]) != UMIN || GET_CODE (operands[4]) == ZERO_EXTEND)\n+  \"(GET_CODE (operands[3]) != UMIN || GET_CODE (operands[4]) == ZERO_EXTEND)\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && (operands[1] != frame_pointer_rtx || GET_CODE (operands[3]) != PLUS)\"\n   \"@\n@@ -2312,32 +1733,20 @@\n    %x3%E4<m> %2,%0\n    %x3%E4<m> %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no,no\")])\n-\n-(define_insn \"*extop<mode>si_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(match_operator:SI\n-\t 3 \"cris_additive_operand_extend_operator\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t  (match_operator:SI\n-\t   4 \"cris_extend_operator\"\n-\t   [(match_operand:BW 2 \"nonimmediate_operand\" \"r,m\")])]))]\n-  \"TARGET_V32\"\n-  \"%x3%e4.%m4 %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n \f\n ;; As with the side-effect patterns, may have to have swapped operands for add.\n ;; For commutative operands, these are the canonical forms.\n \n ;; QImode to HImode\n \n-(define_insn \"*addxqihi_swap_non_v32\"\n+(define_insn \"*addxqihi_swap\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r\")\n \t(plus:HI\n \t (match_operator:HI\n \t  3 \"cris_extend_operator\"\n \t  [(match_operand:QI 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])\n \t (match_operand:HI 1 \"register_operand\" \"0,0,0,r\")))]\n-  \"!TARGET_V32 && operands[1] != frame_pointer_rtx\"\n+  \"operands[1] != frame_pointer_rtx\"\n   \"@\n    add%e3.b %2,%0\n    add%e3.b %2,%0\n@@ -2346,85 +1755,22 @@\n   [(set_attr \"slottable\" \"yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber\")])\n \n-;; A case for v32, to catch the \"addo\" insn in addition to \"adds\".  We\n-;; only care to match the canonical form; there should be no other.\n-\n-(define_insn \"*addsbw_v32\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,!a\")\n-\t(plus:HI\n-\t (sign_extend:HI\n-\t  (match_operand:QI 2 \"nonimmediate_operand\" \"r,m,m\"))\n-\t (match_operand:HI 1 \"register_operand\" \"0,0,r\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   adds.b %2,%0\n-   adds.b %2,%0\n-   addo.b %2,%1,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"clobber,clobber,none\")])\n-\n-(define_insn \"*addubw_v32\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(plus:HI\n-\t (zero_extend:HI\n-\t  (match_operand:QI 2 \"nonimmediate_operand\" \"r,m\"))\n-\t (match_operand:HI 1 \"register_operand\" \"0,0\")))]\n-  \"TARGET_V32\"\n-  \"addu.b %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"*extop<mode>si_swap_non_v32\"\n+(define_insn \"*extop<mode>si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(match_operator:SI\n \t 4 \"cris_plus_or_bound_operator\"\n \t [(match_operator:SI\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand:BW 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])\n \t  (match_operand:SI 1 \"register_operand\" \"0,0,0,r\")]))]\n-  \"!TARGET_V32\n-   && (GET_CODE (operands[4]) != UMIN || GET_CODE (operands[3]) == ZERO_EXTEND)\n+  \"(GET_CODE (operands[4]) != UMIN || GET_CODE (operands[3]) == ZERO_EXTEND)\n    && operands[1] != frame_pointer_rtx\"\n   \"@\n    %x4%E3<m> %2,%0\n    %x4%E3<m> %2,%0\n    %x4%E3<m> %2,%0\n    %x4%E3<m> %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no,no\")])\n-\n-(define_insn \"*adds<mode>_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,!a\")\n-\t(plus:SI\n-\t (sign_extend:SI\n-\t  (match_operand:BW 2 \"nonimmediate_operand\" \"r,m,m\"))\n-\t (match_operand:SI 1 \"register_operand\" \"0,0,r\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   adds<m> %2,%0\n-   adds<m> %2,%0\n-   addo<m> %2,%1,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"*,*,none\")])\n-\n-(define_insn \"*addu<mode>_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-       (plus:SI\n-        (zero_extend:SI\n-          (match_operand:BW 2 \"nonimmediate_operand\" \"r,m\"))\n-        (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n-  \"TARGET_V32 && operands[1] != frame_pointer_rtx\"\n-  \"addu<m> %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n-\n-(define_insn \"*bound<mode>_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-       (umin:SI\n-        (zero_extend:SI\n-         (match_operand:BW 2 \"register_operand\" \"r\"))\n-        (match_operand:SI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_V32 && operands[1] != frame_pointer_rtx\"\n-  \"bound<m> %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n \f\n ;; This is the special case when we use what corresponds to the\n ;; instruction above in \"casesi\".  Do *not* change it to use the generic\n@@ -2458,29 +1804,9 @@\n \t\t  (pc))\n \t (label_ref (match_operand 2 \"\" \"\"))))\n    (use (label_ref (match_operand 3 \"\" \"\")))]\n-  \"!TARGET_V32 && operands[0] != frame_pointer_rtx\"\n+  \"operands[0] != frame_pointer_rtx\"\n   \"adds.w [$pc+%0.w],$pc\"\n   [(set_attr \"cc\" \"clobber\")])\n-\n-;; For V32, we just have a jump, but we need to mark the table as used,\n-;; and the jump insn must have the if_then_else form expected by core\n-;; GCC.  Since we don't want to prolong the lifetime of the original\n-;; index value, we compare against \"unspec 0\".  It's a pity we have to\n-;; jump through to get the default label in place and to keep the jump\n-;; table around.  FIXME: Look into it some time.\n-\n-(define_insn \"*casesi_jump_v32\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ltu (unspec [(const_int 0)] CRIS_UNSPEC_CASESI)\n-\t      (match_operand:SI 0 \"const_int_operand\" \"n\"))\n-\t (match_operand:SI 1 \"register_operand\" \"r\")\n-\t (label_ref (match_operand 2 \"\" \"\"))))\n-   (use (label_ref (match_operand 3 \"\" \"\")))]\n-  \"TARGET_V32\"\n-  \"jump %1%#\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"slottable\" \"has_slot\")])\n \f\n ;; Multiply instructions.\n \n@@ -2520,24 +1846,18 @@\n \n ;; The addi insn as it is normally used.\n \n-;; Make the ACR alternative taste bad enough to not choose it as a\n-;; preference to avoid spilling problems (unwind-dw2-fde.c at build).\n-;; FIXME: Revisit for new register allocator.\n-\n (define_insn \"*addi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,!a\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI\n-\t (mult:SI (match_operand:SI 2 \"register_operand\" \"r,r\")\n-\t\t  (match_operand:SI 3 \"const_int_operand\" \"n,n\"))\n-\t (match_operand:SI 1 \"register_operand\" \"0,r\")))]\n+\t (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 3 \"const_int_operand\" \"n\"))\n+\t (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"operands[0] != frame_pointer_rtx\n    && operands[1] != frame_pointer_rtx\n    && CONST_INT_P (operands[3])\n    && (INTVAL (operands[3]) == 1\n        || INTVAL (operands[3]) == 2 || INTVAL (operands[3]) == 4)\"\n-  \"@\n-   addi %2%T3,%0\n-   addi %2%T3,%1,%0\"\n+  \"addi %2%T3,%0\"\n   [(set_attr \"slottable\" \"yes\")\n    (set_attr \"cc\" \"none\")])\n \n@@ -2554,7 +1874,7 @@\n \t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n \t (ashift:SI (match_operand:SI 3 \"register_operand\" \"0\")\n \t\t    (const_int 1))))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"mstep %2,%0\"\n   [(set_attr \"slottable\" \"yes\")])\n \n@@ -2572,8 +1892,7 @@\n \t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n \t (mult:SI (match_operand:SI 3 \"register_operand\" \"0\")\n \t\t  (const_int 2))))]\n-  \"!TARGET_V32\n-   && operands[0] != frame_pointer_rtx\n+  \"operands[0] != frame_pointer_rtx\n    && operands[1] != frame_pointer_rtx\n    && operands[2] != frame_pointer_rtx\n    && operands[3] != frame_pointer_rtx\"\n@@ -2682,8 +2001,7 @@\n \t\t\t(const_int 1))))]\n   \"\"\n   \"dstep %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n ;; Here's a variant with mult instead of ashift.\n ;;\n@@ -2705,8 +2023,7 @@\n    && operands[2] != frame_pointer_rtx\n    && operands[3] != frame_pointer_rtx\"\n   \"dstep %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \f\n ;; Logical operators.\n \n@@ -2800,31 +2117,18 @@\n ;; pressure (worse code).  That will hopefully change with an\n ;; improved reload pass.\n \n-(define_insn \"*expanded_andsi_non_v32\"\n+(define_insn \"*expanded_andsi\"\n   [(set (match_operand:SI 0 \"register_operand\"\t       \"=r,r,r, r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0, 0,r\")\n \t\t(match_operand:SI 2 \"general_operand\"   \"I,r,Q>,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    andq %2,%0\n    and.d %2,%0\n    and.d %2,%0\n    and.d %2,%0\n    and.d %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,no,no\")])\n-\n-(define_insn \"*expanded_andsi_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"I,r,Q>,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   andq %2,%0\n-   and.d %2,%0\n-   and.d %2,%0\n-   and.d %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,no\")\n-   (set_attr \"cc\" \"noov32\")])\n \f\n ;; For both QI and HI we may use the quick patterns.  This results in\n ;; useless condition codes, but that is used rarely enough for it to\n@@ -2887,7 +2191,7 @@\n \n ;; Catch-all andhi3 pattern.\n \n-(define_insn \"*expanded_andhi_non_v32\"\n+(define_insn \"*expanded_andhi\"\n   [(set (match_operand:HI 0 \"register_operand\"\t       \"=r,r,r, r,r,r,r\")\n \t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0, 0,0,0,r\")\n \t\t(match_operand:HI 2 \"general_operand\"   \"I,r,Q>,L,O,g,!To\")))]\n@@ -2897,7 +2201,7 @@\n ;; pressure (worse code).  That will hopefully change with an\n ;; improved reload pass.\n \n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    andq %2,%0\n    and.w %2,%0\n@@ -2909,21 +2213,6 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"*expanded_andhi_v32\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n-       (and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-               (match_operand:HI 2 \"general_operand\" \"I,r,Q>,L,O,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   andq %2,%0\n-   and.w %2,%0\n-   and.w %2,%0\n-   and.w %2,%0\n-   anDq %b2,%0\n-   and.w %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no\")\n-   (set_attr \"cc\" \"clobber,noov32,noov32,noov32,clobber,noov32\")])\n-\n ;; A strict_low_part pattern.\n \n ;; Note the use of (match_dup 0) for the first operand of the operation\n@@ -2936,6 +2225,7 @@\n ;;        (subreg:QI (reg:SI 15 acr [orig:27 D.7531 ] [27]) 0)\n ;;        (const_int -64 [0xf..fc0]))) x.c:126 147 {*andqi_lowpart_v32}\n ;;  (nil))\n+;; (Note: the example is obsolete.)\n ;; In theory, it could reload this as a movstrictqi of the register\n ;; operand at the and:QI to the destination register and change the\n ;; and:QI operand to the same as the read-write output operand and the\n@@ -2947,30 +2237,17 @@\n ;; match_dup.  FIXME: a sanity-check in gen* to refuse an insn with\n ;; input-constraints matching input-output-constraints, e.g. \"+r\" <- \"0\".\n \n-(define_insn \"*andhi_lowpart_non_v32\"\n+(define_insn \"*andhi_lowpart\"\n   [(set (strict_low_part\n \t (match_operand:HI 0 \"register_operand\"\t       \"+r,r,r\"))\n \t(and:HI (match_dup 0)\n \t\t(match_operand:HI 1 \"general_operand\"   \"r,Q>,g\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    and.w %1,%0\n    and.w %1,%0\n    and.w %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no\")])\n-\n-(define_insn \"*andhi_lowpart_v32\"\n-  [(set (strict_low_part\n-\t (match_operand:HI 0 \"register_operand\" \"+r,r,r\"))\n-\t(and:HI (match_dup 0)\n-\t\t(match_operand:HI 1 \"general_operand\" \"r,Q>,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   and.w %1,%0\n-   and.w %1,%0\n-   and.w %1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,no\")\n-   (set_attr \"cc\" \"noov32\")])\n \f\n (define_expand \"andqi3\"\n   [(set (match_operand:QI 0 \"register_operand\")\n@@ -2979,11 +2256,11 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*andqi3_non_v32\"\n+(define_insn \"*andqi3\"\n   [(set (match_operand:QI 0 \"register_operand\"\t       \"=r,r,r, r,r,r\")\n \t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0, 0,0,r\")\n \t\t(match_operand:QI 2 \"general_operand\"   \"I,r,Q>,O,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    andq %2,%0\n    and.b %2,%0\n@@ -2994,44 +2271,17 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"*andqi3_v32\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n-\t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"I,r,Q>,O,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   andq %2,%0\n-   and.b %2,%0\n-   and.b %2,%0\n-   andQ %b2,%0\n-   and.b %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,no\")\n-   (set_attr \"cc\" \"clobber,noov32,noov32,clobber,noov32\")])\n-\n-(define_insn \"*andqi_lowpart_non_v32\"\n+(define_insn \"*andqi_lowpart\"\n   [(set (strict_low_part\n \t (match_operand:QI 0 \"register_operand\"\t       \"+r,r,r\"))\n \t(and:QI (match_dup 0)\n \t\t(match_operand:QI 1 \"general_operand\"   \"r,Q>,g\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    and.b %1,%0\n    and.b %1,%0\n    and.b %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no\")])\n-\n-(define_insn \"*andqi_lowpart_v32\"\n-  [(set (strict_low_part\n-\t (match_operand:QI 0 \"register_operand\" \"+r,r,r\"))\n-\t(and:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"r,Q>,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   and.b %1,%0\n-   and.b %1,%0\n-   and.b %1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,no\")\n-   (set_attr \"cc\" \"noov32\")])\n \f\n ;; Bitwise or.\n \n@@ -3047,11 +2297,11 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*iorsi3_non_v32\"\n+(define_insn \"*iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"\t       \"=r,r,r, r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0, 0,0,r\")\n \t\t(match_operand:SI 2 \"general_operand\"  \"I, r,Q>,n,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    orq %2,%0\n    or.d %2,%0\n@@ -3062,25 +2312,11 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,no,no,no\")\n    (set_attr \"cc\" \"normal,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"*iorsi3_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"I,r,Q>,n,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   orq %2,%0\n-   or.d %2,%0\n-   or.d %2,%0\n-   oR.%s2 %2,%0\n-   or.d %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,no,no\")\n-   (set_attr \"cc\" \"noov32,noov32,noov32,clobber,noov32\")])\n-\n-(define_insn \"*iorhi3_non_v32\"\n+(define_insn \"*iorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"\t       \"=r,r,r, r,r,r,r\")\n \t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0, 0,0,0,r\")\n \t\t(match_operand:HI 2 \"general_operand\"   \"I,r,Q>,L,O,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    orq %2,%0\n    or.w %2,%0\n@@ -3092,26 +2328,11 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"*iorhi3_v32\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"I,r,Q>,L,O,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   orq %2,%0\n-   or.w %2,%0\n-   or.w %2,%0\n-   or.w %2,%0\n-   oRq %b2,%0\n-   or.w %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no\")\n-   (set_attr \"cc\" \"clobber,noov32,noov32,noov32,clobber,noov32\")])\n-\n-(define_insn \"*iorqi3_non_v32\"\n+(define_insn \"*iorqi3\"\n   [(set (match_operand:QI 0 \"register_operand\"\t       \"=r,r,r, r,r,r\")\n \t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0, 0,0,r\")\n \t\t(match_operand:QI 2 \"general_operand\"   \"I,r,Q>,O,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"@\n    orq %2,%0\n    or.b %2,%0\n@@ -3121,20 +2342,6 @@\n    or.b %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,clobber,normal,normal\")])\n-\n-(define_insn \"*iorqi3_v32\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n-\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"I,r,Q>,O,g\")))]\n-  \"TARGET_V32\"\n-  \"@\n-   orq %2,%0\n-   or.b %2,%0\n-   or.b %2,%0\n-   orQ %b2,%0\n-   or.b %2,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,no\")\n-   (set_attr \"cc\" \"clobber,noov32,noov32,clobber,noov32\")])\n \f\n ;; Exclusive-or\n \n@@ -3147,8 +2354,7 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"xor %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n (define_insn \"xor<mode>3\"\n   [(set (match_operand:BW 0 \"register_operand\" \"=r\")\n@@ -3205,8 +2411,7 @@\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"\"\n   \"not %0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n (define_insn \"one_cmpl<mode>2\"\n   [(set (match_operand:BW 0 \"register_operand\" \"=r\")\n@@ -3229,8 +2434,7 @@\n \n   return \"<slr>q %2,%0\";\n }\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n ;; Since gcc gets lost, and forgets to zero-extend the source (or mask\n ;; the destination) when it changes shifts of lower modes into SImode,\n@@ -3280,17 +2484,15 @@\n \t\t    (match_operand:BW 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"<slr><m> %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n (define_insn \"*<shlr><mode>_lowpart\"\n   [(set (strict_low_part (match_operand:BW 0 \"register_operand\" \"+r\"))\n \t(shiftrt:BW (match_dup 0)\n \t\t    (match_operand:BW 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"<slr><m> %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \f\n ;; Arithmetic/logical shift left.\n \n@@ -3311,7 +2513,7 @@\n        ? \"lslq %2,%0\" : \"lsl<m> %2,%0\");\n }\n   [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32,clobber\")])\n+   (set_attr \"cc\" \"*,clobber\")])\n \n ;; A strict_low_part matcher.\n \n@@ -3321,8 +2523,7 @@\n \t\t   (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"lsl<m> %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \f\n ;; Various strange insns that gcc likes.\n \n@@ -3340,8 +2541,7 @@\n \t(abs:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"abs %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n ;; FIXME: GCC should be able to do these expansions itself.\n \n@@ -3359,16 +2559,14 @@\n \t(clz:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"TARGET_HAS_LZ\"\n   \"lz %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n (define_insn \"bswapsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (bswap:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"TARGET_HAS_SWAP\"\n   \"swapwb %0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n ;; This instruction swaps all bits in a register.\n ;; That means that the most significant bit is put in the place\n@@ -3380,8 +2578,7 @@\n \t\t   CRIS_UNSPEC_SWAP_BITS))]\n   \"TARGET_HAS_SWAP\"\n   \"swapwbr %0\"\n-  [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"noov32\")])\n+  [(set_attr \"slottable\" \"yes\")])\n \n ;; Implement ctz using two instructions, one for bit swap and one for clz.\n ;; Defines a scratch register to avoid clobbering input.\n@@ -3405,16 +2602,13 @@\n \t(umin:SI  (match_operand:SI 1 \"register_operand\" \"\")\n \t\t  (match_operand:SI 2 \"general_operand\" \"\")))]\n   \"\"\n-{\n-  if (MEM_P (operands[2]) && TARGET_V32)\n-    operands[2] = force_reg (SImode, operands[2]);\n-})\n+  \"\")\n \n-(define_insn \"*uminsi3_non_v32\"\n+(define_insn \"*uminsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"\t\t \"=r,r, r,r\")\n \t(umin:SI  (match_operand:SI 1 \"register_operand\" \"%0,0, 0,r\")\n \t\t  (match_operand:SI 2 \"general_operand\"   \"r,Q>,g,!To\")))]\n-  \"!TARGET_V32\"\n+  \"\"\n {\n   if (CONST_INT_P (operands[2]))\n     {\n@@ -3435,30 +2629,6 @@\n   return \"bound.d %2,%0\";\n }\n  [(set_attr \"slottable\" \"yes,yes,no,no\")])\n-\n-(define_insn \"*uminsi3_v32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(umin:SI  (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n-  \"TARGET_V32\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      /* Constant operands are zero-extended, so only 32-bit operands\n-\t may be negative.  */\n-      if (INTVAL (operands[2]) >= 0)\n-\t{\n-\t  if (INTVAL (operands[2]) < 256)\n-\t    return \"bound.b %2,%0\";\n-\n-\t  if (INTVAL (operands[2]) < 65536)\n-\t    return \"bound.w %2,%0\";\n-\t}\n-    }\n-\n-  return \"bound.d %2,%0\";\n-}\n- [(set_attr \"slottable\" \"yes,no\")])\n \f\n ;; Jump and branch insns.\n \n@@ -3477,22 +2647,13 @@\n (define_expand \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\"))]\n   \"\"\n-{\n-  if (TARGET_V32 && MEM_P (operands[0]))\n-    operands[0] = force_reg (SImode, operands[0]);\n-})\n+  \"\")\n \n-(define_insn \"*indirect_jump_non_v32\"\n+(define_insn \"*indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"jump %0\")\n \n-(define_insn \"*indirect_jump_v32\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"TARGET_V32\"\n-  \"jump %0%#\"\n-  [(set_attr \"slottable\" \"has_slot\")])\n-\n ;; Return insn.  Used whenever the epilogue is very simple; if it is only\n ;; a single ret or jump [sp+].  No allocated stack space or saved\n ;; registers are allowed.\n@@ -3551,13 +2712,7 @@\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-{\n-  cris_reduce_compare (&operands[0], &operands[1], &operands[2]);\n-  if (TARGET_V32 && !REG_P (operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n-  if (TARGET_V32 && MEM_P (operands[2]))\n-    operands[2] = force_reg (DImode, operands[2]);\n-})\n+  \"cris_reduce_compare (&operands[0], &operands[1], &operands[2]);\")\n \n \n ;; We suffer from the same overflow-bit-gets-in-the-way problem as\n@@ -3652,13 +2807,7 @@\n \t(match_operator:SI 1 \"ordered_comparison_operator\"\n \t [(cc0) (const_int 0)]))]\n   \"\"\n-{\n-  cris_reduce_compare (&operands[1], &operands[2], &operands[3]);\n-  if (TARGET_V32 && !REG_P (operands[2]))\n-    operands[2] = force_reg (DImode, operands[2]);\n-  if (TARGET_V32 && MEM_P (operands[3]))\n-    operands[3] = force_reg (DImode, operands[3]);\n-})\n+  \"cris_reduce_compare (&operands[1], &operands[2], &operands[3]);\")\n \n (define_expand \"cstore<mode>4\"\n   [(set (cc0) (compare\n@@ -3715,73 +2864,31 @@\n ;; instructions is a different issue.\n \n (define_expand \"call\"\n-  [(parallel [(call (match_operand:QI 0 \"cris_mem_call_operand\" \"\")\n-\t\t    (match_operand 1 \"general_operand\" \"\"))\n+  [(parallel [(call (match_operand:SI 0 \"indirect_operand\")\n+\t\t    (match_operand 1 \"general_operand\"))\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"\"\n {\n-  gcc_assert (MEM_P (operands[0]));\n-  if (flag_pic)\n-    cris_expand_pic_call_address (&operands[0], &operands[1]);\n-  else\n-    operands[1] = const0_rtx;\n+  operands[1] = const0_rtx;\n })\n \n ;; Accept operands for operand 0 in order of preference.\n \n-(define_insn \"*expanded_call_non_v32\"\n+(define_insn \"*expanded_call\"\n   [(call (mem:QI (match_operand:SI 0 \"general_operand\" \"r,Q>,g\"))\n-\t (match_operand:SI 1 \"cris_call_type_marker\" \"rM,rM,rM\"))\n+\t (const_int 0))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"jsr %0\")\n \n-(define_insn \"*expanded_call_v32\"\n-  [(call\n-    (mem:QI\n-     (match_operand:SI 0 \"cris_nonmemory_operand_or_callable_symbol\" \"n,r,U,i\"))\n-    (match_operand:SI 1 \"cris_call_type_marker\" \"rM,rM,rM,rM\"))\n-   (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"TARGET_V32\"\n-  \"@\n-   jsr %0%#\n-   jsr %0%#\n-   bsr %0%#\n-   bsr %0%#\"\n-  [(set_attr \"slottable\" \"has_call_slot\")])\n-\n-;; Parallel when calculating and reusing address of indirect pointer\n-;; with simple offset.  (Makes most sense with PIC.)  It looks a bit\n-;; wrong not to have the clobber last, but that's the way combine\n-;; generates it (except it doesn't look into the *inner* mem, so this\n-;; just matches a peephole2).  FIXME: investigate that.\n-(define_insn \"*expanded_call_side\"\n-  [(call (mem:QI\n-\t  (mem:SI\n-\t   (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,  r,r\")\n-\t\t    (match_operand:SI 1 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n-\t (match_operand:SI 2 \"cris_call_type_marker\" \"rM,rM,rM\"))\n-   (clobber (reg:SI CRIS_SRP_REGNUM))\n-   (set (match_operand:SI 3 \"register_operand\" \"=*0,r,r\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 1)))]\n-  ;; Disabled until after reload until we can avoid an output reload for\n-  ;; operand 3 (being forbidden for call insns).\n-  \"reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32\"\n-  \"jsr [%3=%0%S1]\")\n-\n (define_expand \"call_value\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (match_operand:QI 1 \"cris_mem_call_operand\" \"\")\n-\t\t\t (match_operand 2 \"\" \"\")))\n+  [(parallel [(set (match_operand 0 \"\")\n+\t\t   (call (match_operand:SI 1 \"indirect_operand\")\n+\t\t\t (match_operand 2 \"\")))\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"\"\n {\n-  gcc_assert (MEM_P (operands[1]));\n-  if (flag_pic)\n-    cris_expand_pic_call_address (&operands[1], &operands[2]);\n-  else\n-    operands[2] = const0_rtx;\n+  operands[2] = const0_rtx;\n })\n \n ;; The validity other than \"general\" of\n@@ -3790,51 +2897,15 @@\n ;;  We also accept a PLT symbol.  We output it as [rPIC+sym:GOTPLT] rather\n ;; than requiring getting rPIC + sym:PLT into a register.\n \n-(define_insn \"*expanded_call_value_non_v32\"\n+(define_insn \"*expanded_call_value\"\n   [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(call (mem:QI (match_operand:SI 1 \"general_operand\" \"r,Q>,g\"))\n-\t      (match_operand:SI 2 \"cris_call_type_marker\" \"rM,rM,rM\")))\n+\t      (const_int 0)))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"!TARGET_V32\"\n+  \"\"\n   \"Jsr %1\"\n   [(set_attr \"cc\" \"clobber\")])\n \n-;; See similar call special-case.\n-(define_insn \"*expanded_call_value_side\"\n-  [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(call\n-\t (mem:QI\n-\t  (mem:SI\n-\t   (plus:SI (match_operand:SI 1 \"cris_bdap_operand\" \"%r,  r,r\")\n-\t\t    (match_operand:SI 2 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n-\t (match_operand:SI 3 \"cris_call_type_marker\" \"rM,rM,rM\")))\n-   (clobber (reg:SI CRIS_SRP_REGNUM))\n-   (set (match_operand:SI 4 \"register_operand\" \"=*1,r,r\")\n-\t(plus:SI (match_dup 1)\n-\t\t (match_dup 2)))]\n-  ;; Disabled until after reload until we can avoid an output reload for\n-  ;; operand 4 (being forbidden for call insns).\n-  \"reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32\"\n-  \"Jsr [%4=%1%S2]\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"*expanded_call_value_v32\"\n-  [(set\n-    (match_operand 0 \"nonimmediate_operand\" \"=g,g,g,g\")\n-    (call\n-     (mem:QI\n-      (match_operand:SI 1 \"cris_nonmemory_operand_or_callable_symbol\" \"n,r,U,i\"))\n-     (match_operand:SI 2 \"cris_call_type_marker\" \"rM,rM,rM,rM\")))\n-   (clobber (reg:SI 16))]\n-  \"TARGET_V32\"\n-  \"@\n-   Jsr %1%#\n-   Jsr %1%#\n-   Bsr %1%#\n-   Bsr %1%#\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"slottable\" \"has_call_slot\")])\n-\n ;; Used in debugging.  No use for the direct pattern; unfilled\n ;; delayed-branches are taken care of by other means.\n \n@@ -3844,9 +2915,9 @@\n   \"nop\"\n   [(set_attr \"cc\" \"none\")])\n \n-;; Same as the gdb trap breakpoint, will cause a SIGTRAP for\n-;; cris-linux* and crisv32-linux*, as intended.  Will work in\n-;; freestanding environments with sufficient framework.\n+;; Same as the gdb trap breakpoint: would cause a SIGTRAP for\n+;; cris-linux* and will work in freestanding environments with\n+;; sufficient framework.\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 8))]\n   \"TARGET_TRAP_USING_BREAK8\"\n@@ -3873,7 +2944,7 @@\n ;; this expansion, you must change the macro ASM_OUTPUT_CASE_END\n ;; accordingly, to add the default case at the end of the jump-table.\n \n-(define_expand \"cris_casesi_non_v32\"\n+(define_expand \"casesi\"\n   [(set (match_dup 5) (match_operand:SI 0 \"general_operand\" \"\"))\n    (set (match_dup 6)\n \t(minus:SI (match_dup 5)\n@@ -3899,62 +2970,6 @@\n   operands[6] = gen_reg_rtx (SImode);\n   operands[7] = gen_reg_rtx (SImode);\n })\n-\n-;; FIXME: Check effect of not JUMP_TABLES_IN_TEXT_SECTION.\n-(define_expand \"cris_casesi_v32\"\n-  [(set (match_dup 5) (match_operand:SI 0 \"general_operand\"))\n-   (set (match_dup 6)\n-       (minus:SI (match_dup 5)\n-\t\t (match_operand:SI 1 \"const_int_operand\")))\n-   (set (match_dup 7)\n-       (umin:SI (match_dup 6)\n-\t\t(match_operand:SI 2 \"const_int_operand\")))\n-   (set (match_dup 8) (match_dup 11))\n-   (set (match_dup 9)\n-       (plus:SI (mult:SI (match_dup 7) (const_int 2))\n-\t\t(match_dup 8)))\n-   (set (match_dup 10)\n-       (plus:SI (sign_extend:SI (mem:HI (match_dup 9)))\n-\t\t(match_dup 9)))\n-   (parallel\n-    [(set (pc)\n-\t (if_then_else\n-\t  (ltu (unspec [(const_int 0)] CRIS_UNSPEC_CASESI) (match_dup 2))\n-\t  (match_dup 10)\n-\t  (label_ref (match_operand 4 \"\" \"\"))))\n-     (use (label_ref (match_dup 3)))])]\n-  \"TARGET_V32\"\n-{\n-  int i;\n-  rtx xlabel = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n-  for (i = 5; i <= 10; i++)\n-    operands[i] = gen_reg_rtx (SImode);\n-  operands[2] = plus_constant (SImode, operands[2], 1);\n-\n-  /* Don't forget to decorate labels too, for PIC.  */\n-  operands[11] = flag_pic\n-    ? gen_rtx_CONST (Pmode,\n-\t\t    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xlabel),\n-\t\t\t\t    CRIS_UNSPEC_PCREL))\n-    : xlabel;\n-})\n-\n-(define_expand \"casesi\"\n-  [(match_operand:SI 0 \"general_operand\")\n-   (match_operand:SI 1 \"const_int_operand\")\n-   (match_operand:SI 2 \"const_int_operand\")\n-   (match_operand 3 \"\" \"\")\n-   (match_operand 4 \"\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_V32)\n-    emit_insn (gen_cris_casesi_v32 (operands[0], operands[1], operands[2],\n-\t\t\t\t    operands[3], operands[4]));\n-  else\n-    emit_insn (gen_cris_casesi_non_v32 (operands[0], operands[1], operands[2],\n-\t\t\t\t\toperands[3], operands[4]));\n-  DONE;\n-})\n \f\n ;; Split-patterns.  Some of them have modes unspecified.  This\n ;; should always be ok; if for no other reason sparc.md has it as\n@@ -3975,8 +2990,6 @@\n ;;  op [rx],rz\n ;; Lose if rz=ry or rx=rz.\n ;; Call this op-extend-split.\n-;; Do not match for V32; the addo and addi shouldn't be split\n-;; up.\n \n (define_split\n   [(set (match_operand 0 \"cris_nonsp_register_operand\" \"\")\n@@ -3986,8 +2999,7 @@\n \t  (match_operator\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0])\n+  \"REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -4016,8 +3028,7 @@\n \t  (match_operator\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0])\n+  \"REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -4044,8 +3055,7 @@\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0])\n+  \"REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -4070,8 +3080,7 @@\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0])\n+  \"REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -4099,8 +3108,7 @@\n \t 3 \"cris_orthogonal_operator\"\n \t [(match_operand 1 \"register_operand\" \"\")\n \t  (match_operand 2 \"memory_operand\" \"\")]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0])\n+  \"REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -4123,8 +3131,7 @@\n \t 3 \"cris_commutative_orth_op\"\n \t [(match_operand 2 \"memory_operand\" \"\")\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0])\n+  \"REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -4147,8 +3154,7 @@\n \t 3 \"cris_commutative_orth_op\"\n \t [(match_operand 1 \"register_operand\" \"\")\n \t  (match_operand 2 \"memory_operand\" \"\")]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0]) && REG_P (operands[1])\n+  \"REG_P (operands[0]) && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && REG_P (XEXP (operands[2], 0))\n@@ -4170,8 +3176,7 @@\n \t 3 \"cris_orthogonal_operator\"\n \t [(match_operand 2 \"memory_operand\" \"\")\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"!TARGET_V32\n-   && REG_P (operands[0]) && REG_P (operands[1])\n+  \"REG_P (operands[0]) && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && REG_P (XEXP (operands[2], 0))\n@@ -4848,7 +3853,7 @@\n   /* Make sure we have canonical RTX so we match the insn pattern -\n      not a constant in the first operand.  We also require the order\n      (plus reg mem) to match the final pattern.  */\n-  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))\n+  if (CONSTANT_P (otherop) || MEM_P (otherop))\n     {\n       operands[7] = operands[1];\n       operands[8] = otherop;\n@@ -4899,7 +3904,7 @@\n   /* Make sure we have canonical RTX so we match the insn pattern -\n      not a constant in the first operand.  We also require the order\n      (plus reg mem) to match the final pattern.  */\n-  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))\n+  if (CONSTANT_P (otherop) || MEM_P (otherop))\n     {\n       operands[7] = operands[1];\n       operands[8] = otherop;\n@@ -5044,127 +4049,6 @@\n   operands[3] = gen_rtx_ZERO_EXTEND (SImode, op1);\n   operands[4] = GEN_INT (trunc_int_for_mode (INTVAL (operands[1]), QImode));\n })\n-\n-;; Try and avoid GOTPLT reads escaping a call: transform them into\n-;; PLT.  Curiously (but thankfully), peepholes for instructions\n-;; *without side-effects* that just feed a call (or call_value) are\n-;; not matched neither in a build or test-suite, so those patterns are\n-;; omitted.\n-\n-;; A \"normal\" move where we don't check the consumer.\n-\n-(define_peephole2 ; gotplt-to-plt\n-  [(set\n-    (match_operand:SI 0 \"register_operand\" \"\")\n-    (match_operator:SI\n-     1 \"cris_mem_op\"\n-     [(plus:SI\n-       (reg:SI CRIS_GOT_REGNUM)\n-       (const:SI\n-\t(unspec:SI [(match_operand:SI 2 \"cris_general_operand_or_symbol\" \"\")]\n-\t\t   CRIS_UNSPEC_PLTGOTREAD)))]))]\n-  \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n-   && REGNO_REG_CLASS (REGNO (operands[0])) == REGNO_REG_CLASS (0)\"\n-  [(set (match_dup 0) (const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT_GOTREL)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI CRIS_GOT_REGNUM)))]\n-  \"\")\n-\n-;; And one set with a side-effect getting the PLTGOT offset.\n-;; First call and call_value variants.\n-\n-(define_peephole2 ; gotplt-to-plt-side-call\n-  [(parallel\n-    [(set\n-      (match_operand:SI 0 \"register_operand\" \"\")\n-      (match_operator:SI\n-       1 \"cris_mem_op\"\n-       [(plus:SI\n-\t (reg:SI CRIS_GOT_REGNUM)\n-\t (const:SI\n-\t  (unspec:SI [(match_operand:SI\n-\t\t       2 \"cris_general_operand_or_symbol\" \"\")]\n-\t\t     CRIS_UNSPEC_PLTGOTREAD)))]))\n-     (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t  (plus:SI (reg:SI CRIS_GOT_REGNUM)\n-\t\t   (const:SI\n-\t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])\n-  (parallel [(call (mem:QI (match_dup 0))\n-\t\t    (match_operand 4 \"\" \"\"))\n-\t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n-  \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n-   && peep2_reg_dead_p (2, operands[0])\"\n-  [(parallel [(call (mem:QI (match_dup 1))\n-\t\t    (match_dup 4))\n-\t      (clobber (reg:SI CRIS_SRP_REGNUM))\n-\t      (set (match_dup 3)\n-\t\t   (plus:SI (reg:SI CRIS_GOT_REGNUM)\n-\t\t\t    (const:SI\n-\t\t\t     (unspec:SI [(match_dup 2)]\n-\t\t\t\t\tCRIS_UNSPEC_PLTGOTREAD))))])]\n-  \"\")\n-\n-(define_peephole2 ; gotplt-to-plt-side-call-value\n-  [(parallel\n-    [(set\n-      (match_operand:SI 0 \"register_operand\" \"\")\n-      (match_operator:SI\n-       1 \"cris_mem_op\"\n-       [(plus:SI\n-\t (reg:SI CRIS_GOT_REGNUM)\n-\t (const:SI\n-\t  (unspec:SI [(match_operand:SI\n-\t\t       2 \"cris_general_operand_or_symbol\" \"\")]\n-\t\t     CRIS_UNSPEC_PLTGOTREAD)))]))\n-     (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t  (plus:SI (reg:SI CRIS_GOT_REGNUM)\n-\t\t   (const:SI\n-\t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])\n-   (parallel [(set (match_operand 5 \"\" \"\")\n-\t\t   (call (mem:QI (match_dup 0))\n-\t\t\t (match_operand 4 \"\" \"\")))\n-\t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n-  \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n-   && peep2_reg_dead_p (2, operands[0])\"\n-  [(parallel [(set (match_dup 5)\n-\t\t   (call (mem:QI (match_dup 1))\n-\t\t\t (match_dup 4)))\n-\t      (clobber (reg:SI CRIS_SRP_REGNUM))\n-\t      (set (match_dup 3)\n-\t\t   (plus:SI (reg:SI CRIS_GOT_REGNUM)\n-\t\t\t    (const:SI\n-\t\t\t     (unspec:SI [(match_dup 2)]\n-\t\t\t\t\tCRIS_UNSPEC_PLTGOTREAD))))])]\n-  \"\")\n-\n-(define_peephole2 ; gotplt-to-plt-side\n-  [(parallel\n-    [(set\n-      (match_operand:SI 0 \"register_operand\" \"\")\n-      (match_operator:SI\n-       1 \"cris_mem_op\"\n-       [(plus:SI\n-\t (reg:SI CRIS_GOT_REGNUM)\n-\t (const:SI\n-\t  (unspec:SI [(match_operand:SI\n-\t\t       2 \"cris_general_operand_or_symbol\" \"\")]\n-\t\t     CRIS_UNSPEC_PLTGOTREAD)))]))\n-     (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t  (plus:SI (reg:SI CRIS_GOT_REGNUM)\n-\t\t   (const:SI\n-\t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])]\n-  \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n-   && REGNO_REG_CLASS (REGNO (operands[0])) == REGNO_REG_CLASS (0)\"\n-  [(set (match_dup 3)\n-\t(const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD)))\n-   (set (match_dup 3) (plus:SI (match_dup 3) (reg:SI CRIS_GOT_REGNUM)))\n-   (set (match_dup 0)\n-\t(const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT_GOTREL)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI CRIS_GOT_REGNUM)))]\n-  \"\")\n \f\n ;; Local variables:\n ;; mode:emacs-lisp"}, {"sha": "e574a0a4dbcd7065f5663239641c7872f5e740b6", "filename": "gcc/config/cris/cris.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fcris.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.opt?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -196,7 +196,3 @@ Mask(SVINTO)\n ; TARGET_ALIGN_BY_32: Say that all alignment specifications say\n ; to prefer 32 rather than 16 bits.\n Mask(ALIGN_BY_32)\n-\n-; TARGET_AVOID_GOTPLT is referred to in the .c and the .md so we\n-; need to allocate the flag and macros here.\n-Mask(AVOID_GOTPLT)"}, {"sha": "1fa22cda466a52fe473066ea064a8ab5b220685b", "filename": "gcc/config/cris/predicates.md", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fpredicates.md?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -61,9 +61,7 @@\n ;; Operand helper predicates.\n \n (define_predicate \"cris_bdap_const_operand\"\n-  (and (match_code \"label_ref, symbol_ref, const_int, const_double, const\")\n-       (ior (not (match_test \"flag_pic\"))\n-\t    (match_test \"cris_valid_pic_const (op, true)\"))))\n+  (match_operand 0 \"immediate_operand\"))\n \n (define_predicate \"cris_simple_address_operand\"\n   (ior (match_operand:SI 0 \"register_operand\")\n@@ -132,59 +130,3 @@\n (define_predicate \"cris_bdap_biap_operand\"\n   (ior (match_operand 0 \"cris_bdap_operand\")\n        (match_operand 0 \"cris_biap_mult_operand\")))\n-\n-;; Since with -fPIC, not all symbols are valid PIC symbols or indeed\n-;; general_operands, we have to have a predicate that matches it for the\n-;; \"movsi\" expander.\n-;; FIXME: Can s/special_// when PR 20413 is fixed.\n-\n-(define_special_predicate \"cris_general_operand_or_symbol\"\n-  (ior (match_operand 0 \"general_operand\")\n-       (and (match_code \"const, symbol_ref, label_ref\")\n-       \t    ; The following test is actually just an assertion.\n-\t    (match_test \"cris_symbol_type_of (op) != cris_no_symbol\"))))\n-\n-;; A predicate for the anon movsi expansion, one that fits a PCREL\n-;; operand as well as general_operand.\n-\n-(define_special_predicate \"cris_general_operand_or_pic_source\"\n-  (ior (match_operand 0 \"general_operand\")\n-       (and (match_test \"flag_pic\")\n-\t    (match_test \"cris_valid_pic_const (op, false)\"))))\n-\n-;; Since a PLT symbol is not a general_operand, we have to have a\n-;; predicate that matches it when we need it.  We use this in the expanded\n-;; \"call\" and \"call_value\" anonymous patterns.\n-\n-(define_predicate \"cris_nonmemory_operand_or_callable_symbol\"\n-  (ior (match_operand 0 \"nonmemory_operand\")\n-       (and (match_code \"const\")\n-\t    (and\n-\t     (match_test \"GET_CODE (XEXP (op, 0)) == UNSPEC\")\n-\t     (ior\n-\t      (match_test \"XINT (XEXP (op, 0), 1) == CRIS_UNSPEC_PLT_PCREL\")\n-\t      (match_test \"XINT (XEXP (op, 0), 1) == CRIS_UNSPEC_PCREL\"))))))\n-\n-;; This matches a (MEM (general_operand)) or\n-;; (MEM (cris_general_operand_or_symbol)).  The second one isn't a valid\n-;; memory_operand, so we need this predicate to recognize call\n-;; destinations before we change them to a PLT operand (by wrapping in\n-;; UNSPEC CRIS_UNSPEC_PLT).\n-\n-(define_predicate \"cris_mem_call_operand\"\n-  (and (match_code \"mem\")\n-       (ior (match_operand 0 \"memory_operand\")\n-\t    (match_test \"cris_general_operand_or_symbol (XEXP (op, 0),\n-\t\t\t\t\t\t\t Pmode)\"))))\n-\n-;; A marker for the call-insn: (const_int 0) for a call to a\n-;; hidden or static function and non-pic and\n-;; pic_offset_table_rtx for a call that *might* go through the\n-;; PLT.\n-\n-(define_predicate \"cris_call_type_marker\"\n-  (ior (and (match_operand 0 \"const_int_operand\")\n-\t    (match_test \"op == const0_rtx\"))\n-       (and (and (match_operand 0 \"register_operand\")\n-\t\t (match_test \"op == pic_offset_table_rtx\"))\n-\t    (match_test \"flag_pic != 0\"))))"}, {"sha": "d5bb11ddbcfce90ddcd6cc3d265df552e6597b81", "filename": "gcc/config/cris/sync.md", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0780379c1b621813fbea60449bc51b65f6f8c6e/gcc%2Fconfig%2Fcris%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fsync.md?ref=d0780379c1b621813fbea60449bc51b65f6f8c6e", "patch": "@@ -22,17 +22,12 @@\n ;;\n ;; - Plain old CRIS v0 (..v8)\n ;; - CRIS v10 (as used in ETRAX 100 LX)\n-;; - CRIS v32 (as used in ETRAX FS)\n ;;\n-;; The last two alternatives are similar, of LL/SC type.  They may\n+;; The second alternative is of LL/SC type.  It may\n ;; fail for other reasons; an exception, a cache miss or a bus request\n-;; from other parts of the system.  The difference between them is\n-;; just in what condition-codes are used to track LL and success or\n-;; failure for the store.  See the chapter on integral read-write\n+;; from other parts of the system.  See the chapter on integral read-write\n ;; operations, chapter 1.13 in \"ETRAX 100LX Programmers Manual\",\n-;; <http://www.axis.com/files/tech_notes/etrax_100lx_prog_man-050519.pdf>\n-;; and chapter 2.1 in \"ETRAX FS Designer's reference\",\n-;; <http://www.axis.com/files/manuals/etrax_fs_des_ref-070821.pdf>.\n+;; <http://www.axis.com/files/tech_notes/etrax_100lx_prog_man-050519.pdf>.\n ;; Note that the datum being stored has to be contained fully within a\n ;; cache-line to be integral.  A failure to store the data integrally\n ;; will be flagged, but the store may still have happened in part,\n@@ -134,18 +129,7 @@\n   /* Can't be too sure; better ICE if this happens.  */\n   gcc_assert (!reg_overlap_mentioned_p (operands[2], operands[1]));\n \n-  if (TARGET_V32)\n-    return\n-      \"clearf p\\n\"\n-      \".Lsync.%=:\\;\"\n-      \"move<m> %1,%0\\;\"\n-      \"move.d %0,%3\\;\"\n-      \"<atomic_op_mnem_pre_op2>,%3\\;<atomic_op_mnem_post_op3>\"\n-      \"ax\\;\"\n-      \"move<m> %3,%1\\;\"\n-      \"bcs .Lsync.%=\\;\"\n-      \"clearf p\";\n-  else if (cris_cpu_version == 10)\n+  if (cris_cpu_version == 10)\n     return\n       \"clearf\\n\"\n       \".Lsync.%=:\\;\"\n@@ -245,20 +229,7 @@\n \t CRIS_UNSPEC_ATOMIC_SWAP_MEM))]\n   \"<MODE>mode == QImode || !TARGET_ATOMICS_MAY_CALL_LIBFUNCS\"\n {\n-  if (TARGET_V32)\n-    return\n-      \"\\n.Lsync.repeat.%=:\\;\"\n-      \"clearf p\\;\"\n-      \"move<m> %2,%1\\;\"\n-      \"cmp<qm3> %3,%1\\;\"\n-      \"bne .Lsync.after.%=\\;\"\n-      \"ax\\;\"\n-\n-      \"move<m> %4,%2\\;\"\n-      \"bcs .Lsync.repeat.%=\\n\"\n-      \".Lsync.after.%=:\\;\"\n-      \"seq %0\";\n-  else if (cris_cpu_version == 10)\n+  if (cris_cpu_version == 10)\n     return\n       \"\\n.Lsync.repeat.%=:\\;\"\n       \"clearf\\;\""}]}